

    return ulRet;
}

VOID
sx(
    CMD_ARGLIST
    )
{
    ULONG lpAddress;
    ULONG Flags;
    BOOL Status;
    CMD_INIT();

    lpAddress = (*GetExpression)("ntvdmd!VdmDbgTraceFlags");

    if (!lpAddress) {
        lpAddress = (*GetExpression)("ntvdm!InitialVdmDbgFlags");
    }

    if (!READMEM((PVOID)lpAddress, &Flags, sizeof(ULONG))) {
        PRINTF("Error reading memory\n");
        return;
    }

    PRINTF("VDM DEBUG OPTIONS:\n\n");
    PRINTF("cd - break on create DOS task        - %s\n", (Flags & VDMDBG_BREAK_DOSTASK)? "enabled" : "disabled");
    PRINTF("cw - break on create WOW task        - %s\n", (Flags & VDMDBG_BREAK_WOWTASK)? "enabled" : "disabled");
    PRINTF("ld - break on load DLL               - %s\n", (Flags & VDMDBG_BREAK_LOADDLL)? "enabled" : "disabled");

    lpAddress = (ULONG) (FIXED_NTVDMSTATE_LINEAR + GetIntelBase());

    Status = READMEM((PVOID)lpAddress, &Flags, sizeof(ULONG));

    if (!Status)  {

        lpAddress = (*GetExpression)("ntvdm!InitialVdmTibFlags");

        Status = READMEM((PVOID)lpAddress, &Flags, sizeof(ULONG));

        if (!Status) {
            GetLastError();
            (*Print)("Could not get InitialTibflags\n");
            return;
        }
    }

    PRINTF("ex - break on FIRST CHANCE exceptions- %s\n", (Flags & VDM_BREAK_EXCEPTIONS)? "enabled" : "disabled");
    PRINTF("db - break on INT1, INT3             - %s\n", (Flags & VDM_BREAK_DEBUGGER)  ? "enabled" : "disabled");
    PRINTF("lg - NTVDM trace history log         - %s\n", (Flags & VDM_TRACE_HISTORY)   ? "enabled" : "disabled");

}

VOID
DoSxCmd(
    BOOL fEnable
    )

{
    ULONG lpAddress;
    ULONG ulTF;
    ULONG ulParm;

    if (!GetNextToken()) {
        PRINTF("Please enter an trace flag (enter 'sx' for list)\n");
        return;
    }

    if (!(ulParm = TraceFlagFromName(lpArgumentString))) {

        if (_strnicmp(lpArgumentString, "db", 2) == 0) {

            DoVdmtibFlag(VDM_BREAK_DEBUGGER, fEnable, "Debugger trapping of debug faults");

        } else if (_strnicmp(lpArgumentString, "ex", 2) == 0) {

            DoVdmtibFlag(VDM_BREAK_EXCEPTIONS, fEnable, "Debugger trapping of exceptions");

        } else if (_strnicmp(lpArgumentString, "lg", 2) == 0) {

            DoVdmtibFlag(VDM_TRACE_HISTORY, fEnable, "NTVDM trace log");

        } else {

            PRINTF("Invalid trace flag\n");
        }

        return;
    }

    lpAddress = (*GetExpression)("ntvdmd!VdmDbgTraceFlags");

    if (!lpAddress) {
        lpAddress = (*GetExpression)("ntvdm!InitialVdmDbgFlags");
    }

    if (!READMEM((PVOID)lpAddress, &ulTF, sizeof(ULONG))) {
        PRINTF("Error reading memory\n");
        return;
    }


    if (fEnable) {
        ulTF |= ulParm;
    } else {
        ulTF &= ~ulParm;
    }

    WRITEMEM((PVOID)lpAddress, &ulTF, sizeof(ULONG));

}

VOID
sxd(
    CMD_ARGLIST
    )
{
    CMD_INIT();

    DoSxCmd(FALSE);
}

VOID
sxe(
    CMD_ARGLIST
    )
{
    CMD_INIT();

    EnableDebuggerBreakpoints();
    DoSxCmd(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\sym.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    heap.c

Abstract:

    This function contains the default ntsd debugger extensions

Author:

    Bob Day      (bobday) 29-Feb-1992 Grabbed standard header

Revision History:

    Neil Sandlin (NeilSa) 15-Jan-1996 Merged with vdmexts

--*/

#include <precomp.h>
#pragma hdrstop

#define MYOF_FLAGS (OF_READ | OF_SHARE_DENY_NONE)

#define MAX_MODULE_LIST 200
char ModuleList[MAX_MODULE_LIST][9];
int ModuleListCount = 0;

BOOL
GetVdmDbgEntry(
    LPSTR szEntryPoint,
    PVOID *pProc
    )
{
    HANDLE hModVDM;
    hModVDM = GetModuleHandle("VDMDBG.DLL");
    if (hModVDM == (HANDLE)NULL) {
        PRINTF("VDMEXTS: Can't find vdmdbg.dll\n");
        return FALSE;
    }

    *pProc = GetProcAddress(hModVDM, szEntryPoint);

    if (!*pProc) {
        PRINTF("VDMEXTS: Can't find VDMDBG.DLL entry point %s\n", szEntryPoint);
        return FALSE;
    }
    return TRUE;
}

PSEGENTRY
GetSegtablePointer(
    VOID
    )
{
    static PSEGENTRY (WINAPI *pfnVDMGetSegtablePointer)(VOID) = NULL;

    if (!pfnVDMGetSegtablePointer && !GetVdmDbgEntry("VDMGetSegtablePointer",
                                      (PVOID)&pfnVDMGetSegtablePointer)) {
        return NULL;
    }

    return((*pfnVDMGetSegtablePointer)());
}


VOID
ParseModuleName(
    LPSTR szName,
    LPSTR szPath
    )
/*++

    Routine Description:

        This routine strips off the 8 character file name from a path

    Arguments:

        szName - pointer to buffer of 8 characters (plus null)
        szPath - full path of file

    Return Value

        None.

--*/

{
    LPSTR lPtr = szPath;
    LPSTR lDest = szName;
    int BufferSize = 9;

    while(*lPtr) lPtr++;     // scan to end

    while( ((DWORD)lPtr > (DWORD)szPath) &&
           ((*lPtr != '\\') && (*lPtr != '/'))) lPtr--;

    if (*lPtr) lPtr++;

    while((*lPtr) && (*lPtr!='.')) {
        if (!--BufferSize) break;
        *lDest++ = *lPtr++;
    }

    *lDest = 0;
}

BOOL
FindModuleNameList(
    LPSTR filename
    )
{
    int i;

    for (i=0; i<ModuleListCount; i++) {

        if (!_stricmp(filename, ModuleList[i])) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
AddModuleNameList(
    LPSTR filename
    )
{
    if (!strlen(filename)) {
        return FALSE;
    }

    if (!FindModuleNameList(filename)) {
        if (ModuleListCount>=(MAX_MODULE_LIST-1)) {
            return FALSE;
        }
        strcpy (ModuleList[ModuleListCount++], filename);
    }
    return TRUE;
}

VOID
FreeModuleNameList(
    VOID
    )
{
    ModuleListCount = 0;
    return;
}

VOID
BuildModuleNameList(
    VOID
    )
{
    HEAPENTRY he = {0};
    SEGENTRY  *se;
    char      filename[9];
    WORD sel;
    BOOL    b;
    NEHEADER owner;
    ULONG base;
    CHAR ModuleName[9];
    UCHAR len;

    //
    // Search WOW Module list
    //

    if (!ReadMemExpression("ntvdmd!DbgWowhExeHead", &sel, sizeof(sel))) {
        return;
    }

    while(sel) {

        base = GetInfoFromSelector(sel, PROT_MODE, NULL) + GetIntelBase();

        b = READMEM((LPVOID)base, &owner, sizeof(owner));

        if (!b || (owner.ne_magic != 0x454e)) {
            PRINTF("Invalid module list! (started with hExeHead)\n");
            return;
        }

        len = ReadByteSafe(base+owner.ne_restab);
        if (len>8) {
            len=8;
        }
        READMEM((LPVOID)(base+owner.ne_restab+1), ModuleName, 8);

        ModuleName[len] = 0;
        AddModuleNameList(ModuleName);

        // This is mapped to ne_pnextexe in kernel
        sel = owner.ne_cbenttab;
    }

    //
    // Search debugger segment array
    //

    se = GetSegtablePointer();
    while ( se ) {
        ParseModuleName(filename, se->szExePath);
        AddModuleNameList(filename);

        se = se->Next;
    }
}


BOOL
GetOwnerSegmentFromSelector(
    WORD        selector,
    int         mode,
    LPSTR       szModule,
    WORD       *psegment
    )
/*++

    Routine Description:

        This routine returns the "segment number" and owner name
        of the given selector or v86mode segment. The returned number
        represents the position of the segment in the binary, and is 1-based.

    Arguments:

        selector - either PMODE selector or V86 mode segment
        mode     - PROT_MODE or V86_MODE
        filename - pointer to buffer to receive module name
        psegment - pointer to WORD to receive segment number

    Return Value

        TRUE if found

--*/

{
    HEAPENTRY   he = {0};
    SEGENTRY  *se;

    he.Selector = selector;
    if (FindHeapEntry(&he, FHE_FIND_SEL_ONLY, FHE_FIND_QUIET)) {
        strcpy(szModule, he.FileName);
        *psegment = he.SegmentNumber+1;
        return TRUE;
    }

    se = GetSegtablePointer();
    while ( se ) {
        if (se->selector == selector) {
            ParseModuleName(szModule, se->szExePath);
            *psegment = se->segment;
            return TRUE;
        }
        se = se->Next;
    }

    return FALSE;
}

BOOL
GetSelectorFromOwnerSegment(
    LPSTR       szModule,
    WORD        segment,
    WORD       *pselector,
    int        *pmode
    )
{
    HEAPENTRY   he = {0};
    char tempModule[9];
    SEGENTRY  *se;

    while (FindHeapEntry(&he, FHE_FIND_SEL_ONLY, FHE_FIND_QUIET)) {

        if (!_stricmp(szModule, he.FileName) &&
             (segment == he.SegmentNumber+1)) {

            *pselector = he.gnode.pga_handle|1;
            *pmode = PROT_MODE;
            return TRUE;
        }
    }

    se = GetSegtablePointer();
    while ( se ) {

        ParseModuleName(tempModule, se->szExePath);

        if (!_stricmp(szModule, tempModule) &&
            (segment == se->segment+1)) {

            *pselector = se->selector;
            if (se->type == SEGTYPE_V86) {
                *pmode = V86_MODE;
            } else {
                *pmode = PROT_MODE;
            }
            return TRUE;

        }
        se = se->Next;
    }
    return FALSE;
}


BOOL
FindSymbol(
    WORD        selector,
    LONG        offset,
    LPSTR       sym_text,
    LONG        *dist,
    int         direction,
    int         mode
    )
{
    char filename[9];
    WORD segment;
    static VDMGETSYMBOLPROC pfnGetSymbol = NULL;

    if (!pfnGetSymbol && !GetVdmDbgEntry("VDMGetSymbol", (PVOID)&pfnGetSymbol)) {
        return FALSE;
    }


    if (GetOwnerSegmentFromSelector(selector, mode, filename, &segment)) {
        return(pfnGetSymbol(filename,
                             segment,
                             offset,
                             (mode == PROT_MODE),
                             (direction == AFTER),
                             sym_text,
                             dist));
    }
    return FALSE;
}


BOOL
FindAddress(
    LPSTR       sym_text,
    LPSTR       filename,
    WORD        *psegment,
    WORD        *pselector,
    LONG        *poffset,
    int         *pmode,
    BOOL        bDumpAll
    )
{
    int i;
    BOOL bResult;
    static VDMGETADDREXPRESSIONPROC pfnGetAddrExpression = NULL;
    WORD type;
    char module[9];

    if (!pfnGetAddrExpression && !GetVdmDbgEntry("VDMGetAddrExpression",
                                 (PVOID)&pfnGetAddrExpression)) {
        return FALSE;
    }

    BuildModuleNameList();
    for (i=0; i<ModuleListCount; i++) {
        bResult = pfnGetAddrExpression(ModuleList[i],
                                 sym_text,
                                 pselector,
                                 poffset,
                                 &type);
        if (bResult) {
            strcpy(filename, ModuleList[i]);

            if (type == VDMADDR_V86) {
                *pmode = V86_MODE;
            } else {
                *pmode = PROT_MODE;
            }

            if (!GetOwnerSegmentFromSelector(*pselector, *pmode,
                                             module, psegment)) {
                *pmode = NOT_LOADED;
            }
            return TRUE;
        }
    }
    return FALSE;
}

VOID
ln(
    CMD_ARGLIST
) {
    VDMCONTEXT              ThreadContext;
    WORD                    selector;
    LONG                    offset;
    CHAR                    sym_text[1000];
    DWORD                   dist;
    BOOL                    b;
    int                     mode;

    CMD_INIT();

    mode = GetContext( &ThreadContext );

    if (!GetNextToken()) {
        selector = (WORD) ThreadContext.SegCs;
        offset   = ThreadContext.Eip;
    } else if (!ParseIntelAddress(&mode, &selector, &offset)) {
        return;
    }


    if ( mode == PROT_MODE ) {
        PRINTF( "#%04X:%04lX", selector, offset );
    }
    if ( mode == V86_MODE ) {
        PRINTF( "&%04X:%04lX", selector, offset );
    }


    b = FindSymbol( selector, offset, sym_text, &dist, BEFORE, mode );
    if ( !b ) {
        PRINTF(" = Could not find symbol before");
    } else {
        if ( dist == 0 ) {
            PRINTF(" = %s", sym_text );
        } else {
            PRINTF(" = %s+0x%lx", sym_text, dist );
        }
    }
    b = FindSymbol( selector, offset, sym_text, &dist, AFTER, mode );
    if ( !b ) {
        PRINTF(" | Could not find symbol after");
    } else {
        if ( dist == 0 ) {
            PRINTF(" | %s", sym_text );
        } else {
            PRINTF(" | %s-0x%lx", sym_text, dist );
        }
    }
    PRINTF("\n");
}

VOID
x(
    CMD_ARGLIST
) {
    VDMCONTEXT              ThreadContext;
    BOOL                    result;
    WORD                    selector;
    WORD                    segment;
    LONG                    offset;
    int                     mode;
    char                    filename[9];

    CMD_INIT();

    try {

        mode = GetContext( &ThreadContext );

        result = FindAddress( lpArgumentString,
                              filename,
                              &segment,
                              &selector,
                              &offset,
                              &mode,
                              TRUE);

        if ( result ) {
            if ( mode == PROT_MODE ) {
                PRINTF("#");
            } else if ( mode == V86_MODE ) {
                PRINTF("&");
            } else if ( mode == NOT_LOADED ) {
                selector = 0;
                PRINTF("?");
            }

            PRINTF("%04X:%04X = %s(%04X)!%s\n",
                    selector, offset, filename, segment, lpArgumentString );
            return;
        }

        PRINTF("Could not find symbol '%s'\n", lpArgumentString );

    } except (1) {

        PRINTF("Exception 0x%08x in vdmexts!\n", GetExceptionCode());

    }
}

/****************************************************************************
 ****************************************************************************

   extension debugging routines

   The following functions were added to help debug the debugger extension.
   They are not intended to be used in normal operation.

 ****************************************************************************
 ****************************************************************************/

VOID
DumpModuleNameList(
    VOID
    )
{
    int i;

    for (i=0; i<ModuleListCount; i++) {
        PRINTF("%d %s\n", i, ModuleList[i]);
    }
}


VOID
moddump(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    BuildModuleNameList();
    DumpModuleNameList();
}

VOID
segdef(
    CMD_ARGLIST
    )
{
    int       cnt;
    int       UpdateCnt;
    SEGENTRY  *se;
    WORD        selector;
    WORD        segment;
    DWORD     length;
    int         type;


    CMD_INIT();

    se = GetSegtablePointer();

    if (!GetNextToken()) {
        PRINTF("Missing index\n");
        return;
    }
    UpdateCnt = (int) EvaluateToken();


    if (!GetNextToken()) {
        PRINTF("Missing selector\n");
        return;
    }
    selector = (WORD) EvaluateToken();


    if (!GetNextToken()) {
        PRINTF("Missing segment\n");
        return;
    }
    segment = (WORD) EvaluateToken();


    if (!GetNextToken()) {
        PRINTF("Missing limit\n");
        return;
    }
    length = EvaluateToken();


    if (!GetNextToken()) {
        PRINTF("Missing type\n");
        return;
    }
    type = (int) EvaluateToken();


    if (!GetNextToken()) {
        PRINTF("Missing path\n");
        return;
    }

    cnt = 0;
    while ( se ) {
        if (cnt == UpdateCnt) {
            se->selector = selector;
            se->segment = segment;
            se->length = length;
            se->type = type;
            strcpy(se->szExePath, lpArgumentString);
            break;
        }
        cnt++;
        se = se->Next;
    }

}

VOID
segdump(
    CMD_ARGLIST
    )
{
    int       cnt;
    int       DumpCnt;
    SEGENTRY  *se;

    CMD_INIT();

    PRINTF("Index Sel  Seg   Length  Type  Module   Path\n");
    se = GetSegtablePointer();

    if (GetNextToken()) {
        DumpCnt = (int) EvaluateToken();

        cnt = 0;
        while ( se ) {
            if (DumpCnt == cnt) {
                PRINTF("%03x   %04x %04x %08x %s %s %s\n", cnt,
                    se->selector, se->segment, se->length,
                    ((se->type==SEGTYPE_V86) ? "v86 " : "prot"),
                    se->szModule, se->szExePath);
                break;
            }
            cnt++;
            se = se->Next;
        }
        return;
    }


    cnt = 0;
    while ( se ) {
        PRINTF("%03x   %04x %04x %08x %s %s %s\n", cnt,
                se->selector, se->segment, se->length,
                ((se->type==SEGTYPE_V86) ? "v86 " : "prot"),
                se->szModule, se->szExePath);
        cnt++;
        se = se->Next;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\system.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    system.c

Abstract:

    This file contains code to dump out the virtual machine state.

Author:

    Neil Sandlin (neilsa) 22-Nov-1995

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop
#include "insignia.h"
#include "host_gen.h"
#define BIT_ORDER1 1
#include "dma.h"

VOID
dma(
    CMD_ARGLIST
    )
/*++

Routine Description:

    This routine dumps the virtual DMA state.

Return Value

    None.

--*/
{
    DMA_ADAPT adapter;
    DMA_CNTRL *dcp;
    int i,j;
    int chan = 0;

    CMD_INIT();

    if (!ReadMemExpression("ntvdm!adaptor", &adapter, sizeof(DMA_ADAPT))) {
        return;
    }

    PRINTF(" Virtual DMA State\n");
    PRINTF("       base base  cur  cur\n");
    PRINTF("chn pg addr cnt   addr cnt\n");
    PRINTF("--- -- ---- ----  ---- ----\n");

    for (i=0; i<DMA_ADAPTOR_CONTROLLERS; i++) {

        dcp = &adapter.controller[i];

        for (j=0; j<DMA_CONTROLLER_CHANNELS; j++) {

            PRINTF("%d   %.02X %.04X %.04X  %.04X %.04X", chan, adapter.pages.page[chan],
                        *(USHORT *)dcp->base_address[j], *(USHORT *)dcp->base_count[j],
                        *(USHORT *)dcp->current_address[j], *(USHORT *)dcp->current_count[j]);
            PRINTF("\n");

            chan++;
        }
    }

    PRINTF("\n");
}


VOID
ica(
    CMD_ARGLIST
    )
/*++

Routine Description:

    This routine dumps the virtual PIC state.

Return Value

    None.

--*/
{
    VDMVIRTUALICA VirtualIca[2];
    int i,j;

    CMD_INIT();

    if (!ReadMemExpression("ntvdm!VirtualIca", VirtualIca, 2*sizeof(VDMVIRTUALICA))) {
        return;
    }

    PRINTF(" Virtual PIC State\n");
    PRINTF("              ");
    for (i=0; i<2; i++) {
        for(j=0; j<8; j++) {
            PRINTF("%01X", (VirtualIca[i].ica_base+j)/16);
        }
    }
    PRINTF("\n");

    PRINTF("              ");
    for (i=0; i<2; i++) {
        for(j=0; j<8; j++) {
            PRINTF("%01X", (VirtualIca[i].ica_base+j)&0xf);
        }
    }
    PRINTF("\n");
    PRINTF("              ----------------\n");

    PRINTF("Int Requests  ");
    for (i=0; i<2; i++) {
        for(j=0; j<8; j++) {
            PRINTF("%01X", (VirtualIca[i].ica_irr >> j)&0x1);
        }
    }
    PRINTF("\n");

    PRINTF("In Service    ");
    for (i=0; i<2; i++) {
        for(j=0; j<8; j++) {
            PRINTF("%01X", (VirtualIca[i].ica_isr >> j)&0x1);
        }
    }
    PRINTF("\n");

    PRINTF("Ints Masked   ");
    for (i=0; i<2; i++) {
        for(j=0; j<8; j++) {
            PRINTF("%01X", (VirtualIca[i].ica_imr >> j)&0x1);
        }
    }
    PRINTF("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\trace.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    trace.c

Abstract:

    This file contains code to dump the ntvdm trace history log

Author:

    Neil Sandlin (neilsa) 1-Nov-1995

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop
#include <dbgsvc.h>
#include <dpmi.h>

ULONG TimeIndex;
ULONG TimerMode = 0;
ULONG CpuSpeed = 0;
BOOL bTriedToGetCpuSpeed = FALSE;
#define CPUSPEED_PATH "Hardware\\Description\\System\\CentralProcessor\\0"
#define CPUSPEED_VALUE "~MHz"

VOID
DumpTypeGeneric(
    VDM_TRACEENTRY te
    )
{
    PRINTF("%.4x: %.4X %.8X", te.Type, te.wData, te.lData);
}


VOID
DumpTypeKernel(
    VDM_TRACEENTRY te
    )
{

    switch(te.Type&0xff) {
    case VDMTR_KERNEL_HW_INT:
        PRINTF("Hw Int       %.2x ", te.wData);
        break;

    case VDMTR_KERNEL_OP_PM:
    case VDMTR_KERNEL_OP_V86:
        PRINTF("OpEm   ");

        switch(te.wData&0xff) {

        case 0xec:
            PRINTF("INB");
            break;

        case 0xee:
            PRINTF("OUTB");
            break;

        case 0xfa:
            PRINTF("CLI");
            break;

        case 0xfb:
            PRINTF("STI");
            break;

        default:
            PRINTF("  %.2x ", te.wData);
        }
        break;


    default:
        PRINTF("Unknown : %d", te.Type&0xff);
        return;
    }
}


VOID
DumpTypeDpmi(
    VDM_TRACEENTRY te
    )
{
    //
    // Dpmi dispatch table entries
    //
    static char szDispatchEntries[MAX_DPMI_BOP_FUNC][40] = {
                                 "InitDosxRM",
                                 "InitDosx",
                                 "InitLDT",
                                 "GetFastBopAddress",
                                 "InitIDT",
                                 "InitExceptionHandlers",
                                 "InitApp",
                                 "TerminateApp",
                                 "InUse",
                                 "NoLongerInUse",
                                 "switch_to_protected_mode",
                                 "switch_to_real_mode",
                                 "SetAltRegs",
                                 "IntHandlerIret16",
                                 "IntHandlerIret32",
                                 "FaultHandlerIret16",
                                 "FaultHandlerIret32",
                                 "UnhandledExceptionHandler",
                                 "RMCallBackCall",
                                 "ReflectIntrToPM",
                                 "ReflectIntrToV86",
                                 "InitPmStackInfo",
                                 "VcdPmSvcCall32",
                                 "SetDescriptorEntry",
                                 "ResetLDTUserBase",
                                 "XlatInt21Call",
                                 "Int31"
                                 };


    switch(te.Type&0xff) {
    case DPMI_DISPATCH_INT:
        PRINTF("Dispatch Int %.2x ", te.wData);
        break;
    case DPMI_HW_INT:
        PRINTF("Hw Int       %.2x ", te.wData);
        break;
    case DPMI_SW_INT:
        PRINTF("Sw Int       %.2x ", te.wData);
        break;

    case DPMI_FAULT:
        PRINTF("Fault        %.2x ec=%.8x", te.wData, te.lData);
        break;
    case DPMI_DISPATCH_FAULT:
        PRINTF("Dispatch Flt %.2x ", te.wData);
        break;

    case DPMI_FAULT_IRET:
        PRINTF("Fault Iret");
        break;
    case DPMI_INT_IRET16:
        PRINTF("Int Iret16");
        break;
    case DPMI_INT_IRET32:
        PRINTF("Int Iret32");
        break;

    case DPMI_OP_EMULATION:
        PRINTF("Op Emulation");
        break;

    case DPMI_DISPATCH_ENTRY:
        PRINTF("Dispatch(%d): ", te.wData);
        if (te.lData >= MAX_DPMI_BOP_FUNC) {
            PRINTF("Unknown (%d)", te.lData);
        } else {
            PRINTF("%s", szDispatchEntries[te.lData]);
        }
        break;

    case DPMI_DISPATCH_EXIT:
        PRINTF("Exit(%d):     ", te.wData);
        if (te.lData >= MAX_DPMI_BOP_FUNC) {
            PRINTF("Unknown (%d)", te.lData);
        } else {
            PRINTF("%s", szDispatchEntries[te.lData]);
        }
        break;

    case DPMI_SWITCH_STACKS:
        PRINTF("switch stack -> %.4x:%.8x", te.wData, te.lData);
        break;

    case DPMI_GENERIC:
        PRINTF("Data: %.4x %.8x", te.wData, te.lData);
        break;

    case DPMI_IN_V86:
        PRINTF("in V86 mode");
        break;

    case DPMI_IN_PM:
        PRINTF("in protect mode");
        break;

    case DPMI_REFLECT_TO_PM:
        PRINTF("Reflect to PM");
        break;

    case DPMI_REFLECT_TO_V86:
        PRINTF("Reflect to V86");
        break;

    default:
        PRINTF("Unknown : %d", te.Type&0xff);
        return;
    }
}

VOID
DumpTypeMonitor(
    VDM_TRACEENTRY te
    )
{
    static char szMonitorEntries[][20] = {
                                 "Event IO",
                                 "Event String IO",
                                 "Event Mem Access",
                                 "Event Int Ack",
                                 "Event BOP",
                                 "Event Error",
                                 "Event Irq 13",
                                 "Cpu Simulate",
                                 "Cpu Unsimulate",
                                 };

    if ((te.Type&0xff) <= MONITOR_CPU_UNSIMULATE) {
        PRINTF("%s", szMonitorEntries[(te.Type&0xff)-1]);
        PRINTF(": %.4X %.8X", te.wData, te.lData);
    } else {
        DumpTypeGeneric(te);
    }
}

VOID
DumpTimeInfo(
    VDM_TRACEENTRY te
    )
{

    ULONG USecs = 0;

    switch(TimerMode) {

    case VDMTI_TIMER_TICK:
        PRINTF("%d.%.3d", TimeIndex/1000, TimeIndex%1000);
        PRINTF(" %.8X  ", te.Time);
        break;

    case VDMTI_TIMER_PENTIUM:

        if (CpuSpeed) {
            USecs = TimeIndex / CpuSpeed;
        }
        PRINTF("%5d.%.3d", USecs/1000, USecs%1000);
        PRINTF(" %.8X  ", te.Time);
        break;
    }


}


VOID
DumpTraceEntry(
    int index,
    VDM_TRACEENTRY te,
    ULONG Verbosity
    )

{

    PRINTF("%4x ",index);
    DumpTimeInfo(te);

    switch(te.Type & 0xff00) {
    case (VDMTR_TYPE_KERNEL):
        PRINTF("Krnl ");
        DumpTypeKernel(te);
        break;

    case (VDMTR_TYPE_DPMI):
        PRINTF("Dpmi ");
        DumpTypeDpmi(te);
        break;

    case (VDMTR_TYPE_DPMI_SF):
        PRINTF("Dpmi Set Fault Handler %.02X -> %.4X:%.8X", te.Type & 0xff, te.wData, te.lData);
        break;

    case (VDMTR_TYPE_DPMI_SI):
        PRINTF("Dpmi Set Int Handler %.02X -> %.4X:%.8X", te.Type & 0xff, te.wData, te.lData);
        break;

    case (VDMTR_TYPE_DEM):
        PRINTF("Dem  ");
        switch(te.Type & 0xff) {
        case 1:
            PRINTF("Dispatch: %.4X %.8X", te.wData, te.lData);
            break;
        case 2:
            PRINTF("Exit:     %.4X %.8X", te.wData, te.lData);
            break;
        default:
            DumpTypeGeneric(te);
        }
        break;

    case (VDMTR_TYPE_WOW):
        PRINTF("Wow  ");
        DumpTypeGeneric(te);
        break;

    case (VDMTR_TYPE_VSBD):
        PRINTF("Vsbd ");
        DumpTypeGeneric(te);
        break;

    case (VDMTR_TYPE_DBG):
        PRINTF("Dbg  ");
        DumpTypeGeneric(te);
        break;

    case (VDMTR_TYPE_MONITOR):
        PRINTF("Mon  ");
        DumpTypeMonitor(te);
        break;

    default:
        PRINTF("     ");
        DumpTypeGeneric(te);
    }

    if (Verbosity) {
        PRINTF("\n");

        PRINTF("eax=%08lx ebx=%08lx ecx=%08lx edx=%08lx esi=%08lx edi=%08lx\n",
            te.eax, te.ebx, te.ecx, te.edx, te.esi, te.edi );

        PRINTF("eip=%08lx esp=%08lx ebp=%08lx                ",
            te.eip, te.esp, te.ebp );

        if ( te.eflags & FLAG_OVERFLOW ) {
            PRINTF("ov ");
        } else {
            PRINTF("nv ");
        }
        if ( te.eflags & FLAG_DIRECTION ) {
            PRINTF("dn ");
        } else {
            PRINTF("up ");
        }
        if ( te.eflags & FLAG_INTERRUPT ) {
            PRINTF("ei ");
        } else {
            PRINTF("di ");
        }
        if ( te.eflags & FLAG_SIGN ) {
            PRINTF("ng ");
        } else {
            PRINTF("pl ");
        }
        if ( te.eflags & FLAG_ZERO ) {
            PRINTF("zr ");
        } else {
            PRINTF("nz ");
        }
        if ( te.eflags & FLAG_AUXILLIARY ) {
            PRINTF("ac ");
        } else {
            PRINTF("na ");
        }
        if ( te.eflags & FLAG_PARITY ) {
            PRINTF("po ");
        } else {
            PRINTF("pe ");
        }
        if ( te.eflags & FLAG_CARRY ) {
            PRINTF("cy ");
        } else {
            PRINTF("nc ");
        }
        PRINTF("\n");
        PRINTF("cs=%04x  ss=%04x  ds=%04x  es=%04x  fs=%04x  gs=%04x             efl=%08lx\n",
                te.cs, te.ss, te.ds, te.es, te.fs, te.gs, te.eflags );

    }

    TimeIndex += te.Time;
    PRINTF("\n");
}


VOID
DumpTrace(
    IN ULONG Verbosity
    )
/*++

Routine Description:

    This routine dumps the DPMI trace history buffer.

Arguments:

Return Value

    None.

--*/
{
    PVOID pMem;
    ULONG TraceBase, TraceEnd, TraceCurrent;
    ULONG Lines;
    VDM_TRACEINFO TraceInfo;
    VDM_TRACEENTRY TraceEntry;
    ULONG Count = 0;
    ULONG EntryID;
    ULONG NumEntries;

    if (!ReadMemExpression("ntvdm!pVdmTraceInfo", &pMem, 4)) {
        return;
    }

    if (!READMEM(pMem, &TraceInfo, sizeof(VDM_TRACEINFO))) {
        PRINTF("Error reading memory for TraceInfo\n");
        return;
    }

    if (!TraceInfo.pTraceTable) {
        PRINTF("NTVDM trace history not available\n");
        return;
    }

    if (!CpuSpeed && !bTriedToGetCpuSpeed) {
        HKEY hKey;
        DWORD retCode;
        DWORD dwType, cbData = sizeof(ULONG);
        ULONG dwData;
       
        retCode = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                CPUSPEED_PATH,
                                0,
                                KEY_EXECUTE, // Requesting read access.
                                &hKey);
       
       
        if (!retCode) {
       
            retCode = RegQueryValueEx(hKey,
                                      CPUSPEED_VALUE,
                                      NULL,
                                      &dwType,
                                      (LPSTR)&dwData,
                                      &cbData);
           
            RegCloseKey(hKey);
           
            if (!retCode) {
                CpuSpeed = dwData;
            }
        }
        bTriedToGetCpuSpeed = TRUE;
        if (!CpuSpeed) {
            PRINTF("Error retrieving CPU speed\n");
        }
    }


    TimeIndex = 0;

    NumEntries   = TraceInfo.NumPages*4096/sizeof(VDM_TRACEENTRY);
    TraceBase    = (ULONG) TraceInfo.pTraceTable;
    TraceEnd     = (ULONG) &TraceInfo.pTraceTable[NumEntries];
    TraceCurrent = (ULONG) &TraceInfo.pTraceTable[TraceInfo.CurrentEntry];


    if ((TraceBase & 0xfff) || (TraceEnd & 0xfff) ||
        (TraceCurrent & 0x3f) ||
        (TraceBase > TraceEnd) ||
        (TraceCurrent > TraceEnd) || (TraceCurrent < TraceBase)) {
        PRINTF("TraceBuffer=%.8X, end=%.8X, current=%.8X\n",
                TraceBase, TraceEnd, TraceCurrent);
        PRINTF("Trace buffer info appears corrupt!\n");
        return;
    }

    if (Verbosity) {
        Lines = 8;
    } else {
        Lines = 32;
    }

    EntryID = 1;

    if (GetNextToken()) {
        if (*lpArgumentString == '#') {
            lpArgumentString++;
            EntryID = EvaluateToken();

            if (EntryID > NumEntries) {
                PRINTF("Requested trace entry out of range - %X\n", EntryID);
                return;
            }

        }

        if (GetNextToken()) {

            Lines = (int)EXPRESSION(lpArgumentString);
            if (Lines > NumEntries) {
                PRINTF("Requested count too large - %d\n", Lines);
                return;
            }
        }
    }


    TraceCurrent = (ULONG) &TraceInfo.pTraceTable[(TraceInfo.CurrentEntry-(EntryID-1))%NumEntries];
    TimerMode = (UCHAR) TraceInfo.Flags & VDMTI_TIMER_MODE;

    switch(TimerMode) {

    case VDMTI_TIMER_TICK:
        PRINTF("deltaT is in MSec, Time is in Seconds\n");
        PRINTF("\n#    Time  DeltaT    Event\n");
        break;
    case VDMTI_TIMER_PENTIUM:
        PRINTF("deltaT is at %d MHz, Time is in MSec\n", CpuSpeed);
        PRINTF("\nlog#     Time  DeltaT    Event\n");
        break;
    default:
        PRINTF("\n#    Event\n");
    }


    while (Lines--) {

        TraceCurrent -= sizeof(VDM_TRACEENTRY);
        if (TraceCurrent < TraceBase) {
            TraceCurrent = TraceEnd - sizeof(VDM_TRACEENTRY);
        }

        if (!READMEM((PVOID)TraceCurrent, &TraceEntry, sizeof(VDM_TRACEENTRY))) {
            PRINTF("Error reading memory at %.08X\n", pMem);
            return;
        }

        if (!TraceEntry.Type) {
            if (!Count) {
                if (EntryID == 1) {
                    PRINTF("<Log is empty>\n");
                } else {
                    PRINTF("<End of log>\n");
                }
            } else {
                PRINTF("<End of log>\n");
            }
            break;
        }

        //PRINTF("%.8x  ", TraceCurrent);

        DumpTraceEntry(EntryID++, TraceEntry, Verbosity);
        ++Count;

        if (EntryID >= NumEntries) {
            PRINTF("<End of log>\n");
            break;
        }

    }


}


VOID
lgr(
    CMD_ARGLIST
    )
{
    CMD_INIT();

    DumpTrace(1);
}

VOID
lg(
    CMD_ARGLIST
    )
{
    CMD_INIT();

    DumpTrace(0);
}



VOID
lgt(
    CMD_ARGLIST
    )
{
    PVOID pMem;
    VDM_TRACEINFO TraceInfo;
    UCHAR DbgTimerMode;
    BOOL DbgTimerInitialized;
    ULONG NewTimerMode;

    CMD_INIT();

    if (!ReadMemExpression("ntvdmd!DbgTimerMode", &DbgTimerMode, sizeof(UCHAR))) {
        return;
    }

    if (!ReadMemExpression("ntvdmd!DbgTimerInitialized", &DbgTimerInitialized, sizeof(BOOL))) {
        return;
    }

    if (GetNextToken()) {

        NewTimerMode = EvaluateToken();

        switch(NewTimerMode) {
        case 0:
            PRINTF("Event log timer is now OFF\n");
            break;

        case VDMTI_TIMER_TICK:
            PRINTF("Event log timer resolution set to ~10msec (GetTickCount)\n");
            break;

        case VDMTI_TIMER_PERFCTR:
            PRINTF("Event log timer resolution set to 100nsec (QueryPerformanceCounter)\n");
            break;

        case VDMTI_TIMER_PENTIUM:
            PRINTF("Event log timer resolution set to pentium time stamp counter\n");
            break;

        default:
            PRINTF("Invalid selection - enter 0-3\n");
            return;
        }

        pMem = (PVOID)(*GetExpression)("ntvdmd!DbgTimerMode");
        if (!pMem) {
            PRINTF("Could not find symbol ntvdmd!DbgTimerMode\n");
            return;
        }

        if (!WRITEMEM((PVOID)pMem, &NewTimerMode, sizeof(UCHAR))) {
            PRINTF("Error writing memory\n");
            return;
        }

        pMem = (PVOID)(*GetExpression)("ntvdmd!DbgTimerInitialized");

        if (!pMem) {
            PRINTF("Could not find symbol ntvdmd!DbgTimerInitialized\n");
            return;
        }

        DbgTimerInitialized = FALSE;
        if (!WRITEMEM((PVOID)pMem, &DbgTimerInitialized, sizeof(UCHAR))) {
            PRINTF("Error writing memory\n");
            return;
        }

    } else {


        if (!ReadMemExpression("ntvdm!pVdmTraceInfo", &pMem, sizeof(LPVOID))) {
            return;
        }

        if (!READMEM(pMem, &TraceInfo, sizeof(VDM_TRACEINFO))) {
            PRINTF("Error reading memory for TraceInfo\n");
            return;
        }

        PRINTF("Timer has%sbeen initialized\n", DbgTimerInitialized ? " " : " not ");
        PRINTF("Requested timer resolution == %d\n", DbgTimerMode);
        PRINTF("Current timer resolution == %d\n", TraceInfo.Flags & VDMTI_TIMER_MODE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\wow.c ===
/******************************Module*Header*******************************\
* Module Name: wow.c
*
* This file is for debugging tools and extensions.
*
* Created: 24-Jan-1992
* Author: John Colleran
*
* History:
* Feb 17 92 Matt Felton (mattfe) lots of additional exentions for filtering
* Jul 13 92 (v-cjones) Added API & MSG profiling debugger extensions, fixed
*                      other extensions to handle segment motion correctly,
*                      & cleaned up the file in general
* Jan 3 96 Neil Sandlin (neilsa) integrated this routine into vdmexts
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <tdb16.h>
#include <wmdisp32.h>
#include <wcuricon.h>
#include <wucomm.h>
#include <doswow.h>
#include "..\wow32\wdde.h"


//
// get the compatibility flag values & string names
//
typedef struct _tagWOWCFDATA {
    LPSZ  lpszCFName;
    DWORD dwVal;
} WOWCFDATA;



// allows us to grab the string tables only from mvdm\inc\wowcmpat.h
#define _VDMEXTS_CFLAGS 1

// exposes the compatibility flag strings & values in wowcmpat.h
#define _VDMEXTS_CF 1
WOWCFDATA CFData[] = {
#include "wowcmpat.h"
         {"", 0x00000000}
};
#undef _VDMEXTS_CF

// exposes the EXTENDED compatibility flag strings & values in wowcmpat.h
#define _VDMEXTS_CFEX 1
WOWCFDATA CFDataEx[] = {
#include "wowcmpat.h"
         {"", 0x00000000}
};
#undef _VDMEXTS_CFEX

// exposes the OLD Win3.x compatibility flag strings & values in wowcmpat.h
#define _VDMEXTS_CF31 1
WOWCFDATA CFData31[] = {
#include "wowcmpat.h"
         {"", 0x00000000}
};
#undef _VDMEXTS_CF31

// exposes the IME compatibility flag strings & values in wowcmpat.h
#if FE_SB
#define _VDMEXTS_CF_IME 1
WOWCFDATA CFDataIME[] = {
#include "wowcmpat.h"
         {"", 0x00000000}
};
#endif // FE_SB
#undef _VDMEXTS_CF_IME

#undef _VDMEXTS_CFLAGS





#define MALLOC(cb) HeapAlloc(GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS, cb)
#define FREE(addr) HeapFree(GetProcessHeap(), 0, addr)


//
// Local function prototypes
//

INT  WDahtoi(LPSZ lpsz);


INT WDParseArgStr(LPSZ lpszArgStr, CHAR **argv, INT iMax) {
/*
 * Parse a string looking for SPACE, TAB, & COMMA as delimiters
 *  INPUT:
 *   lpszArgStr - ptr to input arg string
 *   iMax       - maximum number of substrings to parse
 *  OUTPUT:
 *   argv       - ptrs to strings
 *
 *  RETURN: # of vectors in argv
 *  NOTE: substrings are converted to uppercase
 */
    INT   nArgs;
    BOOL  bStrStart;

    nArgs = 0;
    bStrStart = 1;
    while( *lpszArgStr ) {
        if( (*lpszArgStr == ' ') || (*lpszArgStr == '\t') || (*lpszArgStr == ',') ) {
            *lpszArgStr = '\0';
            bStrStart = 1;
        }
        else {
            if( bStrStart ) {
                if( nArgs >= iMax ) {
                    break;
                }
                argv[nArgs++] = lpszArgStr;
                bStrStart = 0;
            }
            *lpszArgStr = (CHAR)toupper(*lpszArgStr);
        }
        lpszArgStr++;
    }
    return(nArgs);
}




VOID
dwp(
    CMD_ARGLIST
    )
{
    PWOWPORT pwp;
    WOWPORT wp;

    CMD_INIT();
    ASSERT_WOW_PRESENT;


    while (' ' == lpArgumentString[0]) {
        lpArgumentString++;
    }

    pwp = (PWOWPORT) WDahtoi(lpArgumentString);

    if (NULL == pwp) {
        PRINTF("Can't read WOWPORT structure!\n\n");
        return;
    }

    PRINTF("Dump of WOWPORT structure at 0x%x:\n\n", (unsigned)pwp);
    
    
    try {

        READMEM_XRET(wp, pwp);

    } except (EXCEPTION_ACCESS_VIOLATION == GetExceptionCode()
              ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {

        PRINTF("Access violation reading WOWPORT structure!\n\n");
        return;
    }

    PRINTF("idComDev       0x%x\n", (unsigned)wp.idComDev);
    PRINTF("h32            0x%x\n", (unsigned)wp.h32);
    PRINTF("hREvent        0x%x\n", (unsigned)wp.hREvent);
    PRINTF("csWrite        OwningThread 0x%x RecursionCount 0x%x\n",
           (unsigned)wp.csWrite.OwningThread, (unsigned)wp.csWrite.RecursionCount);
    PRINTF("pchWriteHead   0x%x\n", (unsigned)wp.pchWriteHead);
    PRINTF("pchWriteTail   0x%x\n", (unsigned)wp.pchWriteTail);
    PRINTF("cbWriteFree    0x%x\n", (unsigned)wp.cbWriteFree);
    PRINTF("cbWritePending 0x%x\n", (unsigned)wp.cbWriteFree);
    PRINTF("pchWriteBuf    0x%x\n", (unsigned)wp.pchWriteBuf);
    PRINTF("cbWriteBuf     0x%x\n", (unsigned)wp.cbWriteBuf);
    PRINTF("hWriteThread   0x%x\n", (unsigned)wp.hWriteThread);
    PRINTF("hWriteEvent    0x%x\n", (unsigned)wp.hWriteEvent);
    PRINTF("OverLap hEvent 0x%x\n", (unsigned)wp.olWrite.hEvent);
    PRINTF("fWriteDone     %s\n", wp.fWriteDone ? "TRUE" : "FALSE");
    PRINTF("cbWritten      0x%x\n", (unsigned)wp.fWriteDone);
    PRINTF("dwThreadID     0x%x\n", (unsigned)wp.dwThreadID);
    PRINTF("dwErrCode      0x%x\n", (unsigned)wp.dwErrCode);
    PRINTF("COMSTAT addr:  0x%x\n", (unsigned)(((char *)&wp.cs - (char *)&wp) + (char *)pwp));
    PRINTF("fChEvt         0x%x\n", (unsigned)wp.fChEvt);
    PRINTF("pdcb16         0x%x\n", (unsigned)wp.pdcb16);
    PRINTF("fUnGet         %s\n", wp.fUnGet ? "TRUE" : "FALSE");
    PRINTF("cUnGet         0x%x (%c)\n", (unsigned)wp.cUnGet, wp.cUnGet);
    PRINTF("hMiThread      0x%x\n", (unsigned)wp.hMiThread);
    PRINTF("fClose         %s\n", wp.fClose ? "TRUE" : "FALSE");
    PRINTF("dwComDEB16     0x%x\n", (unsigned)wp.dwComDEB16);
    PRINTF("lpComDEB16     0x%x\n", (unsigned)wp.lpComDEB16);
    PRINTF("cbInQ          0x%x\n", (unsigned)wp.cbInQ);
    PRINTF("RLSDTimeout    0x%x\n", (unsigned)wp.RLSDTimeout);
    PRINTF("CTSTimeout     0x%x\n", (unsigned)wp.CTSTimeout);
    PRINTF("DSRTimeout     0x%x\n", (unsigned)wp.DSRTimeout);

    PRINTF("\n");

    return;
}


//
//  Dump Taskinfo;
//
//  If no argument, dump all wow tasks.
//  If 0, dump current WOW task
//  Else dump the specifies task {which is thread-id as shown by
//  ~ command under ntsd like 37.6b so thread-id is 6b)
//

void DumpTaskInfo (ptd,mode)
PTD  ptd;
int    mode;
{

    ULONG                   Base;
    TDB                     tdb;
    BOOL                    b;
    char ModName[9];
    int i;
    BOOL                    fTDBValid = TRUE;

    Base = GetInfoFromSelector( ptd->htask16, PROT_MODE, NULL );
    b = READMEM( (LPVOID) (Base+GetIntelBase()), &tdb, sizeof(tdb));

    if ( !b ) {
        fTDBValid = FALSE;
    }

    for (b=FALSE, i=0; i<8; i++) {
        if (!fTDBValid || !tdb.TDB_ModName[i]) {
            b = TRUE;
        }
        if (b) {
            ModName[i] = ' ';
        } else {
            ModName[i] = tdb.TDB_ModName[i];
        }
    }
    ModName[i] = 0;

    PRINTF("%.4x",ptd->dwThreadID);
    PRINTF(" %.4x:%.4x",HIWORD(ptd->vpStack),LOWORD(ptd->vpStack));
    PRINTF(" %.4x", ptd->htask16);
    PRINTF(" %.4x", ptd->hInst16);
    PRINTF(" %.4x", ptd->hMod16);
    PRINTF(" %8s",ModName);
    PRINTF(" %.8x",ptd->dwWOWCompatFlags);
    PRINTF(" %.8x",ptd->hThread);
    if (fTDBValid) {
        PRINTF(" %.8x",tdb.TDB_flags);
        PRINTF(" %.3x",tdb.TDB_ExpWinVer);
        PRINTF(" %.4x:%.4x\n",HIWORD(tdb.TDB_DTA),LOWORD(tdb.TDB_DTA));
    } else {
        PRINTF(" Failure reading TDB at %X\n", Base );
    }
}


void
DumpTask(
    void
    )
{
    VDMCONTEXT              ThreadContext;
    DWORD                   ThreadId;
    PTD                     ptd,ptdHead;
    TD                      td;
    int                     mode;
    BOOL                    b,fFound=FALSE;


    mode = GetContext( &ThreadContext );

    ThreadId = (DWORD)-1;  // Assume Dump All Tasks
    if (GetNextToken()) {
        ThreadId = (DWORD) EXPRESSION( lpArgumentString );
    }

    ptdHead = (PTD)EXPRESSION("wow32!gptdTaskHead");

    // get the pointer to first TD
    b = READMEM((LPVOID) (ptdHead), &ptd, sizeof(DWORD));

    if ( !b ) {
        PRINTF("Failure reading gptdTaskHead at %08lX\n", ptdHead );
        return;
    }

    PRINTF("Thrd   Stack   task inst hmod  Module  Compat   hThread  Tdbflags Ver    Dta\n");


    // enumerate td list to find the match(es)
    while (ptd) {
        b = READMEM((LPVOID) (ptd), &td, sizeof(TD));
        if ( !b ) {
            PRINTF("Failure reading TD At %08lX\n", ptd );
            return;
        }

        if (ThreadId == -1) {
            DumpTaskInfo (&td,mode);
            fFound = TRUE;
        }
        else {
            if (ThreadId == td.dwThreadID) {
                DumpTaskInfo (&td,mode);
                fFound = TRUE;
                break;
            }
        }
        ptd = td.ptdNext;
    }

    if (!fFound) {
        if (ThreadId == -1) {
            PRINTF("No WOW Task Found.\n");
        }
        else
            PRINTF("WOW Task With Thread Id = %02x Not Found.\n",ThreadId);
    }
    return;
}



VOID DumpTaskVerbose( )  // dump WOW32 task database entry
{

    TD        td;
    PTD       ptd;
    INT       iCount;
    PWOAINST  pWOA, pWOALast;
    PTDB      ptdb;
    BOOL      fAll = FALSE;
    BYTE      SavedByte;

    ptd = (PTD) WDahtoi(lpArgumentString);


    if (!ptd) {

        fAll = TRUE;
        GETEXPRVALUE(ptd, "wow32!gptdTaskHead", PTD);
        if (!ptd) {
            Print("Could not get wow32!gptdTaskHead");
            return;
        }
        Print("Dump WOW task list\n\n");

    } else if ((ULONG)ptd < 65536) {
        ULONG dwId = (ULONG) ptd;

        // Here, I'm making the assumption that if the argument is a value
        // that is less than 64k, then it can't be a TD address.
        // So, try it out as a thread id

        GETEXPRVALUE(ptd, "wow32!gptdTaskHead", PTD);
        if (!ptd) {
            Print("Could not get wow32!gptdTaskHead");
            return;
        }

        while(ptd) {
            READMEM_XRET(td, ptd);
            if (td.dwThreadID == dwId) {
                break;
            }

            ptd = td.ptdNext;
        }
        if (!ptd) {
            Print("Could not find thread id %s\n", lpArgumentString);
            return;
        }
    }

    do {

        Print("Dump of TD at 0x%08x:\n\n", (unsigned)ptd);


        READMEM_XRET(td, ptd);

        Print("vpStack             %04x:%04x\n", HIWORD(td.vpStack), LOWORD(td.vpStack));
        Print("vpCBStack           %04x:%04x\n", HIWORD(td.vpCBStack), LOWORD(td.vpCBStack));
        Print("cStackAlloc16       0x%08x\n", td.cStackAlloc16);
        Print("CommDlgTd (ptr)     0x%08x\n", td.CommDlgTd);
        Print("ptdNext             0x%08x\n", td.ptdNext);
        Print("dwFlags             0x%08x\n", td.dwFlags);

        //
        // Dump symbolic names for TDF_ manifests
        //

        if (td.dwFlags & TDF_IGNOREINPUT) {
            Print("                        TDF_IGNOREINPUT\n");
        }
        if (td.dwFlags & TDF_FORCETASKEXIT) {
            Print("                        TDF_FORCETASKEXIT\n");
        }
        if (td.dwFlags & TDF_TASKCLEANUPDONE) {
            Print("                        TDF_TASKCLEANUPDONE\n");
        }
        Print("VDMInfoiTaskID      0x%08x\n", td.VDMInfoiTaskID);

        //
        // Dump CommDlgTd structure if present
        //

        if (td.CommDlgTd) {

            COMMDLGTD CommDlgTd;
            BOOL fCopySuccessful = TRUE;

            READMEM_XRET(CommDlgTd, td.CommDlgTd);

            if (fCopySuccessful) {

                Print("\n");
                Print("    Dump of CommDlgTd at 0x%08x:\n", td.CommDlgTd);
                Print("    hdlg                  0x%04x\n", CommDlgTd.hdlg);
                Print("    vpData                %04x:%04x\n", HIWORD(CommDlgTd.vpData), LOWORD(CommDlgTd.vpData));
                Print("    pData32               0x%08x\n", CommDlgTd.pData32);
                Print("    vpfnHook              %04x:%04x\n", HIWORD(CommDlgTd.vpfnHook), LOWORD(CommDlgTd.vpfnHook));
                Print("    vpfnSetupHook (union) %04x:%04x\n", HIWORD(CommDlgTd.vpfnSetupHook), LOWORD(CommDlgTd.vpfnSetupHook));
                Print("    pRes          (union) 0x%08x\n", CommDlgTd.pRes);
                Print("    SetupHwnd             0x%04x\n", CommDlgTd.SetupHwnd);
                Print("    Previous              0x%08x\n", CommDlgTd.Previous);
                Print("    Flags                 0x%08x\n", CommDlgTd.Flags);

                //
                // Dump symbolic names for WOWCD_ manifests
                //

                if (CommDlgTd.Flags & WOWCD_ISCHOOSEFONT) {
                    Print("                          WOWCD_ISCHOOSEFONT\n");
                }
                if (CommDlgTd.Flags & WOWCD_ISOPENFILE) {
                    Print("                          WOWCD_ISOPENFILE\n");
                }

                Print("\n");

            }
        }


        Print("dwWOWCompatFlags    0x%08x\n", td.dwWOWCompatFlags);

        //
        // Dump symbolic names for WOWCF_ manifests
        //
        if (td.dwWOWCompatFlags) {
            iCount = 0;
            while(CFData[iCount].dwVal) {

                if (td.dwWOWCompatFlags & CFData[iCount].dwVal) {
                    Print("                        %s\n", CFData[iCount].lpszCFName);
                }

                iCount++;
            }
        }


        Print("dwWOWCompatFlagsEx  0x%08x\n", td.dwWOWCompatFlagsEx);

        //
        // Dump symbolic names for WOWCFEX_ manifests
        //
        if (td.dwWOWCompatFlagsEx) {
            iCount = 0;
            while(CFDataEx[iCount].dwVal) {

                if (td.dwWOWCompatFlagsEx & CFDataEx[iCount].dwVal) {
                    Print("                        %s\n", CFDataEx[iCount].lpszCFName);
                }

                iCount++;
            }
        }

#if FE_SB
        Print("dwWOWCompatFlags2   0x%08x\n", td.dwWOWCompatFlags2);

        //
        // Dump symbolic names for WOWCFEX_ manifests
        //

        if (td.dwWOWCompatFlags2) {
            iCount = 0;
            while(CFDataIME[iCount].dwVal) {

                if (td.dwWOWCompatFlags2 & CFDataIME[iCount].dwVal) {
                    Print("                        %s\n", CFDataIME[iCount].lpszCFName);
                }

                iCount++;
            }
        }
#endif

        Print("dwThreadID          0x%08x\n", td.dwThreadID);
        Print("hThread             0x%08x\n", td.hThread);
        Print("hIdleHook           0x%08x\n", td.hIdleHook);
        Print("hrgnClip            0x%08x\n", td.hrgnClip);
        Print("ulLastDesktophDC    0x%08x\n", td.ulLastDesktophDC);
        Print("pWOAList            0x%08x\n", td.pWOAList);

        //
        // Dump WOATD structure if present
        //

        pWOALast = NULL;
        pWOA = td.pWOAList;

        while (pWOA && pWOA != pWOALast) {

            union {
               WOAINST WOA;
               char    buf[128+2+16];
            } u;

            READMEM_XRET(u.buf, pWOA);

            Print("\n");
            Print("    Dump of WOAINST at 0x%08x:\n", pWOA);
            Print("    pNext                 0x%08x\n", u.WOA.pNext);
            Print("    ptdWOA                0x%08x\n", u.WOA.ptdWOA);
            Print("    dwChildProcessID      0x%08x\n", u.WOA.dwChildProcessID);
            Print("    hChildProcess         0x%08x\n", u.WOA.hChildProcess);
            Print("    szModuleName          %s\n",     u.WOA.szModuleName);
            Print("\n");

            pWOALast = pWOA;
            pWOA = u.WOA.pNext;

        }

        Print("htask16             0x%04x\n", td.htask16, td.htask16);

        //
        // Dump the most interesting TDB fields
        //

        if (ptdb = (PTDB) (GetInfoFromSelector(td.htask16, PROT_MODE, NULL) + GetIntelBase())) {

            TDB tdb;

            READMEM_XRET(tdb, ptdb);

            Print("\n");
            Print("    Highlights of TDB at 0x%08x:\n", ptdb);

            if (tdb.TDB_sig != TDB_SIGNATURE) {
                Print("    TDB_sig signature is 0x%04x instead of 0x%04x, halting dump.\n",
                      tdb.TDB_sig, TDB_SIGNATURE);
            } else {

                PDOSPDB pPDB;
                DOSPDB  PDB;
                PBYTE   pJFT;
                BYTE    JFT[256];
                WORD    cbJFT;
                PDOSSF  pSFTHead, pSFTHeadCopy;
                DOSSF   SFTHead;
                PDOSSFT pSFT;
                WORD    fh;
                WORD    SFN;
                WORD    wCount;
                DWORD   cb;
                DWORD   dwCompatFlags;
                PDOSWOWDATA pDosWowData;
                DOSWOWDATA  DosWowData;

                SavedByte = tdb.TDB_ModName[8];
                tdb.TDB_ModName[8] = 0;
                Print("    Module name           \"%s\"\n", tdb.TDB_ModName);
                tdb.TDB_ModName[8] = SavedByte;

                Print("    ExpWinVer             0x%04x\n", tdb.TDB_ExpWinVer);

                dwCompatFlags = *(DWORD *)(&tdb.TDB_CompatFlags);
                Print("    CompatFlags           0x%08x\n", dwCompatFlags);

                if (dwCompatFlags) {
                    //
                    // Dump symbolic names for GACF_ manifests
                    //

                    wCount = 0;
                    while(CFData31[wCount].dwVal) {

                        if (dwCompatFlags & CFData31[wCount].dwVal) {
                            Print("                            %s\n", CFData31[wCount].lpszCFName);
                        }

                        wCount++;
                    }
                }

                Print("    Directory             \"%s\"\n", tdb.TDB_LFNDirectory);
                Print("    PDB (aka PSP)         0x%04x\n", tdb.TDB_PDB);

                pPDB  = (PDOSPDB) (GetInfoFromSelector(tdb.TDB_PDB, PROT_MODE, NULL) + GetIntelBase());
                READMEM_XRET(PDB, pPDB);

                Print("    segEnvironment        0x%04x\n", PDB.PDB_environ);

                //
                // Dump open file handle info
                //

                pJFT  = (PBYTE)   (GetIntelBase() +
                                   (HIWORD(PDB.PDB_JFN_Pointer)<<4) +
                                   LOWORD(PDB.PDB_JFN_Pointer));


                cbJFT = PDB.PDB_JFN_Length;

                Print("    JFT                   %04x:%04x (%08x), size 0x%x\n",
                                                 HIWORD(PDB.PDB_JFN_Pointer),
                                                 LOWORD(PDB.PDB_JFN_Pointer),
                                                 pJFT,
                                                 cbJFT);

                try {
                    READMEM(pJFT, JFT, cbJFT);
                } except (1) {
                    Print("Unable to read JFT from 0x%08x!\n", pJFT);
                    return;
                }

                for (fh = 0; fh < cbJFT; fh++) {

                    if (JFT[fh] != 0xFF) {

                        //
                        // Walk the SFT chain to find Nth entry
                        // where N == JFT[fh]
                        //

                        SFN = 0;
                        wCount = 0;
                        GETEXPRVALUE(pSFTHead, "ntvdm!pSFTHead", PDOSSF);

                        GETEXPRADDR(pDosWowData, "wow32!DosWowData");
                        READMEM_XRET(DosWowData, pDosWowData);

                        if ((DWORD)pSFTHead != DosWowData.lpSftAddr) {
                           Print("ntvdm!pSFTHead is 0x%08x, DosWowData.lpSftAddr ix 0x%08x.\n",
                                   pSFTHead, DosWowData.lpSftAddr);
                        }

                        try {
                            READMEM(pSFTHead, &SFTHead, sizeof(SFTHead));
                        } except (1) {
                            Print("Unable to read SFTHead from 0x%08x!\n", pSFTHead);
                            return;
                        }

                        cb = sizeof(DOSSF) + SFTHead.SFCount * sizeof(DOSSFT);
                        pSFTHeadCopy = MALLOC(cb);

                        // Print("First DOSSF at 0x%08x, SFCount 0x%x, SFLink 0x%08x.\n",
                        //      pSFTHead, SFTHead.SFCount, SFTHead.SFLink);

                        try {
                            READMEM(pSFTHead, pSFTHeadCopy, cb);
                        } except (1) {
                            Print("Unable to read SFTHead from 0x%08x!\n", pSFTHead);
                            return;
                        }

                        pSFT = (PDOSSFT) &(pSFTHeadCopy->SFTable);

                        while (SFN < JFT[fh]) {
                            SFN++;
                            wCount++;
                            pSFT++;
                            if (wCount >= pSFTHeadCopy->SFCount) {

                                if (LOWORD(pSFTHeadCopy->SFLink) == 0xFFFF) {
                                    SFN = JFT[fh] - 1;
                                    break;
                                }

                                pSFTHead = (PDOSSF) (GetIntelBase() +
                                                    (HIWORD(pSFTHeadCopy->SFLink)<<4) +
                                                     LOWORD(pSFTHeadCopy->SFLink));

                                wCount = 0;

                                try {
                                    READMEM(pSFTHead, &SFTHead, sizeof(SFTHead));
                                } except (1) {
                                    Print("Unable to read SFTHead from 0x%08x!\n", pSFTHead);
                                    return;
                                }

                                cb = sizeof(DOSSF) + SFTHead.SFCount * sizeof(DOSSFT);
                                FREE(pSFTHeadCopy);
                                pSFTHeadCopy = MALLOC(cb);

                                // Print("Next DOSSF at 0x%08x, SFCount 0x%x, SFLink 0x%08x.\n",
                                //      pSFTHead, SFTHead.SFCount, SFTHead.SFLink);

                                try {
                                    READMEM(pSFTHead, pSFTHeadCopy, cb);
                                } except (1) {
                                    Print("Unable to read SFTHead from 0x%08x!\n", pSFTHead);
                                    return;
                                }

                                pSFT = (PDOSSFT) &(pSFTHeadCopy->SFTable);
                            }
                        }

                        if (SFN != JFT[fh]) {
                            Print("    Unable to local SFT entry 0x%x for handle 0x%x.\n",
                                  pJFT[fh], fh);
                        } else {
                            Print("    Handle 0x%02x SFN 0x%02x Refs 0x%x Mode 0x%04x Flags 0x%04x ",
                                  fh, SFN, pSFT->SFT_Ref_Count, pSFT->SFT_Mode,
                                  pSFT->SFT_Flags);
                            if (!(pSFT->SFT_Flags & 0x80)) {
                                Print("NT Handle 0x%08x\n", pSFT->SFT_NTHandle);
                            } else {
                                Print("(NTDOS device)\n");
                            }
                        }

                        FREE(pSFTHeadCopy);
                    }
                }

                Print("\n");
            }

        }

        Print("hInst16             0x%04x\n", td.hInst16);
        Print("hMod16              0x%04x\n", td.hMod16);

        Print("\n");

        ptd = td.ptdNext;

    } while (fAll && ptd);

    return;
}


void
dt(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    ASSERT_WOW_PRESENT;

    if (!GetNextToken()) {
        DumpTask();
    } else {
        if ((lpArgumentString[0] == '-') &&
            (tolower(lpArgumentString[1]) == 'v')) {
            SkipToNextWhiteSpace();
            GetNextToken();
            DumpTaskVerbose();
        } else {
            DumpTaskVerbose();
        }
    }

}



VOID
ddte(
    CMD_ARGLIST
    )
// dump dispatch table entry
{
    W32   dte;
    PW32  pdte;
    char  szW32[32];
    char  szMySymbol[256];
    DWORD dwOffset;

    CMD_INIT();
    ASSERT_WOW_PRESENT;

    while (' ' == lpArgumentString[0]) {
        lpArgumentString++;
    }

    pdte = (PW32) WDahtoi(lpArgumentString);


    if (pdte) {

        PRINTF("Dump of dispatch table entry at 0x%08x:\n\n", (unsigned)pdte);

    } else {

        GETEXPRADDR(pdte, "wow32!aw32WOW");
        PRINTF("Dump of first dispatch table entry at 0x%08x:\n\n", (unsigned)pdte);

    }

    try {

        READMEM_XRET(dte, pdte);

        if (dte.lpszW32) {
            READMEM_XRET(szW32, dte.lpszW32);
            dte.lpszW32 = szW32;
            szW32[sizeof(szW32)-1] = '\0';
        }

    } except (1) {

        PRINTF("Exception 0x%08x reading dispatch table entry at 0x%08x!\n\n",
              GetExceptionCode(), pdte);
        return;
    }

    PRINTF("Dispatches to address 0x%08x, ", (unsigned)dte.lpfnW32);
    PRINTF("supposedly function '%s'.\n", dte.lpszW32);

    szMySymbol[0] = '\0';
    GetSymbol((LPVOID)dte.lpfnW32, szMySymbol, &dwOffset);

    PRINTF("Debugger finds symbol '%s' for that address.\n", szMySymbol);
    PRINTF("\n");

    return;
}



PSTR aszWOWCLASS[] =
{
    "UNKNOWN",
    "WIN16",
    "BUTTON",
    "COMBOBOX",
    "EDIT",
    "LISTBOX",
    "MDICLIENT",
    "SCROLLBAR",
    "STATIC",
    "DESKTOP",
    "DIALOG",
    "MENU",
    "ACCEL",
    "CURSOR",
    "ICON",
    "DC",
    "FONT",
    "METAFILE",
    "RGN",
    "BITMAP",
    "BRUSH",
    "PALETTE",
    "PEN",
    "OBJECT"
};


INT  WDahtoi(LPSZ lpsz)
{
    char c;
    int  tot, pow, len, dig, i;


    len = strlen(lpsz) - 1;
    tot = 0;
    pow = 1;

    for(i = len; i >= 0; i--) {

        c = (char)toupper(lpsz[i]);

        if(c == '0') dig = 0;
        else if(c == '1') dig = 1;
        else if(c == '2') dig = 2;
        else if(c == '3') dig = 3;
        else if(c == '4') dig = 4;
        else if(c == '5') dig = 5;
        else if(c == '6') dig = 6;
        else if(c == '7') dig = 7;
        else if(c == '8') dig = 8;
        else if(c == '9') dig = 9;
        else if(c == 'A') dig = 10;
        else if(c == 'B') dig = 11;
        else if(c == 'C') dig = 12;
        else if(c == 'D') dig = 13;
        else if(c == 'E') dig = 14;
        else if(c == 'F') dig = 15;
        else return(-1);

        if(pow > 1) {
           tot += pow * dig;
        }
        else {
           tot = dig;
        }
        pow *= 16;
    }
    return(tot);
}




void
at(
    CMD_ARGLIST
    )
{
    UINT  i;
    ATOM  atom;
    CHAR  pszGAtomName[128];
    CHAR  pszLAtomName[128];
    CHAR  pszCAtomName[128];
    CHAR *argv[2], *psz;

    CMD_INIT();
    ASSERT_WOW_PRESENT;

    if(WDParseArgStr(lpArgumentString, argv, 1) == 1) {

        atom = (ATOM)LOWORD(WDahtoi(argv[0]));

        pszGAtomName[0] = 'G';  // put a random value in 1st byte so we can
        pszLAtomName[0] = 'L';  // tell if it got replaced with a '\0' for
        pszCAtomName[0] = 'C';  // an "undetermined" type

        psz = NULL;
        PRINTF("\n%s: ", argv[0]);
        if(GlobalGetAtomName(atom, pszGAtomName, 128) > 0) {
            PRINTF("<Global atom> \"%s\"  ", pszGAtomName);
            psz = pszGAtomName;
        }
        else if(GetAtomName(atom, pszLAtomName, 128) > 0) {
            PRINTF("<Local atom> \"%s\"  ", pszLAtomName);
            psz = pszLAtomName;
        }
        else if(GetClipboardFormatName((UINT)atom, pszCAtomName, 128) > 0) {
            PRINTF("<Clipboard format> \"%s\"  ", pszCAtomName);
            psz = pszCAtomName;
        }
        if(psz) {
            i = 0;
            while(psz[i] && i < 128) {
                PRINTF(" %2X", psz[i++] & 0x000000FF);
            }
        }
        else {
            PRINTF("<Undetermined type>\n");
            PRINTF("      GlobalGetAtomName string: \"%c\" ", pszGAtomName[0]);
            for(i = 0; i < 8; i++) {
                PRINTF(" %2X", pszGAtomName[i] & 0x000000FF);
            }
            PRINTF("\n            GetAtomName string: \"%c\" ", pszLAtomName[0]);
            for(i = 0; i < 8; i++) {
                PRINTF(" %2X", pszLAtomName[i] & 0x000000FF);
            }
            PRINTF("\n GetClipboardFormatName string: \"%c\" ", pszCAtomName[0]);
            for(i = 0; i < 8; i++) {
                PRINTF(" %2X", pszCAtomName[i] & 0x000000FF);
            }
        }
        PRINTF("\n\n");
    }
    else {
        PRINTF("Usage: at hex_atom_number\n");
    }
}




void
ww(
    CMD_ARGLIST
    )
{
    INT   h16;
    CHAR *argv[2];

    CMD_INIT();
    ASSERT_WOW_PRESENT;

    if(WDParseArgStr(lpArgumentString, argv, 1)) {

        if((h16 = WDahtoi(argv[0])) >= 0) {

        }
        else {
            PRINTF("Usage: ww hwnd16\n");
        }
    }
    else {
        PRINTF("Usage: ww hwnd16\n");
    }
}



void
wc(
    CMD_ARGLIST
    )
{
    PWC pwc;

    INT   h16;
    CHAR *argv[2];

    CMD_INIT();
    ASSERT_WOW_PRESENT;

    if(WDParseArgStr(lpArgumentString, argv, 1)) {

        if((h16 = WDahtoi(argv[0])) >= 0){

            try {

                pwc = (PWC)GetClassLong((HWND)HWND32((HAND16)h16),GCL_WOWWORDS);

                // this got moved out of WC
//              PRINTF("16:16 WndProc : %08lX\n", pwc->vpfnWndProc);

                PRINTF("VPSZ          : %08lX\n", pwc->vpszMenu);
                PRINTF("PWC           : %08lX\n\n", pwc);

            }
            except (EXCEPTION_ACCESS_VIOLATION == GetExceptionCode()) {

                PRINTF("!wow32.wc:  Invalid HWND16 %04x\n", h16);

            }
        }
        else {
            PRINTF("Usage: wc hwnd16\n");
        }
    }
    else {
        PRINTF("Usage: wc hwnd16\n");
    }
}






//
//  Dump Last Logged APIs
//
void
lastlog(
    CMD_ARGLIST
    )
{
    INT     ValueiCircBuffer = CIRC_BUFFERS;
    PVOID   pTmp = NULL;
    INT     iCircBuffer;
    CHAR    achTmp[TMP_LINE_LEN], *pachTmp;
    INT     i;

    CMD_INIT();
    ASSERT_CHECKED_WOW_PRESENT;

    GETEXPRVALUE(iCircBuffer, "wow32!iCircBuffer", INT);
    GETEXPRADDR(pTmp, "wow32!ValueiCircBuffer");
    if(pTmp) {
        try {
            READMEM(pTmp, &ValueiCircBuffer, sizeof(INT));
        } except (1) {
            ValueiCircBuffer = 0;
        }
    }
    if(ValueiCircBuffer == 0) {
        ValueiCircBuffer = CIRC_BUFFERS;
    }
    GETEXPRVALUE(pachTmp, "wow32!pachTmp", PCHAR);

    for (i = iCircBuffer; i >= 0; i--) {
        READMEM_XRET(achTmp, &pachTmp[i*TMP_LINE_LEN]);
        PRINTF("%s",achTmp);
    }

    for (i = ValueiCircBuffer-1; i > iCircBuffer; i--) {
        READMEM_XRET(achTmp, &pachTmp[i*TMP_LINE_LEN]);
        PRINTF("%s",achTmp);
    }

    return;
}


// creates/closes toggle for logfile for iloglevel logging in c:\ilog.log
void
logfile(
    CMD_ARGLIST
    )
{
    INT     nArgs;
    CHAR   *argv[2], szLogFile[128];
    DWORD   fLog;
    LPVOID  lpfLog, lpszLogFile;

    CMD_INIT();
    ASSERT_CHECKED_WOW_PRESENT;

    nArgs = WDParseArgStr(lpArgumentString, argv, 1);

    GETEXPRADDR(lpfLog, "wow32!fLog");
    READMEM_XRET(fLog, lpfLog);

    if(nArgs) {
        strcpy(szLogFile, argv[0]);
    }
    else {
        strcpy(szLogFile, "c:\\ilog.log");
    }

    if(fLog == 0) {
        fLog = 2;

        PRINTF("\nCreating ");
        PRINTF(szLogFile);
        PRINTF("\n\n");
    }
    else {
        fLog = 3;
        PRINTF("\nClosing logfile\n\n");
    }

    WRITEMEM_XRET(lpfLog, fLog);

    GETEXPRADDR(lpszLogFile, "wow32!szLogFile");
    WRITEMEM_N_XRET(lpszLogFile, szLogFile, strlen(szLogFile)+1);

    return;
}




//
//  Set iLogLevel from Debugger Extension
//
void
setloglevel(
    CMD_ARGLIST
    )
{
    INT    iLogLevel;
    LPVOID lpAddress;

    CMD_INIT();
    ASSERT_CHECKED_WOW_PRESENT;

    GETEXPRADDR(lpAddress, "wow32!iLogLevel");
    iLogLevel = (INT)GetExpression(lpArgumentString);
    WRITEMEM_XRET(lpAddress, iLogLevel);

    return;
}


//
//  Toggle Single Step Trace Mode
//
void
steptrace(
    CMD_ARGLIST
    )
{
    INT    localfDebugWait;
    LPVOID lpAddress;

    CMD_INIT();
    ASSERT_CHECKED_WOW_PRESENT;

    GETEXPRADDR(lpAddress, "wow32!fDebugWait");
    READMEM_XRET(localfDebugWait, lpAddress);
    localfDebugWait = ~localfDebugWait;
    WRITEMEM_XRET(lpAddress, localfDebugWait);

    return;
}

/******* Misc filtering functions ********/
//
//  Set Filter Filtering of Specific APIs ON
//
void FilterSpecific( )
{
    INT      i;
    INT      fLogFilter;
    WORD     wfLogFunctionFilter;
    LPVOID   lpAddress;
    PWORD    pawfLogFunctionFilter;
    WORD     wCallId;

    SkipToNextWhiteSpace();
    if (GetNextToken()) {
        wCallId = (WORD)GetExpression(lpArgumentString);
    } else {
        PRINTF("Please specify an api callid\n");
        return;
    }

    if (!wCallId) {
        PRINTF("Invalid callid\n");
        return;
    }


    GETEXPRVALUE(pawfLogFunctionFilter, "wow32!pawfLogFunctionFilter", PWORD);

    for (i = 0; i < FILTER_FUNCTION_MAX ; i++) {

         // Find Empty Position In Array
         READMEM_XRET(wfLogFunctionFilter, &pawfLogFunctionFilter[i]);
         if ((wfLogFunctionFilter == 0xffff) ||
             (wfLogFunctionFilter == 0x0000)) {

            // Add New Filter to Array
            wfLogFunctionFilter = wCallId;
            WRITEMEM_XRET(&pawfLogFunctionFilter[i], wfLogFunctionFilter);
            break;
         }
    }

    GETEXPRADDR(lpAddress, "wow32!fLogFilter");
    fLogFilter = 0xffffffff;
    WRITEMEM_XRET(lpAddress, fLogFilter);

}


//
//  Clear Filter Specific Array
//
void FilterResetSpecific( )
{
    INT     i;
    WORD    NEG1 = (WORD) -1;
    WORD    ZERO = 0;
    PWORD   pawfLogFunctionFilter;
    LPVOID  lpAddress;

    GETEXPRVALUE(pawfLogFunctionFilter, "wow32!pawfLogFunctionFilter", PWORD);

    WRITEMEM_XRET(&pawfLogFunctionFilter[0], NEG1);
    for (i=1; i < FILTER_FUNCTION_MAX ; i++) {
        WRITEMEM_XRET(&pawfLogFunctionFilter[i], ZERO);
    }

    GETEXPRADDR(lpAddress, "wow32!iLogFuncFiltIndex");
    WRITEMEM_XRET(lpAddress, ZERO);

}

//
//  Set TaskID Filtering
//
void FilterTask( )
{
    INT    fLogTaskFilter;
    LPVOID lpAddress;

    SkipToNextWhiteSpace();
    if (GetNextToken()) {
        GETEXPRADDR(lpAddress, "wow32!fLogTaskFilter");
        fLogTaskFilter = (INT)GetExpression(lpArgumentString);
        WRITEMEM_XRET(lpAddress, fLogTaskFilter);
    } else {
        PRINTF("Please specify a task\n");
    }

    return;
}



//
//  Turn All filtering ON
//
void FilterReset( )
{
    LPVOID lpAddress;
    INT    fLogFilter = 0xffffffff;
    WORD   fLogTaskFilter = 0xffff;

    GETEXPRADDR(lpAddress, "wow32!fLogFilter");
    WRITEMEM_XRET(lpAddress, fLogFilter);

    GETEXPRADDR(lpAddress, "wow32!fLogTaskFilter");
    WRITEMEM_XRET(lpAddress, fLogTaskFilter);

    FilterResetSpecific();
}


//
//  Disable logging on all classes
//
void FilterAll( )
{
    INT    fLogFilter;
    LPVOID lpAddress;

    GETEXPRADDR(lpAddress, "wow32!fLogFilter");
    fLogFilter = 0x00000000;
    WRITEMEM_XRET(lpAddress, fLogFilter);

}


VOID
DumpFilterSettings(
    VOID
    )
{
    INT      i;
    INT      fLogFilter;
    WORD     wfLogFunctionFilter;
    WORD     wfLogTaskFilter;
    LPVOID   lpAddress;
    PWORD    pawfLogFunctionFilter;

    GETEXPRVALUE(pawfLogFunctionFilter, "wow32!pawfLogFunctionFilter", PWORD);
    GETEXPRVALUE(wfLogTaskFilter, "wow32!fLogTaskFilter", WORD);
    GETEXPRADDR(lpAddress, "wow32!fLogFilter");
    READMEM_XRET(fLogFilter, lpAddress);


    if (!pawfLogFunctionFilter) {
        PRINTF("Symbol 'wow32!pawfLogFunctionFilter' not available\n");
        return;
    }

    PRINTF("\n*** WOW log filter state ***\n");
    if (fLogFilter & FILTER_VERBOSE) {
        PRINTF("Verbose logging is on\n");
    } else {
        PRINTF("Verbose logging is off\n");
    }

    if (wfLogTaskFilter != 0xffff) {
        PRINTF("Only API calls for task %04X will be logged\n", wfLogTaskFilter);
    } else {
        PRINTF("Task filtering is off\n");
    }

    READMEM_XRET(wfLogFunctionFilter, &pawfLogFunctionFilter[0]);
    if (wfLogFunctionFilter != 0xffff) {

        PRINTF("\nOnly API calls with the following CallId's will be logged:\n");

        for (i = 0; i < FILTER_FUNCTION_MAX ; i++) {

             // Find Empty Position In Array
             READMEM_XRET(wfLogFunctionFilter, &pawfLogFunctionFilter[i]);
             if ((wfLogFunctionFilter != 0xffff) &&
                 (wfLogFunctionFilter != 0x0000)) {
                PRINTF("    %04X\n", wfLogFunctionFilter);
             }
        }
        PRINTF("\n");
    } else {
        PRINTF("Specific API filtering is off\n");
    }

    if (!(~fLogFilter & ~FILTER_VERBOSE)) {
        PRINTF("API class filtering if off\n");
    } else {
        PRINTF("Logging is disabled for the following API classes:\n");
    }

    if (!(fLogFilter & FILTER_KERNEL)) {
        PRINTF("    KERNEL\n");
    }
    if (!(fLogFilter & FILTER_KERNEL16)) {
        PRINTF("    KERNEL16\n");
    }
    if (!(fLogFilter & FILTER_USER)) {
        PRINTF("    USER\n");
    }
    if (!(fLogFilter & FILTER_GDI)) {
        PRINTF("    GDI\n");
    }
    if (!(fLogFilter & FILTER_KEYBOARD)) {
        PRINTF("    KEYBOARD\n");
    }
    if (!(fLogFilter & FILTER_SOUND)) {
        PRINTF("    SOUND\n");
    }
    if (!(fLogFilter & FILTER_MMEDIA)) {
        PRINTF("    MMEDIA\n");
    }
    if (!(fLogFilter & FILTER_WINSOCK)) {
        PRINTF("    WINSOCK\n");
    }
    if (!(fLogFilter & FILTER_COMMDLG)) {
        PRINTF("    COMMDLG\n");
    }

    PRINTF("\n");

}

void
filter(
    CMD_ARGLIST
    )
{
    ULONG Mask = 0;
    LPVOID   lpAddress;

    CMD_INIT();
    ASSERT_CHECKED_WOW_PRESENT;

    while (' ' == *lpArgumentString) {
        lpArgumentString++;
    }

    if (_strnicmp(lpArgumentString, "kernel16", 8) == 0) {
        Mask = FILTER_KERNEL16;
    } else if (_strnicmp(lpArgumentString, "kernel", 6) == 0) {
        Mask = FILTER_KERNEL;
    } else if (_strnicmp(lpArgumentString, "user", 4) == 0) {
        Mask = FILTER_USER;
    } else if (_strnicmp(lpArgumentString, "gdi", 3) == 0) {
        Mask = FILTER_GDI;
    } else if (_strnicmp(lpArgumentString, "keyboard", 8) == 0) {
        Mask = FILTER_KEYBOARD;
    } else if (_strnicmp(lpArgumentString, "sound", 5) == 0) {
        Mask = FILTER_SOUND;
    } else if (_strnicmp(lpArgumentString, "mmedia", 6) == 0) {
        Mask = FILTER_MMEDIA;
    } else if (_strnicmp(lpArgumentString, "winsock", 7) == 0) {
        Mask = FILTER_WINSOCK;
    } else if (_strnicmp(lpArgumentString, "commdlg", 7) == 0) {
        Mask = FILTER_COMMDLG;
    } else if (_strnicmp(lpArgumentString, "callid", 6) == 0) {
        FilterSpecific();
    } else if (_strnicmp(lpArgumentString, "task", 4) == 0) {
        FilterTask();
    } else if (_strnicmp(lpArgumentString, "*", 1) == 0) {
        FilterAll();
    } else if (_strnicmp(lpArgumentString, "reset", 5) == 0) {
        FilterReset();
    } else if (_strnicmp(lpArgumentString, "verbose", 7) == 0) {
        Mask = FILTER_VERBOSE;
    } else {
        if (*lpArgumentString != 0) {
            PRINTF("Invalid argument to Filter command: '%s'\n", lpArgumentString);
            return;
        }
    }

    if (Mask) {
        INT   fLogFilter;
        GETEXPRADDR(lpAddress, "wow32!fLogFilter");
        if (!lpAddress) {
            PRINTF("Symbol 'wow32!fLogFilter' not available\n");
        } else {
            READMEM_XRET(fLogFilter, lpAddress);
            if ((fLogFilter & Mask) == 0) {
                fLogFilter |= Mask;
            } else {
                fLogFilter &= ~Mask;
            }
            WRITEMEM_XRET(lpAddress, fLogFilter);
        }
    }

    DumpFilterSettings();
}


void
cia(
    CMD_ARGLIST
    )
{
    CURSORICONALIAS cia;
    PVOID lpAddress;
    INT maxdump = 500;

    CMD_INIT();
    ASSERT_WOW_PRESENT;

    GETEXPRADDR(lpAddress, "wow32!lpCIAlias");
    READMEM_XRET(lpAddress, lpAddress);

    if (!lpAddress) {

        PRINTF("Cursor/Icon alias list is empty.\n");

    } else {

        PRINTF("Alias    tp H16  H32      inst mod  task res  szname\n");

        READMEM_XRET(cia, lpAddress);

        while ((lpAddress != NULL) && --maxdump) {

            if (cia.fInUse) {
                PRINTF("%08X", lpAddress);
                PRINTF(" %02X", cia.flType);
                PRINTF(" %04X", cia.h16);
                PRINTF(" %08X", cia.h32);
                PRINTF(" %04X", cia.hInst16);
                PRINTF(" %04X", cia.hMod16);
                PRINTF(" %04X", cia.hTask16);
                PRINTF(" %04X", cia.hRes16);
                PRINTF(" %08X\n", cia.lpszName);
            }

            lpAddress = cia.lpNext;
            READMEM_XRET(cia, lpAddress);

        }

        if (!maxdump) {
            PRINTF("Dump ended prematurely - possible infinite loop\n");
        }
    }

}


//WARNING: This structure must match ENTRY in ntgdi\inc\hmgshare.h
//         and in ..\wow32\walias.c

typedef struct _ENTRYWOW
{
    LONG   l1;
    LONG   l2;
    USHORT FullUnique;
    USHORT us1;
    LONG   l3;
} ENTRYWOW, *PENTRYWOW;

// this stuff must match what's in ..\wow32\walias.h.  It is too messy to
// include that file here.
#define BAD_GDI32_HANDLE 0xFFFF  // bad GDI32 handle

#define END_OF_LIST      0       // end of free list

// State flags
#define SLOT_FREE        0x0000  // table index is free
#define IN_USE           0x0001  // table index is in use
#define H16_DELETED      0x0002  // marks index as candidate for being reclaimed
#define GDI_STOCK_OBJECT 0x0003  // marks stock objects (non-deletable)

/*
// defines entries in the GDI16 handle mapping table
typedef struct _tagGDIH16MAP {
    HANDLE  h32;       // store the full h32
    WORD    State;     // Either SLOT_FREE, IN_USE or H16_DELETED
    WORD    NextFree;  // points to next free index or END_OF_LIST
} GDIH16MAP, *PGDIH16MAP;

// defines entries in the GDI32 handle mapping table
typedef struct _tagGDIH32MAP {
    WORD  h16index;
} GDIH32MAP, *PGDIH32MAP;
*/


void DumpGdiHandleVerbose(LPVOID lpAddress16, LPVOID lpAddress32, ULONG h16)
{
    DWORD         dw;
    GDIH16MAP     Entry16;
    GDIH32MAP     Entry32;
    PGDIH16MAP    pTable16;
    PGDIH32MAP    pTable32;
    LPVOID        p;
    HANDLE        h32;
    ULONG         index;

    READMEM_XRET(pTable16, lpAddress16);
    READMEM_XRET(pTable32, lpAddress32);

    if(h16 != 0) {
        index = h16 >> 2;
        p = (LPVOID)&pTable16[index];

        if(!READMEM(p, &Entry16, sizeof(GDIH16MAP))) {
            PRINTF("\nFailure reading GDIH16MAP At %08lX\n", p);
            return;
        }
        h32 = Entry16.h32;
    
        p = (LPVOID)&pTable32[LOWORD(h32)];
    
        if(!READMEM(p, &Entry32, sizeof(GDIH32MAP))) {
            PRINTF("Failure reading GDIH32MAP At %08lX\n", p);
            return;
        }

        PRINTF("Index: %04X\n", index);
        PRINTF("State: %04X: ", Entry16.State);
        if(Entry16.State == SLOT_FREE) {
            PRINTF("SLOT_FREE\n");
        } else if(Entry16.State == IN_USE) {
            PRINTF("IN_USE\n");
        } else if(Entry16.State == H16_DELETED) {
            PRINTF("H16_DELETED\n");
        } else if(Entry16.State == GDI_STOCK_OBJECT) {
            PRINTF("GDI_STOCK_OBJECTH\n");
        } else {
            PRINTF("UNKNOWN!\n");
        }
        PRINTF("NextFree: %04X\n", Entry16.NextFree);
        PRINTF("h16index: %04X\n", Entry32.h16index);
    }
   
    PRINTF("16-bit mapping table (pGdiH16MappingTable): %08lX\n",pTable16);
    PRINTF("32-bit mapping table (pGdiH32MappingTable): %08lX\n",pTable32);

    lpAddress32 = (PGDIH32MAP)EXPRESSION("wow32!gH16_deleted_count");
    READMEM_XRET((LPVOID)dw, lpAddress32);
    PRINTF("      gH16_deleted_count: %04X\n", dw);

    lpAddress32 = (PGDIH32MAP)EXPRESSION("wow32!ghGdi16NextFree");
    READMEM_XRET((LPVOID)dw, lpAddress32);
    PRINTF("         ghGdi16NextFree: %04X\n", dw);

    lpAddress32 = (PGDIH32MAP)EXPRESSION("wow32!ghGdi16LastFree");
    READMEM_XRET((LPVOID)dw, lpAddress32);
    PRINTF("         ghGdi16LastFree: %04X\n", dw);

    lpAddress32 = (PGDIH32MAP)EXPRESSION("wow32!gMaxGdiHandlesPerProcess");
    READMEM_XRET((LPVOID)dw, lpAddress32);
    PRINTF("gMaxGdiHandlesPerProcess: %04X\n", dw);

    lpAddress32 = (PGDIH32MAP)EXPRESSION("wow32!gLastAllowableIndex");
    READMEM_XRET((LPVOID)dw, lpAddress32);
    PRINTF("     gLastAllowableIndex: %04X\n", dw);

    lpAddress32 = (PGDIH32MAP)EXPRESSION("wow32!gFirstNonStockObject");
    READMEM_XRET((LPVOID)dw, lpAddress32);
    PRINTF("    gFirstNonStockObject: %04X\n", dw);

    lpAddress32 = (PGDIH32MAP)EXPRESSION("wow32!gwNextReclaimStart");
    READMEM_XRET((LPVOID)dw, lpAddress32);
    PRINTF("      gwNextReclaimStart: %04X\n", dw);

    lpAddress32 = (PGDIH32MAP)EXPRESSION("wow32!gdwPageCommitSize");
    READMEM_XRET((LPVOID)dw, lpAddress32);
    PRINTF("       gdwPageCommitSize: %04X\n", dw);

    // These are on debug builds only
    lpAddress32 = (PGDIH32MAP)EXPRESSION("wow32!gprevNextFree");
    if(lpAddress32) {
        READMEM_XRET((LPVOID)dw, lpAddress32);
        PRINTF("           gprevNextFree: %04X\n", dw);
    }

    lpAddress32 = (PGDIH32MAP)EXPRESSION("wow32!gAllocatedHandleCount");
    if(lpAddress32) {
        READMEM_XRET((LPVOID)dw, lpAddress32);
        PRINTF("   gAllocatedHandleCount: %04X\n", dw);
    }
    return;
}



// converts an hGDI16 to the equivalent hGDI32
void
hgdi16(
    CMD_ARGLIST
    )
{
    int           argc;
    ULONG         h16 = 0;
    ULONG         index;
    HANDLE        h32;
    PGDIH16MAP    pTable16;
    GDIH16MAP     Entry16;
    LPVOID        lpAddress16;
    LPVOID        lpAddress32;
    LPVOID        p;
    BOOL          fVerbose = FALSE;
    CHAR         *argv[3];

    CMD_INIT();
    ASSERT_WOW_PRESENT;

    argc = WDParseArgStr(lpArgumentString, argv, 2);

    if(argc == 0) {
        goto Usage;
    }

    if(argc == 1) {

        if((argv[0][0] == '-') && (argv[0][1] == 'V')) {
            fVerbose = TRUE;
        }
        else {
            h16 = (ULONG) WDahtoi(argv[0]); 
        }
    }

    else {

        if((argv[0][0] == '-') && (argv[0][1] == 'V')) {
            fVerbose = TRUE;
            h16 = (ULONG) WDahtoi(argv[1]); 
        }
        else if((argv[1][0] == '-') && (argv[1][1] == 'V')) {
            fVerbose = TRUE;
            h16 = (ULONG) WDahtoi(argv[0]); 
        }
        else {
            goto Usage;
        }
    }

    if((h16 == 0) && (fVerbose == FALSE)) {
        goto Usage;
    }

    lpAddress16 = (PGDIH16MAP)EXPRESSION("wow32!pGdiH16MappingTable");
    READMEM_XRET(pTable16, lpAddress16);

    if(h16) {
//        h16 = (ULONG) WDahtoi(lpArgumentString);
        PRINTF("    16-bit Handle: %04X     ", h16);
        index = h16 >> 2;

        p = (LPVOID)&pTable16[index];

        if(!READMEM(p, &Entry16, sizeof(GDIH16MAP))) {
            PRINTF("\nFailure reading GDIH16MAP At %08lX\n", p);
            return;
        }

        h32 = Entry16.h32;
        PRINTF("32-bit Handle: %08X\n", h32);
    }

    if(fVerbose) {

        lpAddress32 = (PGDIH32MAP)EXPRESSION("wow32!pGdiH32MappingTable");

        DumpGdiHandleVerbose(lpAddress16, lpAddress32, h16);
    }
    return;

Usage:
    PRINTF(" Usage: !hgdi16 [-v] h16\n\n");
    return;
}


// converts an hGDI16 to the equivalent hGDI32
void
hgdi32(
    CMD_ARGLIST
    )
{
    int           argc;
    ULONG         h16 = 0;
    ULONG         index;
    HANDLE        h32 = 0;
    PGDIH32MAP    pTable32;
    GDIH32MAP     Entry32;
    LPVOID        lpAddress16;
    LPVOID        lpAddress32;
    LPVOID        p;
    BOOL          fVerbose = FALSE;
    CHAR         *argv[3];

    CMD_INIT();
    ASSERT_WOW_PRESENT;

    argc = WDParseArgStr(lpArgumentString, argv, 2);

    if(argc == 0) {
        goto Usage;
    }

    if(argc == 1) {

        if((argv[0][0] == '-') && (argv[0][1] == 'V')) {
            fVerbose = TRUE;
        }
        else {
            h32 = (HANDLE) WDahtoi(argv[0]); 
        }
    }

    else {

        if((argv[0][0] == '-') && (argv[0][1] == 'V')) {
            fVerbose = TRUE;
            h32 = (HANDLE) WDahtoi(argv[1]); 
        }
        else if((argv[1][0] == '-') && (argv[1][1] == 'V')) {
            fVerbose = TRUE;
            h32 = (HANDLE) WDahtoi(argv[0]); 
        }
        else {
            goto Usage;
        }
    }

    if((h32 == 0) && (fVerbose == FALSE)) {
        goto Usage;
    }

    lpAddress32 = (PGDIH16MAP)EXPRESSION("wow32!pGdiH32MappingTable");
    READMEM_XRET(pTable32, lpAddress32);

    if(h32) {
//        h32 = (ULONG) WDahtoi(lpArgumentString);
        PRINTF("    32-bit Handle: %04X     ", h32);
        index = LOWORD(h32);

        p = (LPVOID)&pTable32[index];

        if(!READMEM(p, &Entry32, sizeof(GDIH32MAP))) {
            PRINTF("\nFailure reading GDIH32MAP At %08lX\n", p);
            return;
        }

        h16 = Entry32.h16index;
        h16 = h16 << 2;
        PRINTF("16-bit Handle: %08X\n", h16);
    }

    if(fVerbose) {

        lpAddress16 = (PGDIH16MAP)EXPRESSION("wow32!pGdiH16MappingTable");

        DumpGdiHandleVerbose(lpAddress16, lpAddress32, h16);
    }
    return;

Usage:
    PRINTF(" Usage: !hgdi32 [-v] h32\n\n");
    return;
}



//typedef struct _HDDE {
//    struct _HDDE *pDDENext;    // pointer to next hDDE alias
//    HAND16  To_hwnd;           // window that will receive this message
//    HAND16  From_hwnd;         // window that sent this message
//    HAND16  hMem16;            // handle of WOW app allocated 16 bit object
//    HANDLE  hMem32;            // handle of WOW allocated 32 bit object
//    WORD    DdeMsg;            // message id
//    WORD    DdeFormat;         // message format
//    WORD    DdeFlags;          // indicates if it is metafile handle
//    HAND16  h16;               // original h16 for bad apps doing EXECUTE
//} HDDE, *PHDDE;

// dumps the list of dde 16-32 memory pairs
void
ddemem(
    CMD_ARGLIST
    )
{
    PHDDE     phdde;
    HDDE      hdde;
    LPVOID    lpAddress;

    CMD_INIT();
    ASSERT_WOW_PRESENT;

    lpAddress = (PENTRYWOW)EXPRESSION("wow32!phDDEFirst");
    READMEM_XRET(phdde, lpAddress);

    while(phdde) {

        if(!READMEM((LPVOID) (phdde), &hdde, sizeof(HDDE))) {
            PRINTF("Failure reading HDDE At %08lX\n", phdde);
            return;
        }

        PRINTF("      PHDDE: %08X\n", phdde);
        PRINTF("  To_hwnd16: %04X\n", hdde.To_hwnd);
        PRINTF("From_hwnd16: %04X\n", hdde.From_hwnd);
        PRINTF("     hMem16: %04X\n", hdde.hMem16);
        PRINTF("     hMem32: %04X\n", hdde.hMem32);
        PRINTF("     DdeMsg: %04X\n", hdde.DdeMsg);
        PRINTF("  DdeFormat: %04X\n", hdde.DdeFormat);
        PRINTF("   DdeFlags: %04X\n", hdde.DdeFlags);
        PRINTF("   Orig h16: %04X\n\n", hdde.h16);

        phdde = hdde.pDDENext;
    }

    return;
}

// must match struct in  "..\wow32\wow32.h"
#ifndef DEBUG
#define ML_MALLOC_W      0x00000001
#define ML_MALLOC_W_ZERO 0x00000002
#define ML_REALLOC_W     0x00000004
#define ML_MALLOC_WTYPE  (ML_MALLOC_W | ML_MALLOC_W_ZERO | ML_REALLOC_W)
#define ML_GLOBALALLOC   0x00000010
#define ML_GLOBALREALLOC 0x00000020
#define ML_GLOBALTYPE    (ML_GLOBALREALLOC | ML_GLOBALALLOC)
typedef struct _tagMEMLEAK {
    struct _tagMEMLEAK *lpmlNext;
    PVOID               lp;
    DWORD               size;
    UINT                fHow;
    ULONG               Count;
    PVOID               CallersAddress;
} MEMLEAK, *LPMEMLEAK;
#endif


void
gmem(
    CMD_ARGLIST
    )
{
    LPMEMLEAK lpml;
    MEMLEAK   ml;
    LPVOID    lpAddress;

    CMD_INIT();
    ASSERT_WOW_PRESENT;

    // DbgBreakPoint();
    lpAddress = (PENTRYWOW)EXPRESSION("wow32!lpMemLeakStart");
    READMEM_XRET(lpml, lpAddress);

    while(lpml) {

        if(!READMEM((LPVOID) (lpml), &ml, sizeof(MEMLEAK))) {
            PRINTF("Failure reading lpml At %08lX\n", lpml);
            return;
        }

        PRINTF("         lp: %08X\n", ml.lp);
        PRINTF("       Size: %08X\n", ml.size);
        PRINTF(" Alloc'd by: %08X\n", ml.CallersAddress);
        PRINTF("Alloc Count: %08X\n", ml.Count);
        PRINTF("How Alloc'd: ");
        if(ml.fHow & ML_MALLOC_W) PRINTF("malloc_w ");
        if(ml.fHow & ML_MALLOC_W_ZERO) PRINTF("malloc_w_zero ");
        if(ml.fHow & ML_REALLOC_W) PRINTF("realloc_w ");
        if(ml.fHow & ML_GLOBALALLOC) PRINTF("GlobalAlloc ");
        if(ml.fHow & ML_GLOBALREALLOC) PRINTF("GlobalReAlloc ");
        PRINTF("\n\n");

        lpml = ml.lpmlNext;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\util.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    heap.c

Abstract:

    This function contains the default ntsd debugger extensions

Author:

    Bob Day      (bobday) 29-Feb-1992 Grabbed standard header

Revision History:

    Neil Sandlin (NeilSa) 15-Jan-1996 Merged with vdmexts
                                      Added command line parsing

--*/

#include <precomp.h>
#pragma hdrstop

VDMCONTEXT ThreadContext;

PVOID LdtAddress = NULL;

BOOL
WINAPI
ReadProcessMem(
    LPVOID lpBaseAddress,
    LPVOID lpBuffer,
    DWORD nSize
    )
{
    return ReadProcessMemory( hCurrentProcess, lpBaseAddress, lpBuffer, nSize, NULL );
}

BOOL
WINAPI
WriteProcessMem(
    LPVOID lpBaseAddress,
    LPVOID lpBuffer,
    DWORD nSize
    )
{
    return WriteProcessMemory( hCurrentProcess, lpBaseAddress, lpBuffer, nSize, NULL );
}

#ifndef i386

//
// The following two routines implement the very funky way that we
// have to get register values on the 486 emulator.
//

ULONG
GetRegValue(
    NT_CPU_REG reg,
    BOOL bInNano,
    ULONG UMask
    )

{
    if (bInNano) {

        return(ReadDwordSafe(reg.nano_reg));

    } else if (UMask & reg.universe_8bit_mask) {

        return (ReadDwordSafe(reg.saved_reg) & 0xFFFFFF00 |
                ReadDwordSafe(reg.reg) & 0xFF);

    } else if (UMask & reg.universe_16bit_mask) {

        return (ReadDwordSafe(reg.saved_reg) & 0xFFFF0000 |
                ReadDwordSafe(reg.reg) & 0xFFFF);

    } else {

        return (ReadDwordSafe(reg.reg));

    }
}

ULONG
GetEspValue(
    NT_CPU_INFO nt_cpu_info,
    BOOL bInNano
    )

{
    if (bInNano) {

        return (ReadDwordSafe(nt_cpu_info.nano_esp));

    } else {

        if (ReadDwordSafe(nt_cpu_info.stack_is_big)) {

            return (ReadDwordSafe(nt_cpu_info.host_sp) -
                    ReadDwordSafe(nt_cpu_info.ss_base));

        } else {

            return (ReadDwordSafe(nt_cpu_info.esp_sanctuary) & 0xFFFF0000 |
                    (ReadDwordSafe(nt_cpu_info.host_sp) -
                     ReadDwordSafe(nt_cpu_info.ss_base) & 0xFFFF));

        }

    }

}

#endif

int
GetContext(
    VDMCONTEXT* lpContext
)
/*
    GetContext

    This function fills in the specified context record with
    the content of the 16-bit registers. The return value is
    the mode (v86 or PROT) of the client.

    Note that on x86, if the machine is currently in the monitor,
    we have to pick up the values from the VdmTib and IntelMSW.

*/
{
#ifndef i386    //
    int         mode;
    ULONG       pTmp;
    NT_CPU_INFO nt_cpu_info;
    BOOL        b;
    BOOL        bInNano;
    ULONG       UMask;
#if 0
    DWORD MyEflags;
#endif

    pTmp = (ULONG)EXPRESSION("ntvdm!nt_cpu_info");

    if ( pTmp ) {

        b = READMEM((LPVOID) pTmp, &nt_cpu_info, sizeof(NT_CPU_INFO));

        if ( !b ) {
            PRINTF("Could not read IntelRegisters context out of process\n");
            return( -1 );
        }

        bInNano = ReadDwordSafe((ULONG) nt_cpu_info.in_nano_cpu);
        UMask   = ReadDwordSafe((ULONG) nt_cpu_info.universe);

        lpContext->Eax = GetRegValue(nt_cpu_info.eax, bInNano, UMask);
        lpContext->Ecx = GetRegValue(nt_cpu_info.ecx, bInNano, UMask);
        lpContext->Edx = GetRegValue(nt_cpu_info.edx, bInNano, UMask);
        lpContext->Ebx = GetRegValue(nt_cpu_info.ebx, bInNano, UMask);
        lpContext->Ebp = GetRegValue(nt_cpu_info.ebp, bInNano, UMask);
        lpContext->Esi = GetRegValue(nt_cpu_info.esi, bInNano, UMask);
        lpContext->Edi = GetRegValue(nt_cpu_info.edi, bInNano, UMask);

        lpContext->Esp    = GetEspValue(nt_cpu_info, bInNano);

        //
        // nt_cpu_info.flags isn't very much use, because several of the
        // flags values are not kept in memory, but computed each time.
        // The emulator doesn't supply us with the right value, so we
        // try to get it from the code in VdmDebugger
        //

        lpContext->EFlags = ReadDwordSafe(nt_cpu_info.flags);
#if 0
        lpContext->EFlags = 0xffffffff;         // indicate value unknown

        if (InVdmPrompt() &&
            (pTmp = (ULONG)EXPRESSION("ntvdmd!VdmDbgEFLAGS"))        &&
            (READMEM((LPVOID) pTmp, &MyEflags, sizeof(DWORD))))  {

                lpContext->EFlags = MyEflags;

        }
#endif

        lpContext->Eip    = ReadDwordSafe(nt_cpu_info.eip);

        lpContext->SegEs = ReadWordSafe(nt_cpu_info.es);
        lpContext->SegCs = ReadWordSafe(nt_cpu_info.cs);
        lpContext->SegSs = ReadWordSafe(nt_cpu_info.ss);
        lpContext->SegDs = ReadWordSafe(nt_cpu_info.ds);
        lpContext->SegFs = ReadWordSafe(nt_cpu_info.fs);
        lpContext->SegGs = ReadWordSafe(nt_cpu_info.gs);


    } else {

        PRINTF("Could not find the symbol 'ntvdm!nt_cpu_info'\n");
        return( -1 );
    }

    if ( !(ReadDwordSafe(nt_cpu_info.cr0) & 1) ) {
        mode = V86_MODE;
    } else {
        mode = PROT_MODE;
    }
    return( mode );

#else           //

    NTSTATUS    rc;
    BOOL        b;
    int         mode;
    ULONG       lpVdmTib;
    ULONG       IntelMSW;

    lpContext->ContextFlags = CONTEXT_FULL;
    rc = NtGetContextThread( hCurrentThread,
                             lpContext );
    if ( NT_ERROR(rc) ) {
        PRINTF( "bde.k: Could not get current threads context - status = %08lX\n", rc );
        return( -1 );
    }
    /*
    ** Get the 16-bit registers from the context
    */

    if ( lpContext->EFlags & V86_BITS ) {
        /*
        ** V86 Mode
        */
        mode = V86_MODE;
    } else {
        if ( ((WORD)(lpContext->SegCs & RPL_MASK)) != KGDT_R3_CODE ) {
            mode = PROT_MODE;
        } else {
            /*
            ** We are in flat 32-bit address space!
            */
            lpVdmTib = GetCurrentVdmTib();
            if ( !lpVdmTib ) {
                PRINTF("Could not find the symbol 'VdmTib'\n");
                return( -1 );
            }

            b = READMEM((LPVOID)(lpVdmTib+FIELD_OFFSET(VDM_TIB,VdmContext)),
                        lpContext, sizeof(VDMCONTEXT));

            if ( !b ) {
                PRINTF("Could not read IntelRegisters context out of process\n");
                return( -1 );
            }

            b = READMEM((LPVOID)(lpVdmTib+FIELD_OFFSET(VDM_TIB,IntelMSW)),
                        &IntelMSW, sizeof(IntelMSW));

            if ( !b ) {
                PRINTF("Could not read IntelMSW out of process\n");
                return( -1 );
            }

            if ( IntelMSW & MSW_PE ) {
                mode = PROT_MODE;
            } else {
                mode = V86_MODE;
            }
        }
    }

    return( mode );
#endif
}

ULONG
GetIntelBase(
    VOID
    )
{
#ifndef i386
    ULONG IntelBase;
    BOOL        b;

    IntelBase = (ULONG)EXPRESSION("ntvdm!Start_of_M_area");
    if ( IntelBase ) {

        b = READMEM((LPVOID) IntelBase, &IntelBase, sizeof(ULONG));

        if ( !b ) {
            PRINTF("Could not read symbol 'ntvdm!Start_of_M_area\n");
            return(0);
        }

    } else {
        PRINTF("Could not find the symbol 'ntvdm!Start_of_M_area'\n");
    }

    return(IntelBase);
#else
    return(0);
#endif
}

DWORD read_dword(
    ULONG   lpAddress,
    BOOL    bSafe
) {
    BOOL    b;
    DWORD   dword;

    b = READMEM((LPVOID)lpAddress, &dword, sizeof(dword));

    if ( !b ) {
        if ( !bSafe ) {
            PRINTF("Failure reading dword at memory location %08lX\n", lpAddress );
        }
        return( 0 );
    }
    return( dword );
}

WORD read_word(
    ULONG   lpAddress,
    BOOL    bSafe
) {
    BOOL    b;
    WORD    word;

    b = READMEM((LPVOID)lpAddress, &word, sizeof(word));

    if ( !b ) {
        if ( !bSafe ) {
            PRINTF("Failure reading word at memory location %08lX\n", lpAddress );
        }
        return( 0 );
    }
    return( word );
}

BYTE read_byte(
    ULONG   lpAddress,
    BOOL    bSafe
) {
    BOOL    b;
    BYTE    byte;

    b = READMEM((LPVOID)lpAddress, &byte, sizeof(byte));

    if ( !b ) {
        if ( !bSafe ) {
            PRINTF("Failure reading byte at memory location %08lX\n", lpAddress );
        }
        return( 0 );
    }
    return( byte );
}

BOOL read_gnode32(
    ULONG   lpAddress,
    PGNODE32  p,
    BOOL    bSafe
) {
    BOOL    b;

    b = READMEM((LPVOID)lpAddress, p, sizeof(*p));

    if ( !b ) {
        if ( !bSafe ) {
            PRINTF("Failure reading word at memory location %08lX\n", lpAddress );
        }
        return( 0 );
    }
    return( TRUE );
}


BOOL GetDescriptorData(
    WORD selector,
    LPVDMLDT_ENTRY pdte
    )
{

//
// Using GetThreadSelectorEntry would be nice if it just wasn't so slow.
// So, we use our LDT, just like on risc, which should be good enough.
//#ifdef i386
#if 0
    LDT_ENTRY  dte;
    if (!GetThreadSelectorEntry( hCurrentThread,
                                    selector,
                                   &dte)) {
        return( FALSE );
    }
    pdte->HighWord = dte.HighWord;
    pdte->BaseLow = dte.BaseLow;
    pdte->LimitLow = dte.LimitLow;
    return (TRUE);
#endif

    NTSTATUS                Status;
    selector &= ~(SELECTOR_LDT | SELECTOR_RPL);

    //
    // Get address of Ldt
    //

    if (!LdtAddress) {
        //
        // GetExpression is VERY SLOW under ntsd now. Who knows what the
        // debugger guys are up to. So just try to cache the address value
        // since it only changes twice (both during boot).
        //
        LdtAddress = (PVOID)EXPRESSION("ntvdm!Ldt");

        Status = READMEM(LdtAddress, &LdtAddress, sizeof(ULONG));
        if (!Status) {
            LdtAddress = NULL;
            return FALSE;
        }
    }

    Status = READMEM((PVOID)((ULONG)LdtAddress + selector),
                      pdte, sizeof(VDMLDT_ENTRY));

    // Now do a special hack for the period of time during dpmi
    // init where the LDT moves. This would all be unecessary if
    // we just were to get the ldt base from VDMDBG, which knows
    // everything.
    if (((ULONG)LdtAddress)-GetIntelBase() < 0x100000) {
        LdtAddress = NULL;  // forget the value again
    }

    return Status;
}

BOOL
ReadMemExpression(
    LPSTR expr,
    LPVOID buffer,
    ULONG len
    )
{
    PVOID pMem;

    pMem = (PVOID)(*GetExpression)(expr);
    if (!pMem) {
        PRINTF("Can't find symbol %s\n", expr);
        return FALSE;
    }

    if (!READMEM(pMem, buffer, len)) {
        PRINTF("Error reading memory\n");
        return FALSE;
    }

    return TRUE;
}


ULONG GetInfoFromSelector(
    WORD                    selector,
    int                     mode,
    SELECTORINFO            *si
) {

    ULONG                   base;
    ULONG                   type;
    VDMLDT_ENTRY            dte;

    switch( mode ) {
    case V86_MODE:
        base = (ULONG)selector << 4;
        if ( si ) {
            si->Limit = 0xFFFFL;
            si->Base = (ULONG)selector << 4;
            si->bCode = FALSE;
            si->bBig = FALSE;
            si->bExpandDown = FALSE;
            si->bWrite = TRUE;
            si->bPresent = TRUE;
        }
        break;
    case PROT_MODE:

        if ( !GetDescriptorData(selector, &dte) ) {
            return( (ULONG)-1 );
        }

        base =   ((ULONG)dte.HighWord.Bytes.BaseHi << 24)
               + ((ULONG)dte.HighWord.Bytes.BaseMid << 16)
               + ((ULONG)dte.BaseLow);

        if ( si ) {
            si->Limit =  (ULONG)dte.LimitLow
                      + ((ULONG)dte.HighWord.Bits.LimitHi << 16);

            if ( dte.HighWord.Bits.Granularity ) {
                si->Limit <<= 12;
                si->Limit += 0xFFF;
            }
            si->Base = base;

            type = dte.HighWord.Bits.Type;

            si->bSystem = !(BOOL) (type & 0x10);

            if (!si->bSystem) {
                si->bCode = (BOOL) (type & 8);
            }
            si->bAccessed = (BOOL) (type & 1);
            si->bWrite =    (BOOL) (type & 2);
            if (si->bCode) {
                si->bWrite = !si->bWrite;

            }

            si->bExpandDown = FALSE;
            if (!si->bSystem && !si->bCode) {
                si->bExpandDown = (BOOL) (type & 4);
            }

            si->bPresent =  (BOOL) dte.HighWord.Bits.Pres;
            si->bBig =  (BOOL) dte.HighWord.Bits.Default_Big;

        }

        break;

    case FLAT_MODE:
        PRINTF("Unsupported determination of base address in flat mode\n");
        base = 0;
        break;
    }

    return( base );
}


BOOL
InVdmPrompt(
    VOID
    )

{
    ULONG pTmp;
    BOOL InVdmDebugger;
    BOOL bReturn = FALSE;


    if ((pTmp = (ULONG)EXPRESSION("ntvdmd!InVdmDebugger"))           &&
        (READMEM((LPVOID) pTmp, &InVdmDebugger, sizeof(BOOL))))  {
        bReturn = InVdmDebugger;
    }

    return bReturn;
}

//****************************************************************************
//
// Command line parsing routines
//
//****************************************************************************
BOOL
SkipToNextWhiteSpace(
    VOID
    )
{
    char ch;
    while ( (ch = *lpArgumentString) != '\0' ) {
        if ( ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n' ) {
            return TRUE;
        }
        lpArgumentString++;
    }
    return FALSE;
}


BOOL
GetNextToken(
    VOID
    )
{
    char ch;

    while ( (ch = *lpArgumentString) != '\0' ) {
        if ( ch != ' ' && ch != '\t' && ch != '\r' && ch != '\n' ) {
            return TRUE;
        }
        lpArgumentString++;
    }
    return FALSE;
}

ULONG
EvaluateToken(
    VOID
    )
{
    char ch;
    LPSTR pTemp;
    ULONG value = 0;

    if (GetNextToken()) {
        pTemp = lpArgumentString;
        SkipToNextWhiteSpace();
        ch = *lpArgumentString;
        *lpArgumentString = 0;
        value = (ULONG) EXPRESSION( pTemp );
        *lpArgumentString = ch;
    }
    return (value);
}

BOOL
IsTokenHex(
    VOID
    )
{

    UCHAR ch;
    LPSTR pTemp;
    BOOL result = TRUE;

    if (GetNextToken()) {
        pTemp = lpArgumentString;
        SkipToNextWhiteSpace();
        lpArgumentString--;

        while(lpArgumentString >= pTemp) {

            ch = *lpArgumentString--;

            if (ch < '0') {
                result = FALSE;
                break;
            }

            if ((ch > '9') && (ch < 'A')) {
                result = FALSE;
                break;
            }

            if ((ch > 'F') && (ch < 'a')) {
                result = FALSE;
                break;
            }

            if (ch > 'f') {
                result = FALSE;
                break;
            }

        }

        lpArgumentString = pTemp;

    }
    return (result);

}


BOOL
RegisterToAsciiValue(
    LPSTR *pszValue,
    LPSTR *pszReg
    )
{
    LPSTR szReg = *pszReg;
    LPSTR szValue = *pszValue;

    if (!_strnicmp(szReg, "ax", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)LOWORD(ThreadContext.Eax), szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "bx", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)LOWORD(ThreadContext.Ebx), szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "cx", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)LOWORD(ThreadContext.Ecx), szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "dx", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)LOWORD(ThreadContext.Edx), szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "si", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)LOWORD(ThreadContext.Esi), szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "di", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)LOWORD(ThreadContext.Edi), szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "sp", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)LOWORD(ThreadContext.Esp), szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "bp", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)LOWORD(ThreadContext.Ebp), szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "ip", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)LOWORD(ThreadContext.Eip), szValue, 16);
        *pszReg += 2;

    } else if (!_strnicmp(szReg, "eax", 3) && !isalpha(szReg[3])) {
        _ultoa(ThreadContext.Eax, szValue, 16);
        *pszReg += 3;
    } else if (!_strnicmp(szReg, "ebx", 3) && !isalpha(szReg[3])) {
        _ultoa(ThreadContext.Ebx, szValue, 16);
        *pszReg += 3;
    } else if (!_strnicmp(szReg, "ecx", 3) && !isalpha(szReg[3])) {
        _ultoa(ThreadContext.Ecx, szValue, 16);
        *pszReg += 3;
    } else if (!_strnicmp(szReg, "edx", 3) && !isalpha(szReg[3])) {
        _ultoa(ThreadContext.Edx, szValue, 16);
        *pszReg += 3;
    } else if (!_strnicmp(szReg, "esi", 3) && !isalpha(szReg[3])) {
        _ultoa(ThreadContext.Esi, szValue, 16);
        *pszReg += 3;
    } else if (!_strnicmp(szReg, "edi", 3) && !isalpha(szReg[3])) {
        _ultoa(ThreadContext.Edi, szValue, 16);
        *pszReg += 3;
    } else if (!_strnicmp(szReg, "esp", 3) && !isalpha(szReg[3])) {
        _ultoa(ThreadContext.Esp, szValue, 16);
        *pszReg += 3;
    } else if (!_strnicmp(szReg, "ebp", 3) && !isalpha(szReg[3])) {
        _ultoa(ThreadContext.Ebp, szValue, 16);
        *pszReg += 3;
    } else if (!_strnicmp(szReg, "eip", 3) && !isalpha(szReg[3])) {
        _ultoa(ThreadContext.Eip, szValue, 16);
        *pszReg += 3;

    } else if (!_strnicmp(szReg, "cs", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)ThreadContext.SegCs, szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "ds", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)ThreadContext.SegDs, szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "es", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)ThreadContext.SegEs, szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "fs", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)ThreadContext.SegFs, szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "gs", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)ThreadContext.SegGs, szValue, 16);
        *pszReg += 2;
    } else if (!_strnicmp(szReg, "ss", 2) && !isalpha(szReg[2])) {
        _ultoa((ULONG)ThreadContext.SegSs, szValue, 16);
        *pszReg += 2;
    } else {
        return FALSE;
    }

//    PRINTF("value = %s\n", szValue);
    while (*szValue) {
        szValue++;
    }
    *pszValue = szValue;
    return TRUE;
}

VOID
ParseForIntelRegisters(
    LPSTR szTarg,
    LPSTR szSrc
    )
{

    while (*szSrc) {
        if (!isalpha(*szSrc)) {
            if (!isdigit(*szSrc)) {
                *szTarg++ = *szSrc++;
                continue;
            }

            while (isalpha(*szSrc) || isdigit(*szSrc)) {
                *szTarg++ = *szSrc++;
            }
            continue;
        }

        if (!RegisterToAsciiValue(&szTarg, &szSrc)) {
            while (isalpha(*szSrc) || isdigit(*szSrc)) {
                *szTarg++ = *szSrc++;
            }
        }

    }
    *szTarg = 0;
}

BOOL
ParseIntelAddress(
    int *pMode,
    WORD *pSelector,
    PULONG pOffset
    )

{
    char sel_text[128], off_text[128];
    char expr_text[256];
    char *colon;
    char *mode_prefix;
    WORD segment;
    char filename[9];

    colon = strchr( lpArgumentString, ':' );
    if ( colon == NULL ) {
        LPSTR pSymbol = lpArgumentString;
        BOOL bResult;
        char chTemp;

        SkipToNextWhiteSpace();
        chTemp = *lpArgumentString;
        *lpArgumentString = 0;

        bResult = FindAddress( pSymbol,
                              filename,
                              &segment,
                              pSelector,
                              pOffset,
                              pMode,
                              FALSE);

        *lpArgumentString = chTemp;

        if (bResult) {
            if (*pMode == NOT_LOADED) {
                PRINTF("Could not determine base of '%s'\n", pSymbol);
                return FALSE;
            } else {
                return TRUE;
            }

        } else {

            PRINTF("Could not find symbol: %s\n", pSymbol);
            return FALSE;
        }
    }

    *pMode = GetContext( &ThreadContext );

    mode_prefix = strchr( lpArgumentString, '&' );
    if ( mode_prefix == NULL ) {

        mode_prefix = strchr( lpArgumentString, '#' );
        if ( mode_prefix != NULL ) {

            if ( mode_prefix != lpArgumentString ) {
                PRINTF("Address must have '&' symbol as the first character\n");
                return FALSE;
            }

            *pMode = PROT_MODE;
            lpArgumentString = mode_prefix+1;
        }

    } else {

        if ( mode_prefix != lpArgumentString ) {
            PRINTF("Address must have '#' symbol as the first character\n");
            return FALSE;
        }
        *pMode = V86_MODE;
        lpArgumentString = mode_prefix+1;

    }

    *colon = '\0';
    strcpy( sel_text, lpArgumentString );
    *colon = ':';
    strcpy( off_text, colon+1 );

    ParseForIntelRegisters(expr_text, sel_text);
    *pSelector = (WORD) EXPRESSION( expr_text );
    ParseForIntelRegisters(expr_text, off_text);
    *pOffset   = (ULONG) EXPRESSION( expr_text );

    SkipToNextWhiteSpace();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\vdmexts.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    vdmexts.h

Abstract:

    This file header defines most of the stuff used in VDMEXTS

Revision History:

    Neil Sandlin (NeilSa) 15-Jan-1996 Merged with vdmexts

--*/


//
// Pointers to WINDBG api
//

extern PWINDBG_OUTPUT_ROUTINE Print;
extern PWINDBG_GET_EXPRESSION GetExpression;
extern PWINDBG_GET_SYMBOL GetSymbol;
extern PWINDBG_DISASM Disassemble;
extern PWINDBG_CHECK_CONTROL_C CheckCtrlC;

extern PWINDBG_READ_PROCESS_MEMORY_ROUTINE  ReadMem;
extern PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE WriteMem;

extern PWINDBG_GET_THREAD_CONTEXT_ROUTINE     ExtGetThreadContext;
extern PWINDBG_SET_THREAD_CONTEXT_ROUTINE     ExtSetThreadContext;
extern PWINDBG_IOCTL_ROUTINE                  ExtIoctl;
extern PWINDBG_STACKTRACE_ROUTINE             ExtStackTrace;

extern HANDLE hCurrentProcess;
extern HANDLE hCurrentThread;
extern LPSTR lpArgumentString;

#define PRINTF          (* Print)
#define EXPRESSION      (* GetExpression)

#define ReadDword(x)     read_dword((ULONG)x, FALSE)
#define ReadWord(x)      read_word ((ULONG)x, FALSE)
#define ReadByte(x)      read_byte ((ULONG)x, FALSE)
#define ReadDwordSafe(x) read_dword((ULONG)x, TRUE)
#define ReadWordSafe(x)  read_word ((ULONG)x, TRUE)
#define ReadByteSafe(x)  read_byte ((ULONG)x, TRUE)
#define ReadGNode32(x,p) read_gnode32((ULONG)x,p,FALSE)
#define ReadGNode32Safe(x,p) read_gnode32((ULONG)x,p,TRUE)

/****** macros common to all versions *******/
#define CMD_ARGLIST  HANDLE CurrentProcess,                 \
                     HANDLE CurrentThread,                  \
                     DWORD CurrentPc,                       \
                     PWINDBG_EXTENSION_APIS pXApis,         \
                     LPSTR ArgumentString

#define CMD_INIT() \
    UNREFERENCED_PARAMETER(CurrentPc);                      \
    hCurrentProcess = CurrentProcess;                       \
    hCurrentThread = CurrentThread;                         \
    lpArgumentString = ArgumentString;                      \
                                                            \
    Print         = pXApis->lpOutputRoutine;                \
    GetSymbol     = pXApis->lpGetSymbolRoutine;             \
    GetExpression = pXApis->lpGetExpressionRoutine;         \
    CheckCtrlC    = pXApis->lpCheckControlCRoutine;         \
                                                            \
    ReadMem       = pXApis->lpReadProcessMemoryRoutine;     \
    WriteMem      = pXApis->lpWriteProcessMemoryRoutine;    \
    ExtGetThreadContext       = pXApis->lpGetThreadContextRoutine;     \
    ExtSetThreadContext       = pXApis->lpSetThreadContextRoutine;     \
    ExtIoctl                  = pXApis->lpIoctlRoutine;                \
    ExtStackTrace             = pXApis->lpStackTraceRoutine;           \


#define READMEM( addr, buff, size ) ReadProcessMem(addr, buff, size)
#define WRITEMEM( addr, buff, size ) WriteProcessMem(addr, buff, size)

#define READMEM_XRET(buff, addr)\
try {\
    READMEM( (LPVOID)(addr), (LPVOID)&(buff), sizeof(buff));\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    Print("ReadProcessMemory Failed !\n");\
    return;\
}


#define READMEM_XRETV(buff, addr, ret)\
try {\
    READMEM((LPVOID) (addr), (LPVOID)&(buff), sizeof(buff));\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    Print("ReadProcessMemory Failed !\n");\
    return ret;\
}


#define WRITEMEM_XRET(addr, buff)\
try {\
    WRITEMEM((LPVOID)(addr), (LPVOID)&(buff), sizeof(buff));\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    Print("WriteProcessMemory Failed !\n");\
    return;\
}

#define WRITEMEM_N_XRET(addr, buff, n)\
try {\
    WRITEMEM((LPVOID)(addr), (LPVOID)(buff), n);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    Print("WriteProcessMemory Failed !\n");\
    return;\
}


#define GETEXPRVALUE(dst, expr, typ) \
{\
   PVOID lpA = (PVOID)GetExpression(expr);\
   READMEM_XRET(dst, lpA);\
}

#define GETEXPRADDR(dst, expr) \
{\
   dst = (PVOID)GetExpression(expr);\
}


#define ASSERT_WOW_PRESENT {                                        \
    if (!EXPRESSION("wow32!gptdTaskHead")) {                        \
        PRINTF("Could not resolve needed symbols for WOW32\n");     \
        return;                                                     \
    }                                                               \
}

#define ASSERT_CHECKED_WOW_PRESENT {                                \
    if (!EXPRESSION("wow32!iCircBuffer")) {                         \
        PRINTF("Could not resolve needed symbols for checked WOW32\n");    \
        return;                                                     \
    }                                                               \
}

#define BEFORE      0
#define AFTER       1

#define RPL_MASK    0x78
#define V86_BITS    0x20000

#define SELECTOR_LDT            0x04
#define SELECTOR_RPL            0x03

#define V86_MODE    0
#define PROT_MODE   1
#define FLAT_MODE   2
#define NOT_LOADED  3

#define CALL_NEAR_RELATIVE   0xE8
#define CALL_NEAR_INDIRECT   0xFF
#define INDIRECT_NEAR_TYPE   0x02
#define CALL_FAR_ABSOLUTE    0x9A
#define CALL_FAR_INDIRECT    0xFF
#define INDIRECT_FAR_TYPE    0x03
#define PUSH_CS              0x0E
#define ADD_SP               0xC483

#define TYPE_BITS            0x38
#define TYPE0                0x00
#define TYPE1                0x08
#define TYPE2                0x10
#define TYPE3                0x18
#define TYPE4                0x20
#define TYPE5                0x28
#define TYPE6                0x30
#define TYPE7                0x38

#define MOD_BITS             0xC0
#define MOD0                 0x00
#define MOD1                 0x40
#define MOD2                 0x80
#define MOD3                 0xC0

#define RM_BITS              0x07
#define RM0                  0x00
#define RM1                  0x01
#define RM2                  0x02
#define RM3                  0x03
#define RM4                  0x04
#define RM5                  0x05
#define RM6                  0x06
#define RM7                  0x07

#define FLAG_OVERFLOW       0x0800
#define FLAG_DIRECTION      0x0400
#define FLAG_INTERRUPT      0x0200
#define FLAG_SIGN           0x0080
#define FLAG_ZERO           0x0040
#define FLAG_AUXILLIARY     0x0010
#define FLAG_PARITY         0x0004
#define FLAG_CARRY          0x0001


typedef struct _SELECTORINFO {
    DWORD Base;
    DWORD Limit;
    BOOL bCode;
    BOOL bSystem;
    BOOL bPresent;
    BOOL bWrite;
    BOOL bAccessed;
    BOOL bBig;
    BOOL bExpandDown;
} SELECTORINFO;

typedef struct _segentry {
    struct _segentry *Next;
    int     type;
    char    szExePath[MAX_PATH16];
    char    szModule[MAX_MODULE_NAME];
    WORD    selector;
    WORD    segment;
    DWORD   length;
} SEGENTRY, *PSEGENTRY;

#define SEGTYPE_V86         1
#define SEGTYPE_PROT        2

#pragma  pack(1)

typedef struct _GNODE32 {     // GlobalArena
   DWORD pga_next      ;    // next arena entry (last points to self)
   DWORD pga_prev      ;    // previous arena entry (first points to self)
   DWORD pga_address   ;    // 32 bit linear address of memory
   DWORD pga_size      ;    // 32 bit size in bytes
   WORD  pga_handle    ;    // back link to handle table entry
   WORD  pga_owner     ;    // Owner field (current task)
   BYTE  pga_count     ;    // lock count for movable segments
   BYTE  pga_pglock    ;    // # times page locked
   BYTE  pga_flags     ;    // 1 word available for flags
   BYTE  pga_selcount  ;    // Number of selectors allocated
   DWORD pga_lruprev   ;    // Previous entry in lru chain
   DWORD pga_lrunext   ;    // Next entry in lru chain
} GNODE32;
typedef GNODE32 UNALIGNED *PGNODE32;

typedef struct _GHI32 {
    WORD  hi_check     ;    // arena check word (non-zero enables heap checking)
    WORD  hi_freeze    ;    // arena frozen word (non-zero prevents compaction)
    WORD  hi_count     ;    // #entries in arena
    WORD  hi_first     ;    // first arena entry (sentinel, always busy)
    WORD  hi_res1      ;    // reserved
    WORD  hi_last      ;    // last arena entry (sentinel, always busy)
    WORD  hi_res2      ;    // reserved
    BYTE  hi_ncompact  ;    // #compactions done so far (max of 3)
    BYTE  hi_dislevel  ;    // current discard level
    DWORD hi_distotal  ;    // total amount discarded so far
    WORD  hi_htable    ;    // head of handle table list
    WORD  hi_hfree     ;    // head of free handle table list
    WORD  hi_hdelta    ;    // #handles to allocate each time
    WORD  hi_hexpand   ;    // address of near procedure to expand handles for this arena
    WORD  hi_pstats    ;    // address of statistics table or zero
} GHI32;
typedef GHI32 UNALIGNED *PGHI32;

typedef struct _HEAPENTRY {
    GNODE32 gnode;
    DWORD CurrentEntry;
    DWORD NextEntry;
    WORD Selector;
    int  SegmentNumber;
    char OwnerName[9];
    char FileName[9];
    char ModuleArg[9];
} HEAPENTRY;

typedef struct _NEHEADER {
    WORD ne_magic       ;
    BYTE ne_ver         ;
    BYTE ne_rev         ;
    WORD ne_enttab      ;
    WORD ne_cbenttab    ;
    DWORD ne_crc        ;
    WORD ne_flags       ;
    WORD ne_autodata    ;
    WORD ne_heap        ;
    WORD ne_stack       ;
    DWORD ne_csip       ;
    DWORD ne_sssp       ;
    WORD ne_cseg        ;
    WORD ne_cmod        ;
    WORD ne_cbnrestab   ;
    WORD ne_segtab      ;
    WORD ne_rsrctab     ;
    WORD ne_restab      ;
    WORD ne_modtab      ;
    WORD ne_imptab      ;
    DWORD ne_nrestab    ;
    WORD ne_cmovent     ;
    WORD ne_align       ;
    WORD ne_cres        ;
    BYTE ne_exetyp      ;
    BYTE ne_flagsothers ;
    WORD ne_pretthunks  ;
    WORD ne_psegrefbytes;
    WORD ne_swaparea    ;
    WORD ne_expver      ;
} NEHEADER;
typedef NEHEADER UNALIGNED *PNEHEADER;

#pragma  pack()


#ifndef i386

//
// Structures in 486 cpu for obtaining registers (FROM NT_CPU.C)
//

typedef struct NT_CPU_REG {
    ULONG *nano_reg;         /* where the nano CPU keeps the register */
    ULONG *reg;              /* where the light compiler keeps the reg */
    ULONG *saved_reg;        /* where currently unused bits are kept */
    ULONG universe_8bit_mask;/* is register in 8-bit form? */
    ULONG universe_16bit_mask;/* is register in 16-bit form? */
} NT_CPU_REG;

typedef struct NT_CPU_INFO {
    /* Variables for deciding what mode we're in */
    BOOL *in_nano_cpu;      /* is the Nano CPU executing? */
    ULONG *universe;         /* the mode that the CPU is in */

    /* General purpose register pointers */
    NT_CPU_REG eax, ebx, ecx, edx, esi, edi, ebp;

    /* Variables for getting SP or ESP. */
    BOOL *stack_is_big;     /* is the stack 32-bit? */
    ULONG *nano_esp;         /* where the Nano CPU keeps ESP */
    UCHAR **host_sp;          /* ptr to variable holding stack pointer as a
                               host address */
    UCHAR **ss_base;          /* ptr to variables holding base of SS as a
                               host address */
    ULONG *esp_sanctuary;    /* top 16 bits of ESP if we're now using SP */

    ULONG *eip;

    /* Segment registers. */
    USHORT *cs, *ds, *es, *fs, *gs, *ss;

    ULONG *flags;

    /* CR0, mainly to let us figure out if we're in real or protect mode */
    ULONG *cr0;
} NT_CPU_INFO;


#endif // i386



BOOL
WINAPI
ReadProcessMem(
    LPVOID lpBaseAddress,
    LPVOID lpBuffer,
    DWORD nSize
    );

BOOL
WINAPI
WriteProcessMem(
    LPVOID lpBaseAddress,
    LPVOID lpBuffer,
    DWORD nSize
    );

BOOL
ReadMemExpression(
    LPSTR expr,
    LPVOID buffer,
    ULONG len
    );

BOOL
CheckGlobalHeap(
    BOOL bVerbose
    );

int GetContext(
    VDMCONTEXT* lpContext
);

ULONG GetInfoFromSelector(
    WORD                    selector,
    int                     mode,
    SELECTORINFO            *si
);

BOOL
FindHeapEntry(
    HEAPENTRY *he,
    UINT FindMethod,
    BOOL bVerbose
    );

#define FHE_FIND_ANY 0
#define FHE_FIND_SEL_ONLY 1
#define FHE_FIND_MOD_ONLY 2

#define FHE_FIND_QUIET FALSE
#define FHE_FIND_VERBOSE TRUE

BOOL
FindAddress(
    LPSTR       sym_text,
    LPSTR       filename,
    WORD        *psegment,
    WORD        *pselector,
    LONG        *poffset,
    int         *pmode,
    BOOL        bDumpAll
    );

BOOL FindSymbol(
    WORD        selector,
    LONG        offset,
    LPSTR       sym_text,
    LONG        *dist,
    int         direction,
    int         mode
);

int
unassemble_one(
    BYTE *pInstrStart,
    BOOL bDefaultBig,
    WORD wInstrSeg,
    DWORD dwInstrOff,
    char *pchOutput,
    char *pchExtra,
    VDMCONTEXT *pThreadContext,
    int mode
    );


ULONG GetIntelBase(
    VOID
);

DWORD read_dword(
    ULONG   lpAddress,
    BOOL    bSafe
);

WORD read_word(
    ULONG   lpAddress,
    BOOL    bSafe
);

BYTE read_byte(
    ULONG   lpAddress,
    BOOL    bSafe
);

BOOL read_gnode32(
    ULONG   lpAddress,
    PGNODE32  p,
    BOOL    bSafe
);

BOOL GetNextToken(
    VOID
    );

ULONG EvaluateToken(
    VOID
    );

VOID helpAPIProfDmp(
    VOID
    );

VOID helpMsgProfDmp(
    VOID
    );

BOOL
InVdmPrompt(
    VOID
    );

BOOL ParseIntelAddress(
    int *pMode,
    WORD *pSelector,
    PULONG pOffset
    );

VOID
ParseModuleName(
    LPSTR szName,
    LPSTR szPath
    );

VOID
EnableDebuggerBreakpoints(
    VOID
    );

BOOL
IsVdmBreakPoint(
    USHORT selector,
    ULONG offset,
    BOOL bProt,
    PULONG pBpNum,
    PUCHAR pBpData
    );

BOOL
LoadBreakPointCache(
    VOID
    );

BOOL
SkipToNextWhiteSpace(
    VOID
    );

BOOL
IsTokenHex(
    VOID
    );

PSEGENTRY
GetSegtablePointer(
    VOID
    );

VOID Drp (VOID);
VOID Erp (VOID);
VOID EventInfop (VOID);
VOID ProfDumpp (VOID);
VOID ProfIntp (VOID);
VOID ProfStartp (VOID);
VOID ProfStopp (VOID);
VOID VdmTibp (VOID);
VOID Fpup (VOID);
BOOL DumpEnvironment(WORD segEnv, int mode);
ULONG GetCurrentVdmTib(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\wowprof.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* This file is for debugging tools and extensions.
*
* Created: 24-Jan-1992
* Author: John Colleran
*
* History:
* Feb 17 92 Matt Felton (mattfe) lots of additional exentions for filtering
* Jul 13 92 (v-cjones) Added API & MSG profiling debugger extensions, fixed
*                      other extensions to handle segment motion correctly,
*                      & cleaned up the file in general
* Jan 3 96 Neil Sandlin (neilsa) integrated this routine into vdmexts
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <wmdisp32.h>
#include <wcuricon.h>
#include <wucomm.h>


INT     cAPIThunks;

//
// WARNING: The following code was copied from WOWTBL.C
//
typedef struct {
        WORD    kernel;
        WORD    dkernel;
        WORD    user;
        WORD    duser;
        WORD    gdi;
        WORD    dgdi;
        WORD    keyboard;
        WORD    sound;
        WORD    shell;
        WORD    winsock;
        WORD    toolhelp;
        WORD    mmedia;
        WORD    commdlg;
#ifdef FE_IME
        WORD    winnls;
#endif // FE_IME
#ifdef FE_SB
        WORD    wifeman;
#endif // FE_SB
} TABLEOFFSETS;
typedef TABLEOFFSETS UNALIGNED *PTABLEOFFSETS;

TABLEOFFSETS tableoffsets;

INT TableOffsetFromName(PSZ szTab);


INT ModFromCallID(INT iFun)
{
    PTABLEOFFSETS pto = &tableoffsets;
    LPVOID lpAddress;

    GETEXPRADDR(lpAddress, "wow32!tableoffsets");
    READMEM(lpAddress, &tableoffsets, sizeof(TABLEOFFSETS));

    if (iFun < pto->user)
                return MOD_KERNEL;

    if (iFun < pto->gdi)
                return MOD_USER;

    if (iFun < pto->keyboard)
                return MOD_GDI;

    if (iFun < pto->sound)
                return MOD_KEYBOARD;

    if (iFun < pto->shell)
                return MOD_SOUND;

    if (iFun < pto->winsock)
                return MOD_SHELL;

    if (iFun < pto->toolhelp)
                return MOD_WINSOCK;

    if (iFun < pto->mmedia)
                return MOD_TOOLHELP;

    if (iFun < pto->commdlg) {
                return(MOD_MMEDIA);
                    }

#if defined(FE_SB)
  #if defined(FE_IME)
    if (iFun < pto->winnls)
        return MOD_COMMDLG;
    if (iFun < pto->wifeman)
        return MOD_WINNLS;
    if (iFun < cAPIThunks)
        return MOD_WIFEMAN;
  #else
    if (iFun < pto->wifeman)
        return MOD_COMMDLG;
    if (iFun < cAPIThunks)
        return MOD_WIFEMAN;
  #endif
#elif defined(FE_IME)
    if (iFun < pto->winnls)
        return MOD_COMMDLG;
    if (iFun < cAPIThunks)
        return MOD_WINNLS;
#else
    if (iFun < cAPIThunks)
        return MOD_COMMDLG;
#endif

    return -1;
}



PSZ apszModNames[] = { "Kernel",
                       "User",
                       "Gdi",
                       "Keyboard",
                       "Sound",
                       "Shell",
                       "Winsock",
                       "Toolhelp",
                       "MMedia",
                       "Commdlg"
#ifdef FE_IME
                       ,"WinNLS"
#endif
#ifdef FE_SB
                       ,"WifeMan"
#endif
                       };

INT nModNames = NUMEL(apszModNames);

PSZ GetModName(INT iFun)
{
    INT nMod;

    nMod = ModFromCallID(iFun);

    if (nMod == -1) {
        return "BOGUS!!";
    }

    nMod = nMod >> 12;      // get the value into the low byte

    return apszModNames[nMod];

}

INT GetOrdinal(INT iFun)
{
    INT nMod;

    nMod = ModFromCallID(iFun);

    if (nMod == -1) {
        return 0;
    }

    return (iFun - TableOffsetFromName(apszModNames[nMod >> 12]));

}

INT TableOffsetFromName(PSZ szTab)
{
    INT     i;
    PTABLEOFFSETS pto = &tableoffsets;

    for (i = 0; i < NUMEL(apszModNames); i++) {
        if (!strcmp(szTab, apszModNames[i]))
            break;
    }

    if (i >= NUMEL(apszModNames))
        return 0;

    switch (i << 12) {

    case MOD_KERNEL:
        return pto->kernel;

    case MOD_USER:
        return pto->user;

    case MOD_DGDI:
        return pto->gdi;

    case MOD_KEYBOARD:
        return pto->keyboard;

    case MOD_SOUND:
        return pto->sound;

    case MOD_SHELL:
        return pto->shell;

    case MOD_WINSOCK:
        return pto->winsock;

    case MOD_TOOLHELP:
        return pto->toolhelp;

    case MOD_MMEDIA:
        return pto->mmedia;

    case MOD_COMMDLG:
        return(pto->commdlg);

#ifdef FE_IME
    case MOD_WINNLS:
        return pto->winnls;
#endif

#ifdef FE_SB
    case MOD_WIFEMAN:
        return pto->wifeman;
#endif

    default:
        return(-1);
    }

}

/********* local functions for WOWPROFILE support *********/

/******* function protoypes for local functions for WOWPROFILE support *******/
BOOL  WDGetAPIProfArgs(LPSZ  lpszArgStr,
                       INT   iThkTblMax,
                       PPA32 ppaThkTbls,
                       LPSZ  lpszTab,
                       BOOL *bTblAll,
                       LPSZ  lpszFun,
                       int  *iFunInd);

BOOL  WDGetMSGProfArgs(LPSZ lpszArgStr,
                       LPSZ lpszMsg,
                       int *iMsgNum);

INT   WDParseArgStr(LPSZ lpszArgStr, CHAR **argv, INT iMax);






BOOL WDGetAPIProfArgs(LPSZ lpszArgStr,
                      INT   iThkTblMax,
                      PPA32 ppaThkTbls,
                      LPSZ lpszTab,
                      BOOL *bTblAll,
                      LPSZ lpszFun,
                      int  *iFunInd) {
/*
 * Decomposes & interprets argument string to apiprofdmp extension.
 *  INPUT:
 *   lpszArgStr - ptr to input arg string
 *   iThkTblMax - # tables in the thunk tables
 *   ppaThkTbls - ptr to the thunk tables
 *  OUTPUT:
 *   lpszTab    - ptr to table name
 *   bTblAll    -  0 => dump specific table, 1 => dump all tables
 *   lpszFun    - ptr to API name
 *   iFunInd    - -1 => dump specific API name
 *                 0 => dump all API entires in table
 *                >0 => dump specific API number (decimal)
 *  RETURN: 0 => OK,  1 => input error (show Usage)
 *
 *  legal forms:  !wow32.apiprofdmp
 *                !wow32.apiprofdmp user
 *                !wow32.apiprofdmp user createwindow
 *                !wow32.apiprofdmp user 41
 *                !wow32.apiprofdmp createwindow
 *                !wow32.apiprofdmp 41
 */
    INT   i, nArgs;
    CHAR *argv[2];


    nArgs = WDParseArgStr(lpszArgStr, argv, 2);

    /* if no arguments dump all entries in all tables */
    if( nArgs == 0 ) {
        *iFunInd = 0;    // specify dump all API entires in the table
        *bTblAll = 1;    // specify dump all tables
        return(0);
    }


    /* see if 1st arg is a table name */
    *bTblAll = 1;  // specify dump all tables


    for (i = 0; i < nModNames; i++) {
        if (!lstrcmpi(apszModNames[i], argv[0])) {

            lstrcpy(lpszTab, apszModNames[i]);
            *bTblAll = 0;  // specify dump specific table

            /* if we got a table name match & only one arg, we're done */
            if( nArgs == 1 ) {
                *iFunInd = 0; // specify dump all API entries in the table
                return(0);
            }
            break;
        }
    }

#if 0
    for(i = 0; i < iThkTblMax; i++) {
        CHAR  temp[40], *TblEnt[2], szTabName[40];
        PA32  awThkTbl;

        /* get table name string from thunk tables */
        READMEM_XRETV(awThkTbl,  &ppaThkTbls[i], 0);
        READMEM_XRETV(szTabName, awThkTbl.lpszW32, 0);

        /* get rid of trailing spaces from table name string */
        lstrcpy(temp, szTabName);
        WDParseArgStr(temp, TblEnt, 1);

        /* if we found a table name that matches the 1st arg...*/
        if( !lstrcmpi(argv[0], TblEnt[0]) ) {

            lstrcpy(lpszTab, szTabName);
            *bTblAll = 0;  // specify dump specific table

            /* if we got a table name match & only one arg, we're done */
            if( nArgs == 1 ) {
                *iFunInd = 0; // specify dump all API entries in the table
                return(0);
            }
            break;
        }
    }
#endif

    /* if 2 args && the 1st doesn't match a table name above => bad input */
    if( (nArgs > 1) && (*bTblAll) ) {
        return(1);
    }

    /* set index to API spec */
    nArgs--;

    /* try to convert API spec to a number */
    *iFunInd = atoi(argv[nArgs]);
    lstrcpy(lpszFun, argv[nArgs]);

    /* if API spec is not a number => it's a name */
    if( *iFunInd == 0 ) {
        *iFunInd = -1;  // specify API search by name
    }

    /* else if API number is bogus -- complain */
    else if( *iFunInd < 0 ) {
        return(1);
    }

    return(0);

}




BOOL  WDGetMSGProfArgs(LPSZ lpszArgStr,
                       LPSZ lpszMsg,
                       int *iMsgNum) {
/*
 * Decomposes & interprets argument string to msgprofdmp extension.
 *  INPUT:
 *   lpszArgStr - ptr to input arg string
 *  OUTPUT:
 *   lpszMsg    - ptr to message name
 *   iMsgNum    - -1  => dump all message entries in the table
 *                -2  => lpszMsg contains specific MSG name
 *                >=0 => dump specific message number
 *  RETURN: 0 => OK,  1 => input error (show Usage)
 */
    INT   nArgs;
    CHAR *argv[2];


    nArgs = WDParseArgStr(lpszArgStr, argv, 1);

    /* if no arguments dump all entries in all tables */
    if( nArgs == 0 ) {
        *iMsgNum = -1;    // specify dump all MSG entires in the table
        return(0);
    }

    if( !_strnicmp(argv[0], "HELP",5) )
        return(1);

    /* try to convert MSG spec to a number */
    *iMsgNum = atoi(argv[0]);
    lstrcpy(lpszMsg, argv[0]);

    /* if MSG spec is not a number => it's a name */
    if( *iMsgNum == 0 ) {
        *iMsgNum = -2;  // specify lpszMsg contains name to search for
    }

    /* else if MSG number is bogus -- complain */
    else if( *iMsgNum < 0 ) {
        return(1);
    }

    return(0);
}




/******* API profiler table functions ********/

/* init some common strings */
CHAR szAPI[]    = "API#                       API Name";
CHAR szMSG[]    = "MSG #                      MSG Name";
CHAR szTITLES[] = "# Calls     Tot. tics        tics/call";
CHAR szDASHES[] = "-----------------------------------  -------  ---------------  ---------------";
CHAR szTOOBIG[] = "too large for table.";
CHAR szNOTUSED[]  = "Unused table index.";
CHAR szRNDTRIP[] = "Round trip message profiling";
CHAR szCLEAR[]   = "Remember to clear the message profile tables.";


VOID
apiprofclr(
    CMD_ARGLIST
    )
{
    int    iTab, iFun, iEntries;
    INT    iThkTblMax;
    W32    awAPIEntry;
    PW32   pawAPIEntryTbl;
    PA32   awThkTbl;
    PPA32  ppaThkTbls;
    CHAR   szTable[20];

    CMD_INIT();
    ASSERT_CHECKED_WOW_PRESENT;

    GETEXPRVALUE(iThkTblMax, "wow32!iThunkTableMax", INT);
    GETEXPRVALUE(ppaThkTbls, "wow32!pawThunkTables", PPA32);

    PRINTF("Clearing:");

    for(iTab = 0; iTab < iThkTblMax; iTab++) {

        READMEM_XRET(awThkTbl, &ppaThkTbls[iTab]);
        READMEM_XRET(szTable,  awThkTbl.lpszW32);
        PRINTF(" %s",  szTable);

        pawAPIEntryTbl = awThkTbl.lpfnA32;
        READMEM_XRET(iEntries, awThkTbl.lpiFunMax);
        for(iFun = 0; iFun < iEntries; iFun++) {
            READMEM_XRET(awAPIEntry, &pawAPIEntryTbl[iFun]);
            awAPIEntry.cCalls = 0L;
            awAPIEntry.cTics  = 0I64;
            WRITEMEM_XRET(&pawAPIEntryTbl[iFun], awAPIEntry);
        }
    }
    PRINTF("\n");

    return;
}




VOID
apiprofdmp(
    CMD_ARGLIST
    )
{
    BOOL    bTblAll, bFound;
    int     i, iFun, iFunInd;
    INT     iThkTblMax;
    W32     awAPIEntry;
    PW32    pawAPIEntryTbl;
    PA32    awThkTbl;
    PPA32   ppaThkTbls;
    CHAR    szTab[20], szFun[40], szTable[20], szFunName[40];

    CMD_INIT();
    ASSERT_CHECKED_WOW_PRESENT;

    GETEXPRVALUE(iThkTblMax, "wow32!iThunkTableMax", INT);
    GETEXPRVALUE(ppaThkTbls, "wow32!pawThunkTables", PPA32);
    GETEXPRVALUE(cAPIThunks, "wow32!cAPIThunks", INT);

    GETEXPRVALUE(i, "wow32!nModNames", INT);
    if (i != nModNames) {
        PRINTF("Error: mismatch of nModNames in apiprofdmp.\nExtension is out of date\n");
        return;
    }

    if( WDGetAPIProfArgs(lpArgumentString,
                         iThkTblMax,
                         ppaThkTbls,
                         szTab,
                         &bTblAll,
                         szFun,
                         &iFunInd) ) {
        helpAPIProfDmp();
        return;
    }

    bFound = FALSE;


#if 0
    for(iTab = 0; iTab < iThkTblMax; iTab++) {

        READMEM_XRET(awThkTbl, &ppaThkTbls[iTab]);
        READMEM_XRET(szTable,  awThkTbl.lpszW32);


        /* if dump all tables || dump this specific table */

       if( bTblAll || !lstrcmp(szTab, szTable) ) {

            pawAPIEntryTbl = awThkTbl.lpfnA32;
#endif
    for (i = 0; i < nModNames; i++) {

        READMEM_XRET(awThkTbl, &ppaThkTbls[0]);
        lstrcpy(szTable, apszModNames[i]);

        /* if dump all tables || dump this specific table */

        if (bTblAll || !lstrcmpi(szTab, apszModNames[i])) {

            INT    nFirst, nLast;

            nFirst = TableOffsetFromName(apszModNames[i]);
            if (i < nModNames - 1)
                nLast = TableOffsetFromName(apszModNames[i+1]) - 1;
            else
                nLast = cAPIThunks - 1;

            pawAPIEntryTbl = awThkTbl.lpfnA32;

            /* if dump a specific API number */
            if( iFunInd > 0 ) {
                PRINTF("\n>>>> %s\n", szTable);
                PRINTF("%s  %s\n%s\n", szAPI, szTITLES, szDASHES);
                //if( iFunInd >= *(awThkTbl.lpiFunMax) ) {
                if( iFunInd > nLast - nFirst ) {
                    PRINTF("Index #%d %s.\n", GetOrdinal(iFunInd), szTOOBIG);
                }
                else {
                    bFound = TRUE;
                //    READMEM_XRET(awAPIEntry, &pawAPIEntryTbl[iFunInd]);
                    READMEM_XRET(awAPIEntry, &pawAPIEntryTbl[nFirst + iFunInd]);
                    READMEM_XRET(szFunName, awAPIEntry.lpszW32);
                    if( szFunName[0] ) {
                        PRINTF("%4d %30s  ", GetOrdinal(iFunInd), szFunName);
                    }
                    else {
                        PRINTF("%4d %30s  ", GetOrdinal(iFunInd), szNOTUSED);
                    }
                    PRINTF("%7ld  %15I64d  ", awAPIEntry.cCalls, awAPIEntry.cTics);
                    if(awAPIEntry.cCalls) {
                        PRINTF("%15I64d\n", awAPIEntry.cTics/awAPIEntry.cCalls);
                    } else {
                        PRINTF("%15ld\n", 0L);
                    }
                }
            }

            /* else if dump an API by name */
            else if ( iFunInd == -1 ) {
              //  READMEM_XRET(iEntries, awThkTbl.lpiFunMax);
              //   for(iFun = 0; iFun < iEntries; iFun++) {
                for(iFun = nFirst; iFun <= nLast; iFun++) {
                    READMEM_XRET(awAPIEntry, &pawAPIEntryTbl[iFun]);
                    READMEM_XRET(szFunName,  awAPIEntry.lpszW32);
                    if ( !lstrcmpi(szFun, szFunName) ) {
                        PRINTF("\n>>>> %s\n", szTable);
                        PRINTF("%s  %s\n%s\n", szAPI, szTITLES, szDASHES);
                        PRINTF("%4d %30s  %7ld  %15I64d  ",
                              GetOrdinal(iFun),
                              szFunName,
                              awAPIEntry.cCalls,
                              awAPIEntry.cTics);
                        if(awAPIEntry.cCalls) {
                            PRINTF("%15I64d\n", awAPIEntry.cTics/awAPIEntry.cCalls);
                        } else {
                            PRINTF("%15ld\n",  0L);
                        }
                        return;
                    }
                }
            }

            /* else dump all the API's in the table */
            else {
                PRINTF("\n>>>> %s\n", szTable);
                PRINTF("%s  %s\n%s\n", szAPI, szTITLES, szDASHES);
                bFound = TRUE;
              //  READMEM_XRET(iEntries, awThkTbl.lpiFunMax);
              //  for(iFun = 0; iFun < iEntries; iFun++) {
                for(iFun = nFirst; iFun <= nLast; iFun++) {
                    READMEM_XRET(awAPIEntry, &pawAPIEntryTbl[iFun]);
                    READMEM_XRET(szFunName,  awAPIEntry.lpszW32);
                    if(awAPIEntry.cCalls) {
                        PRINTF("%4d %30s  %7ld  %15I64d  %15I64d\n",
                              GetOrdinal(iFun),
                              szFunName,
                              awAPIEntry.cCalls,
                              awAPIEntry.cTics,
                              awAPIEntry.cTics/awAPIEntry.cCalls);
                    }
                }
                if( !bTblAll ) {
                    return;
                }
            }
        }
    }
    if( !bFound ) {
        PRINTF("\nCould not find ");
        if( !bTblAll ) {
            PRINTF("%s ", szTab);
        }
        PRINTF("API: %s\n", szFun);
        helpAPIProfDmp();
    }

    return;
}




/******* MSG profiler table functions ********/

VOID
msgprofclr(
    CMD_ARGLIST
    )
{
    int     iMsg;
    INT     iMsgMax;
    M32     awM32;
    PM32    paw32Msg;

    CMD_INIT();
    ASSERT_CHECKED_WOW_PRESENT;

    GETEXPRVALUE(iMsgMax, "wow32!iMsgMax", INT);
    GETEXPRVALUE(paw32Msg, "wow32!paw32Msg", PM32);

    PRINTF("Clearing Message profile table");


    for(iMsg = 0; iMsg < iMsgMax; iMsg++) {
        READMEM_XRET(awM32, &paw32Msg[iMsg]);
        awM32.cCalls = 0L;
        awM32.cTics  = 0I64;
        WRITEMEM_XRET(&paw32Msg[iMsg], awM32);
    }

    PRINTF("\n");

    return;
}



VOID
msgprofdmp(
    CMD_ARGLIST
    )
{
    int     iMsg, iMsgNum;
    INT     iMsgMax;
    BOOL    bFound;
    M32     aw32Msg;
    PM32    paw32Msg;
    CHAR    szMsg[40], *argv[2], szMsg32[40], szMsgName[40];

    CMD_INIT();
    ASSERT_CHECKED_WOW_PRESENT;

    GETEXPRVALUE(iMsgMax, "wow32!iMsgMax", INT);
    GETEXPRVALUE(paw32Msg, "wow32!paw32Msg", PM32);

    if( WDGetMSGProfArgs(lpArgumentString, szMsg, &iMsgNum) ) {
        helpMsgProfDmp();
        return;
    }

    PRINTF("%s  %s\n%s\n", szMSG, szTITLES, szDASHES);

    if( iMsgNum > iMsgMax ) {
        PRINTF("MSG #%4d %s.\n", iMsgNum, szTOOBIG);
        return;
    }

    bFound = 0;
    for(iMsg = 0; iMsg < iMsgMax; iMsg++) {

        READMEM_XRET(aw32Msg,   &paw32Msg[iMsg]);
        READMEM_XRET(szMsgName, aw32Msg.lpszW32);

        /* if specific msg name, parse name from "WM_MSGNAME 0x00XX" format */
        if( iMsgNum == -2 ) {
            lstrcpy(szMsg32, szMsgName);
            WDParseArgStr(szMsg32, argv, 1);
        }

        /* if 'all' msgs || specific msg # || specific msg name */
        if( (iMsgNum == -1) || (iMsg == iMsgNum) ||
            ( (iMsgNum == -2) && (!lstrcmp(szMsg, argv[0])) ) ) {
            bFound = 1;
            if(aw32Msg.cCalls) {
                PRINTF("0x%-4X %28s  %7ld  %15I64d  %15I64d\n",
                       iMsg,
                       szMsgName,
                       aw32Msg.cCalls,
                       aw32Msg.cTics,
                       aw32Msg.cTics/aw32Msg.cCalls);
            }
            /* else if MSG wasn't sent & we're not dumping the whole table */
            else if( iMsgNum != -1 ) {
                PRINTF("0x%-4X %28s  %7ld  %15ld  %15ld\n",
                       iMsgNum,
                       szMsgName,
                       0L,
                       0L,
                       0L);
            }

            /* if we're not dumping the whole table, we're done */
            if( iMsgNum != -1 ) {
                return;
            }
        }
    }
    if( !bFound ) {
        PRINTF("\nCould not find MSG: %s\n", szMsg);
        helpMsgProfDmp();
    }

    return;
}



void
msgprofrt(
    CMD_ARGLIST
    )
{
    INT     fWMsgProfRT;
    LPVOID  lpAddress;

    CMD_INIT();
    ASSERT_CHECKED_WOW_PRESENT;

    GETEXPRADDR(lpAddress, "wow32!fWMsgProfRT");

    READMEM_XRET(fWMsgProfRT, lpAddress);
    fWMsgProfRT = 1 - fWMsgProfRT;
    WRITEMEM_XRET(lpAddress, fWMsgProfRT);

    if( fWMsgProfRT ) {
        PRINTF("\n%s ENABLED.\n%s\n\n", szRNDTRIP, szCLEAR);
    }
    else {
        PRINTF("\n%s DISABLED.\n%s\n\n", szRNDTRIP, szCLEAR);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\i386\regs.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Registers.c

Abstract:

    This module contains routines for manipulating registers.

Author:

    Dave Hastings (daveh) 1-Apr-1992

Notes:

    The routines in this module assume that the pointers to the ntsd
    routines have already been set up.

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop
#include <stdio.h>

const char *FpuTagNames[] = {
    "Valid",
    "Zero",
    "Special",
    "Empty"
};

VOID
PrintContext(
    IN PCONTEXT Context
    );

VOID
IntelRegistersp(
    VOID
    )
/*++

Routine Description:

    This routine dumps out the 16 bit register set from the vdmtib


Arguments:

    None.

Return Value:

    None.

Notes:

    This routine assumes that the pointers to the ntsd routines have already
    been set up.

--*/
{
    BOOL Status;
    ULONG Address;
    CONTEXT IntelRegisters;

    //
    // Get the address of the VdmTib
    //

    if (sscanf(lpArgumentString, "%lx", &Address) <= 0) {
        Address = GetCurrentVdmTib();
    }

    if (!Address) {
        (*Print)("Error geting VdmTib address\n");
        return;
    }

    //
    // Read the 16 bit context
    //

    Status = READMEM(
        &(((PVDM_TIB)Address)->VdmContext),
        &IntelRegisters,
        sizeof(CONTEXT)
        );

    if (!Status) {
        GetLastError();
        (*Print)("Could not get VdmContext\n");
    } else {
        PrintContext(&IntelRegisters);
    }
}

VOID
PrintContext(
    IN PCONTEXT Context
    )
/*++

Routine Description:

    This routine dumps out a context.

Arguments:

    Context -- Supplies a pointer to the context to dump

Return Value:

    None.

--*/
{
    (*Print)(
        "eax=%08lx ebx=%08lx ecx=%08lx edx=%08lx esi=%08lx edi=%08lx\n",
        Context->Eax,
        Context->Ebx,
        Context->Ecx,
        Context->Edx,
        Context->Esi,
        Context->Edi
        );

    (*Print)(
        "eip=%08lx esp=%08lx ebp=%08lx\n",
        Context->Eip,
        Context->Esp,
        Context->Ebp
        );

    (*Print)(
        "cs=%04x  ss=%04x  ds=%04x  es=%04x  fs=%04x  gs=%04x  eflags=%08x\n",
        Context->SegCs,
        Context->SegSs,
        Context->SegDs,
        Context->SegEs,
        Context->SegFs,
        Context->SegGs,
        Context->EFlags
        );
}

VOID
Fpup(
    VOID
    )
/*++

Routine Description:

    This routine dumps out the x86 floating-point state.


Arguments:

    None.

Return Value:

    None.

Notes:

    This routine assumes that the pointers to the ntsd routines have already
    been set up.

--*/
{
    CONTEXT IntelRegisters;
    USHORT Temp;
    int RegNum;

    //
    // Read the thread's context
    //
    IntelRegisters.ContextFlags = CONTEXT_FLOATING_POINT;
    if (GetThreadContext(hCurrentThread, &IntelRegisters) == FALSE) {
        GetLastError();
        (*Print)("Could not get 32-bit thread context\n");
        return;
    };

    Temp = (USHORT)IntelRegisters.FloatSave.ControlWord;
    (*Print)(" Control word = %X\n", Temp);

    (*Print)(
        "  Infinity = %d  Rounding = %d  Precision = %d     PM=%d UM=%d OM=%d ZM=%d DM=%d IM=%d\n",
        (Temp >> 11) & 1,       // Infinity
        (Temp >> 9) & 3,        // Rounding (2 bits)
        (Temp >> 7) & 3,        // Precision (2 bits)
        (Temp >> 5) & 1,        // Precision Exception Mask
        (Temp >> 4) & 1,        // Underflow Exception Mask
        (Temp >> 3) & 1,        // Overflow Exception Mask
        (Temp >> 2) & 1,        // Zero Divide Exception Mask
        (Temp >> 1) & 1,        // Denormalized Operand Exception Mask
        Temp & 1                // Invalid Operation Exception Mask
        );

    Temp = (USHORT)IntelRegisters.FloatSave.StatusWord;
    (*Print)(" Status word = %X\n", Temp);

    (*Print)(
        "  Top=%d C3=%d C2=%d C1=%d C0=%d ES=%d SF=%d           PE=%d UE=%d OE=%d ZE=%d DE=%d IE=%d\n",
        (Temp >> 11) & 7,       // Top (3 bits)
        (Temp >> 7) & 1,        // Error Summary
        (Temp >> 14) & 1,       // C3
        (Temp >> 10) & 1,       // C2
        (Temp >> 9) & 1,        // C1
        (Temp >> 8) & 1,        // C0
        (Temp >> 7) & 1,        // Error Summary
        (Temp >> 6) & 1,        // Stack Fault
        (Temp >> 5) & 1,        // Precision Exception
        (Temp >> 4) & 1,        // Underflow Exception
        (Temp >> 3) & 1,        // Overflow Exception
        (Temp >> 2) & 1,        // Zero Divide Exception
        (Temp >> 1) & 1,        // Denormalized Operand Exception
        Temp & 1                // Invalid Operation Exception
        );

    (*Print)(" Last Instruction: CS:EIP=%X:%X EA=%X:%X\n",
        (USHORT)IntelRegisters.FloatSave.ErrorSelector,
        IntelRegisters.FloatSave.ErrorOffset,
        (USHORT)IntelRegisters.FloatSave.DataSelector,
        IntelRegisters.FloatSave.DataOffset
        );

    (*Print)(" Floating-point registers:\n");
    for (RegNum=0; RegNum<8; ++RegNum) {

        PBYTE r80 = (PBYTE)&IntelRegisters.FloatSave.RegisterArea[RegNum*10];

        Temp = (((USHORT)IntelRegisters.FloatSave.TagWord) >> (RegNum*2)) & 3;

        (*Print)(
                "  %d. %s %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X\n",
                RegNum,
                FpuTagNames[Temp],
                r80[0], r80[1], r80[2], r80[3], r80[4], r80[5], r80[6], r80[7], r80[8], r80[9]
               );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\i386\vdmtib.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Vdmtib.c

Abstract:

    This module contains routines for manipulating the vdmtib.

Author:

    Dave Hastings (daveh) 1-Apr-1992

Notes:

    The routines in this module assume that the pointers to the ntsd
    routines have already been set up.

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop
#include <stdio.h>

VOID
PrintEventInfo(
    IN PVDMEVENTINFO EventInfo
    );

VOID
PrintContext(PCONTEXT Context);

ULONG
GetCurrentVdmTib(
     VOID
     )
/*++

Routine Description:

    Retrives the Wx86Tib for a specified thread.

Arguments:

   None.

Return Value:

    Address of Wx86 (Teb.Vdm) in the debuggee if success

--*/
{
   TEB Teb;
   NTSTATUS Status;
   THREAD_BASIC_INFORMATION ThreadInformation;

   ThreadInformation.TebBaseAddress = NULL;
   Status = NtQueryInformationThread( hCurrentThread,
                                      ThreadBasicInformation,
                                      &ThreadInformation,
                                      sizeof( ThreadInformation ),
                                      NULL
                                      );
   if (!NT_SUCCESS(Status)) {
       (*Print)("Unable to get current thread's TEB Status %x\n", Status);
       return 0;
       }

   Status = READMEM(ThreadInformation.TebBaseAddress, &Teb, sizeof(TEB));
   if (!NT_SUCCESS(Status)) {
       (*Print)("Unable to read TEB %x Status %x\n",
               ThreadInformation.TebBaseAddress,
               Status
               );
       return 0;;
       }

   if ( Teb.Vdm == 0 ) {
       (*Print)("Current thread has no vdmtib (Teb.Vdm == NULL) \n"
               );
       } 
   return (ULONG)Teb.Vdm;

}

VOID
VdmTibp(
    VOID
    )
/*++

Routine Description:

    This routine dumps out the contents of the register block, and
    event info from the vdmtib.  If no address is specified (normal case),
    then the vdmtib is looked up (symbol VdmTib).

Arguments:

    None.

Return Value:

    None.

Notes:

    This routine assumes that the pointers to the ntsd routines have already
    been set up.

--*/
{
    BOOL Status;
    ULONG Address;
    CONTEXT Context;
    VDMEVENTINFO EventInfo;

    //
    // Get the address of the vdmtib
    //
    if (sscanf(lpArgumentString,"%lx",&Address) <= 0) {
        Address = GetCurrentVdmTib();
    }

    if (!Address) {
        (*Print)("Error geting VdmTib address\n");
        return;
    }

    //
    // Get the 32 bit context and print it out
    //

    Status = READMEM(
        &(((PVDM_TIB)Address)->MonitorContext),
        &Context,
        sizeof(CONTEXT)
        );

    if (!Status) {
        GetLastError();
        (*Print)("Could not get MonitorContext\n");
    } else {
        (*Print)("\n32 bit context\n");
        PrintContext(&Context);
    }

    //
    // Get the 16 bit context and print it out
    //

    Status = READMEM(
        &(((PVDM_TIB)Address)->VdmContext),
        &Context,
        sizeof(CONTEXT)
        );

    if (!Status) {
        GetLastError();
        (*Print)("Could not get VdmContext\n");
    } else {
        (*Print)("\n16 bit context\n");
        PrintContext(&Context);
    }

    //
    // Get the event info and print it out
    //

    Status = READMEM(
        &(((PVDM_TIB)Address)->EventInfo),
        &EventInfo,
        sizeof(VDMEVENTINFO)
        );

    if (!Status) {
        GetLastError();
        (*Print)("Could not get EventInfo\n");
    } else {
        (*Print)("\nEvent Info\n");
        PrintEventInfo(&EventInfo);
    }
}

VOID
EventInfop(
    VOID
    )
/*++

Routine Description:

    This routine dumps the contents of an event info structure.  If no
    address is specifed (normal case), the event info from the Vdmtib is
    dumped.

Arguments:

    None.

Return Value:

    None.

Notes:

    This routine assumes that the pointers to the ntsd routines have already
    been set up.

--*/
{
    BOOL Status;
    ULONG Address;
    VDMEVENTINFO EventInfo;

    //
    // Get the address of the eventinfo
    //
    if (sscanf(lpArgumentString,"%lx",&Address) <= 0) {
        Address = GetCurrentVdmTib();
        if (Address) {
            Address = (ULONG)(&(((PVDM_TIB)Address)->EventInfo));
        }
    }

    if (!Address) {
        (*Print)("Error geting VdmTib address\n");
        return;
    }

    //
    // Get the event info and print it out
    //

    Status = READMEM(
        (PVOID)Address,
        &EventInfo,
        sizeof(VDMEVENTINFO)
        );

    if (!Status) {
        GetLastError();
        (*Print)("Could not get EventInfo\n");
    } else {
        (*Print)("\nEvent Info\n");
        PrintEventInfo(&EventInfo);
    }
}

VOID
PrintEventInfo(
    IN PVDMEVENTINFO EventInfo
    )
/*++

Routine Description:

    This routine prints out the contents of an event info structure

Arguments:

    EventInfo -- Supplies a pointer to the eventinfo

Return Value:

    None.

--*/
{
    switch (EventInfo->Event) {
    case VdmIO :

        (*Print)("IO Instruction Event\n");

        if (EventInfo->IoInfo.Read) {
            (*Print)("Read from ");
        } else {
            (*Print)("Write to ");
        }

        switch (EventInfo->IoInfo.Size) {
        case 1 :
            (*Print)("Byte port ");
            break;
        case 2 :
            (*Print)("Word port ");
            break;
        case 4 :
            (*Print)("Dword port ");
            break;
        default:
            (*Print)("Unknown size port ");
        }

        (*Print)(" number %x\n", EventInfo->IoInfo.PortNumber);
        break;

    case VdmStringIO :

        (*Print)("String IO Instruction Event\n");

        if (EventInfo->StringIoInfo.Read) {
            (*Print)("Read from ");
        } else {
            (*Print)("Write to ");
        }

        switch (EventInfo->StringIoInfo.Size) {
        case 1 :
            (*Print)("Byte port ");
            break;
        case 2 :
            (*Print)("Word port ");
            break;
        case 4 :
            (*Print)("Dword port ");
            break;
        default:
            (*Print)("Unknown size port ");
        }

        (*Print)(" number %x, ", EventInfo->StringIoInfo.PortNumber);
        (*Print)(
            " Count = %lx, Address = %lx\n",
            EventInfo->StringIoInfo.Count,
            EventInfo->StringIoInfo.Address
            );
        break;

    case VdmIntAck :

        (*Print)("Interrupt Acknowlege Event\n");
        break;

    case VdmBop:

        (*Print)("Bop Event\n");
        (*Print)("Bop number %x\n",EventInfo->BopNumber);
        break;

    case VdmError :

        (*Print)("Error Event\n");
        (*Print)("Error Status %lx\n",EventInfo->ErrorStatus);

    case VdmIrq13 :

        (*Print)("IRQ 13 Event\n");
        break;

    default:

        (*Print)("Unknown Event %x\n",EventInfo->Event);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\i386\profile.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Profile.c

Abstract:

    This module contains routines for controling the rudimentary sampling
    profiler built into the profiling version of Ntvdm.

Author:

    Dave Hastings (daveh) 31-Jul-1992

Notes:

    The routines in this module assume that the pointers to the ntsd
    routines have already been set up.

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop
#include <stdio.h>

VOID
ProfDumpp(
    VOID
    )
/*++

Routine Description:

    This routine causes the profile information to be dumped the next
    time ntvdm switches from 32 to 16 bit mode.


Arguments:


Return Value:

    None.

Notes:

    This routine assumes that the pointers to the ntsd routines have already
    been set up.

--*/
{
    BOOL Status;
    ULONG Address, Flags;

    Address = FIXED_NTVDMSTATE_LINEAR;

    //
    // Get Flags
    //

    Status = READMEM((PVOID)Address, &Flags, sizeof(ULONG));

    if (!Status) {

        (ULONG)Address = (*GetExpression)("ntvdm!InitialVdmTibFlags");

        Status = READMEM((PVOID)Address, &Flags, sizeof(ULONG));

        if (!Status) {
            GetLastError();
            (*Print)("Could not get InitialVdmTibFlags\n");
            return;
        }
    }

    //
    // Enable profile dump
    //

    Flags |= VDM_ANALYZE_PROFILE;

    Status = WRITEMEM(
        (PVOID)Address,
        &Flags,
        sizeof(ULONG)
        );

    if (!Status) {
        GetLastError();
        (*Print)("Could not set Flags\n");
        return;
    }
}

VOID
ProfIntp(
    VOID
    )
/*++

Routine Description:

    This routine changes the profile interval the next time profiling is
    started.

Arguments:

    None.

Return Value:

    None.

Notes:

    This routine assumes that the pointers to the ntsd routines have already
    been set up.

--*/
{
    BOOL Status;
    ULONG Address, ProfInt;

    //
    // Get profile interval
    //

    if (sscanf(lpArgumentString, "%ld", &ProfInt) < 1) {
        (*Print)("Profile Interval must be specified\n");
        return;
    }

    //
    // Get the address of the profile interval
    //

    Address = (*GetExpression)(
        "ProfInt"
        );

    if (Address) {
        Status = WRITEMEM(
            (PVOID)Address,
            &ProfInt,
            sizeof(ULONG)
            );

        if (!Status) {
            GetLastError();
            (*Print)("Could not set profile interval");
        }
    }
    return;
}

VOID
ProfStartp(
    VOID
    )
/*++

Routine Description:

    This routine causes profiling to start the next
    time ntvdm switches from 32 to 16 bit mode.


Arguments:

    None.

Return Value:

    None.

Notes:

    This routine assumes that the pointers to the ntsd routines have already
    been set up.

--*/
{
    BOOL Status;
    ULONG Address, Flags;

    Address = FIXED_NTVDMSTATE_LINEAR;

    //
    // Get Flags
    //

    Status = READMEM(
        (PVOID)Address,
        &Flags,
        sizeof(ULONG)
        );

    if (!Status) {

        (ULONG)Address = (*GetExpression)("ntvdm!InitialVdmTibFlags");

        Status = READMEM(
            (PVOID)Address,
            &Flags,
            sizeof(ULONG)
            );

        if (!Status) {
            GetLastError();
            (*Print)("Could not get InitialTibflags\n");
            return;
        }
    }

    //
    // Enable profiling
    //

    Flags |= VDM_PROFILE;

    Status = WRITEMEM(
        (PVOID)Address,
        &Flags,
        sizeof(ULONG)
        );

    if (!Status) {
        GetLastError();
        (*Print)("Could not get set Flags\n");
        return;
    }
}

VOID
ProfStopp(
    VOID
    )
/*++

Routine Description:

    This routine causes profiling to stop the next
    time ntvdm switches from 32 to 16 bit mode.


Arguments:

    None.

Return Value:

    None.

Notes:

    This routine assumes that the pointers to the ntsd routines have already
    been set up.

--*/
{
    BOOL Status;
    ULONG Address, Flags;

    Address = FIXED_NTVDMSTATE_LINEAR;


    //
    // Get Flags
    //

    Status = READMEM((PVOID)Address, &Flags, sizeof(ULONG));

    if (!Status) {

        (ULONG)Address = (*GetExpression)("ntvdm!InitialVdmTibFlags");
        Status = READMEM((PVOID)Address, &Flags, sizeof(ULONG));

        if (!Status) {
            GetLastError();
            (*Print)("Could not get InitialTibflags\n");
            return;
        }
    }

    //
    // Disable profiling
    //

    Flags &= ~VDM_PROFILE;

    Status = WRITEMEM(
        (PVOID)Address,
        &Flags,
        sizeof(ULONG)
        );

    if (!Status) {
        GetLastError();
        (*Print)("Could not get set VDM Flags in DOS arena\n");
        return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\dlstruct.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dlstruct.h

Abstract:

    Down-level structures, taken from OS files (which themselves are unusable
    without modification because they incorporate function prototypes which
    clash with NT functions of the same name)

Author:

    Richard L Firth (rfirth) 09-Jun-1992

Revision History:

--*/

//
// misc. manifests
//

#define LANMAN_EMULATION_MAJOR_VERSION  2   // we pretend to be DOS LANMAN v2.1
#define LANMAN_EMULATION_MINOR_VERSION  1

#define NETPOPUP_SERVICE    "NETPOPUP"

#include <packon.h>

//
// Service
//

//
// definition of service_info_2 structure - only this level of info handled
// by NetServiceControl
//

struct service_info_2 {
    char    svci2_name[LM20_SNLEN+1];
    WORD    svci2_status;
    DWORD   svci2_code;
    WORD    svci2_pid;
    char    svci2_text[LM20_STXTLEN+1];
};

//
// Use
//

struct use_info_0 {
    char    ui0_local[LM20_DEVLEN+1];
    char    ui0_pad_1;
    LPSTR   ui0_remote;
};

struct use_info_1 {
    char    ui1_local[LM20_DEVLEN+1];   // B9   0,1
    char    ui1_pad_1;                  // B    2
    LPSTR   ui1_remote;                 // z    3
    LPSTR   ui1_password;               // z    4
    WORD    ui1_status;                 // W    5
    WORD    ui1_asg_type;               // W    6
    WORD    ui1_refcount;               // W    7
    WORD    ui1_usecount;               // W    8
};

//
// User
//

struct user_info_0 {
    char    usri0_name[LM20_UNLEN+1];
};

struct user_info_1 {
    char    usri1_name[LM20_UNLEN+1];
    char    usri1_pad_1;
    char    usri1_password[ENCRYPTED_PWLEN];
    DWORD   usri1_password_age;
    WORD    usri1_priv;
    LPSTR   usri1_home_dir;
    LPSTR   usri1_comment;
    WORD    usri1_flags;
    LPSTR   usri1_script_path;
};

struct user_info_2 {
    char    usri2_name[LM20_UNLEN+1];
    char    usri2_pad_1;
    char    usri2_password[ENCRYPTED_PWLEN];
    DWORD   usri2_password_age;
    WORD    usri2_priv;
    LPSTR   usri2_home_dir;
    LPSTR   usri2_comment;
    WORD    usri2_flags;
    LPSTR   usri2_script_path;
    DWORD   usri2_auth_flags;
    LPSTR   usri2_full_name;
    LPSTR   usri2_usr_comment;
    LPSTR   usri2_parms;
    LPSTR   usri2_workstations;
    DWORD   usri2_last_logon;
    DWORD   usri2_last_logoff;
    DWORD   usri2_acct_expires;
    DWORD   usri2_max_storage;
    WORD    usri2_units_per_week;
    LPSTR   usri2_logon_hours;
    WORD    usri2_bad_pw_count;
    WORD    usri2_num_logons;
    LPSTR   usri2_logon_server;
    WORD    usri2_country_code;
    WORD    usri2_code_page;
};


struct user_info_10 {
    char    usri10_name[LM20_UNLEN+1];
    char    usri10_pad_1;
    LPSTR   usri10_comment;
    LPSTR   usri10_usr_comment;
    LPSTR   usri10_full_name;
};

struct user_info_11 {
    char    usri11_name[LM20_UNLEN+1];
    char    usri11_pad_1;
    LPSTR   usri11_comment;
    LPSTR   usri11_usr_comment;
    LPSTR   usri11_full_name;
    WORD    usri11_priv;
    DWORD   usri11_auth_flags;
    DWORD   usri11_password_age;
    LPSTR   usri11_home_dir;
    LPSTR   usri11_parms;
    DWORD   usri11_last_logon;
    DWORD   usri11_last_logoff;
    WORD    usri11_bad_pw_count;
    WORD    usri11_num_logons;
    LPSTR   usri11_logon_server;
    WORD    usri11_country_code;
    LPSTR   usri11_workstations;
    DWORD   usri11_max_storage;
    WORD    usri11_units_per_week;
    LPSTR   usri11_logon_hours;
    WORD    usri11_code_page;
};

//
// Workstation
//

struct wksta_info_0 {
    WORD    wki0_reserved_1;
    DWORD   wki0_reserved_2;
    LPSTR   wki0_root;
    LPSTR   wki0_computername;
    LPSTR   wki0_username;
    LPSTR   wki0_langroup;
    BYTE    wki0_ver_major;
    BYTE    wki0_ver_minor;
    DWORD   wki0_reserved_3;
    WORD    wki0_charwait;
    DWORD   wki0_chartime;
    WORD    wki0_charcount;
    WORD    wki0_reserved_4;
    WORD    wki0_reserved_5;
    WORD    wki0_keepconn;
    WORD    wki0_keepsearch;
    WORD    wki0_maxthreads;
    WORD    wki0_maxcmds;
    WORD    wki0_reserved_6;
    WORD    wki0_numworkbuf;
    WORD    wki0_sizworkbuf;
    WORD    wki0_maxwrkcache;
    WORD    wki0_sesstimeout;
    WORD    wki0_sizerror;
    WORD    wki0_numalerts;
    WORD    wki0_numservices;
    WORD    wki0_errlogsz;
    WORD    wki0_printbuftime;
    WORD    wki0_numcharbuf;
    WORD    wki0_sizcharbuf;
    LPSTR   wki0_logon_server;
    LPSTR   wki0_wrkheuristics;
    WORD    wki0_mailslots;
};

struct wksta_info_1 {
    WORD  wki1_reserved_1;
    DWORD   wki1_reserved_2;
    LPSTR   wki1_root;
    LPSTR   wki1_computername;
    LPSTR   wki1_username;
    LPSTR   wki1_langroup;
    BYTE    wki1_ver_major;
    BYTE    wki1_ver_minor;
    DWORD   wki1_reserved_3;
    WORD    wki1_charwait;
    DWORD   wki1_chartime;
    WORD    wki1_charcount;
    WORD    wki1_reserved_4;
    WORD    wki1_reserved_5;
    WORD    wki1_keepconn;
    WORD    wki1_keepsearch;
    WORD    wki1_maxthreads;
    WORD    wki1_maxcmds;
    WORD    wki1_reserved_6;
    WORD    wki1_numworkbuf;
    WORD    wki1_sizworkbuf;
    WORD    wki1_maxwrkcache;
    WORD    wki1_sesstimeout;
    WORD    wki1_sizerror;
    WORD    wki1_numalerts;
    WORD    wki1_numservices;
    WORD    wki1_errlogsz;
    WORD    wki1_printbuftime;
    WORD    wki1_numcharbuf;
    WORD    wki1_sizcharbuf;
    LPSTR   wki1_logon_server;
    LPSTR   wki1_wrkheuristics;
    WORD    wki1_mailslots;
    LPSTR   wki1_logon_domain;
    LPSTR   wki1_oth_domains;
    WORD    wki1_numdgrambuf;
};

struct wksta_info_10 {
    LPSTR   wki10_computername;
    LPSTR   wki10_username;
    LPSTR   wki10_langroup;
    BYTE    wki10_ver_major;
    BYTE    wki10_ver_minor;
    LPSTR   wki10_logon_domain;
    LPSTR   wki10_oth_domains;
};

#include <packoff.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\sources.inc ===
!IF 0

Copyright (c) 1989-1991 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

MVDMDIR=$(PROJECT_ROOT)\mvdm

TARGETNAME=vdmredir
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=$(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\rxapi.lib \
           $(SDK_LIB_PATH)\rxcommon.lib \
           $(SDK_LIB_PATH)\netlib.lib \
           $(DS_LIB_PATH)\netapi32p.lib \
           $(SDK_LIB_PATH)\ntvdm.lib \
           $(SDK_LIB_PATH)\xactsrv.lib \
           $(SDK_LIB_PATH)\netrap.lib \
           $(SDK_LIB_PATH)\rpcrt4.lib \
	
DLLENTRY=VrDllInitialize
DLLBASE=0x03000000

USE_MSVCRT=1

INCLUDES=\
    $(MVDMDIR)\vdmredir;\
    $(MVDMDIR)\inc;\
    $(NET_INC_PATH);\
    $(DS_INC_PATH);\
    $(MVDMDIR)\softpc.new\base\inc;\
    $(MVDMDIR)\softpc.new\host\inc

SOURCES=..\vdmredir.rc \
        ..\vrmslot.c   \
        ..\vrnmpipe.c  \
        ..\vrdisp.c    \
        ..\vrinit.c    \
        ..\vrmisc.c    \
        ..\vrnetapi.c  \
        ..\vrnetb.c    \
        ..\vrputil.c   \
        ..\vrremote.c  \
        ..\vrdlc5c.c   \
        ..\vrdlcpst.c  \
        ..\vrdlcbuf.c  \
        ..\vrdlcdbg.c  \
        ..\vrdebug.c   \
        ..\vrdll.c

MSC_WARNING_LEVEL=/W3 /WX

C_DEFINES=-DVDMREDIR_DLL -DUNALIGNED_VDM_POINTERS $(C_DEFINES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\vrdebug.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrdebug.h

Abstract:

    Contains defines for Vdm Redir Debugging info

Author:

    Richard L Firth (rfirth) 13-Feb-1992

Notes:

    Add new category for each new group of functions added for which external
    debug control is required

Revision History:

--*/

//
// COMPILE-time debugging options:
// definitions for debug flags. Each bit enables diagnostic printing/specific
// debugging of corresponding module. Also overridden at run-time in DBG
// version by having these flags in the VR= environment variable
//

#define DEBUG_MAILSLOT      0x00000001L // general Mailslots
#define DEBUG_NAMEPIPE      0x00000002L // general Named Pipe
#define DEBUG_NETAPI        0x00000004L // general NETAPI
#define DEBUG_NETBIOS       0x00000008L // general NETBIOS
#define DEBUG_DLC           0x00000010L // general DLC
#define DEBUG_DOS_CCB_IN    0x00000020L // input DOS CCBs & parameter tables
#define DEBUG_DOS_CCB_OUT   0x00000040L // output DOS CCBs & parameter tables
#define DEBUG_NT_CCB_IN     0x00000080L // input NT CCBs & parameter tables
#define DEBUG_NT_CCB_OUT    0x00000100L // output NT CCBs & parameter tables
#define DEBUG_DLC_BUFFERS   0x00000200L // DLC buffer pools
#define DEBUG_DLC_TX_DATA   0x00000400L // DLC transmit data
#define DEBUG_DLC_RX_DATA   0x00000800L // DLC received data
#define DEBUG_DLC_ASYNC     0x00001000L // DLC async call-backs
#define DEBUG_TRANSACT_TX   0x00002000L // Transaction send data buffer(s)
#define DEBUG_TRANSACT_RX   0x00004000L // Transaction receive data buffer(s)
#define DEBUG_DLC_ALLOC     0x00008000L // dump alloc/free calls in DLC
#define DEBUG_READ_COMPLETE 0x00010000L // dump CCB when READ completes
#define DEBUG_ASYNC_EVENT   0x00020000L // dump asynchronous event info
#define DEBUG_CMD_COMPLETE  0x00040000L // dump command complete event info
#define DEBUG_TX_COMPLETE   0x00080000L // dump transmit complete event info
#define DEBUG_RX_DATA       0x00100000L // dump data received event info
#define DEBUG_STATUS_CHANGE 0x00200000L // dump DLC status change event info
#define DEBUG_EVENT_QUEUE   0x00400000L // dump PutEvent, GetEvent and PeekEvent
#define DEBUG_DOUBLE_TICKS  0x00800000L // multiply timer tick counts by 2
#define DEBUG_DUMP_FREE_BUF 0x01000000L // dump buffer header on BUFFER.FREE
#define DEBUG_CRITSEC       0x02000000L // dump enter/leave critical section info
#define DEBUG_HW_INTERRUPTS 0x04000000L // dump simulated hardware interrupt info
#define DEBUG_CRITICAL      0x08000000L // where #ifdef CRITICAL_DEBUGGING used to be
#define DEBUG_TIME          0x10000000L // display relative time of events
#define DEBUG_TO_FILE       0x20000000L // dump output to file VRDEBUG.LOG
#define DEBUG_DLL           0x40000000L // general DLL stuff - init, terminate
#define DEBUG_BREAKPOINT    0x80000000L // break everywhere there's a DEBUG_BREAK

#define DEBUG_DOS_CCB       (DEBUG_DOS_CCB_IN | DEBUG_DOS_CCB_OUT)

#define VRDEBUG_FILE        "VRDEBUG.LOG"

#if DBG
#include <stdio.h>
extern  DWORD   VrDebugFlags;
extern  FILE*   hVrDebugLog;

extern  VOID    DbgOut(LPSTR, ...);

#define IF_DEBUG(type)      if (VrDebugFlags & DEBUG_##type)
#define DEBUG_BREAK()       IF_DEBUG(BREAKPOINT) { \
                                DbgPrint("BP %s.%d\n", __FILE__, __LINE__); \
                                DbgBreakPoint(); \
                            }
#define DBGPRINT            DbgOut
#define DPUT(s)             DBGPRINT(s)
#define DPUT1(s, a)         DBGPRINT(s, a)
#define DPUT2(s, a, b)      DBGPRINT(s, a, b)
#define DPUT3(s, a, b, c)   DBGPRINT(s, a, b, c)
#define DPUT4(s, a, b, c, d) DBGPRINT(s, a, b, c, d)
#define DPUT5(s, a, b, c, d, e) DBGPRINT(s, a, b, c, d, e)
#define CRITDUMP(x)         DbgPrint x
#define DUMPCCB             DumpCcb
#else
#define IF_DEBUG(type)      if (0)
#define DEBUG_BREAK()
#define DBGPRINT
#define DPUT(s)
#define DPUT1(s, a)
#define DPUT2(s, a, b)
#define DPUT3(s, a, b, c)
#define DPUT4(s, a, b, c, d)
#define DPUT5(s, a, b, c, d, e)
#define CRITDUMP(x)
#define DUMPCCB
#endif

//
// defaults
//

#define DEFAULT_STACK_DUMP  32

//
// numbers
//

#define NUMBER_OF_VR_GROUPS 5
#define NUMBER_OF_CPU_REGISTERS 14
#define MAX_ID_LEN  40
#define MAX_DESC_LEN    256

//
// environment strings - shortened since they all go through to dos & dos can
// only handle 1K of environment
//

#define ES_VRDEBUG  "VRDBG" // "__VRDEBUG"
#define ES_MAILSLOT "MS"    // "MAILSLOT"
#define ES_NAMEPIPE "NP"    // "NAMEPIPE"
#define ES_LANMAN   "LM"    // "LANMAN"
#define ES_NETBIOS  "NB"    // "NETBIOS"
#define ES_DLC      "DLC"   // "DLC"

//
// diagnostic controls - in same numerical order as TOKEN!!!
//

#define DC_BREAK        "BRK"   // "BREAK"
#define DC_DISPLAYNAME  "DN"    // "DISPLAYNAME"
#define DC_DLC          ES_DLC
#define DC_DUMPMEM      "DM"    // "DUMPMEM"
#define DC_DUMPREGS     "DR"    // "DUMPREGS"
#define DC_DUMPSTACK    "DK"    // "DUMPSTACK"
#define DC_DUMPSTRUCT   "DS"    // "DUMPSTRUCT"
#define DC_ERROR        "E"     // "ERROR"
#define DC_ERRORBREAK   "EB"    // "ERRORBREAK"
#define DC_INFO         "I"     // "INFO"
#define DC_LANMAN       ES_LANMAN
#define DC_MAILSLOT     ES_MAILSLOT
#define DC_NAMEPIPE     ES_NAMEPIPE
#define DC_NETBIOS      ES_NETBIOS
#define DC_PAUSEBREAK   "PB"    // "PAUSEBREAK"
#define DC_WARN         "W"     // "WARN"

//
// diagnostic categories (groups)
//

#define DG_ALL          -1L         // catch first enabled set
#define DG_NONE         0           // no category
#define DG_MAILSLOT     0x00000001L
#define DG_NAMEPIPE     0x00000002L
#define DG_LANMAN       0x00000004L
#define DG_NETBIOS      0x00000008L
#define DG_DLC          0x00000010L

//
// diagnostic index (in VrDiagnosticGroups array)
//

#define DI_MAILSLOT     0
#define DI_NAMEPIPE     1
#define DI_LANMAN       2
#define DI_NETBIOS      3
#define DI_DLC          4

//
// diagnostic control manifests
//

#define DM_INFORMATION  0x00010000L     // display all info, warning and error messages
#define DM_WARNING      0x00020000L     // display warning and error messages
#define DM_ERROR        0x00030000L     // display error messages only
#define DM_ERRORBREAK   0x00100000L     // DbgBreakPoint() on error
#define DM_PAUSEBREAK   0x00200000L     // DbgBreakPoint() on pause (wait for developer)
#define DM_DUMPREGS     0x00800000L     // dump x86 registers when routine entered
#define DM_DUMPREGSDBG  0x01000000L     // dump x86 registers when routine entered, debug style
#define DM_DUMPMEM      0x02000000L     // dump DOS memory when routine entered
#define DM_DUMPSTACK    0x04000000L     // dump DOS stack when routine entered
#define DM_DUMPSTRUCT   0x08000000L     // dump a structure when routine entered
#define DM_DISPLAYNAME  0x10000000L     // display the function name
#define DM_BREAK        0x80000000L     // break when routine entered

#define DM_DISPLAY_MASK 0x000f0000L

//
// enumerated types
//

////
//// GPREG - General Purpose REGisters
////
//
//typedef enum {
//    AX = 0,
//    BX,
//    CX,
//    DX,
//    SI,
//    DI,
//    BP,
//    SP
//} GPREG;
//
////
//// SEGREG - SEGment REGisters
////
//
//typedef enum {
//    CS = 8,
//    DS,
//    ES,
//    SS
//} SEGREG;
//
////
//// SPREG - Special Purpose REGisters
////
//
//typedef enum {
//    IP = 12,
//    FLAGS
//} SPREG;
//
//typedef union {
//    SEGREG  SegReg;
//    GPREG   GpReg;
//    SPREG   SpReg;
//} REGISTER;

typedef enum {
    AX = 0,
    BX = 1,
    CX = 2,
    DX = 3,
    SI = 4,
    DI = 5,
    BP = 6,
    SP = 7,
    CS = 8,
    DS = 9,
    ES = 10,
    SS = 11,
    IP = 12,
    FLAGS = 13
} REGISTER;

//
// REGVAL - keeps a 16-bit value or a register specification, depending on
// sense of IsRegister
//

typedef struct {
    BOOL    IsRegister;
    union {
        REGISTER Register;
        WORD    Value;
    } RegOrVal;
} REGVAL, *LPREGVAL;

//
// structures
//

//
// CONTROL - keeps correspondence between control keyword and control flag
//

typedef struct {
    char*   Keyword;
    DWORD   Flag;
} CONTROL;

//
// OPTION - keeps correspondence between diagnostic option and option type
//

typedef struct {
    char*   Keyword;
    DWORD   Flag;
} OPTION;

//
// REGDEF - defines a register - keeps correspondence between name and type
//

typedef struct {
    char    RegisterName[3];
    REGISTER Register;
} REGDEF, *LPREGDEF;

//
// GROUPDEF - keeps correspondence between group name and index in
// VrDiagnosticGroups array
//

typedef struct {
    char*   Name;
    DWORD   Index;
} GROUPDEF;

//
// MEMORY_INFO - for each each memory dump we keep a record of its type, length
// and starting address
//

typedef struct _MEMORY_INFO {
    struct _MEMORY_INFO* Next;
    REGVAL  Segment;
    REGVAL  Offset;
    REGVAL  DumpCount;
    BYTE    DumpType;
} MEMORY_INFO, *LPMEMORY_INFO;

//
// STRUCT_INFO - for each structure to be dumped we keep record of the segment
// and offset registers and the string which describes the structure to be
// dumped. The descriptor is similar to (but NOT THE SAME AS) the Rap
// descriptor stuff
//

typedef struct _STRUCT_INFO {
    struct _STRUCTINFO* Next;
    char    StructureDescriptor[MAX_DESC_LEN+1];
    REGVAL  Segment;
    REGVAL  Offset;
} STRUCT_INFO, *LPSTRUCT_INFO;

//
// DIAGNOSTIC_INFO - information common to GROUP_DIAGNOSTIC and FUNCTION_DIAGNOSTIC
//

typedef struct {
    DWORD       OnControl;
    DWORD       OffControl;
    MEMORY_INFO StackInfo;  // special case of MemoryInfo
    MEMORY_INFO MemoryInfo;
    STRUCT_INFO StructInfo;
} DIAGNOSTIC_INFO, *LPDIAGNOSTIC_INFO;

//
// GROUP_DIAGNOSTIC - because the groups are predefined, we don't keep any
// name information, or a list - just NUMBER_OF_VR_GROUPS elements in an
// array of GROUP_DIAGNOSTIC structures
//

typedef struct {
    char    GroupName[MAX_ID_LEN+1];
    DIAGNOSTIC_INFO Diagnostic;
} GROUP_DIAGNOSTIC, *LPGROUP_DIAGNOSTIC;

//
// FUNCTION_DIAGNOSTIC - if we want to diagnose a particular named function,
// then we generate one of these. We keep a (unsorted) list of these if a
// function description is parsed from the environment string(s)
//

typedef struct _FUNCTION_DIAGNOSTIC {
    struct _FUNCTION_DIAGNOSTIC* Next;
    char    FunctionName[MAX_ID_LEN+1];
    DIAGNOSTIC_INFO Diagnostic;
} FUNCTION_DIAGNOSTIC, *LPFUNCTION_DIAGNOSTIC;

//
// structure descriptor characters (general purpose data descriptors)
//

#define SD_BYTE     'B'     //  8-bits, displayed as hex (0a)
#define SD_WORD     'W'     // 16-bits, displayed as hex (0abc)
#define SD_DWORD    'D'     // 32-bits, displayed as hex (0abc1234)
#define SD_POINTER  'P'     // 32-bits, displayed as pointer (0abc:1234)
#define SD_ASCIZ    'A'     // asciz string, displayed as string "this is a string"
#define SD_ASCII    'a'     // asciz pointer, displayed as pointer, string 0abc:1234 "this is a string"
#define SD_CHAR     'C'     // ascii character, displayed as character 'c'
#define SD_NUM      'N'     //  8-bits, displayed as unsigned byte (0 to 255)
#define SD_INT      'I'     // 16-bits, displayed as unsigned word (0 to 65,535)
#define SD_LONG     'L'     // 32-bits, displayed as unsigned long (0 to 4,294,967,295)
#define SD_SIGNED   '-'     // convert I,L,N to signed
#define SD_DELIM    ':'     // name delimiter
#define SD_FIELDSEP ';'     // separates named fields
#define SD_NAMESEP  '/'     // separates structure name from fields

#define SD_CHARS    {SD_BYTE, \
                    SD_WORD, \
                    SD_DWORD, \
                    SD_POINTER, \
                    SD_ASCIZ, \
                    SD_ASCII,\
                    SD_CHAR, \
                    SD_NUM, \
                    SD_INT, \
                    SD_LONG, \
                    SD_SIGNED}

#define MD_CHARS    {SD_BYTE, SD_WORD, SD_DWORD, SD_POINTER}

//
// token stuff
//

//
// TOKEN - enumerated, alphabetically ordered tokens
//

typedef enum {
    TLEFTPAREN = -6,    // (
    TRIGHTPAREN = -5,   // )
    TREGISTER = -4,
    TNUMBER = -3,
    TEOS = -2,  // end of string
    TUNKNOWN = -1,  // unknown lexeme, assume routine name?

    //
    // tokens from here on down are also the index into DiagnosticTokens which
    // describe them
    //

    TBREAK = 0,
    TDISPLAYNAME,
    TDLC,
    TDUMPMEM,
    TDUMPREGS,
    TDUMPSTACK,
    TDUMPSTRUCT,
    TERROR,
    TERRORBREAK,
    TINFO,
    TLANMAN,
    TMAILSLOT,
    TNAMEPIPE,
    TNETBIOS,
    TPAUSEBREAK,
    TWARN
} TOKEN;

//
// TIB (Token Info Bucket) - Contains info describing token found. Only filled
// in when we find an identifier, number or a register
//

typedef struct {
    LPSTR   TokenStream;
    TOKEN   Token;
    union {
        REGVAL  RegVal;
        char    Id[MAX_DESC_LEN+1];
    } RegValOrId;
} TIB, *LPTIB;

//
// DEBUG_TOKEN - maps from lexeme to token
//

typedef struct {
    char*   TokenString;
    TOKEN   Token;
} DEBUG_TOKEN;

//
// what to expect when parsing strings
//

#define EXPECTING_NOTHING       0x00
#define EXPECTING_REGVAL        0x01
#define EXPECTING_MEMDESC       0x02
#define EXPECTING_STRUCTDESC    0x04
#define EXPECTING_LEFTPAREN     0x08
#define EXPECTING_RIGHTPAREN    0x10
#define EXPECTING_EOS           0x20
#define EXPECTING_NO_ARGS       0x40

//
// data (defined in vrdebug.c)
//

//
// VrDiagnosticGroups - an array of GROUP_DIAGNOSTIC structures
//

GROUP_DIAGNOSTIC VrDiagnosticGroups[NUMBER_OF_VR_GROUPS];

//
// FunctionList - linked list of FUNCTION_DIAGNOSTIC structures
//

LPFUNCTION_DIAGNOSTIC FunctionList;

//
// prototypes (in vrdebug.c)
//

VOID
VrDebugInit(
    VOID
    );

LPDIAGNOSTIC_INFO
VrDiagnosticEntryPoint(
    IN  LPSTR   FunctionName,
    IN  DWORD   FunctionCategory,
    OUT LPDIAGNOSTIC_INFO Info
    );

VOID
VrPauseBreak(
    LPDIAGNOSTIC_INFO Info
    );

VOID
VrErrorBreak(
    LPDIAGNOSTIC_INFO Info
    );

VOID
VrPrint(
    IN  DWORD   Level,
    IN  LPDIAGNOSTIC_INFO Context,
    IN  LPSTR   Format,
    IN  ...
    );

VOID
VrDumpRealMode16BitRegisters(
    IN  BOOL    DebugStyle
    );

VOID
VrDumpDosMemory(
    IN  BYTE    Type,
    IN  DWORD   Iterations,
    IN  WORD    Segment,
    IN  WORD    Offset
    );

VOID
VrDumpDosMemoryStructure(
    IN  LPSTR   Descriptor,
    IN  WORD    Segment,
    IN  WORD    Offset
    );

//
//VOID
//VrDumpDosStack(
//    IN  DWORD   Depth
//    )
//
///*++
//
//Routine Description:
//
//    Dumps <Depth> words from the Vdm stack, as addressed by getSS():getSP().
//    Uses VrDumpDosMemory to dump stack contents
//
//Arguments:
//
//    Depth   - number of 16-bit words to dump from DOS memory stack
//
//Return Value:
//
//    None.
//
//--*/
//

#define VrDumpDosStack(Depth)   VrDumpDosMemory('W', Depth, getSS(), getSP())

//
// macros used in routines to be diagnosed
//

#if DBG
#define DIAGNOSTIC_ENTRY    VrDiagnosticEntryPoint
#define DIAGNOSTIC_EXIT     VrDiagnosticExitPoint
#define BREAK_ON_PAUSE      VrPauseBreak
#define BREAK_ON_ERROR      VrErrorBreak
//#define INFORM(s, ...)      VrPrint(DM_INFORMATION, s, ...)
//#define WARN(s, ...)        VrPrint(DM_WARNING, s, ...)
//#define ERROR(s, ...)       VrPrint(DM_ERROR, s, ...)

#else

//
// macros used in routines to be diagnosed - don't expand to anything in non-debug
//

#define DIAGNOSTIC_ENTRY
#define DIAGNOSTIC_EXIT
#define BREAK_ON_PAUSE
#define BREAK_ON_ERROR
//#define INFORM
//#define WARN
//#define ERROR
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\vrdebug.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrdebug.c

Abstract:

    Contains diagnostic/debugging routines for Vdm Redir:

        VrDebugInit
        VrDiagnosticEntryPoint
        VrPrint
        VrDumpRealMode16BitRegisters
        VrDumpDosMemory
        (ConvertFlagsToString)
        (GetFlags)
        (GrabDosData)
        probe_parens
        CategoryToIndex
        GetRoutineDiagnosticInfo
        MergeInfo
        DoEntryDiagnostics
        GetRegisterOrValue
        VrDumpDosMemoryStructure
        VrPauseBreak
        VrErrorBreak

Author:

    Richard L Firth (rfirth) 13-Feb-1992

Notes:

    This module allows us to run NTVDM.EXE and breakpoint or dump info based
    on an environment variable. Set the __VRDEBUG environment variable depending
    on the level and type of diagnostics required from VdmRedir functions. See
    vrdebug.h for more info

    This is a convenient method of dynamically changing diagnostic/debug
    information at run time without having to poke around in memory or start
    up NTVDM under NTSD (especially since NTVDM is run by the loader and not
    by typing NTVDM<return> at the command prompt. Changing diagnostic settings
    requires that NTVDM be shut down, redefine the __VRDEBUG environment
    variable(s) and start a dos app. Alternatively, start the dos app in a new
    command session after setting the new __VRDEBUG environment variable(s)

    Types of things which can be affected by values in environment string:

        - Whether a routine breakpoints at entry (and goes into debugger)
        - What functions or categories to diagnose
        - What to dump at function entry:
            x86 registers
            DOS memory
            DOS stack
            DOS structures

    Note that currently the order of things at function entry are predefined:

        1. Display function's name
        2. Display x86 registers
        3. Dump DOS stack
        4. Dump DOS memory
        5. Dump DOS structure(s)    Currently only 1 structure
        6. Break

    Diagnostic information is set up once at NTVDM initialisation for this
    session, so the environment information must have been already entered.
    There can be 11 __VRDEBUG environment variables: __VRDEBUG and __VRDEBUG0
    through __VRDEBUG9. Each string can contain several function/group
    specifications of the form:

        <function or group name>[(<diagnostic options>)]

    The group names are predefined (add a new one if a new group of functions
    is added to VdmRedir) and are currently:

        MAILSLOT, NAMEPIPE, LANMAN, NETBIOS and DLC

    Group names are case insensitive. Function names are case sensitive and
    should be entered as they appear in the C code. However, if a case sensitive
    search for a function name fails, a secondary case-insensitive search will
    be made.

    Diagnostic options are case insensitive and are performed in the order shown
    above and are the following:

        BREAK[()]
            Break into the debugger (DbgBreakPoint) when the function is
            entered

        DISPLAYNAME[()]
            Display the function name on entry

        DUMPREGS[()]
            Dump the x86 16-bit registers on entry to the function

        DUMPSTACK[(<number>)]
            Dump <number> of DOS stack words (or use DEFAULT_DUMP_STACK_LENGTH)
            on entry to the function. This is just a special case of DUMPMEM,
            with type set to 'W', and segment:offset set to ss:sp.

        DUMPMEM[(<segment>, <offset>, <number>, <type>)]
            Dump <number> and <type> of DOS memory (or use DEFAULT_DUMP_MEMORY_LENGTH
            and DEFAULT_DUMP_MEMORY_TYPE) at <segment>:<offset>

        DUMPSTRUCT[(<seg> <off> <descriptor>)]
            Dump the structure addressed by <seg>:<off> (not necessarily segment
            and offset registers, can be eg. ax:flags) and descriped by <descriptor>

        INFO[()]
            Filter for calls to VrPrint - display INFORMATION, WARNING and ERROR
            messages

        WARN[()]
            Filter for calls to VrPrint - display WARNING and ERROR messages

        ERROR[()]
            Filter for calls to VrPrint - display ERROR messages only

        ERRORBREAK[()]
            Cause a break into debugger whenever BREAK_ON_ERROR/VrErrorBreak
            called

        PAUSEBREAK[()]
            Cause a break into debuggger whenever BREAK_ON_PAUSE/VrPauseBreak
            called

    If an option appears without parentheses then its function is turned OFF
    for this group or function.

    Whitespace between an option and following parentheses is tolerated, but
    should not be present.

    If an option takes parameters then all required parameters must be present
    or the option is ignored.

    Where an option takes parameters, commas are tolerated between parameters
    but are not necessary. Eg

        dumpmem(ds si 32 B)

    and

        DUMPMEM ( ds, si, 32, b )

    and

        DumpMem (ds,si,32,B)

    are treated as the same (, is just whitespace in this u-grammar).

    Where register parameters are required, absolute hex values can be given.
    Similarly, where a number parameter is required, a 16-bit register (any
    register) definition can be substituted.

    Function specifications take precedence over group specifications. So if the
    same option is given for a group and a function that belongs to that group
    then the options specified in the function entry are used. Any options
    specified for the group but not negated by the function are used for the
    function also.

    When parsing the environment, if the syntax is violated, the current
    description is skipped until the next description starts or the end of
    the string is found. Eg:

        mailslot(break() DLC(break()) DLC(dumpstruct(bx BBBBPPBBBB))
                        ^                               ^
                        1                               2

    In this example, only DLC(break()) is parsed correctly, because there is
    a missing right parenthesis at 1 and a missing offset register specification
    at 2 (assumes bx is segment register, because that's the syntax)

Revision History:

--*/

#if DBG

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <malloc.h>
#include <ctype.h>
#include <nt.h>
#include <ntrtl.h>      // ASSERT, DbgPrint
#include <nturtl.h>
#include <windows.h>
#include <softpc.h>     // x86 virtual machine definitions
#include <vrdlctab.h>
#include <vdmredir.h>
#include "vrdebug.h"

#ifdef VR_DEBUG_FLAGS
DWORD   VrDebugFlags = VR_DEBUG_FLAGS;
#else
DWORD   VrDebugFlags = 0;
#endif

#ifdef DBGDBG
#define DbgPrint    printf
#endif

#define BYTES_DUMPED_AT_A_TIME  16

//
// private prototypes
//

PRIVATE
VOID
GetRoutineDiagnosticInfo(
    IN  LPSTR   FunctionName,
    OUT LPDIAGNOSTIC_INFO Info
    );

PRIVATE
DWORD
CategoryToIndex(
    IN  DWORD   Category
    );

VOID
MergeInfo(
    OUT LPDIAGNOSTIC_INFO Info,
    IN  LPDIAGNOSTIC_INFO FunctionInfo,
    IN  LPDIAGNOSTIC_INFO CategoryInfo
    );

VOID
DoEntryDiagnostics(
    IN  LPSTR   FunctionName,
    IN  LPDIAGNOSTIC_INFO Info
    );

WORD
GetRegisterOrValue(
    IN  REGVAL  Union
    );

PRIVATE
BOOL
ParseString(
    IN  LPSTR   EnvStr
    );

PRIVATE
int
probe_parens(
    LPSTR   str
    );

PRIVATE
VOID
apply_controls(
    IN  DWORD   mask,
    IN  LPFUNCTION_DIAGNOSTIC lpFunc,
    IN  DWORD   on_controls,
    IN  DWORD   off_controls,
    IN  LPMEMORY_INFO lpMemory,
    IN  LPMEMORY_INFO lpStack,
    IN  LPSTRUCT_INFO lpStructure
    );

PRIVATE
VOID
apply_diags(
    IN  LPDIAGNOSTIC_INFO lpDiag,
    IN  DWORD   on_controls,
    IN  DWORD   off_controls,
    IN  LPMEMORY_INFO lpMemory,
    IN  LPMEMORY_INFO lpStack,
    IN  LPSTRUCT_INFO lpStructure
    );

PRIVATE
LPFUNCTION_DIAGNOSTIC
FindFuncDiags(
    IN  LPSTR   function_name
    );

PRIVATE
LPFUNCTION_DIAGNOSTIC
AllocFuncDiags(
    IN  LPSTR   function_name
    );

TOKEN parse_token(LPTIB pTib);
TOKEN peek_token(LPTIB pTib);
LPSTR skip_ws(LPSTR str);
LPSTR search_delim(LPSTR str);
LPSTR extract_token(LPTIB pTib, LPSTR* token_stream);
BOOL IsLexKeyword(LPSTR tokstr, TOKEN* pToken);
BOOL IsLexRegister(LPSTR tokstr, LPREGVAL lpRegVal);
BOOL IsLexNumber(LPSTR tokstr, LPREGVAL lpRegVal);
WORD hex(char hexch);
BOOL IsKeywordToken(TOKEN token);
BOOL IsValidDumpDescriptor(char* str);
BOOL IsValidStructDescriptor(char* str);

PRIVATE
LPSTR
ConvertFlagsToString(
    IN  WORD    FlagsRegister,
    OUT LPSTR   Buffer
    );

PRIVATE
WORD
GetFlags(
    VOID
    );

PRIVATE
DWORD
GrabDosData(
    IN  LPBYTE  DosMemoryPointer,
    IN  DWORD   DataSize
    );

//
// data
//

//
// VrDiagnosticGroups - array of GROUP_DIAGNOSTIC structures in chronological
// order of implementation
//

GROUP_DIAGNOSTIC VrDiagnosticGroups[NUMBER_OF_VR_GROUPS] = {
    {ES_MAILSLOT},    // DI_MAILSLOT
    {ES_NAMEPIPE},    // DI_NAMEPIPE
    {ES_LANMAN},      // DI_LANMAN
    {ES_NETBIOS},     // DI_NETBIOS
    {ES_DLC}          // DI_DLC
};

REGDEF Registers[] = {
    "ax", AX,
    "bx", BX,
    "cx", CX,
    "dx", DX,
    "si", SI,
    "di", DI,
    "bp", BP,
    "sp", SP,
    "cs", CS,
    "ds", DS,
    "es", ES,
    "ss", SS,
    "ip", IP,
    "fl", FLAGS
};

CONTROL Controls[] = {
    DC_BREAK,       DM_BREAK,
    DC_DISPLAYNAME, DM_DISPLAYNAME,
    DC_DLC,         0,
    DC_DUMPMEM,     DM_DUMPMEM,
    DC_DUMPREGS,    DM_DUMPREGS,
    DC_DUMPSTACK,   DM_DUMPSTACK,
    DC_DUMPSTRUCT,  DM_DUMPSTRUCT,
    DC_ERROR,       DM_ERROR,
    DC_ERRORBREAK,  DM_ERRORBREAK,
    DC_INFO,        DM_INFORMATION,
    DC_LANMAN,      0,
    DC_MAILSLOT,    0,
    DC_NAMEPIPE,    0,
    DC_NETBIOS,     0,
    DC_PAUSEBREAK,  DM_PAUSEBREAK,
    DC_WARN,        DM_WARNING
};

#define NUMBER_OF_CONTROLS  (sizeof(Controls)/Sizeof(Controls[0]))

//
// DiagnosticTokens - alphabetical list of all tokens we can parse from string
// excluding registers, parentheses and numbers
//

DEBUG_TOKEN DiagnosticTokens[] = {
    DC_BREAK,       TBREAK,
    DC_DISPLAYNAME, TDISPLAYNAME,
    DC_DLC,         TDLC,
    DC_DUMPMEM,     TDUMPMEM,
    DC_DUMPREGS,    TDUMPREGS,
    DC_DUMPSTACK,   TDUMPSTACK,
    DC_DUMPSTRUCT,  TDUMPSTRUCT,
    DC_ERROR,       TERROR,
    DC_ERRORBREAK,  TERRORBREAK,
    DC_INFO,        TINFO,
    DC_LANMAN,      TLANMAN,
    DC_MAILSLOT,    TMAILSLOT,
    DC_NAMEPIPE,    TNAMEPIPE,
    DC_NETBIOS,     TNETBIOS,
    DC_PAUSEBREAK,  TPAUSEBREAK,
    DC_WARN,        TWARN
};

#define NUMBER_OF_RECOGNIZABLE_TOKENS   (sizeof(DiagnosticTokens)/sizeof(DiagnosticTokens[0]))

LPFUNCTION_DIAGNOSTIC FunctionList = NULL;

//
// routines
//

VOID
VrDebugInit(
    VOID
    )

/*++

Routine Description:

    Sets up the Vdm Redir diagnostic/debugging information based on the presence
    of the __VRDEBUG environment variable. We actually allow 11 __VRDEBUG
    environment variables - __VRDEBUG and __VRDEBUG0 through __VRDEBUG9. This
    is to make it easy to provide a lot of diagnostic information

    Syntax is __VRDEBUG[0..9]=group|routine(diagnostic controls) *
    Where: group is MAILSLOT, NAMEPIPE, LANMAN, NETBIOS, DLC
           routine is name of actual routine
           diagnostic controls are:
                break   break on entry to routine
                dumpreg dump 16-bit registers on entry to routine (before break)
                dumpstack(n) dump n words of DOS stack on entry to routine
                dumpstruct(seg, off, descriptor)

Arguments:

    None.

Return Value:

    None.

--*/

{
    char    envVar[sizeof(ES_VRDEBUG)+1];   // +1 for '0'..'9'
    LPSTR   envString;
    DWORD   i;
    LPSTR   p;

    static  BOOL initialized = FALSE;

    if (initialized) {
        return ;
    }

    strcpy(envVar, ES_VRDEBUG);
    if (envString = getenv(envVar)) {
        ParseString(envString);
    }
    p = strchr(envVar, 0);
    *p = '0';
    *(p+1) = 0;
    for (i=0; i<10; ++i) {
        if (envString = getenv(envVar)) {
            ParseString(envString);
        }
        ++*p;
    }
    initialized = TRUE;
}

LPDIAGNOSTIC_INFO
VrDiagnosticEntryPoint(
    IN  LPSTR   FunctionName,
    IN  DWORD   FunctionCategory,
    OUT LPDIAGNOSTIC_INFO Info
    )

/*++

Routine Description:

    Performs diagnostic processing on entry to routine based on what was
    specified in the __VRDEBUG environment variables for this routine. Tries
    to perform diagnostics specific to this routine. If can't find specific
    function diagnostic control, checks if anything was specified for this
    category

Arguments:

    FunctionName    - string defining procedure's name (eg VrNetUseAdd)
    FunctionCategory- which category this function belongs to (eg DG_LANMAN)
    Info            - pointer to LPDIAGNOSTIC_INFO which will be returned

Return Value:

    LPDIAGNOSTIC_INFO - pointer to structure describing diagnostic controls for
                        THIS ROUTINE

--*/

{
    DIAGNOSTIC_INFO function_info;
    LPDIAGNOSTIC_INFO category_info;

    RtlZeroMemory(&function_info, sizeof(function_info));
    GetRoutineDiagnosticInfo(FunctionName, &function_info);
    if (FunctionCategory != DG_NONE && FunctionCategory != DG_ALL) {
        category_info = &VrDiagnosticGroups[CategoryToIndex(FunctionCategory)].Diagnostic;
    } else {
        DIAGNOSTIC_INFO null_info;

        RtlZeroMemory(&null_info, sizeof(null_info));
        category_info = &null_info;
    }
    MergeInfo(Info, &function_info, category_info);
    DoEntryDiagnostics(FunctionName, Info);
    return Info;
}

PRIVATE
VOID
GetRoutineDiagnosticInfo(
    IN  LPSTR   FunctionName,
    OUT LPDIAGNOSTIC_INFO Info
    )


/*++

Routine Description:

    Tries to find the diagnostic information for this function. If found,
    returns the info, else a DIAGNOSTIC_INFO structure filled with 0s

Arguments:

    FunctionName    - name of function to find info for
    Info            - pointer to place to store returned diagnostic info

Return Value:

    None.

--*/

{
    LPFUNCTION_DIAGNOSTIC pfunc;

    if (pfunc = FindFuncDiags(FunctionName)) {
        *Info = pfunc->Diagnostic;
    } else {
        RtlZeroMemory(Info, sizeof(DIAGNOSTIC_INFO));
    }
}

PRIVATE
DWORD
CategoryToIndex(
    IN  DWORD   Category
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Category    - a DG_ category

Return Value:

    DWORD - offset in VrDiagnosticGroups

--*/

{
    DWORD   i, bit;

    for (i=0, bit=1; bit; bit <<=1, ++i) {
        if (Category & bit) {
            break;
        }
    }
    return i;
}

VOID
MergeInfo(
    OUT LPDIAGNOSTIC_INFO Info,
    IN  LPDIAGNOSTIC_INFO FunctionInfo,
    IN  LPDIAGNOSTIC_INFO CategoryInfo
    )

/*++

Routine Description:

    Creates one DIAGNOSTIC_INFO from one function and one category info structure

Arguments:

    Info            - place to store merged diagnostic info
    FunctionInfo    - input function info
    CategoryInfo    - input category info

Return Value:

    None.

--*/

{
    RtlZeroMemory(Info, sizeof(DIAGNOSTIC_INFO));
    Info->OnControl = (FunctionInfo->OnControl | CategoryInfo->OnControl)
        & ~(FunctionInfo->OffControl | CategoryInfo->OffControl);
    Info->OffControl = 0;
    if (FunctionInfo->OnControl & DM_DUMPSTACK) {
        Info->StackInfo = FunctionInfo->StackInfo;
    } else if (CategoryInfo->OnControl & DM_DUMPSTACK) {
        Info->StackInfo = CategoryInfo->StackInfo;
    }
    if (FunctionInfo->OnControl & DM_DUMPMEM) {
        Info->MemoryInfo = FunctionInfo->MemoryInfo;
    } else if (CategoryInfo->OnControl & DM_DUMPMEM) {
        Info->MemoryInfo = CategoryInfo->MemoryInfo;
    }
    if (FunctionInfo->OnControl & DM_DUMPSTRUCT) {
        Info->StructInfo = FunctionInfo->StructInfo;
    } else if (CategoryInfo->OnControl & DM_DUMPSTRUCT) {
        Info->StructInfo = CategoryInfo->StructInfo;
    }
}

VOID
DoEntryDiagnostics(
    IN  LPSTR   FunctionName,
    IN  LPDIAGNOSTIC_INFO Info
    )

/*++

Routine Description:

    Performs diagnostics at entry to routine as per description in header

Arguments:

    FunctionName    - name of function calling VrDiagnosticEntryPoint
    Info            - pointer to DIAGNOSTIC_INFO created in entry point

Return Value:



--*/

{
    DWORD   control = Info->OnControl;

    if (control & DM_DISPLAYNAME) {
        DbgPrint("\n%s\n", FunctionName);
    }
    if (control & DM_DUMPREGS|DM_DUMPREGSDBG) {
        VrDumpRealMode16BitRegisters(control & DM_DUMPREGSDBG);
    }
    if (control & DM_DUMPSTACK) {
        VrDumpDosStack(GetRegisterOrValue(Info->StackInfo.DumpCount));
    }
    if (control & DM_DUMPMEM) {
        VrDumpDosMemory(Info->MemoryInfo.DumpType,
            GetRegisterOrValue(Info->MemoryInfo.DumpCount),
            GetRegisterOrValue(Info->MemoryInfo.Segment),
            GetRegisterOrValue(Info->MemoryInfo.Offset)
            );
    }
    if (control & DM_DUMPSTRUCT) {
        VrDumpDosMemoryStructure(Info->StructInfo.StructureDescriptor,
            GetRegisterOrValue(Info->StructInfo.Segment),
            GetRegisterOrValue(Info->StructInfo.Offset)
            );
    }
    if (control & DM_BREAK) {
        DbgBreakPoint();
    }
}

WORD
GetRegisterOrValue(
    IN  REGVAL  Union
    )

/*++

Routine Description:

    Given a REGVAL, gets the current register contents described, or the
    returns the number in the union

Arguments:

    Union   -

Return Value:

    WORD

--*/

{
    if (Union.IsRegister) {
        switch (Union.RegOrVal.Register) {
        case AX: return getAX();
        case BX: return getBX();
        case CX: return getCX();
        case DX: return getDX();
        case SI: return getSI();
        case DI: return getDI();
        case BP: return getBP();
        case SP: return getSP();
        case CS: return getCS();
        case DS: return getDS();
        case ES: return getES();
        case SS: return getSS();
        case IP: return getIP();
        case FLAGS: return GetFlags();
        }
    }

    return Union.RegOrVal.Value;
}

VOID
VrPauseBreak(
    LPDIAGNOSTIC_INFO Info
    )

/*++

Routine Description:

    Breaks into debugger if PAUSEBREAK was specified for this function/group

Arguments:

    Info    - pointer to DIAGNOSTIC_INFO for calling function

Return Value:

    None.

--*/

{
    if (Info) {
        if (Info->OnControl & DM_PAUSEBREAK) {
            DbgPrint("VrPauseBreak()\n");
            DbgBreakPoint();
        }
    }
}

VOID
VrErrorBreak(
    LPDIAGNOSTIC_INFO Info
    )

/*++

Routine Description:

    Breaks into debugger if ERRORBREAK was specified for this function/group

Arguments:

    Info    - pointer to DIAGNOSTIC_INFO for calling function

Return Value:

    None.

--*/

{
    if (Info) {
        if (Info->OnControl & DM_ERRORBREAK) {
            DbgPrint("VrErrorBreak()\n");
            DbgBreakPoint();
        }
    }
}

VOID
VrPrint(
    IN  DWORD   Level,
    IN  LPDIAGNOSTIC_INFO Context,
    IN  LPSTR   Format,
    IN  ...
    )

/*++

Routine Description:

    Displays diagnostic messages to standard diagnostic output, but filters
    depending on level of message and required level of output. Only messages
    that have a Level >= requested level for this routine/category are output

Arguments:

    Level   - of message to be displayed (DM_ERROR, DM_WARNING, DM_INFORMATION)
    Context - pointer to DIAGNOSTIC_INFO structure with info for this call
    Format  - printf-style format string
    ...     - additional value parameters

Return Value:

    None.

--*/

{
    char    print_buffer[256];  // will we need more than this?
    va_list list;

    if (Context) {
        if (Level >= (Context->OnControl & DM_DISPLAY_MASK)) {
            va_start(list, Format);
            vsprintf(print_buffer, Format, list);
            va_end(list);
            DbgPrint(print_buffer);
        }
    }
}

#ifndef DBGDBG

VOID
VrDumpRealMode16BitRegisters(
    IN  BOOL    DebugStyle
    )

/*++

Routine Description:

    Displays (to standard diagnostic display (ie com port #)) dump of 16-bit
    real-mode 80286 registers - gp registers (8), segment registers (4), flags
    register (1) instruction pointer register (1)

Arguments:

    DebugStyle  - determines look of output:

DebugStyle == TRUE:

ax=1111  bx=2222  cx=3333  dx=4444  sp=5555  bp=6666  si=7777  di=8888
ds=aaaa  es=bbbb  ss=cccc  cs=dddd  ip=iiii   fl fl fl fl fl fl fl fl

DebugStyle == FALSE:

cs:ip=cccc:iiii  ss:sp=ssss:pppp  bp=bbbb  ax=1111  bx=2222  cx=3333  dx=4444
ds:si=dddd:ssss  es:di=eeee:dddd  flags[ODIxSZxAxPxC]=fl fl fl fl fl fl fl fl

Return Value:

    None.

--*/

{
    char    flags_string[25];

    if (DebugStyle) {
        DbgPrint(
            "ax=%04x  bx=%04x  cx=%04x  dx=%04x  sp=%04x  bp=%04x  si=%04x  di=%04x\n"
            "ds=%04x  es=%04x  ss=%04x  cs=%04x  ip=%04x   %s\n\n",
            getAX(),
            getBX(),
            getCX(),
            getDX(),
            getSP(),
            getBP(),
            getSI(),
            getDI(),
            getDS(),
            getES(),
            getSS(),
            getCS(),
            getIP(),
            ConvertFlagsToString(GetFlags(), flags_string)
            );
    } else {
        DbgPrint(
            "cs:ip=%04x:%04x  ss:sp=%04x:%04x  bp=%04x  ax=%04x  bx=%04x  cx=%04x  dx=%04x\n"
            "ds:si=%04x:%04x  es:di=%04x:%04x  flags[ODITSZxAxPxC]=%s\n\n",
            getCS(),
            getIP(),
            getSS(),
            getSP(),
            getBP(),
            getAX(),
            getBX(),
            getCX(),
            getDX(),
            getDS(),
            getSI(),
            getES(),
            getDI(),
            ConvertFlagsToString(GetFlags(), flags_string)
            );
    }
}

VOID
VrDumpDosMemory(
    BYTE    Type,
    DWORD   Iterations,
    WORD    Segment,
    WORD    Offset
    )

/*++

Routine Description:

    Dumps DOS memory in one of following formats:
        Byte    0a
        Word    0123
        Dword   01234567
        Pointer 0abc:1234

    Byte format also has memory dumped as ASCII, a la debug

    Examples:

Type == 'B':
1234:5678  00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f  | ................

Type == 'W':
1234:5678  0100 0302 0504 0706 0908 0b0a 0d0c 0f0e

Type == 'D':
1234:5678  03020100 07060504 0b0a0908 0f0e0c0d

Type == 'P':
1234:5678  0302:0100 0706:0504 0b0a:0908 0f0e:0c0d

Arguments:

    Type        - of dump - 'B', 'W', 'D' or 'P'
    Iterations  - number of TYPES of data to dump (NOT number of bytes!)
    Segment     - WORD describing segment in DOS memory
    Offset      - WORD describing offset in DOS segment where dump starts

Return Value:

    None.

--*/

{
    LPSTR   dumpStr;
    LPBYTE  pointer;
    DWORD   size;
    DWORD   character;

    switch (Type) {
    case 'P':
        dumpStr = "%04x:%04x ";
        size = 4;
        break;

    case 'D':
        dumpStr = "%08x ";
        size = 4;
        break;

    case 'W':
        dumpStr = "%04x ";
        size = 2;
        break;

    case 'B':
    default:
        dumpStr = "%02x ";
        size = 1;
    }

    pointer = LPBYTE_FROM_WORDS(Segment, Offset);
    while (Iterations) {
        DWORD   i;
        DWORD   weight = BYTES_DUMPED_AT_A_TIME / size;
        DWORD   numDumps;

        DbgPrint("%04x:%04x  ", Segment, Offset);
        numDumps = Iterations > weight ? weight : Iterations;
        for (i=0; i<numDumps; ++i) {

            //
            // if type is pointer, have to extract 2 word values - first is
            // segment, second is offset. However, pointer offset is stored
            // before segment, so reverse order
            //

            if (Type == 'P') {
                DbgPrint(dumpStr, GrabDosData(pointer + 4 * i + 2, 2),
                    GrabDosData(pointer + 4 * i, 2)
                    );
            } else {
                DbgPrint(dumpStr, GrabDosData(pointer + size * i, size));
            }
        }

        //
        // dump data as ascii if bytes
        //

        if (size == 1) {
            for (i=BYTES_DUMPED_AT_A_TIME - numDumps; i; --i) {
                DbgPrint("   ");
            }
            DbgPrint(" | ");
            for (i=0; i<numDumps; ++i) {

                //
                // BUGBUG - need to modify this for MIPS
                //

                character = *(pointer + i);
                DbgPrint("%c", (character >= 0x20 && character <= 0x7f)
                    ? character : '.'
                    );
            }
        }
        DbgPrint("\n");
        Iterations -= numDumps;
        pointer += numDumps * size;
        Offset += BYTES_DUMPED_AT_A_TIME;
    }
}

VOID
VrDumpDosMemoryStructure(
    IN  LPSTR   Descriptor,
    IN  WORD    Segment,
    IN  WORD    Offset
    )

/*++

Routine Description:

    Dumps a structure in Dos memory

Arguments:

    Descriptor  - String describing the structure
    Segment     - in Dos memory where structure lives
    Offset      - in Dos memory where structure lives

Return Value:

    None.

--*/

{
    LPBYTE  bigPointer = LPBYTE_FROM_WORDS(Segment, Offset);
    LPBYTE  delimptr = strchr(Descriptor, SD_NAMESEP);
    char    namebuf[MAX_ID_LEN+1];
    int     len;
    BOOL    is_sign = FALSE;
    char*   format;
    DWORD   value;

    if (delimptr) {
//        DbgPrint("%.*s\n", (DWORD)delimptr - (DWORD)Descriptor, Descriptor);
        len = (DWORD)delimptr - (DWORD)Descriptor;
        if (len < sizeof(namebuf)) {
            strncpy(namebuf, Descriptor, len);
            namebuf[len] = 0;
            DbgPrint("Structure %s:\n", namebuf);
            Descriptor += len+1;
        }
    }
    while (*Descriptor) {
        DbgPrint("%04x:%04x ", Segment, Offset);
        delimptr = strchr(Descriptor, SD_DELIM);
        if (delimptr) {
            len = (DWORD)delimptr - (DWORD)Descriptor;
            if (len < sizeof(namebuf)) {
                strncpy(namebuf, Descriptor, len);
                namebuf[len] = 0;
                DbgPrint("%s ", namebuf);
            }
            Descriptor += len+1;
        }
        switch (*Descriptor) {
        case SD_BYTE   :
            DbgPrint("%#02x\n", (DWORD)*bigPointer & 0xff);
            ++bigPointer;
            ++Offset;
            break;

        case SD_WORD   :
            DbgPrint("%#04x\n", (DWORD)*(LPWORD)bigPointer & 0xffff);
            ++((LPWORD)bigPointer);
            Offset += sizeof(WORD);
            break;

        case SD_DWORD  :
            DbgPrint("%#08x\n", (DWORD)*(LPDWORD)bigPointer);
            ++((LPDWORD)bigPointer);
            Offset += sizeof(DWORD);
            break;

        case SD_POINTER:
            DbgPrint("%04x:%04x\n",
                (DWORD)*(((LPWORD)bigPointer)+1), (DWORD)*(LPWORD)bigPointer
                );
            ++((LPDWORD)bigPointer);
            Offset += 2 * sizeof(WORD);
            break;

        case SD_ASCIZ  :
            DbgPrint("\"%s\"\n",
                LPSTR_FROM_WORDS(*(((LPWORD)bigPointer)+1), *(LPWORD)bigPointer)
                );
            ++((LPDWORD)bigPointer);
            Offset += 2 * sizeof(WORD);
            break;

        case SD_ASCII  :
            DbgPrint("%04x:%04x \"%s\"\n",
                (DWORD)*(((LPWORD)bigPointer)+1), (DWORD)*(LPWORD)bigPointer,
                LPSTR_FROM_WORDS(*(((LPWORD)bigPointer)+1), *(LPWORD)bigPointer)
                );
            ++((LPDWORD)bigPointer);
            Offset += 2 * sizeof(WORD);
            break;

        case SD_CHAR   :
            DbgPrint("'%c'\n", (DWORD)*bigPointer & 0xff);
            ++bigPointer;
            ++Offset;
            break;

        case SD_NUM    :
            format = is_sign ? "%02d\n" : "%02u\n";
            value  = is_sign ? (long)*bigPointer : (unsigned long)*bigPointer;
            DbgPrint(format, value);
            ++bigPointer;
            ++Offset;
            is_sign = FALSE;
            break;

        case SD_INT    :
            format = is_sign ? "%04d\n" : "%04u\n";
            value  = is_sign ? (long)*(LPWORD)bigPointer : (unsigned long)*(LPWORD)bigPointer;
            DbgPrint(format, value);
            ++((LPWORD)bigPointer);
            Offset += sizeof(WORD);
            is_sign = FALSE;
            break;

        case SD_LONG   :
            format = is_sign ? "%08d\n" : "%08u\n";
            value  = is_sign ? (long)*(LPDWORD)bigPointer : (unsigned long)*(LPDWORD)bigPointer;
            DbgPrint(format, value);
            ++((LPDWORD)bigPointer);
            Offset += sizeof(DWORD);
            is_sign = FALSE;
            break;

        case SD_SIGNED :
            is_sign = TRUE;
            break;

        default:
            //
            // if we somehow got a messed up descriptor, display an error and
            // abort the dump
            //
            DbgPrint("VrDumpDosMemoryStructure: Invalid descriptor: '%s'\n",
                Descriptor);
            return ;
        }
        ++Descriptor;
        while (*Descriptor == SD_FIELDSEP) {
            ++Descriptor;
        }
    }
}

#endif

//
// private routines
//

PRIVATE
BOOL
ParseString(
    IN  LPSTR   EnvStr
    )

/*++

Routine Description:

    Given one of the __VRDEBUG environment strings, parse it using BFI algorithm
    and collect the debug/diagnostic info. The string will look something like
    one of the following:

    MAILSLOT(DisplayName, BREAK dumpregs dumpstack(32) dumpstruct(ds si "WWB4PAa"))

    Which tells us that for all the mailslot category Vr routines that we run,
    on entry, we should display the function's name, dump the 16-bit registers,
    dump 32 words of DOS stack, dump a structure addressed by ds:si and having
    the following fields:

          WORD
          WORD
          BYTE
          BYTE
          BYTE
          BYTE
          POINTER
          ASCII string
          POINTER+ASCII string

    VrNetUseEnum(BREAK INFO)

    Which tells us to break into the debugger whenever we run VrNetUseEnum and
    that any calls to VrPrint should not filter out any levels of diagnostic
    (as opposed to WARN which doesn't display INFO levels or ERROR which doesn't
    display WARN or INFO levels of diagnostic messages)

    Note: group category names are case INSENSITIVE but specific function names
    are case SENSITIVE (because C is). However, if a case-sensitive search for
    a function fails to find the required name, a case-insensitive search is
    made, just in case the name was incorrectly entered in the environment string

    Note also that diagnostic option keywords are case insensitive

    Note also also (?) that an empty function specification effectively switches
    off all options for that particular function. An empty group specification
    similarly cancels all options for that group

Arguments:

    EnvStr  - string returned from getenv. Assumed to be non-NULL

Return Value:

    TRUE if EnvironmentString parsed OK, else FALSE. If FALSE, string may have
    been partially parsed

--*/

{
    //
    // Syntax is: <group or function name>(<diagnostic options>*)*
    //
    // diagnostic options are cumulative, so if we found
    //
    //  __VRDEBUG0=NAMEPIPE(DISPLAYNAME()) NAMEPIPE(BREAK())
    //  __VRDEBUG3=NAMEPIPE(DUMPMEM(ds si 32 B))
    //
    // then we would have DISPLAYNAME, BREAK and DUMPMEM ds, si, 32, 'B' in the
    // NAMEPIPE group category entry
    //
    // If we also have
    //
    //  __VRDEBUG8=VrGetNamedPipeInfo(dumpreg)
    //
    // then when VrDiagnosticEntryPoint was called for VrGetNamedPipeInfo,
    // we would first search for VrGetNamedPipeInfo in the FUNCTION_DIAGNOSTIC
    // list then search for an entry for NAMEPIPE in the GROUP_DIAGNOSTIC array.
    // The info is merged and diagnostics run. Note that if we have something
    // like
    //
    //  __VRDEBUG5=VrGetNamedPipeInfo(dumpmem(ds si 32 B))
    //  __VRDEBUG6=NAMEPIPE(dumpmem(ds dx 80 w))
    //
    // then dumpmem(ds si 32 B) takes precedence because we assume that the
    // requirement is to override the NAMEPIPE values for this particular
    // function
    //

    TIB tib;
    TOKEN current_token = TUNKNOWN, next_token;
    int parenthesis_depth = 0;
    int n;
    DWORD expecting = EXPECTING_NOTHING;

#define EXPECTING( x )          (expecting & EXPECTING_##x)

    DWORD off_controls = 0;
    DWORD on_controls = 0;
    DWORD application_mask = DG_MAILSLOT |
                             DG_NAMEPIPE |
                             DG_LANMAN   |
                             DG_NETBIOS  |
                             DG_DLC;
    LPDIAGNOSTIC_INFO pInfo = NULL;
    LPFUNCTION_DIAGNOSTIC pFunc = NULL;
    MEMORY_INFO memory, stack;
    STRUCT_INFO structure;
    int parts_to_collect = 0;
    BOOL already_had_function = FALSE;

#if DBG
    DbgPrint("\nParseString(\"%s\")\n", EnvStr);
#endif

    if (n = probe_parens(EnvStr)) {
        DbgPrint("ParseString: Ignoring string due to unbalanced "
            "parentheses (%d level(s))\n", n);
        return FALSE;
    }

    tib.TokenStream = EnvStr;
    RtlZeroMemory(&memory, sizeof(memory));
    RtlZeroMemory(&stack, sizeof(stack));
    RtlZeroMemory(&structure, sizeof(structure));

    while (1) {
        switch (parse_token(&tib)) {
        case TLEFTPAREN:
#ifdef DBGDBG
            printf("token = TLEFTPAREN\n");
#endif
            if (!(expecting & EXPECTING_LEFTPAREN)) {
                DbgPrint("ParseString: not expecting left parenthesis\n");
                return FALSE;
            }
            ++parenthesis_depth;
            expecting &= ~EXPECTING_LEFTPAREN;
            break;

        case TRIGHTPAREN:
#ifdef DBGDBG
            printf("token = TRIGHTPAREN\n");
#endif
            if (parenthesis_depth < 0) {
                DbgPrint("ParseString: parenthesis level Error in %s\n",
                    EnvStr);
                return FALSE;
            }
            if (!(expecting & EXPECTING_RIGHTPAREN)) {
                DbgPrint("ParseString: not expecting right parenthesis\n");
                return FALSE;
            }
            if (parts_to_collect) {
                if (current_token != TDUMPSTACK) {
                    DbgPrint("ParseString: expecting register, value or descriptor\n");
                    return FALSE;
                } else {
                    stack.DumpCount.IsRegister = FALSE;
                    stack.DumpCount.RegOrVal.Value = DEFAULT_STACK_DUMP;
                }
            }
            expecting &= EXPECTING_RIGHTPAREN;
            --parenthesis_depth;
            if (!parenthesis_depth) {
                apply_controls(application_mask,
                                pFunc,
                                on_controls,
                                off_controls,
                                &memory,
                                &stack,
                                &structure
                                );
                on_controls = 0;
                off_controls = 0;
                application_mask = DG_MAILSLOT |
                                   DG_NAMEPIPE |
                                   DG_LANMAN   |
                                   DG_NETBIOS  |
                                   DG_DLC;
                if (pFunc) {
                    LPFUNCTION_DIAGNOSTIC listptr;

                    if (!FunctionList) {
                        FunctionList = pFunc;
                    } else if (!already_had_function) {
                        for (listptr = FunctionList; listptr->Next; listptr = listptr->Next);
                        listptr->Next = pFunc;
                    }
                    pFunc = NULL;
                }
                expecting = EXPECTING_NOTHING;
                parts_to_collect = 0;
                current_token = TUNKNOWN;
            }
            break;

        case TREGISTER:
        case TNUMBER:
#ifdef DBGDBG
            printf("token = TREGISTER/TNUMBER\n");
#endif
            if (!(expecting & EXPECTING_REGVAL)) {
                DbgPrint("ParseString: Not expecting register or value"
                " at this time. Got %s\n", tib.RegValOrId.Id);
                return FALSE;
            }
            if (current_token == TDUMPSTRUCT) {
                if (parts_to_collect == 3) {
                    structure.Segment = tib.RegValOrId.RegVal;
                } else if (parts_to_collect == 2) {
                    structure.Offset = tib.RegValOrId.RegVal;
                }
                if (--parts_to_collect == 1) {
                    expecting &= ~EXPECTING_REGVAL;
                }
            } else if (current_token == TDUMPMEM) {
                if (parts_to_collect == 4) {
                    memory.Segment = tib.RegValOrId.RegVal;
                } else if (parts_to_collect == 3) {
                    memory.Offset = tib.RegValOrId.RegVal;
                } else if (parts_to_collect == 2) {
                    memory.DumpCount = tib.RegValOrId.RegVal;
                }
                if (--parts_to_collect == 1) {
                    expecting &= ~EXPECTING_REGVAL;
                }
            } else if (current_token == TDUMPREGS) {
                //
                // REGS(0) => debug-style
                // REGS(!0) => vrdebug-style
                //
                if (tib.RegValOrId.RegVal.RegOrVal.Value) {
                    on_controls &= ~DM_DUMPREGSDBG;
                } else {
                    on_controls &= ~DM_DUMPREGS;
                }
                expecting &= ~EXPECTING_REGVAL;
            } else {
                stack.DumpCount = tib.RegValOrId.RegVal;
                if (!--parts_to_collect) {
                    expecting &= ~EXPECTING_REGVAL;
                }
            }
            break;

        case TEOS:
#ifdef DBGDBG
            printf("token = TEOS\n");
#endif
            if (expecting == EXPECTING_NOTHING) {
                apply_controls(application_mask,
                                pFunc,
                                on_controls,
                                off_controls,
                                &memory,
                                &stack,
                                &structure
                                );
                if (pFunc) {
                    LPFUNCTION_DIAGNOSTIC listptr;

                    if (!FunctionList) {
                        FunctionList = pFunc;
                    } else if (!already_had_function) {
                        for (listptr = FunctionList; listptr->Next; listptr = listptr->Next);
                        listptr->Next = pFunc;
                    }
                    pFunc = NULL;
                }
            } else {
                DbgPrint("ParseString: early End-Of-String\n");
            }
            return !expecting && !parenthesis_depth;

        case TUNKNOWN:
#ifdef DBGDBG
            printf("token = TUNKNOWN\n");
#endif
            //
            // can be: MEMDESC, STRUCTDESC or function id
            //

            if (current_token == TDUMPMEM) {
                if (parts_to_collect != 1) {
                    DbgPrint("ParseString: syntax error\n");
                    return FALSE;
                }
                if (!IsValidDumpDescriptor(_strupr(tib.RegValOrId.Id))) {
                    DbgPrint("ParseString: Invalid memory dump descriptor:'%s'\n",
                        tib.RegValOrId.Id);
                    return FALSE;
                }
                memory.DumpType = (BYTE)toupper(*tib.RegValOrId.Id);
                --parts_to_collect;
            } else if (current_token == TDUMPSTRUCT) {
                if (parts_to_collect != 1) {
                    DbgPrint("ParseString: syntax error\n");
                    return FALSE;
                }
                if (!IsValidStructDescriptor(_strupr(tib.RegValOrId.Id))) {
                    DbgPrint("ParseString: Invalid structure dump descriptor:'%s'\n",
                        tib.RegValOrId.Id);
                    return FALSE;
                }
                strcpy(structure.StructureDescriptor, tib.RegValOrId.Id);
                _strupr(structure.StructureDescriptor);
                --parts_to_collect;
            } else {
                if (!(pFunc = FindFuncDiags(tib.RegValOrId.Id))) {
                    pFunc = AllocFuncDiags(tib.RegValOrId.Id);
                    already_had_function = FALSE;
                } else {
                    already_had_function = TRUE;
                }
                if (!pFunc) {
                    DbgPrint("ParseString: out of memory getting struct "
                        "for %s. Aborting!\n", tib.RegValOrId.Id);
                    return FALSE;
                }
                application_mask = 0;   // no groups
                expecting |= EXPECTING_LEFTPAREN;
            }
            break;

        case TBREAK:
#ifdef DBGDBG
            printf("token = TBREAK\n");
#endif
            if ((expecting != EXPECTING_NOTHING) && !(expecting & EXPECTING_RIGHTPAREN)) {
                DbgPrint("ParseString: syntax error\n");
                return FALSE;
            }
            next_token = peek_token(&tib);
            if (next_token == TLEFTPAREN) {
                on_controls |= DM_BREAK;
                expecting = EXPECTING_LEFTPAREN | EXPECTING_RIGHTPAREN;
            } else if (next_token == TRIGHTPAREN || next_token == TEOS) {
                off_controls |= DM_BREAK;
            } else if (IsKeywordToken(next_token)) {
                off_controls |= DM_BREAK;
                expecting &= EXPECTING_RIGHTPAREN;
            } else {
                DbgPrint("ParseString: bad syntax for BREAK\n");
                return FALSE;
            }
            break;

        case TDISPLAYNAME:
#ifdef DBGDBG
            printf("token = TDISPLAYMEM\n");
#endif
            if ((expecting != EXPECTING_NOTHING) && !(expecting & EXPECTING_RIGHTPAREN)) {
                DbgPrint("ParseString: syntax error\n");
                return FALSE;
            }
            next_token = peek_token(&tib);
            if (peek_token(&tib) == TLEFTPAREN) {
                on_controls |= DM_DISPLAYNAME;
                expecting = EXPECTING_LEFTPAREN | EXPECTING_RIGHTPAREN;
            } else if (IsKeywordToken(next_token)) {
                off_controls |= DM_DISPLAYNAME;
                expecting &= EXPECTING_RIGHTPAREN;
            } else {
                DbgPrint("ParseString: bad syntax for DISPLAYNAME\n");
                return FALSE;
            }
            break;

        case TDLC:
#ifdef DBGDBG
            printf("token = TDLC\n");
#endif
            if (expecting != EXPECTING_NOTHING) {
                DbgPrint("ParseString: syntax error\n");
                return FALSE;
            }
            application_mask = DG_DLC;
            pInfo = &VrDiagnosticGroups[DI_DLC].Diagnostic;
            on_controls = off_controls = 0;
            RtlZeroMemory(&memory, sizeof(memory));
            RtlZeroMemory(&stack, sizeof(stack));
            RtlZeroMemory(&structure, sizeof(structure));
            pFunc = NULL;
            if (peek_token(&tib) == TLEFTPAREN) {
                expecting = EXPECTING_LEFTPAREN | EXPECTING_RIGHTPAREN;
            } else {
                expecting = EXPECTING_NOTHING;
            }
            break;

        case TDUMPMEM:
#ifdef DBGDBG
            printf("token = TDUMPMEM\n");
#endif
            if ((expecting != EXPECTING_NOTHING) && !(expecting & EXPECTING_RIGHTPAREN)) {
                DbgPrint("ParseString: syntax error\n");
                return FALSE;
            }
            current_token = TDUMPMEM;
            next_token = peek_token(&tib);
            if (peek_token(&tib) == TLEFTPAREN) {
                on_controls |= DM_DUMPMEM;
                expecting = EXPECTING_LEFTPAREN | EXPECTING_RIGHTPAREN | EXPECTING_REGVAL;
                parts_to_collect = 4;
            } else if (IsKeywordToken(next_token)) {
                off_controls |= DM_DUMPMEM;
                expecting &= EXPECTING_RIGHTPAREN;
            } else {
                DbgPrint("ParseString: bad syntax for DUMPMEM\n");
                return FALSE;
            }
            break;

        case TDUMPREGS:
#ifdef DBGDBG
            printf("token = TDUMPREGS\n");
#endif
            if ((expecting != EXPECTING_NOTHING) && !(expecting & EXPECTING_RIGHTPAREN)) {
                DbgPrint("ParseString: syntax error\n");
                return FALSE;
            }
            current_token = TDUMPREGS;
            next_token = peek_token(&tib);
            if (next_token == TLEFTPAREN) {
                on_controls |= DM_DUMPREGS|DM_DUMPREGSDBG;
                expecting = EXPECTING_LEFTPAREN | EXPECTING_RIGHTPAREN | EXPECTING_REGVAL;
            } else if (IsKeywordToken(next_token)) {
                off_controls |= DM_DUMPREGS;
                expecting &= EXPECTING_RIGHTPAREN;
            } else {
                DbgPrint("ParseString: bad syntax for DUMPREGS\n");
                return FALSE;
            }
            break;

        case TDUMPSTACK:
#ifdef DBGDBG
            printf("token = TDUMPSTACK\n");
#endif
            if ((expecting != EXPECTING_NOTHING) && !(expecting & EXPECTING_RIGHTPAREN)) {
                DbgPrint("ParseString: syntax error\n");
                return FALSE;
            }
            current_token = TDUMPSTACK;
            next_token = peek_token(&tib);
            if (peek_token(&tib) == TLEFTPAREN) {
                on_controls |= DM_DUMPSTACK;
                expecting |= EXPECTING_LEFTPAREN | EXPECTING_RIGHTPAREN | EXPECTING_REGVAL;
                parts_to_collect = 1;
            } else if (IsKeywordToken(next_token)) {
                off_controls |= DM_DUMPSTACK;
                expecting &= EXPECTING_RIGHTPAREN;
            } else {
                DbgPrint("ParseString: bad syntax for DUMPSTACK\n");
                return FALSE;
            }
            break;

        case TDUMPSTRUCT:
#ifdef DBGDBG
            printf("token = TDUMPSTRUCT\n");
#endif
            if ((expecting != EXPECTING_NOTHING) && !(expecting & EXPECTING_RIGHTPAREN)) {
                DbgPrint("ParseString: syntax error\n");
                return FALSE;
            }
            current_token = TDUMPSTRUCT;
            next_token = peek_token(&tib);
            if (peek_token(&tib) == TLEFTPAREN) {
                on_controls |= DM_DUMPSTRUCT;
                expecting = EXPECTING_LEFTPAREN | EXPECTING_RIGHTPAREN | EXPECTING_REGVAL;
                parts_to_collect = 3;
            } else if (IsKeywordToken(next_token)) {
                off_controls |= DM_DUMPSTRUCT;
                expecting &= EXPECTING_RIGHTPAREN;
            } else {
                DbgPrint("ParseString: bad syntax for DUMPSTRUCT\n");
                return FALSE;
            }
            break;

        case TERROR:    //aaiegh!
#ifdef DBGDBG
            printf("token = TERROR\n");
#endif
            if ((expecting != EXPECTING_NOTHING) && !(expecting & EXPECTING_RIGHTPAREN)) {
                DbgPrint("ParseString: syntax error\n");
                return FALSE;
            }
            next_token = peek_token(&tib);
            if (peek_token(&tib) == TLEFTPAREN) {
                on_controls |= DM_ERROR;
                expecting = EXPECTING_LEFTPAREN | EXPECTING_RIGHTPAREN;
            } else if (IsKeywordToken(next_token)) {
                off_controls |= DM_ERROR;
                expecting &= EXPECTING_RIGHTPAREN;
            } else {
                DbgPrint("ParseString: bad syntax for ERROR\n");
                return FALSE;
            }
            break;

        case TERRORBREAK:   //phew! But I'd rather have a TBREAK
#ifdef DBGDBG
            printf("token = TERRORBREAK\n");
#endif
            if ((expecting != EXPECTING_NOTHING) && !(expecting & EXPECTING_RIGHTPAREN)) {
                DbgPrint("ParseString: syntax error\n");
                return FALSE;
            }
            next_token = peek_token(&tib);
            if (peek_token(&tib) == TLEFTPAREN) {
                on_controls |= DM_ERRORBREAK;
                expecting = EXPECTING_LEFTPAREN | EXPECTING_RIGHTPAREN;
            } else if (IsKeywordToken(next_token)) {
                off_controls |= DM_ERRORBREAK;
                expecting &= EXPECTING_RIGHTPAREN;
            } else {
                DbgPrint("ParseString: bad syntax for ERRORBREAK\n");
                return FALSE;
            }
            break;

        case TINFO:
#ifdef DBGDBG
            printf("token = TINFO\n");
#endif
            if ((expecting != EXPECTING_NOTHING) && !(expecting & EXPECTING_RIGHTPAREN)) {
                DbgPrint("ParseString: syntax error\n");
                return FALSE;
            }
            next_token = peek_token(&tib);
            if (peek_token(&tib) == TLEFTPAREN) {
                on_controls |= DM_INFORMATION;
                expecting = EXPECTING_LEFTPAREN | EXPECTING_RIGHTPAREN;
            } else if (IsKeywordToken(next_token)) {
                off_controls |= DM_INFORMATION;
                expecting &= EXPECTING_RIGHTPAREN;
            } else {
                DbgPrint("ParseString: bad syntax for INFO\n");
                return FALSE;
            }
            break;

        case TLANMAN:
#ifdef DBGDBG
            printf("token = TLANMAN\n");
#endif
            if (expecting != EXPECTING_NOTHING) {
                DbgPrint("ParseString: syntax error\n");
                return FALSE;
            }
            application_mask = DG_LANMAN;
            pInfo = &VrDiagnosticGroups[DI_LANMAN].Diagnostic;
            on_controls = off_controls = 0;
            RtlZeroMemory(&memory, sizeof(memory));
            RtlZeroMemory(&stack, sizeof(stack));
            RtlZeroMemory(&structure, sizeof(structure));
            pFunc = NULL;
            if (peek_token(&tib) == TLEFTPAREN) {
                expecting = EXPECTING_LEFTPAREN | EXPECTING_RIGHTPAREN;
            } else {
                expecting = EXPECTING_NOTHING;
            }
            break;

        case TMAILSLOT:
#ifdef DBGDBG
            printf("token = TMAILSLOT\n");
#endif
            if (expecting != EXPECTING_NOTHING) {
                DbgPrint("ParseString: syntax error\n");
                return FALSE;
            }
            application_mask = DG_MAILSLOT;
            pInfo = &VrDiagnosticGroups[DI_MAILSLOT].Diagnostic;
            on_controls = off_controls = 0;
            RtlZeroMemory(&memory, sizeof(memory));
            RtlZeroMemory(&stack, sizeof(stack));
            RtlZeroMemory(&structure, sizeof(structure));
            pFunc = NULL;
            if (peek_token(&tib) == TLEFTPAREN) {
                expecting = EXPECTING_LEFTPAREN | EXPECTING_RIGHTPAREN;
            } else {
                expecting = EXPECTING_NOTHING;
            }
            break;

        case TNAMEPIPE:
#ifdef DBGDBG
            printf("token = TNAMEPIPE\n");
#endif
            if (expecting != EXPECTING_NOTHING) {
                DbgPrint("ParseString: syntax error\n");
                return FALSE;
            }
            application_mask = DG_NAMEPIPE;
            pInfo = &VrDiagnosticGroups[DI_NAMEPIPE].Diagnostic;
            on_controls = off_controls = 0;
            RtlZeroMemory(&memory, sizeof(memory));
            RtlZeroMemory(&stack, sizeof(stack));
            RtlZeroMemory(&structure, sizeof(structure));
            pFunc = NULL;
            if (peek_token(&tib) == TLEFTPAREN) {
                expecting = EXPECTING_LEFTPAREN | EXPECTING_RIGHTPAREN;
            } else {
                expecting = EXPECTING_NOTHING;
            }
            break;

        case TNETBIOS:
#ifdef DBGDBG
            printf("token = TNETBIOS\n");
#endif
            if (expecting != EXPECTING_NOTHING) {
                DbgPrint("ParseString: syntax error\n");
                return FALSE;
            }
            application_mask = DG_NETBIOS;
            pInfo = &VrDiagnosticGroups[DI_NETBIOS].Diagnostic;
            on_controls = off_controls = 0;
            RtlZeroMemory(&memory, sizeof(memory));
            RtlZeroMemory(&stack, sizeof(stack));
            RtlZeroMemory(&structure, sizeof(structure));
            pFunc = NULL;
            if (peek_token(&tib) == TLEFTPAREN) {
                expecting = EXPECTING_LEFTPAREN | EXPECTING_RIGHTPAREN;
            } else {
                expecting = EXPECTING_NOTHING;
            }
            break;

        case TPAUSEBREAK:
#ifdef DBGDBG
            printf("token = TPAUSEBREAK\n");
#endif
            if ((expecting != EXPECTING_NOTHING) && !(expecting & EXPECTING_RIGHTPAREN)) {
                DbgPrint("ParseString: syntax error\n");
                return FALSE;
            }
            next_token = peek_token(&tib);
            if (peek_token(&tib) == TLEFTPAREN) {
                on_controls |= DM_PAUSEBREAK;
                expecting = EXPECTING_LEFTPAREN | EXPECTING_RIGHTPAREN;
            } else if (IsKeywordToken(next_token)) {
                off_controls |= DM_PAUSEBREAK;
                expecting &= EXPECTING_RIGHTPAREN;
            } else {
                DbgPrint("ParseString: bad syntax for PAUSEBREAK\n");
                return FALSE;
            }
            break;

        case TWARN:
#ifdef DBGDBG
            printf("token = TWARN\n");
#endif
            if ((expecting != EXPECTING_NOTHING) && !(expecting & EXPECTING_RIGHTPAREN)) {
                DbgPrint("ParseString: syntax error\n");
                return FALSE;
            }
            next_token = peek_token(&tib);
            if (peek_token(&tib) == TLEFTPAREN) {
                on_controls |= DM_WARNING;
                expecting = EXPECTING_LEFTPAREN | EXPECTING_RIGHTPAREN;
            } else if (IsKeywordToken(next_token)) {
                off_controls |= DM_WARNING;
                expecting &= EXPECTING_RIGHTPAREN;
            } else {
                DbgPrint("ParseString: bad syntax for WARN\n");
                return FALSE;
            }
            break;
        }
    }
}

PRIVATE
int
probe_parens(
    LPSTR   str
    )

/*++

Routine Description:

    Probes env string and returns balance of parentheses. Number of parentheses
    may balance, but string could still break syntax. First line of defence

Arguments:

    str - pointer to string containing parentheses to check balance for

Return Value:

    int number of levels by which parentheses don't balance, or 0 if they do.
    -ve number means more right parens than left

--*/

{
    int balance = 0;
    while (*str) {
        if (*str == '(') {
            ++balance;
        } else if (*str == ')') {
            --balance;
        }
        ++str;
    }
    return balance;
}

PRIVATE
VOID
apply_controls(
    IN  DWORD   mask,
    IN  LPFUNCTION_DIAGNOSTIC lpFunc,
    IN  DWORD   on_controls,
    IN  DWORD   off_controls,
    IN  LPMEMORY_INFO lpMemory,
    IN  LPMEMORY_INFO lpStack,
    IN  LPSTRUCT_INFO lpStructure
    )
{
    DWORD   bit = 1;
    DWORD   index = 0;

    if (on_controls & DM_DUMPSTACK) {
        lpStack->Segment.IsRegister = TRUE;
        lpStack->Segment.RegOrVal.Register = SS;
        lpStack->Offset.IsRegister = TRUE;
        lpStack->Offset.RegOrVal.Register = SP;
        lpStack->DumpType = SD_WORD;
    }
    if (lpFunc) {
        apply_diags(&lpFunc->Diagnostic,
                    on_controls,
                    off_controls,
                    lpMemory,
                    lpStack,
                    lpStructure
                    );
    } else {
        while (bit) {
            if (mask & bit) {
                apply_diags(&VrDiagnosticGroups[index].Diagnostic,
                            on_controls,
                            off_controls,
                            lpMemory,
                            lpStack,
                            lpStructure
                            );
            }
            bit <<= 1;
            ++index;
        }
    }
}

PRIVATE
VOID
apply_diags(
    IN  LPDIAGNOSTIC_INFO lpDiags,
    IN  DWORD   on_controls,
    IN  DWORD   off_controls,
    IN  LPMEMORY_INFO lpMemory,
    IN  LPMEMORY_INFO lpStack,
    IN  LPSTRUCT_INFO lpStructure
    )
{
    lpDiags->OnControl |= on_controls;
    lpDiags->OffControl |= off_controls;
    if (on_controls & DM_DUMPMEM) {
        *(&(lpDiags->MemoryInfo)) = *lpMemory;
    }
    if (on_controls & DM_DUMPSTACK) {
        *(&(lpDiags->StackInfo)) = *lpStack;
    }
    if (on_controls & DM_DUMPSTRUCT) {
        *(&lpDiags->StructInfo) = *lpStructure;
    }
}

PRIVATE
LPFUNCTION_DIAGNOSTIC
FindFuncDiags(
    IN  LPSTR   function_name
    )
{
    LPFUNCTION_DIAGNOSTIC ptr;

    //
    // as promised: search w/ case, then w/o case
    //

    for (ptr = FunctionList; ptr; ptr = ptr->Next) {
        if (!strcmp(function_name, ptr->FunctionName)) {
            return ptr;
        }
    }
    for (ptr = FunctionList; ptr; ptr = ptr->Next) {
        if (!_stricmp(function_name, ptr->FunctionName)) {
            return ptr;
        }
    }
    return NULL;
}

PRIVATE
LPFUNCTION_DIAGNOSTIC
AllocFuncDiags(
    IN  LPSTR   function_name
    )
{
    LPFUNCTION_DIAGNOSTIC result;

    result = calloc(1, sizeof(FUNCTION_DIAGNOSTIC));
    if (result) {
        strcpy(result->FunctionName, function_name);
    }
    return result;
}

TOKEN parse_token(LPTIB pTib) {
    LPSTR   ptr = pTib->TokenStream;
    TOKEN   token;

    ptr = skip_ws(ptr);
    if (!*ptr) {
        token = TEOS;
    } else if (*ptr == '(' ) {
        token = TLEFTPAREN;
        ++ptr;
    } else if (*ptr == ')') {
        token = TRIGHTPAREN;
        ++ptr;
    } else {
        char*   tokstr;
        REGVAL  regval;

        //
        // got some other type of token. This bit leaves ptr pointing at ws or EOS
        //

        tokstr = extract_token(pTib, &ptr);
        if (IsLexRegister(tokstr, &regval)) {
            token = TREGISTER;
            pTib->RegValOrId.RegVal = regval;
        } else if (IsLexNumber(tokstr, &regval)) {
            token = TNUMBER;
            pTib->RegValOrId.RegVal = regval;
        } else if (!IsLexKeyword(tokstr, &token)){
            token = TUNKNOWN;
        }

#ifdef DBGDBG
        printf("parse_token: token = %s\n", tokstr);
#endif

    }
    pTib->TokenStream = ptr; // pointer to next token (if any)
    pTib->Token = token;
    return token;
}

TOKEN peek_token(LPTIB pTib) {
    LPSTR ptr;
    TOKEN token;

    //
    // gets next token type, but doesn't update TIB
    //

    ptr = skip_ws(pTib->TokenStream);
    if (!*ptr) {
        return TEOS;
    } else if (*ptr == '(' ) {
        return TLEFTPAREN;
    } else if (*ptr == ')') {
        return TRIGHTPAREN;
    } else {
        char*   tokstr;
        REGVAL  regval;

        tokstr = extract_token(pTib, &ptr);
        if (IsLexRegister(tokstr, &regval)) {
            return TREGISTER;
        }
        if (IsLexNumber(tokstr, &regval)) {
            return TNUMBER;
        }
        if (IsLexKeyword(tokstr, &token)) {
            return token;
        }
    }
    return TUNKNOWN;    // don't require anything else
}

LPSTR skip_ws(LPSTR str) {
    while (*str && (*str == ' '|| *str == '\t' || *str == ',')) {
        ++str;
    }
    return str;
}

LPSTR search_delim(LPSTR str) {
    // strpbrk(str, " \t,()");
    while (*str
        && !(*str == ' '
            || *str == '\t'
            || *str == ','
            || *str == '('
            || *str == ')'
            )
        ) {
        ++str;
    }
    return str;
}

LPSTR extract_token(LPTIB pTib, LPSTR* token_stream) {
    LPSTR   ptr;
    DWORD   len;

    ptr = search_delim(*token_stream);
    len = (DWORD)ptr - (DWORD)*token_stream;
    if (!len) {
        return NULL;
    }
    strncpy(pTib->RegValOrId.Id, *token_stream, len);
    pTib->RegValOrId.Id[len] = 0;
    *token_stream = ptr;
    return pTib->RegValOrId.Id;
}

BOOL IsLexKeyword(LPSTR tokstr, TOKEN* pToken) {
    int i;

    for (i = 0; i < NUMBER_OF_RECOGNIZABLE_TOKENS; ++i) {
        if (!_stricmp(tokstr, DiagnosticTokens[i].TokenString)) {
            *pToken = DiagnosticTokens[i].Token;
            return TRUE;
        }
    }
    return FALSE;
}

BOOL IsLexRegister(LPSTR tokstr, LPREGVAL lpRegVal) {
    int i;

    if (strlen(tokstr) == 2) {
        for (i = 0; i < NUMBER_OF_CPU_REGISTERS; ++i) {
            if (!_stricmp(tokstr, Registers[i].RegisterName)) {
                lpRegVal->IsRegister = TRUE;
                lpRegVal->RegOrVal.Register = Registers[i].Register;
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL IsLexNumber(LPSTR tokstr, LPREGVAL lpRegVal) {
    WORD    number = 0;
    BOOL    yes = FALSE;

    //
    // go round this loop until no more hex digits. Too bad if we entered 5
    // digits - number will be overflowed and results unpredictable, but its
    // only debug code
    //

    if (!_strnicmp(tokstr, "0x", 2)) {
        tokstr += 2;
        yes = isxdigit(*tokstr);
        while (isxdigit((int)*tokstr)) {
            number = number * (WORD)16 + hex((char)*tokstr);
            ++tokstr;
        }
    } else if (yes = isdigit(*tokstr)) {
        number = (WORD)atoi(tokstr);
    }
    if (yes) {
        lpRegVal->IsRegister = FALSE;
        lpRegVal->RegOrVal.Value = number;
    }
    return yes;
}

WORD hex(char hexch) {
    return hexch <= '9' ? (WORD)(hexch - '0')
        : (WORD)(toupper(hexch) - ('0' + ('A' - ('9' + 1))));
}

BOOL IsKeywordToken(TOKEN token) {
    return token >= TBREAK && token <= TWARN;
}

BOOL IsValidDumpDescriptor(char* str) {
    static char md_chars[] = MD_CHARS;
    if (strlen(str) > 1) {
        return FALSE;
    }
    return strchr(md_chars, *str) != NULL;
}

BOOL IsValidStructDescriptor(char* str) {
    static char sd_chars[] = SD_CHARS;
    unsigned len = strlen(str);
//    return (len <= MAX_DESC_LEN) ? (strspn(str, sd_chars) == len) : FALSE;
    return (len <= MAX_DESC_LEN);
}

PRIVATE
LPSTR
ConvertFlagsToString(
    IN  WORD    FlagsRegister,
    OUT LPSTR   Buffer
    )

/*++

Routine Description:

    Given a 16-bit word, interpret bit positions as for x86 Flags register
    and produce descriptive string of flags state (as per debug) eg:

        NV UP DI PL NZ NA PO NC     ODItSZxAxPxC = 000000000000b
        OV DN EI NG ZR AC PE CY     ODItSZxAxPxC = 111111111111b

    Trap Flag (t) is not dumped since this has no interest for programs which
    are not debuggers or don't examine program execution (ie virtually none)

Arguments:

    FlagsRegister   - 16-bit flags
    Buffer          - place to store string. Requires 25 bytes inc \0

Return Value:

    Address of <Buffer>

--*/

{
    static char* flags_states[16][2] = {
        //0     1
        "NC", "CY", // CF (0x0001) - Carry
        "",   "",   // x  (0x0002)
        "PO", "PE", // PF (0x0004) - Parity
        "",   "",   // x  (0x0008)
        "NA", "AC", // AF (0x0010) - Aux (half) carry
        "",   "",   // x  (0x0020)
        "NZ", "ZR", // ZF (0x0040) - Zero
        "PL", "NG", // SF (0x0080) - Sign
        "",   "",   // TF (0x0100) - Trap (not dumped)
        "DI", "EI", // IF (0x0200) - Interrupt
        "UP", "DN", // DF (0x0400) - Direction
        "NV", "OV", // OF (0x0800) - Overflow
        "",   "",   // x  (0x1000) - (I/O Privilege Level) (not dumped)
        "",   "",   // x  (0x2000) - (I/O Privilege Level) (not dumped)
        "",   "",   // x  (0x4000) - (Nested Task) (not dumped)
        "",   ""    // x  (0x8000)
    };
    int i;
    WORD bit;
    BOOL on;

    *Buffer = 0;
    for (bit=0x0800, i=11; bit; bit >>= 1, --i) {
        on = (BOOL)((FlagsRegister & bit) == bit);
        if (flags_states[i][on][0]) {
            strcat(Buffer, flags_states[i][on]);
            strcat(Buffer, " ");
        }
    }
    return Buffer;
}

#ifndef DBGDBG

PRIVATE
WORD
GetFlags(
    VOID
    )

/*++

Routine Description:

    Supplies the missing softpc function

Arguments:

    None.

Return Value:

    Conglomerates softpc flags into x86 flags word

--*/

{
    WORD    flags;

    flags = (WORD)getCF();
    flags |= (WORD)getPF() << 2;
    flags |= (WORD)getAF() << 4;
    flags |= (WORD)getZF() << 6;
    flags |= (WORD)getSF() << 7;
    flags |= (WORD)getIF() << 9;
    flags |= (WORD)getDF() << 10;
    flags |= (WORD)getOF() << 11;

    return flags;
}

#endif

PRIVATE
DWORD
GrabDosData(
    IN  LPBYTE  DosMemoryPointer,
    IN  DWORD   DataSize
    )

/*++

Routine Description:

    Reads one basic data element from DOS memory in a certain format (BYTE, WORD
    or DWORD)

Arguments:

    DosMemoryPointer    - Flat 32-bit pointer to place in DOS memory from where
                          to read data
    DataSize            - size (in bytes) of data to read - 1, 2 or 4

Return Value:

    DWORD - value read from DOS memory

--*/

{
    switch (DataSize) {
    case 1:
        return (DWORD)*DosMemoryPointer;

    case 2:
        return (DWORD)*((LPWORD)DosMemoryPointer);

    case 4:
        return (DWORD)*((LPDWORD)DosMemoryPointer);
    }
    return 0;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\vrdlc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems

Module Name:

    vrdlc.h

Abstract:

    This module is the only header file of Windows/Nt VDM DLC
    interface module.

    ALL STRUCTURES IN THIS FILE WHICH REFERENCE STRUCTURES IN DOS MEMORY
    ARE BYTE PACKED

Author:

    Antti Saarenheimo (o-anttis) 26-01-1992

Revision History:

--*/

//
// constants
//

#define DOS_DLC_MAX_SAPS                128
#define DOS_DLC_MAX_LINKS               255
#define DOS_DLC_MAX_EVENTS              64

#define LLC_DIR_MODIFY_OPEN_PARMS       0x01
#define LLC_DIR_RESTORE_OPEN_PARMS      0x02
#define LLC_DIR_SET_USER_APPENDAGE      0x2d
#define LLC_DOS_SPECIAL_COMMAND         ((ULONG)(-1))
#define LLC_BREAK                       0x20

#define DOS_DLC_STATUS_NO_INDICATION    0x81

#define LLC_SET_LOCAL_BUSY_BUFFER       0x20

//
// VRDLC_COMMAND_COMPLETION - this value is placed in the CCB_CMD_CMPL field
// of every CCB2 that we issue that is NOT for the VDM. This value is used to
// filter out command completions for commands that are generated by the DOS
// DLC Emulator. This stops us passing command completions through to the
// VDM that are not intended for it!
//

#define VRDLC_COMMAND_COMPLETION        ((ULONG)(-2))

//
// buffer pool sizes
//

#define DOS_DLC_BUFFER_POOL_SIZE   0x00010000   // 64K
#define DOS_DLC_MIN_FREE_THRESHOLD 0x00002000   //  8K

//
// flags for CopyFrame
//

#define CF_CONTIGUOUS               0x00000001  // frame is contiguous
#define CF_BREAK                    0x00000002  // options specified Break
#define CF_PARTIAL                  0x00000004  // receiving partial frame

//
// default values for DOS parameter tables (DD_ = DOS DEFAULT). These replace
// the various parameters which can be specified as 0. They may be different
// to the corresponding defaults applicable to NT DLC, so we fill them in
// specifically
//

//
// defaults for BUFFER.GET:
//

#define DD_BUFFER_GET           1

//
// defaults for DIR.INITIALIZE:
//

#define DD_SRAM_ADDRESS_0       0xd800
#define DD_SRAM_ADDRESS_1       0xd400

//
// defaults for DIR.OPEN.ADAPTER, ADAPTER_PARMS:
//

#define DD_NUMBER_RCV_BUFFERS   8
#define DD_RCV_BUFFER_LENGTH    112
#define DD_DHB_BUFFER_LENGTH    600
#define DD_DATA_HOLD_BUFFERS    1

//
// defaults for DIR.OPEN.ADAPTER, DIRECT_PARMS:
//

#define DD_DIR_BUF_SIZE         160
#define DD_DIR_POOL_BLOCKS      256

//
// defaults for DIR.OPEN.ADAPTER, DLC_PARMS:
//

#define DD_DLC_MAX_SAP          2
#define DD_DLC_MAX_STATIONS     6
#define DD_DLC_MAX_GSAP         0
#define DD_DLC_T1_TICK_ONE      5
#define DD_DLC_T2_TICK_ONE      1
#define DD_DLC_Ti_TICK_ONE      25
#define DD_DLC_T1_TICK_TWO      25
#define DD_DLC_T2_TICK_TWO      10
#define DD_DLC_Ti_TICK_TWO      125

//
// defaults for DLC.OPEN.SAP:
//

#define DD_MAXOUT               2
#define DD_MAXIN                1
#define DD_MAX_RETRY_COUNT      8
#define DD_MAX_I_FIELD          600
#define DD_DLC_BUF_SIZE         160
#define DD_DLC_POOL_LEN         256

//
// macros
//

//
// DOS_PTR_TO_FLAT - given a DOS 16:16 pointer stored implicitly as a DWORD
//

#define DOS_PTR_TO_FLAT(a)  (PVOID)GetVDMAddr(HIWORD(a), LOWORD(a))

//
// NEW_DOS_ADDRESS - generate a new DOS_ADDRESS, given a base DOS_ADDRESS and
// a new pointer which is some number of bytes plus the base DOS_ADDRESS
// converted to a flat pointer. For example, a DOS_ADDRESS of 1234:0000 becomes
// (on x86) a flat pointer of 0x12340. We generate a new pointer 0x12380 and
// want to convert this address back to a DOS_ADDRESS. So we use this macro.
// Offset-wrap and segment update is automatically handled
//

#define NEW_DOS_ADDRESS(b, p)   ((b) + ((DWORD)(p) - (DWORD)DOS_PTR_TO_FLAT(b)))

//
// POOL_INDEX_FROM_SAP - get the index in aBufferPools for a given SAP/adapter
// combination. There are a maximum 127 SAPs per adapter, and 2 adapters which
// are available to DOS
//

#define POOL_INDEX_FROM_SAP(Sap, Adapter)   ((Sap & 0xfe) | Adapter)

//
// POOL_INDEX_FROM_ID - given a station ID (high byte = SAP, low byte = link
// station), get the index to the SAP's buffer pool in aBufferPools
//

#define POOL_INDEX_FROM_ID(Id, Adapter)     POOL_INDEX_FROM_SAP(HIBYTE(Id), Adapter)

//
// GET_POOL_INDEX - the original pool index macro
//

#define GET_POOL_INDEX(Adapter, usStationId)    POOL_INDEX_FROM_ID(usStationId, Adapter)

//
// macros which initialize CCBs and call AcsLan
//

#define DlcFlowControl(Adapter, StationId, Options)\
            LlcCommand(Adapter, LLC_DLC_FLOW_CONTROL, ((DWORD)Options << 16) + StationId)

#define DosDlcFlowControl(Adapter, StationId, Options)\
            LlcCommand(Adapter, LLC_DOS_DLC_FLOW_CONTROL, ((DWORD)Options << 16) + StationId)

#define InitializeCcb(pCcb, AdapterNumber, Command, pParameter) \
            RtlZeroMemory((pCcb), sizeof(*(pCcb)));\
            RtlZeroMemory((pParameter), sizeof(*(pParameter)));\
            (pCcb)->uchAdapterNumber = (UCHAR)AdapterNumber;\
            (pCcb)->uchDlcCommand = (UCHAR)Command;\
            (pCcb)->u.pParameterTable = (PLLC_PARMS)(pParameter)

#define InitializeCcb2(pCcb, AdapterNumber, Command) \
            RtlZeroMemory((pCcb), sizeof(*(pCcb)));\
            (pCcb)->uchAdapterNumber = (UCHAR)AdapterNumber;\
            (pCcb)->uchDlcCommand = (UCHAR)Command;

#define ReceiveCancel(AdapterNumber, pCcb) \
            LlcCommand(AdapterNumber, LLC_RECEIVE_CANCEL, (DWORD)pCcb)

//
// DLC_ERROR_STATUS - after calling AcsLan, if an error was returned by AcsLan
// then return that, else get the return code out of the CCB and return that
//

#define DLC_ERROR_STATUS(AcslanStatus, uchDlcStatus) \
            (DWORD)((AcslanStatus == 0) ? (DWORD)uchDlcStatus : (DWORD)AcslanStatus)

//
// VRDLC_ALLOC - standard allocation strategy in VDM REDIR DLC functions
//

#define VRDLC_ALLOC(Bytes)  LocalAlloc(LMEM_FIXED, Bytes)

//
// VRDLC_FREE - companion to VRDLC_ALLOC - standard allocation free strategy
//

#define VRDLC_FREE(Pointer) LocalFree((HLOCAL)Pointer)

//
// SAP_ID - get the SAP from a station ID word. Used as array index 0..127
// (corresponding to SAP 0..254 step 2)
//

#define SAP_ID(stationId)   (HIBYTE(stationId) >> 1)

//
// LINK_ID - get the link station ID from a station ID word. Used as array index
// 0..254 (corresponding to link station 1..255)
//

#define LINK_ID(stationId)  (LOBYTE(stationId) - 1)
//
// types
//

union _LLC_DOS_PARMS;
typedef union _LLC_DOS_PARMS LLC_DOS_PARMS, *PLLC_DOS_PARMS;
typedef DWORD DOS_ADDRESS;
typedef DOS_ADDRESS DPLLC_DOS_BUFFER;

//
// LLC_DOS_BUFFER - this is a union of all the DOS DLC data buffers. There are
// basically 3 kinds: Buffer 1, the first buffer in a chain which contains net
// address info, this can be in contigous or non-contiguous form, and Buffer 2
// format which is the 2nd and subsequent buffers in a chain. DLC uses the
// buffers for received data. Transmit data (passed from the app to DLC) can
// use a buffer (or chain of buffers) from the pool or can source its own
// buffer. The latter is preferred since taking buffers which DLC would use
// for receiving data can leave DLC in the local busy state (ie no receive
// buffers)
//

#include <packon.h>

typedef union _LLC_DOS_BUFFER {

    //
    // pNext is just a pointer so we can follow the chain
    //

    union _LLC_DOS_BUFFER * pNext;

    //
    // NextDosBuffer is the Buffer 2 structure defined in the IBM Lan Tech.
    // Ref. pg 2-45
    //

    struct _NextDosBuffer {
        union _LLC_DOS_BUFFER * pNextBuffer;// next frame segment
        WORD        cbFrame;                // length of the whole rcvd frame
        WORD        cbBuffer;               // length of this segment
        WORD        offUserData;            // offset of data from descr header
        WORD        cbUserData;             // length of the data
    } Next;

    //
    // NotContiguous is the Not contiguous MAC/Data Buffer 1 structure defined
    // in IBM Lan Tech. Ref. pg 2-42
    //

    struct _DosDlcNotContiguousFirstBuffer {
        union _LLC_DOS_BUFFER * pNextBuffer;  // next frame segment
        WORD            cbFrame;        // length of entire frame
        WORD            cbBuffer;       // length of this buffer
        WORD            offUserData;    // user data in this struct
        WORD            cbUserData;     // length of user data
        WORD            usStationId;    // ssnn station id
        UCHAR           uchOptions;     // option byte from RECEIVE param tbl
        UCHAR           uchMsgType;     // the message type
        WORD            cBuffersLeft;   // number of basic buffer units left
        UCHAR           uchRcvFS;       // the received frame status
        UCHAR           uchAdapterNumber;  // current adapter number
        UCHAR           cbLanHeader;    // length of the LAN header
        UCHAR           cbDlcHeader;    // length of the DLC header
        UCHAR           auchLanHeader[32];// LAN header of the received frame
        UCHAR           auchDlcHeader[4]; // DLC header of the received frame
    } NotContiguous;

    //
    // Contiguous is the Contiguous MAC/Data Buffer 1 structure defined
    // in IBM Lan Tech. Ref. pg 2-43
    //

    struct _DosDlcContiguousFirstBuffer {
        union _LLC_DOS_BUFFER * pNextBuffer;  // next frame segment
        WORD            cbFrame;        // length of entire frame
        WORD            cbBuffer;       // length of this buffer
        WORD            offUserData;    // user data in this struct
        WORD            cbUserData;     // length of user data
        WORD            usStationId;    // ssnn station id
        UCHAR           uchOptions;     // option byte from RECEIVE param tbl
        UCHAR           uchMsgType;     // the message type
        WORD            cBuffersLeft;   // number of basic buffer units left
        UCHAR           uchRcvFS;       // the received frame status
        UCHAR           uchAdapterNumber;
    } Contiguous;
} LLC_DOS_BUFFER, *PLLC_DOS_BUFFER;

#include <packoff.h>

//
// DOS_DLC_BUFFER_POOL - there is one of these per each SAP per adapter (max.
// 127 SAPs per adapter * max. 2 adapters = 256), kept in an array. This
// structure maintains basic information about the DOS buffer pool - its
// starting address (dpBuffer) in DOS 16:16 format, the size of an individual
// buffer in the pool (BufferSize) and the number of buffers in the pool
// (BufferCount). A buffer must be an integral multiple of 16 bytes, a minimum
// length of 80 bytes and not exceeding 64K-16 (0xfff0 = 65520)
//

typedef struct _DOS_DLC_BUFFER_POOL {
    DOS_ADDRESS dpBuffer;
    WORD BufferSize;
    WORD BufferCount;
    WORD MaximumBufferCount;
} DOS_DLC_BUFFER_POOL, *PDOS_DLC_BUFFER_POOL;

//
// DOS DLC CCB aka CCB1 - see definition in IBM Lan Tech. Ref. pg 2-6
//

#include <packon.h>

typedef struct _LLC_DOS_CCB {
    UCHAR   uchAdapterNumber;       // Adapter 0 or 1
    UCHAR   uchDlcCommand;          // DLC command
    UCHAR   uchDlcStatus;           // DLC command completion code
    UCHAR   uchReserved1;           // reserved for DLC DLL
    struct _LLC_DOS_CCB *pNext;     // queued another CCB
    DWORD   ulCompletionFlag;       // used in command completion
    union {
        PLLC_DOS_PARMS pParms;      // pointer to the parameter table
        struct {
            WORD    usStationId;    // Station id
            WORD    usParameter;    // optional parameter
        } dlc;
        struct {
            WORD    usParameter0;   // first optional parameter
            WORD    usParameter1;   // second optional parameter
        } dir;
        UCHAR   auchBuffer[4];      // group/functional address
        DWORD   ulParameter;
    } u;
} LLC_DOS_CCB, *PLLC_DOS_CCB;

//
// additional parameter tables not defined in (sdk\inc\) DLCAPI.H (or where
// CCB1 parameter tables different from those defined in DLCAPI.H)
//

//
// LLC_DOS_DIR_INITIALIZE_PARMS - CCB1 DIR.INITIALIZE parameter table
//

typedef struct {
    WORD    BringUps;
    WORD    SharedRamAddress;
    WORD    Reserved;
    DWORD   AdapterCheckExit;
    DWORD   NetworkStatusExit;
    DWORD   PcErrorExit;
} LLC_DOS_DIR_INITIALIZE_PARMS, *PLLC_DOS_DIR_INITIALIZE_PARMS;

//
// ADAPTER_PARMS, DIRECT_PARMS, DLC_PARMS and NCB_PARMS - these are the
// parameter tables which are passed in to DIR.OPEN.ADAPTER
//

//
// ADAPTER_PARMS - parameters returned from the adapter support s/w
//

typedef struct _ADAPTER_PARMS {
    WORD    OpenErrorCode;          // error detected opening adapter
    WORD    OpenOptions;            // options for Token Ring only:

    //
    // OpenOptions Bit Meanings
    //
    //  This has been paraphrased from the IBM Lan Tech. Ref. p3-22. I don't
    //  understand most of it, but I think I made it easier to read than the
    //  IBM technicalese. Note: ONLY MEANINGFUL TO TOKEN RING ADAPTER
    //
    // Bit 15: Wrap Interface
    //          The adapter doesn't attach to the network; instead, all
    //          transmitted data is reflected back as received data
    //
    // Bit 14: Disable Hard Error
    //          Stops network status change involving "Hard Error" and
    //          "Transmit Beacon" bits from generating interrupt
    //
    // Bit 13: Disable Soft Errors
    //          Stops network status change involving "Soft Error" bit
    //          generating interrupt
    //
    // Bit 12: Pass Adapter MAC Frames
    //          Unsupported MAC frames are passed to the direct station.
    //          If OFF, these frames are ignored
    //
    // Bit 11: Pass Attention MAC Frames
    //          Passes attention MAC frames which are not the same as the last
    //          received Attention MAC Frame to the direct station. If OFF,
    //          these frames are not passed to the direct station (ie App)
    //
    // Bit 10: Reserved
    //          Should be zero, but not checked by adapter
    //
    // Bit  9: Pass Parameter Table
    //          If the adapter is already open, returns options specified
    //
    // Bit  8: Contender
    //          If ON, this adapter will participate in monitor contention
    //          (claim token), should the need arise. If OFF, and it is
    //          another adapter decides it is necessary to claim the token,
    //          this adapter will not participate
    //
    //          If this adapter decides it is necessary to determine a new
    //          active monitor, this adapter will initiate monitor contention
    //          processing IRRESPECTIVE OF THE VALUE OF THIS BIT
    //
    // Bit  7: Pass Beacon MAC Frames
    //          Pass to direct station first Beacon MAC frame and all subsequent
    //          Beacon MAC frames having a change in source address or beacon type
    //
    // Bit  6: Reserved
    //          Should be zero, but not checked by adapter
    //
    // Bit  5: Remote Program Load
    //          Only implemented on 16/4 adapters. Prevents adapter becoming
    //          a monitor during open process. If ON, will cause this adapter
    //          to fail the open if there are no other active adapters on the
    //          ring when it tries to insert itself
    //
    // Bit  4: Token Release
    //          Only implemented on 16/4 adapters and only available when
    //          operating at 16 Mbps. OFF: use early token release (default).
    //          ON: selects no early token release for adapter a 16 Mbps
    //
    // Bit  3: Reserved  \
    // Bit  2: Reserved   >  Should be 0, but are not checked by adapter
    // Bit  1: Reserved  /
    // Bit  0: Reserved /
    //

    BYTE    NodeAddress[6];         // this adapter's address
    DWORD   GroupAddress;           // group address to set
    DWORD   FunctionalAddress;      // functional address to set
    WORD    NumberReceiveBuffers;   // number of receive buffers
    WORD    ReceiveBufferLength;    // size of receive buffer
    WORD    DataHoldBufferLength;   // size of transmit data hold buffer
    BYTE    NumberDataHoldBuffers;  // returned: only by Token Ring
    BYTE    Reserved;
    WORD    OpenLock;               // Protection code to control closing adapter
                                    // This is NOT RETURNED when OpenOptions.9
                                    // is set (Pass parameter table)
    DWORD   ProductId;              // 18-byte product ID
                                    // This is NOT RETURNED when OpenOptions.9
                                    // is set (Pass parameter table)
    //
    // according to table 3-9 in IBM LAN Tech. Ref. (p3-25) the ProductId field
    // should point at an 18-byte buffer formatted like so:
    //
    //  Byte 0      0x01 indicates workstation
    //  Byte 1      0x10
    //  Byte 2-5    last 4 digits from workstation serial number in EBCDIC
    //  Byte 6-17   0x00
    //
} ADAPTER_PARMS, *PADAPTER_PARMS;

//
// DIRECT_PARMS - input parameters defining Direct Station for adapter
//

typedef struct _DIRECT_PARMS {

    //
    // the direct buffer size is min. 80 bytes, and must be integral multiple
    // of 16-bytes. If 0, default of 160 is used
    //

    WORD    DirectBufferSize;       // size of buffers in direct buffer pool


    //
    // direct pool blocks - number of 16-byte blocks in direct station buffer
    // pool. If 0, default of 256 is used (= 4096 byte buffer pool)
    //

    WORD    DirectPoolBlocks;       // size of buffer in 16-byte blocks


    //
    // direct buffer pool - segment address in workstation memory where direct
    // station buffer pool is created. Spec. doesn't say what happens if there
    // is a non-zero (or any, for that matter) offset. If 0, the application
    // must build the direct station buffer pool, in which case DirectBufferSize
    // must indicate the size of each buffer
    //

    DWORD   DirectBufferPool;       // start address of direct buffer pool


    //
    // adapter check exit - vectors to this address when the adapter detects
    // an internal error. If 0, the value specified in DIR.INITIALIZE is used
    //

    DWORD   AdapterCheckExit;       // I/O appendage exit: adapter check


    //
    // network status exit - vectors to this address when the network status
    // changes (whatever that means). If 0, the value specified by
    // DIR.INITIALIZE is used
    //

    DWORD   NetworkStatusExit;      // I/O appendage exit: network status change


    //
    // PC error exit - vectors to this address when the adapter s/w detects an
    // error in the workstation (!). If 0, the value specified by DIR.INITIALIZE
    // is used
    //

    DWORD   PcErrorExit;            // I/O appendage exit: error in workstation


    //
    // adapter work area - segment of area of w/s memory which is to be used
    // by the adapter. Ignored if  AdapterWorkAreaRequested is 0
    //

    DWORD   AdapterWorkArea;        // TR: adapter work are


    //
    // adapter work area length (requested) - the size of the workspace area,
    // the segment of which is specified in AdapterWorkArea. Size is calculated
    // thus: Number of SAPs x 36 + Number of stations (links) x 6 + 48
    //

    WORD    AdapterWorkAreaRequested; // TR: work area length requested


    //
    // adapter work area length (actual) - this value is returned by the
    // adapter. It is the amount of the work area used by the adapter (in bytes).
    // If this is greater than AdapterWorkAreaRequested then an error is returned
    // (0x12)

    WORD    AdapterWorkAreaActual;  // TR: actual work area length taken

} DIRECT_PARMS, *PDIRECT_PARMS;

//
// DLC_PARMS - returned values defining DLC limits
//

typedef struct _DLC_PARMS {

    //
    // maximum number of concurrently opened SAPs: limited by available
    // adapter memory and/or workspace memory. Maximum is 127 (126 if NetBIOS
    // is specified). If 0, the default 2 is used
    //

    BYTE    MaxSaps;                // maximum number of SAPs


    //
    // maximum number of concurrently opened link stations: limited by
    // available adapter and/or work area memory in workstation. Maximum is 255
    // for Token Ring, Ethernet or PC Network. If 0, the default of 6 is used
    //

    BYTE    MaxStations;            // maximum number of link stations


    //
    // maximum number of group SAPs concurrently opened. If 0, no group SAPs
    // can be opened. Maximum value is 126 for Token Ring, 125 for PC Network
    // and Ethernet
    //

    BYTE    MaxGroupSaps;           // maximum number of group SAPs


    //
    // maximum number of SAPs assigned to a group. Maximum is 127 for Token
    // Ring, 126 for PC Network and Ethernet
    //

    BYTE    MaxGroupMembers;        // maximum members per group SAP


    //
    // Timers. There are 3 timers: T1 is the Response Timer; T2 is the Inactivity
    // Timer; and Ti is the Receiver Acknowledgement Timer.
    //
    // Timers are set to a multiple of 40ms. They count down and interrupt the
    // adapter when they reach 0. Timer values can be between 1 and 10. If it
    // is between 1 and 5, the short timer tick (TICK_ONE) is used and is
    // referred to as group 1. If the number is between 6 and 10, the long timer
    // tick (TICK_TWO) is used and is referred to as group 2. The timer value is
    // the number (6 to 10) minus 5 multiplied by the long tick value.
    //

    //
    // Tick1 - number of 40 ms ticks for short DLC timer. Defaults (if 0):
    //  T1 5 (200ms-400ms)
    //  T2 1 (40ms-80ms)
    //  Ti 25 (1s-2s)
    //

    BYTE    T1Tick1;                // Timer 1 short timer
    BYTE    T2Tick1;                // Timer 2 short timer
    BYTE    TiTick1;                // Timer i short timer


    //
    // Tick2 - number of 40 ms ticks for long DLC timer. Default (if 0):
    //  T1 25 (1s-2s)
    //  T2 10 (400ms-800ms)
    //  Ti 125 (5s-10s)
    //

    BYTE    T1Tick2;                // Timer 1 long timer
    BYTE    T2Tick2;                // Timer 2 long timer
    BYTE    TiTick2;                // Timer i long timer
} DLC_PARMS, *PDLC_PARMS;

//
// NCB_PARMS - we are not interested in running DOS NETBIOS over DOS DLC (are we?)
//

typedef struct _NCB_PARMS {
    BYTE    Reserved1[4];       // adapter work area
    BYTE    TimerT1;
    BYTE    TimerT2;
    BYTE    TimerTi;
    BYTE    MaxOut;
    BYTE    MaxIn;
    BYTE    MaxOutIncr;
    BYTE    MaxRetry;
    BYTE    Reserved2[4];
    BYTE    NcbAccessPri;
    BYTE    MaxStations;
    BYTE    Reserved3[19];
    BYTE    MaxNames;
    BYTE    MaxNcbs;
    BYTE    MaxSessions;
    BYTE    Reserved4[2];
    BYTE    Options;
    WORD    PoolLength;
    DWORD   PoolAddress;
    BYTE    TxTimeout;
    BYTE    TxCount;
} NCB_PARMS, *PNCB_PARMS;

//
// LLC_DOS_DIR_OPEN_ADAPTER_PARMS is the CCB1 DIR.OPEN.ADAPTER parameter table
//

typedef struct _LLC_DOS_DIR_OPEN_ADAPTER_PARMS {
    PADAPTER_PARMS  pAdapterParms;
    PDIRECT_PARMS   pDirectParms;
    PDLC_PARMS      pDlcParms;
    PNCB_PARMS      pNcbParms;
} LLC_DOS_DIR_OPEN_ADAPTER_PARMS, *PLLC_DOS_DIR_OPEN_ADAPTER_PARMS;

//
// LLC_DOS_RECEIVE_PARMS is the CCB1 RECEIVE parameter table
//

typedef struct _LLC_DOS_RECEIVE_PARMS {
    WORD        usStationId;    // SAP, link station or direct id
    WORD        usUserLength;   // length of user data in buffer header
    DWORD       ulReceiveExit;  // the received data handler
    PLLC_BUFFER pFirstBuffer;   // first buffer in the pool
    UCHAR       uchOptions;     // defines how the frame is received
} LLC_DOS_RECEIVE_PARMS,  *PLLC_DOS_RECEIVE_PARMS;

//
// LLC_DOS_RECEIVE_PARMS_EX is an extended version of the LLC_DOS_RECEIVE_PARMS
// parameter table. We keep extra information - the DOS address of the original
// CCB and the original RECEIVE_DATA completion exit routine
//

typedef struct _LLC_DOS_RECEIVE_PARMS_EX {
    WORD        usStationId;            // SAP, link station or direct id
    WORD        usUserLength;           // length of user data in buffer header
    DWORD       ulReceiveExit;          // the received data handler
    PLLC_BUFFER pFirstBuffer;           // first buffer in the pool
    UCHAR       uchOptions;             // defines how the frame is received
    UCHAR       auchReserved1[3];       //
    UCHAR       uchRcvReadOption;       // defines if rcv frames are chained
    UCHAR       auchReserved2[3];       // align dpOriginalCcbAddress on DWORD
    DOS_ADDRESS dpOriginalCcbAddress;   // dos address of orginal ccb
    DOS_ADDRESS dpCompletionFlag;       // orginal completion flag
} LLC_DOS_RECEIVE_PARMS_EX,  *PLLC_DOS_RECEIVE_PARMS_EX;

//
// LLC_DOS_RECEIVE_MODIFY_PARMS is the parameter table for RECEIVE.MODIFY which
// we don't seem to support in NT native DLC
//

typedef struct {
    WORD    StationId;                  // SAP & link station Id
    WORD    UserLength;                 // length of user area in buffer
    DWORD   ReceivedDataExit;           // address of routine to call with data
    DWORD   FirstBuffer;                // pointer to first buffer from pool
    DWORD   Subroutine;                 // address of routine to call to get app buffer
} LLC_DOS_RECEIVE_MODIFY_PARMS, *PLLC_DOS_RECEIVE_MODIFY_PARMS;

//
// LLC_DOS_TRANSMIT_PARMS this structure is identical to LLC_TRANSMIT_PARMS
// except that there is no XMIT_READ_OPTION byte on the end, and the types of
// the fields are different, although the sizes are the same: eg. DOS_ADDRESS
// instead of PVOID or PLLC_XMIT_BUFFER
//

typedef struct _LLC_DOS_TRANSMIT_PARMS {
    WORD        usStationId;            // SAP and link station ID
    BYTE        uchTransmitFs;          // returned: Frame Status
    BYTE        uchRemoteSap;           // remote SAP we're talking to
    DOS_ADDRESS pXmitQueue1;            // address of 1st buffer queue. Not pooled
    DOS_ADDRESS pXmitQueue2;            // address of 2nd buffer queue. Pooled
    WORD        cbBuffer1;              // length of data in pBuffer1
    WORD        cbBuffer2;              // length of data in pBuffer2
    DOS_ADDRESS pBuffer1;               // address of 1st data buffer
    DOS_ADDRESS pBuffer2;               // address of 2nd data buffer
} LLC_DOS_TRANSMIT_PARMS, *PLLC_DOS_TRANSMIT_PARMS;

typedef struct _LLC_MODIFY_OPEN_PARMS {
    WORD        usBufferSize;           // block size of dlc buffers (>=80)
    WORD        cPoolBlocks;            // number of 16 bytes blocks in buffer
    DOS_ADDRESS dpPoolAddress;
    DOS_ADDRESS dpAdapterCheckExit;
    DOS_ADDRESS dpNetworkStatusExit;
    DOS_ADDRESS dpPcErrorExit;
    WORD        usOpenOption;
} LLC_MODIFY_OPEN_PARMS, *PLLC_MODIFY_OPEN_PARMS;

typedef struct _DOS_DLC_DIRECT_PARMS {
    WORD        usBufferSize;           // block size of dlc buffers (>=80)
    WORD        cPoolBlocks;            // number of 16 bytes blocks in buffer
    DOS_ADDRESS dpPoolAddress;          //
    DOS_ADDRESS dpAdapterCheckExit;
    DOS_ADDRESS dpNetworkStatusExit;
    DOS_ADDRESS dpPcErrorExit;
    DWORD       ulReserved1;
    WORD        usReserved2;
    WORD        usReserved3;
} DOS_DLC_DIRECT_PARMS, *PDOS_DLC_DIRECT_PARMS;

typedef struct _DOS_DLC_OPEN_SAP_PARMS {
    WORD        usStationId;            // SAP or link station id
    WORD        usUserStatValue;        // reserved for user
    UCHAR       uchT1;                  // response timer
    UCHAR       uchT2;                  // aknowledgment timer
    UCHAR       uchTi;                  // inactivity timer
    UCHAR       uchMaxOut;              // max tramists without ack
    UCHAR       uchMaxIn;               // max receives without ack
    UCHAR       uchMaxOutIncr;          // dynamic window increment value
    UCHAR       uchMaxRetryCnt;         // N2 value (retries)
    UCHAR       uchMaxMembers;          // maximum members for group SAP
    WORD        usMaxI_Field;           // maximum length of the Info field
    UCHAR       uchSapValue;            // SAP value to be assigned
    UCHAR       uchOptionsPriority;     // SAP options and access priority
    UCHAR       uchcStationCount;       // maximum number of link stations in sap
    UCHAR       uchReserved2[2];        //
    UCHAR       cGroupCount;            // number of group SAPs of this SAP
    PUCHAR      pGroupList;             // offset to the group list
    DWORD       DlcStatusFlags;         // User notify flag for DLC status changes
    WORD        usBufferSize;           // size of individual buffer in bytes
    WORD        cPoolBlocks;            // number of 16-byte blocks in pool
    DOS_ADDRESS dpPoolAddress;          // address of Buffer Pool (may be 0)
} DOS_DLC_OPEN_SAP_PARMS,  *PDOS_DLC_OPEN_SAP_PARMS;

typedef struct _DOS_DIR_STATUS_PARMS {
    UCHAR       auchPermanentAddress[6];// permanent encoded address
    UCHAR       auchNodeAddress[6];     // adapter's network address
    UCHAR       auchGroupAddress[4];    // adapter's group address
    UCHAR       auchFunctAddr[4];       // adapter's functional address
    UCHAR       uchMaxSap;              // maximum allowable SAP
    UCHAR       uchOpenSaps;            // number of currently open saps
    UCHAR       uchMaxStations;         // max number of stations (always 253)
    UCHAR       uchOpenStation;         // number of open stations (only up to 253)
    UCHAR       uchAvailStations;       // number of available stations (always 253)
    UCHAR       uchAdapterConfig;       // adapter configuration flags
    UCHAR       auchMicroCodeLevel[10]; // microcode level
    DOS_ADDRESS dpAdapterParmsAddr;     // shared RAM address of adapter parms
    DOS_ADDRESS dpAdapterMacAddr;       // shared RAM address of adapter MAC buffer
    DOS_ADDRESS dpTimerTick;            // address of DLC timer tick counter
    USHORT      usLastNetworkStatus;    // most recent network status issued
    DOS_ADDRESS dpExtendedParms;        // address of extended status table
} DOS_DIR_STATUS_PARMS, *PDOS_DIR_STATUS_PARMS;

typedef struct {
    DOS_ADDRESS dpAdapterCheckExit;     // adapter check appendage
    DOS_ADDRESS dpNetworkStatusExit;    // network status change appendage
    DOS_ADDRESS dpPcErrorExit;          // workstation error appendage
} LLC_DIR_SET_USER_APPENDAGE_PARMS, *PLLC_DIR_SET_USER_APPENDAGE_PARMS;

#include <packoff.h>

union _LLC_DOS_PARMS {
    LLC_BUFFER_FREE_PARMS       BufferFree;
    LLC_BUFFER_GET_PARMS        BufferGet;
    LLC_DLC_CONNECT_PARMS       DlcConnectStation;
    LLC_DLC_MODIFY_PARMS        DlcModify;
    LLC_DLC_OPEN_SAP_PARMS      DlcOpenSap;
    LLC_DLC_OPEN_STATION_PARMS  DlcOpenStation;
    LLC_DLC_REALLOCATE_PARMS    DlcReallocate;
    LLC_DLC_SET_THRESHOLD_PARMS DlcSetThreshold;
    LLC_DLC_STATISTICS_PARMS    DlcStatistics;
    LLC_DIR_INITIALIZE_PARMS    DirInitialize;
    LLC_MODIFY_OPEN_PARMS       DirModifyOpenParms;
    LLC_DIR_OPEN_ADAPTER_PARMS  DirOpenAdapter;
    LLC_DIR_OPEN_DIRECT_PARMS   DirOpenDirect;
    LLC_DIR_READ_LOG_PARMS      DirReadLog;
    LLC_DIR_SET_EFLAG_PARMS     DirSetExceptionFlags;
    LLC_DIR_SET_USER_APPENDAGE_PARMS    DirSetUserAppendage;
    LLC_DIR_STATUS_PARMS        DirStatus;
    DOS_DIR_STATUS_PARMS        DosDirStatus;
    LLC_READ_PARMS              Read;
    LLC_DOS_RECEIVE_PARMS_EX    Receive;
    LLC_DOS_RECEIVE_PARMS       DosReceive;
    LLC_TRANSMIT_PARMS          Transmit;
    LLC_TRANSMIT2_COMMAND       Transmit2;
    LLC_TRACE_INITIALIZE_PARMS  TraceInitialize;
    DOS_DLC_OPEN_SAP_PARMS      DosDlcOpenSap;
};

//
// ADAPTER_TYPE - what type of network adapter we have - Token Ring, Ethernet
// or (less likely) PC network
//

typedef enum {
    TokenRing,
    Ethernet,
    PcNetwork,
    UnknownAdapter
} ADAPTER_TYPE;

//
// LOCAL_BUSY_STATE - a link station can be in 1 of 3 emulated local-busy
// (buffer) states:
//
//  NOT_BUSY
//      the station doesn't have any backed-up I-frames pending
//
//  BUSY
//      the station is in emulated local-busy(buffer) state and a
//      DLC.FLOW.CONTROL(local-busy(buffer), set) has been sent to
//      the DLC device driver
//
//  BUSY_BUFFER
//      to get out of BUSY state into CLEARING, we need at least one buffer and
//      a DLC.FLOW.CONTROL from the app. Because apps can issue DLC.FLOW.CONTROL
//      and BUFFER.FREE in the wrong order, we need an AND of these 2 commands
//      to get going again. So we have this intermediate state where we are
//      awaiting either command to restart I-Frame reception
//
//  BUSY_FLOW
//      Together with BUSY_BUFFER, used to create a hysteresis whereby we can't
//      reach CLEARING from BUSY without getting both a DLC.FLOW.CONTROL and
//      BUFFER.FREE
//
//  CLEARING
//      the VDM app has cleared the emulated local-busy state, but
//      the DLC device driver is still in local-busy (buffer) state.
//      When the last deferred I-Frame is indicated to the VDM app,
//      the NT device driver local-busy(buffer) state will be reset
//      and normal service will resume
//
//
// State transitions:
//
//  NOT_BUSY -> BUSY
//      occurs when we discover there aren't enough DOS buffers to
//      receive an I-Frame. This transition is distinguished by the
//      following actions:
//
//          1. DLC.FLOW.CONTROL(local-busy(buffer), set) is indicated to
//             the DLC device driver
//          2. the received I-Frame is dequeued from the event queue for
//             this adapter and queued on the LocalBusyInfo.Queue
//          3. a local-busy(buffer) DLC status change event is indicated to
//             the DOS DLC app
//
//  BUSY -> BUSY_FLOW/BUSY_BUFFER
//      occurs when either a DLC.FLOW.CONTROL or BUFFER.FREE (resp) is issued
//
//  BUSY_FLOW/BUSY_BUFFER -> CLEARING
//      occurs when the DOS DLC app indicates we can continue receiving.
//      This is done when the other (DLC.FLOW.CONTROL or BUFFER.FREE) required
//      command is issued
//      This transition is distinguished by the following actions:
//
//          1. DOS DLC app issues DLC.FLOW.CONTROL(local-busy(buffer), reset)
//          2. DOS DLC app *may* issue BUFFER.FREE to return receive
//             buffers to the SAP pool
//
//  CLEARING -> NOT_BUSY
//      occurs when we indicate the last deferred receive to the DOS DLC
//      app. At this point we can do the following:
//
//          1. issue DLC.FLOW.CONTROL(local-busy(buffer), reset) to the
//             device driver
//
//  CLEARING -> BUSY
//      occurs when, during indicating deferred received I-Frames to the DOS
//      DLC app, we once again run out of buffers. Again, we indicate a DLC
//      status change of local-busy(buffer) to the DOS DLC app, but WE DO NOT
//      indicate local-busy(buffer) to the DLC device driver (it is still in
//      local-busy(buffer) state)
//

typedef enum {
    NOT_BUSY = 0,
    CLEARING,
    BUSY,
    BUSY_BUFFER,
    BUSY_FLOW
} LOCAL_BUSY_STATE;

//
// LOCAL_BUSY_INFO - this structure maintains a local-busy(buffer) state
// indicator and a pointer to a queue of deferred received I-Frames per link
// station per adapter
//

typedef struct {

    //
    // State maintains the tri-state of the link station w.r.t. received I-Frames
    //
    //  NOT_BUSY
    //      nothing queued on Queue, get next completed event from event Q
    //
    //  BUSY
    //      local-busy(buffer) state has been set in DLC driver,
    //      awaiting buffers & flow control command from DOS DLC app
    //
    //  CLEARING
    //      DOS DLC app has submitted DLC.FLOW.CONTROL(local_busy(buffer), reset)
    //      command, we are now trying to indicate deferred received I-Frames to
    //      DOS DLC app, pending enough DOS receive buffers
    //

    LOCAL_BUSY_STATE State;

    //
    // Queue - when in BUSY and CLEARING states, maintains a linked list of
    // completed NT READ CCBs containing received I-Frames
    //

    PLLC_CCB Queue;

#if DBG

    //
    // track queue depth for each link station in debug version
    //

    DWORD Depth;
#endif

} LOCAL_BUSY_INFO;

//
// MAX_I_FRAME_DEPTH - we don't expect the queue of deferred I-Frames to grow
// beyond this small number. The deferred I-Frame queue is a buffer between
// running out of receive buffers & restarting I-Frame reception
//

#define MAX_I_FRAME_DEPTH   64  // !

//
// DOS_ADAPTER - there is one of these for each DOS adapter (i.e. 2 max.). The
// structure contains information about the virtual state of each DOS adapter.
// We record such information as the parameters used to open the adapter, the
// exit addresses and the direct station information
//

typedef struct {

    //
    // AdapterType - tells us what type (class?) of adapter we are using. We
    // mainly use this to differentiate the types of values we return based
    // on whether this is a Token Ring adapter. We get the information from
    // the NT DIR.STATUS command
    //

    ADAPTER_TYPE AdapterType;

    //
    // IsOpen will be TRUE when this adapter has been successfully opened
    //

    BOOLEAN IsOpen;

    //
    // DirectStationOpen is TRUE when the direct station has been initialized
    // for this adapter. This is required because the direct station is opened
    // separately from the adapter in NT, but DOS expects both to be opened
    // simultaneously. Hence, we only issue a DIR.OPEN.DIRECT when the DOS app
    // issues a request for the direct station
    //

    BOOLEAN DirectStationOpen;

    //
    // if DirectReceive is TRUE then there is a receive outstanding on the
    // direct station for this adapter
    //

    BOOLEAN DirectReceive;

    //
    // if WaitingRestore is TRUE then we must get a DIR.RESTORE.OPEN.PARMS
    // before we can accept the next DIR.MODIFY.OPEN.PARMS
    //

    BOOLEAN WaitingRestore;

    //
    // BufferFree is TRUE when a BUFFER_FREE has been successfully issued for
    // any station ID belonging to this adapter
    //

    BOOLEAN BufferFree;

    //
    // BufferPool is the buffer pool for this adapter's direct station
    //

    PVOID BufferPool;

    //
    // CurrentExceptionHandlers and PreviousExceptionHandlers are the addresses
    // of exception 'exit' routines in DOS memory which are called asynchronously
    // if one of the special exceptions occurs. These are mapped to exception
    // flags in NT DLC and are presented as such in the READ CCB (ulCompletionFlag)
    //
    // exception handlers are always presented in the following order:
    //
    //  Adapter Check Exit
    //  Network Status Exit
    //  PC Error Exit
    //

    DWORD CurrentExceptionHandlers[3];
    DWORD PreviousExceptionHandlers[3];

    //
    // DlcStatusChangeAppendage - this appendage pointer is supplied in DLC.OPEN.SAP
    // - one for each SAP. We need to keep them here because the emulator can
    // generate its own DLC status change call-backs (local-busy(buffer))
    //

    DWORD DlcStatusChangeAppendage[DOS_DLC_MAX_SAPS];

    //
    // LastNetworkStatusChange is the last network status change we recorded.
    // This is reported in DIR.STATUS
    //

    WORD LastNetworkStatusChange;

    //
    // UserStatusValue - we have to record the USER_STAT_VALUE from each
    // successful DLC.OPEN.SAP. This is returned to the DLC status change
    // appendage. We need this info for when we generate our own status change
    // event (ie when we detect emulated local busy (buffer) state)
    //

    WORD UserStatusValue[DOS_DLC_MAX_SAPS];

    //
    // AdapterParms are the actual adapter parameters that this adapter was
    // opened with - either specified in the DIR.OPEN.ADAPTER from the DOS
    // app, or those which we use internally when we automatically open the
    // adapter
    //

    ADAPTER_PARMS AdapterParms;

    //
    // DlcSpecified will be TRUE if the DLC_PARMS table was given when the
    // adapter was opened (either by DIR.OPEN.ADAPTER from DOS app, or by
    // DIR.OPEN.ADAPTER from automatic open)
    //

    BOOLEAN DlcSpecified;

    //
    // DlcParms - the DLC parameters specified in the open
    //

    DLC_PARMS DlcParms;

    //
    // AdapterCloseCcb - used in asynchronous adapter close when close is
    // initiated by emulator
    //

    LLC_CCB AdapterCloseCcb;

    //
    // DirectCloseCcb - used in asynchronous direct station close when close is
    // initiated by emulator
    //

    LLC_CCB DirectCloseCcb;

    //
    // ReadCcb - pointer to current READ CCB for this adapter
    //

    PLLC_CCB ReadCcb;

    //
    // EventQueueCritSec - must hold this while accessing EventQueue
    //

    CRITICAL_SECTION EventQueueCritSec;

    //
    // EventQueue - linked list of pending completed READ CCBs. These are linked
    // by pNext field which is not normally used by READ CCB. The event queue is
    // a serialized list of asynchronous events which have occurred for this
    // adapter. Events are command completions, transmit completions, received
    // data frames and status changes
    //

    PLLC_CCB EventQueueHead;    // pointer to READ CCB at head of queue
    PLLC_CCB EventQueueTail;    //    "     "   "   "  "  end  "    "
    DWORD QueueElements;        // count of elements currently on EventQueue

    //
    // LocalBusyCritSec - must hold this while accessing DeferredReceives or
    // LocalBusyInfo array
    //

    CRITICAL_SECTION LocalBusyCritSec;

    //
    // DeferredReceives - reference count of number of link stations for this
    // adapter which are in local busy (buffer) state. Accessed while holding
    // LocalBusyCritSec. Serves as a boolean: check for !0 to discover if there
    // are deferred receives before checking all of LocalBusyInfo
    //

    DWORD DeferredReceives;

    //
    // FirstIndex and LastIndex - the start & stop points for searches through
    // LocalBusyInfo. These are used in an attempt to improve searching, since
    // for the vast majority of time, very few of the 255 possible slots in
    // LocalBusyInfo will be used
    //
    // NOTE: these are array indicies, NOT link station ids (index = id - 1)
    //

    DWORD FirstIndex;
    DWORD LastIndex;

    //
    // LocalBusyInfo - when a link station is in emulated local busy (buffer)
    // state, we dequeue any completed received I-Frames from the event queue
    // and link them onto the LocalBusyInfo list. For each adapter, there are
    // 255 lists - one per link station (there are 255 possible link stations
    // per adapter). The deferred receives are a list of completed NT READ CCBs
    // linked by CCB.pNext field. The lists serve as a buffer between realizing
    // we are out of buffers and the DLC device driver receiving the
    // DLC.FLOW.CONTROL(set, buffer) command. The lists are not expected to
    // grow very long
    //
    // This array combines the state of each link station for this adapter w.r.t.
    // local-busy(buffer) and maintains the list of deferred I-Frames.
    //
    // The array is accessed both by the main VDM thread and the EventHandlerThread
    // and so must only be accessed when holding LocalBusyCritSec
    //
    // Since there are 255 possible link stations per adapter and since the
    // Direct Station doesn't support link stations, link station 01 uses slot
    // 0, etc.
    //

    LOCAL_BUSY_INFO LocalBusyInfo[DOS_DLC_MAX_LINKS];

} DOS_ADAPTER, *PDOS_ADAPTER;

#define NO_LINKS_BUSY   ((DWORD)0x7fffffff)

//
// DOS DLC prototypes and externals
//

extern PLLC_BUFFER aOverflowedData[];
extern DWORD OpenedAdapters;
extern DOS_ADDRESS dpVdmWindow;

//
// vrdlc5c.c
//

VOID
VrDlc5cHandler(
    VOID
    );

VOID
CompleteCcbProcessing(
    IN LLC_STATUS Status,
    IN LLC_DOS_CCB UNALIGNED * pCcb,
    IN PLLC_PARMS pNtParms
    );

LLC_STATUS
LlcCommand(
    IN  UCHAR   AdapterNumber,
    IN  UCHAR   Command,
    IN  DWORD   Parameter
    );

LLC_STATUS
BufferFree(
    IN  UCHAR   AdapterNumber,
    IN  PVOID   pFirstBuffer,
    OUT LPWORD  pusBuffersLeft
    );

VOID
VrVdmWindowInit(
    VOID
    );

VOID
TerminateDlcEmulation(
    VOID
    );

//
// vrdlcbuf.c
//

VOID
InitializeBufferPools(
    VOID
    );

LLC_STATUS
CreateBufferPool(
    IN  DWORD   PoolIndex,
    IN  DOS_ADDRESS dpBuffer,
    IN  WORD    BufferCount,
    IN  WORD    BufferSize
    );

VOID
DeleteBufferPool(
    IN  DWORD   PoolIndex
    );

LLC_STATUS
GetBuffers(
    IN  DWORD   PoolIndex,
    IN  WORD    BuffersToGet,
    IN  DPLLC_DOS_BUFFER *pdpBuffer,
    OUT LPWORD  pusBuffersLeft,
    IN  BOOLEAN PartialList,
    OUT PWORD   BuffersGot OPTIONAL
    );

LLC_STATUS
FreeBuffers(
    IN  DWORD   PoolIndex,
    IN  DPLLC_DOS_BUFFER dpBuffer,
    OUT LPWORD  pusBuffersLeft
    );

WORD
CalculateBufferRequirement(
    IN UCHAR Adapter,
    IN WORD StationId,
    IN PLLC_BUFFER pFrame,
    IN LLC_DOS_PARMS UNALIGNED * pDosParms,
    OUT PWORD BufferSize
    );

LLC_STATUS
CopyFrame(
    IN PLLC_BUFFER pFrame,
    IN DPLLC_DOS_BUFFER DosBuffers,
    IN WORD UserLength,
    IN WORD BufferSize,
    IN DWORD Flags
    );

BOOLEAN
AllBuffersInPool(
    IN DWORD PoolIndex
    );

//
// vrdlcpst.c
//

VOID
VrDlcInitialize(
    VOID
    );

BOOLEAN
VrDlcHwInterrupt(
    VOID
    );

BOOLEAN
ResetEmulatedLocalBusyState(
    IN BYTE AdapterNumber,
    IN WORD StationId,
    IN BYTE DlcCommand
    );

BOOLEAN
InitializeEventHandler(
    VOID
    );

PLLC_CCB
InitiateRead(
    IN DWORD AdapterNumber,
    OUT LLC_STATUS* ErrorStatus
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\vrdisp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrdisp.c

Abstract:

    Contains dispatcher for VdmRedir (Vr) functions

    Contents:
        VrDispatch

Author:

    Richard L Firth (rfirth) 13-Sep-1991

Environment:

    Flat 32-bit

Revision History:

    13-Sep-1991 rfirth
        Created

--*/

#include <nt.h>
#include <ntrtl.h>              // ASSERT, DbgPrint
#include <nturtl.h>
#include <windows.h>
#include <softpc.h>             // x86 virtual machine definitions
#include <vrdlctab.h>
#include <vdmredir.h>           // common VdmRedir stuff
#include <vrinit.h>             // Vr init prototypes
#include <vrmisc.h>             // Vr miscellaneous prototypes
#include <vrnmpipe.h>           // Vr named pipe prototypes
#include <vrmslot.h>            // Vr mailslot prototypes
#include <vrnetapi.h>           // Vr net api prototypes
#include <nb30.h>               // NCBNAMSZ etc.
#include <netb.h>               // Vr netbios api prototypes
#include <rdrexp.h>             // VrDispatch prototypes
#include <rdrsvc.h>             // SVC_RDR... defines
#include <smbgtpt.h>
#include <dlcapi.h>             // Official DLC API definition
#include <ntdddlc.h>            // IOCTL commands
#include <dlcio.h>              // Internal IOCTL API interface structures
#include <vrdlc.h>              // Vr dlc prototypes, etc.

//
// The functions in VrDispatchTable must be in the same order as the
// corresponding SVC codes in rdrsvc.h
//

VOID (*VrDispatchTable[])(VOID) = {
    VrInitialize,               // 0x00
    VrUninitialize,             // 0x01
    VrGetNamedPipeInfo,         // 0x02
    VrGetNamedPipeHandleState,  // 0x03
    VrSetNamedPipeHandleState,  // 0x04
    VrPeekNamedPipe,            // 0x05
    VrTransactNamedPipe,        // 0x06
    VrCallNamedPipe,            // 0x07
    VrWaitNamedPipe,            // 0x08
    VrDeleteMailslot,           // 0x09
    VrGetMailslotInfo,          // 0x0a
    VrMakeMailslot,             // 0x0b
    VrPeekMailslot,             // 0x0c
    VrReadMailslot,             // 0x0d
    VrWriteMailslot,            // 0x0e
    VrTerminateDosProcess,      // 0x0f
    VrNetTransactApi,           // 0x10
    VrNetRemoteApi,             // 0x11
    VrNetNullTransactApi,       // 0x12
    VrNetServerEnum,            // 0x13
    VrNetUseAdd,                // 0x14
    VrNetUseDel,                // 0x15
    VrNetUseEnum,               // 0x16
    VrNetUseGetInfo,            // 0x17
    VrNetWkstaGetInfo,          // 0x18
    VrNetWkstaSetInfo,          // 0x19
    VrNetMessageBufferSend,     // 0x1a
    VrGetCDNames,               // 0x1b
    VrGetComputerName,          // 0x1c
    VrGetUserName,              // 0x1d
    VrGetDomainName,            // 0x1e
    VrGetLogonServer,           // 0x1f
    VrNetHandleGetInfo,         // 0x20
    VrNetHandleSetInfo,         // 0x21
    VrNetGetDCName,             // 0x22
    VrReadWriteAsyncNmPipe,     // 0x23
    VrReadWriteAsyncNmPipe,     // 0x24
    VrNetbios5c,                // 0x25
    VrHandleAsyncCompletion,    // 0x26
    VrDlc5cHandler,             // 0x27
    VrVdmWindowInit,            // 0x28
    VrReturnAssignMode,         // 0x29
    VrSetAssignMode,            // 0x2a
    VrGetAssignListEntry,       // 0x2b
    VrDefineMacro,              // 0x2c
    VrBreakMacro,               // 0x2d
    VrNetServiceControl,        // 0x2e
    VrDismissInterrupt,         // 0x2f
    VrEoiAndDismissInterrupt,   // 0x30
    VrCheckPmNetbiosAnr         // 0x31
};

#define LAST_VR_FUNCTION        LAST_ELEMENT(VrDispatchTable)

BOOL
VrDispatch(
    IN ULONG SvcCode
    )

/*++

Routine Description:

    Dispatches a Vdm Redir support function based on the SVC code

Arguments:

    SvcCode - Function dispatcher

Return Value:

    BOOL
        TRUE    - Function executed
        FALSE   - Function not executed

--*/

{
#if 0
#if DBG
    DbgPrint("VrDisp: You have successfully made a Bop into VdmRedir (%d)\n",
        SvcCode
        );
#endif
#endif

    if (SvcCode > LAST_VR_FUNCTION) {
#if DBG
        DbgPrint("Error: VrDisp: Unsupported SVC code: %d\n", SvcCode);
        VrUnsupportedFunction();
#endif
        return FALSE;
    }
    VrDispatchTable[SvcCode]();
    return TRUE;
}

//
// BUGBUG - this goes away when all C compilers understand inline functions
//

#ifndef i386
LPVOID _inlinePointerFromWords(WORD seg, WORD off) {
    WORD _seg = seg;
    WORD _off = off;

    if (seg + off) {
        return (LPVOID)GetVDMAddr(_seg, _off);
    }
    return 0;
}

LPVOID _inlineConvertAddress(WORD Seg, WORD Off, WORD Size, BOOLEAN Pm) {

    WORD _seg = Seg;
    WORD _off = Off;

    return (_seg | _off) ? Sim32GetVDMPointer(((DWORD)_seg << 16) + _off, Size, Pm) : 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\vrdlcdbg.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrdlcdbg.c

Abstract:

    Contains functions for dumping CCBs, parameter tables; diagnostic and
    debugging functions for DOS DLC (CCB1)

    Contents:
        DbgOut
        DbgOutStr
        DumpCcb
        DumpDosDlcBufferPool
        DumpDosDlcBufferChain
        MapCcbRetcode
        (DefaultParameterTableDump)
        (DumpParameterTableHeader)
        (DumpBufferFreeParms)
        (DumpBufferGetParms)
        (DumpDirCloseAdapterParms)
        (DumpDirDefineMifEnvironmentParms)
        (DumpDirInitializeParms)
        (DumpDirModifyOpenParmsParms)
        (DumpDirOpenAdapterParms)
        (DumpDirReadLog)
        (DumpDirRestoreOpenParmsParms)
        (DumpDirSetFunctionalAddressParms)
        (DumpDirSetGroupAddressParms)
        (DumpDirSetUserAppendageParms)
        (DumpDirStatusParms)
        (DumpDirTimerCancelParms)
        (DumpDirTimerCancelGroupParms)
        (DumpDirTimerSetParms)
        (DumpDlcCloseSapParms)
        (DumpDlcCloseStationParms)
        (DumpDlcConnectStationParms)
        (DumpDlcFlowControlParms)
        (MapFlowControl)
        (DumpDlcModifyParms)
        (DumpDlcOpenSapParms)
        (MapOptionsPriority)
        (DumpDlcOpenStationParms)
        (DumpDlcReallocateParms)
        (DumpDlcResetParms)
        (DumpDlcStatisticsParms)
        (DumpPdtTraceOffParms)
        (DumpPdtTraceOnParms)
        (DumpReadParms)
        (MapReadEvent)
        (MapDlcStatus)
        (DumpReadCancelParms)
        (DumpReceiveParms)
        (DumpReceiveCancelParms)
        (DumpReceiveModifyParms)
        (DumpTransmitDirFrameParms)
        (DumpTransmitIFrameParms)
        (DumpTransmitTestCmdParms)
        (DumpTransmitUiFrameParms)
        (DumpTransmitXidCmdParms)
        (DumpTransmitXidRespFinalParms)
        (DumpTransmitXidRespNotFinalParms)
        (DumpTransmitParms)
        (DumpTransmitQueue)
        DumpReceiveDataBuffer
        (MapMessageType)
        DumpData
        IsCcbErrorCodeAllowable
        IsCcbErrorCodeValid
        IsCcbCommandValid
        MapCcbCommandToName
        DumpDosAdapter
        (MapAdapterType)

Author:

    Richard L Firth (rfirth) 30-Apr-1992

Revision History:

--*/

#if DBG

#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>      // ASSERT, DbgPrint
#include <nturtl.h>
#include <windows.h>
#include <softpc.h>     // x86 virtual machine definitions
#include <vrdlctab.h>
#include <vdmredir.h>
#include <smbgtpt.h>
#include <dlcapi.h>     // Official DLC API definition
#include <ntdddlc.h>    // IOCTL commands
#include <dlcio.h>      // Internal IOCTL API interface structures
#include "vrdlc.h"
#include "vrdebug.h"
#include "vrdlcdbg.h"

//
// defines
//

//
// standard parameters to each table dump routine
//

#define DUMP_TABLE_PARMS    \
    IN  PVOID   Parameters, \
    IN  BOOL    IsDos,      \
    IN  BOOL    IsInput,    \
    IN  WORD    Segment,    \
    IN  WORD    Offset

//
// DumpData options
//

#define DD_NO_ADDRESS   0x00000001  // don't display address of data
#define DD_LINE_BEFORE  0x00000002  // linefeed before first dumped line
#define DD_LINE_AFTER   0x00000004  // linefeed after last dumped line
#define DD_INDENT_ALL   0x00000008  // indent all lines
#define DD_NO_ASCII     0x00000010  // don't dump ASCII respresentation
#define DD_UPPER_CASE   0x00000020  // upper-case hex dump (F4 instead of f4)

//
// misc.
//

#define DEFAULT_FIELD_WIDTH 13      // amount of description before a number

//
// local prototypes
//

VOID
DbgOutStr(
    IN LPSTR Str
    );

PRIVATE
VOID
DefaultParameterTableDump(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpParameterTableHeader(
    IN LPSTR CommandName,
    IN PVOID Table,
    IN BOOL IsDos,
    IN WORD Segment,
    IN WORD Offset
    );

PRIVATE
VOID
DumpBufferFreeParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpBufferGetParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDirCloseAdapterParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDirDefineMifEnvironmentParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDirInitializeParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDirModifyOpenParmsParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDirOpenAdapterParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDirReadLog(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDirRestoreOpenParmsParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDirSetFunctionalAddressParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDirSetGroupAddressParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDirSetUserAppendageParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDirStatusParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDirTimerCancelParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDirTimerCancelGroupParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDirTimerSetParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDlcCloseSapParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDlcCloseStationParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDlcConnectStationParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDlcFlowControlParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
LPSTR
MapFlowControl(
    BYTE FlowControl
    );

PRIVATE
VOID
DumpDlcModifyParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDlcOpenSapParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
LPSTR
MapOptionsPriority(
    UCHAR OptionsPriority
    );

PRIVATE
VOID
DumpDlcOpenStationParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDlcReallocateParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDlcResetParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpDlcStatisticsParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpPdtTraceOffParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpPdtTraceOnParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpReadParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
LPSTR
MapReadEvent(
    UCHAR Event
    );

PRIVATE
LPSTR
MapDlcStatus(
    WORD Status
    );

PRIVATE
VOID
DumpReadCancelParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpReceiveParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpReceiveCancelParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpReceiveModifyParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpTransmitDirFrameParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpTransmitIFrameParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpTransmitTestCmdParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpTransmitUiFrameParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpTransmitXidCmdParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpTransmitXidRespFinalParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpTransmitXidRespNotFinalParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpTransmitParms(
    DUMP_TABLE_PARMS
    );

PRIVATE
VOID
DumpTransmitQueue(
    IN DOS_ADDRESS dpQueue
    );

PRIVATE
LPSTR
MapMessageType(
    UCHAR MessageType
    );

VOID
DumpData(
    IN LPSTR Title,
    IN PBYTE Address,
    IN DWORD Length,
    IN DWORD Options,
    IN DWORD Indent,
    IN BOOL IsDos,
    IN WORD Segment,
    IN WORD Offset
    );

PRIVATE
LPSTR
MapAdapterType(
    IN ADAPTER_TYPE AdapterType
    );

//
// explanations of error codes returned in CCB_RETCODE fields. Explanations
// taken more-or-less verbatim from IBM Local Area Network Technical Reference
// table B-1 ppB-2 to B-5. Includes all errors, even not relevant to CCB1
//

static LPSTR CcbRetcodeExplanations[] = {
    "Success",
    "Invalid command code",
    "Duplicate command, one already outstanding",
    "Adapter open, should be closed",
    "Adapter closed, should be open",
    "Required parameter missing",
    "Invalid/incompatible option",
    "Command cancelled - unrecoverable failure",
    "Unauthorized access priority",
    "Adapter not initialized, should be",
    "Command cancelled by user request",
    "Command cancelled, adapter closed while command in progress",
    "Command completed Ok, adapter not open",
    "Invalid error code 0x0D",
    "Invalid error code 0x0E",
    "Invalid error code 0x0F",
    "Adapter open, NetBIOS not operational",
    "Error in DIR.TIMER.SET or DIR.TIMER.CANCEL",
    "Available work area exceeded",
    "Invalid LOG.ID",
    "Invalid shared RAM segment or size",
    "Lost log data, buffer too small, log reset",
    "Requested buffer size exceeds pool length",
    "Command invalid, NetBIOS operational",
    "Invalid SAP buffer length",
    "Inadequate buffers available for request",
    "USER_LENGTH value too large for buffer length",
    "The CCB_PARM_TAB pointer is invalid",
    "A pointer in the CCB parameter table is invalid",
    "Invalid CCB_ADAPTER value",
    "Invalid functional address",
    "Invalid error code 0x1F",
    "Lost data on receive, no buffers available",
    "Lost data on receive, inadequate buffer space",
    "Error on frame transmission, check TRANSMIT_FS data",
    "Error on frame transmit or strip process",
    "Unauthorized MAC frame",
    "Maximum number of commands exceeded",
    "Unrecognized command correlator",
    "Link not transmitting I frames, state changed from link opened",
    "Invalid transmit frame length",
    "Invalid error code 0x29",
    "Invalid error code 0x2a",
    "Invalid error code 0x2b",
    "Invalid error code 0x2c",
    "Invalid error code 0x2d",
    "Invalid error code 0x2e",
    "Invalid error code 0x2f",
    "Inadequate receive buffers for adapter to open",
    "Invalid error code 0x31",
    "Invalid NODE_ADDRESS",
    "Invalid adapter receive buffer length defined",
    "Invalid adapter transmit buffer length defined",
    "Invalid error code 0x35",
    "Invalid error code 0x36",
    "Invalid error code 0x37",
    "Invalid error code 0x38",
    "Invalid error code 0x39",
    "Invalid error code 0x3a",
    "Invalid error code 0x3b",
    "Invalid error code 0x3c",
    "Invalid error code 0x3d",
    "Invalid error code 0x3e",
    "Invalid error code 0x3f",
    "Invalid STATION_ID",
    "Protocol error, link in invalid state for command",
    "Parameter exceeded maximum allowed",
    "Invalid SAP value or value already in use",
    "Invalid routing information field",
    "Requested group membership in non-existent group SAP",
    "Resources not available",
    "Sap cannot close unless all link stations are closed",
    "Group SAP cannot close, individual SAPs not closed",
    "Group SAP has reached maximum membership",
    "Sequence error, incompatible command in progress",
    "Station closed without remote acknowledgement",
    "Sequence error, cannot close, DLC commands outstanding",
    "Unsuccessful link station connection attempted",
    "Member SAP not found in group SAP list",
    "Invalid remote address, may not be a group address",
    "Invalid pointer in CCB_POINTER field",
    "Invalid error code 0x51",
    "Invalid application program ID",
    "Invalid application program key code",
    "Invalid system key code",
    "Buffer is smaller than buffer size given in DLC.OPEN.SAP",
    "Adapter's system process is not installed",
    "Inadequate stations available",
    "Invalid CCB_PARAMETER_1 parameter",
    "Inadequate queue elements to satisfy request",
    "Initialization failure, cannot open adapter",
    "Error detected in chained READ command",
    "Direct stations not assigned to application program",
    "Dd interface not installed",
    "Requested adapter is not installed",
    "Chained CCBs must all be for same adapter",
    "Adapter initializing, command not accepted",
    "Number of allowed application programs has been exceeded",
    "Command cancelled by system action",
    "Direct stations not available",
    "Invalid DDNAME parameter",
    "Inadequate GDT selectors to satisfy request",
    "Invalid error code 0x66",
    "Command cancelled, CCB resources purged",
    "Application program ID not valid for interface",
    "Segment associated with request cannot be locked"
};

#define NUMBER_OF_ERROR_MESSAGES    ARRAY_ELEMENTS(CcbRetcodeExplanations)
#define LAST_DLC_ERROR_CODE         LAST_ELEMENT(CcbRetcodeExplanations)

VOID
DbgOut(
    IN LPSTR Format,
    IN ...
    )

/*++

Routine Description:

    Sends formatted debug output to desired output device. If DEBUG_TO_FILE
    was specified in VR environment flags, output goes to VRDEBUG.LOG in
    current directory, else to standard debug output via DbgPrint

Arguments:

    Format  - printf-style format string
    ...     - variable args

Return Value:

    None.

--*/

{
    va_list list;
    char buffer[2048];

    va_start(list, Format);
    vsprintf(buffer, Format, list);
    va_end(list);
    if (hVrDebugLog) {
        fputs(buffer, hVrDebugLog);
    } else {
        DbgPrint(buffer);
    }
}

VOID
DbgOutStr(
    IN LPSTR Str
    )

/*++

Routine Description:

    Sends formatted debug output to desired output device. If DEBUG_TO_FILE
    was specified in VR environment flags, output goes to VRDEBUG.LOG in
    current directory, else to standard debug output via DbgPrint

Arguments:

    Str     - string to print

Return Value:

    None.

--*/

{
    if (hVrDebugLog) {
        fputs(Str, hVrDebugLog);
    } else {
        DbgPrint(Str);
    }
}

VOID
DumpCcb(
    IN PVOID Ccb,
    IN BOOL DumpAll,
    IN BOOL CcbIsInput,
    IN BOOL IsDos,
    IN WORD Segment OPTIONAL,
    IN WORD Offset OPTIONAL
    )

/*++

Routine Description:

    Dumps (to debug terminal) a CCB and any associated parameter table. Also
    displays the symbolic CCB command and an error code description if the
    CCB is being returned to the caller. Dumps in either DOS format (segmented
    16-bit pointers) or NT format (flat 32-bit pointers)

Arguments:

    Ccb         - flat 32-bit pointer to CCB1 or CCB2 to dump
    DumpAll     - if TRUE, dumps parameter tables and buffers, else just CCB
    CcbIsInput  - if TRUE, CCB is from user: don't display error code explanation
    IsDos       - if TRUE, CCB is DOS format
    Segment     - if IsDos is TRUE, segment of CCB in VDM
    Offset      - if IsDos is TRUE, offset of CCB in VDM

Return Value:

    None.

--*/

{
    PVOID   parmtab = NULL;
    LPSTR   cmdname = "UNKNOWN CCB!";
    PLLC_CCB NtCcb = (PLLC_CCB)Ccb;
    PLLC_DOS_CCB DosCcb = (PLLC_DOS_CCB)Ccb;
    BOOL    haveParms = FALSE;
    VOID    (*DumpParms)(PVOID, BOOL, BOOL, WORD, WORD) = DefaultParameterTableDump;
    PVOID   parameterTable = NULL;
    WORD    seg;
    WORD    off;
    BOOL    parmsInCcb = FALSE;

    switch (((PLLC_CCB)Ccb)->uchDlcCommand) {
    case LLC_BUFFER_FREE:
        cmdname = "BUFFER.FREE";
        haveParms = TRUE;
        DumpParms = DumpBufferFreeParms;
        break;

    case LLC_BUFFER_GET:
        cmdname = "BUFFER.GET";
        haveParms = TRUE;
        DumpParms = DumpBufferGetParms;
        break;

    case LLC_DIR_CLOSE_ADAPTER:
        cmdname = "DIR.CLOSE.ADAPTER";
        haveParms = TRUE;
        DumpParms = DumpDirCloseAdapterParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DIR_CLOSE_DIRECT:
        cmdname = "DIR.CLOSE.DIRECT";
        break;

    case 0x2b:

        //
        // not supported ! (yet?)
        //

        cmdname = "DIR.DEFINE.MIF.ENVIRONMENT";
        haveParms = TRUE;
        break;

    case LLC_DIR_INITIALIZE:
        cmdname = "DIR.INITIALIZE";
        haveParms = TRUE;
        DumpParms = DumpDirInitializeParms;
        break;

    case LLC_DIR_INTERRUPT:
        cmdname = "DIR.INTERRUPT";
        break;

    case LLC_DIR_MODIFY_OPEN_PARMS:
        cmdname = "DIR.MODIFY.OPEN.PARMS";
        haveParms = TRUE;
        break;

    case LLC_DIR_OPEN_ADAPTER:
        cmdname = "DIR.OPEN.ADAPTER";
        haveParms = TRUE;
        DumpParms = DumpDirOpenAdapterParms;
        break;

    case LLC_DIR_OPEN_DIRECT:

        //
        // not supported from DOS!
        //

        cmdname = "DIR.OPEN.DIRECT";
        haveParms = TRUE;
        break;

    case LLC_DIR_READ_LOG:
        cmdname = "DIR.READ.LOG";
        haveParms = TRUE;
        break;

    case LLC_DIR_RESTORE_OPEN_PARMS:
        cmdname = "DIR.RESTORE.OPEN.PARMS";
        break;

    case LLC_DIR_SET_FUNCTIONAL_ADDRESS:
        cmdname = "DIR.SET.FUNCTIONAL.ADDRESS";
        haveParms = TRUE;
        DumpParms = DumpDirSetFunctionalAddressParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DIR_SET_GROUP_ADDRESS:
        cmdname = "DIR.SET.GROUP.ADDRESS";
        haveParms = TRUE;
        DumpParms = DumpDirSetGroupAddressParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DIR_SET_USER_APPENDAGE:
        cmdname = "DIR.SET.USER.APPENDAGE";
        haveParms = TRUE;
        DumpParms = DumpDirSetUserAppendageParms;
        break;

    case LLC_DIR_STATUS:
        cmdname = "DIR.STATUS";
        haveParms = TRUE;
        DumpParms = DumpDirStatusParms;
        break;

    case LLC_DIR_TIMER_CANCEL:
        cmdname = "DIR.TIMER.CANCEL";
        haveParms = TRUE;
        DumpParms = DumpDirTimerCancelParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DIR_TIMER_CANCEL_GROUP:
        cmdname = "DIR.TIMER.CANCEL.GROUP";
        haveParms = TRUE;
        DumpParms = DumpDirTimerCancelGroupParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DIR_TIMER_SET:
        cmdname = "DIR.TIMER.SET";
        haveParms = TRUE;
        DumpParms = DumpDirTimerSetParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DLC_CLOSE_SAP:
        cmdname = "DLC.CLOSE.SAP";
        haveParms = TRUE;
        DumpParms = DumpDlcCloseSapParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DLC_CLOSE_STATION:
        cmdname = "DLC.CLOSE.STATION";
        haveParms = TRUE;
        DumpParms = DumpDlcCloseStationParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DLC_CONNECT_STATION:
        cmdname = "DLC.CONNECT.STATION";
        haveParms = TRUE;
        DumpParms = DumpDlcConnectStationParms;
        break;

    case LLC_DLC_FLOW_CONTROL:
        cmdname = "DLC.FLOW.CONTROL";
        haveParms = TRUE;
        DumpParms = DumpDlcFlowControlParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DLC_MODIFY:
        cmdname = "DLC.MODIFY";
        haveParms = TRUE;
        break;

    case LLC_DLC_OPEN_SAP:
        cmdname = "DLC.OPEN.SAP";
        haveParms = TRUE;
        DumpParms = DumpDlcOpenSapParms;
        break;

    case LLC_DLC_OPEN_STATION:
        cmdname = "DLC.OPEN.STATION";
        haveParms = TRUE;
        DumpParms = DumpDlcOpenStationParms;
        break;

    case LLC_DLC_REALLOCATE_STATIONS:
        cmdname = "DLC.REALLOCATE";
        haveParms = TRUE;
        break;

    case LLC_DLC_RESET:
        cmdname = "DLC.RESET";
        haveParms = TRUE;
        DumpParms = DumpDlcResetParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DLC_SET_THRESHOLD:
        cmdname = "DLC.SET.THRESHOLD";
        haveParms = TRUE;
        break;

    case LLC_DLC_STATISTICS:
        cmdname = "DLC.STATISTICS";
        haveParms = TRUE;
        break;

    case 0x25:

        //
        // not supported !
        //

        cmdname = "PDT.TRACE.OFF";
        break;

    case 0x24:

        //
        // not supported !
        //

        cmdname = "PDT.TRACE.ON";
        break;

    case LLC_READ:
        cmdname = "READ";
        haveParms = TRUE;
        DumpParms = DumpReadParms;
        break;

    case LLC_READ_CANCEL:
        cmdname = "READ.CANCEL";
        break;

    case LLC_RECEIVE:
        cmdname = "RECEIVE";
        haveParms = TRUE;
        DumpParms = DumpReceiveParms;
        break;

    case LLC_RECEIVE_CANCEL:
        cmdname = "RECEIVE.CANCEL";
        haveParms = TRUE;
        DumpParms = DumpReceiveCancelParms;
        parmsInCcb = TRUE;
        break;

    case LLC_RECEIVE_MODIFY:
        cmdname = "RECEIVE.MODIFY";
        haveParms = TRUE;
        DumpParms = DumpReceiveModifyParms;
        break;

    case LLC_TRANSMIT_DIR_FRAME:
        cmdname = "TRANSMIT.DIR.FRAME";
        haveParms = TRUE;
        DumpParms = DumpTransmitDirFrameParms;
        break;

    case LLC_TRANSMIT_I_FRAME:
        cmdname = "TRANSMIT.I.FRAME";
        haveParms = TRUE;
        DumpParms = DumpTransmitIFrameParms;
        break;

    case LLC_TRANSMIT_TEST_CMD:
        cmdname = "TRANSMIT.TEST.CMD";
        haveParms = TRUE;
        DumpParms = DumpTransmitTestCmdParms;
        break;

    case LLC_TRANSMIT_UI_FRAME:
        cmdname = "TRANSMIT.UI.FRAME";
        haveParms = TRUE;
        DumpParms = DumpTransmitUiFrameParms;
        break;

    case LLC_TRANSMIT_XID_CMD:
        cmdname = "TRANSMIT.XID.CMD";
        haveParms = TRUE;
        DumpParms = DumpTransmitXidCmdParms;
        break;

    case LLC_TRANSMIT_XID_RESP_FINAL:
        cmdname = "TRANSMIT.XID.RESP.FINAL";
        haveParms = TRUE;
        DumpParms = DumpTransmitXidRespFinalParms;
        break;

    case LLC_TRANSMIT_XID_RESP_NOT_FINAL:
        cmdname = "TRANSMIT.XID.RESP.NOT.FINAL";
        haveParms = TRUE;
        DumpParms = DumpTransmitXidRespNotFinalParms;
        break;

    }

    if (IsDos) {
        seg = GET_SELECTOR(&DosCcb->u.pParms);
        off = GET_OFFSET(&DosCcb->u.pParms);
        parmtab = POINTER_FROM_WORDS(seg, off);
    } else {
        parmtab = NtCcb->u.pParameterTable;
    }

    if (IsDos) {
        PLLC_DOS_CCB DosCcb = (PLLC_DOS_CCB)Ccb;

        DBGPRINT(   "\n"
                    "------------------------------------------------------------------------------"
                    "\n"
                    );

        IF_DEBUG(TIME) {
            SYSTEMTIME timestruct;

            GetLocalTime(&timestruct);
            DBGPRINT(
                    "%02d:%02d:%02d.%03d\n",
                    timestruct.wHour,
                    timestruct.wMinute,
                    timestruct.wSecond,
                    timestruct.wMilliseconds
                    );
        }

        DBGPRINT(   "%s DOS CCB @%04x:%04x:\n"
                    "adapter      %02x\n"
                    "command      %02x [%s]\n"
                    "retcode      %02x [%s]\n"
                    "reserved     %02x\n"
                    "next         %04x:%04x\n"
                    "ANR          %04x:%04x\n",
                    CcbIsInput ? "INPUT" : "OUTPUT",
                    Segment,
                    Offset,
                    DosCcb->uchAdapterNumber,
                    DosCcb->uchDlcCommand,
                    cmdname,
                    DosCcb->uchDlcStatus,
                    CcbIsInput ? "" : MapCcbRetcode(DosCcb->uchDlcStatus),
                    DosCcb->uchReserved1,
                    GET_SEGMENT(&DosCcb->pNext),
                    GET_OFFSET(&DosCcb->pNext),
                    GET_SEGMENT(&DosCcb->ulCompletionFlag),
                    GET_OFFSET(&DosCcb->ulCompletionFlag)
                    );
        if (haveParms) {
            if (!parmsInCcb) {
                DBGPRINT(
                    "parms        %04x:%04x\n",
                    GET_SEGMENT(&DosCcb->u.pParms),
                    GET_OFFSET(&DosCcb->u.pParms)
                    );
                parameterTable = POINTER_FROM_WORDS(GET_SEGMENT(&DosCcb->u.pParms),
                                                    GET_OFFSET(&DosCcb->u.pParms)
                                                    );
            } else {
                parameterTable = (PVOID)READ_DWORD(&DosCcb->u.ulParameter);
            }
        }
    } else {
        PLLC_CCB NtCcb = (PLLC_CCB)Ccb;

        DBGPRINT(   "\n"
                    "------------------------------------------------------------------------------"
                    "\n"
                    );

        IF_DEBUG(TIME) {
            SYSTEMTIME timestruct;

            GetLocalTime(&timestruct);
            DBGPRINT(
                    "%02d:%02d:%02d.%03d\n",
                    timestruct.wHour,
                    timestruct.wMinute,
                    timestruct.wSecond,
                    timestruct.wMilliseconds
                    );
        }

        DBGPRINT(   "%s NT CCB @ %#8x\n"
                    "adapter      %02x\n"
                    "command      %02x [%s]\n"
                    "retcode      %02x [%s]\n"
                    "reserved     %02x\n"
                    "next         %08x\n"
                    "ANR          %08x\n",
                    CcbIsInput ? "INPUT" : "OUTPUT",
                    Ccb,
                    NtCcb->uchAdapterNumber,
                    NtCcb->uchDlcCommand,
                    cmdname,
                    NtCcb->uchDlcStatus,
                    CcbIsInput ? "" : MapCcbRetcode(NtCcb->uchDlcStatus),
                    NtCcb->uchReserved1,
                    NtCcb->pNext,
                    NtCcb->ulCompletionFlag
                    );
        if (haveParms) {
            if (!parmsInCcb) {
                DBGPRINT(
                    "parms        %08x\n",
                    NtCcb->u.pParameterTable
                    );
            }
            parameterTable = NtCcb->u.pParameterTable;
        }
        DBGPRINT(
                    "hEvent       %08x\n"
                    "reserved     %02x\n"
                    "readflag     %02x\n"
                    "reserved     %04x\n",
                    NtCcb->hCompletionEvent,
                    NtCcb->uchReserved2,
                    NtCcb->uchReadFlag,
                    NtCcb->usReserved3
                    );
    }
    if ((parameterTable && DumpAll) || parmsInCcb) {
        DumpParms(parameterTable, IsDos, CcbIsInput, seg, off);
    }
}

VOID
DumpDosDlcBufferPool(
    IN PDOS_DLC_BUFFER_POOL PoolDescriptor
    )

/*++

Routine Description:

    Dumps a DOS DLC buffer pool so we can see that it looks ok

Arguments:

    PoolDescriptor  - pointer to DOS_DLC_BUFFER_POOL structure

Return Value:

    None.

--*/

{
    int count = PoolDescriptor->BufferCount;

    DBGPRINT(   "DOS DLC Buffer Pool @%04x:%04x, BufferSize=%d, BufferCount=%d\n",
                HIWORD(PoolDescriptor->dpBuffer),
                LOWORD(PoolDescriptor->dpBuffer),
                PoolDescriptor->BufferSize,
                PoolDescriptor->BufferCount
                );

    DumpDosDlcBufferChain(PoolDescriptor->dpBuffer, PoolDescriptor->BufferCount);
}

VOID
DumpDosDlcBufferChain(
    IN DOS_ADDRESS DosAddress,
    IN DWORD BufferCount
    )

/*++

Routine Description:

    Dumps a chain of DOS buffers

Arguments:

    DosAddress  - address of buffer in VDM memory in DOS_ADDRESS format (16:16)
    BufferCount - number of buffers to dump

Return Value:

    None.

--*/

{
    WORD seg = HIWORD(DosAddress);
    WORD off = LOWORD(DosAddress);
    LPVOID pointer = DOS_PTR_TO_FLAT(DosAddress);
    int i;

    for (i = 1; BufferCount; --BufferCount, ++i) {
        DBGPRINT("Buffer % 3d: %04x:%04x, Next Buffer @%04x:%04x\n",
                    i,
                    seg, off,
                    (DWORD)GET_SELECTOR(&((PLLC_DOS_BUFFER)pointer)->pNext),
                    (DWORD)GET_OFFSET(&((PLLC_DOS_BUFFER)pointer)->pNext)
                    );
        seg = GET_SELECTOR(&((PLLC_DOS_BUFFER)pointer)->pNext);
        off = GET_OFFSET(&((PLLC_DOS_BUFFER)pointer)->pNext);

        IF_DEBUG(DUMP_FREE_BUF) {

            PLLC_DOS_BUFFER pBuf = (PLLC_DOS_BUFFER)pointer;

            DBGPRINT(
                    "next buffer  %04x:%04x\n"
                    "frame length %04x\n"
                    "data length  %04x\n"
                    "user offset  %04x\n"
                    "user length  %04x\n"
                    "station id   %04x\n"
                    "options      %02x\n"
                    "message type %02x\n"
                    "buffers left %04x\n"
                    "rcv FS       %02x\n"
                    "adapter num  %02x\n"
                    "\n",
                    GET_SEGMENT(&pBuf->Contiguous.pNextBuffer),
                    GET_OFFSET(&pBuf->Contiguous.pNextBuffer),
                    READ_WORD(&pBuf->Contiguous.cbFrame),
                    READ_WORD(&pBuf->Contiguous.cbBuffer),
                    READ_WORD(&pBuf->Contiguous.offUserData),
                    READ_WORD(&pBuf->Contiguous.cbUserData),
                    READ_WORD(&pBuf->Contiguous.usStationId),
                    pBuf->Contiguous.uchOptions,
                    pBuf->Contiguous.uchMsgType,
                    READ_WORD(&pBuf->Contiguous.cBuffersLeft),
                    pBuf->Contiguous.uchRcvFS,
                    pBuf->Contiguous.uchAdapterNumber
                    );
        }

        pointer = READ_FAR_POINTER(&((PLLC_DOS_BUFFER)pointer)->pNext);
    }
}

LPSTR
MapCcbRetcode(
    IN BYTE Retcode
    )

/*++

Routine Description:

    Returns string describing error code

Arguments:

    Retcode - CCB_RETCODE

Return Value:

    LPSTR

--*/

{
    static char    errbuf[128];

    if (Retcode == LLC_STATUS_PENDING) {
        return "Command in progress";
    } else if (Retcode > NUMBER_OF_ERROR_MESSAGES) {
        sprintf(errbuf, "*** Invalid error code 0x%2x ***", Retcode);
        return errbuf;
    }
    return CcbRetcodeExplanations[Retcode];
}

PRIVATE
VOID
DefaultParameterTableDump(
    DUMP_TABLE_PARMS
    )

/*++

Routine Description:

    Displays default message for CCBs which have parameter tables that don't
    have a dump routine yet

Arguments:

    Parameters  - pointer to parameter table
    IsDos       - if TRUE parameters in DOS (16:16) format
    Segment     - if IsDos is TRUE, segment of CCB in VDM
    Offset      - if IsDos is TRUE, offset of CCB in VDM

Return Value:

    None.

--*/

{
    DBGPRINT("Parameter table dump not implemented for this CCB\n");
}

PRIVATE
VOID
DumpParameterTableHeader(
    IN LPSTR CommandName,
    IN PVOID Table,
    IN BOOL IsDos,
    IN WORD Segment,
    IN WORD Offset
    )

/*++

Routine Description:

    Displays header for parameter table dump. Displays address in DOS or NT
    format (32-bit flat or 16:16)

Arguments:

    CommandName - name of command which owns parameter table
    Table       - flat 32-bit address of parameter table
    IsDos       - if TRUE, use Segment:Offset in display
    Segment     - if IsDos is TRUE, segment of parameter table in VDM
    Offset      - if IsDos is TRUE, offset of parameter table in VDM

Return Value:

    None.

--*/

{
    DBGPRINT(   IsDos   ? "\n%s parameter table @%04x:%04x\n"
                        : "\n%s parameter table @%08x\n",
                CommandName,
                IsDos ? (DWORD)Segment : (DWORD)Table,
                IsDos ? (DWORD)Offset : 0
                );
}

PRIVATE
VOID
DumpBufferFreeParms(
    DUMP_TABLE_PARMS
    )
{
    PLLC_BUFFER_FREE_PARMS parms = (PLLC_BUFFER_FREE_PARMS)Parameters;

    DumpParameterTableHeader("BUFFER.FREE", Parameters, IsDos, Segment, Offset);

    DBGPRINT(   "station id   %04x\n"
                "buffers left %04x\n"
                "reserved     %02x %02x %02x %02x\n",
                READ_WORD(&parms->usReserved1),
                READ_WORD(&parms->cBuffersLeft),
                ((PBYTE)&(parms->ulReserved))[0],
                ((PBYTE)&(parms->ulReserved))[1],
                ((PBYTE)&(parms->ulReserved))[2],
                ((PBYTE)&(parms->ulReserved))[3]
                );
    if (IsDos) {
        DBGPRINT(
                "first buffer %04x:%04x\n",
                GET_SELECTOR(&parms->pFirstBuffer),
                GET_OFFSET(&parms->pFirstBuffer)
                );
    } else {
        DBGPRINT(
                "first buffer %08x\n", parms->pFirstBuffer);
    }
}

PRIVATE
VOID
DumpBufferGetParms(
    DUMP_TABLE_PARMS
    )
{
    //
    // Antti's definition different from that in manual, so use IBM def.
    //

    typedef struct {
        WORD    StationId;
        WORD    BufferLeft;
        BYTE    BufferGet;
        BYTE    Reserved[3];
        DWORD   FirstBuffer;
    } CCB1_BUFFER_GET_PARMS, *PCCB1_BUFFER_GET_PARMS;

    PCCB1_BUFFER_GET_PARMS parms = (PCCB1_BUFFER_GET_PARMS)Parameters;

    DumpParameterTableHeader("BUFFER.GET", Parameters, IsDos, Segment, Offset);

    DBGPRINT(   "station id   %04x\n"
                "buffers left %04x\n"
                "buffers get  %02x\n"
                "reserved     %02x %02x %02x\n",
                READ_WORD(&parms->StationId),
                READ_WORD(&parms->BufferLeft),
                parms->BufferGet,
                parms->Reserved[0],
                parms->Reserved[1],
                parms->Reserved[2]
                );
    if (IsDos) {
        DBGPRINT(
                "first buffer %04x:%04x\n",
                GET_SELECTOR(&parms->FirstBuffer),
                GET_OFFSET(&parms->FirstBuffer)
                );
    } else {
        DBGPRINT(
                "first buffer %08x\n", parms->FirstBuffer);
    }
}

PRIVATE
VOID
DumpDirCloseAdapterParms(
    DUMP_TABLE_PARMS
    )
{
    UNREFERENCED_PARAMETER(IsDos);
    UNREFERENCED_PARAMETER(Segment);
    UNREFERENCED_PARAMETER(Offset);

    DBGPRINT(   "lock code    %04x\n", LOWORD(Parameters));
}

PRIVATE
VOID
DumpDirDefineMifEnvironmentParms(
    DUMP_TABLE_PARMS
    )
{
}

PRIVATE
VOID
DumpDirInitializeParms(
    DUMP_TABLE_PARMS
    )
{
    //
    // once again, invent a structure to reflect the DOS CCB parameter table
    // as defined in the IBM LAN tech ref
    //

    typedef struct {
        WORD    BringUps;
        WORD    SharedRam;
        BYTE    Reserved[4];
        DWORD   AdapterCheckAppendage;
        DWORD   NetworkStatusChangeAppendage;
        DWORD   IoErrorAppendage;
    } CCB1_DIR_INITIALIZE_PARMS, *PCCB1_DIR_INITIALIZE_PARMS;

    PCCB1_DIR_INITIALIZE_PARMS parms = (PCCB1_DIR_INITIALIZE_PARMS)Parameters;

    DumpParameterTableHeader("DIR.INITIALIZE", Parameters, IsDos, Segment, Offset);

    DBGPRINT(   "bring ups    %04x\n"
                "shared RAM   %04x\n"
                "reserved     %02x %02x %02x %02x\n"
                "adap. check  %04x:%04x\n"
                "n/w status   %04x:%04x\n"
                "pc error     %04x:%04x\n",
                READ_WORD(&parms->BringUps),
                READ_WORD(&parms->SharedRam),
                parms->Reserved[0],
                parms->Reserved[1],
                parms->Reserved[2],
                parms->Reserved[3],
                GET_SEGMENT(&parms->AdapterCheckAppendage),
                GET_OFFSET(&parms->AdapterCheckAppendage),
                GET_SEGMENT(&parms->NetworkStatusChangeAppendage),
                GET_OFFSET(&parms->NetworkStatusChangeAppendage),
                GET_SEGMENT(&parms->IoErrorAppendage),
                GET_OFFSET(&parms->IoErrorAppendage)
                );
}

PRIVATE
VOID
DumpDirModifyOpenParmsParms(
    DUMP_TABLE_PARMS
    )
{
}

PRIVATE
VOID
DumpDirOpenAdapterParms(
    DUMP_TABLE_PARMS
    )
{
    PLLC_DOS_DIR_OPEN_ADAPTER_PARMS dosParms = (PLLC_DOS_DIR_OPEN_ADAPTER_PARMS)Parameters;
    PLLC_DIR_OPEN_ADAPTER_PARMS ntParms = (PLLC_DIR_OPEN_ADAPTER_PARMS)Parameters;

    DumpParameterTableHeader("DIR.OPEN.ADAPTER", Parameters, IsDos, Segment, Offset);

    if (IsDos) {
        PADAPTER_PARMS pAdapterParms = READ_FAR_POINTER(&dosParms->pAdapterParms);
        PDIRECT_PARMS pDirectParms = READ_FAR_POINTER(&dosParms->pDirectParms);
        PDLC_PARMS pDlcParms = READ_FAR_POINTER(&dosParms->pDlcParms);
        PNCB_PARMS pNcbParms = READ_FAR_POINTER(&dosParms->pNcbParms);
        ULPBYTE pProductId;
        DWORD i;

        DBGPRINT(
                "adapter parms %04x:%04x\n"
                "direct parms  %04x:%04x\n"
                "DLC parms     %04x:%04x\n"
                "NCB parms     %04x:%04x\n",
                GET_SEGMENT(&dosParms->pAdapterParms),
                GET_OFFSET(&dosParms->pAdapterParms),
                GET_SEGMENT(&dosParms->pDirectParms),
                GET_OFFSET(&dosParms->pDirectParms),
                GET_SEGMENT(&dosParms->pDlcParms),
                GET_OFFSET(&dosParms->pDlcParms),
                GET_SEGMENT(&dosParms->pNcbParms),
                GET_OFFSET(&dosParms->pNcbParms)
                );
        if (pAdapterParms) {
            DBGPRINT(
                "\n"
                "ADAPTER_PARMS @%04x:%04x\n"
                "open error    %04x\n"
                "open options  %04x\n"
                "node address  %02x-%02x-%02x-%02x-%02x-%02x\n"
                "group address %08x\n"
                "func. address %08x\n"
                "# rcv buffers %04x\n"
                "rcv buf len   %04x\n"
                "DHB len       %04x\n"
                "# DHBs        %02x\n"
                "Reserved      %02x\n"
                "Open Lock     %04x\n"
                "Product ID    %04x:%04x\n",
                GET_SEGMENT(&dosParms->pAdapterParms),
                GET_OFFSET(&dosParms->pAdapterParms),
                READ_WORD(&pAdapterParms->OpenErrorCode),
                READ_WORD(&pAdapterParms->OpenOptions),
                READ_BYTE(&pAdapterParms->NodeAddress[0]),
                READ_BYTE(&pAdapterParms->NodeAddress[1]),
                READ_BYTE(&pAdapterParms->NodeAddress[2]),
                READ_BYTE(&pAdapterParms->NodeAddress[3]),
                READ_BYTE(&pAdapterParms->NodeAddress[4]),
                READ_BYTE(&pAdapterParms->NodeAddress[5]),
                READ_DWORD(&pAdapterParms->GroupAddress),
                READ_DWORD(&pAdapterParms->FunctionalAddress),
                READ_WORD(&pAdapterParms->NumberReceiveBuffers),
                READ_WORD(&pAdapterParms->ReceiveBufferLength),
                READ_WORD(&pAdapterParms->DataHoldBufferLength),
                READ_BYTE(&pAdapterParms->NumberDataHoldBuffers),
                READ_BYTE(&pAdapterParms->Reserved),
                READ_WORD(&pAdapterParms->OpenLock),
                GET_SEGMENT(&pAdapterParms->ProductId),
                GET_OFFSET(&pAdapterParms->ProductId)
                );
            pProductId = READ_FAR_POINTER(&pAdapterParms->ProductId);
            if (pProductId) {
                DBGPRINT("\nPRODUCT ID:\n");
                for (i=0; i<18; ++i) {
                    DBGPRINT("%02x ", *pProductId++);
                }
                DBGPRINT("\n");
            }
        }
        if (pDirectParms) {
            DBGPRINT(
                "\n"
                "DIRECT_PARMS @%04x:%04x\n"
                "dir buf size  %04x\n"
                "dir pool blx  %04x\n"
                "dir buf pool  %04x:%04x\n"
                "adap chk exit %04x:%04x\n"
                "nw stat exit  %04x:%04x\n"
                "pc error exit %04x:%04x\n"
                "adap wrk area %04x:%04x\n"
                "adap wrk req. %04x\n"
                "adap wrk act  %04x\n",
                GET_SEGMENT(&dosParms->pDirectParms),
                GET_OFFSET(&dosParms->pDirectParms),
                READ_WORD(&pDirectParms->DirectBufferSize),
                READ_WORD(&pDirectParms->DirectPoolBlocks),
                GET_SEGMENT(&pDirectParms->DirectBufferPool),
                GET_OFFSET(&pDirectParms->DirectBufferPool),
                GET_SEGMENT(&pDirectParms->AdapterCheckExit),
                GET_OFFSET(&pDirectParms->AdapterCheckExit),
                GET_SEGMENT(&pDirectParms->NetworkStatusExit),
                GET_OFFSET(&pDirectParms->NetworkStatusExit),
                GET_SEGMENT(&pDirectParms->PcErrorExit),
                GET_OFFSET(&pDirectParms->PcErrorExit),
                GET_SEGMENT(&pDirectParms->AdapterWorkArea),
                GET_OFFSET(&pDirectParms->AdapterWorkArea),
                READ_WORD(&pDirectParms->AdapterWorkAreaRequested),
                READ_WORD(&pDirectParms->AdapterWorkAreaActual)
                );
        }
        if (pDlcParms) {
            DBGPRINT(
                "\n"
                "DLC_PARMS @%04x:%04x\n"
                "max SAPs      %02x\n"
                "max links     %02x\n"
                "max grp SAPs  %02x\n"
                "max grp memb  %02x\n"
                "T1 tick 1     %02x\n"
                "T2 tick 1     %02x\n"
                "Ti tick 1     %02x\n"
                "T1 tick 2     %02x\n"
                "T2 tick 2     %02x\n"
                "Ti tick 2     %02x\n",
                GET_SEGMENT(&dosParms->pDlcParms),
                GET_OFFSET(&dosParms->pDlcParms),
                READ_BYTE(&pDlcParms->MaxSaps),
                READ_BYTE(&pDlcParms->MaxStations),
                READ_BYTE(&pDlcParms->MaxGroupSaps),
                READ_BYTE(&pDlcParms->MaxGroupMembers),
                READ_BYTE(&pDlcParms->T1Tick1),
                READ_BYTE(&pDlcParms->T2Tick1),
                READ_BYTE(&pDlcParms->TiTick1),
                READ_BYTE(&pDlcParms->T1Tick2),
                READ_BYTE(&pDlcParms->T2Tick2),
                READ_BYTE(&pDlcParms->TiTick2)
                );
        }
        if (pNcbParms) {
            DBGPRINT(
                "\n"
                "NCB_PARMS @%04x:%04x???\n",
                GET_SEGMENT(&dosParms->pNcbParms),
                GET_OFFSET(&dosParms->pNcbParms)

                );
        }
    } else {
        PLLC_ADAPTER_OPEN_PARMS pAdapterParms = ntParms->pAdapterParms;
        PLLC_EXTENDED_ADAPTER_PARMS pExtendedParms = ntParms->pExtendedParms;
        PLLC_DLC_PARMS pDlcParms = ntParms->pDlcParms;
        PVOID pNcbParms = ntParms->pReserved1;

        DBGPRINT(
                "adapter parms %08x\n"
                "direct parms  %08x\n"
                "DLC parms     %08x\n"
                "NCB parms     %08x\n",
                pAdapterParms,
                pExtendedParms,
                pDlcParms,
                pNcbParms
                );
        if (pAdapterParms) {
            DBGPRINT(
                "\n"
                "ADAPTER_PARMS @%08x\n"
                "open error    %04x\n"
                "open options  %04x\n"
                "node address  %02x-%02x-%02x-%02x-%02x-%02x\n"
                "group address %08x\n"
                "func. address %08x\n"
                "reserved 1    %04x\n"
                "reserved 2    %04x\n"
                "max frame len %04x\n"
                "reserved 3[0] %04x\n"
                "reserved 3[1] %04x\n"
                "reserved 3[2] %04x\n"
                "reserved 3[3] %04x\n"
                "bring ups     %04x\n"
                "init warnings %04x\n"
                "reserved 4[0] %04x\n"
                "reserved 4[1] %04x\n"
                "reserved 4[2] %04x\n",
                pAdapterParms,
                pAdapterParms->usOpenErrorCode,
                pAdapterParms->usOpenOptions,
                pAdapterParms->auchNodeAddress[0],
                pAdapterParms->auchNodeAddress[1],
                pAdapterParms->auchNodeAddress[2],
                pAdapterParms->auchNodeAddress[3],
                pAdapterParms->auchNodeAddress[4],
                pAdapterParms->auchNodeAddress[5],
                *(UNALIGNED DWORD *)&pAdapterParms->auchGroupAddress,
                *(UNALIGNED DWORD *)&pAdapterParms->auchFunctionalAddress,
                pAdapterParms->usReserved1,
                pAdapterParms->usReserved2,
                pAdapterParms->usMaxFrameSize,
                pAdapterParms->usReserved3[0],
                pAdapterParms->usReserved3[1],
                pAdapterParms->usReserved3[2],
                pAdapterParms->usReserved3[3],
                pAdapterParms->usBringUps,
                pAdapterParms->InitWarnings,
                pAdapterParms->usReserved4[0],
                pAdapterParms->usReserved4[1],
                pAdapterParms->usReserved4[2]
                );
        }
        if (pExtendedParms) {
            DBGPRINT(
                "\n"
                "EXTENDED PARMS @%08x\n"
                "hBufferPool   %08x\n"
                "pSecurityDesc %08x\n"
                "Ethernet Type %08x\n",
                pExtendedParms,
                pExtendedParms->hBufferPool,
                pExtendedParms->pSecurityDescriptor,
                pExtendedParms->LlcEthernetType
                );
        }
        if (pDlcParms) {
            DBGPRINT(
                "\n"
                "DLC_PARMS @%04x:%04x\n"
                "max SAPs      %02x\n"
                "max links     %02x\n"
                "max grp SAPs  %02x\n"
                "max grp memb  %02x\n"
                "T1 tick 1     %02x\n"
                "T2 tick 1     %02x\n"
                "Ti tick 1     %02x\n"
                "T1 tick 2     %02x\n"
                "T2 tick 2     %02x\n"
                "Ti tick 2     %02x\n",
                pDlcParms,
                pDlcParms->uchDlcMaxSaps,
                pDlcParms->uchDlcMaxStations,
                pDlcParms->uchDlcMaxGroupSaps,
                pDlcParms->uchDlcMaxGroupMembers,
                pDlcParms->uchT1_TickOne,
                pDlcParms->uchT2_TickOne,
                pDlcParms->uchTi_TickOne,
                pDlcParms->uchT1_TickTwo,
                pDlcParms->uchT2_TickTwo,
                pDlcParms->uchTi_TickTwo
                );
        }
        if (pNcbParms) {
            DBGPRINT(
                "\n"
                "NCB_PARMS @%08x???\n",
                pNcbParms
                );
        }
    }
}

PRIVATE
VOID
DumpDirReadLog(
    DUMP_TABLE_PARMS
    )
{
    DumpParameterTableHeader("DIR.READ.LOG", Parameters, IsDos, Segment, Offset);
}

PRIVATE
VOID
DumpDirRestoreOpenParmsParms(
    DUMP_TABLE_PARMS
    )
{
}

PRIVATE
VOID
DumpDirSetFunctionalAddressParms(
    DUMP_TABLE_PARMS
    )
{
    DBGPRINT(   "funct addr   %08lx\n", Parameters);
}

PRIVATE
VOID
DumpDirSetGroupAddressParms(
    DUMP_TABLE_PARMS
    )
{
    DBGPRINT(   "group addr   %08lx\n", Parameters);
}

PRIVATE
VOID
DumpDirSetUserAppendageParms(
    DUMP_TABLE_PARMS
    )
{
    PLLC_DIR_SET_USER_APPENDAGE_PARMS parms = (PLLC_DIR_SET_USER_APPENDAGE_PARMS)Parameters;

    DumpParameterTableHeader("DIR.SET.USER.APPENDAGE", Parameters, IsDos, Segment, Offset);

    if (IsDos) {
        DBGPRINT(   "adapt check  %04x:%04x\n"
                    "n/w status   %04x:%04x\n"
                    "w/s error    %04x:%04x\n",
                    GET_SEGMENT(&parms->dpAdapterCheckExit),
                    GET_OFFSET(&parms->dpAdapterCheckExit),
                    GET_SEGMENT(&parms->dpNetworkStatusExit),
                    GET_OFFSET(&parms->dpNetworkStatusExit),
                    GET_SEGMENT(&parms->dpPcErrorExit),
                    GET_OFFSET(&parms->dpPcErrorExit)
                    );
    }
}

PRIVATE
VOID
DumpDirStatusParms(
    DUMP_TABLE_PARMS
    )
{
    PDOS_DIR_STATUS_PARMS dosParms = (PDOS_DIR_STATUS_PARMS)Parameters;

    DumpParameterTableHeader("DIR.STATUS", Parameters, IsDos, Segment, Offset);

    if (IsDos) {
        DBGPRINT(   "perm addr    %02x-%02x-%02x-%02x-%02x-%02x\n"
                    "local addr   %02x-%02x-%02x-%02x-%02x-%02x\n"
                    "group addr   %08lx\n"
                    "func addr    %08lx\n"
                    "max SAPs     %02x\n"
                    "open SAPs    %02x\n"
                    "max links    %02x\n"
                    "open links   %02x\n"
                    "avail links  %02x\n"
                    "adapt config %02x\n"
                    "ucode level  %02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x\n"
                    "adap parms   %04x:%04x\n"
                    "adap MAC     %04x:%04x\n"
                    "timer tick   %04x:%04x\n"
                    "last NW stat %04x\n"
                    "ext. status  %04x:%04x\n",
                    dosParms->auchPermanentAddress[0],
                    dosParms->auchPermanentAddress[1],
                    dosParms->auchPermanentAddress[2],
                    dosParms->auchPermanentAddress[3],
                    dosParms->auchPermanentAddress[4],
                    dosParms->auchPermanentAddress[5],
                    dosParms->auchNodeAddress[0],
                    dosParms->auchNodeAddress[1],
                    dosParms->auchNodeAddress[2],
                    dosParms->auchNodeAddress[3],
                    dosParms->auchNodeAddress[4],
                    dosParms->auchNodeAddress[5],
                    READ_DWORD(&dosParms->auchGroupAddress),
                    READ_DWORD(&dosParms->auchFunctAddr),
                    dosParms->uchMaxSap,
                    dosParms->uchOpenSaps,
                    dosParms->uchMaxStations,
                    dosParms->uchOpenStation,
                    dosParms->uchAvailStations,
                    dosParms->uchAdapterConfig,
                    dosParms->auchMicroCodeLevel[0],
                    dosParms->auchMicroCodeLevel[1],
                    dosParms->auchMicroCodeLevel[2],
                    dosParms->auchMicroCodeLevel[3],
                    dosParms->auchMicroCodeLevel[4],
                    dosParms->auchMicroCodeLevel[5],
                    dosParms->auchMicroCodeLevel[6],
                    dosParms->auchMicroCodeLevel[7],
                    dosParms->auchMicroCodeLevel[8],
                    dosParms->auchMicroCodeLevel[9],
                    GET_SEGMENT(&dosParms->dpAdapterParmsAddr),
                    GET_OFFSET(&dosParms->dpAdapterParmsAddr),
                    GET_SEGMENT(&dosParms->dpAdapterMacAddr),
                    GET_OFFSET(&dosParms->dpAdapterMacAddr),
                    GET_SEGMENT(&dosParms->dpTimerTick),
                    GET_OFFSET(&dosParms->dpTimerTick),
                    READ_WORD(&dosParms->usLastNetworkStatus),
                    GET_SEGMENT(&dosParms->dpExtendedParms),
                    GET_OFFSET(&dosParms->dpExtendedParms)
                    );
    } else {
        DBGPRINT("no dump for this table yet\n");
    }
}

PRIVATE
VOID
DumpDirTimerCancelParms(
    DUMP_TABLE_PARMS
    )
{
    if (IsDos) {
        DBGPRINT(   "cancel timer %04x:%04x\n",
                HIWORD(Parameters),
                LOWORD(Parameters)
                );
    }
}

PRIVATE
VOID
DumpDirTimerCancelGroupParms(
    DUMP_TABLE_PARMS
    )
{
    if (IsDos) {
        DBGPRINT(   "cancel timer %04x:%04x\n",
                HIWORD(Parameters),
                LOWORD(Parameters)
                );
    }
}

PRIVATE
VOID
DumpDirTimerSetParms(
    DUMP_TABLE_PARMS
    )
{
    if (IsDos) {
        DBGPRINT(   "timer value  %04x\n",
                LOWORD(Parameters)
                );
    }
}

PRIVATE
VOID
DumpDlcCloseSapParms(
    DUMP_TABLE_PARMS
    )
{
    if (IsDos) {
        DBGPRINT(   "STATION_ID   %04x\n"
                    "reserved     %04x\n",
                LOWORD(Parameters),
                HIWORD(Parameters)
                );
    }
}

PRIVATE
VOID
DumpDlcCloseStationParms(
    DUMP_TABLE_PARMS
    )
{
    if (IsDos) {
        DBGPRINT(   "STATION_ID   %04x\n"
                    "reserved     %02x %02x\n",
                LOWORD(Parameters),
                LOBYTE(HIWORD(Parameters)),
                HIBYTE(HIWORD(Parameters))
                );
    }
}

PRIVATE
VOID
DumpDlcConnectStationParms(
    DUMP_TABLE_PARMS
    )
{
    LLC_DLC_CONNECT_PARMS UNALIGNED * parms = (PLLC_DLC_CONNECT_PARMS)Parameters;
    ULPBYTE routing = NULL;
    int i;

    DumpParameterTableHeader("DLC.CONNECT.STATION", Parameters, IsDos, Segment, Offset);

    DBGPRINT(   "station id   %04x\n"
                "reserved     %02x %02x\n",
                READ_WORD(&parms->usStationId),
                ((ULPBYTE)(&parms->usReserved))[0],
                ((ULPBYTE)(&parms->usReserved))[1]
                );
    if (IsDos) {
        DBGPRINT(
                "routing addr %04x:%04x\n",
                GET_SEGMENT(&parms->pRoutingInfo),
                GET_OFFSET(&parms->pRoutingInfo)
                );
        routing = READ_FAR_POINTER(&parms->pRoutingInfo);
    } else {
        DBGPRINT(
                "routing addr %08x\n",
                parms->pRoutingInfo
                );
        routing = parms->pRoutingInfo;
    }
    if (routing) {
        DBGPRINT("ROUTING INFO: ");
        for (i=0; i<18; ++i) {
            DBGPRINT("%02x ", routing[i]);
        }
        DBGPRINT("\n");
    }
}

PRIVATE
VOID
DumpDlcFlowControlParms(
    DUMP_TABLE_PARMS
    )
{
    DBGPRINT(
            "STATION_ID   %04x\n"
            "flow control %02x [%s]\n"
            "reserved     %02x\n",
            LOWORD(Parameters),
            LOBYTE(HIWORD(Parameters)),
            MapFlowControl(LOBYTE(HIWORD(Parameters))),
            HIBYTE(HIWORD(Parameters))
            );
}

PRIVATE LPSTR MapFlowControl(BYTE FlowControl) {
    if (FlowControl & 0x80) {
        if (FlowControl & 0x40) {
            return "reset local_busy(buffer)";
        } else {
            return "reset local_busy(user)";
        }
    } else {
        return "set local_busy(user)";
    }
}

PRIVATE
VOID
DumpDlcModifyParms(
    DUMP_TABLE_PARMS
    )
{
}

PRIVATE
VOID
DumpDlcOpenSapParms(
    DUMP_TABLE_PARMS
    )
{
    PLLC_DLC_OPEN_SAP_PARMS parms = (PLLC_DLC_OPEN_SAP_PARMS)Parameters;

    DumpParameterTableHeader("DLC.OPEN.SAP", Parameters, IsDos, Segment, Offset);

    DBGPRINT(   "station id   %04x\n"
                "user stat    %04x\n"
                "T1           %02x\n"
                "T2           %02x\n"
                "Ti           %02x\n"
                "max out      %02x\n"
                "max in       %02x\n"
                "max out inc  %02x\n"
                "max retry    %02x\n"
                "max members  %02x\n"
                "max I field  %04x\n"
                "SAP value    %02x\n"
                "options      %02x [%s]\n"
                "link count   %02x\n"
                "reserved     %02x %02x\n"
                "group count  %02x\n",
                READ_WORD(&parms->usStationId),
                READ_WORD(&parms->usUserStatValue),
                parms->uchT1,
                parms->uchT2,
                parms->uchTi,
                parms->uchMaxOut,
                parms->uchMaxIn,
                parms->uchMaxOutIncr,
                parms->uchMaxRetryCnt,
                parms->uchMaxMembers,
                READ_WORD(&parms->usMaxI_Field),
                parms->uchSapValue,
                parms->uchOptionsPriority,
                MapOptionsPriority(parms->uchOptionsPriority),
                parms->uchcStationCount,
                parms->uchReserved2[0],
                parms->uchReserved2[1],
                parms->cGroupCount
                );
    if (IsDos) {
        DBGPRINT(
                "group list   %04x:%04x\n"
                "dlc stat app %04x:%04x\n",
                GET_SEGMENT(&parms->pGroupList),
                GET_OFFSET(&parms->pGroupList),
                GET_SEGMENT(&parms->DlcStatusFlags),
                GET_OFFSET(&parms->DlcStatusFlags)
                );

        //
        // some code here to dump group list
        //

    } else {
        DBGPRINT(
                "group list   %08x\n"
                "dlc status   %08x\n",
                parms->pGroupList,
                parms->DlcStatusFlags
                );
    }
    DBGPRINT(   "buffer size  %04x\n"
                "pool length  %04x\n",
                READ_WORD(&parms->uchReserved3[0]),
                READ_WORD(&parms->uchReserved3[2])
                );
    if (IsDos) {
        DBGPRINT(
                "buffer pool  %04x:%04x\n",
                READ_WORD(&parms->uchReserved3[6]),
                READ_WORD(&parms->uchReserved3[4])
                );
    } else {
        DBGPRINT(
                "buffer pool  %08x\n",
                *(LPDWORD)&parms->uchReserved3[4]
                );
    }
}

PRIVATE LPSTR MapOptionsPriority(UCHAR OptionsPriority) {
    static char buf[80];
    char* bufptr = buf;

    bufptr += sprintf(buf, "Access Priority=%d", (OptionsPriority & 0xe0) >> 5);
    if (OptionsPriority & 8) {
        bufptr += sprintf(bufptr, " XID handled by APP");
    } else {
        bufptr += sprintf(bufptr, " XID handled by DLC");
    }
    if (OptionsPriority & 4) {
        bufptr += sprintf(bufptr, " Individual SAP");
    }
    if (OptionsPriority & 2) {
        bufptr += sprintf(bufptr, " Group SAP");
    }
    if (OptionsPriority & 1) {
        bufptr += sprintf(bufptr, " Group Member SAP");
    }
    return buf;
}

PRIVATE
VOID
DumpDlcOpenStationParms(
    DUMP_TABLE_PARMS
    )
{
    PLLC_DLC_OPEN_STATION_PARMS parms = (PLLC_DLC_OPEN_STATION_PARMS)Parameters;
    ULPBYTE dest = NULL;
    int i;

    DumpParameterTableHeader("DLC.OPEN.STATION", Parameters, IsDos, Segment, Offset);

    DBGPRINT(   "sap station  %04x\n"
                "link station %04x\n"
                "T1           %02x\n"
                "T2           %02x\n"
                "Ti           %02x\n"
                "max out      %02x\n"
                "max in       %02x\n"
                "max out inc  %02x\n"
                "max retry    %02x\n"
                "remote SAP   %02x\n"
                "max I field  %04x\n"
                "access pri   %02x\n",
                READ_WORD(&parms->usSapStationId),
                READ_WORD(&parms->usLinkStationId),
                parms->uchT1,
                parms->uchT2,
                parms->uchTi,
                parms->uchMaxOut,
                parms->uchMaxIn,
                parms->uchMaxOutIncr,
                parms->uchMaxRetryCnt,
                parms->uchRemoteSap,
                READ_WORD(&parms->usMaxI_Field),
                parms->uchAccessPriority
                );
    if (IsDos) {
        DBGPRINT(
                "destination  %04x:%04x\n",
                GET_SEGMENT(&parms->pRemoteNodeAddress),
                GET_OFFSET(&parms->pRemoteNodeAddress)
                );
        dest = READ_FAR_POINTER(&parms->pRemoteNodeAddress);
    } else {
        DBGPRINT(
                "destination  %08x\n",
                parms->pRemoteNodeAddress
                );
        dest = parms->pRemoteNodeAddress;
    }
    if (dest) {
        DBGPRINT("DESTINATION ADDRESS: ");
        for (i=0; i<6; ++i) {
            DBGPRINT("%02x ", dest[i]);
        }
        DBGPRINT("\n");
    }
}

PRIVATE
VOID
DumpDlcReallocateParms(
    DUMP_TABLE_PARMS
    )
{
}

PRIVATE
VOID
DumpDlcResetParms(
    DUMP_TABLE_PARMS
    )
{
    DBGPRINT(   "STATION_ID   %04x\n"
                "reserved     %02x %02x\n",
            LOWORD(Parameters),
            LOBYTE(HIWORD(Parameters)),
            HIBYTE(HIWORD(Parameters))
            );
}

PRIVATE
VOID
DumpDlcStatisticsParms(
    DUMP_TABLE_PARMS
    )
{
}

PRIVATE
VOID
DumpPdtTraceOffParms(
    DUMP_TABLE_PARMS
    )
{
}

PRIVATE
VOID
DumpPdtTraceOnParms(
    DUMP_TABLE_PARMS
    )
{
}

PRIVATE
VOID
DumpReadParms(
    DUMP_TABLE_PARMS
    )
{
    PLLC_READ_PARMS parms = (PLLC_READ_PARMS)Parameters;

    DumpParameterTableHeader("READ", Parameters, IsDos, Segment, Offset);

    //
    // this parameter table not for DOS
    //

    DBGPRINT(   "station id   %04x\n"
                "option ind.  %02x\n"
                "event set    %02x\n"
                "event        %02x [%s]\n"
                "crit. subset %02x\n"
                "notify flag  %08x\n",
                parms->usStationId,
                parms->uchOptionIndicator,
                parms->uchEventSet,
                parms->uchEvent,
                MapReadEvent(parms->uchEvent),
                parms->uchCriticalSubset,
                parms->ulNotificationFlag
                );

    //
    // rest of table interpreted differently depending on whether status change
    //

    if (parms->uchEvent & 0x38) {
        DBGPRINT(
                "station id   %04x\n"
                "status code  %04x [%s]\n"
                "FRMR data    %02x %02x %02x %02x %02x\n"
                "access pri.  %02x\n"
                "remote addr  %02x-%02x-%02x-%02x-%02x-%02x\n"
                "remote SAP   %02x\n"
                "reserved     %02x\n"
                "user stat    %04x\n",
                parms->Type.Status.usStationId,
                parms->Type.Status.usDlcStatusCode,
                MapDlcStatus(parms->Type.Status.usDlcStatusCode),
                parms->Type.Status.uchFrmrData[0],
                parms->Type.Status.uchFrmrData[1],
                parms->Type.Status.uchFrmrData[2],
                parms->Type.Status.uchFrmrData[3],
                parms->Type.Status.uchFrmrData[4],
                parms->Type.Status.uchAccessPritority,
                parms->Type.Status.uchRemoteNodeAddress[0],
                parms->Type.Status.uchRemoteNodeAddress[1],
                parms->Type.Status.uchRemoteNodeAddress[2],
                parms->Type.Status.uchRemoteNodeAddress[3],
                parms->Type.Status.uchRemoteNodeAddress[4],
                parms->Type.Status.uchRemoteNodeAddress[5],
                parms->Type.Status.uchRemoteSap,
                parms->Type.Status.uchReserved,
                parms->Type.Status.usUserStatusValue
                );
    } else {
        DBGPRINT(
                "CCB count    %04x\n"
                "CCB list     %08x\n"
                "buffer count %04x\n"
                "buffer list  %08x\n"
                "frame count  %04x\n"
                "frame list   %08x\n"
                "error code   %04x\n"
                "error data   %04x %04x %04x\n",
                parms->Type.Event.usCcbCount,
                parms->Type.Event.pCcbCompletionList,
                parms->Type.Event.usBufferCount,
                parms->Type.Event.pFirstBuffer,
                parms->Type.Event.usReceivedFrameCount,
                parms->Type.Event.pReceivedFrame,
                parms->Type.Event.usEventErrorCode,
                parms->Type.Event.usEventErrorData[0],
                parms->Type.Event.usEventErrorData[1],
                parms->Type.Event.usEventErrorData[2]
                );

        //
        // address of CCB is in DOS memory
        //

        if (parms->Type.Event.usCcbCount) {
            DumpCcb(DOS_PTR_TO_FLAT(parms->Type.Event.pCcbCompletionList),
                    TRUE,   // DumpAll
                    FALSE,  // CcbIsInput
                    TRUE,   // IsDos
                    HIWORD(parms->Type.Event.pCcbCompletionList),
                    LOWORD(parms->Type.Event.pCcbCompletionList)
                    );
        }
        if (parms->Type.Event.usReceivedFrameCount) {
            DumpReceiveDataBuffer(parms->Type.Event.pReceivedFrame, FALSE, 0, 0);
        }
    }
}

PRIVATE LPSTR MapReadEvent(UCHAR Event) {
    switch (Event) {
    case 0x80:
        return "Reserved Event!";

    case 0x40:
        return "System Action (non-critical)";

    case 0x20:
        return "Network Status (non-critical)";

    case 0x10:
        return "Critical Exception";

    case 0x8:
        return "DLC Status Change";

    case 0x4:
        return "Receive Data";

    case 0x2:
        return "Transmit Completion";

    case 0x1:
        return "Command Completion";
    }
    return "Unknown Read Event";
}

PRIVATE LPSTR MapDlcStatus(WORD Status) {
    if (Status & 0x8000) {
        return "Link lost";
    } else if (Status & 0x4000) {
        return "DM/DISC Received -or- DISC ack'd";
    } else if (Status & 0x2000) {
        return "FRMR Received";
    } else if (Status & 0x1000) {
        return "FRMR Sent";
    } else if (Status & 0x0800) {
        return "SABME Received for open link station";
    } else if (Status & 0x0400) {
        return "SABME Received - link station opened";
    } else if (Status & 0x0200) {
        return "REMOTE Busy Entered";
    } else if (Status & 0x0100) {
        return "REMOTE Busy Left";
    } else if (Status & 0x0080) {
        return "Ti EXPIRED";
    } else if (Status & 0x0040) {
        return "DLC counter overflow - issue DLC.STATISTICS";
    } else if (Status & 0x0020) {
        return "Access Priority lowered";
    } else if (Status & 0x001e) {
        return "*** ERROR - INVALID STATUS ***";
    } else if (Status & 0x0001) {
        return "Entered LOCAL Busy";
    } else {
        return "Unknown DLC Status";
    }
}

PRIVATE
VOID
DumpReadCancelParms(
    DUMP_TABLE_PARMS
    )
{
}

PRIVATE
VOID
DumpReceiveParms(
    DUMP_TABLE_PARMS
    )
{
    //
    // the format of the recieve parameter table is different depending on
    // whether this is a DOS command (CCB1) or NT (CCB2)
    //

    PLLC_RECEIVE_PARMS ntParms = (PLLC_RECEIVE_PARMS)Parameters;
    PLLC_DOS_RECEIVE_PARMS dosParms = (PLLC_DOS_RECEIVE_PARMS)Parameters;
    PLLC_DOS_RECEIVE_PARMS_EX dosExParms = (PLLC_DOS_RECEIVE_PARMS_EX)Parameters;
    PVOID Buffer;

    DumpParameterTableHeader("RECEIVE", Parameters, IsDos, Segment, Offset);

    //
    // some common bits: use any structure pointer
    //

    DBGPRINT(   "station id   %04x\n"
                "user length  %04x\n",
                READ_WORD(&ntParms->usStationId),
                READ_WORD(&ntParms->usUserLength)
                );

    //
    // dump segmented pointers for DOS, flat for NT
    //

    if (IsDos) {
        DBGPRINT(
                "receive exit %04x:%04x\n"
                "first buffer %04x:%04x\n",
                GET_SEGMENT(&dosParms->ulReceiveExit),
                GET_OFFSET(&dosParms->ulReceiveExit),
                GET_SEGMENT(&dosParms->pFirstBuffer),
                GET_OFFSET(&dosParms->pFirstBuffer)
                );
        Buffer = READ_FAR_POINTER(&dosParms->pFirstBuffer);

        //
        // use Segment & Offset to address received data buffer
        //

        Segment = GET_SEGMENT(&dosParms->pFirstBuffer);
        Offset = GET_OFFSET(&dosParms->pFirstBuffer);
    } else {
        DBGPRINT(
                "receive flag %08x\n"
                "first buffer %08x\n",
                ntParms->ulReceiveFlag,
                ntParms->pFirstBuffer
                );
        Buffer = ntParms->pFirstBuffer;
    }

    //
    // more common bits
    //

    DBGPRINT(   "options      %02x\n",
                ntParms->uchOptions
                );
    if (!IsDos) {
        DBGPRINT(
                "reserved1    %02x %02x %02x\n"
                "read options %02x\n"
                "reserved2    %02x %02x %02x\n"
                "original CCB %08x\n"
                "orig. exit   %08x\n",
                ntParms->auchReserved1[0],
                ntParms->auchReserved1[1],
                ntParms->auchReserved1[2],
                ntParms->uchRcvReadOption,
                ((PLLC_DOS_RECEIVE_PARMS_EX)ntParms)->auchReserved2[0],
                ((PLLC_DOS_RECEIVE_PARMS_EX)ntParms)->auchReserved2[1],
                ((PLLC_DOS_RECEIVE_PARMS_EX)ntParms)->auchReserved2[2],
                ((PLLC_DOS_RECEIVE_PARMS_EX)ntParms)->dpOriginalCcbAddress,
                ((PLLC_DOS_RECEIVE_PARMS_EX)ntParms)->dpCompletionFlag
                );
/*    } else {

        //
        // we have no way of knowing from the general purpose parameters if this
        // is the original DOS CCB1 RECEIVE parameter table, or the extended
        // RECEIVE parameter table that we create. Dump the extended bits for
        // DOS anyhow
        //

        DBGPRINT(
                "\nExtended RECEIVE parameters for table @%08x\n"
                "reserved1    %02x %02x %02x\n"
                "read options %02x\n"
                "reserved2    %02x %02x %02x\n"
                "original CCB %04x:%04x\n"
                "orig. exit   %04x:%04x\n",
                Parameters,
                dosExParms->auchReserved1[0],
                dosExParms->auchReserved1[1],
                dosExParms->auchReserved1[2],
                dosExParms->uchRcvReadOption,
                dosExParms->auchReserved2[0],
                dosExParms->auchReserved2[1],
                dosExParms->auchReserved2[2],
                GET_SEGMENT(&dosExParms->dpOriginalCcbAddress),
                GET_OFFSET(&dosExParms->dpOriginalCcbAddress),
                GET_SEGMENT(&dosExParms->dpCompletionFlag),
                GET_OFFSET(&dosExParms->dpCompletionFlag)
                );
*/
    }

    //
    // only dump the buffer(s) if this is an output CCB dump
    //

    if (Buffer && !IsInput) {
        DumpReceiveDataBuffer(Buffer, IsDos, Segment, Offset);
    }
}

PRIVATE
VOID
DumpReceiveCancelParms(
    DUMP_TABLE_PARMS
    )
{
    DBGPRINT("STATION_ID   %04x\n", LOWORD(Parameters));
}

PRIVATE
VOID
DumpReceiveModifyParms(
    DUMP_TABLE_PARMS
    )
{
    PLLC_DOS_RECEIVE_MODIFY_PARMS parms = (PLLC_DOS_RECEIVE_MODIFY_PARMS)Parameters;
    PVOID Buffer;

    DumpParameterTableHeader("RECEIVE.MODIFY", Parameters, IsDos, Segment, Offset);

    DBGPRINT(   "station id   %04x\n"
                "user length  %04x\n"
                "receive exit %04x:%04x\n"
                "first buffer %04x:%04x\n"
                "subroutine   %04x:%04x\n",
                READ_WORD(&parms->StationId),
                READ_WORD(&parms->UserLength),
                GET_SEGMENT(&parms->ReceivedDataExit),
                GET_OFFSET(&parms->ReceivedDataExit),
                GET_SEGMENT(&parms->FirstBuffer),
                GET_OFFSET(&parms->FirstBuffer),
                GET_SEGMENT(&parms->Subroutine),
                GET_OFFSET(&parms->Subroutine)
                );
    Buffer = READ_FAR_POINTER(&parms->FirstBuffer);
    if (Buffer) {
        DumpReceiveDataBuffer(Buffer, IsDos, Segment, Offset);
    }
}

PRIVATE
VOID
DumpTransmitDirFrameParms(
    DUMP_TABLE_PARMS
    )
{
    DumpParameterTableHeader("TRANSMIT.DIR.FRAME", Parameters, IsDos, Segment, Offset);
    DumpTransmitParms(Parameters, IsDos, IsInput, Segment, Offset);
}

PRIVATE
VOID
DumpTransmitIFrameParms(
    DUMP_TABLE_PARMS
    )
{
    DumpParameterTableHeader("TRANSMIT.I.FRAME", Parameters, IsDos, Segment, Offset);
    DumpTransmitParms(Parameters, IsDos, IsInput, Segment, Offset);
}

PRIVATE
VOID
DumpTransmitTestCmdParms(
    DUMP_TABLE_PARMS
    )
{
    DumpParameterTableHeader("TRANSMIT.TEST.CMD", Parameters, IsDos, Segment, Offset);
    DumpTransmitParms(Parameters, IsDos, IsInput, Segment, Offset);
}

PRIVATE
VOID
DumpTransmitUiFrameParms(
    DUMP_TABLE_PARMS
    )
{
    DumpParameterTableHeader("TRANSMIT.UI.FRAME", Parameters, IsDos, Segment, Offset);
    DumpTransmitParms(Parameters, IsDos, IsInput, Segment, Offset);
}

PRIVATE
VOID
DumpTransmitXidCmdParms(
    DUMP_TABLE_PARMS
    )
{
    DumpParameterTableHeader("TRANSMIT.XID.CMD", Parameters, IsDos, Segment, Offset);
    DumpTransmitParms(Parameters, IsDos, IsInput, Segment, Offset);
}

PRIVATE
VOID
DumpTransmitXidRespFinalParms(
    DUMP_TABLE_PARMS
    )
{
    DumpParameterTableHeader("TRANSMIT.XID.RESP.FINAL", Parameters, IsDos, Segment, Offset);
    DumpTransmitParms(Parameters, IsDos, IsInput, Segment, Offset);
}

PRIVATE
VOID
DumpTransmitXidRespNotFinalParms(
    DUMP_TABLE_PARMS
    )
{
    DumpParameterTableHeader("TRANSMIT.XID.RESP.NOT.FINAL", Parameters, IsDos, Segment, Offset);
    DumpTransmitParms(Parameters, IsDos, IsInput, Segment, Offset);
}

PRIVATE
VOID
DumpTransmitParms(
    DUMP_TABLE_PARMS
    )
{
    PLLC_TRANSMIT_PARMS ntParms = (PLLC_TRANSMIT_PARMS)Parameters;
    PLLC_DOS_TRANSMIT_PARMS dosParms = (PLLC_DOS_TRANSMIT_PARMS)Parameters;

    DBGPRINT(   "station id   %04x\n"
                "frame status %02x\n"
                "remote SAP   %02x\n",
                READ_WORD(&dosParms->usStationId),
                dosParms->uchTransmitFs,
                dosParms->uchRemoteSap
                );

    if (IsDos) {
        DBGPRINT(
                "xmit q1      %04x:%04x\n"
                "xmit q2      %04x:%04x\n"
                "buf. len. 1  %04x\n"
                "buf. len. 2  %04x\n"
                "buffer 1     %04x:%04x\n"
                "buffer 2     %04x:%04x\n",
                GET_SEGMENT(&dosParms->pXmitQueue1),
                GET_OFFSET(&dosParms->pXmitQueue1),
                GET_SEGMENT(&dosParms->pXmitQueue2),
                GET_OFFSET(&dosParms->pXmitQueue2),
                READ_WORD(&dosParms->cbBuffer1),
                READ_WORD(&dosParms->cbBuffer2),
                GET_SEGMENT(&dosParms->pBuffer1),
                GET_OFFSET(&dosParms->pBuffer1),
                GET_SEGMENT(&dosParms->pBuffer2),
                GET_OFFSET(&dosParms->pBuffer2)
                );
        IF_DEBUG(DLC_TX_DATA) {
            if (READ_DWORD(&dosParms->pXmitQueue1)) {
                DBGPRINT("\nXMIT_QUEUE_ONE:\n");
                DumpTransmitQueue(READ_DWORD(&dosParms->pXmitQueue1));
            }
            if (READ_DWORD(&dosParms->pXmitQueue2)) {
                DBGPRINT("\nXMIT_QUEUE_TWO:\n");
                DumpTransmitQueue(READ_DWORD(&dosParms->pXmitQueue2));
            }
            if (dosParms->cbBuffer1) {
                DBGPRINT("\nBUFFER1:\n");
                DumpData(NULL,
                        NULL,
                        dosParms->cbBuffer1,
                        DD_UPPER_CASE,
                        0,
                        TRUE,
                        GET_SEGMENT(&dosParms->pBuffer1),
                        GET_OFFSET(&dosParms->pBuffer1)
                        );
            }
            if (dosParms->cbBuffer2) {
                DBGPRINT("\nBUFFER2:\n");
                DumpData(NULL,
                        NULL,
                        dosParms->cbBuffer2,
                        DD_UPPER_CASE,
                        0,
                        TRUE,
                        GET_SEGMENT(&dosParms->pBuffer2),
                        GET_OFFSET(&dosParms->pBuffer2)
                        );
            }
        }
    } else {
        DBGPRINT(
                "xmit q1      %08x\n"
                "xmit q2      %08x\n"
                "buf. len. 1  %02x\n"
                "buf. len. 2  %02x\n"
                "buffer 1     %08x\n"
                "buffer 2     %08x\n"
                "xmt read opt %02x\n",
                ntParms->pXmitQueue1,
                ntParms->pXmitQueue2,
                ntParms->cbBuffer1,
                ntParms->cbBuffer2,
                ntParms->pBuffer1,
                ntParms->pBuffer2,
                ntParms->uchXmitReadOption
                );
    }
}

PRIVATE
VOID
DumpTransmitQueue(
    IN DOS_ADDRESS dpQueue
    )
{
    PLLC_XMIT_BUFFER pTxBuffer;
    WORD userLength;
    WORD dataLength;

    while (dpQueue) {
        pTxBuffer = (PLLC_XMIT_BUFFER)DOS_PTR_TO_FLAT(dpQueue);
        dataLength = READ_WORD(&pTxBuffer->cbBuffer);
        userLength = READ_WORD(&pTxBuffer->cbUserData);
        DBGPRINT(
                "\n"
                "Transmit Buffer @%04x:%04x\n"
                "next buffer  %04x:%04x\n"
                "reserved     %02x %02x\n"
                "data length  %04x\n"
                "user data    %04x\n"
                "user length  %04x\n",
                HIWORD(dpQueue),
                LOWORD(dpQueue),
                GET_SEGMENT(&pTxBuffer->pNext),
                GET_OFFSET(&pTxBuffer->pNext),
                ((LPBYTE)(&pTxBuffer->usReserved1))[0],
                ((LPBYTE)(&pTxBuffer->usReserved1))[1],
                dataLength,
                READ_WORD(&pTxBuffer->usReserved2),
                userLength
                );
        DumpData("user space",
                (PBYTE)(&pTxBuffer->auchData),
                userLength,
                DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL,
                DEFAULT_FIELD_WIDTH,
                FALSE,  // not displaying seg:off, so no need for these 3
                0,
                0
                );
        DumpData("xmit data",
                (PBYTE)(&pTxBuffer->auchData) + userLength,
                dataLength,
                DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL,
                DEFAULT_FIELD_WIDTH,
                FALSE,  // not displaying seg:off, so no need for these 3
                0,
                0
                );
        dpQueue = READ_DWORD(&pTxBuffer->pNext);
    }
}

VOID
DumpReceiveDataBuffer(
    IN PVOID Buffer,
    IN BOOL IsDos,
    IN WORD Segment,
    IN WORD Offset
    )
{
    if (IsDos) {

        PLLC_DOS_BUFFER pBuf = (PLLC_DOS_BUFFER)Buffer;
        BOOL contiguous = pBuf->Contiguous.uchOptions & 0xc0;
        WORD userLength = READ_WORD(&pBuf->Next.cbUserData);
        WORD dataLength = READ_WORD(&pBuf->Next.cbBuffer);
        WORD userOffset = READ_WORD(&pBuf->Next.offUserData);

        //
        // Buffer 1: [not] contiguous MAC/DATA
        //

        DBGPRINT(
                "\n"
                "%sContiguous MAC/DATA frame @%04x:%04x\n"
                "next buffer  %04x:%04x\n"
                "frame length %04x\n"
                "data length  %04x\n"
                "user offset  %04x\n"
                "user length  %04x\n"
                "station id   %04x\n"
                "options      %02x\n"
                "message type %02x [%s]\n"
                "buffers left %04x\n"
                "rcv FS       %02x\n"
                "adapter num  %02x\n",
                contiguous ? "" : "Not",
                Segment,
                Offset,
                GET_SEGMENT(&pBuf->Contiguous.pNextBuffer),
                GET_OFFSET(&pBuf->Contiguous.pNextBuffer),
                READ_WORD(&pBuf->Contiguous.cbFrame),
                READ_WORD(&pBuf->Contiguous.cbBuffer),
                READ_WORD(&pBuf->Contiguous.offUserData),
                READ_WORD(&pBuf->Contiguous.cbUserData),
                READ_WORD(&pBuf->Contiguous.usStationId),
                pBuf->Contiguous.uchOptions,
                pBuf->Contiguous.uchMsgType,
                MapMessageType(pBuf->Contiguous.uchMsgType),
                READ_WORD(&pBuf->Contiguous.cBuffersLeft),
                pBuf->Contiguous.uchRcvFS,
                pBuf->Contiguous.uchAdapterNumber
                );
        if (!contiguous) {

            DWORD cbLanHeader = (DWORD)pBuf->NotContiguous.cbLanHeader;
            DWORD cbDlcHeader = (DWORD)pBuf->NotContiguous.cbDlcHeader;

            DBGPRINT(
                "LAN hdr len  %02x\n"
                "DLC hdr len  %02x\n",
                cbLanHeader,
                cbDlcHeader
                );
            DumpData("LAN header",
                    NULL,
                    (DWORD)cbLanHeader,
                    DD_NO_ADDRESS | DD_NO_ASCII | DD_UPPER_CASE | DD_INDENT_ALL,
                    DEFAULT_FIELD_WIDTH,
                    TRUE,
                    Segment,
                    (WORD)(Offset + (WORD)&((PLLC_DOS_BUFFER)0)->NotContiguous.auchLanHeader)
                    );
            DumpData("DLC header",
                    NULL,
                    cbDlcHeader,
                    DD_NO_ADDRESS | DD_NO_ASCII | DD_UPPER_CASE | DD_INDENT_ALL,
                    DEFAULT_FIELD_WIDTH,
                    TRUE,
                    Segment,
                    (WORD)(Offset + (WORD)&((PLLC_DOS_BUFFER)0)->NotContiguous.auchDlcHeader)
                    );
            IF_DEBUG(DLC_RX_DATA) {
                if (userLength) {
                    DumpData("user space",
                            NULL,
                            userLength,
                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL,
                            DEFAULT_FIELD_WIDTH,
                            TRUE,
                            Segment,
                            //Offset + userOffset
                            userOffset
                            );
                } else {
                    DBGPRINT(
                        "user space\n"
                        );
                }
                if (dataLength) {
                    DumpData("rcvd data",
                            NULL,
                            dataLength,
                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL,
                            DEFAULT_FIELD_WIDTH,
                            TRUE,
                            Segment,
                            //Offset + userOffset + userLength
                            (WORD)(userOffset + userLength)
                            );
                } else {
                    DBGPRINT(
                        "rcvd data\n"
                        );
                }
            }
        } else {

            //
            // data length is size of frame in contiguous buffer?
            //

            dataLength = READ_WORD(&pBuf->Contiguous.cbBuffer);

            IF_DEBUG(DLC_RX_DATA) {
                if (userLength) {
                    DumpData("user space",
                            NULL,
                            userLength,
                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL,
                            DEFAULT_FIELD_WIDTH,
                            TRUE,
                            Segment,
                            //Offset + userOffset
                            userOffset
                            );
                } else {
                    DBGPRINT(
                        "user space\n"
                        );
                }
                if (dataLength) {
                    DumpData("rcvd data",
                            NULL,
                            dataLength,
                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL,
                            DEFAULT_FIELD_WIDTH,
                            TRUE,
                            Segment,
                            //Offset + userOffset + userLength
                            (WORD)(userOffset + userLength)
                            );
                } else {
                    DBGPRINT(
                        "rcvd data\n"
                        );
                }
            }
        }

        //
        // dump second & subsequent buffers
        //

        Segment = GET_SEGMENT(&pBuf->pNext);
        Offset = GET_OFFSET(&pBuf->pNext);

        for (
                pBuf = (PLLC_DOS_BUFFER)READ_FAR_POINTER(&pBuf->pNext);
                pBuf;
                pBuf = (PLLC_DOS_BUFFER)READ_FAR_POINTER(&pBuf->pNext)
                ) {

            userLength = READ_WORD(&pBuf->Next.cbUserData);
            dataLength = READ_WORD(&pBuf->Next.cbBuffer);

            DBGPRINT(
                    "\n"
                    "Buffer 2/Subsequent @%04x:%04x\n"
                    "next buffer  %04x:%04x\n"
                    "frame length %04x\n"
                    "data length  %04x\n"
                    "user offset  %04x\n"
                    "user length  %04x\n",
                    Segment,
                    Offset,
                    GET_SEGMENT(&pBuf->pNext),
                    GET_OFFSET(&pBuf->pNext),
                    READ_WORD(&pBuf->Next.cbFrame),
                    dataLength,
                    READ_WORD(&pBuf->Next.offUserData),
                    userLength
                    );
            IF_DEBUG(DLC_RX_DATA) {
                if (userLength) {
                    DumpData("user space",
                            NULL,
                            userLength,
                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL,
                            DEFAULT_FIELD_WIDTH,
                            TRUE,
                            Segment,
                            //Offset + READ_WORD(&pBuf->Next.offUserData)
                            READ_WORD(&pBuf->Next.offUserData)
                            );
                } else {
                    DBGPRINT(
                            "user space\n"
                            );
                }

                //
                // there must be received data
                //

                DumpData("rcvd data",
                        NULL,
                        dataLength,
                        DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL,
                        DEFAULT_FIELD_WIDTH,
                        TRUE,
                        Segment,
                        //Offset + READ_WORD(&pBuf->Next.offUserData) + userLength
                        (WORD)(READ_WORD(&pBuf->Next.offUserData) + userLength)
                        );
            }
            Segment = GET_SEGMENT(&pBuf->pNext);
            Offset = GET_OFFSET(&pBuf->pNext);
        }
    } else {

        PLLC_BUFFER pBuf = (PLLC_BUFFER)Buffer;
        BOOL contiguous = pBuf->Contiguous.uchOptions & 0xc0;
        WORD userLength = pBuf->Next.cbUserData;
        WORD dataLength = pBuf->Next.cbBuffer;
        WORD userOffset = pBuf->Next.offUserData;

        //
        // Buffer 1: [not] contiguous MAC/DATA
        //

        DBGPRINT(
                "\n"
                "%sContiguous MAC/DATA frame @%08x\n"
                "next buffer  %08x\n"
                "frame length %04x\n"
                "data length  %04x\n"
                "user offset  %04x\n"
                "user length  %04x\n"
                "station id   %04x\n"
                "options      %02x\n"
                "message type %02x [%s]\n"
                "buffers left %04x\n"
                "rcv FS       %02x\n"
                "adapter num  %02x\n",
                contiguous ? "" : "Not",
                pBuf,
                pBuf->Contiguous.pNextBuffer,
                pBuf->Contiguous.cbFrame,
                pBuf->Contiguous.cbBuffer,
                pBuf->Contiguous.offUserData,
                pBuf->Contiguous.cbUserData,
                pBuf->Contiguous.usStationId,
                pBuf->Contiguous.uchOptions,
                pBuf->Contiguous.uchMsgType,
                MapMessageType(pBuf->Contiguous.uchMsgType),
                pBuf->Contiguous.cBuffersLeft,
                pBuf->Contiguous.uchRcvFS,
                pBuf->Contiguous.uchAdapterNumber
                );
        if (!contiguous) {
            DWORD cbLanHeader = (DWORD)pBuf->NotContiguous.cbLanHeader;
            DWORD cbDlcHeader = (DWORD)pBuf->NotContiguous.cbDlcHeader;

            DBGPRINT(
                "next frame   %08x\n"
                "LAN hdr len  %02x\n"
                "DLC hdr len  %02x\n",
                pBuf->NotContiguous.pNextFrame,
                cbLanHeader,
                cbDlcHeader
                );
            DumpData("LAN header",
                    pBuf->NotContiguous.auchLanHeader,
                    cbLanHeader,
                    DD_NO_ADDRESS | DD_NO_ASCII | DD_UPPER_CASE | DD_INDENT_ALL,
                    DEFAULT_FIELD_WIDTH,
                    FALSE,
                    0,
                    0
                    );
            DumpData("DLC header",
                    pBuf->NotContiguous.auchDlcHeader,
                    cbDlcHeader,
                    DD_NO_ADDRESS | DD_NO_ASCII | DD_UPPER_CASE | DD_INDENT_ALL,
                    DEFAULT_FIELD_WIDTH,
                    FALSE,
                    0,
                    0
                    );
            IF_DEBUG(DLC_RX_DATA) {
                if (userLength) {
                    DumpData("user space   ",
                            (PBYTE)pBuf + userOffset,
                            userLength,
                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL,
                            DEFAULT_FIELD_WIDTH,
                            FALSE,
                            0,
                            0
                            );
                } else {
                    DBGPRINT(
                        "user space\n"
                        );
                }
                if (dataLength) {
                    DumpData("rcvd data",
                            (PBYTE)pBuf + userOffset + userLength,
                            dataLength,
                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL,
                            DEFAULT_FIELD_WIDTH,
                            FALSE,
                            0,
                            0
                            );
                } else {
                    DBGPRINT(
                        "rcvd data\n"
                        );
                }
            }
        } else {

            //
            // data length is size of frame in contiguous buffer?
            //

            dataLength = pBuf->Contiguous.cbFrame;

            DBGPRINT(
                "next frame   %08x\n",
                pBuf->NotContiguous.pNextFrame
                );
            IF_DEBUG(DLC_RX_DATA) {
                if (userLength) {
                    DumpData("user space",
                            (PBYTE)pBuf + userOffset,
                            userLength,
                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL,
                            DEFAULT_FIELD_WIDTH,
                            FALSE,
                            0,
                            0
                            );
                } else {
                    DBGPRINT(
                        "user space\n"
                        );
                }
                if (dataLength) {
                    DumpData("rcvd data",
                            (PBYTE)pBuf + userOffset + userLength,
                            dataLength,
                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL,
                            DEFAULT_FIELD_WIDTH,
                            FALSE,
                            0,
                            0
                            );
                } else {
                    DBGPRINT(
                        "rcvd data\n"
                        );
                }
            }
        }

        //
        // dump second & subsequent buffers
        //

        for (pBuf = pBuf->pNext; pBuf; pBuf = pBuf->pNext) {
            userLength = pBuf->Next.cbUserData;
            dataLength = pBuf->Next.cbBuffer;
            DBGPRINT(
                    "\n"
                    "Buffer 2/Subsequent @%08x\n"
                    "next buffer  %08x\n"
                    "frame length %04x\n"
                    "data length  %04x\n"
                    "user offset  %04x\n"
                    "user length  %04x\n",
                    pBuf,
                    pBuf->pNext,
                    pBuf->Next.cbFrame,
                    dataLength,
                    pBuf->Next.offUserData,
                    userLength
                    );
            IF_DEBUG(DLC_RX_DATA) {
                if (userLength) {
                    DumpData("user space",
                            (PBYTE)&pBuf + pBuf->Next.offUserData,
                            userLength,
                            DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL,
                            DEFAULT_FIELD_WIDTH,
                            FALSE,
                            0,
                            0
                            );
                } else {
                    DBGPRINT(
                            "user space\n"
                            );
                }

                //
                // there must be received data
                //

                DumpData("rcvd data",
                        (PBYTE)pBuf + pBuf->Next.offUserData + userLength,
                        dataLength,
                        DD_NO_ADDRESS | DD_UPPER_CASE | DD_INDENT_ALL,
                        DEFAULT_FIELD_WIDTH,
                        FALSE,
                        0,
                        0
                        );
            }
        }
    }
}

PRIVATE LPSTR MapMessageType(UCHAR MessageType) {
    switch (MessageType) {
    case 0x02:
        return "MAC Frame (Direct Station on Token Ring only)";

    case 0x04:
        return "I-Frame";

    case 0x06:
        return "UI-Frame";

    case 0x08:
        return "XID Command (POLL)";

    case 0x0a:
        return "XID Command (not POLL)";

    case 0x0c:
        return "XID Response (FINAL)";

    case 0x0e:
        return "XID Response (not FINAL)";

    case 0x10:
        return "TEST Response (FINAL)";

    case 0x12:
        return "TEST Response (not FINAL)";

    case 0x14:
        return "OTHER - non-MAC frame (Direct Station only)";

    default:
        return "*** BAD FRAME TYPE ***";
    }
}

VOID
DumpData(
    IN LPSTR Title,
    IN PBYTE Address,
    IN DWORD Length,
    IN DWORD Options,
    IN DWORD Indent,
    IN BOOL IsDos,
    IN WORD Segment,
    IN WORD Offset
    )
{
    char dumpBuf[128];
    char* bufptr;
    int i, n, iterations;
    char* hexptr;

    if (IsDos) {
        Address = LPBYTE_FROM_WORDS(Segment, Offset);
    }

    //
    // the usual dump style: 16 columns of hex bytes, followed by 16 columns
    // of corresponding ASCII characters, or '.' where the character is < 0x20
    // (space) or > 0x7f (del?)
    //

    if (Options & DD_LINE_BEFORE) {
        DbgOutStr("\n");
    }
    iterations = 0;
    while (Length) {
        bufptr = dumpBuf;
        if (Title && !iterations) {
            strcpy(bufptr, Title);
            bufptr = strchr(bufptr, 0);
        }
        if (Indent && ((Options & DD_INDENT_ALL) || iterations)) {

            int indentLen = (!iterations && Title)
                                ? ((int)Indent - (int)strlen(Title) < 0)
                                    ? 1
                                    : Indent - strlen(Title)
                                : Indent;

            RtlFillMemory(bufptr, indentLen, ' ');
            bufptr += indentLen;
        }
        if (!(Options & DD_NO_ADDRESS)) {
            if (IsDos) {
                bufptr += sprintf(bufptr, "%04x:%04x  ", Segment, Offset);
            } else {
                bufptr += sprintf(bufptr, "%08x: ", Address);
            }
        }
        n = (Length < 16) ? Length : 16;
        hexptr = bufptr;
        for (i = 0; i < n; ++i) {
            bufptr += sprintf(bufptr, "%02x", Address[i]);
            *bufptr++ = (i == 7) ? '-' : ' ';
        }
        if (Options & DD_UPPER_CASE) {
            _strupr(hexptr);
        }
        if (!(Options & DD_NO_ASCII)) {
            if (n < 16) {
                for (i = 0; i < 16-n; ++i) {
                    bufptr += sprintf(bufptr, "   ");
                }
            }
            bufptr += sprintf(bufptr, "  ");
            for (i = 0; i < n; ++i) {
                *bufptr++ = (Address[i] < 0x20 || Address[i] > 0x7f) ? '.' : Address[i];
            }
        }
        *bufptr++ = '\n';
        *bufptr = 0;
        DbgOutStr(dumpBuf);
        Length -= n;
        Address += n;
        ++iterations;

        //
        // take care of segment wrap for DOS addresses
        //

        if (IsDos) {

            DWORD x = (DWORD)Offset + n;

            Offset = (WORD)x;
            if (HIWORD(x)) {
                Segment += 0x1000;
            }
        }
    }
    if (Options & DD_LINE_AFTER) {
        DbgOutStr("\n");
    }
}

//
// CCB1 error checking
//

#define BITS_PER_BYTE       8
#define CCB1_ERROR_SPREAD   ((MAX_CCB1_ERROR + BITS_PER_BYTE) & ~(BITS_PER_BYTE-1))

//
// Ccb1ErrorTable - for each command described in IBM Lan Tech. Ref. (including
// those not applicable to CCB1), we keep a list of the permissable error codes
// which are taken from the "Return Codes for CCB1 Commands" table on pp B-5
// and B-6
// The error list is an 80-bit bitmap in which an ON bit indicates that the
// error number corresponding to the bit's position is allowable for the CCB1
// command corresponding to the list's index in the table
//

typedef struct {
    BOOL    ValidForCcb1;
    BYTE    ErrorList[CCB1_ERROR_SPREAD/BITS_PER_BYTE];
    char*   CommandName;
} CCB1_ERROR_TABLE;

#define MAX_INCLUSIVE_CCB1_COMMAND  LLC_MAX_DLC_COMMAND

CCB1_ERROR_TABLE Ccb1ErrorTable[MAX_INCLUSIVE_CCB1_COMMAND + 1] = {

// DIR.INTERRUPT (0x00)
    {
        TRUE,
        {0x83, 0x02, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "DIR.INTERRUPT"
    },

// DIR.MODIFY.OPEN.PARMS (0x01)
    {
        TRUE,
        {0x97, 0x02, 0x40, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "DIR.MODIFY.OPEN.PARMS"
    },

// DIR.RESTORE.OPEN.PARMS (0x02)
    {
        TRUE,
        {0xd3, 0x02, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "DIR.RESTORE.OPEN.PARMS"
    },

// DIR.OPEN.ADAPTER (0x03)
    {
        TRUE,
        {0xaf, 0x02, 0x45, 0x79, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00},
        "DIR.OPEN.ADAPTER"
    },

// DIR.CLOSE.ADAPTER (0x04)
    {
        TRUE,
        {0xb3, 0x02, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "DIR.CLOSE.ADAPTER"
    },

// non-existent command (0x05)
    {
        FALSE,
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "NON-EXISTENT COMMAND (0x05)"
    },

// DIR.SET.GROUP.ADDRESS (0x06)
    {
        TRUE,
        {0x93, 0x0a, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "DIR.SET.GROUP.ADDRESS"
    },

// DIR.SET.FUNCTIONAL.ADDRESS (0x07)
    {
        TRUE,
        {0x93, 0x0a, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "DIR.SET.FUNCTIONAL.ADDRESS"
    },

// DIR.READ.LOG (0x08)
    {
        TRUE,
        {0x93, 0x0a, 0x28, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "DIR.READ.LOG"
    },

// non-existent command (0x09)
    {
        FALSE,
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "NON-EXISTENT COMMAND (0x09)"
    },

// TRANSMIT.DIR.FRAME (0x0a)
    {
        TRUE,
        {0x93, 0x0f, 0x00, 0x28, 0xbc, 0x01, 0x00, 0x00, 0x13, 0x04},
        "TRANSMIT.DIR.FRAME"
    },

// TRANSMIT.I.FRAME (0x0b)
    {
        TRUE,
        {0x93, 0x0f, 0x00, 0x28, 0xbc, 0x01, 0x00, 0x00, 0x13, 0x04},
        "TRANSMIT.I.FRAME"
    },

// non-existent command (0x0c)
    {
        FALSE,
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "NON-EXISTENT COMMAND (0x0c)"
    },

// TRANSMIT.UI.FRAME (0x0d)
    {
        TRUE,
        {0x93, 0x0f, 0x00, 0x28, 0xbc, 0x01, 0x00, 0x00, 0x13, 0x04},
        "TRANSMIT.UI.FRAME"
    },

// TRANSMIT.XID.CMD (0x0e)
    {
        TRUE,
        {0x93, 0x0f, 0x00, 0x28, 0xbc, 0x01, 0x00, 0x00, 0x13, 0x04},
        "TRANSMIT.XID.CMD"
    },

// TRANSMIT.XID.RESP.FINAL (0x0f)
    {
        TRUE,
        {0x93, 0x0f, 0x00, 0x28, 0xbc, 0x01, 0x00, 0x00, 0x13, 0x04},
        "TRANSMIT.XID.RESP.FINAL"
    },

// TRANSMIT.XID.RESP.NOT.FINAL (0x10)
    {
        TRUE,
        {0x93, 0x0f, 0x00, 0x28, 0xbc, 0x01, 0x00, 0x00, 0x13, 0x04},
        "TRANSMIT.XID.RESP.NOT.FINAL"
    },

// TRANSMIT.TEST.CMD (0x11)
    {
        TRUE,
        {0x93, 0x0f, 0x00, 0x28, 0xbc, 0x01, 0x00, 0x00, 0x13, 0x04},
        "TRANSMIT.TEST.CMD"
    },

// non-existent command (0x12)
    {
        FALSE,
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "NON-EXISTENT COMMAND (0x12)"
    },

// non-existent command (0x13)
    {
        FALSE,
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "NON-EXISTENT COMMAND (0x13)"
    },

// DLC.RESET (0x14)
    {
        TRUE,
        {0x93, 0x0a, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00},
        "DLC.RESET"
    },

// DLC.OPEN.SAP (0x15)
    {
        TRUE,
        {0xd3, 0x0b, 0x40, 0x39, 0x00, 0x00, 0x00, 0x00, 0x6c, 0x02},
        "DLC.OPEN.SAP"
    },

// DLC.CLOSE.SAP (0x16)
    {
        TRUE,
        {0x93, 0x0a, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x81, 0x11},
        "DLC.CLOSE.SAP"
    },

// DLC.REALLOCATE (0x17)
    {
        TRUE,
        {0x93, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00},
        "DLC.REALLOCATE"
    },

// non-existent command (0x18)
    {
        FALSE,
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "NON-EXISTENT COMMAND (0x18)"
    },

// DLC.OPEN.STATION (0x19)
    {
        TRUE,
        {0xb3, 0x0b, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x4d, 0x80},
        "DLC.OPEN.STATION"
    },

// DLC.CLOSE.STATION (0x1a)
    {
        TRUE,
        {0x93, 0x0a, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x81, 0x18},
        "DLC.CLOSE.STATION"
    },

// DLC.CONNECT.STATION (0x1b)
    {
        TRUE,
        {0x97, 0x0a, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x13, 0x24},
        "DLC.CONNECT.STATION"
    },

// DLC.MODIFY (0x1c)
    {
        TRUE,
        {0x93, 0x0b, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x25, 0x42},
        "DLC.MODIFY"
    },

// DLC.FLOW.CONTROL (0x1d)
    {
        TRUE,
        {0x93, 0x0a, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00},
        "DLC.FLOW.CONTROL"
    },

// DLC.STATISTICS (0x1e)
    {
        TRUE,
        {0x93, 0x0a, 0x20, 0x28, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00},
        "DLC.STATISTICS"
    },

// non-existent command (0x1f)
    {
        FALSE,
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "NON-EXISTENT COMMAND (0x1f)"
    },

// DIR.INITIALIZE (0x20)
    {
        TRUE,
        {0x87, 0x00, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "DIR.INITIALIZE"
    },

// DIR.STATUS (0x21)
    {
        TRUE,
        {0x03, 0x12, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "DIR.STATUS"
    },

// DIR.TIMER.SET (0x22)
    {
        TRUE,
        {0x83, 0x0e, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "DIR.TIMER.SET"
    },

// DIR.TIMER.CANCEL (0x23)
    {
        TRUE,
        {0x03, 0x02, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "DIR.TIMER.CANCEL"
    },

// PDT.TRACE.ON (0x24)
    {
        TRUE,
        {0x45, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "PDT.TRACE.ON"
    },

// PDT.TRACE.OFF (0x25)
    {
        TRUE,
        {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "PDT.TRACE.OFF"
    },

// BUFFER.GET (0x26)
    {
        TRUE,
        {0x13, 0x02, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00},
        "BUFFER.GET"
    },

// BUFFER.FREE (0x27)
    {
        TRUE,
        {0x13, 0x02, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00},
        "BUFFER.FREE"
    },

// RECEIVE (0x28)
    {
        TRUE,
        {0x97, 0x0e, 0x00, 0x3c, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00},
        "RECEIVE"
    },

// RECEIVE.CANCEL (0x29)
    {
        TRUE,
        {0x13, 0x02, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00},
        "RECEIVE.CANCEL"
    },

// RECEIVE.MODIFY (0x2a)
    {
        TRUE,
        {0x97, 0x0e, 0x00, 0x3c, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00},
        "RECEIVE.MODIFY"
    },

// DIR.DEFINE.MIF.ENVIRONMENT (0x2b)
    {
        TRUE,
        {0x03, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "DIR.DEFINE.MIF.ENVIRONMENT"
    },

// DIR.TIMER.CANCEL.GROUP (0x2c)
    {
        TRUE,
        {0x03, 0x02, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "DIR.TIMER.CANCEL.GROUP"
    },

// DIR.SET.USER.APPENDAGE (0x2d)
    {
        TRUE,
        {0x93, 0x02, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "DIR.SET.USER.APPENDAGE"
    },

// non-existent command (0x2e)
    {
        FALSE,
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "NON-EXISTENT COMMAND (0x2e)"
    },

// non-existent command (0x2f)
    {
        FALSE,
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "NON-EXISTENT COMMAND (0x2f)"
    },

// non-existent command (0x30)
    {
        FALSE,
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "NON-EXISTENT COMMAND (0x30)"
    },

// READ (0x31)
    {
        FALSE,
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "READ"
    },

// READ.CANCEL (0x32)
    {
        FALSE,
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "READ.CANCEL"
    },

// DLC.SET.THRESHOLD (0x33)
    {
        FALSE,
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "DLC.SET.THRESHOLD"
    },

// DIR.CLOSE.DIRECT (0x34)
    {
        FALSE,
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "DIR.CLOSE.DIRECT"
    },

// DIR.OPEN.DIRECT (0x35)
    {
        FALSE,
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "DIR.OPEN.DIRECT"
    },

// PURGE.RESOURCES (0x36)
    {
        FALSE,
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "PURGE.RESOURCES"
    },

// LLC_MAX_DLC_COMMAND (0x37) ?
    {
        FALSE,
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        "NON-EXISTENT-COMMAND (0x37)"
    }
};

BOOL
IsCcbErrorCodeAllowable(
    IN BYTE CcbCommand,
    IN BYTE CcbErrorCode
    )

/*++

Routine Description:

    Check whether an error code is allowable for a particular CCB(1) command
    code. Perform range check on the error code before using as index into
    allowable error table

Arguments:

    CcbCommand      - Command code
    CcbErrorCode    - Return code

Return Value:

    BOOL
        TRUE    - CcbErrorCode is valid for CcbCommand
        FALSE   - CcbErrorCode should not be returned for CcbCommand
                  OR CcbErrorCode is invalid (out of range)
--*/

{
    if (CcbErrorCode == CCB_COMMAND_IN_PROGRESS) {
        return TRUE;
    }
    if (CcbErrorCode > MAX_CCB1_ERROR)
        return FALSE;
    return Ccb1ErrorTable[CcbCommand].ErrorList[CcbErrorCode/8] & (1 << (CcbErrorCode % 8));
}

BOOL
IsCcbErrorCodeValid(
    IN BYTE CcbErrorCode
    )

/*++

Routine Description:

    Check if a return code from a CCB(1) is an allowable return code,
    irrespective of command type

Arguments:

    CcbErrorCode    - return code to check

Return Value:

    BOOL
        TRUE    - CcbErrorCode is in range
        FALSE   - CcbErrorCode is not in range

--*/

{
    return (CcbErrorCode == CCB_COMMAND_IN_PROGRESS)    // 0xff

        // 0x00 - 0x0c
        || ((CcbErrorCode >= CCB_SUCCESS) && (CcbErrorCode <= CCB_SUCCESS_ADAPTER_NOT_OPEN))

        // 0x10 - 0x1e
        || ((CcbErrorCode >= CCB_NETBIOS_FAILURE) && (CcbErrorCode <= CCB_INVALID_FUNCTION_ADDRESS))

        // 0x20 - 0x28
        || ((CcbErrorCode >= CCB_DATA_LOST_NO_BUFFERS) && (CcbErrorCode <= CCB_INVALID_FRAME_LENGTH))

        // 0x30
        || (CcbErrorCode == CCB_NOT_ENOUGH_BUFFERS_OPEN)

        // 0x32 - 0x34
        || ((CcbErrorCode >= CCB_INVALID_NODE_ADDRESS) && (CcbErrorCode <= CCB_INVALID_TRANSMIT_LENGTH))

        // 0x40 - 0x4f
        || ((CcbErrorCode >= CCB_INVALID_STATION_ID) && (CcbErrorCode <= CCB_INVALID_REMOTE_ADDRESS))
        ;
}

BOOL
IsCcbCommandValid(
    IN BYTE CcbCommand
    )

/*++

Routine Description:

    Check if CCB command code is one of the allowable codes for a DOS CCB
    (CCB1)

Arguments:

    CcbCommand  - command code to check

Return Value:

    BOOL
        TRUE    - CcbCommand is recognized
        FALSE   - CcbCommand is not recognized

--*/

{
    return ((CcbCommand >= LLC_DIR_INTERRUPT) && (CcbCommand <= LLC_DIR_CLOSE_ADAPTER))
        || ((CcbCommand >= LLC_DIR_SET_GROUP_ADDRESS) && (CcbCommand <= LLC_DIR_SET_FUNCTIONAL_ADDRESS))
        || ((CcbCommand >= LLC_TRANSMIT_DIR_FRAME) && (CcbCommand <= LLC_TRANSMIT_I_FRAME))
        || ((CcbCommand >= LLC_TRANSMIT_UI_FRAME) && (CcbCommand <= LLC_TRANSMIT_TEST_CMD))
        || ((CcbCommand >= LLC_DLC_RESET) && (CcbCommand <= LLC_DLC_REALLOCATE_STATIONS))
        || ((CcbCommand >= LLC_DLC_OPEN_STATION) && (CcbCommand <= LLC_DLC_STATISTICS))
        || ((CcbCommand >= LLC_DIR_INITIALIZE) && (CcbCommand <= LLC_DIR_SET_USER_APPENDAGE))
        ;
}

LPSTR
MapCcbCommandToName(
    IN BYTE CcbCommand
    )

/*++

Routine Description:

    Return the name of a CCB command, given its value

Arguments:

    CcbCommand  - command code to map

Return Value:

    char* pointer to ASCIZ name of command (in IBM format X.Y.Z)

--*/

{
    return Ccb1ErrorTable[CcbCommand].CommandName;
}

VOID
DumpDosAdapter(
    IN DOS_ADAPTER* pDosAdapter
    )
{
    DBGPRINT(   "DOS_ADAPTER @ %08x\n"
                "AdapterType. . . . . . . . . %s\n"
                "IsOpen . . . . . . . . . . . %d\n"
                "DirectStationOpen. . . . . . %d\n"
                "DirectReceive. . . . . . . . %d\n"
                "WaitingRestore . . . . . . . %d\n"
                "BufferFree . . . . . . . . . %d\n"
                "BufferPool . . . . . . . . . %08x\n"
                "CurrentExceptionHandlers . . %08x %08x %08x\n"
                "PreviousExceptionHandlers. . %08x %08x %08x\n"
                "DlcStatusChangeAppendage . . \n"
                "LastNetworkStatusChange. . . %04x\n"
                "UserStatusValue. . . . . . . \n"
                "AdapterParms:\n"
                "   OpenErrorCode . . . . . . %04x\n"
                "   OpenOptions . . . . . . . %04x\n"
                "   NodeAddress . . . . . . . %02x-%02x-%02x-%02x-%02x-%02x\n"
                "   GroupAddress. . . . . . . %08x\n"
                "   FunctionalAddress . . . . %08x\n"
                "   NumberReceiveBuffers. . . %04x\n"
                "   ReceiveBufferLength . . . %04x\n"
                "   DataHoldBufferLength. . . %04x\n"
                "   NumberDataHoldBuffers . . %02x\n"
                "   Reserved. . . . . . . . . %02x\n"
                "   OpenLock. . . . . . . . . %04x\n"
                "   ProductId . . . . . . . . %08x\n"
                "DlcSpecified . . . . . . . . %d\n"
                "DlcParms:\n"
                "   MaxSaps . . . . . . . . . %02x\n"
                "   MaxStations . . . . . . . %02x\n"
                "   MaxGroupSaps. . . . . . . %02x\n"
                "   MaxGroupMembers . . . . . %02x\n"
                "   T1Tick1 . . . . . . . . . %02x\n"
                "   T2Tick1 . . . . . . . . . %02x\n"
                "   TiTick1 . . . . . . . . . %02x\n"
                "   T1Tick2 . . . . . . . . . %02x\n"
                "   T2Tick2 . . . . . . . . . %02x\n"
                "   TiTick2 . . . . . . . . . %02x\n"
                "AdapterCloseCcb. . . . . . . \n"
                "DirectCloseCcb . . . . . . . \n"
                "ReadCcb. . . . . . . . . . . \n"
                "EventQueueCritSec. . . . . . \n"
                "EventQueueHead . . . . . . . \n"
                "EventQueueTail . . . . . . . \n"
                "QueueElements. . . . . . . . \n"
                "LocalBusyCritSec . . . . . . \n"
                "DeferredReceives . . . . . . \n"
                "FirstIndex . . . . . . . . . \n"
                "LastIndex. . . . . . . . . . \n"
                "LocalBusyInfo. . . . . . . . \n",
                MapAdapterType(pDosAdapter->AdapterType),
                pDosAdapter->IsOpen,
                pDosAdapter->DirectStationOpen,
                pDosAdapter->DirectReceive,
                pDosAdapter->WaitingRestore,
                pDosAdapter->BufferFree,
                pDosAdapter->BufferPool,
                pDosAdapter->CurrentExceptionHandlers[0],
                pDosAdapter->CurrentExceptionHandlers[1],
                pDosAdapter->CurrentExceptionHandlers[2],
                pDosAdapter->PreviousExceptionHandlers[0],
                pDosAdapter->PreviousExceptionHandlers[1],
                pDosAdapter->PreviousExceptionHandlers[2],
                pDosAdapter->LastNetworkStatusChange,
                pDosAdapter->AdapterParms.OpenErrorCode,
                pDosAdapter->AdapterParms.OpenOptions,
                pDosAdapter->AdapterParms.NodeAddress[0],
                pDosAdapter->AdapterParms.NodeAddress[1],
                pDosAdapter->AdapterParms.NodeAddress[2],
                pDosAdapter->AdapterParms.NodeAddress[3],
                pDosAdapter->AdapterParms.NodeAddress[4],
                pDosAdapter->AdapterParms.NodeAddress[5],
                pDosAdapter->AdapterParms.GroupAddress,
                pDosAdapter->AdapterParms.FunctionalAddress,
                pDosAdapter->AdapterParms.NumberReceiveBuffers,
                pDosAdapter->AdapterParms.ReceiveBufferLength,
                pDosAdapter->AdapterParms.DataHoldBufferLength,
                pDosAdapter->AdapterParms.NumberDataHoldBuffers,
                pDosAdapter->AdapterParms.Reserved,
                pDosAdapter->AdapterParms.OpenLock,
                pDosAdapter->AdapterParms.ProductId,
                pDosAdapter->DlcSpecified,
                pDosAdapter->DlcParms.MaxSaps,
                pDosAdapter->DlcParms.MaxStations,
                pDosAdapter->DlcParms.MaxGroupSaps,
                pDosAdapter->DlcParms.MaxGroupMembers,
                pDosAdapter->DlcParms.T1Tick1,
                pDosAdapter->DlcParms.T2Tick1,
                pDosAdapter->DlcParms.TiTick1,
                pDosAdapter->DlcParms.T1Tick2,
                pDosAdapter->DlcParms.T2Tick2,
                pDosAdapter->DlcParms.TiTick2
                );
}

PRIVATE
LPSTR
MapAdapterType(
    IN ADAPTER_TYPE AdapterType
    )
{
    switch (AdapterType) {
    case TokenRing:
        return "Token Ring";

    case Ethernet:
        return "Ethernet";

    case PcNetwork:
        return "PC Network";

    case UnknownAdapter:
        return "Unknown Adapter";
    }
    return "*** REALLY UNKNOWN ADAPTER! ***";
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\vrdlcbuf.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems

Module Name:

    vrdlcbuf.c

Abstract:

    The module implements the buffer management used by DOS DLC applications

    Contents:
        InitializeBufferPools
        CreateBufferPool
        DeleteBufferPool
        GetBuffers
        FreeBuffers
        CalculateBufferRequirement
        CopyFrame
        AllBuffersInPool

Author:

    Antti Saarenheimo (o-anttis) 26-DEC-1991

Notes:

    Originally, this code created a list of DOS buffers by keeping the segment
    constant, and updating the offset. For example, if a buffer pool was
    supplied starting at 0x1234:0000, buffers 0x100 bytes long, then the
    chain would be:

        1234:0000 -> 1234:0100 -> 1234:0200 -> ... -> 0000:0000

    But it turns out that some DOS DLC apps (Rumba) expect the offset to remain
    constant (at 0), and the segment to change(!). Thus, given the same buffer
    pool address, we would have a chain:

        1234:0000 -> 1244:0000 -> 1254:0000 -> ... -> 0000:0000

    As far as DOS apps are concerned, there is no difference, since the
    effective 20-bit address is the same.

    This is mainly done so that an app can take the USER_OFFSET field of a
    received buffer and glue it to the segment, without having to do any
    arithmetic

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>      // ASSERT, DbgPrint
#include <nturtl.h>
#include <windows.h>
#include <softpc.h>     // x86 virtual machine definitions
#include <vrdlctab.h>
#include <vdmredir.h>
#include <dlcapi.h>     // Official DLC API definition
#include <ntdddlc.h>    // IOCTL commands
#include <dlcio.h>      // Internal IOCTL API interface structures
#include "vrdlc.h"
#include "vrdebug.h"
#include "vrdlcdbg.h"

//
// defines
//

//
// BUFFER_2_SIZE - this is the size of the fixed part of a DOS receive Buffer 2.
// It just so happens that DOS and NT Buffer 2 (aka Next) are the same size
//

#define BUFFER_2_SIZE   sizeof(((PLLC_DOS_BUFFER)0)->Next)

//
// macros
//

//
// BUFFER_1_SIZE - return the size of the fixed part of a DOS receive Buffer 1.
// The size is dependent on whether the receive options specified contiguous or
// non-contiguous receive buffers. The size of a DOS Buffer 1 (of either type)
// is 4 bytes smaller than the equivalent NT Buffer 1 because the NEXT_FRAME
// field is absent
//

#define BUFFER_1_SIZE(contiguous)   ((contiguous) \
                                    ? sizeof(((PLLC_DOS_BUFFER)0)->Contiguous) \
                                    : sizeof(((PLLC_DOS_BUFFER)0)->NotContiguous))

//
// private prototypes
//

//
// public data
//

//
// private data
//

//
// DOS Buffer Pools - there can be one buffer pool per SAP. Protect access
// using critical section.
// There are 256 SAPs max, which breaks down into a maximum of 128 SAPs per
// adapter. We can accomodate a maximum of 2 adapters - one Token Ring (adapter
// 0) and one Ether Link (adapter 1)
//

DOS_DLC_BUFFER_POOL aBufferPools[DOS_DLC_MAX_SAPS * DOS_DLC_MAX_ADAPTERS];
CRITICAL_SECTION BufferSemaphore;


//
// functions
//

VOID
InitializeBufferPools(
    VOID
    )

/*++

Routine Description:

    Clears all buffer pools - sets structures to 0 - and initializes the buffer
    synchronization semaphore

Arguments:

    None.

Return Value:

    None.

--*/

{
    IF_DEBUG(DLC_BUFFERS) {
        DPUT("InitializeBufferPools\n");
    }

    InitializeCriticalSection(&BufferSemaphore);
    RtlZeroMemory(aBufferPools, sizeof(aBufferPools));
}


LLC_STATUS
CreateBufferPool(
    IN DWORD PoolIndex,
    IN DOS_ADDRESS dpBuffer,
    IN WORD PoolBlocks,
    IN WORD BufferSize
    )

/*++

Routine Description:

    The function initializes buffer pool for a DLC application.
    DOS DLC applications do not necessarily need to create the
    buffer pool immediately in DlcOpenSap (or DirOpenAdapter).
    We initialize the buffer pool for DOS memory mode using
    parallel pointers in flat and DOS side.

Arguments:

    PoolIndex   - SAP and adapter number (bit 0 defines 0 or 1 adapter)

    dpBuffer    - DOS pointer, space for the buffer segments. May be 0 in which
                  case the app maintains its own buffers, we just get to know
                  how many there are

    PoolBlocks  - number of 16 byte blocks which comprise the buffer pool.
                  If this is 0 then the default of 256 (*16 = 4096) is used

    BufferSize  - size of an individual buffer in bytes and an integral multiple
                  of 16. The minimum size is 80. If it is zero then the default
                  of 160 is used

Return Value:

    LLC_STATUS

        Success - LLC_STATUS_SUCCESS
                    Buffer pool for this SAP has been created

        Failure - LLC_STATUS_DUPLICATE_COMMAND
                    The buffer pool for this SAP already exists

                  LLC_STATUS_INVALID_BUFFER_LENGTH
                    The given buffer size is not a multiple of 16 or is less
                    than 80 bytes (default minimum buffer size)

                  LLC_STATUS_BUFFER_SIZE_EXCEEDED
                    The buffer pool isn't big enough to hold 1 buffer of the
                    requested size

--*/

{
    WORD BufferSizeInBlocks;
    WORD BufferCount;
    DWORD i;

    IF_DEBUG(DLC_BUFFERS) {
        DPUT4("CreateBufferPool(PoolIndex=%#x, dpBuffer=%#x, PoolBlocks=%d, BufferSize=%d)\n",
            PoolIndex, dpBuffer, PoolBlocks, BufferSize);
    }

    //
    // An app may reinitialize the buffer with DIR.MODIFY.OPEN.PARMS but the
    // command must fail, if there are already buffers in the pool. We should
    // also check if there is a pending receive command, but we cannot do it
    // without major changes in the receive handling architecture
    //

    if (aBufferPools[PoolIndex].BufferSize) {

        IF_DEBUG(DLC_BUFFERS) {
            DPUT1("CreateBufferPool: already have buffer pool for %#x\n", PoolIndex);
        }

        return LLC_STATUS_DUPLICATE_COMMAND;
    }

    //
    //  Use the default, if the orginal value is 0
    //

    if (BufferSize == 0) {
        BufferSize = 160;
    }
    if (PoolBlocks == 0) {
        PoolBlocks = 256;
    }

    //
    //  The buffer size must be at least 80 and an even 16 bytes
    //

    if ((BufferSize < 80) || (BufferSize % 16)) {
        return LLC_STATUS_INVALID_BUFFER_LENGTH;
    }

    BufferSizeInBlocks = BufferSize / 16;
    if (BufferSizeInBlocks > PoolBlocks) {

        IF_DEBUG(DLC_BUFFERS) {
            DPUT("CreateBufferPool: Error: BufferSizeInBlocks > PoolBlocks\n");
        }

        return LLC_STATUS_BUFFER_SIZE_EXCEEDED;
    }

    EnterCriticalSection(&BufferSemaphore);

    //
    // A DLC application may want to manage the buffer pool itself and to
    // provide the receive buffers with FreeBuffers, but the buffer size must
    // always be defined here.
    //

    aBufferPools[PoolIndex].BufferSize = BufferSize;
    aBufferPools[PoolIndex].dpBuffer = dpBuffer;    // may be 0!
    aBufferPools[PoolIndex].BufferCount = 0;

    //
    // if the app has actually given us a buffer to use then we initialize it
    // else the app must manage its own buffers; we just maintain the metrics.
    // Note that the app's buffer might be aligned any old way, but we have to
    // put up with it at the expense of speed
    //

    if (dpBuffer) {

        LPBYTE ptr32;

        BufferCount = PoolBlocks/BufferSizeInBlocks;

        //
        // if the number of buffers we can fit in our pool is zero then inform
        // the app that we can't proceed with this request and clear out the
        // information for this buffer pool
        //

        if (BufferCount == 0) {
            aBufferPools[PoolIndex].BufferSize = 0;
            aBufferPools[PoolIndex].dpBuffer = 0;
            aBufferPools[PoolIndex].BufferCount = 0;
            LeaveCriticalSection(&BufferSemaphore);
            return LLC_STATUS_BUFFER_SIZE_EXCEEDED;
        }

        aBufferPools[PoolIndex].BufferCount = BufferCount;
        aBufferPools[PoolIndex].MaximumBufferCount = BufferCount;

        //
        // convert the DOS address to a flat 32-bit pointer
        //

        ptr32 = (LPBYTE)DOS_PTR_TO_FLAT(dpBuffer);

        //
        // link the buffers together and initialize the headers. The headers
        // are only intialized with 2 pieces of info: the size of the buffer
        // and the pointer to the next buffer
        //

        aBufferPools[PoolIndex].dpBuffer = dpBuffer;

        //
        // update the segment only - leave the offset
        //

        dpBuffer += BufferSize / 16 * 65536;
        for (i = BufferCount; i; --i) {

            //
            // do we really need this? I don't think so: looking at the manual,
            // this field is to report size of data received, not size of
            // buffer, which we know anyway
            //

            //WRITE_WORD(((PLLC_DOS_BUFFER)ptr32)->Next.cbBuffer, BufferSize);

            //
            // if this is the last buffer then set its NextBuffer field to
            // NULL. All buffers get the size info
            //

            if (i - 1) {
                WRITE_DWORD(&((PLLC_DOS_BUFFER)ptr32)->Next.pNextBuffer, dpBuffer);

                //
                // update the segment only - leave the offset
                //

                dpBuffer += BufferSize / 16 * 65536;
                ptr32 += BufferSize;
            } else {
                WRITE_DWORD(&((PLLC_DOS_BUFFER)ptr32)->Next.pNextBuffer, NULL);
            }
        }

#if DBG
        IF_DEBUG(DLC_BUFFERS) {
            DumpDosDlcBufferPool(&aBufferPools[PoolIndex]);
        }
#endif

    }

    LeaveCriticalSection(&BufferSemaphore);
    return LLC_STATUS_SUCCESS;
}


VOID
DeleteBufferPool(
    IN DWORD PoolIndex
    )

/*++

Routine Description:

    The function deletes a buffer pool

Arguments:

    PoolIndex   - pool index based on SAP and adapter number

Return Value:

    None.

--*/

{
    IF_DEBUG(DLC_BUFFERS) {
        DPUT("DeleteBufferPool\n");
    }

    //
    // DLC.RESET for all adapters calls this 127 times
    //

    EnterCriticalSection(&BufferSemaphore);
    if (aBufferPools[PoolIndex].BufferSize != 0) {
        RtlZeroMemory(&aBufferPools[PoolIndex], sizeof(aBufferPools[PoolIndex]));
    }
    LeaveCriticalSection(&BufferSemaphore);
}


LLC_STATUS
GetBuffers(
    IN  DWORD PoolIndex,
    IN  WORD BuffersToGet,
    OUT DPLLC_DOS_BUFFER *pdpBuffer,
    OUT LPWORD pusBuffersLeft,
    IN  BOOLEAN PartialList,
    OUT PWORD BuffersGot OPTIONAL
    )

/*++

Routine Description:

    The function allocates DLC buffers. It will allocate buffers as a chain
    if >1 is requested. If PartialList is TRUE then will allocate as many
    buffers as are available up to BuffersToGet and return the number in
    BuffersGot

Arguments:

    PoolIndex       - SAP and adapter number
    BuffersToGet    - numbers of buffers to get. If this is 0, defaults to 1
    pdpBuffer       - the returned link list of LLC buffers
    pusBuffersLeft  - returned count of buffers left after this call
    PartialList     - TRUE if the caller wants a partial list
    BuffersGot      - pointer to returned number of buffers allocated

Return Value:

    LLC_STATUS
        Success - LLC_STATUS_SUCCESS
                    The requested number of buffers have been returned, or a
                    number of buffers less than the original request if
                    PartialList is TRUE

        Failure - LLC_STATUS_LOST_DATA_NO_BUFFERS
                    The request could not be satistfied - not enough buffers
                    in pool

                  LLC_STATUS_INVALID_STATION_ID
                    The request was mad to an invalid SAP

--*/

{
    PLLC_DOS_BUFFER pBuffer;
    PDOS_DLC_BUFFER_POOL pBufferPool = &aBufferPools[PoolIndex];
    LLC_STATUS status;
    WORD n;
    WORD bufferSize;

#if DBG
    DWORD numBufs = BuffersToGet;

    IF_DEBUG(DLC_BUFFERS) {
        DPUT2("GetBuffers(PoolIndex=%#02x, BuffersToGet=%d)\n", PoolIndex, BuffersToGet);
    }
#endif

    EnterCriticalSection(&BufferSemaphore);

    //
    // if the caller specified PartialList then return whatever we've got. If
    // whatever we've got is 0 then we'll default it to 1 and fail the allocation
    // since 0 is less than 1
    //

    if (PartialList) {
        if (pBufferPool->BufferCount < BuffersToGet) {
            BuffersToGet = pBufferPool->BufferCount;
        }
    }

    //
    // IBM DLC allows a default value of 1 to be used if the caller specified 0
    //

    if (!BuffersToGet) {
        ++BuffersToGet;
    }

    //
    // default the returned DOS buffer chain pointer to NULL
    //

    *pdpBuffer = 0;

    //
    // if there are no buffers defined then this is an erroneous request
    //

    if (pBufferPool->BufferSize) {

        //
        // calculate the size of the data part of the buffer. We put this value
        // in the LENGTH_IN_BUFFER field
        //

        bufferSize = pBufferPool->BufferSize
                   - (WORD)sizeof(pBuffer->Next);

        //
        // there may be no buffers left, in which case the next buffer pointer
        // (in DOS 16:16 format) will be 0 (0:0). If, on the other hand, it's
        // not 0 then we're in business: see if we can't allocate the buffers
        // requested
        //

        if (pBufferPool->dpBuffer && pBufferPool->BufferCount >= BuffersToGet) {

            pBuffer = (PLLC_DOS_BUFFER)DOS_PTR_TO_FLAT(pBufferPool->dpBuffer);
            *pdpBuffer = pBufferPool->dpBuffer;
            pBufferPool->BufferCount -= BuffersToGet;
            n = BuffersToGet;

            //
            // Eicon Access wants the size of the buffer in the buffer
            // when it is returned by BUFFER.GET. Oblige
            //

            WRITE_WORD(&pBuffer->Next.cbBuffer, bufferSize);

            //
            // we will return a chain of buffers, so we (nicely) terminate it
            // with a NULL for the last NextBuffer field. It doesn't say in
            // the lovely IBM Tech Ref whether this should be done, but its
            // probably the best thing to do. Because this buffer pool lives
            // in DOS memory, we have to use READ_POINTER and WRITE_FAR_POINTER
            // macros, lest we get an alignment fault on RISC
            //

            status = LLC_STATUS_SUCCESS;

            for (--BuffersToGet; BuffersToGet; --BuffersToGet) {
                pBuffer = (PLLC_DOS_BUFFER)READ_FAR_POINTER(&(pBuffer->pNext));
                if (pBuffer) {

                    //
                    // Eicon Access wants the size of the buffer in the buffer
                    // when it is returned by BUFFER.GET. Oblige
                    //

                    WRITE_WORD(&pBuffer->Next.cbBuffer, bufferSize);

                } else {

                    //
                    // As Prefix found out, the next lines below would
                    // dereference a NULL. This is a bad case since the
                    // buffer creation process somehow failed, or, more
                    // likely, someone stumped the memory. We thus assume
                    // success above and set the error in this case.
                    //
                    status = LLC_STATUS_LOST_DATA_NO_BUFFERS;
                    n = 0;
                    break;
                }
            }

            //
            // set the new buffer pool head
            //

            if (status == LLC_STATUS_SUCCESS) {

                pBufferPool->dpBuffer = READ_DWORD(&pBuffer->pNext);

                //
                // terminate the chain
                //

                WRITE_FAR_POINTER(&pBuffer->pNext, NULL);


    #if DBG
                IF_DEBUG(DLC_BUFFERS) {
                    DumpDosDlcBufferChain(*pdpBuffer, numBufs ? numBufs : 1);
                }
    #endif

            }
        } else {

            //
            // if no buffers are obtained, the returned list is set to 0
            //


            status = LLC_STATUS_LOST_DATA_NO_BUFFERS;
            n = 0;
        }

        //
        // return the number of buffers left after this call. Works if we
        // allocated some or not
        //

        *pusBuffersLeft = pBufferPool->BufferCount;

    } else {

        //
        // bad SAP - no buffer pool for this one
        //

        status = LLC_STATUS_INVALID_STATION_ID;
        n = 0;
    }

    LeaveCriticalSection(&BufferSemaphore);

    //
    // if BuffersGot was specified then return the number of buffers allocated
    // and chained
    //

    if (ARGUMENT_PRESENT(BuffersGot)) {
        *BuffersGot = n;
    }

    IF_DEBUG(DLC_BUFFERS) {
        DPUT2("GetBuffers returning status=%x, BuffersLeft=%d\n", status, *pusBuffersLeft);
    }

    return status;
}


LLC_STATUS
FreeBuffers(
    IN DWORD PoolIndex,
    IN DPLLC_DOS_BUFFER dpBuffer,
    OUT LPWORD pusBuffersLeft
    )

/*++

Routine Description:

    Free a DOS buffer to a DLC buffer pool

Arguments:

    PoolIndex       - SAP and adapter number (bit0 defines 0 or 1 adapter)
    dpBuffer        - the released buffers (DOS pointer)
    pusBuffersLeft  - the number of buffers left after the free

Return Value:

--*/

{
    DPLLC_DOS_BUFFER dpBase;        // DOS pointer
    PLLC_DOS_BUFFER pNextBuffer;    // flat NT pointer
    PLLC_DOS_BUFFER pBuffer;        // flat NT pointer
    PDOS_DLC_BUFFER_POOL pBufferPool = &aBufferPools[PoolIndex];

#if DBG
    int n = 0;
#endif

    IF_DEBUG(DLC_BUFFERS) {
        DPUT2("FreeBuffers: PoolIndex=%x dpBuffer=%x\n", PoolIndex, dpBuffer);
    }

    if (pBufferPool->BufferSize == 0) {
        return LLC_STATUS_INVALID_STATION_ID;
    }

    EnterCriticalSection(&BufferSemaphore);

    dpBase = dpBuffer;
    pNextBuffer = pBuffer = DOS_PTR_TO_FLAT(dpBuffer);

    //
    // the manual says for BUFFER.FREE (p3-4):
    //
    //  "When the buffer is placed back in the buffer pool, bytes 4 and 5
    // (buffer length) of the buffer are set to zero."
    //
    // So, we oblige
    //

    WRITE_WORD(&pBuffer->Next.cbFrame, 0);
    if (pNextBuffer) {

        //
        // count the number of buffers being freed. Hopefully, the application
        // hasn't chenged over our terminating NULL pointer
        //

        while (pNextBuffer) {
            ++pBufferPool->BufferCount;

#if DBG
            ++n;
#endif

            pBuffer = pNextBuffer;
            pNextBuffer = (PLLC_DOS_BUFFER)READ_FAR_POINTER(&pBuffer->pNext);

            //
            // see above, about bytes 4 and 5
            //

            WRITE_WORD(&pBuffer->Next.cbFrame, 0);
        }

        //
        // put the freed chain at the head of the list, after linking the
        // buffer currently at the head of the list to the end of the freed
        // chain
        //

        WRITE_DWORD(&pBuffer->pNext, pBufferPool->dpBuffer);
        pBufferPool->dpBuffer = dpBase;

#if DBG
        IF_DEBUG(DLC_BUFFERS) {
            DumpDosDlcBufferChain(dpBuffer, n);
        }

    } else {

        DPUT("ERROR: App tried to free NULL buffer chain\n");
#endif

    }

    *pusBuffersLeft = pBufferPool->BufferCount;

    if (pBufferPool->BufferCount > pBufferPool->MaximumBufferCount) {
        pBufferPool->MaximumBufferCount = pBufferPool->BufferCount;
    }

    LeaveCriticalSection(&BufferSemaphore);

    return STATUS_SUCCESS;
}


WORD
CalculateBufferRequirement(
    IN UCHAR Adapter,
    IN WORD StationId,
    IN PLLC_BUFFER pFrame,
    IN LLC_DOS_PARMS UNALIGNED * pDosParms,
    OUT PWORD BufferSize
    )

/*++

Routine Description:

    Calculate the number of DOS buffers required to hold the data received into
    an NT buffer. We have to go through this laborious phase because we need to
    know ahead of time if we have enough DOS buffers into which we will receive
    an I-Frame.

    Also, the size of DOS buffers is fixed, but the size of NT receive frame
    buffers can vary depending on the size of the received frame, the options
    requested and the 'binary buddy' allocator algorithm in the DLC driver. You
    may think that since we specify to the driver the buffer pool size in the
    DLC.OPEN.SAP call that it would allocate buffers of the specified size.
    Well, you'd be wrong: the DLC driver ignores this information and creates
    a buffer pool which can dole out variable size buffers, making my life more
    difficult than it ought to be

Arguments:

    Adapter     - which adapter we're receiving from
    StationId   - the Station Id we're receiving on
    pFrame      - pointer to the received frame in NT buffer
    pDosParms   - pointer to the original DOS RECEIVE parameters
    BufferSize  - pointer to the returned DOS buffer size

Return Value:

    WORD

--*/

{
    //
    // pBufferPool points to the DOS buffer pool for this adapter/station ID
    //

    PDOS_DLC_BUFFER_POOL pBufferPool = &aBufferPools[GET_POOL_INDEX(Adapter, StationId)];

    //
    // dosUserLength is the USER_LENGTH value the DOS client requested when
    // the RECEIVE was submitted. This value may well be different than the
    // USER_LENGTH in the NT receive frame buffer
    //

    WORD dosUserLength = READ_WORD(&pDosParms->DosReceive.usUserLength);

    //
    // buffersRequired is the number of DOS buffers we need to allocate in order
    // to return the received frame. It will be at least 1
    //

    WORD buffersRequired = 1;

    //
    // dataSpace is the area in a DOS buffer available for data (after the
    // Buffer 1 or Buffer 2 header and the USER_LENGTH consideration)
    //

    WORD dataSpace;

    //
    // dataLeft is the amount of data in an NT buffer needing to be copied to
    // a DOS buffer
    //

    WORD dataLeft = 0;

    //
    // calculate the number of DOS buffers required to hold the data frame
    // received into the NT buffer. Note that we can't simply use the size
    // of the received frame because we need the size of the buffer headers
    // and if the NT frame is larger than the DOS buffers then we may end
    // up with more DOS buffers required than NT buffers which in turn
    // results in more overhead which we have to factor in
    //

    WORD bufferSize = pBufferPool->BufferSize;

    IF_DEBUG(DLC_BUFFERS) {
        DPUT("CalculateBufferRequirement\n");
    }

    //
    // calculate the amount of space in a DOS buffer after the Buffer 1 structure
    // (contiguous or non-contiguous, smoking or non-smoking, ah, ah, ah ahh-haa)
    // The buffer size MUST be large enough to hold the Buffer 1 overhead. This
    // is a FACT
    //

    dataSpace = bufferSize
              - (BUFFER_1_SIZE(
                    pFrame->Contiguous.uchOptions
                        & (LLC_CONTIGUOUS_MAC | LLC_CONTIGUOUS_DATA)
                    )
                 + dosUserLength
                );

    //
    // if there is less data space available in the first DOS receive buffer
    // than received data in the NT buffer then our first NT buffer will be
    // mapped to >1 DOS buffers: a Buffer 1 and 1 or more Buffer 2s. This is
    // before we even get to any associated Buffer 2s in the NT receive frame.
    //
    // Also: if the LLC_BREAK option is specified in the receive parameters
    // then the first data buffer will contain the header information. Note:
    // we assume this can only be for NotContiguous data, else how would we
    // know the size of the header information?
    //

    if (pFrame->Contiguous.uchOptions & LLC_BREAK) {
        if (!(pFrame->Contiguous.uchOptions & (LLC_CONTIGUOUS_MAC | LLC_CONTIGUOUS_DATA))) {
            dataLeft = pFrame->NotContiguous.cbBuffer;
        }

#if DBG
        else {
            DPUT("CalculateBufferRequirement: Error: invalid options: BREAK && CONTIGUOUS???\n");
        }
#endif

    } else if (dataSpace < pFrame->Contiguous.cbBuffer) {
        dataLeft = pFrame->Contiguous.cbBuffer - dataSpace;
    } else {

        //
        // we have enough space in the DOS buffer to copy all the received data
        // and some more
        //

        dataSpace -= pFrame->Next.cbBuffer;
        dataLeft = 0;
    }

    //
    // if there is more data in the NT buffer than we can fit in a DOS buffer,
    // either because the buffer sizes are different or due to the DOS client
    // requesting the BREAK option, then generate Buffer 2 requirements
    //

    while (dataLeft) {
        ++buffersRequired;
        dataSpace = bufferSize - (BUFFER_2_SIZE + dosUserLength);
        if (dataLeft > dataSpace) {
            dataLeft -= dataSpace;
            dataSpace = 0;
        } else {
            dataSpace -= dataLeft;
            dataLeft = 0;
        }
    }

    //
    // if the NT received frame has any associated Buffer 2 structures then
    // calculate the additional buffer requirement. Again, the NT buffers may
    // be a different size(s) than the DOS buffers.
    //
    // At this point, dataSpace is the amount of remaining data area in the
    // previous DOS buffer - Buffer 1 or Buffer 2. Use this before we allocate
    // a new DOS buffer
    //

    for (pFrame = pFrame->pNext; pFrame; pFrame = pFrame->pNext) {
        if (pFrame->Next.cbBuffer > dataSpace) {
            dataLeft = pFrame->Next.cbBuffer - dataSpace;
            dataSpace = 0;
            while (dataLeft) {
                ++buffersRequired;
                dataSpace = bufferSize - (BUFFER_2_SIZE + dosUserLength);
                if (dataLeft > dataSpace) {
                    dataLeft -= dataSpace;
                    dataSpace = 0;
                } else {
                    dataSpace -= dataLeft;
                    dataLeft = 0;
                }
            }
        } else {

            //
            // we have enough space in the DOS buffer to copy all the received data
            // and some more
            //

            dataSpace -= pFrame->Next.cbBuffer;
            dataLeft = 0;
        }
    }

    IF_DEBUG(DLC_BUFFERS) {
        DPUT1("CalculateBufferRequirement: %d buffers required\n", buffersRequired);
    }

    //
    // set the output DOS buffer size and return the number of DOS buffers
    // required
    //

    *BufferSize = bufferSize;
    return buffersRequired;
}


LLC_STATUS
CopyFrame(
    IN PLLC_BUFFER pFrame,
    IN DPLLC_DOS_BUFFER DosBuffers,
    IN WORD UserLength,
    IN WORD BufferSize,
    IN DWORD Flags
    )

/*++

Routine Description:

    Copies a received NT frame into DOS buffers. We have previously calculated
    the DOS buffer requirement and allocated that requirement

    We may copy the entire received frame or only part of it. We can only copy
    partial frames if the frame is NOT an I-Frame

    Notes:  1. the DOS buffer manager returns the orginal DOS 16:16 buffer
            pointers, we must use those original pointers, when the buffers
            are linked to each other.

            2. We do NOT chain frames - DOS DLC cannot handle frames being
            chained, and there is nothing to be gained by us chaining them
            except that we reduce the number of completed READs. However,
            we still have to generate the same number of simulated hardware
            interrupts to the VDM

            3. Unlike DOS buffer pools, NT does not deal in buffers of a
            specific size. Rather, it allocates buffers from a pool based
            on a 'binary buddy' algorithm and the size of the data to be
            returned. Therefore, there is no correspondence between the
            size of DOS buffers (for a station) and the NT buffers which
            were used to receive the data

            4. We only copy the data in this routine - whether it is deferred
            data from some prior local busy state or current data is immaterial
            to this routine. Responsibility for managing current/deferred frames
            is left to the caller

Arguments:

    pFrame      - pointer to received frame in NT buffer(s)
    DosBuffers  - DOS pointer to chain of DOS receive buffers
    UserLength  - the USER_LENGTH value specified in the DOS RECEIVE
    BufferSize  - size of a DOS buffer
    Flags       - various flags:
                    CF_CONTIGUOUS
                        Set if this frame is contiguous

                    CF_BREAK
                        Set if the DOS client requested that the buffers be
                        broken into header, data

                    CF_PARTIAL
                        Set if we are copying a partial frame - ok for non
                        I-Frames

Return Value:

    LLC_STATUS
        LLC_STATUS_SUCCESS
            All data copied from NT buffer to DOS buffer(s)

        LLC_STATUS_LOST_DATA_INADEQUATE_SPACE
            A partial copy was performed. Some data ended up in DOS buffer(s),
            the rest is lost. Cannot be I-Frame!

--*/

{
    //
    // pDosBuffer - pointer to the DOS buffer which is usable in 32-bit mode
    //

    PLLC_DOS_BUFFER pDosBuffer = (PLLC_DOS_BUFFER)DOS_PTR_TO_FLAT(DosBuffers);

    //
    // dataSpace - amount of data space available in the current DOS buffer.
    // Initialize it for common Buffer 1 case
    //

    WORD dataSpace = BufferSize - (WORD)&(((PLLC_BUFFER)0)->Contiguous.pNextFrame);

    PBYTE pDosData;     // pointer to place in DOS buffer where we copy data TO
    PBYTE pNtData;      // corresponding place in NT buffer where we copy data FROM
    WORD headerLength;  // amount of data in headers
    WORD dataLeft;      // amount of data to be copied FROM the NT buffer
    WORD userOffset;    // offset of USER_SPACE
    WORD bufferLeft;    // amount of data left in current NT buffer
    WORD dataToCopy;    // amount of data to copy to DOS buffer
    WORD dataCopied;    // amount of data copied to Buffer 1/Buffer 2
    WORD frameLength;   // length of entire frame

    //
    // bufferOffset - used in generating the correct userOffset
    //

    WORD bufferOffset = LOWORD(DosBuffers);

    IF_DEBUG(DLC_BUFFERS) {
        DPUT5("CopyFrame: pFrame=%x DosBuffers=%x UserLength=%x Flags=%x pDosBuffer=%x\n",
                pFrame, DosBuffers, UserLength, Flags, pDosBuffer);
    }

    //
    // copy the first buffer. If the BREAK option is set then we only copy the
    // header part (ASSUMES NotContiguous)! NB: we KNOW that we can fit at least
    // this amount of data in the DOS buffer. Also: it is safe to use RtlCopyMemory ?
    //

    RtlCopyMemory(&pDosBuffer->Contiguous.cbFrame,
                  &pFrame->Contiguous.cbFrame,
                  (DWORD)&(((PLLC_BUFFER)0)->Contiguous.pNextFrame)
                  - (DWORD)&(((PLLC_BUFFER)0)->Contiguous.cbFrame)
                  );

    //
    // pDosData points to the area in the DOS buffer where the LAN header info
    // or data will go, depending on format
    //

    pDosData = &pDosBuffer->NotContiguous.cbLanHeader;

    //
    // if the CF_CONTIGUOUS flag is not set in the Flags parameter then this is
    // a NotContiguous frame. We must copy the header in 2 parts, because the
    // NT buffer contains the NEXT_FRAME field which the DOS buffer does not
    //

    if (!(Flags & CF_CONTIGUOUS)) {

        IF_DEBUG(DLC_BUFFERS) {
            DPUT("Buffer is NOT CONTIGUOUS\n");
        }

        RtlCopyMemory(pDosData,
                      &pFrame->NotContiguous.cbLanHeader,
                      (DWORD)&(((PLLC_BUFFER)0)->NotContiguous.usPadding)
                      - (DWORD)&(((PLLC_BUFFER)0)->NotContiguous.cbLanHeader)
                      );

        pDosData += (DWORD)&(((PLLC_BUFFER)0)->NotContiguous.usPadding)
                  - (DWORD)&(((PLLC_BUFFER)0)->NotContiguous.cbLanHeader);

        dataSpace -= (WORD)&(((PLLC_BUFFER)0)->NotContiguous.usPadding)
                   - (WORD)&(((PLLC_BUFFER)0)->NotContiguous.cbLanHeader);
        userOffset = (WORD)&(((PLLC_DOS_BUFFER)0)->NotContiguous.auchDlcHeader)
                   + sizeof(((PLLC_DOS_BUFFER)0)->NotContiguous.auchDlcHeader);

        //
        // sanity check
        //

        ASSERT(userOffset == 58);

        //
        // amount of data in headers
        //

        headerLength = pFrame->NotContiguous.cbLanHeader
                     + pFrame->NotContiguous.cbDlcHeader;
    } else {

        IF_DEBUG(DLC_BUFFERS) {
            DPUT("Buffer is CONTIGUOUS\n");
        }

        userOffset = (WORD)&(((PLLC_DOS_BUFFER)0)->Contiguous.uchAdapterNumber)
                   + sizeof(((PLLC_DOS_BUFFER)0)->Contiguous.uchAdapterNumber);

        //
        // sanity check
        //

        ASSERT(userOffset == 20);

        //
        // no header info in contiguous buffer
        //

        headerLength = 0;
    }

    //
    // if the CF_BREAK flag is set in the Flags parameter then the DOS app
    // requested that the first buffer (presumed NotContiguous) be broken into
    // one buffer containing just the header information and another containing
    // the data. In this case copy no more data to the first buffer
    //

    if (!(Flags & CF_BREAK)) {

        //
        // pDosData points at USER_SPACE - offset 58 for NotContiguous buffer,
        // offset 20 for Contiguous buffer. Bump it by USER_LENGTH (still don't
        // know if we ever expect anything meaningful to be placed at USER_SPACE
        // before we give the buffer to DOS
        //

        pDosData += UserLength;

        //
        // get in dataSpace the amount of space left in the DOS buffer where
        // we are able to copy data. Assume that UserLength doesn't make this
        // go negative (ie LARGE)
        //

        ASSERT(dataSpace >= UserLength);

        dataSpace -= UserLength;
    } else {

        IF_DEBUG(DLC_BUFFERS) {
            DPUT("Buffer has BREAK\n");
        }

        //
        // the DOS app requested BREAK. Set the count of data in this buffer
        // to 0. Use WRITE_WORD since it may be unaligned. Update the other
        // header fields we can't just copy from the NT buffer
        //

        WRITE_WORD(&pDosBuffer->NotContiguous.cbBuffer, 0);
        WRITE_WORD(&pDosBuffer->NotContiguous.offUserData, userOffset + bufferOffset);
        WRITE_WORD(&pDosBuffer->NotContiguous.cbUserData, UserLength);

        //
        // get the next DOS buffer in the list. There may not be one? (Don't
        // expect such a situation)
        //

        bufferOffset = READ_WORD(&pDosBuffer->pNext);
        pDosBuffer = DOS_PTR_TO_FLAT(pDosBuffer->pNext);
        if (pDosBuffer) {
            userOffset = (WORD)&(((PLLC_DOS_BUFFER)0)->Next.cbUserData)
                       + sizeof(((PLLC_DOS_BUFFER)0)->Next.cbUserData);

            //
            // sanity check
            //

            ASSERT(userOffset == 12);
            dataSpace = BufferSize - (BUFFER_2_SIZE + UserLength);
            pDosData = (PBYTE)pDosBuffer + BUFFER_2_SIZE + UserLength;
        } else {

            //
            // that was the last buffer. Either there was just header data or
            // this is a partial copy and therefore not an I-Frame
            //

            IF_DEBUG(DLC_BUFFERS) {
                DPUT("CopyFrame: returning early\n");
            }

            return (Flags & CF_PARTIAL)
                ? LLC_STATUS_LOST_DATA_INADEQUATE_SPACE
                : LLC_STATUS_SUCCESS;
        }
    }

    //
    // frameLength is length of entire frame - must appear in Buffer 1 and
    // Buffer 2s
    //

    frameLength = pFrame->Contiguous.cbFrame;

    //
    // dataLeft is the amount of data left to copy from the frame after the
    // headers have been taken care of. For a Contiguous buffer, this is the
    // same as the length of the frame; for a NotContiguous buffer, this is
    // the length of the frame - the combined length of the LAN and DLC
    // headers
    //

    dataLeft = frameLength - headerLength;

    //
    // get pointer to data in NT buffer and the amount of data to copy (from
    // rest of NT frame)
    //

    pNtData = (PBYTE)pFrame
            + pFrame->Contiguous.offUserData
            + pFrame->Contiguous.cbUserData;

    bufferLeft = pFrame->Contiguous.cbBuffer;

    //
    // dataCopied is amount of data copied to current buffer (1 or 2) and goes
    // in cbBuffer field (aka LENGTH_IN_BUFFER)
    //

    dataCopied = 0;

    //
    // we have copied all the data we could to the first buffer. While there
    // are more DOS buffers, copy data from NT buffer
    //

    do {

        //
        // calculate the amount of space available in the current buffer
        //

        if (dataSpace >= bufferLeft) {
            dataToCopy = bufferLeft;
            dataLeft -= dataToCopy;
            dataSpace -= dataToCopy;
            bufferLeft = 0;
        } else {
            dataToCopy = dataSpace;
            bufferLeft -= dataSpace;
            dataLeft -= dataSpace;
            dataSpace = 0;
        }

        //
        // copy the data. This will fill up the current DOS buffer, exhaust the
        // current NT buffer, or both
        //

        if (dataToCopy) {

            IF_DEBUG(DLC_RX_DATA) {
                DPUT3("CopyFrame: Copying %d bytes from %x to %x\n", dataToCopy, pNtData, pDosData);
            }

            RtlCopyMemory(pDosData, pNtData, dataToCopy);

            //
            // dataCopied accumulates until we fill a DOS buffer
            //

            dataCopied += dataToCopy;

            //
            // update to- and from- pointers for next go round loop
            //

            pDosData += dataToCopy;
            pNtData += dataToCopy;
        }

        //
        // we have run out of space in a DOS buffer, or out of data to copy from
        // the NT buffer
        //

        if (dataLeft) {

            //
            // we think there is data left to copy
            //

            if (!bufferLeft) {

                //
                // finished current NT buffer. Get next one
                //

                pFrame = pFrame->pNext;
                if (pFrame) {
                    bufferLeft = pFrame->Next.cbBuffer;
                    pNtData = (PBYTE)pFrame
                            + pFrame->Contiguous.offUserData
                            + pFrame->Contiguous.cbUserData;

                    IF_DEBUG(DLC_RX_DATA) {
                        DPUT3("CopyFrame: new NT buffer @%x pNtData @%x bufferLeft=%d\n",
                                pFrame, pNtData, bufferLeft);
                    }

                } else {

                    //
                    // no more NT buffers. Is this a partial copy?
                    //

                    DPUT("*** ERROR: dataLeft && no more NT buffers ***\n");
                    ASSERT(Flags & CF_PARTIAL);
                    break;
                }
            }
            if (!dataSpace) {

                //
                // update the current DOS buffer header (it doesn't matter that
                // we use Contiguous, NotContiguous, or Next: these fields are
                // present in all 3 buffer types)
                //

                WRITE_WORD(&pDosBuffer->Contiguous.cbFrame, frameLength);
                WRITE_WORD(&pDosBuffer->Contiguous.cbBuffer, dataCopied);
                WRITE_WORD(&pDosBuffer->Contiguous.offUserData, userOffset + bufferOffset);
                WRITE_WORD(&pDosBuffer->Contiguous.cbUserData, UserLength);

                //
                // and get the next one
                //

                bufferOffset = READ_WORD(&pDosBuffer->pNext);
                pDosBuffer = DOS_PTR_TO_FLAT(pDosBuffer->pNext);

                //
                // if we have another DOS buffer, then it is a Next buffer. Get the
                // buffer variables
                //

                if (pDosBuffer) {
                    pDosData = (PBYTE)pDosBuffer + BUFFER_2_SIZE + UserLength;
                    userOffset = (WORD)&(((PLLC_DOS_BUFFER)0)->Next.cbUserData)
                               + sizeof(((PLLC_DOS_BUFFER)0)->Next.cbUserData);

                    //
                    // sanity check
                    //

                    ASSERT(userOffset == 12);

                    //
                    // get new available space (constant)
                    //

                    dataSpace = BufferSize - (BUFFER_2_SIZE + UserLength);
                    dataCopied = 0;

                    IF_DEBUG(DLC_RX_DATA) {
                        DPUT3("CopyFrame: new DOS buffer @%x pDosData @%x dataSpace=%d\n",
                                pDosBuffer, pDosData, dataSpace);
                    }

                } else {

                    //
                    // no more DOS buffers. Is this a partial copy?
                    //

                    DPUT("*** ERROR: dataLeft && no more DOS buffers ***\n");
                    ASSERT(Flags & CF_PARTIAL);
                    break;
                }
            }
        } else {

            //
            // update the current DOS buffer header
            //

            WRITE_WORD(&pDosBuffer->Contiguous.cbFrame, frameLength);
            WRITE_WORD(&pDosBuffer->Contiguous.cbBuffer, dataCopied);
            WRITE_WORD(&pDosBuffer->Contiguous.offUserData, userOffset + bufferOffset);
            WRITE_WORD(&pDosBuffer->Contiguous.cbUserData, UserLength);
        }

    } while ( dataLeft );

    //
    // if CF_PARTIAL set then we knew we were copying a partial frame before
    // we got here
    //

    return (Flags & CF_PARTIAL)
        ? LLC_STATUS_LOST_DATA_INADEQUATE_SPACE
        : LLC_STATUS_SUCCESS;
}


BOOLEAN
AllBuffersInPool(
    IN DWORD PoolIndex
    )

/*++

Routine Description:

    Returns TRUE if all buffers that a pool has held are currently in the pool.

    Once a buffer has been added to a pool, it cannot be removed, saved by not
    returning it to the pool. Hence this function will always return TRUE if
    the app is well-behaved and all buffers that have been placed in the pool
    are currently in the pool

Arguments:

    PoolIndex   - pool id

Return Value:

    BOOLEAN
        TRUE    - all buffers back
        FALSE   - buffer pool currently contains less than full number of buffers

--*/

{
    BOOLEAN result;
    PDOS_DLC_BUFFER_POOL pBufferPool = &aBufferPools[PoolIndex];

    EnterCriticalSection(&BufferSemaphore);
    result = (pBufferPool->BufferCount == pBufferPool->MaximumBufferCount);
    LeaveCriticalSection(&BufferSemaphore);
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\vrdlc5c.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems

Module Name:

    vrdlc5c.c

Abstract:

    This module handles DLC INT 5Ch calls from a VDM

    Contents:
        VrDlc5cHandler
        (ValidateDosAddress)
        (AutoOpenAdapter)
        (ProcessImmediateCommand)
        (MapDosCommandsToNt)
        CompleteCcbProcessing
        (InitializeAdapterSupport)
        (SaveExceptions)
        (RestoreExceptions)
        (CopyDosBuffersToDescriptorArray)
        (BufferCreate)
        (SetExceptionFlags)
        LlcCommand
        (OpenAdapter)
        (CloseAdapter)
        (OpenDirectStation)
        (CloseDirectStation)
        BufferFree
        (VrDlcInit)
        VrVdmWindowInit
        (GetAdapterType)
        (LoadDlcDll)
        TerminateDlcEmulation
        InitializeDlcWorkerThread
        VrDlcWorkerThread
        DlcCallWorker

Author:

    Antti Saarenheimo (o-anttis) 26-DEC-1991

Revision History:

    16-Jul-1992 Richard L Firth (rfirth)
        Rewrote large parts - separated functions into categories (complete
        in DLL, complete in driver, complete asynchronously); allocate NT
        CCBs for commands which complete asynchronously; fixed asynchronous
        processing; added extra debugging; condensed various per-adapter data
        structures into Adapters data structure; made processing closer to IBM
        LAN Tech. Ref. specification

--*/

#include <nt.h>
#include <ntrtl.h>      // ASSERT, DbgPrint
#include <nturtl.h>
#include <windows.h>
#include <softpc.h>     // x86 virtual machine definitions
#include <vrdlctab.h>
#include <vdmredir.h>
#include <smbgtpt.h>
#include <dlcapi.h>     // Official DLC API definition
#include <ntdddlc.h>    // IOCTL commands
#include <dlcio.h>      // Internal IOCTL API interface structures
#include <vrdefld.h>    // VDM_LOAD_INFO
#include "vrdlc.h"
#include "vrdebug.h"
#include "vrdlcdbg.h"

//
// defines
//

//
// for each DLC command, a flags byte in DlcFunctionalCharacteristics uses these
// bits to indicate properties of the command processing
//

#define POINTERS_IN_TABLE   0x01    // pointers in parameter table
#define OUTPUT_PARMS        0x02    // parameters returned from DLC
#define SECONDARY_TABLE     0x04    // parameter table has pointers to secondary table(s)
#define IMMEDIATE_COMMAND   0x20    // command executes without call to DLC DLL
#define SYNCHRONOUS_COMMAND 0x40    // command executes in workstation
#define UNSUPPORTED_COMMAND 0x80    // command is not supported in DOS DLC

//
// macros
//

//
// IS_IMMEDIATE_COMMAND - the following commands are those which complete
// 'immediately' - i.e. without having to submit the CCB to AcsLan or NtAcsLan.
// Immediate commands may read and write the parameter table though
//

#define IS_IMMEDIATE_COMMAND(c) (((c) == LLC_BUFFER_FREE)            || \
                                 ((c) == LLC_BUFFER_GET)             || \
                                 ((c) == LLC_DIR_INTERRUPT)          || \
                                 ((c) == LLC_DIR_MODIFY_OPEN_PARMS)  || \
                                 ((c) == LLC_DIR_RESTORE_OPEN_PARMS) || \
                                 ((c) == LLC_DIR_SET_USER_APPENDAGE)    \
                                 )

//
// private prototypes
//

LLC_STATUS
ValidateDosAddress(
    IN DOS_ADDRESS Address,
    IN WORD Size,
    IN LLC_STATUS ErrorCode
    );

LLC_STATUS
AutoOpenAdapter(
    IN UCHAR AdapterNumber
    );

LLC_STATUS
ProcessImmediateCommand(
    IN UCHAR AdapterNumber,
    IN UCHAR Command,
    IN LLC_DOS_PARMS UNALIGNED * pParms
    );

LLC_STATUS
MapDosCommandsToNt(
    IN PLLC_CCB pDosCcb,
    IN DOS_ADDRESS dpOriginalCcbAddress,
    OUT LLC_DOS_CCB UNALIGNED * pOutputCcb
    );

LLC_STATUS
InitializeAdapterSupport(
    IN UCHAR AdapterNumber,
    IN DOS_DLC_DIRECT_PARMS UNALIGNED * pDirectParms OPTIONAL
    );

VOID
SaveExceptions(
    IN UCHAR AdapterNumber,
    IN LPDWORD pulExceptionFlags
    );

LPDWORD
RestoreExceptions(
    IN UCHAR AdapterNumber
    );

LLC_STATUS
CopyDosBuffersToDescriptorArray(
    IN OUT PLLC_TRANSMIT_DESCRIPTOR pDescriptors,
    IN PLLC_XMIT_BUFFER pDlcBufferQueue,
    IN OUT LPDWORD pIndex
    );

LLC_STATUS
BufferCreate(
    IN UCHAR AdapterNumber,
    IN PVOID pVirtualMemoryBuffer,
    IN DWORD ulVirtualMemorySize,
    IN DWORD ulMinFreeSizeThreshold,
    OUT HANDLE* phBufferPoolHandle
    );

LLC_STATUS
SetExceptionFlags(
    IN UCHAR AdapterNumber,
    IN DWORD ulAdapterCheckFlag,
    IN DWORD ulNetworkStatusFlag,
    IN DWORD ulPcErrorFlag,
    IN DWORD ulSystemActionFlag
    );

LLC_STATUS
OpenAdapter(
    IN UCHAR AdapterNumber
    );

VOID
CloseAdapter(
    IN UCHAR AdapterNumber
    );

LLC_STATUS
OpenDirectStation(
    IN UCHAR AdapterNumber
    );

VOID
CloseDirectStation(
    IN UCHAR AdapterNumber
    );

LLC_STATUS
VrDlcInit(
    VOID
    );

ADAPTER_TYPE
GetAdapterType(
    IN UCHAR AdapterNumber
    );

BOOLEAN
LoadDlcDll(
    VOID
    );

BOOLEAN
InitializeDlcWorkerThread(
    VOID
    );

VOID
VrDlcWorkerThread(
    IN LPVOID Parameters
    );

LLC_STATUS
DlcCallWorker(
    PLLC_CCB pInputCcb,
    PLLC_CCB pOriginalCcb,
    PLLC_CCB pOutputCcb
    );

//
// public data
//

//
// lpVdmWindow is the flat 32-bit address of the VDM_REDIR_DOS_WINDOW structure
// in DOS memory (in the redir TSR)
//

LPVDM_REDIR_DOS_WINDOW lpVdmWindow = 0;

//
// dpVdmWindow is the DOS address (ssssoooo, s=segment, o=offset) of the
// VDM_REDIR_DOS_WINDOW structure in DOS memory (in the redir TSR)
//

DOS_ADDRESS dpVdmWindow = 0;

DWORD OpenedAdapters = 0;

//
// Adapters - for each adapter supported by DOS emulation (maximum 2 adapters -
// primary & secondary) there is a structure which maintains adapter specific
// information - like whether the adapter has been opened, etc.
//

DOS_ADAPTER Adapters[DOS_DLC_MAX_ADAPTERS];

//
// all functions in DLCAPI.DLL are now called indirected through function pointer
// create these typedefs to avoid compiler warnings
//

typedef ACSLAN_STATUS (*ACSLAN_FUNC_PTR)(IN OUT PLLC_CCB, OUT PLLC_CCB*);
ACSLAN_FUNC_PTR lpAcsLan;

typedef LLC_STATUS (*DLC_CALL_DRIVER_FUNC_PTR)(IN UINT, IN UINT, IN PVOID, IN UINT, OUT PVOID, IN UINT);
DLC_CALL_DRIVER_FUNC_PTR lpDlcCallDriver;

typedef LLC_STATUS (*NTACSLAN_FUNC_PTR)(IN PLLC_CCB, IN PVOID, OUT PLLC_CCB, IN HANDLE OPTIONAL);
NTACSLAN_FUNC_PTR lpNtAcsLan;

//
// private data
//

static LLC_EXTENDED_ADAPTER_PARMS DefaultExtendedParms = {
    NULL,                       // hBufferPool
    NULL,                       // pSecurityDescriptor
    LLC_ETHERNET_TYPE_DEFAULT   // LlcEthernetType
};

//
// DlcFunctionCharacteristics - for each DOS DLC command, tells us the size of
// the parameter table to copy and whether there are pointers in the parameter
// table. Segmented 16-bit pointers in the parameter table must be converted to
// flat 32-bit pointers. The Flags byte tells us - at a glance - the following:
//
//  - if this command is supported a) in DOS DLC, b) in our implementation
//  - if this command has parameters
//  - if there are (DOS) pointers in the parameter table
//  - if this command receives output parameters (ie written to parameter table)
//  - if the parameter table has secondary parameter tables (DIR.OPEN.ADAPTER)
//  - if this command is synchronous (ie does not return 0xFF)
//

struct {
    BYTE    ParamSize;  // no parameter tables >255 bytes long
    BYTE    Flags;
} DlcFunctionCharacteristics[] = {
    {0, IMMEDIATE_COMMAND},                         // 0x00, DIR.INTERRUPT
    {
        sizeof(LLC_DIR_MODIFY_OPEN_PARMS),
        IMMEDIATE_COMMAND
    },                                              // 0x01, DIR.MODIFY.OPEN.PARMS
    {0, IMMEDIATE_COMMAND},                         // 0x02, DIR.RESTORE.OPEN.PARMS
    {
        sizeof(LLC_DIR_OPEN_ADAPTER_PARMS),
        SYNCHRONOUS_COMMAND
        | SECONDARY_TABLE
        | OUTPUT_PARMS
        | POINTERS_IN_TABLE
    },                                              // 0x03, DIR.OPEN.ADAPTER
    {0, 0x00},                                      // 0x04, DIR.CLOSE.ADAPTER
    {0, UNSUPPORTED_COMMAND},                       // 0x05, ?
    {0, SYNCHRONOUS_COMMAND},                       // 0x06, DIR.SET.GROUP.ADDRESS
    {0, SYNCHRONOUS_COMMAND},                       // 0x07, DIR.SET.FUNCTIONAL.ADDRESS
    {0, SYNCHRONOUS_COMMAND},                       // 0x08, READ.LOG
    {0, UNSUPPORTED_COMMAND},                       // 0x09, NT: TRANSMIT.FRAME
    {
        sizeof(LLC_TRANSMIT_PARMS),
        POINTERS_IN_TABLE
    },                                              // 0x0a, TRANSMIT.DIR.FRAME
    {
        sizeof(LLC_TRANSMIT_PARMS),
        POINTERS_IN_TABLE
    },                                              // 0x0b, TRANSMIT.I.FRAME
    {0, UNSUPPORTED_COMMAND},                       // 0x0c, ?
    {sizeof(LLC_TRANSMIT_PARMS), POINTERS_IN_TABLE},// 0x0d, TRANSMIT.UI.FRAME
    {sizeof(LLC_TRANSMIT_PARMS), POINTERS_IN_TABLE},// 0x0e, TRANSMIT.XID.CMD
    {sizeof(LLC_TRANSMIT_PARMS), POINTERS_IN_TABLE},// 0x0f, TRANSMIT.XID.RESP.FINAL
    {sizeof(LLC_TRANSMIT_PARMS), POINTERS_IN_TABLE},// 0x10, TRANSMIT.XID.RESP.NOT.FINAL
    {sizeof(LLC_TRANSMIT_PARMS), POINTERS_IN_TABLE},// 0x11, TRANSMIT.TEST.CMD
    {0, UNSUPPORTED_COMMAND},                       // 0x12, ?
    {0, UNSUPPORTED_COMMAND},                       // 0x13, ?
    {0, 0x00},                                      // 0x14, DLC.RESET
    {
        sizeof(LLC_DLC_OPEN_SAP_PARMS),
        SYNCHRONOUS_COMMAND
        | OUTPUT_PARMS
        | POINTERS_IN_TABLE
    },                                              // 0x15, DLC.OPEN.SAP
    {0, 0x00},                                      // 0x16, DLC.CLOSE.SAP
    {0, SYNCHRONOUS_COMMAND},                       // 0x17, DLC_REALLOCATE
    {0, UNSUPPORTED_COMMAND},                       // 0x18, ?
    {
        sizeof(LLC_DLC_OPEN_STATION_PARMS),
        SYNCHRONOUS_COMMAND
        | OUTPUT_PARMS
        | POINTERS_IN_TABLE
    },                                              // 0x19, DLC.OPEN.STATION
    {0, 0x00},                                      // 0x1a, DLC.CLOSE.STATION
    {
        sizeof(LLC_DLC_CONNECT_PARMS),
        POINTERS_IN_TABLE
    },                                              // 0x1b, DLC.CONNECT.STATION
    {
        sizeof(LLC_DLC_MODIFY_PARMS),
        SYNCHRONOUS_COMMAND
        | POINTERS_IN_TABLE
    },                                              // 0x1c, DLC.MODIFY
    {0, SYNCHRONOUS_COMMAND},                       // 0x1d, DLC.FLOW.CONTROL
    {
        sizeof(LLC_DLC_STATISTICS_PARMS),
        SYNCHRONOUS_COMMAND
        | OUTPUT_PARMS
        | POINTERS_IN_TABLE
    },                                              // 0x1e, DLC.STATISTICS
    {0, UNSUPPORTED_COMMAND},                       // 0x1f, ?
    {
        sizeof(LLC_DOS_DIR_INITIALIZE_PARMS),
        SYNCHRONOUS_COMMAND
        | OUTPUT_PARMS
    },                                              // 0x20, DIR.INITIALIZE
    {
        sizeof(DOS_DIR_STATUS_PARMS) - 2,
        SYNCHRONOUS_COMMAND
        | OUTPUT_PARMS
        | POINTERS_IN_TABLE
    },                                              // 0x21, DIR.STATUS
    {0, 0x00},                                      // 0x22, DIR.TIMER.SET
    {0, SYNCHRONOUS_COMMAND},                       // 0x23, DIR.TIMER.CANCEL
    {0, UNSUPPORTED_COMMAND},                       // 0x24, PDT.TRACE.ON / DLC_TRACE_INITIALIZE
    {0, UNSUPPORTED_COMMAND},                       // 0x25, PDT.TRACE.OFF
    {
        sizeof(LLC_BUFFER_GET_PARMS),
        IMMEDIATE_COMMAND
        | OUTPUT_PARMS
    },                                              // 0x26, BUFFER.GET
    {
        sizeof(LLC_BUFFER_FREE_PARMS),
        IMMEDIATE_COMMAND
        | POINTERS_IN_TABLE
    },                                              // 0x27, BUFFER.FREE
    {sizeof(LLC_DOS_RECEIVE_PARMS), OUTPUT_PARMS},  // 0x28, RECEIVE
    {0, SYNCHRONOUS_COMMAND},                       // 0x29, RECEIVE.CANCEL
    {
        sizeof(LLC_DOS_RECEIVE_MODIFY_PARMS),
        SYNCHRONOUS_COMMAND
        | OUTPUT_PARMS
    },                                              // 0x2a, RECEIVE.MODIFY
    {0, UNSUPPORTED_COMMAND},                       // 0x2b, DIR.DEFINE.MIF.ENVIRONMENT
    {0, SYNCHRONOUS_COMMAND},                       // 0x2c, DLC.TIMER.CANCEL.GROUP
    {
        sizeof(LLC_DIR_SET_EFLAG_PARMS),
        IMMEDIATE_COMMAND
    }                                               // 0x2d, DIR.SET.USER.APPENDAGE
};

//
// routines
//


VOID
VrDlc5cHandler(
    VOID
    )

/*++

Routine Description:

    Receives control from the INT 5Ch BOP provided by the DOS redir TSR. The
    DLC calls can be subdivided into the following categories:

        * complete within this translation layer
        * complete synchronously in a call to AcsLan
        * complete asynchronously after calling AcsLan

    The latter type complete when a READ (which we submit when the adapter is
    opened) completes. Control transfers to an ISR in the DOS redir TSR via
    the EventHandlerThread (in vrdlcpst.c)

    The calls can be further subdivided:

        * calls which return parameters in the parameter table
        * calls which do not return parameters in the parameter table

    For the former type of call, we have to copy the parameter table from
    DOS memory and copy the returned parameters back to DOS memory

    With the exception of a few DLC commands, we assume that the parameter
    tables are exactly the same size between DOS and NT, even if the don't
    contain exactly the same information

Arguments:

    None.

Return Value:

    None, LLC_STATUS is return in AL register.

--*/

{
    LLC_CCB ccb;    // should be NT CCB for NtAcsLan
    LLC_PARMS parms;
    LLC_DOS_CCB UNALIGNED * pOutputCcb;
    LLC_DOS_PARMS UNALIGNED * pDosParms;
    DOS_ADDRESS dpOriginalCcbAddress;
    BOOLEAN parmsCopied;
    WORD paramSize;
    LLC_STATUS status;
    UCHAR command;
    UCHAR adapter;
    BYTE functionFlags;

    static BOOLEAN IsDlcDllLoaded = FALSE;

    IF_DEBUG(DLC) {
        DPUT("VrDlc5cHandler entered\n");
    }

    //
    // DLCAPI.DLL is now dynamically loaded
    //

    if (!IsDlcDllLoaded) {
        if (!LoadDlcDll()) {
            setAL(LLC_STATUS_COMMAND_CANCELLED_FAILURE);
            return;
        } else {
            IsDlcDllLoaded = TRUE;
        }
    }

    //
    // dpOriginalCcbAddress is the segmented 16-bit address stored as a DWORD
    // eg. a CCB1 address of 1234:abcd gets stored as 0x1234abcd. This will
    // be used in asynchronous command completion to get back the address of
    // the original DOS CCB
    //

    dpOriginalCcbAddress = (DOS_ADDRESS)MAKE_DWORD(getES(), getBX());

    //
    // pOutputCcb is the flat 32-bit address of the DOS CCB. We can use this
    // to read and write byte fields only (unaligned)
    //

    pOutputCcb = POINTER_FROM_WORDS(getES(), getBX());
    pOutputCcb->uchDlcStatus = (UCHAR)LLC_STATUS_PENDING;

    //
    // zero the CCB_POINTER (pNext) field. CCB1 cannot have chained CCBs on
    // input: this is just for returning (cancelled) pending CCBs. If we don't
    // zero it & the app leaves garbage there, then NtAcsLan can think it is
    // a pointer to a chain of CCBs (CCB2 can be chained), which is bogus
    //

    WRITE_DWORD(&pOutputCcb->pNext, 0);

    IF_DEBUG(CRITICAL) {
        CRITDUMP(("INPUT CCB @%04x:%04x command=%02x\n", getES(), getBX(), pOutputCcb->uchDlcCommand));
    }

    IF_DEBUG(DOS_CCB_IN) {

        //
        // dump the input CCB1 - gives us an opportunity to check out what
        // the DOS app is sending us, even if its garbage
        //

        DUMPCCB(pOutputCcb,
                TRUE,                           // DumpAll
                TRUE,                           // CcbIsInput
                TRUE,                           // IsDos
                HIWORD(dpOriginalCcbAddress),   // segment
                LOWORD(dpOriginalCcbAddress)    // offset
                );
    }

    //
    // first check that the adapter is 0 or 1 - DOS only supports 2 adapters -
    // and check that the request code in the CCB is not off the end of our
    // table. Unsupported requests will be filtered out in the BIG switch
    // statement below
    //

    adapter = pOutputCcb->uchAdapterNumber;
    command = pOutputCcb->uchDlcCommand;

    if (adapter >= DOS_DLC_MAX_ADAPTERS) {

        //
        // adapter is not 0 or 1 - return 0x1D
        //

        status = LLC_STATUS_INVALID_ADAPTER;
        pOutputCcb->uchDlcStatus = (UCHAR)status;
    } else if (command > LAST_ELEMENT(DlcFunctionCharacteristics)) {

        //
        // command is off end of supported list - return 0x01
        //

        status = LLC_STATUS_INVALID_COMMAND;
        pOutputCcb->uchDlcStatus = (UCHAR)status;
    } else {

        //
        // the command is in range. Get the parameter table size and flags from
        // the function characteristics array
        //

        functionFlags = DlcFunctionCharacteristics[command].Flags;
        paramSize = DlcFunctionCharacteristics[command].ParamSize;

        //
        // if we don't support this command, return an error
        //

        status = LLC_STATUS_SUCCESS;
        if (functionFlags & UNSUPPORTED_COMMAND) {
            status = LLC_STATUS_INVALID_COMMAND;
            pOutputCcb->uchDlcStatus = LLC_STATUS_INVALID_COMMAND;
        } else {

            //
            // command is supported. If it has a parameter table, check that
            // the address is in range for 0x1B error check
            //

            if (paramSize) {
                status = ValidateDosAddress((DOS_ADDRESS)(pOutputCcb->u.pParms),
                                            paramSize,
                                            LLC_STATUS_INVALID_PARAMETER_TABLE
                                            );
            }

            //
            // we allow the adapter to be opened as a consequence of another
            // request since DOS apps could assume that the adapter has already
            // been opened (by NetBIOS). If the command is DIR.OPEN.ADAPTER or
            // DIR.CLOSE.ADAPTER then let it go through
            //

            if (status == LLC_STATUS_SUCCESS
            && !Adapters[adapter].IsOpen
            && !(command == LLC_DIR_OPEN_ADAPTER || command == LLC_DIR_CLOSE_ADAPTER)) {
                status = AutoOpenAdapter(adapter);
            } else {
                status = LLC_STATUS_SUCCESS;
            }
        }

        //
        // if we have a valid command, an ok-looking parameter table pointer
        // and an open adapter (or a command which will open or close it) then
        // process the command
        //

        if (status == LLC_STATUS_SUCCESS) {

            //
            // get a 32-bit pointer to the DOS parameter table. This may be
            // an unaligned address!
            //

            pDosParms = READ_FAR_POINTER(&pOutputCcb->u.pParms);

            //
            // the CCB commands are subdivided into those which do not need the
            // CCB to be mapped from DOS memory to NT memory and which complete
            // 'immediately' in this DLL, and those which must be mapped from
            // DOS to NT and which may complete synchronously or asynchronously
            //

            if (functionFlags & IMMEDIATE_COMMAND) {

                IF_DEBUG(DLC) {
                    DPUT("VrDlc5cHandler: request is IMMEDIATE command\n");
                }

                status = ProcessImmediateCommand(adapter, command, pDosParms);

                //
                // the following is safe - it is a single byte write
                //

                pOutputCcb->uchDlcStatus = (char)status;

                //
                // the 'immediate' case is now complete, and control can be
                // returned to the VDM
                //

            } else {

                //
                // the CCB is not one which can be completed immediately. We
                // have to copy (and align) the DOS CCB (and the parameter
                // table, if there is one) into 32-bit address space.
                // Note that since we are going to call AcsLan or NtAcsLan
                // with this CCB then we supply the correct CCB format - 2,
                // not 1 as it was previously. However, handing in a CCB1
                // didn't *seem* to cause any problems (yet)
                //

                RtlCopyMemory(&ccb, pOutputCcb, sizeof(*pOutputCcb));

                //
                // zero the unused fields
                //

                ccb.hCompletionEvent = 0;
                ccb.uchReserved2 = 0;
                ccb.uchReadFlag = 0;
                ccb.usReserved3 = 0;

                parmsCopied = FALSE;
                if (paramSize) {

                    //
                    // if the parameter table contains (segmented) pointers
                    // (which we need to convert to flat-32 bit pointers) OR
                    // the parameter table is not DWORD aligned, copy the whole
                    // parameter table to 32-bit memory . If we need to modify
                    // pointers, do it in the specific case in the switch
                    // statement in MapDosCommandsToNt
                    //
                    // Note: DIR.OPEN.ADAPTER is a special case because its
                    // parameter table just points to 4 other parameter tables.
                    // We take care of this in MapDosCommandsToNt and
                    // CompleteCcbProcessing
                    //

                    if ((functionFlags & POINTERS_IN_TABLE)) {
                        RtlCopyMemory(&parms, pDosParms, paramSize);
                        ccb.u.pParameterTable = &parms;
                        parmsCopied = TRUE;
                    } else {

                        //
                        // didn't need to copy parameter table - leave it in
                        // DOS memory. It is safe to read & write this table
                        //

                        ccb.u.pParameterTable = (PLLC_PARMS)pDosParms;
                    }
                }

                //
                // submit the synchronous/asynchronous CCB for processing
                //

                status = MapDosCommandsToNt(&ccb, dpOriginalCcbAddress, pOutputCcb);
                if (status == STATUS_PENDING) {
                    status = LLC_STATUS_PENDING;
                }

                IF_DEBUG(CRITICAL) {
                    CRITDUMP(("CCB submitted: returns %02x\n", status));
                }

                IF_DEBUG(DLC) {
                    DPUT2("VrDlc5cHandler: MapDosCommandsToNt returns %#x (%d)\n", status, status);
                }

                //
                // if status is not LLC_STATUS_PENDING then the CCB completed
                // synchronously. We can complete the processing here
                //

                if (status != LLC_STATUS_PENDING) {
                    if ((functionFlags & OUTPUT_PARMS) && parmsCopied) {

                        //
                        // if there are no pointers in the parameter table then
                        // we can simply copy the 32-bit parameters to 16-bit
                        // memory. If there are pointers, then they will be in
                        // an incorrect format for DOS. We must update these
                        // parameter tables individually
                        //

                        if (!(functionFlags & POINTERS_IN_TABLE)) {
                            RtlCopyMemory(pDosParms, &parms, paramSize);
                        } else {
                            CompleteCcbProcessing(status, pOutputCcb, &parms);
                        }
                    }

                    //
                    // set the CCB status. It will be marked as PENDING if
                    // LLC_STATUS_PENDING returned from MapDosCommandsToNt
                    //

                    pOutputCcb->uchDlcStatus = (UCHAR)status;
                }
            }
        } else {
            pOutputCcb->uchDlcStatus = (UCHAR)status;
        }
    }

    //
    // return the DLC status in AL
    //

    setAL((UCHAR)status);

#if DBG
    IF_DEBUG(DOS_CCB_OUT) {

        DPUT2("VrDlc5cHandler: returning AL=%02x CCB.RETCODE=%02x\n",
                status,
                pOutputCcb->uchDlcStatus
                );

        //
        // dump the CCB being returned to the DOS app
        //

        DumpCcb(pOutputCcb,
                TRUE,                           // DumpAll
                FALSE,                          // CcbIsInput
                TRUE,                           // IsDos
                HIWORD(dpOriginalCcbAddress),   // segment
                LOWORD(dpOriginalCcbAddress)    // offset
                );
    }

    //
    // make sure (in debug version) that the error code being returned is valid
    // for this particular command. Doesn't necessarily mean the return code is
    // semantically correct, just that it belongs to the set of allowed DLC
    // return codes for the DLC command being processed
    //

    IF_DEBUG(DLC) {
        if (!IsCcbErrorCodeAllowable(pOutputCcb->uchDlcCommand, pOutputCcb->uchDlcStatus)) {
            DPUT2("Returning bad error code: Command=%02x, Retcode=%02x\n",
                    pOutputCcb->uchDlcCommand,
                    pOutputCcb->uchDlcStatus
                    );
            DEBUG_BREAK();
        }
    }
#endif
}


LLC_STATUS
ValidateDosAddress(
    IN DOS_ADDRESS Address,
    IN WORD Size,
    IN LLC_STATUS ErrorCode
    )

/*++

Routine Description:

    IBM DLC performs some checking of pointers - if the address points into
    the IVT or is close enough to the end of a segment that the address would
    wrap then we return an error

    This is a useless test, but we do it for compatibility (just in case an
    app tests for the specific error code). There are a million other addresses
    in DOS memory that need to be checked. The tests in this routine will only
    protect against scribbling over the interrupt vectors, but would allow e.g.
    scribbling over DOS's code segment

Arguments:

    Address     - DOS address to check (ssssoooo, s=segment, o=offset)
    Size        - word size of structure at Address
    ErrorCode   - which error code to return. This function called to validate
                  A) the parameter table pointer, in which case the error code
                  to return is LLC_STATUS_INVALID_PARAMETER_TABLE (0x1B) or
                  B) pointers within the parameter table, in which case the
                  error to return is LLC_STATUS_INVALID_POINTER_IN_CCB (0x1C)

Return Value:

    LLC_STATUS

--*/

{
    //
    // convert segment:offset into 20-bit real-mode linear address
    //

    DWORD linearAddress = HIWORD(Address) * 16 + LOWORD(Address);

    //
    // the Interrupt Vector Table (IVT) in real-mode occupies addresses 0
    // through 400h
    //

    if ((linearAddress < 0x400L) || (((DWORD)LOWORD(Address) + Size) < (DWORD)LOWORD(Address))) {
        return ErrorCode;
    }
    return LLC_STATUS_SUCCESS;
}


LLC_STATUS
AutoOpenAdapter(
    IN UCHAR AdapterNumber
    )

/*++

Routine Description:

    Opens the adapter as a consequence of a request other than DIR.OPEN.ADAPTER

Arguments:

    AdapterNumber - which adapter to open

Return Value:

    LLC_STATUS
        Success - LLC_STATUS_SUCCESS
        Failure -

--*/

{
    LLC_STATUS status;

    //
    // Any DLC command except DIR.OPEN.ADAPTER or DIR.INITIALIZE automatically
    // opens the adapter. There are three reasons to do this:
    //
    //  1. DIR.STATUS command can be issued before DIR.OPEN.ADAPTER in DOS.
    //     In Windows/Nt this is not possible. Therefore, DIR.STATUS should
    //     open the adapter
    //
    //  2. An application may assume that the adapter is always opened
    //     by NetBIOS and that it can't open the adapter itself if it
    //     has already been opened
    //
    //  3. A DOS DLC application may initialize (= hw reset) a closed
    //     adapter before the open and that takes 5 - 10 seconds.
    //

    IF_DEBUG(DLC) {
        DPUT1("AutoOpenAdapter: automatically opening adapter %d\n", AdapterNumber);
    }

    status = OpenAdapter(AdapterNumber);
    if (status == LLC_STATUS_SUCCESS) {

        //
        // initialize the buffer pool for the direct station on this
        // adapter. If this succeeds, open the direct station. If that
        // succeeds, preset the ADAPTER_PARMS and DLC_PARMS structures
        // in the DOS_ADAPTER with default values
        //

        status = InitializeAdapterSupport(AdapterNumber, NULL);
        if (status == LLC_STATUS_SUCCESS) {
            status = OpenDirectStation(AdapterNumber);
            if (status == LLC_STATUS_SUCCESS) {

            }
        }

        if (status != LLC_STATUS_SUCCESS) {

            IF_DEBUG(DLC) {
                DPUT("AutoOpenAdapter: InitializeAdapterSupport failed\n");
            }

        }
    } else {

        IF_DEBUG(DLC) {
            DPUT("AutoOpenAdapter: auto open adapter failed\n");
        }

    }

    return status;
}


LLC_STATUS
ProcessImmediateCommand(
    IN UCHAR AdapterNumber,
    IN UCHAR Command,
    IN LLC_DOS_PARMS UNALIGNED * pParms
    )

/*++

Routine Description:

    Processes CCB requests which complete 'immediately'. An immediate completion
    is one where the CCB does not have to be submitted to the DLC driver. There
    may be other calls to the driver as a consequence of the immediate command,
    but the CCB itself is not submitted. Immediate command completion requires
    the parameter table only. We may return parameters into the DOS parameter
    table

Arguments:

    AdapterNumber   - which adapter to process command for
    Command         - command to process
    pParms          - pointer to parameter table (in DOS memory)

Return Value:

    LLC_STATUS
        Completion status of the 'immediate' command

--*/

{
    LLC_STATUS status;
    WORD cBuffersLeft;
    WORD stationId;
    DPLLC_DOS_BUFFER buffer;

    switch (Command) {
    case LLC_BUFFER_FREE:

        IF_DEBUG(DLC) {
            DPUT("LLC_BUFFER_FREE\n");
        }

        //
        // if the FIRST_BUFFER field is 0:0 then this request returns success
        //

        buffer = (DPLLC_DOS_BUFFER)READ_DWORD(&pParms->BufferFree.pFirstBuffer);
        if (!buffer) {
            status = LLC_STATUS_SUCCESS;
            break;
        }

        //
        // Windows/Nt doesn't need station id for buffer pool operation =>
        // thus the field is reserved
        //

        stationId = READ_WORD(&pParms->BufferFree.usReserved1);
        status = FreeBuffers(GET_POOL_INDEX(AdapterNumber, stationId),
                             buffer,
                             &cBuffersLeft
                             );

        IF_DEBUG(CRITICAL) {
            CRITDUMP(("LLC_BUFFER_FREE: %d\n", status));
        }

        if (status == LLC_STATUS_SUCCESS) {

            //
            // write the number of buffers left to the parameter table using
            // WRITE_WORD macro, since the table may not be aligned on a WORD
            // boundary
            //

            WRITE_WORD(&pParms->BufferFree.cBuffersLeft, cBuffersLeft);

            //
            // p3-4 of the IBM LAN Tech. Ref. states that the FIRST_BUFFER
            // field will be set to zero when the request is completed
            //

            WRITE_DWORD(&pParms->BufferFree.pFirstBuffer, 0);

            //
            // note that a successful BUFFER.FREE has been executed for this
            // adapter
            //

            Adapters[AdapterNumber].BufferFree = TRUE;

            //
            // perform half of the local-busy reset processing. This only has
            // an effect if the link is in emulated local-busy(buffer) state.
            // This is required because we need 2 events to get us out of local
            // busy buffer state - a BUFFER.FREE and a DLC.FLOW.CONTROL command
            // Apps don't always issue these in the correct sequence
            //

            ResetEmulatedLocalBusyState(AdapterNumber, stationId, LLC_BUFFER_FREE);

            //
            // this here because Extra! for Windows gets its state machine in a
            // knot if we go buffer busy too quickly after a flow control
            //

            if (AllBuffersInPool(GET_POOL_INDEX(AdapterNumber, stationId))) {
                ResetEmulatedLocalBusyState(AdapterNumber, stationId, LLC_DLC_FLOW_CONTROL);
            }
        }
        break;

    case LLC_BUFFER_GET:

        IF_DEBUG(DLC) {
            DPUT("LLC_BUFFER_GET\n");
        }

        status = GetBuffers(
                    GET_POOL_INDEX(AdapterNumber, READ_WORD(&pParms->BufferGet.usReserved1)),
                    READ_WORD(&pParms->BufferGet.cBuffersToGet),
                    &buffer,
                    &cBuffersLeft,
                    FALSE,
                    NULL
                    );

        //
        // if GetBuffers fails, buffer is returned as 0
        //

        WRITE_WORD(&pParms->BufferGet.cBuffersLeft, cBuffersLeft);
        WRITE_DWORD(&pParms->BufferGet.pFirstBuffer, buffer);
        break;

    case LLC_DIR_INTERRUPT:

        IF_DEBUG(DLC) {
            DPUT("LLC_DIR_INTERRUPT\n");
        }

        //
        // We may consider, that the adapter is always initialized!
        // I hope, that the apps doesn't use an appendage routine
        // in DIR_INTERRUPT, because it would be very difficult to
        // call from here.
        //

        status = LLC_STATUS_SUCCESS;
        break;

    case LLC_DIR_MODIFY_OPEN_PARMS:

        IF_DEBUG(DLC) {
            DPUT("LLC_DIR_MODIFY_OPEN_PARMS\n");
        }

        //
        // this command is rejected if a BUFFER.FREE has been issued for this
        // adapter or there is a RECEIVE active at the direct interface
        //

        if (Adapters[AdapterNumber].BufferFree || Adapters[AdapterNumber].DirectReceive) {

            //
            // BUGBUG - this can't be correct error code. Check what is
            //          returned by IBM DOS DLC stack
            //

            status = LLC_STATUS_INVALID_COMMAND;
        } else if (Adapters[AdapterNumber].WaitingRestore) {

            //
            // BUGBUG - this can't be correct error code. Check what is
            //          returned by IBM DOS DLC stack
            //

            status = LLC_STATUS_INVALID_COMMAND;
        } else {

            //
            // Create a buffer pool, if there are no buffers in
            // the current one, set the exception flags (or dos appendage
            // routines), if the operation was success
            //

            status = CreateBufferPool(
                        (DWORD)GET_POOL_INDEX(AdapterNumber, 0),
                        (DOS_ADDRESS)READ_DWORD(&pParms->DirModifyOpenParms.dpPoolAddress),
                        READ_WORD(&pParms->DirModifyOpenParms.cPoolBlocks),
                        READ_WORD(&pParms->DirModifyOpenParms.usBufferSize)
                        );

            if (status == LLC_STATUS_SUCCESS) {

                //
                // SaveExceptions uses RtlCopyMemory, so its okay to pass in a possibly
                // unaligned pointer to the exception handlers
                //

                SaveExceptions(AdapterNumber,
                    (LPDWORD)&pParms->DirModifyOpenParms.dpAdapterCheckExit
                    );

                //
                // set the exception handlers as the exception flags in the
                // DLC driver
                //

                status = SetExceptionFlags(
                            AdapterNumber,
                            READ_DWORD(&pParms->DirModifyOpenParms.dpAdapterCheckExit),
                            READ_DWORD(&pParms->DirModifyOpenParms.dpNetworkStatusExit),
                            READ_DWORD(&pParms->DirModifyOpenParms.dpPcErrorExit),
                            0
                            );
            }

            //
            // mark this adapter as waiting for a DIR.RESTORE.OPEN.PARMS before
            // we can process the next DIR.MODIFY.OPEN.PARMS
            //

            if (status == LLC_STATUS_SUCCESS) {
                Adapters[AdapterNumber].WaitingRestore = TRUE;
            }
        }
        break;

    case LLC_DIR_RESTORE_OPEN_PARMS:

        IF_DEBUG(DLC) {
            DPUT("LLC_DIR_RESTORE_OPEN_PARMS\n");
        }

        //
        // if a DIR.MODIFY.OPEN.PARMS has not been successfully processed for
        // this adapter then return an error
        //

        if (!Adapters[AdapterNumber].WaitingRestore) {
            status = LLC_STATUS_INVALID_OPTION;
        } else {

            //
            // Delete the current buffer pool and restore the previous exception
            // handlers
            //

            DeleteBufferPool(GET_POOL_INDEX(AdapterNumber, 0));
            pParms = (PLLC_DOS_PARMS)RestoreExceptions(AdapterNumber);
            status = SetExceptionFlags(
                        AdapterNumber,
                        READ_DWORD(&pParms->DirSetExceptionFlags.ulAdapterCheckFlag),
                        READ_DWORD(&pParms->DirSetExceptionFlags.ulNetworkStatusFlag),
                        READ_DWORD(&pParms->DirSetExceptionFlags.ulPcErrorFlag),
                        0
                        );

            //
            // if the restore succeeded, mark this adapter as able to accept
            // the next DIR.MODIFY.OPEN.PARMS request
            //

            if (status == LLC_STATUS_SUCCESS) {
                Adapters[AdapterNumber].WaitingRestore = FALSE;
            }
        }
        break;

    case LLC_DIR_SET_USER_APPENDAGE:

        IF_DEBUG(DLC) {
            DPUT("LLC_DIR_SET_USER_APPENDAGE\n");
        }

        if (pParms == NULL) {
            pParms = (PLLC_DOS_PARMS)RestoreExceptions(AdapterNumber);
        } else {
            SaveExceptions(AdapterNumber, (LPDWORD)&pParms->DirSetUserAppendage);
        }
        status = SetExceptionFlags(
                    AdapterNumber,
                    READ_DWORD(&pParms->DirSetUserAppendage.dpAdapterCheckExit),
                    READ_DWORD(&pParms->DirSetUserAppendage.dpNetworkStatusExit),
                    READ_DWORD(&pParms->DirSetUserAppendage.dpPcErrorExit),
                    0
                    );
        break;

#if DBG
    default:
        DPUT1("ProcessImmediateCommand: Error: Command is NOT immediate (%x)\n", Command);
        DbgBreakPoint();
#endif

    }

    return status;
}


LLC_STATUS
MapDosCommandsToNt(
    IN PLLC_CCB pDosCcb,
    IN DOS_ADDRESS dpOriginalCcbAddress,
    OUT LLC_DOS_CCB UNALIGNED * pOutputCcb
    )

/*++

Routine Description:

    This function handles DOS CCBs which must be submitted to the DLC driver.
    The CCBs may complete synchronously - i.e. the DLC driver returns a
    success or failure indication, or they complete asyncronously - i.e. the
    DLC driver returns a pending status.

    This function processes CCBs which may have parameter tables. The parameter
    tables will have been mapped to 32-bit memory unless they are already aligned
    on a DWORD boundary

Architecture
------------

    There is a major difference in the adapter initialization between DOS and
    NT (or OS/2) DLC applications.  A DOS DLC application could assume that
    the adapter is always open (opened by NetBIOS).  It might directly check
    the type of adapter with DIR.STATUS command, open SAP stations and setup
    a link session to a host. Usually a DOS app uses DIR.INTERRUPT to check if
    the adapter is already initialized.  There are also commands to redefine
    new parameters for the direct interface and restore the old ones when the
    application completes.  Only one application may be simultaneously using
    the direct station or a SAP.

    In Windows/NT each DLC application is a process having its own separate
    virtual image of the DLC interface. They must first make a logical open for
    the adapter to access DLC services and close the adapter when they are
    terminating. Process exit automatically closes any open DLC objects.

    A Windows/NT MVDM process does not allocate any DLC resources until it
    issues the first DLC command, which opens the adapter and initializes its
    buffer pool.


DLC Commands Different In Windows/NT And DOS
--------------------------------------------

    BUFFER.FREE, BUFFER.GET
     -  separate buffer pools ...

    DIR.DEFINE.MIF.ENVIRONMENT
     -  not supported, a special api for
        IBM Netbios running on DLC.

    DIR.INITIALIZE
     -  We will always return OK status from DIR.INITIALIZE: the app should not
        call this very often. We don't need to care about the exception handlers
        set in DIR.INITIALIZE, because they are never used. DOS DLC and OS/2 DLC
        states can be mapped thus:

            DOS DLC             OS/2 DLC
            ----------------------------
            uninitialized       Closed
            Initialized         Closed
            Open                Open

        DIR.OPEN.ADAPTER defines new exception handlers, thus the values
        set by DIR.INITIALIZE are valid only when the adapter is closed.
        Therefore, nothing untoward can happen if we just ignore them

    DIR.INTERRUPT
     -  This command opens the adapter, if it has not yet been opened
        and returns the successful status.

    DIR.MODIFY.OPEN.PARMS
     -  Defines buffers pool for the direct station, if it was not defined
        in DIR.OPEN.ADAPTER, and defines DLC exception handlers.

    DIR.OPEN.ADAPTER
     -  Can be executed only immediately after DIR.CLOSE.ADAPTER
        and DIR.INITIALIZE. We must support the special DOS Direct Open Parms.

    DIR.OPEN.DIRECT, DIR.CLOSE.DIRECT
     -  Not supported for DOS

    DIR.SET.USER.APPENDAGE == DIR.SET.EXCEPTION.FLAGS (- system action flag)
     -  This is just one of those many functions to set the exception handlers
        for DOS DLC (you may set them when adapter is opened, you may set
        them when adapter is closed, you may restore the old values and
        set the new values if the buffer pool was uninitialized or if they
        were restored ... (I become crazy)

    DIR.STATUS
     -  (We must fill MicroCodeLevel with a sensible string and set
        AdapterConfigAddress to point a some constant code in DOS
        DLC handler) Not yet implemented!!!
     -  DOS DLC stub code should hook the timer tick interrupt and
        update the timer counter.
     -  We must also set the correct adapter data rate in AdapterConfig
        (this should be done by the DLC driver!).
     -  We must convert the Nt (and OS/2) adapter type to a DOS type
        (ethernet have a different value in IBM DOS and OS/2 DLC
        implementations)

    PDT.TRACE.ON, PDT.TRACE.OFF
     -  Not Supported

    RECEIVE.MODIFY
     -  This function is not supported in the first implementation,
        Richard may have to do this later, if a DOS DLC application
        uses the function.

    RECEIVE
     -  DOS uses shorter RECEIVE parameter table, than NT (or OS/2).
        Thus we cannot directly use DOS CCBs.  We also need the pointer
        of the original receive CCB and the DOS receive appendage is called.
        On the other hand, the only original CCB can be linked to the
        other CCBs (using the original DOS pointer).
        Solution:
        The Input CCB and its parameter table are always allocated from the
        stack. Output CCB is the original DOS CCB mapped to 32-bit address space.
        The receive flag in the input CCB parameter table is the output CCB
        pointer.  The actual receive data appendage can be read from
        the output CCB. DOS DLC driver completes and links the receive CCB
        correctly, because we use the original receive CCB as an output buffer
        and DOS CCB address.
        This method would not work if we had to receive any parameters
        to the parameter table (actually we could get it to work by
        calling directly DLC driver with a correct parameter table address
        in the CCB structure of the input parameter block. The actual
        input parameters would be modified (receive data appendage)).


Adapter Exception Handlers
--------------------------

    The exception handler setting and resetting is very confusing in DOS DLC,
    but the main idea seems to be this: a temporary DOS DLC application must
    restore the exception handlers set by a TSR, because otherwise the next
    network exception would call the random memory.  On the other hand, a newer
    TSR may always overwrite the previous exception handlers (because it never
    restores the old values).  We may assume, that any DOS DLC application
    process resets its exception handlers and restores the original addresses.
    Solution: we have two tables, both initially reset: any set operation
    copies first table 1 to table 2 and saves the new values back to table 1.
    A restore operation copies table 2 back to table 1 and sets its values to DLC.
    We don't make any difference between set/reset by DIR.SET.USER.APPENDAGE or
    doing the same operation with DIR.MODIFY.OPEN.PARMS and DIR.RESTORE.OPEN.PARMS.
    We don't try to save the buffer pool definitions, because it is unnecessary.


DLC Status
----------

    A DOS DLC status indication returns a pointer to a link specific DLC
    status table.  DOS DLC application may keep this pointer and use it
    later for example to find the remote node address and SAP (not very likely).
    On the other hand, the link may expect the status table to be stable
    until another DOS task (eg. from timer tick) has responded to it.
    If we used only one status table for all links, a new overwrite the old
    status, because it has been handled by DOS.
    For example, losing a local buffer busy indication would hang up the link
    station permamently. Thus we cannot use just one link status table.
    Allocating 20 bytes for each 2 * 255 link station would take 10 kB
    DOS memory.  Limiting the number of available link stations would
    be also too painful to implement and manage by installation program.
    Thus we will implement a compromise:
        1. We allocate 5 permanent DLC status tables for the first link stations
           on both adapters.
        2. All other link stations (on both adapters) share the last
           5 status tables

    => We need to allocate only 300 bytes DOS memory for the DLC status tables.
    This will not work, if a DOS application assumes having permanent pointers
    to status tables and uses more than 5 DLC sessions for an adapter or
    if an application has again over 5 link stations on an adapter and
    it gets very rapidily more than 5 DLC status indications (it may lose
    the first DLC indications).

    Actually this should work quite well, because DLC applications should
    save (by copying) the DLC status in the DLC status appendage routine,
    because a new DLC status indication for the same adapter could overwrite
    the previous status.

Arguments:

    pDosCcb             - aligned DOS DLC Command control block (NT CCB)
    dpOriginalCcbAddress- the original
    pOutputCcb          - the original DLC Command control block

Return Value:

    LLC_STATUS

--*/

{
    UCHAR adapter = pDosCcb->uchAdapterNumber;
    UCHAR command = pDosCcb->uchDlcCommand;
    DWORD InputBufferSize;
    UCHAR FrameType;
    DWORD cElement;
    DWORD i;
    PLLC_CCB pNewCcb;
    LLC_STATUS Status;
    NT_DLC_PARMS NtDlcParms;
    LLC_DOS_PARMS UNALIGNED * pParms = (PLLC_DOS_PARMS)pDosCcb->u.pParameterTable;
    PDOS_DLC_DIRECT_PARMS pDirectParms = NULL;
    PLLC_PARMS pNtParms;

    //
    // adapterOpenParms and dlcParms are used to take the place of the DOS
    // ADAPTER_PARMS and DLC_PARMS structures in DIR.OPEN.ADAPTER
    //

    LLC_ADAPTER_OPEN_PARMS adapterParms;
    LLC_DLC_PARMS dlcParms;
    DWORD groupAddress = 0;
    DWORD functionalAddress = 0;

    IF_DEBUG(DLC) {
        DPUT("MapDosCommandsToNt\n");
    }

    //
    // check that the command code in the CCB is a valid CCB1 command - this
    // will error if its one of the disallowed OS/2 (CCB2) commands or an
    // unsupported DOS (CCB1) command (eg PDT.TRACE.ON)
    //

    CHECK_CCB_COMMAND(pDosCcb);

    //
    // preset the CCB to PENDING
    //

    pOutputCcb->uchDlcStatus = (UCHAR)LLC_STATUS_PENDING;

    //
    // This large switch statement will convert individual DOS format parameter
    // tables to NT format. Functions that can be handled entirely in VdmRedir
    // return early, else we need to make a call into DlcApi (AcsLan or NtAcsLan)
    //
    // We must convert all 16:16 DOS pointers to flat 32-bit pointers.
    // We must copy all changed data structures (that includes pointers)
    // to stack, because we don't want to change them back, when
    // the command completes.  All transmit commands are changed to
    // the new generic transmit.
    //

    switch (command) {
    default:

        IF_DEBUG(DLC) {
            DPUT("*** Shouldn't be here - this command should be caught already ***\n");
        }

        return LLC_STATUS_INVALID_COMMAND;

    //
    // *** everything below here has been sanctioned ***
    //

    case LLC_DIR_CLOSE_ADAPTER:

        IF_DEBUG(DLC) {
            DPUT("LLC_DIR_CLOSE_ADAPTER\n");
        }

        //
        // no parameter table
        //

        break;

    case LLC_DIR_INITIALIZE:

        IF_DEBUG(DLC) {
            DPUT("LLC_DIR_INITIALIZE\n");
        }

        break;

    case LLC_DIR_OPEN_ADAPTER:

        IF_DEBUG(DLC) {
            DPUT("LLC_DIR_OPEN_ADAPTER\n");
        }

        //
        // copy the adapter parms and DLC parms to 32-bit memory. If there is no
        // adapter parms or direct parms pointer then return an error
        //

        if (!(pParms->DirOpenAdapter.pAdapterParms && pParms->DirOpenAdapter.pExtendedParms)) {
            return LLC_STATUS_PARAMETER_MISSING;
        }

        //
        // copy the DOS ADAPTER_PARMS table to an NT ADAPTER_PARMS table. The
        // NT table is larger, so zero the uncopied part
        //

        RtlCopyMemory(&adapterParms,
                      DOS_PTR_TO_FLAT(pParms->DirOpenAdapter.pAdapterParms),
                      sizeof(ADAPTER_PARMS)
                      );
        RtlZeroMemory(&adapterParms.usReserved3[0],
                      sizeof(LLC_ADAPTER_OPEN_PARMS) - (DWORD)&((PLLC_ADAPTER_OPEN_PARMS)0)->usReserved3
                      );
        pParms->DirOpenAdapter.pAdapterParms = &adapterParms;

        //
        // make a note of the group and functional addresses. We have to set
        // these later if they're not 0x00000000. We have to save these, because
        // the addresses in the table will get blasted when DIR.OPEN.ADAPTER
        // (in DLCAPI.DLL/DLC.SYS) writes the current (0) values to the table
        //

        groupAddress = *(UNALIGNED DWORD *)adapterParms.auchGroupAddress;
        functionalAddress = *(UNALIGNED DWORD *)adapterParms.auchFunctionalAddress;

        //
        // the DLC_PARMS table doesn't HAVE to be supplied - if we just want to
        // use the direct station, we don't need these parameters. However, if
        // they were supplied, copy them to 32-bit memory. The tables are the
        // same size in DOS and NT
        //

        if (pParms->DirOpenAdapter.pDlcParms) {
            RtlCopyMemory(&dlcParms,
                          DOS_PTR_TO_FLAT(pParms->DirOpenAdapter.pDlcParms),
                          sizeof(dlcParms)
                          );
            pParms->DirOpenAdapter.pDlcParms = &dlcParms;
        }

        //
        // set the default values for ADAPTER_PARMS. Not sure about these
        //
        //  usReserved1 == NUMBER_RCV_BUFFERS
        //  usReserved2 == RCV_BUFFER_LEN
        //  usMaxFrameSize == DHB_BUFFER_LENGTH
        //  usReserved3[0] == DATA_HOLD_BUFFERS
        //

        if (pParms->DirOpenAdapter.pAdapterParms->usReserved1 < 2) {
            pParms->DirOpenAdapter.pAdapterParms->usReserved1 = DD_NUMBER_RCV_BUFFERS;
        }
        if (pParms->DirOpenAdapter.pAdapterParms->usReserved2 == 0) {
            pParms->DirOpenAdapter.pAdapterParms->usReserved2 = DD_RCV_BUFFER_LENGTH;
        }
        if (pParms->DirOpenAdapter.pAdapterParms->usMaxFrameSize == 0) {
            pParms->DirOpenAdapter.pAdapterParms->usReserved1 = DD_DHB_BUFFER_LENGTH;
        }
        if (*(PBYTE)&pParms->DirOpenAdapter.pAdapterParms->usReserved3 == 0) {
            pParms->DirOpenAdapter.pAdapterParms->usReserved1 = DD_DATA_HOLD_BUFFERS;
        }

        //
        // if we have DLC_PARMS then set the defaults, else reset the flag
        //

        if (pParms->DirOpenAdapter.pDlcParms) {
            if (pParms->DirOpenAdapter.pDlcParms->uchDlcMaxSaps == 0) {
                pParms->DirOpenAdapter.pDlcParms->uchDlcMaxSaps = DD_DLC_MAX_SAP;
            }
            if (pParms->DirOpenAdapter.pDlcParms->uchDlcMaxStations == 0) {
                pParms->DirOpenAdapter.pDlcParms->uchDlcMaxStations = DD_DLC_MAX_STATIONS;
            }
            if (pParms->DirOpenAdapter.pDlcParms->uchDlcMaxGroupSaps == 0) {
                pParms->DirOpenAdapter.pDlcParms->uchDlcMaxGroupSaps = DD_DLC_MAX_GSAP;
            }
            if (pParms->DirOpenAdapter.pDlcParms->uchT1_TickOne == 0) {
                pParms->DirOpenAdapter.pDlcParms->uchT1_TickOne = DD_DLC_T1_TICK_ONE;
            }
            if (pParms->DirOpenAdapter.pDlcParms->uchT2_TickOne == 0) {
                pParms->DirOpenAdapter.pDlcParms->uchT2_TickOne = DD_DLC_T2_TICK_ONE;
            }
            if (pParms->DirOpenAdapter.pDlcParms->uchTi_TickOne == 0) {
                pParms->DirOpenAdapter.pDlcParms->uchTi_TickOne = DD_DLC_Ti_TICK_ONE;
            }
            if (pParms->DirOpenAdapter.pDlcParms->uchT1_TickTwo == 0) {
                pParms->DirOpenAdapter.pDlcParms->uchT1_TickTwo = DD_DLC_T1_TICK_TWO;
            }
            if (pParms->DirOpenAdapter.pDlcParms->uchT2_TickTwo == 0) {
                pParms->DirOpenAdapter.pDlcParms->uchT2_TickTwo = DD_DLC_T2_TICK_TWO;
            }
            if (pParms->DirOpenAdapter.pDlcParms->uchTi_TickTwo == 0) {
                pParms->DirOpenAdapter.pDlcParms->uchTi_TickTwo = DD_DLC_Ti_TICK_TWO;
            }
            Adapters[adapter].DlcSpecified = TRUE;
        } else {
            Adapters[adapter].DlcSpecified = FALSE;
        }

        //
        // replace DIRECT_PARMS with the EXTENDED_ADAPTER_PARMS
        //

        pDirectParms = (PDOS_DLC_DIRECT_PARMS)
                       READ_FAR_POINTER(&pParms->DirOpenAdapter.pExtendedParms);
        pParms->DirOpenAdapter.pExtendedParms = &DefaultExtendedParms;
        break;

    case LLC_DIR_READ_LOG:

        IF_DEBUG(DLC) {
            DPUT("LLC_DIR_READ_LOG\n");
        }

        pParms->DirReadLog.pLogBuffer = DOS_PTR_TO_FLAT(pParms->DirReadLog.pLogBuffer);
        break;

    case LLC_DIR_SET_FUNCTIONAL_ADDRESS:

        IF_DEBUG(DLC) {
            DPUT("LLC_DIR_SET_FUNCTIONAL_ADDRESS\n");
        }

        //
        // no parameter table
        //

        break;

    case LLC_DIR_SET_GROUP_ADDRESS:

        IF_DEBUG(DLC) {
            DPUT("LLC_DIR_SET_GROUP_ADDRESS\n");
        }

        //
        // no parameter table
        //

        break;

    case LLC_DIR_STATUS:

        IF_DEBUG(DLC) {
            DPUT("LLC_DIR_STATUS\n");
        }

        break;

    case LLC_DIR_TIMER_CANCEL:

        IF_DEBUG(DLC) {
            DPUT("LLC_DIR_TIMER_CANCEL\n");
        }

        //
        // no parameter table
        //

        break;

    case LLC_DIR_TIMER_CANCEL_GROUP:

        IF_DEBUG(DLC) {
            DPUT("LLC_DIR_TIMER_CANCEL_GROUP\n");
        }

        //
        // no parameter table
        //

        break;

    case LLC_DIR_TIMER_SET:

        IF_DEBUG(DLC) {
            DPUT("LLC_DIR_TIMER_SET\n");
        }

        //
        // no parameter table
        //

        //
        // Debug code is too slow - commands keep timing out. Multiply the
        // timer value by 2 to give us a chance!
        //

        IF_DEBUG(DOUBLE_TICKS) {
            pDosCcb->u.dir.usParameter0 *= 2;
        }

        break;

    case LLC_DLC_CLOSE_SAP:

        IF_DEBUG(DLC) {
            DPUT("LLC_DLC_CLOSE_SAP\n");
        }

        //
        // no parameter table
        //

        break;

    case LLC_DLC_CLOSE_STATION:

        IF_DEBUG(DLC) {
            DPUT("LLC_DLC_CLOSE_STATION\n");
        }

        //
        // no parameter table
        //

        break;

    case LLC_DLC_CONNECT_STATION:

        IF_DEBUG(DLC) {
            DPUT("LLC_DLC_CONNECT_STATION\n");
        }

        pParms->DlcConnectStation.pRoutingInfo = DOS_PTR_TO_FLAT(pParms->DlcConnectStation.pRoutingInfo);
        break;

    case LLC_DLC_FLOW_CONTROL:

        IF_DEBUG(DLC) {
            DPUT("LLC_DLC_FLOW_CONTROL\n");
        }

        //
        // if we are resetting the local-busy(buffer) state then we clear the
        // emulated state. When all deferred I-Frames are indicated to the app
        // the real local-busy(buffer) state will be reset in the driver
        //
        // If we don't think the indicated link station is in emulated local
        // busy(buffer) state then let the driver handle the request. If we
        // reset the emulated state then return success
        //

        if ((LOBYTE(pDosCcb->u.dlc.usParameter) & LLC_RESET_LOCAL_BUSY_BUFFER) == LLC_RESET_LOCAL_BUSY_BUFFER) {
            if (ResetEmulatedLocalBusyState(adapter, pDosCcb->u.dlc.usStationId, LLC_DLC_FLOW_CONTROL)) {
                return LLC_STATUS_SUCCESS;
            } else {

                IF_DEBUG(DLC) {
                    DPUT2("MapDosCommandsToNt: ERROR: Adapter %d StationId %04x not in local-busy(buffer) state\n",
                          adapter,
                          pDosCcb->u.dlc.usStationId
                          );
                }

                return LLC_STATUS_SUCCESS;
            }
        }

        //
        // let AcsLan/driver handle any other type of flow control request
        //

        break;

    case LLC_DLC_MODIFY:

        IF_DEBUG(DLC) {
            DPUT("LLC_DLC_MODIFY\n");
        }

        pParms->DlcModify.pGroupList = DOS_PTR_TO_FLAT(pParms->DlcModify.pGroupList);
        break;

    case LLC_DLC_OPEN_SAP:

        IF_DEBUG(DLC) {
            DPUT("LLC_DLC_OPEN_SAP\n");
        }

        //
        // convert segmented group list pointer to flat-32
        //

        pParms->DlcOpenSap.pGroupList = DOS_PTR_TO_FLAT(pParms->DlcOpenSap.pGroupList);

        //
        // Initialize the DOS DLC buffer pool for the SAP station. If this fails
        // return error immediately else call the NT driver to create the SAP
        // proper. If that fails, then the buffer pool created here will be
        // destroyed
        //

        Status = CreateBufferPool(
                    POOL_INDEX_FROM_SAP(pParms->DosDlcOpenSap.uchSapValue, adapter),
                    pParms->DosDlcOpenSap.dpPoolAddress,
                    pParms->DosDlcOpenSap.cPoolBlocks,
                    pParms->DosDlcOpenSap.usBufferSize
                    );
        if (Status != LLC_STATUS_SUCCESS) {

            IF_DEBUG(DLC) {
                DPUT1("MapDosCommandsToNt: Couldn't create buffer pool for DLC.OPEN.SAP (%x)\n", Status);
            }

            return Status;
        }

        //
        // trim the timer parameters to the range expected by the DLC driver
        //

        if (pParms->DlcOpenSap.uchT1 > 10) {
            pParms->DlcOpenSap.uchT1 = 10;
        }
        if (pParms->DlcOpenSap.uchT2 > 10) {
            pParms->DlcOpenSap.uchT2 = 10;
        }
        if (pParms->DlcOpenSap.uchTi > 10) {
            pParms->DlcOpenSap.uchTi = 10;
        }
        break;

    case LLC_DLC_OPEN_STATION:

        IF_DEBUG(DLC) {
            DPUT("LLC_DLC_OPEN_STATION\n");
        }

        pParms->DlcOpenStation.pRemoteNodeAddress = DOS_PTR_TO_FLAT(pParms->DlcOpenStation.pRemoteNodeAddress);
        break;

    case LLC_DLC_REALLOCATE_STATIONS:

        IF_DEBUG(DLC) {
            DPUT("LLC_DLC_REALLOCATE_STATIONS\n");
        }

        break;

    case LLC_DLC_RESET:

        IF_DEBUG(DLC) {
            DPUT("LLC_DLC_RESET\n");
        }

        //
        // no parameter table
        //

        break;

    case LLC_DLC_STATISTICS:

        IF_DEBUG(DLC) {
            DPUT("LLC_DLC_STATISTICS\n");
        }

        pParms->DlcStatistics.pLogBuf = DOS_PTR_TO_FLAT(pParms->DlcStatistics.pLogBuf);
        break;


    //
    // RECEIVE processing
    //

    case LLC_RECEIVE:

        IF_DEBUG(DLC) {
            DPUT("LLC_RECEIVE\n");
        }

        //
        // we have to replace the DOS RECEIVE with an NT RECEIVE for 2 reasons:
        // (i) NT assumes an NT RECEIVE parameter table which is longer than
        // the DOS RECEIVE parameter table: if we send the DOS pointers through
        // NT may write RECEIVE parameter information where we don't want it;
        // (ii) NT will complete the RECEIVE with NT buffers which we need to
        // convert to DOS buffers anyway in the event completion processing
        //
        // NOTE: we no longer chain receive frames on the SAP since this doesn't
        // really improve performance because we generate the same number of VDM
        // interrupts if we don't chain frames, and it just serves to complicate
        // completion event processing
        //

        pNewCcb = (PLLC_CCB)LocalAlloc(LMEM_FIXED,
                                       sizeof(LLC_CCB)
                                       + sizeof(LLC_DOS_RECEIVE_PARMS_EX)
                                       );
        if (pNewCcb == NULL) {
            return LLC_STATUS_NO_MEMORY;
        } else {

            IF_DEBUG(DLC) {
                DPUT1("VrDlc5cHandler: allocated Extended RECEIVE+parms @ %08x\n", pNewCcb);
            }

        }
        RtlCopyMemory(pNewCcb, pDosCcb, sizeof(LLC_DOS_CCB));
        RtlCopyMemory((PVOID)(pNewCcb + 1), (PVOID)pParms, sizeof(LLC_DOS_RECEIVE_PARMS));
        pNewCcb->hCompletionEvent = NULL;
        pNewCcb->uchReserved2 = 0;
        pNewCcb->uchReadFlag = 0;
        pNewCcb->usReserved3 = 0;
        pDosCcb = pNewCcb;
        pNtParms = (PLLC_PARMS)(pNewCcb + 1);
        pDosCcb->u.pParameterTable = pNtParms;
        ((PLLC_DOS_RECEIVE_PARMS_EX)pNtParms)->dpOriginalCcbAddress = dpOriginalCcbAddress;
        ((PLLC_DOS_RECEIVE_PARMS_EX)pNtParms)->dpCompletionFlag = 0;
        dpOriginalCcbAddress = (DOS_ADDRESS)pOutputCcb = (DOS_ADDRESS)pDosCcb;

        //
        // point the notification flag at the extended RECEIVE CCB. This is how
        // we get back to the extended RECEIVE CCB when a READ completes with a
        // receive event. From this CCB pointer, we can find our way to the
        // extended parameter table and from there the original DOS CCB address
        // and from there the original DOS RECEIVE parameter table
        //

        pNtParms->Receive.ulReceiveFlag = (DWORD)dpOriginalCcbAddress;

        //
        // uchRcvReadOption of 0x00 means DO NOT chain received frames. DOS DLC
        // cannot handle more than 1 frame at a time
        //

        pNtParms->Receive.uchRcvReadOption = 0;

        //
        // indicate, using LLC_DOS_SPECIAL_COMMAND as the completion flags, that
        // this RECEIVE CCB & parameter table were allocated on behalf of the
        // VDM, in this emulator, and should be freed when the command completes.
        // This also indicates that the parameter table is the extended receive
        // parameter table and as such contains the address of the original DOS
        // CCB which we must complete with the same information which completes
        // the NT RECEIVE we are about to submit
        //

        pNewCcb->ulCompletionFlag = LLC_DOS_SPECIAL_COMMAND;

#if DBG

        //
        // clear out the first-buffer field to stop the debug code displaying
        // a ton of garbage if the field is left uninitialized
        //

        WRITE_DWORD(&pOutputCcb->u.pParms->DosReceive.pFirstBuffer, 0);
        pNtParms->Receive.pFirstBuffer = NULL;
#endif

        break;

    case LLC_RECEIVE_CANCEL:

        IF_DEBUG(DLC) {
            DPUT("LLC_RECEIVE_CANCEL\n");
        }

        break;

    case LLC_RECEIVE_MODIFY:

        IF_DEBUG(DLC) {
            DPUT("LLC_RECEIVE_MODIFY\n");
        }

        break;


    //
    // TRANSMIT processing. All transmit commands (7 flavours) are collapsed
    // into the new TRANSMIT command
    //

    case LLC_TRANSMIT_DIR_FRAME:

        IF_DEBUG(DLC) {
            DPUT("LLC_TRANSMIT_DIR_FRAME\n");
        }

        FrameType = LLC_DIRECT_TRANSMIT;
        goto TransmitHandling;

    case LLC_TRANSMIT_I_FRAME:

        IF_DEBUG(DLC) {
            DPUT("LLC_TRANSMIT_I_FRAME\n");
        }

        FrameType = LLC_I_FRAME;
        goto TransmitHandling;

    case LLC_TRANSMIT_TEST_CMD:

        IF_DEBUG(DLC) {
            DPUT("LLC_TRANSMIT_TEST_CMD\n");
        }

        FrameType = LLC_TEST_COMMAND_POLL;
        goto TransmitHandling;

    case LLC_TRANSMIT_UI_FRAME:

        IF_DEBUG(DLC) {
            DPUT("LLC_TRANSMIT_UI_FRAME\n");
        }

        FrameType = LLC_UI_FRAME;
        goto TransmitHandling;

    case LLC_TRANSMIT_XID_CMD:

        IF_DEBUG(DLC) {
            DPUT("LLC_TRANSMIT_XID_CMD\n");
        }

        FrameType = LLC_XID_COMMAND_POLL;
        goto TransmitHandling;

    case LLC_TRANSMIT_XID_RESP_FINAL:

        IF_DEBUG(DLC) {
            DPUT("LLC_TRANSMIT_XID_RESP_FINAL\n");
        }

        FrameType = LLC_XID_RESPONSE_FINAL;
        goto TransmitHandling;

    case LLC_TRANSMIT_XID_RESP_NOT_FINAL:

        IF_DEBUG(DLC) {
            DPUT("LLC_TRANSMIT_XID_RESP_NOT_FINAL\n");
        }

        FrameType = LLC_XID_RESPONSE_NOT_FINAL;

TransmitHandling:

        //
        // Copy the DOS CCB to the input buffer, save the original DOS address
        // of the CCB and fix the parameter table address (to a flat address)
        // Copy the link list headers to the descriptor array and build NT CCB
        //

        WRITE_DWORD(&pOutputCcb->pNext, dpOriginalCcbAddress);
        RtlCopyMemory((PCHAR)&NtDlcParms.Async.Ccb, (PCHAR)pOutputCcb, sizeof(NT_DLC_CCB));
        NtDlcParms.Async.Ccb.u.pParameterTable = DOS_PTR_TO_FLAT(NtDlcParms.Async.Ccb.u.pParameterTable);
        NtDlcParms.Async.Parms.Transmit.StationId = pParms->Transmit.usStationId;
        NtDlcParms.Async.Parms.Transmit.RemoteSap = pParms->Transmit.uchRemoteSap;
        NtDlcParms.Async.Parms.Transmit.XmitReadOption = LLC_CHAIN_XMIT_COMMANDS_ON_SAP;
        NtDlcParms.Async.Parms.Transmit.FrameType = FrameType;

        cElement = 0;

        if (pParms->Transmit.pXmitQueue1) {
            Status = CopyDosBuffersToDescriptorArray(
                        NtDlcParms.Async.Parms.Transmit.XmitBuffer,
                        (PLLC_XMIT_BUFFER)pParms->Transmit.pXmitQueue1,
                        &cElement
                        );
            if (Status != LLC_STATUS_SUCCESS) {
                return Status;
            }
        }

        if (pParms->Transmit.pXmitQueue2) {
            Status = CopyDosBuffersToDescriptorArray(
                        NtDlcParms.Async.Parms.Transmit.XmitBuffer,
                        (PLLC_XMIT_BUFFER)pParms->Transmit.pXmitQueue2,
                        &cElement
                        );
            if (Status != LLC_STATUS_SUCCESS) {
                return Status;
            }
        }

        if (pParms->Transmit.cbBuffer1) {
            if (cElement == MAX_TRANSMIT_SEGMENTS) {
                return LLC_STATUS_TRANSMIT_ERROR;
            }

            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].pBuffer = DOS_PTR_TO_FLAT(pParms->Transmit.pBuffer1);
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].cbBuffer = pParms->Transmit.cbBuffer1;
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].boolFreeBuffer = FALSE;
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].eSegmentType = LLC_NEXT_DATA_SEGMENT;
            cElement++;
        }

        if (pParms->Transmit.cbBuffer2) {
            if (cElement == MAX_TRANSMIT_SEGMENTS) {
                return LLC_STATUS_TRANSMIT_ERROR;
            }

            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].cbBuffer = pParms->Transmit.cbBuffer2;
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].pBuffer = DOS_PTR_TO_FLAT(pParms->Transmit.pBuffer2);
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].boolFreeBuffer = FALSE;
            NtDlcParms.Async.Parms.Transmit.XmitBuffer[cElement].eSegmentType = LLC_NEXT_DATA_SEGMENT;
            cElement++;
        }

        NtDlcParms.Async.Parms.Transmit.XmitBuffer[0].eSegmentType = LLC_FIRST_DATA_SEGMENT;
        NtDlcParms.Async.Parms.Transmit.XmitBufferCount = cElement;

        InputBufferSize = sizeof(LLC_TRANSMIT_DESCRIPTOR) * cElement
                        + sizeof(NT_DLC_TRANSMIT_PARMS)
                        + sizeof(NT_DLC_CCB)
                        - sizeof(LLC_TRANSMIT_DESCRIPTOR);

        //
        // We don't need return FrameCopied status, when sending
        // I-frames.  We save an extra memory locking, when we use
        // TRANSMIT2 with the I- frames.
        //

        return lpDlcCallDriver((DWORD)adapter,
                               //(FrameType == LLC_I_FRAME)
                               // ? IOCTL_DLC_TRANSMIT2
                               // : IOCTL_DLC_TRANSMIT,
                               IOCTL_DLC_TRANSMIT,
                               &NtDlcParms,
                               InputBufferSize,
                               pOutputCcb,
                               sizeof(NT_DLC_CCB_OUTPUT)
                               );
    }

    //
    // Call the common DLC API entry point for DOS and Windows/Nt
    //

    Status = DlcCallWorker((PLLC_CCB)pDosCcb,    // aligned input CCB pointer
                           (PLLC_CCB)dpOriginalCcbAddress,
                           (PLLC_CCB)pOutputCcb  // possibly unaligned output CCB pointer
                           );

    IF_DEBUG(DLC) {
        DPUT2("MapDosCommandsToNt: NtAcsLan returns %#x (%d)\n", Status, Status);
    }

    switch (pDosCcb->uchDlcCommand) {
    case LLC_DIR_CLOSE_ADAPTER:
    case LLC_DIR_INITIALIZE:
        OpenedAdapters--;

        //
        // NtAcsLan converts DIR.INITIALIZE to DIR.CLOSE.ADAPTER. The former
        // completes "in the workstation", whereas the latter completes
        // asynchronously. Interpret LLC_STATUS_PENDING as LLC_STATUS_SUCCESS
        // in this case, otherwise we may not fully uninitialize the adapter
        //

        if (Status == LLC_STATUS_SUCCESS || Status == LLC_STATUS_PENDING) {

            //
            // We may free all virtual memory in NT buffer pool
            //

            Adapters[adapter].IsOpen = FALSE;
            LocalFree(Adapters[adapter].BufferPool);

            IF_DEBUG(DLC_ALLOC) {
                DPUT1("FREE: freed block @ %x\n", Adapters[adapter].BufferPool);
            }

            //
            // Delete all DOS buffer pools
            //

            for (i = 0; i <= 0xfe00; i += 0x0200) {
                DeleteBufferPool(GET_POOL_INDEX(adapter, i));
            }

            //
            // closing the adapter also closed the direct station
            //

            Adapters[adapter].DirectStationOpen = FALSE;

            //
            // clear the stored ADAPTER_PARMS and DLC_PARMS
            //

            RtlZeroMemory(&Adapters[adapter].AdapterParms, sizeof(ADAPTER_PARMS));
            RtlZeroMemory(&Adapters[adapter].DlcParms, sizeof(DLC_PARMS));

            if (pDosCcb->uchDlcCommand == LLC_DIR_INITIALIZE) {
                Status = LLC_STATUS_SUCCESS;
            }
        }
        break;

    case LLC_DIR_OPEN_ADAPTER:
        if (Status != LLC_STATUS_SUCCESS) {
            break;
        }

        //
        // Initialize the adapter support software
        //

        Status = InitializeAdapterSupport(adapter, pDirectParms);

        //
        // if we allocated the direct station buffer ok then perform the
        // rest of the open request - open the direct station, add any
        // group or functional addresses specified and set the ADAPTER_PARMS
        // and DLC_PARMS default values in the DOS_ADAPTER structure
        //

        if (Status == LLC_STATUS_SUCCESS) {

            //
            // open the direct station
            //

            Status = OpenDirectStation(adapter);
            if (Status == LLC_STATUS_SUCCESS) {

                //
                // add the group address
                //

                if (groupAddress) {
                    Status = LlcCommand(adapter,
                                        LLC_DIR_SET_GROUP_ADDRESS,
                                        groupAddress
                                        );
                } else IF_DEBUG(DLC) {
                    DPUT1("Error: couldn't set group address: %02x\n", Status);
                }

                if (Status == LLC_STATUS_SUCCESS) {

                    //
                    // add the functional address
                    //

                    if (functionalAddress) {
                        Status = LlcCommand(adapter,
                                            LLC_DIR_SET_FUNCTIONAL_ADDRESS,
                                            functionalAddress
                                            );
                    }
                } else IF_DEBUG(DLC) {
                    DPUT1("Error: couldn't set functional address: %02x\n", Status);
                }

            } else IF_DEBUG(DLC) {
                DPUT1("Error: could open Direct Station: %02x\n", Status);
            }
        }

        //
        // copy the returned default information to the adapter structure if
        // we successfully managed to open the direct station and add the
        // group and functional addresses (if specified)
        //

        if (Status == LLC_STATUS_SUCCESS) {
            RtlCopyMemory(&Adapters[adapter].AdapterParms,
                          pParms->DirOpenAdapter.pAdapterParms,
                          sizeof(ADAPTER_PARMS)
                          );
            if (pParms->DirOpenAdapter.pDlcParms) {
                RtlCopyMemory(&Adapters[adapter].DlcParms,
                              pParms->DirOpenAdapter.pDlcParms,
                              sizeof(DLC_PARMS)
                              );
            }
        } else {

            //
            // yoiks! something failed - close the direct station (if its
            // open, close the adapter and fail the request)
            //

            if (Adapters[adapter].DirectStationOpen) {
                CloseDirectStation(adapter);
            }
            CloseAdapter(adapter);
        }
        break;

    case LLC_DLC_CLOSE_SAP:
    case LLC_DLC_CLOSE_STATION:

        //
        // Delete the buffer pools of the closed or closing station.
        // It does not matter, if the close operation is still pending,
        // because the pending operations should always succeed
        //

        if (Status == LLC_STATUS_SUCCESS || Status == LLC_STATUS_PENDING) {

            DeleteBufferPool(GET_POOL_INDEX(adapter, pDosCcb->u.dlc.usStationId));

            //
            // DLC.SYS returns a pointer to the NT RECEIVE CCB for this SAP.
            // Change the pointer to the DOS RECEIVE CCB
            //

            if (Status == LLC_STATUS_SUCCESS || !pDosCcb->ulCompletionFlag) {

                PLLC_CCB pNtReceive;
                PLLC_DOS_RECEIVE_PARMS_EX pNtReceiveParms;

                pNtReceive = (PLLC_CCB)READ_DWORD(&pOutputCcb->pNext);
                if (pNtReceive) {
                    pNtReceiveParms = (PLLC_DOS_RECEIVE_PARMS_EX)(pNtReceive->u.pParameterTable);
                    WRITE_FAR_POINTER(&pOutputCcb->pNext, pNtReceiveParms->dpOriginalCcbAddress);

                    //
                    // free the NT RECEIVE CCB we allocated (see LLC_RECEIVE above)
                    //

                    ASSERT(pNtReceive->ulCompletionFlag == LLC_DOS_SPECIAL_COMMAND);
                    LocalFree((HLOCAL)pNtReceive);

                    IF_DEBUG(DLC) {
                        DPUT1("VrDlc5cHandler: freed Extended RECEIVE+parms @ %08x\n", pNtReceive);
                    }

                }
            }
        }
        break;

    case LLC_DLC_OPEN_SAP:

        //
        // delete the buffer pool, if the open SAP command failed
        //

        if (Status != LLC_STATUS_SUCCESS) {
            DeleteBufferPool(GET_POOL_INDEX(adapter, pParms->DlcOpenSap.usStationId));
        } else {

            //
            // record the DLC status change appendage for this SAP
            //

            Adapters[ adapter ].DlcStatusChangeAppendage

                [ SAP_ID(pParms->DlcOpenSap.usStationId) ]

                    = pParms->DlcOpenSap.DlcStatusFlags;

            //
            // and user value
            //

            Adapters[ adapter ].UserStatusValue

                [ SAP_ID(pParms->DlcOpenSap.usStationId) ]

                    = pParms->DlcOpenSap.usUserStatValue;
        }
        break;

    case LLC_DLC_RESET:

        //
        // Delete the reset sap buffer pool,
        // or all sap buffer pools.  We don't need to care about
        // the possible error codes, because this can fail only
        // if the given sap station does not exist any more =>
        // it does not matter, if we reset it again.
        //

        if (pDosCcb->u.dlc.usStationId != 0) {
            DeleteBufferPool(GET_POOL_INDEX(adapter, pDosCcb->u.dlc.usStationId));
        } else {

            int sapNumber;

            //
            // Close all SAP stations (0x0200 - 0xfe00). SAP number goes up in
            // increments of 2 since bit 0 is ignored (ie SAP 2 == SAP 3 etc)
            //

            for (sapNumber = 2; sapNumber <= 0xfe; sapNumber += 2) {
                DeleteBufferPool(POOL_INDEX_FROM_SAP(sapNumber, adapter));
            }
        }
        break;
    }
    return Status;
}


VOID
CompleteCcbProcessing(
    IN LLC_STATUS Status,
    IN LLC_DOS_CCB UNALIGNED * pCcb,
    IN PLLC_PARMS pNtParms
    )

/*++

Routine Description:

    Performs any CCB completion processing. Processing can be called either
    when the CCB completes synchronously, or asynchronously. Processing is
    typically to fill in parts of the DOS CCB or parameter table

Arguments:

    Status  - of the request
    pCcb    - pointer to DOS CCB to complete (flat 32-bit pointer to DOS memory)
    pNtParms- pointer to NT parameter table

Return Value:

    None.

--*/

{
    LLC_DOS_PARMS UNALIGNED * pDosParms = READ_FAR_POINTER(&pCcb->u.pParms);
    BYTE adapter = pCcb->uchAdapterNumber;

    IF_DEBUG(DLC) {
        DPUT("CompleteCcbProcessing\n");
    }

    switch (pCcb->uchDlcCommand) {
    case LLC_DIR_OPEN_ADAPTER:

        //
        // this command is unique in that it has a parameter table which points
        // to up to 4 other parameter tables. The following values are output:
        //
        //  ADAPTER_PARMS
        //      OPEN_ERROR_CODE
        //      NODE_ADDRESS
        //
        //  DIRECT_PARMS
        //      WORK_LEN_ACT
        //
        //  DLC_PARMS
        //      None for CCB1
        //
        //  NCB_PARMS
        //      Not accessed
        //

        //
        // we only copy the info if the command succeeded (we may have garbage
        // table pointers otherwise). It is also OK to copy the information if
        // the adapter is already open and the caller requested that we pass
        // the default information back
        //

        if (Status == LLC_STATUS_SUCCESS || Status == LLC_STATUS_ADAPTER_OPEN) {

            PLLC_DOS_DIR_OPEN_ADAPTER_PARMS pOpenAdapterParms = (PLLC_DOS_DIR_OPEN_ADAPTER_PARMS)pDosParms;
            PADAPTER_PARMS pAdapterParms = READ_FAR_POINTER(&pOpenAdapterParms->pAdapterParms);
            PDIRECT_PARMS pDirectParms = READ_FAR_POINTER(&pOpenAdapterParms->pDirectParms);
            PDLC_PARMS pDlcParms = READ_FAR_POINTER(&pOpenAdapterParms->pDlcParms);

            //
            // if we got an error and the caller didn't request the original
            // open parameters, then skip out
            //

            if (Status == LLC_STATUS_ADAPTER_OPEN && !(pAdapterParms->OpenOptions & 0x200)) {
                break;
            }

            WRITE_WORD(&pAdapterParms->OpenErrorCode, pNtParms->DirOpenAdapter.pAdapterParms->usOpenErrorCode);
            RtlCopyMemory(&pAdapterParms->NodeAddress,
                          pNtParms->DirOpenAdapter.pAdapterParms->auchNodeAddress,
                          sizeof(pAdapterParms->NodeAddress)
                          );

            //
            // direct parms are not returned from NT DLC, so we just copy the
            // requested work area size to the actual
            //

            WRITE_WORD(&pDirectParms->AdapterWorkAreaActual,
                        READ_WORD(&pDirectParms->AdapterWorkAreaRequested)
                        );

            //
            // copy the entire DLC_PARMS structure from the DOS_ADAPTER structure
            //

            if (pDlcParms) {
                RtlCopyMemory(pDlcParms, &Adapters[adapter].DlcParms, sizeof(*pDlcParms));
            }
        }
        break;

    case LLC_DIR_STATUS:

        //
        // copy the common areas from the 32-bit parameter table to 16-bit table
        // This copies up to the adapter parameters address
        //

        RtlCopyMemory(pDosParms, pNtParms, (DWORD)&((PDOS_DIR_STATUS_PARMS)0)->dpAdapterParmsAddr);

        //
        // fill in the other fields as best we can
        //

        RtlZeroMemory(pDosParms->DosDirStatus.auchMicroCodeLevel,
                      sizeof(pDosParms->DosDirStatus.auchMicroCodeLevel)
                      );
        WRITE_DWORD(&pDosParms->DosDirStatus.dpAdapterMacAddr, 0);
        WRITE_DWORD(&pDosParms->DosDirStatus.dpTimerTick, 0);
        WRITE_WORD(&pDosParms->DosDirStatus.usLastNetworkStatus,
                    Adapters[adapter].LastNetworkStatusChange
                    );

        //
        // If the app has requested we return the extended parameter table, then
        // fill it in with reasonable values if we can. There is one table per
        // adapter, statically allocated in the real-mode redir TSR
        //

        if (pDosParms->DosDirStatus.uchAdapterConfig & 0x20) {

            //
            // Ethernet type uses different bit in DOS and Nt (or OS/2)
            //

            lpVdmWindow->aExtendedStatus[adapter].cbSize = sizeof(EXTENDED_STATUS_PARMS);

            //
            // if adapter type as reported by NtAcsLan is Ethernet (0x100), set
            // adapter type in extended status table to Ethernet (0x10), else
            // record whatever NtAcsLan gave us
            //

            if (pNtParms->DirStatus.usAdapterType & 0x100) {
                WRITE_WORD(&lpVdmWindow->aExtendedStatus[adapter].wAdapterType,
                           0x0010
                           );
                lpVdmWindow->aExtendedStatus[adapter].cbPageFrameSize = 0;
                WRITE_WORD(&lpVdmWindow->aExtendedStatus[adapter].wCurrentFrameSize,
                           0
                           );
                WRITE_WORD(&lpVdmWindow->aExtendedStatus[adapter].wMaxFrameSize,
                           0
                           );
            } else {
                WRITE_WORD(&lpVdmWindow->aExtendedStatus[adapter].wAdapterType,
                           pNtParms->DirStatus.usAdapterType
                           );

                //
                // set the TR page frame size (KBytes)
                //

                lpVdmWindow->aExtendedStatus[adapter].cbPageFrameSize = 16;

                //
                // set the current and maximum DHB sizes for TR cards
                //

                WRITE_WORD(&lpVdmWindow->aExtendedStatus[adapter].wCurrentFrameSize,
                           (WORD)pNtParms->DirStatus.ulMaxFrameLength
                           );
                WRITE_WORD(&lpVdmWindow->aExtendedStatus[adapter].wMaxFrameSize,
                           (WORD)pNtParms->DirStatus.ulMaxFrameLength
                           );
            }

            //
            // record the address of the extended parameter table in the
            // DIR.STATUS parameter table
            //

            WRITE_DWORD(&pDosParms->DosDirStatus.dpExtendedParms,
                        NEW_DOS_ADDRESS(dpVdmWindow, &lpVdmWindow->aExtendedStatus[adapter])
                        );
        } else {

            //
            // no extended parameters requested
            //

            WRITE_DWORD(&pDosParms->DosDirStatus.dpExtendedParms, 0);
        }

        //
        // return the tick counter. We don't currently update the tick counter
        //

        WRITE_DWORD(&pDosParms->DosDirStatus.dpTimerTick,
                    NEW_DOS_ADDRESS(dpVdmWindow, &lpVdmWindow->dwDlcTimerTick)
                    );

        //
        // always return a pointer to the extended adapter parameter table we
        // now keep in DOS memory. We currently always zero this table. It
        // would normally be maintained by the adapter (MAC) software
        //

        WRITE_DWORD(&pDosParms->DosDirStatus.dpAdapterParmsAddr,
                    NEW_DOS_ADDRESS(dpVdmWindow, &lpVdmWindow->AdapterStatusParms[adapter])
                    );
        RtlZeroMemory(&lpVdmWindow->AdapterStatusParms[adapter],
                      sizeof(lpVdmWindow->AdapterStatusParms[adapter])
                      );
        break;

    case LLC_DLC_OPEN_SAP:

        //
        // STATION_ID is only output value
        //

        WRITE_WORD(&pDosParms->DlcOpenSap.usStationId, pNtParms->DlcOpenSap.usStationId);
        break;

    case LLC_DLC_OPEN_STATION:

        //
        // LINK_STATION_ID is only output value
        //

        WRITE_WORD(&pDosParms->DlcOpenStation.usLinkStationId, pNtParms->DlcOpenStation.usLinkStationId);
        break;

    case LLC_DLC_STATISTICS:
        break;
    }
}


LLC_STATUS
InitializeAdapterSupport(
    IN UCHAR AdapterNumber,
    IN DOS_DLC_DIRECT_PARMS UNALIGNED * pDirectParms OPTIONAL
    )

/*++

Routine Description:

    The function initializes the buffer pool for the new adapter opened by
    DOS DLC

Arguments:

    AdapterNumber   - which adapter to initialize the buffer pool for
    pDirectParms    - Direct station parameter table, not used in NT, but
                      optional in DOS

Return Value:

    LLC_STATUS
        LLC_NO_RESOURCES

--*/

{
    LLC_STATUS Status;
    HANDLE hBufferPool;

    IF_DEBUG(DLC) {
        DPUT("InitializeAdapterSupport\n");
    }

    //
    // Check if the global DLL initialization has already been done. This is not
    // done in global DLL init because there is no reason to start an extra
    // thread if DLC is not used. If this succeeds then the asynchronous event
    // handler thread will be waiting on a list of 2 events - one for each
    // adapter. We need to submit a READ CCB for this adapter
    //

    Status = VrDlcInit();
    if (Status != LLC_STATUS_SUCCESS) {
        return Status;
    } else if (InitiateRead(AdapterNumber, &Status) == NULL) {
        return Status;
    }

    OpenedAdapters++;

    //
    // mark the adapter as being opened and get the media type/class
    //

    Adapters[AdapterNumber].IsOpen = TRUE;
    Adapters[AdapterNumber].AdapterType = GetAdapterType(AdapterNumber);

    //
    // Create the DLC buffer pool for the new adapter. DLC driver will
    // deallocate the buffer pool in the DIR.CLOSE.ADAPTER or when
    // the MVDM process makes a process exit
    //

    Adapters[AdapterNumber].BufferPool = (PVOID)LocalAlloc(LMEM_FIXED, DOS_DLC_BUFFER_POOL_SIZE);
    if (Adapters[AdapterNumber].BufferPool == NULL) {
        Status = LLC_STATUS_NO_MEMORY;
        goto ErrorHandler;
    }

    Status = BufferCreate(AdapterNumber,
                          Adapters[AdapterNumber].BufferPool,
                          DOS_DLC_BUFFER_POOL_SIZE,
                          DOS_DLC_MIN_FREE_THRESHOLD,
                          &hBufferPool
                          );
    if (Status != LLC_STATUS_SUCCESS) {
        goto ErrorHandler;
    }

    if (ARGUMENT_PRESENT(pDirectParms)) {

        //
        // create a buffer pool for the direct station (SAP 0). This allows
        // us to receive MAC and non-MAC frames sent to the direct station
        // without having to purposefully allocate a buffer
        //

        Status = CreateBufferPool(GET_POOL_INDEX(AdapterNumber, 0),
                                  pDirectParms->dpPoolAddress,
                                  pDirectParms->cPoolBlocks,
                                  pDirectParms->usBufferSize
                                  );
        if (Status != LLC_STATUS_SUCCESS) {
            goto ErrorHandler;
        }

        SaveExceptions(AdapterNumber,
                       (LPDWORD)&pDirectParms->dpAdapterCheckExit
                       );
        Status = SetExceptionFlags(AdapterNumber,
                                   (DWORD)pDirectParms->dpAdapterCheckExit,
                                   (DWORD)pDirectParms->dpNetworkStatusExit,
                                   (DWORD)pDirectParms->dpPcErrorExit,
                                   0
                                   );
        if (Status != LLC_STATUS_SUCCESS) {
            goto ErrorHandler;
        }
    }

    IF_DEBUG(DLC) {
        DPUT("InitializeAdapterSupport: returning success\n");
    }

    return LLC_STATUS_SUCCESS;

ErrorHandler:

    //
    // The open failed. We must close the adapter, but we don't care about the
    // result. This must succeed
    //

    if (Adapters[AdapterNumber].BufferPool != NULL) {
        LocalFree(Adapters[AdapterNumber].BufferPool);

        IF_DEBUG(DLC_ALLOC) {
            DPUT1("FREE: freed block @ %x\n", Adapters[AdapterNumber].BufferPool);
        }

    }

    CloseAdapter(AdapterNumber);
    Adapters[AdapterNumber].IsOpen = FALSE;

    //
    // this is probably not the right error code to return under these
    // circumstances, but we'll keep it until something better comes along
    //

    IF_DEBUG(DLC) {
        DPUT("InitializeAdapterSupport: returning FAILURE\n");
    }

    return LLC_STATUS_ADAPTER_NOT_INITIALIZED;
}


VOID
SaveExceptions(
    IN UCHAR AdapterNumber,
    IN LPDWORD pulExceptionFlags
    )

/*++

Routine Description:

    Procedure saves the current exception handlers
    and copies new current values on the old ones.

Arguments:

    IN UCHAR AdapterNumber - current adapter
    IN LPDWORD pulExceptionFlags - 3 dos exception handlers in the arrays

Return Value:

    None

--*/

{
    IF_DEBUG(DLC) {
        DPUT("SaveExceptions\n");
    }

    RtlCopyMemory(Adapters[AdapterNumber].PreviousExceptionHandlers,
                  Adapters[AdapterNumber].CurrentExceptionHandlers,
                  sizeof(Adapters[AdapterNumber].PreviousExceptionHandlers)
                  );
    RtlCopyMemory(Adapters[AdapterNumber].CurrentExceptionHandlers,
                  pulExceptionFlags,
                  sizeof(Adapters[AdapterNumber].CurrentExceptionHandlers)
                  );
}


LPDWORD
RestoreExceptions(
    IN UCHAR AdapterNumber
    )

/*++

Routine Description:

    Procedure restores the previous exception handlers
    and returns the their address.

Arguments:

    IN UCHAR AdapterNumber - current adapter

Return Value:

    None

--*/

{
    IF_DEBUG(DLC) {
        DPUT("RestoreExceptions\n");
    }

    RtlCopyMemory(Adapters[AdapterNumber].CurrentExceptionHandlers,
                  Adapters[AdapterNumber].PreviousExceptionHandlers,
                  sizeof(Adapters[AdapterNumber].CurrentExceptionHandlers)
                  );
    return Adapters[AdapterNumber].CurrentExceptionHandlers;
}


LLC_STATUS
CopyDosBuffersToDescriptorArray(
    IN OUT PLLC_TRANSMIT_DESCRIPTOR pDescriptors,
    IN PLLC_XMIT_BUFFER pDlcBufferQueue,
    IN OUT LPDWORD pIndex
    )

/*++

Routine Description:

    The routine copies DOS transmit buffers to a Nt Transmit
    descriptor array.  All DOS pointers must be mapped to the flat
    32-bit address space.  Any data in the parameter table may be
    unaligned.

Arguments:

    pDescriptors    - current descriptor array
    pDlcBufferQueue - DOS transmit buffer queue
    pIndex          - current index in the descriptor array

Return Value:

    LLC_STATUS

--*/

{
    PLLC_XMIT_BUFFER pBuffer;
    DWORD Index = *pIndex;
    DWORD i = 0;
    DWORD DlcStatus = LLC_STATUS_SUCCESS;
    WORD cbBuffer;

    IF_DEBUG(DLC) {
        DPUT("CopyDosBuffersToDescriptorArray\n");
    }

    while (pDlcBufferQueue) {
        pBuffer = (PLLC_XMIT_BUFFER)DOS_PTR_TO_FLAT(pDlcBufferQueue);

        //
        // Check the overflow of the internal xmit buffer in stack and
        // the loop counter, that prevents the forever loop of zero length
        // transmit buffer (the buffer chain might be circular)
        //

        if (Index >= MAX_TRANSMIT_SEGMENTS || i > 60000) {
            DlcStatus = LLC_STATUS_TRANSMIT_ERROR;
            break;
        }

        if ((cbBuffer = READ_WORD(&pBuffer->cbBuffer)) != 0) {
            pDescriptors[Index].pBuffer = (PUCHAR)(pBuffer->auchData)
                                        + READ_WORD(&pBuffer->cbUserData);
            pDescriptors[Index].cbBuffer = cbBuffer;
            pDescriptors[Index].eSegmentType = LLC_NEXT_DATA_SEGMENT;
            pDescriptors[Index].boolFreeBuffer = FALSE;

            Index++;
        }
        i++;
        pDlcBufferQueue = (PLLC_XMIT_BUFFER)READ_DWORD(&pBuffer->pNext);
    }
    *pIndex = Index;
    return DlcStatus;
}


LLC_STATUS
BufferCreate(
    IN UCHAR AdapterNumber,
    IN PVOID pVirtualMemoryBuffer,
    IN DWORD ulVirtualMemorySize,
    IN DWORD ulMinFreeSizeThreshold,
    OUT HANDLE* phBufferPoolHandle
    )

/*++

Routine Description:

    Function creates a Windows/Nt DLC buffer pool.

    THIS COMMAND COMPLETES SYNCHRONOUSLY

Arguments:

    AdapterNumber           -
    pVirtualMemoryBuffer    - pointer to a virtual memory
    ulVirtualMemorySize     - size of all available buffer pool space
    ulMinFreeSizeThreshold  - locks more pages when this is exceeded
    phBufferPoolHandle      -

Return Value:

    LLC_STATUS

--*/

{
    LLC_CCB ccb;
    LLC_BUFFER_CREATE_PARMS BufferCreate;
    LLC_STATUS status;

    IF_DEBUG(DLC) {
        DPUT("BufferCreate\n");
    }

    InitializeCcb(&ccb, AdapterNumber, LLC_BUFFER_CREATE, &BufferCreate);

    BufferCreate.pBuffer = pVirtualMemoryBuffer;
    BufferCreate.cbBufferSize = ulVirtualMemorySize;
    BufferCreate.cbMinimumSizeThreshold = ulMinFreeSizeThreshold;

    status = lpAcsLan(&ccb, NULL);
    *phBufferPoolHandle = BufferCreate.hBufferPool;

    IF_DEBUG(DLC) {
        DPUT2("BufferCreate: returning %#x (%d)\n", status, status);
    }

    return DLC_ERROR_STATUS(status, ccb.uchDlcStatus);
}


LLC_STATUS
SetExceptionFlags(
    IN UCHAR AdapterNumber,
    IN DWORD ulAdapterCheckFlag,
    IN DWORD ulNetworkStatusFlag,
    IN DWORD ulPcErrorFlag,
    IN DWORD ulSystemActionFlag
    )

/*++

Routine Description:

    Sets the new appendage addresses

    THIS COMMAND COMPLETES SYNCHRONOUSLY

Arguments:

    AdapterNumber       -
    ulAdapterCheckFlag  -
    ulNetworkStatusFlag -
    ulPcErrorFlag       -
    ulSystemActionFlag  -

Return Value:

    LLC_STATUS

--*/

{
    LLC_CCB ccb;
    LLC_STATUS status;
    LLC_DIR_SET_EFLAG_PARMS DirSetFlags;

    IF_DEBUG(DLC) {
        DPUT("SetExceptionFlags\n");
    }

    InitializeCcb(&ccb, AdapterNumber, LLC_DIR_SET_EXCEPTION_FLAGS, &DirSetFlags);

    DirSetFlags.ulAdapterCheckFlag = ulAdapterCheckFlag;
    DirSetFlags.ulNetworkStatusFlag = ulNetworkStatusFlag;
    DirSetFlags.ulPcErrorFlag = ulPcErrorFlag;
    DirSetFlags.ulSystemActionFlag = ulSystemActionFlag;

    status = lpAcsLan(&ccb, NULL);
    return DLC_ERROR_STATUS(status, ccb.uchDlcStatus);
}


LLC_STATUS
LlcCommand(
    IN UCHAR AdapterNumber,
    IN UCHAR Command,
    IN DWORD Parameter
    )

/*++

Routine Description:

    Calls the ACSLAN DLL to perform a DLC request which takes no parameter
    table, but which takes parameters in byte, word or dword form in the CCB

    COMMANDS USING THIS ROUTINE MUST COMPLETE SYNCHRONOUSLY

Arguments:

    AdapterNumber   - which adapter to perform command for
    Command         - which DLC command to perform. Currently, commands are:
                        DIR.SET.GROUP.ADDRESS
                        DIR.SET.FUNCTIONAL.ADDRESS
                        DLC.FLOW.CONTROL
                        RECEIVE.CANCEL
    Parameter       - the associated command

Return Value:

    DWORD

--*/

{
    LLC_CCB ccb;
    LLC_STATUS status;

    IF_DEBUG(DLC) {
        DPUT3("LlcCommand(%d, %02x, %08x)\n", AdapterNumber, Command, Parameter);
    }

    InitializeCcb2(&ccb, AdapterNumber, Command);
    ccb.u.ulParameter = Parameter;

    status = lpAcsLan(&ccb, NULL);
    return DLC_ERROR_STATUS(status, ccb.uchDlcStatus);
}


LLC_STATUS
OpenAdapter(
    IN UCHAR AdapterNumber
    )

/*++

Routine Description:

    Opens a DLC adapter context for a Windows/Nt VDM

    THIS COMMAND COMPLETES SYNCHRONOUSLY

Arguments:

    AdapterNumber   - which adapter to open

Return Value:

    LLC_STATUS

--*/

{
    LLC_CCB Ccb;
    LLC_DIR_OPEN_ADAPTER_PARMS DirOpenAdapter;
    LLC_ADAPTER_OPEN_PARMS AdapterParms;
    LLC_EXTENDED_ADAPTER_PARMS ExtendedParms;
    LLC_DLC_PARMS DlcParms;
    LLC_STATUS status;

    IF_DEBUG(DLC) {
        DPUT1("OpenAdapter(AdapterNumber=%d)\n", AdapterNumber);
    }

    InitializeCcb(&Ccb, AdapterNumber, LLC_DIR_OPEN_ADAPTER, &DirOpenAdapter);

    DirOpenAdapter.pAdapterParms = &AdapterParms;
    DirOpenAdapter.pExtendedParms = &ExtendedParms;
    DirOpenAdapter.pDlcParms = &DlcParms;

    ExtendedParms.hBufferPool = NULL;
    ExtendedParms.pSecurityDescriptor = NULL;
    ExtendedParms.LlcEthernetType = LLC_ETHERNET_TYPE_DEFAULT;

    RtlZeroMemory(&AdapterParms, sizeof(AdapterParms));
    RtlZeroMemory(&DlcParms, sizeof(DlcParms));

    status = lpAcsLan(&Ccb, NULL);

    if (status == LLC_STATUS_SUCCESS) {

        //
        // get the adapter media type/class
        //

        Adapters[AdapterNumber].AdapterType = GetAdapterType(AdapterNumber);

        //
        // mark the adapter structure as open
        //

        Adapters[AdapterNumber].IsOpen = TRUE;

        //
        // fill in the DOS ADAPTER_PARMS and DLC_PARMS structures with any
        // returned values
        //

        RtlCopyMemory(&Adapters[AdapterNumber].AdapterParms,
                      &AdapterParms,
                      sizeof(ADAPTER_PARMS)
                      );
        RtlCopyMemory(&Adapters[AdapterNumber].DlcParms,
                      &DlcParms,
                      sizeof(DLC_PARMS)
                      );
        Adapters[AdapterNumber].DlcSpecified = TRUE;
    }

    IF_DEBUG(DLC) {
        DPUT2("OpenAdapter: returning %d (%x)\n", status, status);
    }

    return DLC_ERROR_STATUS(status, Ccb.uchDlcStatus);
}


VOID
CloseAdapter(
    IN UCHAR AdapterNumber
    )

/*++

Routine Description:

    Closes this adapter. Uses a CCB in the DOS_ADAPTER structure specifically
    for this purpose

    THIS COMMAND COMPLETES ** ASYNCHRONOUSLY **

Arguments:

    AdapterNumber   - adapter to close

Return Value:

    None.

--*/

{
    InitializeCcb2(&Adapters[AdapterNumber].AdapterCloseCcb, AdapterNumber, LLC_DIR_CLOSE_ADAPTER);
    Adapters[AdapterNumber].AdapterCloseCcb.ulCompletionFlag = VRDLC_COMMAND_COMPLETION;

#if DBG

    ASSERT(lpAcsLan(&Adapters[AdapterNumber].AdapterCloseCcb, NULL) == LLC_STATUS_SUCCESS);

#else

    lpAcsLan(&Adapters[AdapterNumber].AdapterCloseCcb, NULL);

#endif

    //
    // mark the adapter structure as being closed
    //

    Adapters[AdapterNumber].IsOpen = FALSE;
}


LLC_STATUS
OpenDirectStation(
    IN UCHAR AdapterNumber
    )

/*++

Routine Description:

    Opens the direct station for this adapter

    THIS COMMAND COMPLETES SYNCHRONOUSLY

Arguments:

    AdapterNumber   - which adapter to open direct station for

Return Value:

    LLC_STATUS

--*/

{
    LLC_CCB ccb;
    LLC_DIR_OPEN_DIRECT_PARMS DirOpenDirect;
    LLC_STATUS status;

    IF_DEBUG(DLC) {
        DPUT1("OpenDirectStation(%d)\n", AdapterNumber);
    }

    InitializeCcb(&ccb, AdapterNumber, LLC_DIR_OPEN_DIRECT, &DirOpenDirect);

    DirOpenDirect.usOpenOptions = 0;
    DirOpenDirect.usEthernetType = 0;

    status = lpAcsLan(&ccb, NULL);
    if (status == LLC_STATUS_SUCCESS) {

        //
        // mark this DOS_ADAPTER as having the direct station open
        //

        Adapters[AdapterNumber].DirectStationOpen = TRUE;
    }

    status = DLC_ERROR_STATUS(status, ccb.uchDlcStatus);

    IF_DEBUG(DLC) {
        DPUT2("OpenDirectStation: returning %d (%x)\n", status, status);
    }

    return status;
}


VOID
CloseDirectStation(
    IN UCHAR AdapterNumber
    )

/*++

Routine Description:

    Closes the direct station for this adapter. Uses a CCB in the DOS_ADAPTER
    structure specifically for this purpose

    THIS COMMAND COMPLETES ** ASYNCHRONOUSLY **

Arguments:

    AdapterNumber   - adapter to close the direct station for

Return Value:

    None.

--*/

{
    InitializeCcb2(&Adapters[AdapterNumber].DirectCloseCcb, AdapterNumber, LLC_DIR_CLOSE_DIRECT);
    Adapters[AdapterNumber].DirectCloseCcb.ulCompletionFlag = VRDLC_COMMAND_COMPLETION;

#if DBG

    ASSERT(lpAcsLan(&Adapters[AdapterNumber].DirectCloseCcb, NULL) == LLC_STATUS_SUCCESS);

#else

    lpAcsLan(&Adapters[AdapterNumber].DirectCloseCcb, NULL);

#endif

    //
    // mark the adapter structure as no longer having the direct station open
    //

    Adapters[AdapterNumber].DirectStationOpen = FALSE;
}


LLC_STATUS
BufferFree(
    IN UCHAR AdapterNumber,
    IN PVOID pFirstBuffer,
    OUT LPWORD pusBuffersLeft
    )

/*++

Routine Description:

    Frees a SAP buffer pool in the NT DLC driver

    THIS COMMAND COMPLETES SYNCHRONOUSLY

Arguments:

    AdapterNumber   -
    pFirstBuffer    -
    pusBuffersLeft  -

Return Value:

    LLC_STATUS

--*/

{
    LLC_CCB ccb;
    LLC_BUFFER_FREE_PARMS parms;
    LLC_STATUS status;

    IF_DEBUG(DLC) {
        DPUT1("BufferFree(%x)\n", pFirstBuffer);
    }

    InitializeCcb(&ccb, AdapterNumber, LLC_BUFFER_FREE, &parms);

    parms.pFirstBuffer = pFirstBuffer;

    status = lpAcsLan(&ccb, NULL);
    *pusBuffersLeft = parms.cBuffersLeft;

    return DLC_ERROR_STATUS(status, ccb.uchDlcStatus);
}


LLC_STATUS
VrDlcInit(
    VOID
    )

/*++

Routine Description:

    perform one-shot initialization:

        * clear Adapters structures

        * initialize array of buffer pool structures and initialize the buffer
          pool critical section (InitializeBufferPools in vrdlcbuf.c)

        * create all events and threads for asynchronous command completion
          processing (InitializeEventHandler in vrdlcpst.c)

        * initialize critical sections for each adapter's local-busy(buffer)
          state information

        * set the DLC initialized flag

Arguments:

    None.

Return Value:

    LLC_STATUS
        Success - LLC_STATUS_SUCCESS
                    DLC support already initialized or initialization completed
                    successfully

        Failure - LLC_STATUS_NO_MEMORY
                    failed to create the asynchronous event thread or an event
                    object

--*/

{
    static BOOLEAN VrDlcInitialized = FALSE;
    LLC_STATUS Status = LLC_STATUS_SUCCESS;

    if (!VrDlcInitialized) {

        //
        // ensure that the DOS_ADAPTER structures begin life in a known state
        //

        RtlZeroMemory(Adapters, sizeof(Adapters));

        //
        // clear out the buffer pool structures and initialize the buffer
        // pool critical section
        //

        InitializeBufferPools();

        //
        // crreate the event handler thread and the worker thread
        //

        if (!(InitializeEventHandler() && InitializeDlcWorkerThread())) {
            Status = LLC_STATUS_NO_MEMORY;
        } else {

            //
            // initialize each adapter's local-busy state critical section
            // and set the first & last indicies to -1, meaning no index
            //

            int i;

            for (i = 0; i < ARRAY_ELEMENTS(Adapters); ++i) {
                InitializeCriticalSection(&Adapters[i].EventQueueCritSec);
                InitializeCriticalSection(&Adapters[i].LocalBusyCritSec);
                Adapters[i].FirstIndex = Adapters[i].LastIndex = NO_LINKS_BUSY;
            }
            VrDlcInitialized = TRUE;
        }
    }
    return Status;
}


VOID
VrVdmWindowInit(
    VOID
    )

/*++

Routine Description:

    This routine saves the address of a VDM memory window, that is used
    in the communication betwen VDM TSR and its virtual device driver.
    This is called from a DOS TSR module.

Arguments:

    ES:BX in the VDM context are set to point to a memory window in TSR.

Return Value:

    None

--*/

{
    IF_DEBUG(DLC) {
        DPUT("VrVdmWindowInit\n");
    }

    //
    // Initialize the VDM memory window addresses
    //

    dpVdmWindow = MAKE_DWORD(getES(), getBX());
    lpVdmWindow = (LPVDM_REDIR_DOS_WINDOW)DOS_PTR_TO_FLAT(dpVdmWindow);

    IF_DEBUG(DLC) {
        DPUT2("VrVdmWindowsInit: dpVdmWindow=%08x lpVdmWindow=%08x\n", dpVdmWindow, lpVdmWindow);
    }

    //
    // have to return success to VDM redir TSR
    //

    setCF(0);
}


ADAPTER_TYPE
GetAdapterType(
    IN UCHAR AdapterNumber
    )

/*++

Routine Description:

    Determines what type of adapter AdapterNumber designates

    THE DIR.STATUS COMMAND COMPLETES SYNCHRONOUSLY

Arguments:

    AdapterNumber   - number of adapter to get type of

Return Value:

    ADAPTER_TYPE
        TokenRing, Ethernet, PcNetwork, or UnknownAdapter
--*/

{
    LLC_CCB ccb;
    LLC_DIR_STATUS_PARMS parms;
    LLC_STATUS status;

    IF_DEBUG(DLC) {
        DPUT("GetAdapterType\n");
    }

    InitializeCcb(&ccb, AdapterNumber, LLC_DIR_STATUS, &parms);

    status = lpAcsLan(&ccb, NULL);

    if (status == LLC_STATUS_SUCCESS) {
        switch (parms.usAdapterType) {
        case 0x0001:    // Token Ring Network PC Adapter
        case 0x0002:    // Token Ring Network PC Adapter II
        case 0x0004:    // Token Ring Network Adapter/A
        case 0x0008:    // Token Ring Network PC Adapter II
        case 0x0020:    // Token Ring Network 16/4 Adapter
        case 0x0040:    // Token Ring Network 16/4 Adapter/A
        case 0x0080:    // Token Ring Network Adapter/A
            return TokenRing;

        case 0x0100:    //Ethernet Adapter
            return Ethernet;

        case 0x4000:    // PC Network Adapter
        case 0x8000:    // PC Network Adapter/A
            return PcNetwork;
        }
    }
    return UnknownAdapter;
}


BOOLEAN
LoadDlcDll(
    VOID
    )

/*++

Routine Description:

    Dynamically loads DLCAPI.DLL & fixes-up entry points

Arguments:

    None.

Return Value:

    BOOLEAN
        TRUE if success else FALSE

--*/

{
    HANDLE hLibrary;
    LPWORD lpVdmPointer;

    if ((hLibrary = LoadLibrary("DLCAPI")) == NULL) {

        IF_DEBUG(DLC) {
            DPUT1("LoadDlcDll: Error: cannot load DLCAPI.DLL: %d\n", GetLastError());
        }

        return FALSE;
    }
    if ((lpAcsLan = (ACSLAN_FUNC_PTR)GetProcAddress(hLibrary, "AcsLan")) == NULL) {

        IF_DEBUG(DLC) {
            DPUT1("LoadDlcDll: Error: cannot GetProcAddress(AcsLan): %d\n", GetLastError());
        }

        return FALSE;
    }
    if ((lpDlcCallDriver = (DLC_CALL_DRIVER_FUNC_PTR)GetProcAddress(hLibrary, "DlcCallDriver")) == NULL) {

        IF_DEBUG(DLC) {
            DPUT1("LoadDlcDll: Error: cannot GetProcAddress(DlcCallDriver): %d\n", GetLastError());
        }

        return FALSE;
    }
    if ((lpNtAcsLan = (NTACSLAN_FUNC_PTR)GetProcAddress(hLibrary, "NtAcsLan")) == NULL) {

        IF_DEBUG(DLC) {
            DPUT1("LoadDlcDll: Error: cannot GetProcAddress(NtAcsLan): %d\n", GetLastError());
        }

        return FALSE;
    }

    IF_DEBUG(DLC) {
        DPUT("LoadDlcDll: DLCAPI.DLL loaded Ok\n");
    }

    //
    // Initialize the VDM memory window addresses from our well-known address
    // in the VDM Redir. Do this here because we no longer initialize 32-bit
    // support at the point where we load the 16-bit REDIR
    //

    lpVdmPointer = POINTER_FROM_WORDS(getCS(), (DWORD)&((VDM_LOAD_INFO*)0)->DlcWindowAddr);
    dpVdmWindow = MAKE_DWORD(GET_SEGMENT(lpVdmPointer), GET_OFFSET(lpVdmPointer));
    lpVdmWindow = (LPVDM_REDIR_DOS_WINDOW)DOS_PTR_TO_FLAT(dpVdmWindow);

    IF_DEBUG(DLC) {
        DPUT4("LoadDlcDll: lpVdmPointer=%x dpVdmWindow = %04x:%04x lpVdmWindow=%x\n",
              lpVdmPointer,
              HIWORD(dpVdmWindow),
              LOWORD(dpVdmWindow),
              lpVdmWindow
              );
    }

    return TRUE;
}


VOID
TerminateDlcEmulation(
    VOID
    )

/*++

Routine Description:

    Closes any open adapters. Any pending commands are terminated

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD i;

    IF_DEBUG(DLC) {
        DPUT("TerminateDlcEmulation\n");
    }

    IF_DEBUG(CRITICAL) {
        DPUT("TerminateDlcEmulation\n");
    }

    for (i = 0; i < ARRAY_ELEMENTS(Adapters); ++i) {
        if (Adapters[i].IsOpen) {
            CloseAdapter((BYTE)i);
        }
    }
}

HANDLE DlcWorkerEvent;
HANDLE DlcWorkerCompletionEvent;
HANDLE DlcWorkerThreadHandle;

struct {
    PLLC_CCB Input;
    PLLC_CCB Original;
    PLLC_CCB Output;
    LLC_STATUS Status;
} DlcWorkerThreadParms;


BOOLEAN
InitializeDlcWorkerThread(
    VOID
    )

/*++

Routine Description:

    Creates events which control VrDlcWorkerThread and starts the worker thread

Arguments:

    None.

Return Value:

    BOOLEAN
        TRUE    - worker thread was successfully created
        FALSE   - couldn't start worker thread for some reason

--*/

{
    DWORD threadId;

    //
    // create 2 auto-reset events
    //

    DlcWorkerEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (DlcWorkerEvent == NULL) {
        return FALSE;
    }
    DlcWorkerCompletionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (DlcWorkerCompletionEvent == NULL) {
        CloseHandle(DlcWorkerEvent);
        return FALSE;
    }

    //
    // kick off the one-and-only worker thread
    //

    DlcWorkerThreadHandle = CreateThread(NULL,
                                         0,
                                         (LPTHREAD_START_ROUTINE)VrDlcWorkerThread,
                                         NULL,
                                         0,
                                         &threadId
                                         );
    if (DlcWorkerThreadHandle == NULL) {
        CloseHandle(DlcWorkerEvent);
        CloseHandle(DlcWorkerCompletionEvent);
        return FALSE;
    }
    return TRUE;
}


VOID
VrDlcWorkerThread(
    IN LPVOID Parameters
    )

/*++

Routine Description:

    Submits requests to NtAcsLan on behalf of DOS thread. This exists because of
    a problem with 16-bit Windows apps that use DLC (like Extra!). Eg:

        1. start Extra! session. Extra submits RECEIVE command
        2. connect to mainframe
        3. start second Extra! session
        4. connect second instance to mainframe
        5. kill first Extra! session

    On a DOS machine, the RECEIVE is submitted for the entire process, so when
    the first Extra! session is killed, the RECEIVE is still active.

    However, on NT, each session is represented by a separate thread in NTVDM.
    So when the first session is killed, any outstanding IRPs are cancelled,
    including the RECEIVE. The second instance of Extra! doesn't know that the
    RECEIVE has been cancelled, and never receives any more data

Arguments:

    Parameters  - unused pointer to parameter block

Return Value:

    None.

--*/

{
    DWORD object;

    UNREFERENCED_PARAMETER(Parameters);

    while (TRUE) {
        object = WaitForSingleObject(DlcWorkerEvent, INFINITE);
        if (object == WAIT_OBJECT_0) {
            DlcWorkerThreadParms.Status = lpNtAcsLan(DlcWorkerThreadParms.Input,
                                                     DlcWorkerThreadParms.Original,
                                                     DlcWorkerThreadParms.Output,
                                                     NULL
                                                     );
            SetEvent(DlcWorkerCompletionEvent);
        }
    }
}


LLC_STATUS
DlcCallWorker(
    PLLC_CCB pInputCcb,
    PLLC_CCB pOriginalCcb,
    PLLC_CCB pOutputCcb
    )

/*++

Routine Description:

    Queues (depth is one) a request to the DLC worker thread and waits for the
    worker thread to complete the request

Arguments:

    pInputCcb       - pointer to input CCB. Mapped to 32-bit aligned memory
    pOriginalCcb    - address of original CCB. Can be non-aligned DOS address
    pOutputCcb      - pointer to output CCB. Can be non-aligned DOS address

Return Value:

    LLC_STATUS

--*/

{
    DlcWorkerThreadParms.Input = pInputCcb;
    DlcWorkerThreadParms.Original = pOriginalCcb;
    DlcWorkerThreadParms.Output = pOutputCcb;
    SetEvent(DlcWorkerEvent);
    WaitForSingleObject(DlcWorkerCompletionEvent, INFINITE);
    return DlcWorkerThreadParms.Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\vrdlcdbg.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrdlcdbg.h

Abstract:

    contains prototypes etc for DLC dump/diagnostic functions in VrDlcDbg.c

Author:

    Richard L Firth (rfirth) 30-Apr-1992

Revision History:

--*/

//
// CCB return codes valid in DOS mode
// See IBM Local Area Network Tech. Ref. Appendix B
//

#define CCB_COMMAND_IN_PROGRESS     0xff
#define CCB_SUCCESS                 0x00
#define CCB_INVALID_COMMAND         0x01
#define CCB_ALREADY_PENDING         0x02
#define CCB_ADAPTER_NOT_CLOSED      0x03
#define CCB_ADAPTER_NOT_OPEN        0x04
#define CCB_PARAMETERS_MISSING      0x05
#define CCB_INVALID_OPTION          0x06
#define CCB_COMMAND_CANCELLED       0x07
#define CCB_UNAUTHORIZED_ACCESS     0x08
#define CCB_ADAPTER_NOT_INITIALIZED 0x09
#define CCB_CANCELLED_BY_USER       0x0a
#define CCB_CANCELLED_IN_PROGRESS   0x0b
#define CCB_SUCCESS_ADAPTER_NOT_OPEN 0x0c

// hole - 0x0d to 0x0f

#define CCB_NETBIOS_FAILURE         0x10
#define CCB_TIMER_ERROR             0x11
#define CCB_NEED_MORE_WORK_AREA     0x12
#define CCB_INVALID_LOG_ID          0x13
#define CCB_INVALID_SHARED_SEGMENT  0x14
#define CCB_LOST_LOG_DATA           0x15
#define CCB_BUFFER_TOO_BIG          0x16
#define CCB_NETBIOS_CLASH           0x17
#define CCB_INVALID_SAP_BUFFER      0x18
#define CCB_NOT_ENOUGH_BUFFERS      0x19
#define CCB_USER_BUFFER_TOO_BIG     0x1a
#define CCB_INVALID_PARAMETER_POINTER 0x1b
#define CCB_INVALID_TABLE_POINTER   0x1c
#define CCB_INVALID_ADAPTER         0x1d
#define CCB_INVALID_FUNCTION_ADDRESS 0x1e

// hole - 0x1f

#define CCB_DATA_LOST_NO_BUFFERS    0x20
#define CCB_DATA_LOST_NO_SPACE      0x21
#define CCB_TRANSMIT_FS_ERROR       0x22
#define CCB_TRANSMIT_ERROR          0x23
#define CCB_UNAUTHORIZED_MAC_FRAME  0x24
#define CCB_MAX_COMMANDS_EXCEEDED   0x25
#define CCB_UNRECOGNIZED_CORRELATOR 0x26    // Not Used
#define CCB_LINK_NOT_OPEN           0x27
#define CCB_INVALID_FRAME_LENGTH    0x28

// hole - 0x29 to 0x2f

#define CCB_NOT_ENOUGH_BUFFERS_OPEN 0x30

// hole - 0x31

#define CCB_INVALID_NODE_ADDRESS    0x32
#define CCB_INVALID_RECEIVE_LENGTH  0x33
#define CCB_INVALID_TRANSMIT_LENGTH 0x34

// hole - 0x35 to 0x3f

#define CCB_INVALID_STATION_ID      0x40
#define CCB_PROTOCOL_ERROR          0x41
#define CCB_PARAMETER_EXCEEDS_MAX   0x42
#define CCB_INVALID_SAP_VALUE       0x43
#define CCB_INVALID_ROUTING_LENGTH  0x44
#define CCB_INVALID_GROUP_SAP       0x45
#define CCB_NOT_ENOUGH_LINK_STATIONS 0x46
#define CCB_CANNOT_CLOSE_SAP        0x47
#define CCB_CANNOT_CLOSE_GROUP_SAP  0x48
#define CCB_GROUP_SAP_FULL          0x49
#define CCB_SEQUENCE_ERROR          0x4a
#define CCB_STATION_CLOSED_NO_ACK   0x4b
#define CCB_COMMANDS_PENDING        0x4c
#define CCB_CANNOT_CONNECT          0x4d
#define CCB_SAP_NOT_IN_GROUP        0x4e
#define CCB_INVALID_REMOTE_ADDRESS  0x4f

#define MAX_CCB1_ERROR              CCB_INVALID_REMOTE_ADDRESS

#define NUMBER_OF_CCB1_ERRORS       (MAX_CCB1_ERROR + 1)    // including holes

//
// Error macros
//

#define IS_VALID_CCB1_COMMAND(command)  (command <= MAX_CCB1_COMMAND)
#define IS_VALID_CCB1_ERROR(error)      (error <= MAX_CCB1_ERROR)

//
// prototypes
//

VOID
DumpCcb(
    IN PVOID Ccb,
    IN BOOL DumpAll,
    IN BOOL CcbIsInput,
    IN BOOL IsDos,
    IN WORD Segment OPTIONAL,
    IN WORD Offset OPTIONAL
    );

VOID
DumpDosDlcBufferPool(
    IN PDOS_DLC_BUFFER_POOL PoolDescriptor
    );

VOID
DumpDosDlcBufferChain(
    IN DOS_ADDRESS DosAddress,
    IN DWORD BufferCount
    );

VOID
DumpReceiveDataBuffer(
    IN PVOID Buffer,
    IN BOOL IsDos,
    IN WORD Segment,
    IN WORD Offset
    );

LPSTR
MapCcbRetcode(
    IN BYTE Retcode
    );

BOOL
IsCcbErrorCodeAllowable(
    IN BYTE CcbCommand,
    IN BYTE CcbErrorCode
    );

BOOL
IsCcbErrorCodeValid(
    IN BYTE CcbErrorCode
    );

BOOL
IsCcbCommandValid(
    IN BYTE CcbCommand
    );

LPSTR
MapCcbCommandToName(
    IN BYTE CcbCommand
    );

VOID
DumpDosAdapter(
    IN DOS_ADAPTER* pDosAdapter
    );

//
// debug conditional macros
//

#if DBG
#define CHECK_CCB_COMMAND(pccb) \
            ASSERT(IsCcbCommandValid(((PLLC_DOS_CCB)pccb)->uchDlcCommand))
#define CHECK_CCB_RETCODE(pccb) \
            ASSERT(IsCcbErrorCodeAllowable(((PLLC_DOS_CCB)pccb)->uchDlcCommand, ((PLLC_DOS_CCB)pccb)->uchDlcStatus))
#else
#define CHECK_CCB_COMMAND(pccb)
#define CHECK_CCB_RETCODE(pccb)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\vrdlcpst.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1991  Nokia Data Systems

Module Name:

    vrdlcpst.c

Abstract:

    This module implements the call-back functions for DOS DLC CCBs. The call-
    backs are also referred to (in IBM terminology) as appendages or exits.
    These are executed asynchronously when a CCB request completes. Other
    asynchronous events can be generated such as adapter status change or
    network error. These latter types (& other similar events) are dependent
    upon the adapter hardware we are using - Token Ring or EtherNet (IBM Ether
    Link or PC Network), and are not expected to occur frequently (usually in
    error situations or where something bad happens to the net).

    We maintain a READ CCB for each supported adapter (2 per VDM). The READ
    will capture ALL events - command completions, data reception, status
    change, etc. When a READ CCB completes, we put it in a queue of completed
    CCBs and interrupt the VDM. The VDM must asynchronously call back to
    VrDlcHwInterrupt where it dequeues and processes the completed command at
    the head of the queue. The READ CCB has a pointer to the completed CCB or
    received data. If the READ is for a completed NT CCB then the CCB will have
    a pointer to the original DOS CCB. We have to get the original DOS CCB
    address from the NT CCB and complete the command with the relevant
    information contained in the READ/completed NT CCBs.

    We never expect the queue of pending completions/data receptions to grow
    very large, since DOS is single-tasking and unless it has interrupts
    disabled for a large part of the time, then the completion queue should be
    processed in a timely fashion

    Contents:
        VrDlcInitialize
        VrDlcHwInterrupt
        (FindCompletedRead)
        (ProcessReceiveFrame)
        (QueryEmulatedLocalBusyState)
        (SetEmulatedLocalBusyState)
        ResetEmulatedLocalBusyState
        (ResetEmulatedLocalBusyStateSap)
        (ResetEmulatedLocalBusyStateLink)
        (DeferReceive)
        (DeferAllIFrames)
        (RemoveDeferredReceive)
        (VrDlcEventHandlerThread)
        InitializeEventHandler
        InitiateRead
        (PutEvent)
        (PeekEvent)
        (GetEvent)
        (FlushEventQueue)
        (RemoveDeadReceives)
        (ReleaseReceiveResources)
        (IssueHardwareInterrupt)
        (AcknowledgeHardwareInterrupt)
        (CancelHardwareInterrupts)

Author:

    Antti Saarenheimo (o-anttis) 26-DEC-1991

Revision History:

    16-Jul-1992 rfirth
        Added queue and interrupt serialization; debugging

    19-Nov-1992 rfirth
        substantially modified event processing - use a queue per adapter;
        consolidated per-adapter data into DOS_ADAPTER structure; re-wrote
        local-busy processing

        Note: It turns out that a thread can recursively enter a critical
        section. The functions marked 'MUST [NOT] BE ENTERED WHILE HOLDING
        CRITICAL SECTION <foo>' could be altered

--*/

#include <nt.h>
#include <ntrtl.h>      // ASSERT, DbgPrint
#include <nturtl.h>
#include <windows.h>
#include <softpc.h>     // x86 virtual machine definitions
#include <vrdlctab.h>
#include <vdmredir.h>
#include "vrdebug.h"
#include <dlcapi.h>     // Official DLC API definition
#include <ntdddlc.h>    // IOCTL commands
#include <dlcio.h>      // Internal IOCTL API interface structures
#include "vrdlc.h"
#include "vrdlcdbg.h"
#define BOOL
#include <insignia.h>   // Insignia defines
#include <xt.h>         // half_word
#include <ica.h>        // ica_hw_interrupt
#include <vrica.h>      // call_ica_hw_interrupt

//
// defines
//

#define EVENT_THREAD_STACK  0   // 4096

//
// macros
//

//
// IS_LOCAL_BUSY - determines whether we have a LOCAL BUSY state active for a
// particular link station
//

#define IS_LOCAL_BUSY(adapter, stationId)   (QueryEmulatedLocalBusyState((BYTE)adapter, (WORD)stationId) == BUSY)

//
// private types
//

typedef enum {
    INDICATE_RECEIVE_FRAME,
    INDICATE_LOCAL_BUSY,
    INDICATE_COMPLETE_RECEIVE
} INDICATION;

typedef enum {
    CURRENT,
    DEFERRED
} READ_FRAME_TYPE;

//
// private prototypes
//

PLLC_CCB
FindCompletedRead(
    OUT READ_FRAME_TYPE* pFrameType
    );

INDICATION
ProcessReceiveFrame(
    IN OUT PLLC_CCB* ppCcb,
    IN LLC_DOS_CCB UNALIGNED * pDosCcb,
    IN LLC_DOS_PARMS UNALIGNED * pDosParms,
    OUT LLC_STATUS* Status
    );

LOCAL_BUSY_STATE
QueryEmulatedLocalBusyState(
    IN BYTE AdapterNumber,
    IN WORD StationId
    );

VOID
SetEmulatedLocalBusyState(
    IN BYTE AdapterNumber,
    IN WORD StationId
    );

BOOLEAN
ResetEmulatedLocalBusyStateSap(
    IN BYTE AdapterNumber,
    IN WORD StationId,
    IN BYTE DlcCommand
    );

BOOLEAN
ResetEmulatedLocalBusyStateLink(
    IN BYTE AdapterNumber,
    IN WORD StationId,
    IN BYTE DlcCommand
    );

VOID
DeferReceive(
    IN BYTE AdapterNumber,
    IN WORD StationId,
    IN PLLC_CCB pReadCcb
    );

VOID
DeferAllIFrames(
    IN BYTE AdapterNumber,
    IN WORD StationId
    );

PLLC_CCB
RemoveDeferredReceive(
    IN BYTE AdapterNumber,
    IN WORD StationId,
    OUT BOOLEAN* pDeferredFramesLeft
    );

DWORD
VrDlcEventHandlerThread(
    IN PVOID pParameter
    );

VOID
PutEvent(
    IN BYTE AdapterNumber,
    IN PLLC_CCB pCcb
    );

PLLC_CCB
PeekEvent(
    IN BYTE AdapterNumber
    );

PLLC_CCB
GetEvent(
    IN BYTE AdapterNumber
    );

VOID
FlushEventQueue(
    IN BYTE AdapterNumber
    );

VOID
RemoveDeadReceives(
    IN PLLC_CCB pCcb
    );

VOID
ReleaseReceiveResources(
    IN PLLC_CCB pCcb
    );

VOID
IssueHardwareInterrupt(
    VOID
    );

VOID
AcknowledgeHardwareInterrupt(
    VOID
    );

VOID
CancelHardwareInterrupts(
    IN LONG Count
    );

//
// external functions
//

extern ACSLAN_STATUS (*lpAcsLan)(IN OUT PLLC_CCB, OUT PLLC_CCB*);

extern
VOID
VrQueueCompletionHandler(
    IN VOID (*AsyncDispositionRoutine)(VOID)
    );

extern
VOID
VrRaiseInterrupt(
    VOID
    );

//
// external data
//

extern DOS_ADAPTER Adapters[DOS_DLC_MAX_ADAPTERS];

//
// private data
//

//
// aReadCcbs - for each adapter (max. 2) we have an NT READ CCB which is used
// to get received data which is returned to the DOS program via its RECEIVE
// CCB. Note that these are pointers to CCBs, not the actual CCBs. We also get
// status changes & command completions through the same mechanism. These are
// reflected to the VDM through the various 'appendages'
//
// NB: once initialized, this array is ONLY WRITTEN BY InitiateRead
//

PLLC_CCB aReadCcbs[DOS_DLC_MAX_ADAPTERS];

//
// aReadEvents - for each adapter (max. 2) we have a handle to an EVENT object.
// This is in the unsignalled state until an event completes the READ CCB.
// These are kept in an array because this is how WaitForMultipleObjects
// expects them
//

HANDLE aReadEvents[DOS_DLC_MAX_ADAPTERS];

//
// HardwareIntCritSec is used to protect updates to HardwareIntsQueued.
// HardwareIntsQueued is the number of outstanding hardware interrupt requests
// to the VDM. -1 means none outstanding, 0 is 1, etc.
//

#define NO_INTERRUPTS_PENDING   (-1)

static CRITICAL_SECTION HardwareIntCritSec;
static LONG HardwareIntsQueued = NO_INTERRUPTS_PENDING;

//
// hEventThread - handle of asynchronous event thread
//

static HANDLE hEventThread;


//
// routines
//

VOID
VrDlcInitialize(
    VOID
    )

/*++

Routine Description:

    Initializes critical sections that must always be available

Arguments:

    None.

Return Value:

    None.

--*/

{
    IF_DEBUG(DLC) {
        DPUT("VrDlcInitialize\n");
    }

    IF_DEBUG(CRITICAL) {
        CRITDUMP(("VrDlcInitialize\n"));
    }

    //
    // initialize the critical section for the event list
    //

    InitializeCriticalSection(&HardwareIntCritSec);
}


BOOLEAN
VrDlcHwInterrupt(
    VOID
    )

/*++

Routine Description:

    Procedure reads one DOS appendage call from the event queue
    and sets the initializes MS-DOS registers for the appendage
    call.  A NT DLC event may generate several DOS appendage calls.
    It is also possible, that no appendage call is needed.
    The event queue is incremented only after the last DOS appendage
    has been generated

Return Value:

    FALSE - the event queue was empty, poll the next interrupt handler
    TRUE - an event was handled successfully.

--*/

{
    BOOLEAN GetNewEvent = FALSE;    // default no extra events generated
    PLLC_CCB pReadCcb;              // READ CCB at head of EventQueue
    PLLC_READ_PARMS pReadParms;     // READ parameter table
    LLC_DOS_CCB UNALIGNED * pDosCcb;// flat 32-bit pointer to DOS CCB
    WORD cLeft;
    PLLC_CCB pCcb;
    LLC_CCB UNALIGNED * pFlatCcbAddr;
    LLC_DOS_PARMS UNALIGNED * pParms;
    DWORD iStation;
    static DWORD iCurrentTempStatus = 0;
    PLLC_BUFFER pNtFrame;           // pointer to received NT frame
    PLLC_DOS_RECEIVE_PARMS_EX pRcvParms;    // special NT rcv params for DOS
    LLC_STATUS Status;
    INDICATION indication;
    WORD buffersLeft;
    DOS_ADDRESS dpDosCcb;
    DOS_ADDRESS newAddress;
    READ_FRAME_TYPE frameType;
    BYTE adapterNumber;
    BYTE sapNumber;
    WORD stationId = 0;
    PLLC_CCB cancelledReceive = NULL;

#if DBG

    CHAR reasonCode;
    DWORD reasonCount;

#endif

    IF_DEBUG(DLC_ASYNC) {
        DPUT("VrDlcHwInterrupt entered\n");
    }

    //
    // preset the VDM flags to do nothing by default when control is returned
    // to the hardware interrupt service routine
    //

    SET_CALLBACK_NOTHING();

    //
    // This is called from the hardware interrupt handler in vrnetb.c. If there
    // are no events in the queue, then let the NetBIOS h/w interrupt handler
    // check if it has any completed NCBs. If there is something in the DLC
    // event queue then we will return info to the DOS box telling it that it
    // has a completed CCB; if there was something to complete for NetBIOS,
    // then it will have to wait until all pending DLC events are completed
    //

    pReadCcb = FindCompletedRead(&frameType);
    if (pReadCcb == NULL) {

        IF_DEBUG(DLC_ASYNC) {
            DPUT("*** VrDlcHwInterrupt: Error: no completed READs ***\n");
        }

        IF_DEBUG(CRITICAL) {
            CRITDUMP(("*** VrDlcHwInterrupt: Error: no completed READs ***\n"));
        }

        return FALSE;
    }

    IF_DEBUG(CRITICAL) {
        CRITDUMP(("*** VrDlcHwInterrupt: READ CCB Peeked @ %x ***\n", pReadCcb));
    }

    //
    // get the completion event and dispatch it
    //

    pReadParms = &pReadCcb->u.pParameterTable->Read;
    adapterNumber = pReadCcb->uchAdapterNumber;
    switch (pReadParms->uchEvent) {
    case LLC_EVENT_COMMAND_COMPLETION:

        //
        // Event 0x01
        //

        IF_DEBUG(DLC_ASYNC) {
            DPUT("VrDlcHwInterrupt: LLC_EVENT_COMMAND_COMPLETION\n");
        }

        //
        // Complete only the first CCB command in the list.
        // The completed receive CCBs are in the 32-bit flat address
        // space (we cannot pass them through to DOS because of
        // different buffer format between DOS and Nt (or OS/2)).
        //
        // Every completed receive command (the ones with receive data flag
        // are never completed here) uses LLC_DOS_SPECIAL_COMMAND as its
        // input flag, the command actual post routine address and the
        // original CCB address in DOS have been save to its parameter table.
        // The completion flag is zero, if the receive command is not
        // completed by a command completion routine.
        //

        pCcb = pReadParms->Type.Event.pCcbCompletionList;

        if (pReadParms->ulNotificationFlag == LLC_DOS_SPECIAL_COMMAND) {

            //
            // The DOS receive is yet another exception:
            // We cannot directly use the DOS receive CCB, because
            // the driver completes the command with the received data in
            // NT buffers => we have allocated a special receive CCB and
            // parameter table from 32-bit address space to execute
            // the same receive command.  We must now copy the received data
            // back to DOS buffer pools and then complete the original DOS
            // receive CCB
            //

            pRcvParms = (PVOID)READ_DWORD(&pCcb->u.pParameterTable);
            pDosCcb = DOS_PTR_TO_FLAT((PVOID)READ_DWORD(&pRcvParms->dpOriginalCcbAddress));

            //
            // Copy the received data only if the receive was successful
            //

            if (pCcb->uchDlcStatus == STATUS_SUCCESS ||
                pCcb->uchDlcStatus == LLC_STATUS_LOST_DATA_INADEQUATE_SPACE) {

                //
                // We must complete here all receive data commands regardless
                // if they have a DOS appendage. Zero value in appendage
                // means, that we don't call appendage routine.
                // (interrupt vectors don't usually include executable code).
                //

                if (pRcvParms->dpCompletionFlag != 0) {
                    setPostRoutine(pRcvParms->dpCompletionFlag);
                    setES(HIWORD(pRcvParms->dpOriginalCcbAddress));
                    setBX(LOWORD(pRcvParms->dpOriginalCcbAddress));
                    setAX((WORD)pCcb->uchDlcStatus);
                }
            } else {
                setPostRoutine(0);
            }
            pDosCcb->uchDlcStatus = pCcb->uchDlcStatus;
            cancelledReceive = pCcb;

        } else {

            //
            // On entry to the command completion appendage, the following
            // are set:
            //
            //      ES:BX = CCB address of the completed command.
            //      CX    = adapter number
            //      AL    = return code from CCB_RETCODE
            //      AH    = 0x00
            //

            pFlatCcbAddr = DOS_PTR_TO_FLAT(pCcb);
            setES(HIWORD(pCcb));
            setBX(LOWORD(pCcb));
            setCX((WORD)pFlatCcbAddr->uchAdapterNumber);
            setAX((WORD)pFlatCcbAddr->uchDlcStatus);
            setPostRoutine(pReadParms->ulNotificationFlag);

            IF_DEBUG(CRITICAL) {
                CRITDUMP(("COMMAND_COMPLETION: ANR=%04x:%04x CCB=%04x:%04x Type=%02x Status=%02x Adapter=%04x\n",
                         HIWORD(pReadParms->ulNotificationFlag),
                         LOWORD(pReadParms->ulNotificationFlag),
                         getES(),
                         getBX(),
                         pFlatCcbAddr->uchDlcCommand,
                         getAL(),
                         getCX()
                         ));
            }
        }
        break;

    case LLC_EVENT_TRANSMIT_COMPLETION:

        //
        // Event 0x02
        //

        IF_DEBUG(DLC_ASYNC) {
            DPUT("VrDlcHwInterrupt: LLC_EVENT_TRANSMIT_COMPLETION\n");
        }

        //
        // Map first CCB pointer and its parameter table to 32-bit addr space
        //

        pCcb = pReadParms->Type.Event.pCcbCompletionList;
        pFlatCcbAddr = (PLLC_CCB)DOS_PTR_TO_FLAT(pCcb);
        pParms = (PLLC_DOS_PARMS)DOS_PTR_TO_FLAT(READ_DWORD(&pFlatCcbAddr->u.pParameterTable));

        IF_DEBUG(TX_COMPLETE) {
            DPUT3("VrDlcHwInterrupt: pCcb=%x pFlatCcbAddr=%x pParms=%x\n",
                    pCcb,
                    pFlatCcbAddr,
                    pParms
                    );
        }

        //
        // there may be several completed transmit CCBs chained together
        //

        if (--pReadParms->Type.Event.usCcbCount) {

            //
            // RLF 09/24/92
            //
            // If there are multiple completions linked together then we leave
            // this READ CCB at the head of the queue. Decrement the number of
            // CCBs left and update the pointer to the next one
            //

            pReadParms->Type.Event.pCcbCompletionList = (PLLC_CCB)READ_DWORD(&pFlatCcbAddr->pNext);
            WRITE_DWORD(&pFlatCcbAddr->pNext, 0);
            pReadCcb = NULL;
            GetNewEvent = TRUE;

            IF_DEBUG(DLC_ASYNC) {
                DPUT2("VrDlcHwInterrupt: next Tx completion: %04x:%04x\n",
                        HIWORD(pReadParms->Type.Event.pCcbCompletionList),
                        LOWORD(pReadParms->Type.Event.pCcbCompletionList)
                        );
            }

#if DBG

            reasonCode = 'T';
            reasonCount = pReadParms->Type.Event.usCcbCount;

#endif

        }

        //
        // The second transmit queue must be returned to the buffer pool IF the
        // transmit was successful
        //

        if (pFlatCcbAddr->uchDlcStatus == LLC_STATUS_SUCCESS && READ_DWORD(&pParms->Transmit.pXmitQueue2)) {

            IF_DEBUG(DLC_ASYNC) {
                DPUT2("VrDlcHwInterrupt: freeing XmitQueue2 @ %04x:%04x\n",
                        GET_SEGMENT(&pParms->Transmit.pXmitQueue2),
                        GET_OFFSET(&pParms->Transmit.pXmitQueue2)
                        );
            }

            //
            // p2-47 IBM LAN Tech Ref:
            //
            //  "Buffers in XMIT_QUEUE_TWO are freed by the adapter support
            //   software if the transmission is successful (return code is
            //   zero)."
            //

            FreeBuffers(GET_POOL_INDEX(pFlatCcbAddr->uchAdapterNumber,
                                       READ_WORD(&pParms->Transmit.usStationId)
                                       ),
                        (DPLLC_DOS_BUFFER)READ_DWORD(&pParms->Transmit.pXmitQueue2),
                        &cLeft
                        );

            IF_DEBUG(DLC_ASYNC) {
                DPUT1("VrDlcHwInterrupt: after FreeBuffers: %d buffers left\n", cLeft);
//                DUMPCCB(pFlatCcbAddr,
//                        TRUE,           // DumpAll
//                        FALSE,          // CcbIsInput
//                        TRUE,           // IsDos
//                        HIWORD(pCcb),   // Segment
//                        LOWORD(pCcb)    // Offset
//                        );
            }

            //
            // p3-105 IBM LAN Tech Ref:
            //
            //  "Before taking an appendage exit or posting completion, the
            //   buffers in this queue are returned to the SAP buffer pool
            //   and this field set to zero upon command completion if the
            //   return code equals zero (X'00)."
            //

            WRITE_DWORD(&pParms->Transmit.pXmitQueue2, 0);
        }

        //
        // this is a real asynchronous notification - we must asynchronously
        // call a DOS appendage routine - set up registers:
        //
        //  ES:BX = completed (transmit) CCB
        //  CX    = adapter number
        //  AL    = return status
        //  AH    = 0x00
        //

        setPostRoutine(pReadParms->ulNotificationFlag);
        setES(HIWORD(pCcb));
        setBX(LOWORD(pCcb));
        setCX((WORD)pFlatCcbAddr->uchAdapterNumber);
        setAX((WORD)pFlatCcbAddr->uchDlcStatus);

        IF_DEBUG(CRITICAL) {
            CRITDUMP(("TRANSMIT_COMPLETION: ANR=%04x:%04x CCB=%04x:%04x Type=%02x Status=%02x Adapter=%04x\n",
                     HIWORD(pReadParms->ulNotificationFlag),
                     LOWORD(pReadParms->ulNotificationFlag),
                     getES(),
                     getBX(),
                     pFlatCcbAddr->uchDlcCommand,
                     getAL(),
                     getCX()
                     ));
        }

        break;

    case LLC_EVENT_RECEIVE_DATA:

        //
        // Event 0x04
        //

        IF_DEBUG(DLC_ASYNC) {
            DPUT("VrDlcHwInterrupt: LLC_EVENT_RECEIVE_DATA\n");

            //
            // dump the NT extended RECEIVE + parms
            //

            DUMPCCB((PLLC_CCB)(pReadParms->ulNotificationFlag),
                    TRUE,   // DumpAll
                    FALSE,  // CcbIsInput
                    FALSE,  // IsDos
                    0,      // Segment
                    0       // Offset
                    );
        }

        /***********************************************************************

        picture this, if you will

        NT READ CCB

        +---------+
        |         |
        |         |                   NT RECEIVE CCB
        |         |
        |         |                   +---------+
        |         |                   |         |
        |         |                   |         |
        |         |                   |         |
        | u.pParameterTable-+         |         |
        +---------+         |         |         |
                            |         |         |
                            |         |         |
                            |         | u.pParameterTable-+
                            |         +---------+         |
                            v              ^              |
                       +---------+         |              |
        NT READ parms  |         |         |              |
                       |         |         |              v
                       |         |         |         +---------+ EXTENDED NT
                       |ulNotificationFlag-+         |         | RECEIVE PARMS
                       |         |                   |         |
                       |pFirstBuffer--+              |         |
                       |         |    |              |         |
                       +---------+    |              |         |
                                      |              |         |
                                      |              |         |
                                      |              |dpOrigininalCcbAddress
                                      |              +---------+      |
                                      v                               |
                                 +---------+                          |
                                 |         |                          |
          first NT receive frame |         |                          v
                                 |         |                     +---------+
                                 |         |         DOS RECEIVE |         |
                                 |         |             CCB     |         |
                                 |         |                     |         |
                                 |         |                     |         |
                                 |         |                     |         |
                                 +---------+                     |         |
                                                                 |         |
                                                           +----------     |
                                                           |     +---------+
                                                           |
                                                           |
                                                           |
                                                           v
                                                      +---------+
                                    DOS RECEIVE parms |         |
                                                      |         |
                                                      |         |
                                                      |         |
                                                      |         |
                                                      |         |
                                                      |      - - - - -> DOS
                                                      |         |   receive
                                                      |         |      data
                                                      +---------+   buffers

        to avoid the DLC device driver writing to the DOS RECEIVE parameter
        table (because the NT RECEIVE parameter table is larger, and the
        driver will corrupt DOS memory if we give it a DOS RECEIVE CCB), the
        RECEIVE CCB is actually an NT RECEIVE CCB. The RECEIVE parameters are
        in an extended table which contains the DOS address of the original
        DOS RECEIVE CCB. When completing a DOS RECEIVE, we have to copy the
        data from the NT frame to DOS buffers and put the address of the DOS
        buffers in the DOS RECEIVE parameter table then call the DOS receive
        data appendage

        ***********************************************************************/

        pDosCcb = (PLLC_DOS_CCB)pReadParms->ulNotificationFlag;
        dpDosCcb = ((PLLC_DOS_RECEIVE_PARMS_EX)pDosCcb->u.pParms)->dpOriginalCcbAddress;
        pDosCcb = (PLLC_DOS_CCB)DOS_PTR_TO_FLAT(dpDosCcb);
        pParms = (PLLC_DOS_PARMS)READ_FAR_POINTER(&pDosCcb->u.pParms);
        pNtFrame = pReadParms->Type.Event.pReceivedFrame;
        stationId = pNtFrame->Contiguous.usStationId;
        sapNumber = SAP_ID(stationId);

        IF_DEBUG(RX_DATA) {
            DPUT3("VrDlcHwInterrupt: pNtFrame=%x pDosCcb=%x pParms=%x\n",
                    pNtFrame, pDosCcb, pParms);
        }

        //
        // call ProcessReceiveFrame to find out what to do with this frame. If
        // we accepted it then we can free the READ CCB and received NT buffer
        // else we have to indicate local busy. N.B. The READ CCB pointed to
        // by pReadCcb may well be a different READ CCB when this function
        // returns
        //

        indication = ProcessReceiveFrame(&pReadCcb, pDosCcb, pParms, &Status);
        switch (indication) {
        case INDICATE_RECEIVE_FRAME:

            //
            // we have an I-Frame to indicate to the VDM. If we got the I-Frame
            // from the deferred queue then generate another h/w interrupt
            //

            IF_DEBUG(RX_DATA) {
                DPUT("INDICATE_RECEIVE_FRAME\n");
            }

            //
            // set up the registers for the data received appendage:
            //
            //  DS:SI = RECEIVE CCB
            //  ES:BX = received data buffer (Buffer 1)
            //  CX    = adapter number
            //  AL    = return code - STATUS_SUCCESS
            //  AH    = 0x00
            //

            setDS(HIWORD(dpDosCcb));
            setSI(LOWORD(dpDosCcb));
            setES(GET_SEGMENT(&pParms->Receive.pFirstBuffer));
            setBX(GET_OFFSET(&pParms->Receive.pFirstBuffer));
            setAX((WORD)LLC_STATUS_SUCCESS);
            setCX((WORD)pReadCcb->uchAdapterNumber);
            setPostRoutine(READ_DWORD(&pParms->Receive.ulReceiveExit));

            IF_DEBUG(CRITICAL) {
                CRITDUMP(("DATA_COMPLETION: ANR=%04x:%04x CCB=%04x:%04x Type=%02x Status=%02x Adapter=%04x\n",
                         HIWORD(READ_DWORD(&pParms->Receive.ulReceiveExit)),
                         LOWORD(READ_DWORD(&pParms->Receive.ulReceiveExit)),
                         getDS(),
                         getSI(),
                         pDosCcb->uchDlcCommand,
                         getAL(),
                         getCX()
                         ));
            }

            IF_DEBUG(ASYNC_EVENT) {
                DUMPCCB(POINTER_FROM_WORDS(getDS(), getSI()),
                        TRUE,   // DumpAll
                        FALSE,  // CcbIsInput
                        TRUE,   // IsDos
                        getDS(),// Segment
                        getSI() // Offset
                        );
            }

            IF_DEBUG(RX_DATA) {
                DPUT5("VrDlcHwInterrupt: received data @ %04x:%04x, CCB @ %04x:%04x. status=%02x\n",
                        getES(),
                        getBX(),
                        getDS(),
                        getSI(),
                        getAL()
                        );
            }

            break;

        case INDICATE_LOCAL_BUSY:

            //
            // we have an I-Frame to receive, but no buffers. We have put NT
            // DLC into LOCAL BUSY (Buffer) state for this link, we must tell
            // the VDM that we are in LOCAL BUSY state
            //

            IF_DEBUG(RX_DATA) {
                DPUT("INDICATE_LOCAL_BUSY\n");
            }

            //
            // generate a DLC Status Change event & status table
            //

            iStation = iCurrentTempStatus++ & 7;
            RtlZeroMemory((LPBYTE)&lpVdmWindow->aStatusTables[iStation], sizeof(struct _DOS_DLC_STATUS));
            WRITE_WORD(&((PDOS_DLC_STATUS)&lpVdmWindow->aStatusTables[iStation])->usStationId, stationId);
            WRITE_WORD(&((PDOS_DLC_STATUS)&lpVdmWindow->aStatusTables[iStation])->usDlcStatusCode, LLC_INDICATE_LOCAL_STATION_BUSY);

            //
            // Set the registers for DLC status change event: ES:BX point to the
            // DLC status table containing the additional information; AX contains
            // the status code; CX contains the adapter number; SI contains the
            // value specified for USER_STAT_VALUE in the DLC.OPEN.SAP
            //

            newAddress = NEW_DOS_ADDRESS(dpVdmWindow, &lpVdmWindow->aStatusTables[iStation]);
            setES(HIWORD(newAddress));
            setBX(LOWORD(newAddress));
            setAX(LLC_INDICATE_LOCAL_STATION_BUSY);
            setCX((WORD)adapterNumber);
            setSI(Adapters[adapterNumber].UserStatusValue[sapNumber]);
            setPostRoutine(Adapters[adapterNumber].DlcStatusChangeAppendage[sapNumber]);

            IF_DEBUG(STATUS_CHANGE) {
                DPUT5("VrDlcHwInterrupt: Status Change info: ES:BX=%04x:%04x, AX=%04x, CX=%04x, SI=%04x\n",
                        getES(),
                        getBX(),
                        getAX(),
                        getCX(),
                        getSI()
                        );
                DPUT4("VrDlcHwInterrupt: Status Change Exit = %04x:%04x, StationId=%04x, StatusCode=%04x\n",
                        HIWORD(Adapters[adapterNumber].DlcStatusChangeAppendage[sapNumber]),
                        LOWORD(Adapters[adapterNumber].DlcStatusChangeAppendage[sapNumber]),
                        ((PDOS_DLC_STATUS)&lpVdmWindow->aStatusTables[iStation])->usStationId,
                        ((PDOS_DLC_STATUS)&lpVdmWindow->aStatusTables[iStation])->usDlcStatusCode
                        );
            }

            IF_DEBUG(CRITICAL) {
                CRITDUMP(("LOCAL_BUSY: ES:BX=%04x:%04x, AX=%04x, CX=%04x, SI=%04x\n"
                         "Status Change Exit = %04x:%04x, StationId=%04x, StatusCode=%04x\n",
                         getES(),
                         getBX(),
                         getAX(),
                         getCX(),
                         getSI(),
                         HIWORD(Adapters[adapterNumber].DlcStatusChangeAppendage[sapNumber]),
                         LOWORD(Adapters[adapterNumber].DlcStatusChangeAppendage[sapNumber]),
                         ((PDOS_DLC_STATUS)&lpVdmWindow->aStatusTables[iStation])->usStationId,
                         ((PDOS_DLC_STATUS)&lpVdmWindow->aStatusTables[iStation])->usDlcStatusCode
                         ));
            }
            break;

        case INDICATE_COMPLETE_RECEIVE:

            //
            // a non I-Frame cannot be completed due to insufficient buffers.
            // We will discard the frame, but we have to complete the
            // outstanding RECEIVE, which means CANCELLING the outstanding
            // NT RECEIVE (assuming that it didn't complete due to real LOCAL
            // BUSY state)
            //

            IF_DEBUG(RX_DATA) {
                DPUT("INDICATE_COMPLETE_RECEIVE\n");
            }

            //
            // cancel the NT RECEIVE
            //

            ReceiveCancel(pReadCcb->uchAdapterNumber,
                          pReadParms->ulNotificationFlag
                          );

            //
            // we must delete any pending receives which reference this RECEIVE CCB
            //

            cancelledReceive = (PLLC_CCB)pReadParms->ulNotificationFlag;

            //
            // set up the registers to call the command completion appendage
            // for the failed RECEIVE command
            //

            setES(HIWORD(dpDosCcb));
            setBX(LOWORD(dpDosCcb));
            setAL((UCHAR)Status);
            setPostRoutine(READ_DWORD(&pDosCcb->ulCompletionFlag));
            WRITE_BYTE(&pDosCcb->uchDlcStatus, Status);

            IF_DEBUG(CRITICAL) {
                CRITDUMP(("COMPLETE_RECEIVE: ANR=%04x:%04x CCB=%04x:%04x Type=%02x Status=%02x\n",
                         HIWORD(READ_DWORD(&pDosCcb->ulCompletionFlag)),
                         LOWORD(READ_DWORD(&pDosCcb->ulCompletionFlag)),
                         getES(),
                         getBX(),
                         pDosCcb->uchDlcCommand,
                         getAL()
                         ));
            }
            break;
        }

        //
        // if we have a non-NULL READ CCB pointer then we have to free the
        // NT buffer and free the CCB
        //

        if (pReadCcb) {
            BufferFree(pReadCcb->uchAdapterNumber,
                       pReadCcb->u.pParameterTable->Read.Type.Event.pReceivedFrame,
                       &buffersLeft
                       );
        }
        break;

    case LLC_EVENT_STATUS_CHANGE:

        //
        // Event 0x08, 0x10, 0x20 & 0x40?
        //

        IF_DEBUG(DLC_ASYNC) {
            DPUT("VrDlcHwInterrupt: LLC_EVENT_STATUS_CHANGE\n");
        }

        //
        // This heuristics tries to minimize the risk of overwritten
        // DLC status indications and minimize the needed DOS memory.
        // The first 5 link stations on each adapter has permanent
        // status tables => apps requiring permanent status tables
        // works fine up to 5 link connections.  The first opened
        // adapter may use also slots 5 - 10 for permanent status tables,
        // if there is only one opened adapter.  The last 5 slots
        // are always reserved to routing of the status indications.
        // This implementation takes 300 bytes DOS memory.  The full
        // support of all possible 510 link stations would take 10 kB memory.
        // It's better save 10 kB DOS memory and have no configuration
        // parameters, and accept a very low error probability
        //

        //
        // decrement the station ID by 1 since we always start at station 1
        // (0 is the SAP)
        //

        iStation = (pReadParms->Type.Status.usStationId & 0x00ff) - 1;
        if (OpenedAdapters == 1 && iStation < DOS_DLC_STATUS_PERM_SLOTS) {

            //
            // We have only one adapter, use slots 1 - 10 for permanent tables
            //

            ;   // NOP

        } else if (OpenedAdapters == 2 && iStation < (DOS_DLC_STATUS_PERM_SLOTS / 2)) {

            //
            // We have two adapters, use 5 slots for each adapter
            // to have permanent status tables at least for the
            // first station ids
            //

            iStation += (DOS_DLC_STATUS_PERM_SLOTS / 2) * adapterNumber;
        } else {

            //
            // Use the slots reserve for temporary DLC status indications
            //

            iStation = iCurrentTempStatus;
            iCurrentTempStatus = (iCurrentTempStatus + 1) % DOS_DLC_STATUS_TEMP_SLOTS;
        }

        //
        // We must copy the DLC status block to the VDM address space. Note we
        // actually use 3 bytes more than the CCB1 status tables, but since we
        // are using pointers, it shouldn't matter
        //

        RtlCopyMemory((LPBYTE)&lpVdmWindow->aStatusTables[iStation],
                      &pReadParms->Type.Status,
                      sizeof(struct _DOS_DLC_STATUS)
                      );

        //
        // Set the registers for DLC status change event: ES:BX point to the
        // DLC status table containing the additional information; AX contains
        // the status code; CX contains the adapter number; SI contains the
        // value specified for USER_STAT_VALUE in the DLC.OPEN.SAP
        //

        newAddress = NEW_DOS_ADDRESS(dpVdmWindow, &lpVdmWindow->aStatusTables[iStation]);
        setES(HIWORD(newAddress));
        setBX(LOWORD(newAddress));
        setAX(pReadParms->Type.Status.usDlcStatusCode);
        setCX((WORD)pReadCcb->uchAdapterNumber);
        setSI(pReadParms->Type.Status.usUserStatusValue);
        setPostRoutine(pReadParms->ulNotificationFlag);

        IF_DEBUG(CRITICAL) {
            CRITDUMP(("STATUS_CHANGE: ANR=%04x:%04x Status Table=%04x:%04x Status=%04x Adapter=%04x\n",
                     HIWORD(pReadParms->ulNotificationFlag),
                     LOWORD(pReadParms->ulNotificationFlag),
                     getES(),
                     getBX(),
                     getAX(),
                     getCX()
                     ));
        }

        IF_DEBUG(STATUS_CHANGE) {
            DPUT5("VrDlcHwInterrupt: Status Change info: ES:BX=%04x:%04x, AX=%04x, CX=%04x, SI=%04x\n",
                    getES(),
                    getBX(),
                    getAX(),
                    getCX(),
                    getSI()
                    );
            DPUT4("VrDlcHwInterrupt: Status Change Exit = %04x:%04x, StationId=%04x, StatusCode=%04x\n",
                    HIWORD(pReadParms->ulNotificationFlag),
                    LOWORD(pReadParms->ulNotificationFlag),
                    ((PDOS_DLC_STATUS)&lpVdmWindow->aStatusTables[iStation])->usStationId,
                    ((PDOS_DLC_STATUS)&lpVdmWindow->aStatusTables[iStation])->usDlcStatusCode
                    );
        }

        break;

    default:

        //
        // This should be impossible!
        //

        DPUT("VrDlcHwInterrupt: this is an impossible situation!\n");

        IF_DEBUG(CRITICAL) {
            CRITDUMP(("VrDlcHwInterrupt: this is an impossible situation!\n"));
        }

        break;
    }

    //
    // if pReadCcb is not NULL, free the READ CCB & parameter table. If it is
    // NULL then this means we did not complete processing of the READ CCB -
    // it has more than 1 transmit CCB chained to it or it is a received frame
    // which is on the deferred queue
    //

    if (pReadCcb) {
        if (frameType == CURRENT) {

            //
            // RLF 09/24/92
            //
            // Remove the READ CCB from the head of the queue using GetEvent
            // before freeing it. We got the pointer to the completed READ CCB
            // from PeekEvent which left the READ at the head of the queue in
            // case we needed to access the same completed READ for multiple
            // transmit completions
            //

#if DBG

            //
            // ensure that the CCB that we are removing from the head of the queue
            // is the same one returned by PeekEvent
            //

            {
                PLLC_CCB CcbAtQueueHead;

                CcbAtQueueHead = GetEvent(adapterNumber);
                if (pReadCcb != CcbAtQueueHead) {
                    DbgPrint("VrDlcHwInterrupt: "
                             "*** ERROR: GetEvent CCB (%x) != PeekEvent CCB (%x) ***\n",
                             CcbAtQueueHead,
                             pReadCcb
                             );
                    DbgBreakPoint();
                }
            }

#else

            GetEvent(adapterNumber);

#endif
        } else {

            //
            // READ CCB is at head of deferred queue. Remove it. If there are
            // any more READ CCBs queued on this deferred queue then we have
            // to generate an extra h/w interrupt
            //

            //
            // PYS 03/18/02
            //
            // There are two cases where pReadCcb is NULL. Either
            // LLC_EVENT_RECEIVE_DATA which calls ProcessReceiveFrame
            // in which case we do have a valid stationId or
            // LLC_EVENT_TRANSMIT_COMPLETE, in which case stationId is
            // uninitialize as prefix will warn on the two calls down
            // here with stationId. Since RemoveDeferredReceive asserts
            // on 0 stationId, I added it as a sentinel above and will
            // not call it when it occurs. I don't know how to generate
            // this, so I leave a breakpoint in debug to catch this.
            // 
            //

#if DBG
            {
                // ensure that the CCB that we are removing from the head of the queue
                // is the same one returned by FindCompletedRead
                //

                PLLC_CCB CcbAtQueueHead;

                CcbAtQueueHead = RemoveDeferredReceive(adapterNumber, stationId, &GetNewEvent);
                if (pReadCcb != CcbAtQueueHead) {
                    DbgPrint("VrDlcHwInterrupt: "
                                "*** ERROR: GetEvent CCB (%x) != PeekEvent CCB (%x) ***\n",
                                CcbAtQueueHead,
                                pReadCcb
                                );
                    DbgBreakPoint();
                }
                if (GetNewEvent) {
                    reasonCode = 'R';
                    reasonCount = Adapters[adapterNumber].LocalBusyInfo[LINK_ID(stationId)].Depth;
                }
            }
#else

            RemoveDeferredReceive(adapterNumber, stationId, &GetNewEvent);

#endif
        }

        LocalFree((HLOCAL)pReadCcb);

        IF_DEBUG(DLC_ALLOC) {
            DPUT1("FREE: freed block @ %x\n", pReadCcb);
        }

    }

    //
    // RLF 09/24/92
    //
    // Re-ordered issuing h/w int & removing freeing READ CCB since now that
    // we peek first & remove later, we must be sure that a fully completed
    // READ CCB is removed from the queue before we request a new h/w
    // interrupt. I am not expecting this to be re-entered, but who knows
    // what might happen on a MP machine?
    //

    if (GetNewEvent) {

        //
        // The event generates more than one appendage call. We need a new
        // h/w interrupt for each extra appendage call
        //

#if DBG

        IF_DEBUG(DLC_ASYNC) {
            DPUT2("*** Calling ica_hw_interrupt from within ISR. Cause = %d %s ***\n",
                    reasonCount,
                    reasonCode == 'T' ? "multiple transmits" : "deferred I-Frames"
                    );
        }

        IF_DEBUG(CRITICAL) {
            CRITDUMP(("*** Calling ica_hw_interrupt from within ISR. Cause = %d %s ***\n",
                        reasonCount,
                        reasonCode == 'T' ? "multiple transmits" : "deferred I-Frames"
                        ));
        }

#endif

        IssueHardwareInterrupt();
    }

    //
    // if an NT RECEIVE CCB was completed or terminated, remove any pending
    // READ CCBs completed by received data events which reference the terminated
    // RECEIVE
    //

    if (cancelledReceive) {
        RemoveDeadReceives(cancelledReceive);

        LocalFree(cancelledReceive);

        IF_DEBUG(DLC_ALLOC) {
            DPUT1("FREE: freed block @ %x\n", cancelledReceive);
        }
    }

    //
    // acknowledge this hardware interrupt, meaning decrement the interrupt
    // counter and issue a new request if we've got interrupts outstanding
    //

    AcknowledgeHardwareInterrupt();

    //
    // return TRUE to indicate that we have accepted the hw interrupt
    //

    return TRUE;
}


PLLC_CCB
FindCompletedRead(
    OUT READ_FRAME_TYPE* pFrameType
    )

/*++

Routine Description:

    Finds the next READ CCB to process - first looks at the event queue of
    current completed CCBs, then at the deferred I-Frame queue.

    This routine attempts to bounce between both adapters if they are both
    active, in order not to only service the most active adapter and ignore
    for a long period of time pending completed CCBs on the less active
    adapter

    NOTE: we only return a deferred I-Frame when the app has issued
    DLC.FLOW.CONTROL against the station

Arguments:

    pFrameType  - returns the type of event found - CURRENT (event READ is at
                  head of EventQueue) or DEFERRED (event READ is at head of
                  a LOCAL_BUSY_INFO queue)

Return Value:

    PLLC_CCB
        pointer to completed READ CCB. The CCB is NOT DEQUEUED - the caller
        must do that when the event has been completely disposed of to the VDM

--*/

{
    DWORD i;
    PLLC_CCB pCcb = NULL;
    static BYTE ThisAdapter = 0;

    for (i = 0; !Adapters[ThisAdapter].IsOpen && i < DOS_DLC_MAX_ADAPTERS; ++i) {
        ThisAdapter = (ThisAdapter + 1) & (DOS_DLC_MAX_ADAPTERS - 1);
    }
    if (i == DOS_DLC_MAX_ADAPTERS) {

        //
        // no adapters alive?
        //

        IF_DEBUG(DLC_ASYNC) {
            DPUT("*** FindCompletedRead: no open adapters??? ***\n");
        }

        return NULL;
    }

    //
    // RLF 09/24/92
    //
    // Changed GetEvent to PeekEvent: if there are multiple chained completed
    // CCBs (transmit+?) then we have to leave the READ CCB @ the head of the
    // queue until we have generated call-backs for all chained completions.
    // Only when there are no more completions can we remove the READ CCB from
    // the queue (using GetEvent)
    //

    if (pCcb = PeekEvent(ThisAdapter)) {
        *pFrameType = CURRENT;
    } else {

        //
        // see if there are any deferred I-Frames
        //

        IF_DEBUG(CRITSEC) {
            DPUT1("FindCompletedRead: ENTERING Adapters[%d].LocalBusyCritSec\n",
                  ThisAdapter
                  );
        }

        EnterCriticalSection(&Adapters[ThisAdapter].LocalBusyCritSec);

        //
        // DeferredReceives is a reference count of link stations in emulated
        // local-busy(buffer) state. They can be BUSY or CLEARING. We are only
        // interested in CLEARING: this means that the app has issued
        // DLC.FLOW.CONTROL to us & presumably has returned some buffers via
        // BUFFER.FREE (if not, we just go back to BUSY state)
        //

        if (Adapters[ThisAdapter].DeferredReceives) {
            for (i = Adapters[ThisAdapter].FirstIndex;
                 i <= Adapters[ThisAdapter].LastIndex; ++i) {
                if (Adapters[ThisAdapter].LocalBusyInfo[i].State == CLEARING) {
                    if (pCcb = Adapters[ThisAdapter].LocalBusyInfo[i].Queue) {
                        *pFrameType = DEFERRED;
                        break;
                    }
                }
            }
        }

        IF_DEBUG(CRITSEC) {
            DPUT1("FindCompletedRead: LEAVING Adapters[%d].LocalBusyCritSec\n",
                  ThisAdapter
                  );
        }

        LeaveCriticalSection(&Adapters[ThisAdapter].LocalBusyCritSec);
    }

    IF_DEBUG(DLC_ASYNC) {
        DPUT2("FindCompletedRead: returning READ CCB @ %08x type is %s\n",
                pCcb,
                *pFrameType == DEFERRED ? "DEFERRED" : "CURRENT"
                );
    }

    //
    // next time in, try the other adapter first
    //

    ThisAdapter = (ThisAdapter + 1) & (DOS_DLC_MAX_ADAPTERS - 1);

    return pCcb;
}


INDICATION
ProcessReceiveFrame(
    IN OUT PLLC_CCB* ppCcb,
    IN LLC_DOS_CCB UNALIGNED * pDosCcb,
    IN LLC_DOS_PARMS UNALIGNED * pDosParms,
    OUT LLC_STATUS* Status
    )

/*++

Routine Description:

    Determines what to do with a received frame. We try to copy the received
    frame to DOS buffers, but if we have insufficient buffers then we must
    queue or discard the frame. We queue the frame only if it is an I-Frame.
    We must first check the queue of deferred received frames or else risk
    getting out-of-sequence received data in the DOS client.

    When this routine is called, *ppCcb points at one of:

        1.  A deferred I-Frame READ CCB
        2.  A current received data READ CCB, I-Frame or other MAC/data

    NOTE: Deferred I-Frames that are for stations whose local-busy(buffer)
          state has been cleared by the app take precedence over the event
          at the head of the EventQueue

Arguments:

    ppCcb       - pointer to new READ CCB. On output, this will be a non-NULL
                  value if we are to free the CCB and the received NT frame
                  buffer. If we placed the read on the deferred receive queue
                  then we return a NULL

    pDosCcb     - pointer to DOS CCB

    pDosParms   - pointer to DOS RECEIVE parameter table. If we copy - entirely
                  or partially - a frame, the DOS buffer chain is linked to
                  the DOS RECEIVE parameter table at FIRST_BUFFER

    Status      - if the frame was copied, contains the status to return to the
                  DOS appendage:

                    LLC_STATUS_SUCCESS
                        The frame was completely copied to the DOS buffer(s)

                    LLC_STATUS_LOST_DATA_NO_BUFFERS
                        The frame could not be copied to the DOS buffers and
                        has been discarded. There were NO buffers available.
                        The frame was NOT an I-Frame

                    LLC_STATUS_LOST_DATA_INADEQUATE_SPACE
                        The frame has been partially copied to the DOS buffer(s),
                        but the rest of it had to be discarded, because not
                        enough DOS buffers were available. The frame was NOT an
                        I-Frame

                  Status is only meaningful when INDICATE_COMPLETE_RECEIVE is
                  returned

Return Value:

    INDICATION
        INDICATE_RECEIVE_FRAME
            We copied the frame to DOS buffers. Free the CCB and NT buffer and
            return the frame to DOS

        INDICATE_LOCAL_BUSY
            We couldn't copy the received I-Frame to DOS buffers because we don't
            have enough of them. We have put the NT link station into LOCAL BUSY
            (Buffer) state. Indicate local busy to the VDM

        INDICATE_COMPLETE_RECEIVE
            We couldn't copy the received non I-Frame to DOS buffers. Complete
            the DOS RECEIVE command with an error

--*/

{
    PLLC_CCB pCcb = *ppCcb;
    PLLC_PARMS pParms = pCcb->u.pParameterTable;
    PLLC_BUFFER pFrame = pParms->Read.Type.Event.pReceivedFrame;
    UCHAR adapter = pCcb->uchAdapterNumber;
    WORD stationId = pFrame->Contiguous.usStationId;
    WORD numBufs;
    WORD bufferSize;
    WORD buffersAvailable;
    WORD nLeft;
    DPLLC_DOS_BUFFER dosBuffers;
    INDICATION indication;
    LLC_STATUS status;
    DWORD flags;

    IF_DEBUG(DLC_ASYNC) {
        DPUT2("ProcessReceiveFrame: adapter=%d, stationId=%x\n", adapter, stationId);
    }

    //
    // make sure we don't read or write bogus Adapter structure
    //

    ASSERT(adapter < DOS_DLC_MAX_ADAPTERS);

    //
    // we are NOT chaining receive frames. DOS receive frame processing assumes
    // that we get one frame at a time. Assert that it is so
    //

    ASSERT(pFrame->Contiguous.pNextFrame == NULL);

    //
    // get the contiguous and break flags for CopyFrame based on the RECEIVE options
    //

    flags = ((pFrame->Contiguous.uchOptions & (LLC_CONTIGUOUS_MAC | LLC_CONTIGUOUS_DATA))
                ? CF_CONTIGUOUS : 0)
            | ((pFrame->Contiguous.uchOptions & LLC_BREAK) ? CF_BREAK : 0);

    //
    // calculate the number of buffers required to receive this frame
    //

    numBufs = CalculateBufferRequirement(adapter,
                                         stationId,
                                         pFrame,
                                         pDosParms,
                                         &bufferSize
                                         );

    //
    // if the frame is an I-Frame then we have to perform these checks:
    //
    //  1.  if there is already a deferred packet for this station ID/adapter
    //      then we must try to receive this before the frame in hand
    //
    //  2.  if there aren't sufficient buffers for the request then we must
    //      queue this frame on the deferred queue (if it isn't there already)
    //      and indicate that we have a local busy (buffers) state to the DOS
    //      client
    //

    if (pFrame->Contiguous.uchMsgType == LLC_I_FRAME) {

        IF_DEBUG(DLC_ASYNC) {
            DPUT("ProcessReceiveFrame: I-Frame\n");
        }

        //
        // try to allocate the required number of buffers as a chain - returns
        // DOS pointers, ie unusable in flat data space. Note that if we have
        // deferred receives then we may be able to satisfy the request now.
        // We must allocate all the required buffers for an I-Frame, or none
        //

        status = GetBuffers(GET_POOL_INDEX(adapter, stationId),
                            numBufs,
                            &dosBuffers,
                            &nLeft,
                            FALSE,
                            NULL
                            );
        if (status == LLC_STATUS_SUCCESS) {

            //
            // we managed to allocate the required number of DOS buffers. Copy
            // the NT frame to the DOS buffers and set the indication to return
            // the I-Frame and free the READ CCB and NT frame buffer
            //

            status = CopyFrame(pFrame,
                               dosBuffers,
                               READ_WORD(&pDosParms->Receive.usUserLength),
                               bufferSize,
                               flags
                               );

            ASSERT(status == LLC_STATUS_SUCCESS);

            indication = INDICATE_RECEIVE_FRAME;
        } else {

            //
            // we couldn't get the required number of DOS buffers. We must
            // queue this I-Frame (& any subsequent I-Frames received for this
            // link station) on the deferred queue and indicate the local
            // busy (buffers) state to the DOS client. Set pCcb to NULL to
            // indicate that it mustn't be deallocated by the caller (it has
            // already been deallocated in SetEmulatedLocalBusyState)
            //
            // We set the LOCAL BUSY (Buffer) state as quickly as possible: we
            // don't want more than 1 I-Frame queued per link station if we
            // can help it
            //

            SetEmulatedLocalBusyState(adapter, stationId);
            pCcb = NULL;
            indication = INDICATE_LOCAL_BUSY;
        }
    } else {

        IF_DEBUG(DLC_ASYNC) {
            DPUT("ProcessReceiveFrame: other MAC/DATA Frame\n");
        }

        //
        // the frame is not an I-Frame. If we don't have sufficient buffers to
        // receive it then we can discard it
        //

        status = GetBuffers(GET_POOL_INDEX(adapter, stationId),
                            numBufs,
                            &dosBuffers,
                            &nLeft,
                            TRUE,
                            &buffersAvailable
                            );
        if (status == LLC_STATUS_SUCCESS) {

            //
            // we got some DOS buffers, but maybe not all requirement
            //

            if (buffersAvailable < numBufs) {

                //
                // set the status required to be returned to DOS in the completed
                // RECEIVE CCB and set the CF_PARTIAL flag so that CopyFrame
                // will know to terminate early
                //

                *Status = LLC_STATUS_LOST_DATA_INADEQUATE_SPACE;
                flags |= CF_PARTIAL;
                indication = INDICATE_COMPLETE_RECEIVE;
            } else {

                //
                // we allocated all required DOS buffers for this frame
                //

                indication = INDICATE_RECEIVE_FRAME;
            }

            //
            // copy the whole or partial frame
            //

            status = CopyFrame(pFrame,
                               dosBuffers,
                               READ_WORD(&pDosParms->Receive.usUserLength),
                               bufferSize,
                               flags
                               );

            IF_DEBUG(DLC_ASYNC) {
                DPUT1("ProcessReceiveFrame: CopyFrame (non-I-Frame) returns %x\n", status);
            }

        } else {

            //
            // no DOS buffers at all
            //

            *Status = LLC_STATUS_LOST_DATA_NO_BUFFERS;
            indication = INDICATE_COMPLETE_RECEIVE;
        }
    }

    //
    // set the FIRST_BUFFER field in the DOS RECEIVE parameter table. This
    // is only meaningful if we're going to complete the RECEIVE, with either
    // success or failure status. Use WRITE_DWORD in case the parameter table
    // is unaligned
    //

    WRITE_DWORD(&pDosParms->Receive.pFirstBuffer, dosBuffers);

    //
    // if we are returning DOS buffers, then return the BUFFERS_LEFT field
    //

    if (dosBuffers) {

        PLLC_DOS_BUFFER pDosBuffer = (PLLC_DOS_BUFFER)DOS_PTR_TO_FLAT(dosBuffers);

        WRITE_WORD(&pDosBuffer->Contiguous.cBuffersLeft, nLeft);
    }

    //
    // set *ppCcb. If this contains non-NULL on return then the caller will
    // deallocate the CCB and free the NT buffer(s)
    //

    *ppCcb = pCcb;

    //
    // return indication of action to take
    //

    return indication;
}


LOCAL_BUSY_STATE
QueryEmulatedLocalBusyState(
    IN BYTE AdapterNumber,
    IN WORD StationId
    )

/*++

Routine Description:

    Gets the current local-busy(buffer) state of the requested link station on
    a particular adapter

Arguments:

    AdapterNumber   - which adapter
    StationId       - which link station

Return Value:

    LOCAL_BUSY_STATE
        NOT_BUSY
            AdapterNumber/StationId has no deferred I-Frames

        BUSY
            AdapterNumber/StationId has deferred I-Frames and has not yet
            received DLC.FLOW.CONTROL(local-busy(buffer), reset) from the
            DOS DLC app

        CLEARING
            AdapterNumber/StationId has deferred I-Frames AND has received
            DLC.FLOW.CONTROL(local-busy(buffer), reset) from the DOS DLC app
            and is currently trying to unload I-Frames to DOS DLC app

--*/

{
    LOCAL_BUSY_STATE state;

    ASSERT(HIBYTE(StationId) != 0);
    ASSERT(LOBYTE(StationId) != 0);

    IF_DEBUG(CRITSEC) {
        DPUT1("QueryEmulatedLocalBusyState: ENTERING Adapters[%d].LocalBusyCritSec\n",
              AdapterNumber
              );
    }

    EnterCriticalSection(&Adapters[AdapterNumber].LocalBusyCritSec);
    state = Adapters[AdapterNumber].LocalBusyInfo[LINK_ID(StationId)].State;
    if (state == BUSY_BUFFER || state == BUSY_FLOW) {
        state = BUSY;
    }

    IF_DEBUG(CRITSEC) {
        DPUT1("QueryEmulatedLocalBusyState: LEAVING Adapters[%d].LocalBusyCritSec\n",
              AdapterNumber
              );
    }

    LeaveCriticalSection(&Adapters[AdapterNumber].LocalBusyCritSec);

    ASSERT(state == NOT_BUSY
        || state == CLEARING
        || state == BUSY
        || state == BUSY_BUFFER
        || state == BUSY_FLOW
        );

    IF_DEBUG(DLC_ASYNC) {
        DPUT1("QueryEmulatedLocalBusyState: returning %s\n",
              state == NOT_BUSY
                ? "NOT_BUSY"
                : state == CLEARING
                    ? "CLEARING"
                        : state == BUSY
                            ? "BUSY"
                            : state == BUSY_BUFFER
                                ? "BUSY_BUFFER"
                                : "BUSY_FLOW"
              );
    }

    return state;
}


VOID
SetEmulatedLocalBusyState(
    IN BYTE AdapterNumber,
    IN WORD StationId
    )

/*++

Routine Description:

    Sets the emulated local-busy state to local-busy(buffer). If the state is
    currently NOT_BUSY, sends a DLC.FLOW.CONTROL(local-busy(buffer), set) to
    the DLC driver. In all cases sets the current state to BUSY

    Called during processing of an I-Frame when we run out of DOS buffers into
    which we receive the I-Frame. We can be processing a current I-Frame or a
    deferred I-Frame at the time we run out of buffers: in the first instance
    this routine sets local-busy(buffer) state for the first time; in the
    second instance we regress into local-busy(buffer) state (BUSY) from the
    CLEARING state. This will happen so long as we continue to run out of DOS
    buffers

Arguments:

    AdapterNumber   - which adapter to set emulated local busy state for
    StationId       - which link station on AdapterNumber

Return Value:

    None.

--*/

{
    LOCAL_BUSY_STATE state;
    DWORD link = LINK_ID(StationId);

    ASSERT(AdapterNumber < DOS_DLC_MAX_ADAPTERS);
    ASSERT(HIBYTE(StationId) != 0);     // SAP can't be 0
    ASSERT(LOBYTE(StationId) != 0);     // Link Station can't be 0

    IF_DEBUG(CRITSEC) {
        DPUT1("SetEmulatedLocalBusyState: ENTERING Adapters[%d].LocalBusyCritSec\n",
              AdapterNumber
              );
    }

    EnterCriticalSection(&Adapters[AdapterNumber].LocalBusyCritSec);
    state = Adapters[AdapterNumber].LocalBusyInfo[link].State;

    ASSERT(state == NOT_BUSY
        || state == CLEARING
        || state == BUSY
        || state == BUSY_BUFFER
        || state == BUSY_FLOW
        );

    //
    // if the state of this link station is currently NOT_BUSY then we have
    // to stop the DLC driver receiving I-Frames for this station. In all
    // cases, put the READ CCB on the end of the deferred queue for this
    // adapter/link station
    //

    Adapters[AdapterNumber].LocalBusyInfo[link].State = BUSY;

    //
    // if the previous state was NOT_BUSY then this is the first time this link
    // station has gone into local-busy(buffer) state. Increment the deferred
    // receive count (number of links in local-busy(buffer) state on this
    // adapter) and send a flow control command to the DLC driver, disabling
    // further I-Frame receives until we clear the backlog
    //

    if (state == NOT_BUSY) {

        IF_DEBUG(DLC_ASYNC) {
            DPUT2("SetEmulatedLocalBusyState: setting %d:%04x to BUSY from NOT_BUSY\n",
                  AdapterNumber,
                  StationId
                  );
        }

        ++Adapters[AdapterNumber].DeferredReceives;

        //
        // update the indexes to reduce search effort when looking for deferred
        // receives
        //

        ASSERT(Adapters[AdapterNumber].FirstIndex <= Adapters[AdapterNumber].LastIndex);

        if (Adapters[AdapterNumber].FirstIndex > link) {
            Adapters[AdapterNumber].FirstIndex = link;
        }
        if (Adapters[AdapterNumber].LastIndex < link
        || Adapters[AdapterNumber].LastIndex == NO_LINKS_BUSY) {
            Adapters[AdapterNumber].LastIndex = link;
        }

#if DBG

        //ASSERT(DosDlcFlowControl(AdapterNumber, StationId, LLC_SET_LOCAL_BUSY_BUFFER) == LLC_STATUS_SUCCESS);
        ASSERT(DlcFlowControl(AdapterNumber, StationId, LLC_SET_LOCAL_BUSY_USER) == LLC_STATUS_SUCCESS);

#else

        //DosDlcFlowControl(AdapterNumber, StationId, LLC_SET_LOCAL_BUSY_BUFFER);
        DlcFlowControl(AdapterNumber, StationId, LLC_SET_LOCAL_BUSY_USER);

#endif

    } else {

        IF_DEBUG(DLC_ASYNC) {
            DPUT3("SetEmulatedLocalBusyState: setting %d:%04x to BUSY from %s\n",
                  AdapterNumber,
                  StationId,
                  state == CLEARING
                    ? "CLEARING"
                    : state == BUSY_BUFFER
                        ? "BUSY_BUFFER"
                        : state == BUSY_FLOW
                            ? "BUSY_FLOW"
                            : "???"
                  );
        }
    }

    ASSERT(state != BUSY);

    //
    // add this READ CCB to the end of the deferred receive queue for this
    // adapter/link station and any subsequent READ CCBs which completed with
    // received I-Frames
    //

    DeferAllIFrames(AdapterNumber, StationId);

    IF_DEBUG(DLC_ASYNC) {
        DPUT5("SetEmulatedLocalBusyState(%d, %04x): Ref#=%d, First=%d, Last=%d\n",
                AdapterNumber,
                StationId,
                Adapters[AdapterNumber].DeferredReceives,
                Adapters[AdapterNumber].FirstIndex,
                Adapters[AdapterNumber].LastIndex
                );
    }

    //
    // now reduce the priority of the event handler thread to give the CCB
    // handler thread some time to free buffers & issue DLC.FLOW.CONTROL
    // (mainly for DOS apps which do it in the wrong order)
    //

    SetThreadPriority(hEventThread, THREAD_PRIORITY_LOWEST);

    IF_DEBUG(CRITSEC) {
        DPUT1("SetEmulatedLocalBusyState: LEAVING Adapters[%d].LocalBusyCritSec\n",
              AdapterNumber
              );
    }

    LeaveCriticalSection(&Adapters[AdapterNumber].LocalBusyCritSec);
}


BOOLEAN
ResetEmulatedLocalBusyState(
    IN BYTE AdapterNumber,
    IN WORD StationId,
    IN BYTE DlcCommand
    )

/*++

Routine Description:

    Clears the local-busy(buffer) state for this adapter/link station. If the
    transition is from BUSY to CLEARING then just changes the state and issues
    a hardware interrupt to the VDM: the reason for this is that the original
    interrupt from the READ which caused us to go into local-busy(buffer) state
    was used to generate a DLC status change event

    Called for a single link station or an entire SAP

    Called in response to receiving DLC.FLOW.CONTROL(local-busy(buffer), reset)
    from DOS app for a SAP or link station

Arguments:

    AdapterNumber   - which adapter to clear the local-busy(buffer) state for
    StationId       - which link station on this adapter
    DlcCommand      - which DLC command is causing this reset

Return Value:

    BOOLEAN
        TRUE    - state was reset from BUSY to CLEARING
        FALSE   - state is NOT_BUSY: invalid request

--*/

{
    BOOLEAN reset;

    ASSERT(AdapterNumber < DOS_DLC_MAX_ADAPTERS);
    ASSERT(HIBYTE(StationId) != 0);     // SAP can't be 0

    //
    // grab the LocalBusyCritSec for the adapter and reset the local-busy(buffer)
    // state for the link station or the entire SAP. If we are resetting for the
    // entire SAP, holding the critical section ensures that new I-Frames won't
    // cause another station to go into emulated local-busy(buffer) state while
    // we are resetting the rest
    //

    IF_DEBUG(CRITSEC) {
        DPUT1("ResetEmulatedLocalBusyState: ENTERING Adapters[%d].LocalBusyCritSec\n",
              AdapterNumber
              );
    }

    EnterCriticalSection(&Adapters[AdapterNumber].LocalBusyCritSec);

    if (LOBYTE(StationId) == 0) {
        reset = ResetEmulatedLocalBusyStateSap(AdapterNumber, StationId, DlcCommand);
    } else {
        reset = ResetEmulatedLocalBusyStateLink(AdapterNumber, StationId, DlcCommand);
    }

    IF_DEBUG(CRITSEC) {
        DPUT1("ResetEmulatedLocalBusyState: LEAVING Adapters[%d].LocalBusyCritSec\n",
              AdapterNumber
              );
    }

    LeaveCriticalSection(&Adapters[AdapterNumber].LocalBusyCritSec);

    return reset;
}


BOOLEAN
ResetEmulatedLocalBusyStateSap(
    IN BYTE AdapterNumber,
    IN WORD StationId,
    IN BYTE DlcCommand
    )

/*++

Routine Description:

    This function is called when the app resets the local-busy(buffer) state
    for an entire SAP

    NB: This function MUST BE CALLED WHILE HOLDING THE LocalBusyCritSec for
    this adapter

Arguments:

    AdapterNumber   - which adapter to
    StationId       - SAP:00 - which SAP to reset local-busy(buffer) states for
    DlcCommand      - which DLC command is causing this reset

Return Value:

    BOOLEAN
        TRUE    - links reset for this SAP
        FALSE   - no links reset for this SAP

--*/

{
    DWORD link = Adapters[AdapterNumber].FirstIndex;
    DWORD last = Adapters[AdapterNumber].LastIndex;
    DWORD count = 0;
    LOCAL_BUSY_STATE state;

    ASSERT(AdapterNumber < DOS_DLC_MAX_ADAPTERS);
    ASSERT(HIBYTE(StationId) != 0);
    ASSERT(link <= last);
    ASSERT(DlcCommand == LLC_BUFFER_FREE || DlcCommand == LLC_DLC_FLOW_CONTROL);

    IF_DEBUG(DLC_ASYNC) {
        DPUT3("ResetEmulatedLocalBusyStateSap(%d, %04x, %s)\n",
                AdapterNumber,
                StationId,
                DlcCommand == LLC_BUFFER_FREE ? "BUFFER.FREE"
                    : DlcCommand == LLC_DLC_FLOW_CONTROL ? "DLC.FLOW.CONTROL"
                    : "???"
                );
    }

    //
    // we may have a DLC.FLOW.CONTROL for a SAP which has already been reset
    // by a previous DLC.FLOW.CONTROL
    //

    if (link == NO_LINKS_BUSY) {

        ASSERT(last == NO_LINKS_BUSY);

        IF_DEBUG(DLC_ASYNC) {
            DPUT("ResetEmulatedLocalBusyStateSap: SAP already reset\n");
        }

        return FALSE;
    }

    //
    // since we are holding the LocalBusyCritSec for this adapter, we can use
    // FirstLink and LastLink to try reduce the number of searches for busy
    // stations. No new stations can go busy and change FirstLink or LastLink
    // while we are in this loop
    //

    for (++StationId; link <= last; ++StationId) {
        state = Adapters[AdapterNumber].LocalBusyInfo[link].State;
        ++link;
        if (state == BUSY
        || (state == BUSY_BUFFER && DlcCommand == LLC_DLC_FLOW_CONTROL)
        || (state == BUSY_FLOW && DlcCommand == LLC_BUFFER_FREE)) {
            if (ResetEmulatedLocalBusyStateLink(AdapterNumber, StationId, DlcCommand)) {
                ++count;
            }
        }
    }

    return count != 0;
}


BOOLEAN
ResetEmulatedLocalBusyStateLink(
    IN BYTE AdapterNumber,
    IN WORD StationId,
    IN BYTE DlcCommand
    )

/*++

Routine Description:

    This function is called when the app resets the local-busy(buffer) state
    for a single link station

    Clears the local-busy(buffer) state for this adapter/link station. If the
    transition is from BUSY to CLEARING then just changes the state and issues
    a hardware interrupt to the VDM: the reason for this is that the original
    interrupt from the READ which caused us to go into local-busy(buffer) state
    was used to generate a DLC status change event

    NB: This function MUST BE CALLED WHILE HOLDING THE LocalBusyCritSec for
    this adapter

Arguments:

    AdapterNumber   - which adapter to clear the local-busy(buffer) state for
    StationId       - which link station on this adapter
    DlcCommand      - which DLC command is causing this reset

Return Value:

    BOOLEAN
        TRUE    - state was reset from BUSY to CLEARING
        FALSE   - state is NOT_BUSY: invalid request

--*/

{
    DWORD link = LINK_ID(StationId);
    LOCAL_BUSY_STATE state;

    ASSERT(AdapterNumber < DOS_DLC_MAX_ADAPTERS);
    ASSERT(HIBYTE(StationId) != 0);     // SAP can't be 0
    ASSERT(LOBYTE(StationId) != 0);     // Link Station can't be 0
    ASSERT(DlcCommand == LLC_BUFFER_FREE || DlcCommand == LLC_DLC_FLOW_CONTROL);

    IF_DEBUG(DLC_ASYNC) {
        DPUT3("ResetEmulatedLocalBusyStateLink(%d, %04x, %s)\n",
                AdapterNumber,
                StationId,
                DlcCommand == LLC_BUFFER_FREE ? "BUFFER.FREE"
                    : DlcCommand == LLC_DLC_FLOW_CONTROL ? "DLC.FLOW.CONTROL"
                    : "???"
                );
    }

    state = Adapters[AdapterNumber].LocalBusyInfo[link].State;

    ASSERT(state == NOT_BUSY
        || state == CLEARING
        || state == BUSY
        || state == BUSY_BUFFER
        || state == BUSY_FLOW
        );

    if (state == BUSY) {

        //
        // if the state is BUSY then this is the first DLC.FLOW.CONTROL or
        // BUFFER.FREE since we went into local-busy(buffer) state. State
        // transition is to BUSY_FLOW if this is a DLC.FLOW.CONTROL else
        // BUSY_BUFFER
        //

        IF_DEBUG(DLC_ASYNC) {
            DPUT1("ResetEmulatedLocalBusyStateLink: state: BUSY -> %s\n",
                    DlcCommand == LLC_BUFFER_FREE ? "BUSY_BUFFER" : "BUSY_FLOW"
                    );
        }

        Adapters[AdapterNumber].LocalBusyInfo[link].State = (DlcCommand == LLC_BUFFER_FREE)
                                                                ? BUSY_BUFFER
                                                                : BUSY_FLOW;
    } else if ((state == BUSY_FLOW && DlcCommand == LLC_BUFFER_FREE)
            || (state == BUSY_BUFFER && DlcCommand == LLC_DLC_FLOW_CONTROL)) {

        //
        // state is BUSY_FLOW or BUSY_BUFFER. If this reset is caused by the
        // other half of the state transition requirement then change the state
        //

        IF_DEBUG(DLC_ASYNC) {
            DPUT3("ResetEmulatedLocalBusyStateLink: link %d.%04x changing from %s to CLEARING\n",
                  AdapterNumber,
                  StationId,
                  state == BUSY_FLOW ? "BUSY_FLOW" : "BUSY_BUFFER"
                  );
        }

        Adapters[AdapterNumber].LocalBusyInfo[link].State = CLEARING;

        IF_DEBUG(DLC_ASYNC) {
            DPUT("ResetEmulatedLocalBusyStateLink: Interrupting VDM\n");
        }

        IssueHardwareInterrupt();

        //
        // for the benefit of the caller, the state was essentially BUSY
        //

        state = BUSY;
    } else {

        IF_DEBUG(DLC_ASYNC) {
            DPUT3("ResetEmulatedLocalBusyStateLink: NOT resetting state of %d.%04x. state is %s\n",
                  AdapterNumber,
                  StationId,
                  state == CLEARING ? "CLEARING" : "NOT_BUSY"
                  );
        }

    }

    return state == BUSY;
}


VOID
DeferReceive(
    IN BYTE AdapterNumber,
    IN WORD StationId,
    IN PLLC_CCB pReadCcb
    )

/*++

Routine Description:

    Adds a READ CCB to the end of the deferred receive queue for an adapter/
    station id

    NB: This function MUST BE CALLED WHILE HOLDING THE LocalBusyCritSec for
    this adapter

Arguments:

    AdapterNumber   - which adapter to set emulated local busy state for
    StationId       - which link station on AdapterNumber
    pReadCcb        - pointer to completed received I-Frame CCB (NT READ CCB)

Return Value:

    None.

--*/

{
    PLLC_CCB* pQueue;
    PLLC_CCB pLlcCcb;

    //
    // if there is nothing in the queue for this adapter number/station ID
    // then place this CCB at the head of the queue, else put the CCB at
    // the end. The CCBs are chained together using their CCB_POINTER fields.
    // Normally, this field is not used for received frame READ CCBs
    //

    ASSERT(pReadCcb->pNext == NULL);
    ASSERT(HIBYTE(StationId) != 0);
    ASSERT(LOBYTE(StationId) != 0);

#if DBG

    IF_DEBUG(DLC_ASYNC) {
        DPUT4("DeferReceive: deferring I-Frame for %d.%04x. CCB = %08x. Current depth is %d\n",
                AdapterNumber,
                StationId,
                pReadCcb,
                Adapters[AdapterNumber].LocalBusyInfo[LINK_ID(StationId)].Depth
                );
    }

#endif

    pQueue = &Adapters[AdapterNumber].LocalBusyInfo[LINK_ID(StationId)].Queue;
    pLlcCcb = *pQueue;
    if (!pLlcCcb) {
        *pQueue = pReadCcb;
    } else {
        for (; pLlcCcb->pNext; pLlcCcb = pLlcCcb->pNext) {
            ;
        }
        pLlcCcb->pNext = pReadCcb;
    }

#if DBG

    ++Adapters[AdapterNumber].LocalBusyInfo[LINK_ID(StationId)].Depth;
    ASSERT(Adapters[AdapterNumber].LocalBusyInfo[LINK_ID(StationId)].Depth <= MAX_I_FRAME_DEPTH);

    IF_DEBUG(CRITICAL) {
        CRITDUMP(("DeferReceive: %d.%04x CCB=%08x Depth=%d\n",
                 AdapterNumber,
                 StationId,
                 pReadCcb,
                 Adapters[AdapterNumber].LocalBusyInfo[LINK_ID(StationId)].Depth
                 ));
    }

#endif

}


VOID
DeferAllIFrames(
    IN BYTE AdapterNumber,
    IN WORD StationId
    )

/*++

Routine Description:

    Removes all pending I-Frames for StationId from the EventQueue for this
    adapter and places them on the deferred queue for this StationId.

    This is done when the StationId goes into local-busy(buffer) state. We do
    this so that any event packets behind the I-Frames can be completed, other
    link stations which aren't blocked can receive their I-Frames and ensures
    that once in local-busy state, all I-Frames are deferred for a link station

    NB: This function MUST BE CALLED WHILE HOLDING THE LocalBusyCritSec for
    this adapter

    NB: we have to gain access to 2 critical sections - the LocalBusyCritSec
    for this station ID & the EventQueueCritSec for this adapter

    Assumption: This function is called in the context of the VDM h/w ISR and
                before AcknowledgeHardwareInterrupt is called for this ISR BOP
Arguments:

    AdapterNumber   - which adapter structure to use
    StationId       - which link station to remove I-Frames for

Return Value:

    None.

--*/

{
    PLLC_CCB pCcb;
    PLLC_CCB next;
    PLLC_CCB* last;
    PLLC_READ_PARMS pReadParms;
    PLLC_BUFFER pFrame;
    BOOLEAN remove;

    //
    // deferredFrameCount starts at -1 because it is a count of pending h/w
    // interrupts to cancel. We have to acknowledge the current one which will
    // reduce the count by 1
    //

    LONG deferredFrameCount = -1;

    ASSERT(AdapterNumber < DOS_DLC_MAX_ADAPTERS);
    ASSERT(HIBYTE(StationId) != 0);
    ASSERT(LOBYTE(StationId) != 0);

    IF_DEBUG(CRITSEC) {
        DPUT1("DeferAllIFrames: ENTERING Adapters[%d].EventQueueCritSec\n",
              AdapterNumber
              );
    }

    EnterCriticalSection(&Adapters[AdapterNumber].EventQueueCritSec);
    pCcb = Adapters[AdapterNumber].EventQueueHead;
    last = &Adapters[AdapterNumber].EventQueueHead;
    while (pCcb) {
        pReadParms = &pCcb->u.pParameterTable->Read;

        //
        // only remove I-Frames from the EventQueue that are destined for this
        // link station
        //

        remove = FALSE;
        if (pReadParms->uchEvent == LLC_EVENT_RECEIVE_DATA) {
            pFrame = pReadParms->Type.Event.pReceivedFrame;
            if (pFrame->Contiguous.uchMsgType == LLC_I_FRAME
            && pFrame->Contiguous.usStationId == StationId) {
                remove = TRUE;
            }
        }
        if (remove) {
            next = pCcb->pNext;
            *last = next;
            --Adapters[AdapterNumber].QueueElements;
            if (Adapters[AdapterNumber].EventQueueTail == pCcb) {
                if (last == &Adapters[AdapterNumber].EventQueueHead) {
                    Adapters[AdapterNumber].EventQueueTail = NULL;
                } else {
                    Adapters[AdapterNumber].EventQueueTail = CONTAINING_RECORD(last, LLC_CCB, pNext);
                }
            }

            IF_DEBUG(DLC_ASYNC) {
                DPUT3("DeferAllIFrames: moving CCB %08x for %d.%04x\n",
                      pCcb,
                      AdapterNumber,
                      StationId
                      );
            }

            pCcb->pNext = NULL;
            DeferReceive(AdapterNumber, StationId, pCcb);
            ++deferredFrameCount;
            pCcb = next;
        } else {

            IF_DEBUG(DLC_ASYNC) {
                DPUT1("DeferAllIFrames: not removing CCB %08x from EventQueue\n",
                      pCcb
                      );
            }

            last = (PLLC_CCB*)&pCcb->pNext;
            pCcb = pCcb->pNext;
        }
    }

    if (deferredFrameCount > 0) {
        CancelHardwareInterrupts(deferredFrameCount);
    }

    IF_DEBUG(CRITSEC) {
        DPUT1("DeferAllIFrames: LEAVING Adapters[%d].EventQueueCritSec\n",
              AdapterNumber
              );
    }

    LeaveCriticalSection(&Adapters[AdapterNumber].EventQueueCritSec);
}


PLLC_CCB
RemoveDeferredReceive(
    IN BYTE AdapterNumber,
    IN WORD StationId,
    OUT BOOLEAN* pDeferredFramesLeft
    )

/*++

Routine Description:

    Removes a READ CCB from the head of the deferred receive queue for an
    adapter/station id and sets the head to point to the next deferred receive
    in the queue

    NB: This function MUST NOT BE CALLED WHILE HOLDING THE LocalBusyCritSec for
    this adapter (opposite of DeferReceive)

Arguments:

    AdapterNumber       - which adapter to set emulated local busy state for
    StationId           - which link station on AdapterNumber
    pDeferredFramesLeft - TRUE if there are more frames on this deferred queue

Return Value:

    PLLC_CCB
        pointer to CCB from head of queue

--*/

{
    PLLC_CCB* pQueue;
    PLLC_CCB pLlcCcb;
    DWORD link;
    
    //
    // if there is nothing in the queue for this adapter number/station ID
    // then place this CCB at the head of the queue, else put the CCB at
    // the end. The CCBs are chained together using their CCB_POINTER fields.
    // Normally, this field is not used for received frame READ CCBs
    //

    if (StationId == 0)
    {
#if DBG
        DbgBreakPoint();
#endif
        return(NULL);
    }

    link = LINK_ID(StationId);

    IF_DEBUG(CRITSEC) {
        DPUT1("RemoveDeferredReceive: ENTERING Adapters[%d].LocalBusyCritSec\n",
              AdapterNumber
              );
    }

    EnterCriticalSection(&Adapters[AdapterNumber].LocalBusyCritSec);
    pQueue = &Adapters[AdapterNumber].LocalBusyInfo[link].Queue;
    pLlcCcb = *pQueue;
    *pQueue = pLlcCcb->pNext;

    ASSERT(pLlcCcb != NULL);

    IF_DEBUG(DLC_ASYNC) {
        DPUT4("RemoveDeferredReceive: removing I-Frame for %d.%04x. CCB = %08x. Current depth is %d\n",
                AdapterNumber,
                StationId,
                pLlcCcb,
                Adapters[AdapterNumber].LocalBusyInfo[LINK_ID(StationId)].Depth
                );
    }

#if DBG

    --Adapters[AdapterNumber].LocalBusyInfo[link].Depth;

#endif

    //
    // if the deferred queue is now empty, reset the state and issue the real
    // DLC.FLOW.CONTROL(local-busy(buffer), reset) to the DLC driver. Also
    // reduce the reference count of link stations on this adapter in the
    // local-busy(buffer) state and update the first and last link indicies
    //

    if (*pQueue == NULL) {

        IF_DEBUG(DLC_ASYNC) {
            DPUT2("RemoveDeferredReceive: %d.%04x: change state to NOT_BUSY\n",
                    AdapterNumber,
                    StationId
                    );
        }

        Adapters[AdapterNumber].LocalBusyInfo[link].State = NOT_BUSY;
        --Adapters[AdapterNumber].DeferredReceives;
        if (Adapters[AdapterNumber].DeferredReceives) {
            if (link == Adapters[AdapterNumber].FirstIndex) {
                for (link = Adapters[AdapterNumber].FirstIndex + 1;
                link <= Adapters[AdapterNumber].LastIndex;
                ++link) {
                    if (Adapters[AdapterNumber].LocalBusyInfo[link].State != NOT_BUSY) {
                        Adapters[AdapterNumber].FirstIndex = link;
                        break;
                    }
                }
            } else if (link == Adapters[AdapterNumber].LastIndex) {
                for (link = Adapters[AdapterNumber].LastIndex - 1;
                link >= Adapters[AdapterNumber].FirstIndex;
                --link
                ) {
                    if (Adapters[AdapterNumber].LocalBusyInfo[link].State != NOT_BUSY) {
                        Adapters[AdapterNumber].LastIndex = link;
                        break;
                    }
                }
            }
        } else {
            Adapters[AdapterNumber].FirstIndex = NO_LINKS_BUSY;
            Adapters[AdapterNumber].LastIndex = NO_LINKS_BUSY;
        }

#if DBG

        //ASSERT(DosDlcFlowControl(AdapterNumber, StationId, LLC_RESET_LOCAL_BUSY_BUFFER) == LLC_STATUS_SUCCESS);
        ASSERT(DlcFlowControl(AdapterNumber, StationId, LLC_RESET_LOCAL_BUSY_USER) == LLC_STATUS_SUCCESS);

#else

        //DosDlcFlowControl(AdapterNumber, StationId, LLC_RESET_LOCAL_BUSY_BUFFER);
        DlcFlowControl(AdapterNumber, StationId, LLC_RESET_LOCAL_BUSY_USER);

#endif

        *pDeferredFramesLeft = FALSE;

        //
        // restore async event thread's priority
        //

        SetThreadPriority(hEventThread, THREAD_PRIORITY_ABOVE_NORMAL);
    } else {
        *pDeferredFramesLeft = TRUE;
    }

    IF_DEBUG(DLC_ASYNC) {
        DPUT5("RemoveDeferredReceive(%d, %04x): Ref#=%d, First=%d, Last=%d\n",
                AdapterNumber,
                StationId,
                Adapters[AdapterNumber].DeferredReceives,
                Adapters[AdapterNumber].FirstIndex,
                Adapters[AdapterNumber].LastIndex
                );
    }

    IF_DEBUG(CRITSEC) {
        DPUT1("RemoveDeferredReceive: LEAVING Adapters[%d].LocalBusyCritSec\n",
              AdapterNumber
              );
    }

    LeaveCriticalSection(&Adapters[AdapterNumber].LocalBusyCritSec);
    return pLlcCcb;
}


DWORD
VrDlcEventHandlerThread(
    IN PVOID pParameter
    )

/*++

Routine Description:

    This is the VDM DLC event handler thread. The thread reads all DLC events
    from both DOS DLC adapters, queues them to the event queue and requests a
    DOS hardware interrupt (the post routine mechanism uses hardware interrupts
    to make an external event in the VDM)

    To make this stuff as fast as possible, we don't allocate or free any memory
    in this loop, but we reuse the old read CCBs and their parameter tables in
    the event queue

    We filter out any completion which will NOT result in an asynchronous event
    in the VDM. This means CCB completions for this emulator (DIR.CLOSE.ADAPTER
    and DIR.CLOSE.DIRECT for example) and received I-Frames for link stations
    which are currently in the BUSY (local-busy(buffer)) state. This avoids us
    making unnecessary interrupts in the VDM and costly (on x86 machines) BOPs
    which achieve no action for the VDM

Arguments:

    pParameter  - not used

Return Value:

    None, this should loop forever, until the VDM process dies

--*/

{
    DWORD status = LLC_STATUS_PENDING;
    DWORD waitIndex;
    PLLC_CCB pReadCcb;
    PLLC_READ_PARMS pReadParms;
    WORD stationId;

    UNREFERENCED_PARAMETER(pParameter);

    IF_DEBUG(DLC_ASYNC) {
        DPUT2("VrDlcEventHandlerThread kicked off: Thread Handle=%x, Id=%d\n",
              GetCurrentThread(),
              GetCurrentThreadId()
              );
    }

    //
    // wait for the READ CCB event for either adapter to become signalled (by
    // DLC driver when READ completes)
    //

    while (TRUE) {
        waitIndex = WaitForMultipleObjects(
                        ARRAY_ELEMENTS(aReadEvents),    // count of objects
                        aReadEvents,                    // handle array
                        FALSE,                          // do not wait all objects
                        INFINITE                        // wait forever
                        );

        //
        // if we get 0xFFFFFFFF back then an error occurred
        //

        if (waitIndex == 0xffffffff) {
            status = GetLastError();

            IF_DEBUG(DLC_ASYNC) {
                DPUT1("VrDlcEventHandlerThread: FATAL: WaitForMultipleObjects returns %d\n", status);
            }

            //
            // this terminates the thread!
            //

            break;
        }

        //
        // if we get a number > number of events-1, then either a timeout
        // occurred or a mutex was abandoned, both of which are highly
        // improbable. Just continue with the loop
        //

        if (waitIndex > LAST_ELEMENT(aReadEvents)) {

            IF_DEBUG(DLC_ASYNC) {
                DPUT1("VrDlcEventHandlerThread: ERROR: WaitForMultipleObjects returns %d?: continuing\n", waitIndex);
            }

            continue;
        }

        //
        // one of the READ CCBs has successfully completed (oh joy!)
        //

        pReadCcb = aReadCcbs[waitIndex];

        //
        // reset the event
        //

        ResetEvent(aReadEvents[waitIndex]);

        IF_DEBUG(DLC_ASYNC) {
            DPUT1("VrDlcEventHandlerThread: Event occurred for adapter %d\n", waitIndex);
            IF_DEBUG(READ_COMPLETE) {
                DUMPCCB(pReadCcb, TRUE, FALSE, FALSE, 0, 0);
            }
        }

        if (pReadCcb->uchDlcStatus == STATUS_SUCCESS) {

            //
            // it gets better!
            //

            pReadParms = &pReadCcb->u.pParameterTable->Read;

            //
            // if the completion flag is VRDLC_COMMAND_COMPLETION then this
            // command originated in this emulator: Do Not hand it back to
            // the VDM. In fact do nothing with it: this is an asynchronous
            // command that we didn't want to wait for (like DIR.CLOSE.ADAPTER
            // or DIR.CLOSE.DIRECT)
            //

            if (pReadParms->ulNotificationFlag == VRDLC_COMMAND_COMPLETION) {

                IF_DEBUG(CRITICAL) {
                    CRITDUMP(("*** VrDlcEventHandlerThread: VRDLC_COMMAND_COMPLETION: CCB=%08x COMMAND=%02x ***\n", pReadCcb, pReadCcb->uchDlcCommand));
                }

            } else if (pReadParms->uchEvent == LLC_EVENT_STATUS_CHANGE
            && pReadParms->Type.Status.usDlcStatusCode == LLC_INDICATE_LOCAL_STATION_BUSY
            && !IS_LOCAL_BUSY(waitIndex, pReadParms->Type.Status.usStationId)) {

                //
                // We must separate the buffer busy states of global NT
                // buffer pool and the local buffer pools.
                // This must be a real buffer busy indication, if
                // the SAP has no overflowed receive buffers.
                // How can such a situation arise - if we (ie DOS emulation) aren't
                // holding onto the buffers, then where are they? Sounds like a bug
                // to me (RLF 07/22/92)
                //

                IF_DEBUG(DLC_ASYNC) {
                    DPUT("VrDlcEventHandlerThread: *** REAL LOCAL BUSY??? ***\n");
                }

                //
                // We are not queueing buffers because of having
                // no SAP buffers available => this must be a real
                // buffer busy indication.  The READ command should
                // automatically extend the buffer pool size (up
                // to the maximum value set in the initialization)
                //

                DlcFlowControl((BYTE)waitIndex, pReadParms->Type.Status.usStationId, LLC_RESET_LOCAL_BUSY_BUFFER);

            } else if (pReadParms->uchEvent == LLC_EVENT_RECEIVE_DATA
            && pReadParms->Type.Event.pReceivedFrame->Contiguous.uchMsgType
            == LLC_I_FRAME) {

                stationId = pReadParms->Type.Event.pReceivedFrame->Contiguous.usStationId;

                ASSERT(HIBYTE(stationId) != 0);
                ASSERT(LOBYTE(stationId) != 0);

                IF_DEBUG(CRITSEC) {
                    DPUT1("VrDlcEventHandlerThread: ENTERING Adapters[%d].LocalBusyCritSec\n",
                          waitIndex
                          );
                }

                EnterCriticalSection(&Adapters[waitIndex].LocalBusyCritSec);

                //
                // if the link station is in emulated local-busy(buffer) state
                // BUSY or CLEARING then queue the I-Frame. This action does NOT
                // generate a h/w interrupt to the VDM. VrDlcHwInterrupt generates
                // additional h/w interrupts when it processes deferred I-Frames
                //

                ASSERT(
                    Adapters[waitIndex].LocalBusyInfo[LINK_ID(stationId)].State == NOT_BUSY
                    || Adapters[waitIndex].LocalBusyInfo[LINK_ID(stationId)].State == CLEARING
                    || Adapters[waitIndex].LocalBusyInfo[LINK_ID(stationId)].State == BUSY
                    || Adapters[waitIndex].LocalBusyInfo[LINK_ID(stationId)].State == BUSY_BUFFER
                    || Adapters[waitIndex].LocalBusyInfo[LINK_ID(stationId)].State == BUSY_FLOW
                    );

                if (Adapters[waitIndex].LocalBusyInfo[LINK_ID(stationId)].State != NOT_BUSY) {
                    DeferReceive((BYTE)waitIndex, stationId, pReadCcb);

                    //
                    // set the READ CCB pointer to NULL: we have to allocate a
                    // new READ CCB
                    //

                    pReadCcb = NULL;
                }

                IF_DEBUG(CRITSEC) {
                    DPUT1("VrDlcEventHandlerThread: LEAVING Adapters[%d].LocalBusyCritSec\n",
                          waitIndex
                          );
                }

                LeaveCriticalSection(&Adapters[waitIndex].LocalBusyCritSec);
            }

            //
            // pReadCcb is NULL if the READ CCB is to be added to the event
            // queue, NULL if we deferred an I-Frame for a link station in
            // local-busy(buffer) state
            //

            if (pReadCcb) {

                //
                // queue the completed READ CCB in the event queue. If it is
                // full (!) then wait. We will already have issued a call to
                // call_ica_hw_interrupt for each of the events in the queue
                // so we wait on the VDM removing events from the queue. This
                // is an irregular situation, that I (RLF) don't expect to
                // arise. If it does, then it probably means there is some
                // horrendous inefficiency somewhere
                //

                PutEvent((BYTE)waitIndex, pReadCcb);

                IF_DEBUG(DLC_ASYNC) {
                    DPUT("VrDlcEventHandlerThread: Interrupting VDM\n");
                }

                //
                // poke the VDM so that it knows there is some asynchronous
                // processing to do
                //

                IssueHardwareInterrupt();

                //
                // set pReadCcb to NULL. We have to allocate and submit a new
                // READ CCB
                //

                pReadCcb = NULL;
            }
        } else {

            //
            // The READ function failed, the adapter must be closed. We now
            // wait until the adapter is opened again and the event is set
            // back to the signaled state
            //

            IF_DEBUG(DLC_ASYNC) {
                DPUT1("VrDlcEventHandlerThread: READ failed. Status=%x\n", pReadCcb->uchDlcStatus);
            }

            LocalFree(pReadCcb);

            IF_DEBUG(DLC_ALLOC) {
                DPUT1("FREE: freed block @ %x\n", pReadCcb);
            }

            //
            // wait for a new READ CCB to be created the next time this adapter
            // is opened
            //

            //continue;
            pReadCcb = NULL;
        }

        //
        // if we had a successful completion then get a new CCB. If the CCB was
        // not queued, re-use it
        //

        if (!pReadCcb) {
            pReadCcb = InitiateRead(waitIndex, (LLC_STATUS*)&status);
            if (pReadCcb) {
                status = pReadCcb->uchDlcStatus;
            } else {

                IF_DEBUG(DLC_ASYNC) {
                    DPUT("VrDlcEventHandlerThread: Error: InitiateRead returns NULL\n");
                }

                break;
            }
        } else {
            status = lpAcsLan(pReadCcb, NULL);
            if (status != LLC_STATUS_SUCCESS) {

                IF_DEBUG(DLC_ASYNC) {
                    DPUT1("VrDlcEventHandlerThread: Error: AcsLan returns %d\n", status);
                }

                break;
            }
        }
    }

    //
    // !!! WE SHOULD NEVER BE HERE !!!
    //

    IF_DEBUG(DLC_ASYNC) {
        DPUT1("VrDlcEventHandlerThread: Fatal: terminating. Status = %x\n", status);
    }

    return 0;
}


BOOLEAN
InitializeEventHandler(
    VOID
    )

/*++

Routine Description:

    Initializes static data structures used in event handling

Arguments:

    None

Return Value:

    BOOLEAN
        Success - TRUE
        Failure - FALSE

--*/

{
    DWORD i;
    DWORD Tid;

    IF_DEBUG(DLC_ASYNC) {
        DPUT("Vr: InitializeEventHandler\n");
    }

    //
    // make sure the read CCBs and event queues are in a known state
    //

    RtlZeroMemory(aReadCcbs, sizeof(aReadCcbs));

    //
    // preset the handle array with invalid handles so we know which ones
    // have been allocated in clean up
    //

    for (i = 0; i < ARRAY_ELEMENTS(aReadEvents); ++i) {
        aReadEvents[i] = INVALID_HANDLE_VALUE;
    }

    //
    // create event handles for all (both) supported adapters. DIR.OPEN.ADAPTER
    // sets the event to signalled which enables the event handler thread to
    // receive events for that adapter. If we get an error creating the handles
    // then clean up before exiting so that we may try this again later
    //

    for (i = 0; i < ARRAY_ELEMENTS(aReadEvents); i++) {
        aReadEvents[i] = CreateEvent(NULL,    // security attributes: no inherit
                                     TRUE,    // manual-reset event
                                     FALSE,   // initial state = not signaled
                                     NULL     // unnamed event
                                     );
        if (aReadEvents[i] == NULL) {

            IF_DEBUG(DLC_ASYNC) {
                DPUT1("Vr: InitializeEventHandler: Error: failed to create read event: %d\n", GetLastError());
            }

            goto cleanUp;
        }
    }

    //
    // create and start the thread which handles RECEIVE events
    //

    hEventThread = CreateThread(NULL,                // security attributes
                                EVENT_THREAD_STACK,  // initial thread stack size
                                VrDlcEventHandlerThread,
                                NULL,                // thread args
                                0,                   // creation flags
                                &Tid
                                );
    if (hEventThread) {

        IF_DEBUG(CRITICAL) {
            CRITDUMP(("InitializeEventHandler: Created thread Handle=%x, Tid=%d\n", hEventThread, Tid));
        }

        SetThreadPriority(hEventThread, THREAD_PRIORITY_ABOVE_NORMAL);
        return TRUE;
    } else {

        IF_DEBUG(DLC_ASYNC) {
            DPUT1("Vr: InitializeEventHandler: Error: failed to create thread: %d\n", GetLastError());
        }

    }

    //
    // we come here if for some reason we couldn't create the event handles or
    // the event handler thread
    //

cleanUp:
    for (i = 0; i < ARRAY_ELEMENTS(aReadEvents); ++i) {
        if (aReadEvents[i] != INVALID_HANDLE_VALUE) {
            CloseHandle(aReadEvents[i]);
        }
    }

    IF_DEBUG(DLC_ASYNC) {
        DPUT("InitializeEventHandler: Error: returning FALSE\n");
    }

    return FALSE;
}


PLLC_CCB
InitiateRead(
    IN DWORD AdapterNumber,
    OUT LLC_STATUS* ErrorStatus
    )

/*++

Routine Description:

    Create a READ CCB, initialize it to get all events for all stations, set
    the completion event to the event created for this adapter and submit the
    CCB (via AcsLan). If the submit succeeds, set this CCB as the READ CCB
    for AdapterNumber

    NB: The READ CCB - which will be queued on EventQueue - and its parameter
        table are allocated together, so we only need one call to LocalFree to
        deallocate both

        This routine IS THE ONLY PLACE WHERE aReadCcbs IS WRITTEN once the array
        has been initialized in InitializeEventHandler

Arguments:

    AdapterNumber   - which adapter to initiate this READ for

    ErrorStatus     - returned LLC_STATUS describing failure if this function
                      returns NULL

Return Value:

    PLLC_CCB
        pointer to allocated/submitted CCB or NULL.

        If this function succeeds then aReadCcbs[AdapterNumber] points to the
        READ CCB

        If this function fails then *ErrorStatus will contain an LLC_STATUS
        describing why we failed to allocate/submit the CCB. The CCB will be
        deallocated in this case

--*/

{
    PLLC_CCB pCcb;
    PLLC_READ_PARMS parms;
    LLC_STATUS status;

    IF_DEBUG(DLC_ASYNC) {
        DPUT1("InitiateRead: AdapterNumber=%d\n", AdapterNumber);
    }

    //
    // Allocate, initialize and issue the next DLC command. Allocate contiguous
    // space for CCB and parameter table
    //

    pCcb = (PLLC_CCB)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                sizeof(LLC_CCB) + sizeof(LLC_READ_PARMS)
                                );

    //
    // put the READ CCB in the array before we have a chance to complete it
    //

    aReadCcbs[AdapterNumber] = pCcb;
    if (pCcb) {

        //
        // initialize required CCB fields
        //

        pCcb->uchAdapterNumber = (UCHAR)AdapterNumber;
        pCcb->uchDlcCommand = LLC_READ;
        parms = (PLLC_READ_PARMS)&pCcb[1];
        pCcb->u.pParameterTable = (PLLC_PARMS)parms;
        pCcb->hCompletionEvent = aReadEvents[AdapterNumber];

        //
        // set the read options to receive ALL events for ALL stations
        //

        parms->uchOptionIndicator = LLC_OPTION_READ_ALL;
        parms->uchEventSet = LLC_READ_ALL_EVENTS;

        //
        // submit the CCB. If it's not ok, free the CCB and NULL the pointer
        // in the list of per-adapter READ CCBs
        //

        status = lpAcsLan(pCcb, NULL);
        if (status != LLC_STATUS_SUCCESS) {

            aReadCcbs[AdapterNumber] = NULL;

            IF_DEBUG(DLC_ASYNC) {
                DPUT1("InitiateRead: AcsLan failed: %x\n", status);
            }

            LocalFree((HLOCAL)pCcb);

            IF_DEBUG(DLC_ALLOC) {
                DPUT1("FREE: freed block @ %x\n", pCcb);
            }

            *ErrorStatus = status;
            pCcb = NULL;
        }
    } else {
        *ErrorStatus = LLC_STATUS_NO_MEMORY;
    }

#if DBG

    IF_DEBUG(DLC_ASYNC) {
        DPUT2("InitiateRead: returning pCcb=%x%c", pCcb, pCcb ? '\n' : ' ');
        if (!pCcb) {
            DPUT1("*ErrorStatus=%x\n", *ErrorStatus);
        }
    }

#endif

    return pCcb;
}


VOID
PutEvent(
    IN BYTE AdapterNumber,
    IN PLLC_CCB pCcb
    )

/*++

Routine Description:

    Adds a completed event (READ CCB) to the Event Queue. If the event queue
    is full then returns FALSE. Updates the queue tail index. The queue is
    accessed inside a critical section

Arguments:

    AdapterNumber   - which adapter to queue event for
    pCcb            - pointer to completed READ CCB to add to the queue

Return Value:

    None.

--*/

{
    ASSERT(AdapterNumber < DOS_DLC_MAX_ADAPTERS);
    ASSERT(pCcb->pNext == NULL);

    IF_DEBUG(CRITSEC) {
        DPUT1("PutEvent: ENTERING Adapters[%d].EventQueueCritSec\n",
              AdapterNumber
              );
    }

    EnterCriticalSection(&Adapters[AdapterNumber].EventQueueCritSec);
    if (Adapters[AdapterNumber].EventQueueTail == NULL) {
        Adapters[AdapterNumber].EventQueueHead = pCcb;
    } else {
        Adapters[AdapterNumber].EventQueueTail->pNext = pCcb;
    }
    Adapters[AdapterNumber].EventQueueTail = pCcb;
    ++Adapters[AdapterNumber].QueueElements;

    IF_DEBUG(EVENT_QUEUE) {
        DPUT5("PutEvent: Added %x to adapter %d EventQueue. Head=%x Tail=%x Elements=%d\n",
              pCcb,
              AdapterNumber,
              Adapters[AdapterNumber].EventQueueHead,
              Adapters[AdapterNumber].EventQueueTail,
              Adapters[AdapterNumber].QueueElements
              );
    }

    IF_DEBUG(CRITSEC) {
        DPUT1("PutEvent: LEAVING Adapters[%d].EventQueueCritSec\n",
              AdapterNumber
              );
    }

    LeaveCriticalSection(&Adapters[AdapterNumber].EventQueueCritSec);
}


PLLC_CCB
PeekEvent(
    IN BYTE AdapterNumber
    )

/*++

Routine Description:

    Reads the next completed CCB from the head of the Event Queue. If the
    queue is empty (QueueElements == 0) then returns NULL. The queue is
    accessed inside a critical section

Arguments:

    None.

Return Value:

    PLLC_CCB
        Success - pointer to CCB at queue head
        Failure - NULL

--*/

{
    PLLC_CCB pCcb;

    ASSERT(AdapterNumber < DOS_DLC_MAX_ADAPTERS);

    IF_DEBUG(CRITSEC) {
        DPUT1("PeekEvent: ENTERING Adapters[%d].EventQueueCritSec\n",
              AdapterNumber
              );
    }

    EnterCriticalSection(&Adapters[AdapterNumber].EventQueueCritSec);
    if (Adapters[AdapterNumber].QueueElements) {
        pCcb = Adapters[AdapterNumber].EventQueueHead;

        IF_DEBUG(EVENT_QUEUE) {
            DPUT5("PeekEvent: CCB %x from adapter %d queue head. Head=%x Tail=%x Elements=%d\n",
                  pCcb,
                  AdapterNumber,
                  Adapters[AdapterNumber].EventQueueHead,
                  Adapters[AdapterNumber].EventQueueTail,
                  Adapters[AdapterNumber].QueueElements
                  );
        }

    } else {
        pCcb = NULL;

        IF_DEBUG(EVENT_QUEUE) {
            DPUT1("PeekEvent: adapter %d queue is EMPTY!\n", AdapterNumber);
        }

    }

    IF_DEBUG(CRITSEC) {
        DPUT1("PeekEvent: LEAVING Adapters[%d].EventQueueCritSec\n",
              AdapterNumber
              );
    }

    LeaveCriticalSection(&Adapters[AdapterNumber].EventQueueCritSec);

    IF_DEBUG(CRITICAL) {
        CRITDUMP(("PeekEvent: returning %x\n", pCcb));
    }

    return pCcb;
}


PLLC_CCB
GetEvent(
    IN BYTE AdapterNumber
    )

/*++

Routine Description:

    Gets the next completed CCB from the head of the Event Queue. If the
    queue is empty (QueueElements == 0) then returns NULL. If there is a
    completed event in the queue, removes it and advances the queue head
    to the next element. The queue is accessed inside a critical section

Arguments:

    AdapterNumber   - which adapter's event queue to remove event from

Return Value:

    PLLC_CCB
        Success - pointer to dequeued CCB
        Failure - NULL

--*/

{
    PLLC_CCB pCcb;

    IF_DEBUG(CRITSEC) {
        DPUT1("GetEvent: ENTERING Adapters[%d].EventQueueCritSec\n",
              AdapterNumber
              );
    }

    EnterCriticalSection(&Adapters[AdapterNumber].EventQueueCritSec);
    if (Adapters[AdapterNumber].QueueElements) {
        pCcb = Adapters[AdapterNumber].EventQueueHead;
        Adapters[AdapterNumber].EventQueueHead = pCcb->pNext;
        --Adapters[AdapterNumber].QueueElements;
        if (Adapters[AdapterNumber].QueueElements == 0) {
            Adapters[AdapterNumber].EventQueueTail = NULL;
        }

        IF_DEBUG(EVENT_QUEUE) {
            DPUT5("GetEvent: Removed %x from adapter %d EventQueue. Head=%x Tail=%x Elements=%d\n",
                  pCcb,
                  AdapterNumber,
                  Adapters[AdapterNumber].EventQueueHead,
                  Adapters[AdapterNumber].EventQueueTail,
                  Adapters[AdapterNumber].QueueElements
                  );
        }

    } else {
        pCcb = NULL;

        IF_DEBUG(EVENT_QUEUE) {
            DPUT1("GetEvent: queue for adapter %d is EMPTY!\n", AdapterNumber);
        }

    }

    IF_DEBUG(CRITSEC) {
        DPUT1("GetEvent: LEAVING Adapters[%d].EventQueueCritSec\n",
              AdapterNumber
              );
    }

    LeaveCriticalSection(&Adapters[AdapterNumber].EventQueueCritSec);

    IF_DEBUG(CRITICAL) {
        CRITDUMP(("GetEvent: returning %x\n", pCcb));
    }

    return pCcb;
}


VOID
FlushEventQueue(
    IN BYTE AdapterNumber
    )

/*++

Routine Description:

    Removes all READ CCBs from the event queue.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PLLC_CCB pCcb;

    IF_DEBUG(CRITSEC) {
        DPUT1("FlushEventQueue: ENTERING Adapters[%d].EventQueueCritSec\n",
              AdapterNumber
              );
    }

    EnterCriticalSection(&Adapters[AdapterNumber].EventQueueCritSec);

#if DBG

    if (!Adapters[AdapterNumber].QueueElements) {
        DPUT("FlushEventQueue: queue is EMPTY!\n");
    }

#endif

    while (Adapters[AdapterNumber].QueueElements) {
        pCcb = Adapters[AdapterNumber].EventQueueHead;
        --Adapters[AdapterNumber].QueueElements;
        Adapters[AdapterNumber].EventQueueHead = pCcb->pNext;

        IF_DEBUG(EVENT_QUEUE) {
            DPUT5("FlushEventQueue: Removed %x from adapter %d EventQueue. Head=%x Tail=%x Elements=%d\n",
                  pCcb,
                  AdapterNumber,
                  Adapters[AdapterNumber].EventQueueHead,
                  Adapters[AdapterNumber].EventQueueTail,
                  Adapters[AdapterNumber].QueueElements
                  );
        }

        //
        // BUGBUG - received frames?
        //

        LocalFree((HLOCAL)pCcb);

        IF_DEBUG(DLC_ALLOC) {
            DPUT1("FREE: freed block @ %x\n", pCcb);
        }

        Adapters[AdapterNumber].EventQueueTail = NULL;
    }

    IF_DEBUG(CRITSEC) {
        DPUT1("FlushEventQueue: ENTERING Adapters[%d].EventQueueCritSec\n",
              AdapterNumber
              );
    }

    LeaveCriticalSection(&Adapters[AdapterNumber].EventQueueCritSec);
}


VOID
RemoveDeadReceives(
    IN PLLC_CCB pCcb
    )

/*++

Routine Description:

    The receive command described by pCcb has completed (terminated). We must
    remove any queued reads completed by data receive which refer to this CCB

Arguments:

    pCcb    - pointer to RECEIVE CCB (NT)

Return Value:

    None.

--*/

{
    PLLC_CCB thisCcb;
    PLLC_CCB nextCcb;
    PLLC_CCB lastCcb = NULL;
    PLLC_CCB prevCcb = NULL;
    DWORD i;
    PDOS_ADAPTER pAdapter = &Adapters[pCcb->uchAdapterNumber];
    PLLC_CCB* pQueue;

    //
    // remove any queued receives from the event queue. Note: There should NOT
    // be any. The reason: there can't be any data received after the associated
    // RECEIVE command has been cancelled or terminated. This is the theory,
    // anyway
    //

    EnterCriticalSection(&pAdapter->EventQueueCritSec);
    thisCcb = pAdapter->EventQueueHead;
    for (i = pAdapter->QueueElements; i; --i) {
        nextCcb = thisCcb->pNext;
        if (thisCcb->u.pParameterTable->Read.ulNotificationFlag == (ULONG)pCcb) {

            IF_DEBUG(EVENT_QUEUE) {
                DPUT5("RemoveDeadReceives: Removed %x from adapter %d EventQueue. Head=%x Tail=%x Elements=%d\n",
                      thisCcb,
                      pCcb->uchAdapterNumber,
                      pAdapter->EventQueueHead,
                      pAdapter->EventQueueTail,
                      pAdapter->QueueElements
                      );
            }

            ReleaseReceiveResources(thisCcb);

            if (pAdapter->EventQueueHead == thisCcb) {
                pAdapter->EventQueueHead = nextCcb;
            }
            --pAdapter->QueueElements;
            lastCcb = thisCcb;
        } else {
            prevCcb = thisCcb;
        }
        thisCcb = nextCcb;
    }
    if (pAdapter->EventQueueTail == lastCcb) {
        pAdapter->EventQueueTail = prevCcb;
    }
    LeaveCriticalSection(&pAdapter->EventQueueCritSec);

    //
    // remove any queued deferred receives from the deferred I-Frame queue for
    // this SAP or link station
    //

    EnterCriticalSection(&pAdapter->LocalBusyCritSec);
    if (pAdapter->DeferredReceives) {

        ASSERT(pAdapter->FirstIndex != NO_LINKS_BUSY);
        ASSERT(pAdapter->LastIndex != NO_LINKS_BUSY);

        for (i = pAdapter->FirstIndex; i <= pAdapter->LastIndex; ++i) {
            pQueue = &pAdapter->LocalBusyInfo[i].Queue;
            for (thisCcb = *pQueue; thisCcb; thisCcb = thisCcb->pNext) {
                if (thisCcb->u.pParameterTable->Read.ulNotificationFlag == (ULONG)pCcb) {

                    IF_DEBUG(EVENT_QUEUE) {
                        DPUT3("RemoveDeadReceives: Removed %x from adapter %d BusyList. Queue=%x\n",
                              thisCcb,
                              pCcb->uchAdapterNumber,
                              pAdapter->LocalBusyInfo[i].Queue
                              );
                    }

                    *pQueue = thisCcb->pNext;
                    ReleaseReceiveResources(thisCcb);

#if DBG
                    --pAdapter->LocalBusyInfo[i].Depth;
#endif

                    thisCcb = *pQueue;
                } else {
                    pQueue = &thisCcb->pNext;
                }
            }
            if (pAdapter->LocalBusyInfo[i].Queue == NULL) {
                pAdapter->LocalBusyInfo[i].State = NOT_BUSY;
                --pAdapter->DeferredReceives;
            }
        }

        //
        // reset the indicies
        //

        if (pAdapter->DeferredReceives) {
            for (i = pAdapter->FirstIndex; i <= pAdapter->LastIndex; ++i) {
                if (pAdapter->LocalBusyInfo[i].State != NOT_BUSY) {
                    pAdapter->FirstIndex = i;
                    break;
                }
            }
            for (i = pAdapter->LastIndex; i > pAdapter->FirstIndex; --i) {
                if (pAdapter->LocalBusyInfo[i].State != NOT_BUSY) {
                    pAdapter->LastIndex = i;
                    break;
                }
            }
        } else {
            pAdapter->FirstIndex = NO_LINKS_BUSY;
            pAdapter->LastIndex = NO_LINKS_BUSY;
        }
    }
    LeaveCriticalSection(&pAdapter->LocalBusyCritSec);
}


VOID
ReleaseReceiveResources(
    IN PLLC_CCB pCcb
    )

/*++

Routine Description:

    Releases all resources used by a completed data receive READ CCB

Arguments:

    pCcb    - pointer to completed READ CCB. We have to return all received
              frames to buffer pool, and the READ CCB and parameter table to
              the proceess heap

Return Value:

    None.

--*/

{
    WORD buffersLeft;

    //
    // this is a data receive - return the data buffers to the pool
    //

    ASSERT(pCcb->u.pParameterTable->Read.uchEvent == LLC_EVENT_RECEIVE_DATA);

    BufferFree(pCcb->uchAdapterNumber,
               pCcb->u.pParameterTable->Read.Type.Event.pReceivedFrame,
               &buffersLeft
               );

    //
    // free the READ CCB and parameter table
    //

    LocalFree((HLOCAL)pCcb);

    IF_DEBUG(DLC_ALLOC) {
        DPUT1("FREE: freed block @ %x\n", pCcb);
    }
}


VOID
IssueHardwareInterrupt(
    VOID
    )

/*++

Routine Description:

    Issue a simulated hardware interrupt to the VDM. This routine exists because
    we were losing interrupts - seeing more calls to call_ica_hw_interrupt than
    calls to VrDlcHwInterrupt. Hence presumably simulated interrupts were being
    lost. So we now only have 1 un-acknowledged simulated interrupt outstanding
    at any one time. If we already have interrupts outstanding then we just
    increment a counter of pending interrupts. When we dismiss the current
    interrupt using the companion routine AcknowledgeHardwareInterrupt, we can
    generate at that point a queued interrupt

Arguments:

    None.

Return Value:

    None.

--*/

{
    IF_DEBUG(CRITICAL) {
        CRITDUMP(("*** INT ***\n"));
    }

    IF_DEBUG(DLC_ASYNC) {
        DPUT("*** INT ***\n");
    }

    //
    // increment the hardware interrupt counter under critical section control.
    // The counter starts at -1, so 0 means 1 interrupt outstanding. If we go
    // to >1 then we have interrupts queued and must wait until the current
    // one is dismissed
    //

    IF_DEBUG(CRITSEC) {
        DPUT("IssueHardwareInterrupt: ENTERING HardwareIntCritSec\n");
    }

    EnterCriticalSection(&HardwareIntCritSec);
    ++HardwareIntsQueued;
    if (!HardwareIntsQueued) {
        VrQueueCompletionHandler(VrDlcHwInterrupt);
        //call_ica_hw_interrupt(NETWORK_ICA, NETWORK_LINE, 1);
        VrRaiseInterrupt();
    } else {
        IF_DEBUG(CRITICAL) {
            CRITDUMP(("*** INT Queued (%d) ***\n", HardwareIntsQueued));
        }
    }

    IF_DEBUG(CRITSEC) {
        DPUT("IssueHardwareInterrupt: LEAVING HardwareIntCritSec\n");
    }

    LeaveCriticalSection(&HardwareIntCritSec);

    IF_DEBUG(DLC_ASYNC) {
        DPUT("*** EOF INT ***\n");
    }
}


VOID
AcknowledgeHardwareInterrupt(
    VOID
    )

/*++

Routine Description:

    The companion routine to IssueHardwareInterrupt. Here we just decrement the
    interrupt counter. If it is >= 0 then we still have interrupts pending, so
    we issue a new interrupt request. This seems to work - we don't lose
    interrupt requests to the VDM

Arguments:

    None.

Return Value:

    None.

--*/

{
#if DBG

    LONG deferredInts;

#endif

    IF_DEBUG(CRITICAL) {
        CRITDUMP(("*** INT ACK ***\n"));
    }

    IF_DEBUG(DLC_ASYNC) {
        DPUT("*** INT ACK ***\n");
    }

    //
    // decrement the interrupt counter within the critical section. If it goes
    // to -1 then we have no more outstanding hardware interrupt requests. If
    // it is > -1 then issue a new interrupt request
    //

    IF_DEBUG(CRITSEC) {
        DPUT("AcknowledgeHardwareInterrupt: ENTERING HardwareIntCritSec\n");
    }

    EnterCriticalSection(&HardwareIntCritSec);
    --HardwareIntsQueued;

#if DBG

    deferredInts = HardwareIntsQueued;

#endif

    //
    // sanity check
    //

    ASSERT(HardwareIntsQueued >= -1);

    if (HardwareIntsQueued >= 0) {

        IF_DEBUG(CRITICAL) {
            CRITDUMP(("*** INT2 ***\n"));
        }

        VrQueueCompletionHandler(VrDlcHwInterrupt);
        //call_ica_hw_interrupt(NETWORK_ICA, NETWORK_LINE, 1);
        VrRaiseInterrupt();
    }

    IF_DEBUG(CRITSEC) {
        DPUT("AcknowledgeHardwareInterrupt: LEAVING HardwareIntCritSec\n");
    }

    LeaveCriticalSection(&HardwareIntCritSec);

#if DBG

    IF_DEBUG(CRITICAL) {
        CRITDUMP(("*** EOF INT ACK (%d) ***\n", deferredInts));
    }

    IF_DEBUG(DLC_ASYNC) {
        DPUT1("*** EOF INT ACK (%d) ***\n", deferredInts);
    }

#endif

}


VOID
CancelHardwareInterrupts(
    IN LONG Count
    )

/*++

Routine Description:

    Used to decrement the number of pending h/w interrupts. We need to do this
    when removing completed READ CCBs from an event queue for which h/w
    interrupts have been issued

Arguments:

    Count   - number of h/w interrupt requests to cancel. Used to aggregate
              the cancels, saving Count-1 calls to this routine & Enter &
              Leave critical section calls

Return Value:

    None.

--*/

{
#if DBG

    LONG deferredInts;

#endif

    IF_DEBUG(CRITICAL) {
        CRITDUMP(("*** CancelHardwareInterrupts(%d) ***\n", Count));
    }

    IF_DEBUG(DLC_ASYNC) {
        DPUT1("*** CancelHardwareInterrupts(%d) ***\n", Count);
    }

    //
    // decrement the interrupt counter within the critical section. If it goes
    // to -1 then we have no more outstanding hardware interrupt requests. If
    // it is > -1 then issue a new interrupt request
    //

    IF_DEBUG(CRITSEC) {
        DPUT("CancelHardwareInterrupts: ENTERING HardwareIntCritSec\n");
    }

    EnterCriticalSection(&HardwareIntCritSec);
    HardwareIntsQueued -= Count;

#if DBG

    deferredInts = HardwareIntsQueued;

#endif

    //
    // sanity check
    //

    ASSERT(HardwareIntsQueued >= -1);

    IF_DEBUG(CRITSEC) {
        DPUT("CancelHardwareInterrupts: LEAVING HardwareIntCritSec\n");
    }

    LeaveCriticalSection(&HardwareIntCritSec);

#if DBG

    IF_DEBUG(CRITICAL) {
        CRITDUMP(("*** EOF CancelHardwareInterrupts (%d) ***\n", deferredInts));
    }

    IF_DEBUG(DLC_ASYNC) {
        DPUT1("*** EOF CancelHardwareInterrupts (%d) ***\n", deferredInts);
    }

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\vrica.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrica.h

Abstract:

    Defines exported function in ntvdm.exe which calls the ica_hw_interrupt
    function

    Contents:

Author:

    Richard L Firth (rfirth) 09-Jun-1992

Revision History:

--*/

extern call_ica_hw_interrupt(int, int, int);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\vrinit.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrinit.c

Abstract:

    Contains Vdm Redir (Vr) 32-bit side initialization and uninitialization
    routines

    Contents:
        VrInitialized
        VrInitialize
        VrUninitialize
        VrRaiseInterrupt
        VrDismissInterrupt
        VrQueueCompletionHandler
        VrHandleAsyncCompletion
        VrCheckPmNetbiosAnr
        VrEoiAndDismissInterrupt
        VrSuspendHook
        VrResumeHook

Author:

    Richard L Firth (rfirth) 13-Sep-1991

Environment:

    32-bit flat address space

Revision History:

    13-Sep-1991 RFirth
        Created

--*/

#include <nt.h>
#include <ntrtl.h>      // ASSERT, DbgPrint
#include <nturtl.h>
#include <windows.h>
#include <softpc.h>     // x86 virtual machine definitions
#include <vrdlctab.h>
#include <vdmredir.h>   // common Vdm Redir stuff
#include <vrinit.h>
#include <nb30.h>
#include <netb.h>
#include <dlcapi.h>
#include <vrdefld.h>
#include "vrdlc.h"
#include "vrdebug.h"
#define BOOL            // kludge for mips build
#include <insignia.h>   // Required for ica.h
#include <xt.h>         // Required for ica.h
#include <ica.h>
#include <vrica.h>      // call_ica_hw_interrupt

//
// external functions
//

extern BOOL VDDInstallUserHook(HANDLE, FARPROC, FARPROC, FARPROC, FARPROC);

//
// prototypes
//

VOID
VrSuspendHook(
    VOID
    );

VOID
VrResumeHook(
    VOID
    );

//
// data
//

static BOOLEAN IsVrInitialized = FALSE; // set when TSR loaded

extern DWORD VrPeekNamedPipeTickCount;
extern CRITICAL_SECTION VrNmpRequestQueueCritSec;
extern CRITICAL_SECTION VrNamedPipeCancelCritSec;


//
// Async Event Disposition. The following critical sections, queue and counter
// plus the routines VrRaiseInterrupt, VrDismissInterrupt,
// VrQueueCompletionHandler and VrHandleAsyncCompletion comprise the async
// event disposition processing.
//
// We employ these to dispose of the asynchronous event completions in the order
// they occur. Also we keep calls to call_ica_hw_interrupt serialized: the reason
// for this is that the ICA is not guaranteed to generate an interrupt. Rather
// than blast the ICA with interrupt requests, we generate one only when we
// know we have completed the previous disposition
//

CRITICAL_SECTION AsyncEventQueueCritSec;
VR_ASYNC_DISPOSITION* AsyncEventQueueHead = NULL;
VR_ASYNC_DISPOSITION* AsyncEventQueueTail = NULL;

CRITICAL_SECTION QueuedInterruptCritSec;
LONG QueuedInterrupts = -1;
LONG FrozenInterrupts = 0;

//
// FrozenVdmContext - TRUE if the 16-bit context has been suspended. When this
// happens, we need to queue any hardware interrupt requests until the 16-bit
// context has been resumed
//

BOOLEAN FrozenVdmContext = FALSE;


//
// routines
//

BOOLEAN
VrInitialized(
    VOID
    )

/*++

Routine Description:

    Returns whether the VdmRedir support has been initialized yet (ie redir.exe
    TSR loaded in DOS emulation memory). Principally here because VdmRedir is
    now a DLL loaded at run-time via LoadLibrary

Arguments:

    None.

Return Value:

    BOOLEAN
        TRUE    VdmRedir support is active
        FALSE   VdmRedir support inactive

--*/

{
    return IsVrInitialized;
}


BOOLEAN
VrInitialize(
    VOID
    )

/*++

Routine Description:

    Performs 32-bit side initialization when the redir TSR is loaded

Arguments:

    None. ES:BX in VDM context is place to return computer name, CX is size
    of buffer in VDM context for computer name

Return Value:

    None.

--*/

{
    LPBYTE lpVdmVrInitialized;

#if DBG
    DIAGNOSTIC_INFO info;

    VrDebugInit();
    DIAGNOSTIC_ENTRY("VrInitialize", DG_NONE, &info);
#endif

    //
    // if we are already initialized return TRUE. Not sure if this should
    // really happen?
    //

    if (IsVrInitialized) {
        return TRUE;
    }

    //
    // register our hooks
    //

    if (!VDDInstallUserHook(GetModuleHandle("VDMREDIR"),
                            (FARPROC)NULL,  // 16-bit process create hook
                            (FARPROC)NULL,  // 16-bit process terminate hook
                            (FARPROC)VrSuspendHook,
                            (FARPROC)VrResumeHook
                            )) {
        return FALSE;
    }

    //
    // do the rest of the initialization - none of this can fail
    //

    InitializeCriticalSection(&VrNmpRequestQueueCritSec);
    InitializeCriticalSection(&AsyncEventQueueCritSec);
    InitializeCriticalSection(&QueuedInterruptCritSec);
    InitializeCriticalSection(&VrNamedPipeCancelCritSec);
    VrNetbios5cInitialize();
    VrDlcInitialize();
    IsVrInitialized = TRUE;

    //
    // deferred loading: we need to let the VDM redir know that the 32-bit
    // support is loaded. Set the VrInitialized flag in the VDM Redir at
    // the known address
    //

    lpVdmVrInitialized = LPBYTE_FROM_WORDS(getCS(), (DWORD)(&(((VDM_LOAD_INFO*)0)->VrInitialized)));
    *lpVdmVrInitialized = 1;

    //
    // VrPeekNamedPipe idle processing
    //

    VrPeekNamedPipeTickCount = GetTickCount();
    setCF(0);   // no carry == successful initialization

    //
    // inform 32-bit caller of successful initialization
    //

    return TRUE;
}


VOID
VrUninitialize(
    VOID
    )

/*++

Routine Description:

    Performs 32-bit side uninitialization when the redir TSR is removed

Arguments:

    None.

Return Value:

    None.

--*/

{
    IF_DEBUG(DLL) {
        DPUT("VrUninitialize\n");
    }

    if (IsVrInitialized) {
        DeleteCriticalSection(&VrNmpRequestQueueCritSec);
        DeleteCriticalSection(&AsyncEventQueueCritSec);
        DeleteCriticalSection(&QueuedInterruptCritSec);
        DeleteCriticalSection(&VrNamedPipeCancelCritSec);
    }
    IsVrInitialized = FALSE;
    setCF(0);   // no carry == successful uninitialization
}


VOID
VrRaiseInterrupt(
    VOID
    )

/*++

Routine Description:

    Generates a simulated hardware interrupt by calling the ICA routine. Access
    to the ICA is serialized here: we maintain a count. If the count goes from
    -1 to 0, we call the ICA function to generate the interrupt in the VDM. Any
    other value just queues the interrupt by incrementing the counter. When the
    corresponding VrDismissInterrupt call is made, a queued interrupt will be
    generated. This stops us losing simulated h/w interrupts to the VDM

Arguments:

    None.

Return Value:

    None.

--*/

{
    EnterCriticalSection(&QueuedInterruptCritSec);
    ++QueuedInterrupts;
    if (QueuedInterrupts == 0) {

        if (!FrozenVdmContext) {

            IF_DEBUG(CRITICAL) {
                CRITDUMP(("*** VrRaiseInterrupt: Interrupting VDM ***\n"));
            }

            IF_DEBUG(HW_INTERRUPTS) {
                DBGPRINT("VrRaiseInterrupt: interrupting VDM\n");
            }

            call_ica_hw_interrupt(NETWORK_ICA, NETWORK_LINE, 1);
        } else {

            IF_DEBUG(HW_INTERRUPTS) {
                DBGPRINT("*** VrRaiseInterrupt: VDM is Frozen, not interrupting ***\n");
            }
        }
    }

    IF_DEBUG(CRITICAL) {
        CRITDUMP(("*** VrRaiseInterrupt (%d) ***\n", QueuedInterrupts));
    }

    IF_DEBUG(HW_INTERRUPTS) {
        DBGPRINT("*** VrRaiseInterrupt (%d) ***\n", QueuedInterrupts);
    }

    LeaveCriticalSection(&QueuedInterruptCritSec);
}


VOID
VrDismissInterrupt(
    VOID
    )

/*++

Routine Description:

    Companion routine to VrRaiseInterrupt: this function is called when the
    async event which called VrRaiseInterrupt has been disposed. If other calls
    to VrRaiseInterrupt have been made in the interim then QueuedInterrupts will
    be >0. In this case we re-issue the call to call_ica_hw_interrupt() which
    will generate an new simulated h/w interrupt in the VDM.

    Note: This routine is called from the individual disposition routine, not
    from the disposition dispatch routine (VrHandleAsyncCompletion)

Arguments:

    None.

Return Value:

    None.

--*/

{
    EnterCriticalSection(&QueuedInterruptCritSec);
    if (!FrozenVdmContext) {
        --QueuedInterrupts;
        if (QueuedInterrupts >= 0) {

            IF_DEBUG(CRITICAL) {
                CRITDUMP(("*** VrDismissInterrupt: interrupting VDM ***\n"));
            }

            IF_DEBUG(HW_INTERRUPTS) {
                DBGPRINT("VrDismissInterrupt: interrupting VDM\n");
            }

            call_ica_hw_interrupt(NETWORK_ICA, NETWORK_LINE, 1);
        }
    } else {

        IF_DEBUG(HW_INTERRUPTS) {
            DBGPRINT("*** VrDismissInterrupt: VDM is Frozen??? ***\n");
        }

    }

    IF_DEBUG(CRITICAL) {
        CRITDUMP(("*** VrDismissInterrupt (%d) ***\n", QueuedInterrupts));
    }

    IF_DEBUG(HW_INTERRUPTS) {
        DBGPRINT("*** VrDismissInterrupt (%d) ***\n", QueuedInterrupts);
    }

    LeaveCriticalSection(&QueuedInterruptCritSec);
}


VOID
VrQueueCompletionHandler(
    IN VOID (*AsyncDispositionRoutine)(VOID)
    )

/*++

Routine Description:

    Adds an async event disposition packet to the queue of pending completions
    (event waiting to be fully completed by the VDM async event ISR/BOP). We
    keep these in a singly-linked queue so that we avoid giving priority to one
    completion handler while polling

Arguments:

    AsyncDispositionRoutine - address of routine which will dispose of the
                              async completion event

Return Value:

    None.

--*/

{
    VR_ASYNC_DISPOSITION* pDisposition;

    pDisposition = (VR_ASYNC_DISPOSITION*)LocalAlloc(LMEM_FIXED,
                                                     sizeof(VR_ASYNC_DISPOSITION)
                                                     );
    if (pDisposition == NULL) {

        IF_DEBUG(CRITICAL) {
            CRITDUMP(("*** VrQueueCompletionHandler: ERROR: Failed to alloc Q packet ***\n"));
        }

        IF_DEBUG(HW_INTERRUPTS) {
            DBGPRINT("!!! VrQueueCompletionHandler: failed to allocate memory\n");
        }

        return;
    }
    EnterCriticalSection(&AsyncEventQueueCritSec);
    pDisposition->Next = NULL;
    pDisposition->AsyncDispositionRoutine = AsyncDispositionRoutine;
    if (AsyncEventQueueHead == NULL) {
        AsyncEventQueueHead = pDisposition;
    } else {
        AsyncEventQueueTail->Next = pDisposition;
    }
    AsyncEventQueueTail = pDisposition;
    LeaveCriticalSection(&AsyncEventQueueCritSec);

    IF_DEBUG(CRITICAL) {
        CRITDUMP(("VrQueueCompletionHandler: Handler %08x queued @ %08x\n",
                AsyncDispositionRoutine,
                pDisposition
                ));
    }

    IF_DEBUG(HW_INTERRUPTS) {
        DBGPRINT("VrQueueCompletionHandler: Handler %08x queued @ %08x\n",
                 AsyncDispositionRoutine,
                 pDisposition
                 );
    }
}


VOID
VrHandleAsyncCompletion(
    VOID
    )

/*++

Routine Description:

    Called by VrDispatch for the async completion event BOP. Dequeues the
    disposition packet from the head of the queue and calls the disposition
    routine

Arguments:

    None.

Return Value:

    None.

--*/

{
    VR_ASYNC_DISPOSITION* pDisposition;
    VOID (*AsyncDispositionRoutine)(VOID);

    EnterCriticalSection(&AsyncEventQueueCritSec);
    pDisposition = AsyncEventQueueHead;
    AsyncDispositionRoutine = pDisposition->AsyncDispositionRoutine;
    AsyncEventQueueHead = pDisposition->Next;

    IF_DEBUG(CRITICAL) {
        CRITDUMP(("VrHandleAsyncCompletion: Handler %08x dequeued @ %08x\n",
                AsyncDispositionRoutine,
                pDisposition
                ));
    }

    IF_DEBUG(HW_INTERRUPTS) {
        DBGPRINT("VrHandleAsyncCompletion: freeing @ %08x && calling handler %08x\n",
                 pDisposition,
                 AsyncDispositionRoutine
                 );
    }

    LocalFree((HLOCAL)pDisposition);
    LeaveCriticalSection(&AsyncEventQueueCritSec);
    AsyncDispositionRoutine();
}


VOID
VrCheckPmNetbiosAnr(
    VOID
    )

/*++

Routine Description:

    If the disposition routine queued at the head of the disposition list is
    VrNetbios5cInterrupt, indicating that the next asynchronous event to be
    completed is an async Netbios call, then set the 16-bit Zero Flag to TRUE
    if the NCB originated in 16-bit protect mode

    Assumes:

        1.  This function is called after the corresponding interrupt has been
            delivered

        2.  There is something on the AsyncEventQueue

Arguments:

    None.

Return Value:

    None.

    ZF in 16-bit context flags word:

        TRUE    - the next thing to complete is not an NCB, OR, it originated
                  in 16-bit real-mode

        FALSE   - the next event to be disposed of IS an async Netbios request,
                  the NCB for which originated in 16-bit protect mode

--*/

{
    BOOLEAN result;

    EnterCriticalSection(&AsyncEventQueueCritSec);
    if (AsyncEventQueueHead->AsyncDispositionRoutine == VrNetbios5cInterrupt) {
        result = IsPmNcbAtQueueHead();
    } else {
        result = FALSE;
    }

    IF_DEBUG(HW_INTERRUPTS) {
        DBGPRINT("VrCheckPmNetbiosAnr: %s\n", result ? "TRUE" : "FALSE");
    }

    //
    // set ZF: TRUE means event at head of list not PM NCB completion, or no
    // NCB completion event on list
    //

    setZF(!result);
    LeaveCriticalSection(&AsyncEventQueueCritSec);
}


VOID
VrEoiAndDismissInterrupt(
    VOID
    )

/*++

Routine Description:

    Performs an EOI then calls VrDismissInterrupt which checks for pending
    interrupt requests.

    Called when we handle the simulated h/w interrupt entirely in protect mode
    (original call was from a WOW app). In this case, the p-m interrupt handler
    doesn't perform out a0,20; out 20,20 (non-specific EOI to PIC 0 & PIC 1),
    but calls this handler which gets SoftPc to handle the EOIs to the virtual
    PICs. This is quicker because we don't take any restricted-opcode faults
    (the out instruction in real mode causes a GPF because the code doesn't
    have enough privilege to execute I/O instructions. SoftPc takes a look and
    sees that the code is trying to talk to the PIC. It then performs the
    necessary mangling of the PIC state)

Arguments:

    None.

Return Value:

    None.

--*/

{
    int line;

    extern VOID SoftPcEoi(int, int*);

    IF_DEBUG(HW_INTERRUPTS) {
        DBGPRINT("VrEoiAndDismissInterrupt\n");
    }

#ifndef NEC_98
    line = -1;
    SoftPcEoi(1, &line);    // non-specific EOI to slave PIC
#endif

    line = -1;
    SoftPcEoi(0, &line);    // non-specific EOI to master PIC
    VrDismissInterrupt();
}


VOID
VrSuspendHook(
    VOID
    )

/*++

Routine Description:

    This is the hook called by NTVDM.EXE for the VDD handle owned by VDMREDIR.DLL.
    The hook is called when NTVDM is about to execute a 32-bit process and it
    suspends the 16-bit context

    Within the queued interrupt critical section we note that the 16-bit context
    has been frozen and snapshot the outstanding interrupt request count

    N.B. We don't expect that this function will be called again before an
    intervening call to VrResumeHook

Arguments:

    None.

Return Value:

    None.

--*/

{
    EnterCriticalSection(&QueuedInterruptCritSec);
    FrozenVdmContext = TRUE;
    FrozenInterrupts = QueuedInterrupts;

        IF_DEBUG(HW_INTERRUPTS) {
            DBGPRINT("VrSuspendHook - FrozenInterrupts = %d\n", FrozenInterrupts);
        }

    LeaveCriticalSection(&QueuedInterruptCritSec);
}


VOID
VrResumeHook(
    VOID
    )

/*++

Routine Description:

    This hook is called when NTVDM resumes the 16-bit context after executing a
    32-bit process

    Within the queued interrupt critical section we note that the 16-bit context
    has been resumed and we compare the current queued interrupt request count
    with the snapshot value we took when the context was suspended. If during the
    intervening period, interrupt requests have been made, we call
    VrDismissInterrupt to generate the next interrupt

    N.B. We don't expect that this function will be called again before an
    intervening call to VrSuspendHook

Arguments:

    None.

Return Value:

    None.

--*/

{
    EnterCriticalSection(&QueuedInterruptCritSec);

    IF_DEBUG(HW_INTERRUPTS) {
        DBGPRINT("VrResumeHook - FrozenInterrupts = %d QueuedInterrupts = %d\n",
                 FrozenInterrupts,
                 QueuedInterrupts
                 );
    }

    FrozenVdmContext = FALSE;
    if (QueuedInterrupts > FrozenInterrupts) {

        //
        // interrupts were queued while the 16-bit context was suspended. If
        // the QueuedInterrupts count was -1 when we took the snapshot then
        // we must interrupt the VDM. The count has already been updated to
        // account for the interrupt, but none was delivered. Do it here
        //

//        if (FrozenInterrupts == -1) {

            IF_DEBUG(HW_INTERRUPTS) {
                DBGPRINT("*** VrResumeHook: interrupting VDM ***\n");
            }

            call_ica_hw_interrupt(NETWORK_ICA, NETWORK_LINE, 1);
//        }
    }
    LeaveCriticalSection(&QueuedInterruptCritSec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\vrdll.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrdll.c

Abstract:

    Initialization for VdmRedir as DLL

    Contents:
        VrDllInitialize

Author:

    Richard L Firth (rfirth) 11-May-1992


Revision History:


--*/

#if DBG
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vrnmpipe.h>
#include <vrinit.h>
#include "vrdebug.h"

//
// external data
//

//
// external functions
//

extern
VOID
TerminateDlcEmulation(
    VOID
    );


#if DBG
FILE* hVrDebugLog = NULL;
#endif

BOOLEAN
VrDllInitialize(
    IN  PVOID DllHandle,
    IN  ULONG Reason,
    IN  PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    Gets control as a process or thread attaches/detaches from VdmRedir DLL.
    Always returns success

Arguments:

    DllHandle   -
    Reason      -
    Context     -

Return Value:

    BOOLEAN
        TRUE

--*/

{
    BOOL ok = TRUE;

#if DBG
    if (Reason == DLL_PROCESS_ATTACH) {

        //
        // a little run-time diagnostication, madam?
        //

        LPSTR ptr;

        //
        // override VrDebugFlags from VR environment variable
        //

        if (ptr = getenv("VR")) {
            if (!_strnicmp(ptr, "0x", 2)) {
                ptr += 2;
            }
            for (VrDebugFlags = 0; isxdigit(*ptr); ++ptr) {
                VrDebugFlags = VrDebugFlags * 16
                    + (*ptr
                        - ('0' + ((*ptr <= '9') ? 0
                            : ((islower(*ptr) ? 'a' : 'A') - ('9' + 1)))));
            }
            IF_DEBUG(DLL) {
                DBGPRINT("Setting VrDebugFlags to %#08x from environment variable (VR)\n", VrDebugFlags);
            }
        }
        IF_DEBUG(TO_FILE) {
            if ((hVrDebugLog = fopen(VRDEBUG_FILE, "w+")) == NULL) {
                VrDebugFlags &= ~DEBUG_TO_FILE;
            } else {

                char currentDirectory[256];
                int n;

                currentDirectory[0] = 0;
                if (n = GetCurrentDirectory(sizeof(currentDirectory), currentDirectory)) {
                    if (currentDirectory[n-1] == '\\') {
                        currentDirectory[n-1] = 0;
                    }
                }
                DbgPrint("Writing debug output to %s\\" VRDEBUG_FILE "\n", currentDirectory);
            }
        }
        IF_DEBUG(DLL) {
            DBGPRINT("VrDllInitialize: process %d Attaching\n", GetCurrentProcessId());
        }
    } else if (Reason == DLL_PROCESS_DETACH) {
        IF_DEBUG(DLL) {
            DBGPRINT("VrDllInitialize: process %d Detaching\n", GetCurrentProcessId());
        }
        if (hVrDebugLog) {
            fclose(hVrDebugLog);
        }
    } else {
        IF_DEBUG(DLL) {
            DBGPRINT("VrDllInitialize: Thread %d.%d %staching\n",
                     GetCurrentProcessId(),
                     GetCurrentThreadId(),
                     (Reason == DLL_THREAD_ATTACH) ? "At" : "De"
                     );
        }
    }
#endif

    if (Reason == DLL_PROCESS_ATTACH) {

        //
        // we now perform initialization at load time due to deferred loading
        // of VdmRedir.DLL
        //

        ok = VrInitialize();
    } else if (Reason == DLL_PROCESS_DETACH) {

        //
        // clean up resources
        //

        VrUninitialize();
        TerminateDlcEmulation();
        ok = TRUE;
    }

    //
    // basically, nothing to do
    //

    return (BOOLEAN)ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\vrmisc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrmisc.c

Abstract:

    Contains miscellaneous VdmRedir (Vr) functions:

        VrTerminateDosProcess
        VrUnsupportedFunction

Author:

    Richard L Firth (rfirth) 01-Oct-1991

Environment:

    Flat 32-bit

Revision History:

    01-Oct-1991 rfirth
        Created

--*/

#include <nt.h>
#include <ntrtl.h>      // ASSERT, DbgPrint
#include <nturtl.h>
#include <windows.h>
#include <softpc.h>     // x86 virtual machine definitions
#include <vrdlctab.h>
#include <vdmredir.h>   // common Vdm Redir stuff
#include <vrmisc.h>     // Vr miscellaneous prototypes
#include <vrmslot.h>    // Vr mailslot prototypes
#include <vrnmpipe.h>   // Vr named pipe prototypes
#include "vrdebug.h"    // debugging stuff


VOID
VrTerminateDosProcess(
    VOID
    )

/*++

Routine Description:

    When a Dos app terminates a NetResetEnvironment is sent to the redir so
    that it can clean up any state info left by the closing application. In
    our case control is passed here and we perform common cleanup operations
    like deleting any outstanding mailslots

Arguments:

    AX = PDB of terminating DOS process

Return Value:

    None.

--*/

{
    WORD DosPdb = getAX();

#if DBG

    IF_DEBUG(NETAPI) {
        DbgPrint("VrTerminateDosProcess. PDB=%04x\n", DosPdb);
    }

#endif

    VrTerminateMailslots(DosPdb);
    VrTerminateNamedPipes(DosPdb);
}


VOID
VrUnsupportedFunction(
    VOID
    )

/*++

Routine Description:

    Default error routine for unsupported/not-yet-implemented functions

Arguments:

    None.

Return Value:

    None.
    Sets CF=1 in x86 context image and AX=ERROR_NOT_SUPPORTED (50)

--*/

{

#if DBG

    DbgPrint("VrUnsupportedFunction\n");
    VrDumpRealMode16BitRegisters(TRUE);

#endif

    SET_ERROR(ERROR_NOT_SUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\vrnetapi.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrnetapi.c

Abstract:

    This module contains routines which support Vdm Redir lanman APIs and
    private functions:

        VrGetCDNames
        VrGetComputerName
        VrGetDomainName
        VrGetLogonServer
        VrGetUserName
        VrNetGetDCName
        VrNetMessageBufferSend
        VrNetNullTransactApi
        VrNetRemoteApi
        OemToUppercaseUnicode
        VrNetServiceControl
        VrNetServiceEnum
        VrNetServerEnum
        VrNetTransactApi
        VrNetUseAdd
        VrNetUseDel
        VrNetUseEnum
        VrNetUseGetInfo
        VrNetWkstaGetInfo
        (DumpWkstaInfo)
        VrNetWkstaSetInfo
        VrReturnAssignMode
        VrSetAssignMode
        VrGetAssignListEntry
        VrDefineMacro
        VrBreakMacro
        (VrpTransactVdm)
        EncryptPassword

Author:

    Richard L Firth (rfirth) 21-Oct-1991

Revision History:

    21-Oct-1991 rfirth
        Created

    02-May-1994 rfirth
        Upped password limit (& path length limit) to LM20_ values for
        VrDefineMacro

--*/

#include <nt.h>
#include <ntrtl.h>      // ASSERT, DbgPrint
#include <nturtl.h>
#include <windows.h>
#include <softpc.h>     // x86 virtual machine definitions
#include <vrdlctab.h>
#include <vdmredir.h>   // common Vdm Redir stuff
#include <lmcons.h>     // LM20_PATHLEN
#include <lmerr.h>      // lan manager error codes
#include <lmuse.h>      // USE_LOTS_OF_FORCE
#include <lmwksta.h>    // NetWkstaGetInfo
#include <lmserver.h>   // SV_TYPE_ALL
#include <lmapibuf.h>   // NetApiBufferFree
#include <vrnetapi.h>   // prototypes
#include <vrremote.h>   // VrRemoteApi prototypes
#include <packon.h>     // structures in apistruc.h are not dword-only
#include <apistruc.h>   // tr_packet
#include <packoff.h>    // switch back on structure packing
#include <apinums.h>    // remotable API numbers
#include <remdef.h>     // remotable API descriptors
#include <remtypes.h>   // remotable API descriptor characters
#include <rxp.h>        // RxpTransactSmb
#include <apiparam.h>   // XS_NET_USE_ADD
#include <xstypes.h>    // XS_PARAMETER_HEADER
#include <xsprocs.h>    // XsNetUseAdd etc
#include <string.h>     // Dos still dealing with ASCII
#include <netlibnt.h>   // NetpNtStatusToApiStatus()
#include "vrputil.h"    // VrpMapDosError()
#include "vrdebug.h"    // VrDebugFlags etc
#include "dlstruct.h"   // down-level structures
#include <rxuser.h>     // RxNetUser...
#include <lmaccess.h>   // USER_PASSWORD_PARMNUM
#include <crypt.h>      // Needed by NetUserPasswordSet

//
// private routine prototypes
//

#if DBG

VOID
DumpWkstaInfo(
    IN DWORD Level,
    IN LPBYTE Buffer
    );

#endif

NET_API_STATUS
VrpTransactVdm(
    IN  BOOL    NullSessionFlag
    );

#if DBG
PRIVATE
VOID
DumpTransactionPacket(
    IN  struct tr_packet* TransactionPacket,
    IN  BOOL    IsInput,
    IN  BOOL    DumpData
    );
#endif

//
// external functions
//

NET_API_STATUS
GetLanmanSessionKey(
    IN LPWSTR ServerName,
    OUT LPBYTE pSessionKey
    );

//
// internal functions (not necessarily private)
//

BOOL
OemToUppercaseUnicode(
    IN LPSTR AnsiStringPointer,
    OUT LPWSTR UnicodeStringPointer,
    IN DWORD MaxLength
    );

BOOL
EncryptPassword(
    IN LPWSTR ServerName,
    IN OUT LPBYTE Password
    );


//
// public routines
//

//
// net APIs now unicode
//

#define NET_UNICODE

VOID
VrGetCDNames(
    VOID
    )

/*++

Routine Description:

    Performs the private redir function to get the computer and domain names.
    These are usually stored in the redir after they are read out of lanman.ini

    NOTE:

        This code assumes that the pointers are valid and point to valid,
        writable memory which has enough reserved space for the types of
        strings to be written

Arguments:

    None. All arguments are extracted from the Vdm context registers/memory
    The dos redir gets passed a buffer in es:di which contains 3 far pointers
    to:
        place to store computer name
        place to store primary domain controller name
        place to store logon domain name

Return Value:

    None. Results returned via VDM registers or in VDM memory, according to
    request

    Note that in the dos redir function, there is no return code, so if this
    routine fails the results will be unpredictable

--*/

{
    struct I_CDNames* structurePointer;
    LPSTR stringPointer;
    LPWSTR infoString;
    NET_API_STATUS rc1;
    NET_API_STATUS rc2;
    ANSI_STRING ansiString;
    UNICODE_STRING unicodeString;
    LPWKSTA_INFO_100 wkstaInfo = NULL;
    LPWKSTA_USER_INFO_1 userInfo = NULL;
    CHAR ansiBuf[LM20_CNLEN+1];
    NTSTATUS status;
    register DWORD len;

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrGetCDNames\n");
        IF_DEBUG(BREAKPOINT) {
            DbgBreakPoint();
        }
    }
#endif

    rc1 = NetWkstaGetInfo(NULL, 100, (LPBYTE*)&wkstaInfo);
    rc2 = NetWkstaUserGetInfo(0, 1, (LPBYTE*)&userInfo);
    
    ansiBuf[0] = 0;
    ansiString.MaximumLength = sizeof(ansiBuf);
    ansiString.Length = 0;
    ansiString.Buffer = ansiBuf;

    structurePointer = (struct I_CDNames*)POINTER_FROM_WORDS(getES(), getDI());
    stringPointer = POINTER_FROM_POINTER(&structurePointer->CDN_pszComputer);
    if (stringPointer) {
        *stringPointer = 0;
        if (rc1 == NERR_Success) {
            infoString = (LPWSTR)wkstaInfo->wki100_computername;
            len = wcslen(infoString);
            if (len <= LM20_CNLEN) {
                RtlInitUnicodeString(&unicodeString, infoString);
                status = RtlUnicodeStringToAnsiString(&ansiString, &unicodeString, FALSE);
                if (NT_SUCCESS(status)) {
                    RtlCopyMemory(stringPointer, ansiBuf, len+1);
                    _strupr(stringPointer);
                }
            }

        }
    }

    stringPointer = POINTER_FROM_POINTER(&structurePointer->CDN_pszPrimaryDomain);
    if (stringPointer) {
        *stringPointer = 0;
        if (rc1 == NERR_Success) {
            infoString = (LPWSTR)wkstaInfo->wki100_langroup;
            len = wcslen(infoString);
            if (len <= LM20_CNLEN) {
                RtlInitUnicodeString(&unicodeString, infoString);
                status = RtlUnicodeStringToAnsiString(&ansiString, &unicodeString, FALSE);
                if (NT_SUCCESS(status)) {
                    RtlCopyMemory(stringPointer, ansiBuf, len+1);
                    _strupr(stringPointer);
                }
            }
        }
    }

    stringPointer = POINTER_FROM_POINTER(&structurePointer->CDN_pszLogonDomain);
    if (stringPointer) {
        *stringPointer = 0;
        if (rc2 == NERR_Success) {
            infoString = (LPWSTR)userInfo->wkui1_logon_domain;
            len = wcslen(infoString);
            if (len <= LM20_CNLEN) {
                RtlInitUnicodeString(&unicodeString, infoString);
                status = RtlUnicodeStringToAnsiString(&ansiString, &unicodeString, FALSE);
                if (NT_SUCCESS(status)) {
                    RtlCopyMemory(stringPointer, ansiBuf, len+1);
                    _strupr(stringPointer);
                }
            }

        }
    }

    if (wkstaInfo) {
        NetApiBufferFree((LPVOID)wkstaInfo);
    }
    if (userInfo) {
        NetApiBufferFree((LPVOID)userInfo);
    }

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrGetCDNames: computername=%s, PDCname=%s, logon domain=%s\n\n",
                POINTER_FROM_POINTER(&structurePointer->CDN_pszComputer)
                    ? POINTER_FROM_POINTER(&structurePointer->CDN_pszComputer)
                    : "",
                POINTER_FROM_POINTER(&structurePointer->CDN_pszPrimaryDomain)
                    ? POINTER_FROM_POINTER(&structurePointer->CDN_pszPrimaryDomain)
                    : "",
                POINTER_FROM_POINTER(&structurePointer->CDN_pszLogonDomain)
                    ? POINTER_FROM_POINTER(&structurePointer->CDN_pszLogonDomain)
                    : ""
                );
    }
#endif
}


VOID
VrGetComputerName(
    VOID
    )

/*++

Routine Description:

    Performs the private redir function to return the computer name stored in
    the redir

Arguments:

    ENTRY   ES:DI = buffer to copy computer name into

Return Value:

    None.

--*/

{
    BOOL    ok;
    CHAR    nameBuf[MAX_COMPUTERNAME_LENGTH+1];
    DWORD   nameLen;

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrGetComputerName\n");
    }
#endif

    nameLen = sizeof(nameBuf)-1;
    ok = GetComputerName(nameBuf, &nameLen);
    if (!ok) {
        SET_ERROR(ERROR_NOT_SUPPORTED);
    } else {
        if (nameLen > LM20_CNLEN) {
            SET_ERROR(NERR_BufTooSmall);
#if DBG
            IF_DEBUG(NETAPI) {
                DbgPrint("VrGetComputerName returning ERROR %d!\n", getAX());
            }
#endif
        } else {
            strcpy(LPSTR_FROM_WORDS(getES(), getDI()), nameBuf);
            setAX(0);
            setCF(0);
#if DBG
            IF_DEBUG(NETAPI) {
                DbgPrint("VrGetComputerName returning %s\n", nameBuf);
            }
#endif
        }
    }
}


VOID
VrGetDomainName(
    VOID
    )

/*++

Routine Description:

    Performs the private redir function to return the primary domain name.
    This info is stored in the redir after being read from lanman.ini at
    configuration time

Arguments:

    None. All arguments are extracted from the Vdm context registers/memory

Return Value:

    None. Results returned via VDM registers or in VDM memory, according to
    request

--*/

{
#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrGetDomainName\n");
        IF_DEBUG(BREAKPOINT) {
            DbgBreakPoint();
        }
    }
#endif

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrGetDomainName - unsupported SVC\n");
    }
#endif

    SET_ERROR(ERROR_NOT_SUPPORTED);
}


VOID
VrGetLogonServer(
    VOID
    )

/*++

Routine Description:

    Performs the private redir function to return the name of the computer
    which logged this user onto the network

Arguments:

    None. All arguments are extracted from the Vdm context registers/memory

Return Value:

    None. Results returned via VDM registers or in VDM memory, according to
    request

--*/

{
#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrGetLogonServer\n");
        IF_DEBUG(BREAKPOINT) {
            DbgBreakPoint();
        }
    }
#endif

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrGetLogonServer - unsupported SVC\n");
    }
#endif

    SET_ERROR(ERROR_NOT_SUPPORTED);
}


VOID
VrGetUserName(
    VOID
    )

/*++

Routine Description:

    Performs the private redir function to return the logged on user name
    which is normally stored in the redir

Arguments:

    ENTRY   BX = 0  call doesn't care about buffer length (NetGetEnumInfo)
            BX = 1  call is for NetGetUserName, which does care about buffer length
            CX = buffer length, if BX = 1
            ES:DI = buffer

Return Value:

    None.

--*/

{
    NET_API_STATUS status;
    LPBYTE buffer;
    LPWKSTA_USER_INFO_0 pInfo;
    BOOL itFits;
    DWORD len;

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrGetUserName\n");
        IF_DEBUG(BREAKPOINT) {
            DbgBreakPoint();
        }
    }
#endif

    status = NetWkstaUserGetInfo(NULL, 0, &buffer);
    if (status == NERR_Success) {
        pInfo = (LPWKSTA_USER_INFO_0)buffer;
#ifdef DBCS /*fix for DBCS char sets*/
        len = (DWORD)NetpUnicodeToDBCSLen(pInfo->wkui0_username);
#else // !DBCS
        len = (DWORD)wcslen(pInfo->wkui0_username);
#endif // !DBCS
        if (getBX()) {
            itFits = (len) <= (DWORD)getCX()-1;
            if (itFits) {
                SET_SUCCESS();
            } else {
                SET_ERROR(NERR_BufTooSmall);
            }
        } else {
            itFits = TRUE;
        }
        if (itFits) {
#ifdef DBCS /*fix for DBCS charsets*/
            NetpCopyWStrToStrDBCS(LPSTR_FROM_WORDS(getES(), getDI()),
                                   pInfo->wkui0_username);
#else // !DBCS
            NetpCopyWStrToStr(LPSTR_FROM_WORDS(getES(), getDI()), pInfo->wkui0_username);
#endif // !DBCS
        }
        NetApiBufferFree(buffer);
    } else {
        SET_ERROR((WORD)status);
    }
}


VOID
VrNetGetDCName(
    VOID
    )

/*++

Routine Description:

    Performs local NetGetDCName on behalf of the Vdm client

Arguments:

    None. All arguments are extracted from the Vdm context registers/memory

Return Value:

    None. Results returned via VDM registers or in VDM memory, according to
    request

--*/

{
#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrGetDCName\n");
        IF_DEBUG(BREAKPOINT) {
            DbgBreakPoint();
        }
    }
#endif

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrNetGetDCName - unsupported SVC\n");
    }
#endif

    SET_ERROR(ERROR_NOT_SUPPORTED);
}


VOID
VrNetMessageBufferSend(
    VOID
    )

/*++

Routine Description:

    Performs local NetMessageBufferSend on behalf of the Vdm client

Arguments:

    Function 5F40h

    ENTRY    DS:DX = NetMessageBufferSendStruc:
                 char far*    NMBSS_NetName;
                 char far*    NMBSS_Buffer;
                 unsigned int NMBSS_BufSize;

Return Value:

    None. Results returned via VDM registers:
        CF = 0
            Success

        CF = 1
            AX = Error code

--*/

{
    NTSTATUS ntstatus;
    NET_API_STATUS status;
    XS_PARAMETER_HEADER header;
    XS_NET_MESSAGE_BUFFER_SEND parameters;
    struct NetMessageBufferSendStruc* structurePointer;

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrNetMessageBufferSend\n");
        IF_DEBUG(BREAKPOINT) {
            DbgBreakPoint();
        }
    }
#endif

    structurePointer = (struct NetMessageBufferSendStruc*)
                            POINTER_FROM_WORDS(getDS(), getDX());

    parameters.Recipient = LPSTR_FROM_POINTER(&structurePointer->NMBSS_NetName);
    parameters.Buffer = LPBYTE_FROM_POINTER(&structurePointer->NMBSS_Buffer);
    parameters.BufLen = READ_WORD(&structurePointer->NMBSS_BufSize);

    header.Status = 0;
    header.ClientMachineName = NULL;
    header.ClientTransportName = NULL;

    ntstatus = XsNetMessageBufferSend(&header, &parameters, NULL, NULL);
    if (ntstatus != STATUS_SUCCESS) {
        status = NetpNtStatusToApiStatus(ntstatus);
    } else {
        status = header.Status;
    }
    if (status) {
        SET_ERROR(VrpMapDosError(status));

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrNetMessageBufferSend: returning %d\n", status);
    }
#endif

    } else {
        setCF(0);
    }
}


VOID
VrNetNullTransactApi(
    VOID
    )

/*++

Routine Description:

    Performs a transaction IOCTL using the NULL session for a Vdm client

Arguments:

    None. All arguments are extracted from the Vdm context registers/memory

Return Value:

    None. Results returned via VDM registers or in VDM memory, according to
    request

--*/

{
    DWORD status;

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrNetNullTransactApi\n");
        IF_DEBUG(BREAKPOINT) {
            DbgBreakPoint();
        }
    }
#endif

    status = VrpTransactVdm(TRUE);
    if (status) {
        SET_ERROR((WORD)status);
    } else {
        setCF(0);
    }
}


VOID
VrNetRemoteApi(
    VOID
    )

/*++

Routine Description:

    This routine is invoked when a dos program in a Vdm makes a lanman API
    call which in turn calls the redir NetIRemoteAPI function to send the
    request to a lanman server

Arguments:

    None. All arguments are extracted from the Vdm context registers/memory

Return Value:

    None. Results returned via VDM registers or in VDM memory, according to
    request

--*/

{
    DWORD ApiNumber;
    BOOL NullSessionFlag;
    NET_API_STATUS status;
    LPBYTE ServerNamePointer = LPBYTE_FROM_WORDS(getES(), getBX());

#define ParameterDescriptor LPSTR_FROM_WORDS(getDS(), getSI())
#define DataDescriptor      LPSTR_FROM_WORDS(getDS(), getDI())
#define AuxDescriptor       LPSTR_FROM_WORDS(getDS(), getDX())

    ApiNumber = (DWORD)getCX();
    NullSessionFlag = ApiNumber & USE_NULL_SESSION_FLAG;
    ApiNumber &= ~USE_NULL_SESSION_FLAG;

    //
    // get pointers to the various descriptors which are readable from 32-bit
    // context and call the routine to perform the 16-bit remote api function
    //

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrNetRemoteApi: ApiNumber=%d, ServerName=%s\n"
                 "ParmDesc=%s, DataDesc=%s, AuxDesc=%s\n",
                 ApiNumber,
                 LPSTR_FROM_POINTER(ServerNamePointer),
                 ParameterDescriptor,
                 DataDescriptor,
                 AuxDescriptor
                 );
    }
#endif

    //
    // RLF 04/21/93
    //
    // Yikes! It looks like passwords entered in DOS programs are not getting
    // encrypted. What a security hole. Let's block it-
    //
    // if this is a NetUserPasswordSet2 then we call the RxNetUserPasswordSet
    // function to remotely change the password. This function takes care of
    // correctly encrypting the password and sending the request over the NULL
    // session. In this case, ServerNamePointer points at the server name
    // parameter in the following PASCAL calling convention stack frame in DOS
    // memory:
    //
    // tos: far pointer to new password (OEM string)
    //      far pointer to old password (OEM string)
    //      far pointer to user name    (OEM string)
    //      far pointer to server name  (OEM string) <- ServerNamePointer
    //

    if (ApiNumber == API_WUserPasswordSet2) {

        WCHAR uServerName[LM20_UNCLEN + 1];
        WCHAR uUserName[LM20_UNLEN + 1];
        WCHAR uOldPassword[LM20_PWLEN + 1];
        WCHAR uNewPassword[LM20_PWLEN + 1];
        NTSTATUS ntStatus;
        DWORD length;
        LPSTR ansiStringPointer;

        ansiStringPointer = LPSTR_FROM_POINTER(ServerNamePointer);
        ntStatus = RtlOemToUnicodeN(uServerName,
                                    sizeof(uServerName) - sizeof(uServerName[0]),
                                    &length,
                                    ansiStringPointer,
                                    strlen(ansiStringPointer)
                                    );
        if (NT_SUCCESS(ntStatus)) {
            uServerName[length/sizeof(uServerName[0])] = 0;
        } else {
            status = ERROR_INVALID_PARAMETER;
            goto VrNetRemoteApi_exit;
        }

        //
        // copy, upper case and convert to UNICODE, user name
        //

        ServerNamePointer -= sizeof(LPSTR);
        ansiStringPointer = LPSTR_FROM_POINTER(ServerNamePointer);
        if (!OemToUppercaseUnicode(ansiStringPointer,
                                   uUserName,
                                   ARRAY_ELEMENTS(uUserName) - 1)) {
            status = ERROR_INVALID_PARAMETER;
            goto VrNetRemoteApi_exit;
        }

        //
        // copy, upper case and convert to UNICODE, old password
        //

        ServerNamePointer -= sizeof(LPSTR);
        ansiStringPointer = LPSTR_FROM_POINTER(ServerNamePointer);
        if (!OemToUppercaseUnicode(ansiStringPointer,
                                   uOldPassword,
                                   ARRAY_ELEMENTS(uOldPassword) - 1)) {
            status = ERROR_INVALID_PARAMETER;
            goto VrNetRemoteApi_exit;
        }

        //
        // copy, upper case and convert to UNICODE, new password
        //

        ServerNamePointer -= sizeof(LPSTR);
        ansiStringPointer = LPSTR_FROM_POINTER(ServerNamePointer);
        if (!OemToUppercaseUnicode(ansiStringPointer,
                                   uNewPassword,
                                   ARRAY_ELEMENTS(uNewPassword) - 1)) {
            status = ERROR_INVALID_PARAMETER;
            goto VrNetRemoteApi_exit;
        }

        //
        // make the call to the down-level password set function
        //

        status = RxNetUserPasswordSet((LPTSTR)uServerName,
                                      (LPTSTR)uUserName,
                                      (LPTSTR)uOldPassword,
                                      (LPTSTR)uNewPassword
                                      );
    } else {

        CHAR aPassword[ENCRYPTED_PWLEN];
        LPBYTE parameterPointer;
        LPBYTE passwordPointer = NULL;
        DWORD passwordEncrypted;
        DWORD passwordLength;

        //
        // we are going to remote the API as requested. However, if the request
        // is NetUserAdd2 or NetUserSetInfo2 then we check to see if a password
        // is being sent over the wire. We may need to encrypt the password on
        // behalf of the DOS app
        //

        if (ApiNumber == API_WUserAdd2 || ApiNumber == API_WUserSetInfo2) {

            //
            // API request is to add a user or set a user's info. The former will
            // contain a password which needs to be encrypted, the latter MAY
            // contain a password which needs to be encrypted if the request is
            // to set all the information, or just the password
            //

            DWORD level;
            DWORD parmNum = PARMNUM_ALL;
            LPBYTE dataLengthPointer;

            //
            // in the case of NetUserAdd2, the stack frame in DOS memory looks like
            // this:
            //
            // tos: original password length
            //      password encryption flag
            //      buffer length
            //      far pointer to buffer containing user_info_1 or user_info_2
            //      info level
            //      far pointer to server name  <- ServerNamePointer
            //
            // and the NetUserSetInfo2 stack looks like this:
            //
            // tos: original password length
            //      password encryption flag
            //      parameter number
            //      buffer length
            //      far pointer to user_info_1 or user_info_2 or single parameter
            //      info level
            //      far pointer to user name
            //      far pointer to server name  <- ServerNamePointer
            //

            parameterPointer = ServerNamePointer;
            if (ApiNumber == API_WUserSetInfo2) {

                //
                // for SetInfo: bump the stack parameter pointer past the user
                // name pointer
                //

                parameterPointer -= sizeof(LPSTR);
            }

            //
            // bump the stack parameter pointer to the level parameter and
            // retrieve it
            //

            parameterPointer -= sizeof(WORD);
            level = (DWORD)READ_WORD(parameterPointer);

            //
            // bump the stack parameter pointer to point to the buffer address
            //

            parameterPointer -= sizeof(LPBYTE);
            passwordPointer = parameterPointer;

            //
            // move the stack parameter pointer to the password encryption flag
            // in the case of UserAdd2 or the parmNum parameter in the case of
            // SetInfo2. If SetInfo2, retrieve the parmNum parameter and move
            // the parameterPointer to point at the password encryption flag
            //

            parameterPointer -= sizeof(WORD);
            if (ApiNumber == API_WUserSetInfo2) {
                dataLengthPointer = parameterPointer;
            }
            parameterPointer -= sizeof(WORD);
            if (ApiNumber == API_WUserSetInfo2) {
                parmNum = (DWORD)READ_WORD(parameterPointer);
                parameterPointer -= sizeof(WORD);
            }

            //
            // get the password encryption flag and cleartext password length
            // from the DOS stack frame. Leave the stack frame pointer pointing
            // at the location for the encryption flag: we'll need to replace
            // this with TRUE and restore it before we return control
            //

            passwordEncrypted = (DWORD)READ_WORD(parameterPointer);
            passwordLength = (DWORD)READ_WORD(parameterPointer - sizeof(WORD));

            //
            // if the DOS app has already encrypted the password (how'd it do that?)
            // then we'll leave the password alone. Otherwise, we need to read
            // out the cleartext password from the user_info_1 or _2 structure
            // or SetInfo buffer, encrypt it and write back the encrypted
            // password, submit the request, then replace the encrypted password
            // in DOS memory with the original cleartext password.
            //
            // Note: passwordEncrypted might be 0 because this is a SetInfo2
            // call which is NOT setting the password
            //

            if (!passwordEncrypted
            && (parmNum == PARMNUM_ALL || parmNum == USER_PASSWORD_PARMNUM)
            && (level == 1 || level == 2)) {

                LM_OWF_PASSWORD lmOwfPassword;
                LM_SESSION_KEY lanmanKey;
                ENCRYPTED_LM_OWF_PASSWORD encryptedLmOwfPassword;
                NTSTATUS ntStatus;
                WCHAR uServerName[LM20_CNLEN + 1];
                DWORD length;
                LPSTR lpServerName;

                //
                // get into passwordPointer the address of the buffer. If UserAdd2
                // or SetInfo2 with PARMNUM_ALL, this is the address of a
                // user_info_1 or _2 structure, and we need to bump the pointer
                // again to be the address of the password field within the
                // structure.
                //
                // If the request is SetInfo2 with USER_PASSWORD_PARMNUM then
                // the buffer is the address of the password to set.
                //
                // Otherwise, this is a SetInfo2 call which is not setting a
                // password, so we don't have anything left to do
                //
                // if this is a SetInfo2 call with USER_PASSWORD_PARMNUM then
                // we have a slight kludge to perform. We need to encrypt the
                // password in 16-bit memory space, but if we just copy over
                // the cleartext password then we risk blatting over whatever
                // is in memory after the password. We have reserved a 16-byte
                // buffer in REDIR.EXE at CS:AX for this very purpose
                //

                if (parmNum == USER_PASSWORD_PARMNUM) {
                    RtlCopyMemory(POINTER_FROM_WORDS(getCS(), getAX()),
                                  LPBYTE_FROM_POINTER(passwordPointer),
                                  ENCRYPTED_PWLEN
                                  );

                    //
                    // set the address of the buffer in the stack to point to
                    // the encryption buffer in REDIR.EXE
                    //

                    WRITE_WORD(passwordPointer, getAX());
                    WRITE_WORD(passwordPointer+2, getCS());
                    passwordPointer = POINTER_FROM_WORDS(getCS(), getAX());
                } else {
                    passwordPointer = LPBYTE_FROM_POINTER(passwordPointer);
                }

                //
                // BUGBUG - I have no idea (currently) if we ever get a NULL
                //          pointer, but I think it is wrong. If we do, just
                //          skip ahead and remote the function - let the
                //          server handle it
                //

                if (!passwordPointer) {
                    goto VrNetRemoteApi_do_remote;
                }

                //
                // if passwordPointer currently points at a user_info_1 or
                // user_info_2 structure, bump it to point at the password
                // field within the structure
                //

                if (parmNum == PARMNUM_ALL) {
                    passwordPointer += (DWORD)&((struct user_info_1*)0)->usri1_password[0];
                }

                //
                // if the password is NULL_USERSETINFO_PASSWD (14 spaces and
                // terminating 0) there is nothing to do
                //

                if (!strcmp(passwordPointer, NULL_USERSETINFO_PASSWD)) {
                    passwordPointer = NULL;
                    goto VrNetRemoteApi_do_remote;
                }

                //
                // okay, let's do some encryption (exciting isn't it?)
                //

                RtlCopyMemory(aPassword,
                              passwordPointer,
                              sizeof(((struct user_info_1*)0)->usri1_password)
                              );

                //
                // BUGBUG, this isn't necessarily the correct upper-case function
                //

                _strupr(aPassword);

                //
                // convert the ANSI server name to UNICODE for GetLanmanSessionKey
                //

                lpServerName = LPSTR_FROM_POINTER(ServerNamePointer);
                ntStatus = RtlOemToUnicodeN(uServerName,
                                            sizeof(uServerName) - sizeof(uServerName[0]),
                                            &length,
                                            lpServerName,
                                            strlen(lpServerName)
                                            );
                if (NT_SUCCESS(ntStatus)) {
                    uServerName[length/sizeof(uServerName[0])] = 0;
                } else {
                    status = ERROR_INVALID_PARAMETER;
                    goto VrNetRemoteApi_exit;
                }

                ntStatus = RtlCalculateLmOwfPassword(aPassword, &lmOwfPassword);
                if (NT_SUCCESS(ntStatus)) {
                    ntStatus = GetLanmanSessionKey((LPWSTR)uServerName, (LPBYTE)&lanmanKey);
                    if (NT_SUCCESS(ntStatus)) {
                        ntStatus = RtlEncryptLmOwfPwdWithLmSesKey(&lmOwfPassword,
                                                                  &lanmanKey,
                                                                  &encryptedLmOwfPassword
                                                                  );
                        if (NT_SUCCESS(ntStatus)) {
                            RtlCopyMemory(passwordPointer,
                                          &encryptedLmOwfPassword,
                                          sizeof(encryptedLmOwfPassword)
                                          );

                            //
                            // fake it
                            //

                            WRITE_WORD(parameterPointer, 1);

                            //
                            // if this is SetInfo2 with USER_PASSWORD_PARMNUM
                            // then we don't need to copy back the cleartext
                            // password because we have not modified the
                            // original buffer in the app's space
                            //
                            // We also have to change the size of data being
                            // passed in to the size of the encrypted password
                            //

                            if (parmNum == USER_PASSWORD_PARMNUM) {
                                WRITE_WORD(dataLengthPointer, ENCRYPTED_PWLEN);
                                passwordPointer = NULL;
                            }
                        }
                    }
                }

                //
                // if we fell by the wayside, quit out
                //

                if (!NT_SUCCESS(ntStatus)) {
                    status = RtlNtStatusToDosError(ntStatus);
                    goto VrNetRemoteApi_exit;
                }
            } else {

                //
                // we are not encrypting the password - set the pointer back
                // to NULL. Used as a flag after call to VrRemoteApi
                //

                passwordPointer = NULL;
            }
        }

        //
        // build a transaction request from the caller's parameters
        //

VrNetRemoteApi_do_remote:

        status = VrRemoteApi(ApiNumber,
                             ServerNamePointer,
                             ParameterDescriptor,
                             DataDescriptor,
                             AuxDescriptor,
                             NullSessionFlag
                             );

        //
        // if we replaced a cleartext password with an encrypted password in
        // DOS memory, then undo the change before giving control back to DOS
        //

        if (passwordPointer) {
            RtlCopyMemory(passwordPointer,
                          aPassword,
                          sizeof(((struct user_info_1*)0)->usri1_password)
                          );
            WRITE_WORD(parameterPointer, 0);
        }
    }

VrNetRemoteApi_exit:

    if (status != NERR_Success) {
        SET_ERROR((WORD)status);

#if DBG
        IF_DEBUG(NETAPI) {
            DbgPrint("Error: VrNetRemoteApi returning %u\n", (DWORD)getAX());
        }
#endif

    } else {
        setCF(0);
    }
}


BOOL
OemToUppercaseUnicode(
    IN LPSTR AnsiStringPointer,
    OUT LPWSTR UnicodeStringPointer,
    IN DWORD MaxLength
    )

/*++

Routine Description:

    given a string in OEM character set, upper cases it then converts it to
    UNICODE

Arguments:

    AnsiStringPointer       - pointer to 8-bit string to convert
    UnicodeStringPointer    - pointer to resultant 16-bit (UNICODE) string
    MaxLength               - maximum output buffer length in # of characters,
                              NOT including terminating NUL

Return Value:

    BOOL
        TRUE    - string converted
        FALSE   - failed for some reason (string too long, Rtl function failed)

--*/

{
    DWORD stringLength;
    char scratchpad[UNLEN + 1]; // UNLEN is the largest type of string we'll get
    NTSTATUS ntStatus;
    DWORD length;

    stringLength = strlen(AnsiStringPointer);
    if (stringLength > MaxLength) {
        return FALSE;
    }
    strcpy(scratchpad, AnsiStringPointer);

    //
    // BUGBUG - this is not necessarily the correct upper-case function
    //

    _strupr(scratchpad);
    ntStatus = RtlOemToUnicodeN(UnicodeStringPointer,
                                MaxLength * sizeof(*UnicodeStringPointer),
                                &length,
                                scratchpad,
                                stringLength
                                );
    if (NT_SUCCESS(ntStatus)) {
        UnicodeStringPointer[length/sizeof(*UnicodeStringPointer)] = 0;
        return TRUE;
    } else {
        return FALSE;
    }
}


VOID
VrNetServerEnum(
    VOID
    )

/*++

Routine Description:

    Handles NetServerEnum and NetServerEnum2

Arguments:

    NetServerEnum

    ENTRY   AL = 4Ch
            BL = level (0 or 1)
            CX = size of buffer
            ES:DI = buffer

    EXIT    CF = 1
                AX = Error code:
                    NERR_BufTooSmall
                    ERROR_MORE_DATA

            CF = 0
                BX = entries read
                CX = total available


    NetServerEnum2

    ENTRY   AL = 53h
            DS:SI = NetServerEnum2Struct:
                DW  Level
                DD  Buffer
                DW  Buflen
                DD  Type
                DD  Domain

    EXIT    CF = 1
                AX = Error code:
                    NERR_BufTooSmall
                    ERROR_MORE_DATA

            CF = 0
                BX = entries read
                CX = total available

Return Value:

    None.

--*/

{
    BYTE callType = getAL();

    struct NetServerEnum2Struct* structPtr;
    LPBYTE buffer;
    WORD bufferSegment;
    WORD bufferOffset;
    LPDESC descriptor;
    WORD level;
    WORD buflen;
    DWORD serverType;
    LPSTR domain;

    XS_NET_SERVER_ENUM_2 parameters;
    XS_PARAMETER_HEADER header;
    NTSTATUS ntstatus;
    NET_API_STATUS status;

//    LPBYTE enumPtr;
//    DWORD nRead;
//    DWORD nAvail;

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrNetServerEnum: type=0x%02x\n", callType);
        IF_DEBUG(BREAKPOINT) {
            DbgBreakPoint();
        }
    }
#endif

    if (callType == 0x4c) {

        //
        // call is NetServerEnum
        //

        bufferSegment = getES();
        bufferOffset = getDI();
        buffer = LPBYTE_FROM_WORDS(bufferSegment, bufferOffset);
        buflen = (WORD)getCX();
        level = (WORD)getBL();
        serverType = SV_TYPE_ALL;
        domain = NULL;
    } else {

        //
        // call is NetServerEnum2
        //

        structPtr = (struct NetServerEnum2Struct*)POINTER_FROM_WORDS(getDS(), getSI());
        bufferSegment = GET_SEGMENT(&structPtr->NSE_buf);
        bufferOffset = GET_OFFSET(&structPtr->NSE_buf);
        buffer = POINTER_FROM_WORDS(bufferSegment, bufferOffset);
        buflen = READ_WORD(&structPtr->NSE_buflen);
        level = READ_WORD(&structPtr->NSE_level);
        serverType = READ_DWORD(&structPtr->NSE_type);
        domain = LPSTR_FROM_POINTER(&structPtr->NSE_domain);
    }

    //
    // set the returned EntriesRead (BX) and TotalAvail (CX) to zero here for
    // the benefit of the 16-bit Windows NETAPI.DLL!NetServerEnum2
    // This function tries to unpack BX entries from the enum buffer as
    // soon as control is returned after the call to the redir via DoIntx. BUT
    // IT DOESN'T LOOK AT THE RETURN CODE FIRST. As Sam Kinnison used to say
    // AAAAAAAAAAAAAAARRRRRGH AAAAAAARGHH AAAAAAARGHHHHHHH!!!!!!!
    //

    setBX(0);
    setCX(0);

    //
    // first, check level - both types only handle 0 or 1
    //

    switch (level) {
    case 0:
        descriptor = REM16_server_info_0;
        break;

    case 1:
        descriptor = REM16_server_info_1;
        break;

    //
    // levels 2 & 3 not used in enum
    //

    default:

#if DBG
        IF_DEBUG(NETAPI) {
            DbgPrint("VrNetServerEnum - invalid level %d. Returning early\n", level);
        }
#endif

        SET_ERROR(ERROR_INVALID_LEVEL);
        return;
    }

    parameters.Level = level;
    parameters.Buffer = buffer;
    parameters.BufLen = buflen;
    parameters.ServerType = serverType;
    parameters.Domain = domain;

#if DBG

    IF_DEBUG(NETAPI) {
        DbgPrint("buffer @%04x:%04x, length=%d, level=%d, type=0x%08x, domain=%s\n",
                bufferSegment, bufferOffset, parameters.BufLen, level,
                parameters.ServerType, parameters.Domain
                );
    }

#endif

//    //
//    // I_BrowserServerEnum which XsNetServerEnum2 calls requires a transport
//    // name. If we don't give it one, it'll return ERROR_INVALID_PARAMETER
//    //
//
//    status = NetWkstaTransportEnum(NULL,
//                                   0,
//                                   &enumPtr,
//                                   -1L,         // we'll take everything
//                                   &nRead,      // number returned
//                                   &nAvail,     // total available
//                                   NULL         // no resume handle
//                                   );
//    if (status != NERR_Success) {
//
//#if DBG
//        IF_DEBUG(NETAPI) {
//            DbgPrint("VrNetServerEnum: Error: NetWkstaTransportEnum returns %d\n", status);
//        }
//#endif
//
//        SET_ERROR(status);
//        return;
//    }

    header.Status = 0;
    header.ClientMachineName = NULL;

    //
    // use the first enumerated transport name
    //

//    header.ClientTransportName = ((LPWKSTA_TRANSPORT_INFO_0)enumPtr)->wkti0_transport_name;
    header.ClientTransportName = NULL;

    ntstatus = XsNetServerEnum2(&header, &parameters, descriptor, NULL);
    if (!NT_SUCCESS(ntstatus)) {
        status = NetpNtStatusToApiStatus(ntstatus);
    } else {
        status = (NET_API_STATUS)header.Status;
    }
    if (status == NERR_Success) {
        SET_SUCCESS();
    } else {
        SET_ERROR((WORD)status);
    }
    if (status == NERR_Success || status == ERROR_MORE_DATA) {
        if (parameters.EntriesRead) {
            VrpConvertReceiveBuffer(buffer,
                                    bufferSegment,
                                    bufferOffset,
                                    header.Converter,
                                    parameters.EntriesRead,
                                    descriptor,
                                    NULL
                                    );
        }
        setBX(parameters.EntriesRead);
        setCX(parameters.TotalAvail);
    }

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrNetServerEnum: returning %d for NetServerEnum2\n", getAX());
        if (getAX() == NERR_Success || getAX() == ERROR_MORE_DATA) {
            DbgPrint("EntriesRead=%d, TotalAvail=%d\n",
                        parameters.EntriesRead,
                        parameters.TotalAvail
                        );
        }
    }
#endif

//    //
//    // free up the buffer returned by NetWkstaTransportEnum
//    //
//
//    NetApiBufferFree(enumPtr);
}


VOID
VrNetServiceControl(
    VOID
    )

/*++

Routine Description:

    We allow the interrogate function for specific services. The other functions
    are pause, continue and stop (uninstall) which we disallow

Arguments:

    Function 5F42

    DL = opcode:
        0 = interrogate SUPPORTED
        1 = pause service * NOT SUPPORTED *
        2 = continue service * NOT SUPPORTED *
        3 = uninstall service * NOT SUPPORTED *
        4 - 127 = reserved
        127 - 255 = OEM defined
    DH = OEM defined argument
    ES:BX = NetServiceControl structure:
        char far* service name
        unsigned short buffer length
        char far* buffer

Return Value:

    None.

--*/

{
    BYTE opcode = getDL();
    BYTE oemArg = getDH();
    struct NetServiceControlStruc* structPtr = (struct NetServiceControlStruc*)
                                                POINTER_FROM_WORDS(getES(), getBX());

    LPSTR serviceName = READ_FAR_POINTER(&structPtr->NSCS_Service);
    WORD buflen = READ_WORD(&structPtr->NSCS_BufLen);
    LPSTR buffer = READ_FAR_POINTER(&structPtr->NSCS_BufferAddr);
    WORD seg = GET_SEGMENT(&structPtr->NSCS_BufferAddr);
    WORD off = GET_OFFSET(&structPtr->NSCS_BufferAddr);

    XS_NET_SERVICE_CONTROL parameters;
    XS_PARAMETER_HEADER header;
    NTSTATUS ntstatus;
    NET_API_STATUS status;

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrNetServiceControl: Service=%s, Opcode=%d, OemArg=%d, Buffer @%04x:%04x, len=%d\n",
                serviceName,
                opcode,
                oemArg,
                seg,
                off,
                buflen
                );
    }
#endif

    if (opcode > 4) {
        SET_ERROR(NERR_ServiceCtlNotValid);
        return;
    }

    //
    // we are disallowing anything other than 0 (interrogate) by returning
    // ERROR_INVALID_PARAMETER, which may be a new error code
    //

    if (opcode) {
        SET_ERROR(ERROR_INVALID_PARAMETER);
        return;
    }

    //
    // KLUDGE - if the service name is NETPOPUP then we return NERR_ServiceNotInstalled.
    // LANMAN.DRV checks to see if this service is loaded. If it is then
    // it sticks Load=WinPopUp in WIN.INI. We don't want it to do this
    //

    if (!_stricmp(serviceName, NETPOPUP_SERVICE)) {

        //
        // roll our own service_info_2 structure
        //

        if (buflen >= sizeof(struct service_info_2)) {
            SET_ERROR(NERR_ServiceNotInstalled);
        } else {
            SET_ERROR(NERR_BufTooSmall);
        }
        return;
    }

    //
    // leave the work to XsNetServiceControl
    //

    parameters.Service = serviceName;
    parameters.OpCode = opcode;
    parameters.Arg = oemArg;
    parameters.Buffer = buffer;
    parameters.BufLen = buflen;

    header.Status = 0;
    header.ClientMachineName = NULL;
    header.ClientTransportName = NULL;

    ntstatus = XsNetServiceControl(&header, &parameters, REM16_service_info_2, NULL);
    if (!NT_SUCCESS(ntstatus)) {
        status = NetpNtStatusToApiStatus(ntstatus);
    } else {
        status = (NET_API_STATUS)header.Status;
    }

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrNetServiceControl: returning %d\n", status);
    }
#endif

    if (status == NERR_Success || status == ERROR_MORE_DATA) {

        //
        // there are no pointers in a service_info_2 structure, so there is
        // no need to call VrpConvertReceiveBuffer. Also, we are not going to
        // allow the DOS process to pause, continue, start or stop any of our
        // 32-bit services, so we must tell the DOS app that the service
        // cannot accept these controls: zero out bit 4
        // (SERVICE_NOT_UNINSTALLABLE) and bit 5 (SERVICE_NOT_PAUSABLE)
        //

        ((struct service_info_2*)buffer)->svci2_status &= 0xff0f;
        SET_OK((WORD)status);
    } else {
        SET_ERROR((WORD)status);
    }
}

VOID
VrNetServiceEnum(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    SET_ERROR(ERROR_NOT_SUPPORTED);
}


VOID
VrNetTransactApi(
    VOID
    )

/*++

Routine Description:

    Performs a transaction on behalf of the Vdm

Arguments:

    None. All arguments are extracted from the Vdm context registers/memory

Return Value:

    None. Results returned via VDM registers or in VDM memory, according to
    request

--*/

{
    DWORD   status;

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrNetTransactApi\n");
        IF_DEBUG(BREAKPOINT) {
            DbgBreakPoint();
        }
    }
#endif

    status = VrpTransactVdm(FALSE);
    if (status) {
        SET_ERROR((WORD)status);
    } else {
        setCF(0);
    }
}


VOID
VrNetUseAdd(
    VOID
    )

/*++

Routine Description:

    Performs local NetUseAdd on behalf of the Vdm client

Arguments:

    Function 5F47h
    ENTRY   BX = level
            CX = buffer length
            DS:SI = server name for remote call (MBZ)
            ES:DI = buffer containing use_info_1 structure

Return Value:

    None.

--*/

{
    NET_API_STATUS status;
    XS_NET_USE_ADD parameters;
    XS_PARAMETER_HEADER header;
    NTSTATUS ntstatus;
    LPSTR   computerName;
    LPBYTE  buffer;
    WORD    level;
    BOOL    allocated;
    DWORD   buflen;
    DWORD   auxOffset;
    char    myDescriptor[sizeof(REM16_use_info_1)];
    char    myDataBuffer[sizeof(struct use_info_1) + LM20_PWLEN + 1];

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrNetUseAdd\n");
        IF_DEBUG(BREAKPOINT) {
            DbgBreakPoint();
        }
    }
#endif

    //
    // ensure the computer name designates the local machine (NULL)
    //

    computerName = LPSTR_FROM_WORDS(getDS(), getSI());

    level = (WORD)getBX();
    if (level != 1) {

        //
        // level must be 1 for an add
        //

        SET_ERROR(ERROR_INVALID_LEVEL);
        return;
    }

    //
    // preset the modifiable descriptor string
    //

    strcpy(myDescriptor, REM16_use_info_1);

    //
    // pack the use_info_1 buffer as if we were getting ready to ship it over
    // the net. Return errors
    //

    buffer = LPBYTE_FROM_WORDS(getES(), getDI());
    buflen = (DWORD)getCX();

    //
    // copy the DOS buffer to 32-bit memory. Do this to avoid irritating problem
    // of getting an already packed buffer from the client, and not being able
    // to do anything with it
    //

    RtlCopyMemory(myDataBuffer, buffer, sizeof(struct use_info_1));
    buffer = myDataBuffer;
    buflen = sizeof(myDataBuffer);
    status = VrpPackSendBuffer(&buffer,
                &buflen,
                &allocated,
                myDescriptor,   // modifiable descriptor
                NULL,           // AuxDescriptor
                VrpGetStructureSize(REM16_use_info_1, &auxOffset),
                (DWORD)-1,      // AuxOffset (-1 means there is no aux char 'N')
                0,              // AuxSize
                FALSE,          // not a SetInfo call
                TRUE            // OkToModifyDescriptor
                );
    if (status) {
        SET_ERROR(VrpMapDosError(status));
        return;
    }

    parameters.Level = level;
    parameters.Buffer = buffer;
    parameters.BufLen = (WORD)buflen;

    header.Status = 0;
    header.ClientMachineName = NULL;
    header.ClientTransportName = NULL;

    ntstatus = XsNetUseAdd(&header, &parameters, myDescriptor, NULL);
    if (ntstatus != STATUS_SUCCESS) {
        status = NetpNtStatusToApiStatus(ntstatus);
    } else {

        //
        // no error generated in XsNetUseAdd. Get the status of the NetUseAdd
        // proper from the header
        //

        status = (NET_API_STATUS)header.Status;
    }
    if (status != NERR_Success) {
#if DBG
        IF_DEBUG(NETAPI) {
            DbgPrint("Error: VrNetUseAdd: XsNetUseAdd returns %u\n", status);
        }
#endif
        SET_ERROR((WORD)status);
    } else {
        setCF(0);
    }

    //
    // if VrpPackSendBuffer allocated a new buffer then free it
    //

    if (allocated) {
        LocalFree(buffer);
    }
}


VOID
VrNetUseDel(
    VOID
    )

/*++

Routine Description:

    Performs local NetUseDel on behalf of the Vdm client

Arguments:

    Function 5F48h

    ENTRY   BX = force flag
            DS:SI = server name for remote call (MBZ)
            ES:DI = use name

Return Value:

    None.

--*/

{
    NTSTATUS    ntstatus;
    NET_API_STATUS  status;
    WORD    force;
    LPSTR   name;
    XS_NET_USE_DEL  parameters;
    XS_PARAMETER_HEADER header;

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrNetUseDel\n");
        IF_DEBUG(BREAKPOINT) {
            DbgBreakPoint();
        }
    }
#endif

    force = (WORD)getBX();
    if (force > USE_LOTS_OF_FORCE) {
        SET_ERROR(ERROR_INVALID_PARAMETER);
        return;
    }

    name = LPSTR_FROM_WORDS(getDS(), getSI());

    //
    // make sure name is local
    //

    name = LPSTR_FROM_WORDS(getES(), getDI());

    parameters.UseName = name;
    parameters.Force = force;

    header.Status = 0;
    header.ClientMachineName = NULL;
    header.ClientTransportName = NULL;

    ntstatus = XsNetUseDel(&header, &parameters, NULL, NULL);

    //
    // if XsNetUseDel failed then map the NT error returned into a Net error
    // else get the result of the NetUseDel proper from the header structure
    //

    if (ntstatus != STATUS_SUCCESS) {
        status = NetpNtStatusToApiStatus(ntstatus);
    } else {
        status = (NET_API_STATUS)header.Status;
    }
    if (status != NERR_Success) {
        SET_ERROR(VrpMapDosError(status));
    } else {
        setCF(0);
    }
}


VOID
VrNetUseEnum(
    VOID
    )

/*++

Routine Description:

    Performs local NetUseEnum on behalf of the Vdm client

Arguments:

    Function 5F46h

    ENTRY   BX = level of info required - 0 or 1
            CX = buffer length
            ES:DI = buffer for enum info

Return Value:

    None.

--*/

{
    NTSTATUS    ntstatus;
    NET_API_STATUS status;
    WORD    level = getBX();
    XS_NET_USE_ENUM parameters;
    XS_PARAMETER_HEADER header;
    LPDESC  dataDesc;
    LPBYTE  receiveBuffer;

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrNetUseEnum\n");
        IF_DEBUG(BREAKPOINT) {
            DbgBreakPoint();
        }
    }
#endif

    if (level <= 1) {
        dataDesc = (level == 1) ? REM16_use_info_1 : REM16_use_info_0;
        parameters.Level  = level;
        receiveBuffer = POINTER_FROM_WORDS(getES(), getDI());
        parameters.Buffer = receiveBuffer;
        parameters.BufLen = getCX();

        header.Status = 0;
        header.ClientMachineName = NULL;
        header.ClientTransportName = NULL;

        ntstatus = XsNetUseEnum(&header, &parameters, dataDesc, NULL);

        //
        // if XsNetUseEnum didn't have any problems, convert the actual status
        // code to that returned in the header
        //

        if (ntstatus != STATUS_SUCCESS) {
            status = NetpNtStatusToApiStatus(ntstatus);
        } else {
            status = (DWORD)header.Status;
        }
    } else {
        status = ERROR_INVALID_LEVEL;
    }

    //
    // NetUseEnum sets these even in the event of failure. We do the same
    //

    setCX(parameters.EntriesRead);
    setDX(parameters.TotalAvail);

    //
    // if we're returning data, convert the pointer offsets to something
    // meaningful
    //

    if (((status == NERR_Success) || (status == ERROR_MORE_DATA))
        && parameters.EntriesRead) {
        VrpConvertReceiveBuffer(receiveBuffer,
            (WORD)getES(),
            (WORD)getDI(),
            (WORD)header.Converter,
            parameters.EntriesRead,
            dataDesc,
            NULL
            );
    }

    //
    // only return carry clear if no error occurred. Even if ERROR_MORE_DATA
    // set CF
    //

    if (status) {
        SET_ERROR(VrpMapDosError(status));
    } else {
        setCF(0);
    }
}


VOID
VrNetUseGetInfo(
    VOID
    )

/*++

Routine Description:

    Performs local NetUseGetInfo on behalf of the Vdm client

Arguments:

    Function 5F49h

    ENTRY   DS:DX = NetUseGetInfoStruc:
                const char FAR* NUGI_usename;
                short           NUGI_level;
                char FAR*       NUGI_buffer;
                unsigned short  NUGI_buflen;

Return Value:

    None.

--*/

{
    NTSTATUS    ntstatus;
    NET_API_STATUS status;
    XS_NET_USE_GET_INFO parameters;
    XS_PARAMETER_HEADER header;
    struct NetUseGetInfoStruc* structurePointer;
    WORD    level;
    LPDESC  dataDesc;
    LPBYTE  receiveBuffer;

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrNetUseGetInfo\n");
        IF_DEBUG(BREAKPOINT) {
            DbgBreakPoint();
        }
    }
#endif

    //
    // pull info out of Vdm context
    //

    structurePointer = (struct NetUseGetInfoStruc*)
                            POINTER_FROM_WORDS(getDS(), getDX());
    level = structurePointer->NUGI_level;

    //
    // level can be 0 or 1
    //

    if (level <= 1) {
        dataDesc = (level == 1) ? REM16_use_info_1 : REM16_use_info_0;

#if DBG
        IF_DEBUG(NETAPI) {
            DbgPrint("VrNetUseGetInfo: dataDesc=%s\n", dataDesc);
        }
#endif

        parameters.UseName= POINTER_FROM_POINTER(&(structurePointer->NUGI_usename));

#if DBG
        IF_DEBUG(NETAPI) {
            DbgPrint("VrNetUseGetInfo: UseName=%s\n", parameters.UseName);
        }
#endif

        parameters.Level  = level;

#if DBG
        IF_DEBUG(NETAPI) {
            DbgPrint("VrNetUseGetInfo: level=%d\n", level);
        }
#endif

        receiveBuffer = POINTER_FROM_POINTER(&(structurePointer->NUGI_buffer));

#if DBG
        IF_DEBUG(NETAPI) {
            DbgPrint("VrNetUseGetInfo: receiveBuffer=%x\n", receiveBuffer);
        }
#endif

        parameters.Buffer = receiveBuffer;
        parameters.BufLen = READ_WORD(&structurePointer->NUGI_buflen);

#if DBG
        IF_DEBUG(NETAPI) {
            DbgPrint("VrNetUseGetInfo: BufLen=%d\n", parameters.BufLen);
        }
#endif

        header.Status = 0;
        header.ClientMachineName = NULL;
        header.ClientTransportName = NULL;

        ntstatus = XsNetUseGetInfo(&header, &parameters, dataDesc, NULL);
        if (ntstatus != STATUS_SUCCESS) {
            status = NetpNtStatusToApiStatus(ntstatus);
        } else {
            status = header.Status;
        }
    } else {
        status = ERROR_INVALID_LEVEL;
    }

    if ((status == NERR_Success)
        || (status == ERROR_MORE_DATA)
        || (status == NERR_BufTooSmall)
        ) {
        setDX(parameters.TotalAvail);

#if DBG
        IF_DEBUG(NETAPI) {
            DbgPrint("VrNetUseGetInfo: TotalAvail=%d\n", parameters.TotalAvail);
        }
#endif

        if ((status == NERR_Success) || (status == ERROR_MORE_DATA)) {
            VrpConvertReceiveBuffer(
                receiveBuffer,
                GET_SELECTOR(&(structurePointer->NUGI_buffer)),
                GET_OFFSET(&(structurePointer->NUGI_buffer)),
                (WORD)header.Converter,
                1,
                dataDesc,
                NULL
                );
        }
    } else {

        //
        // the first thing NetUseGetInfo does is set the returned total available
        // count to 0. Lets be compatible!
        //

        setDX(0);

    }
    if (status) {
        SET_ERROR(VrpMapDosError(status));
    } else {
        setCF(0);
    }
}


VOID
VrNetWkstaGetInfo(
    VOID
    )

/*++

Routine Description:

    Performs local NetWkstaGetInfo on behalf of the Vdm client

Arguments:

    Function 5F44h

    ENTRY   BX = level (0, 1 or 10)
            CX = size of caller's buffer
            DS:SI = computer name for remote call (IGNORED)
            ES:DI = caller's buffer

Return Value:

    CF = 0
        DX = size of buffer required to honour request

    CF = 1
        AX = error code

--*/

{
    DWORD   level;
    DWORD   bufLen;
    LPBYTE  buffer;
    LPDESC  dataDesc;
    NET_API_STATUS status;
    NTSTATUS ntStatus;
    XS_PARAMETER_HEADER header;
    XS_NET_WKSTA_GET_INFO parameters;
    WORD    bufferSegment;
    WORD    bufferOffset;
    INT     bufferLeft;
    DWORD   totalAvail;

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("\nVrNetWkstaGetInfo\n");
        IF_DEBUG(BREAKPOINT) {
            DbgBreakPoint();
        }
    }
#endif

    level = (DWORD)getBX();
    switch (level) {
    case 0:
        dataDesc = REMSmb_wksta_info_0;
        break;

    case 1:
        dataDesc = REMSmb_wksta_info_1;
        break;

    case 10:
        dataDesc = REMSmb_wksta_info_10;
        break;

    default:
        SET_ERROR(ERROR_INVALID_LEVEL);

#if DBG
        IF_DEBUG(NETAPI) {
            DbgPrint("VrNetWkstaGetInfo: Error: returning %d for level %d\n",
                     getAX(),
                     level
                     );
        }
#endif

        return;
    }

    bufLen = (DWORD)getCX();
    bufferSegment = getES();
    bufferOffset = getDI();
    buffer = LPBYTE_FROM_WORDS(bufferSegment, bufferOffset);

    if (bufLen && !buffer) {
        SET_ERROR(ERROR_INVALID_PARAMETER);

#if DBG
        IF_DEBUG(NETAPI) {
            DbgPrint("VrNetWkstaGetInfo: Error: buffer=NULL, buflen=%d\n", bufLen);
        }
#endif

        return;
    }

    //
    // clear out the caller's buffer - just in case XsNetWkstaGetInfo forgets
    // to fill in some fields
    //

    if (bufLen) {
        RtlZeroMemory(buffer, bufLen);
    }

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrNetWkstaGetInfo: level=%d, bufLen = %d (0x%x), buffer = %x:%x\n",
            level, bufLen, bufLen, bufferSegment, bufferOffset
            );
    }
#endif

    parameters.Level = (WORD)level;
    parameters.Buffer = buffer;
    parameters.BufLen = (WORD)bufLen;

    header.Status = 0;
    header.Converter = 0;
    header.ClientMachineName = NULL;
    header.ClientTransportName = NULL;
    header.EncryptionKey = NULL;

    ntStatus = XsNetWkstaGetInfo(&header, &parameters, dataDesc, NULL);
    if (!NT_SUCCESS(ntStatus)) {
        status = NetpNtStatusToApiStatus(ntStatus);
    } else {
        status = (NET_API_STATUS)header.Status;
    }
    if (status != NERR_Success) {
        SET_ERROR((WORD)status);
    } else {
        setCF(0);
        setAX((WORD)status);
    }

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrNetWkstaGetInfo: status after XsNetWkstaGetInfo=%d, TotalAvail=%d\n",
                 status,
                 parameters.TotalAvail
                 );
//        DumpWkstaInfo(level, buffer);
    }
#endif

    //
    // This next bit of code will add the per-user information only if there
    // is space to add all of it - XsNetWkstaGetInfo returns either all the
    // variable data, or none of it. This is incorrect, but we'll play along.
    //
    // Assumes that the variable data is packed into the buffer starting at
    // the end of the fixed structure + 1
    //
    // Irrespective of whether data is returned, we have to update the
    // TotalAvail parameter to reflect the adjusted amount of data
    //

    totalAvail = parameters.TotalAvail;
    bufferLeft = (INT)(bufLen - totalAvail);

    if ((status == NERR_Success)
    || (status == ERROR_MORE_DATA)
    || (status == NERR_BufTooSmall)) {

        //
        // because of NT's ability to instantaneously support more than one
        // user, XsNetWkstaGetInfo no longer returns information pertinent to
        // the current user. Thus, we have to furnish the information from
        // this user's context:
        //
        //              field\level     0  1  10
        //              ------------------------
        //              user name       x  x  x
        //              logon server    x  x
        //              logon domain       x  x
        //              other domains      x  x
        //
        // all this info is returned from NetWkstaUserGetInfo, level 1
        //

        LPBYTE info;
        NET_API_STATUS net_status;
        char username[LM20_UNLEN + 1];
        char logonServer[LM20_UNCLEN + 1];
        char logonDomain[LM20_DNLEN + 1];
        char otherDomains[512]; // arbitrary
        DWORD len;
        LPWSTR UNALIGNED str;
        //BOOL nullPointer;
        BOOL addSlashes;

//// TEST_DATA
//        static INT testindex = 0;
//        static WCHAR* testnames[] = {
//            NULL,
//            NULL,
//            L"",
//            L"",
//            L"A",
//            L"A",
//            L"AB",
//            L"AB",
//            L"ABC",
//            L"ABC",
//            L"ABCDEFGHIJKLMNO",
//            L"ABCDEFGHIJKLMNO",
//            L"\\\\",
//            L"\\\\",
//            L"\\\\A",
//            L"\\\\A",
//            L"\\\\AB",
//            L"\\\\AB",
//            L"\\\\ABC",
//            L"\\\\ABC",
//            L"\\\\ABCDEFGHIJKLMNO",
//            L"\\\\ABCDEFGHIJKLMNO"
//            };
//// TEST_DATA

        //
        // first off, modify the pointers for any data returned by
        // XsNetWkstaGetInfo
        //

        if (status == NERR_Success) {

//#if DBG
//            IF_DEBUG(NETAPI) {
//                DbgPrint("VrNetWkstaGetInfo: calling VrpConvertReceiveBuffer: Converter=%04x\n",
//                            header.Converter
//                            );
//            }
//#endif

            VrpConvertReceiveBuffer(
                buffer,
                bufferSegment,
                bufferOffset,
                (WORD)header.Converter,
                1,
                dataDesc,
                NULL
                );
        }

        //
        // get the per-user information
        //

        net_status = NetWkstaUserGetInfo(NULL, 1, &info);
        if (net_status == NERR_Success) {

//#if DBG
//            IF_DEBUG(NETAPI) {
//                DbgPrint("NetWkstaUserGetInfo:\n"
//                         "user name     %ws\n"
//                         "logon domain  %ws\n"
//                         "other domains %ws\n"
//                         "logon server  %ws\n"
//                         "\n",
//                         ((PWKSTA_USER_INFO_1)info)->wkui1_username,
//                         ((PWKSTA_USER_INFO_1)info)->wkui1_logon_domain,
//                         ((PWKSTA_USER_INFO_1)info)->wkui1_oth_domains,
//                         ((PWKSTA_USER_INFO_1)info)->wkui1_logon_server
//                         );
//            }
//#endif

            //
            // username for all levels
            //

            str = (LPWSTR)((PWKSTA_USER_INFO_1)info)->wkui1_username;
            if (!str) {
                str = L"";
            }
            //nullPointer = ((level == 10)
            //                ? ((struct wksta_info_10*)buffer)->wki10_username
            //                : ((struct wksta_info_0*)buffer)->wki0_username
            //                ) == NULL;
            //len = wcslen(str) + nullPointer ? 1 : 0;
#ifdef DBCS /*fix for DBCS char sets*/
            len = (DWORD)NetpUnicodeToDBCSLen(str) + 1;
#else // !DBCS
            len = wcslen(str) + 1;
#endif // !DBCS
            bufferLeft -= len;
            totalAvail += len;

            if (len <= sizeof(username)) {
#ifdef DBCS /*fix for DBCS char sets*/
                NetpCopyWStrToStrDBCS(username, str);
#else // !DBCS
                NetpCopyWStrToStr(username, str);
#endif // !DBCS
            } else {
                username[0] = 0;
            }

            //
            // logon_server for levels 0 & 1
            //

            if (level <= 1) {
                str = (LPWSTR)((PWKSTA_USER_INFO_1)info)->wkui1_logon_server;

//// TEST_CODE
//                if (testindex < sizeof(testnames)/sizeof(testnames[0])) {
//                    str = testnames[testindex++];
//                }
//// TEST_CODE

                if (!str) {
                    str = L"";
                }
#ifdef DBCS /*fix for DBCS char sets*/
                len = (DWORD)NetpUnicodeToDBCSLen(str) + 1;
#else // !DBCS
                len = wcslen(str) + 1;
#endif // !DBCS

                //
                // DOS returns "\\logon_server" whereas NT returns "logon_server".
                // We need to account for the extra backslashes (but only if not
                // NULL string)
                // At this time, len includes +1 for terminating \0, so even a
                // NULL string has length 1
                //

                addSlashes = TRUE;
                if (len >= 3 && IS_PATH_SEPARATOR(str[0]) && IS_PATH_SEPARATOR(str[1])) {
                    addSlashes = FALSE;
                } else if (len == 1) {  // NULL string
                    addSlashes = FALSE;
                }
                if (addSlashes) {
                    len += 2;
                }

                bufferLeft -= len;
                totalAvail += len;

                if (len <= sizeof(logonServer)) {

                    INT offset = 0;

                    if (addSlashes) {
                        logonServer[0] = logonServer[1] = '\\';
                        offset = 2;
                    }
#ifdef DBCS /*fix for DBCS char sets*/
                    NetpCopyWStrToStrDBCS(&logonServer[offset], str);
#else // !DBCS
                    NetpCopyWStrToStr(&logonServer[offset], str);
#endif // !DBCS
                } else {
                    logonServer[0] = 0;
                }
            }

            //
            // logon_domain and oth_domains for levels 1 & 10
            //

            if (level >= 1) {
                str = (LPWSTR)((PWKSTA_USER_INFO_1)info)->wkui1_logon_domain;
                if (!str) {
                    str = L"";
                }
#ifdef DBCS /*fix for DBCS char sets*/
                len = (DWORD)NetpUnicodeToDBCSLen(str) + 1;
#else // !DBCS
                len = wcslen(str) + 1;
#endif // !DBCS
                bufferLeft -= len;
                totalAvail += len;

                if (len <= sizeof(logonDomain)) {
#ifdef DBCS /*fix for DBCS char sets*/
                    NetpCopyWStrToStrDBCS(logonDomain, str);
#else // !DBCS
                    NetpCopyWStrToStr(logonDomain, str);
#endif // !DBCS
                } else {
                    logonDomain[0] = 0;
                }

                str = (LPWSTR)((PWKSTA_USER_INFO_1)info)->wkui1_oth_domains;
                if (!str) {
                    str = L"";
                }
#ifdef DBCS /*fix for DBCS char sets*/
                len = (DWORD)NetpUnicodeToDBCSLen(str) + 1;
#else // !DBCS
                len = wcslen(str) + 1;
#endif // !DBCS
                bufferLeft -= len;
                totalAvail += len;

                if (len <= sizeof(otherDomains)) {
#ifdef DBCS /*fix for DBCS char sets*/
                    NetpCopyWStrToStrDBCS(otherDomains, str);
#else // !DBCS
                    NetpCopyWStrToStr(otherDomains, str);
#endif // !DBCS
                } else {
                    otherDomains[0] = 0;
                }
            }

            //
            // if there's enough space in the buffer then copy the strings
            //

            if (status == NERR_Success && bufferLeft >= 0) {

                WORD offset = bufferOffset + parameters.TotalAvail;
                LPSTR UNALIGNED ptr = POINTER_FROM_WORDS(bufferSegment, offset);

                //
                // username for all levels
                //

                strcpy(ptr, username);
                len = strlen(username) + 1;

                if (level <= 1) {

                    //
                    // levels 0 & 1 have username field at same offset
                    //

                    WRITE_WORD(&((struct wksta_info_1*)buffer)->wki1_username, offset);
                    WRITE_WORD((LPWORD)&((struct wksta_info_1*)buffer)->wki1_username+1, bufferSegment);
                } else {
                    WRITE_WORD(&((struct wksta_info_10*)buffer)->wki10_username, offset);
                    WRITE_WORD((LPWORD)&((struct wksta_info_10*)buffer)->wki10_username+1, bufferSegment);
                }
                ptr += len;
                offset += (WORD)len;

                //
                // logon_server for levels 0 & 1
                //

                if (level <= 1) {

                    strcpy(ptr, logonServer);
                    len = strlen(logonServer) + 1;

                    //
                    // levels 0 & 1 have logon_server field at same offset
                    //

                    WRITE_WORD(&((struct wksta_info_1*)buffer)->wki1_logon_server, offset);
                    WRITE_WORD((LPWORD)&((struct wksta_info_1*)buffer)->wki1_logon_server+1, bufferSegment);
                    ptr += len;
                    offset += (WORD)len;
                }

                //
                // logon_domain and oth_domains for levels 1 & 10
                //

                if (level >= 1) {
                    if (level == 1) {
                        strcpy(ptr, logonDomain);
                        len = strlen(logonDomain) + 1;
                        WRITE_WORD(&((struct wksta_info_1*)buffer)->wki1_logon_domain, offset);
                        WRITE_WORD((LPWORD)&((struct wksta_info_1*)buffer)->wki1_logon_domain+1, bufferSegment);
                        ptr += len;
                        offset += (WORD)len;
                        strcpy(ptr, otherDomains);
                        WRITE_WORD(&((struct wksta_info_1*)buffer)->wki1_oth_domains, offset);
                        WRITE_WORD((LPWORD)&((struct wksta_info_1*)buffer)->wki1_oth_domains+1, bufferSegment);
                    } else {
                        strcpy(ptr, logonDomain);
                        len = strlen(logonDomain) + 1;
                        WRITE_WORD(&((struct wksta_info_10*)buffer)->wki10_logon_domain, offset);
                        WRITE_WORD((LPWORD)&((struct wksta_info_10*)buffer)->wki10_logon_domain+1, bufferSegment);
                        ptr += len;
                        offset += (WORD)len;
                        strcpy(ptr, otherDomains);
                        WRITE_WORD(&((struct wksta_info_10*)buffer)->wki10_oth_domains, offset);
                        WRITE_WORD((LPWORD)&((struct wksta_info_10*)buffer)->wki10_oth_domains+1, bufferSegment);
                    }
                }
            } else if (status == NERR_Success) {

                //
                // the additional data will overflow the caller's buffer:
                // return ERROR_MORE_STATUS and NULL out any pointer fields
                // that XsNetWkstaGetInfo managed to set
                //

                switch (level) {
                case 1:
                    WRITE_FAR_POINTER(&((struct wksta_info_1*)buffer)->wki1_logon_domain, NULL);
                    WRITE_FAR_POINTER(&((struct wksta_info_1*)buffer)->wki1_oth_domains, NULL);

                    //
                    // FALL THROUGH TO LEVEL 0 FOR REST OF FIELDS
                    //

                case 0:
                    WRITE_FAR_POINTER(&((struct wksta_info_0*)buffer)->wki0_root, NULL);
                    WRITE_FAR_POINTER(&((struct wksta_info_0*)buffer)->wki0_computername, NULL);
                    WRITE_FAR_POINTER(&((struct wksta_info_0*)buffer)->wki0_username, NULL);
                    WRITE_FAR_POINTER(&((struct wksta_info_0*)buffer)->wki0_langroup, NULL);
                    WRITE_FAR_POINTER(&((struct wksta_info_0*)buffer)->wki0_logon_server, NULL);
                    WRITE_FAR_POINTER(&((struct wksta_info_0*)buffer)->wki0_wrkheuristics, NULL);
                    break;

                case 10:
                    WRITE_FAR_POINTER(&((struct wksta_info_10*)buffer)->wki10_computername, NULL);
                    WRITE_FAR_POINTER(&((struct wksta_info_10*)buffer)->wki10_username, NULL);
                    WRITE_FAR_POINTER(&((struct wksta_info_10*)buffer)->wki10_langroup, NULL);
                    WRITE_FAR_POINTER(&((struct wksta_info_10*)buffer)->wki10_logon_domain, NULL);
                    WRITE_FAR_POINTER(&((struct wksta_info_10*)buffer)->wki10_oth_domains, NULL);
                    break;
                }
                status = ERROR_MORE_DATA;
                SET_ERROR((WORD)status);
            }

            //
            // free the wksta user info buffer
            //

            NetApiBufferFree((LPVOID)info);

        } else {

#if DBG
            IF_DEBUG(NETAPI) {
                DbgPrint("VrNetWkstaGetInfo: NetWkstaUserGetInfo returns %d\n", net_status);
            }
#endif

        }

        //
        // update the amount of data available when we return NERR_Success,
        // ERROR_MORE_DATA or NERR_BufTooSmall
        //

        setDX((WORD)totalAvail);

#if DBG
        IF_DEBUG(NETAPI) {
            DbgPrint("VrNetWkstaGetInfo: TotalAvail=%d\n", getDX());
        }
#endif

    }

    //
    // if we got data back, then we must change the version number from
    // 3.0 to 2.1 so lanman.drv thinks it is compatible with this version
    // of LM
    //

    if (status == NERR_Success || status == ERROR_MORE_DATA) {
        switch (level) {
        case 0:
            ((struct wksta_info_0*)buffer)->wki0_ver_major = LANMAN_EMULATION_MAJOR_VERSION;
            ((struct wksta_info_0*)buffer)->wki0_ver_minor = LANMAN_EMULATION_MINOR_VERSION;
            break;

        case 1:
            ((struct wksta_info_1*)buffer)->wki1_ver_major = LANMAN_EMULATION_MAJOR_VERSION;
            ((struct wksta_info_1*)buffer)->wki1_ver_minor = LANMAN_EMULATION_MINOR_VERSION;
            break;

        case 10:
            ((struct wksta_info_10*)buffer)->wki10_ver_major = LANMAN_EMULATION_MAJOR_VERSION;
            ((struct wksta_info_10*)buffer)->wki10_ver_minor = LANMAN_EMULATION_MINOR_VERSION;
            break;
        }
    }

#if DBG

    IF_DEBUG(NETAPI) {
        DbgPrint("VrNetWkstaGetInfo: return status=%d, TotalAvail=%d\n", getAX(), getDX());
    }

    if (status == NERR_Success || status == ERROR_MORE_DATA) {
        IF_DEBUG(NETAPI) {
            DumpWkstaInfo(level, buffer);
        }
    }

#endif

}

#if DBG

#define POSSIBLE_STRING(s)  ((s) ? (s) : "")

VOID
DumpWkstaInfo(
    IN DWORD level,
    IN LPBYTE buffer
    )
{
    switch (level) {
    case 0:
    case 1:

        //
        // DbgPrint resets the test machine if we try it with this
        // string & these args all at once!
        //

        DbgPrint(   "reserved1      %04x\n",
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_reserved_1)
                    );

        DbgPrint(   "reserved2      %08x\n",
                    READ_DWORD(&((struct wksta_info_0*)buffer)->wki0_reserved_2)
                    );

        DbgPrint(   "lanroot        %04x:%04x \"%s\"\n",
                    GET_SEGMENT(&((struct wksta_info_0*)buffer)->wki0_root),
                    GET_OFFSET(&((struct wksta_info_0*)buffer)->wki0_root),
                    POSSIBLE_STRING(LPSTR_FROM_POINTER(&((struct wksta_info_0*)buffer)->wki0_root))
                    );

        DbgPrint(   "computername   %04x:%04x \"%s\"\n",
                    GET_SEGMENT(&((struct wksta_info_0*)buffer)->wki0_computername),
                    GET_OFFSET(&((struct wksta_info_0*)buffer)->wki0_computername),
                    POSSIBLE_STRING(LPSTR_FROM_POINTER(&((struct wksta_info_0*)buffer)->wki0_computername))
                    );

        DbgPrint(   "username       %04x:%04x \"%s\"\n",
                    GET_SEGMENT(&((struct wksta_info_0*)buffer)->wki0_username),
                    GET_OFFSET(&((struct wksta_info_0*)buffer)->wki0_username),
                    POSSIBLE_STRING(LPSTR_FROM_POINTER(&((struct wksta_info_0*)buffer)->wki0_username))
                    );

        DbgPrint(   "langroup       %04x:%04x \"%s\"\n",
                    GET_SEGMENT(&((struct wksta_info_0*)buffer)->wki0_langroup),
                    GET_OFFSET(&((struct wksta_info_0*)buffer)->wki0_langroup),
                    POSSIBLE_STRING(LPSTR_FROM_POINTER(&((struct wksta_info_0*)buffer)->wki0_langroup))
                    );

        DbgPrint(   "ver major      %02x\n"
                    "ver minor      %02x\n"
                    "reserved3      %08x\n"
                    "charwait       %04x\n"
                    "chartime       %08x\n"
                    "charcount      %04x\n",
                    READ_BYTE(&((struct wksta_info_0*)buffer)->wki0_ver_major),
                    READ_BYTE(&((struct wksta_info_0*)buffer)->wki0_ver_minor),
                    READ_DWORD(&((struct wksta_info_0*)buffer)->wki0_reserved_3),
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_charwait),
                    READ_DWORD(&((struct wksta_info_0*)buffer)->wki0_chartime),
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_charcount)
                    );

        DbgPrint(   "reserved4      %04x\n"
                    "reserved5      %04x\n"
                    "keepconn       %04x\n"
                    "keepsearch     %04x\n"
                    "maxthreads     %04x\n"
                    "maxcmds        %04x\n",
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_reserved_4),
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_reserved_5),
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_keepconn),
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_keepsearch),
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_maxthreads),
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_maxcmds)
                    );

        DbgPrint(   "reserved6      %04x\n"
                    "numworkbuf     %04x\n"
                    "sizworkbuf     %04x\n"
                    "maxwrkcache    %04x\n"
                    "sesstimeout    %04x\n"
                    "sizerror       %04x\n",
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_reserved_6),
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_numworkbuf),
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_sizworkbuf),
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_maxwrkcache),
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_sesstimeout),
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_sizerror)
                    );

        DbgPrint(   "numalerts      %04x\n"
                    "numservices    %04x\n"
                    "errlogsz       %04x\n"
                    "printbuftime   %04x\n"
                    "numcharbuf     %04x\n"
                    "sizcharbuf     %04x\n",
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_numalerts),
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_numservices),
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_errlogsz),
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_printbuftime),
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_numcharbuf),
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_sizcharbuf)
                    );

        DbgPrint(   "logon server   %04x:%04x \"%s\"\n",
                    GET_SEGMENT(&((struct wksta_info_0*)buffer)->wki0_logon_server),
                    GET_OFFSET(&((struct wksta_info_0*)buffer)->wki0_logon_server),
                    POSSIBLE_STRING(LPSTR_FROM_POINTER(&((struct wksta_info_0*)buffer)->wki0_logon_server))
                    );

        DbgPrint(   "wrkheuristics  %04x:%04x \"%s\"\n",
                    GET_SEGMENT(&((struct wksta_info_0*)buffer)->wki0_wrkheuristics),
                    GET_OFFSET(&((struct wksta_info_0*)buffer)->wki0_wrkheuristics),
                    POSSIBLE_STRING(LPSTR_FROM_POINTER(&((struct wksta_info_0*)buffer)->wki0_wrkheuristics))
                    );

        DbgPrint(   "mailslots      %04x\n",
                    READ_WORD(&((struct wksta_info_0*)buffer)->wki0_mailslots)
                    );

        if (level == 1) {
            DbgPrint(
                    "logon domain   %04x:%04x \"%s\"\n",
                    GET_SEGMENT(&((struct wksta_info_1*)buffer)->wki1_logon_domain),
                    GET_OFFSET(&((struct wksta_info_1*)buffer)->wki1_logon_domain),
                    POSSIBLE_STRING(LPSTR_FROM_POINTER(&((struct wksta_info_1*)buffer)->wki1_logon_domain))
                    );
            DbgPrint(
                    "other domains  %04x:%04x \"%s\"\n",
                    GET_SEGMENT(&((struct wksta_info_1*)buffer)->wki1_oth_domains),
                    GET_OFFSET(&((struct wksta_info_1*)buffer)->wki1_oth_domains),
                    POSSIBLE_STRING(LPSTR_FROM_POINTER(&((struct wksta_info_1*)buffer)->wki1_oth_domains))
                    );

            DbgPrint(
                    "numdgrambuf    %04x\n",
                    ((struct wksta_info_1*)buffer)->wki1_numdgrambuf
                    );
        }
        break;

    case 10:
        DbgPrint(   "computername   %04x:%04x \"%s\"\n",
                    GET_SEGMENT(&((struct wksta_info_10*)buffer)->wki10_computername),
                    GET_OFFSET(&((struct wksta_info_10*)buffer)->wki10_computername),
                    POSSIBLE_STRING(LPSTR_FROM_POINTER(&((struct wksta_info_10*)buffer)->wki10_computername))
                    );

        DbgPrint(   "username       %04x:%04x \"%s\"\n",
                    GET_SEGMENT(&((struct wksta_info_10*)buffer)->wki10_username),
                    GET_OFFSET(&((struct wksta_info_10*)buffer)->wki10_username),
                    POSSIBLE_STRING(LPSTR_FROM_POINTER(&((struct wksta_info_10*)buffer)->wki10_username))
                    );

        DbgPrint(   "langroup       %04x:%04x \"%s\"\n",
                    GET_SEGMENT(&((struct wksta_info_10*)buffer)->wki10_langroup),
                    GET_OFFSET(&((struct wksta_info_10*)buffer)->wki10_langroup),
                    POSSIBLE_STRING(LPSTR_FROM_POINTER(&((struct wksta_info_10*)buffer)->wki10_langroup))
                    );

        DbgPrint(   "ver major      %02x\n"
                    "ver minor      %02x\n"
                    "logon domain   %04x:%04x \"%s\"\n",
                    READ_BYTE(&((struct wksta_info_10*)buffer)->wki10_ver_major),
                    READ_BYTE(&((struct wksta_info_10*)buffer)->wki10_ver_minor),
                    GET_SEGMENT(&((struct wksta_info_10*)buffer)->wki10_logon_domain),
                    GET_OFFSET(&((struct wksta_info_10*)buffer)->wki10_logon_domain),
                    POSSIBLE_STRING(LPSTR_FROM_POINTER(&((struct wksta_info_10*)buffer)->wki10_logon_domain))
                    );

        DbgPrint(   "other domains  %04x:%04x \"%s\"\n",
                    GET_SEGMENT(&((struct wksta_info_10*)buffer)->wki10_oth_domains),
                    GET_OFFSET(&((struct wksta_info_10*)buffer)->wki10_oth_domains),
                    POSSIBLE_STRING(LPSTR_FROM_POINTER(&((struct wksta_info_10*)buffer)->wki10_oth_domains))
                    );
        break;
    }
    DbgPrint("\n");
}

#endif


VOID
VrNetWkstaSetInfo(
    VOID
    )

/*++

Routine Description:

    Performs local NetUseEnum on behalf of the Vdm client

Arguments:

    None.

Return Value:

    None.

--*/

{
#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrNetWkstaSetInfo\n");
        IF_DEBUG(BREAKPOINT) {
            DbgBreakPoint();
        }
    }
#endif

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrNetWkstaSetInfo - unsupported SVC\n");
    }
#endif

    SET_ERROR(ERROR_NOT_SUPPORTED);
}


VOID
VrReturnAssignMode(
    VOID
    )

/*++

Routine Description:

    Returns net pause/continue status

Arguments:

    Function 5F00h

    None. All arguments are extracted from the Vdm context registers/memory

Return Value:

    None. Results returned via VDM registers or in VDM memory, according to
    request

--*/

{
}


VOID
VrSetAssignMode(
    VOID
    )

/*++

Routine Description:

    Pauses or continues net (drive/printer) redirection

Arguments:

    Function 5F01h

    None. All arguments are extracted from the Vdm context registers/memory

Return Value:

    None. Results returned via VDM registers or in VDM memory, according to
    request

--*/

{
}

//
// DefineMacroDriveUserWords - the old DefineMacro call (int 21h/ax=5f03h)
// allows the caller to associate a (16-bit) word value with the assignment.
// This value can be returned from GetAssignListEntry (int 21h/ax=5f02h).
// NetUse doesn't support this, so we fake it
//
// DefineMacroPrintUserWords - same idea for printers; we reserve 8 max
//

static WORD DefineMacroDriveUserWords[26];
static WORD DefineMacroPrintUserWords[8];


VOID
VrGetAssignListEntry(
    VOID
    )

/*++

Routine Description:

    Old version of NetUseGetInfo. In DOS this function performs the following:

        look along CDS list for entry # bx with IS_NET bit set
        if found
            return local device name and remote net name
        else
            look along list of printers for entry # bx
            if found
                return local device name and remote net name
            endif
        endif

        Every time a drive entry is found with IS_NET set or a printer entry
        found, bx is decremented. When bx reaches 0, then that's the entry to
        return

        NOTE: This function DOES NOT support UNC connections

Arguments:

    Function 5F02h (GetAssignList)
    Function 5F05h (GetAssignList2)

    ENTRY   BX = which item to return (starts @ 0)
            DS:SI points to local redirection name
            ES:DI points to remote redirection name
            AL != 0 means return LSN in BP (GetAssignList2)?

Return Value:

    CF = 0
        BL = macro type (3 = printer, 4 = drive)
        BH = 'interesting' bits         ** UNSUPPORTED **
        AX = net name ID                ** UNSUPPORTED **
        CX = user word
        DX = max xmit size              ** UNSUPPORTED **
        BP = LSN if AL != 0 on entry    ** UNSUPPORTED **
        DS:SI has device name
        ES:DI has net path
    CF = 1
        AX = ERROR_NO_MORE_FILES

--*/

{
    NTSTATUS ntstatus;
    NET_API_STATUS status;
    XS_NET_USE_ENUM parameters;
    XS_PARAMETER_HEADER header;
    LPBYTE receiveBuffer;
    DWORD entryNumber;
    struct use_info_1* driveInfo[26];
    struct use_info_1* printInfo[8];    // is overkill, 3 is more like it
    struct use_info_1* infoPtr;
    struct use_info_1* infoBase;
    DWORD index;
    DWORD i;
    LPSTR remoteName;
    WORD userWord;
    DWORD converter;
    WORD wstatus;
    LPSTR dosPointer;

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrGetAssignListEntry\n");
        VrDumpRealMode16BitRegisters(FALSE);
    }
#endif

    //
    // maximum possible enumeration buffer size = 26 * (26 + 256 + 3) = 7410
    // which we'll round to 8K, which is overkill. Decided to allocate 2K
    //

#define ASSIGN_LIST_BUFFER_SIZE 2048

    receiveBuffer = (LPBYTE)LocalAlloc(LMEM_FIXED, ASSIGN_LIST_BUFFER_SIZE);
    if (receiveBuffer == NULL) {

        //
        // BUGBUG - possibly incompatible error code
        //

        SET_ERROR((WORD)ERROR_NOT_ENOUGH_MEMORY);
        return;
    }

    parameters.Level  = 1;
    parameters.Buffer = receiveBuffer;
    parameters.BufLen = ASSIGN_LIST_BUFFER_SIZE;

    header.Status = 0;
    header.ClientMachineName = NULL;
    header.ClientTransportName = NULL;

    ntstatus = XsNetUseEnum(&header, &parameters, REM16_use_info_1, NULL);

    //
    // if XsNetUseEnum didn't have any problems, convert the actual status
    // code to that returned in the header
    //

    if (ntstatus != STATUS_SUCCESS) {
        status = NetpNtStatusToApiStatus(ntstatus);
    } else {
        status = (DWORD)header.Status;

        //
        // we really want to brute-force this, so make sure we have all the
        // data
        //

#if DBG

        IF_DEBUG(NETAPI) {
            if (status != NERR_Success) {
                DbgPrint("VrGetAssignListEntry: XsNetUseEnum returns header.Status == %d\n", status);
            }
        }

        if (status == NERR_Success) {
            ASSERT(parameters.EntriesRead == parameters.TotalAvail);
        }

#endif

    }

    entryNumber = getBX();
    if (status == NERR_Success) {

        //
        // only do the following if the bx'th entry is in the list
        //

        if (parameters.EntriesRead > entryNumber) {

            //
            // we need to emulate the action of the DOS Redirector: we need to
            // sort the entries into ascending drive entries followed by
            // ascending printer entries. There were no such things as UNC
            // connections in the original (3.1) version of DOS, so we ignore
            // any in our list. Also ignored are IPC connections and comms
            // connections
            //

            RtlZeroMemory(driveInfo, sizeof(driveInfo));
            RtlZeroMemory(printInfo, sizeof(printInfo));
            infoPtr = (struct use_info_1*)receiveBuffer;

            //
            // XsNetUseEnum returns pointers in the structure as actual offsets
            // from the start of the buffer + a converter word. We have to
            // recalculate the actual pointers as
            //
            //  start of enum buffer + (pointer offset - converter dword)
            //
            // we have to convert the 16-bit converter word to a dword for
            // 32-bit pointer arithmetic
            //        driveInfo[index] = infoBase + ((DWORD)infoPtr->ui1_remote - converter);
            //

            infoBase = infoPtr;
            converter = (DWORD)header.Converter;

            for (i = 0; i < parameters.EntriesRead; ++i) {

                //
                // ignore UNCs - local name is NULL string (\0)
                //

                if (infoPtr->ui1_asg_type == USE_DISKDEV && infoPtr->ui1_local[0]) {
                    index = toupper(infoPtr->ui1_local[0])-'A';
                    driveInfo[index] = infoPtr;

#if DBG
                    IF_DEBUG(NETAPI) {
                        DbgPrint("Index=%d Drive=%s Netname=%s\n",
                                index,
                                infoPtr->ui1_local,
                                (LPSTR)infoBase + ((DWORD)infoPtr->ui1_remote - converter)
                                );
                    }
#endif

                } else if (infoPtr->ui1_asg_type == USE_SPOOLDEV && infoPtr->ui1_local[0]) {

                    //
                    // NOTE: assume there was never, is not, and will never be
                    // such a thing as LPT0:
                    //

                    index = infoPtr->ui1_local[3] - '1';
                    printInfo[index] = infoPtr;

#if DBG
                    IF_DEBUG(NETAPI) {
                        DbgPrint("Index=%d Printer=%s Netname=%s\n",
                                index,
                                infoPtr->ui1_local,
                                (LPSTR)infoBase + ((DWORD)infoPtr->ui1_remote - converter)
                                );
                    }
#endif

                }
                ++infoPtr;
            }

            //
            // now look along the list(s) for the bx'th (in entryNumber) entry
            //

            ++entryNumber;
            for (i = 0; i < ARRAY_ELEMENTS(driveInfo); ++i) {
                if (driveInfo[i]) {
                    --entryNumber;
                    if (!entryNumber) {
                        infoPtr = driveInfo[i];
                        userWord = DefineMacroDriveUserWords[i];
                        break;
                    }
                }
            }

            //
            // if entryNumber was not reduced to 0 then check the printers
            //

            if (entryNumber) {
                for (i = 0; i < ARRAY_ELEMENTS(printInfo); ++i) {
                    if (printInfo[i]) {
                        --entryNumber;
                        if (!entryNumber) {
                            infoPtr = printInfo[i];
                            userWord = DefineMacroPrintUserWords[i];
                            break;
                        }
                    }
                }
            }

            //
            // if entryNumber is 0 then we found the bx'th entry. Return it.
            //

            if (!entryNumber) {

#if DBG
                IF_DEBUG(NETAPI) {
                    DbgPrint("LocalName=%s, RemoteName=%s, UserWord=%04x\n",
                            infoPtr->ui1_local,
                            (LPSTR)infoBase + ((DWORD)infoPtr->ui1_remote - converter),
                            userWord
                            );
                }
#endif

                //
                // copy the strings to DOS memory, making sure to upper case
                // them and convert / to \.
                //

                strcpy(POINTER_FROM_WORDS(getDS(), getSI()), infoPtr->ui1_local);
                dosPointer = LPSTR_FROM_WORDS(getES(), getDI());
                remoteName = (LPSTR)infoBase + ((DWORD)infoPtr->ui1_remote - converter);
                wstatus = VrpTranslateDosNetPath(&remoteName, &dosPointer);

#if DBG
                IF_DEBUG(NETAPI) {
                    if (wstatus != 0) {
                        DbgPrint("VrGetAssignListEntry: wstatus == %d\n", wstatus);
                    }
                }
#endif

                setBL((BYTE)(infoPtr->ui1_asg_type == 0 ? 4 : 3));
                setCX(userWord);

                //
                // return some innocuous (?!) values for the unsupported
                // returned parameters
                //

                setBH((BYTE)(infoPtr->ui1_status ? 1 : 0));   // 'interesting' bits (?)
            } else {
                status = ERROR_NO_MORE_FILES;
            }
        } else {
            status = ERROR_NO_MORE_FILES;
        }
    }

    //
    // only return carry clear if no error occurred. Even if ERROR_MORE_DATA
    // set CF
    //

    if (status) {
        SET_ERROR(VrpMapDosError(status));
    } else {
        setCF(0);
    }

    //
    // free resources
    //

    LocalFree(receiveBuffer);
}


VOID
VrDefineMacro(
    VOID
    )

/*++

Routine Description:

    Old version of NetUseAdd. Convert to NetUseAdd

Arguments:

    Function 5F03h

    ENTRY   BL = device type
                3 = printer
                4 = drive
            bit 7 on means use the wksta password when connecting   ** UNSUPPORTED **
            CX = user word
            DS:SI = local device
                Can be NUL device name, indicating UNC use
            ES:DI = remote name

Return Value:

    CF = 0
        success

    CF = 1
        AX = ERROR_INVALID_PARAMETER (87)
             ERROR_INVALID_PASSWORD (86)
             ERROR_INVALID_DRIVE (15)
             ERROR_ALREADY_ASSIGNED (85)
             ERROR_PATH_NOT_FOUND (3)
             ERROR_ACCESS_DENIED (5)
             ERROR_NOT_ENOUGH_MEMORY (8)
             ERROR_NO_MORE_FILES (18)
             ERROR_REDIR_PAUSED (72)

--*/

{
    NET_API_STATUS status;
    XS_NET_USE_ADD parameters;
    XS_PARAMETER_HEADER header;
    NTSTATUS ntstatus;
    BYTE bl;
    LPSTR netStringPointer;
    WORD index;

    //
    // modifiable descriptor string
    //

    char descriptor[sizeof(REM16_use_info_1)];

    //
    // buffer for use_info_1 plus remote string plus password
    //

    char useBuffer[sizeof(struct use_info_1) + LM20_PATHLEN + 1 + LM20_PWLEN + 1];
    WORD wstatus;
    LPBYTE variableData;
    DWORD len;
    LPSTR dosString;

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrDefineMacro \"%s\" == \"%s\"\n",
                 LPSTR_FROM_WORDS(getDS(), getSI()),
                 LPSTR_FROM_WORDS(getES(), getDI())
                 );
    }
#endif

    bl = getBL();
    if (bl == 3) {
        ((struct use_info_1*)useBuffer)->ui1_asg_type = 1;  // USE_SPOOLDEV
    } else if (bl == 4) {
        ((struct use_info_1*)useBuffer)->ui1_asg_type = 0;  // USE_DISKDEV
    } else {
        SET_ERROR(ERROR_INVALID_PARAMETER);
        return;
    }

    //
    // copy the standard 16-bit use_info_1 structure descriptor to the
    // modifiable descriptor string: if we discover a NUL password then we
    // set the ui1_password field to NULL and the corresponding descriptor
    // character to 'O'
    //

    strcpy(descriptor, REM16_use_info_1);

    //
    // check the local name length
    //

    dosString = LPSTR_FROM_WORDS(getDS(), getSI());
    if (dosString) {
        if ((len = strlen(dosString) + 1) > LM20_DEVLEN + 1) {
            SET_ERROR(ERROR_INVALID_PARAMETER);
            return;
        }

        //
        // copy the local device name into the use_info_1 structure
        //

        RtlCopyMemory(((struct use_info_1*)useBuffer)->ui1_local, dosString, len);

        //
        // BUGBUG - Code Page, Kanji, DBCS, Locale?
        //

        _strupr(((struct use_info_1*)useBuffer)->ui1_local);
    } else {
        ((struct use_info_1*)useBuffer)->ui1_local[0] = 0;
    }

    //
    // copy the remote name to the end of the use_info_1 structure. If there's
    // an error, return it
    //

    netStringPointer = POINTER_FROM_WORDS(getES(), getDI());
    variableData = (LPBYTE)&((struct use_info_1*)useBuffer)[1];
    ((struct use_info_1*)useBuffer)->ui1_remote = variableData;
    wstatus = VrpTranslateDosNetPath(&netStringPointer, &variableData);
    if (wstatus) {
        SET_ERROR(wstatus);
        return;
    }

    //
    // if there was a password with this remote name, copy it to the end of
    // the variable data area
    //

    if (*netStringPointer) {
        if ((len = strlen(netStringPointer) + 1) > LM20_PWLEN + 1) {
            SET_ERROR(ERROR_INVALID_PASSWORD);
            return;
        } else {
            ((struct use_info_1*)useBuffer)->ui1_password = netStringPointer;
            RtlCopyMemory(variableData, netStringPointer, len);
        }
    } else {

        //
        // there is no password - set the password pointer field to NULL and
        // change the descriptor character for this field to 'O' signifying
        // that there will be no string in the variable data for this field
        //

        ((struct use_info_1*)useBuffer)->ui1_password = NULL;
        descriptor[4] = REM_NULL_PTR;   // 'O'
    }

    parameters.Level = 1;
    parameters.Buffer = useBuffer;
    parameters.BufLen = sizeof(useBuffer);

    header.Status = 0;
    header.ClientMachineName = NULL;
    header.ClientTransportName = NULL;

    ntstatus = XsNetUseAdd(&header, &parameters, descriptor, NULL);

    if (!NT_SUCCESS(ntstatus)) {
        status = NetpNtStatusToApiStatus(ntstatus);

#if DBG
        if (!NT_SUCCESS(ntstatus)) {
            IF_DEBUG(NETAPI) {
                DbgPrint("VrDefineMacro: Error: XsNetUseAdd returns %x\n", ntstatus);
            }
        }
#endif

    } else {

        //
        // no error generated in XsNetUseAdd. Get the status of the NetUseAdd
        // proper from the header
        //

        status = (NET_API_STATUS)header.Status;
    }
    if (status != NERR_Success) {

#if DBG
        IF_DEBUG(NETAPI) {
            DbgPrint("Error: VrDefineMacro: XsNetUseAdd returns %u\n", status);
        }
#endif

        SET_ERROR((WORD)status);
    } else {

        //
        // set the user word in the appropriate list
        //

        if (bl == 3) {
            index = ((struct use_info_1*)useBuffer)->ui1_local[3] - '0';
            DefineMacroPrintUserWords[index] = getCX();
        } else if (((struct use_info_1*)useBuffer)->ui1_local[0]) {

            //
            // note that we already upper-cased the device name
            //

            index = ((struct use_info_1*)useBuffer)->ui1_local[0] - 'A';
            DefineMacroDriveUserWords[index] = getCX();
        }

        //
        // BUGBUG - don't record user word for UNC connections????
        //

        setCF(0);
    }
}


VOID
VrBreakMacro(
    VOID
    )

/*++

Routine Description:

    Old version of NetUseDel. Convert to NetUseDel

Arguments:

    Function 5F04h

    ENTRY   DS:SI = buffer containing device name of redirection to break

Return Value:

    CF = 0
        success

    CF = 1
        AX = ERROR_PATH_NOT_FOUND (3)
             ERROR_ACCESS_DENIED (5)
             ERROR_NOT_ENOUGH_MEMORY (8)
             ERROR_REDIR_PAUSED (72)
             ERROR_NO_MORE_FILES (18)

--*/

{
    NTSTATUS ntstatus;
    NET_API_STATUS status;
    XS_NET_USE_DEL parameters;
    XS_PARAMETER_HEADER header;

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrBreakMacro %s\n", LPSTR_FROM_WORDS(getDS(), getSI()));
    }
#endif

    parameters.UseName = LPSTR_FROM_WORDS(getDS(), getSI());
    parameters.Force = USE_LOTS_OF_FORCE;

    header.Status = 0;
    header.ClientMachineName = NULL;
    header.ClientTransportName = NULL;

    ntstatus = XsNetUseDel(&header, &parameters, NULL, NULL);

    //
    // if XsNetUseDel failed then map the NT error returned into a Net error
    // else get the result of the NetUseDel proper from the header structure
    //

    if (ntstatus != STATUS_SUCCESS) {
        status = NetpNtStatusToApiStatus(ntstatus);
    } else {
        status = (NET_API_STATUS)header.Status;
        if (status != NERR_Success) {
            SET_ERROR(VrpMapDosError(status));
        } else {
            setCF(0);
        }
    }
}


//
// private routines
//

NET_API_STATUS
VrpTransactVdm(
    IN BOOL NullSessionFlag
    )

/*++

Routine Description:

    Performs transaction request for NetTransactAPI and NetNullTransactAPI

Arguments:

    NullSessionFlag - TRUE if the transaction request will use a NULL session

    VDM DS:SI points at a transaction descriptor structure:

        far pointer to transaction name (\\COMPUTER\PIPE\LANMAN)
        far pointer to password for connection
        far pointer to send parameter buffer
        far pointer to send data buffer
        far pointer to receive set-up buffer
        far pointer to receive parameter buffer
        far pointer to receive data buffer
        unsigned short send parameter buffer length
        unsigned short send data buffer length
        unsigned short receive parameter buffer length
        unsigned short receive data buffer length
        unsigned short receive set-up buffer length
        unsigned short flags
        unsigned long  timeout
        unsigned short reserved
        unsigned short send set-up buffer length

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - return code from RxpTransactSmb

--*/

{
    struct tr_packet* transactionPacket;
    DWORD receiveBufferLen;
    NET_API_STATUS status;
    char computerName[LM20_UNCLEN+1];
    LPSTR pipeName;
    DWORD i;
    LPWSTR uncName;
    UNICODE_STRING uString;
    ANSI_STRING aString;
    NTSTATUS ntstatus;
    LPBYTE parameterBuffer;
    LPBYTE pSendParameters;
    LPBYTE pReceiveParameters;
    WORD sendParameterLen;
    WORD receiveParameterLen;
    WORD apiNumber;

#if DBG
    BOOL dumpRxData;
    IF_DEBUG(NETAPI) {
        DbgPrint("VrpTransactVdm: tr_packet @ %04x:%04x\n", getDS(), getSI());
    }
#endif

    transactionPacket = (struct tr_packet*)POINTER_FROM_WORDS(getDS(), getSI());

#if DBG
    IF_DEBUG(NETAPI) {
        DumpTransactionPacket(transactionPacket, TRUE, TRUE);
    }
#endif

    receiveBufferLen = (DWORD)READ_WORD(&transactionPacket->tr_rdlen);

    //
    // try to extract the UNC computer name from the pipe name
    //

    pipeName = LPSTR_FROM_POINTER(&transactionPacket->tr_name);
    if (IS_ASCII_PATH_SEPARATOR(pipeName[0]) && IS_ASCII_PATH_SEPARATOR(pipeName[1])) {
        computerName[0] = computerName[1] = '\\';
        for (i = 2; i < sizeof(computerName)-1; ++i) {
            if (IS_ASCII_PATH_SEPARATOR(pipeName[i])) {
                break;
            }
            computerName[i] = pipeName[i];
        }
        if (IS_ASCII_PATH_SEPARATOR(pipeName[i])) {
            computerName[i] = '\0';
            pipeName = computerName;
        }
    }

    RtlInitAnsiString(&aString, pipeName);
    ntstatus = RtlAnsiStringToUnicodeString(&uString, &aString, (BOOLEAN)TRUE);
    if (!NT_SUCCESS(ntstatus)) {

#if DBG
        IF_DEBUG(NETAPI) {
            DbgPrint("VrpTransactVdm: Unexpected situation: RtlAnsiStringToUnicodeString returns %x\n", ntstatus);
        }
#endif

        return ERROR_NOT_ENOUGH_MEMORY;
    }
    uncName = uString.Buffer;

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrpTransactVdm: UncName=%ws\n", uncName);
    }
#endif

    //
    // if the app supplies different send and receive parameter buffer pointers
    // we have to collapse them into the same buffer
    //

    pSendParameters = LPBYTE_FROM_POINTER(&transactionPacket->tr_spbuf);
    pReceiveParameters = LPBYTE_FROM_POINTER(&transactionPacket->tr_rpbuf);
    sendParameterLen = READ_WORD(&transactionPacket->tr_splen);
    receiveParameterLen = READ_WORD(&transactionPacket->tr_rplen);
    if (pSendParameters != pReceiveParameters) {
        parameterBuffer = (LPBYTE)LocalAlloc(
                                    LMEM_FIXED,
                                    max(sendParameterLen, receiveParameterLen)
                                    );
        if (parameterBuffer == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        RtlMoveMemory(parameterBuffer, pSendParameters, sendParameterLen);
        pSendParameters = pReceiveParameters = parameterBuffer;
    } else {
        parameterBuffer = NULL;
    }

    //
    // in the case of remoted NetUserAdd2, NetUserPasswordSet2 and NetUserSetInfo2
    // we have to encrypt any passwords if not already encrypted. We will change
    // data in the parameter and send data buffer. Since we assume that this call
    // is coming from the NET function library and not from the app, it should
    // be okay to modify these buffers and not restore them before this function
    // is complete
    //

    apiNumber = READ_WORD(pSendParameters);
    if (apiNumber == API_WUserAdd2
    || apiNumber == API_WUserPasswordSet2
    || apiNumber == API_WUserSetInfo2) {

        LPBYTE parameterPointer = pSendParameters + sizeof(WORD);
        LPBYTE passwordPointer;
        DWORD parmNum = PARMNUM_ALL;

        //
        // skip over parameter descriptor and data descriptor
        //

        parameterPointer += strlen(parameterPointer) + 1;
        parameterPointer += strlen(parameterPointer) + 1;

        //
        // the next thing in the parameter buffer for SetInfo2 and PasswordSet2
        // is the user name: skip it
        //

        if (apiNumber != API_WUserAdd2) {
            parameterPointer += strlen(parameterPointer) + 1;
        }

        //
        // if this is PasswordSet2 then parameterPointer is pointing at the
        // old and new passwords. Remember this address and scan forward to
        // the password encryption flag/new cleartext password length
        //
        // if this is AddUser2, we are pointing at the level which we are not
        // interested in; skip forward to the encryption flag/cleartext password
        // length
        //
        // if this is SetInfo2, we are pointing at the level which we are not
        // interested in; skip forward to the parmnum. Record that. Then skip
        // forward again to the encryption flag/cleartext password length
        //

        if (apiNumber == API_WUserPasswordSet2) {
            passwordPointer = parameterPointer;
            parameterPointer += ENCRYPTED_PWLEN * 2;
        } else {
            parameterPointer += sizeof(WORD);
            if (apiNumber == API_WUserSetInfo2) {
                parmNum = (DWORD)READ_WORD(parameterPointer);
                parameterPointer += sizeof(WORD);
            }

            //
            // in the case of NetUserAdd2 and NetUserSetInfo2, the data buffer
            // contains the password. If the SetInfo2 is using PARMNUM_ALL then
            // the password is in the same place as for AddUser2: in a user_info_1
            // or user_info_2 structure. Luckily, the password is at the same
            // offset for both structures.
            //
            // If this is SetInfo2 with USER_PASSWORD_PARMNUM then the send data
            // pointer points at the password
            //

            passwordPointer = LPBYTE_FROM_POINTER(&transactionPacket->tr_sdbuf);
            if (parmNum == PARMNUM_ALL) {
                passwordPointer += (DWORD)&((struct user_info_1*)0)->usri1_password;
            }
        }

        //
        // only perform encryption if parmNum is PARMNUM_ALL or USER_PASSWORD_PARMNUM
        //

        if (parmNum == PARMNUM_ALL || parmNum == USER_PASSWORD_PARMNUM) {

            //
            // in all cases, parameterPointer points at the encryption flag
            //

            if (!READ_WORD(parameterPointer)) {

                WORD cleartextLength;

                //
                // the password(s) is (are) not already encrypted (surprise!). We
                // have to do it. If encryption fails for any reason, return an
                // internal error. We do not want to fail-back to putting clear-text
                // passwords on the wire in this case
                //

                cleartextLength = (WORD)strlen(passwordPointer);

                //
                // NetUserPasswordSet2 requires a different method than the
                // other 2
                //

                if (apiNumber == API_WUserPasswordSet2) {

                    NTSTATUS ntStatus;
                    LPBYTE oldPasswordPointer = passwordPointer;
                    ENCRYPTED_LM_OWF_PASSWORD oldEncryptedWithNew;
                    ENCRYPTED_LM_OWF_PASSWORD newEncryptedWithOld;

                    ntStatus = RtlCalculateLmOwfPassword(
                                    passwordPointer,
                                    (PLM_OWF_PASSWORD)passwordPointer
                                    );
                    if (!NT_SUCCESS(ntStatus)) {
                        status = NERR_InternalError;
                        goto VrpTransactVdm_exit;
                    }
                    passwordPointer += ENCRYPTED_PWLEN;
                    cleartextLength = (WORD)strlen(passwordPointer);
                    ntStatus = RtlCalculateLmOwfPassword(
                                    passwordPointer,
                                    (PLM_OWF_PASSWORD)passwordPointer
                                    );
                    if (!NT_SUCCESS(ntStatus)) {
                        status = NERR_InternalError;
                        goto VrpTransactVdm_exit;
                    }

                    //
                    // for PasswordSet2, we need to double-encrypt the passwords
                    //

                    ntStatus = RtlEncryptLmOwfPwdWithLmOwfPwd(
                                    (PLM_OWF_PASSWORD)oldPasswordPointer,
                                    (PLM_OWF_PASSWORD)passwordPointer,
                                    &oldEncryptedWithNew
                                    );
                    if (!NT_SUCCESS(ntStatus)) {
                        status = NERR_InternalError;
                        goto VrpTransactVdm_exit;
                    }
                    ntStatus = RtlEncryptLmOwfPwdWithLmOwfPwd(
                                    (PLM_OWF_PASSWORD)passwordPointer,
                                    (PLM_OWF_PASSWORD)oldPasswordPointer,
                                    &newEncryptedWithOld
                                    );
                    if (!NT_SUCCESS(ntStatus)) {
                        status = NERR_InternalError;
                        goto VrpTransactVdm_exit;
                    }
                    RtlCopyMemory(oldPasswordPointer,
                                  &oldEncryptedWithNew,
                                  sizeof(oldEncryptedWithNew)
                                  );
                    RtlCopyMemory(passwordPointer,
                                  &newEncryptedWithOld,
                                  sizeof(newEncryptedWithOld)
                                  );
                } else {
                    if (!EncryptPassword(uncName, passwordPointer)) {
                        status = NERR_InternalError;
                        goto VrpTransactVdm_exit;
                    }
                }

                //
                // set the password encrypted flag in the parameter buffer
                //

                WRITE_WORD(parameterPointer, 1);

                //
                // record the length of the cleartext password (the new one in case
                // of PasswordSet2)
                //

                WRITE_WORD(parameterPointer + sizeof(WORD), cleartextLength);
            }
        }
    }

    status = RxpTransactSmb(
                (LPTSTR)uncName,
                NULL,           // transport name
                pSendParameters,
                (DWORD)sendParameterLen,
                LPBYTE_FROM_POINTER(&transactionPacket->tr_sdbuf),
                (DWORD)READ_WORD(&transactionPacket->tr_sdlen),
                pReceiveParameters,
                (DWORD)receiveParameterLen,
                LPBYTE_FROM_POINTER(&transactionPacket->tr_rdbuf),
                &receiveBufferLen,
                NullSessionFlag
                );

    //
    // if we received data, set the received data length in the structure
    //

    if (status == NERR_Success || status == ERROR_MORE_DATA) {
        WRITE_WORD(&transactionPacket->tr_rdlen, receiveBufferLen);
    }

    //
    // if we munged the parameter buffer then copy the returned parameters to
    // the app's supplied buffer
    //

    if (parameterBuffer) {
        RtlMoveMemory(LPBYTE_FROM_POINTER(&transactionPacket->tr_rpbuf),
                      pReceiveParameters,
                      receiveParameterLen
                      );
    }

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrpTransactVdm: returning %d\n\n", status);
        if (status == NERR_Success || status == ERROR_MORE_DATA) {
            dumpRxData = TRUE;
        } else {
            dumpRxData = FALSE;
        }
        DumpTransactionPacket(transactionPacket, FALSE, dumpRxData);
    }
#endif

VrpTransactVdm_exit:

    RtlFreeUnicodeString(&uString);

    if (parameterBuffer) {
        LocalFree((HLOCAL)parameterBuffer);
    }

    return status;
}


BOOL
EncryptPassword(
    IN LPWSTR ServerName,
    IN OUT LPBYTE Password
    )

/*++

Routine Description:

    Encrypts an ANSI password

Arguments:

    ServerName  - pointer to UNICODE server name. Server is where we are going
                  to send the encrypted password
    Password    - pointer to buffer containing on input an ANSI password (<= 14
                  characters, plus NUL), and on output contains the 16-byte
                  encrypted password

Return Value:

    BOOL
        TRUE    - Password has been encrypted
        FALSE   - couldn't encrypt password. Password is in unknown state

--*/

{
    NTSTATUS ntStatus;
    LM_OWF_PASSWORD lmOwfPassword;
    LM_SESSION_KEY lanmanKey;

    _strupr(Password);
    ntStatus = RtlCalculateLmOwfPassword(Password, &lmOwfPassword);
    if (NT_SUCCESS(ntStatus)) {
        ntStatus = GetLanmanSessionKey(ServerName, (LPBYTE)&lanmanKey);
        if (NT_SUCCESS(ntStatus)) {
            ntStatus = RtlEncryptLmOwfPwdWithLmSesKey(&lmOwfPassword,
                                                      &lanmanKey,
                                                      (PENCRYPTED_LM_OWF_PASSWORD)Password
                                                      );
        }
    }
    return NT_SUCCESS(ntStatus);
}

#if DBG
PRIVATE
VOID
DumpTransactionPacket(
    IN struct tr_packet* TransactionPacket,
    IN BOOL IsInput,
    IN BOOL DumpData
    )
{
    LPBYTE password;
    WORD parmSeg;
    WORD parmOff;
    WORD dataSeg;
    WORD dataOff;
    DWORD parmLen;
    DWORD dataLen;
    char passwordBuf[8*3+1];

    password = LPBYTE_FROM_POINTER(&TransactionPacket->tr_passwd);
    if (password) {
        sprintf(passwordBuf, "%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x",
                password[0],
                password[1],
                password[2],
                password[3],
                password[4],
                password[5],
                password[6],
                password[7]
                );
    } else {
        passwordBuf[0] = 0;
    }

    DbgPrint(   "DumpTransactionPacket(%08x)\n"
                "name               %04x:%04x \"%s\"\n"
                "password           %04x:%04x %s\n"
                "send parm buffer   %04x:%04x\n"
                "send data buffer   %04x:%04x\n"
                "rcv setup buffer   %04x:%04x\n"
                "rcv parm buffer    %04x:%04x\n"
                "rcv data buffer    %04x:%04x\n"
                "send parm len      %04x\n"
                "send data len      %04x\n"
                "rcv parm len       %04x\n"
                "rcv data len       %04x\n"
                "rcv setup len      %04x\n"
                "flags              %04x\n"
                "timeout            %08x (%d)\n"
                "reserved           %04x\n"
                "send setup len     %04x\n"
                "\n",
                TransactionPacket,
                GET_SEGMENT(&TransactionPacket->tr_name),
                GET_OFFSET(&TransactionPacket->tr_name),
                LPSTR_FROM_POINTER(&TransactionPacket->tr_name),
                GET_SEGMENT(&TransactionPacket->tr_passwd),
                GET_OFFSET(&TransactionPacket->tr_passwd),
                passwordBuf,
                GET_SEGMENT(&TransactionPacket->tr_spbuf),
                GET_OFFSET(&TransactionPacket->tr_spbuf),
                GET_SEGMENT(&TransactionPacket->tr_sdbuf),
                GET_OFFSET(&TransactionPacket->tr_sdbuf),
                GET_SEGMENT(&TransactionPacket->tr_rsbuf),
                GET_OFFSET(&TransactionPacket->tr_rsbuf),
                GET_SEGMENT(&TransactionPacket->tr_rpbuf),
                GET_OFFSET(&TransactionPacket->tr_rpbuf),
                GET_SEGMENT(&TransactionPacket->tr_rdbuf),
                GET_OFFSET(&TransactionPacket->tr_rdbuf),
                READ_WORD(&TransactionPacket->tr_splen),
                READ_WORD(&TransactionPacket->tr_sdlen),
                READ_WORD(&TransactionPacket->tr_rplen),
                READ_WORD(&TransactionPacket->tr_rdlen),
                READ_WORD(&TransactionPacket->tr_rslen),
                READ_WORD(&TransactionPacket->tr_flags),
                READ_DWORD(&TransactionPacket->tr_timeout),
                READ_DWORD(&TransactionPacket->tr_timeout),
                READ_WORD(&TransactionPacket->tr_resvd),
                READ_WORD(&TransactionPacket->tr_sslen)
                );
    if (IsInput) {
        parmLen = (DWORD)READ_WORD(&TransactionPacket->tr_splen);
        dataLen = (DWORD)READ_WORD(&TransactionPacket->tr_sdlen);
        parmSeg = GET_SEGMENT(&TransactionPacket->tr_spbuf);
        parmOff = GET_OFFSET(&TransactionPacket->tr_spbuf);
        dataSeg = GET_SEGMENT(&TransactionPacket->tr_sdbuf);
        dataOff = GET_OFFSET(&TransactionPacket->tr_sdbuf);
    } else {
        parmLen = (DWORD)READ_WORD(&TransactionPacket->tr_rplen);
        dataLen = (DWORD)READ_WORD(&TransactionPacket->tr_rdlen);
        parmSeg = GET_SEGMENT(&TransactionPacket->tr_rpbuf);
        parmOff = GET_OFFSET(&TransactionPacket->tr_rpbuf);
        dataSeg = GET_SEGMENT(&TransactionPacket->tr_rdbuf);
        dataOff = GET_OFFSET(&TransactionPacket->tr_rdbuf);
    }
    if (DumpData) {
        if (IsInput) {
            IF_DEBUG(TRANSACT_TX) {
                if (parmLen) {
                    DbgPrint("Send Parameters:\n");
                    VrDumpDosMemory('B', parmLen, parmSeg, parmOff);
                }
                if (dataLen) {
                    DbgPrint("Send Data:\n");
                    VrDumpDosMemory('B', dataLen, dataSeg, dataOff);
                }
            }
        } else {
            IF_DEBUG(TRANSACT_RX) {
                if (parmLen) {
                    DbgPrint("Received Parameters:\n");
                    VrDumpDosMemory('B', parmLen, parmSeg, parmOff);
                }
                if (dataLen) {
                    DbgPrint("Received Data:\n");
                    VrDumpDosMemory('B', dataLen, dataSeg, dataOff);
                }
            }
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\vrmslot.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrmslot.c

Abstract:

    Contains Mailslot function handlers for Vdm Redir (Vr) support. This module
    contains the following Vr routines:

        VrDeleteMailslot
        VrGetMailslotInfo
        VrMakeMailslot
        VrPeekMailslot
        VrReadMailslot
        VrWriteMailslot
        VrTerminateMailslots

    Private (Vrp) routines:

        VrpIsMailslotName
        VrpMakeLocalMailslotName
        VrpLinkMailslotStructure
        VrpUnlinkMailslotStructure
        VrpMapMailslotHandle16
        VrpMapMailslotName
        VrpRemoveProcessMailslots
        VrpAllocateHandle16
        VrpFreeHandle16


Author:

    Richard L Firth (rfirth) 16-Sep-1991

Notes:

    Although once created, we must read and write local mailslots using a
    32-bit handle, we use a 16-bit handle to identify the mailslot.  Hence
    we must map the 16-bit mailslot handle to an open 32-bit mailslot
    handle on reads.  The DosWriteMailslot function always supplies the
    symbolic name of a mailslot even if it is local.  In this case we must
    map the name to the open 32-bit local mailslot handle.  We need to
    keep all 3 pieces of information around and map the 16-bit handles
    (ordinal and symbolic) to 32-bit mailslot handles.  Hence the need to
    keep mailslot info structures which are identified mainly by the
    16-bit handle value which we must generate.

    Note that in the DOS world, mailslot handles are traditionally handled
    only by the redirector TSR and DOS has no knowledge of their existence
    or meaning.  Therefore, the 32-bit handle cannot be kept in an SFT and
    DOS would not know what to do with a mailslot handle if given one,
    except where it was numerically equivalent to an open file handle,
    which would probably cause some grief.

    It is assumed that this code is shared between multiple NTVDM processes
    but that each process has its own copy of the data. Hence, none of the
    data items declared in this module are shared - each process has its
    own copy

Environment:

    32-bit flat address space

Revision History:

    16-Sep-1991 rfirth
        Created

--*/

#include <nt.h>
#include <ntrtl.h>      // ASSERT, DbgPrint
#include <nturtl.h>
#include <windows.h>
#include <softpc.h>     // x86 virtual machine definitions
#include <vrdlctab.h>
#include <vdmredir.h>   // common Vdm Redir stuff
#include <vrmslot.h>
#include <string.h>     // Dos still dealing with ASCII
#include <lmcons.h>     // LM20_PATHLEN
#include <lmerr.h>      // NERR_???
#include "vrputil.h"    // private utilities
#include "apistruc.h"   // DosWriteMailslotStruct
#include "vrdebug.h"    // IF_DEBUG

//
// local manifests
//

#define MAILSLOT_PREFIX                 "\\MAILSLOT\\"
#define MAILSLOT_PREFIX_LENGTH          (sizeof(MAILSLOT_PREFIX) - 1)
#define LOCAL_MAILSLOT_PREFIX           "\\\\."
#define LOCAL_MAILSLOT_NAMELEN          LM20_PATHLEN

//
// MAX_16BIT_HANDLES is used as the array allocator count for Handle16Bitmap
// which is stored as DWORDs. Hence, this value should be a multiple of 32,
// or BITSIN(DWORD)
//

#define MAX_16BIT_HANDLES               (1 * BITSIN(DWORD))

#define HANDLE_FUNCTION_FAILED          ((HANDLE)0xffffffff)

//
// local macros
//

#define VrpAllocateMailslotStructure(n) ((PVR_MAILSLOT_INFO)LocalAlloc(LMEM_FIXED, sizeof(VR_MAILSLOT_INFO) + (n)))
#define VrpFreeMailslotStructure(ptr)   ((void)LocalFree(ptr))
#ifdef VR_BREAK
#define VR_BREAKPOINT()                 DbgBreakPoint()
#else
#define VR_BREAKPOINT()
#endif


//
// private routine prototypes
//

PRIVATE
BOOL
VrpIsMailslotName(
    IN LPSTR Name
    );

PRIVATE
VOID
VrpMakeLocalMailslotName(
    IN LPSTR lpBuffer,
    IN LPSTR lpName
    );

PRIVATE
VOID
VrpLinkMailslotStructure(
    IN PVR_MAILSLOT_INFO MailslotInfo
    );

PRIVATE
PVR_MAILSLOT_INFO
VrpUnlinkMailslotStructure(
    IN WORD Handle16
    );

PRIVATE
PVR_MAILSLOT_INFO
VrpMapMailslotHandle16(
    IN WORD Handle16
    );

PRIVATE
PVR_MAILSLOT_INFO
VrpMapMailslotName(
    IN LPSTR Name
    );

PRIVATE
VOID
VrpRemoveProcessMailslots(
    IN WORD DosPdb
    );

PRIVATE
WORD
VrpAllocateHandle16(
    VOID
    );

PRIVATE
VOID
VrpFreeHandle16(
    IN WORD Handle16
    );


//
// VdmRedir Mailslot support routines
//

VOID
VrDeleteMailslot(
    VOID
    )

/*++

Routine Description:

    Performs DosDeleteMailslot request on behalf of VDM redir. Locates
    VR_MAILSLOT_INFO structure given 16-bit handle, unlinks structure from
    list, frees it and de-allocates the handle

    Notes:

        Only the owner of the mailslot can delete it. That means the PDB
        of this process must equal the PDB of the process which created
        the mailslot (DosMakeMailslot)

Arguments:

    None. All arguments are extracted from 16-bit context descriptor

Return Value:

    None. Returns values in VDM Ax and Flags registers

--*/

{
    WORD    Handle16, DosPdb;
    PVR_MAILSLOT_INFO   ptr;

    //
    // The redir passes us the CurrentPDB in ax
    //

    DosPdb = getAX();
    Handle16 = getBX();

#if DBG
    IF_DEBUG(MAILSLOT) {
        DbgPrint("VrDeleteMailslot(Handle=%#04x, PDB=%#04x)\n", Handle16, DosPdb);
//    VR_BREAKPOINT();
    }
#endif

    if (!(ptr = VrpMapMailslotHandle16(Handle16))) {
        SET_ERROR(ERROR_INVALID_HANDLE);
    } else {
        if (ptr->DosPdb != DosPdb) {
            SET_ERROR(ERROR_INVALID_HANDLE);
        } else {
            if (!CloseHandle(ptr->Handle32)) {
                SET_ERROR(VrpMapLastError());
            } else {

                //
                // phew! succeeded in deleting the mailslot. Unlink and free
                // the VR_MAILSLOT_INFO structure and de-allocate the 16-bit
                // handle
                //

                VrpUnlinkMailslotStructure(Handle16);
                VrpFreeHandle16(Handle16);

                //
                // Return some info in various registers for DOS
                //

                setES(ptr->BufferAddress.Selector);
                setDI(ptr->BufferAddress.Offset);
                setDX(ptr->Selector);

                //
                // now repatriate the structure
                //

                VrpFreeMailslotStructure(ptr);

                //
                // 'return' success indication
                //

                setCF(0);
            }
        }
    }
}


VOID
VrGetMailslotInfo(
    VOID
    )

/*++

Routine Description:

    Performs DosMailslotInfo request on behalf of VDM redir

Arguments:

    None. All arguments are extracted from 16-bit context descriptor

Return Value:

    None. Returns values in VDM Ax and Flags registers

--*/

{
    PVR_MAILSLOT_INFO   ptr;
    DWORD   MaxMessageSize, NextSize, MessageCount;
    BOOL    Ok;

#if DBG
    IF_DEBUG(MAILSLOT) {
        DbgPrint("VrGetMailslotInfo(Handle=%#04x)\n", getBX());
//    VR_BREAKPOINT();
    }
#endif

    if ((ptr = VrpMapMailslotHandle16(getBX())) == NULL) {
        SET_ERROR(ERROR_INVALID_HANDLE);
    } else {
        Ok = GetMailslotInfo(ptr->Handle32,
                                &MaxMessageSize,
                                &NextSize,
                                &MessageCount,
                                NULL            // lpReadTimeout
                                );
        if (!Ok) {
            SET_ERROR(VrpMapLastError());
        } else {

            //
            // fill in the VDM registers with the required info
            //

            setAX((WORD)MaxMessageSize);
            setBX((WORD)MaxMessageSize);
            if (NextSize == MAILSLOT_NO_MESSAGE) {
                setCX(0);
            } else {
                setCX((WORD)NextSize);
            }

            //
            // we don't support priorities, just return 0
            //

            setDX(0);
            setSI((WORD)MessageCount);
            setCF(0);
        }
    }
}


VOID
VrMakeMailslot(
    VOID
    )

/*++

Routine Description:

    Performs DosMakeMailslot request on behalf of VDM redir. This routine
    creates a local mailslot. If the mailslot name argument designates a
    remote mailslot name then this call will fail

Arguments:

    None. All arguments are extracted from 16-bit context descriptor

Return Value:

    None. Returns values in VDM Ax and Flags registers

--*/

{
    PVR_MAILSLOT_INFO   ptr;
    WORD    Handle16;
    HANDLE  Handle32;
    DWORD   NameLength;
    LPSTR   lpName;
    CHAR    LocalMailslot[LOCAL_MAILSLOT_NAMELEN+1];
    BOOL    Ok;


#if DBG
    IF_DEBUG(MAILSLOT) {
        DbgPrint("VrMakeMailslot\n");
//    VR_BREAKPOINT();
    }
#endif

    //
    // grab the next 16-bit handle value. This pre-allocates the handle. If we
    // cannot allocate a handle return a path not found error. If we should
    // fail anywhere along the line after this we must free up the handle
    //

    if ((Handle16 = VrpAllocateHandle16()) == 0) {
        SET_ERROR(ERROR_PATH_NOT_FOUND);    // all handles used!
        return;
    }

    //
    // get the pointer to the mailslot name from the VDM registers then
    // compute the significant length for the name
    //

    lpName = LPSTR_FROM_WORDS(getDS(), getSI());
    NameLength = strlen(lpName);

#if DBG
    IF_DEBUG(MAILSLOT) {
        DbgPrint("VrMakeMailslot: lpName=%s\n", lpName);
    }
#endif

    //
    // if the name length is less than the prefix length (\MAILSLOT\) may as
    // well return an invalid name error here - can't be proper mailslot name
    //

    if (NameLength <= MAILSLOT_PREFIX_LENGTH) {
        SET_ERROR(ERROR_PATH_NOT_FOUND);
        VrpFreeHandle16(Handle16);
        return;
    }

    //
    // NameLength is length of local mailslot name after \MAILSLOT\. We
    // only store this info if the mailslot actually turns out to be
    // local
    //

    NameLength -= MAILSLOT_PREFIX_LENGTH;

    //
    // grab a structure in which to store the info. If we can't get one(!)
    // return a path not found error (Do we have a better one that the app
    // might be expecting?). We need a structure large enough to hold the
    // significant part of the mailslot name too
    //

    if ((ptr = VrpAllocateMailslotStructure(NameLength)) == NULL) {
        SET_ERROR(ERROR_PATH_NOT_FOUND);    // mon dieu! sacre fromage! etc...
        VrpFreeHandle16(Handle16);
        return;
    }

    //
    // convert the DOS namespace mailslot name to a local mailslot name
    // (\MAILSLOT\name => \\.\MAILSLOT\name)
    //

    VrpMakeLocalMailslotName(LocalMailslot, lpName);

    //
    // create the mailslot. If this fails free up the structure and handle
    // already allocated. Note: at this point we may have a proper mailslot
    // name or we could have any old garbage. We trust that CreateMailslot
    // will sort the wheat from the oatbran
    //

#if DBG
    IF_DEBUG(MAILSLOT) {
        DbgPrint("Before CreateMailslot: Name=%s, MsgSize=%d, MslotSize=%d\n",
                 LocalMailslot,
                 (DWORD)getBX(),
                 (DWORD)getCX()
                 );
    }
#endif

    Handle32 = CreateMailslot(LocalMailslot,
                                (DWORD)getBX(),     // nMaxMessageSize
                                0,                  // lReadTimeout
                                NULL                // security descriptor
                                );
    if (Handle32 == HANDLE_FUNCTION_FAILED) {
        SET_ERROR(VrpMapLastError());

#if DBG
    IF_DEBUG(MAILSLOT) {
        DbgPrint("Error: CreateMailslot failed: GetLastError()=%d\n",
                 GetLastError()
                 );
    }
#endif

        VrpFreeMailslotStructure(ptr);
        VrpFreeHandle16(Handle16);
    } else {

#if DBG
        IF_DEBUG(MAILSLOT) {
            DbgPrint("VrMakeMailslot: Handle32=%#08x\n", Handle32);
        }
#endif

        //
        // mailslot created - fill in the VR_MAILSLOT_INFO structure -
        // containing mailslot info for Dos app - and link it into the
        // list of structures. Return an arbitrary (but unique!) 16-bit
        // handle
        //

        ptr->DosPdb = getAX();
        ptr->Handle16 = Handle16;
        ptr->Handle32 = Handle32;
        ptr->BufferAddress.Offset = getDI();
        ptr->BufferAddress.Selector = getES();
        ptr->Selector = getDX();    // prot mode selector for Win3

        //
        // find the true message size from the info API
        //

        Ok = GetMailslotInfo(Handle32,
                                &ptr->MessageSize,
                                NULL,           // lpNextSize
                                NULL,           // lpMessageCount
                                NULL            // lpReadTimeout
                                );
        if (!Ok) {

#if DBG
            IF_DEBUG(MAILSLOT) {
                DbgPrint("Error: VrMakeMailslot: GetMailslotInfo(%#08x) failed!\n",
                         Handle32
                         );
            }
#endif

            ptr->MessageSize = getCX();
        }

        //
        // copy the name of the mailslot after \MAILSLOT\ to the structure.
        // We compare this when a mailslot write is requested (because
        // DosWriteMailslot passes in a name; we have to write locally
        // using a handle, so we must convert the name of a local mailslot
        // to an already open handle). Check NameLength first before doing
        // strcmp
        //

        ptr->NameLength = NameLength;
        strcpy(ptr->Name, lpName + MAILSLOT_PREFIX_LENGTH);
        VrpLinkMailslotStructure(ptr);
        setAX(Handle16);
        setCF(0);
    }
}


VOID
VrPeekMailslot(
    VOID
    )

/*++

Routine Description:

    Performs DosPeekMailslot request on behalf of VDM redir.

    Note: we are not supporting Peeks of NT mailslots (the Win32 Mailslot API
    does not support mailslot peek). This routine is left here as a place
    holder should we want to descend to the NT level to implement mailslots
    (which do allow peeks)

Arguments:

    None. All arguments are extracted from 16-bit context descriptor

Return Value:

    None. Returns values in VDM Ax and Flags registers

--*/

{
#if DBG
    IF_DEBUG(MAILSLOT) {
        DbgPrint("Error: file %s line %d: VrPeekMailslot unsupported function\n",
                 __FILE__,
                 __LINE__
                 );
    }
#endif

    //
    // return not supported error instead of ERROR_INVALID_FUNCTION
    //

    SET_ERROR(ERROR_NOT_SUPPORTED);
}


VOID
VrReadMailslot(
    VOID
    )

/*++

Routine Description:

    Performs DosReadMailslot request on behalf of VDM redir

Arguments:

    None. All arguments are extracted from 16-bit context descriptor

Return Value:

    None. Returns values in VDM Ax and Flags registers

--*/

{
    PVR_MAILSLOT_INFO   ptr;
    HANDLE  Handle;
    DWORD   BytesRead;
    DWORD   NextSize;
    BOOL    Ok;

#if DBG
    IF_DEBUG(MAILSLOT) {
        DbgPrint("VrReadMailslot(Handle=%#04x)\n", getBX());
//    VR_BREAKPOINT();
    }
#endif

    if ((ptr = VrpMapMailslotHandle16(getBX())) == NULL) {
        SET_ERROR(ERROR_INVALID_HANDLE);
    } else {

        //
        // the NT API won't allow us to specify the read timeout on each read
        // call, so we have to change it with SetMailslotInfo before we can
        // do the read
        //

        Handle = ptr->Handle32;
        if (!SetMailslotInfo(Handle, MAKE_DWORD(getDX(), getCX()))) {
            SET_ERROR(VrpMapLastError());
        } else {

#if DBG
            IF_DEBUG(MAILSLOT) {
                DbgPrint("VrReadMailslot: reading Handle=%#08x\n", Handle);
            }
#endif

            Ok = ReadFile(Handle,
                            POINTER_FROM_WORDS(getES(), getDI()),
                            ptr->MessageSize,
                            &BytesRead,
                            NULL            // not overlapped
                            );
            if (!Ok) {
                SET_ERROR(VrpMapLastError());
            } else {

#if DBG
                IF_DEBUG(MAILSLOT) {
                    DbgPrint("VrReadMailslot: read %d bytes @ %#08x. MessageSize=%d\n",
                             BytesRead,
                             POINTER_FROM_WORDS(getES(), getDI()),
                             ptr->MessageSize
                             );
                }
#endif

                setAX((WORD)BytesRead);

                //
                // we need to return also the NextSize and NextPriority info
                //

                NextSize = MAILSLOT_NO_MESSAGE;
                Ok = GetMailslotInfo(Handle,
                                        NULL,           // lpMaxMessageSize
                                        &NextSize,
                                        NULL,           // lpMessageCount
                                        NULL            // lpReadTimeout
                                        );
                if (NextSize == MAILSLOT_NO_MESSAGE) {
                    setCX(0);
                } else {
                    setCX((WORD)NextSize);
                }

#if DBG
                IF_DEBUG(MAILSLOT) {
                    DbgPrint("VrReadMailslot: NextSize=%d\n", NextSize);
                }
#endif

                //
                // we don't support priorities, just return 0
                //

                setDX(0);
                setCF(0);
            }
        }
    }
}


VOID
VrWriteMailslot(
    VOID
    )

/*++

Routine Description:

    Performs DosWriteMailslot request on behalf of VDM redir

Arguments:

    None. All arguments are extracted from 16-bit context descriptor

Return Value:

    None. Returns values in VDM Ax and Flags registers

--*/

{
    LPSTR   Name;
    HANDLE  Handle;
    BOOL    Ok;
    DWORD   BytesWritten;
    CHAR    LocalMailslotName[LOCAL_MAILSLOT_NAMELEN+1];
    struct  DosWriteMailslotStruct* StructurePointer;

    //
    // search for the local mailslot based on the name. If not found assume
    // it is a remote handle and try to open it. Return failure if cannot
    // open
    //

    Name = LPSTR_FROM_WORDS(getDS(), getSI());

#if DBG
    IF_DEBUG(MAILSLOT) {
        DbgPrint("VrWriteMailslot(%s)\n", Name);
//    VR_BREAKPOINT();
    }
#endif

    if (!VrpIsMailslotName(Name)) {

#if DBG
        IF_DEBUG(MAILSLOT) {
            DbgPrint("Error: VrWriteMailslot: %s is not a mailslot\n", Name);
        }
#endif

        SET_ERROR(ERROR_PATH_NOT_FOUND);
    }
    if (!IS_ASCII_PATH_SEPARATOR(Name[1])) {
        strcpy(LocalMailslotName, LOCAL_MAILSLOT_PREFIX);
        strcat(LocalMailslotName, Name);
        Name = LocalMailslotName;
    }

    Handle = CreateFile(Name,
                        GENERIC_WRITE,
                        FILE_SHARE_WRITE | FILE_SHARE_READ,
                        NULL,               // lpSecurityAttributes
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL                // hTemplateFile
                        );
    if (Handle == HANDLE_FUNCTION_FAILED) {
        SET_ERROR(VrpMapLastError());

#if DBG
        IF_DEBUG(MAILSLOT) {
            DbgPrint("Error: VrWriteMailslot: CreateFile failed:%d\n", GetLastError());
        }
#endif

    } else {

        //
        // we have a handle to an open mailslot - either local or remote. Get
        // the caller's timeout and buffer pointer from the
        // DosWriteMailslotStruct at es:di
        //

        StructurePointer = (struct DosWriteMailslotStruct*)
                                POINTER_FROM_WORDS(getES(), getDI());

        Ok = SetMailslotInfo(Handle, READ_DWORD(&StructurePointer->DWMS_Timeout));

#if DBG
        IF_DEBUG(MAILSLOT) {
            DbgPrint("VrWriteMailslot: setting timeout to %d returns %d\n",
                     READ_DWORD(&StructurePointer->DWMS_Timeout),
                     Ok
                     );
        }
        if (!Ok) {
            DbgPrint("Timeout error=%d\n", GetLastError());
        }
#endif

        Ok = WriteFile(Handle,
                        READ_FAR_POINTER(&StructurePointer->DWMS_Buffer),
                        (DWORD)getCX(),
                        &BytesWritten,
                        NULL            // lpOverlapped
                        );
        if (!Ok) {
            SET_ERROR(VrpMapLastError());

#if DBG
            IF_DEBUG(MAILSLOT) {
                DbgPrint("Error: VrWriteMailslot: WriteFile failed:%d\n", GetLastError());
            }
#endif

        } else {

#if DBG
            IF_DEBUG(MAILSLOT) {
                DbgPrint("VrWriteMailslot: %d bytes written from %#08x\n",
                         BytesWritten,
                         READ_FAR_POINTER(&StructurePointer->DWMS_Buffer)
                         );
            }
#endif

            setCF(0);
        }
        CloseHandle(Handle);
    }
}


VOID
VrTerminateMailslots(
    IN WORD DosPdb
    )

/*++

Routine Description:

    If a Dos app created some mailslots and then terminates, then we need to
    delete the mailslots on its behalf. The main reason is that Dos process
    termination cleanup is limited mainly to file handles. Mailslot handles
    are not part of the file handle set so don't get closed for a terminating
    app. Control is passed here via the redir receiving a NetResetEnvironment
    call when Dos decides the app is closing. The redir BOPs here and we
    clean up the mailslot mess

    Assumes single-threadedness

Arguments:

    DosPdb  - 16-bit (segment) identifier of terminating DOS process

Return Value:

    None. Returns values in VDM Ax and Flags registers

--*/

{
#if DBG
    IF_DEBUG(MAILSLOT) {
        DbgPrint("VrTerminateMailslots(%04x)\n", DosPdb);
    }
#endif

    VrpRemoveProcessMailslots(DosPdb);
}


//
// private utilities
//

PRIVATE
BOOL
VrpIsMailslotName(
    IN LPSTR Name
    )

/*++

Routine Description:

    Checks if a string designates a mailslot. As criteria for the decision
    we use:

        \\computername\MAILSLOT\...
        \MAILSLOT\...

Arguments:

    Name    - to check for (Dos) mailslot syntax

Return Value:

    BOOL
        TRUE    - Name refers to (local or remote) mailslot
        FALSE   - Name doesn't look like mailslot name

--*/

{
    int     CharCount;

#if DBG
    LPSTR   OriginalName = Name;
#endif

    if (IS_ASCII_PATH_SEPARATOR(*Name)) {
        ++Name;
        if (IS_ASCII_PATH_SEPARATOR(*Name)) {
            ++Name;
            CharCount = 0;
            while (*Name && !IS_ASCII_PATH_SEPARATOR(*Name)) {
                ++Name;
                ++CharCount;
            }
            if (!CharCount || !*Name) {

                //
                // Name is \\ or \\\ or just \\name, none of which I understand,
                // so its not a valid mailslot name - fail it
                //

#if DBG
                IF_DEBUG(MAILSLOT) {
                    DbgPrint("VrpIsMailslotName - returning FALSE for %s\n", OriginalName);
                }
#endif

                return FALSE;
            }
            ++Name;
        }

        //
        // We are at <something> (after \ or \\<name>\). Check if <something>
        // is [Mm][Aa][Ii][Ll][Ss][Ll][Oo][Tt][\\/]
        //

        if (!_strnicmp(Name, "MAILSLOT", 8)) {
            Name += 8;
            if (IS_ASCII_PATH_SEPARATOR(*Name)) {

#if DBG
                IF_DEBUG(MAILSLOT) {
                    DbgPrint("VrpIsMailslotName - returning TRUE for %s\n", OriginalName);
                }
#endif

                return TRUE;
            }
        }
    }

#if DBG
    IF_DEBUG(MAILSLOT) {
        DbgPrint("VrpIsMailslotName - returning FALSE for %s\n", OriginalName);
    }
#endif

    return FALSE;
}


PRIVATE
VOID
VrpMakeLocalMailslotName(
    IN LPSTR lpBuffer,
    IN LPSTR lpName
    )

/*++

Routine Description:

    Converts a local DOS mailslot name of the form \MAILSLOT\<name> to a local
    NT/Win32 mailslot name of the form \\.\MAILSLOT\<name>

Arguments:

    lpBuffer    - pointer to ASCIZ buffer where local NT mailslot name will
                  be returned
    lpName      - pointer to ASCIZ Dos mailslot name

    NOTE: It is assumed that the buffer @ lpBuffer is large enough to hold the
    composite name and that Unicode support (or conversion) is NOT REQUIRED
    since we are supporting Dos which will only use ASCIZ (or at worst DBCS)
    strings

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    if (!_strnicmp(lpName, MAILSLOT_PREFIX, MAILSLOT_PREFIX_LENGTH)) {
        strcpy(lpBuffer, LOCAL_MAILSLOT_PREFIX);
        strcat(lpBuffer, lpName);
    }

#if DBG
    IF_DEBUG(MAILSLOT) {
        DbgPrint("VrpMakeLocalMailslotName: lpBuffer=%s\n", lpBuffer);
    }
#endif

}


//
// private mailslot list and list manipulators
//

PRIVATE
PVR_MAILSLOT_INFO   MailslotInfoList    = NULL;

PRIVATE
PVR_MAILSLOT_INFO   LastMailslotInfo    = NULL;



PRIVATE
VOID
VrpLinkMailslotStructure(
    IN PVR_MAILSLOT_INFO MailslotInfo
    )

/*++

Routine Description:

    Adds a VR_MAILSLOT_INFO structure to the end of MailslotInfoList. Points
    LastMailslotInfo at this structure

    Notes:

        Assumes that if LastMailslotInfo is NULL then there is nothing in
        the list (ie MailslotInfoList is also NULL)

Arguments:

    MailslotInfo    - pointer to VR_MAILSLOT_INFO stucture to add

Return Value:

    None.

--*/

{
    if (!LastMailslotInfo) {
        MailslotInfoList = MailslotInfo;
    } else {
        LastMailslotInfo->Next = MailslotInfo;
    }
    LastMailslotInfo = MailslotInfo;
    MailslotInfo->Next = NULL;
}


PRIVATE
PVR_MAILSLOT_INFO
VrpUnlinkMailslotStructure(
    IN WORD Handle16
    )

/*++

Routine Description:

    Removes a VR_MAILSLOT_INFO structure from the list at MailslotInfoList.
    The structure to remove is identified by the 32-bit handle

Arguments:

    Handle16    - 16-bit handle of open mailslot to search for

Return Value:

    PVR_MAILSLOT_INFO
        Success - pointer to removed VR_MAILSLOT_INFO structure
        Failure - NULL

--*/

{
    PVR_MAILSLOT_INFO   ptr, previous = NULL;

    for (ptr = MailslotInfoList; ptr; ) {
        if (ptr->Handle16 == Handle16) {
            if (!previous) {
                MailslotInfoList = ptr->Next;
            } else {
                previous->Next = ptr->Next;
            }
            if (LastMailslotInfo == ptr) {
                LastMailslotInfo = previous;
            }
            break;
        } else {
            previous = ptr;
            ptr = ptr->Next;
        }
    }

#if DBG
    IF_DEBUG(MAILSLOT) {
        if (ptr == NULL) {
            DbgPrint("Error: VrpUnlinkMailslotStructure: can't find mailslot. Handle=%#04x\n",
                     Handle16
                     );
        } else {
            DbgPrint("VrpUnlinkMailslotStructure: removed structure %#08x, handle=%d\n",
                     ptr,
                     Handle16
                     );
        }
    }
#endif

    return ptr;
}


PRIVATE
PVR_MAILSLOT_INFO
VrpMapMailslotHandle16(
    IN WORD Handle16
    )

/*++

Routine Description:

    Searches the list of VR_MAILSLOT_INFO structures looking for the one
    containing Handle16. If found, returns pointer to structure else NULL

    Notes:

        This routine assumes that Handle16 is unique and >1 mailslot structure
        cannot simultaneously exist with this handle

Arguments:

    Handle16    - Unique 16-bit handle to search for

Return Value:

    PVR_MAILSLOT_INFO
        Success - pointer to located structure
        Failure - NULL
--*/

{
    PVR_MAILSLOT_INFO   ptr;

    for (ptr = MailslotInfoList; ptr; ptr = ptr->Next) {
        if (ptr->Handle16 == Handle16) {
            break;
        }
    }

#if DBG
    IF_DEBUG(MAILSLOT) {
        if (ptr == NULL) {
            DbgPrint("Error: VrpMapMailslotHandle16: can't find mailslot. Handle=%#04x\n",
                     Handle16
                     );
        } else {
            DbgPrint("VrpMapMailslotHandle16: found handle %d, mailslot=%s\n",
                     Handle16,
                     ptr->Name
                     );
        }
    }
#endif

    return ptr;
}


PRIVATE
PVR_MAILSLOT_INFO
VrpMapMailslotName(
    IN LPSTR Name
    )

/*++

Routine Description:

    Searches for a VR_MAILSLOT_INFO structure in MailslotInfoList by name

Arguments:

    Name    - of mailslot to search for. Full name, including \MAILSLOT\

Return Value:

    PVR_MAILSLOT_INFO
        Success - pointer to structure containing Name
        Failure - NULL

--*/

{
    PVR_MAILSLOT_INFO   ptr;
    DWORD   NameLength;

    NameLength = strlen(Name) - MAILSLOT_PREFIX_LENGTH;
    for (ptr = MailslotInfoList; ptr; ptr = ptr->Next) {
        if (ptr->NameLength == NameLength) {
            if (!_stricmp(ptr->Name, Name)) {
                break;
            }
        }
    }

#if DBG
    IF_DEBUG(MAILSLOT) {
        if (ptr == NULL) {
            DbgPrint("Error: VrpMapMailslotName: can't find mailslot. Name=%s\n",
                     Name
                     );
        } else {
            DbgPrint("VrpMapMailslotName: found %s\n", Name);
        }
    }
#endif

    return ptr;
}


PRIVATE
VOID
VrpRemoveProcessMailslots(
    IN WORD DosPdb
    )

/*++

Routine Description:

    Searches for a VR_MAILSLOT_INFO structure in MailslotInfoList by PDB
    then deletes it if found.

    Unfortunately, this routine is munged from a couple others

Arguments:

    DosPdb  - PID of terminating Dos app. Kill all mailslots belonging to
              this app

Return Value:

    None.

--*/

{
    PVR_MAILSLOT_INFO   ptr, previous = NULL, next;

#if DBG
    BOOL    Ok;

    IF_DEBUG(MAILSLOT) {
        DbgPrint("VrpRemoveProcessMailslots\n");
    }
#endif

    //
    // usual type of thing - grovel through list of mailslot structures, if
    // one belongs to our dos process then remove it from the list, close
    // the mailslot and free the structure
    //

    for (ptr = MailslotInfoList; ptr; ) {
        if (ptr->DosPdb == DosPdb) {

#if DBG
            IF_DEBUG(MAILSLOT) {
                DbgPrint("VrpRemoveProcessMailslots: Freeing struct @%#08x. Handle=%d, Pdb=%04x\n",
                         ptr,
                         ptr->Handle16,
                         ptr->DosPdb
                         );
            }

            Ok =
#endif

            CloseHandle(ptr->Handle32);

#if DBG
            if (!Ok) {
                IF_DEBUG(MAILSLOT) {
                    DbgPrint("Error: VrpRemoveProcessMailslots: CloseHandle(%#08x) "
                             "returns %u\n",
                             ptr->Handle32,
                             GetLastError()
                             );
                }
            }
#endif

            //
            // remove mailslot structure from list
            //

            if (!previous) {
                MailslotInfoList = ptr->Next;
            } else {
                previous->Next = ptr->Next;
            }
            if (LastMailslotInfo == ptr) {
                LastMailslotInfo = previous;
            }

            //
            // free up the 16-bit handle allocation
            //

            VrpFreeHandle16(ptr->Handle16);

            //
            // and repatriate the structure
            //

            next = ptr->Next;
            VrpFreeMailslotStructure(ptr);
            ptr = next;
        } else {
            previous = ptr;
            ptr = ptr->Next;
        }
    }
}


//
// 16-bit handle allocators
//

PRIVATE
DWORD   Handle16Bitmap[MAX_16BIT_HANDLES/BITSIN(DWORD)];

PRIVATE
WORD
VrpAllocateHandle16(
    VOID
    )

/*++

Routine Description:

    Allocates the next free 16-bit handle. This is based on a bitmap: the
    ordinal number of the next available 0 bit in the map indicates the next
    16-bit handle value.

    Notes:

        The 16-bit handle is an arbitrary but unique number. We don't expect
        there to be too many TSR mailslots and 1 or 2 DWORDs should suffice
        even the most demanding local mailslot user.

        The handles are returned starting at 1. Therefore bit 0 in the map
        corresponds to handle 1; bit 0 in Handle16Bitmap[1] corresponds to
        handle 33, etc.

        Nothing assumed about byte order, only bits in DWORD (which is
        universal, methinks)

Arguments:

    None.

Return Value:

    WORD
        Success - 16-bit handle value in range 1 <= Handle <= 32
        Failure - 0

--*/

{
    int     i;
    DWORD   map;
    WORD    Handle16 = 1;

    //
    // this 'kind of' assumes that the bitmap is stored as DWORDs. Its
    // actually more explicit, so don't change the type or MAX_16BIT_HANDLES
    // without checking this code first
    //

    for (i=0; i<sizeof(Handle16Bitmap)/sizeof(Handle16Bitmap[0]); ++i) {
        map = Handle16Bitmap[i];

        //
        // if this entry in the bitmap is already full, skip to the next one
        // (if there is one, that is)
        //

        if (map == -1) {
            Handle16 += BITSIN(DWORD);
            continue;
        } else {
            int j;

            //
            // use BFI method to find next available slot
            //

            for (j=1, Handle16=1; map & j; ++Handle16, j <<= 1);
            Handle16Bitmap[i] |= j;

#if DBG
            IF_DEBUG(MAILSLOT) {
                DbgPrint("VrpAllocateHandle16: returning handle %d, map=%#08x, i=%d\n",
                         Handle16,
                         Handle16Bitmap[i],
                         i
                         );
            }
#endif

            return Handle16;
        }
    }

    //
    // no free handles found. Since handles start at 1, use 0 to indicate error
    //

#if DBG
    IF_DEBUG(MAILSLOT) {
        DbgPrint("Error: VrpAllocateHandle16: can't allocate new handle\n");
        DbgBreakPoint();
    }
#endif

    return 0;
}


PRIVATE
VOID
VrpFreeHandle16(
    IN WORD Handle16
    )

/*++

Routine Description:

    Free a 16-bit handle. Reset the corresponding bit in the bitmap

    Notes:

        This routine assumes that the Handle16 parameter is a valid 16-bit
        Handle value, as generated by VrpAllocate16BitHandle

Arguments:

    Handle16    - number of bit to reset

Return Value:

    None.

--*/

{
    //
    // remember: we allocated the handle value as the next free bit + 1, so
    // we started the handles at 1, not 0
    //

    --Handle16;

#if DBG
    IF_DEBUG(MAILSLOT) {
        if (Handle16/BITSIN(DWORD) > sizeof(Handle16Bitmap)/sizeof(Handle16Bitmap[0])) {
            DbgPrint("Error: VrpFreeHandle16: out of range handle: %d\n", Handle16);
            DbgBreakPoint();
        }
    }
#endif

    Handle16Bitmap[Handle16/BITSIN(DWORD)] &= ~(1 << Handle16 % BITSIN(DWORD));

#if DBG
    IF_DEBUG(MAILSLOT) {
        DbgPrint("VrpFreeHandle16: map=%#08x\n", Handle16Bitmap[Handle16/BITSIN(DWORD)]);
    }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\vrnetb.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrnetb.c

Abstract:

    Contains Netbios function handlers for Vdm Int5c support. This module
    contains the following Vr (VdmRedir) routines:

        VrNetbios5c
        VrNetbios5cInterrupt

    Private (Vrp) routines:
        Netbios32Post
        ResetLana
        VrNetbios5cInitialize
        IsPmNcbAtQueueHead

Author:

    Colin Watson (colinw) 09-Dec-1991

Environment:

    Any 32-bit flat address space

Notes:

Revision History:

    09-Dec-1991 ColinW
        Created

--*/

#include <nt.h>
#include <ntrtl.h>      // ASSERT, DbgPrint
#include <nturtl.h>
#include <windows.h>
#include <softpc.h>     // x86 virtual machine definitions
#include <vrdlctab.h>
#include <vdmredir.h>   // common Vdm Redir stuff
#include <vrinit.h>     // VrQueueCompletionHandler
#include <smbgtpt.h>    // Macros for misaligned data
#include <dlcapi.h>     // Official DLC API definition
#include <ntdddlc.h>    // IOCTL commands
#include <dlcio.h>      // Internal IOCTL API interface structures
#include <vrdlc.h>      // DLC prototypes
#include <nb30.h>       // NCB
#include <netb.h>       // NCBW
#include <mvdm.h>       // STOREWORD
#include "vrdebug.h"
#define BOOL            // kludge for mips build
#include <insignia.h>   // Required for ica.h
#include <xt.h>         // Required for ica.h
#include <ica.h>
#include <vrica.h>      // call_ica_hw_interrupt

CRITICAL_SECTION PostCrit;      //  protects PostWorkQueue.
LIST_ENTRY PostWorkQueue;       //  queue to 16 bit code.

BYTE LanaReset[MAX_LANA+1];

//
// private routine prototypes
//


VOID
Netbios32Post(
    PNCB pncb
    );

UCHAR
ResetLana(
    UCHAR Adapter
    );

//
// Vdm Netbios support routines
//

VOID
VrNetbios5c(
    VOID
    )
/*++

Routine Description:

    Creates a copy of the NCB to submit to Netbios.
    Performs address translation from the registers provided by the 16 bit
    application and translates all the addresses in the NCB.
    Using a copy of the NCB also solves alignment problems.

Arguments:

    None. All arguments are extracted from 16-bit context descriptor

Return Value:

    None. Returns values in VDM Ax register

--*/

{
    PNCB pncb;
    PNCBW pncbw;
    BOOLEAN protectMode = (BOOLEAN)(getMSW() & MSW_PE);
    BOOLEAN isAsyncCommand;
    UCHAR command;
    USHORT es = getES();
    USHORT bx = getBX();

    //
    // es:bx is the 16 bit address of the NCB. Can be in real- or protect-mode
    // 16-bit memory
    //

    pncb = (PNCB)CONVERT_ADDRESS(es, bx, sizeof(NCB), protectMode);
    command = pncb->ncb_command;
    isAsyncCommand = command & ASYNCH;
    command &= ~ASYNCH;

    pncbw = RtlAllocateHeap(
        RtlProcessHeap(), 0,
        sizeof(NCBW));

#if DBG
    IF_DEBUG(NETBIOS) {
        DBGPRINT("VrNetbios5c: NCB @ %04x:%04x Command=%02x pncbw=%08x\n",
                 es,
                 bx,
                 pncb->ncb_command,
                 pncbw
                 );
    }
#endif

    if ( pncbw == NULL ) {
        pncb->ncb_retcode = NRC_NORES;
        pncb->ncb_cmd_cplt = NRC_NORES;
        setAL( NRC_NORES );
        return;
    }

    //
    //  Do not need a valid lana number for an ncb enum. If the lana mumber is out
    //  of range let the driver handle it.
    //

    if ((command != NCBENUM) &&
        ( pncb->ncb_lana_num <= MAX_LANA ) &&
        ( LanaReset[pncb->ncb_lana_num] == FALSE )) {

        UCHAR result;

        //
        //  Do a reset on the applications behalf. Most dos applications assume that the
        //  redirector has reset the card already.
        //
        //  Use default sessions. If application wants more sessions then it must execute
        //  a reset itself. This will be very rare so executing this reset plus the
        //  applications will not be a significant overhead.
        //

        result = ResetLana(pncb->ncb_lana_num);

        if (result != NRC_GOODRET) {
            pncb->ncb_retcode = result;
            pncb->ncb_cmd_cplt = result;
            setAL( result );
            return;
        }
        LanaReset[pncb->ncb_lana_num] = TRUE;

    }

    //
    // safe to use RtlCopyMemory - 16-bit memory and process heap don't overlap
    //

    RtlCopyMemory(
        pncbw,
        pncb,
        sizeof(NCB));

    pncbw->ncb_event = 0;

    //  Fill in mvdm data fields
    pncbw->ncb_es = es;
    pncbw->ncb_bx = bx;
    pncbw->ncb_original_ncb = pncb;

    //  Update all 16 bit pointers to 32 bit pointers

    pncbw->ncb_buffer = CONVERT_ADDRESS((ULONG)pncbw->ncb_buffer >> 16,
                                        (ULONG)pncbw->ncb_buffer & 0x0ffff,
                                        pncbw->ncb_length
                                            ? pncbw->ncb_length
                                            : (command == NCBCANCEL)
                                                ? sizeof(NCB)
                                                : 0,
                                        protectMode
                                        );

    //
    // if this is a NCB.CANCEL, then the ncb_buffer field should point at the
    // NCB we are cancelling. We stored the address of the 32-bit NCB in the
    // reserved field of the original 16-bit NCB
    //

    if (command == NCBCANCEL) {
        pncbw->ncb_buffer = (PUCHAR)READ_DWORD(&((PNCB)pncbw->ncb_buffer)->ncb_reserve);
    } else if ((command == NCBCHAINSEND) || (command == NCBCHAINSENDNA)) {
        pncbw->cu.ncb_chain.ncb_buffer2 =
            CONVERT_ADDRESS(
                (ULONG)pncbw->cu.ncb_chain.ncb_buffer2 >> 16,
                (ULONG)pncbw->cu.ncb_chain.ncb_buffer2 & 0x0ffff,
                pncbw->cu.ncb_chain.ncb_length2,
                protectMode
                );
    } else if ( command == NCBRESET ) {

        //
        //  If it is a reset then modify the new NCB to the protect mode parameters
        //

        pncbw->cu.ncb_callname[0] = (pncb->ncb_lsn == 0) ?  6 : pncb->ncb_lsn;
        pncbw->cu.ncb_callname[1] = (pncb->ncb_num == 0) ? 12 : pncb->ncb_num;
        pncbw->cu.ncb_callname[2] = 16;
        pncbw->cu.ncb_callname[3] = 1;

        //
        // DOS always allocates resources on RESET: set ncb_lsn to 0 to indicate
        // this fact to Netbios (else it will free resources, causing us pain)
        //

        pncbw->ncb_lsn = 0;
    }

    //
    // we are about to submit the NCB. Store the address of the 32-bit structure
    // in the reserved field of the 16-bit structure for use in NCB.CANCEL
    //

    WRITE_DWORD(&pncb->ncb_reserve, pncbw);

    if ( !isAsyncCommand ) {
        setAL( Netbios( (PNCB)pncbw ) );
        //  Copy back the fields that might have changed during the call.
        STOREWORD(pncb->ncb_length, pncbw->ncb_length);
        if (( command == NCBLISTEN ) ||
            ( command == NCBDGRECV ) ||
            ( command == NCBDGRECVBC )) {
            RtlCopyMemory( pncb->ncb_callname, pncbw->cu.ncb_callname, NCBNAMSZ );
        }
        pncb->ncb_retcode = pncbw->ncb_retcode;
        pncb->ncb_lsn = pncbw->ncb_lsn;
        pncb->ncb_num = pncbw->ncb_num;
        pncb->ncb_cmd_cplt = pncbw->ncb_cmd_cplt;
        RtlFreeHeap( RtlProcessHeap(), 0, pncbw );
    } else {

        //
        // This is an asynchronous call. Netbios32Post will free pncbw
        // We also note which (virtual) processor mode was in effect when we
        // received the call. This is used later to determine who should handle
        // the completion - the real-mode handler, or the new protect-mode
        // version
        //

        pncbw->ProtectModeNcb = (DWORD)protectMode;
        pncbw->ncb_post = Netbios32Post;
        pncb->ncb_retcode = NRC_PENDING;
        pncb->ncb_cmd_cplt = NRC_PENDING;
        setAL( Netbios( (PNCB)pncbw ) );
    }

}


VOID
Netbios32Post(
    PNCB pncb
    )
/*++

Routine Description:

    This routine is called every time a 32 bit NCB completes. It examines the NCB.
    If the caller provided a POST routine then it queues the NCB to the 16 bit routine.

Arguments:

    PNCB pncb   -   Supplies a 32 bit pointer to the NCB

Return Value:

    None.

--*/

{
    PNCBW pncbw = (PNCBW) pncb;
    PNCB pdosNcb = pncbw->ncb_original_ncb;

#if DBG

    IF_DEBUG(NETBIOS) {
        DBGPRINT("Netbios32Post: NCB @ %04x:%04x Command=%02x ANR=%08x. pncbw @ %08x\n",
                 pncbw->ncb_es,
                 pncbw->ncb_bx,
                 pncbw->ncb_command,
                 READ_DWORD(&pdosNcb->ncb_post),
                 pncbw
                 );
    }

#endif

    if ( READ_DWORD(&pdosNcb->ncb_post) ) {

        //
        //  Pretend we have a network card on IRQL NETWORK_LINE. Queue the NCB
        //  completion to the NETWORK_LINE interrupt handler so that it will
        //  call the 16 bit post routine.
        //

        EnterCriticalSection( &PostCrit );
        InsertTailList( &PostWorkQueue, &pncbw->u.ncb_next );
        LeaveCriticalSection( &PostCrit );
        VrQueueCompletionHandler(VrNetbios5cInterrupt);
        VrRaiseInterrupt();
    } else {

        //
        //  Copy back the fields that might have changed during the call.
        //

        STOREWORD(pdosNcb->ncb_length, pncbw->ncb_length);
        if ((( pncbw->ncb_command & ~ASYNCH ) == NCBLISTEN ) ||
            (( pncbw->ncb_command & ~ASYNCH ) == NCBDGRECV ) ||
            (( pncbw->ncb_command & ~ASYNCH ) == NCBDGRECVBC )) {
            RtlCopyMemory( pdosNcb->ncb_callname, pncbw->cu.ncb_callname, NCBNAMSZ );
        }
        pdosNcb->ncb_retcode = pncbw->ncb_retcode;
        pdosNcb->ncb_lsn = pncbw->ncb_lsn;
        pdosNcb->ncb_num = pncbw->ncb_num;
        pdosNcb->ncb_cmd_cplt = pncbw->ncb_cmd_cplt;
        RtlFreeHeap( RtlProcessHeap(), 0, pncbw );
    }
}

VOID
VrNetbios5cInterrupt(
    VOID
    )
/*++

Routine Description:

    If there is a completed asynchronous DLC CCB then complete it else
    Retrieves an NCB from the PostWorkQueue and returns it to the 16 bit code
    to call the post routine specified by the application.

Arguments:

    None.

Return Value:

    None. Returns values in VDM Ax, Es and Bx registers.

--*/

{

#if DBG
    IF_DEBUG(NETBIOS) {
        DBGPRINT("Netbios5cInterrupt\n");
    }
#endif

    EnterCriticalSection( &PostCrit );

    if (!IsListEmpty(&PostWorkQueue)) {

        PLIST_ENTRY entry;
        PNCBW pncbw;
        PNCB pncb;

        entry = RemoveHeadList(&PostWorkQueue);

        LeaveCriticalSection( &PostCrit );

        pncbw = CONTAINING_RECORD( entry, NCBW, u.ncb_next );
        pncb = pncbw->ncb_original_ncb;

#if DBG
        IF_DEBUG(NETBIOS) {
            DBGPRINT("Netbios5cInterrupt returning pncbw: %lx, 16-bit NCB: %04x:%04x Command=%02x\n",
                     pncbw,
                     pncbw->ncb_es,
                     pncbw->ncb_bx,
                     pncbw->ncb_command
                     );
        }
#endif

        //  Copy back the fields that might have changed during the call.
        STOREWORD(pncb->ncb_length, pncbw->ncb_length);
        if ((( pncbw->ncb_command & ~ASYNCH ) == NCBLISTEN ) ||
            (( pncbw->ncb_command & ~ASYNCH ) == NCBDGRECV ) ||
            (( pncbw->ncb_command & ~ASYNCH ) == NCBDGRECVBC )) {
            RtlCopyMemory( pncb->ncb_callname, pncbw->cu.ncb_callname, NCBNAMSZ );
        }
        pncb->ncb_retcode = pncbw->ncb_retcode;
        pncb->ncb_lsn = pncbw->ncb_lsn;
        pncb->ncb_num = pncbw->ncb_num;
        pncb->ncb_cmd_cplt = pncbw->ncb_cmd_cplt;

        setES( pncbw->ncb_es );
        setBX( pncbw->ncb_bx );
        setAL(pncbw->ncb_retcode);

        //
        // use flags to indicate to hardware interrupt routine that there is
        // NetBios post processing to do
        //

        SET_CALLBACK_NETBIOS();

        RtlFreeHeap( RtlProcessHeap(), 0, pncbw );

    } else {
        LeaveCriticalSection( &PostCrit );

        //
        // use flags to indicate there is no post processing to do
        //

        SET_CALLBACK_NOTHING();
    }
}

UCHAR
ResetLana(
    UCHAR Adapter
    )
/*++

Routine Description:

    Reset the adapter on the applications behalf.

Arguments:

    UCHAR Adapter - Supplies the lana number to reset.

Return Value:

    Result of the reset.

--*/

{
    NCB ResetNcb;
    RtlZeroMemory( &ResetNcb, sizeof(NCB) );
    ResetNcb.ncb_command = NCBRESET;
    ResetNcb.ncb_lana_num = Adapter;
    ResetNcb.ncb_callname[0] = 64;
    ResetNcb.ncb_callname[1] = 128;
    ResetNcb.ncb_callname[2] = 16;
    ResetNcb.ncb_callname[3] = 1;
    Netbios( &ResetNcb );
    return ResetNcb.ncb_retcode;
}

VOID
VrNetbios5cInitialize(
    VOID
    )
/*++

Routine Description:

    Initialize the global structures used to return post routine calls back to the application.

Arguments:

    None.

Return Value:

    None.

--*/

{
    int index;
    InitializeCriticalSection( &PostCrit );
    InitializeListHead( &PostWorkQueue );
    for ( index = 0; index <= MAX_LANA ; index++ ) {
        LanaReset[index] = FALSE;
    }
}

BOOLEAN
IsPmNcbAtQueueHead(
    VOID
    )

/*++

Routine Description:

    Returns TRUE if the NCBW at the head of the PostWorkQueue originated in
    protect mode, else FALSE

Arguments:

    None.

Return Value:

    BOOLEAN
        TRUE    - head of queue represents protect mode NCB
        FALSE   - head of queue is real-mode NCB

--*/

{
    return (BOOLEAN)((CONTAINING_RECORD(PostWorkQueue.Flink, NCBW, u.ncb_next))->ProtectModeNcb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\vrnmpipe.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrnmpipe.c

Abstract:

    Contains Named Pipe function handlers for Vdm Redir support. This module
    contains the following Vr (VdmRedir) routines:

    Contents:
        VrGetNamedPipeInfo
        VrGetNamedPipeHandleState
        VrSetNamedPipeHandleState
        VrPeekNamedPipe
        VrTransactNamedPipe
        VrCallNamedPipe
        VrWaitNamedPipe
        VrNetHandleGetInfo
        VrNetHandleSetInfo
        VrReadWriteAsyncNmPipe
        VrNmPipeInterrupt
        VrTerminateNamedPipes
        VrCancelPipeIo

    There are a couple of extra routines which must be called on open and close.
    Because these routines (in Dos Emulator) are general purpose, our open
    and close routines will be called for every file open/handle close. We
    must check that the operation is being performed on a named pipe entity.
    The routines are:

        VrAddOpenNamedPipeInfo
        VrRemoveOpenNamedPipeInfo

    Because named pipes are now opened in overlapped I/O mode, in case an app
    wishes to perform an asynchronous read or write operation, we must provide
    our own read/write routines for synchronously reading a pipe. If we just
    left this to the standard read/write routines in DEM, they would return an
    error because the handles were opened with FLAG_FILE_OVERLAPPED and the
    operations are performed with the LPOVERLAPPED parameter set to NULL

        VrReadNamedPipe
        VrWriteNamedPipe

    A couple of helper routines which are callable from outside of this module:

        VrIsNamedPipeName
        VrIsNamedPipeHandle
        VrConvertLocalNtPipeName

    Private (Vrp) routines:

        VrpAsyncNmPipeThread
        VrpSnapshotEventList
        VrpSearchForRequestByEventHandle
        VrpCompleteAsyncRequest
        VrpQueueAsyncRequest
        VrpDequeueAsyncRequest
        VrpFindCompletedRequest
        VrpAddOpenNamedPipeInfo
        VrpGetOpenNamedPipeInfo
        VrpRemoveOpenNamedPipeInfo
        RememberPipeIo
        ForgetPipeIo

Author:

    Richard L Firth (rfirth) 10-Sep-1991

Environment:

    Any 32-bit flat address space

Notes:

    This module implements client-side named pipe support for the VDM process.
    Client-side named pipes are opened using the standard DOS open call (INT 21/
    ah=3dh) from a DOS app. The actual open is performed in the 32-bit context
    where a 32-bit handle is returned. This is put in the DOS context SFT and
    DOS returns an 8-bit J(ob) F(ile) N(umber) which the app then uses in other
    named pipe calls. The redir, which handles named pipe requests apart from
    open and close, must map the 8-bit JFN to the original 32-bit handle using
    a routine exported from DOS. The handle is then stored in BP:BX and control
    passed here.

    When an open succeeds, we add an OPEN_NAMED_PIPE_INFO structure to a list
    of structures. This maps the handle and name (for DosQNmPipeInfo). We don't
    expect to have very many of these structures at any one time, so they are
    singly linked and sequentially traversed using the handle as a key

    This code assumes that only one process at a time will be updating the list
    of structures and that any non-stack data items in this module will be
    replicated to all processes which use these functions (Ie the data is NOT
    shared)

Revision History:

    10-Sep-1991 RFirth
        Created

--*/

#include <nt.h>
#include <ntrtl.h>      // ASSERT, DbgPrint
#include <nturtl.h>
#include <windows.h>
#include <softpc.h>     // x86 virtual machine definitions
#include <vrdlctab.h>
#include <vdmredir.h>   // common Vdm Redir stuff
#include <vrinit.h>     // VrQueueCompletionHandler
#include "vrdebug.h"    // IF_DEBUG
#include "vrputil.h"    // private utility prototypes
//#include <os2def.h>
//#include <bsedos.h>     // PIPEINFO structure
#include <align.h>
#include <lmcons.h>     // LM20_PATHLEN
#include <lmerr.h>      // NERR_
#include <string.h>     // Dos still dealing with ASCII
#include <dossvc.h>     // PDEMEXTERR
#include <exterr.h>     // extended error info

//
// the following 2 #undef's required because without them, insignia.h gives
// errors (BOOL previously typedef'd) when compiled for MIPS
//

#undef BOOL
#undef NT_INCLUDED
#include <insignia.h>   // Insignia defines
#include <xt.h>         // half_word
#include <ica.h>        // ica_hw_interrupt
#include <idetect.h>    // WaitIfIdle
#include <vrica.h>      // call_ica_hw_interrupt
#include <vrnmpipe.h>   // routine prototypes

#include <stdio.h>

//
// manifests
//

//#define NAMED_PIPE_TIMEOUT  300000  // 5 minutes
#define NAMED_PIPE_TIMEOUT  INFINITE

//
// private data types
//

//
// OVERLAPPED_PIPE_IO - contains handle of thread issuing named pipe I/O request.
// If the app is later killed, we need to cancel any pending named pipe I/O
//

typedef struct _OVERLAPPED_PIPE_IO {
    struct _OVERLAPPED_PIPE_IO* Next;
    DWORD Thread;
    BOOL Cancelled;
    OVERLAPPED Overlapped;
} OVERLAPPED_PIPE_IO, *POVERLAPPED_PIPE_IO;


//
// private routine prototypes
//

#undef PRIVATE
#define PRIVATE /* static */            // actually, want to see routines in FREE build

PRIVATE
DWORD
VrpAsyncNmPipeThread(
    IN LPVOID Parameters
    );

PRIVATE
DWORD
VrpSnapshotEventList(
    OUT LPHANDLE pList
    );

PRIVATE
PDOS_ASYNC_NAMED_PIPE_INFO
VrpSearchForRequestByEventHandle(
    IN HANDLE EventHandle
    );

PRIVATE
VOID
VrpCompleteAsyncRequest(
    IN PDOS_ASYNC_NAMED_PIPE_INFO pAsyncInfo
    );

PRIVATE
VOID
VrpQueueAsyncRequest(
    IN PDOS_ASYNC_NAMED_PIPE_INFO pAsyncInfo
    );

PRIVATE
PDOS_ASYNC_NAMED_PIPE_INFO
VrpDequeueAsyncRequest(
    IN PDOS_ASYNC_NAMED_PIPE_INFO pAsyncInfo
    );

PRIVATE
PDOS_ASYNC_NAMED_PIPE_INFO
VrpFindCompletedRequest(
    VOID
    );

PRIVATE
BOOL
VrpAddOpenNamedPipeInfo(
    IN HANDLE Handle,
    IN LPSTR PipeName
    );

PRIVATE
POPEN_NAMED_PIPE_INFO
VrpGetOpenNamedPipeInfo(
    IN HANDLE Handle
    );

PRIVATE
BOOL
VrpRemoveOpenNamedPipeInfo(
    IN HANDLE Handle
    );

PRIVATE
VOID
RememberPipeIo(
    IN POVERLAPPED_PIPE_IO PipeIo
    );

PRIVATE
VOID
ForgetPipeIo(
    IN POVERLAPPED_PIPE_IO PipeIo
    );

#if DBG
VOID DumpOpenPipeList(VOID);
VOID DumpRequestQueue(VOID);
#endif

//
// global data
//

DWORD VrPeekNamedPipeTickCount;

//
// private data
//

CRITICAL_SECTION VrNamedPipeCancelCritSec;
POVERLAPPED_PIPE_IO PipeIoQueue = NULL;


//
// Vdm Redir Named Pipe support routines
//

VOID
VrGetNamedPipeInfo(
    VOID
    )

/*++

Routine Description:

    Performs GetNamedPipeInfo (DosQNmPipeInfo) request on behalf of VDM redir

Arguments:

    Function = 5F32h

    ENTRY   BP:BX = 32-bit Named Pipe handle
            CX = Buffer size
            DX = Info level
            DS:SI = Buffer

    EXIT    CF = 1
                AX = Error code

            CF = 0
                no error
                AX = undefined

Return Value:

    None. Returns values in VDM Ax and Flags registers

--*/

{
    HANDLE Handle;
    DWORD Flags, OutBufferSize, InBufferSize, MaxInstances, CurInstances, bufLen;
    PIPEINFO* PipeInfo;
    BOOL Ok;
    POPEN_NAMED_PIPE_INFO OpenNamedPipeInfo;

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrGetNamedPipeInfo(0x%08x, %d, %04x:%04x, %d)\n",
                 HANDLE_FROM_WORDS(getBP(), getBX()),
                 getDX(),
                 getDS(),
                 getSI(),
                 getCX()
                 );
    }
#endif

    //
    // bp:bx is 32-bit named pipe handle. Mapped from 8-bit handle in redir
    //

    Handle = HANDLE_FROM_WORDS(getBP(), getBX());

    //
    // we have to collect the info to put in the PIPEINFO structure from
    // various sources - we stored the name (& name length) in a
    // OPEN_NAMED_PIPE_INFO structure. The other stuff we get from
    // GetNamedPipeInfo and GetNamedPipeHandleState
    //

    OpenNamedPipeInfo = VrpGetOpenNamedPipeInfo(Handle);
    if (OpenNamedPipeInfo) {
        bufLen = getCX();
        if (bufLen >= sizeof(PIPEINFO)) {
            Ok =  GetNamedPipeInfo(Handle,
                                   &Flags,
                                   &OutBufferSize,
                                   &InBufferSize,
                                   &MaxInstances
                                   );
            if (Ok) {

                //
                // we are only interested in the current # instances of the
                // named pipe from this next call
                //

                Ok = GetNamedPipeHandleState(Handle,
                                             NULL,
                                             &CurInstances,
                                             NULL,
                                             NULL,
                                             NULL,
                                             0
                                             );
                if (Ok) {
                    PipeInfo = (PIPEINFO*)POINTER_FROM_WORDS(getDS(), getSI());
                    WRITE_WORD(&PipeInfo->cbOut, (OutBufferSize > 65535 ? 65535 : OutBufferSize));
                    WRITE_WORD(&PipeInfo->cbIn, (InBufferSize > 65535 ? 65535 : InBufferSize));
                    WRITE_BYTE(&PipeInfo->cbMaxInst, (MaxInstances > 255 ? 255 : MaxInstances));
                    WRITE_BYTE(&PipeInfo->cbCurInst, (CurInstances > 255 ? 255 : CurInstances));
                    WRITE_BYTE(&PipeInfo->cbName, OpenNamedPipeInfo->NameLength);

                    //
                    // copy name if enough space
                    //

                    if (bufLen - sizeof(PIPEINFO) >= OpenNamedPipeInfo->NameLength) {
                        strcpy(PipeInfo->szName, OpenNamedPipeInfo->Name);
                    }
                    setCF(0);
                } else {
                    SET_ERROR(VrpMapLastError());
                }
            } else {
                SET_ERROR(VrpMapLastError());
            }
        } else {
            SET_ERROR(ERROR_BUFFER_OVERFLOW);
        }
    } else {

#if DBG

        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrGetNamedPipeInfo: Error: can't map handle 0x%08x\n", Handle);
        }

#endif

        SET_ERROR(ERROR_INVALID_HANDLE);
    }

#if DBG
    IF_DEBUG(NAMEPIPE) {
        if (getCF()) {
            DbgPrint("VrGetNamedPipeInfo: returning ERROR: %d\n", getAX());
        } else {
            DbgPrint("VrGetNamedPipeInfo: returning OK. PIPEINFO:\n"
                     "cbOut     %04x\n"
                     "cbIn      %04x\n"
                     "cbMaxInst %02x\n"
                     "cbCurInst %02x\n"
                     "cbName    %02x\n"
                     "szName    %s\n",
                     READ_WORD(&PipeInfo->cbOut),
                     READ_WORD(&PipeInfo->cbIn),
                     READ_BYTE(&PipeInfo->cbMaxInst),
                     READ_BYTE(&PipeInfo->cbCurInst),
                     READ_BYTE(&PipeInfo->cbName),
                     READ_BYTE(&PipeInfo->szName)
                     );
        }
    }
#endif

}


VOID
VrGetNamedPipeHandleState(
    VOID
    )

/*++

Routine Description:

    Performs GetNamedPipeHandleState request on behalf of VDM redir

Arguments:

    Function = 5F33h

    ENTRY   BP:BX = 32-bit Named Pipe handle

    EXIT    CF = 1
                AX = Error code

            CF = 0
                AX = Pipe mode:
                        BSxxxWxRIIIIIIII

                        where:
                            B = Blocking mode. If B=1 the pipe is non blocking
                            S = Server end of pipe if 1
                            W = Pipe is written in message mode if 1 (else byte mode)
                            R = Pipe is read in message mode if 1 (else byte mode)
                            I = Pipe instances. Unlimited if 0xFF

Return Value:

    None. Returns values in VDM Ax and Flags registers

--*/

{
    HANDLE  Handle;
    DWORD   State, CurInstances, Flags, MaxInstances;
    BOOL    Ok;
    WORD    PipeHandleState;

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrGetNamedPipeHandleState\n");
    }
#endif

    Handle = HANDLE_FROM_WORDS(getBP(), getBX());
    Ok =  GetNamedPipeHandleState(Handle,
                                  &State,
                                  &CurInstances,
                                  NULL,
                                  NULL,
                                  NULL,
                                  0
                                  );
    if (Ok) {
        Ok = GetNamedPipeInfo(Handle, &Flags, NULL, NULL, &MaxInstances);
        if (Ok) {

            //
            // Create the Dos pipe handle state from the information gathered
            //

            PipeHandleState = (WORD)((MaxInstances > 255) ? 255 : (MaxInstances & 0xff))
                | (WORD)((State & PIPE_NOWAIT) ? NP_NBLK : 0)
                | (WORD)((State & PIPE_READMODE_MESSAGE) ? NP_RMESG : 0)

                //
                // BUGBUG - can't possibly be server end????
                //

                | (WORD)((Flags & PIPE_SERVER_END) ? NP_SERVER : 0)
                | (WORD)((Flags & PIPE_TYPE_MESSAGE) ? NP_WMESG : 0)
                ;

            setAX((WORD)PipeHandleState);
            setCF(0);
        } else {
            SET_ERROR(VrpMapLastError());
        }
    } else {
        SET_ERROR(VrpMapLastError());
    }
}


VOID
VrSetNamedPipeHandleState(
    VOID
    )

/*++

Routine Description:

    Performs SetNamedPipeHandleState request on behalf of VDM redir

Arguments:

    Function = 5F34h

    ENTRY   BP:BX = 32-bit Named Pipe handle
            CX = Pipe mode to set

    EXIT    CF = 1
                AX = Error code

            CF = 0
                AX = Pipe mode set

Return Value:

    None. Returns values in VDM Ax and Flags registers

--*/

{
    HANDLE  Handle = HANDLE_FROM_WORDS(getBP(), getBX());
    BOOL    Ok;
    WORD    DosPipeMode;
    DWORD   WinPipeMode;

#define ILLEGAL_NMP_SETMODE_BITS    ~(NP_NBLK | NP_RMESG | NP_WMESG)

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrSetNamedPipeHandleState(0x%08x, %04x)\n", Handle, getCX());
    }
#endif

    //
    // Convert the Dos pipe mode bits to Win32 pipe mode bits. We can only
    // change the wait/no-wait status and the read mode of the pipe (byte
    // or message)
    //

    DosPipeMode = getCX();

    //
    // catch disallowed flags
    //

    if (DosPipeMode & ILLEGAL_NMP_SETMODE_BITS) {
        SET_ERROR(ERROR_INVALID_PARAMETER);
        return;
    }

    WinPipeMode = ((DosPipeMode & NP_NBLK)
                    ? PIPE_NOWAIT
                    : PIPE_WAIT)
                | ((DosPipeMode & NP_RMESG)
                    ? PIPE_READMODE_MESSAGE
                    : PIPE_READMODE_BYTE);
    if (!(Ok = SetNamedPipeHandleState(Handle, &WinPipeMode, NULL, NULL))) {

#if DBG

        IF_DEBUG(NAMEPIPE) {
            DbgPrint("Error: VrSetNamedPipeHandleState: returning %d\n", GetLastError());
        }

#endif

        SET_ERROR(VrpMapLastError());
    } else {
        setCF(0);
    }
}


VOID
VrPeekNamedPipe(
    VOID
    )

/*++

Routine Description:

    Performs PeekNamedPipe request on behalf of VDM redir

Arguments:

    Function = 5F35h

    ENTRY   BP:BX = 32-bit Named Pipe handle
            CX = Size of buffer for peek
            DS:SI = Buffer address

    EXIT    CF = 1
                AX = Error code

            CF = 0
                AX = Pipe status
                BX = Number of bytes peeked into buffer
                CX = Number of bytes in pipe
                DX = Number of bytes in message
                DI = Pipe status
                DS:SI = Data peeked

Return Value:

    None. Returns values in VDM Ax and Flags registers

--*/

{
    HANDLE Handle;
    LPBYTE lpBuffer;
    DWORD nBufferSize, BytesRead, BytesAvailable, BytesLeftInMessage;
    BOOL Ok;

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrPeekNamedPipe(0x%08x, %04x:%04x, %d)\n",
                 HANDLE_FROM_WORDS(getBP(), getBX()),
                 getDS(),
                 getSI(),
                 getCX()
                 );
    }
#endif

    Handle = HANDLE_FROM_WORDS(getBP(), getBX());
    lpBuffer = (LPBYTE)POINTER_FROM_WORDS(getDS(), getSI());
    nBufferSize = (DWORD)getCX();
    Ok = PeekNamedPipe(Handle,
                       lpBuffer,
                       nBufferSize,
                       &BytesRead,
                       &BytesAvailable,
                       &BytesLeftInMessage
                       );
    if (Ok) {

        //
        // Since we gave a 16-bit quantity for the buffer size, BytesRead
        // cannot be >64K
        //

        setBX((WORD)BytesRead);
        setCX((WORD)BytesAvailable);

        //
        // if message mode pipe, return total bytes in message (as opposed to
        // NT's bytes LEFT in message)
        //

        setDX((WORD)(BytesLeftInMessage ? ((WORD)BytesLeftInMessage + (WORD)BytesRead) : 0));

        //
        // Not sure what this means. According to NETPIAPI.ASM, a 3 is returned
        // on success, meaning status = connected. The named pipe statuses are
        // (according to BSEDOS.H):
        //
        //      NP_DISCONNECTED 1
        //      NP_LISTENING    2
        //      NP_CONNECTED    3
        //      NP_CLOSING      4
        //
        // Presumably, a client-side pipe can only be connected or the pipe is
        // closed
        //

        setDI(NP_CONNECTED);
        setCF(0);

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrPeekNamedPipe: Ok: %d bytes peeked, %d avail, %d left in message\n",
                     BytesRead,
                     BytesAvailable,
                     BytesLeftInMessage
                     );
        }
#endif

    } else {
        SET_ERROR(VrpMapLastError());

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrPeekNamedPipe: Error %d\n", getAX());
        }
#endif

        BytesRead = 0;
    }

    //
    // idle processing - only idle if there is nothing to return (including
    // an error occurred)
    //
    // For now, allow 10(!) peeks per second - on ALL pipe handles
    //

    if (!BytesRead) {
        if (GetTickCount() - VrPeekNamedPipeTickCount < 100) {
            WaitIfIdle();
        }
    }
    VrPeekNamedPipeTickCount = GetTickCount();
}


VOID
VrTransactNamedPipe(
    VOID
    )

/*++

Routine Description:

    Performs TransactNamedPipe request on behalf of VDM redir

Arguments:

    Function = 5F36h

    ENTRY   BP:BX = 32-bit Named Pipe handle
            CX = Transmit buffer length
            DX = Receive buffer length
            DS:SI = Transmit buffer
            ES:DI = Receive buffer

    EXIT    CF = 1
                AX = Error code

            CF = 0
                CX = Number of bytes in Receive buffer


Return Value:

    None. Returns values in VDM Ax and Flags registers

--*/

{
    DWORD BytesRead;
    BOOL Ok;
    OVERLAPPED_PIPE_IO pipeio;
    DWORD Error;
    HANDLE Handle;

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrTransactNamedPipe(0x%08x, TxLen=%d, TxBuf=%04x:%04x, RxLen=%d, RxBuf=%04x:%04x)\n",
                 HANDLE_FROM_WORDS(getBP(), getBX()),
                 getCX(),
                 getDS(),
                 getSI(),
                 getDX(),
                 getES(),
                 getDI()
                 );
    }
#endif

    //
    // now that we are opening named pipes with FLAG_FILE_OVERLAPPED, we have
    // to perform every I/O operation with an OVERLAPPED structure. We are only
    // interested in the event handle. We create a new event for synchronous
    // operation which requires an OVERLAPPED structure. Create the event to
    // be manually reset - this way, if we wait on it & the read has already
    // completed, the wait completes immediately. If we create an auto-reset
    // event, then it may go back into the not-signalled state, causing us to
    // wait forever for an event that has already occurred
    //

    RtlZeroMemory(&pipeio, sizeof(pipeio));
    pipeio.Overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (pipeio.Overlapped.hEvent != NULL) {

        //
        // collect arguments from registers and perform transact named pipe call
        //

        Handle = HANDLE_FROM_WORDS(getBP(), getBX());
        RememberPipeIo(&pipeio);
        Ok = TransactNamedPipe(Handle,
                               (LPVOID)POINTER_FROM_WORDS(getDS(), getSI()),
                               (DWORD)getCX(),
                               (LPVOID)POINTER_FROM_WORDS(getES(), getDI()),
                               (DWORD)getDX(),
                               &BytesRead,
                               &pipeio.Overlapped
                               );
        Error = Ok ? NO_ERROR : GetLastError();
        if (Error == ERROR_IO_PENDING) {

#if DBG
            IF_DEBUG(NAMEPIPE) {
                DbgPrint("VrTransactNamedPipe: Ok, Waiting on hEvent...\n");
            }
#endif

            Error = WaitForSingleObject(pipeio.Overlapped.hEvent, NAMED_PIPE_TIMEOUT);
        }
        ForgetPipeIo(&pipeio);
        if (pipeio.Cancelled) {
            Error = WAIT_TIMEOUT;
        }
        if (Error == NO_ERROR || Error == ERROR_MORE_DATA) {
            GetOverlappedResult(Handle, &pipeio.Overlapped, &BytesRead, TRUE);

#if DBG
            IF_DEBUG(NAMEPIPE) {
                DbgPrint("WaitForSingleObject completed. BytesRead=%d\n", BytesRead);
            }
#endif

            setCX((WORD)BytesRead);
            setAX((WORD)Error);

            //
            // if we are returning NO_ERROR then carry flag is clear, else we
            // are returning ERROR_MORE_DATA: set carry flag
            //

            setCF(Error == ERROR_MORE_DATA);
        } else {

            //
            // if we timed-out then close the pipe handle
            //

            if (Error == WAIT_TIMEOUT) {

#if DBG
                IF_DEBUG(NAMEPIPE) {
                    DbgPrint("VrTransactNamedPipe: Wait timed out: closing handle %08x\n", Handle);
                }
#endif
                CloseHandle(Handle);
                VrpRemoveOpenNamedPipeInfo(Handle);
            } else {
                Error = VrpMapDosError(Error);
            }
            SET_ERROR((WORD)Error);

#if DBG
            IF_DEBUG(NAMEPIPE) {
                DbgPrint("VrTransactNamedPipe: Error: %d\n", getAX());
            }
#endif
        }

        //
        // kill the event handle
        //

        CloseHandle(pipeio.Overlapped.hEvent);
    } else {

        //
        // failed to create event handle
        //

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("vdmredir: DosTransactNamedPipe couldn't create event error %d\n", GetLastError());
        }
#endif
        SET_ERROR(VrpMapLastError());
    }
}


VOID
VrCallNamedPipe(
    VOID
    )

/*++

Routine Description:

    Performs CallNamedPipe request on behalf of VDM redir

Arguments:

    Function = 5F37h

    ENTRY   DS:SI = Pointer to CallNmPipe structure:

                DWORD   Timeout;            +0
                LPWORD  lpBytesRead;        +4
                WORD    OutputBufferLen;    +8
                LPBYTE  OutputBuffer;       +10
                WORD    InputBufferLength;  +14
                LPBYTE  InputBuffer;        +16
                LPSTR   PipeName;           +20

    EXIT    CF = 1
                AX = Error code

            CF = 0
                CX = Bytes received

Return Value:

    None. Returns values in VDM Ax and Flags registers

--*/

{
    BOOL Ok;
    DWORD BytesRead;
    PDOS_CALL_NAMED_PIPE_STRUCT StructurePointer;


    StructurePointer = (PDOS_CALL_NAMED_PIPE_STRUCT)POINTER_FROM_WORDS(getDS(), getSI());

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrCallNamedPipe(%s)\n", (LPSTR)READ_FAR_POINTER(&StructurePointer->lpPipeName));
    }
#endif

    Ok = CallNamedPipe((LPSTR)READ_FAR_POINTER(&StructurePointer->lpPipeName),
                        READ_FAR_POINTER(&StructurePointer->lpInBuffer),
                        READ_WORD(&StructurePointer->nInBufferLen),
                        READ_FAR_POINTER(&StructurePointer->lpOutBuffer),
                        READ_WORD(&StructurePointer->nOutBufferLen),
                        &BytesRead,
                        READ_DWORD(&StructurePointer->Timeout)
                        );
    if (!Ok) {
        SET_ERROR(VrpMapLastError());

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrCallNamedPipe: Error: CallNamedPipe returns %u\n", getAX());
        }
#endif
    } else {
        WRITE_WORD(READ_FAR_POINTER(&StructurePointer->lpBytesRead), (WORD)BytesRead);
        setCX((WORD)BytesRead);
        setCF(0);

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrCallNamedPipe: Ok\n");
        }
#endif
    }
}


VOID
VrWaitNamedPipe(
    VOID
    )

/*++

Routine Description:

    Performs WaitNamedPipe request on behalf of VDM redir. We assume that the
    name we are getting is \\computer\pipe\name, anything else is invalid

Arguments:

    Function = 5F38h

    ENTRY   BX:CX = Timeout
            DS:DX = Pipe name

    EXIT    CF = 1
                AX = Error code

            CF = 0
                No error

Return Value:

    None. Returns values in VDM Ax and Flags registers

--*/

{
    BOOL Ok;

    //
    // BUGBUG - should really perform DosPathCanonicalization on input string -
    // DOS redir would convert eg //server/pipe\foo.bar into \\SERVER\PIPE\FOO.BAR
    // if it makes any difference
    //

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrWaitNamedPipe(%s, %d)\n",
                    LPSTR_FROM_WORDS(getDS(), getDX()),
                    DWORD_FROM_WORDS(getBX(), getCX())
                    );
    }
#endif

    Ok = WaitNamedPipe(LPSTR_FROM_WORDS(getDS(), getDX()),
                        DWORD_FROM_WORDS(getBX(), getCX())
                        );
    if (!Ok) {
        SET_ERROR(VrpMapLastError());
    } else {

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("WaitNamedPipe returns TRUE\n");
        }
#endif
        setAX(0);
        setCF(0);
    }
}


VOID
VrNetHandleGetInfo(
    VOID
    )

/*++

Routine Description:

    Performs local NetHandleGetInfo on behalf of the Vdm client

Arguments:

    Function = 5F3Ch

    ENTRY   BP:BX = 32-bit Named Pipe handle
            CX = Buffer length
            SI = Level (1)
            DS:DX = Buffer

    EXIT    CX = size of required buffer (whether we got it or not)
            CF = 1
                AX = Error code

            CF = 0
                indicated stuff put in buffer

Return Value:

    None. Results returned via VDM registers or in VDM memory, according to
    request

--*/

{
    HANDLE  Handle;
    DWORD   Level;
    DWORD   BufLen;
    BOOL    Ok;
    DWORD   CollectCount;
    DWORD   CollectTime;
    LPVDM_HANDLE_INFO_1 StructurePointer;

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrNetHandleGetInfo\n");
    }
#endif

    Handle = HANDLE_FROM_WORDS(getBP(), getBX());
    Level = (DWORD)getSI();
    if (Level == 1) {
        BufLen = (DWORD)getCX();
        if (BufLen >= sizeof(VDM_HANDLE_INFO_1)) {

            //
            // BUGBUG - the information we are interested in cannot be returned
            // if the client and server are on the same machine, or if this is
            // the server end of the pipe???
            //

            Ok = GetNamedPipeHandleState(Handle,
                                            NULL,   // not interested in state
                                            NULL,   // ditto curInstances
                                            &CollectCount,
                                            &CollectTime,
                                            NULL,   // not interested in client app name
                                            0
                                            );
            if (!Ok) {
                SET_ERROR(VrpMapLastError());
            } else {
                StructurePointer = (LPVDM_HANDLE_INFO_1)POINTER_FROM_WORDS(getDS(), getDX());
                StructurePointer->CharTime = CollectTime;
                StructurePointer->CharCount = (WORD)CollectCount;
                setCF(0);
            }
        } else {
            SET_ERROR(NERR_BufTooSmall);
        }
    } else {
        SET_ERROR(ERROR_INVALID_LEVEL);
    }
}


VOID
VrNetHandleSetInfo(
    VOID
    )

/*++

Routine Description:

    Performs local NetHandleSetInfo on behalf of the Vdm client

Arguments:

    Function = 5F3Bh

    ENTRY   BP:BX = 32-bit Named Pipe handle
            CX = Buffer length
            SI = Level (1)
            DI = Parmnum
            DS:DX = Buffer

    EXIT    CF = 1
                AX = Error code

            CF = 0
                Stuff from buffer set

Return Value:

    None. Results returned via VDM registers or in VDM memory, according to
    request

--*/

{
    HANDLE  Handle;
    DWORD   Level;
    DWORD   BufLen;
    BOOL    Ok;
    DWORD   Data;
    DWORD   ParmNum;
    LPBYTE  Buffer;

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrNetHandleGetInfo\n");
        DbgBreakPoint();
    }
#endif

    Handle = HANDLE_FROM_WORDS(getBP(), getBX());
    Level = (DWORD)getSI();
    Buffer = LPBYTE_FROM_WORDS(getDS(), getDX());
    if (Level == 1) {
        BufLen = (DWORD)getCX();

        //
        // ParmNum can be 1 (CharTime) or 2 (CharCount), Can't be 0 (set
        // everything)
        //

        ParmNum = (DWORD)getDI();
        if (!--ParmNum) {
            if (BufLen < sizeof(((LPVDM_HANDLE_INFO_1)0)->CharTime)) {
                SET_ERROR(NERR_BufTooSmall);
                return ;
            }
            Data = (DWORD)*(LPDWORD)Buffer;
        } else if (!--ParmNum) {
            if (BufLen < sizeof(((LPVDM_HANDLE_INFO_1)0)->CharCount)) {
                SET_ERROR(NERR_BufTooSmall);
                return ;
            }
            Data = (DWORD)*(LPWORD)Buffer;
        } else {
            SET_ERROR(ERROR_INVALID_PARAMETER);
            return ;
        }

        //
        // BUGBUG - the information we are interested in cannot be set
        // if the client and server are on the same machine, or if this is
        // the server end of the pipe???
        //

        Ok = SetNamedPipeHandleState(Handle,
                                        NULL,   // not interested in mode
                                        (LPDWORD)((ParmNum == 1) ? &Data : NULL),
                                        (LPDWORD)((ParmNum == 2) ? &Data : NULL)
                                        );
        if (!Ok) {
            SET_ERROR(VrpMapLastError());
        } else {
            setCF(0);
        }
    } else {
        SET_ERROR(ERROR_INVALID_LEVEL);
    }
}


//
// Request Queue. This queue holds a singly linked list of async named pipe
// read/write requests. The async thread will search this list when an async
// read or write completes (the event is signalled). It then sets up the
// information for the call back to the VDM and dequeues the request info.
// Because we can have the async thread and the request thread simultaneously
// accessing the queue, it is protected by a critical section
//

CRITICAL_SECTION VrNmpRequestQueueCritSec;
PDOS_ASYNC_NAMED_PIPE_INFO RequestQueueHead = NULL;
PDOS_ASYNC_NAMED_PIPE_INFO RequestQueueTail = NULL;
HANDLE VrpNmpSomethingToDo;


VOID
VrReadWriteAsyncNmPipe(
    VOID
    )

/*++

Routine Description:

    Performs asynchronous read or write of a message mode named pipe on behalf
    of the VDM DOS application

Arguments:

    None. All arguments are extracted from DOS registers/memory.

    These calls are made through int 2fh/ax=function code, not int 21h/ah=5fh

        AX = 1186h  DosReadAsyncNmPipe
             118Fh  DosWriteAsyncNmPipe
             1190h  DosReadAsyncNmPipe2
             1191h  DosWriteAsyncNmPipe2

        BP:BX = 32-bit Named Pipe Handle

        DS:SI = DOS_ASYNC_NAMED_PIPE_STRUCT
            DD  address of returned bytes read
            DW  size of caller's buffer
            DD  address of caller's buffer
            DD  address of returned error code
            DD  address of Asynchronous Notification Routine
            DW  named pipe handle
            DD  address of caller's 'semaphore'

Return Value:

    None.

--*/

{
    HANDLE  Handle;

    //
    // Type is type of request - read or write, standard or 2 (meaning the
    // request has an associated 'semaphore' which must be cleared)
    //

    DWORD   Type;

    //
    // StructurePointer is 32-bit flat pointer to structure in DOS memory
    // containing request parameters
    //

    PDOS_ASYNC_NAMED_PIPE_STRUCT StructurePointer;

    //
    // pAsyncInfo is a pointer to the request packet we stick on the request
    // queue
    //

    PDOS_ASYNC_NAMED_PIPE_INFO pAsyncInfo;

    //
    // pipeInfo is a pointer to the information we created/stored when the
    // named pipe was opened. We just need this to check the handle's valid
    //

    POPEN_NAMED_PIPE_INFO pipeInfo;

    WORD    length;
    LPBYTE  buffer;
    DWORD   error;
    BOOL    ok;
    HANDLE  hEvent;
    DWORD   bytesTransferred;

    //
    // hThread and tid: these must be kept alive so long as the async named
    // pipe (completion) thread exists. tid can be used with ResumeThread and
    // SuspendThread as we may see fit
    //

    static HANDLE hThread = NULL;
    static DWORD tid;

    //
    // get info from registers and the async named pipe structure
    //

    Handle = HANDLE_FROM_WORDS(getBP(), getBX());
    pipeInfo = VrpGetOpenNamedPipeInfo(Handle);
    Type = (DWORD)getAX() & 0xff;   // 0x86, 0x8f, 0x90 or 0x91
    StructurePointer = (PDOS_ASYNC_NAMED_PIPE_STRUCT)POINTER_FROM_WORDS(getDS(), getSI());
    length = READ_WORD(&StructurePointer->BufferLength);
    buffer = READ_FAR_POINTER(&StructurePointer->lpBuffer);

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint(   "\n"
                    "VrReadWriteAsyncNmPipe (%04x) [%s]:\n"
                    "DOS_READ_ASYNC_NAMED_PIPE_STRUCT @ %08x:\n"
                    "32-bit named pipe handle . . . . %08x\n"
                    "Address of returned bytes read . %04x:%04x\n"
                    "Size of caller's buffer. . . . . %04x\n"
                    "Address of caller's buffer . . . %04x:%04x\n"
                    "Address of returned error code . %04x:%04x\n"
                    "Address of ANR . . . . . . . . . %04x:%04x\n"
                    "Named pipe handle. . . . . . . . %04x\n"
                    "Address of caller's semaphore. . %04x:%04x\n"
                    "\n",
                    (DWORD)getAX(), // type of read/write request
                    Type == ANP_READ
                        ? "READ"
                        : Type == ANP_WRITE
                            ? "WRITE"
                            : Type == ANP_READ2
                                ? "READ2"
                                : Type == ANP_WRITE2
                                    ? "WRITE2"
                                    : "?????",
                    StructurePointer,
                    Handle,
                    (DWORD)GET_SELECTOR(&StructurePointer->lpBytesRead),
                    (DWORD)GET_OFFSET(&StructurePointer->lpBytesRead),
                    (DWORD)StructurePointer->BufferLength,
                    (DWORD)GET_SELECTOR(&StructurePointer->lpBuffer),
                    (DWORD)GET_OFFSET(&StructurePointer->lpBuffer),
                    (DWORD)GET_SELECTOR(&StructurePointer->lpErrorCode),
                    (DWORD)GET_OFFSET(&StructurePointer->lpErrorCode),
                    (DWORD)GET_SELECTOR(&StructurePointer->lpANR),
                    (DWORD)GET_OFFSET(&StructurePointer->lpANR),
                    (DWORD)StructurePointer->PipeHandle,
                    (DWORD)GET_SELECTOR(&StructurePointer->lpSemaphore),
                    (DWORD)GET_OFFSET(&StructurePointer->lpSemaphore)
                    );
    }
#endif

    //
    // if we can't find this handle in our list of opened named pipes, return
    // an error
    //

    if (!pipeInfo) {

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrReadWriteAsyncNmPipe: Handle 0x%08x is invalid\n", Handle);
        }
#endif

        SET_ERROR(ERROR_INVALID_HANDLE);
        return;
    }

    //
    // looks like we're going to make an async read/write request. Create the
    // async thread if it doesn't already exist. Create also the "something to
    // do" event. Create this as an auto reset event which is initially in the
    // not-signalled state
    //

    if (hThread == NULL) {
        VrpNmpSomethingToDo = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (VrpNmpSomethingToDo == NULL) {

#if DBG
            IF_DEBUG(NAMEPIPE) {
                DbgPrint("VrReadWriteAsyncNmPipe: Error: Couldn't create something-to-do event: %d\n",
                            GetLastError()
                            );
            }
#endif

            //
            // return an out-of-resources error
            //

            SET_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return;
        }

        //
        // we have the "something to do" event. Now create the thread
        //

        hThread = CreateThread(NULL,
                               0,
                               VrpAsyncNmPipeThread,
                               NULL,
                               0,
                               &tid
                               );
        if (hThread == NULL) {

#if DBG
            IF_DEBUG(NAMEPIPE) {
                DbgPrint("VrReadWriteAsyncNmPipe: Error: Couldn't create thread: %d\n",
                            GetLastError()
                            );
            }
#endif

            CloseHandle(VrpNmpSomethingToDo);
            SET_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return;
        }
    }

    //
    // allocate a structure in which to store the information required to
    // complete the request (in the VDM)
    //

    pAsyncInfo = (PDOS_ASYNC_NAMED_PIPE_INFO)LocalAlloc(LMEM_FIXED, sizeof(DOS_ASYNC_NAMED_PIPE_INFO));
    if (pAsyncInfo == NULL) {

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrReadWriteAsyncNmPipe: Error: Couldn't allocate structure\n");
        }
#endif

        SET_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return;
    }

    RtlZeroMemory(&pAsyncInfo->Overlapped, sizeof(pAsyncInfo->Overlapped));

    //
    // create a new event for this request - there can be multiple simultaneous
    // requests per named pipe. The event is manual reset so that if the request
    // completes before the WaitForMultipleObjects snaps the list, the event
    // will stay reset and hence the wait will complete. If we created the event
    // as auto-reset, it may get signalled, and go not-signalled before we wait
    // on it, potentially causing an infinite wait
    //

    hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (hEvent == NULL) {

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrReadWriteAsyncNmPipe: Error: Couldn't create event: %d\n", GetLastError());
        }
#endif

        LocalFree((HLOCAL)pAsyncInfo);

        //
        // return approximation out-of-resources error
        //

        SET_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return;
    } else {
        pAsyncInfo->Overlapped.hEvent = hEvent;
    }

    //
    // set up rest of async operation info structure
    //

    pAsyncInfo->Completed = FALSE;
    pAsyncInfo->Handle = Handle;
    pAsyncInfo->Buffer = (DWORD)StructurePointer->lpBuffer;
    pAsyncInfo->pBytesTransferred = READ_FAR_POINTER(&StructurePointer->lpBytesRead);
    pAsyncInfo->pErrorCode = READ_FAR_POINTER(&StructurePointer->lpErrorCode);
    pAsyncInfo->ANR = READ_DWORD(&StructurePointer->lpANR);

    //
    // if this is an AsyncNmPipe2 call then it has an associated semaphore
    // handle. Earlier versions don't have a semaphore
    //

    if (Type == ANP_READ2 || Type == ANP_WRITE2) {
        pAsyncInfo->Type2 = TRUE;
        pAsyncInfo->Semaphore = READ_DWORD(&StructurePointer->lpSemaphore);
    } else {
        pAsyncInfo->Type2 = FALSE;
        pAsyncInfo->Semaphore = (DWORD)NULL;
    }

#if DBG
    pAsyncInfo->RequestType = Type;
#endif

    //
    // add the completion info structure to the async thread's work queue
    //

    VrpQueueAsyncRequest(pAsyncInfo);

    //
    // Q: what happens if the request completes asynchronously before we finish
    // this routine?
    //

    if (Type == ANP_READ || Type == ANP_READ2) {
        ok = ReadFile(Handle,
                      buffer,
                      length,
                      &bytesTransferred,
                      &pAsyncInfo->Overlapped
                      );

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrReadWriteAsyncNmPipe: ReadFile(%x, %x, %d, ...): %d\n",
                     Handle,
                     buffer,
                     length,
                     ok
                     );
        }
#endif

    } else {
        ok = WriteFile(Handle,
                       buffer,
                       length,
                       &bytesTransferred,
                       &pAsyncInfo->Overlapped
                       );

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrReadWriteAsyncNmPipe: WriteFile(%x, %x, %d, ...): %d\n",
                     Handle,
                     buffer,
                     length,
                     ok
                     );
        }
#endif

    }
    error = ok ? NO_ERROR : GetLastError();

    //
    // if we get ERROR_MORE_DATA then treat it as an error. GetOverlappedResult
    // will give us the same error which we will return asynchronously
    //

    if (error != NO_ERROR && error != ERROR_IO_PENDING && error != ERROR_MORE_DATA) {

        //
        // we didn't get to start the I/O operation successfully, therefore
        // we won't get called back, so we dequeue and free the completion
        // structure and return the error
        //

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrReadWriteAsyncNmPipe: Error: IO operation returns %d\n", error);
        }
#endif

        VrpDequeueAsyncRequest(pAsyncInfo);
        CloseHandle(hEvent);
        LocalFree(pAsyncInfo);
        SET_ERROR((WORD)error);
    } else {

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrReadWriteAsyncNmPipe: IO operation started: returns %s\n",
                     error == ERROR_IO_PENDING ? "ERROR_IO_PENDING" : "NO_ERROR"
                     );
        }
#endif

        setCF(0);
    }

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrReadWriteAsyncNmPipe: returning CF=%d, AX=%d\n", getCF(), getAX());
    }
#endif
}


BOOLEAN
VrNmPipeInterrupt(
    VOID
    )

/*++

Routine Description:

    Called from hardware interrupt BOP processing to check if there are any
    async named pipe ANRs to call

Arguments:

    None.

Return Value:

    BOOLEAN
        TRUE    - there was an async named pipe operation to complete. The
                  VDM registers & data areas have been modified to indicate
                  that the named pipe ANR must be called

        FALSE   - no async named pipe processing to do. Interrupt must have
                  been generated by NetBios or DLC

--*/

{
    PDOS_ASYNC_NAMED_PIPE_INFO pAsyncInfo;

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrNmPipeInterrupt\n");
    }
#endif


    //
    // locate the first async named pipe request packet that has completed and
    // is waiting for interrupt processing (ie its ANR to be called)
    //

    pAsyncInfo = VrpFindCompletedRequest();
    if (!pAsyncInfo) {

#if DBG

        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrNmPipeInterrupt - nothing to do\n");
        }

#endif

        //
        // returning FALSE indicates that the hardware interrupt callback was
        // not generated by async named pipe request completing
        //

        return FALSE;
    } else {

        //
        // set the VDM registers to indicate a named pipe callback
        //

        setDS(HIWORD(pAsyncInfo->Buffer));
        setSI(LOWORD(pAsyncInfo->Buffer));
        setES(HIWORD(pAsyncInfo->Semaphore));
        setDI(LOWORD(pAsyncInfo->Semaphore));
        setCX(HIWORD(pAsyncInfo->ANR));
        setBX(LOWORD(pAsyncInfo->ANR));
        setAL((BYTE)pAsyncInfo->Type2);
        SET_CALLBACK_NAMEPIPE();

        //
        // finished with this request packet, so dequeue and deallocate it
        //

        VrpDequeueAsyncRequest(pAsyncInfo);
        CloseHandle(pAsyncInfo->Overlapped.hEvent);
        LocalFree(pAsyncInfo);

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrNmPipeInterrupt: Setting DOS Registers:\n"
                     "DS:SI=%04x:%04x, ES:DI=%04x:%04x, CX:BX=%04x:%04x, AL=%02x\n",
                     getDS(), getSI(),
                     getES(), getDI(),
                     getCX(), getBX(),
                     getAL()
                     );
        }
#endif

        //
        // returning TRUE indicates that we have accepted a named pipe
        // completion request
        //

        //VrDismissInterrupt();
        return TRUE;
    }
}


VOID
VrTerminateNamedPipes(
    IN WORD DosPdb
    )

/*++

Routine Description:

    Cleans out all open named pipe info and pending async named pipe requests
    when the owning DOS app terminates

Arguments:

    DosPdb  - PDB (DOS 'process' identifier) of terminating DOS process

Return Value:

    None.

--*/

{
#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrTerminateNamedPipes\n");
    }
#endif
}


VOID
VrCancelPipeIo(
    IN DWORD Thread
    )

/*++

Routine Description:

    For all pending named pipe I/Os owned by Thread, mark them as cancelled
    and signal the event in the OVERLAPPED structure, causing the wait to
    terminate.

    This thread may not have any outstanding named pipe I/O

Arguments:

    Thread  - pseudo-handle of thread owning named pipe I/O

Return Value:

    None.

--*/

{
    POVERLAPPED_PIPE_IO ptr;

    EnterCriticalSection(&VrNamedPipeCancelCritSec);
    for (ptr = PipeIoQueue; ptr; ptr = ptr->Next) {
        if (ptr->Thread == Thread) {
            ptr->Cancelled = TRUE;
            SetEvent(ptr->Overlapped.hEvent);
        }
    }
    LeaveCriticalSection(&VrNamedPipeCancelCritSec);
}


#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

PRIVATE
DWORD
VrpAsyncNmPipeThread(
    IN LPVOID Parameters
    )

/*++

Routine Description:

    Waits for an asynchronous named pipe read or write operation to complete.
    Loops forever, waiting on list of pending async (overlapped) named pipe
    operations. If there are no more outstanding named pipe read/writes then
    waits on VrpNmpSomethingToDo which is reset (put in not-signalled state)
    when there are no packets left on the request queue

Arguments:

    Parameters  - unused parameter block

Return Value:

    DWORD
        0

--*/

{
    DWORD numberOfHandles;
    DWORD index;
    HANDLE eventList[MAXIMUM_ASYNC_PIPES + 1];
    PDOS_ASYNC_NAMED_PIPE_INFO pRequest;

    UNREFERENCED_PARAMETER(Parameters);

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrAsyncNamedPipeThread: *** Started ***\n");
    }
#endif

    while (TRUE) {

        //
        // create an array of event handles. The first handle in the array is
        // the "something to do" event. This will only be reset when the queue
        // of requests changes from the empty set
        //

        numberOfHandles = VrpSnapshotEventList(eventList);
        index = WaitForMultipleObjects(numberOfHandles, eventList, FALSE, INFINITE);

        //
        // if the index is 0, then the "something to do" event has been signalled,
        // meaning that we have to snapshot a new event list and re-wait
        //

        if (index > 0 && index < numberOfHandles) {

#if DBG
            IF_DEBUG(NAMEPIPE) {
                DbgPrint("VrpAsyncNmPipeThread: event #%d fired\n", index);
            }
#endif

            pRequest = VrpSearchForRequestByEventHandle(eventList[index]);
            if (pRequest != NULL) {
                VrpCompleteAsyncRequest(pRequest);
            }

#if DBG
            else {
                IF_DEBUG(NAMEPIPE) {
                    DbgPrint("VrpAsyncNmPipeThread: Couldn't find request for handle 0x%08x\n",
                                eventList[index]
                                );
                }
            }
#endif

        } else if (index) {

            //
            // an error occurred
            //

#if DBG
            IF_DEBUG(NAMEPIPE) {
                DbgPrint("VrpAsyncNmPipeThread: Error: WaitForMultipleObjects returns %d (%d)\n",
                            index,
                            GetLastError()
                            );
            }
#endif

        }

#if DBG
        else {
            IF_DEBUG(NAMEPIPE) {
                DbgPrint("VrpAsyncNmPipeThread: Something-to-do event fired\n");
            }
        }
#endif

    }

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrpAsyncNmPipeThread: *** Terminated ***\n");
    }
#endif

    return 0;   // appease the compiler-god
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


PRIVATE
DWORD
VrpSnapshotEventList(
    OUT LPHANDLE pList
    )

/*++

Routine Description:

    Builds an array of event handles for those asynchronous named pipe I/O
    requests which are still not completed (the Completed flag is FALSE).
    The first event handle is always the "something to do" event

Arguments:

    pList   - pointer to callers list to build

Return Value:

    DWORD

--*/

{
    DWORD count = 1;
    PDOS_ASYNC_NAMED_PIPE_INFO ptr;

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrpSnapshotEventList\n");
    }
#endif

    pList[0] = VrpNmpSomethingToDo;
    EnterCriticalSection(&VrNmpRequestQueueCritSec);
    for (ptr = RequestQueueHead; ptr; ptr = ptr->Next) {
        if (ptr->Completed == FALSE) {
            pList[count++] = ptr->Overlapped.hEvent;
        }
    }
    LeaveCriticalSection(&VrNmpRequestQueueCritSec);

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrpSnapshotEventList: returning %d events\n", count);
    }
#endif

    return count;
}


PRIVATE
PDOS_ASYNC_NAMED_PIPE_INFO
VrpSearchForRequestByEventHandle(
    IN HANDLE EventHandle
    )

/*++

Routine Description:

    Searches the async request queue for the structure with this event handle.
    If the structure is found, it is marked as Completed. The required structure
    may NOT be located: this might occur when an item was removed from the list
    due to an error in VrReadWriteAsyncNmPipe

Arguments:

    EventHandle - to search for

Return Value:

    PDOS_ASYNC_NAMED_PIPE_INFO
        Success - the located structure
        Failure - NULL

--*/

{
    PDOS_ASYNC_NAMED_PIPE_INFO ptr;

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrpSearchForRequestByEventHandle(0x%08x)\n", EventHandle);
    }
#endif

    EnterCriticalSection(&VrNmpRequestQueueCritSec);
    for (ptr = RequestQueueHead; ptr; ptr = ptr->Next) {
        if (ptr->Overlapped.hEvent == EventHandle) {
            ptr->Completed = TRUE;
            break;
        }
    }
    LeaveCriticalSection(&VrNmpRequestQueueCritSec);

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrpLocateAsyncRequestByEventHandle returning 0x%08x: Request is %s\n",
                 ptr,
                 !ptr
                    ? "NO REQUEST!!"
                    : ptr->RequestType == ANP_READ
                        ? "READ"
                        : ptr->RequestType == ANP_WRITE
                            ? "WRITE"
                            : ptr->RequestType == ANP_READ2
                                ? "READ2"
                                : ptr->RequestType == ANP_WRITE2
                                    ? "WRITE2"
                                    : "UNKNOWN REQUEST!!"
                 );
    }
#endif

    return ptr;
}


PRIVATE
VOID
VrpCompleteAsyncRequest(
    IN PDOS_ASYNC_NAMED_PIPE_INFO pAsyncInfo
    )

/*++

Routine Description:

    Completes the asynchronous named pipe I/O request by getting the results
    of the transfer and filling-in the error & bytes transferred fields of
    the async named pipe info structure. If there is an ANR to be called, then
    a simulated hardware interrupt request is generated to the VDM. If there
    is no ANR to call then the async named pipe info structure is cleared out.

    If there is an ANR, the request will be completed finally when it is
    dequeued & freed by VrNmPipeInterrupt

Arguments:

    pAsyncInfo  - pointer to DOS_ASYNC_NAMED_PIPE_INFO structure to complete

Return Value:

    None.

--*/

{
    BOOL ok;
    DWORD bytesTransferred=0;
    DWORD error;

#if DBG

    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrpCompleteAsyncRequest(0x%08x)\n", pAsyncInfo);
    }

#endif

    ok = GetOverlappedResult(pAsyncInfo->Handle,
                             &pAsyncInfo->Overlapped,
                             &bytesTransferred,
                             FALSE
                             );
    error = ok ? NO_ERROR : GetLastError();

    //
    // update the VDM variables
    //

    WRITE_WORD(pAsyncInfo->pErrorCode, error);
    WRITE_WORD(pAsyncInfo->pBytesTransferred, bytesTransferred);

#if DBG

    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrpCompleteAsyncRequest: error=%d, bytesTransferred=%d\n",
                    error,
                    bytesTransferred
                    );
    }

#endif

    //
    // if there is no ANR then we cannot make a call-back to DOS (error? DOS
    // app polls 'semaphore'?) so close the event handle, dequeue the request
    // packet and free it
    //

    if (!pAsyncInfo->ANR) {

#if DBG

        PDOS_ASYNC_NAMED_PIPE_INFO ptr;

        ptr = VrpDequeueAsyncRequest(pAsyncInfo);
        if (ptr != pAsyncInfo) {
            DbgPrint("*** Error: incorrect request packet dequeued ***\n");
            DbgBreakPoint();
        }
#else

        VrpDequeueAsyncRequest(pAsyncInfo);

#endif

        CloseHandle(pAsyncInfo->Overlapped.hEvent);
        LocalFree(pAsyncInfo);
    } else {

        //
        // interrupt the VDM. It must call back to find out what asynchronous
        // processing there is to do
        //

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrpCompleteAsyncRequest: *** INTERRUPTING VDM ***\n");
        }
#endif

        VrQueueCompletionHandler(VrNmPipeInterrupt);
        VrRaiseInterrupt();
    }
}


PRIVATE
VOID
VrpQueueAsyncRequest(
    IN PDOS_ASYNC_NAMED_PIPE_INFO pAsyncInfo
    )

/*++

Routine Description:

    Adds a DOS_ASYNC_NAMED_PIPE_INFO structure to the end of the request queue.
    The queue is protected by a critical section

Arguments:

    pAsyncInfo  - pointer to structure to add

Return Value:

    None.

--*/

{
#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrpQueueAsyncRequest\n");
    }
#endif

    EnterCriticalSection(&VrNmpRequestQueueCritSec);
    if (!RequestQueueHead) {
        RequestQueueHead = pAsyncInfo;

        //
        // the set is changing state from empty set to not empty set. Set the
        // "something to do" event. Note: it is OK to do this here (before we
        // have finished updating the queue info): because the async thread
        // must gain this critical section before it can access the request
        // queue
        //

//        PulseEvent(VrpNmpSomethingToDo);
    } else {
        RequestQueueTail->Next = pAsyncInfo;
    }
    pAsyncInfo->Next = NULL;
    RequestQueueTail = pAsyncInfo;
    SetEvent(VrpNmpSomethingToDo);
    LeaveCriticalSection(&VrNmpRequestQueueCritSec);
}


PRIVATE
PDOS_ASYNC_NAMED_PIPE_INFO
VrpDequeueAsyncRequest(
    IN PDOS_ASYNC_NAMED_PIPE_INFO pAsyncInfo
    )

/*++

Routine Description:

    Removes the DOS_ASYNC_NAMED_PIPE_INFO structure pointed at by pAsyncInfo
    from the request queue. Protected by critical section

Arguments:

    pAsyncInfo  - pointer to DOS_ASYNC_NAMED_PIPE_INFO to remove

Return Value:

    PDOS_ASYNC_NAMED_PIPE_INFO
        Success - pAsyncInfo is returned
        Failure - NULL - AsyncInfo wasn't found on the queue

--*/

{
    PDOS_ASYNC_NAMED_PIPE_INFO ptr;
    PDOS_ASYNC_NAMED_PIPE_INFO prev = (PDOS_ASYNC_NAMED_PIPE_INFO)&RequestQueueHead;

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrpDequeueAsyncRequest(0x%08x)\n", pAsyncInfo);
    }
#endif

    EnterCriticalSection(&VrNmpRequestQueueCritSec);
    for (ptr = RequestQueueHead; ptr; ptr = ptr->Next) {
        if (ptr == pAsyncInfo) {
            break;
        } else {
            prev = ptr;
        }
    }
    if (ptr) {
        prev->Next = ptr->Next;
        if (RequestQueueTail == ptr) {
            RequestQueueTail = prev;
        }
    }

    //
    // if this was the last item on the queue (in the set) then the set has
    // changed state from not empty to empty set. Reset the "something to do"
    // event to stop the async thread until another request arrives. Note: it
    // is safe to reset the event here
    //

//    ResetEvent(VrpNmpSomethingToDo);
    LeaveCriticalSection(&VrNmpRequestQueueCritSec);

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrpDequeueAsyncRequest returning %08x\n", ptr);
    }
#endif

    return ptr;
}


PRIVATE
PDOS_ASYNC_NAMED_PIPE_INFO
VrpFindCompletedRequest(
    VOID
    )

/*++

Routine Description:

    Tries to locate the first request packet in the queue with the Completed
    field set, meaning the I/O request has completed and is waiting to generate
    a callback

Arguments:

    None.

Return Value:

    PDOS_ASYNC_NAMED_PIPE_INFO
        Success - pointer to request packet to complete
        Failure - NULL

--*/

{
    PDOS_ASYNC_NAMED_PIPE_INFO ptr;

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrpFindCompletedRequest\n");
    }
#endif

    EnterCriticalSection(&VrNmpRequestQueueCritSec);
    for (ptr = RequestQueueHead; ptr; ptr = ptr->Next) {
        if (ptr->Completed) {
            break;
        }
    }
    LeaveCriticalSection(&VrNmpRequestQueueCritSec);

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrpFindCompletedRequest returning 0x%08x: Request is %s\n",
                 ptr,
                 !ptr
                    ? "NO REQUEST!!"
                    : ptr->RequestType == ANP_READ
                        ? "READ"
                        : ptr->RequestType == ANP_WRITE
                            ? "WRITE"
                            : ptr->RequestType == ANP_READ2
                                ? "READ2"
                                : ptr->RequestType == ANP_WRITE2
                                    ? "WRITE2"
                                    : "UNKNOWN REQUEST!!"
                 );
    }
#endif

    return ptr;
}


//
// externally callable interceptors
//

BOOL
VrAddOpenNamedPipeInfo(
    IN  HANDLE  Handle,
    IN  LPSTR   lpFileName
    )

/*++

Routine Description:

    This routine is called whenever DEM (Dos Emulator) successfully opens a
    handle to a file. We check if the file just opened was a named pipe (based
    on the name) and if so create an association between name and handle

Arguments:

    Handle      - of just opened file/pipe/device
    lpFileName  - symbolic name of what was just opened

Return Value:

    BOOL
        TRUE    - created/added open named pipe structure
        FALSE   - couldn't allocate structure memory or create event

--*/

{
    BOOL ok;

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrAddOpenNamedPipeInfo\n");
    }
#endif

    if (VrIsNamedPipeName(lpFileName)) {

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("Adding %s as named pipe\n", lpFileName);
        }
#endif

        //
        // if we can't create the named pipe info structure, or the async
        // read/write event, return FALSE which results in an out-of-resources
        // error (not enough memory) since DOS doesn't understand about events
        //

        ok = VrpAddOpenNamedPipeInfo(Handle, lpFileName);
    } else {

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrAddOpenNamedPipeInfo: Error: not named pipe: %s\n", lpFileName);
        }
#endif

        ok = FALSE;

    }

    return ok;
}


BOOL
VrRemoveOpenNamedPipeInfo(
    IN HANDLE Handle
    )

/*++

Routine Description:

    This is the companion routine to VrAddOpenNamedPipeInfo. When a handle is
    successfully closed for a DOS app, we must check if it referenced a named
    pipe, and if so remove the info structure we created when the pipe was
    opened

Arguments:

    Handle  - to file/pipe/device just closed for Dos app

Return Value:

    BOOL
        TRUE
        FALSE

--*/

{
#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrRemoveOpenNamedPipeInfo\n");
    }

    if (!VrpRemoveOpenNamedPipeInfo(Handle)) {
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("Handle 0x%08x is not a named pipe\n", Handle);
        }
        return FALSE;
    } else {
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrRemoveOpenNamedPipeInfo - Handle 0x%08x has been removed\n", Handle);
        }
        return TRUE;
    }
#else
    VrpRemoveOpenNamedPipeInfo(Handle);
#endif

    return TRUE;
}


BOOL
VrReadNamedPipe(
    IN  HANDLE  Handle,
    IN  LPBYTE  Buffer,
    IN  DWORD   Buflen,
    OUT LPDWORD BytesRead,
    OUT LPDWORD Error
    )

/*++

Routine Description:

    Performs ReadFile on a named pipe handle. All named pipes are opened in
    overlapped-IO mode because async read/writes cannot be performed otherwise

Arguments:

    Handle      - of opened NamedPipe
    Buffer      - client (VDM) data buffer
    Buflen      - size of read buffer
    BytesRead   - where actual bytes read is returned
    Error       - pointer to returned error in case of failure or more data

Return Value:

    BOOL
        TRUE    - handle was successfully written
        FALSE   - an error occurred, use GetLastError

--*/

{
    OVERLAPPED_PIPE_IO pipeio;
    BOOL success;
    DWORD error;
    DWORD dwBytesRead = 0;
    BOOL  bWaited = FALSE;

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrReadNamePipe(0x%08x, %x, %d)\n", Handle, Buffer, Buflen);
    }
#endif

    //
    // create an event to wait on. This goes in the overlapped structure - it
    // is the only thing in the overlapped structure we are interested in.
    // Create the event with manual reset. This is so that if the I/O operation
    // completes immediately, we don't wait on the event. If we create the
    // event as auto-reset, it can go into the signalled state, and back to the
    // not-signalled state before we prime the wait, causing us to wait forever
    // for an event that has already occurred
    //

    RtlZeroMemory(&pipeio, sizeof(pipeio));
    if ((pipeio.Overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL) {
        *Error = ERROR_NOT_ENOUGH_MEMORY;   // really want out-of-resources (71?)
        return FALSE;
    }

    //
    // event handle created ok
    //

    RememberPipeIo(&pipeio);
    success = ReadFile(Handle, Buffer, Buflen, BytesRead, &pipeio.Overlapped);
    if (!success) {
        error = GetLastError();
        if (error == ERROR_IO_PENDING) {
            error = WaitForSingleObject(pipeio.Overlapped.hEvent, NAMED_PIPE_TIMEOUT);
            bWaited = TRUE;
            if (error == 0xffffffff) {
                error = GetLastError();
            } else {
                success = (error == WAIT_OBJECT_0);
            }

        } else {

#if DBG
            IF_DEBUG(NAMEPIPE) {
                DbgPrint("VrReadNamedPipe: ReadFile failed: %d\n", GetLastError());
            }
#endif

            //
            // if we got ERROR_MORE_DATA, then this is actually success(!). In this case
            // we don't want to SetLastError, but we do want to set the extended error
            // info in DOS data segment. This is done by demRead
            //

            if (error == ERROR_MORE_DATA) {
                success = TRUE;
            }
        }
    } else {
        error = NO_ERROR;
        dwBytesRead = *BytesRead;
    }

    ForgetPipeIo(&pipeio);
    if (pipeio.Cancelled) {
        error = WAIT_TIMEOUT;
        success = FALSE;
    }

    if (success && bWaited) {

        //
        // get the real bytes read. If GetOverlappedResult returns FALSE,
        // check for ERROR_MORE_DATA
        //

        success = GetOverlappedResult(Handle, &pipeio.Overlapped, &dwBytesRead, FALSE);
        error = success ? NO_ERROR : GetLastError();

        //
        // if we got ERROR_MORE_DATA, then this is actually success(!). In this case
        // we don't want to SetLastError, but we do want to set the extended error
        // info in DOS data segment. This is done by demRead
        //

        if (error == ERROR_MORE_DATA) {
            success = TRUE;
        }
    } else if (error == WAIT_TIMEOUT) {
        CloseHandle(Handle);
        VrpRemoveOpenNamedPipeInfo(Handle);
    }

    CloseHandle(pipeio.Overlapped.hEvent);

    //
    // if no bytes were read and success was returned then treat this as an
    // error - this is what the DOS Redir does
    //

    if (error == NO_ERROR && dwBytesRead == 0) {
        error = ERROR_NO_DATA;
        success = FALSE;
    }

    if (!success) {

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrReadNamePipe: Error: Returning %d\n", error);
        }
#endif

        SetLastError(error);
    } else {
        *BytesRead = dwBytesRead;

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrReadNamePipe: Ok: %d bytes read from pipe\n", *BytesRead);
        }
#endif

    }

    //
    // set the error code so that we can set the extended error code info
    // from demRead and return the success/failure indication
    //

    *Error = error;
    return success;
}


BOOL
VrWriteNamedPipe(
    IN  HANDLE  Handle,
    IN  LPBYTE  Buffer,
    IN  DWORD   Buflen,
    OUT LPDWORD BytesWritten
    )

/*++

Routine Description:

    Performs WriteFile on a named pipe handle. All named pipes are opened in
    overlapped-IO mode because async read/writes cannot be performed otherwise

Arguments:

    Handle          - of opened NamedPipe
    Buffer          - client (VDM) data buffer
    Buflen          - size of write
    BytesWritten    - where actual bytes written is returned

Return Value:

    BOOL
        TRUE    - handle was successfully written
        FALSE   - an error occurred, use GetLastError

--*/

{
    OVERLAPPED_PIPE_IO pipeio;
    BOOL success;
    DWORD error;

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrWriteNamePipe(0x%08x, %x, %d)\n", Handle, Buffer, Buflen);
    }
#endif

    //
    // create an event to wait on. This goes in the overlapped structure - it
    // is the only thing in the overlapped structure we are interested in.
    // Create the event with manual reset. This is so that if the I/O operation
    // completes immediately, we don't wait on the event. If we create the
    // event as auto-reset, it can go into the signalled state, and back to the
    // not-signalled state before we prime the wait, causing us to wait forever
    // for an event that has already occurred
    //

    RtlZeroMemory(&pipeio, sizeof(pipeio));
    if ((pipeio.Overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        success = FALSE;
    } else {
        RememberPipeIo(&pipeio);
        success = WriteFile(Handle, Buffer, Buflen, BytesWritten, &pipeio.Overlapped);
        error = success ? NO_ERROR : GetLastError();
        if (error == ERROR_IO_PENDING) {
            error = WaitForSingleObject(pipeio.Overlapped.hEvent, NAMED_PIPE_TIMEOUT);
            if (error == 0xffffffff) {
                error = GetLastError();
            } else {
                success = (error == WAIT_OBJECT_0);
            }
        }
        ForgetPipeIo(&pipeio);
        if (pipeio.Cancelled) {
            error = WAIT_TIMEOUT;
            success = FALSE;
        }
    }
    if (success) {

        //
        // get the real bytes written
        //

        GetOverlappedResult(Handle, &pipeio.Overlapped, BytesWritten, FALSE);
    }
    CloseHandle(pipeio.Overlapped.hEvent);
    if (!success) {

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrWriteNamePipe: Error: Returning %d\n", error);
        }
#endif

        SetLastError(error);
        if (error == WAIT_TIMEOUT) {
            CloseHandle(Handle);
            VrpRemoveOpenNamedPipeInfo(Handle);
        }
    }

#if DBG

    else {
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrWriteNamePipe: Ok: %d bytes written to pipe\n", *BytesWritten);
        }
    }

#endif

    return success;
}


//
// externally callable helpers
//

BOOL
VrIsNamedPipeName(
    IN LPSTR Name
    )

/*++

Routine Description:

    Checks if a string designates a named pipe. As criteria for the decision
    we use:

        \\computername\PIPE\...

    DOS (client-side) can only open a named pipe which is created at a server
    and must therefore be prefixed by a computername

    We *know* that Name has just been used to successfully open a handle to
    a named <something>, so it should at least be semi-sensible. We can
    assume the following:

        * ASCIZ string
        * an LPSTR points at a single byte (& therefore ++ will add 1)

    But we can't assume the following:

        * Canonicalized name

Arguments:

    Name    - to check for (Dos) named pipe syntax

Return Value:

    BOOL
        TRUE    - Name refers to (local or remote) named pipe
        FALSE   - Name doesn't look like name of pipe

--*/

{
    int     CharCount;

#if DBG
    LPSTR   OriginalName = Name;
#endif

    if (IS_ASCII_PATH_SEPARATOR(*Name)) {
        ++Name;
        if (IS_ASCII_PATH_SEPARATOR(*Name)) {
            ++Name;
            CharCount = 0;
            while (*Name && !IS_ASCII_PATH_SEPARATOR(*Name)) {
                ++Name;
                ++CharCount;
            }
            if (!CharCount || !*Name) {

                //
                // Name is \\ or \\\ or just \\name which I don't understand,
                // so its not a named pipe - fail it
                //

#if DBG
                IF_DEBUG(NAMEPIPE) {
                    DbgPrint("VrIsNamedPipeName - returning FALSE for %s\n", OriginalName);
                }
#endif
                return FALSE;
            }

            //
            // bump name past next path separator. Note that we don't have to
            // check CharCount for max. length of a computername, because this
            // function is called only after the (presumed) named pipe has been
            // successfully opened, therefore we know that the name has been
            // validated
            //

            ++Name;
        } else {

#if DBG
            IF_DEBUG(NAMEPIPE) {
                DbgPrint("VrIsNamedPipeName - returning FALSE for %s\n", OriginalName);
            }
#endif

            return FALSE;

        }

        //
        // We are at <something> (after \ or \\<name>\). Check if <something>
        // is [Pp][Ii][Pp][Ee][\\/]
        //

        if (!_strnicmp(Name, "PIPE", 4)) {
            Name += 4;
            if (IS_ASCII_PATH_SEPARATOR(*Name)) {

#if DBG
                IF_DEBUG(NAMEPIPE) {
                    DbgPrint("VrIsNamedPipeName - returning TRUE for %s\n", OriginalName);
                }
#endif

                return TRUE;
            }
        }
    }

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrIsNamedPipeName - returning FALSE for %s\n", OriginalName);
    }
#endif

    return FALSE;
}


BOOL
VrIsNamedPipeHandle(
    IN HANDLE Handle
    )

/*++

Routine Description:

    Checks if Handle appears in the list of known named pipe handles. Callable
    from outside this module

Arguments:

    Handle  - of suspected name pipe

Return Value:

    BOOL
        TRUE    Handle refers to an open named pipe
        FALSE   Don't know what Handle refers to

--*/

{
    return VrpGetOpenNamedPipeInfo(Handle) != NULL;
}


LPSTR
VrConvertLocalNtPipeName(
    OUT LPSTR Buffer OPTIONAL,
    IN LPSTR Name
    )

/*++

Routine Description:

    Converts a pipe name of the form \\<local-machine-name>\pipe\name to
    \\.\pipe\name

    If non-NULL pointer is returned, the buffer contains a canonicalized
    name - any forward-slash characters (/) are converted to backward-slash
    characters (\). In the interest of future-proofing, the name is not
    upper-cased

    Assumes: Name points to a named pipe specification (\\Server\PIPE\name)

    Note: it is possible to supply the same input and output buffers and have
          the conversion take place in situ. However, this is a side-effect
          of the fact the input computername is replaced by effectively a
          computername of length 1. Nevertheless, it is safe

Arguments:

    Buffer  - pointer to CHAR array where name is placed. If this parameter
              is not present then this routine will allocate a buffer (using
              LocalAlloc and return that
    Name    - pointer to ASCIZ pipe name

Return Value:

    LPSTR   - pointer to buffer containing name or NULL if failed

--*/

{
    DWORD prefixLength; // length of \\computername
    DWORD pipeLength;   // length of pipe name without computername/device prefix
    LPSTR pipeName;     // \PIPE\name...
    static char ThisComputerName[MAX_COMPUTERNAME_LENGTH+1] = {0};
    static DWORD ThisComputerNameLength = 0xffffffff;
    BOOLEAN mapped = FALSE;

    ASSERT(Name);
    ASSERT(IS_ASCII_PATH_SEPARATOR(Name[0]) && IS_ASCII_PATH_SEPARATOR(Name[1]));

    //
    // first time round, get the computername. If this fails assume there is no
    // computername (i.e. no network)
    //

    if (ThisComputerNameLength == 0xffffffff) {
        ThisComputerNameLength = sizeof(ThisComputerName);
        if (!GetComputerName((LPTSTR)&ThisComputerName, &ThisComputerNameLength)) {
            ThisComputerNameLength = 0;
        }
    }

    if (!ARGUMENT_PRESENT(Buffer)) {
        Buffer = (LPSTR)LocalAlloc(LMEM_FIXED, strlen(Name)+1);
    }

    if (Buffer) {
        pipeName = strchr(Name+2, '\\');    // starts \pipe\...
        if (!pipeName) {
            pipeName = strchr(Name+2, '/');
        }
        ASSERT(pipeName);

        if ( NULL == pipeName ) {
             LocalFree ( (HLOCAL)Buffer );
             return NULL;
        }

        pipeLength = strlen(pipeName);
        prefixLength = (DWORD)pipeName - (DWORD)Name;
        if (ThisComputerNameLength && (prefixLength - 2 == ThisComputerNameLength)) {
            if (!_strnicmp(ThisComputerName, &Name[2], ThisComputerNameLength)) {
                strcpy(Buffer, LOCAL_DEVICE_PREFIX);
                mapped = TRUE;
            }
        }
        if (!mapped) {
            strncpy(Buffer, Name, prefixLength);
            Buffer[prefixLength] = 0;

        }
        strcat(Buffer, pipeName);

        //
        // convert any forward-slashes to backward-slashes
        //


        do {
            if (pipeName = strchr(Buffer, '/')) {
                *pipeName++ = '\\';
            }
        } while (pipeName);

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrConvertLocalNtPipeName - returning %s\n", Buffer);
        }
#endif

    }

    return Buffer;
}


//
// Private utilities
//

//
// Private list of open named pipe info structures for this VDM process, and
// associated manipulation routines
//

PRIVATE
POPEN_NAMED_PIPE_INFO   OpenNamedPipeInfoList = NULL;

PRIVATE
POPEN_NAMED_PIPE_INFO   LastOpenNamedPipeInfo = NULL;

PRIVATE
BOOL
VrpAddOpenNamedPipeInfo(
    IN HANDLE Handle,
    IN LPSTR PipeName
    )

/*++

Routine Description:

    When a named pipe is successfully opened, we call this routine to
    associate an open handle and a pipe name. This is required by
    DosQNmPipeInfo (VrGetNamedPipeInfo)

Arguments:

    Handle      - The handle returned from CreateFile (in demOpen)
    PipeName    - Name of pipe being opened

Return Value:

    BOOL
        TRUE    - created a OPEN_NAMED_PIPE_INFO structure and added to list
        FALSE   - couldn't get memory, or couldn't create event. Use GetLastError
                  if you really want to know why this failed

--*/

{
    POPEN_NAMED_PIPE_INFO PipeInfo;
    DWORD NameLength;

    //
    // grab a OPEN_NAMED_PIPE_INFO structure
    //

    NameLength = strlen(PipeName) + 1;
    PipeInfo = (POPEN_NAMED_PIPE_INFO)
                LocalAlloc(LMEM_FIXED,
                    ROUND_UP_COUNT((sizeof(OPEN_NAMED_PIPE_INFO) + NameLength),
                        sizeof(DWORD)
                        )
                    );

    //
    // if we cannot claim memory here, we should *really* close the pipe and
    // return an insufficient memory error to the VDM. However, I don't expect
    // us to run out of memory
    //

    if (PipeInfo == NULL) {

#if DBG
        IF_DEBUG(NAMEPIPE) {
            DbgPrint("VrpAddOpenNamedPipeInfo: couldn't allocate structure - returning FALSE\n");
        }
#endif

        return FALSE;
    }

    //
    // fill it in
    //

    PipeInfo->Next = NULL;
    PipeInfo->Handle = Handle;
    PipeInfo->NameLength = NameLength;
    strcpy(PipeInfo->Name, PipeName);   // from DOS, so its old-fashioned ASCII

    //
    // put it at the end of the list
    //

    if (LastOpenNamedPipeInfo == NULL) {
        OpenNamedPipeInfoList = PipeInfo;
    } else {
        LastOpenNamedPipeInfo->Next = PipeInfo;
    }
    LastOpenNamedPipeInfo = PipeInfo;

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrpAddOpenNamedPipeInfo - adding structure @ %08x, Handle=0x%08x, Name=%s\n",
            PipeInfo,
            PipeInfo->Handle,
            PipeInfo->Name
            );
    }
#endif

    return TRUE;
}


PRIVATE
POPEN_NAMED_PIPE_INFO
VrpGetOpenNamedPipeInfo(
    IN HANDLE Handle
    )

/*++

Routine Description:

    Linear search for an OPEN_NAMED_PIPE_INFO structure in OpenNamedPipeInfoList
    using the handle as search criteria

Arguments:

    Handle  - to search for

Return Value:

    POPEN_NAMED_PIPE_INFO
        Success - Pointer to located structure
        Failure - NULL

--*/

{
    POPEN_NAMED_PIPE_INFO ptr;

    for (ptr = OpenNamedPipeInfoList; ptr; ptr = ptr->Next) {
        if (ptr->Handle == Handle) {
            break;
        }
    }
    return ptr;
}


PRIVATE
BOOL
VrpRemoveOpenNamedPipeInfo(
    IN HANDLE Handle
    )

/*++

Routine Description:

    Unlinks and frees an OPEN_NAMED_PIPE_INFO structure from
    OpenNamedPipeInfoList

    Note: Assumes that the Handle is in the list (no action taken if not
    found)

Arguments:

    Handle  - defining OPEN_NAMED_PIPE_INFO structure to remove from list

Return Value:

    BOOL
        TRUE    - OPEN_NAMED_PIPE_INFO structure corresponding to Handle was
                  removed from list and freed
        FALSE   - OPEN_NAMED_PIPE_INFO structure corresponding to Handle was
                  not found

--*/

{
    POPEN_NAMED_PIPE_INFO ptr, prev = NULL;

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrpRemoveOpenNamedPipeInfo(0x%08x)\n", Handle);
        DumpOpenPipeList();
        DumpRequestQueue();
    }
#endif

    for (ptr = OpenNamedPipeInfoList; ptr; ) {
        if (ptr->Handle == Handle) {
            if (!prev) {
                OpenNamedPipeInfoList = ptr->Next;
            } else {
                prev->Next = ptr->Next;
            }
            if (LastOpenNamedPipeInfo == ptr) {
                LastOpenNamedPipeInfo = prev;
            }

#if DBG
            IF_DEBUG(NAMEPIPE) {
                DbgPrint("VrpRemoveOpenNamedPipeInfo - freeing structure @ %08x, Handle=0x%08x, Name=%s\n",
                    ptr,
                    ptr->Handle,
                    ptr->Name
                    );
            }
#endif

            LocalFree(ptr);
            return TRUE;
        } else {
            prev = ptr;
            ptr = ptr->Next;
        }
    }

#if DBG
    IF_DEBUG(NAMEPIPE) {
        DbgPrint("VrpRemoveOpenNamedPipeInfo: Can't find 0x%08x in list\n", Handle);
    }
#endif

    return FALSE;
}


PRIVATE
VOID
RememberPipeIo(
    IN POVERLAPPED_PIPE_IO PipeIo
    )

/*++

Routine Description:

    Adds an OVERLAPPED_PIPE_IO structure to the list of in-progress named pipe
    I/Os

Arguments:

    PipeIo  - pointer to OVERLAPPED_PIPE_IO structure to add to list

Return Value:

    None.

--*/

{
    //
    // just stick this at front of list; order is not important - this is just
    // a stack of in-progress requests
    //

    PipeIo->Thread = GetCurrentThreadId();
    EnterCriticalSection(&VrNamedPipeCancelCritSec);
    PipeIo->Next = PipeIoQueue;
    PipeIoQueue = PipeIo;
    LeaveCriticalSection(&VrNamedPipeCancelCritSec);
}


PRIVATE
VOID
ForgetPipeIo(
    IN POVERLAPPED_PIPE_IO PipeIo
    )

/*++

Routine Description:

    Removes an OVERLAPPED_PIPE_IO structure from the list of in-progress named
    pipe I/Os

Arguments:

    PipeIo  - pointer to OVERLAPPED_PIPE_IO structure to remove

Return Value:

    None.

--*/

{
    POVERLAPPED_PIPE_IO prev, ptr;

    EnterCriticalSection(&VrNamedPipeCancelCritSec);
    for (ptr = PipeIoQueue, prev = (POVERLAPPED_PIPE_IO)&PipeIoQueue; ptr && ptr != PipeIo; ) {
        prev = ptr;
        ptr = ptr->Next;
    }
    if (ptr == PipeIo) {
        prev->Next = ptr->Next;
    }
    LeaveCriticalSection(&VrNamedPipeCancelCritSec);
}


#if DBG
VOID DumpOpenPipeList()
{
    POPEN_NAMED_PIPE_INFO ptr = OpenNamedPipeInfoList;

    DbgPrint("DumpOpenPipeList\n");

    if (!ptr) {
        DbgPrint("DumpOpenPipeList: no open named pipe structures\n");
    } else {
        while (ptr) {
            DbgPrint("\n"
                     "OPEN_NAMED_PIPE_INFO structure @%08x:\n"
                     "Next. . . . . . . . . . %08x\n"
                     "Handle. . . . . . . . . %08x\n"
                     "NameLength. . . . . . . %d\n"
                     "DosPdb. . . . . . . . . %04x\n"
                     "Name. . . . . . . . . . %s\n",
                     ptr,
                     ptr->Next,
                     ptr->Handle,
                     ptr->NameLength,
                     ptr->DosPdb,
                     ptr->Name
                     );
            ptr = ptr->Next;
        }
        DbgPrint("\n");
    }
}

VOID DumpRequestQueue()
{
    PDOS_ASYNC_NAMED_PIPE_INFO ptr;

    DbgPrint("DumpRequestQueue\n");

    EnterCriticalSection(&VrNmpRequestQueueCritSec);
    ptr = RequestQueueHead;
    if (!ptr) {
        DbgPrint("DumpRequestQueue: no request packets queued\n");
    } else {
        for (; ptr; ptr = ptr->Next) {

            //
            // NT (308c) can't handle all this being put on the stack - gets
            // fault in KdpCopyDataToStack
            //

            DbgPrint("\n"
                     "DOS_ASYNC_NAMED_PIPE_INFO structure @%08x:\n"
                     "Next. . . . . . . . . . %08x\n"
                     "Overlapped.Internal . . %08x\n"
                     "Overlapped.InternalHigh %08x\n"
                     "Overlapped.Offset . . . %08x\n"
                     "Overlapped.OffsetHigh . %08x\n"
                     "Overlapped.hEvent . . . %08x\n",
                     ptr,
                     ptr->Next,
                     ptr->Overlapped.Internal,
                     ptr->Overlapped.InternalHigh,
                     ptr->Overlapped.Offset,
                     ptr->Overlapped.OffsetHigh,
                     ptr->Overlapped.hEvent
                     );
            DbgPrint("Type2 . . . . . . . . . %d\n"
                     "Completed . . . . . . . %d\n"
                     "Handle. . . . . . . . . %08x\n"
                     "Buffer. . . . . . . . . %04x:%04x\n"
                     "BytesTransferred. . . . %d\n"
                     "pBytesTransferred . . . %08x\n"
                     "pErrorCode. . . . . . . %08x\n"
                     "ANR . . . . . . . . . . %04x:%04x\n"
                     "Semaphore . . . . . . . %04x:%04x\n"
                     "RequestType . . . . . . %04x [%s]\n",
                     ptr->Type2,
                     ptr->Completed,
                     ptr->Handle,
                     HIWORD(ptr->Buffer),
                     LOWORD(ptr->Buffer),
                     ptr->BytesTransferred,
                     ptr->pBytesTransferred,
                     ptr->pErrorCode,
                     HIWORD(ptr->ANR),
                     LOWORD(ptr->ANR),
                     HIWORD(ptr->Semaphore),
                     LOWORD(ptr->Semaphore),
                     ptr->RequestType,
                     ptr->RequestType == ANP_READ
                        ? "READ"
                        : ptr->RequestType == ANP_READ2
                            ? "READ2"
                            : ptr->RequestType == ANP_WRITE
                                ? "WRITE"
                                : ptr->RequestType == ANP_WRITE2
                                    ? "WRITE2"
                                    : "*** UNKNOWN REQUEST ***"
                    );
        }
        DbgPrint("\n");
    }
    LeaveCriticalSection(&VrNmpRequestQueueCritSec);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\vrputil.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrputil.c

Abstract:

    Contains 'private' Vdm Redir (Vrp) 32-bit side utility routines:

        VrpMapLastError
        VrpMapDosError
        VrpTranslateDosNetPath

Author:

    Richard L Firth (rfirth) 13-Sep-1991

Environment:

    32-bit flat address space

Revision History:

    13-Sep-1991 RFirth
        Created

--*/

#include <stdio.h>
#include <stdlib.h>     // toupper
#include <nt.h>
#include <ntrtl.h>      // ASSERT, DbgPrint
#include <nturtl.h>
#include <windows.h>
#include <softpc.h>     // x86 virtual machine definitions
#include <vrdlctab.h>
#include <vdmredir.h>   // common Vr stuff
#include <vrinit.h>
#include "vrputil.h"    // prototypes
#include <lmcons.h>
#include <lmerr.h>


WORD
VrpMapLastError(
    VOID
    )

/*++

Routine Description:

    Gets last error code returned by Win32 function and maps it to corresponding
    Dos error

Arguments:

    None.

Return Value:

    WORD        - Dos equivalent error code

--*/

{
    DWORD   LastError;

    LastError = GetLastError();
#ifdef VR_DIAGNOSE
    DbgPrint("VrpMapLastError: last error was %d\n", LastError);
#endif
    return VrpMapDosError(LastError);
}


WORD
VrpMapDosError(
    IN  DWORD   ErrorCode
    )

/*++

Routine Description:

    Maps (DWORD) errors returned from Win32 routines to (WORD) Dos errors

Arguments:

    ErrorCode   - Error code returned from Win32 routine

Return Value:

    WORD        - Dos equivalent error code

--*/

{
    switch (ErrorCode) {
    case NERR_UseNotFound:
        ErrorCode = ERROR_PATH_NOT_FOUND;
        break;
    }
    return (WORD)ErrorCode;
}


WORD
VrpTranslateDosNetPath(
    IN OUT LPSTR* InputString,
    OUT LPSTR* OutputString
    )

/*++

Routine Description:

    Converts a DOS net string: use UPPER CASE, convert / to \. Called with
    net strings, so validates them too - expects \\computername\share.
    computername is 1 <= name <= 15. sharename is 1 <= name <= 8. There must
    be 2 leading back-slashes

    BUGBUG: code page? Kanji? DBCS?

Arguments:

    InputString     - pointer to pointer to string in DOS memory <= LM20_PATHLEN
    OutputString    - pointer to pointer to string in 32-bit memory

Return Value:

    WORD
        Success = 0
            InputString points to one character past the end of the input string
            OutputString points to one character past the end of the output string
        Failure = ERROR_INVALID_PARAMETER

--*/

{
    char ch;
    char lastCh = 0;
    int state = 0;  // 0 = leading slashes; 1 = computer name; 2 = share name
    int slashesToGo = 2;
    int charsToGo = 0;
    int maxLen = LM20_PATHLEN;

    while (ch = *((*InputString)++)) {
        --maxLen;
        if (maxLen < 0) {
            break;
        }
        if (ch == '/') {
            ch = '\\';
        } else {
            ch = (char)toupper(ch);

        }
        if (ch == '\\') {
            --slashesToGo;
            if (slashesToGo < 0) {
                break;
            }
        } else {
            if (lastCh == '\\') {
                if (slashesToGo) {
                    break;
                } else {
                    if (state == 0) {
                        state = 1;
                        charsToGo = LM20_CNLEN;
                        slashesToGo = 1;
                    } else if (state == 1) {
                        state = 2;
                        charsToGo = LM20_NNLEN;
                        slashesToGo = 0;
                    }
                }
            }
            --charsToGo;
            if (charsToGo < 0) {
                break;
            }
        }
        *((*OutputString)++) = ch;
        lastCh = ch;
    }
    *((*OutputString)++) = 0;
    return ch ? (WORD)ERROR_INVALID_PARAMETER : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\vrputil.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vrputil.h

Abstract:

    Contains 'private' Vdm Redir (Vrp) 32-bit side utility routine protoypes:

        VrpMapLastError
        VrpMapDosError

Author:

    Richard L Firth (rfirth) 13-Sep-1991

Environment:

    32-bit flat address space

Revision History:

    13-Sep-1991 RFirth
        Created

--*/



WORD
VrpMapLastError(
    VOID
    );

WORD
VrpMapDosError(
    IN  DWORD   ErrorCode
    );

WORD
VrpTranslateDosNetPath(
    IN OUT LPSTR* InputString,
    OUT LPSTR* OutputString
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmredir\vrremote.c ===
/*++

Copyright (c) 1987-1991  Microsoft Corporation

Module Name:

    vrremote.c

Abstract:

    This module contains a routine VrRemoteApi which is a 16-bit only version
    of RxRemoteApi from the net\rpcxlate project. This routine supports remoted
    lanman APIs from a Virtual Dos Machine.

    This routine does not have to convert 32-16-32, but rather receives 16-bit
    data and sends a 16-bit transaction packet either to a down-level server
    or an NT-level server which must be running XactSrv to respond to this
    request.

    This routine and the support routines in vrremutl.c were lifted from the
    lanman project

    Note: since this is 32-bit code which deals with 16-bit data in a few places,
    32-bit data items should be used where possible and only use 16-bit items
    where unavoidable

    Contents of this file:

        VrRemoteApi
        VrTransaction
        (VrpGetStructureSize)
        (VrpGetArrayLength)
        (VrpGetFieldSize)
        (VrpConvertReceiveBuffer)
        (VrpConvertVdmPointer)
        (VrpPackSendBuffer)

Author:

    Richard L Firth (rfirth) 24-Oct-1991

Environment:

    Flat 32-bit, user space

Revision History:

    21-Oct-1991 rfirth
        Created

--*/

#include <nt.h>
#include <ntrtl.h>      // ASSERT, DbgPrint
#include <nturtl.h>
#include <windows.h>
#include <softpc.h>     // x86 virtual machine definitions
#include <vrdlctab.h>
#include <vdmredir.h>   // common Vr stuff
#include <lmcons.h>
#include <lmerr.h>
#include <lmwksta.h>    // NetWkstaGetInfo
#include <lmapibuf.h>   // NetApiBufferFree
#include <apiworke.h>   // REM_MAX_PARMS
#include <mvdm.h>       // FETCHWORD
#include <vrremote.h>   // prototypes
#include <remtypes.h>
#include <smbgtpt.h>
#include <rxp.h>        // RxpTransactSmb
#include <apinums.h>    // API_W numbers
#include <string.h>
#include <vrdebug.h>

//
// Global data.
//

unsigned short remapi_err_flag;

//
// code
//


NET_API_STATUS
VrTransaction(
    IN      LPSTR   ServerName,
    IN      LPBYTE  SendParmBuffer,
    IN      DWORD   SendParmBufLen,
    IN      LPBYTE  SendDataBuffer,
    IN      DWORD   SendDataBufLen,
    OUT     LPBYTE  ReceiveParmBuffer,
    IN      DWORD   ReceiveParmBufLen,
    IN      LPBYTE  ReceiveDataBuffer,
    IN OUT  LPDWORD ReceiveDataBufLen,
    IN      BOOL    NullSessionFlag
    )

/*++

Routine Description:

    Sends a transaction request to a server and receives a response

Arguments:

    ServerName          - to send request to
    SendParmBuffer      - send parameters
    SendParmBufLen      - length of send parameters
    SendDataBuffer      - send data
    SendDataBufLen      - length of send data
    ReceiveParmBuffer   - receive parameter buffer
    ReceiveParmBufLen   - length of receive parameter buffer
    ReceiveDataBuffer   - where to receive data
    ReceiveDataBufLen   - length of data buffer
    NullSessionFlag     - set if we are to use a null session

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure -

--*/

{
    NET_API_STATUS  status;

    status = RxpTransactSmb(ServerName,

                            //
                            // BUGBUG - transport name?
                            //

                            NULL,
                            SendParmBuffer,
                            SendParmBufLen,
                            SendDataBuffer,
                            SendDataBufLen,
                            ReceiveParmBuffer,
                            ReceiveParmBufLen,
                            ReceiveDataBuffer,
                            ReceiveDataBufLen,
                            NullSessionFlag
                            );
    if (status == NERR_Success) {
    }

    return status;
}


NET_API_STATUS
VrRemoteApi(
    IN  DWORD   ApiNumber,
    IN  LPBYTE  ServerNamePointer,
    IN  LPSTR   ParameterDescriptor,
    IN  LPSTR   DataDescriptor,
    IN  LPSTR   AuxDescriptor OPTIONAL,
    IN  BOOL    NullSessionFlag
    )

/*++

Routine Description:

    This routine creates and sends a 16-bit transaction SMB containing the
    parameters and data required for a remoted function call. Any received
    data is copied back into the caller's data space as 16-bit data. This
    function is being called on behalf of a VDM process which in turn is
    running as a virtual Intel 286 which means:

        * little endian
        * pointers are 32-bits <segment|selector>:<offset>
        * stack is 16-bits wide and EXPANDS DOWN

    This routine is called as a result of the NetIRemoteAPI function being
    called in the VDM. This is an internal function and so the descriptor
    parameters are trusted. However, if the original (16-bit) caller gave
    us a bad buffer address or length then the results will be unpredictable.

    The original API which called NetIRemoteAPI was a pascal calling convention
    routine so if its parameter list was:

    FAR PASCAL
    NetRoutine(server_name, buffer_pointer, buffer_length, &bytes_read, &total);

    the stack would look like this: (note: all pointers are far)

                             +----------------+
            stack pointer => | ip             | routine was called far
                             +----------------+
                             | cs             |
                             +----------------+
                             | &total         | Offset
                             +----------------+
                             | &total         | Segment
                             +----------------+
                             | &bytes_read    | Offset
                             +----------------+
                             | &bytes_read    | Segment
                             +----------------+
                             | buffer_length  |
                             +----------------+
                             | buffer_pointer | Offset
                             +----------------+
                             | buffer_pointer | Segment
                             +----------------+
                             | server_name    | Offset
                             +----------------+
                             | server_name    | Segment
                             +----------------+

    Assumes:

        BYTE  is an 8-bit quantity
        WORD  is a 16-bit quantity
        DWORD is a 32-bit quantity
        LPSTR is a 32-bit flat pointer to an 8-bit quantity

Arguments:

    ApiNumber           - Function number of the API required

    ServerNamePointer   - Flat 32-bit pointer to address of 32-bit segmented
                          far pointer to ASCIZ server name in Dos image.
                          Immediately prior to this is a pascal calling
                          convention stack of 16-bit caller parameters (see
                          above). The server name identifies the server at
                          which the API is to be executed

    ParameterDescriptor - Flat 32-bit pointer to ASCIZ string which describes
                          caller parameters

    DataDescriptor      - Flat 32-bit pointer to ASCIZ string which describes
                          data structure in caller buffer (if any) or structure
                          of data returned from server

    AuxDescriptor       - Flat 32-bit pointer to ASCIZ string which describes
                          auxiliary data structures in send buffer (if any) or
                          structure of aux data returned from server

    NullSessionFlag     - TRUE if we are to use a NULL session

Return Value:

    NET_API_STATUS
        Success - 0
        Failure - NERR_InternalError
                    Return this when we have a bad descriptor character or we
                    blow an internal limit. Basically if we return this its
                    safe to assume the DOS box handed us some garbage (typically
                    a descriptor string got trashed etc)

--*/

{

//
// redefine our parameter identifiers as old-code identifiers
//

#define api_num         ApiNumber
#define servername_ptr  ServerNamePointer
#define parm_str        ParameterDescriptor
#define data_str        DataDescriptor
#define aux_str         AuxDescriptor

//
// define a macro to perform the buffer checking and length and pointer
// manipulation. Either quits the routine and returns ERROR_INVALID_PARAMETER
// or updates parm_len and parm_pos to indicate the next available positions
// and makes this_parm_pos available as the current position to write into
//

#define CHECK_PARAMETERS(len)           \
{                                       \
    parm_len += len;                    \
    if (parm_len > sizeof(parm_buf)) {  \
        return ERROR_INVALID_PARAMETER; \
    }                                   \
    this_parm_pos = parm_pos;           \
    parm_pos += len;                    \
}

    //
    // 32-bit flat pointers and buffers
    //

    BYTE    parm_buf[REM_MAX_PARMS];    // Parameter buffer
    BYTE    computerName[CNLEN+1];
    LPBYTE  parm_pos;                   // Pointer into parm_buf
    LPBYTE  this_parm_pos;              // next place to write in parm_buf
    LPBYTE  parm_ptr;                   // Ponter to stack parms
    LPSTR   l_parm;                     // Used to index parm_str
    LPSTR   l_data;                     // Used to index data_str
    LPSTR   l_aux;                      // Used to index aux_str
    LPBYTE  rcv_data_ptr;               // Pointer to callers rcv buf
    LPBYTE  send_data_ptr;              // Ptr to send buffer to use
    LPBYTE  wkstaInfo;
    LPBYTE  serverName;

    //
    // lengths - 32-bit variables (even though actual lengths are quite small)
    //

    DWORD   parm_len;                   // Length of send parameters
    DWORD   ret_parm_len;               // Length of expected parms
    DWORD   rcv_data_length;            // Length of callers rcv buf
    DWORD   send_data_length;           // Length of callers send buf
    DWORD   parm_num;                   // Callers value for parm_num
    DWORD   struct_size;                // Size of fixed data struct
    DWORD   aux_size;                   // Size of aux data struct
    DWORD   num_struct;                 // Loop count for ptr fixup

    //
    // 16-bit quantities - only used when converting received 16-bit data in
    // caller's receive buffer
    //

    WORD    ReceiveBufferSelector;
    WORD    ReceiveBufferOffset;
    WORD    converter;                  // For pointer fixups

    //
    // various flags
    //

    BOOL    rcv_dl_flag;                // Expect return data flag
    BOOL    send_dl_flag;               // Send data buffer flag
    BOOL    rcv_dp_flag;                // rcv buf ptr present flag
    BOOL    send_dp_flag;               // send buf ptr present flag
    BOOL    parm_num_flag;              // API has a parm_num
    BOOL    alloc_flag;

    //
    // misc. variables
    //

    DWORD   aux_pos;                    // aux structure expected
    DWORD   no_aux_check;               // check flag
    int     len;                        // General purpose length
    API_RET_TYPE    status;             // Return status from remote

    UNICODE_STRING uString;
    ANSI_STRING aString;
    LPWSTR uncName;
    NTSTATUS ntstatus;


    //
    // Clear the internal error flag
    //

    remapi_err_flag = 0;

    //
    // Set found parameter flags to FALSE and ponters to NULL
    //

    rcv_dl_flag     = FALSE;
    send_dl_flag    = FALSE;
    rcv_dp_flag     = FALSE;
    alloc_flag      = FALSE;
    send_dp_flag    = FALSE;
    parm_num_flag   = FALSE;
    rcv_data_length = 0;
    send_data_length= 0;
    parm_num        = 0;
    rcv_data_ptr    = NULL;
    send_data_ptr   = NULL;

    //
    // Set up parm_ptr to point to first of the callers parmeters
    //

    parm_ptr = servername_ptr;
    parm_pos = parm_buf;
    ret_parm_len = 2 * sizeof(WORD);    /* Allow for return status & offset */


    //
    // parse parameter descriptor/build parameter buffer for transaction
    // and get interesting information from 16-bit parameters
    // When finished, the parameter buffer looks like this:
    //
    //  <api_num><parm_desc><data_desc><parms>[<aux_desc>]
    //
    // Remember: DOS only deals with ASCII characters
    //

    *((LPWORD)parm_pos)++ = (WORD)ApiNumber;
    parm_len = sizeof(WORD);

    len = strlen(ParameterDescriptor) + 1;
    parm_len += len;
    if (parm_len > sizeof(parm_buf)) {
        return NERR_InternalError;
    }
    l_parm = parm_pos;
    RtlCopyMemory(parm_pos, ParameterDescriptor, len);
    parm_pos += len;

    len = strlen(DataDescriptor) + 1;
    parm_len += len;
    if (parm_len > sizeof(parm_buf)) {
        return NERR_InternalError;
    }
    l_data = parm_pos;
    RtlCopyMemory(parm_pos, DataDescriptor, len);
    parm_pos += len;

    //
    // parse the parameter descriptor strings. Remember interesting things such
    // as pointers to buffers, buffer lengths, etc.
    //

    for (; *l_parm != '\0'; l_parm++) {
        switch(*l_parm) {
        case REM_WORD:
            CHECK_PARAMETERS(sizeof(WORD));
            parm_ptr -= sizeof(WORD);
            SmbMoveUshort((LPWORD)this_parm_pos, (LPWORD)parm_ptr);
            break;

        case REM_ASCIZ: {
                LPSTR   pstring;

                //
                // the parameter is a pointer to a string. Read the string
                // pointer from the caller's stack then check the string proper.
                // If the pointer is NULL, change the parameter descriptor sent
                // in the SMB to indicate the pointer was NULL at this end
                //

                parm_ptr -= sizeof(LPSTR);
                pstring = LPSTR_FROM_POINTER(parm_ptr);
                if (pstring == NULL) {
                    *(l_parm) = REM_NULL_PTR;
                    break;
                }
                len = strlen(pstring) + 1;
                CHECK_PARAMETERS(len);
                RtlCopyMemory(this_parm_pos, pstring, len);
            }
            break;

        case REM_BYTE_PTR:
        case REM_WORD_PTR:
        case REM_DWORD_PTR: {
                LPBYTE  pointer;

                parm_ptr -= sizeof(LPBYTE);
                pointer = LPBYTE_FROM_POINTER(parm_ptr);
                if (pointer == NULL) {
                    *(l_parm) = REM_NULL_PTR; /* Indicate null pointer */
                    break;
                }
                len = VrpGetArrayLength(l_parm, &l_parm);
                CHECK_PARAMETERS(len);
                RtlCopyMemory(this_parm_pos, pointer, len);
            }
            break;


        case REM_RCV_WORD_PTR:
        case REM_RCV_BYTE_PTR:
        case REM_RCV_DWORD_PTR: {
                LPBYTE  pointer;

                parm_ptr -= sizeof(LPBYTE*);
                pointer = LPBYTE_FROM_POINTER(parm_ptr);

                //
                // Added this test for a NULL pointer to allow for
                // a reserved field (currently MBN) to be a recv
                // pointer. - ERICPE 7/19/89
                //

                if (pointer == NULL) {
                    *(l_parm) = REM_NULL_PTR;
                    break;
                }
                ret_parm_len += VrpGetArrayLength(l_parm, &l_parm);
                if (ret_parm_len > sizeof(parm_buf)) {
                    ASSERT(FALSE);
                    return NERR_InternalError;
                }
            }
            break;

        case REM_DWORD:
            CHECK_PARAMETERS(sizeof(DWORD));
            parm_ptr -= sizeof(DWORD);
            SmbMoveUlong((LPDWORD)this_parm_pos, (LPDWORD)parm_ptr);
            break;

        case REM_RCV_BUF_LEN:
            CHECK_PARAMETERS(sizeof(WORD));
            parm_ptr -= sizeof(WORD);
            SmbMoveUshort((LPWORD)this_parm_pos, (LPWORD)parm_ptr);
            rcv_data_length = (DWORD)SmbGetUshort((LPWORD)parm_ptr);
            rcv_dl_flag = TRUE;
#ifdef VR_DIAGNOSE
            DbgPrint("VrRemoteApi: rcv_data_length=%x\n", rcv_data_length);
#endif
            break;

        case REM_RCV_BUF_PTR:
            parm_ptr -= sizeof(LPBYTE);
            ReceiveBufferOffset = GET_OFFSET(parm_ptr);
            ReceiveBufferSelector = GET_SELECTOR(parm_ptr);
            rcv_data_ptr = LPBYTE_FROM_POINTER(parm_ptr);
            rcv_dp_flag = TRUE;
#ifdef VR_DIAGNOSE
            DbgPrint("VrRemoteApi: Off=%x, Sel=%x, data_ptr=%x\n",
                ReceiveBufferOffset, ReceiveBufferSelector, rcv_data_ptr);
#endif
            break;

        case REM_SEND_BUF_PTR:
            parm_ptr -= sizeof(LPBYTE);
            send_data_ptr = LPBYTE_FROM_POINTER(parm_ptr);
            send_dp_flag = TRUE;
            break;

        case REM_SEND_BUF_LEN:
            parm_ptr -= sizeof(WORD);
            send_data_length = (DWORD)SmbGetUshort((LPWORD)parm_ptr);
            send_dl_flag = TRUE;
            break;

        case REM_ENTRIES_READ:
            ret_parm_len += sizeof(WORD);
            if (ret_parm_len > sizeof(parm_buf)) {
                ASSERT(FALSE);
                return NERR_InternalError;
            }
            parm_ptr -= sizeof(LPBYTE);
            break;

        case REM_PARMNUM:
            CHECK_PARAMETERS(sizeof(WORD));
            parm_ptr -= sizeof(WORD);
            parm_num = (DWORD)SmbGetUshort((LPWORD)parm_ptr);
            SmbMoveUshort((LPWORD)this_parm_pos, (LPWORD)parm_ptr);
            parm_num_flag = TRUE;
            break;

        case REM_FILL_BYTES:

            //
            // This is a rare type but is needed to ensure that the
            // send paramteres are at least as large as the return
            // parameters so that buffer management can be simplified
            // on the server.
            //

            len = VrpGetArrayLength(l_parm, &l_parm);
            CHECK_PARAMETERS(len);
            break;

        default:        /* Could be a digit from NULL send array */
            break;
        }
    }

    //
    // The parameter buffer now contains ;
    // api_num      - word
    // parm_str     - asciz, (NULL c,i,f,z identifiers replaced with Z.
    // data_str     - asciz
    // parameters   - as identified by parm_str.
    //

    //
    // For the receive buffer there is no data to set up for the call
    // but there might have been an REM_AUX_COUNT descriptor in data_str
    // which requires the aux_str to be copied onto the end of the
    // parameter buffer.
    //

    if (rcv_dp_flag || send_dp_flag) {
        //
        // Find the length of the fixed length portion of the data
        // buffer.
        //

        struct_size = VrpGetStructureSize(l_data, &aux_pos);
        if (aux_pos != -1) {
            l_aux = aux_str;
            len = strlen(l_aux) + 1;       /* Length of aux descriptor */
            CHECK_PARAMETERS(len);
            RtlCopyMemory(this_parm_pos, aux_str, len);
            aux_size = VrpGetStructureSize(l_aux, &no_aux_check);
            if (no_aux_check != -1) {        /* Error if N in aux_str */
                ASSERT(FALSE);
                return NERR_InternalError;
            }
        }
    }

    //
    // For a send buffer the data pointed to in the fixed structure
    // must be copied into the send buffer. Any pointers which already
    // point in the send buffer are NULLed as it is illegal to use
    // the buffer for the send data, it is our transport buffer.
    // NOTE - if parmnum was specified the buffer contains only that
    // element of the structure so no length checking is needed at this
    // side. A parmnum for a pointer type means that the data is at the
    // start of the buffer so there is no copying to be done.
    //


    if (send_dp_flag) {
        //
        // Only process buffer if no parm_num and this is not a block send
        // (no data structure) or an asciz concatenation send
        //

        if ((parm_num == 0) && (*l_data != REM_DATA_BLOCK)) {
            status = VrpPackSendBuffer(
                        &send_data_ptr,
                        &send_data_length,
                        &alloc_flag,
                        data_str,
                        aux_str,
                        struct_size,
                        aux_pos,
                        aux_size,
                        parm_num_flag,
                        FALSE
                        );
            if (status != 0) {
                return status;
            }
        }
    }

    //
    // Check for an internal error prior to issuing the transaction
    //

    if (remapi_err_flag != 0) {
        if (alloc_flag) {
            LocalFree(send_data_ptr);
        }
        return NERR_InternalError;
    }

    //
    // get the server name. If it is NULL then we are faking a local API call
    // by making a remote call to XactSrv on this machine. Fill in our computer
    // name
    //

    serverName = LPSTR_FROM_POINTER(servername_ptr);

////////////////////////////////////////////////////////////////////////////////
//// is this actually required any longer?

    if (serverName == NULL) {
        status = NetWkstaGetInfo(NULL, 100, &wkstaInfo);
        if (status) {
            if (alloc_flag) {
                LocalFree(send_data_ptr);
            }
            return status;
        } else {
            computerName[0] = computerName[1] = '\\';

            //
            // BUGBUG - Unicode - ASCII conversion here
            //

            strcpy(computerName+2,
                    (LPSTR)((LPWKSTA_INFO_100)wkstaInfo)->wki100_computername);
            NetApiBufferFree(wkstaInfo);
            serverName = computerName;
#ifdef VR_DIAGNOSE
            DbgPrint("VrRemoteApi: computername is %s\n", serverName);
#endif
        }
    }

////////////////////////////////////////////////////////////////////////////////

    //
    // The parameter buffers and data buffers are now set up for
    // sending to the API worker so call transact to send them.
    //

    RtlInitAnsiString(&aString, serverName);
    ntstatus = RtlAnsiStringToUnicodeString(&uString, &aString, (BOOLEAN)TRUE);
    if (!NT_SUCCESS(ntstatus)) {

#if DBG
        IF_DEBUG(NETAPI) {
            DbgPrint("VrRemoteApi: Unexpected situation: RtlAnsiStringToUnicodeString returns %x\n", ntstatus);
        }
#endif

        return ERROR_NOT_ENOUGH_MEMORY;
    }
    uncName = uString.Buffer;

#if DBG
    IF_DEBUG(NETAPI) {
        DbgPrint("VrpTransactVdm: UncName=%ws\n", uncName);
    }
#endif

    status = RxpTransactSmb((LPTSTR)uncName,

                            //
                            // BUGBUG - transport name?
                            //

                            NULL,
                            parm_buf,               // Send parm buffer
                            parm_len,               // Send parm length
                            send_data_ptr,          // Send data buffer
                            send_data_length,       // Send data length
                            parm_buf,               // Rcv prm buffer
                            ret_parm_len,           // Rcv parm length
                            rcv_data_ptr,           // Rcv data buffer
                            &rcv_data_length,       // Rcv data length
                            NullSessionFlag
                            );
    RtlFreeUnicodeString(&uString);

    if (status) {
#ifdef VR_DIAGNOSE
        DbgPrint("Error: VrRemoteApi: RxpTransactSmb returns %d(%x)\n",
            status, status);
#endif
        switch (status) {
        case NERR_BufTooSmall:  /* No data returned from API worker */
            rcv_data_length = 0;
            break;

        case ERROR_MORE_DATA:   /* Just a warning for the caller */
            break;

        case NERR_TooMuchData:  /* Just a warning for the caller */
            break;

        default:
            rcv_data_length = 0;
            break;
        }
    }

    /* The API call was successful. Now translate the return buffers
     * into the local API format.
     *
     * First copy any data from the return parameter buffer into the
     * fields pointed to by the original call parmeters.
     * The return parameter buffer contains;
     *      status,         (unsigned short)
     *      converter,      (unsigned short)
     *      ...             - fields described by rcv ptr types in parm_str
     */

    parm_pos = parm_buf + sizeof(WORD);
    converter = (WORD)SmbGetUshort((LPWORD)parm_pos);
    parm_pos += sizeof(WORD);

    //
    // Set up parm_ptr to point to first of the callers parmeters
    //

    parm_ptr = servername_ptr;

    //
    // set default value of num_struct to 1, if data, 0 if no data
    //

    num_struct = (DWORD)((*data_str == '\0') ? 0 : 1);

    for (; *parm_str != '\0'; parm_str++) {
        switch (*parm_str) {
        case REM_RCV_WORD_PTR:
        case REM_RCV_BYTE_PTR:
        case REM_RCV_DWORD_PTR: {
                LPBYTE  ptr;

                parm_ptr -= sizeof(LPBYTE*);
                ptr = LPBYTE_FROM_POINTER(parm_ptr);

                //
                // if the rcv buffer given to us by the user is NULL,
                // (one currently can be - it is an MBZ parameter for
                // now in the log read apis...), don't attempt to
                // copy anything. len will be garbage in this
                // case, so don't update parm_pos either.  All we
                // use VrpGetArrayLength for is to update parm_str if
                // the parameter was NULL.
                //

                if (ptr != NULL) {
                    len = VrpGetArrayLength(parm_str, &parm_str);
                    RtlCopyMemory(ptr, parm_pos, len);

                    //
                    // This gross hack is to fix the problem that a
                    // down level spooler (Lan Server 1.2)
                    // do not perform level checking
                    // on the w functions of the api(s):
                    // DosPrintQGetInfo
                    // and thus can return NERR_Success
                    // and bytesavail == 0.  This combination
                    // is technically illegal, and results in
                    // us attempting to unpack a buffer full of
                    // garbage.  The following code detects this
                    // condition and resets the amount of returned
                    // data to zero so we do not attempt to unpack
                    // the buffer.  Since we know the reason for the
                    // mistake at the server end is that we passed
                    // them a new level, we return ERROR_INVALID_LEVEL
                    // in this case.
                    // ERICPE, 5/16/90.
                    //

                    if ((api_num == API_WPrintQGetInfo)
                    && (status == NERR_Success)
                    && (*parm_str == REM_RCV_WORD_PTR)
                    && (*(LPWORD)ptr == 0)) {
                        rcv_data_length = 0;
                        status = ERROR_INVALID_LEVEL;
                    }

                    //
                    // END OF GROSS HACK
                    //

                    parm_pos += len;
                }
            }
            break;

        case REM_ENTRIES_READ: {
                LPWORD  wptr;

                parm_ptr -= sizeof(LPWORD*);
                wptr = (LPWORD)POINTER_FROM_POINTER(parm_ptr);
                num_struct = (DWORD)SmbGetUshort((LPWORD)parm_pos);
                SmbPutUshort((LPWORD)wptr, (WORD)num_struct);
                parm_pos += sizeof(WORD);
            }
            break;

        case REM_FILL_BYTES:
            //
            // Special case, this was not really an input parameter
            // so parm_ptr does not get changed. However, the parm_str
            // pointer must be advanced past the descriptor field so
            // use get VrpGetArrayLength to do this but ignore the
            // return length.
            //

            VrpGetArrayLength(parm_str, &parm_str);
            break;

        default:
            //
            // If the descriptor was not a rcv pointer type then step
            // over the parmeter pointer.
            //

            parm_ptr -= VrpGetFieldSize(parm_str, &parm_str);
        }
    }

    //
    // Now convert all pointer fields in the receive buffer to local
    // pointers.
    //

    if (rcv_dp_flag && (rcv_data_length != 0)) {
        VrpConvertReceiveBuffer(
            rcv_data_ptr,           // lp
            ReceiveBufferSelector,  // word
            ReceiveBufferOffset,    // word
            converter,              // word
            num_struct,             // dword
            data_str,               // lp
            aux_str                 // lp
            );
    }

    if (alloc_flag) {
        LocalFree(send_data_ptr);
    }

    if (remapi_err_flag != 0) {
        return NERR_InternalError;
    }

    return status;
}


DWORD
VrpGetStructureSize(
    IN  LPSTR   Descriptor,
    IN  LPDWORD AuxOffset
    )

/*++

Routine Description:

    Calculates the length of the fixed portion of a structure, based on the
    descriptor for that structure

Arguments:

    Descriptor  - pointer to ASCIZ data descriptor string
    AuxOffset   - pointer to returned dword which is relative position in the
                  data descriptor where a REM_AUX_NUM descriptor was found
                  This will be set to -1 if no aux descriptor found

Return Value:

    Length in bytes of structure described by Descriptor

--*/

{
    DWORD   length;
    char    c;

    *AuxOffset = (DWORD)(-1);
    for (length = 0; (c = *Descriptor) != '\0'; Descriptor++) {
        if (c == REM_AUX_NUM) {
            *AuxOffset = length;
            length += sizeof(WORD);
        } else {
            length += VrpGetFieldSize(Descriptor, &Descriptor);
        }
    }
    return length;
}


DWORD
VrpGetArrayLength(
    IN  LPSTR   Descriptor,
    IN  LPSTR*  pDescriptor
    )

/*++

Routine Description:

    Calculates the length of an array described by an element of a
    descriptor string and update the descriptor string pointer to point
    to the last char in the element of the descriptor string.

Arguments:

    Descriptor  - pointer to ASCIZ descriptor string
    pDescriptor - pointer to address of Descriptor

Return Value:

    Length in bytes of array described by Descriptor

--*/

{
    DWORD   num_elements;
    DWORD   element_length;

    //
    // First set length of an element in the array
    //

    switch (*Descriptor) {
    case REM_WORD:
    case REM_WORD_PTR:
    case REM_RCV_WORD_PTR:
        element_length = sizeof(WORD);
        break;

    case REM_DWORD:
    case REM_DWORD_PTR:
    case REM_RCV_DWORD_PTR:
        element_length = sizeof(DWORD);
        break;

    case REM_BYTE:
    case REM_BYTE_PTR:
    case REM_RCV_BYTE_PTR:
    case REM_FILL_BYTES:
        element_length = sizeof(BYTE);
        break;

    //
    // Warning: following fixes a bug in which "b21" type
    //          combinations in parmeter string will be
    //          handled correctly when pointer to such "bit map"
    //          in the struct is NULL. These two dumbos could
    //          interfere so we  force a success return.
    //

    case REM_ASCIZ:
    case REM_SEND_LENBUF:
    case REM_NULL_PTR:
        return 0;

    default:
        remapi_err_flag = NERR_InternalError;
        ASSERT(FALSE);
        return 0;
    }

    //
    // Now get numeber of elements in the array
    //

    for (num_elements = 0, Descriptor++;
        (*Descriptor <= '9') && (*Descriptor >= '0');
        Descriptor++, (*pDescriptor)++) {
        num_elements = (WORD)((10 * num_elements) + ((WORD)*Descriptor - (WORD)'0'));
    }

    return (num_elements == 0) ? element_length : element_length * num_elements;
}


DWORD
VrpGetFieldSize(
    IN  LPSTR   Descriptor,
    IN  LPSTR*  pDescriptor
    )

/*++

Routine Description:

    Calculates the length of an field described by an element of a
    descriptor string and update the descriptor string pointer to point
    to the last char in the element of the descriptor string.

Arguments:

    Descriptor  - pointer to the descriptor string
    pDescriptor - pointer to the address of the descriptor. On exit
                  this points to the last character in the descriptor
                  just parsed

Return Value:

    Length in bytes of the field parsed

--*/

{
    char c;

    c = *Descriptor;
    if (IS_POINTER(c) || (c == REM_NULL_PTR)) { /* All pointers same size */
        while (*(++Descriptor) <= '9' && *Descriptor >= '0') {
            (*pDescriptor)++;     /* Move ptr to end of field size */
        }
        return sizeof(LPSTR);
    }

    //
    // Here if descriptor was not a pointer type so have to find the field
    // length specifically
    //

    switch (c) {
    case REM_WORD:
    case REM_BYTE:
    case REM_DWORD:
        return VrpGetArrayLength(Descriptor, pDescriptor);

    case REM_AUX_NUM:
    case REM_PARMNUM:
    case REM_RCV_BUF_LEN:
    case REM_SEND_BUF_LEN:
        return sizeof(WORD);

    case REM_DATA_BLOCK:
    case REM_IGNORE:
        return 0;                  /* No structure for this */

    case REM_DATE_TIME:
        return sizeof(DWORD);

    default:
        remapi_err_flag = NERR_InternalError;
#ifdef VR_DIAGNOSE
        DbgPrint("VrpGetFieldSize: offending descriptor is '%c'\n", c);
#endif
        ASSERT(FALSE);
        return 0;
    }
}


VOID
VrpConvertReceiveBuffer(
    IN  LPBYTE  ReceiveBuffer,
    IN  WORD    BufferSelector,
    IN  WORD    BufferOffset,
    IN  WORD    ConverterWord,
    IN  DWORD   NumberStructs,
    IN  LPSTR   DataDescriptor,
    IN  LPSTR   AuxDescriptor
    )

/*++

Routine Description:

    All pointers in the receive buffer are returned from the API worker as
    pointers into the buffer position given to the API on the API worker's
    station. In order to convert them into local pointers the segment
    of each pointer must be set to the segment of the rcv buffer and the offset
    must be set to;

        offset of rcv buffer + offset of pointer - converter word.

    This routine steps through the receive buffer and calls VrpConvertVdmPointer
    to perform the above pointer conversions.

Arguments:

    ReceiveBuffer   - 32-bit flat pointer to 16-bit DOS buffer
    BufferSelector  - 16-bit selector of Dos receive buffer
    BufferOffset    - 16-bit offset of Dos receive buffer
    ConverterWord   - From API worker
    NumberStructs   - Entries read parm (or 1 for GetInfo)
    DataDescriptor  - String for data format
    AuxDescriptor   - string for aux format

Return Value:

    None.

--*/

{
    LPSTR   l_data;
    LPSTR   l_aux;
    DWORD   num_aux;
    DWORD   i, j;
    char    c;


    for (i = 0; i < NumberStructs; i++) {
        //
        // convert all pointers in next primary; if we hit a aux word count
        // remember number of secondary structures
        //

        for (l_data = DataDescriptor, num_aux = 0; c = *l_data; l_data++) {
            if (c == REM_AUX_NUM) {
                num_aux = (DWORD)*(ULPWORD)ReceiveBuffer;
            }
            if (IS_POINTER(c)) {
                VrpConvertVdmPointer(
                    (ULPWORD)ReceiveBuffer,
                    BufferSelector,
                    BufferOffset,
                    ConverterWord
                    );
            }
            ReceiveBuffer += VrpGetFieldSize(l_data, &l_data);
        }

        //
        // convert any pointers in any returned secondary (aux) structures
        //

        for (j = 0; j < num_aux; j++) {
            for (l_aux = AuxDescriptor; c = *l_aux; l_aux++) {
                if (IS_POINTER(c)) {
                    VrpConvertVdmPointer(
                        (ULPWORD)ReceiveBuffer,
                        BufferSelector,
                        BufferOffset,
                        ConverterWord
                        );
                }
                ReceiveBuffer += VrpGetFieldSize(l_aux, &l_aux);
            }
        }
    }
}


VOID
VrpConvertVdmPointer(
    IN  ULPWORD TargetPointer,
    IN  WORD    BufferSegment,
    IN  WORD    BufferOffset,
    IN  WORD    ConverterWord
    )

/*++

Routine Description:

    All pointers in the receive buffer are returned from the API worker as
    pointers into the buffer position given to to the API on the API worker's
    station. In order to convert them into local pointers the segment
    of each pointer must be set to the segment of the rcv buffer and the offset
    must be set to;

        offset of rcv buffer + offset of pointer - converter word.

    The pointer is not converted if it is NULL

Arguments:

    TargetPointer   - 32-bit flat pointer to segmented Dos pointer to convert
    BufferSegment   - 16-bit selector/segment of target buffer in DOS image
    BufferOffset    - 16-bit offset within BufferSegment where buffer starts
    ConverterWord   - 16-bit offset converter word from API worker on server

Return Value:

    None.

--*/

{
    WORD    offset;

    if (*((UCHAR * UNALIGNED *)TargetPointer) != NULL) {
        SET_SELECTOR(TargetPointer, BufferSegment);
        offset = GET_OFFSET(TargetPointer) - ConverterWord;
        SET_OFFSET(TargetPointer, BufferOffset + offset);
    }
}


NET_API_STATUS
VrpPackSendBuffer(
    IN OUT  LPBYTE* SendBufferPtr,
    IN OUT  LPDWORD SendBufLenPtr,
    OUT     LPBOOL  SendBufferAllocated,
    IN OUT  LPSTR   DataDescriptor,
    IN      LPSTR   AuxDescriptor,
    IN      DWORD   StructureSize,
    IN      DWORD   AuxOffset,
    IN      DWORD   AuxSize,
    IN      BOOL    SetInfoFlag,
    IN      BOOL    OkToModifyDescriptor
    )

/*++

Routine Description:

    For a send buffer the data pointed to in the fixed structure
    must be copied into the send buffer. Any pointers which already
    point in the send buffer are NULLed ( or errored if the call is not
    a SetInfo type) as it is illegal to use the buffer for the send data,
    it is our transport buffer

    Note that if the caller's (VDM) buffer is large enough, the variable data
    will be copied there. Eg. if the caller is doing a NetUseAdd which has a
    26 byte fixed structure (use_info_1) and they placed that structure in a
    1K buffer, the remote name will be copied into their own buffer at offset 26.

    The data pointed to is in 16-bit little-endian format; any pointers are
    segmented 16:16 pointers combined in the (thankfully) imitable intel way
    to result in a 20-bit linear (virtual) address

    If this function fails, the caller's buffer pointer and length will not
    have altered. If it succeeds however, *SendBufferPtr and *SendBufLenPtr
    may be different to the values passed, depending on whether
    *SendBufferAllocated is TRUE

Arguments:

    SendBufferPtr       - pointer to pointer to caller's 16-bit send buffer.
                          We may be able to satisfy the send from this buffer
                          if the data is simple (ie no structures to send). If
                          we have to send structured data then we may have to
                          allocate a new buffer in this routine because we need
                          to move all of the caller's data into one buffer and
                          (s)he may not have allocated enough space to hold
                          everything. Additionally, we cannot assume that we
                          can write the caller's data into their own buffer!

    SendBufLenPtr       - pointer to the length of the allocated buffer. If
                          we allocate a buffer in this routine, this length
                          will alter

    SendBufferAllocated - pointer to a flag which will get set (TRUE) if we do
                          actually allocate a buffer in this routine

    DataDescriptor      - pointer to ASCIZ string which describes the primary
                          data structure in the buffer. This may be updated if
                          NULL pointers are found where a REM_ASCIZ descriptor
                          designates a string pointer

    AuxDescriptor       - pointer to ASCIZ string which describes the secondary
                          data structure in the buffer

    StructureSize       - the size (in bytes) of the fixed portion of the
                          primary data structure

    AuxOffset           - offset to the REM_AUX_NUM descriptor ('N') within the
                          data descriptor, or -1 if there isn't one

    AuxSize             - size in bytes of the fixed part of the secondary data
                          structure, if any

    SetInfoFlag         - indication of whether the API was a SetInfo call

    OkToModifyDescriptor- TRUE if we can modify REM_ASCIZ descriptor chars to
                          REM_NULL_PTR in DataDescriptor, if a NULL pointer is
                          found in the structure. Used by VrNet routines which
                          are not calling VrRemoteApi

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - ERROR_NOT_ENOUGH_MEMORY
                  NERR_BufTooSmall
--*/

{

    LPBYTE  struct_ptr;
    LPBYTE  c_send_buf;
    LPBYTE  send_ptr;
    DWORD   c_send_len;
    DWORD   buf_length;
    DWORD   to_send_len;
    DWORD   num_aux;
    LPSTR   data_ptr;
    LPSTR   l_dsc;
    LPSTR   l_str;
    BOOL    alloc_flag = FALSE;
    DWORD   num_struct;
    DWORD   len;
    UCHAR   c;
    DWORD   numberOfStructureTypes;
    DWORD   i, j;
    LPBYTE  ptr;

    //
    // Make local copies of the original start and length of the caller's
    // buffer as the originals may change if malloc is used but they
    // will still be needed for the F_RANGE check.
    //

    struct_ptr = c_send_buf = send_ptr = *SendBufferPtr;
    c_send_len = buf_length = *SendBufLenPtr;

    if ((buf_length < StructureSize) || (AuxOffset == StructureSize)) {
        return NERR_BufTooSmall;
    }

    //
    // if the offset to the REM_AUX_NUM descriptor is not -1 then we have
    // associated secondary structures with this primary. The actual number
    // is embedded in the primary structure. Retrieve it
    //

    if (AuxOffset != -1) {
        num_aux = (DWORD)SmbGetUshort((LPWORD)(send_ptr + AuxOffset));
        to_send_len = StructureSize + (num_aux * AuxSize);
        if (buf_length < to_send_len) {
            return NERR_BufTooSmall;
        }
        numberOfStructureTypes = 2;
    } else {
        to_send_len = StructureSize;
        num_aux = AuxSize = 0;
        numberOfStructureTypes = 1;
    }

    //
    // Set up the data pointer to point past fixed length structures
    //

    data_ptr = send_ptr + to_send_len;

    //
    // Any data pointed to by pointers in the data or aux structures
    // must now be copied into the buffer. Start with the primary data
    // structure.
    //

    l_str = DataDescriptor;
    num_struct = 1;         /* Only one primary structure allowed */

    for (i = 0; i < numberOfStructureTypes;
        l_str = AuxDescriptor, num_struct = num_aux, i++) {
        for (j = 0 , l_dsc = l_str; j < num_struct; j++, l_dsc = l_str) {
            for (; (c = *l_dsc) != '\0'; l_dsc++) {
                if (IS_POINTER(c)) {
                    ptr = LPBYTE_FROM_POINTER(struct_ptr);
                    if (ptr == NULL) {
                        if ((*l_dsc == REM_ASCIZ) && OkToModifyDescriptor) {
#ifdef VR_DIAGNOSE
                            DbgPrint("VrpPackSendBuffer: modifying descriptor to REM_NULL_PTR\n");
#endif
                            *l_dsc = REM_NULL_PTR;
                        }
                        struct_ptr += sizeof(LPBYTE);
                        VrpGetArrayLength(l_dsc, &l_dsc);
                    } else {

                        //
                        // If the pointer is NULL or points inside the
                        // original send buffer ( may have been reallocated)
                        // then NULL it as it is not a field being set OR
                        // return an error for a non SetInfo type call as
                        // it is illegal to have a pointer into the
                        // transport buffer.
                        //

                        if (RANGE_F(ptr, c_send_buf, c_send_len)) {
                            if (SetInfoFlag) {
                                SmbPutUlong((LPDWORD)struct_ptr, 0L);
                                VrpGetArrayLength(l_dsc, &l_dsc);
                                struct_ptr += sizeof(LPSTR);
                            } else {
                                return ERROR_INVALID_PARAMETER;
                            }
                        } else {
                            switch (c) {
                            case REM_ASCIZ:
                                len = strlen(ptr) + 1;
                                break;

                            case REM_SEND_LENBUF:
                                len = *(LPWORD)ptr;
                                break;

                            default:
                                len = VrpGetArrayLength(l_dsc, &l_dsc);
                            }

                            //
                            // There is data to be copied into the send
                            // buffer so check that it will fit.
                            //

                            to_send_len += len;
                            if (to_send_len > buf_length) {
                                buf_length = to_send_len + BUF_INC;
                                if (!alloc_flag) {

                                    //
                                    // Need new buffer
                                    //

                                    send_ptr = (LPBYTE)LocalAlloc(LMEM_FIXED, buf_length);
                                    if (send_ptr == NULL) {
                                        return ERROR_NOT_ENOUGH_MEMORY;
                                    }
                                    alloc_flag = TRUE;

                                    //
                                    // Got new buffer, so copy old buffer
                                    //

                                    RtlCopyMemory(send_ptr, c_send_buf, to_send_len - len);
                                    struct_ptr = send_ptr + (struct_ptr - c_send_buf);
                                    data_ptr = send_ptr + (data_ptr - c_send_buf);
                                } else {
                                    LPBYTE  newPtr;

                                    newPtr = (LPBYTE)LocalReAlloc(send_ptr, buf_length, LMEM_MOVEABLE);
                                    if (newPtr == NULL) {
                                        LocalFree(send_ptr);
                                        return ERROR_NOT_ENOUGH_MEMORY;
                                    } else if (newPtr != send_ptr) {

                                        //
                                        // fix up the pointers
                                        //

                                        data_ptr = newPtr + (data_ptr - send_ptr);
                                        struct_ptr = newPtr + (struct_ptr - send_ptr);
                                        send_ptr = newPtr;
                                    }
                                }
                            }

                            //
                            // There is room for new data in buffer so copy
                            // it and and update the struct and data ptrs
                            //

                            RtlCopyMemory(data_ptr, ptr, len);
                            data_ptr += len;
                            struct_ptr += sizeof(LPBYTE);
                        }
                    }
                } else {

                    //
                    // If the descriptor was not a pointer type then step
                    // over the corresponding data field.
                    //

                    struct_ptr += VrpGetFieldSize(l_dsc, &l_dsc);
                }
            }
        }
    }

    *SendBufferPtr = send_ptr;

    //
    // Note that this is potentially incorrect: we are actually returning the
    // size of the structure + dynamic data to be sent, which is probably not
    // the same as the size of the buffer we (re)allocated. This is how it is
    // done in Lanman, so we'll do the same thing until it breaks
    //

    *SendBufLenPtr = to_send_len;
    *SendBufferAllocated = alloc_flag;

    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmutils\forcedos\forcedos.h ===
#define	ID_NO_FILE		    0
#define	ID_BAD_PATH		    1
#define	ID_BAD_CMDLINE		    2
#define	ID_BAD_DEFDIR		    3
#define	ID_BAD_TEMPFILE 	    4
#define	ID_NO_PIF		    5
#define	ID_BAD_PIF		    6
#define	ID_NO_MEMORY		    7
#define	ID_BAD_PROCESS		    8

// KEEP THEM TOGETHER, The code relies on the sequence.
#define ID_USAGE_00		    20
#define ID_USAGE_01		    21
#define ID_USAGE_02		    22
#define ID_USAGE_03		    23
#define ID_USAGE_04		    24
#define ID_USAGE_BASE		    ID_USAGE_00
#define ID_USAGE_MAX		    ID_USAGE_04


#define MAX_EXTENTION		    3
#define MAX_MSG_LENGTH		    256

BOOL
IsDirectory
(
char  * pDirectory
);

VOID YellAndExit
(
UINT	MsgID,
WORD	ExitCode
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmutils\forcedos\forcedos.c ===
/*++

Module Name:

    forcedos.c

Abstract:
    This program forces NT to treat and execute the given program
    as a DOS application.

Author:

    William Hsieh -  williamh 25-Jan-1993

Revision History:

--*/

/*
   Some applications have Windows or OS/2 executable format while
   run these program under NT, users will get the following message:
   Please run this program under DOS. Since NT selects the subsystem
   for application based on application executable format. There is
   no way for NT to "run this program under DOS". This utility was provided
   for this purpose. We create a pif file for the application and then
   create a process for the pif. Since pif file always goes to NTVDM
   we got the chance to play game on the program. NTVDM will decode
   the pif file and dispatch the program to DOS. All the subsequent program
   exec from the first program will be forced to execute under DOS.
*/
#define UNICODE     1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winnlsp.h>
#include "forcedos.h"

#if DBG
#include <stdio.h>
#endif

WCHAR   * Extention[MAX_EXTENTION];
WCHAR   EXEExtention[] = L".EXE";
WCHAR   COMExtention[] = L".COM";
WCHAR   BATExtention[] = L".BAT";
WCHAR   ProgramNameBuffer[MAX_PATH + 1];
WCHAR   SearchPathName[MAX_PATH + 1];
WCHAR   DefDirectory[MAX_PATH + 1];
char    CommandLine[MAX_PATH + 1];
char    ProgramName[MAX_PATH + 1];
WCHAR   UnicodeMessage[MAX_MSG_LENGTH];
char    OemMessage[MAX_MSG_LENGTH * 2];

#if DBG
BOOL    fOutputDebugInfo = FALSE;
#endif




void
_cdecl
main(
    int argc,
    char **argv
    )
{
   char *SavePtr;

    char    * pCommandLine;
    char    * pCurDirectory;
    char    * pProgramName;
    char    * p;
    BOOL    fDisplayUsage;
    ULONG   i, nChar, Length, CommandLineLength;
    PROCESS_INFORMATION ProcessInformation;
    DWORD   ExitCode, dw;
    STARTUPINFO   StartupInfo;
    PUNICODE_STRING pTebUnicodeString;
    NTSTATUS   Status;
    OEM_STRING OemString, CmdLineString;
    UNICODE_STRING  UnicodeString;
    WCHAR   *pwch, *pFilePart;

    Extention[0] = COMExtention;
    Extention[1] = EXEExtention;
    Extention[2] = BATExtention;

    // Set language code page to system locale.
    SetThreadUILanguage(0);


    pCurDirectory = pProgramName = NULL;
    pCommandLine = CommandLine;
    CommandLineLength = 0;
    pTebUnicodeString = &NtCurrentTeb()->StaticUnicodeString;
    fDisplayUsage = TRUE;


    if ( argc > 1 ) {
   fDisplayUsage = FALSE;

   while (--argc != 0) {
       p = *++argv;
       if (pProgramName == NULL) {
      if (*p == '/' || *p == '-') {
          switch (*++p) {
         case '?':
             fDisplayUsage = TRUE;
             break;
         case 'D':
         case 'd':
             // if the directory follows the /D immediately
             // get it
             if (*++p != 0) {
            pCurDirectory = p;
            break;
             }
             else if (--argc > 1)
             // the next argument must be the curdirectory
                pCurDirectory = *++argv;
             else
                fDisplayUsage = TRUE;
             break;

             default:
             fDisplayUsage = TRUE;
             break;
          }
      }
                else {
                    pProgramName = p;
                    nChar = strlen(p);
                    if(nChar+1 >= sizeof(CommandLine)) {
                       YellAndExit(ID_BAD_CMDLINE, 0xFF);
                    }
                    strncpy(CommandLine, pProgramName, nChar);
                    pCommandLine = CommandLine + nChar;
                    CommandLineLength = nChar + 1;
                }
       }
       else {
      // aggregate command line from all subsequent argvs
      nChar = strlen(p);

      //check if there is enough space to copy

      if(CommandLineLength + nChar + sizeof(" ") >= sizeof(CommandLine)) {
         YellAndExit(ID_BAD_CMDLINE, 0xFF);
      }

      if (CommandLineLength != 0) {
          strncpy(pCommandLine, " ", 1);
          pCommandLine++;
      }
      strncpy(pCommandLine, p, nChar);
      pCommandLine += nChar;
      CommandLineLength += nChar + 1;
       }
       if (fDisplayUsage)
      break;
   }
   if (pProgramName == NULL)
       fDisplayUsage = TRUE;
    }

    if ( fDisplayUsage) {
   OemString.Length = 0;
   OemString.MaximumLength = MAX_MSG_LENGTH << 1;
   OemString.Buffer = OemMessage;
   UnicodeString.Length = 0;
   UnicodeString.Buffer = UnicodeMessage;
   UnicodeString.MaximumLength = MAX_MSG_LENGTH << 1;
   for (i = ID_USAGE_BASE; i <= ID_USAGE_MAX; i++) {
       nChar = LoadString(NULL, 
                               i, 
                               UnicodeString.Buffer,
                sizeof(UnicodeMessage)/sizeof(WCHAR));
            UnicodeString.Length  = (USHORT)(nChar << 1);
       Status = RtlUnicodeStringToOemString(
                   &OemString,
                   &UnicodeString,
                   FALSE
                   );
       if (!NT_SUCCESS(Status))
      break;
            if (!WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),
            OemString.Buffer,
            OemString.Length,
            &Length, NULL) ||
      Length != OemString.Length)
      break;
   }
   ExitProcess(0xFF);
    }

    if (pCurDirectory != NULL) {
#if DBG
   if (fOutputDebugInfo)
       printf("Default directory = %s\n", pCurDirectory);
#endif

   RtlInitString((PSTRING)&OemString, pCurDirectory);
   UnicodeString.MaximumLength = (MAX_PATH + 1) * sizeof(WCHAR);
   UnicodeString.Buffer = DefDirectory;
   UnicodeString.Length = 0;
   Status = RtlOemStringToUnicodeString(&UnicodeString, &OemString, FALSE);
   if (!NT_SUCCESS(Status))
       YellAndExit(ID_BAD_DEFDIR, 0xFF);
   dw = GetFileAttributes(DefDirectory);
   if (dw == (DWORD)(-1) || !(dw & FILE_ATTRIBUTE_DIRECTORY))
       YellAndExit(ID_BAD_DEFDIR, 0xFF);
   SetCurrentDirectory(DefDirectory);
    }
    else
   GetCurrentDirectory(MAX_PATH + 1, DefDirectory);

    // get a local copy of program name (for code conversion)
    strcpy(ProgramName, pProgramName);
    pProgramName = ProgramName;
    // when we feed SearchPath with an initial path name ".;%path%"
    // it will search the executable for use according to our requirement
    // Currentdir -> path
    SearchPathName[0] = L'.';
    SearchPathName[1] = L';';
    GetEnvironmentVariable(L"path", &SearchPathName[2], MAX_PATH + 1 - 2);
    RtlInitString((PSTRING)&OemString, pProgramName);
    Status = RtlOemStringToUnicodeString(pTebUnicodeString, &OemString, FALSE);
    if (!NT_SUCCESS(Status))
   YellAndExit(ID_BAD_PATH, 0xFF);
    i = 0;
    nChar = 0;
    pwch = wcschr(pTebUnicodeString->Buffer, (WCHAR)'.');
    Length = (pwch) ? 1 : MAX_EXTENTION;
    while (i < Length &&
      (nChar = SearchPath(
                SearchPathName,
                pTebUnicodeString->Buffer,
                Extention[i],
                MAX_PATH + 1,
                ProgramNameBuffer,
                &pFilePart
                )) == 0)
       i++;
    if (nChar == 0)
   YellAndExit(ID_NO_FILE, 0xFF);
    nChar = GetFileAttributes(ProgramNameBuffer);
    if (nChar == (DWORD) (-1) || (nChar & FILE_ATTRIBUTE_DIRECTORY))
   YellAndExit(ID_NO_FILE, 0xFF);

    if (OemString.Length + CommandLineLength  > 128 - 2 - 1)
   YellAndExit(ID_BAD_CMDLINE, 0xFF);
#if DBG
    if (fOutputDebugInfo)
   printf("Program path name is %s\n", ProgramNameBuffer);
#endif
    RtlInitString((PSTRING)&CmdLineString, CommandLine);
    Status = RtlOemStringToUnicodeString(pTebUnicodeString, &CmdLineString, FALSE);
    if (!NT_SUCCESS(Status))
   YellAndExit(ID_BAD_CMDLINE, 0xFF);

    ZeroMemory(&StartupInfo, sizeof(STARTUPINFO));
    StartupInfo.cb = sizeof (STARTUPINFO);
    if (!CreateProcess(
            ProgramNameBuffer,   // program name
            pTebUnicodeString->Buffer,// command line
            NULL,       // process attr
            NULL,       // thread attr
            TRUE,       // inherithandle
            CREATE_FORCEDOS,     // create flag
            NULL,       // environment
            DefDirectory,     // cur dir
            &StartupInfo,     // startupinfo
            &ProcessInformation
            )) {
   YellAndExit(ID_BAD_PROCESS, 0xFF);
#if DBG
   if(fOutputDebugInfo)
       printf("CreateProceess Failed, error code = %ld\n", GetLastError());
#endif
    }

//    LocalFree( SavePtr );


    WaitForSingleObject(ProcessInformation.hProcess, INFINITE);
    GetExitCodeProcess(ProcessInformation.hProcess, &ExitCode);
    CloseHandle(ProcessInformation.hProcess);
    ExitProcess(ExitCode);
}


VOID YellAndExit
(
UINT  MsgID,             // string table id from resource
WORD  ExitCode        // exit code to be used
)
{
    int     MessageSize;
    ULONG   SizeWritten;
    OEM_STRING OemString;
    UNICODE_STRING UnicodeString;

    MessageSize = LoadString(NULL, MsgID, UnicodeMessage, sizeof(UnicodeMessage)/sizeof(WCHAR));
    OemString.Buffer = OemMessage;
    OemString.Length = 0;
    OemString.MaximumLength = MAX_MSG_LENGTH * 2;
    RtlInitUnicodeString(&UnicodeString, UnicodeMessage);
    RtlUnicodeStringToOemString(&OemString, &UnicodeString, FALSE);

    WriteFile(GetStdHandle(STD_ERROR_HANDLE),
              OemString.Buffer,
              OemString.Length,
              &SizeWritten,
              NULL
              );

    ExitProcess(ExitCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmutils\forcedos\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=forcedos
TARGETPATH=obj
TARGETTYPE=PROGRAM

SOURCES=..\forcedos.c ..\forcedos.rc

C_DEFINES=/DUNICODE=1 /DNOMINMAX

USE_MSVCRT=1

UMLIBS=$(SDK_LIB_PATH)\user32.lib \
       $(SDK_LIB_PATH)\ntdll.lib \
       $(SDK_LIB_PATH)\kernl32p.lib
MSC_WARNING_LEVEL=/W3 /WX

UMTYPE=console
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmutils\forcedos\pif.h ===
#pragma pack(1)

/*
 * Structure and equates of PIF files
 */

#define PIFEDITMAXPIF		1024	 /* maximum PIF file size we support */
#define PIFEDITMAXPIFL		1024L

#define PIFNAMESIZE		30
#define PIFSTARTLOCSIZE 	63
#define PIFDEFPATHSIZE		64
#define PIFPARAMSSIZE		64
#define PIFSHPROGSIZE		64
#define PIFSHDATASIZE		64

#define PIFEXTSIGSIZE		16

#define PIFSIZE 		367 /* two bytes less, this is used for checksum */

typedef struct {
    char extsig[PIFEXTSIGSIZE];
    unsigned short extnxthdrfloff;
    unsigned short extfileoffset;
    unsigned short extsizebytes;
    } PIFEXTHEADER;

#define LASTHEADERPTR		0xFFFF
#define STDHDRSIG		"MICROSOFT PIFEX"

#define W386HDRSIG		"WINDOWS 386 3.0"
#define W286HDRSIG30		"WINDOWS 286 3.0"
#define WNTHDRSIG31		"WINDOWS NT  3.1"

typedef struct {
    char unknown;
    char id;
    char name[PIFNAMESIZE];
    short maxmem;
    short minmem;
    char startfile[PIFSTARTLOCSIZE];
    char MSflags;
    char reserved;
    char defpath[PIFDEFPATHSIZE];
    char params[PIFPARAMSSIZE];
    char screen;
    char cPages;
    unsigned char lowVector;
    unsigned char highVector;
    char rows;
    char cols;
    char rowoff;
    char coloff;
    unsigned short sysmem;
    char shprog[PIFSHPROGSIZE];
    char shdata[PIFSHDATASIZE];
    unsigned char behavior;
    unsigned char sysflags;
    PIFEXTHEADER stdpifext;
    } PIFNEWSTRUCT;

typedef struct {
    short maxmem;
    short minmem;
    unsigned short PfFPriority;
    unsigned short PfBPriority;
    short PfMaxEMMK;
    unsigned short PfMinEMMK;
    short PfMaxXmsK;
    unsigned short PfMinXmsK;
    unsigned long PfW386Flags;
    unsigned long PfW386Flags2;
    unsigned short PfHotKeyScan;
    unsigned short PfHotKeyShVal;
    unsigned short PfHotKeyShMsk;
    unsigned char PfHotKeyVal;
    unsigned char PfHotKeyPad[9];
    char params[PIFPARAMSSIZE];
    } PIF386EXT;

/* Windows NT extension format */
typedef struct                            
   {                                      
   DWORD dwWNTFlags;                      
   DWORD dwRes1;                          
   DWORD dwRes2;                          
   char  achConfigFile[PIFDEFPATHSIZE];   
   char  achAutoexecFile[PIFDEFPATHSIZE]; 
   } PIFWNTEXT;                           

// equates for dwWNTFlags
#define NTPIF_SUBSYSMASK	0x0000000F	// sub system type mask
#define SUBSYS_DEFAULT		0
#define SUBSYS_DOS		1
#define SUBSYS_WOW		2
#define SUBSYS_OS2		3

#define PIFWNTEXTSIZE sizeof(PIFWNTEXT)   

#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmutils\graftabl\graftabl.h ===
/* GRAFTABL.H
   Date: 1/29/93
   Message IDs fro CRAFTABL utility
*/

#define HELP_TEXT	100
#define ACTIVE_CP	101
#define INVALID_SWITCH	102
#define NOT_ALLOWED	103
#define PREVIOUS_CP	104
#define NONE_CP		105
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmutils\pifedit\mods.h ===
/* MODS.H - function prototypes for MODS.C */

#define  GetInstanceData(hinst, npstr, cb) (0)

int   MemCopy(LPSTR, LPSTR, int);
BOOL  SetInitialMode(void);
int   CountLines(LPSTR);
DWORD GetTextExtent(HDC, LPSTR, int);
int   delete(LPSTR);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmutils\pifedit\mods.c ===
/* MODS.C - stubs, asm substitutes etc. for 32-bit port of pifedit.exe */
#include "windows.h"
#include "stdio.h"
#include "memory.h"
#include "mods.h"

int MemCopy(LPSTR src, LPSTR dest, int cb)
{
    memcpy(dest, src, cb);
    return(1);
}


BOOL SetInitialMode(void)
{
    return(1);
}


int CountLines(LPSTR lpstr)
{
    return(0);
}


DWORD GetTextExtent(HDC hdc, LPSTR lpszStr, int cbStr)
{
    SIZE   size;

    if(GetTextExtentPoint(hdc, lpszStr, cbStr, &size)) {
        return( MAKELONG( (LOWORD(size.cy)), (LOWORD(size.cx)) ) );
    }

    else
        return(0);
}



int delete(LPSTR lpszPath)
{
   return(unlink(lpszPath));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmutils\graftabl\graftabl.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <string.h>
#include "graftabl.h"

/************************************************************************\
*
*  FUNCTION:    32-bit version of GRAFTABL
*
*  Syntax:      GRAFTABL [XXX]
*               GRAFTABL /STATUS
*
*  COMMENTS:    This program changes only Console Output CP and
*               cannot change console (input) CP as normal GRAFTABL
*               in MS-DOS 5.0
*
*  HISTORY:     Jan. 4, 1993
*               YSt
*
*  Copyright Microsoft Corp. 1993
*
\************************************************************************/
void _cdecl main( int argc, char* argv[] )
{
    int iCP, iPrevCP, iRet;
    char szArgv[128];
    TCHAR szSour[256];
    char szDest[256];

#ifdef DBCS
//bug fix #14165
//fix kksuzuka: #988
//Support billingual messages.
   iPrevCP = GetConsoleOutputCP();
   switch (iPrevCP) 
   {
   case 932:
   case 936:
   case 949:
   case 950:
        SetThreadLocale(
        MAKELCID( MAKELANGID( PRIMARYLANGID(GetSystemDefaultLangID()),
            SUBLANG_ENGLISH_US ),
            SORT_DEFAULT ) );
        break;
   default:
        SetThreadLocale(
        MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
            SORT_DEFAULT ) );
        break;
   }
#else // !DBCS
    iPrevCP = 0;
#endif // DBCS
    if(argc > 1) {
        strncpy(szArgv, argv[1],127);
        szArgv[127]='\0';
        _strupr(szArgv);

// Help option
	if(!strcmp(szArgv, "/?") || !strcmp(szArgv, "-?")) {
            iRet = LoadString(NULL, HELP_TEXT, szSour, sizeof(szSour)/sizeof(TCHAR));
	    CharToOem(szSour, szDest);

	    puts(szDest);
            exit(0);
        }
// Status option
        else if(!strcmp(szArgv, "/STATUS") ||
                !strcmp(szArgv, "-STATUS") ||
                !strcmp(szArgv, "-STA") ||
		!strcmp(szArgv, "/STA")) {

            iRet = LoadString(NULL, ACTIVE_CP, szSour, sizeof(szSour)/sizeof(TCHAR));
	    CharToOem(szSour, szDest);

#ifdef DBCS
	    if(iPrevCP == 932) {
	       iRet = LoadString(NULL,NONE_CP, szSour, sizeof(szSour)/sizeof(TCHAR));
	       printf("%s", szDest);
	    }
	    else
#endif // DBCS
	    printf(szDest, GetConsoleOutputCP());
            exit(0);
        }


// Change output CP
	else {
#ifdef DBCS  // v-junm - 08/11/93
// Since Japanese DOS runs in graphics mode, this function is not supported.
	    if(((iCP = atoi(szArgv)) < 1) || (iCP > 10000) || (iCP == 932)) {
#else // !DBCS
	    iPrevCP = GetConsoleOutputCP();

	    if(((iCP = atoi(szArgv)) < 1) || (iCP > 10000)) {
#endif // !DBCS
                iRet = LoadString(NULL, INVALID_SWITCH, szSour, sizeof(szSour)/sizeof(TCHAR));
		CharToOem(szSour, szDest);

		fprintf(stderr, szDest, argv[1]);
                exit(1);
            }
	    if(!SetConsoleOutputCP(iCP)) {
                iRet = LoadString(NULL, NOT_ALLOWED, szSour, sizeof(szSour)/sizeof(TCHAR));
		CharToOem(szSour, szDest);
		fprintf(stderr, szDest, iCP);
                exit(2);
            }
        }
#ifdef DBCS
//bug fix #14165
//fix kksuzuka: #988
//Support billingual messages.
   switch (iCP)
   {
   case 932:
   case 936:
   case 949:
   case 950:
        SetThreadLocale(
        MAKELCID( MAKELANGID( PRIMARYLANGID(GetSystemDefaultLangID()),
            SUBLANG_ENGLISH_US ),
            SORT_DEFAULT ) );
        break;
   default:
        SetThreadLocale(
        MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
            SORT_DEFAULT ) );
        break;
   }
#endif // DBCS
    }
#ifdef DBCS
	if(iPrevCP && iPrevCP != 932) {
#else // !DBCS
    if(iPrevCP) {
#endif // !DBCS
        iRet = LoadString(NULL,PREVIOUS_CP, szSour, sizeof(szSour)/sizeof(TCHAR));
	CharToOem(szSour, szDest);
	printf(szDest, iPrevCP);
    }
    else {
        iRet = LoadString(NULL,NONE_CP, szSour, sizeof(szSour)/sizeof(TCHAR));
	CharToOem(szSour, szDest);
	puts(szDest);
    }

    iRet = LoadString(NULL,ACTIVE_CP, szSour, sizeof(szSour)/sizeof(TCHAR));
    CharToOem(szSour, szDest);
#ifdef DBCS
    if ( GetConsoleOutputCP() != 932 )
#endif // DBCS
    printf(szDest, GetConsoleOutputCP());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmutils\graftabl\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=graftabl
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOURCES=..\graftabl.c ..\graftabl.rc

C_DEFINES=/DUNICODE=1 /DNOMINMAX

UMLIBS=$(SDK_LIB_PATH)\user32.lib

MSC_WARNING_LEVEL=/W3 /WX

UMTYPE=console
UMAPPL=graftabl
UMAPPLEXT=.com
UMRES=$(O)\graftabl.res

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmutils\pifedit\pifedit.c ===
/* originally named PIF.C in Win3.1 -- changed to make build 32 happy */
#define NOSOUND
#define NOCOMM
#define WIN31
#include "pifedit.h"
#include "commdlg.h"
#include "shellapi.h"
#include "mods.h"

extern BOOL IsLastPifedit(void);
extern int MemCopy(LPSTR,LPSTR,int);
extern int MaybeSaveFile(void);
extern int InitPifStruct(void);
extern int UpdatePifScreen(void);
extern int UpdatePifScreenAdv(void);
extern int UpdatePifScreenNT(void);
extern BOOL UpdatePifStruct(void);
extern int LoadPifFile(PSTR);
extern int SavePifFile(PSTR, int);
extern BOOL SetInitialMode(void);
extern int CountLines(LPSTR);
extern int Warning(int,WORD);
extern PIF386EXT UNALIGNED *AllocInit386Ext(void);
extern PIFWNTEXT UNALIGNED *AllocInitNTExt(void);
extern void SetFileOffsets(unsigned char *,WORD *,WORD *);
extern void SetNTDlgItem(int);
/*
 * extern PIF286EXT31 *AllocInit286Ext31(void);
 */
extern PIF286EXT30 UNALIGNED *AllocInit286Ext30(void);
extern BOOL DoFieldsWork(BOOL);
extern BOOL DoFieldsWorkNT(BOOL);
extern BOOL DoFieldsWorkAdv(BOOL);
extern BOOL UpdatePif386Struc(void);
extern BOOL UpdatePifNTStruc(void);

#define SBUMAIN        0 // Scroll Bar update on Main
#define SBUADV         1 // Scroll Bar update on Advanced
#define SBUNT          2 // Scroll Bar update on NT
#define SBUMAINADVNT   3 // Scroll Bar Update on Main, Advanced, and NT
#define SBUSZMAIN      4 // SIZE and Scroll Bar update on Main
#define SBUSZADV       5 // SIZE and Scroll Bar update on Advanced
#define SBUSZNT        6 // SIZE and Scroll Bar update on NT
#define SBUSZMAINADVNT 7 // SIZE and Scroll Bar update on Main, Advanced, and NT

int	      SwitchAdvance386(HWND);
int	      SwitchNT(HWND);
unsigned char *PutUpDB(int);
int	      DoHelp(unsigned int,unsigned int);
int	      Disable386Advanced(HWND, HWND);
int	      SetMainWndSize(int);
int	      MainScroll(HWND, int, int, int, int);
int	      ChangeHotKey(void);
int	      SetHotKeyLen(void);
int	      SetHotKeyState(WPARAM,LONG);
int	      SetHotKeyTextFromPIF(void);
int	      CmdArgAddCorrectExtension(unsigned char *);
int           SetHotKeyTextFromInMem(void);
void          CpyCmdStr( LPSTR szDst, LPSTR szSrc );


CHAR szOldAutoexec[PIFDEFPATHSIZE*4];
CHAR szOldConfig[PIFDEFPATHSIZE*4];

BOOL CurrMode386;   /* true if in Windows 386 mode, False if in Windows 286 mode */

BOOL SysMode386;    /* true if running Windows 386,  False if running Windows 286 */

BOOL ModeAdvanced = FALSE;   /* true if in advanced PIF mode */

BOOL AdvClose = FALSE;	     /* true if advanced PIF mode and Cancel = Close */

BOOL NTClose = FALSE;	     /* true if NT PIF mode and Cancel = Close */

BOOL FileChanged = FALSE;

BOOL EditHotKey = FALSE;

BOOL NewHotKey = FALSE;

BOOL DoingMsg = FALSE;

BOOL InitShWind = FALSE;	/* true if initial ShowWindow has been done */

BOOL CompleteKey = FALSE;

BOOL SizingFlag = FALSE;	/* Semaphore to prevent re-entrant sizing */

/* invalid filename flags for NT autoexec & config files */
BOOL fNoNTAWarn = FALSE;
BOOL fNTAWarnne = FALSE;
BOOL fNoNTCWarn = FALSE;
BOOL fNTCWarnne = FALSE;

HWND hwndPrivControl = (HWND)NULL;
HWND hwndHelpDlgParent = (HWND)NULL; // This is actually mostly a flag that says
                                     // we have the help engine up

unsigned char MenuMnemonic1;
unsigned char MenuMnemonic2;
unsigned char MenuMnemonic3;

unsigned char KeySepChr;

unsigned char CurrHotKeyTxt[160];
int	      CurrHotKeyTxtLen = 0;

WORD fileoffset = 0;
WORD extoffset = 0;
WORD tmpfileoffset = 0;
WORD tmpextoffset = 0;

typedef VOID (FAR PASCAL *LPFNREGISTERPENAPP)(WORD, BOOL);
static LPFNREGISTERPENAPP lpfnRegisterPenApp = NULL;

#define NUM286ALIASES	8

unsigned int Aliases286 [(NUM286ALIASES * 2)] = { IDI_MEMREQ,IDI_MEMREQ_286ALIAS,
						  IDI_XMAREQ,IDI_XMAREQ_286ALIAS,
						  IDI_XMADES,IDI_XMADES_286ALIAS,
					       /*
						*   IDI_EMSREQ,IDI_EMSREQ_286ALIAS,
						*   IDI_EMSDES,IDI_EMSDES_286ALIAS,
						*/
						  IDI_ALTTAB,IDI_ALTTAB_286ALIAS,
						  IDI_ALTESC,IDI_ALTESC_286ALIAS,
						  IDI_ALTPRTSC,IDI_ALTPRTSC_286ALIAS,
						  IDI_PRTSC,IDI_PRTSC_286ALIAS,
						  IDI_CTRLESC,IDI_CTRLESC_286ALIAS };

unsigned      TmpHotKeyScan;
unsigned      TmpHotKeyShVal;
unsigned      TmpHotKeyShMsk = 0x000F;	     /* Either CTRL, ALT or SHIFT */
unsigned char TmpHotKeyVal;

unsigned      InMemHotKeyScan = 0;
unsigned      InMemHotKeyShVal = 0;
unsigned      InMemHotKeyShMsk = 0;
unsigned char InMemHotKeyVal;

BOOL ChangeHkey = FALSE;		/* Prevent re-entrancy */

BOOL bMouse;
HCURSOR hArrowCurs;
HCURSOR hWaitCurs;

int SysCharHeight;
int SysCharWidth;

HFONT HotKyFnt = 0;
int   HotKyFntHgt = 0;
HFONT SysFixedFont;
int SysFixedHeight;
int SysFixedWidth;

HINSTANCE hPifInstance;
HWND hwndPifDlg = (HWND)NULL;
HWND hwndNTPifDlg = (HWND)NULL;
HWND hwndAdvPifDlg = (HWND)NULL;
HWND hParentWnd = (HWND)NULL;
HWND hwndFocusMain = (HWND)NULL;
HWND hwndFocusAdv = (HWND)NULL;
HWND hwndFocusNT = (HWND)NULL;
BOOL bNTDlgOpen = FALSE;
BOOL bAdvDlgOpen = FALSE;
int  FocusIDMain = IDI_ENAME;
int  FocusIDMainMenu = 0;
int  FocusIDAdvMenu = 0;
int  FocusIDAdv = IDI_BPRI;
int  FocusIDNTMenu = 0;
int  FocusIDNT = IDI_AUTOEXEC;
HWND hwndFocus = (HWND)NULL;
int  FocusID = IDI_ENAME;

unsigned char FocStatTextMain[PIFSTATUSLEN*2] = { 0 };
unsigned char FocStatTextAdv[PIFSTATUSLEN*2] = { 0 };
unsigned char FocStatTextNT[PIFSTATUSLEN*2] = { 0 };

PIFSTATUSPAINT StatusPntData;

RECT StatRecSizeMain;
RECT StatRecSizeAdv;
RECT StatRecSizeNT;

HWND hMainwnd = (HWND)NULL;

int  MainScrollRange = 0;
int  MainScrollLineSz = 0;
int  MainWndLines = 0;
int  MaxMainNeg = 0;
int  MainWndSize = SIZENORMAL;

int  AdvScrollRange = 0;
int  AdvScrollLineSz = 0;
int  AdvWndLines = 0;
int  MaxAdvNeg = 0;
int  AdvWndSize = SIZENORMAL;

int  NTScrollRange = 0;
int  NTScrollLineSz = 0;
int  NTWndLines = 0;
int  MaxNTNeg = 0;
int  NTWndSize = SIZENORMAL;

HACCEL hAccel;

unsigned char CurPifFile[256];		/* this is name IN ANSI!! */
unsigned char PifBuf[PIFEDITMAXPIF*2];
unsigned char NTSys32Root[PIFDEFPATHSIZE*2];

PIFNEWSTRUCT UNALIGNED *PifFile;
PIF386EXT UNALIGNED *Pif386ext = (PIF386EXT *)NULL;
/*
 * PIF286EXT31	 *Pif286ext31 = (PIF286EXT31 *)NULL;
 */
PIF286EXT30 UNALIGNED *Pif286ext30 = (PIF286EXT30 *)NULL;
PIFWNTEXT UNALIGNED *PifNText = (PIFWNTEXT *)NULL;

OFSTRUCT ofReopen;
unsigned char rgchInsMem[320];
unsigned char rgchTitle[60];
unsigned char szExtSave[] = "\\*.PIF";

HMENU	hSysMenuMain = (HMENU)NULL;
HMENU	hFileMenu = (HMENU)NULL;
HMENU	hModeMenu = (HMENU)NULL;
HMENU	hHelpMenu = (HMENU)NULL;
HMENU	hSysMenuAdv = (HMENU)NULL;
HMENU	hSysMenuNT = (HMENU)NULL;

DLGPROC lpfnPifWnd;
DLGPROC lpfnAdvPifWnd;
DLGPROC lpfnNTPifWnd;

void InvalidateStatusBar(HWND hwnd)
{
    RECT	  rc;

    if((hwnd == hwndAdvPifDlg) && AdvScrollRange) /* No status bar if scroll bar */
	return;

    if((hwnd == hwndNTPifDlg) && NTScrollRange) /* No status bar if scroll bar */
	return;

    GetClientRect(hwnd, &rc);
    if(rc.bottom >= (StatusPntData.dyStatus + StatusPntData.dyBorderx2)) {
	rc.top = rc.bottom - (StatusPntData.dyStatus + StatusPntData.dyBorderx2);
	InvalidateRect(hwnd,(CONST RECT *)&rc,FALSE);
    }
}

void InvalidateAllStatus(void)
{

    if(hMainwnd) {
	InvalidateStatusBar(hMainwnd);
    }
    if(hwndAdvPifDlg) {
	InvalidateStatusBar(hwndAdvPifDlg);
    }
    if(hwndNTPifDlg) {
	InvalidateStatusBar(hwndNTPifDlg);
    }
}

void SetStatusText(HWND hwnd,int FocID,BOOL redrawflg)
{
    unsigned char *dst;

    if(hwnd == hMainwnd) {
	dst = FocStatTextMain;
    } else if (hwnd == hwndAdvPifDlg) {
	dst = FocStatTextAdv;
    } else {
	dst = FocStatTextNT;
    }
    if((FocID == IDADVCANCEL) && AdvClose) {
	FocID = IDI_CANCLOSE;
    }

    if(!LoadString(hPifInstance, FocID, dst, PIFSTATUSLEN-1)) {
        /* if string not defined above, try getting the generic string */
        if(!LoadString(hPifInstance, IDI_GENSTAT, dst, PIFDEFPATHSIZE-1)) {
	    Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
        }
    }
    if(redrawflg) {
	InvalidateStatusBar(hwnd);
    }
}

void PaintStatus(HWND hwnd)
{
    HDC 	hdc;
    RECT	rc, rcTemp, rcTemp2;
    HBRUSH	hBrush;
    PAINTSTRUCT ps;
    BOOL	bEGA;
    unsigned	char *txtpnt;
    unsigned	char blank[] = "  ";

    if((hwnd == hwndAdvPifDlg) && AdvScrollRange) /* No status bar if scroll bar */
	return;

    if((hwnd == hwndNTPifDlg) && NTScrollRange) /* No status bar if scroll bar */
	return;

    hdc = BeginPaint(hwnd, &ps);

    GetClientRect(hwnd, &rc);
    StatusPntData.hFontStatus = SelectObject(hdc, StatusPntData.hFontStatus);

    rc.top = rc.bottom - (StatusPntData.dyStatus + StatusPntData.dyBorderx2);

    bEGA = GetNearestColor(hdc, GetSysColor(COLOR_BTNHIGHLIGHT)) ==
	   GetNearestColor(hdc, GetSysColor(COLOR_BTNFACE));

    if (bEGA) {

	    /* EGA type display */

	    SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
	    SetBkColor(hdc, GetSysColor(COLOR_WINDOW));

    } else {

	/* VGA type display */

	/* draw the frame */

	    /* Border color */

	    hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));

	/* top and bottom border */

	    /* Top */

	    rcTemp = rc;
	    rcTemp.bottom = rcTemp.top + StatusPntData.dyBorderx3;
	    rcTemp.top += StatusPntData.dyBorder;
	    FillRect(hdc, (CONST RECT *)&rcTemp, hBrush);

	    /* Bottom */

	    rcTemp = rc;
	    rcTemp.top = rcTemp.bottom - StatusPntData.dyBorderx2;
	    FillRect(hdc, (CONST RECT *)&rcTemp, hBrush);

	/* left and right border */

	    /* Left */

	    rcTemp = rc;
	    rcTemp.right = 8 * StatusPntData.dyBorder;
	    rcTemp.top += StatusPntData.dyBorder;
	    FillRect(hdc, (CONST RECT *)&rcTemp, hBrush);

	    /* Right */

	    rcTemp = rc;
	    rcTemp.left = rcTemp.right - (8 * StatusPntData.dyBorder);
	    rcTemp.top += StatusPntData.dyBorder;
	    FillRect(hdc, (CONST RECT *)&rcTemp, hBrush);

	    DeleteObject((HGDIOBJ)hBrush);

	    /* Shadow color */

	    hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW));

	/* Top and left shadow */

	    /* Top */

	    rcTemp.left   = 8 * StatusPntData.dyBorder;
	    rcTemp.right  = rcTemp.right - 8 * StatusPntData.dyBorder;
	    rcTemp.top	  = rc.top + StatusPntData.dyBorderx3;
	    rcTemp.bottom = rcTemp.top + StatusPntData.dyBorder;
	    FillRect(hdc, (CONST RECT *)&rcTemp, hBrush);

	    /* Left */

	    rcTemp = rc;
	    rcTemp.left = 8 * StatusPntData.dyBorder;
	    rcTemp.right = rcTemp.left + StatusPntData.dyBorder;
	    rcTemp.top += StatusPntData.dyBorderx3;
	    rcTemp.bottom -= StatusPntData.dyBorderx2;
	    FillRect(hdc, (CONST RECT *)&rcTemp, hBrush);

	    DeleteObject((HGDIOBJ)hBrush);

	    /* Hilight color */

	    hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNHIGHLIGHT));

	/* Right and bottom hilight */

	    /* Bottom */

	    rcTemp = rc;
	    rcTemp.left   = 8 * StatusPntData.dyBorder;
	    rcTemp.right  = rcTemp.right - 8 * StatusPntData.dyBorder;
	    rcTemp.top	  = rc.bottom - 3 * StatusPntData.dyBorder;
	    rcTemp.bottom = rcTemp.top + StatusPntData.dyBorder;
	    FillRect(hdc, (CONST RECT *)&rcTemp, hBrush);

	    /* Right */

	    rcTemp = rc;
	    rcTemp.left = rcTemp.right - 9 * StatusPntData.dyBorder;
	    rcTemp.right = rcTemp.left + StatusPntData.dyBorder;
	    rcTemp.top += StatusPntData.dyBorderx3;
	    rcTemp.bottom -= StatusPntData.dyBorderx2;
	    FillRect(hdc, (CONST RECT *)&rcTemp, hBrush);

	    DeleteObject((HGDIOBJ)hBrush);

	    SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));
	    SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));
    }

    /* solid black line across top */

    hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOWTEXT));
    rcTemp = rc;
    rcTemp.bottom = rcTemp.top;
    rcTemp.bottom += StatusPntData.dyBorder;
    FillRect(hdc, (CONST RECT *)&rcTemp, hBrush);
    DeleteObject((HGDIOBJ)hBrush);

    /* now the text, with the button face background */

    rcTemp.top	  = rc.top + ((1+2+1) * StatusPntData.dyBorder);
    rcTemp.bottom = rc.bottom - StatusPntData.dyBorderx3;
    rcTemp.left   = 9 * StatusPntData.dyBorder;
    rcTemp.right  = rc.right - 9 * StatusPntData.dyBorder;

    if (bEGA) {
	rcTemp2 = rc;
	rcTemp2.top += StatusPntData.dyBorder;
    } else {
	rcTemp2 = rcTemp;
    }

    if(DoingMsg) {
	txtpnt = blank;
    } else {
	if(hwnd == hMainwnd) {
	    txtpnt = FocStatTextMain;
	} else if(hwnd == hwndAdvPifDlg) {
	    txtpnt = FocStatTextAdv;
	} else {
	    txtpnt = FocStatTextNT;
	}
    }

    ExtTextOut(hdc, rcTemp.left + StatusPntData.dyBorderx2, rcTemp.top,
	       ETO_OPAQUE | ETO_CLIPPED, (CONST RECT *)&rcTemp2, (LPSTR)txtpnt,
	       lstrlen((LPSTR)txtpnt), NULL);

    StatusPntData.hFontStatus = SelectObject(hdc, StatusPntData.hFontStatus);

    EndPaint(hwnd, (CONST PAINTSTRUCT *)&ps);

}

void HourGlass(BOOL bOn)
{
    /* toggle hourglass cursor */

    if(!bMouse) 		/* Turn cursor on/off if no mouse */
	ShowCursor(bOn);
    SetCursor(bOn ? hWaitCurs : hArrowCurs);
}

void SetMainTitle(void)
{
    int 	  i;
    int 	  j;
    HANDLE        hFile;
    unsigned char buf[(MAX_PATH*2)+360];
    unsigned char buf2[360];
    unsigned char *pch;
    WIN32_FIND_DATA fd;

    if(!(i = LoadString(hPifInstance, PIFCAPTION, (LPSTR)buf, sizeof(buf)))) {
	Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
    }

    if(hwndAdvPifDlg) {
	if(!(j = LoadString(hPifInstance, PIFCAPTIONADV, (LPSTR)buf2, sizeof(buf2)))) {
	    Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	}
    }
    else if(hwndNTPifDlg) {
	if(!(j = LoadString(hPifInstance, PIFCAPTIONNT, (LPSTR)buf2, sizeof(buf2)))) {
	    Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	}
    }
    if(CurPifFile[0] == 0) {
	if(!LoadString(hPifInstance, NOTITLE, (LPSTR)(buf+i), (sizeof(buf)-i))) {
	    Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	}
/*
 *	 if(hwndAdvPifDlg) {
 *	     if(!LoadString(hPifInstance, NOTITLE, (LPSTR)(buf2+j), (sizeof(buf2)-j))) {
 *		 Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
 *	     }
 *	 }
 */
    } else {
        if((hFile = FindFirstFile(CurPifFile, &fd)) != INVALID_HANDLE_VALUE) {
    	    lstrcat((LPSTR)buf, fd.cFileName);
            FindClose(hFile);
        }
        else {
    	    pch = CurPifFile+fileoffset;
	    lstrcat((LPSTR)buf, (LPSTR)pch);
        }
      /*
       * if(hwndAdvPifDlg)
       *     lstrcat((LPSTR)buf2, (LPSTR)pch);
       */
    }
    SetWindowText(hMainwnd,(LPSTR)buf);

    if(hwndAdvPifDlg) {
	SetWindowText(hwndAdvPifDlg,(LPSTR)buf2);
    }
    else if(hwndNTPifDlg) {
	SetWindowText(hwndNTPifDlg,(LPSTR)buf2);
    }
}


UndoNTClose(void)
{
    unsigned char chBuf[40];

    if(NTClose && hwndNTPifDlg) {
	if(!LoadString(hPifInstance, PIFCANCELSTRNG , (LPSTR)chBuf, sizeof(chBuf))) {
	    Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	} else {
	    SetDlgItemText(hwndNTPifDlg,IDNTCANCEL,(LPSTR)chBuf);
	}
	NTClose = FALSE;
	if(FocusIDNT == IDNTCANCEL) {
	    SetStatusText(hwndNTPifDlg,FocusIDNT,TRUE);
	}
	return(TRUE);
    }
    return(FALSE);
}


UndoAdvClose(void)
{
    unsigned char chBuf[40];

    if(AdvClose && hwndAdvPifDlg) {
	if(!LoadString(hPifInstance, PIFCANCELSTRNG , (LPSTR)chBuf, sizeof(chBuf))) {
	    Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	} else {
	    SetDlgItemText(hwndAdvPifDlg,IDADVCANCEL,(LPSTR)chBuf);
	}
	AdvClose = FALSE;
	if(FocusIDAdv == IDADVCANCEL) {
	    SetStatusText(hwndAdvPifDlg,FocusIDAdv,TRUE);
	}
	return(TRUE);
    }
    return(FALSE);
}


DoDlgCommand(HWND hwnd, WPARAM wParam, LONG lParam)
{
    unsigned int value;
    char buf[PIFDEFPATHSIZE*2];
    int len, cmd;
    int ivalue;
    BOOL result;
    BOOL OldFileChanged;

    cmd = LOWORD(wParam);

    switch (cmd) {

/*	  case IDI_PSNONE:
 *	 case IDI_PSTEXT:
 *	 case IDI_PSGRAPH:
 *	     CheckRadioButton(hwnd, IDI_PSFIRST, IDI_PSLAST, cmd);
 *	     break;
 */
	case IDI_PSTEXT:
	case IDI_PSGRAPH:
	    CheckRadioButton(hwnd, IDI_PSTEXT, IDI_PSGRAPH, cmd);
	    break;

/*
 *	 case IDI_SENONE:
 *	 case IDI_SETEXT:
 *	 case IDI_SEGRAPH:
 *	     CheckRadioButton(hwnd, IDI_SEFIRST, IDI_SELAST, cmd);
 *	     break;
 */

	case IDI_ADVANCED:
	    if(CurrMode386) {
		HourGlass(TRUE);
		SwitchAdvance386(hwnd);
		HourGlass(FALSE);
	    } else {

	    }
	    break;

	case IDI_NT:
	    if(CurrMode386) {
		HourGlass(TRUE);
		SwitchNT(hwnd);
		HourGlass(FALSE);
	    } else {

	    }
	    break;

	case IDI_PSNONE:
	case IDI_SENONE:

/*	  case IDI_DMSCREEN: */
/*	  case IDI_DMMEM:    */
	case IDI_DMCOM1:
	case IDI_DMCOM2:
	case IDI_DMCOM3:
	case IDI_DMCOM4:
	case IDI_DMKBD:
	case IDI_EXIT:
	case IDI_BACK:
	case IDI_EXCL:
	case IDI_NOSAVVID:
	case IDI_NTTIMER:
	    CheckDlgButton(hwnd, cmd, !IsDlgButtonChecked(hwnd, cmd));
	    break;

	case IDI_POLL:
	case IDI_ALTTAB:
	case IDI_ALTESC:
	case IDI_CTRLESC:
	case IDI_ALTSPACE:
	case IDI_ALTENTER:
	case IDI_ALTPRTSC:
	case IDI_PRTSC:
	case IDI_NOHMA:
	case IDI_INT16PST:
	case IDI_VMLOCKED:
	case IDI_XMSLOCKED:
	case IDI_EMSLOCKED:
	case IDI_TEXTEMULATE:
	case IDI_RETAINALLO:
	case IDI_TRAPTXT:
	case IDI_TRAPLRGRFX:
	case IDI_TRAPHRGRFX:
	    CheckDlgButton(hwnd, cmd, !IsDlgButtonChecked(hwnd, cmd));
	    UndoAdvClose();
	    break;

	case IDI_VMODETXT:
	    CheckRadioButton(hwnd, IDI_VMODETXT, IDI_VMODEHRGRFX, IDI_VMODETXT);
	    break;

	case IDI_VMODELRGRFX:
	    CheckRadioButton(hwnd, IDI_VMODETXT, IDI_VMODEHRGRFX, IDI_VMODELRGRFX);
	    break;

	case IDI_VMODEHRGRFX:
	    CheckRadioButton(hwnd, IDI_VMODETXT, IDI_VMODEHRGRFX, IDI_VMODEHRGRFX);
	    break;

	case IDI_CLOSE:
	    CheckDlgButton(hwnd, cmd, !IsDlgButtonChecked(hwnd, cmd));
	    if(IsDlgButtonChecked(hwnd, cmd)) {
		value = Warning(WARNCLOSE,MB_ICONHAND | MB_OKCANCEL);
		if(value == IDCANCEL) {
			CheckDlgButton(hwnd, cmd, FALSE);
		}
	    }
	    UndoAdvClose();
	    break;

	case IDI_FSCR:
	case IDI_WND:
	    CheckRadioButton(hwnd, IDI_WND, IDI_FSCR, cmd);
	    break;

	case IDI_FPRI:
	case IDI_BPRI:
	    if (HIWORD(wParam) == EN_CHANGE) {
		len = GetDlgItemText(hwnd, cmd, (LPSTR)buf, sizeof(buf));
		value = GetDlgItemInt(hwnd, cmd, (BOOL FAR *)&result, FALSE);
		if((!result) && (len == 0)) {
		    UndoAdvClose();
		} else if((!result) || (value == 0) || (value > 10000)) {
		    MessageBeep(0);
		    Warning(errBadNumberP,MB_ICONEXCLAMATION | MB_OK);
		    SetDlgItemInt(hwnd, cmd,
			(cmd == IDI_FPRI ? Pif386ext->PfFPriority : Pif386ext->PfBPriority),
			FALSE);
		} else {
		    UndoAdvClose();
		}
	    }
	    break;

	case IDI_MEMDES:
	case IDI_MEMREQ:
	    if (HIWORD(wParam) == EN_CHANGE) {
		len = GetDlgItemText(hwnd, cmd, (LPSTR)buf, sizeof(buf));
		ivalue = (int)GetDlgItemInt(hwnd, cmd, (BOOL FAR *)&result, TRUE);
		if(((!result) && (len == 0)) || ((!result) && (len == 1) && (buf[0] == '-'))) {
		} else if((!result) || (ivalue < -1) || (ivalue > 640)) {
		    MessageBeep(0);
		    if(cmd == IDI_MEMREQ)
			Warning(errBadNumberMR,MB_ICONEXCLAMATION | MB_OK);
		    else
			Warning(errBadNumberMD,MB_ICONEXCLAMATION | MB_OK);
		    if(CurrMode386)
			SetDlgItemInt(hwnd, cmd,
			    (cmd == IDI_MEMDES ? Pif386ext->maxmem : Pif386ext->minmem),
			    TRUE);
		    else
			SetDlgItemInt(hwnd, cmd,
			    (cmd == IDI_MEMDES ? PifFile->maxmem : PifFile->minmem),
			    TRUE);
		}
	    }
	    break;

	case IDI_EMSDES:
	case IDI_XMADES:
	    if (HIWORD(wParam) == EN_CHANGE) {
		len = GetDlgItemText(hwnd, cmd, (LPSTR)buf, sizeof(buf));
		ivalue = (int)GetDlgItemInt(hwnd, cmd, (BOOL FAR *)&result, TRUE);
		if(((!result) && (len == 0)) || ((!result) && (len == 1) && (buf[0] == '-'))) {
		} else if((!result) || ((ivalue < -1) || (ivalue > 16384))) {
		    MessageBeep(0);
		    Warning(errBadNumberXEMSD,MB_ICONEXCLAMATION | MB_OK);
		    if(CurrMode386) {
			if(Pif386ext) {
			    switch (cmd) {
				case IDI_EMSDES:
				    SetDlgItemInt(hwnd, cmd, Pif386ext->PfMaxEMMK,TRUE);
				    break;
				case IDI_XMADES:
				    SetDlgItemInt(hwnd, cmd, Pif386ext->PfMaxXmsK,TRUE);
				    break;
			    }
			}
		    } else {
			/*
			 *switch (cmd) {
			 *
			 *   case IDI_EMSDES:
			 *	 if(Pif286ext31)
			 *	     SetDlgItemInt(hwnd, cmd, Pif286ext31->PfMaxEmsK,TRUE);
			 *	 break;
			 *
			 *   case IDI_XMADES:
			 */
				if(Pif286ext30)
				    SetDlgItemInt(hwnd, cmd, Pif286ext30->PfMaxXmsK,TRUE);
			/*
			 *	 break;
			 *}
			 */
		    }
		}
	    }
	    break;


	case IDI_EMSREQ:
	case IDI_XMAREQ:
	    if (HIWORD(wParam) == EN_CHANGE) {
		len = GetDlgItemText(hwnd, cmd, (LPSTR)buf, sizeof(buf));
		value = GetDlgItemInt(hwnd, cmd, (BOOL FAR *)&result, FALSE);
		if((!result) && (len == 0)) {
		} else if((!result) || (value > 16384)) {
		    MessageBeep(0);
		    Warning(errBadNumberXEMSR,MB_ICONEXCLAMATION | MB_OK);
		    if(CurrMode386) {
			if(Pif386ext) {
			    switch (cmd) {
				case IDI_EMSREQ:
				    SetDlgItemInt(hwnd, cmd, Pif386ext->PfMinEMMK,FALSE);
				    break;
				case IDI_XMAREQ:
				    SetDlgItemInt(hwnd, cmd, Pif386ext->PfMinXmsK,FALSE);
				    break;
			    }
			}
		    } else {
			/*
			 *switch (cmd) {
			 *
			 *   case IDI_EMSREQ:
			 *	 if(Pif286ext31)
			 *	     SetDlgItemInt(hwnd, cmd, Pif286ext31->PfMinEmsK,FALSE);
			 *	 break;
			 *
			 *   case IDI_XMAREQ:
			 */
				if(Pif286ext30)
				    SetDlgItemInt(hwnd, cmd, Pif286ext30->PfMinXmsK,FALSE);
			/*
			 *	 break;
			 *}
			 */
		    }
		}
	    }
	    break;

	case IDCANCEL:
	case IDNTCANCEL:
	case IDADVCANCEL:
	    if((hwnd == hwndAdvPifDlg) || (hwnd == hwndNTPifDlg)) {
		SendMessage(hwnd,WM_PRIVCLOSECANCEL,0,0L);
	    }
	    break;

	case IDOK:
	case IDNTOK:
	    if(hwnd == hwndAdvPifDlg) {
		if(CurrMode386) {
		    if(UpdatePif386Struc())
			FileChanged = TRUE;
		}
		if(!DoFieldsWorkAdv(FALSE))
		    break;
		SendMessage(hwnd,WM_PRIVCLOSEOK,0,0L);
	    }
	    else if(hwnd == hwndNTPifDlg) {
		if(CurrMode386) {
		    if(UpdatePifNTStruc()) {
                        OldFileChanged = FileChanged;
			FileChanged = TRUE;
                    }
		}
		if(!DoFieldsWorkNT(FALSE)) {
                    FileChanged = OldFileChanged;
		    break;
                }
		SendMessage(hwnd,WM_PRIVCLOSEOK,0,0L);
	    }
	    break;

    }
    return(TRUE);
}


long GetNTDlgSize(HWND hwnd)
{
    int  i = 0;
    RECT rc2;
    RECT rc3;
    RECT rc4;

    /* get right side from the OK button */
    GetWindowRect(GetDlgItem(hwnd,IDNTOK),(LPRECT)&rc2);

    /* get left & bottom sides from the IDI_NTTIMER check box */
    GetWindowRect(GetDlgItem(hwnd,IDI_NTTIMER),(LPRECT)&rc3);
    GetWindowRect(hwnd,(LPRECT)&rc4);

    if(NTScrollRange && (i = GetScrollPos(hwnd,SB_VERT))) {
	i = min((i * NTScrollLineSz),MaxNTNeg);
    }
    return(MAKELONG((rc2.right - rc4.left) +
		     SysCharWidth -
		     GetSystemMetrics(SM_CXFRAME),
		    (rc3.bottom - rc4.top) +
		    (SysCharHeight/2) +
		    i -
		    (GetSystemMetrics(SM_CYCAPTION) +
		     GetSystemMetrics(SM_CYBORDER) +
		     GetSystemMetrics(SM_CYFRAME)) +
		    (StatusPntData.dyStatus + StatusPntData.dyBorderx2)));
}


long GetAdvDlgSize(HWND hwnd)
{
    int  i = 0;
    RECT rc2;
    RECT rc3;

    GetWindowRect(GetDlgItem(hwnd,IDI_OTHGRP),(LPRECT)&rc2);
    GetWindowRect(hwnd,(LPRECT)&rc3);
    if(AdvScrollRange && (i = GetScrollPos(hwnd,SB_VERT))) {
	i = min((i * AdvScrollLineSz),MaxAdvNeg);
    }
    return(MAKELONG((rc2.right - rc3.left) +
		     SysCharWidth -
		     GetSystemMetrics(SM_CXFRAME),
		    (rc2.top-rc3.top) +
		    (rc2.bottom - rc2.top) +
		    (SysCharHeight/2) +
		    i -
		    (GetSystemMetrics(SM_CYCAPTION) +
		     GetSystemMetrics(SM_CYBORDER) +
		     GetSystemMetrics(SM_CYFRAME)) +
		    (StatusPntData.dyStatus + StatusPntData.dyBorderx2)));
}


ReEnableAdvButton(void)
{
    HWND hwndctl;

    if(hwndPifDlg && CurrMode386) {

        if(!bNTDlgOpen) {
	    hwndctl = GetDlgItem(hwndPifDlg,IDI_NT);
	    if(hwndFocusMain == hwndctl)
	        SendMessage(hwndctl,BM_SETSTYLE,BS_DEFPUSHBUTTON,1L);
	    else
	        SendMessage(hwndctl,BM_SETSTYLE,BS_PUSHBUTTON,1L);
	    EnableWindow(hwndctl,TRUE);
        }

        if(!bAdvDlgOpen) {
	    hwndctl = GetDlgItem(hwndPifDlg,IDI_ADVANCED);
	    if(hwndFocusMain == hwndctl)
	        SendMessage(hwndctl,BM_SETSTYLE,BS_DEFPUSHBUTTON,1L);
	    else
	        SendMessage(hwndctl,BM_SETSTYLE,BS_PUSHBUTTON,1L);
	    EnableWindow(hwndctl,TRUE);
        }
    }
    return(TRUE);
}

DoOpenPifFile(HDROP DropHnd)
{
    HWND	  hwnd2;
    unsigned char *pchBuf = (unsigned char *)NULL;
    unsigned char *pch;

    if (MaybeSaveFile()) {
	if(DropHnd) {
	    if(!(pchBuf = (unsigned char *)LocalAlloc(LPTR, 132))) {
		Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	    } else {
		if(!(DragQueryFile(DropHnd,0,(LPSTR)pchBuf,132))) {
		    LocalFree((HANDLE)pchBuf);
		    pchBuf = (unsigned char *)NULL;
		} else {
		    SetFileOffsets(pchBuf,&tmpfileoffset,&tmpextoffset);
		}
	    }
	} else {
	    pchBuf = PutUpDB(DTOPEN);
	}
    }
    if(pchBuf) {
	AnsiUpper((LPSTR)pchBuf);
	pch = pchBuf+tmpextoffset;
	if((tmpextoffset == 0) || (lstrcmp((LPSTR)pch, (LPSTR)"PIF"))) {
	    if( Warning(errWrongExt,MB_ICONEXCLAMATION | MB_OKCANCEL | MB_DEFBUTTON2) == IDCANCEL) {
		LocalFree((HANDLE)pchBuf);
		pchBuf = (unsigned char *)NULL;
	    }
	}
    }
    if(pchBuf) {
	HourGlass(TRUE);
	LoadPifFile(pchBuf);
	LocalFree((HANDLE)pchBuf);
	SendMessage(hwndPifDlg,WM_NEXTDLGCTL,
		    (WPARAM)(hwnd2 = GetDlgItem(hwndPifDlg,IDI_ENAME)),1L);
	SetFocus(hwnd2);
	HourGlass(FALSE);
	SetMainTitle();
    }
    if(DropHnd)
	DragFinish(DropHnd);
    return(TRUE);
}


int FAR PASCAL PifNTWndProc(HWND hwnd, UINT message, WPARAM wParam, LONG lParam)
{
    LPPOINT ppnt3;
    LPPOINT ppnt4;
    int     width;
    int     height;
    long    size;
    BOOL    ChngFlg;
    HMENU   hmenu;
    RECT    rc;
    CHAR    buf[PIFDEFPATHSIZE*2];
    int     tmpFOCID;

    switch (message) {

	case WM_INITDIALOG:
	    if((hmenu = GetSystemMenu(hwnd,FALSE))) {
		DeleteMenu(hmenu, SC_RESTORE,  MF_BYCOMMAND);
		DeleteMenu(hmenu, SC_SIZE,     MF_BYCOMMAND);
		DeleteMenu(hmenu, SC_MINIMIZE, MF_BYCOMMAND);
		DeleteMenu(hmenu, SC_MAXIMIZE, MF_BYCOMMAND);
	    } else {
		Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	    }
            lstrcpy(szOldAutoexec, (LPSTR)(PifNText->achAutoexecFile));
            lstrcpy(szOldConfig, (LPSTR)(PifNText->achConfigFile));
	    hwndFocusNT = (HWND)wParam;
            bNTDlgOpen = TRUE;
	    FocusIDNT = GetDlgCtrlID((HWND)wParam);
            OemToAnsi((LPSTR)PifNText->achAutoexecFile, buf);
            SetDlgItemText(hwnd, IDI_AUTOEXEC,(LPSTR)buf);
            OemToAnsi((LPSTR)PifNText->achConfigFile, buf);
            SetDlgItemText(hwnd, IDI_CONFIG, (LPSTR)buf);
	    SendDlgItemMessage(hwnd, IDI_AUTOEXEC, EM_LIMITTEXT, PIFDEFPATHSIZE-1, 0L);
	    SendDlgItemMessage(hwnd, IDI_CONFIG, EM_LIMITTEXT, PIFDEFPATHSIZE-1, 0L);
  	    CheckDlgButton(hwnd, IDI_NTTIMER, (PifNText->dwWNTFlags & COMPAT_TIMERTIC ? TRUE : FALSE));
	    SetStatusText(hwnd,FocusIDNT,FALSE);
	    if(InitShWind) {
		SetFocus((HWND)wParam);  /* Give focus to wparam item */
		SendMessage((HWND)wParam,EM_SETSEL,0,MAKELONG(0,0x7FFF));
		return(FALSE);
	    } else {
		return(FALSE);		 /* Do not set focus until init show */
	    }
	    break;

	case WM_PAINT:
	    PaintStatus(hwnd);
	    return(FALSE);
	    break;

	case WM_COMMAND:
	    SetStatusText(hwnd,FocusIDNT,TRUE);
	    FocusIDNTMenu = 0;
	    DoDlgCommand(hwnd, wParam, lParam);
	    break;

	case WM_SYSCOLORCHANGE:
	    InvalidateStatusBar(hwnd);
	    break;

	case WM_MENUSELECT:
	    tmpFOCID = FocusIDNTMenu;
	    if((HIWORD(wParam) == 0xFFFF) && (lParam == (LPARAM)NULL)) { // was menu closed?
		SetStatusText(hwnd,FocusIDNT,TRUE);
		tmpFOCID = FocusIDNTMenu = 0;
	    } else if(lParam == 0) {	    /* ignore these */
	    } else if(HIWORD(wParam) & MF_POPUP) {
		if((HMENU)lParam == hSysMenuNT)
		    FocusIDNTMenu = M_SYSMENUNT;
	    } else {
		if(LOWORD(wParam) != 0)    /* separators have wparam of 0 */
		    FocusIDNTMenu = LOWORD(wParam);
		if(FocusIDNTMenu == SC_CLOSE)
		    FocusIDNTMenu = SC_NTCLOSE;
	    }
	    if(tmpFOCID != FocusIDNTMenu)
		SetStatusText(hwnd,FocusIDNTMenu,TRUE);
	    break;

	case WM_SIZE:
	    GetClientRect(hwnd, &rc);
	    rc.top = rc.bottom - (StatusPntData.dyStatus + StatusPntData.dyBorderx2);
	    if(rc.top < StatRecSizeNT.top) {
		/* Window SHRANK, need to invalidate current status rect */
		InvalidateRect(hwnd, (CONST RECT *)&rc,FALSE);
	    } else {
		/* Window GREW, need to invalidate prev status rect */
		InvalidateRect(hwnd, (CONST RECT *)&StatRecSizeNT,TRUE);
	    }
	    switch (wParam) {
		case SIZEFULLSCREEN:
		case SIZENORMAL:
		    NTWndSize = wParam;
		    SetMainWndSize(SBUNT);
		/* NOTE FALL THROUGH */
		default:
		    return(FALSE);
		    break;
	    }
	    break;

	case WM_VSCROLL:
	    if(NTScrollRange)
		MainScroll(hwnd, (int)(LOWORD(wParam)), (int)(HIWORD(wParam)), 0, 0);
	    return(TRUE);
	    break;

	case WM_PRIVCLOSECANCEL:
	    CompleteKey = FALSE;
	    EditHotKey = FALSE;
	    NewHotKey = FALSE;
            lstrcpy((LPSTR)(PifNText->achAutoexecFile), szOldAutoexec);
            SetDlgItemText(hwnd, IDI_AUTOEXEC, szOldAutoexec);
            lstrcpy((LPSTR)(PifNText->achConfigFile), szOldConfig);
            SetDlgItemText(hwnd, IDI_CONFIG, szOldConfig);
            SetNTDlgItem(IDI_AUTOEXEC);
	    UpdatePifScreenNT();   /* DISCARD any changes in NT */

	    /* NOTE FALL THROUGH */
	case WM_PRIVCLOSEOK:
            bNTDlgOpen = FALSE;
	    ChngFlg = UpdatePifStruct();
	    if(ChngFlg)
		FileChanged = ChngFlg;
	    hwndNTPifDlg = (HWND)NULL;
	    hSysMenuNT = (HMENU)NULL;
	    /*
	     * WHAT IS THIS RANDOM SetFocus DOING HERE??? Well the advanced
	     *	window is WS_OVERLAPPED, and  Windows CAN get all confused
	     *	about where the Focus should go on Destroy with this style.
	     *	The style probably should be changed to WS_POPUP, but that
	     *	is a change that may cause other problems.
	     */
	    SetFocus(hMainwnd);
	    DragAcceptFiles(hwnd,FALSE);
	    DestroyWindow(hwnd);
	    ReEnableAdvButton();
	    NTScrollRange = 0;
	    ModeAdvanced = FALSE;
	    return(TRUE);
	    break;

	case WM_SYSCOMMAND:
	    switch (wParam) {
		case SC_CLOSE:
		    SendMessage(hwnd,WM_PRIVCLOSECANCEL,0,0L);
		    return(TRUE);

		default:
		    return(FALSE);
	    }
	    break;

	case WM_PRIVGETSIZE:	/* return correct size for client area */
	    *(long FAR *)lParam = GetNTDlgSize(hwnd);
	    break;

	case WM_GETMINMAXINFO:
	    GetClientRect(hwnd, &StatRecSizeNT);
	    StatRecSizeNT.top = StatRecSizeNT.bottom - (StatusPntData.dyStatus + StatusPntData.dyBorderx2);
	    size = GetNTDlgSize(hwnd);
	    width = LOWORD(size) +
		    (2 * GetSystemMetrics(SM_CXFRAME)) +
		    GetSystemMetrics(SM_CXVSCROLL) +
		    GetSystemMetrics(SM_CXBORDER);
	    height = HIWORD(size) +
		    GetSystemMetrics(SM_CYCAPTION) +
		    (2 * GetSystemMetrics(SM_CYFRAME));
	    ppnt3 = ppnt4 = (LPPOINT)lParam;
	    ppnt3 += 3;
	    ppnt4 += 4;
	    if(height > (ppnt4->y - (4 * SysCharHeight)))
		height = ppnt4->y - (4 * SysCharHeight);
	    ppnt3->y = height;
	    ppnt3->x = width;
	    return(TRUE);
	    break;

	case WM_DROPFILES:
	    DoOpenPifFile((HDROP)wParam);
	    break;

	default:
	    return(FALSE);

    }
    return(TRUE);
}


int FAR PASCAL PifAdvWndProc(HWND hwnd, UINT message, WPARAM wParam, LONG lParam)
{
    LPPOINT ppnt3;
    LPPOINT ppnt4;
    int     width;
    int     height;
    long    size;
    BOOL    ChngFlg;
    HMENU   hmenu;
    RECT    rc;
    int     tmpFOCID;

    switch (message) {

	case WM_INITDIALOG:
	    if((hmenu = GetSystemMenu(hwnd,FALSE))) {
		DeleteMenu(hmenu, SC_RESTORE,  MF_BYCOMMAND);
		DeleteMenu(hmenu, SC_SIZE,     MF_BYCOMMAND);
		DeleteMenu(hmenu, SC_MINIMIZE, MF_BYCOMMAND);
		DeleteMenu(hmenu, SC_MAXIMIZE, MF_BYCOMMAND);
	    } else {
		Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	    }
	    hwndFocusAdv = (HWND)wParam;
            bAdvDlgOpen = TRUE;
	    FocusIDAdv = GetDlgCtrlID((HWND)wParam);
	    SetStatusText(hwnd,FocusIDAdv,FALSE);
	    if(InitShWind) {
		SetFocus((HWND)wParam);  /* Give focus to wparam item */
		SendMessage((HWND)wParam,EM_SETSEL,0,MAKELONG(0,0x7FFF));
		return(FALSE);
	    } else {
		return(FALSE);		 /* Do not set focus until init show */
	    }
	    break;

	case WM_PAINT:
	    PaintStatus(hwnd);
	    return(FALSE);
	    break;

	case WM_COMMAND:
	    SetStatusText(hwnd,FocusIDAdv,TRUE);
	    FocusIDAdvMenu = 0;
	    DoDlgCommand(hwnd, wParam, lParam);
	    break;

	case WM_SYSCOLORCHANGE:
	    InvalidateStatusBar(hwnd);
	    break;

	case WM_MENUSELECT:
	    tmpFOCID = FocusIDAdvMenu;
	    if((HIWORD(wParam) == 0xFFFF) && (lParam == (LPARAM)NULL)) { // was menu closed?
		SetStatusText(hwnd,FocusIDAdv,TRUE);
		tmpFOCID = FocusIDAdvMenu = 0;
	    } else if(lParam == 0) {	    /* ignore these */
	    } else if(HIWORD(wParam) & MF_POPUP) {
		if((HMENU)lParam == hSysMenuAdv)
		    FocusIDAdvMenu = M_SYSMENUADV;
	    } else {
		if(LOWORD(wParam) != 0)    /* separators have wparam of 0 */
		    FocusIDAdvMenu = LOWORD(wParam);
		if(FocusIDAdvMenu == SC_CLOSE)
		    FocusIDAdvMenu = SC_CLOSEADV;
	    }
	    if(tmpFOCID != FocusIDAdvMenu)
		SetStatusText(hwnd,FocusIDAdvMenu,TRUE);
	    break;

	case WM_SIZE:
	    GetClientRect(hwnd, &rc);
	    rc.top = rc.bottom - (StatusPntData.dyStatus + StatusPntData.dyBorderx2);
	    if(rc.top < StatRecSizeAdv.top) {
		/* Window SHRANK, need to invalidate current status rect */
		InvalidateRect(hwnd, (CONST RECT *)&rc,FALSE);
	    } else {
		/* Window GREW, need to invalidate prev status rect */
		InvalidateRect(hwnd, (CONST RECT *)&StatRecSizeAdv,TRUE);
	    }
	    switch (wParam) {
		case SIZEFULLSCREEN:
		case SIZENORMAL:
		    AdvWndSize = wParam;
		    SetMainWndSize(SBUADV);
		/* NOTE FALL THROUGH */
		default:
		    return(FALSE);
		    break;
	    }
	    break;

	case WM_VSCROLL:
	    if(AdvScrollRange)
		MainScroll(hwnd, (int)(LOWORD(wParam)), (int)(HIWORD(wParam)), 0, 0);
	    return(TRUE);
	    break;

	case WM_PRIVCLOSECANCEL:
	    CompleteKey = FALSE;
	    EditHotKey = FALSE;
	    NewHotKey = FALSE;
	    UpdatePifScreenAdv();   /* DISCARD any changes in advanced */
	    /* NOTE FALL THROUGH */
	case WM_PRIVCLOSEOK:
            bAdvDlgOpen = FALSE;
	    ChngFlg = UpdatePifStruct();
	    if(ChngFlg)
		FileChanged = ChngFlg;
	    hwndAdvPifDlg = (HWND)NULL;
	    hSysMenuAdv = (HMENU)NULL;
	    /*
	     * WHAT IS THIS RANDOM SetFocus DOING HERE??? Well the advanced
	     *	window is WS_OVERLAPPED, and  Windows CAN get all confused
	     *	about where the Focus should go on Destroy with this style.
	     *	The style probably should be changed to WS_POPUP, but that
	     *	is a change that may cause other problems.
	     */
	    SetFocus(hMainwnd);
	    DragAcceptFiles(hwnd,FALSE);
	    DestroyWindow(hwnd);
	    ReEnableAdvButton();
	    AdvScrollRange = 0;
	    ModeAdvanced = FALSE;
	    return(TRUE);
	    break;

	case WM_SYSCOMMAND:
	    switch (wParam) {
		case SC_CLOSE:
		    SendMessage(hwnd,WM_PRIVCLOSECANCEL,0,0L);
		    return(TRUE);

		default:
		    return(FALSE);
	    }
	    break;

	case WM_PRIVGETSIZE:	/* return correct size for client area */
	    *(long FAR *)lParam = GetAdvDlgSize(hwnd);
	    break;

	case WM_GETMINMAXINFO:
	    GetClientRect(hwnd, &StatRecSizeAdv);
	    StatRecSizeAdv.top = StatRecSizeAdv.bottom - (StatusPntData.dyStatus + StatusPntData.dyBorderx2);
	    size = GetAdvDlgSize(hwnd);
	    width = LOWORD(size) +
		    (2 * GetSystemMetrics(SM_CXFRAME)) +
		    GetSystemMetrics(SM_CXVSCROLL) +
		    GetSystemMetrics(SM_CXBORDER);
	    height = HIWORD(size) +
		    GetSystemMetrics(SM_CYCAPTION) +
		    (2 * GetSystemMetrics(SM_CYFRAME));
	    ppnt3 = ppnt4 = (LPPOINT)lParam;
	    ppnt3 += 3;
	    ppnt4 += 4;
	    if(height > (ppnt4->y - (4 * SysCharHeight)))
		height = ppnt4->y - (4 * SysCharHeight);
	    ppnt3->y = height;
	    ppnt3->x = width;
	    return(TRUE);
	    break;

	case WM_DROPFILES:
	    DoOpenPifFile((HDROP)wParam);
	    break;

	default:
	    return(FALSE);

    }
    return(TRUE);
}

BOOL CALLBACK PifWndProc(HWND hwnd, UINT message, WPARAM wParam, LONG lParam)
{
    RECT rc2;
    RECT rc3;
    RECT rc4;

    switch (message) {

	case WM_INITDIALOG:
	    hwndFocusMain = (HWND)wParam;
	    FocusIDMain = GetDlgCtrlID((HWND)wParam);
	    SetStatusText(hMainwnd,FocusIDMain,TRUE);
	    if(InitShWind) {
		SetFocus((HWND)wParam);  /* Give focus to wparam item */
		SendMessage((HWND)wParam,EM_SETSEL,0,MAKELONG(0,0x7FFF));
		return(FALSE);
	    } else {
		return(FALSE);		 /* Do not set focus until init show */
	    }
	    break;

	case WM_COMMAND:
	    DoDlgCommand(hwnd, wParam, lParam);
	    break;

	case WM_PRIVGETSIZE:	/* return correct size for parent window client area */
	    GetWindowRect(hwnd,(LPRECT)&rc3);
	    if(CurrMode386) {
		GetWindowRect(GetDlgItem(hwnd,IDI_BACK),(LPRECT)&rc4);
		GetWindowRect(GetDlgItem(hwnd,IDI_EXIT),(LPRECT)&rc2);
	    } else {
		GetWindowRect(GetDlgItem(hwnd,IDI_EPATH),(LPRECT)&rc4);
		GetWindowRect(GetDlgItem(hwnd,IDI_ALTPRTSC),(LPRECT)&rc2);
	    }
	    *(long FAR *)lParam = MAKELONG((rc4.right - rc3.left) +
					    SysCharWidth,
					   (rc2.top-rc3.top) +
					   (rc2.bottom - rc2.top) +
					   ((rc2.bottom - rc2.top)/3) +
					   (StatusPntData.dyStatus + StatusPntData.dyBorderx2));
	    if(!wParam) {
		SetWindowPos(hwnd,
			     (HWND)NULL,
			     0,
			     0,
			     0,
			     0,
			     SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
	    }
	    break;

	case WM_DROPFILES:
	    DoOpenPifFile((HDROP)wParam);
	    break;

	default:
	    return(FALSE);

    }
    return(TRUE);
}


SwitchNT(HWND hwnd)
{
    BOOL    ChngFlg;

    hwndFocusMain = hwndFocusAdv = hwndFocusNT = hwndFocus = (HWND)NULL;
    if(ModeAdvanced) {
	Disable386Advanced(hwndAdvPifDlg, hwndNTPifDlg);
    }
    else {
	ChngFlg = UpdatePifStruct();
	if(ChngFlg)
	    FileChanged = ChngFlg;
        if(!bNTDlgOpen) {
	    EnableWindow(GetDlgItem(hwnd,IDI_NT),FALSE);
	    NTScrollRange = 0;
/*
	    NTClose = TRUE;
*/
	    hwndNTPifDlg = CreateDialog(hPifInstance,
				        MAKEINTRESOURCE(ID_PIFNTTEMPLT),
				        hMainwnd ,
				        lpfnNTPifWnd);
        }
	if(hwndNTPifDlg == (HWND)NULL) {
	    hwndNTPifDlg = (HWND)NULL;
	    Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	    Disable386Advanced(hwndAdvPifDlg, hwndNTPifDlg);
	} else {
	    hSysMenuNT = GetSystemMenu(hwndNTPifDlg,FALSE);
	    DragAcceptFiles(hwndNTPifDlg,TRUE);
	    ModeAdvanced = TRUE;
	    SetMainTitle();
	    UpdatePifScreen();
	    hwndFocusMain = GetDlgItem(hwndPifDlg,IDI_ENAME);
	    FocusIDMain = IDI_ENAME;
	    SetMainWndSize(SBUSZNT);
	    SetStatusText(hMainwnd,FocusIDMain,TRUE);
	}
    }
    if(hwndNTPifDlg) {
	ShowWindow(hwndNTPifDlg, SW_SHOWNORMAL);
	SendDlgItemMessage(hwndNTPifDlg,IDI_AUTOEXEC,EM_SETSEL,0,MAKELONG(0,0x7FFF));
    }
    return(TRUE);
}



SwitchAdvance386(HWND hwnd)
{
    BOOL    ChngFlg;

    hwndFocusMain = hwndFocusAdv = hwndFocusNT = hwndFocus = (HWND)NULL;
    if(ModeAdvanced) {
	Disable386Advanced(hwndAdvPifDlg, hwndNTPifDlg);
    } else {
	ChngFlg = UpdatePifStruct();
	if(ChngFlg)
	    FileChanged = ChngFlg;
        if(!bAdvDlgOpen)
	    EnableWindow(GetDlgItem(hwnd,IDI_ADVANCED),FALSE);
	AdvScrollRange = 0;
	AdvClose = TRUE;
	hwndAdvPifDlg = CreateDialog(hPifInstance,
				     MAKEINTRESOURCE(ID_PIF386ADVTEMPLT),
				     hMainwnd ,
				     lpfnAdvPifWnd);
	if(hwndAdvPifDlg == (HWND)NULL) {
	    hwndAdvPifDlg = (HWND)NULL;
	    Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	    Disable386Advanced(hwndAdvPifDlg, hwndNTPifDlg);
	} else {
	    hSysMenuAdv = GetSystemMenu(hwndAdvPifDlg,FALSE);
	    DragAcceptFiles(hwndAdvPifDlg,TRUE);
	    ModeAdvanced = TRUE;
	    SetMainTitle();
	    UpdatePifScreen();
	    hwndFocusMain = GetDlgItem(hwndPifDlg,IDI_ENAME);
	    FocusIDMain = IDI_ENAME;
	    SetMainWndSize(SBUSZADV);
	    SetStatusText(hMainwnd,FocusIDMain,TRUE);
	}
    }
    if(hwndAdvPifDlg) {
	ShowWindow(hwndAdvPifDlg, SW_SHOWNORMAL);
	SendDlgItemMessage(hwndAdvPifDlg,IDI_BPRI,EM_SETSEL,0,MAKELONG(0,0x7FFF));
    }
    return(TRUE);
}


BOOL EnableMode286(HWND hwnd,BOOL showflg)
{
    HMENU hMenu;
    HWND hWndSv;

    if(!Pif286ext30) {
	if(!(Pif286ext30 = AllocInit286Ext30())) {
	    Warning(NOMODE286,MB_ICONEXCLAMATION | MB_OK);
	    return(FALSE);
	}
    }
    /*
     * if(!Pif286ext31) {
     *	   if(!(Pif286ext31 = AllocInit286Ext31())) {
     *	       Warning(NOMODE286,MB_ICONEXCLAMATION | MB_OK);
     *	       return(FALSE);
     *	   }
     * }
     */
    hwndFocusMain = hwndFocusAdv = hwndFocusNT = hwndFocus = (HWND)NULL;
    if(hwndAdvPifDlg)
	SendMessage(hwndAdvPifDlg,WM_PRIVCLOSEOK,0,0L);
    if(hwndNTPifDlg)
	SendMessage(hwndNTPifDlg,WM_PRIVCLOSEOK,0,0L);
    if(hwndPifDlg) {
	hWndSv = hwndPifDlg;
	hwndPifDlg = (HWND)NULL;
	DragAcceptFiles(hWndSv,FALSE);
	DestroyWindow(hWndSv);
    }

    CurrMode386 = FALSE;

    if(Pif386ext && !(Pif286ext30->PfW286Flags &
       (fALTTABdis286 | fALTESCdis286 | fCTRLESCdis286 | fALTPRTSCdis286 | fPRTSCdis286))) {
	if(Pif386ext->PfW386Flags & fALTTABdis)
	    Pif286ext30->PfW286Flags |= fALTTABdis286;
	if(Pif386ext->PfW386Flags & fALTESCdis)
	    Pif286ext30->PfW286Flags |= fALTESCdis286;
	if(Pif386ext->PfW386Flags & fCTRLESCdis)
	    Pif286ext30->PfW286Flags |= fCTRLESCdis286;
	if(Pif386ext->PfW386Flags & fALTPRTSCdis)
	    Pif286ext30->PfW286Flags |= fALTPRTSCdis286;
	if(Pif386ext->PfW386Flags & fPRTSCdis)
	    Pif286ext30->PfW286Flags |= fPRTSCdis286;
    }

    hwndPifDlg = CreateDialog(hPifInstance,
			      MAKEINTRESOURCE(ID_PIF286TEMPLATE),
			      hwnd,
			      lpfnPifWnd);

    if(hwndPifDlg == (HWND)NULL) {
	hwndPifDlg = (HWND)NULL;
	Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	return(FALSE);
    } else {
	DragAcceptFiles(hwndPifDlg,TRUE);
	CheckMenuItem((hMenu = GetMenu(hwnd)),M_286,MF_BYCOMMAND + MF_CHECKED);
	CheckMenuItem(hMenu,M_386,MF_BYCOMMAND + MF_UNCHECKED);
	SetMainWndSize(SBUSZMAINADVNT);
	SendDlgItemMessage(hwndPifDlg, IDI_ENAME, EM_LIMITTEXT, PIFSTARTLOCSIZE-1, 0L);
	SendDlgItemMessage(hwndPifDlg, IDI_EPARM, EM_LIMITTEXT, PIFPARAMSSIZE-1, 0L);
	SendDlgItemMessage(hwndPifDlg, IDI_EPATH, EM_LIMITTEXT, PIFDEFPATHSIZE-1, 0L);
	SendDlgItemMessage(hwndPifDlg, IDI_ETITLE, EM_LIMITTEXT, PIFNAMESIZE, 0L);
	UpdatePifScreen();
	if(showflg) {
	    ShowWindow(hwndPifDlg, SW_SHOWNORMAL);
	    if(hwndAdvPifDlg)
		ShowWindow(hwndAdvPifDlg, SW_SHOWNORMAL);
	    if(hwndNTPifDlg)
		ShowWindow(hwndNTPifDlg, SW_SHOWNORMAL);
	}
	return(TRUE);
    }
}


EnableMode386(HWND hwnd,BOOL showflg)
{
    HMENU hMenu;
    HWND hWndSv;
    unsigned char buf[20];
    unsigned char buf2[100];
    unsigned char buf3[100];
    unsigned char buf4[100];

    if(!Pif386ext) {
	if(!(Pif386ext = AllocInit386Ext())) {
	    Warning(NOMODE386,MB_ICONEXCLAMATION | MB_OK);
	    return(FALSE);
	}
    }
    if(!PifNText) {
	if(!(PifNText = AllocInitNTExt())) {
	    Warning(NOMODENT,MB_ICONEXCLAMATION | MB_OK);
	    return(FALSE);
	}
    }
    hwndFocusMain = hwndFocusAdv = hwndFocusNT = hwndFocus = (HWND)NULL;
    if(hwndAdvPifDlg)
	SendMessage(hwndAdvPifDlg,WM_PRIVCLOSEOK,0,0L);
    if(hwndNTPifDlg)
	SendMessage(hwndNTPifDlg,WM_PRIVCLOSEOK,0,0L);
    if(hwndPifDlg) {
	hWndSv = hwndPifDlg;
	hwndPifDlg = (HWND)NULL;
	DragAcceptFiles(hWndSv,FALSE);
	DestroyWindow(hWndSv);
    }

    CurrMode386 = TRUE;
    ModeAdvanced = FALSE;

    if(Pif286ext30 && !(Pif386ext->PfW386Flags &
       (fALTTABdis | fALTESCdis | fCTRLESCdis | fALTPRTSCdis | fPRTSCdis))) {
	if(Pif286ext30->PfW286Flags & fALTTABdis286)
	    Pif386ext->PfW386Flags |= fALTTABdis;
	if(Pif286ext30->PfW286Flags & fALTESCdis286)
	    Pif386ext->PfW386Flags |= fALTESCdis;
	if(Pif286ext30->PfW286Flags & fCTRLESCdis286)
	    Pif386ext->PfW386Flags |= fCTRLESCdis;
	if(Pif286ext30->PfW286Flags & fALTPRTSCdis286)
	    Pif386ext->PfW386Flags |= fALTPRTSCdis;
	if(Pif286ext30->PfW286Flags & fPRTSCdis286)
	    Pif386ext->PfW386Flags |= fPRTSCdis;

    }

    hwndPifDlg = CreateDialog(hPifInstance,
			      MAKEINTRESOURCE(ID_PIF386TEMPLATE),
			      hwnd ,
			      lpfnPifWnd);

    if(hwndPifDlg == (HWND)NULL) {
	hwndPifDlg = (HWND)NULL;
	Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	return(FALSE);
    } else {
	DragAcceptFiles(hwndPifDlg,TRUE);
	CheckMenuItem((hMenu = GetMenu(hwnd)),M_386,MF_BYCOMMAND + MF_CHECKED);
	CheckMenuItem(hMenu,M_286,MF_BYCOMMAND + MF_UNCHECKED);
	if(LoadString(hPifInstance, WININISECT, (LPSTR)buf, sizeof(buf)) &&
	   LoadString(hPifInstance, WININIADV, (LPSTR)buf2, sizeof(buf2)) &&
	   LoadString(hPifInstance, WININION, (LPSTR)buf3, sizeof(buf3))) {
	    GetProfileString((LPSTR)buf,(LPSTR)buf2,(LPSTR)"",(LPSTR)buf4,sizeof(buf4));
	    if(!lstrcmp(AnsiUpper((LPSTR)buf4),AnsiUpper((LPSTR)buf3)))
		ModeAdvanced = TRUE;
	}
	if(ModeAdvanced) {
            EnableWindow(GetDlgItem(hwndPifDlg,IDI_ADVANCED),FALSE);
	    AdvScrollRange = 0;
	    AdvClose = TRUE;
	    hwndAdvPifDlg = CreateDialog(hPifInstance,
					 MAKEINTRESOURCE(ID_PIF386ADVTEMPLT),
					 hwnd ,
					 lpfnAdvPifWnd);
	    if(hwndAdvPifDlg == (HWND)NULL) {
		hwndAdvPifDlg = (HWND)NULL;
		Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
		ReEnableAdvButton();
		return(FALSE);
	    }
	    hSysMenuAdv = GetSystemMenu(hwndAdvPifDlg,FALSE);
	    DragAcceptFiles(hwndAdvPifDlg,TRUE);

	    EnableWindow(GetDlgItem(hwndPifDlg,IDI_NT),FALSE);
	    NTScrollRange = 0;
/*
	    NTClose = TRUE;
*/
	    hwndNTPifDlg = CreateDialog(hPifInstance,
					MAKEINTRESOURCE(ID_PIFNTTEMPLT),
					hwnd ,
					lpfnNTPifWnd);
	    if(hwndNTPifDlg == (HWND)NULL) {
		hwndNTPifDlg = (HWND)NULL;
		Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
		ReEnableAdvButton();
		return(FALSE);
	    }
	    hSysMenuNT = GetSystemMenu(hwndNTPifDlg,FALSE);
	    DragAcceptFiles(hwndNTPifDlg,TRUE);
	    SetMainTitle();
	} else {
	    ReEnableAdvButton();
	}
	SetMainWndSize(SBUSZMAINADVNT);
	SendDlgItemMessage(hwndPifDlg, IDI_ENAME, EM_LIMITTEXT, PIFSTARTLOCSIZE-1, 0L);
	SendDlgItemMessage(hwndPifDlg, IDI_EPARM, EM_LIMITTEXT, PIFPARAMSSIZE-1, 0L);
	SendDlgItemMessage(hwndPifDlg, IDI_EPATH, EM_LIMITTEXT, PIFDEFPATHSIZE-1, 0L);
	SendDlgItemMessage(hwndPifDlg, IDI_ETITLE, EM_LIMITTEXT, PIFNAMESIZE, 0L);
	UpdatePifScreen();
	if(showflg) {
	    ShowWindow(hwndPifDlg, SW_SHOWNORMAL);
	    if(hwndAdvPifDlg)
		ShowWindow(hwndAdvPifDlg, SW_SHOWNORMAL);
	    if(hwndNTPifDlg)
		ShowWindow(hwndNTPifDlg, SW_SHOWNORMAL);
	}
	return(TRUE);
    }
}


DoPifCommand(HWND hwnd,WPARAM wParam,LONG lParam)
{
    int 	  i, cmd;
    unsigned char *pch;
    unsigned char *pchBuf;
    HWND	  hwnd2;
    BOOL	  ChngFlg;

    cmd = LOWORD(wParam);

    switch (cmd) {
    case M_NEW:
	if (MaybeSaveFile()) {
	    InitPifStruct();
	    UpdatePifScreen();
	    UpdatePifStruct();
	    FileChanged = FALSE;
	    ofReopen.szPathName[0] = 0;
	    CurPifFile[0] = 0;

	    PifFile->id = 0;			 /* compute check sum */
	    pch = (PUCHAR)PifFile->name;
	    i = PIFSIZE;
	    while (i--)
		PifFile->id += *pch++;
	    SendMessage(hwndPifDlg,WM_NEXTDLGCTL,
			(WPARAM)(hwnd2 = GetDlgItem(hwndPifDlg,IDI_ENAME)),1L);
	    SetFocus(hwnd2);
	    SetMainTitle();
	}
	break;

    case M_OPEN:
	DoOpenPifFile((HDROP)NULL);
	break;

    case M_SAVE:
	if (CurPifFile[0]) {
	    pchBuf = CurPifFile;
	    goto Save;
	}
    case M_SAVEAS:
SaveAs:
	if(pchBuf = PutUpDB(DTSAVE)) {
Save:
	    HourGlass(TRUE);
	    i = SavePifFile(pchBuf, cmd);
	    if (pchBuf != CurPifFile) {
		LocalFree((HANDLE)pchBuf);
	    }
	    HourGlass(FALSE);
	    if (i == SAVERETRY)
		goto SaveAs;
	}
	SetMainTitle();
	break;

    case M_INDXHELP:
	if(CurrMode386) {
	    if(ModeAdvanced) {
                if(hwnd == hwndAdvPifDlg) {
		    DoHelp(IDXID_386AHELP,IDXID_386AHELP);
                }
                else {
		    DoHelp(IDXID_NTHELP,IDXID_NTHELP);
                }
	    } else {
		DoHelp(IDXID_386HELP,IDXID_386HELP);
	    }
	} else {
	    DoHelp(IDXID_286HELP,IDXID_286HELP);
	}
	break;

    case M_HELPHELP:
    case M_286HELP:
    case M_386HELP:
    case M_386AHELP:
    case M_NTHELP:
    case M_SHELP:
	DoHelp(cmd,0);
	break;

    case M_AHELP:
	DoHelp(0,0);
	break;

    case M_ABOUT:
	PutUpDB(DTABOUT);
	break;

    case M_286:
	if(CurrMode386) {
	    if(SysMode386) {
		if(Warning(IS286,MB_ICONASTERISK | MB_OKCANCEL) == IDCANCEL) {
		    break;
		}
	    }
	    ChngFlg = UpdatePifStruct();
	    if(ChngFlg)
		FileChanged = ChngFlg;
	    if(!DoFieldsWork(FALSE))
		break;
	    HourGlass(TRUE);
	    if(!EnableMode286(hwnd,TRUE))
		SendMessage(hwnd,WM_CLOSE,0,0);
	    HourGlass(FALSE);
	}
	break;

    case M_386:
	if(!CurrMode386) {
	    if(!SysMode386) {
		if(Warning(IS386,MB_ICONASTERISK | MB_OKCANCEL) == IDCANCEL) {
		    break;
		}
	    }
	    ChngFlg = UpdatePifStruct();
	    if(ChngFlg)
		FileChanged = ChngFlg;
	    if(!DoFieldsWork(FALSE))
		break;
	    HourGlass(TRUE);
	    if(!EnableMode386(hwnd,TRUE))
		SendMessage(hwnd,WM_CLOSE,0,0);
	    HourGlass(FALSE);
	}
	break;

    case M_EXIT:
	PostMessage(hwnd, WM_CLOSE, 0, 0L);
	break;

    }
    return(TRUE);
}


long FAR PASCAL PifMainWndProc(HWND hwnd, UINT message, WPARAM wParam, LONG lParam)
{
    LPPOINT ppnt3;
    LPPOINT ppnt4;
    int     width;
    int     height;
    int     tmpFOCID;
    long    size;
    RECT    rc;
    HWND    Hparsav;

    switch (message) {


    case WM_SETFOCUS:
	if(hwndFocusMain) {
	    /*
	     *	How can hwndFocusMain != 0 but hwndPifDlg == 0, I hear you
	     *	ask. Well it's due to a message race. Windows has sent the
	     *	WM_INITDIALOG to hwndPifDlg which sets hwndFocusMain, but
	     *	the CreateDialog call has not actually returned yet so
	     *	hwndPifDlg is still 0.
	     *
	     */
	    if(hwndPifDlg)
		SendMessage(hwndPifDlg,WM_NEXTDLGCTL,(WPARAM)hwndFocusMain,1L);
	    SetFocus(hwndFocusMain);
	}
	return(TRUE);

    case WM_PAINT:
	PaintStatus(hwnd);
	goto DoDef;
	break;

    case WM_MENUSELECT:
	tmpFOCID = FocusIDMainMenu;
	if((HIWORD(wParam) == 0xFFFF) && (lParam == (LPARAM)NULL)) {  // was menu closed?
	    SetStatusText(hwnd,FocusIDMain,TRUE);
	    tmpFOCID = FocusIDMainMenu = 0;
	} else if(lParam == 0) {	/* ignore these */
	} else if(HIWORD(wParam) & MF_POPUP) {
	    if((HMENU)lParam == hSysMenuMain)
		FocusIDMainMenu = M_SYSMENUMAIN;
	    else if((HMENU)lParam == hFileMenu)
		FocusIDMainMenu = M_FILEMENU;
	    else if((HMENU)lParam == hModeMenu)
		FocusIDMainMenu = M_MODEMENU;
	    else if((HMENU)lParam == hHelpMenu)
		FocusIDMainMenu = M_HELPMENU;
	} else {
	    if(LOWORD(wParam) != 0)	    /* separators have wparam of 0 */
		FocusIDMainMenu = LOWORD(wParam);
	}
	if(tmpFOCID != FocusIDMainMenu)
	    SetStatusText(hwnd,FocusIDMainMenu,TRUE);
	goto DoDef;
	break;

    case WM_QUERYENDSESSION:
	if(DoingMsg) {
	    Hparsav = hParentWnd;
	    hParentWnd = 0;
	    Warning(errNOEND,MB_ICONEXCLAMATION | MB_OK | MB_SYSTEMMODAL);
	    hParentWnd = Hparsav;
	    return(FALSE);
	}
    case WM_CLOSE:
	if (MaybeSaveFile()) {
	    if (message == WM_CLOSE) {
		if(hwndHelpDlgParent) {
		    WinHelp(hwndHelpDlgParent,(LPSTR)PIFHELPFILENAME,HELP_QUIT,(DWORD)NULL);
		    hwndHelpDlgParent = (HWND)NULL;
		}
		DragAcceptFiles(hwnd,FALSE);
                DestroyWindow(hwnd);
	    }
	    return(TRUE);
	}
	return(FALSE);
	break;

    case WM_COMMAND:
	SetStatusText(hwnd,FocusIDMain,TRUE);
	tmpFOCID = FocusIDMainMenu = 0;
	DoPifCommand(hwnd,wParam,lParam);
	break;

    case WM_VSCROLL:
	if(MainScrollRange)
	    MainScroll(hwnd, (int)(LOWORD(wParam)), (int)(HIWORD(wParam)), 0, 0);
	break;

    case WM_SYSCOLORCHANGE:
	InvalidateStatusBar(hwnd);
	break;

    case WM_SIZE:
	GetClientRect(hwnd, &rc);
	rc.top = rc.bottom - (StatusPntData.dyStatus + StatusPntData.dyBorderx2);
	if(rc.top < StatRecSizeMain.top) {
	    /* Window SHRANK, need to invalidate current status rect */
	    InvalidateRect(hwnd, (CONST RECT *)&rc,FALSE);
	} else {
	    /* Window GREW, need to invalidate prev status rect */
	    InvalidateRect(hwnd, (CONST RECT *)&StatRecSizeMain,TRUE);
	}
	switch (wParam) {
	    case SIZEFULLSCREEN:
	    case SIZENORMAL:
		MainWndSize = wParam;
		SetMainWndSize(SBUMAIN);
		break;

	    default:
		break;
	}
	break;

    case WM_GETMINMAXINFO:
	if(!hwndPifDlg)
	    goto DoDef;
	GetClientRect(hwnd, &StatRecSizeMain);
	StatRecSizeMain.top = StatRecSizeMain.bottom - (StatusPntData.dyStatus + StatusPntData.dyBorderx2);
	SendMessage(hwndPifDlg,WM_PRIVGETSIZE,1,(LONG)(long FAR *)&size);
	width = LOWORD(size) +
		(2 * GetSystemMetrics(SM_CXFRAME)) +
		GetSystemMetrics(SM_CXVSCROLL) +
		GetSystemMetrics(SM_CXBORDER);
	height = HIWORD(size) +
		 GetSystemMetrics(SM_CYCAPTION) +
		 GetSystemMetrics(SM_CYMENU) +
		 (2 * GetSystemMetrics(SM_CYFRAME));
	ppnt3 = ppnt4 = (LPPOINT)lParam;
	ppnt3 += 3;
	ppnt4 += 4;
	if(height > (ppnt4->y - (4 * SysCharHeight)))
	    height = ppnt4->y - (4 * SysCharHeight);
	ppnt3->y = height;
	ppnt3->x = width;
	break;

    case WM_DESTROY:
	if(HotKyFnt) {
	    DeleteObject((HGDIOBJ)HotKyFnt);
	    HotKyFnt = (HFONT)NULL;
	}
	if(StatusPntData.hFontStatus) {
	    DeleteObject(StatusPntData.hFontStatus);
	    StatusPntData.hFontStatus = (HGDIOBJ)NULL;
	}
	PostQuitMessage(0);
	break;

    case WM_DROPFILES:
	DoOpenPifFile((HDROP)wParam);
	break;

/* this must be just before the default section */
    case WM_SYSCOMMAND:
DoDef:
    default:
	return(DefWindowProc(hwnd, message, wParam, lParam));
    }
    return(TRUE);

}


AdjustFocusCtrl(HWND hwnd)
{
    RECT rc;
    RECT rc2;
    POINT cTLpt;
    POINT cLRpt;
    int  i;
    int  tmpFOCID;
    HWND tmpFocWnd;

    if(hwnd == hwndAdvPifDlg) {
	if(!(tmpFocWnd = hwndFocusAdv))
	    return(TRUE);
    } else if(hwnd == hwndNTPifDlg) {
	if(!(tmpFocWnd = hwndFocusNT))
	    return(TRUE);
    } else {
	if(!(tmpFocWnd = hwndFocusMain))
	    return(TRUE);
    }
    for(i = 0; i < 20; i++) {
	if((hwnd == hwndAdvPifDlg) || (hwnd == hwndNTPifDlg)) {
	    GetWindowRect(tmpFocWnd,(LPRECT)&rc2);
	    GetWindowRect(hwnd,(LPRECT)&rc);
	    rc.bottom -= GetSystemMetrics(SM_CYFRAME) + (StatusPntData.dyStatus + StatusPntData.dyBorderx2);
	    rc.top += GetSystemMetrics(SM_CYFRAME) +
		      GetSystemMetrics(SM_CYCAPTION);
	} else {
	    GetClientRect(hMainwnd,(LPRECT)&rc);
	    cTLpt.x = rc.left;
	    cTLpt.y = rc.top;
	    cLRpt.x = rc.right;
	    cLRpt.y = rc.bottom;
	    ClientToScreen(hMainwnd,(LPPOINT)&cTLpt);
	    ClientToScreen(hMainwnd,(LPPOINT)&cLRpt);
	    rc.left = cTLpt.x;
	    rc.top = cTLpt.y;
	    rc.right = cLRpt.x;
	    rc.bottom = cLRpt.y - (StatusPntData.dyStatus + StatusPntData.dyBorderx2);
	    GetWindowRect(tmpFocWnd,(LPRECT)&rc2);
	}
	if((rc2.top >= rc.top) && (rc2.bottom <= rc.bottom)) {
	    if(hwnd == hwndAdvPifDlg) {
		if(tmpFocWnd == hwndFocusAdv)
		    return(TRUE);
		hwndFocus = hwndFocusAdv = tmpFocWnd;
		tmpFOCID = FocusIDAdv;
		FocusID = FocusIDAdv = GetDlgCtrlID(hwndFocusAdv);
		if(tmpFOCID != FocusIDAdv)
		    SetStatusText(hwndAdvPifDlg,FocusIDAdv,TRUE);
	    } else if(hwnd == hwndNTPifDlg) {
		if(tmpFocWnd == hwndFocusNT)
		    return(TRUE);
		hwndFocus = hwndFocusNT = tmpFocWnd;
		tmpFOCID = FocusIDNT;
		FocusID = FocusIDNT = GetDlgCtrlID(hwndFocusNT);
		if(tmpFOCID != FocusIDNT)
		    SetStatusText(hwndNTPifDlg,FocusIDNT,TRUE);
	    } else {
		if(tmpFocWnd == hwndFocusMain)
		    return(TRUE);
		hwndFocus = hwndFocusMain = tmpFocWnd;
		tmpFOCID = FocusIDMain;
		FocusID = FocusIDMain = GetDlgCtrlID(hwndFocusMain);
		if(tmpFOCID != FocusIDMain)
		    SetStatusText(hMainwnd,FocusIDMain,TRUE);
	    }
	    SendMessage(hwnd,WM_NEXTDLGCTL,(WPARAM)tmpFocWnd,1L);
	    SetFocus(tmpFocWnd);
	    return(TRUE);
	} else if (rc2.top < rc.top) {
	    tmpFocWnd = GetNextDlgTabItem(hwnd,tmpFocWnd,0);
	} else {
	    tmpFocWnd = GetNextDlgTabItem(hwnd,tmpFocWnd,1);
	}
    }
    if(hwnd == hwndAdvPifDlg) {
	if(tmpFocWnd == hwndFocusAdv)
	    return(TRUE);
	hwndFocus = hwndFocusAdv = tmpFocWnd;
	tmpFOCID = FocusIDAdv;
	FocusID = FocusIDAdv = GetDlgCtrlID(hwndFocusAdv);
	if(tmpFOCID != FocusIDAdv)
	    SetStatusText(hwndAdvPifDlg,FocusIDAdv,TRUE);
    } else if(hwnd == hwndNTPifDlg) {
	if(tmpFocWnd == hwndFocusNT)
	    return(TRUE);
	hwndFocus = hwndFocusNT = tmpFocWnd;
	tmpFOCID = FocusIDNT;
	FocusID = FocusIDNT = GetDlgCtrlID(hwndFocusNT);
	if(tmpFOCID != FocusIDNT)
	    SetStatusText(hwndNTPifDlg,FocusIDNT,TRUE);
    } else {
	if(tmpFocWnd == hwndFocusMain)
	    return(TRUE);
	hwndFocus = hwndFocusMain = tmpFocWnd;
	tmpFOCID = FocusIDMain;
	FocusID = FocusIDMain = GetDlgCtrlID(hwndFocusMain);
	if(tmpFOCID != FocusIDMain)
	    SetStatusText(hMainwnd,FocusIDMain,TRUE);
    }
    SendMessage(hwnd,WM_NEXTDLGCTL,(WPARAM)tmpFocWnd,1L);
    SetFocus(tmpFocWnd);
    return(TRUE);
}


MainScrollTrack(HWND hwnd,int cmd,int mindistance)
{
    int *ScrollLineSz;

    if(hwnd == hwndAdvPifDlg) {
	ScrollLineSz   = &AdvScrollLineSz;
    } else if(hwnd == hwndNTPifDlg) {
	ScrollLineSz   = &NTScrollLineSz;
    } else {
	ScrollLineSz   = &MainScrollLineSz;
    }

    if(mindistance <= *ScrollLineSz) {
	MainScroll(hwnd,cmd,0,0,0);
    } else {
	MainScroll(hwnd,cmd,0,
		       (mindistance + (2* *ScrollLineSz) - 1) / *ScrollLineSz,
		       0);
    }
    return(TRUE);
}

MainScroll(HWND hwnd, int cmd, int pos, int multiln, int callflag)
{

    int oldScrollPos;
    int newScrollPos;
    int *ScrollRange;
    int *ScrollLineSz;
    int *WndLines;
    int *MaxNeg;
    RECT rc2;

    if(hwnd == hwndAdvPifDlg) {
	 ScrollRange	= &AdvScrollRange;
	 ScrollLineSz	= &AdvScrollLineSz;
	 WndLines	= &AdvWndLines;
	 MaxNeg 	= &MaxAdvNeg;
    } else if(hwnd == hwndNTPifDlg) {
	 ScrollRange	= &NTScrollRange;
	 ScrollLineSz	= &NTScrollLineSz;
	 WndLines	= &NTWndLines;
	 MaxNeg 	= &MaxNTNeg;
    } else {
	 ScrollRange	= &MainScrollRange;
	 ScrollLineSz	= &MainScrollLineSz;
	 WndLines	= &MainWndLines;
	 MaxNeg 	= &MaxMainNeg;
    }

    newScrollPos = oldScrollPos = GetScrollPos(hwnd,SB_VERT);

    switch (cmd) {
	case SB_LINEUP:
	    if (oldScrollPos)
		if(multiln)
		    newScrollPos -= min(oldScrollPos,multiln);
		else
		    newScrollPos--;
	    break;

	case SB_LINEDOWN:
	    if (oldScrollPos < *ScrollRange)
		if(multiln)
		    newScrollPos += min((*ScrollRange -
					 oldScrollPos),multiln);
		else
		    newScrollPos++;
	    break;

	case SB_PAGEUP:
	    newScrollPos -= *WndLines;
	    if ( newScrollPos < 0)
		newScrollPos = 0;
	    break;

	case SB_PAGEDOWN:
	    newScrollPos += *WndLines;
	    if (newScrollPos > *ScrollRange)
		newScrollPos = *ScrollRange;
	    break;

	case SB_THUMBPOSITION:
	    SetScrollPos(hwnd, SB_VERT, pos, TRUE);
	    return(TRUE);

	case SB_THUMBTRACK:
	    newScrollPos = pos;
	    break;

        case SB_TOP:
	    if (!callflag && GetKeyState(VK_CONTROL) >= 0)
		return(TRUE); /* top of data must be Ctrl+Home */
	    newScrollPos = 0;
            break;

        case SB_BOTTOM:
	    if (!callflag && GetKeyState(VK_CONTROL) >= 0)
		return(TRUE); /* end of data must be Ctrl+End */
	    newScrollPos = *ScrollRange;
            break;
    }
    if (newScrollPos != oldScrollPos) {
	if (cmd != SB_THUMBTRACK)
	    SetScrollPos(hwnd, SB_VERT, newScrollPos, TRUE);
	newScrollPos = min((newScrollPos * *ScrollLineSz),*MaxNeg);
	oldScrollPos = min((oldScrollPos * *ScrollLineSz),*MaxNeg);
	GetClientRect(hwnd,(LPRECT)&rc2);
	if((hwnd == hwndAdvPifDlg) || (hwnd == hwndNTPifDlg)) {
	    ScrollWindow(hwnd,
			 0,
			 oldScrollPos-newScrollPos,
			 (CONST RECT *)NULL,
			 (CONST RECT *)NULL);
	    UpdateWindow(hwnd);
	    AdjustFocusCtrl(hwnd);
	} else {
	    SetWindowPos(hwndPifDlg,
			 (HWND)NULL,
			 0,
			 -newScrollPos,
			 rc2.right - rc2.left,
			 rc2.bottom - rc2.top + newScrollPos -
			   (StatusPntData.dyStatus + StatusPntData.dyBorderx2),
			 SWP_NOZORDER | SWP_NOACTIVATE);
	    UpdateWindow(hwndPifDlg);
	    AdjustFocusCtrl(hwndPifDlg);
	}
	InvalidateStatusBar(hwnd);
    }
    return(TRUE);
}


DoHkeyCaret(HWND hwnd)
{
    HDC     hdc;
    HFONT   hfont;
    SIZE    size;

    if(!(hdc = GetDC(hwnd))) {
	Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	return(FALSE);
    }
    if(HotKyFnt)
	hfont = (HFONT)SelectObject(hdc,(HGDIOBJ)HotKyFnt);
    GetTextExtentPoint(hdc,(LPSTR)CurrHotKeyTxt,CurrHotKeyTxtLen, &size);
    SetCaretPos(size.cx+4,1);
    if(HotKyFnt && hfont)
	SelectObject(hdc,(HGDIOBJ)hfont);
    ReleaseDC(hwnd,hdc);
    return(TRUE);
}


/*
 *
 * This is the Windows Proc for the private Hot Key Control in
 *    the WIN386 dialog box
 *
 */
long FAR PASCAL PifHotKyWndProc(HWND hwnd, UINT message, WPARAM wParam, LONG lParam)
{
    PAINTSTRUCT ps;
    HFONT	hfont;
    DWORD	txtcolor;

    switch (message) {

	case WM_SETFOCUS:
	    if(HotKyFntHgt)
		CreateCaret(hwnd,NULL,0,HotKyFntHgt);
	    else
		CreateCaret(hwnd,NULL,0,SysCharHeight);
	    DoHkeyCaret(hwnd);
	    ShowCaret(hwnd);
	    break;

	case WM_KILLFOCUS:
/*	      ChangeHotKey();	*/
	    DestroyCaret();
	    break;

	case WM_SYSKEYDOWN:
	case WM_KEYDOWN:
	    switch (wParam) {
		case VK_BACK:
		    if(GetKeyState(VK_SHIFT) & 0x8000) {
			InMemHotKeyScan = 0;
			InMemHotKeyShVal = 0;
			InMemHotKeyShMsk = 0;
			NewHotKey = TRUE;
			UndoAdvClose();
			CompleteKey = FALSE;
			EditHotKey = FALSE;
			if(!LoadString(hPifInstance,
				       NONE,
				       (LPSTR)CurrHotKeyTxt,
				       sizeof(CurrHotKeyTxt))) {
			    Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
			}
		    } else {
			CompleteKey = FALSE;
			EditHotKey = TRUE;
			NewHotKey = TRUE;
			CurrHotKeyTxt[0] = '\0';
		    }
		    SetHotKeyLen();
		    InvalidateRect(hwnd,(CONST RECT *)NULL,TRUE);
		    DoHkeyCaret(hwnd);
		    break;

		case VK_RETURN:
		    if(!(GetKeyState(VK_SHIFT) & 0x8000) &&
		       !(GetKeyState(VK_MENU) & 0x8000) &&
		       !(GetKeyState(VK_CONTROL) & 0x8000)) {
			PostMessage(hwndAdvPifDlg,WM_COMMAND,IDOK,0L);
		    } else {
			CompleteKey = FALSE;
			EditHotKey = FALSE;
			NewHotKey = FALSE;
			SetHotKeyTextFromInMem();
			DoHkeyCaret(hwnd);
			return(DefWindowProc(hwnd, message, wParam, lParam));
		    }
		    break;

		case VK_TAB:
		    if(GetKeyState(VK_MENU) & 0x8000) {
			CompleteKey = FALSE;
			EditHotKey = FALSE;
			NewHotKey = FALSE;
			SetHotKeyTextFromInMem();
			DoHkeyCaret(hwnd);
		    } else {
			ChangeHotKey();
			DoHkeyCaret(hwnd);
		    }
		    return(DefWindowProc(hwnd, message, wParam, lParam));
		    break;

		case VK_CONTROL:	/* Add modifier */
		case VK_MENU:
		    if(!EditHotKey) {
StartHotKey:
			CompleteKey = FALSE;
			EditHotKey = TRUE;
			CurrHotKeyTxt[0] = '\0';
			SetHotKeyLen();
		    }
SetHotKey:
		    SetHotKeyState(wParam,lParam);
		    InvalidateRect(hwnd,(CONST RECT *)NULL,TRUE);
		    DoHkeyCaret(hwnd);
		    UndoAdvClose();
		    break;

		case VK_SHIFT:
		    if(EditHotKey && !CompleteKey && (CurrHotKeyTxtLen != 0))
			goto SetHotKey;
		    break;

		case VK_ESCAPE:
		    if((GetKeyState(VK_MENU) & 0x8000) ||
		       (GetKeyState(VK_CONTROL) & 0x8000)) {
			CompleteKey = FALSE;
			EditHotKey = FALSE;
			NewHotKey = FALSE;
			SetHotKeyTextFromInMem();
			DoHkeyCaret(hwnd);
			return(DefWindowProc(hwnd, message, wParam, lParam));
		    } else {
			if(GetKeyState(VK_SHIFT) & 0x8000)
			    MessageBeep(0);
			else {
			    CompleteKey = FALSE;
			    EditHotKey = FALSE;
			    NewHotKey = FALSE;
			    PostMessage(hwndAdvPifDlg,WM_COMMAND,IDCANCEL,0L);
			}
		    }
		    break;

		case VK_SPACE:
		case VK_MULTIPLY:
		    CompleteKey = FALSE;
		    EditHotKey = FALSE;
		    NewHotKey = FALSE;
		    SetHotKeyTextFromInMem();
		    DoHkeyCaret(hwnd);
		    return(DefWindowProc(hwnd, message, wParam, lParam));
		    break;

		default:		/* Set Key */
		    if(!EditHotKey || CompleteKey)
			goto StartHotKey;
		    goto SetHotKey;
		    break;
	    }
	    break;

	case WM_SYSCHAR:
	case WM_CHAR:
	case WM_SYSKEYUP:
	case WM_KEYUP:
	    switch (wParam) {
		case VK_SPACE:
		case VK_MULTIPLY:
		case VK_RETURN:
		case VK_ESCAPE:
		case VK_TAB:
		    return(DefWindowProc(hwnd, message, wParam, lParam));
		    break;

		default:
		    break;
	    }
	    break;

	case WM_LBUTTONDOWN:
	    SetFocus(hwnd);
	    break;

	case WM_CREATE:
	    hwndPrivControl = hwnd;
	    SetHotKeyTextFromPIF();
	    break;

	case WM_PAINT:
	    if(!BeginPaint(hwnd, (LPPAINTSTRUCT)&ps)) {
		Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
		break;
	    }
	    if(HotKyFnt)
		hfont = (HFONT)SelectObject(ps.hdc,(HGDIOBJ)HotKyFnt);
	    txtcolor = GetSysColor(COLOR_WINDOWTEXT);
	    SetTextColor(ps.hdc,txtcolor);
	    txtcolor = GetSysColor(COLOR_WINDOW);
	    SetBkColor(ps.hdc,txtcolor);
	    TextOut(ps.hdc, 4, 1, (LPSTR)CurrHotKeyTxt, sizeof(CurrHotKeyTxt));
	    if(HotKyFnt && hfont)
		SelectObject(ps.hdc,(HGDIOBJ)hfont);
	    EndPaint(hwnd, (CONST PAINTSTRUCT *)&ps);
	    break;

	case WM_DESTROY:
	    hwndPrivControl = (HWND)NULL;
	default:
	    return(DefWindowProc(hwnd, message, wParam, lParam));
    }
    return(TRUE);
}


SetHotKeyState(WPARAM keyid,LONG lParam)
{
    unsigned char *cptr;
    BOOL	  FirstEl = FALSE;

    cptr = CurrHotKeyTxt;

    if(lParam & 0x01000000L)
	TmpHotKeyVal = 1;
    else
	TmpHotKeyVal = 0;

    if(GetKeyState(VK_MENU) & 0x8000) {
	cptr += GetKeyNameText(ALTLPARAM,(LPSTR)cptr,
				      sizeof(CurrHotKeyTxt)-(cptr-CurrHotKeyTxt));
	FirstEl = TRUE;
	TmpHotKeyShVal |= 0x0008;
    } else {
	TmpHotKeyShVal &= ~0x0008;
    }
    if(GetKeyState(VK_CONTROL) & 0x8000) {
	if(FirstEl) {
	    *cptr++ = KeySepChr;
	} else {
	    FirstEl = TRUE;
	}
	cptr += GetKeyNameText(CTRLLPARAM,(LPSTR)cptr,
				      sizeof(CurrHotKeyTxt)-(cptr-CurrHotKeyTxt));
	TmpHotKeyShVal |= 0x0004;
    } else {
	TmpHotKeyShVal &= ~0x0004;
    }
    if(GetKeyState(VK_SHIFT) & 0x8000) {
	if(FirstEl) {
	    *cptr++ = KeySepChr;
	} else {
	    FirstEl = TRUE;
	}
	cptr += GetKeyNameText(SHIFTLPARAM,(LPSTR)cptr,
				      sizeof(CurrHotKeyTxt)-(cptr-CurrHotKeyTxt));
	TmpHotKeyShVal |= 0x0003;
    } else {
	TmpHotKeyShVal &= ~0x0003;
    }

    if((keyid != VK_MENU) && (keyid != VK_SHIFT) && (keyid != VK_CONTROL)) {
	if(FirstEl) {
	    *cptr++ = KeySepChr;
	} else {
	    FirstEl = TRUE;
	}

	if((GetKeyNameText(lParam,(LPSTR)cptr,
				     sizeof(CurrHotKeyTxt)-(cptr-CurrHotKeyTxt)))
	     && (TmpHotKeyShVal & 0x000C)) {
	    TmpHotKeyScan = HIWORD(lParam) & 0x00FF;
            CompleteKey = TRUE;
	}
    }

    SetHotKeyLen();
    return(TRUE);
}


ChangeHotKey()
{

    if(!ChangeHkey) {
	ChangeHkey = TRUE;
	if(EditHotKey) {
	    if(CompleteKey) {
		InMemHotKeyScan = TmpHotKeyScan;
		InMemHotKeyShVal = TmpHotKeyShVal;
		InMemHotKeyShMsk = TmpHotKeyShMsk;
		InMemHotKeyVal = TmpHotKeyVal;
		NewHotKey = TRUE;
	    } else if (CurrHotKeyTxtLen == 0) {
		SetHotKeyTextFromPIF();
		NewHotKey = FALSE;
	    } else {
                Warning(BADHK,MB_ICONEXCLAMATION | MB_OK);
		SetHotKeyTextFromPIF();
		NewHotKey = FALSE;
	    }
	    EditHotKey = FALSE;
	    CompleteKey = FALSE;
	}
	ChangeHkey = FALSE;
    }
    return(TRUE);
}

BOOL UpdateHotKeyStruc(void)
{
    ChangeHotKey();
    if(((UINT)Pif386ext->PfHotKeyScan != InMemHotKeyScan) ||
       ((UINT)Pif386ext->PfHotKeyShVal != InMemHotKeyShVal) ||
       ((UINT)Pif386ext->PfHotKeyShMsk != InMemHotKeyShMsk) ||
       (Pif386ext->PfHotKeyVal != InMemHotKeyVal)) {

	Pif386ext->PfHotKeyScan  = InMemHotKeyScan;
	Pif386ext->PfHotKeyShVal = InMemHotKeyShVal;
	Pif386ext->PfHotKeyShMsk = InMemHotKeyShMsk;
	Pif386ext->PfHotKeyVal	 = InMemHotKeyVal;
	return(TRUE);
    } else {
	return(FALSE);
    }
}


SetHotKeyTextFromInMem(void)
{
    unsigned char *cptr;
    BOOL	  FirstEl = FALSE;

    cptr = CurrHotKeyTxt;

    if((InMemHotKeyScan == 0) &&
       (InMemHotKeyShVal == 0) &&
       (InMemHotKeyShMsk == 0)) {
	if(!LoadString(hPifInstance, NONE, (LPSTR)CurrHotKeyTxt, sizeof(CurrHotKeyTxt))) {
	    Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	}
    } else {
	if(InMemHotKeyShVal & 0x0008) {
	    cptr += GetKeyNameText(ALTLPARAM,(LPSTR)cptr
					     ,sizeof(CurrHotKeyTxt)-(cptr-CurrHotKeyTxt));
            FirstEl = TRUE;
        }
	if(InMemHotKeyShVal & 0x0004) {
            if(FirstEl) {
		*cptr++ = KeySepChr;
            } else {
                FirstEl = TRUE;
            }
	    cptr += GetKeyNameText(CTRLLPARAM,(LPSTR)cptr
					     ,sizeof(CurrHotKeyTxt)-(cptr-CurrHotKeyTxt));
        }
	if(InMemHotKeyShVal & 0x0003) {
            if(FirstEl) {
		*cptr++ = KeySepChr;
            } else {
                FirstEl = TRUE;
            }
	    cptr += GetKeyNameText(SHIFTLPARAM,(LPSTR)cptr
					     ,sizeof(CurrHotKeyTxt)-(cptr-CurrHotKeyTxt));
        }
        if(FirstEl) {
	    *cptr++ = KeySepChr;
        } else {
            FirstEl = TRUE;
        }

	if(GetKeyNameText(InMemHotKeyVal ? ((DWORD)InMemHotKeyScan << 16L | 0x01000000L) : ((DWORD)InMemHotKeyScan << 16L),
			   (LPSTR)cptr,
			   sizeof(CurrHotKeyTxt)-(cptr-CurrHotKeyTxt)) == 0 ||
	    (!(InMemHotKeyShVal & 0x000C)) ||
	    (InMemHotKeyShMsk != 0x000F)) {

	    if(CurrMode386 && hwndAdvPifDlg)
                Warning(BADHK,MB_ICONEXCLAMATION | MB_OK);
	    InMemHotKeyScan = 0;
	    InMemHotKeyShVal = 0;
	    InMemHotKeyShMsk = 0;
	    InMemHotKeyVal = 0;
	    if(!LoadString(hPifInstance, NONE, (LPSTR)CurrHotKeyTxt, sizeof(CurrHotKeyTxt))) {
		Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	    }

        }
    }
    SetHotKeyLen();
    if(CurrMode386 && hwndAdvPifDlg)
	InvalidateRect(GetDlgItem(hwndAdvPifDlg, IDI_HOTKEY),
                       (CONST RECT *)NULL,
                       TRUE);
    return(TRUE);
}


SetHotKeyTextFromPIF()
{
    if(!Pif386ext)
	return(FALSE);
    InMemHotKeyScan  = Pif386ext->PfHotKeyScan;
    InMemHotKeyShVal = Pif386ext->PfHotKeyShVal;
    InMemHotKeyShMsk = Pif386ext->PfHotKeyShMsk;
    InMemHotKeyVal   = Pif386ext->PfHotKeyVal;
    SetHotKeyTextFromInMem();
    return(TRUE);
}

SetHotKeyLen()
{
    int i;
    BOOL dospc;

    for(dospc = FALSE, i = 0; i < sizeof(CurrHotKeyTxt); i++) {
	if(dospc) {
	    CurrHotKeyTxt[i] = ' ';
	} else {
	    if(!CurrHotKeyTxt[i]){
		CurrHotKeyTxt[i] = ' ';
		CurrHotKeyTxtLen = i;
		dospc = TRUE;
	    }
	}
    }
    return(TRUE);
}

Disable386Advanced(HWND hAdvwnd, HWND hNTwnd)
{

    if(hAdvwnd) {
	if(CurrMode386) {
	    if(UpdatePif386Struc())
		FileChanged = TRUE;
	    if(UpdatePifNTStruc())
		FileChanged = TRUE;
	}
	if(!DoFieldsWorkAdv(FALSE))
	    return(FALSE);
	if(!DoFieldsWorkNT(FALSE))
	    return(FALSE);
	SendMessage(hNTwnd,WM_PRIVCLOSEOK,0,0L);
    }
    ModeAdvanced = FALSE;
    ReEnableAdvButton();
    return(TRUE);
}

/*
 * routine added so that pifedit can hack in normal menu functionality.
 * Want Alt+Mnemonic to work like normal windows, even though pifedit is
 * really a dialog box.  Look for Alt+Mnemonic before letting message go
 * to the dialog manager.
 * 08-Jun-1987. davidhab.
 */
BOOL PifMenuMnemonic(LPMSG lpmsg)
{
    unsigned char chMenu;
    HWND	  hwAct;

    if (lpmsg->message == WM_SYSCHAR && GetActiveWindow() == hMainwnd) {
	chMenu = (unsigned char)AnsiUpper((LPSTR)(DWORD)(unsigned char)lpmsg->wParam);
	if ((chMenu == MenuMnemonic1) || (chMenu == MenuMnemonic2) ||
	    (chMenu == MenuMnemonic3)) {
	    DefWindowProc(hwndPifDlg, lpmsg->message, lpmsg->wParam, lpmsg->lParam);
            return(TRUE);
        }
    /*
     *
     * The following allows keyboard access to the main window scroll bar
     *
     */
    } else if ((lpmsg->message == WM_KEYDOWN) &&
	       (((hwAct = GetActiveWindow()) == hMainwnd) ||
		(hwndAdvPifDlg && (hwAct == hwndAdvPifDlg)))) {
	switch (lpmsg->wParam) {
	    case VK_HOME:
		PostMessage(hwAct, WM_VSCROLL, SB_TOP, 0L);
		break;

	    case VK_END:
		PostMessage(hwAct, WM_VSCROLL, SB_BOTTOM, 0L);
		break;

	    case VK_NEXT:
		PostMessage(hwAct, WM_VSCROLL, SB_PAGEDOWN, 0L);
		break;

	    case VK_PRIOR:
		PostMessage(hwAct, WM_VSCROLL, SB_PAGEUP, 0L);
		break;

	    default:
		break;
	}
	return(FALSE);
    }
    return(FALSE);
}


FilterPrivateMsg(HWND hwnd, unsigned message, WPARAM wParam, LONG lParam)
{
    switch (message) {
	case WM_KEYDOWN:
	case WM_CHAR:
	case WM_KEYUP:
	case WM_SYSKEYDOWN:
	case WM_SYSCHAR:
	case WM_SYSKEYUP:
	    switch (wParam) {
		case VK_TAB:
		    return(TRUE);

		case VK_SPACE:
		case VK_RETURN:
		case VK_ESCAPE:
		case VK_MULTIPLY:
		    if(GetKeyState(VK_MENU) & 0x8000)
			return(TRUE);
		    else
			return(FALSE);

		default:
		    return(FALSE);
	    }
	    break;

	default:
	    return(TRUE);
    }
}


BOOL InitPifStuff(HINSTANCE hPrevInstance)
{
    unsigned char buf[20];
    PWNDCLASS	  pClass;
    HDC 	  hIC;
    HFONT	  hfont;
    TEXTMETRIC	  Metrics;
    HANDLE	  mhand;
    HDC 	  hdcScreen;
    char	  szHelv[] = "MS Sans Serif";  // don't use Helv, mapping problems
    TEXTMETRIC	  tm;
    int 	  dxText;

    if (lpfnRegisterPenApp = (LPFNREGISTERPENAPP)GetProcAddress((HMODULE)(GetSystemMetrics(SM_PENWINDOWS)), "RegisterPenApp")) {
        (*lpfnRegisterPenApp)((WORD)1, TRUE); /* be Pen-Enhanced */
    }

    if (!hPrevInstance) {

	StatusPntData.dyBorder = GetSystemMetrics(SM_CYBORDER);
	StatusPntData.dyBorderx2 = StatusPntData.dyBorder * 2;
	StatusPntData.dyBorderx3 = StatusPntData.dyBorder * 3;

	if(!(hdcScreen = GetDC(NULL)))
	    goto NoMem;

	StatusPntData.Fntheight = MulDiv(-10, GetDeviceCaps(hdcScreen, LOGPIXELSY), 72);

	dxText = LOWORD(GetTextExtent(hdcScreen, "M", 1));

	if(!(StatusPntData.hFontStatus = (HGDIOBJ)CreateFont(StatusPntData.Fntheight, 0, 0, 0, 400, 0, 0, 0,
	      ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
	      DEFAULT_QUALITY, VARIABLE_PITCH | FF_SWISS, (LPCTSTR)szHelv)))
	    goto NoMem;
	mhand = SelectObject(hdcScreen, StatusPntData.hFontStatus);

	GetTextMetrics(hdcScreen, &tm);

	SelectObject(hdcScreen, mhand);
	StatusPntData.dyStatus = tm.tmHeight + tm.tmExternalLeading + 7 * StatusPntData.dyBorder;
	ReleaseDC(NULL, hdcScreen);

    } else {
	if(!GetInstanceData(hPrevInstance,(NPSTR)&StatusPntData,sizeof(StatusPntData))) {
	    StatusPntData.hFontStatus = (HGDIOBJ)NULL;
	    goto NoMem;
	}
	if(!(StatusPntData.hFontStatus = (HGDIOBJ)CreateFont(StatusPntData.Fntheight, 0, 0, 0, 400, 0, 0, 0,
	      ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
	      DEFAULT_QUALITY, VARIABLE_PITCH | FF_SWISS, szHelv)))
	    goto NoMem;
    }

    if(!(lpfnPifWnd =  MakeProcInstance(PifWndProc, hPifInstance))) {
NoMem:
	Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	return(FALSE);
    }

    if(!(lpfnAdvPifWnd =  MakeProcInstance(PifAdvWndProc, hPifInstance)))
	goto NoMem;

    if(!(lpfnNTPifWnd =  MakeProcInstance(PifNTWndProc, hPifInstance)))
	goto NoMem;

    if(!LoadString(hPifInstance, errTitle, (LPSTR)rgchTitle, sizeof(rgchTitle)))
	goto NoMem;

    if(!(hAccel = LoadAccelerators(hPifInstance, (LPSTR)"pifaccels")))
	goto NoMem;

    if(!LoadString(hPifInstance, MENUMNEMONIC1, (LPSTR)buf, sizeof(buf)))
	goto NoMem;
    MenuMnemonic1 = buf[0];

    if(!LoadString(hPifInstance, MENUMNEMONIC2, (LPSTR)buf, sizeof(buf)))
	goto NoMem;
    MenuMnemonic2 = buf[0];

    if(!LoadString(hPifInstance, MENUMNEMONIC3, (LPSTR)buf, sizeof(buf)))
	goto NoMem;
    MenuMnemonic3 = buf[0];

    if(!LoadString(hPifInstance, KEYSEPCHAR, (LPSTR)buf, sizeof(buf)))
	goto NoMem;
    KeySepChr = buf[0];

    if(!(hArrowCurs = LoadCursor((HANDLE)NULL,(LPSTR)IDC_ARROW)))
	goto NoMem;
    if(!(hWaitCurs = LoadCursor((HANDLE)NULL,(LPSTR)IDC_WAIT)))
	goto NoMem;

    bMouse = GetSystemMetrics(SM_MOUSEPRESENT);
    hIC = CreateIC((LPSTR)"DISPLAY", (LPSTR)NULL, (LPSTR)NULL, (LPDEVMODE)NULL);
    if (!hIC)
	return(FALSE);
    /* Setup the fonts */
    GetTextMetrics(hIC, (LPTEXTMETRIC)(&Metrics));  /* find out what kind of font it really is */
    SysCharHeight = Metrics.tmHeight;		    /* the height */
    SysCharWidth = Metrics.tmAveCharWidth;	    /* the average width */

    SysFixedFont = (HFONT)GetStockObject(SYSTEM_FIXED_FONT);
    SelectObject(hIC,(HGDIOBJ)SysFixedFont);
    GetTextMetrics(hIC, (LPTEXTMETRIC)(&Metrics));
    SysFixedHeight = Metrics.tmHeight;
    SysFixedWidth = Metrics.tmAveCharWidth;
    if(Metrics.tmPitchAndFamily & 1) {
	SysFixedFont = (HFONT)GetStockObject(ANSI_FIXED_FONT);
	SelectObject(hIC,(HGDIOBJ)SysFixedFont);
	GetTextMetrics(hIC, (LPTEXTMETRIC)(&Metrics));	 /* find out what kind of font it really is */
	SysFixedHeight = Metrics.tmHeight;		 /* the height */
	SysFixedWidth = Metrics.tmAveCharWidth; 	 /* the average width */
    }

    HotKyFnt = CreateFont(8,				/* lfHeight	*/
			  0,				/* lfWidth	*/
			  0,				/* lfEscapement */
			  0,				/* lfOrientation*/
			  FW_BOLD,			/* lfWeight	*/
			  FALSE,			/* lfItalic	*/
			  FALSE,			/* lfUnderline	*/
			  FALSE,			/* lfStrikeout	*/
			  ANSI_CHARSET, 		/* lfCharset	*/
			  OUT_DEFAULT_PRECIS,		/* lfOutPrec	*/
			  OUT_DEFAULT_PRECIS,		/* lfClipPrec	*/
			  DEFAULT_QUALITY,		/* lfQuality	*/
			  VARIABLE_PITCH | FF_SWISS,	/* lfPitchAndFam*/
			  (LPSTR)"MS Sans Serif");	/* lfFacename	*/

    if(HotKyFnt) {
	if((hfont = (HFONT)SelectObject(hIC,(HGDIOBJ)HotKyFnt))) {
	    if(GetTextMetrics(hIC, (LPTEXTMETRIC)(&Metrics))) {
		HotKyFntHgt = Metrics.tmHeight;
	    }
	    SelectObject(hIC,(HGDIOBJ)hfont);
	}
    }
    DeleteDC(hIC);

    /* only register classes if first instance. 23-Oct-1987. davidhab. */
    if (!hPrevInstance) {
	if(!(pClass = (PWNDCLASS)LocalAlloc(LPTR, sizeof(WNDCLASS))))
	    goto NoMem;

	pClass->hCursor       = LoadCursor(NULL, IDC_ARROW);
	pClass->hIcon	      = LoadIcon(hPifInstance, MAKEINTRESOURCE(ID_PIFICON));
	pClass->lpszMenuName  = MAKEINTRESOURCE(ID_PIFMENU);
	pClass->hInstance     = hPifInstance;
	pClass->lpszClassName = (LPSTR)"Pif";
	pClass->hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
	pClass->lpfnWndProc   = PifMainWndProc;
	pClass->style	      = CS_BYTEALIGNCLIENT;
	if (!RegisterClass((CONST WNDCLASS *)pClass))
	    return(FALSE);
	LocalFree((HANDLE)pClass);

	if(!(pClass = (PWNDCLASS)LocalAlloc(LPTR, sizeof(WNDCLASS))))
	    goto NoMem;

	pClass->hCursor       = LoadCursor(NULL, IDC_ARROW);
	pClass->hIcon	      = (HICON)NULL;
	pClass->hInstance     = hPifInstance;
	pClass->lpszClassName = (LPSTR)"PifHKy";
	pClass->hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
	pClass->lpfnWndProc   = PifHotKyWndProc;
	pClass->style	      = 0;
        if (!RegisterClass((CONST WNDCLASS *)pClass))
            return(FALSE);
        LocalFree((HANDLE)pClass);
    }
    return(TRUE);
}


int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCommandLine, int cmdShow)
{
    MSG 	  msg;
    BYTE	  *p;
    PSTR	  pchFileName;
    HWND	  hWndTmp;
    HWND	  hWndTmp2;
    HMENU	  hMenu;
    int 	  i;
    unsigned char buf[160];
    POINT	  cTLpt;
    POINT	  cLRpt;
    RECT	  rc1;
    RECT	  rc2;
    int 	  tmpFOCID;

    PifFile = (PIFNEWSTRUCT *)PifBuf;

    if(!LoadString(hPifInstance, EINSMEMORY, (LPSTR)rgchInsMem, sizeof(rgchInsMem))) {
	return(FALSE);
    }
    if(!LoadString(hPifInstance, NTSYSTEMROOT, (LPSTR)NTSys32Root, PIFDEFPATHSIZE-1)) {
	Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	return(FALSE);
    }

    if(!LoadString(hPifInstance, NTSYSTEM32, (LPSTR)buf, PIFDEFPATHSIZE-1)) {
	Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	return(FALSE);
    }
    lstrcat(NTSys32Root, buf);

    hPifInstance = hInstance;

    if(!InitPifStuff(hPrevInstance)) {
	if (lpfnRegisterPenApp)
	   (*lpfnRegisterPenApp)((WORD)1, FALSE);   /* deregister */
	return(FALSE);
    }

    if(!(i = LoadString(hPifInstance, PIFCAPTION, (LPSTR)buf, sizeof(buf)))) {
	Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	if (lpfnRegisterPenApp)
	   (*lpfnRegisterPenApp)((WORD)1, FALSE);   /* deregister */
	return(FALSE);
    }

    if(!LoadString(hPifInstance, NOTITLE, (LPSTR)(buf+i), (sizeof(buf)-i))) {
	Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	if (lpfnRegisterPenApp)
	   (*lpfnRegisterPenApp)((WORD)1, FALSE);   /* deregister */
	return(FALSE);
    }

    hParentWnd = hMainwnd = CreateWindow((LPSTR)"Pif",
				(LPSTR)buf,
				WS_OVERLAPPED | WS_THICKFRAME | WS_CAPTION |
				WS_SYSMENU | WS_MINIMIZEBOX | WS_VSCROLL |
				WS_MAXIMIZEBOX,
				SysCharWidth * 2,
				SysCharHeight * 3,
				0,
				0,
				(HWND)NULL,
				(HMENU)NULL,
				hPifInstance,
				(LPSTR)NULL);

    if(!hMainwnd) {
	Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	if (lpfnRegisterPenApp)
	   (*lpfnRegisterPenApp)((WORD)1, FALSE);   /* deregister */
	return(FALSE);
    }
    hSysMenuMain = GetSystemMenu(hMainwnd,FALSE);
    hMenu = GetMenu(hMainwnd);
    hFileMenu = GetSubMenu(hMenu,0);
    hModeMenu = GetSubMenu(hMenu,1);
    hHelpMenu = GetSubMenu(hMenu,2);

    CurrMode386 = SysMode386 = SetInitialMode();

    if(!InitPifStruct()){
	if (lpfnRegisterPenApp)
	   (*lpfnRegisterPenApp)((WORD)1, FALSE);   /* deregister */
	return(FALSE);
    }

    if(CurrMode386) {
	if(!EnableMode386(hMainwnd,FALSE)) {
	    if (lpfnRegisterPenApp)
	       (*lpfnRegisterPenApp)((WORD)1, FALSE);	/* deregister */
	    return(FALSE);
	}
    } else {
	if(!EnableMode286(hMainwnd,FALSE)) {
	    if (lpfnRegisterPenApp)
	       (*lpfnRegisterPenApp)((WORD)1, FALSE);	/* deregister */
	    return(FALSE);
	}
    }

    if(hMainwnd) {
	DragAcceptFiles(hMainwnd,TRUE);
    }
    if(hwndPifDlg) {
	DragAcceptFiles(hwndPifDlg,TRUE);
    }
    if(hwndAdvPifDlg) {
	DragAcceptFiles(hwndAdvPifDlg,TRUE);
    }
    if(hwndNTPifDlg) {
	DragAcceptFiles(hwndNTPifDlg,TRUE);
    }

    if (*lpszCommandLine) {
        if (pchFileName = (PSTR)LocalAlloc(LPTR, MAX_PATH)) {
            if (lstrlen(lpszCommandLine) > (MAX_PATH - 5))
                *(lpszCommandLine + (MAX_PATH - 5)) = 0;
            CpyCmdStr((LPSTR)pchFileName, lpszCommandLine);
	    CmdArgAddCorrectExtension(pchFileName);
	    LoadPifFile(pchFileName);
	    LocalFree((HANDLE)pchFileName);
	    SetMainTitle();
	} else {
	    Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	    if (lpfnRegisterPenApp)
	       (*lpfnRegisterPenApp)((WORD)1, FALSE);	/* deregister */
	    return(FALSE);
	}
    }

    UpdatePifScreen();
    UpdatePifStruct();

    PifFile->id = 0;			 /* compute check sum */
    p = (BYTE *)&PifFile->name[ 0 ];
    i = PIFSIZE;
    while (i--)
	PifFile->id += *p++;


    InitShWind = TRUE;
    ShowWindow(hwndPifDlg, SW_SHOWNORMAL);
    if(hwndAdvPifDlg)
	ShowWindow(hwndAdvPifDlg, cmdShow);
    if(hwndNTPifDlg)
	ShowWindow(hwndNTPifDlg, cmdShow);
    ShowWindow(hMainwnd, cmdShow);
    /*
     * The following HACK gets around a wierd problem where we end up with no
     * ICON when started minimized. It is believed that this is due to the
     * wierd stuff we do based on the InitShWind flag in WM_INITDIALOG.
     */
    if((cmdShow == SW_SHOWMINNOACTIVE) || (cmdShow == SW_SHOWMINIMIZED))
	InvalidateRect(hMainwnd, (CONST RECT *)NULL, TRUE);

    while (GetMessage((LPMSG)&msg, NULL, 0, 0)) {
	if (!TranslateAccelerator(hMainwnd, hAccel, (LPMSG)&msg)) {
	    if(hwndPrivControl == msg.hwnd) {
		if(!FilterPrivateMsg(msg.hwnd,msg.message,msg.wParam,msg.lParam)) {
		    TranslateMessage((CONST MSG *)&msg);
		    DispatchMessage((CONST MSG *)&msg);
		    goto CheckFocus;
		}
	    }
	    if(PifMenuMnemonic((LPMSG)&msg))
		goto CheckFocus;
	    if (!hwndPifDlg || !IsDialogMessage(hwndPifDlg, (LPMSG)&msg)) {
		if(hwndAdvPifDlg && IsDialogMessage(hwndAdvPifDlg, (LPMSG)&msg))
		    goto CheckFocus;
		if(hwndNTPifDlg && IsDialogMessage(hwndNTPifDlg, (LPMSG)&msg))
		    goto CheckFocus;
		TranslateMessage((CONST MSG *)&msg);
		DispatchMessage((CONST MSG *)&msg);
	    } else {		/* Dialog message for hwndPifDlg or hwndAdvPifDlg */
CheckFocus:
		if (hWndTmp = GetFocus()) {
		    if((((hWndTmp2 = GetParent(hWndTmp)) == hwndPifDlg) ||
		      (hWndTmp2 == hwndAdvPifDlg) || (hWndTmp2 == hwndNTPifDlg))
                      && (hWndTmp != hwndFocus)) {
			if((hWndTmp2 == hwndAdvPifDlg)
                           || (hWndTmp2 == hwndNTPifDlg))
			    hParentWnd = hWndTmp2;
			else
			    hParentWnd = hMainwnd;
			hwndFocus = hWndTmp;
			FocusID = GetDlgCtrlID(hWndTmp);
			if(hWndTmp2 == hwndPifDlg) {
			    hwndFocusMain = hwndFocus;
			    tmpFOCID	  = FocusIDMain;
			    FocusIDMain   = FocusID;
			    if(tmpFOCID != FocusIDMain)
				SetStatusText(hMainwnd,FocusIDMain,TRUE);
			} else if(hWndTmp2 == hwndAdvPifDlg) {
			    hwndFocusAdv = hwndFocus;
			    tmpFOCID = FocusIDAdv;
			    FocusIDAdv	 = FocusID;
			    if(tmpFOCID != FocusIDAdv)
				SetStatusText(hwndAdvPifDlg,FocusIDAdv,TRUE);
			} else {
			    hwndFocusNT = hwndFocus;
			    tmpFOCID = FocusIDNT;
			    FocusIDNT = FocusID;
			    if(tmpFOCID != FocusIDNT)
				SetStatusText(hwndNTPifDlg,FocusIDNT,TRUE);
			}
			/*
			 * Check to make sure this control is visible.
			 * If it isn't, scroll the window to make it
			 * visible.
			 *
			 */
			if((hWndTmp2 == hwndPifDlg) && MainScrollRange) {
			    GetClientRect(hMainwnd,(LPRECT)&rc1);
			    rc1.bottom -= (StatusPntData.dyStatus + StatusPntData.dyBorderx2);
			    cTLpt.x = rc1.left;
			    cTLpt.y = rc1.top;
			    cLRpt.x = rc1.right;
			    cLRpt.y = rc1.bottom;
			    ClientToScreen(hMainwnd,(LPPOINT)&cTLpt);
			    ClientToScreen(hMainwnd,(LPPOINT)&cLRpt);
			    GetWindowRect(hwndFocus,(LPRECT)&rc2);
			    if(rc2.top < cTLpt.y) {
				MainScrollTrack(hMainwnd,SB_LINEUP,
						cTLpt.y - rc2.top);
			    } else if(rc2.bottom > cLRpt.y) {
				MainScrollTrack(hMainwnd,SB_LINEDOWN,
						    rc2.bottom - cLRpt.y);
			    }
			} else if ((hWndTmp2 == hwndAdvPifDlg) && AdvScrollRange) {
			    GetClientRect(hwndAdvPifDlg,(LPRECT)&rc1);
			    rc1.bottom -= (StatusPntData.dyStatus + StatusPntData.dyBorderx2);
			    cTLpt.x = rc1.left;
			    cTLpt.y = rc1.top;
			    cLRpt.x = rc1.right;
			    cLRpt.y = rc1.bottom;
			    ClientToScreen(hwndAdvPifDlg,(LPPOINT)&cTLpt);
			    ClientToScreen(hwndAdvPifDlg,(LPPOINT)&cLRpt);
			    GetWindowRect(hwndFocus,(LPRECT)&rc2);
			    if(rc2.top < cTLpt.y) {
				MainScrollTrack(hwndAdvPifDlg,SB_LINEUP,
						cTLpt.y - rc2.top);
			    } else if(rc2.bottom > cLRpt.y) {
				MainScrollTrack(hwndAdvPifDlg,SB_LINEDOWN,
						    rc2.bottom - cLRpt.y);
			    }

			} else if((hWndTmp2 == hwndNTPifDlg) && NTScrollRange) {
			    GetClientRect(hwndNTPifDlg,(LPRECT)&rc1);
			    rc1.bottom -= (StatusPntData.dyStatus + StatusPntData.dyBorderx2);
			    cTLpt.x = rc1.left;
			    cTLpt.y = rc1.top;
			    cLRpt.x = rc1.right;
			    cLRpt.y = rc1.bottom;
			    ClientToScreen(hwndNTPifDlg,(LPPOINT)&cTLpt);
			    ClientToScreen(hwndNTPifDlg,(LPPOINT)&cLRpt);
			    GetWindowRect(hwndFocus,(LPRECT)&rc2);
			    if(rc2.top < cTLpt.y) {
				MainScrollTrack(hwndNTPifDlg,SB_LINEUP,
						cTLpt.y - rc2.top);
			    } else if(rc2.bottom > cLRpt.y) {
				MainScrollTrack(hwndNTPifDlg,SB_LINEDOWN,
						    rc2.bottom - cLRpt.y);
			    }

			}
		    }
		}
	    }
	}
    }
    if (lpfnRegisterPenApp)
       (*lpfnRegisterPenApp)((WORD)1, FALSE);	/* deregister */
    return(0);
}


unsigned char *PutUpDB(int idb)
{
    OPENFILENAME OpnStruc;
    BOOL MsgFlagSav;
    unsigned char *pResultBuf = NULL;
    char filespec[160];
    char specbuf[80];
    int i,j;
    char extspec[] = "PIF";
    char chbuf[100];
    HICON hIcon;


    if(!(i = LoadString(hPifInstance, errFlTypePIF, (LPSTR)filespec, sizeof(specbuf)))) {
	Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	return((unsigned char *)NULL);
    }
    if(!(j = LoadString(hPifInstance,errFlTypeAll , (LPSTR)specbuf, sizeof(specbuf)))) {
	Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	return((unsigned char *)NULL);
    }
    i++;		/* point to char after NUL at end of errFlTypePIF */
    lstrcpy((LPSTR)&filespec[i],(LPSTR)"*.PIF");
    i += 6;		/* point to char after NUL at end of *.PIF */
    lstrcpy((LPSTR)&filespec[i],(LPSTR)specbuf);
    i += j + 1; 	/* point to char after NUL at end of errFlTypeAll */
    lstrcpy((LPSTR)&filespec[i],(LPSTR)"*.*");
    i += 4;		/* point to char after NUL at end of *.* */
    filespec[i] = '\0'; /* double nul terminate */


    if((idb == DTOPEN) || (idb == DTSAVE)) {
	if(!(pResultBuf = (unsigned char *)LocalAlloc(LPTR, 132))) {
	    Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	    return((unsigned char *)NULL);
	}
	lstrcpy((LPSTR)pResultBuf, (LPSTR)CurPifFile);
	OpnStruc.lStructSize = (unsigned long)(sizeof(OpnStruc));
	OpnStruc.hwndOwner = hMainwnd;
	OpnStruc.hInstance = 0;
	OpnStruc.lpstrFilter = (LPSTR)filespec;
	OpnStruc.lpstrCustomFilter = (LPSTR)NULL;
	OpnStruc.nMaxCustFilter = (DWORD)NULL;
	OpnStruc.nFilterIndex = 1;
	OpnStruc.lpstrFile = (LPSTR)pResultBuf;
	OpnStruc.nMaxFile = 132;
	/*
	 * We should use the next cookie to set our title BUT we still
	 *   have to deal with file names we get from command line
	 *   argument and drag drop.
	 */
	OpnStruc.lpstrFileTitle = (LPSTR)NULL;
	OpnStruc.nMaxFileTitle = 0;
	OpnStruc.lpstrInitialDir = (LPSTR)NULL;
	OpnStruc.lpstrTitle = (LPSTR)NULL;
	OpnStruc.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;
	OpnStruc.nFileOffset = 0;
	OpnStruc.nFileExtension = 0;
	OpnStruc.lpstrDefExt = (LPSTR)extspec;
	OpnStruc.lCustData = 0;
	OpnStruc.lpfnHook = (LPOFNHOOKPROC)NULL;
	OpnStruc.lpTemplateName = (LPSTR)NULL;
    } else if(idb == DTABOUT) {
	if(!LoadString(hPifInstance, errTitle, (LPSTR)chbuf, sizeof(chbuf))) {
	    Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	    return(pResultBuf);
	}
	hIcon = LoadIcon(hPifInstance, MAKEINTRESOURCE(ID_PIFICON));
    }

    /*
     * These dialogs always come up via menu selections in the main window
     *	menu. The parent is therefore always hMainwnd
     */
    switch(idb) {

	case DTOPEN:
	    MsgFlagSav = DoingMsg;
	    DoingMsg = TRUE;
	    if(MsgFlagSav != DoingMsg)
		InvalidateAllStatus();
	    if(!(GetOpenFileName((LPOPENFILENAME)&OpnStruc))){
		if(pResultBuf)
		    LocalFree((HANDLE)pResultBuf);
		pResultBuf = (unsigned char *)NULL;
	    } else {
		tmpfileoffset = OpnStruc.nFileOffset;
		tmpextoffset = OpnStruc.nFileExtension;
	    }
	    if(MsgFlagSav != DoingMsg) {
		DoingMsg = MsgFlagSav;
		InvalidateAllStatus();
	    } else {
		DoingMsg = MsgFlagSav;
	    }
	    break;

	case DTSAVE:
	    MsgFlagSav = DoingMsg;
	    DoingMsg = TRUE;
	    if(MsgFlagSav != DoingMsg)
		InvalidateAllStatus();
	    if(!(GetSaveFileName((LPOPENFILENAME)&OpnStruc))){
		if(pResultBuf)
		    LocalFree((HANDLE)pResultBuf);
		pResultBuf = (unsigned char *)NULL;
	    } else {
		tmpfileoffset = OpnStruc.nFileOffset;
		tmpextoffset = OpnStruc.nFileExtension;
	    }
	    if(MsgFlagSav != DoingMsg) {
		DoingMsg = MsgFlagSav;
		InvalidateAllStatus();
	    } else {
		DoingMsg = MsgFlagSav;
	    }
	    break;

	case DTABOUT:
	    MsgFlagSav = DoingMsg;
	    DoingMsg = TRUE;
	    if(MsgFlagSav != DoingMsg)
		InvalidateAllStatus();
	    ShellAbout(hMainwnd, (LPSTR)chbuf, (LPSTR)NULL, hIcon);
	    pResultBuf = (unsigned char *)NULL;
	    if(MsgFlagSav != DoingMsg) {
		DoingMsg = MsgFlagSav;
		InvalidateAllStatus();
	    } else {
		DoingMsg = MsgFlagSav;
	    }
	    break;
    }
    return(pResultBuf);
}


/* ** return TRUE iff 0 terminated string contains a '*' or '\' */
BOOL	FSearchSpec(unsigned char *sz)
{
    for (; *sz;sz=AnsiNext(sz)) {
	if (*sz == '*' || *sz == '?')
	    return TRUE;
    }
    return FALSE;
}


CheckOkEnable(HWND hwnd, unsigned message)
{
    if (message == EN_CHANGE)
	EnableWindow(GetDlgItem(hwnd, IDOK),
		     (BOOL)(SendMessage(GetDlgItem(hwnd, ID_EDIT),
					WM_GETTEXTLENGTH, 0, 0L)));
    return(TRUE);
}

/* ** Given filename or partial filename or search spec or partial
      search spec, add appropriate extension. */
CmdArgAddCorrectExtension(unsigned char *szEdit)
{
    register unsigned char    *pchLast;
    register unsigned char    *pchT;
    int 		      ichExt;
    BOOL		      fDone = FALSE;
    int 		      cchEdit;

    pchT = pchLast = (unsigned char *)AnsiPrev((LPSTR)szEdit, (LPSTR)(szEdit + (cchEdit = lstrlen((LPSTR)szEdit))));

    if ((*pchLast == '.' && *(AnsiPrev((LPSTR)szEdit, (LPSTR)pchLast)) == '.') && cchEdit == 2)
	ichExt = 0;
    else if (*pchLast == '\\' || *pchLast == ':')
	ichExt = 1;
    else {
	ichExt = 2;
	for (; pchT > szEdit; pchT = (unsigned char *)AnsiPrev((LPSTR)szEdit, (LPSTR)pchT)) {
	    /* If we're not searching and we encounter a period, don't add
	       any extension.  If we are searching, period is assumed to be
	       part of directory name, so go ahead and add extension. However,
	       if we are searching and find a search spec, do not add any
	       extension. */
	    if (*pchT == '.') {
		return(TRUE);
	    }
	    /* Quit when we get to beginning of last node. */
	    if (*pchT == '\\')
		break;
	}
    }
    lstrcpy((LPSTR)(pchLast+1), (LPSTR)(szExtSave+ichExt));
    return(TRUE);
}

DoHelp(unsigned int hindx,unsigned int IDIndx)
{
    BOOL retval;
    unsigned int *aliasptr;
    int i;

    if(hindx == 0)
	hindx = (unsigned int)FocusID;

    if(IDIndx == 0) {
	if(CurrMode386) {
	    if(ModeAdvanced) {
  		IDIndx = IDXID_386AHELP;
	    } else {
		IDIndx = IDXID_386HELP;
	    }
	} else {
	    IDIndx = IDXID_286HELP;
	}
    }

    if(hindx == M_HELPHELP) {
	retval = WinHelp(hMainwnd,(LPSTR)NULL,HELP_HELPONHELP,(DWORD)0);
    } else if(hindx == M_SHELP) {
	retval = WinHelp(hMainwnd,(LPSTR)PIFHELPFILENAME,HELP_PARTIALKEY,(DWORD)(LPSTR)"");
    } else if((hindx == IDXID_386AHELP) || (hindx == IDXID_386HELP) ||
	      (hindx == IDXID_286HELP)) {
	WinHelp(hMainwnd,(LPSTR)PIFHELPFILENAME,HELP_CONTEXT,(DWORD)IDIndx);
	retval = WinHelp(hMainwnd,(LPSTR)PIFHELPFILENAME,HELP_SETINDEX,(DWORD)IDIndx);
    } else {
	if(IDIndx == IDXID_286HELP) {
	    for(i = 1, aliasptr = Aliases286;
		i <= NUM286ALIASES;
		i++, aliasptr += 2) {

		if(*aliasptr == hindx) {
		    aliasptr++;
		    hindx = *aliasptr;
		    break;
		}
	    }
	}
	retval = WinHelp(hMainwnd,(LPSTR)PIFHELPFILENAME,HELP_CONTEXT,(DWORD)hindx);
	WinHelp(hMainwnd,(LPSTR)PIFHELPFILENAME,HELP_SETINDEX,(DWORD)IDIndx);
    }
    if(retval) {
	hwndHelpDlgParent = hMainwnd;
    } else {
	Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	return(FALSE);
    }
    return(TRUE);
}


int SetWndScroll(int sizeflg, HWND hMwnd, int WindHeight, int WindWidth,
		 int *WndSize, int *ScrollRange, int *ScrollLineSz,
		 int *WndLines, int *MaxNeg)
{
    int i;
    int range;
    int rangeFS;
    int MaxrangeNRML;
    int WndCapSz;
    int newheight;
    int newwidth;
    int oldscrollpos;
    int oldscrollOffset;
    int newscrollOffset;
    int oldscrollRange;

    RECT rc1;
    RECT rc2;

    if(hMwnd == hMainwnd) {
	WndCapSz = GetSystemMetrics(SM_CYCAPTION) +
		     GetSystemMetrics(SM_CYMENU);
    } else {
	WndCapSz = GetSystemMetrics(SM_CYCAPTION);
    }

    WndCapSz += (i = (2 * GetSystemMetrics(SM_CYFRAME)));

    rangeFS = GetSystemMetrics(SM_CYSCREEN) + i;

    MaxrangeNRML = rangeFS - (2 * SysCharHeight);

    if(*WndSize != SIZEFULLSCREEN) {
	range = MaxrangeNRML;
    } else {
	range = rangeFS;
    }

    WindHeight += WndCapSz;

    if(sizeflg) {
	if(WindHeight > range)
	    newheight = range;
	else
	    newheight = WindHeight;
	newwidth = WindWidth + (2 * GetSystemMetrics(SM_CXFRAME));
    } else {
	GetWindowRect(hMwnd,(LPRECT)&rc1);
	newheight = rc1.bottom - rc1.top;
	newwidth = rc1.right - rc1.left;
    }

    if(*WndSize == SIZEFULLSCREEN) {
	newwidth = GetSystemMetrics(SM_CXSCREEN) +
			(2 * GetSystemMetrics(SM_CXFRAME));
	newheight = rangeFS;
    }
    newscrollOffset = 0;
    /* Don't bother with SB stuff till window is visible */
    if(IsWindowVisible(hMwnd)) {
	oldscrollOffset = oldscrollpos = 0;
	if((oldscrollRange = *ScrollRange)) {
	    oldscrollpos = GetScrollPos(hMwnd,SB_VERT);
	    newscrollOffset = oldscrollOffset =
			      min((oldscrollpos * *ScrollLineSz),*MaxNeg);
	}
	if(WindHeight > newheight) {
	    GetWindowRect(GetDlgItem(hwndPifDlg,IDI_ENAME),(LPRECT)&rc1);
	    GetWindowRect(GetDlgItem(hwndPifDlg,IDI_ETITLE),(LPRECT)&rc2);
	    *ScrollLineSz = rc2.top - rc1.top;
	    *MaxNeg = WindHeight - newheight;
	    *WndLines = range = (*MaxNeg + *ScrollLineSz - 1)/ *ScrollLineSz;
	    if(range != *ScrollRange) {
		SetScrollRange(hMwnd, SB_VERT, 0, range, FALSE);
		if(!oldscrollpos) {
		    SetScrollPos(hMwnd, SB_VERT, 0, TRUE);
		} else if (oldscrollpos > range) {
		    SetScrollPos(hMwnd, SB_VERT, range, TRUE);
		    newscrollOffset = min((range * *ScrollLineSz),*MaxNeg);
		} else {
		    SetScrollPos(hMwnd, SB_VERT, oldscrollpos, TRUE);
		    newscrollOffset = min((oldscrollpos * *ScrollLineSz),*MaxNeg);
		}
		*ScrollRange = range;
	    } else {
		newscrollOffset = min((oldscrollpos * *ScrollLineSz),*MaxNeg);
	    }
	    if(oldscrollpos && (newscrollOffset != oldscrollOffset)) {
		if((hMwnd == hwndAdvPifDlg) || (hMwnd == hwndNTPifDlg)) {
		    ScrollWindow(hMwnd,
				 0,
				 oldscrollOffset-newscrollOffset,
				 (CONST RECT *)NULL,
				 (CONST RECT *)NULL);
		    UpdateWindow(hMwnd);
		    AdjustFocusCtrl(hMwnd);
		} else {
		    SetWindowPos(hwndPifDlg,
				 (HWND)NULL,
				 0,
				 -newscrollOffset,
				 newwidth,
				 newheight + newscrollOffset -
				   (StatusPntData.dyStatus + StatusPntData.dyBorderx2),
				 SWP_NOZORDER | SWP_NOACTIVATE);
		    UpdateWindow(hwndPifDlg);
		    AdjustFocusCtrl(hwndPifDlg);
		}
		InvalidateStatusBar(hMwnd);
	    }
	} else {
	    if(*ScrollRange && oldscrollpos) {
		MainScroll(hMwnd, SB_TOP, 0, 0, 1);
	    }
	    SetScrollRange(hMwnd, SB_VERT, 0, 0, FALSE);
	    *ScrollRange = 0;
	}
    }
    if(sizeflg) {
	SetWindowPos(hMwnd,
		     (HWND)NULL,
		     (int)NULL,
		     (int)NULL,
		     newwidth,
		     newheight,
		     SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
    }
    return(newscrollOffset);
}


SetMainWndSize(int sizeflg)
{
    long SizeLong;
    int MainWindHeight;
    int MainWindWidth;
    int AdvWindHeight;
    int AdvWindWidth;
    int NTWindHeight;
    int NTWindWidth;
    int PassFlg;
    int ScrlOff;
    RECT rc;

    if(SizingFlag)
	return(TRUE);
    SizingFlag++;

    switch(sizeflg) {
        case SBUMAIN:
        case  SBUADV:
        case   SBUNT:
	    PassFlg = 0;	/* Flag just SB update to do */
            break;

        default:
	    PassFlg = 1;	/* Flag SB and SIZE update to do */
            break;
    }

    switch(sizeflg) {
        case SBUMAIN:
        case SBUMAINADVNT:
        case SBUSZMAIN:
        case SBUSZMAINADVNT:
 	    SendMessage(hwndPifDlg,WM_PRIVGETSIZE,0,(LONG)(long FAR *)&SizeLong);
	    MainWindHeight = HIWORD(SizeLong);
	    MainWindWidth = LOWORD(SizeLong);
	    ScrlOff = SetWndScroll(PassFlg,hMainwnd,MainWindHeight,
                                   MainWindWidth,&MainWndSize,&MainScrollRange,
                                   &MainScrollLineSz,&MainWndLines,&MaxMainNeg);
	    /*
	     *  Clip the dialog so that it doesn't overlap the status bar
	     */
	    GetClientRect(hMainwnd,(LPRECT)&rc);
	    SetWindowPos(hwndPifDlg,
		         (HWND)NULL,
		         0,
		         0,
		         rc.right - rc.left,
		         rc.bottom - rc.top + ScrlOff -
		          (StatusPntData.dyStatus + StatusPntData.dyBorderx2),
		         SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
            break;

        default:
            break;
    }

    if(hwndAdvPifDlg) {
        switch(sizeflg) {
            case SBUSZMAINADVNT:
            case   SBUMAINADVNT:
            case       SBUSZADV:
            case         SBUADV:
	        SendMessage(hwndAdvPifDlg,WM_PRIVGETSIZE,0,
                            (LONG)(long FAR *)&SizeLong);
	        AdvWindHeight = HIWORD(SizeLong);
	        AdvWindWidth = LOWORD(SizeLong);
	        ScrlOff = SetWndScroll(PassFlg,hwndAdvPifDlg,AdvWindHeight,
                                       AdvWindWidth,&AdvWndSize,&AdvScrollRange,
                                       &AdvScrollLineSz,&AdvWndLines,
                                       &MaxAdvNeg);
                break;

            default:
                break;
        }
    }

    if(hwndNTPifDlg) {
        switch(sizeflg) {
            case SBUSZMAINADVNT:
            case   SBUMAINADVNT:
            case        SBUSZNT:
            case          SBUNT:
	        SendMessage(hwndNTPifDlg,WM_PRIVGETSIZE,0,
                            (LONG)(long FAR *)&SizeLong);
	        NTWindHeight = HIWORD(SizeLong);
	        NTWindWidth = LOWORD(SizeLong);
	        ScrlOff = SetWndScroll(PassFlg,hwndNTPifDlg,NTWindHeight,
                                       NTWindWidth,&NTWndSize,&NTScrollRange,
                                       &NTScrollLineSz,&NTWndLines,
                                       &MaxNTNeg);
                break;

            default:
                break;
        }
    }

    SizingFlag = 0;
    return(TRUE);
}


/*
 * CpyCmdStr( LPSTR szDst, LPSTR szSrc )
 *
 * Copies szSrc to szDst and correctly deals with double quotes
 */
void CpyCmdStr( LPSTR szDst, LPSTR szSrc ) {

    do {
        switch( *szSrc ) {
        case '"':
            /* eat double quotes */
            break;

#if 0
        //
        // This 'case' makes it difficult to put a '^' in a filename.
        // (due to cmd processing, it needs to appear 4 times in the line)!
        //
        // With out this case, it is impossible to put a '"' in the middle
        // of a filename, but " is illegal in a filename on _ALL_ NT
        // filesystems, and is not supported by any command line utility
        // in that context.
        //
        case '^':
            /* use '^' to mean 'quote next char' */
            szSrc++;
            /* FALL THROUGH to default */
#endif

        default:
            *szDst++ = *szSrc;
            break;
        }
    }while( *szSrc++ );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmutils\pifedit\pifhelp.h ===
#define PIFHELPFILENAME 	"PIFEDIT.HLP"

/* Menu commands main window */
#define M_OPEN			10
#define M_SAVE			11
#define M_NEW			12
#define M_SAVEAS		13
#define M_ABOUT 		14	/* NOTE this is actually on help menu */
#define M_EXIT			15
#define M_AHELP 		16	/* Item ID for F1 help key */
#define M_286			17
#define M_386			18

/* Special HELP Menu item IDs */
#define M_286HELP		0x0022
#define M_386HELP		0x0023
#define M_386AHELP		0x0024
#define M_SHELP 		0x0025
#define M_NTHELP 		0x0026
#define M_INDXHELP		0xFFFF
#define M_HELPHELP		0xFFFC

/* Values used only for status bar text, these are for the main menu items */
#define M_SYSMENUMAIN		 19
#define M_FILEMENU		 20
#define M_MODEMENU		 21
#define M_HELPMENU		 22
#define M_SYSMENUADV		 23
#define M_SYSMENUNT 		 M_SYSMENUADV
#define SC_CLOSEADV		 24
#define SC_NTCLOSE		 25

/* Help Index IDs */
#define IDXID_286HELP		0x0050
#define IDXID_386HELP		0x0051
#define IDXID_386AHELP		0x0052
#define IDXID_NTHELP  	 	0x0053

/* Special */
#define IDI_ADVANCED		90
#define IDI_NT      		91

/* edit fields IDs main windows (both 286 and 386) */
#define IDI_ENAME		100
#define IDI_ETITLE		101
#define IDI_EPARM		102
#define IDI_EPATH		103	/* Used to size main wnd std Right */
#define IDI_MEMREQ		104
#define IDI_MEMDES		105

/* "directly modifies" checkbox group 286 */
/* #define IDI_DMSCREEN 	   200 */
#define IDI_DMCOM1		201
/* #define IDI_DM8087		   202 */
#define IDI_DMKBD		203
#define IDI_DMCOM2		204
/* #define IDI_DMMEM		   205 */
#define IDI_DMCOM3		206
#define IDI_DMCOM4		207

/* Program switch radio group 286 */
#define IDI_PSFIRST		300
#define IDI_PSNONE		300
#define IDI_PSTEXT		301
#define IDI_PSGRAPH		302
#define IDI_PSLAST		302
#define IDI_NOSAVVID		308

/* Screen exchange radio group 286 */
/* #define IDI_SEFIRST		   400	*/
#define IDI_SENONE		400
/* #define IDI_SETEXT		   401	*/
/* #define IDI_SEGRAPH		   402	*/
/* #define IDI_SELAST		   402	*/

/* Close window checkbox group 286/386 */
#define IDI_EXIT		500	/* Used to size main wnd Enh Bottom */

/* WIN386 group */
#define IDI_OTHGRP		600	/* Used to Size adv wnd Bottom & Right*/
#define IDI_FPRI		601
#define IDI_BPRI		602
#define IDI_POLL		603
#define IDI_EMSREQ		604
#define IDI_EMSDES		605
#define IDI_EMSLOCKED		606
#define IDI_XMAREQ		607
#define IDI_XMADES		608
#define IDI_XMSLOCKED		609
#define IDI_BACK		610	/* Used to size main wnd Enh Right */
#define IDI_WND 		611
#define IDI_FSCR		612
#define IDI_EXCL		613
#define IDI_CLOSE		614
#define IDI_HOTKEY		615
#define IDI_ALTTAB		616
#define IDI_ALTESC		617
#define IDI_ALTENTER		618
#define IDI_ALTSPACE		619
#define IDI_ALTPRTSC		620	/* Used to size main wnd std Bottom */
#define IDI_PRTSC		621
#define IDI_CTRLESC		622
#define IDI_NOHMA		623
#define IDI_INT16PST		624
#define IDI_VMLOCKED		625
/* WIN386 VIDEO GROUP */
#define IDI_TEXTEMULATE 	700
#define IDI_TRAPTXT		701
#define IDI_TRAPLRGRFX		702
#define IDI_TRAPHRGRFX		703
#define IDI_RETAINALLO		704
#define IDI_VMODETXT		705
#define IDI_VMODELRGRFX 	706
#define IDI_VMODEHRGRFX 	707

/* Windows NT group */
#define IDI_AUTOEXEC		800
#define IDI_CONFIG		801
#define IDI_DOS   		802
#define IDI_NTTIMER		803     /* Used to size NT wnd Bottom */

/*
 * HELP Aliases.
 *
 *   Some of the items have the same ID in both 286 and 386 mode, but
 *	the help is different depending on the mode (286 help != 386 help
 *	for this item). These are the ALIASES for these items so that we
 *	can pass a different ID when in 286 mode.
 *
 */
#define IDI_MEMREQ_286ALIAS	900

#define IDI_XMAREQ_286ALIAS	901
#define IDI_XMADES_286ALIAS	902

#define IDI_ALTTAB_286ALIAS	903
#define IDI_ALTESC_286ALIAS	904
#define IDI_ALTPRTSC_286ALIAS	905
#define IDI_PRTSC_286ALIAS	906
#define IDI_CTRLESC_286ALIAS	907

/*
 *#define IDI_EMSREQ_286ALIAS	  908
 *#define IDI_EMSDES_286ALIAS	  909
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmutils\pifedit\pifedit.h ===
#include "windows.h"
#include "pif.h"
#include "pifhelp.h"

extern char hextobyte(LPSTR);

/* EQUATES for special virtual key values that are used a lot */
#define ALTLPARAM    (DWORD)((DWORD)(MapVirtualKey(VK_MENU,0)) << 16L)
#define CTRLLPARAM   (DWORD)((DWORD)(MapVirtualKey(VK_CONTROL,0)) << 16L)
#define SHIFTLPARAM  (DWORD)((DWORD)(MapVirtualKey(VK_SHIFT,0)) << 16L)

/* Special private messages for PIFEDIT */
#define WM_PRIVGETSIZE		WM_USER+20
#define WM_PRIVCLOSEOK		WM_USER+21
#define WM_PRIVCLOSECANCEL	WM_USER+22
#define IDADVCANCEL             WM_USER+23
#define IDNTCANCEL              WM_USER+24
#define IDNTOK                  WM_USER+25

/* Max Length of all of the status bar texts, INCLUDING THE NUL */
#define PIFSTATUSLEN		90

/* There is no control for these, IDI_GENSTAT is for the default status text */
#define IDI_GENSTAT		1001
/* IDI_CLOSE is for when IDCANCEL appears as CLOSE */
#define IDI_CANCLOSE		1002
#define IDI_NTCANCLOSE		1003

/* Status paint helper structure */
typedef struct {
    int 	dyBorder;	        /* System Border Width/Height     */
    int 	dyBorderx2;	        /* System Border Width/Height * 2 */
    int 	dyBorderx3;	        /* System Border Width/Height * 3 */
    int 	dyStatus;	        /* Status Bar height		  */
    int 	Fntheight;	        /* Height of the font		  */
    HGDIOBJ	hFontStatus;	        /* Font used in status bar        */
} PIFSTATUSPAINT;

/* String table equates */
#define errTitle		2000
#define errNoPIFfnf		2001
#define errNoPIFpnf		2002
#define errNoCreate		2003
#define errMmMaxMin386		2004
#define errHiLow		2005
#define errNoFileHnds		2006
#define warSave 		2007
#define errNoAcc		2008
#define EINSMEMORY		2009
#define errNOEND		2010
#define EINVALIDFILE		2011
#define errDiskFull		2012
#define IABOUT		        2013	
#define errBadExt		2014
#define errBadProgram		2015
#define IS386			2016
#define IS286			2017
#define PIFCAPTIONADV		2018
#define PIFCAPTION		2019
#define errNoOpen		2020
#define PIFBADFIL		2021
#define PIFOLDFIL		2022
#define WARNCLOSE		2023
#define NONE			2024
#define BADHK			2025
#define WININISECT		2026
#define WININIADV		2027
#define WININION		2028
#define MENUMNEMONIC1		2029
#define MENUMNEMONIC2		2030
#define MENUMNEMONIC3		2031
#define KEYSEPCHAR		2032
#define errBadNumberP		2033
#define errBadNumberMR		2034
#define errBadNumberMD		2035
#define errBadNumberXEMSR	2036
#define errBadNumberXEMSD	2037
#define NOMODE386		2038
#define NOMODE286		2039
#define NOTITLE 		2040
#define PIFCANCELSTRNG		2041
#define PIFDONESTRNG		2042
#define errXMSMaxMin386 	2044
#define errXMSMaxMin286 	2045
#define errEMMMaxMin386 	2046
/*
 * #define PIFOLDFIL2		   2047
 * #define errEMMMaxMin286	   2048
 */
#define errWrongExt		2049
#define errSharing		2050
#define errCrtRO		2051
#define errFlTypePIF		2052
#define errFlTypeAll		2053
#define PIFCAPTIONNT            2054
#define errNoNTAFile            2055
#define errNoNTCFile            2056
#define errNTAFilene            2057
#define errNTCFilene            2058
#define NTSYSTEMROOT            2059
#define NTSYSTEM32              2060
#define NOMODENT                2061
#define NTAUTOEXECFILE          2062
#define NTCONFIGFILE            2063
#define errBadAutoPath          2064
#define errBadConfigPath        2065
#define errBadAutoName          2070
#define errBadConName           2071

/* DIALOG IDs for DialogBox dialogs */
#define DTOPEN			10
#define DTSAVE			11
#define DTABOUT 		12

/* Return values for SAVE dialog */
#define SAVERETRY		1
#define SAVEDONE		2
#define SAVEERROR		3

/* IDs of special controls in Save As, Open, etc dialogs */
#define ID_PATH 		10
#define ID_EDIT 		11
#define ID_LISTBOX		12
#define ID_LISTBOXDIR		13
#define IDSCROLL		16
#define IDTEXTBOX		17

#define PATHMAX 		128

/* LISTBOX type equates */
#define ATTRDIRLIST		0xC010		/* dirs and drives only */
#define ATTRFILELIST		0x0000		/* normal files */
#define ATTRDIRFILE		0x4010		/* normal files */


#define ID_PIFICON		1

#define ID_PIFMENU		1

/* Dialog templates for main and advanced window dialogs */
#define ID_PIF286TEMPLATE	1
#define ID_PIF386TEMPLATE	2
#define ID_PIF386ADVTEMPLT	3
#define ID_PIFNTTEMPLT		4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmutils\pifedit\pifsubs.c ===
#define NOSOUND
#define NOCOMM
#include "pifedit.h"

extern int	     SetHotKeyTextFromPIF(void);
extern int	     delete(PSTR);
extern BOOL	     UpdateHotKeyStruc(void);
extern unsigned char *PutUpDB(int);
extern void	     SetStatusText(HWND,int,BOOL);
extern void	     InvalidateAllStatus(void);
extern int	     CmdArgAddCorrectExtension(unsigned char *);
extern HINSTANCE hPifInstance;
extern HWND hwndPifDlg;
extern HWND hwndAdvPifDlg;
extern HWND hwndNTPifDlg;
extern HWND hMainwnd;
extern HWND hParentWnd;
extern BOOL CurrMode386;
extern BOOL NewHotKey;
extern BOOL FileChanged;
extern BOOL DoingMsg;
extern unsigned char rgchInsMem[80];
extern unsigned char rgchTitle[60];
extern unsigned char CurPifFile[];
extern unsigned char PifBuf[];
extern unsigned char NTSys32Root[];
extern BOOL AdvClose;
extern BOOL NTClose;
extern unsigned InMemHotKeyScan;
extern unsigned InMemHotKeyShVal;
extern unsigned InMemHotKeyShMsk;
extern int  FocusIDAdv;
extern int  FocusIDNT;
extern WORD fileoffset;
extern WORD extoffset;

extern PIFNEWSTRUCT UNALIGNED *PifFile;
extern PIF386EXT UNALIGNED *Pif386ext;
extern PIFWNTEXT UNALIGNED *PifNText;
/*
 * extern PIF286EXT31	*Pif286ext31;
 */
extern PIF286EXT30 UNALIGNED *Pif286ext30;
extern BOOL fNoNTAWarn;
extern BOOL fNTAWarnne;
extern BOOL fNoNTCWarn;
extern BOOL fNTCWarnne;

int  InitPif386Struc(void);
int  InitPifNTStruc(void);
int  InitPif286Struc(void);
int  InitStdPIFExt(void);
int  InitPifStruct(void);
BOOL ValidFileSpec(LPSTR lpstr, int iCaller);
BOOL ExpandFileSpec(LPSTR lpstrExp, LPSTR lpstr, int errID);

unsigned int WarningSem = 0;

PIFEXTHEADER UNALIGNED *LastPifExt;
unsigned PifFileSize;

char stdHdr[] = STDHDRSIG;
char w386Hdr[] = W386HDRSIG;
char w286Hdr30[] = W286HDRSIG30;
char wNTHdr[] =  WNTHDRSIG31;
/*
 * char w286Hdr31[] = W286HDRSIG31;
 */

/* char *SCANNames[] = { "00h","01h","02h","03h","04h","05h","06h","07h",
                      "08h","09h","0Ah","0Bh","0Ch","0Dh","0Eh","0Fh",
                      "10h","11h","12h","13h","14h","15h","16h","17h",
                      "18h","19h","1Ah","1Bh","1Ch","1Dh","1Eh","1Fh",
                      "20h","21h","22h","23h","24h","25h","26h","27h",
                      "28h","29h","2Ah","2Bh","2Ch","2Dh","2Eh","2Fh",
                      "30h","31h","32h","33h","34h","35h","36h","37h",
                      "38h","39h","3Ah","3Bh","3Ch","3Dh","3Eh","3Fh",
                      "40h","41h","42h","43h","44h","45h","46h","47h",
                      "48h","49h","4Ah","4Bh","4Ch","4Dh","4Eh","4Fh",
                      "50h","51h","52h","53h","54h","55h","56h","57h",
                      "58h","59h","5Ah","5Bh","5Ch","5Dh","5Eh","5Fh",
                      "60h","61h","62h","63h","64h","65h","66h","67h",
                      "68h","69h","6Ah","6Bh","6Ch","6Dh","6Eh","6Fh",
                      "70h","71h","72h","73h","74h","75h","76h","77h",
                      "78h","79h","7Ah","7Bh","7Ch","7Dh","7Eh","7Fh",
                      "80h","81h","82h","83h","84h","85h","86h","87h",
                      "88h","89h","8Ah","8Bh","8Ch","8Dh","8Eh","8Fh",
                      "90h","91h","92h","93h","94h","95h","96h","97h",
                      "98h","99h","9Ah","9Bh","9Ch","9Dh","9Eh","9Fh",
                      "A0h","A1h","A2h","A3h","A4h","A5h","A6h","A7h",
                      "A8h","A9h","AAh","ABh","ACh","ADh","AEh","AFh",
                      "B0h","B1h","B2h","B3h","B4h","B5h","B6h","B7h",
                      "B8h","B9h","BAh","BBh","BCh","BDh","BEh","BFh",
                      "C0h","C1h","C2h","C3h","C4h","C5h","C6h","C7h",
                      "C8h","C9h","CAh","CBh","CCh","CDh","CEh","CFh",
                      "D0h","D1h","D2h","D3h","D4h","D5h","D6h","D7h",
                      "D8h","D9h","DAh","DBh","DCh","DDh","DEh","DFh",
                      "E0h","E1h","E2h","E3h","E4h","E5h","E6h","E7h",
                      "E8h","E9h","EAh","EBh","ECh","EDh","EEh","EFh",
                      "F0h","F1h","F2h","F3h","F4h","F5h","F6h","F7h",
                      "F8h","F9h","FAh","FBh","FCh","FDh","FEh","FFh" }; */



void SetFileOffsets(unsigned char *nmptr,WORD *fileoff,WORD *extoff)
{
    unsigned char *pch;
    unsigned char ch;

    pch = nmptr+lstrlen((LPSTR)nmptr);
    while ((ch = *pch) != '\\' && ch != ':' && pch > nmptr)
	pch = (unsigned char *)AnsiPrev((LPSTR)nmptr, (LPSTR)pch);
    if((ch = *pch) == '\\' || ch == ':')
	pch++;
    *fileoff = pch - nmptr;
    *extoff = 0;
    while ((ch = *pch) != '.' && ch != '\0')
	pch = (unsigned char *)AnsiNext((LPSTR)pch);
    if(ch == '.') {
	pch++;
	if(*pch == '\0')
	    return;
	else
	    *extoff = pch - nmptr;
    }
}


int Warning(int ID,WORD type)
{

    unsigned char buf[500];
    int retval;
    BOOL MsgFlagSav;

    if(hParentWnd != hMainwnd) {
	if(!WarningSem) {
	    EnableWindow(hMainwnd,FALSE);
	}
	WarningSem++;

    }
    MsgFlagSav = DoingMsg;
    DoingMsg = TRUE;
    if(MsgFlagSav != DoingMsg)
	InvalidateAllStatus();
    if(ID == EINSMEMORY) {
	retval = MessageBox(hParentWnd, (LPSTR)rgchInsMem, (LPSTR)rgchTitle, type);
    } else if(LoadString(hPifInstance, ID, (LPSTR)buf, sizeof(buf))) {
	retval = MessageBox(hParentWnd, (LPSTR)buf, (LPSTR)rgchTitle, type);
    } else {
	MessageBox(hParentWnd, (LPSTR)rgchInsMem, (LPSTR)rgchTitle, MB_ICONEXCLAMATION | MB_OK);
	retval = IDCANCEL;
    }
    if(hParentWnd != hMainwnd) {
	if(WarningSem == 1) {
	    EnableWindow(hMainwnd,TRUE);
	}
	WarningSem--;
    }
    if(retval == 0) {		/* map messagebox failure to cancel */
	retval = IDCANCEL;
    }
    if(MsgFlagSav != DoingMsg) {
	DoingMsg = MsgFlagSav;
	InvalidateAllStatus();
    } else {
	DoingMsg = MsgFlagSav;
    }
    return(retval);
}


PIFWNTEXT UNALIGNED *AllocInitNTExt(void)
{
    PIFWNTEXT UNALIGNED *extNT;
    char      buf[PIFDEFPATHSIZE*2];
    char      buf2[PIFDEFPATHSIZE*4];

    if(PifFileSize >= PIFEDITMAXPIF - (sizeof(PIFWNTEXT) + sizeof(PIFEXTHEADER))) {
	return((PIFWNTEXT *)NULL);
    }

    LastPifExt->extnxthdrfloff = PifFileSize;

    LastPifExt = (PIFEXTHEADER *)(PifBuf + PifFileSize);

    LastPifExt->extnxthdrfloff = LASTHEADERPTR;
    LastPifExt->extfileoffset = PifFileSize + sizeof(PIFEXTHEADER);
    LastPifExt->extsizebytes = sizeof(PIFWNTEXT);
    lstrcpy((LPSTR)LastPifExt->extsig,(LPSTR)wNTHdr);
    PifFileSize += sizeof(PIFWNTEXT) + sizeof(PIFEXTHEADER);

    extNT = (PIFWNTEXT *)(PifBuf + LastPifExt->extfileoffset);

    extNT->dwWNTFlags = 0;
    extNT->dwRes1 = 0;
    extNT->dwRes2 = 0;
    fNoNTAWarn = FALSE;
    fNTAWarnne = FALSE;
    fNoNTCWarn = FALSE;
    fNTCWarnne = FALSE;

    lstrcpy((LPTSTR)buf2, (LPCTSTR)NTSys32Root);
    if(LoadString(hPifInstance, NTAUTOEXECFILE, (LPSTR)buf, PIFDEFPATHSIZE-1)) {
        lstrcat((LPTSTR)buf2, (LPCTSTR)buf);
        AnsiToOem(buf2, (LPTSTR)extNT->achAutoexecFile);
    }

    lstrcpy((LPTSTR)buf2, (LPCTSTR)NTSys32Root);
    if(LoadString(hPifInstance, NTCONFIGFILE, (LPSTR)buf, PIFDEFPATHSIZE-1)) {
        lstrcat((LPTSTR)buf2, (LPCTSTR)buf);
        AnsiToOem(buf2, (LPTSTR)extNT->achConfigFile);
    }

    return(extNT);

}


PIF386EXT UNALIGNED *AllocInit386Ext(void)
{
    PIF386EXT UNALIGNED *ext386;
    unsigned char   *src,*dst;
    int 	    i;

    if(PifFileSize >= PIFEDITMAXPIF - (sizeof(PIF386EXT) + sizeof(PIFEXTHEADER))) {
	return((PIF386EXT *)NULL);
    }

    LastPifExt->extnxthdrfloff = PifFileSize;

    LastPifExt = (PIFEXTHEADER *)(PifBuf + PifFileSize);

    LastPifExt->extnxthdrfloff = LASTHEADERPTR;
    LastPifExt->extfileoffset = PifFileSize + sizeof(PIFEXTHEADER);
    LastPifExt->extsizebytes = sizeof(PIF386EXT);
    lstrcpy((LPSTR)LastPifExt->extsig,(LPSTR)w386Hdr);
    PifFileSize += sizeof(PIF386EXT) + sizeof(PIFEXTHEADER);

    ext386 = (PIF386EXT *)(PifBuf + LastPifExt->extfileoffset);

    dst = (PUCHAR)ext386->params;
    src = (PUCHAR)(((PIFOLD286STR *)PifBuf)->params);
    for(i=0;i<PIFPARAMSSIZE;i++)
	*dst++ = *src++;

    ext386->maxmem = 640;
    ext386->minmem = 128;
    ext386->PfFPriority = 100;
    ext386->PfBPriority = 50;
    ext386->PfMaxEMMK = 1024;
    ext386->PfMinEMMK = 0;
    ext386->PfMaxXmsK = 1024;
    ext386->PfMinXmsK = 0;
    ext386->PfW386Flags = fFullScreen | fPollingDetect | fINT16Paste;
    if(Pif286ext30) {
	if(Pif286ext30->PfW286Flags & fALTTABdis286)
	    ext386->PfW386Flags |= fALTTABdis;
	if(Pif286ext30->PfW286Flags & fALTESCdis286)
	    ext386->PfW386Flags |= fALTESCdis;
	if(Pif286ext30->PfW286Flags & fCTRLESCdis286)
	    ext386->PfW386Flags |= fCTRLESCdis;
	if(Pif286ext30->PfW286Flags & fALTPRTSCdis286)
	    ext386->PfW386Flags |= fALTPRTSCdis;
	if(Pif286ext30->PfW286Flags & fPRTSCdis286)
	    ext386->PfW386Flags |= fPRTSCdis;
    }
    ext386->PfW386Flags2 = fVidTxtEmulate | fVidNoTrpTxt | fVidNoTrpLRGrfx
			   | fVidTextMd;
    /*
     * The following is if( > EGA), then don't trap Hi Res graphics ports
     *	The setting of this bit is irrelevant on HERC CGA and PLASMA,
     *	so the fact that these guys also get "caught" by this doesn't
     *	matter. EGA is the only low res guy that matters.
     *
     */
    if(GetSystemMetrics(SM_CYSCREEN) > 350) {
	ext386->PfW386Flags2 |= fVidNoTrpHRGrfx;
    }
    ext386->PfHotKeyScan = 0;
    ext386->PfHotKeyShVal = 0;
    ext386->PfHotKeyShMsk = 0;
    InMemHotKeyScan = 0;
    InMemHotKeyShVal = 0;
    InMemHotKeyShMsk = 0;
    NewHotKey = FALSE;
    SetHotKeyTextFromPIF();
    return(ext386);

}

PIF286EXT30 UNALIGNED *AllocInit286Ext30(void)
{
    PIF286EXT30 UNALIGNED *ext286;

    if(PifFileSize >= PIFEDITMAXPIF - (sizeof(PIF286EXT30) + sizeof(PIFEXTHEADER))) {
	return((PIF286EXT30 *)NULL);
    }

    LastPifExt->extnxthdrfloff = PifFileSize;

    LastPifExt = (PIFEXTHEADER *)(PifBuf + PifFileSize);

    LastPifExt->extnxthdrfloff = LASTHEADERPTR;
    LastPifExt->extfileoffset = PifFileSize + sizeof(PIFEXTHEADER);
    LastPifExt->extsizebytes = sizeof(PIF286EXT30);
    lstrcpy((LPSTR)LastPifExt->extsig,(LPSTR)w286Hdr30);
    PifFileSize += sizeof(PIF286EXT30) + sizeof(PIFEXTHEADER);

    ext286 = (PIF286EXT30 *)(PifBuf + LastPifExt->extfileoffset);

    ext286->PfMaxXmsK = 0;
    ext286->PfMinXmsK = 0;
    ext286->PfW286Flags = 0;
    if(Pif386ext) {
	if(Pif386ext->PfW386Flags & fALTTABdis)
	    ext286->PfW286Flags |= fALTTABdis286;
	if(Pif386ext->PfW386Flags & fALTESCdis)
	    ext286->PfW286Flags |= fALTESCdis286;
	if(Pif386ext->PfW386Flags & fCTRLESCdis)
	    ext286->PfW286Flags |= fCTRLESCdis286;
	if(Pif386ext->PfW386Flags & fALTPRTSCdis)
	    ext286->PfW286Flags |= fALTPRTSCdis286;
	if(Pif386ext->PfW386Flags & fPRTSCdis)
	    ext286->PfW286Flags |= fPRTSCdis286;
    }
    return(ext286);
}

/*
 * PIF286EXT31 *AllocInit286Ext31(void)
 * {
 *     PIF286EXT31 *ext286;
 *
 *     if(PifFileSize >= PIFEDITMAXPIF - (sizeof(PIF286EXT31) + sizeof(PIFEXTHEADER))) {
 *	   return((PIF286EXT31 *)NULL);
 *     }
 *
 *     LastPifExt->extnxthdrfloff = PifFileSize;
 *
 *     LastPifExt = (PIFEXTHEADER *)(PifBuf + PifFileSize);
 *
 *     LastPifExt->extnxthdrfloff = LASTHEADERPTR;
 *     LastPifExt->extfileoffset = PifFileSize + sizeof(PIFEXTHEADER);
 *     LastPifExt->extsizebytes = sizeof(PIF286EXT31);
 *     lstrcpy((LPSTR)LastPifExt->extsig,(LPSTR)w286Hdr31);
 *     PifFileSize += sizeof(PIF286EXT31) + sizeof(PIFEXTHEADER);
 *
 *     ext286 = (PIF286EXT31 *)(PifBuf + LastPifExt->extfileoffset);
 *
 *     ext286->PfMaxEmsK = 0;
 *     ext286->PfMinEmsK = 0;
 *     return(ext286);
 * }
 */

UpdatePifScreenAdv(void)
{
    unsigned char rgch[200];

    if(hwndAdvPifDlg) {
	if(!AdvClose) {
	    if(!LoadString(hPifInstance, PIFDONESTRNG , (LPSTR)rgch, sizeof(rgch))) {
		Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	    } else {
		SetDlgItemText(hwndAdvPifDlg,IDCANCEL,(LPSTR)rgch);
	    }
	    AdvClose = TRUE;
	    if(FocusIDAdv == IDCANCEL) {
		SetStatusText(hwndAdvPifDlg,FocusIDAdv,TRUE);
	    }
	}
	if(CurrMode386) {
	    SetDlgItemInt(hwndAdvPifDlg, IDI_FPRI, Pif386ext->PfFPriority, FALSE);
	    SetDlgItemInt(hwndAdvPifDlg, IDI_BPRI, Pif386ext->PfBPriority, FALSE);
	    CheckDlgButton(hwndAdvPifDlg, IDI_POLL, Pif386ext->PfW386Flags & fPollingDetect ? TRUE  : FALSE );
	    CheckDlgButton(hwndAdvPifDlg, IDI_CLOSE, Pif386ext->PfW386Flags & fEnableClose ? TRUE  : FALSE );
	    CheckDlgButton(hwndAdvPifDlg, IDI_ALTTAB, Pif386ext->PfW386Flags & fALTTABdis ? TRUE : FALSE );
	    CheckDlgButton(hwndAdvPifDlg, IDI_ALTESC, Pif386ext->PfW386Flags & fALTESCdis ? TRUE : FALSE );
	    CheckDlgButton(hwndAdvPifDlg, IDI_CTRLESC, Pif386ext->PfW386Flags & fCTRLESCdis ? TRUE : FALSE );
	    CheckDlgButton(hwndAdvPifDlg, IDI_ALTSPACE, Pif386ext->PfW386Flags & fALTSPACEdis ? TRUE : FALSE );
	    CheckDlgButton(hwndAdvPifDlg, IDI_ALTENTER, Pif386ext->PfW386Flags & fALTENTERdis ? TRUE : FALSE );
	    CheckDlgButton(hwndAdvPifDlg, IDI_ALTPRTSC, Pif386ext->PfW386Flags & fALTPRTSCdis ? TRUE : FALSE );
	    CheckDlgButton(hwndAdvPifDlg, IDI_PRTSC, Pif386ext->PfW386Flags & fPRTSCdis ? TRUE : FALSE );
	    CheckDlgButton(hwndAdvPifDlg, IDI_NOHMA, Pif386ext->PfW386Flags & fNoHMA ? FALSE : TRUE );
	    CheckDlgButton(hwndAdvPifDlg, IDI_INT16PST, Pif386ext->PfW386Flags & fINT16Paste ? TRUE : FALSE );
	    CheckDlgButton(hwndAdvPifDlg, IDI_VMLOCKED, Pif386ext->PfW386Flags & fVMLocked ? TRUE : FALSE );
	    CheckDlgButton(hwndAdvPifDlg, IDI_XMSLOCKED, Pif386ext->PfW386Flags & fXMSLocked ? TRUE : FALSE );
	    CheckDlgButton(hwndAdvPifDlg, IDI_EMSLOCKED, Pif386ext->PfW386Flags & fEMSLocked ? TRUE : FALSE );
	    CheckDlgButton(hwndAdvPifDlg, IDI_TEXTEMULATE, Pif386ext->PfW386Flags2 & fVidTxtEmulate ? TRUE : FALSE );
	    CheckDlgButton(hwndAdvPifDlg, IDI_RETAINALLO, Pif386ext->PfW386Flags2 & fVidRetainAllo ? TRUE : FALSE );
	    CheckDlgButton(hwndAdvPifDlg, IDI_TRAPTXT, Pif386ext->PfW386Flags2 & fVidNoTrpTxt ? FALSE : TRUE );
	    CheckDlgButton(hwndAdvPifDlg, IDI_TRAPLRGRFX, Pif386ext->PfW386Flags2 & fVidNoTrpLRGrfx ? FALSE : TRUE );
	    CheckDlgButton(hwndAdvPifDlg, IDI_TRAPHRGRFX, Pif386ext->PfW386Flags2 & fVidNoTrpHRGrfx ? FALSE : TRUE );
	    SetHotKeyTextFromPIF();
	} else {

	}
    }
    return(TRUE);
}


UpdatePifScreenNT(void)
{
    unsigned char rgch[PIFDEFPATHSIZE*4];

    if(hwndNTPifDlg) {
	if(!NTClose) {
	    if(!LoadString(hPifInstance, PIFDONESTRNG , (LPSTR)rgch, sizeof(rgch))) {
		Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	    } else {
		SetDlgItemText(hwndNTPifDlg,IDCANCEL,(LPSTR)rgch);
	    }
	    NTClose = TRUE;
	    if(FocusIDNT == IDCANCEL) {
		SetStatusText(hwndNTPifDlg,FocusIDNT,TRUE);
	    }
	}
	if(CurrMode386) {
            OemToAnsi((LPCTSTR)PifNText->achAutoexecFile, rgch);
	    SetDlgItemText(hwndNTPifDlg,IDI_AUTOEXEC,(LPCTSTR)rgch);
            OemToAnsi((LPCTSTR)PifNText->achConfigFile, rgch);
	    SetDlgItemText(hwndNTPifDlg,IDI_CONFIG,(LPCTSTR)rgch);
	    CheckDlgButton(hwndNTPifDlg, IDI_NTTIMER, (PifNText->dwWNTFlags & COMPAT_TIMERTIC));
	} else {

	}
    }
    return(TRUE);
}


/* make the screen match the structure */
UpdatePifScreen(void)
{
    unsigned char rgch[200];
    int i;

    /*
     * make sure of nul terminator before calling OemToAnsi
     */
    PifFile->startfile[PIFSTARTLOCSIZE-1] = '\0';
    OemToAnsi((LPSTR)PifFile->startfile,(LPSTR)rgch);
    SetDlgItemText(hwndPifDlg, IDI_ENAME, (LPSTR)rgch);
    SendMessage(GetDlgItem(hwndPifDlg, IDI_ENAME), EM_SETMODIFY, FALSE, 0L);
    /*
     * NOTE: the PifFile->name field MAY NOT be nul terminated!!!!!!
     */
    for(i = 0;i < PIFNAMESIZE; i++)
	rgch[i] = PifFile->name[i];
    rgch[i] = '\0';
    OemToAnsi((LPSTR)rgch,(LPSTR)rgch);
    SetDlgItemText(hwndPifDlg, IDI_ETITLE, (LPSTR)rgch);
    SendMessage(GetDlgItem(hwndPifDlg, IDI_ETITLE), EM_SETMODIFY, FALSE, 0L);
    /*
     * make sure of nul terminator before calling OemToAnsi
     */
    PifFile->defpath[PIFDEFPATHSIZE-1] = '\0';
    OemToAnsi((LPSTR)PifFile->defpath,(LPSTR)rgch);
    SetDlgItemText(hwndPifDlg, IDI_EPATH, (LPSTR)rgch);
    SendMessage(GetDlgItem(hwndPifDlg, IDI_EPATH), EM_SETMODIFY, FALSE, 0L);
    CheckDlgButton(hwndPifDlg, IDI_EXIT    , PifFile->MSflags & EXITMASK ? TRUE  : FALSE );
    if(CurrMode386) {
	/*
	 * make sure of nul terminator before calling OemToAnsi
	 */
	Pif386ext->params[PIFPARAMSSIZE-1] = '\0';
	OemToAnsi((LPSTR)Pif386ext->params,(LPSTR)rgch);
	SetDlgItemText(hwndPifDlg, IDI_EPARM, (LPSTR)rgch);
	SendMessage(GetDlgItem(hwndPifDlg, IDI_EPARM), EM_SETMODIFY, FALSE, 0L);
	SetDlgItemInt(hwndPifDlg, IDI_MEMREQ, Pif386ext->minmem, TRUE);
	if (Pif386ext->maxmem) {
	    SetDlgItemInt(hwndPifDlg, IDI_MEMDES, Pif386ext->maxmem, TRUE);
	} else {
	    SetDlgItemText(hwndPifDlg, IDI_MEMDES, (LPSTR)"");
	}
	CheckRadioButton(hwndPifDlg, IDI_WND, IDI_FSCR,Pif386ext->PfW386Flags & fFullScreen ? IDI_FSCR : IDI_WND);
	CheckDlgButton(hwndPifDlg, IDI_BACK, Pif386ext->PfW386Flags & fBackground ? TRUE  : FALSE );
	CheckDlgButton(hwndPifDlg, IDI_EXCL, Pif386ext->PfW386Flags & fExclusive ? TRUE  : FALSE );
	if (Pif386ext->PfW386Flags2 & fVidTextMd ) {
	    CheckRadioButton(hwndPifDlg, IDI_VMODETXT, IDI_VMODEHRGRFX, IDI_VMODETXT);
	} else if (Pif386ext->PfW386Flags2 & fVidLowRsGrfxMd) {
	    CheckRadioButton(hwndPifDlg, IDI_VMODETXT, IDI_VMODEHRGRFX, IDI_VMODELRGRFX);
	} else {
	    CheckRadioButton(hwndPifDlg, IDI_VMODETXT, IDI_VMODEHRGRFX, IDI_VMODEHRGRFX);
	}
	SetDlgItemInt(hwndPifDlg, IDI_EMSREQ, Pif386ext->PfMinEMMK, FALSE);
	SetDlgItemInt(hwndPifDlg, IDI_EMSDES, Pif386ext->PfMaxEMMK, TRUE);
	SetDlgItemInt(hwndPifDlg, IDI_XMAREQ, Pif386ext->PfMinXmsK, FALSE);
	SetDlgItemInt(hwndPifDlg, IDI_XMADES, Pif386ext->PfMaxXmsK, TRUE);
	UpdatePifScreenAdv();
	UpdatePifScreenNT();
    } else {
	/*
	 * make sure of nul terminator before calling OemToAnsi
	 */
	PifFile->params[PIFPARAMSSIZE-1] = '\0';
	OemToAnsi((LPSTR)PifFile->params,(LPSTR)rgch);
	SetDlgItemText(hwndPifDlg, IDI_EPARM, (LPSTR)rgch);
	SendMessage(GetDlgItem(hwndPifDlg, IDI_EPARM), EM_SETMODIFY, FALSE, 0L);
	SetDlgItemInt(hwndPifDlg, IDI_MEMREQ, PifFile->minmem, TRUE);
/*
 *	 if (PifFile->maxmem) {
 *	     SetDlgItemInt(hwndPifDlg, IDI_MEMDES, PifFile->maxmem, TRUE);
 *	 } else {
 *	     SetDlgItemText(hwndPifDlg, IDI_MEMDES, (LPSTR)"");
 *	 }
 *	 CheckDlgButton(hwndPifDlg, IDI_DMSCREEN, PifFile->behavior & SCRMASK ? TRUE  : FALSE );
 *	 CheckDlgButton(hwndPifDlg, IDI_DMMEM	, PifFile->MSflags  & MEMMASK ? TRUE  : FALSE );
 */

	CheckDlgButton(hwndPifDlg, IDI_DMKBD   , PifFile->behavior & KEYMASK ? TRUE  : FALSE );
	CheckDlgButton(hwndPifDlg, IDI_DMCOM1  , PifFile->MSflags & COM1MASK ? TRUE  : FALSE );
	CheckDlgButton(hwndPifDlg, IDI_DMCOM2  , PifFile->MSflags & COM2MASK ? TRUE  : FALSE );
	if(Pif286ext30) {
	    CheckDlgButton(hwndPifDlg, IDI_DMCOM3  , Pif286ext30->PfW286Flags & fCOM3_286 ? TRUE  : FALSE );
	    CheckDlgButton(hwndPifDlg, IDI_DMCOM4  , Pif286ext30->PfW286Flags & fCOM4_286 ? TRUE  : FALSE );
	    CheckDlgButton(hwndPifDlg, IDI_ALTTAB, Pif286ext30->PfW286Flags & fALTTABdis286 ? TRUE : FALSE );
	    CheckDlgButton(hwndPifDlg, IDI_ALTESC, Pif286ext30->PfW286Flags & fALTESCdis286 ? TRUE : FALSE );
	    CheckDlgButton(hwndPifDlg, IDI_CTRLESC, Pif286ext30->PfW286Flags & fCTRLESCdis286 ? TRUE : FALSE );
	    CheckDlgButton(hwndPifDlg, IDI_ALTPRTSC, Pif286ext30->PfW286Flags & fALTPRTSCdis286 ? TRUE : FALSE );
	    CheckDlgButton(hwndPifDlg, IDI_PRTSC, Pif286ext30->PfW286Flags & fPRTSCdis286 ? TRUE : FALSE );
	    CheckDlgButton(hwndPifDlg, IDI_NOSAVVID, Pif286ext30->PfW286Flags & fNoSaveVid286 ? TRUE : FALSE );
	    SetDlgItemInt(hwndPifDlg, IDI_XMAREQ, Pif286ext30->PfMinXmsK, FALSE);
	    SetDlgItemInt(hwndPifDlg, IDI_XMADES, Pif286ext30->PfMaxXmsK, TRUE);
	} else {
	    CheckDlgButton(hwndPifDlg, IDI_DMCOM3  , FALSE );
	    CheckDlgButton(hwndPifDlg, IDI_DMCOM4  , FALSE );
	    CheckDlgButton(hwndPifDlg, IDI_ALTTAB,  FALSE );
	    CheckDlgButton(hwndPifDlg, IDI_ALTESC,  FALSE );
	    CheckDlgButton(hwndPifDlg, IDI_CTRLESC, FALSE );
	    CheckDlgButton(hwndPifDlg, IDI_ALTPRTSC, FALSE );
	    CheckDlgButton(hwndPifDlg, IDI_PRTSC, FALSE );
	    CheckDlgButton(hwndPifDlg, IDI_NOSAVVID, FALSE );
	    SetDlgItemText(hwndPifDlg, IDI_XMAREQ, (LPSTR)"0");
	    SetDlgItemText(hwndPifDlg, IDI_XMADES, (LPSTR)"0");
	}
	/*
	 * if(Pif286ext31) {
	 *     SetDlgItemInt(hwndPifDlg, IDI_EMSREQ, Pif286ext31->PfMinEmsK, FALSE);
	 *     SetDlgItemInt(hwndPifDlg, IDI_EMSDES, Pif286ext31->PfMaxEmsK, TRUE);
	 * } else {
	 *     SetDlgItemText(hwndPifDlg, IDI_EMSREQ, (LPSTR)"0");
	 *     SetDlgItemText(hwndPifDlg, IDI_EMSDES, (LPSTR)"0");
	 * }
	 */
	if (PifFile->MSflags & SGMASK) {
	   CheckDlgButton(hwndPifDlg, IDI_SENONE, TRUE);
	} else {
	   CheckDlgButton(hwndPifDlg, IDI_SENONE, FALSE);
	}
	if (PifFile->MSflags & PSMASK) {
	   CheckDlgButton(hwndPifDlg, IDI_PSNONE, TRUE);
	} else {
	   CheckDlgButton(hwndPifDlg, IDI_PSNONE, FALSE);
	}

	CheckRadioButton(hwndPifDlg, IDI_PSTEXT, IDI_PSGRAPH,
		   (PifFile->sysmem < 16 ? IDI_PSTEXT : IDI_PSGRAPH));

/*
 *	  if (PifFile->MSflags & SGMASK) {
 *	     CheckRadioButton(hwndPifDlg, IDI_SEFIRST, IDI_SELAST, IDI_SENONE);
 *	  } else {
 *	     CheckRadioButton(hwndPifDlg, IDI_SEFIRST, IDI_SELAST,
 *		     (PifFile->MSflags & GRAPHMASK ? IDI_SEGRAPH : IDI_SETEXT));
 *	  }
 *
 *	  if (PifFile->MSflags & PSMASK) {
 *	     CheckRadioButton(hwndPifDlg, IDI_PSFIRST, IDI_PSLAST, IDI_PSNONE);
 *	  } else {
 *	     CheckRadioButton(hwndPifDlg, IDI_PSFIRST, IDI_PSLAST,
 *		     (PifFile->sysmem < 16 ? IDI_PSTEXT : IDI_PSGRAPH));
 *	  }
 */


    }
    return(TRUE);
}


BOOL UpdateParms(unsigned char *parmPtr)
{
    int cch;
    unsigned char *pch;
    BOOL result;

    result = FALSE;

    if (SendMessage(GetDlgItem(hwndPifDlg, IDI_EPARM), EM_GETMODIFY, 0, 0L))
	result = TRUE;

    cch = GetDlgItemText(hwndPifDlg, IDI_EPARM, (LPSTR)parmPtr, PIFPARAMSSIZE);
    AnsiToOem((LPSTR)parmPtr,(LPSTR)parmPtr);
    /*
     * Trim leading spaces
     */
    for (pch = parmPtr; *pch == ' '; pch=AnsiNext(pch))
	;
    lstrcpy((LPSTR)parmPtr, (LPSTR)pch);
    /*
     * Point to last char
     */
    for (pch = parmPtr; *pch; pch=AnsiNext(pch))
	;
    if (pch > parmPtr)
	pch =AnsiPrev(parmPtr,pch);
    /*
     * Trim trailing spaces
     */
    while (*pch == ' ' && pch > parmPtr)
	pch=AnsiPrev(parmPtr,pch);
    *++pch = 0;

    cch = pch - parmPtr;
    if(!CurrMode386) {
	if (cch) {
	    PifFile->sysflags |= PARMMASK;
	} else {
	    PifFile->sysflags &= NOTPARMMASK;
	}
    }
    if (cch) {
	pch++;
	cch++;
    }

    /*
     * Space pad out to full field width
     */
    for ( ; cch <PIFPARAMSSIZE; ++pch, ++cch)
	*pch = ' ';
    return(result);
}


void FixString(LPSTR lpstrIn)
{
    int   i;
    char  str[PIFDEFPATHSIZE*2];
    LPSTR lpstr;

    lpstr = lpstrIn;

    while(*lpstr == ' ')
        lpstr++;

    i = 0;
    while((*lpstr != '\0') && (*lpstr != ' ')) {
        str[i++] = *lpstr++;
    }

    str[i] = '\0';

    lstrcpy(lpstrIn, str);

    // don't Uppercase environment vars
    i = lstrlen(lpstrIn)-1;
    while(i > 0) {
        if(lpstrIn[i] == '%') {
            i++;
            break;
        }
        i--;
    }

    AnsiUpper(&(lpstrIn[i]));
}




BOOL UpdatePifNTStruc(void)
{
    BOOL result;
    char rgch[60];
    char szFile[PIFDEFPATHSIZE*2];

    result = FALSE;	/* did anything change? */

    if(hwndNTPifDlg) {
	if(!NTClose) {
	    if(!LoadString(hPifInstance, PIFDONESTRNG , (LPSTR)rgch, sizeof(rgch))) {
		Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	    } else {
		SetDlgItemText(hwndNTPifDlg,IDCANCEL,(LPSTR)rgch);
	    }
	    NTClose = TRUE;
	    if(FocusIDNT == IDCANCEL) {
		SetStatusText(hwndNTPifDlg,FocusIDNT,TRUE);
	    }
	}
	GetDlgItemText(hwndNTPifDlg,IDI_AUTOEXEC,szFile,PIFDEFPATHSIZE-1);
        FixString(szFile);
        AnsiToOem(szFile, szFile);
        if(lstrcmp((LPTSTR)PifNText->achAutoexecFile, (LPCTSTR)szFile)) {
            lstrcpy((LPTSTR)PifNText->achAutoexecFile, (LPCTSTR)szFile);
            fNoNTAWarn = FALSE;
            fNTAWarnne = FALSE;
            result = TRUE;
        }

	GetDlgItemText(hwndNTPifDlg,IDI_CONFIG,szFile,PIFDEFPATHSIZE-1);
        FixString(szFile);
        AnsiToOem(szFile, szFile);
        if(lstrcmp((LPTSTR)PifNText->achConfigFile, (LPCTSTR)szFile)) {
            lstrcpy((LPTSTR)PifNText->achConfigFile, (LPCTSTR)szFile);
            fNoNTCWarn = FALSE;
            fNTCWarnne = FALSE;
            result = TRUE;
        }

        // is checkbox checked?
        if(IsDlgButtonChecked(hwndNTPifDlg, IDI_NTTIMER)) {
            // if it wasn't, note the change
            if(!(PifNText->dwWNTFlags & COMPAT_TIMERTIC)) {
                result = TRUE;
            }
            PifNText->dwWNTFlags |= COMPAT_TIMERTIC; // mark it as checked
        }
        else {
            if(PifNText->dwWNTFlags & COMPAT_TIMERTIC) {
                result = TRUE;
            }
            PifNText->dwWNTFlags &= ~COMPAT_TIMERTIC;
        }

    }

    return(result);
}



BOOL UpdatePif386Struc(void)
{
    int result, i;
    unsigned int u;
    unsigned long W386flags;
    char rgch[60];
    BOOL iresult;

    result = FALSE;	/* did anything change? */


    if(UpdateParms((PUCHAR)Pif386ext->params))
	result = TRUE;

    /*
     *	Return of zero here ignored (set IDI_MEMREQ to 0)
     */
    ;
    if ((i = (int)GetDlgItemInt(hwndPifDlg, IDI_MEMREQ, (BOOL FAR *)&iresult, TRUE))
	!= Pif386ext->minmem) {
	if(iresult) {
	    result = TRUE;
	    Pif386ext->minmem = i;
	}
    }

    if ((i = (int)GetDlgItemInt(hwndPifDlg, IDI_MEMDES, (BOOL FAR *)&iresult, TRUE))
	!= Pif386ext->maxmem) {
	if(iresult) {
	    result = TRUE;
	    Pif386ext->maxmem = i;
	}
    }

    if(UpdateHotKeyStruc())
	result = TRUE;

    W386flags = Pif386ext->PfW386Flags;

    if (IsDlgButtonChecked(hwndPifDlg, IDI_FSCR))
	W386flags |= fFullScreen;
    else
	W386flags &= ~fFullScreen;

    if (IsDlgButtonChecked(hwndPifDlg, IDI_EXCL))
	W386flags |= fExclusive;
    else
	W386flags &= ~fExclusive;

    if (IsDlgButtonChecked(hwndPifDlg, IDI_BACK))
	W386flags |= fBackground;
    else
	W386flags &= ~fBackground;

    if ((u = GetDlgItemInt(hwndPifDlg, IDI_EMSREQ, (BOOL FAR *)&iresult, FALSE))
	!= (UINT)Pif386ext->PfMinEMMK) {
	if(iresult) {
	    result = TRUE;
	    Pif386ext->PfMinEMMK = u;
	}
    }

    if ((i = (int)GetDlgItemInt(hwndPifDlg, IDI_EMSDES, (BOOL FAR *)&iresult, TRUE))
	!= Pif386ext->PfMaxEMMK) {
	if(iresult) {
	    result = TRUE;
	    Pif386ext->PfMaxEMMK = i;
	}
    }

    if ((u = GetDlgItemInt(hwndPifDlg, IDI_XMAREQ, (BOOL FAR *)&iresult, FALSE))
	!= (UINT)Pif386ext->PfMinXmsK) {
	if(iresult) {
	    result = TRUE;
	    Pif386ext->PfMinXmsK = u;
	}
    }

    if ((i = (int)GetDlgItemInt(hwndPifDlg, IDI_XMADES, (BOOL FAR *)&iresult, TRUE))
	!= Pif386ext->PfMaxXmsK) {
	if(iresult) {
	    result = TRUE;
	    Pif386ext->PfMaxXmsK = i;
	}
    }

    if(hwndAdvPifDlg) {
	if(!AdvClose) {
	    if(!LoadString(hPifInstance, PIFDONESTRNG , (LPSTR)rgch, sizeof(rgch))) {
		Warning(EINSMEMORY,MB_ICONEXCLAMATION | MB_OK);
	    } else {
		SetDlgItemText(hwndAdvPifDlg,IDCANCEL,(LPSTR)rgch);
	    }
	    AdvClose = TRUE;
	    if(FocusIDAdv == IDCANCEL) {
		SetStatusText(hwndAdvPifDlg,FocusIDAdv,TRUE);
	    }
	}

	if ((u = GetDlgItemInt(hwndAdvPifDlg, IDI_FPRI, (BOOL FAR *)&iresult, FALSE))
	    != (UINT)Pif386ext->PfFPriority) {
	    if(iresult) {
		result = TRUE;
		Pif386ext->PfFPriority = u;
	    }
	}

	if ((u = GetDlgItemInt(hwndAdvPifDlg, IDI_BPRI, (BOOL FAR *)&iresult, FALSE))
	    != (UINT)Pif386ext->PfBPriority) {
	    if(iresult) {
		result = TRUE;
		Pif386ext->PfBPriority = u;
	    }
	}

	if (IsDlgButtonChecked(hwndAdvPifDlg, IDI_POLL))
	    W386flags |= fPollingDetect;
	else
	    W386flags &= ~fPollingDetect;

	if (IsDlgButtonChecked(hwndAdvPifDlg, IDI_ALTTAB))
	    W386flags |= fALTTABdis;
	else
	    W386flags &= ~fALTTABdis;

	if (IsDlgButtonChecked(hwndAdvPifDlg, IDI_ALTESC))
	    W386flags |= fALTESCdis;
	else
	    W386flags &= ~fALTESCdis;

	if (IsDlgButtonChecked(hwndAdvPifDlg, IDI_CTRLESC))
	    W386flags |= fCTRLESCdis;
	else
	    W386flags &= ~fCTRLESCdis;

	if (IsDlgButtonChecked(hwndAdvPifDlg, IDI_ALTSPACE))
	    W386flags |= fALTSPACEdis;
	else
	    W386flags &= ~fALTSPACEdis;

	if (IsDlgButtonChecked(hwndAdvPifDlg, IDI_ALTENTER))
	    W386flags |= fALTENTERdis;
	else
	    W386flags &= ~fALTENTERdis;

	if (IsDlgButtonChecked(hwndAdvPifDlg, IDI_ALTPRTSC))
	    W386flags |= fALTPRTSCdis;
	else
	    W386flags &= ~fALTPRTSCdis;

	if (IsDlgButtonChecked(hwndAdvPifDlg, IDI_PRTSC))
	    W386flags |= fPRTSCdis;
	else
	    W386flags &= ~fPRTSCdis;

	if (IsDlgButtonChecked(hwndAdvPifDlg, IDI_NOHMA))
	    W386flags &= ~fNoHMA;
	else
	    W386flags |= fNoHMA;

	if (IsDlgButtonChecked(hwndAdvPifDlg, IDI_INT16PST))
	    W386flags |= fINT16Paste;
	else
	    W386flags &= ~fINT16Paste;

	if (IsDlgButtonChecked(hwndAdvPifDlg, IDI_VMLOCKED))
	    W386flags |= fVMLocked;
	else
	    W386flags &= ~fVMLocked;

	if (IsDlgButtonChecked(hwndAdvPifDlg, IDI_CLOSE))
	    W386flags |= fEnableClose;
	else
	    W386flags &= ~fEnableClose;

	if (IsDlgButtonChecked(hwndAdvPifDlg, IDI_EMSLOCKED))
	    W386flags |= fEMSLocked;
	else
	    W386flags &= ~fEMSLocked;

	if (IsDlgButtonChecked(hwndAdvPifDlg, IDI_XMSLOCKED))
	    W386flags |= fXMSLocked;
	else
	    W386flags &= ~fXMSLocked;
    }

    if((Pif386ext->PfHotKeyScan != 0)||(Pif386ext->PfHotKeyShVal != 0)||(Pif386ext->PfHotKeyShMsk != 0))
	W386flags |= fHasHotKey;
    else
	W386flags &= ~fHasHotKey;

    if (W386flags != Pif386ext->PfW386Flags) {
	Pif386ext->PfW386Flags = W386flags;
	result = TRUE;
    }

    W386flags = Pif386ext->PfW386Flags2;

    W386flags &= ~(fVidTextMd | fVidLowRsGrfxMd | fVidHghRsGrfxMd);

    if (IsDlgButtonChecked(hwndPifDlg, IDI_VMODETXT))
	W386flags |= fVidTextMd;
    else if (IsDlgButtonChecked(hwndPifDlg, IDI_VMODELRGRFX))
	W386flags |= fVidLowRsGrfxMd;
    else
	W386flags |= fVidHghRsGrfxMd;

    if(hwndAdvPifDlg) {

	if (IsDlgButtonChecked(hwndAdvPifDlg, IDI_RETAINALLO))
	    W386flags |= fVidRetainAllo;
	else
	    W386flags &= ~fVidRetainAllo;

	if (IsDlgButtonChecked(hwndAdvPifDlg, IDI_TEXTEMULATE))
	    W386flags |= fVidTxtEmulate;
	else
	    W386flags &= ~fVidTxtEmulate;

	if (IsDlgButtonChecked(hwndAdvPifDlg, IDI_TRAPTXT))
	    W386flags &= ~fVidNoTrpTxt;
	else
	    W386flags |= fVidNoTrpTxt;

	if (IsDlgButtonChecked(hwndAdvPifDlg, IDI_TRAPLRGRFX))
	    W386flags &= ~fVidNoTrpLRGrfx;
	else
	    W386flags |= fVidNoTrpLRGrfx;

	if (IsDlgButtonChecked(hwndAdvPifDlg, IDI_TRAPHRGRFX))
	    W386flags &= ~fVidNoTrpHRGrfx;
	else
	    W386flags |= fVidNoTrpHRGrfx;

    }
    if (W386flags != Pif386ext->PfW386Flags2) {
	Pif386ext->PfW386Flags2 = W386flags;
	result = TRUE;
    }

    return(result);
}

/* make the structure match the screen */
BOOL UpdatePifStruct(void)
{
    unsigned char rgch[200];
    int cch;
    unsigned char *pch;
    char flags;
    unsigned flags2;
    int result;
    BOOL iresult;
    int i;
    unsigned int u;

    result = FALSE;	/* did anything change? */

    if (SendMessage(GetDlgItem(hwndPifDlg, IDI_ENAME), EM_GETMODIFY, 0, 0L))
	result = TRUE;
    cch = GetDlgItemText(hwndPifDlg, IDI_ENAME, (LPSTR)PifFile->startfile, PIFSTARTLOCSIZE);
    AnsiUpper((LPSTR)PifFile->startfile);
    AnsiToOem((LPSTR)PifFile->startfile,(LPSTR)PifFile->startfile);
    /*
     * Trim off leading spaces
     */
    for (pch = (PUCHAR)PifFile->startfile; *pch == ' '; pch=(PUCHAR)AnsiNext((LPCTSTR)pch))
	;
    lstrcpy((LPTSTR)PifFile->startfile, (LPCTSTR)pch);
    /*
     * Point to last char of string
     */
    for (pch = (PUCHAR)PifFile->startfile; *pch; pch=(PUCHAR)AnsiNext((LPCTSTR)pch))
	;
    if (pch > PifFile->startfile)
	pch=(PUCHAR)AnsiPrev((LPCTSTR)PifFile->startfile,(LPCTSTR)pch);
    /*
     * Trim trailing spaces
     */
    while (*pch == ' ' && pch > PifFile->startfile)
	pch=(PUCHAR)AnsiPrev((LPCTSTR)PifFile->startfile,(LPCTSTR)pch);
    pch=AnsiNext(pch);
    *pch++ = 0;
    /*
     * Space pad out to full field width
     */
    for (cch = pch - PifFile->startfile;  cch < PIFSTARTLOCSIZE; ++cch)
	*pch++ = ' ';
    if (SendMessage(GetDlgItem(hwndPifDlg, IDI_ETITLE), EM_GETMODIFY, 0, 0L))
	result = TRUE;
    cch = GetDlgItemText(hwndPifDlg, IDI_ETITLE, (LPSTR)rgch, PIFNAMESIZE+1);
    AnsiToOem((LPSTR)rgch,(LPSTR)rgch);
    /*
     * NOTE: the PifFile->name field will NOT be nul terminated if it is
     *	      PIFNAMESIZE bytes long
     *
     * Trim off leading spaces
     */
    for (pch = rgch; *pch == ' '; pch=AnsiNext(pch))
	;
    lstrcpy((LPSTR)rgch, (LPSTR)pch);
    /*
     * Point to last char of string
     */
    for (pch = rgch; *pch; pch=AnsiNext(pch))
	;
    if (pch > rgch)
	pch =AnsiPrev(rgch,pch);
    /*
     * Trim trailing spaces
     */
    while (*pch == ' ' && pch > rgch)
	pch=AnsiPrev(rgch,pch);
    pch=AnsiNext(pch);
    *pch++ = '\0';
    /*
     * Space pad out to full field width
     */
    for (cch = pch - rgch;  cch < PIFNAMESIZE; ++cch)
	*pch++ = ' ';
    for(i = 0;i < PIFNAMESIZE; i++)
	PifFile->name[i] = rgch[i];
    if (SendMessage(GetDlgItem(hwndPifDlg, IDI_EPATH), EM_GETMODIFY, 0, 0L))
	result = TRUE;
    cch = GetDlgItemText(hwndPifDlg, IDI_EPATH, (LPSTR)PifFile->defpath, PIFDEFPATHSIZE-1);
    AnsiUpper((LPSTR)PifFile->defpath);
    AnsiToOem((LPSTR)PifFile->defpath,(LPSTR)PifFile->defpath);
    /*
     * Trim off leading spaces
     */
    for (pch = (PUCHAR)PifFile->defpath;*pch == ' '; pch=(PUCHAR)AnsiNext((LPCTSTR)pch))
	;
    lstrcpy((LPSTR)PifFile->defpath, (LPSTR)pch);
    /*
     * Point to last char of string
     */
    for (pch = (PUCHAR)PifFile->defpath; *pch; pch=(PUCHAR)AnsiNext((LPCTSTR)pch))
	;
    if (pch > PifFile->defpath)
	pch = (PUCHAR)AnsiPrev((LPCTSTR)PifFile->defpath,(LPCTSTR)pch);
    /*
     * Trim trailing spaces
     */
    while (*pch == ' ' && pch > PifFile->defpath)
	pch = (PUCHAR)AnsiPrev((LPCTSTR)PifFile->defpath,(LPCTSTR)pch);
    pch = (PUCHAR)AnsiNext((LPCTSTR)pch);
    *pch++ = 0;
    /*
     * Space pad out to full field width
     */
    for (cch = pch - PifFile->defpath;	cch < PIFDEFPATHSIZE; ++cch)
	*pch++ = ' ';

    flags = PifFile->MSflags;

    if (IsDlgButtonChecked(hwndPifDlg, IDI_EXIT))
	flags |= EXITMASK;
    else
	flags &= NOTEXITMASK;

    if(CurrMode386) {
	if(UpdatePif386Struc())
	    result = TRUE;
	if(UpdatePifNTStruc())
	    result = TRUE;
    } else {
	if(UpdateParms((PUCHAR)PifFile->params))
	    result = TRUE;

	/*
	 *  Return of zero here ignored (set IDI_MEMREQ to 0)
	 */
	if ((i = (int)GetDlgItemInt(hwndPifDlg, IDI_MEMREQ, (BOOL FAR *)&iresult, TRUE))
	    != PifFile->minmem) {
	    if(iresult) {
		result = TRUE;
		PifFile->minmem = i;
	    }
	}

     /*
      *  if ((i = (int)GetDlgItemInt(hwndPifDlg, IDI_MEMDES, (BOOL FAR *)&iresult, TRUE))
      *      != PifFile->maxmem) {
      *      if(iresult) {
      * 	 result = TRUE;
      * 	 PifFile->maxmem = i;
      *      }
      *  }
      */

	if (IsDlgButtonChecked(hwndPifDlg, IDI_PSNONE)) {
	    flags |= PSMASK;
	} else {
	    flags &= NOTPSMASK;
	}

	if (IsDlgButtonChecked(hwndPifDlg, IDI_SENONE)) {
	    flags |= SGMASK;	  /* disable screen grabber */
	} else {
	    flags &= NOTSGMASK;
	}

	if (IsDlgButtonChecked(hwndPifDlg, IDI_PSTEXT) ) {
	    if (PifFile->sysmem >= 16)
		PifFile->sysmem = 7;
	    flags &= TEXTMASK;
	} else {
	    if (PifFile->sysmem < 16)
		PifFile->sysmem = 23;
	    flags |= GRAPHMASK;
	}

/*
 *	 if (IsDlgButtonChecked(hwndPifDlg, IDI_PSNONE)) {
 *	     flags |= PSMASK;
 *	 } else {
 *	     flags &= NOTPSMASK;
 *	     if ((IsDlgButtonChecked(hwndPifDlg, IDI_PSTEXT)) && (PifFile->sysmem >= 16))
 *		 PifFile->sysmem = 7;
 *	     else if ((IsDlgButtonChecked(hwndPifDlg, IDI_PSGRAPH)) && (PifFile->sysmem < 16) )
 *		 PifFile->sysmem = 23;
 *	 }
 *
 *	 if (IsDlgButtonChecked(hwndPifDlg, IDI_SENONE)) {
 *	     flags |= SGMASK;
 *	 } else if (IsDlgButtonChecked(hwndPifDlg, IDI_SETEXT)) {
 *	     flags &= TEXTMASK;
 *	     flags &= NOTSGMASK;
 *	 } else if (IsDlgButtonChecked(hwndPifDlg, IDI_SEGRAPH)) {
 *	     flags |= GRAPHMASK;
 *	     flags &= NOTSGMASK;
 *	 }
 *
 *	 if (IsDlgButtonChecked(hwndPifDlg, IDI_DMSCREEN)) {
 *	     if (!(PifFile->behavior & SCRMASK))
 *		 result = TRUE;
 *	     PifFile->behavior |= SCRMASK;
 *	 } else {
 *	     if (PifFile->behavior & SCRMASK)
 *		 result = TRUE;
 *	     PifFile->behavior &= NOTSCRMASK;
 *	 }
 *
 *	 if (IsDlgButtonChecked(hwndPifDlg, IDI_DMMEM))
 *	     flags |= MEMMASK;
 *	 else
 *	     flags &= NOTMEMMASK;
 */

	if (IsDlgButtonChecked(hwndPifDlg, IDI_DMKBD)) {
	    if (!(PifFile->behavior & KEYMASK))
		result = TRUE;
	    PifFile->behavior |= KEYMASK;
	} else {
	    if (PifFile->behavior & KEYMASK)
		result = TRUE;
	    PifFile->behavior &= NOTKEYMASK;
	}

	if (IsDlgButtonChecked(hwndPifDlg, IDI_DMCOM1))
	    flags |= COM1MASK;
	else
	    flags &= NOTCOM1MASK;

	if (IsDlgButtonChecked(hwndPifDlg, IDI_DMCOM2))
	    flags |= COM2MASK;
	else
	    flags &= NOTCOM2MASK;

	if(Pif286ext30) {

	    flags2 = 0;

	    if (IsDlgButtonChecked(hwndPifDlg, IDI_NOSAVVID))
		flags2 |= fNoSaveVid286;
	    else
		flags2 &= ~fNoSaveVid286;

	    if (IsDlgButtonChecked(hwndPifDlg, IDI_DMCOM3))
		flags2 |= fCOM3_286;
	    else
		flags2 &= ~fCOM3_286;

	    if (IsDlgButtonChecked(hwndPifDlg, IDI_DMCOM4))
		flags2 |= fCOM4_286;
	    else
		flags2 &= ~fCOM4_286;

	    if (IsDlgButtonChecked(hwndPifDlg, IDI_ALTTAB))
		flags2 |= fALTTABdis286;
	    else
		flags2 &= ~fALTTABdis286;

	    if (IsDlgButtonChecked(hwndPifDlg, IDI_ALTESC))
		flags2 |= fALTESCdis286;
	    else
		flags2 &= ~fALTESCdis286;

	    if (IsDlgButtonChecked(hwndPifDlg, IDI_CTRLESC))
		flags2 |= fCTRLESCdis286;
	    else
		flags2 &= ~fCTRLESCdis286;

	    if (IsDlgButtonChecked(hwndPifDlg, IDI_ALTPRTSC))
		flags2 |= fALTPRTSCdis286;
	    else
		flags2 &= ~fALTPRTSCdis286;

	    if (IsDlgButtonChecked(hwndPifDlg, IDI_PRTSC))
		flags2 |= fPRTSCdis286;
	    else
		flags2 &= ~fPRTSCdis286;

	    if ((u = GetDlgItemInt(hwndPifDlg, IDI_XMAREQ, (BOOL FAR *)&iresult, FALSE))
		!= (UINT)Pif286ext30->PfMinXmsK) {
		if(iresult) {
		    result = TRUE;
		    Pif286ext30->PfMinXmsK = u;
		}
	    }

	    if ((i = (int)GetDlgItemInt(hwndPifDlg, IDI_XMADES, (BOOL FAR *)&iresult, TRUE))
		!= Pif286ext30->PfMaxXmsK) {
		if(iresult) {
		    result = TRUE;
		    Pif286ext30->PfMaxXmsK = i;
		}
	    }
	    if (flags2 != (unsigned)Pif286ext30->PfW286Flags) {
		Pif286ext30->PfW286Flags = flags2;
		result = TRUE;
	    }
	}
	/*
	 * if(Pif286ext31) {
	 *
	 *     if ((u = GetDlgItemInt(hwndPifDlg, IDI_EMSREQ, (BOOL FAR *)&iresult, FALSE))
	 *	   != Pif286ext31->PfMinEmsK) {
	 *	   if(iresult) {
	 *	       result = TRUE;
	 *	       Pif286ext31->PfMinEmsK = u;
	 *	   }
	 *     }
	 *
	 *     if ((i = (int)GetDlgItemInt(hwndPifDlg, IDI_EMSDES, (BOOL FAR *)&iresult, TRUE))
	 *	   != Pif286ext31->PfMaxEmsK) {
	 *	   if(iresult) {
	 *	       result = TRUE;
	 *	       Pif286ext31->PfMaxEmsK = i;
	 *	   }
	 *     }
	 * }
	 */
    }
    if (flags != PifFile->MSflags) {
	PifFile->MSflags = flags;
	result = TRUE;
    }
    return(result);
}

BOOL DoFieldsWorkAdv(BOOL all)
{
    BOOL result;
    BOOL result2;


    /*
     *	Check to make sure numeric edit controls actually have numbers in them
     */
    if(hwndAdvPifDlg) {
	GetDlgItemInt(hwndAdvPifDlg, IDI_BPRI, (BOOL FAR *)&result, FALSE);
	GetDlgItemInt(hwndAdvPifDlg, IDI_FPRI, (BOOL FAR *)&result2, FALSE);
	if((!result) || (!result2)) {
	    Warning(errBadNumberP,MB_ICONEXCLAMATION | MB_OK);
	    return(FALSE);
	}
    }
    if (Pif386ext && CurrMode386) {
	if ((Pif386ext->PfMaxEMMK > 0) && ((int)Pif386ext->PfMinEMMK > Pif386ext->PfMaxEMMK)) {
	    Warning(errEMMMaxMin386,MB_ICONEXCLAMATION | MB_OK);
	    return(FALSE);
	}

	if ((Pif386ext->PfMaxXmsK > 0) && ((int)Pif386ext->PfMinXmsK > Pif386ext->PfMaxXmsK)) {
	    Warning(errXMSMaxMin386,MB_ICONEXCLAMATION | MB_OK);
	    return(FALSE);
	}
    }
    return(TRUE);
}



void SetNTDlgItem(int itemID)
{
    HWND  hwnd;
    SetStatusText(hwndNTPifDlg, itemID, TRUE);
    hwnd = GetDlgItem(hwndNTPifDlg, itemID);
    SetFocus(hwnd);
    SendMessage(hwnd, EM_SETSEL,0,-1);
}



BOOL DoFieldsWorkNT(BOOL all)
{
    UCHAR    szFile[PIFDEFPATHSIZE*2];
    UCHAR    szFileExp[PIFDEFPATHSIZE*4];
    OFSTRUCT of;


    /*
     *	Check to make sure Autoexec & Config fields have valid filenames in them
     */
    if(hwndNTPifDlg) {

	if(!GetDlgItemText(hwndNTPifDlg,IDI_AUTOEXEC,szFile,PIFDEFPATHSIZE-1)) {
            if(!fNoNTAWarn) {
	        if(Warning(errNoNTAFile,
                           MB_ICONEXCLAMATION | MB_OKCANCEL | MB_DEFBUTTON2)
                           == IDCANCEL) {
                    SetNTDlgItem(IDI_AUTOEXEC);
                    return(FALSE);
                }
                else
                    fNoNTAWarn = TRUE;
            }
	}
        else {
            if(ExpandFileSpec(szFileExp, szFile, errBadAutoPath)) {
                if(OpenFile(szFileExp,&of,OF_EXIST) == HFILE_ERROR) {
                    if(!fNTAWarnne){
	                if(Warning(errNTAFilene, MB_ICONEXCLAMATION |
                                                 MB_OKCANCEL        |
                                                 MB_DEFBUTTON2) == IDCANCEL) {
                            SetNTDlgItem(IDI_AUTOEXEC);
                            return(FALSE);
                        }
                        else
                            fNTAWarnne = TRUE;
                    }
                }
            }
            else {
                SetNTDlgItem(IDI_AUTOEXEC);
                return(FALSE);
            }
        }

	if(!GetDlgItemText(hwndNTPifDlg,IDI_CONFIG,szFile,PIFDEFPATHSIZE-1)) {
            if(!fNoNTCWarn) {
	        if(Warning(errNoNTCFile,
                           MB_ICONEXCLAMATION | MB_OKCANCEL | MB_DEFBUTTON2)
                           == IDCANCEL) {
                    SetNTDlgItem(IDI_CONFIG);
                    return(FALSE);
                }
                else
                    fNoNTCWarn = TRUE;
            }
	}
        else {
            if(ExpandFileSpec(szFileExp, szFile, errBadConfigPath)) {
                if(OpenFile(szFileExp,&of,OF_EXIST) == HFILE_ERROR) {
                    if(!fNTCWarnne){
	                if(Warning(errNTCFilene, MB_ICONEXCLAMATION |
                                                 MB_OKCANCEL        |
                                                 MB_DEFBUTTON2)  == IDCANCEL) {
                            SetNTDlgItem(IDI_CONFIG);
                            return(FALSE);
                        }
                        else
                            fNTCWarnne = TRUE;
                    }
                }
            }
            else {
                SetNTDlgItem(IDI_CONFIG);
                return(FALSE);
            }
        }
    }
    return(TRUE);
}


BOOL DoFieldsWork(BOOL all)
{
    BOOL result;
    BOOL result2;

    if(!DoFieldsWorkAdv(all))
	return(FALSE);

    if(!DoFieldsWorkNT(all))
	return(FALSE);

    /*
     *	Check to make sure numeric edit controls actually have numbers in them
     */
    if(hwndPifDlg) {
	if(CurrMode386) {
	    GetDlgItemInt(hwndPifDlg, IDI_MEMDES, (BOOL FAR *)&result, TRUE);
	} else {
	    result = TRUE;
	}
	GetDlgItemInt(hwndPifDlg, IDI_MEMREQ, (BOOL FAR *)&result2, TRUE);
	if(!result2) {
	    Warning(errBadNumberMR,MB_ICONEXCLAMATION | MB_OK);
	    return(FALSE);
	}
	if(!result) {
	    Warning(errBadNumberMD,MB_ICONEXCLAMATION | MB_OK);
	    return(FALSE);
	}
	GetDlgItemInt(hwndPifDlg, IDI_XMADES, (BOOL FAR *)&result, TRUE);
	GetDlgItemInt(hwndPifDlg, IDI_XMAREQ, (BOOL FAR *)&result2, FALSE);
	if(!result2) {
	    Warning(errBadNumberXEMSR,MB_ICONEXCLAMATION | MB_OK);
	    return(FALSE);
	}
	if(!result) {
	    Warning(errBadNumberXEMSD,MB_ICONEXCLAMATION | MB_OK);
	    return(FALSE);
	}
	if(CurrMode386) {
	    GetDlgItemInt(hwndPifDlg, IDI_EMSDES, (BOOL FAR *)&result, TRUE);
	    GetDlgItemInt(hwndPifDlg, IDI_EMSREQ, (BOOL FAR *)&result2, FALSE);
	    if(!result2) {
		Warning(errBadNumberXEMSR,MB_ICONEXCLAMATION | MB_OK);
		return(FALSE);
	    }
	    if(!result) {
		Warning(errBadNumberXEMSD,MB_ICONEXCLAMATION | MB_OK);
		return(FALSE);
	    }
	} else {
	}
    }

    if (Pif386ext && CurrMode386) {
	if ((Pif386ext->maxmem > 0) &&
            ((Pif386ext->minmem == -1) || (Pif386ext->minmem > Pif386ext->maxmem))
           ) {
	    Warning(errMmMaxMin386,MB_ICONEXCLAMATION | MB_OK);
	    return(FALSE);
	}
    }

    if ((PifFile->maxmem > 0) &&
        ((PifFile->minmem == -1) || (PifFile->minmem > PifFile->maxmem))
       ) {
     /*
      *  Warning(errMmMaxMin286,MB_ICONEXCLAMATION | MB_OK);
      *  return(FALSE);
      */
	PifFile->maxmem = PifFile->minmem;
    }

    if (Pif286ext30) {
	if ((Pif286ext30->PfMaxXmsK > 0) && ((int)Pif286ext30->PfMinXmsK > Pif286ext30->PfMaxXmsK)) {
	    Warning(errXMSMaxMin286,MB_ICONEXCLAMATION | MB_OK);
	    return(FALSE);
	}
    }
    /*
     * if (Pif286ext31) {
     *	   if ((Pif286ext31->PfMaxEmsK > 0) && ((int)Pif286ext31->PfMinEmsK > Pif286ext31->PfMaxEmsK)) {
     *	       Warning(errEMMMaxMin286,MB_ICONEXCLAMATION | MB_OK);
     *	       return(FALSE);
     *	   }
     * }
     */

    if(all) {
	if (PifFile->lowVector > PifFile->highVector && (PifFile->sysflags & SWAPMASK)) {
	    Warning(errHiLow,MB_ICONEXCLAMATION | MB_OK);
	    return(FALSE);
	}

        if(!ValidFileSpec((LPSTR)PifFile->startfile, errBadProgram))
            return(FALSE);

    }
    return(TRUE);
}



BOOL ExpandFileSpec(LPSTR lpstrExp, LPSTR lpstr, int errID)
{
    int   len, cPath;
    UCHAR sz[PIFDEFPATHSIZE*2];
    LPSTR psz;

    if(!ValidFileSpec(lpstr, errID)) {
        return(FALSE);
    }

    cPath = PIFDEFPATHSIZE * 2;
    while(*lpstr) {

        if(*lpstr == '%') {
            lpstr++;
            lstrcpy(sz, lpstr);
            psz = &sz[0];
            while(*psz && (*psz != '%')) {
                psz++;
            }
            if(*psz != '%') {
                Warning(errID, MB_ICONEXCLAMATION | MB_OK | MB_DEFBUTTON2);
                return(FALSE);
            }
            len = psz - &sz[0];
            sz[len] = '\0';
            lpstr += len + 1;
            if(len = GetEnvironmentVariable(sz, lpstrExp, cPath)) {
                cPath    -= len;
                if(cPath <= 0) {
                    Warning(errID, MB_ICONEXCLAMATION | MB_OK | MB_DEFBUTTON2);
                    return(FALSE);
                }
                lpstrExp += len;
            }
            else {
                Warning(errID, MB_ICONEXCLAMATION | MB_OK | MB_DEFBUTTON2);
                return(FALSE);
            }
        }
        else {
            *lpstrExp++ = *lpstr++;
            cPath--;
        }
        if(cPath <= 0) {
            Warning(errID, MB_ICONEXCLAMATION | MB_OK | MB_DEFBUTTON2);
            return(FALSE);
        }
    }

    *lpstrExp = '\0';

    return(TRUE);
}



BOOL ValidFileSpec(LPSTR lpstr, int iCaller)
{
    int   len;
    LPSTR pch, pch2;
    int   errID;
    BOOL  fExt = FALSE;

    switch( iCaller ) {

    case errBadAutoPath:
        errID = errBadAutoName;
        break;

    case errBadConfigPath:
        errID = errBadConName;
        break;

    default:
        fExt = TRUE;
        errID = errBadProgram;
        break;
    }


    len = lstrlen((LPSTR)lpstr);
    pch = lpstr + len;
    pch = AnsiPrev(lpstr,pch);
    while (*pch        &&
           *pch != ':'  &&
           *pch != '.'  &&
           *pch != '\\' &&
           pch > lpstr)
        pch=AnsiPrev(lpstr,pch);

    if (*pch != '.') {
        if(fExt) {
            if(Warning(errBadExt,MB_ICONEXCLAMATION|MB_OKCANCEL|MB_DEFBUTTON2)
                         == IDCANCEL)
                return(FALSE);
        }

        /*
         * No extension given, reset pch to end of the string so
         * following 8 char name check doesn't trip as well unless
         * it is supposed to.
         */
        pch = lpstr + len;
    }
    else if(fExt){
        /*
         * At this point we know *pch == '.'
         */
        if (lstrcmp((LPSTR)(pch+1), (LPSTR)"EXE") &&
            lstrcmp((LPSTR)(pch+1), (LPSTR)"COM") &&
            lstrcmp((LPSTR)(pch+1), (LPSTR)"BAT")) {

            if(Warning(errBadExt,MB_ICONEXCLAMATION|MB_OKCANCEL|MB_DEFBUTTON2)
                         == IDCANCEL)
                return(FALSE);
        }
    }

    if(pch <= lpstr) {
        if(Warning(errID, MB_ICONEXCLAMATION | MB_OKCANCEL | MB_DEFBUTTON2)
                     == IDCANCEL)
        return(FALSE);
    }
    else {
        for (pch2 = AnsiPrev(lpstr,pch);
             pch2 > lpstr && *pch2 != '\\' && *pch2 != ':';
             pch2 = AnsiPrev(lpstr,pch2)) {

            if(*pch2 <  ' ' ||
               *pch2 == '*' ||
               *pch2 == '?' ||
               *pch2 == '[' ||
               *pch2 == ']' ||
               *pch2 == '>' ||
               *pch2 == '<' ||
               *pch2 == '|' ||
               *pch2 == '"' ||
               *pch2 == '=' ||
               *pch2 == '+' ||
               *pch2 == ';' ||
               *pch2 == ',' ||
               *pch2 == '.' ) {

                if(Warning(errID,
                           MB_ICONEXCLAMATION | MB_OKCANCEL | MB_DEFBUTTON2)
                                   == IDCANCEL)
                    return(FALSE);
                else
                    break; /* from for loop */
            }
        }

        if((*pch2 == '\\') || (*pch2 == ':'))
            pch2=AnsiNext(pch2);

        if (pch - pch2 > 8 || pch - pch2 == 0) {
            if(Warning(errID,MB_ICONEXCLAMATION | MB_OKCANCEL | MB_DEFBUTTON2) == IDCANCEL)
                return(FALSE);
        }
    }

    return(TRUE);
}



ResetStd(void)
{
    InitStdPIFExt();
    InitPif386Struc();
    InitPif286Struc();
    InitPifNTStruc();
    return(TRUE);
}


LoadPifFile(PSTR pchFile)
{
    int fh;
    unsigned char *pch;
    OFSTRUCT ofReopen;
    unsigned long fsize;
    PIFEXTHEADER UNALIGNED *hdrptr;
    BOOL scandone;
    BOOL Pif2X = FALSE;

    ofReopen.szPathName[0] = 0;
    if ((fh = OpenFile((LPSTR)pchFile, (LPOFSTRUCT)&ofReopen, OF_READ | OF_SHARE_DENY_WRITE)) != -1) {

	fsize = _llseek( fh, 0L, 2);
	_llseek( fh, 0L, 0);

	if(fsize >= PIFEDITMAXPIFL) {
	    Warning(errNoOpen,MB_ICONEXCLAMATION | MB_OK);
	    InitPifStruct();
	    _lclose(fh);
	    return(FALSE);
	}

	_lread(fh, (LPSTR)PifBuf, PIFEDITMAXPIF);

	FileChanged = FALSE;

	Pif386ext = (PIF386EXT *)NULL;
	PifNText  = (PIFWNTEXT *)NULL;
	Pif286ext30 = (PIF286EXT30 *)NULL;
	/*
	 * Pif286ext31 = (PIF286EXT31 *)NULL;
	 */

	PifFileSize = LOWORD(fsize);

	if(fsize < (long)sizeof(PIFOLD286STR)) {
	    Warning(PIFBADFIL,MB_ICONEXCLAMATION | MB_OK);
	    ResetStd();
	    FileChanged = TRUE;
	} else if(fsize == (long)sizeof(PIFOLD286STR)) {
	    Warning(PIFOLDFIL,MB_ICONEXCLAMATION | MB_OK);
	    Pif2X = TRUE;
	    ResetStd();
	    FileChanged = TRUE;
	    if(Pif386ext) {
		Pif386ext->PfHotKeyScan = InMemHotKeyScan = 0;
		Pif386ext->PfHotKeyShVal = InMemHotKeyShVal = 0;
		Pif386ext->PfHotKeyShMsk = InMemHotKeyShMsk = 0;
		if (PifFile->behavior & KEYMASK)
		    Pif386ext->PfW386Flags |= fExclusive;
		else
		    Pif386ext->PfW386Flags &= ~fExclusive;
		if (PifFile->MSflags  & MEMMASK)
		    Pif386ext->PfW386Flags |= fBackground;
		else
		    Pif386ext->PfW386Flags &= ~fBackground;
		if (PifFile->behavior & SCRMASK)
		    Pif386ext->PfW386Flags |= fFullScreen;
		else
		    Pif386ext->PfW386Flags &= ~fFullScreen;
		Pif386ext->maxmem = PifFile->maxmem;
		Pif386ext->minmem = PifFile->minmem;
	    }
	    if(Pif286ext30) {
		Pif286ext30->PfMaxXmsK = 0;
		Pif286ext30->PfMinXmsK = 0;
		Pif286ext30->PfW286Flags = 0;
		if(Pif386ext) {
		    if(Pif386ext->PfW386Flags & fALTTABdis)
			Pif286ext30->PfW286Flags |= fALTTABdis286;
		    if(Pif386ext->PfW386Flags & fALTESCdis)
			Pif286ext30->PfW286Flags |= fALTESCdis286;
		    if(Pif386ext->PfW386Flags & fCTRLESCdis)
			Pif286ext30->PfW286Flags |= fCTRLESCdis286;
		    if(Pif386ext->PfW386Flags & fALTPRTSCdis)
			Pif286ext30->PfW286Flags |= fALTPRTSCdis286;
		    if(Pif386ext->PfW386Flags & fPRTSCdis)
			Pif286ext30->PfW286Flags |= fPRTSCdis286;
		}
	    }
	    /*
	     * if(Pif286ext31) {
	     *	   Pif286ext31->PfMaxEmsK = 0;
	     *	   Pif286ext31->PfMinEmsK = 0;
	     * }
	     */
	} else {
	    if(lstrcmp((LPSTR)PifFile->stdpifext.extsig, (LPSTR)stdHdr)) {
		Warning(PIFBADFIL,MB_ICONEXCLAMATION | MB_OK);
		ResetStd();
		FileChanged = TRUE;
	    } else {
		hdrptr = &PifFile->stdpifext;
		scandone = FALSE;
		while(!scandone) {
		    if(hdrptr->extnxthdrfloff == LASTHEADERPTR) {
			scandone = TRUE;
			LastPifExt = hdrptr;
		    } else if((unsigned)hdrptr->extnxthdrfloff >= PifFileSize) {
			Warning(PIFBADFIL,MB_ICONEXCLAMATION | MB_OK);
			ResetStd();
			FileChanged = TRUE;
			break;
		    }
		    if(!lstrcmp((LPSTR)hdrptr->extsig, (LPSTR)w386Hdr)) {
			if((hdrptr->extsizebytes == sizeof(PIF386EXT)) &&
			    ((unsigned)hdrptr->extfileoffset <= PifFileSize - sizeof(PIF386EXT))) {
			    Pif386ext = (PIF386EXT *)(PifBuf + hdrptr->extfileoffset);
			    SetHotKeyTextFromPIF();
			} else {
			    Warning(PIFBADFIL,MB_ICONEXCLAMATION | MB_OK);
			    ResetStd();
			    FileChanged = TRUE;
			    break;
			}
		    } else if(!lstrcmp((LPSTR)hdrptr->extsig, (LPSTR)w286Hdr30)) {
			if((hdrptr->extsizebytes == sizeof(PIF286EXT30)) &&
			    ((unsigned)hdrptr->extfileoffset <= PifFileSize - sizeof(PIF286EXT30))) {
			    Pif286ext30 = (PIF286EXT30 *)(PifBuf + hdrptr->extfileoffset);
			} else {
			    Warning(PIFBADFIL,MB_ICONEXCLAMATION | MB_OK);
			    ResetStd();
			    FileChanged = TRUE;
			    break;
			}
		    } else if(!lstrcmp((LPSTR)hdrptr->extsig, (LPSTR)wNTHdr)) {
			if((hdrptr->extsizebytes == sizeof(PIFWNTEXT)) &&
			    ((unsigned)hdrptr->extfileoffset <= PifFileSize - sizeof(PIFWNTEXT))) {
			    PifNText = (PIFWNTEXT *)(PifBuf + hdrptr->extfileoffset);
			} else {
			    Warning(PIFBADFIL,MB_ICONEXCLAMATION | MB_OK);
			    ResetStd();
			    FileChanged = TRUE;
			    break;
			}
		    }
		    /*
		     * } else if(!lstrcmp((LPSTR)hdrptr->extsig, (LPSTR)w286Hdr31)) {
		     *	   if((hdrptr->extsizebytes == sizeof(PIF286EXT31)) &&
		     *	       (hdrptr->extfileoffset <= PifFileSize - sizeof(PIF286EXT31))) {
		     *	       Pif286ext31 = (PIF286EXT31 *)(PifBuf + hdrptr->extfileoffset);
		     *	   } else {
		     *	       Warning(PIFBADFIL,MB_ICONEXCLAMATION | MB_OK);
		     *	       ResetStd();
		     *	       FileChanged = TRUE;
		     *	       break;
		     *	   }
		     * }
		     */
		    if(!scandone)
			hdrptr = (PIFEXTHEADER *)(PifBuf + hdrptr->extnxthdrfloff);
		}
	    }
	}

	if(CurrMode386) {
	    if(!Pif386ext) {
		if(!(Pif386ext = AllocInit386Ext())) {
		    Warning(PIFBADFIL,MB_ICONEXCLAMATION | MB_OK);
		    ResetStd();
		}
		FileChanged = TRUE;
	    }
	} else {
	    /*
	     * if(!Pif286ext31) {
	     *	   if(Pif286ext30 && !Pif2X)
	     *	       Warning(PIFOLDFIL2,MB_ICONEXCLAMATION | MB_OK);
	     *	   if(!(Pif286ext31 = AllocInit286Ext31())) {
	     *	       Warning(PIFBADFIL,MB_ICONEXCLAMATION | MB_OK);
	     *	       ResetStd();
	     *	   }
	     *	   FileChanged = TRUE;
	     * }
	     */
	    if(!Pif286ext30) {
		if(!(Pif286ext30 = AllocInit286Ext30())) {
		    Warning(PIFBADFIL,MB_ICONEXCLAMATION | MB_OK);
		    ResetStd();
		}
		FileChanged = TRUE;
	    }
	    if((PifFile->MSflags & GRAPHMASK) && (PifFile->sysmem <= 16))
		PifFile->sysmem = 23;
	    if((!(PifFile->MSflags & GRAPHMASK)) && (PifFile->sysmem > 16))
		PifFile->MSflags |= GRAPHMASK;
	}
	if(CurrMode386) {
	    if(!PifNText) {
		if(!(PifNText = AllocInitNTExt())) {
		    Warning(PIFBADFIL,MB_ICONEXCLAMATION | MB_OK);
		    ResetStd();
		}
		//FileChanged = TRUE; //can be confusing if they don't change it
	    }
        }

	_lclose(fh);

        /* Make sure that we have valid memory values. */

	if (PifFile->minmem != -1) {
	    PifFile->minmem = max(PifFile->minmem, 0);
	    PifFile->minmem = min(PifFile->minmem, 640);
	}
	if (PifFile->maxmem != -1) {
	    PifFile->maxmem = max(PifFile->maxmem, 0);
	    PifFile->maxmem = min(PifFile->maxmem, 640);
	}

	if(Pif386ext) {
	    if (Pif386ext->minmem != -1) {
		Pif386ext->minmem = max(Pif386ext->minmem, 0);
		Pif386ext->minmem = min(Pif386ext->minmem, 640);
	    }
	    if (Pif386ext->maxmem != -1) {
		Pif386ext->maxmem = max(Pif386ext->maxmem, 0);
		Pif386ext->maxmem = min(Pif386ext->maxmem, 640);
	    }

	    Pif386ext->PfMinEMMK = max(Pif386ext->PfMinEMMK, 0);
	    Pif386ext->PfMinEMMK = min(Pif386ext->PfMinEMMK, 16384);
	    Pif386ext->PfMinXmsK = max(Pif386ext->PfMinXmsK, 0);
	    Pif386ext->PfMinXmsK = min(Pif386ext->PfMinXmsK, 16384);

	    if (Pif386ext->PfMaxEMMK != -1) {
		Pif386ext->PfMaxEMMK = max(Pif386ext->PfMaxEMMK, 0);
		Pif386ext->PfMaxEMMK = min(Pif386ext->PfMaxEMMK, 16384);
	    }
	    if (Pif386ext->PfMaxXmsK != -1) {
		Pif386ext->PfMaxXmsK = max(Pif386ext->PfMaxXmsK, 0);
		Pif386ext->PfMaxXmsK = min(Pif386ext->PfMaxXmsK, 16384);
	    }
	    if (Pif386ext->PfFPriority > 10000) {
		Pif386ext->PfFPriority = 10000;
	    }
	    if (Pif386ext->PfBPriority > 10000) {
		Pif386ext->PfBPriority = 10000;
	    }
	    if (Pif386ext->PfFPriority <= 0) {
		Pif386ext->PfFPriority = 1;
	    }
	    if (Pif386ext->PfBPriority <= 0) {
		Pif386ext->PfBPriority = 1;
	    }
	}
	/*
	 * if(Pif286ext31) {
	 *     Pif286ext31->PfMinEmsK = max(Pif286ext31->PfMinEmsK, 0);
	 *     Pif286ext31->PfMinEmsK = min(Pif286ext31->PfMinEmsK, 16384);
	 *     if (Pif286ext31->PfMaxEmsK != -1) {
	 *	   Pif286ext31->PfMaxEmsK = max(Pif286ext31->PfMaxEmsK, 0);
	 *	   Pif286ext31->PfMaxEmsK = min(Pif286ext31->PfMaxEmsK, 16384);
	 *     }
	 * }
	 */
	if(Pif286ext30) {
	    Pif286ext30->PfMinXmsK = max(Pif286ext30->PfMinXmsK, 0);
	    Pif286ext30->PfMinXmsK = min(Pif286ext30->PfMinXmsK, 16384);
	    if (Pif286ext30->PfMaxXmsK != -1) {
		Pif286ext30->PfMaxXmsK = max(Pif286ext30->PfMaxXmsK, 0);
		Pif286ext30->PfMaxXmsK = min(Pif286ext30->PfMaxXmsK, 16384);
	    }
	}

	/*
	 * Trim trailing spaces off PifFile->name
	 */
	for (pch = (PUCHAR)(PifFile->name+PIFNAMESIZE-1); *pch == ' ' && pch > PifFile->name; pch=(PUCHAR)AnsiPrev((LPCTSTR)PifFile->name,(PUCHAR)pch))
	    ;
	*++pch = 0;
	/*
	 * Trim trailing spaces off PifFile->params (and Pif386ext->params)
	 */
	for (pch = (PUCHAR)(PifFile->params+PIFPARAMSSIZE-1); *pch  == ' ' && pch > PifFile->params; pch=(PUCHAR)AnsiPrev((LPCTSTR)PifFile->params,(PUCHAR)pch))
	    ;
	*++pch = 0;
	if(Pif386ext) {
	    for (pch = (PUCHAR)(Pif386ext->params+PIFPARAMSSIZE-1); *pch	== ' ' && pch > Pif386ext->params; pch=(PUCHAR)AnsiPrev((LPCTSTR)Pif386ext->params,(PUCHAR)pch))
		;
	    *++pch = 0;
	}
	UpdatePifScreen();
	//OemToAnsi((LPSTR)ofReopen.szPathName,(LPSTR)CurPifFile);
	lstrcpy((LPSTR)CurPifFile, (LPSTR)ofReopen.szPathName);
	AnsiUpper((LPSTR)CurPifFile);
	SetFileOffsets(CurPifFile,&fileoffset,&extoffset);
    } else {
	fh = ofReopen.nErrCode;
	switch (fh) {
	    case 2:		/* File not found */
		fh = errNoPIFfnf;
		break;

	    case 3:		/* Path not found */
		fh = errNoPIFpnf;
		break;

	    case 4:		/* Too many open files */
		fh = errNoFileHnds;
		break;

	    case 5:		/* Access denied */
		fh = errNoAcc;
		break;

	    case 32:		/* Sharing violation */
		fh = errSharing;
		break;

	    default:
		fh = errNoPIFfnf;
		break;
	}
	Warning(fh,MB_ICONEXCLAMATION | MB_OK);
    }
    return(TRUE);
}


IsFileName(unsigned char *pchFile)
{
    while (*pchFile) {
	if (*pchFile <= ' ')
	    return(FALSE);
	pchFile=AnsiNext(pchFile);
    }
    return(TRUE);
}


ClearChanges(void)
{
    SendMessage(GetDlgItem(hwndPifDlg, IDI_ENAME), EM_SETMODIFY, FALSE, 0L);
    SendMessage(GetDlgItem(hwndPifDlg, IDI_ETITLE), EM_SETMODIFY, FALSE, 0L);
    SendMessage(GetDlgItem(hwndPifDlg, IDI_EPATH), EM_SETMODIFY, FALSE, 0L);
    SendMessage(GetDlgItem(hwndPifDlg, IDI_EPARM), EM_SETMODIFY, FALSE, 0L);
    NewHotKey = FALSE;
    FileChanged = FALSE;
    return(TRUE);
}


int SavePifFile(PSTR pchFile, int wmcommand)
{
    int fh;
    OFSTRUCT ofReopen;
    int i;
    BYTE *p;
    int stuffspot;
    int cch;

#if 0
    // This code is not needed since NTVDM can deal with long names in DAYTONA
    // 24-Jan-1994 JonPa
    if (!IsFileName(pchFile)) {
	Warning(EINVALIDFILE,MB_ICONEXCLAMATION | MB_OK);
        return(SAVERETRY);
    }
#endif

    UpdatePifStruct();

    if (DoFieldsWork(TRUE)) {
	PifFile->id = 0;
	stuffspot = -1;
	for(i = 0;i < PIFNAMESIZE; i++)
	    if(!PifFile->name[i]) {
		PifFile->name[i] = ' ';
		stuffspot = i;
	    }
	p = (BYTE *)&PifFile->name[ 0 ];
	i = PIFSIZE;
	while (i--)
	    PifFile->id += *p++;
	AnsiUpper((LPSTR) pchFile );
	ofReopen.szPathName[0] = 0;
	if ((fh = OpenFile((LPSTR)pchFile, (LPOFSTRUCT)&ofReopen, OF_CREATE | OF_READWRITE | OF_SHARE_EXCLUSIVE)) == -1) {
	    fh = ofReopen.nErrCode;
	    switch (fh) {
		case 2: 	    /* File not found */
		    fh = errNoCreate;
		    break;

		case 3: 	    /* Path not found */
		    fh = errNoPIFpnf;
		    break;

		case 4: 	    /* Too many open files */
		    fh = errNoFileHnds;
		    break;

		case 5: 	    /* Access denied */
		    fh = errCrtRO;
		    break;

		case 32:	    /* Sharing violation */
		    fh = errSharing;
		    break;

		default:
		    fh = errNoCreate;
		    break;
	    }
	    Warning(fh,MB_ICONEXCLAMATION | MB_OK);
	    if(stuffspot != -1)
		PifFile->name[stuffspot] = '\0';
	    return(SAVERETRY);
	}
	cch = _lwrite(fh, (LPSTR)PifBuf, PifFileSize);
	if(stuffspot != -1)
	    PifFile->name[stuffspot] = '\0';
	_lclose(fh);
	if ((unsigned)cch != PifFileSize) {
	    delete(pchFile);
	    Warning(errDiskFull,MB_ICONEXCLAMATION | MB_OK);
	} else {

	}
    } else
        return(SAVEERROR);

    lstrcpy((LPSTR)CurPifFile, (LPSTR)pchFile);
    AnsiUpper((LPSTR)CurPifFile);
    SetFileOffsets(CurPifFile,&fileoffset,&extoffset);
    ClearChanges();
    return(SAVEDONE);
}


InitStdPIFExt(void)
{
    lstrcpy((LPSTR)PifFile->stdpifext.extsig, (LPSTR)stdHdr);
    PifFile->stdpifext.extnxthdrfloff = LASTHEADERPTR;
    PifFile->stdpifext.extfileoffset = 0;
    PifFile->stdpifext.extsizebytes = sizeof(PIFOLD286STR);

    LastPifExt = &PifFile->stdpifext;
    PifFileSize = sizeof(PIFNEWSTRUCT);
    Pif386ext = (PIF386EXT *)NULL;
    /*
     * Pif286ext31 = (PIF286EXT31 *)NULL;
     */
    Pif286ext30 = (PIF286EXT30 *)NULL;
    PifNText = (PIFWNTEXT *)NULL;
    return(TRUE);
}


InitPifStruct(void)
{
    BOOL result = TRUE;

    PifFile->unknown = 0;
    *PifFile->name = 0;
    PifFile->maxmem = 128;
    PifFile->minmem = 128;
    *PifFile->startfile = 0;
    *PifFile->defpath = 0;
    *PifFile->params = 0;
    PifFile->screen = 0x7F;
    PifFile->cPages = 1;
    PifFile->lowVector = 0;
    PifFile->highVector = 0x0ff;
    PifFile->rows = 25;
    PifFile->cols = 80;
    PifFile->rowoff = 0;
    PifFile->coloff = 0;
    PifFile->sysmem = 7;
    *PifFile->shprog = 0;
    *PifFile->shdata = 0;
    PifFile->behavior = SCRMASK | MASK8087;
    PifFile->sysflags = SWAPS;
    PifFile->MSflags = EXITMASK;
    InitStdPIFExt();
    if(!(InitPif386Struc()))
	result = FALSE;
    if(!(InitPif286Struc()))
	result = FALSE;
    if(!(InitPifNTStruc()))
	result = FALSE;
    return(result);
}


InitPifNTStruc(void)
{

    if(!PifNText) {
	if(!(PifNText = AllocInitNTExt())) {
	    Warning(NOMODENT,MB_ICONEXCLAMATION | MB_OK);
	    return(FALSE);
	}
    }
    return(TRUE);
}


InitPif386Struc(void)
{

    if(!Pif386ext) {
	if(!(Pif386ext = AllocInit386Ext())) {
	    Warning(NOMODE386,MB_ICONEXCLAMATION | MB_OK);
	    return(FALSE);
	}
    }
    return(TRUE);
}

InitPif286Struc(void)
{

    if(!Pif286ext30) {
	if(!(Pif286ext30 = AllocInit286Ext30())) {
	    Warning(NOMODE286,MB_ICONEXCLAMATION | MB_OK);
	    return(FALSE);
	}
    }
    /*
     * if(!Pif286ext31) {
     *	   if(!(Pif286ext31 = AllocInit286Ext31())) {
     *	       Warning(NOMODE286,MB_ICONEXCLAMATION | MB_OK);
     *	       return(FALSE);
     *	   }
     * }
     */
    return(TRUE);
}

MaybeSaveFile(void)
{
    int j;
    unsigned char *pch;
    int i;
    unsigned char *pchFile;
    unsigned char *pchBuf = 0;

    if (UpdatePifStruct() || FileChanged) {
	j = 0;
	pch = (PUCHAR)PifFile->name;
	i = PIFSIZE;
	while (i--)
	    j += *pch++;
	if (j != PifFile->id) {
	    i = Warning(warSave,MB_ICONEXCLAMATION | MB_YESNOCANCEL);
	    switch (i) {
		case IDYES:
		    if (!CurPifFile[0]) {
			if(pchBuf = PutUpDB(DTSAVE))
			    pchFile = pchBuf;
			else
			    return(FALSE);	/* cancelled */
		    } else {
			pchFile = CurPifFile;
		    }
		    CmdArgAddCorrectExtension(pchFile);
                    i = SavePifFile(pchFile, M_SAVE);
		    if(pchBuf)
			LocalFree((HANDLE)pchBuf);
                    return(i==SAVEDONE ? TRUE : FALSE);

		case IDNO:
		    return(TRUE);

		case IDCANCEL:
		    return(FALSE);
	    }
	} else {
	    return(TRUE);
	}
    } else {
	return(TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\commdlg\colordlg.h ===
/*****************************************************************************\
*                                                                             *
* colordlg.h -  Common dialog color dialog's control id numbers               *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_COLORDLG
#define _INC_COLORDLG

#define DLG_COLOR          10

#define COLOR_HUESCROLL   700	       /* color dialog */
#define COLOR_SATSCROLL   701
#define COLOR_LUMSCROLL   702
#define COLOR_HUE         703
#define COLOR_SAT         704
#define COLOR_LUM         705
#define COLOR_RED         706
#define COLOR_GREEN       707
#define COLOR_BLUE        708
#define COLOR_CURRENT     709
#define COLOR_RAINBOW     710
#define COLOR_SAVE        711
#define COLOR_ADD         712
#define COLOR_SOLID       713
#define COLOR_TUNE        714
#define COLOR_SCHEMES     715
#define COLOR_ELEMENT     716
#define COLOR_SAMPLES     717
#define COLOR_PALETTE     718
#define COLOR_MIX         719
#define COLOR_BOX1        720
#define COLOR_CUSTOM1     721

#define COLOR_HUEACCEL    723
#define COLOR_SATACCEL    724
#define COLOR_LUMACCEL    725
#define COLOR_REDACCEL    726
#define COLOR_GREENACCEL  727
#define COLOR_BLUEACCEL   728

#define NUM_BASIC_COLORS   48
#define NUM_CUSTOM_COLORS  16

#endif  /* !_INC_COLORDLG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmutils\win\win.c ===
/*++
 *
 *  WOW v1.0
 *
 *  Copyright (c) 1993, Microsoft Corporation
 *
 *  WIN.C
 *  Simple WIN.COM which spawns program given on command line.
 *  This allows DOS install which run "win appname" to work.
 *
 *  History:
 *  Created 29-Mar-1993 Dave Hart (davehart)
 *          20-Jul-1994 Dave Hart (davehart) Changed from console to windows app.
--*/

#include <windows.h>

//
// Support for debug output disabled for build (no console).
// DPRINTF macro must be used with two sets of parens:
// DPRINTF(("Hello %s\n", szName));
//

#if 0
#include <stdio.h>
#define DPRINTF(args) printf args
#else
#define DPRINTF(args)
#endif


//
// SKIP_BLANKS -- Handy macro to skip blanks.
//

#define SKIP_BLANKS(pch)     {while (' ' == *(pch)) { (pch)++; }}

//
// SKIP_NONBLANKS -- Handy macro to skip everything but blanks.
//

#define SKIP_NONBLANKS(pch)  {while (*(pch) && ' ' != *(pch)) { (pch)++; }}




//
// WinMain
//

int WinMain(
    HINSTANCE hInst,
    HINSTANCE hPrevInst,
    LPSTR     pszCommandLine,
    int       nCmdShow
    )
{
    char *psz;
    BOOL fSuccess;
    DWORD dwExitCode;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    DPRINTF(("win.com: Command line is '%s'.\n", pszCommandLine));

    //
    // Throw away any switches on the command line.  The command line
    // looks like:
    //
    // win [/r] [/2] [/s] [/3] [/n] [winapp winapp-args]
    //
    // So we'll go into a loop of skipping all words that begin with
    // "/" or "-" until we hit a word that doesn't start with either,
    // which is presumably the winapp name.
    //

    psz = pszCommandLine;
    SKIP_BLANKS(psz);

    //
    // psz now points to either the first word of our command
    // line ("win" not included), or to a null terminator if
    // we were invoked without arguments.
    //

    while ('-' == *psz || '/' == *psz) {

        SKIP_NONBLANKS(psz);

        //
        // psz now points to either a space or the null terminator.
        //

        SKIP_BLANKS(psz);

        //
        // psz now points to either the beginning of the next word
        // on the command line, or the null terminator.
        //

    }

    if (!(*psz)) {

        //
        // If psz now points to a null terminator, then win.com was invoked
        // either without arguments or all arguments were switches that we
        // skipped above.  So there's nothing to do!
        //

        return 0;


    }

    DPRINTF(("win.com: Invoking '%s'.\n", psz));

    //
    // Run that program.
    //

    RtlZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESHOWWINDOW | STARTF_FORCEONFEEDBACK;
    si.wShowWindow = (WORD) nCmdShow;

    fSuccess = CreateProcess(
        NULL,                  // image name (in the command line instead)
        psz,                   // command line (begins with image name)
        NULL,                  // lpsaProcess
        NULL,                  // lpsaThread
        FALSE,                 // no handle inheritance
        0,                     // dwCreateOptions
        NULL,                  // pointer to environment
        NULL,                  // pointer to curdir
        &si,                   // startup info struct
        &pi                    // process information (gets handles)
        );

    if (!fSuccess) {

        dwExitCode = GetLastError();
        DPRINTF(("CreateProcess fails with error %d.\n", dwExitCode));
        return dwExitCode;

    }


    //
    // Close the thread handle, we're only using the process handle.
    //

    CloseHandle(pi.hThread);


    //
    // Wait for the process to terminate and return its exit code as
    // our exit code.
    //

    if (0xffffffff == WaitForSingleObject(pi.hProcess, INFINITE)) {

        dwExitCode = GetLastError();
        DPRINTF(("WaitForSingleObject(hProcess, INFINITE) fails with error %d.\n",
                dwExitCode));
        goto Cleanup;

    }


    if (!GetExitCodeProcess(pi.hProcess, &dwExitCode)) {

        dwExitCode = GetLastError();
        DPRINTF(("GetExitCodeProcess() fails with error %d.\n", dwExitCode));
        goto Cleanup;

    }

    DPRINTF(("win.com: Returning child's exit code (%d)\n", dwExitCode));

    Cleanup:
        CloseHandle(pi.hProcess);
        return dwExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\makefile.inc ===
!include $(NTMAKEENV)\makefile.plt
#
# Common MAKEFILE definitions for WOW16
#

.SUFFIXES:
.SUFFIXES: .c   .asm .h   .inc .obj .lst .sys .exe .com .map .sym .def .lib .rc .res

DEST=$(ALT_PROJECT)\obj$(BUILD_ALT_DIR)\$(TARGET_DIRECTORY)

########## Path definition so we find 16 bit tools ##########
# Also works around bug in RC 3.1 that doesn't allow rcpp.err to be
# in a directory that is greater than 128 chars down the path, even if
# rc 3.1 is running as an OS/2 app.

PATH    = $(PATH_TOOLS16);$(PATH)

!IF 0
!IF "$(QFE_BUILD)" != "1"
CL16=cl16
!ELSE
CL16=cl
!ENDIF
!ENDIF

ASM     = masm386
LINK    = link16 /batch
LINK16  = link16 /batch
CL      = cl16
RC      = rc16
MAPSYM  = mapsym
IMPLIB  = implib
MKPUB   = mkpublic
CVPACK  = cvpack

!ifdef INCLUDE
INCS    =
!else
!IFDEF LVL_2
INCS    = -I..\..\inc -I..\..\..\inc -I$(PROJECT_INC_PATH)
ENVINCS = ..\..\inc;..\..\..\inc;$(PROJECT_INC_PATH);$(SDK_INC_PATH)
!ELSE
INCS    = -I..\inc -I..\..\inc -I$(PROJECT_INC_PATH)
ENVINCS = ..\inc;..\..\inc;$(PROJECT_INC_PATH);$(SDK_INC_PATH)
!ENDIF
!endif


DEFINES = -DWOW $(MVDMFLAGS)


AOBJ    = -Ml -t $(DEFINES) $(INCS)
CW16    = -AS -G2sw -Os -W3 -Zp $(DEFINES)
CW16B   = $(CW16) -B1 c1l.exe -B2 c2l.exe -B3 c3l.exe
LINKOPTS = /map /align:16

!if !$(FREEBUILD)
AOBJ    = $(AOBJ) -Zd
CW16    = $(CW16) /Od /Oi /Zd
LINKOPTS = $(LINKOPTS) /LI
!endif


.asm{$(DEST)}.obj:
    $(ASM) $(AOBJ) $(*F),$*;

.asm{$(DEST)}.lst:
    $(ASM) $(AOBJ) -l $(*F),nul,$*.lst;


.c{$(DEST)}.obj:
    @set include=$(ENVINCS);$(INCLUDE)
    $(CL) -c -nologo $(CW16) -Fo$* $(*F).c

.c{$(DEST)}.lst:
    @set include=$(ENVINCS);$(INCLUDE)
    $(CL) -c -nologo $(CW16) -Fonul -Fc$*.lst $(*F).c


.def{$(DEST)}.lib:
    implib $*.lib $(*F).def

{$(DEST)}.map{$(DEST)}.sym:
    mapsym -o $*.sym $*

.rc{$(DEST)}.res:
    @set include=$(ENVINCS);$(INCLUDE)
    $(RC) -r -fo$*.res $(*F).rc $*
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\commdlg\dlgs.c ===
/*---------------------------------------------------------------------------
   Dlgs.c : Common functions for Common Dialog Library

   Copyright (c) Microsoft Corporation, 1990-
  ---------------------------------------------------------------------------*/

#include "windows.h"

#include "commdlg.h"

char szCommdlgHelp[] = HELPMSGSTRING;

UINT   msgHELP;
WORD   wWinVer = 0x030A;
HANDLE hinsCur;
DWORD  dwExtError;


/*---------------------------------------------------------------------------
   LibMain
   Purpose:  To initialize any instance specific data needed by functions
             in this DLL
   Returns:  TRUE if A-OK, FALSE if not
  ---------------------------------------------------------------------------*/

int  FAR PASCAL
LibMain(HANDLE hModule, WORD wDataSeg, WORD cbHeapSize, LPSTR lpstrCmdLine)
{
    hinsCur = (HANDLE) hModule;
    wDataSeg = wDataSeg;
    cbHeapSize = cbHeapSize;
    lpstrCmdLine = lpstrCmdLine;

    /* msgHELP is sent whenever a help button is pressed in one of the */
    /* common dialogs (provided an owner was declared and the call to  */
    /* RegisterWindowMessage doesn't fail.   27 Feb 1991   clarkc      */

    msgHELP = RegisterWindowMessage(szCommdlgHelp);

    return(TRUE);
}

/*---------------------------------------------------------------------------
   WEP
   Purpose:  To perform cleanup tasks when DLL is unloaded
   Returns:  TRUE if OK, FALSE if not
  ---------------------------------------------------------------------------*/
int  FAR PASCAL
WEP(int fSystemExit)
{
  fSystemExit = fSystemExit;
  return(TRUE);
}



/*---------------------------------------------------------------------------
   CommDlgExtendedError
   Purpose:  Provide additional information about dialog failure
   Assumes:  Should be called immediately after failure
   Returns:  Error code in low word, error specific info in hi word
  ---------------------------------------------------------------------------*/

DWORD FAR PASCAL WowCommDlgExtendedError(void);

DWORD FAR PASCAL CommDlgExtendedError()
{
    //
    // HACKHACK - John Vert (jvert) 8-Jan-1993
    //      If the high bit of dwExtError is set, then the last
    //      common dialog call was thunked through to the 32-bit.
    //      So we need to call the WOW thunk to get the real error.
    //      This will go away when all the common dialogs are thunked.
    //

    if (dwExtError & 0x80000000) {
        return(WowCommDlgExtendedError());
    } else {
        return(dwExtError);
    }
}

VOID _loadds FAR PASCAL SetWowCommDlg()
{
    dwExtError = 0x80000000;
}

/*---------------------------------------------------------------------------
   MySetObjectOwner
   Purpose:  Call SetObjectOwner in GDI, eliminating "<Object> not released"
             error messages when an app terminates.
   Returns:  Yep
  ---------------------------------------------------------------------------*/

void FAR PASCAL MySetObjectOwner(HANDLE hObject)
{
    extern char szGDI[];
    VOID (FAR PASCAL *lpSetObjOwner)(HANDLE, HANDLE);
    HMODULE hMod;

    if (wWinVer >= 0x030A)
    {
        if ((hMod = GetModuleHandle(szGDI)) != NULL) {
            lpSetObjOwner = (VOID (FAR PASCAL *)(HANDLE, HANDLE))GetProcAddress(hMod, MAKEINTRESOURCE(461));
            if (lpSetObjOwner) {
                (lpSetObjOwner)(hObject, hinsCur);
            }
        }
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\commdlg\commdlg.h ===
/*****************************************************************************\
*                                                                             *
* commdlg.h -   Common dialog functions, types, and definitions               *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_COMMDLG
#define _INC_COMMDLG

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef WINAPI          /* If not included with 3.1 headers... */
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */

typedef struct tagOFN
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HINSTANCE hInstance;
    LPCSTR  lpstrFilter;
    LPSTR   lpstrCustomFilter;
    DWORD   nMaxCustFilter;
    DWORD   nFilterIndex;
    LPSTR   lpstrFile;
    DWORD   nMaxFile;
    LPSTR   lpstrFileTitle;
    DWORD   nMaxFileTitle;
    LPCSTR  lpstrInitialDir;
    LPCSTR  lpstrTitle;
    DWORD   Flags;
    UINT    nFileOffset;
    UINT    nFileExtension;
    LPCSTR  lpstrDefExt;
    LPARAM  lCustData;
    UINT    (CALLBACK *lpfnHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpTemplateName;
}   OPENFILENAME;
typedef OPENFILENAME FAR* LPOPENFILENAME;

BOOL    WINAPI GetOpenFileName(OPENFILENAME FAR*);
BOOL    WINAPI GetSaveFileName(OPENFILENAME FAR*);
int     WINAPI GetFileTitle(LPCSTR, LPSTR, UINT);

#define OFN_READONLY                 0x00000001
#define OFN_OVERWRITEPROMPT          0x00000002
#define OFN_HIDEREADONLY             0x00000004
#define OFN_NOCHANGEDIR              0x00000008
#define OFN_SHOWHELP                 0x00000010
#define OFN_ENABLEHOOK               0x00000020
#define OFN_ENABLETEMPLATE           0x00000040
#define OFN_ENABLETEMPLATEHANDLE     0x00000080
#define OFN_NOVALIDATE               0x00000100
#define OFN_ALLOWMULTISELECT         0x00000200
#define OFN_EXTENSIONDIFFERENT       0x00000400
#define OFN_PATHMUSTEXIST            0x00000800
#define OFN_FILEMUSTEXIST            0x00001000
#define OFN_CREATEPROMPT             0x00002000
#define OFN_SHAREAWARE               0x00004000
#define OFN_NOREADONLYRETURN         0x00008000
#define OFN_NOTESTFILECREATE         0x00010000

/* Return values for the registered message sent to the hook function
 * when a sharing violation occurs.  OFN_SHAREFALLTHROUGH allows the
 * filename to be accepted, OFN_SHARENOWARN rejects the name but puts
 * up no warning (returned when the app has already put up a warning
 * message), and OFN_SHAREWARN puts up the default warning message
 * for sharing violations.
 *
 * Note:  Undefined return values map to OFN_SHAREWARN, but are
 *        reserved for future use.
 */

#define OFN_SHAREFALLTHROUGH     2
#define OFN_SHARENOWARN          1
#define OFN_SHAREWARN            0

typedef struct tagCHOOSECOLOR
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HWND    hInstance;
    COLORREF rgbResult;
    COLORREF FAR* lpCustColors;
    DWORD   Flags;
    LPARAM  lCustData;
    UINT    (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpTemplateName;
} CHOOSECOLOR;
typedef CHOOSECOLOR FAR *LPCHOOSECOLOR;

BOOL    WINAPI ChooseColor(CHOOSECOLOR FAR*);

#define CC_RGBINIT               0x00000001
#define CC_FULLOPEN              0x00000002
#define CC_PREVENTFULLOPEN       0x00000004
#define CC_SHOWHELP              0x00000008
#define CC_ENABLEHOOK            0x00000010
#define CC_ENABLETEMPLATE        0x00000020
#define CC_ENABLETEMPLATEHANDLE  0x00000040

typedef struct tagFINDREPLACE
{
    DWORD    lStructSize;            /* size of this struct 0x20 */
    HWND     hwndOwner;              /* handle to owner's window */
    HINSTANCE hInstance;             /* instance handle of.EXE that
                                      * contains cust. dlg. template
                                      */
    DWORD    Flags;                  /* one or more of the FR_?? */
    LPSTR    lpstrFindWhat;          /* ptr. to search string    */
    LPSTR    lpstrReplaceWith;       /* ptr. to replace string   */
    UINT     wFindWhatLen;           /* size of find buffer      */
    UINT     wReplaceWithLen;        /* size of replace buffer   */
    LPARAM   lCustData;              /* data passed to hook fn.  */
    UINT    (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
                                     /* ptr. to hook fn. or NULL */
    LPCSTR   lpTemplateName;         /* custom template name     */
} FINDREPLACE;
typedef FINDREPLACE FAR *LPFINDREPLACE;

#define FR_DOWN 			0x00000001
#define FR_WHOLEWORD			0x00000002
#define FR_MATCHCASE			0x00000004
#define FR_FINDNEXT			0x00000008
#define FR_REPLACE			0x00000010
#define FR_REPLACEALL			0x00000020
#define FR_DIALOGTERM			0x00000040
#define FR_SHOWHELP			0x00000080
#define FR_ENABLEHOOK			0x00000100
#define FR_ENABLETEMPLATE		0x00000200
#define FR_NOUPDOWN			0x00000400
#define FR_NOMATCHCASE			0x00000800
#define FR_NOWHOLEWORD			0x00001000
#define FR_ENABLETEMPLATEHANDLE 	0x00002000
#define FR_HIDEUPDOWN			0x00004000
#define FR_HIDEMATCHCASE		0x00008000
#define FR_HIDEWHOLEWORD		0x00010000

HWND    WINAPI FindText(FINDREPLACE FAR*);
HWND    WINAPI ReplaceText(FINDREPLACE FAR*);

typedef struct tagCHOOSEFONT
{
    DWORD	    lStructSize;	/* */
    HWND	    hwndOwner;		/* caller's window handle   */
    HDC 	    hDC;		/* printer DC/IC or NULL    */
    LOGFONT FAR*    lpLogFont;          /* ptr. to a LOGFONT struct */
    int		    iPointSize;		/* 10 * size in points of selected font */
    DWORD	    Flags;		/* enum. type flags	    */
    COLORREF        rgbColors;          /* returned text color      */
    LPARAM          lCustData;          /* data passed to hook fn.  */
    UINT (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
					/* ptr. to hook function    */
    LPCSTR          lpTemplateName;     /* custom template name     */
    HINSTANCE       hInstance;          /* instance handle of.EXE that
					 * contains cust. dlg. template
					 */
    LPSTR	    lpszStyle;		/* return the style field here 
					 * must be LF_FACESIZE or bigger */
    UINT            nFontType;          /* same value reported to the EnumFonts
					 * call back with the extra FONTTYPE_ 
					 * bits added */
    int		    nSizeMin;		/* minimum pt size allowed & */
    int		    nSizeMax;		/* max pt size allowed if    */
					/* CF_LIMITSIZE is used      */
} CHOOSEFONT;
typedef CHOOSEFONT FAR *LPCHOOSEFONT;

BOOL WINAPI ChooseFont(CHOOSEFONT FAR*);

#define CF_SCREENFONTS		     0x00000001
#define CF_PRINTERFONTS 	     0x00000002
#define CF_BOTH 		     (CF_SCREENFONTS | CF_PRINTERFONTS)
#define CF_SHOWHELP		     0x00000004L
#define CF_ENABLEHOOK		     0x00000008L
#define CF_ENABLETEMPLATE	     0x00000010L
#define CF_ENABLETEMPLATEHANDLE      0x00000020L
#define CF_INITTOLOGFONTSTRUCT       0x00000040L
#define CF_USESTYLE		     0x00000080L
#define CF_EFFECTS		     0x00000100L
#define CF_APPLY		     0x00000200L
#define CF_ANSIONLY		     0x00000400L
#define CF_NOVECTORFONTS	     0x00000800L
#define CF_NOOEMFONTS		     CF_NOVECTORFONTS
#define CF_NOSIMULATIONS	     0x00001000L
#define CF_LIMITSIZE		     0x00002000L
#define CF_FIXEDPITCHONLY	     0x00004000L
#define CF_WYSIWYG		     0x00008000L /* must also have CF_SCREENFONTS & CF_PRINTERFONTS */
#define CF_FORCEFONTEXIST	     0x00010000L
#define CF_SCALABLEONLY		     0x00020000L
#define CF_TTONLY		     0x00040000L
#define CF_NOFACESEL		     0x00080000L
#define CF_NOSTYLESEL		     0x00100000L
#define CF_NOSIZESEL		     0x00200000L

/* these are extra nFontType bits that are added to what is returned to the
 * EnumFonts callback routine */

#define SIMULATED_FONTTYPE	0x8000
#define PRINTER_FONTTYPE	0x4000
#define SCREEN_FONTTYPE		0x2000
#define BOLD_FONTTYPE		0x0100
#define ITALIC_FONTTYPE		0x0200
#define REGULAR_FONTTYPE	0x0400

#define WM_CHOOSEFONT_GETLOGFONT	(WM_USER + 1)


/* strings used to obtain unique window message for communication
 * between dialog and caller
 */
#define LBSELCHSTRING  "commdlg_LBSelChangedNotify"
#define SHAREVISTRING  "commdlg_ShareViolation"
#define FILEOKSTRING   "commdlg_FileNameOK"
#define COLOROKSTRING  "commdlg_ColorOK"
#define SETRGBSTRING   "commdlg_SetRGBColor"
#define FINDMSGSTRING  "commdlg_FindReplace"
#define HELPMSGSTRING  "commdlg_help"

/* HIWORD values for lParam of commdlg_LBSelChangeNotify message */
#define CD_LBSELNOITEMS -1
#define CD_LBSELCHANGE   0
#define CD_LBSELSUB      1
#define CD_LBSELADD      2

typedef struct tagPD
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HGLOBAL hDevMode;
    HGLOBAL hDevNames;
    HDC     hDC;
    DWORD   Flags;
    UINT    nFromPage;
    UINT    nToPage;
    UINT    nMinPage;
    UINT    nMaxPage;
    UINT    nCopies;
    HINSTANCE hInstance;
    LPARAM  lCustData;
    UINT    (CALLBACK* lpfnPrintHook)(HWND, UINT, WPARAM, LPARAM);
    UINT    (CALLBACK* lpfnSetupHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpPrintTemplateName;
    LPCSTR  lpSetupTemplateName;
    HGLOBAL hPrintTemplate;
    HGLOBAL hSetupTemplate;
} PRINTDLG;
typedef PRINTDLG  FAR* LPPRINTDLG;

BOOL    WINAPI PrintDlg(PRINTDLG FAR*);

#define PD_ALLPAGES                  0x00000000
#define PD_SELECTION                 0x00000001
#define PD_PAGENUMS                  0x00000002
#define PD_NOSELECTION               0x00000004
#define PD_NOPAGENUMS                0x00000008
#define PD_COLLATE                   0x00000010
#define PD_PRINTTOFILE               0x00000020
#define PD_PRINTSETUP                0x00000040
#define PD_NOWARNING                 0x00000080
#define PD_RETURNDC                  0x00000100
#define PD_RETURNIC                  0x00000200
#define PD_RETURNDEFAULT             0x00000400
#define PD_SHOWHELP                  0x00000800
#define PD_ENABLEPRINTHOOK           0x00001000
#define PD_ENABLESETUPHOOK           0x00002000
#define PD_ENABLEPRINTTEMPLATE       0x00004000
#define PD_ENABLESETUPTEMPLATE       0x00008000
#define PD_ENABLEPRINTTEMPLATEHANDLE 0x00010000
#define PD_ENABLESETUPTEMPLATEHANDLE 0x00020000
#define PD_USEDEVMODECOPIES          0x00040000
#define PD_DISABLEPRINTTOFILE        0x00080000
#define PD_HIDEPRINTTOFILE           0x00100000

typedef struct tagDEVNAMES
{
    UINT wDriverOffset;
    UINT wDeviceOffset;
    UINT wOutputOffset;
    UINT wDefault;
} DEVNAMES;
typedef DEVNAMES FAR* LPDEVNAMES;

#define DN_DEFAULTPRN      0x0001

DWORD   WINAPI CommDlgExtendedError(void);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_COMMDLG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\commdlg\commdlg.asm ===
TITLE   commdlg.ASM
        PAGE    ,132
;
; WOW v1.0
;
; Copyright (c) 1993, Microsoft Corporation
;
; COMMDLG.ASM
; Thunks in 16-bit space to route commdlg API calls to WOW32
;
; History:
;   John Vert (jvert) 30-Dec-1992
;   Created.
;

        .286p

        include wow.inc
        include wowcmdlg.inc
        include cmacros.inc

        __acrtused = 0
        public  __acrtused      ;satisfy external C ref.

createSeg   _TEXT,CODE,WORD,PUBLIC,CODE
createSeg   _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
defgrp      DGROUP,DATA

externFP SetWowCommDlg
externFP WOW16Call

sBegin  DATA
Reserved        db  16 dup (0)      ;reserved for Windows  //!!!!! what is this

commdlg_Identifier   db      'commdlg16 Data Segment'

extrn   dwExtError:dword
sEnd
sEnd    DATA


sBegin  CODE
assumes CS,CODE
assumes DS,DATA
assumes ES,NOTHING

        CommdlgThunk        GETOPENFILENAME
        CommdlgThunk        GETSAVEFILENAME
        CommdlgThunk        FINDTEXT
        CommdlgThunk        REPLACETEXT
        CommdlgThunk        CHOOSECOLOR
        CommdlgThunk        CHOOSEFONT
        CommdlgThunk        PRINTDLG
        CommdlgThunk        WOWCOMMDLGEXTENDEDERROR


sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\commdlg\dlgs.h ===
/*****************************************************************************\
*                                                                             *
* dlgs.h -      Common dialog's dialog element ID numbers                     *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_DLGS
#define _INC_DLGS

#define ctlFirst    0x0400
#define ctlLast     0x04ff
    /* Push buttons */
#define psh1        0x0400
#define psh2        0x0401
#define psh3        0x0402
#define psh4        0x0403
#define psh5        0x0404
#define psh6        0x0405
#define psh7        0x0406
#define psh8        0x0407
#define psh9        0x0408
#define psh10       0x0409
#define psh11       0x040a
#define psh12       0x040b
#define psh13       0x040c
#define psh14       0x040d
#define psh15       0x040e
#define pshHelp     psh15
#define psh16       0x040f
    /* Checkboxes */
#define chx1        0x0410
#define chx2        0x0411
#define chx3        0x0412
#define chx4        0x0413
#define chx5        0x0414
#define chx6        0x0415
#define chx7        0x0416
#define chx8        0x0417
#define chx9        0x0418
#define chx10       0x0419
#define chx11       0x041a
#define chx12       0x041b
#define chx13       0x041c
#define chx14       0x041d
#define chx15       0x041e
#define chx16       0x041f
    /* Radio buttons */
#define rad1        0x0420
#define rad2        0x0421
#define rad3        0x0422
#define rad4        0x0423
#define rad5        0x0424
#define rad6        0x0425
#define rad7        0x0426
#define rad8        0x0427
#define rad9        0x0428
#define rad10       0x0429
#define rad11       0x042a
#define rad12       0x042b
#define rad13       0x042c
#define rad14       0x042d
#define rad15       0x042e
#define rad16       0x042f
    /* Groups, frames, rectangles, and icons */
#define grp1        0x0430
#define grp2        0x0431
#define grp3        0x0432
#define grp4        0x0433
#define frm1        0x0434
#define frm2        0x0435
#define frm3        0x0436
#define frm4        0x0437
#define rct1        0x0438
#define rct2        0x0439
#define rct3        0x043a
#define rct4        0x043b
#define ico1        0x043c
#define ico2        0x043d
#define ico3        0x043e
#define ico4        0x043f
    /* Static text */
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
#define stc5        0x0444
#define stc6        0x0445
#define stc7        0x0446
#define stc8        0x0447
#define stc9        0x0448
#define stc10       0x0449
#define stc11       0x044a
#define stc12       0x044b
#define stc13       0x044c
#define stc14       0x044d
#define stc15       0x044e
#define stc16       0x044f
#define stc17       0x0450
#define stc18       0x0451
#define stc19       0x0452
#define stc20       0x0453
#define stc21       0x0454
#define stc22       0x0455
#define stc23       0x0456
#define stc24       0x0457
#define stc25       0x0458
#define stc26       0x0459
#define stc27       0x045a
#define stc28       0x045b
#define stc29       0x045c
#define stc30       0x045d
#define stc31       0x045e
#define stc32       0x045f
    /* Listboxes */
#define lst1        0x0460
#define lst2        0x0461
#define lst3        0x0462
#define lst4        0x0463
#define lst5        0x0464
#define lst6        0x0465
#define lst7        0x0466
#define lst8        0x0467
#define lst9        0x0468
#define lst10       0x0469
#define lst11       0x046a
#define lst12       0x046b
#define lst13       0x046c
#define lst14       0x046d
#define lst15       0x046e
#define lst16       0x046f
    /* Combo boxes */
#define cmb1        0x0470
#define cmb2        0x0471
#define cmb3        0x0472
#define cmb4        0x0473
#define cmb5        0x0474
#define cmb6        0x0475
#define cmb7        0x0476
#define cmb8        0x0477
#define cmb9        0x0478
#define cmb10       0x0479
#define cmb11       0x047a
#define cmb12       0x047b
#define cmb13       0x047c
#define cmb14       0x047d
#define cmb15       0x047e
#define cmb16       0x047f
    /* Edit controls */
#define edt1        0x0480
#define edt2        0x0481
#define edt3        0x0482
#define edt4        0x0483
#define edt5        0x0484
#define edt6        0x0485
#define edt7        0x0486
#define edt8        0x0487
#define edt9        0x0488
#define edt10       0x0489
#define edt11       0x048a
#define edt12       0x048b
#define edt13       0x048c
#define edt14       0x048d
#define edt15       0x048e
#define edt16       0x048f
    /* Scroll bars */
#define scr1        0x0490
#define scr2        0x0491
#define scr3        0x0492
#define scr4        0x0493
#define scr5        0x0494
#define scr6        0x0495
#define scr7        0x0496
#define scr8        0x0497

/* These dialog resource ordinals really start at 0x0600, but the
 * RC Compiler can't handle hex for resource IDs, hence the decimal.
 */
#define FILEOPENORD      1536
#define MULTIFILEOPENORD 1537
#define PRINTDLGORD      1538
#define PRNSETUPDLGORD   1539
#define FINDDLGORD       1540
#define REPLACEDLGORD    1541
#define FONTDLGORD       1542
#define FORMATDLGORD31   1543
#define FORMATDLGORD30   1544

#endif  /* !_INC_DLGS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\commdlg\font.c ===
/*******************************************************************************
 *
 *  MODULE      : Font.c
 *
 *  DESCRIPTION : Font selection dialog routines and related functions.
 *
 *  HISTORY     :  11/13/90 - by L.Raman.
 *  HISTORY     :  4/30/91  - reworked for new super font dialog
 *
 *  Copyright (c) Microsoft Corporation, 1990-
 *
 *  some notes:
 *
 *      under 3.0 sending a CB_SETCURSEL message to an owner draw
 *      combo wipes out the exit text (in this case that means the
 *      face and size combos).
 *
 ******************************************************************************/

#define NOCOMM
#define NOWH

#include <windows.h>

#include "privcomd.h"
#include "font.h"

typedef struct {
    HWND hwndFamily;
    HWND hwndStyle;
    HWND hwndSizes;
    HDC hDC;
    DWORD dwFlags;
    WORD nFontType;
    BOOL bFillSize;
    BOOL bPrinterFont;
    LPCHOOSEFONT lpcf;
} ENUM_FONT_DATA, FAR *LPENUM_FONT_DATA;

#define CBN_MYSELCHANGE         (WM_USER + 500)
#define CBN_MYEDITUPDATE        (WM_USER + 501)

#define DEF_POINT_SIZE          10

HBITMAP NEAR PASCAL LoadBitmaps(int id);

BOOL FAR PASCAL FormatCharDlgProc(HWND, unsigned, WORD, LONG);

void NEAR PASCAL FreeFonts(HWND hwnd);
BOOL NEAR PASCAL ProcessDlgCtrlCommand(HWND hDlg, LPCHOOSEFONT lpcf, WORD wParam, LONG lParam);
BOOL NEAR PASCAL DrawColorComboItem(LPDRAWITEMSTRUCT lpdis);
BOOL NEAR PASCAL DrawFamilyComboItem(LPDRAWITEMSTRUCT lpdis);
BOOL NEAR PASCAL DrawSizeComboItem(LPDRAWITEMSTRUCT lpdis);
BOOL NEAR PASCAL FillInFont(HWND hDlg, LPCHOOSEFONT lpcf, LPLOGFONT lplf, BOOL bSetBits);
void NEAR PASCAL FillColorCombo(HWND hDlg);
void NEAR PASCAL ComputeSampleTextRectangle(HWND hDlg);
void NEAR PASCAL SelectStyleFromLF(HWND hwnd, LPLOGFONT lplf);
void NEAR PASCAL DrawSampleText(HWND hDlg, LPCHOOSEFONT lpcf, HDC hDC);
int  NEAR PASCAL GetPointString(LPSTR buf, HDC hdc, int height);
BOOL NEAR PASCAL GetFontFamily(HWND hDlg, HDC hDC, DWORD dwEnumCode);
BOOL NEAR PASCAL GetFontStylesAndSizes(HWND hDlg, LPCHOOSEFONT lpcf, BOOL bFillSizes);
int  NEAR PASCAL CBSetTextFromSel(HWND hwnd);
int  NEAR PASCAL CBSetSelFromText(HWND hwnd, LPSTR lpszString);
int  NEAR PASCAL CBFindString(HWND hwnd, LPSTR lpszString);
int  NEAR PASCAL CBGetTextAndData(HWND hwnd, LPSTR lpszString, int iSize, LPDWORD lpdw);
void NEAR PASCAL InitLF(LPLOGFONT lplf);

#if 0
int  NEAR PASCAL atoi(LPSTR sz);
#endif


/* color table used for colors combobox
   the order of these values must match the names in sz.src */

DWORD rgbColors[CCHCOLORS] = {
        RGB(  0,   0, 0),       /* Black        */
        RGB(128,   0, 0),       /* Dark red     */
        RGB(  0, 128, 0),       /* Dark green   */
        RGB(128, 128, 0),       /* Dark yellow  */
        RGB(  0,   0, 128),     /* Dark blue    */
        RGB(128,   0, 128),     /* Dark purple  */
        RGB(  0, 128, 128),     /* Dark aqua    */
        RGB(128, 128, 128),     /* Dark grey    */
        RGB(192, 192, 192),     /* Light grey   */
        RGB(255,   0, 0),       /* Light red    */
        RGB(  0, 255, 0),       /* Light green  */
        RGB(255, 255, 0),       /* Light yellow */
        RGB(  0,   0, 255),     /* Light blue   */
        RGB(255,   0, 255),     /* Light purple */
        RGB(  0, 255, 255),     /* Light aqua   */
        RGB(255, 255, 255),     /* White        */
};

RECT rcText;
WORD nLastFontType;
HBITMAP hbmFont = NULL;

#define DX_BITMAP       20
#define DY_BITMAP       12

char szRegular[CCHSTYLE];
char szBold[CCHSTYLE];
char szItalic[CCHSTYLE];
char szBoldItalic[CCHSTYLE];

#if 0
char szEnumFonts31[] = "EnumFontFamilies";
char szEnumFonts30[] = "EnumFonts";
#else
#define szEnumFonts30 MAKEINTRESOURCE(70)
#define szEnumFonts31 MAKEINTRESOURCE(330)
#endif

char szGDI[]         = "GDI";
char szPtFormat[]    = "%d";

UINT (FAR PASCAL *glpfnFontHook)(HWND, UINT, WPARAM, LPARAM) = 0;

void NEAR PASCAL SetStyleSelection(HWND hDlg, LPCHOOSEFONT lpcf, BOOL bInit)
{
    if (!(lpcf->Flags & CF_NOSTYLESEL)) {
        if (bInit && (lpcf->Flags & CF_USESTYLE))
          {
            PLOGFONT plf;
            short iSel;

            iSel = (short)CBSetSelFromText(GetDlgItem(hDlg, cmb2), lpcf->lpszStyle);
            if (iSel >= 0)
              {
                plf = (PLOGFONT)(WORD)SendDlgItemMessage(hDlg, cmb2,
                                                     CB_GETITEMDATA, iSel, 0L);
                lpcf->lpLogFont->lfWeight = plf->lfWeight;
                lpcf->lpLogFont->lfItalic = plf->lfItalic;
              }
            else
              {
                lpcf->lpLogFont->lfWeight = FW_NORMAL;
                lpcf->lpLogFont->lfItalic = 0;
              }
          }
        else
            SelectStyleFromLF(GetDlgItem(hDlg, cmb2), lpcf->lpLogFont);

        CBSetTextFromSel(GetDlgItem(hDlg, cmb2));
    }
}


void NEAR PASCAL HideDlgItem(HWND hDlg, int id)
{
        EnableWindow(GetDlgItem(hDlg, id), FALSE);
        ShowWindow(GetDlgItem(hDlg, id), SW_HIDE);
}

// fix the ownerdraw combos to match the heigh of the non owner draw combo
// this only works on 3.1

void NEAR PASCAL FixComboHeights(HWND hDlg)
{
        int height;

        height = (int)SendDlgItemMessage(hDlg, cmb2, CB_GETITEMHEIGHT, (WPARAM)-1, 0L);
        SendDlgItemMessage(hDlg, cmb1, CB_SETITEMHEIGHT, (WPARAM)-1, (LPARAM)height);
        SendDlgItemMessage(hDlg, cmb3, CB_SETITEMHEIGHT, (WPARAM)-1, (LPARAM)height);
}


/****************************************************************************
 *
 *  FormatCharDlgProc
 *
 *  PURPOSE    : Handles dialog messages for the font picker dialog.
 *
 *  RETURNS    : Normal dialog function values.
 *
 *  ASSUMES    :
 *               chx1 - "  "  "Underline" checkbox
 *               chx2 - "  "  "Strikeout" checkbox
 *               psh4 - "  "  "Help..." pushbutton
 *
 *  COMMENTS   : The CHOOSEFONT struct is accessed via lParam during a
 *               WM_INITDIALOG, and stored in the window's property list. If
 *               a hook function has been specified, it is invoked AFTER the
 *               current function has processed WM_INITDIALOG. For all other
 *               messages, control is passed directly to the hook function.
 *               Depending on the latter's return value, the message is also
 *               processed by this function.
 *
 ****************************************************************************/

BOOL FAR PASCAL FormatCharDlgProc(HWND hDlg, unsigned wMsg, WORD wParam, LONG lParam)
{
    PAINTSTRUCT  ps;
    TEXTMETRIC   tm;
    HDC          hDC;             /* handle to screen DC                    */
    LPCHOOSEFONT lpcf = NULL;     /* ptr. to struct. passed to ChooseFont() */
    LPCHOOSEFONT *plpcf;          /* ptr. to above                          */
    HWND hWndHelp;                /* handle to Help... pushbutton           */
    short nIndex;                 /* At init, see if color matches          */
    char szPoints[10];
    HDC hdc;
    HFONT hFont;
    DWORD dw;
    WORD  wRet;

    /* If the CHOOSEFONT. struct has already been accessed and if a hook fn. is
     * specified, let it do the processing.
     */

    plpcf = (LPCHOOSEFONT *)GetProp(hDlg, FONTPROP);
    if (plpcf) {
       lpcf = (LPCHOOSEFONT)*plpcf++;

       if (lpcf->Flags & CF_ENABLEHOOK) {
            if ((wRet = (WORD)(*lpcf->lpfnHook)(hDlg, wMsg, wParam, lParam)) != 0)
               return wRet;
       }
    }
    else if (glpfnFontHook && (wMsg != WM_INITDIALOG)) {
        if ((wRet = (WORD)(* glpfnFontHook)(hDlg, wMsg,wParam,lParam)) != 0) {
            return(wRet);
        }
    }

    switch(wMsg){
        case WM_INITDIALOG:
            if (!LoadString(hinsCur, iszRegular, (LPSTR)szRegular, CCHSTYLE) ||
                !LoadString(hinsCur, iszBold, (LPSTR)szBold, CCHSTYLE)       ||
                !LoadString(hinsCur, iszItalic, (LPSTR)szItalic, CCHSTYLE)   ||
                !LoadString(hinsCur, iszBoldItalic, (LPSTR)szBoldItalic, CCHSTYLE))
              {
                dwExtError = CDERR_LOADSTRFAILURE;
                EndDialog(hDlg, FALSE);
                return FALSE;
              }
            lpcf = (LPCHOOSEFONT)lParam;
            if ((lpcf->Flags & CF_LIMITSIZE) &&
                              (lpcf->nSizeMax < lpcf->nSizeMin))
              {
                dwExtError = CFERR_MAXLESSTHANMIN;
                EndDialog(hDlg, FALSE);
                return FALSE;
              }
            /* Save the pointer to the CHOOSEFONT struct. in the dialog's
             * property list. Also, allocate for a temporary LOGFONT struct.
             * to be used for the length of the dlg. session, the contents of
             * which will be copied over to the final LOGFONT (pointed to by
             * CHOOSEFONT) only if <OK> is selected.
             */

            plpcf = (LPCHOOSEFONT *)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(LPCHOOSEFONT));
            if (!plpcf) {
                dwExtError = CDERR_MEMALLOCFAILURE;
                EndDialog(hDlg, FALSE);
                return FALSE;
            }
            SetProp(hDlg, FONTPROP, (HANDLE)plpcf);
            glpfnFontHook = 0;

            lpcf = *(LPCHOOSEFONT FAR *)plpcf = (LPCHOOSEFONT)lParam;

            if (!hbmFont)
                hbmFont = LoadBitmaps(BMFONT);

            if (!(lpcf->Flags & CF_APPLY))
                HideDlgItem(hDlg, psh3);

            if (!(lpcf->Flags & CF_EFFECTS)) {
                HideDlgItem(hDlg, stc4);
                HideDlgItem(hDlg, cmb4);
            } else {
                // fill color list

                FillColorCombo(hDlg);
                for (nIndex = CCHCOLORS - 1; nIndex > 0; nIndex--) {
                    dw = SendDlgItemMessage(hDlg, cmb4, CB_GETITEMDATA, nIndex, 0L);
                    if (lpcf->rgbColors == dw)
                        break;
                }
                SendDlgItemMessage(hDlg, cmb4, CB_SETCURSEL, nIndex, 0L);
            }

            ComputeSampleTextRectangle(hDlg);
            FixComboHeights(hDlg);

            // init our LOGFONT

            if (!(lpcf->Flags & CF_INITTOLOGFONTSTRUCT)) {
                InitLF(lpcf->lpLogFont);
#if 0
                *lpcf->lpLogFont->lfFaceName   = 0;
                lpcf->lpLogFont->lfWeight      = FW_NORMAL;
                lpcf->lpLogFont->lfHeight      = 0;
                lpcf->lpLogFont->lfItalic      = 0;
                lpcf->lpLogFont->lfStrikeOut   = 0;
                lpcf->lpLogFont->lfUnderline   = 0;
#endif
            }

            // init effects

            if (!(lpcf->Flags & CF_EFFECTS)) {
                HideDlgItem(hDlg, grp1);
                HideDlgItem(hDlg, chx1);
                HideDlgItem(hDlg, chx2);
            } else {
                CheckDlgButton(hDlg, chx1, lpcf->lpLogFont->lfStrikeOut);
                CheckDlgButton(hDlg, chx2, lpcf->lpLogFont->lfUnderline);
            }

            nLastFontType = 0;

            if (!GetFontFamily(hDlg, lpcf->hDC, lpcf->Flags)) {
                dwExtError = CFERR_NOFONTS;
                EndDialog(hDlg, FALSE);
                RemoveProp(hDlg, FONTPROP);
                if (lpcf->Flags & CF_ENABLEHOOK)
                    glpfnFontHook = lpcf->lpfnHook;
                return FALSE;
            }

            if (!(lpcf->Flags & CF_NOFACESEL) && *lpcf->lpLogFont->lfFaceName) {
                CBSetSelFromText(GetDlgItem(hDlg, cmb1), lpcf->lpLogFont->lfFaceName);
                CBSetTextFromSel(GetDlgItem(hDlg, cmb1));
            }

            GetFontStylesAndSizes(hDlg, lpcf, TRUE);

            if (!(lpcf->Flags & CF_NOSTYLESEL)) {
                SetStyleSelection(hDlg, lpcf, TRUE);
            }

            if (!(lpcf->Flags & CF_NOSIZESEL) && lpcf->lpLogFont->lfHeight) {
                hdc = GetDC(NULL);
                GetPointString(szPoints, hdc, lpcf->lpLogFont->lfHeight);
                ReleaseDC(NULL, hdc);
                CBSetSelFromText(GetDlgItem(hDlg, cmb3), szPoints);
                SetDlgItemText(hDlg, cmb3, szPoints);
            }

            /* Hide the help button if it isn't needed */
            if (!(lpcf->Flags & CF_SHOWHELP)) {
                ShowWindow (hWndHelp = GetDlgItem(hDlg, pshHelp), SW_HIDE);
                EnableWindow (hWndHelp, FALSE);
            }

            SendDlgItemMessage(hDlg, cmb1, CB_LIMITTEXT, LF_FACESIZE-1, 0L);
            SendDlgItemMessage(hDlg, cmb2, CB_LIMITTEXT, LF_FACESIZE-1, 0L);
            SendDlgItemMessage(hDlg, cmb3, CB_LIMITTEXT, 4, 0L);

            // if hook function has been specified, let it do any additional
            // processing of this message.

            if (lpcf->Flags & CF_ENABLEHOOK)
                return (*lpcf->lpfnHook)(hDlg, wMsg, wParam, lParam);

            SetCursor(LoadCursor(NULL, IDC_ARROW));

            break;

        case WM_PAINT:
            if (BeginPaint(hDlg, &ps)) {
                DrawSampleText(hDlg, lpcf, ps.hdc);
                EndPaint(hDlg, &ps);
            }
            break;

        case WM_MEASUREITEM:
            hDC = GetDC(hDlg);
            hFont = (HFONT)SendMessage(hDlg, WM_GETFONT, 0, 0L);
            if (hFont)
                hFont = SelectObject(hDC, hFont);
            GetTextMetrics(hDC, &tm);
            if (hFont)
                SelectObject(hDC, hFont);
            ReleaseDC(hDlg, hDC);

            if (((LPMEASUREITEMSTRUCT)lParam)->itemID != -1)
                ((LPMEASUREITEMSTRUCT)lParam)->itemHeight = max(tm.tmHeight, DY_BITMAP);
            else
                // this is for 3.0.  since in 3.1 the CB_SETITEMHEIGH
                // will fix this.  note, this is off by one on 8514
                ((LPMEASUREITEMSTRUCT)lParam)->itemHeight = tm.tmHeight + 1;

            break;

        case WM_DRAWITEM:
            #define lpdis ((LPDRAWITEMSTRUCT)lParam)

            if (lpdis->itemID == 0xFFFF)
                break;

            if (lpdis->CtlID == cmb4)
                DrawColorComboItem(lpdis);
            else if (lpdis->CtlID == cmb1)
                DrawFamilyComboItem(lpdis);
            else
                DrawSizeComboItem(lpdis);
            break;

            #undef lpdis

        case WM_SYSCOLORCHANGE:
            DeleteObject(hbmFont);
            hbmFont = LoadBitmaps(BMFONT);
            break;

        case WM_COMMAND:
            return ProcessDlgCtrlCommand(hDlg, lpcf, wParam, lParam);
            break;

        case WM_CHOOSEFONT_GETLOGFONT:
            return FillInFont(hDlg, lpcf, (LPLOGFONT)lParam, TRUE);

        default:
            return FALSE;
    }
    return TRUE;
}

// given a logfont select the closest match in the style list

void NEAR PASCAL SelectStyleFromLF(HWND hwnd, LPLOGFONT lplf)
{
        int i, count, iSel;
        PLOGFONT plf;
        int weight_delta, best_weight_delta = 1000;
        BOOL bIgnoreItalic;

        count = (int)SendMessage(hwnd, CB_GETCOUNT, 0, 0L);
        iSel = 0;
        bIgnoreItalic = FALSE;

TryAgain:
        for (i = 0; i < count; i++) {
                plf = (PLOGFONT)LOWORD(SendMessage(hwnd, CB_GETITEMDATA, i, 0L));

                if (bIgnoreItalic ||
                    (plf->lfItalic && lplf->lfItalic) ||
                    (!plf->lfItalic && !lplf->lfItalic)) {

                        weight_delta = lplf->lfWeight - plf->lfWeight;
                        if (weight_delta < 0)
                                weight_delta = -weight_delta;

                        if (weight_delta < best_weight_delta) {
                                best_weight_delta = weight_delta;
                                iSel = i;
                        }
                }
        }
        if (!bIgnoreItalic && iSel == 0) {
                bIgnoreItalic = TRUE;
                goto TryAgain;
        }

        SendMessage(hwnd, CB_SETCURSEL, iSel, 0L);
}



// make the currently selected item the edit text for a combobox

int NEAR PASCAL CBSetTextFromSel(HWND hwnd)
{
        int iSel;
        char szFace[LF_FACESIZE];

        iSel = (int)SendMessage(hwnd, CB_GETCURSEL, 0, 0L);
        if (iSel >= 0) {
            SendMessage(hwnd, CB_GETLBTEXT, iSel, (LONG)(LPSTR)szFace);
            SetWindowText(hwnd, szFace);
        }
        return iSel;
}

// set the selection based on lpszString.  send notification
// messages if bNotify is TRUE

int NEAR PASCAL CBSetSelFromText(HWND hwnd, LPSTR lpszString)
{
        int iInd;

        iInd = CBFindString(hwnd, lpszString);

        if (iInd >= 0) {

            SendMessage(hwnd, CB_SETCURSEL, iInd, 0L);

        }
        return iInd;
}

// return the text and item data for a combo box based on the current
// edit text.  if the current edit text does not match anything in the
// listbox return CB_ERR

int NEAR PASCAL CBGetTextAndData(HWND hwnd, LPSTR lpszString, int iSize, LPDWORD lpdw)
{
    int iSel;

    GetWindowText(hwnd, lpszString, iSize);
    iSel = CBFindString(hwnd, lpszString);
    if (iSel < 0)
        return iSel;

    *lpdw = SendMessage(hwnd, CB_GETITEMDATA, iSel, 0L);
    return iSel;
}


// do an exact string find and return the index

int NEAR PASCAL CBFindString(HWND hwnd, LPSTR lpszString)
{
        int iItem, iCount;
        char szFace[LF_FACESIZE];

        iCount = (int)SendMessage(hwnd, CB_GETCOUNT, 0, 0L);

        for (iItem = 0; iItem < iCount; iItem++) {
                SendMessage(hwnd, CB_GETLBTEXT, iItem, (LONG)(LPSTR)szFace);
                if (!lstrcmpi(szFace, lpszString))
                    return iItem;
        }

        return CB_ERR;
}


#define GPS_COMPLAIN    0x0001
#define GPS_SETDEFSIZE  0x0002

// make sure the point size edit field is in range.
//
// returns:
//      the point size of the edit field limitted by the min/max size
//      0 if the field is empty


BOOL NEAR PASCAL GetPointSizeInRange(HWND hDlg, LPCHOOSEFONT lpcf, LPINT pts,
      WORD wFlags)
{
  char szBuffer[90];
  char szTitle[90];
  int nTmp;
  BOOL bOK;

  *pts = 0;

  if (GetDlgItemText(hDlg, cmb3, szBuffer, sizeof(szBuffer))) {
      nTmp = GetDlgItemInt(hDlg, cmb3, &bOK, TRUE);
      if (!bOK)
          nTmp = 0;
  } else if (wFlags & GPS_SETDEFSIZE) {
      nTmp = DEF_POINT_SIZE;
      bOK = TRUE;
  } else {
      /* We're just returning with 0 in *pts
       */
      return(FALSE);
  }

  /* Check that we got a number in range
   */
  if (wFlags & GPS_COMPLAIN) {
      if ((lpcf->Flags&CF_LIMITSIZE) &&
            (!bOK || nTmp>lpcf->nSizeMax || nTmp<lpcf->nSizeMin)) {
          bOK = FALSE;
          LoadString(hinsCur, iszSizeRange, szTitle, sizeof(szTitle));
          wsprintf(szBuffer, szTitle, lpcf->nSizeMin, lpcf->nSizeMax);
      } else if (!bOK)
          LoadString(hinsCur, iszSizeNumber, szBuffer, sizeof(szBuffer));

      if (!bOK) {
          GetWindowText(hDlg, szTitle, sizeof(szTitle));
          MessageBox(hDlg, szBuffer, szTitle, MB_OK | MB_ICONINFORMATION);
          return(FALSE);
      }
  }

  *pts = nTmp;
  return(TRUE);
}


/****************************************************************************
 *
 *  ProcessDlgCtrlCommand
 *
 *  PURPOSE    : Handles all WM_COMMAND messages for the font picker dialog
 *
 *  ASSUMES    : cmb1 - ID of font facename combobox
 *               cmb2 - "  "  style
 *               cmb3 - "  "  size
 *               chx1 - "  "  "Underline" checkbox
 *               chx2 - "  "  "Strikeout" checkbox
 *               stc5 - "  "  frame around text preview area
 *               psh4 - "  "  button that invokes the Help application
 *               IDOK - "  "  OK button to end dialog, retaining information
 *               IDCANCEL"  " button to cancel dialog, not doing anything.
 *
 *  RETURNS    : TRUE if message is processed succesfully, FALSE otherwise.
 *
 *  COMMENTS   : if the OK button is selected, all the font information is
 *               written into the CHOOSEFONT structure.
 *
 ****************************************************************************/

BOOL NEAR PASCAL ProcessDlgCtrlCommand(HWND hDlg, LPCHOOSEFONT lpcf, WORD wParam, LONG lParam)
{
    int iSel;
    char szPoints[10];
    char szStyle[LF_FACESIZE];
    DWORD dw;
    WORD  wCmbId;
    char szMsg[160], szTitle[160];

    switch (wParam) {

        case IDABORT:
            // this is how a hook can cause the dialog to go away

            FreeFonts(GetDlgItem(hDlg, cmb2));
            EndDialog(hDlg, LOWORD(lParam));
            RemoveProp(hDlg, FONTPROP);
            if (lpcf->Flags & CF_ENABLEHOOK)
                glpfnFontHook = lpcf->lpfnHook;
            break;

        case IDOK:
            if (!GetPointSizeInRange(hDlg, lpcf, &iSel,
                  GPS_COMPLAIN|GPS_SETDEFSIZE)) {
                PostMessage(hDlg, WM_NEXTDLGCTL, GetDlgItem(hDlg, cmb3), 1L);
                break;
            }
            lpcf->iPointSize = iSel * 10;

            FillInFont(hDlg, lpcf, lpcf->lpLogFont, TRUE);

            if (lpcf->Flags & CF_FORCEFONTEXIST)
              {
                if (lpcf->Flags & CF_NOFACESEL)
                    wCmbId = cmb1;
                else if (lpcf->Flags & CF_NOSTYLESEL)
                    wCmbId = cmb2;
                else
                    wCmbId = NULL;

                if (wCmbId)  /* Error found */
                  {
                    LoadString(hinsCur, (wCmbId == cmb1) ? iszNoFaceSel
                                    : iszNoStyleSel, szMsg, sizeof(szMsg));
                    GetWindowText(hDlg, szTitle, sizeof(szTitle));
                    MessageBox(hDlg, szMsg, szTitle, MB_OK|MB_ICONINFORMATION);
                    PostMessage(hDlg,WM_NEXTDLGCTL,GetDlgItem(hDlg,wCmbId),1L);
                    break;
                  }
              }

            if (lpcf->Flags & CF_EFFECTS) {
                // Get currently selected item in color combo box and the 32 bit
                // color rgb value associated with it
                iSel = (int)SendDlgItemMessage(hDlg, cmb4, CB_GETCURSEL, 0, 0L);
                lpcf->rgbColors= (DWORD)SendDlgItemMessage(hDlg, cmb4, CB_GETITEMDATA, iSel, 0L);
            }

            CBGetTextAndData(GetDlgItem(hDlg, cmb2), szStyle, sizeof(szStyle), &dw);
            lpcf->nFontType = HIWORD(dw);

            if (lpcf->Flags & CF_USESTYLE)
                lstrcpy(lpcf->lpszStyle, szStyle);

            // fall through

        case IDCANCEL:
            FreeFonts(GetDlgItem(hDlg, cmb2));
            EndDialog(hDlg, wParam == IDOK);
            RemoveProp(hDlg, FONTPROP);
            if (lpcf->Flags & CF_ENABLEHOOK)
                glpfnFontHook = lpcf->lpfnHook;
            break;

        case cmb1:      // facenames combobox
            switch (HIWORD(lParam)) {
            case CBN_SELCHANGE:
                CBSetTextFromSel(LOWORD(lParam));
FillStyles:
                // try to mainting the current point size and style
                GetDlgItemText(hDlg, cmb3, szPoints, sizeof(szPoints));
                GetFontStylesAndSizes(hDlg, lpcf, FALSE);
                SetStyleSelection(hDlg, lpcf, FALSE);


                // preserv the point size selection or put it in the
                // edit control if it is not in the list for this font

                iSel = CBFindString(GetDlgItem(hDlg, cmb3), szPoints);
                if (iSel < 0) {
                    SetDlgItemText(hDlg, cmb3, szPoints);
                } else {
                    SendDlgItemMessage(hDlg, cmb3, CB_SETCURSEL, iSel, 0L);
                    // 3.0 wipes out the edit text in the above call
                    if (wWinVer < 0x030A)
                        CBSetTextFromSel(GetDlgItem(hDlg, cmb3));
                }

                if (wWinVer < 0x030A)
                    PostMessage(hDlg, WM_COMMAND, cmb1, MAKELONG(LOWORD(lParam), CBN_MYSELCHANGE));
                goto DrawSample;
                break;

            case CBN_MYSELCHANGE:       // for 3.0
                CBSetTextFromSel(LOWORD(lParam));
                SendMessage(LOWORD(lParam), CB_SETEDITSEL, 0, 0xFFFF0000);
                break;

            case CBN_EDITUPDATE:
                PostMessage(hDlg, WM_COMMAND, wParam, MAKELONG(LOWORD(lParam), CBN_MYEDITUPDATE));
                break;

            // case CBN_EDITCHANGE:
            // case CBN_EDITUPDATE:
            case CBN_MYEDITUPDATE:
                GetWindowText(LOWORD(lParam), szStyle, sizeof(szStyle));
                iSel = CBFindString(LOWORD(lParam), szStyle);
                if (iSel >= 0) {
                        SendMessage(LOWORD(lParam), CB_SETCURSEL, iSel, 0L);
                        // 3.0 wipes out the edit text in the above call
                        if (wWinVer < 0x030A)
                            CBSetTextFromSel(LOWORD(lParam));
                        SendMessage(LOWORD(lParam), CB_SETEDITSEL, 0, -1L);
                        goto FillStyles;
                }
                break;
            }
            break;

        case cmb3:      // point sizes combobox
        case cmb2:      // styles combobox
            switch (HIWORD(lParam)) {
            case CBN_EDITUPDATE:
               PostMessage(hDlg, WM_COMMAND, wParam, MAKELONG(LOWORD(lParam), CBN_MYEDITUPDATE));
               break;

            // case CBN_EDITCHANGE:
            // case CBN_EDITUPDATE:
            case CBN_MYEDITUPDATE:
                if (wParam == cmb2) {
                    GetWindowText(LOWORD(lParam), szStyle, sizeof(szStyle));
                    iSel = CBFindString(LOWORD(lParam), szStyle);
                    if (iSel >= 0) {
                        SendMessage(LOWORD(lParam), CB_SETCURSEL, iSel, 0L);
                        // 3.0 wipes out the edit text in the above call
                        if (wWinVer < 0x030A)
                            CBSetTextFromSel(LOWORD(lParam));
                        SendMessage(LOWORD(lParam), CB_SETEDITSEL, 0, -1L);
                        goto DrawSample;
                    }
                }
                break;

            case CBN_SELCHANGE:
                iSel = CBSetTextFromSel(LOWORD(lParam));
                if (iSel >= 0) {
                    // make the style selection stick
                    if (wParam == cmb2) {
                        PLOGFONT plf = (PLOGFONT)(WORD)SendMessage(LOWORD(lParam), CB_GETITEMDATA, iSel, 0L);
                        lpcf->lpLogFont->lfWeight = plf->lfWeight;
                        lpcf->lpLogFont->lfItalic = plf->lfItalic;
                    }
                }

                if (wWinVer < 0x030A)
                    PostMessage(hDlg, WM_COMMAND, wParam, MAKELONG(LOWORD(lParam), CBN_MYSELCHANGE));
                goto DrawSample;

            case CBN_MYSELCHANGE:       // for 3.0
                CBSetTextFromSel(LOWORD(lParam));
                SendMessage(LOWORD(lParam), CB_SETEDITSEL, 0, 0xFFFF0000);
                break;

            case CBN_KILLFOCUS:
DrawSample:
                // force redraw of preview text for any size change
                InvalidateRect(hDlg, &rcText, FALSE);
                UpdateWindow(hDlg);
            }
            break;

        case cmb4:
            if (HIWORD(lParam) != CBN_SELCHANGE)
                break;

            // fall through

        case chx1:      // bold
        case chx2:      // italic
            goto DrawSample;

        case pshHelp:   // help
             if (msgHELP && lpcf->hwndOwner)
                 SendMessage(lpcf->hwndOwner, msgHELP, hDlg, (DWORD) lpcf);
             break;

        default:
            return (FALSE);
    }
    return TRUE;
}

//
// this returns the best of the 2 font types.
// the values of the font type bits are monotonic except the low
// bit (RASTER_FONTTYPE).  so we flip that bit and then can compare
// the words directly.
//

int NEAR PASCAL CmpFontType(WORD ft1, WORD ft2)
{
        ft1 &= ~(SCREEN_FONTTYPE | PRINTER_FONTTYPE);
        ft2 &= ~(SCREEN_FONTTYPE | PRINTER_FONTTYPE);

        ft1 ^= RASTER_FONTTYPE;         // flip these so we can compare
        ft2 ^= RASTER_FONTTYPE;

        return (int)ft1 - (int)ft2;
}


//      nFontType bits
//
//   SCALABLE DEVICE  RASTER
//     (TT)  (not GDI) (not scalable)
//      0       0       0       vector, ATM screen
//      0       0       1       GDI raster font
//      0       1       0       PS/LJ III, ATM printer, ATI/LaserMaster
//      0       1       1       non scalable device font
//      1       0       x       TT screen font
//      1       1       x       TT dev font

int FAR PASCAL FontFamilyEnumProc(LPLOGFONT lplf, LPTEXTMETRIC lptm, WORD nFontType, LPENUM_FONT_DATA lpData)
{
        int iItem;
        WORD nOldType, nNewType;

        lptm = lptm;

        // bounce non TT fonts
        if ((lpData->dwFlags & CF_TTONLY) &&
            !(nFontType & TRUETYPE_FONTTYPE))
                return TRUE;

        // bounce non scalable fonts
        if ((lpData->dwFlags & CF_SCALABLEONLY) &&
            (nFontType & RASTER_FONTTYPE))
                return TRUE;

        // bounce non ANSI fonts
        if ((lpData->dwFlags & CF_ANSIONLY) &&
            (lplf->lfCharSet != ANSI_CHARSET))
                return TRUE;

        // bounce proportional fonts
        if ((lpData->dwFlags & CF_FIXEDPITCHONLY) &&
            (lplf->lfPitchAndFamily & VARIABLE_PITCH))
                return TRUE;

        // bounce vector fonts
        if ((lpData->dwFlags & CF_NOVECTORFONTS) &&
            (lplf->lfCharSet == OEM_CHARSET))
                return TRUE;

        if (lpData->bPrinterFont)
                nFontType |= PRINTER_FONTTYPE;
        else
                nFontType |= SCREEN_FONTTYPE;

        // test for a name collision
        iItem = CBFindString(lpData->hwndFamily, lplf->lfFaceName);
        if (iItem >= 0) {
                nOldType = (WORD)SendMessage(lpData->hwndFamily, CB_GETITEMDATA, iItem, 0L);
                /* If we don't want screen fonts, but do want printer fonts,
                 * the old font is a screen font and the new font is a
                 * printer font, take the new font regardless of other flags.
                 * Note that this means if a printer wants TRUETYPE fonts, it
                 * should enumerate them.  Bug 9675, 12-12-91, Clark Cyr
                 */
                if (!(lpData->dwFlags & CF_SCREENFONTS)  &&
                     (lpData->dwFlags & CF_PRINTERFONTS) &&
                     (nFontType & PRINTER_FONTTYPE)      &&
                     (nOldType & SCREEN_FONTTYPE)         )
                  {
                    nOldType = 0; /* for setting nNewType below */
                    goto SetNewType;
                  }

                if (CmpFontType(nFontType, nOldType) > 0) {
SetNewType:
                        nNewType = nFontType;
                        SendMessage(lpData->hwndFamily, CB_INSERTSTRING, iItem, (LONG)(LPSTR)lplf->lfFaceName);
                        SendMessage(lpData->hwndFamily, CB_DELETESTRING, iItem + 1, 0L);
                } else {
                        nNewType = nOldType;
                }
                // accumulate the printer/screen ness of these fonts
                nNewType |= (nFontType | nOldType) & (SCREEN_FONTTYPE | PRINTER_FONTTYPE);

                SendMessage(lpData->hwndFamily, CB_SETITEMDATA, iItem, MAKELONG(nNewType, 0));
                return TRUE;
        }

        iItem = (int)SendMessage(lpData->hwndFamily, CB_ADDSTRING, 0, (LONG)(LPSTR)lplf->lfFaceName);
        if (iItem < 0)
                return FALSE;

        SendMessage(lpData->hwndFamily, CB_SETITEMDATA, iItem, MAKELONG(nFontType, 0));

        return TRUE;
}


/****************************************************************************
 *
 *  GetFontFamily
 *
 *  PURPOSE    : Fills the screen and/or printer font facenames into the font
 *               facenames combobox, depending on the CF_?? flags passed in.
 *
 *  ASSUMES    : cmb1 - ID of font facename combobox
 *
 *  RETURNS    : TRUE if succesful, FALSE otherwise.
 *
 *  COMMENTS   : Both screen and printer fonts are listed into the same combo
 *               box.
 *
 ****************************************************************************/

BOOL NEAR PASCAL GetFontFamily(HWND hDlg, HDC hDC, DWORD dwEnumCode)
{
     ENUM_FONT_DATA data;
     HANDLE hMod;
     int iItem, iCount;
     WORD nFontType;
     char szMsg[100], szTitle[40];
     WORD (FAR PASCAL *lpEnumFonts)(HDC, LPSTR, FARPROC, VOID FAR *);

     hMod = GetModuleHandle(szGDI);
     if (wWinVer < 0x030A)
         lpEnumFonts = (WORD (FAR PASCAL *)(HDC, LPSTR, FARPROC, VOID FAR *))GetProcAddress(hMod, szEnumFonts30);
     else
         lpEnumFonts = (WORD (FAR PASCAL *)(HDC, LPSTR, FARPROC, VOID FAR *))GetProcAddress(hMod, szEnumFonts31);

     if (!lpEnumFonts)
         return FALSE;

     data.hwndFamily = GetDlgItem(hDlg, cmb1);
     data.dwFlags = dwEnumCode;

     // this is a bit strage.  we have to get all the screen fonts
     // so if they ask for the printer fonts we can tell which
     // are really printer fonts.  that is so we don't list the
     // vector and raster fonts as printer device fonts

     data.hDC = GetDC(NULL);
     data.bPrinterFont = FALSE;
     (*lpEnumFonts)(data.hDC, NULL, FontFamilyEnumProc, &data);
     ReleaseDC(NULL, data.hDC);

     /* list out printer font facenames */
     if (dwEnumCode & CF_PRINTERFONTS) {
         data.hDC = hDC;
         data.bPrinterFont = TRUE;
         (*lpEnumFonts)(hDC, NULL, FontFamilyEnumProc, &data);
     }

     // now we have to remove those screen fonts if they didn't
     // ask for them.

     if (!(dwEnumCode & CF_SCREENFONTS)) {
        iCount = (int)SendMessage(data.hwndFamily, CB_GETCOUNT, 0, 0L);

        for (iItem = iCount - 1; iItem >= 0; iItem--) {
                nFontType = (WORD)SendMessage(data.hwndFamily, CB_GETITEMDATA, iItem, 0L);
                if ((nFontType & (SCREEN_FONTTYPE | PRINTER_FONTTYPE)) == SCREEN_FONTTYPE)
                        SendMessage(data.hwndFamily, CB_DELETESTRING, iItem, 0L);
        }
     }

     // for WYSIWYG mode we delete all the fonts that don't exist
     // on the screen and the printer

     if (dwEnumCode & CF_WYSIWYG) {
        iCount = (int)SendMessage(data.hwndFamily, CB_GETCOUNT, 0, 0L);

        for (iItem = iCount - 1; iItem >= 0; iItem--) {
                nFontType = (WORD)SendMessage(data.hwndFamily, CB_GETITEMDATA, iItem, 0L);
                if ((nFontType & (SCREEN_FONTTYPE | PRINTER_FONTTYPE)) != (SCREEN_FONTTYPE | PRINTER_FONTTYPE))
                        SendMessage(data.hwndFamily, CB_DELETESTRING, iItem, 0L);
        }
     }

     if ((int)SendMessage(data.hwndFamily, CB_GETCOUNT, 0, 0L) <= 0) {
         LoadString(hinsCur, iszNoFontsTitle, szTitle, sizeof(szTitle));
         LoadString(hinsCur, iszNoFontsMsg, szMsg, sizeof(szMsg));
         MessageBox(hDlg, szMsg, szTitle, MB_OK | MB_ICONINFORMATION);

         return FALSE;
     }

     return TRUE;
}

void NEAR PASCAL CBAddSize(HWND hwnd, int pts, LPCHOOSEFONT lpcf)
{
        int iInd;
        char szSize[10];
        int count, test_size;

        if ((lpcf->Flags & CF_LIMITSIZE) && ((pts > lpcf->nSizeMax) || (pts < lpcf->nSizeMin)))
                return;

        wsprintf(szSize, szPtFormat, pts);

        count = (int)SendMessage(hwnd, CB_GETCOUNT, 0, 0L);

        test_size = -1;

        for (iInd = 0; iInd < count; iInd++) {
            test_size = (int)SendMessage(hwnd, CB_GETITEMDATA, iInd, 0L);
            if (pts <= test_size)
                break;
        }

        if (pts == test_size)   /* don't add duplicates */
            return;

        iInd = (int)SendMessage(hwnd, CB_INSERTSTRING, iInd, (LONG)(LPSTR)szSize);

        if (iInd >= 0)
                SendMessage(hwnd, CB_SETITEMDATA, iInd, MAKELONG(pts, 0));
}

// sort styles by weight first, then italicness
// returns:
//      the index of the place this was inserted

int NEAR PASCAL InsertStyleSorted(HWND hwnd, LPSTR lpszStyle, LPLOGFONT lplf)
{
        int count, i;
        PLOGFONT plf;

        count = (int)SendMessage(hwnd, CB_GETCOUNT, 0, 0L);

        for (i = 0; i < count; i++) {
            plf = (PLOGFONT)LOWORD(SendMessage(hwnd, CB_GETITEMDATA, i, 0L));
            if (lplf->lfWeight < plf->lfWeight) {
                break;
            } else if (lplf->lfWeight == plf->lfWeight) {
                if (lplf->lfItalic && !plf->lfItalic)
                  i++;
                break;
            }
        }
        return (int)SendMessage(hwnd, CB_INSERTSTRING, i, (LONG)lpszStyle);
}


PLOGFONT NEAR PASCAL CBAddStyle(HWND hwnd, LPSTR lpszStyle, WORD nFontType, LPLOGFONT lplf)
{
        int iItem;
        PLOGFONT plf;

        // don't add duplicates

        if (CBFindString(hwnd, lpszStyle) >= 0)
                return NULL;

        iItem = (int)InsertStyleSorted(hwnd, lpszStyle, lplf);
        if (iItem < 0)
                return NULL;

        plf = (PLOGFONT)LocalAlloc(LMEM_FIXED, sizeof(LOGFONT));
        if (!plf) {
                SendMessage(hwnd, CB_DELETESTRING, iItem, 0L);
                return NULL;
        }

        *plf = *lplf;

        SendMessage(hwnd, CB_SETITEMDATA, iItem, MAKELONG(plf, nFontType));

        return plf;
}

// generate simulated forms from those that we have
//
// reg -> bold
// reg -> italic
// bold || italic || reg -> bold italic

void NEAR PASCAL FillInMissingStyles(HWND hwnd)
{
        PLOGFONT plf, plf_reg, plf_bold, plf_italic;
        WORD nFontType;
        int i, count;
        BOOL bBold, bItalic, bBoldItalic;
        DWORD dw;
        LOGFONT lf;

        bBold = bItalic = bBoldItalic = FALSE;
        plf_reg = plf_bold = plf_italic = NULL;

        count = (int)SendMessage(hwnd, CB_GETCOUNT, 0, 0L);
        for (i = 0; i < count; i++) {
                dw = SendMessage(hwnd, CB_GETITEMDATA, i, 0L);
                plf = (PLOGFONT)LOWORD(dw);
                nFontType = HIWORD(dw);
                if ((nFontType & BOLD_FONTTYPE) && (nFontType & ITALIC_FONTTYPE)) {
                    bBoldItalic = TRUE;
                } else if (nFontType & BOLD_FONTTYPE) {
                    bBold = TRUE;
                    plf_bold = plf;
                } else if (nFontType & ITALIC_FONTTYPE) {
                    bItalic = TRUE;
                    plf_italic = plf;
                } else
                    plf_reg = plf;
        }

        nFontType |= SIMULATED_FONTTYPE;

        if (!bBold && plf_reg) {
                lf = *plf_reg;
                lf.lfWeight = FW_BOLD;
                CBAddStyle(hwnd, szBold, nFontType | BOLD_FONTTYPE, &lf);
        }

        if (!bItalic && plf_reg) {
                lf = *plf_reg;
                lf.lfItalic = TRUE;
                CBAddStyle(hwnd, szItalic, nFontType | ITALIC_FONTTYPE, &lf);
        }
        if (!bBoldItalic && (plf_bold || plf_italic || plf_reg)) {
                if (plf_italic)
                        plf = plf_italic;
                else if (plf_bold)
                        plf = plf_bold;
                else
                        plf = plf_reg;

                lf = *plf;
                lf.lfItalic = TRUE;
                lf.lfWeight = FW_BOLD;
                CBAddStyle(hwnd, szBoldItalic, nFontType | BOLD_FONTTYPE | ITALIC_FONTTYPE, &lf);
        }
}

void NEAR PASCAL FillScalableSizes(HWND hwnd, LPCHOOSEFONT lpcf)
{
    CBAddSize(hwnd, 8, lpcf);
    CBAddSize(hwnd, 9, lpcf);
    CBAddSize(hwnd, 10, lpcf);
    CBAddSize(hwnd, 11, lpcf);
    CBAddSize(hwnd, 12, lpcf);
    CBAddSize(hwnd, 14, lpcf);
    CBAddSize(hwnd, 16, lpcf);
    CBAddSize(hwnd, 18, lpcf);
    CBAddSize(hwnd, 20, lpcf);
    CBAddSize(hwnd, 22, lpcf);
    CBAddSize(hwnd, 24, lpcf);
    CBAddSize(hwnd, 26, lpcf);
    CBAddSize(hwnd, 28, lpcf);
    CBAddSize(hwnd, 36, lpcf);
    CBAddSize(hwnd, 48, lpcf);
    CBAddSize(hwnd, 72, lpcf);
}

#define GDI_FONTTYPE_STUFF      (RASTER_FONTTYPE | DEVICE_FONTTYPE | TRUETYPE_FONTTYPE)

int FAR PASCAL FontStyleEnumProc(LPLOGFONT lplf, LPNEWTEXTMETRIC lptm, WORD nFontType, LPENUM_FONT_DATA lpData)
{
        int height, pts;
        char buf[10];

        // filter for a font type match (the font type of the selected face
        // must be the same as that enumerated)

        if (nFontType != (WORD)(GDI_FONTTYPE_STUFF & lpData->nFontType))
                return TRUE;

        if (!(nFontType & RASTER_FONTTYPE)) {

                // vector or TT font

                if (lpData->bFillSize &&
                    (int)SendMessage(lpData->hwndSizes, CB_GETCOUNT, 0, 0L) == 0) {
                        FillScalableSizes(lpData->hwndSizes, lpData->lpcf);
                }

        } else {

                height = lptm->tmHeight - lptm->tmInternalLeading;
                pts = GetPointString(buf, lpData->hDC, height);

                // filter devices same size of multiple styles
                if (CBFindString(lpData->hwndSizes, buf) < 0)
                        CBAddSize(lpData->hwndSizes, pts, lpData->lpcf);

        }

        // keep the printer/screen bits from the family list here too

        nFontType |= (lpData->nFontType & (SCREEN_FONTTYPE | PRINTER_FONTTYPE));

        if (nFontType & TRUETYPE_FONTTYPE) {

                // if (lptm->ntmFlags & NTM_REGULAR)
                if (!(lptm->ntmFlags & (NTM_BOLD | NTM_ITALIC)))
                        nFontType |= REGULAR_FONTTYPE;

                if (lptm->ntmFlags & NTM_ITALIC)
                        nFontType |= ITALIC_FONTTYPE;

                if (lptm->ntmFlags & NTM_BOLD)
                        nFontType |= BOLD_FONTTYPE;

                // after the LOGFONT.lfFaceName there are 2 more names
                // lfFullName[LF_FACESIZE * 2]
                // lfStyle[LF_FACESIZE]

                CBAddStyle(lpData->hwndStyle, lplf->lfFaceName + 3 * LF_FACESIZE, nFontType, lplf);

        } else {
                if ((lplf->lfWeight >= FW_BOLD) && lplf->lfItalic)
                    CBAddStyle(lpData->hwndStyle, szBoldItalic, nFontType | BOLD_FONTTYPE | ITALIC_FONTTYPE, lplf);
                else if (lplf->lfWeight >= FW_BOLD)
                    CBAddStyle(lpData->hwndStyle, szBold, nFontType | BOLD_FONTTYPE, lplf);
                else if (lplf->lfItalic)
                    CBAddStyle(lpData->hwndStyle, szItalic, nFontType | ITALIC_FONTTYPE, lplf);
                else
                    CBAddStyle(lpData->hwndStyle, szRegular, nFontType | REGULAR_FONTTYPE, lplf);
        }

        return TRUE;
}

void NEAR PASCAL FreeFonts(HWND hwnd)
{
        DWORD dw;
        int i, count;

        count = (int)SendMessage(hwnd, CB_GETCOUNT, 0, 0L);

        for (i = 0; i < count; i++) {
                dw = SendMessage(hwnd, CB_GETITEMDATA, i, 0L);
                LocalFree((HANDLE)LOWORD(dw));
        }

        SendMessage(hwnd, CB_RESETCONTENT, 0, 0L);
}

// initalize a LOGFONT strucuture to some base generic regular type font

void NEAR PASCAL InitLF(LPLOGFONT lplf)
{
        HDC hdc;

        lplf->lfEscapement = 0;
        lplf->lfOrientation = 0;
        lplf->lfCharSet = ANSI_CHARSET;
        lplf->lfOutPrecision = OUT_DEFAULT_PRECIS;
        lplf->lfClipPrecision = CLIP_DEFAULT_PRECIS;
        lplf->lfQuality = DEFAULT_QUALITY;
        lplf->lfPitchAndFamily = DEFAULT_PITCH;
        lplf->lfItalic = 0;
        lplf->lfWeight = FW_NORMAL;
        lplf->lfStrikeOut = 0;
        lplf->lfUnderline = 0;
        lplf->lfWidth = 0;      // otherwise we get independant x-y scaling
        lplf->lfFaceName[0] = 0;
        hdc = GetDC(NULL);
        lplf->lfHeight = -MulDiv(DEF_POINT_SIZE, GetDeviceCaps(hdc, LOGPIXELSY), POINTS_PER_INCH);
        ReleaseDC(NULL, hdc);
}



/****************************************************************************
 *
 *  GetFontStylesAndSizes
 *
 *  PURPOSE    : Fills the point sizes combo box with the point sizes for the
 *               current selection in the facenames combobox.
 *
 *  ASSUMES    : cmb1 - ID of font facename combobox
 *
 *  RETURNS    : TRUE if succesful, FALSE otherwise.
 *
 ****************************************************************************/

BOOL NEAR PASCAL GetFontStylesAndSizes(HWND hDlg, LPCHOOSEFONT lpcf, BOOL bForceSizeFill)
{
     ENUM_FONT_DATA data;
     char szFace[LF_FACESIZE];
     WORD nFontType;
     int iSel;
     int iMapMode;
     DWORD dwViewportExt, dwWindowExt;
     HANDLE hMod;
     LOGFONT lf;
     WORD (FAR PASCAL *lpEnumFonts)(HDC, LPSTR, FARPROC, VOID FAR *);

     bForceSizeFill = bForceSizeFill;

     hMod = GetModuleHandle(szGDI);
     if (wWinVer < 0x030A)
         lpEnumFonts = (WORD (FAR PASCAL *)(HDC, LPSTR, FARPROC, VOID FAR *))GetProcAddress(hMod, szEnumFonts30);
     else
         lpEnumFonts = (WORD (FAR PASCAL *)(HDC, LPSTR, FARPROC, VOID FAR *))GetProcAddress(hMod, szEnumFonts31);

     if (!lpEnumFonts)
         return FALSE;

     FreeFonts(GetDlgItem(hDlg, cmb2));

     data.hwndStyle = GetDlgItem(hDlg, cmb2);
     data.hwndSizes = GetDlgItem(hDlg, cmb3);
     data.dwFlags   = lpcf->Flags;
     data.lpcf      = lpcf;

     iSel = (int)SendDlgItemMessage(hDlg, cmb1, CB_GETCURSEL, 0, 0L);
     if (iSel < 0) {
         // if we don't have a face name selected we will synthisize
         // the standard font styles...

         InitLF(&lf);
         CBAddStyle(data.hwndStyle, szRegular, REGULAR_FONTTYPE, &lf);
         lf.lfWeight = FW_BOLD;
         CBAddStyle(data.hwndStyle, szBold, BOLD_FONTTYPE, &lf);
         lf.lfWeight = FW_NORMAL;
         lf.lfItalic = TRUE;
         CBAddStyle(data.hwndStyle, szItalic, ITALIC_FONTTYPE, &lf);
         lf.lfWeight = FW_BOLD;
         CBAddStyle(data.hwndStyle, szBoldItalic, BOLD_FONTTYPE | ITALIC_FONTTYPE, &lf);
         FillScalableSizes(data.hwndSizes, lpcf);

         return TRUE;
     }

     nFontType = (WORD)SendDlgItemMessage(hDlg, cmb1, CB_GETITEMDATA, iSel, 0L);

     data.nFontType  = nFontType;
#if 0
     data.bFillSize  = bForceSizeFill ||
                       (nLastFontType & RASTER_FONTTYPE) != (nFontType & RASTER_FONTTYPE) ||
                       (nFontType & RASTER_FONTTYPE);
/* This does the same thing as above, i.e. if either or both fonts are
 * raster fonts, update the sizes combobox.  If they're both non-raster,
 * don't update the combobox.
 */
     data.bFillSize  = bForceSizeFill ||
                       (nLastFontType & RASTER_FONTTYPE) ||
                       (nFontType & RASTER_FONTTYPE) ||
                       (SendMessage(data.hwndSizes, CB_GETCOUNT, 0, 0L) <= 0);
#else
     data.bFillSize = TRUE;
#endif

     if (data.bFillSize) {
        SendMessage(data.hwndSizes, CB_RESETCONTENT, 0, 0L);
        SendMessage(data.hwndSizes, WM_SETREDRAW, FALSE, 0L);
     }

     SendMessage(data.hwndStyle, WM_SETREDRAW, FALSE, 0L);

     GetDlgItemText(hDlg, cmb1, szFace, sizeof(szFace));

     if (lpcf->Flags & CF_SCREENFONTS) {
         data.hDC = GetDC(NULL);
         data.bPrinterFont = FALSE;
         (*lpEnumFonts)(data.hDC, szFace, FontStyleEnumProc, &data);
         ReleaseDC(NULL, data.hDC);
     }

     if (lpcf->Flags & CF_PRINTERFONTS) {
/* Bug #10619:  Save and restore the DC's mapping mode (and extents if
 * needed) if it's been set by the app to something other than MM_TEXT.
 *                          3 January 1992        Clark Cyr
 */
         if ((iMapMode = GetMapMode(lpcf->hDC)) != MM_TEXT)
           {
             if ((iMapMode == MM_ISOTROPIC) || (iMapMode == MM_ANISOTROPIC))
               {
                 dwViewportExt = GetViewportExt(lpcf->hDC);
                 dwWindowExt = GetWindowExt(lpcf->hDC);
               }
             SetMapMode(lpcf->hDC, MM_TEXT);
           }

         data.hDC = lpcf->hDC;
         data.bPrinterFont = TRUE;
         (*lpEnumFonts)(lpcf->hDC, szFace, FontStyleEnumProc, &data);

         if (iMapMode != MM_TEXT)
           {
             SetMapMode(lpcf->hDC, iMapMode);
             if ((iMapMode == MM_ISOTROPIC) || (iMapMode == MM_ANISOTROPIC))
               {
                 SetWindowExt(lpcf->hDC, LOWORD(dwWindowExt),
                                         HIWORD(dwWindowExt));
                 SetViewportExt(lpcf->hDC, LOWORD(dwViewportExt),
                                           HIWORD(dwViewportExt));
               }
           }
     }

     if (!(lpcf->Flags & CF_NOSIMULATIONS))
         FillInMissingStyles(data.hwndStyle);

     SendMessage(data.hwndStyle, WM_SETREDRAW, TRUE, 0L);
     if (wWinVer < 0x030A)
         InvalidateRect(data.hwndStyle, NULL, TRUE);

     if (data.bFillSize) {
         SendMessage(data.hwndSizes, WM_SETREDRAW, TRUE, 0L);
         if (wWinVer < 0x030A)
             InvalidateRect(data.hwndSizes, NULL, TRUE);
     }

     return TRUE;
}


/****************************************************************************
 *
 *  FillColorCombo
 *
 *  PURPOSE    : Adds the color name strings to the colors combobox.
 *
 *  ASSUMES    : cmb4 - ID of colors combobox
 *
 *  COMMENTS   : The color rectangles are drawn later in response to
 *               WM_DRAWITEM messages
 *
 ****************************************************************************/
void NEAR PASCAL FillColorCombo(HWND hDlg)
{
  int     iT, item;
  char    szT[CCHCOLORNAMEMAX];

  for (iT = 0; iT < CCHCOLORS; ++iT)
    {
      *szT = 0;
      LoadString(hinsCur, iszBlack + iT, szT, sizeof(szT));
      item = (int)SendDlgItemMessage(hDlg, cmb4, CB_INSERTSTRING, iT, (LONG)(LPSTR)szT);
      if (item >= 0)
          SendDlgItemMessage(hDlg, cmb4, CB_SETITEMDATA, item, rgbColors[iT]);
    }
}

/****************************************************************************
 *
 *  ComputeSampleTextRectangle
 *
 *  PURPOSE    : Determines the bounding rectangle for the text preview area,
 *               and fills in rcText.
 *
 *  ASSUMES    : stc5 - ID preview text rectangle
 *
 *  COMMENTS   : The coordinates are calculated w.r.t the dialog.
 *
 ****************************************************************************/

void NEAR PASCAL ComputeSampleTextRectangle(HWND hDlg)
{
    GetWindowRect(GetDlgItem (hDlg, stc5), &rcText);
    ScreenToClient(hDlg, (LPPOINT)&rcText.left);
    ScreenToClient(hDlg, (LPPOINT)&rcText.right);
}


BOOL NEAR PASCAL DrawSizeComboItem(LPDRAWITEMSTRUCT lpdis)
{
    HDC hDC;
    DWORD rgbBack, rgbText;
    char szFace[10];

    hDC = lpdis->hDC;

    if (lpdis->itemState & ODS_SELECTED) {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
    } else {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    }

    SendMessage(lpdis->hwndItem, CB_GETLBTEXT, lpdis->itemID, (LONG)(LPSTR)szFace);

    ExtTextOut(hDC, lpdis->rcItem.left + GetSystemMetrics(SM_CXBORDER), lpdis->rcItem.top, ETO_OPAQUE, &lpdis->rcItem, szFace, lstrlen(szFace), NULL);

    SetTextColor(hDC, rgbText);
    SetBkColor(hDC, rgbBack);

    return TRUE;
}


BOOL NEAR PASCAL DrawFamilyComboItem(LPDRAWITEMSTRUCT lpdis)
{
    HDC hDC, hdcMem;
    DWORD rgbBack, rgbText;
    char szFace[LF_FACESIZE + 10];
    HBITMAP hOld;
    int dy, x;

    hDC = lpdis->hDC;

    if (lpdis->itemState & ODS_SELECTED) {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
    } else {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    }

    // wsprintf(szFace, "%4.4X", LOWORD(lpdis->itemData));

    SendMessage(lpdis->hwndItem, CB_GETLBTEXT, lpdis->itemID, (LONG)(LPSTR)szFace);
    ExtTextOut(hDC, lpdis->rcItem.left + DX_BITMAP, lpdis->rcItem.top, ETO_OPAQUE, &lpdis->rcItem, szFace, lstrlen(szFace), NULL);

    hdcMem = CreateCompatibleDC(hDC);
    if (hdcMem) {
        if (hbmFont) {
            hOld = SelectObject(hdcMem, hbmFont);

            if (lpdis->itemData & TRUETYPE_FONTTYPE)
                x = 0;
            else if ((lpdis->itemData & (PRINTER_FONTTYPE | DEVICE_FONTTYPE)) == (PRINTER_FONTTYPE | DEVICE_FONTTYPE))
                // this may be a screen and printer font but
                // we will call it a printer font here
                x = DX_BITMAP;
            else
                goto SkipBlt;

            dy = ((lpdis->rcItem.bottom - lpdis->rcItem.top) - DY_BITMAP) / 2;

            BitBlt(hDC, lpdis->rcItem.left, lpdis->rcItem.top + dy, DX_BITMAP, DY_BITMAP, hdcMem,
                x, lpdis->itemState & ODS_SELECTED ? DY_BITMAP : 0, SRCCOPY);

SkipBlt:
            SelectObject(hdcMem, hOld);
        }
        DeleteDC(hdcMem);
    }

    SetTextColor(hDC, rgbText);
    SetBkColor(hDC, rgbBack);

    return TRUE;
}


/****************************************************************************
 *
 *  DrawColorComboItem
 *
 *  PURPOSE    : Called by main dialog fn. in response to a WM_DRAWITEM
 *               message, computes and draws the color combo items.
 *
 *  RETURNS    : TRUE if succesful, FALSE otherwise.
 *
 *  COMMENTS   : All color name strings have already loaded and filled into
 *               combobox.
 *
 ****************************************************************************/

BOOL NEAR PASCAL DrawColorComboItem(LPDRAWITEMSTRUCT lpdis)
{
    HDC     hDC;
    HBRUSH  hbr;
    WORD    dx, dy;
    RECT    rc;
    char    szColor[CCHCOLORNAMEMAX];
    DWORD   rgbBack, rgbText, dw;

    hDC = lpdis->hDC;

    if (lpdis->itemState & ODS_SELECTED) {
        rgbBack = SetBkColor(hDC, GetSysColor (COLOR_HIGHLIGHT));
        rgbText = SetTextColor(hDC, GetSysColor (COLOR_HIGHLIGHTTEXT));
    } else {
        rgbBack = SetBkColor(hDC, GetSysColor (COLOR_WINDOW));
        rgbText = SetTextColor(hDC, GetSysColor (COLOR_WINDOWTEXT));
    }
    ExtTextOut(hDC, lpdis->rcItem.left, lpdis->rcItem.top, ETO_OPAQUE, &lpdis->rcItem, NULL, 0, NULL);

    /* compute coordinates of color rectangle and draw it */
    dx = (WORD)GetSystemMetrics(SM_CXBORDER);
    dy = (WORD)GetSystemMetrics(SM_CYBORDER);
    rc.top    = lpdis->rcItem.top + dy;
    rc.bottom = lpdis->rcItem.bottom - dy;
    rc.left   = lpdis->rcItem.left + dx;
    rc.right  = rc.left + 2 * (rc.bottom - rc.top);

    if (wWinVer < 0x030A)
        dw = SendMessage(lpdis->hwndItem, CB_GETITEMDATA, lpdis->itemID, 0L);
    else
        dw = lpdis->itemData;

    hbr = CreateSolidBrush(dw);
    if (!hbr)
        return FALSE;

    hbr = SelectObject (hDC, hbr);
    Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom);
    DeleteObject(SelectObject(hDC, hbr));

    /* shift the color text right by the width of the color rectangle */
    *szColor = 0;
    SendMessage(lpdis->hwndItem, CB_GETLBTEXT, lpdis->itemID, (LONG)(LPSTR)szColor);
    TextOut(hDC, 2 * dx + rc.right, lpdis->rcItem.top, szColor, lstrlen(szColor));

    SetTextColor(hDC, rgbText);
    SetBkColor(hDC, rgbBack);

    return TRUE;
}

/****************************************************************************
 *
 *  DrawSampleText
 *
 *  PURPOSE    : To display the sample text with the given attributes
 *
 *  COMMENTS   : Assumes rcText holds the coordinates of the area within the
 *               frame (relative to dialog client) which text should be drawn in
 *
 ****************************************************************************/

void NEAR PASCAL DrawSampleText(HWND hDlg, LPCHOOSEFONT lpcf, HDC hDC)
{
    DWORD rgbText;
    DWORD rgbBack;
    int iItem;
    HFONT hFont, hTemp;
    char szSample[50];
    LOGFONT lf;
    int len, x, y, dx, dy;
    TEXTMETRIC tm;
    BOOL bCompleteFont;

    bCompleteFont = FillInFont(hDlg, lpcf, &lf, FALSE);

    hFont = CreateFontIndirect(&lf);
    if (!hFont)
        return;

    hTemp = SelectObject(hDC, hFont);

    rgbBack = SetBkColor(hDC, GetSysColor(COLOR_WINDOW));

    if (lpcf->Flags & CF_EFFECTS) {
        iItem = (int)SendDlgItemMessage(hDlg, cmb4, CB_GETCURSEL, 0, 0L);
        if (iItem != CB_ERR)
            rgbText = SendDlgItemMessage(hDlg, cmb4, CB_GETITEMDATA, iItem, 0L);
        else
            goto GetWindowTextColor;
    }
    else
      {
GetWindowTextColor:
        rgbText = GetSysColor(COLOR_WINDOWTEXT);
      }

    rgbText = SetTextColor(hDC, rgbText);

    if (bCompleteFont)
        GetDlgItemText(hDlg, stc5, szSample, sizeof(szSample));
    else
        szSample[0] = 0;

    GetTextMetrics(hDC, &tm);

    len = lstrlen(szSample);
    dx = (int)GetTextExtent(hDC, szSample, len);
    dy = tm.tmAscent - tm.tmInternalLeading;

    if ((dx >= (rcText.right - rcText.left)) || (dx <= 0))
        x = rcText.left;
    else
        x = rcText.left   + ((rcText.right - rcText.left) - (int)dx) / 2;

    y = min(rcText.bottom, rcText.bottom - ((rcText.bottom - rcText.top) - (int)dy) / 2);

    ExtTextOut(hDC, x, y - (tm.tmAscent), ETO_OPAQUE | ETO_CLIPPED, &rcText, szSample, len, NULL);

    SetBkColor(hDC, rgbBack);
    SetTextColor(hDC, rgbText);

    if (hTemp)
        DeleteObject(SelectObject(hDC, hTemp));
}


// fill in the LOGFONT strucuture based on the current selection
//
// in:
//      bSetBits        if TRUE the Flags fields in the lpcf are set to
//                      indicate what parts (face, style, size) are not
//                      selected
// out:
//      lplf            filled in LOGFONT
//
// returns:
//      TRUE    if there was an unambigious selection
//              (the LOGFONT is filled as per the enumeration in)
//      FALSE   there was not a complete selection
//              (fields set in the LOGFONT with default values)


BOOL NEAR PASCAL FillInFont(HWND hDlg, LPCHOOSEFONT lpcf, LPLOGFONT lplf, BOOL bSetBits)
{
    HDC hdc;
    int iSel, id, pts;
    DWORD dw;
    WORD nFontType;
    PLOGFONT plf;
    char szStyle[LF_FACESIZE];
    char szMessage[128];
    BOOL bFontComplete = TRUE;

    InitLF(lplf);

    GetDlgItemText(hDlg, cmb1, lplf->lfFaceName, sizeof(lplf->lfFaceName));
    if (CBFindString(GetDlgItem(hDlg, cmb1), lplf->lfFaceName) >= 0) {
        if (bSetBits)
            lpcf->Flags &= ~CF_NOFACESEL;
    } else {
        bFontComplete = FALSE;
        if (bSetBits)
            lpcf->Flags |= CF_NOFACESEL;
    }

    iSel = CBGetTextAndData(GetDlgItem(hDlg, cmb2), szStyle, sizeof(szStyle), &dw);
    if (iSel >= 0) {
        nFontType = HIWORD(dw);
        plf = (PLOGFONT)LOWORD(dw);
        *lplf = *plf;   // copy the LOGFONT
        lplf->lfWidth = 0;      // 1:1 x-y scaling
        if (bSetBits)
            lpcf->Flags &= ~CF_NOSTYLESEL;
    } else {
        bFontComplete = FALSE;
        if (bSetBits)
            lpcf->Flags |= CF_NOSTYLESEL;
        nFontType = 0;
    }

    // now make sure the size is in range; pts will be 0 if not
    GetPointSizeInRange(hDlg, lpcf, &pts, 0);

    hdc = GetDC(NULL);
    if (pts) {
        lplf->lfHeight = -MulDiv(pts, GetDeviceCaps(hdc, LOGPIXELSY), POINTS_PER_INCH);
        if (bSetBits)
            lpcf->Flags &= ~CF_NOSIZESEL;
    } else {
        lplf->lfHeight = -MulDiv(DEF_POINT_SIZE, GetDeviceCaps(hdc, LOGPIXELSY), POINTS_PER_INCH);
        bFontComplete = FALSE;
        if (bSetBits)
            lpcf->Flags |= CF_NOSIZESEL;
    }
    ReleaseDC(NULL, hdc);

    // and the attributes we control

    lplf->lfStrikeOut = (BYTE)IsDlgButtonChecked(hDlg, chx1);
    lplf->lfUnderline = (BYTE)IsDlgButtonChecked(hDlg, chx2);

    if (nFontType != nLastFontType) {

        if (lpcf->Flags & CF_PRINTERFONTS) {
            if (nFontType & SIMULATED_FONTTYPE) {
                id = iszSynth;
            } else if (nFontType & TRUETYPE_FONTTYPE) {
                id = iszTrueType;
            } else if ((nFontType & (PRINTER_FONTTYPE | SCREEN_FONTTYPE)) == SCREEN_FONTTYPE) {
                id = iszGDIFont;
            } else if ((nFontType & (PRINTER_FONTTYPE | DEVICE_FONTTYPE)) == (PRINTER_FONTTYPE | DEVICE_FONTTYPE)) {
                // may be both screen and printer (ATM) but we'll just
                // call this a printer font
                id = iszPrinterFont;
            } else {
                szMessage[0] = 0;
                goto SetText;
            }
            LoadString(hinsCur, id, szMessage, sizeof(szMessage));
SetText:
            SetDlgItemText(hDlg, stc6, szMessage);
        }
    }
    nLastFontType = nFontType;

    return bFontComplete;

}

/****************************************************************************
 *
 *  TermFont
 *
 *  PURPOSE    : To release any data required by functions in this module
 *               Called from WEP on exit from DLL
 *
 ****************************************************************************/
void FAR PASCAL TermFont(void)
{
        if (hbmFont)
                DeleteObject(hbmFont);
}

/****************************************************************************
 *
 *  GetPointString
 *
 *  PURPOSE    : Converts font height into a string of digits repr. pointsize
 *
 *  RETURNS    : size in points and fills in buffer with string
 *
 ****************************************************************************/
int NEAR PASCAL GetPointString(LPSTR buf, HDC hDC, int height)
{
    int pts;

    pts = MulDiv((height < 0) ? -height : height, 72, GetDeviceCaps(hDC, LOGPIXELSY));
    wsprintf(buf, szPtFormat, pts);
    return pts;
}


//
// BOOL FAR PASCAL LoadBitmaps()
//
// this routine loads DIB bitmaps, and "fixes up" their color tables
// so that we get the desired result for the device we are on.
//
// this routine requires:
//      the DIB is a 16 color DIB authored with the standard windows colors
//      bright blue (00 00 FF) is converted to the background color!
//      light grey  (C0 C0 C0) is replaced with the button face color
//      dark grey   (80 80 80) is replaced with the button shadow color
//
// this means you can't have any of these colors in your bitmap
//

#define BACKGROUND      0x000000FF      // bright blue
#define BACKGROUNDSEL   0x00FF00FF      // bright blue
#define BUTTONFACE      0x00C0C0C0      // bright grey
#define BUTTONSHADOW    0x00808080      // dark grey

DWORD NEAR PASCAL FlipColor(DWORD rgb)
{
        return RGB(GetBValue(rgb), GetGValue(rgb), GetRValue(rgb));
}


HBITMAP NEAR PASCAL LoadBitmaps(int id)
{
  HDC                   hdc;
  HANDLE                h;
  DWORD FAR             *p;
  LPSTR                 lpBits;
  HANDLE                hRes;
  LPBITMAPINFOHEADER    lpBitmapInfo;
  int numcolors;
  DWORD rgbSelected;
  DWORD rgbUnselected;
  HBITMAP hbm;

  rgbSelected = FlipColor(GetSysColor(COLOR_HIGHLIGHT));
  rgbUnselected = FlipColor(GetSysColor(COLOR_WINDOW));

  h = FindResource(hinsCur, MAKEINTRESOURCE(id), RT_BITMAP);
  hRes = LoadResource(hinsCur, h);

  /* Lock the bitmap and get a pointer to the color table. */
  lpBitmapInfo = (LPBITMAPINFOHEADER)LockResource(hRes);

  if (!lpBitmapInfo)
        return FALSE;

  p = (DWORD FAR *)((LPSTR)(lpBitmapInfo) + lpBitmapInfo->biSize);

  /* Search for the Solid Blue entry and replace it with the current
   * background RGB.
   */
  numcolors = 16;

  while (numcolors-- > 0) {
      if (*p == BACKGROUND)
          *p = rgbUnselected;
      else if (*p == BACKGROUNDSEL)
          *p = rgbSelected;
#if 0
      else if (*p == BUTTONFACE)
          *p = FlipColor(GetSysColor(COLOR_BTNFACE));
      else if (*p == BUTTONSHADOW)
          *p = FlipColor(GetSysColor(COLOR_BTNSHADOW));
#endif

      p++;
  }
  UnlockResource(hRes);

  /* Now create the DIB. */
  lpBitmapInfo = (LPBITMAPINFOHEADER)LockResource(hRes);

  /* First skip over the header structure */
  lpBits = (LPSTR)(lpBitmapInfo + 1);

  /* Skip the color table entries, if any */
  lpBits += (1 << (lpBitmapInfo->biBitCount)) * sizeof(RGBQUAD);

  /* Create a color bitmap compatible with the display device */
  hdc = GetDC(NULL);
  hbm = CreateDIBitmap(hdc, lpBitmapInfo, (DWORD)CBM_INIT, lpBits, (LPBITMAPINFO)lpBitmapInfo, DIB_RGB_COLORS);
  ReleaseDC(NULL, hdc);

  MySetObjectOwner(hbm);

  GlobalUnlock(hRes);
  FreeResource(hRes);

  return hbm;
}

#if 0
#define ISDIGIT(c)  ((c) >= '0' && (c) <= '9')

int NEAR PASCAL atoi(LPSTR sz)
{
    int n = 0;
    BOOL bNeg = FALSE;

    if (*sz == '-') {
        bNeg = TRUE;
        sz++;
    }

    while (ISDIGIT(*sz)) {
        n *= 10;
        n += *sz - '0';
        sz++;
    }
    return bNeg ? -n : n;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\commdlg\isz.h ===
//---------------------------------------------------------------------------
// Isz.h : String resource IDs for dialogs
//
// Copyright (c) Microsoft Corporation, 1990-
//---------------------------------------------------------------------------

    // 0x0000 - 0x00ff Error codes

// MESSAGES:  0x0100 to 0x01ff
#define iszOverwriteCaption     0x0100
#define iszOverwriteQuestion    0x0101
#define iszDefExitCaption       0x0102
#define iszDefExitText          0x0103

#define iszDefaultPitch         0x0104
#define iszFixedPitch           0x0105
#define iszVariablePitch        0x0106
#define iszAnsiCharset          0x0107
#define iszOemCharset           0x0108
#define iszSymbolCharset        0x0109
#define iszDecorativeFamily     0x010a
#define iszUnknownFamily        0x010b
#define iszModernFamily         0x010c
#define iszRomanFamily          0x010d
#define iszScriptFamily         0x010e
#define iszSwissFamily          0x010f

#define iszSystemFont           0x0110
#define iszHelvFont             0x0111
#define iszCourierFont          0x0112
#define iszTmsRmnFont           0x0113
#define iszSymbolFont           0x0114
#define iszRomanFont            0x0115
#define iszScriptFont           0x0116
#define iszModernFont           0x0117
#define iszLastFont             iszModernFont

#define iszFileOpenTitle        0x0180
#define iszFileSaveTitle        0x0181
#define iszSaveFileAsType       0x0182
#define iszDriveDoesNotExist    0x0183
#define iszNoDiskInDrive        0x0184
#define iszWrongDiskInDrive     0x0185
#define iszUnformatedDisk       0x0186
#define iszFileNotFound         0x0187
#define iszPathNotFound         0x0188
#define iszInvalidFileName      0x0189
#define iszSharingViolation     0x018A
#define iszAccessDenied         0x018B
#define iszReadOnly             0x018C
#define iszInt24Error           0x018D
#define iszPortName             0x018E
#define iszWriteProtection      0x018F
#define iszDiskFull             0x0190
#define iszNoFileHandles        0x0191
#define iszCreatePrompt         0x0192
#define iszCreateNoModify       0x0193
#define iszSelectDriveTrouble   0x0194

// RESOURCES:  0x0200 to 0x020f
    // Menus:           0x0200 to 0x020f
    // Icons:           0x0210 to 0x021f
    // Cursors:         0x0220 to 0x022f
    // Accelerators:    0x0230 to 0x023f
    // Bitmaps:         0x0240 to 0x024f
    // Private:         0x0250 to 0x025f

#define icoPortrait         528
#define icoLandscape        529

#define bmpDirDrive	    576
#define bmpCrossHair        584
#define bmpCurLum           585
#define bmpHls              586
 
#define rcdataDefColors     592
 

// DIALOGS:  0x0300 to 0x03ff
#define dlgFileOpen         0x0300
#define dlgFileSave         0x0301
#define dlgExitChanges      0x0302
#define dlgChooseColor      0x0303
#define dlgFindText         0x0304
#define dlgReplaceText      0x0305
#define dlgFormatChar       0x0306
#define dlgFontInfo         0x0307
#define dlgPrintDlg         0x0308
#define dlgPrintSetupDlg    0x0309
#define dlgMultiFileOpen    0x030a


// MISC:  0x0400 to 0x04ff
#define BMLEFT              30
#define BMUP                31
#define BMRIGHT             32
#define BMDOWN              33
#define BMLEFTI             34
#define BMUPI               35
#define BMRIGHTI            36
#define BMDOWNI             37
#define BMFONT              38

#define iszSampleString     0x040c   /* sample text for Font picker   */
#define iszClose	    0x040d   /* "Close" text for find/replace */


#define iszBlack            0x0410
#define iszDkRed            0x0411
#define iszDkGreen          0x0412
#define iszDkYellow         0x0413
#define iszDkBlue           0x0414
#define iszDkPurple         0x0415
#define iszDkAqua           0x0416
#define iszDkGrey           0x0417
#define iszLtGrey           0x0418
#define iszLtRed            0x0419
#define iszLtGreen          0x041a
#define iszLtYellow         0x041b
#define iszLtBlue           0x041c
#define iszLtPurple         0x041d
#define iszLtAqua           0x041e
#define iszWhite            0x041f

#define iszAtomData         0x0420

#define iszHighPrnQ         0x0430
#define iszMedPrnQ          0x0431
#define iszLowPrnQ          0x0432
#define iszDraftPrnQ        0x0433

#define iszPrinter          0x0440
#define iszSysPrn           0x0441
#define iszPrnOnPort        0x0442
#define iszExtDev           0x0443
#define iszDevMode          0x0444
#define iszDevCap           0x0445
#define iszDefCurOn         0x0446
#define iszLocal            0x0447
#define iszPrintSetup       0x0448

#define iszSizeNumber           0x44A
#define iszSizeRange            0x44B
#define iszSynth      		0x44C
#define iszTrueType   		0x44D
#define iszPrinterFont		0x44E
#define iszGDIFont    		0x44F

#define iszFromBelowMin         0x450
#define iszFromAboveMax         0x451
#define iszToBelowMin           0x452
#define iszToAboveMax           0x453
#define iszFromInvalidChar      0x454
#define iszToInvalidChar        0x455
#define iszFromAndToEmpty       0x456
#define iszCopiesEmpty          0x457
#define iszCopiesInvalidChar    0x458
#define iszCopiesZero           0x459
#define iszNoPrnsInstalled      0x45A
#define iszPrnDrvNotFound       0x45B

#define iszPaperSizeIndex   0x0480	// and up are used

#define iszNoFontsTitle	    0x0500
#define iszNoFontsMsg	    0x0501
#define iszNoFaceSel	    0x0502
#define iszNoStyleSel	    0x0503
#define iszRegular   	    0x0504
#define iszBold      	    0x0505
#define iszItalic    	    0x0506
#define iszBoldItalic	    0x0507

/* CCHSTYLE is the max allowed length of iszRegular to iszBoldItalic strings */
#define CCHSTYLE  32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\commdlg\parse.c ===
#define NOCOMM
#define NOWH

#include "windows.h"
#include "parse.h"

#define chSpace        ' '
#define chPeriod       '.'

long ParseFile(ULPSTR lpstrFileName);
LPSTR mystrchr(LPSTR, int);
#define chMatchOne     '?'
#define chMatchAny     '*'

LPSTR mystrchr(LPSTR str, int ch)
{
  while(*str)
    {
      if (ch == *str)
          return(str);
      str = AnsiNext(str);
    }
  return(NULL);
}

/*---------------------------------------------------------------------------
 * GetFileTitle
 * Purpose:  API to outside world to obtain the title of a file given the
 *              file name.  Useful if file name received via some method
 *              other that GetOpenFileName (e.g. command line, drag drop).
 * Assumes:  lpszFile  points to NULL terminated DOS filename (may have path)
 *           lpszTitle points to buffer to receive NULL terminated file title
 *           wBufSize  is the size of buffer pointed to by lpszTitle
 * Returns:  0 on success
 *           < 0, Parsing failure (invalid file name)
 *           > 0, buffer too small, size needed (including NULL terminator)
 *--------------------------------------------------------------------------*/
short FAR PASCAL
GetFileTitle(LPCSTR lpszFile, LPSTR lpszTitle, WORD wBufSize)
{
  short nNeeded;
  LPSTR lpszPtr;

  nNeeded = (WORD) ParseFile((ULPSTR)lpszFile);
  if (nNeeded >= 0)         /* Is the filename valid? */
    {
      lpszPtr = (LPSTR)lpszFile + nNeeded;
      if ((nNeeded = (short)(lstrlen(lpszPtr) + 1)) <= (short) wBufSize)
        {
          /* ParseFile() fails if wildcards in directory, but OK if in name */
          /* Since they aren't OK here, the check needed here               */
          if (mystrchr(lpszPtr, chMatchAny) || mystrchr(lpszPtr, chMatchOne))
            {
              nNeeded = PARSE_WILDCARDINFILE;  /* Failure */
            }
          else
            {
              lstrcpy(lpszTitle, lpszPtr);
              nNeeded = 0;  /* Success */
            }
        }
    }
  return(nNeeded);
}

/*---------------------------------------------------------------------------
 * ParseFile
 * Purpose:  Determine if the filename is a legal DOS name
 * Input:    Long pointer to a SINGLE file name
 *           Circumstance checked:
 *           1) Valid as directory name, but not as file name
 *           2) Empty String
 *           3) Illegal Drive label
 *           4) Period in invalid location (in extention, 1st in file name)
 *           5) Missing directory character
 *           6) Illegal character
 *           7) Wildcard in directory name
 *           8) Double slash beyond 1st 2 characters
 *           9) Space character in the middle of the name (trailing spaces OK)
 *          10) Filename greater than 8 characters
 *          11) Extention greater than 3 characters
 * Notes:
 *   Filename length is NOT checked.
 *   Valid filenames will have leading spaces, trailing spaces and
 *     terminating period stripped in place.
 *
 * Returns:  If valid, LOWORD is byte offset to filename
 *                     HIWORD is byte offset to extention
 *                            if string ends with period, 0
 *                            if no extention is given, string length
 *           If invalid, LOWORD is error code suggesting problem (< 0)
 *                       HIWORD is approximate offset where problem found
 *                         Note that this may be beyond the offending character
 * History:
 * Thu 24-Jan-1991 12:20:00  -by-  Clark R. Cyr  [clarkc]
 *   Initial writing
 * Thu 21-Feb-1991 10:19:00  -by-  Clark R. Cyr  [clarkc]
 *   Changed to unsigned character pointer
 *--------------------------------------------------------------------------*/

long ParseFile(ULPSTR lpstrFileName)
{
  short nFile, nExt, nFileOffset, nExtOffset;
  BOOL bExt;
  BOOL bWildcard;
  short nNetwork = 0;
  BOOL  bUNCPath = FALSE;
  ULPSTR lpstr = lpstrFileName;

/* Strip off initial white space.  Note that TAB is not checked */
/* because it cannot be received out of a standard edit control */
/* 30 January 1991  clarkc                                      */
  while (*lpstr == chSpace)
      lpstr++;

  if (!*lpstr)
    {
      nFileOffset = PARSE_EMPTYSTRING;
      goto FAILURE;
    }

  if (lpstr != lpstrFileName)
    {
      lstrcpy((LPSTR)lpstrFileName, (LPSTR)lpstr);
      lpstr = lpstrFileName;
    }

  if (*AnsiNext((LPSTR)lpstr) == ':')
    {
      unsigned char cDrive = (unsigned char)((*lpstr | (unsigned char) 0x20));  /* make lowercase */

/* This does not test if the drive exists, only if it's legal */
      if ((cDrive < 'a') || (cDrive > 'z'))
        {
          nFileOffset = PARSE_INVALIDDRIVE;
          goto FAILURE;
        }
      lpstr = (ULPSTR)AnsiNext(AnsiNext((LPSTR)lpstr));
    }

  if ((*lpstr == '\\') || (*lpstr == '/'))
    {
      if (*++lpstr == chPeriod)               /* cannot have c:\. */
        {
          if ((*++lpstr != '\\') && (*lpstr != '/'))   
            {
              if (!*lpstr)        /* it's the root directory */
                  goto MustBeDir;

              nFileOffset = PARSE_INVALIDPERIOD;
              goto FAILURE;
            }
          else
              ++lpstr;   /* it's saying top directory (again), thus allowed */
        }
      else if ((*lpstr == '\\') && (*(lpstr-1) == '\\'))
        {
/* It seems that for a full network path, whether a drive is declared or
 * not is insignificant, though if a drive is given, it must be valid
 * (hence the code above should remain there).
 * 13 February 1991           clarkc
 */
          ++lpstr;            /* ...since it's the first slash, 2 are allowed */
          nNetwork = -1;      /* Must receive server and share to be real     */
          bUNCPath = TRUE;    /* No wildcards allowed if UNC name             */
        }
      else if (*lpstr == '/')
        {
          nFileOffset = PARSE_INVALIDDIRCHAR;
          goto FAILURE;
        }
    }
  else if (*lpstr == chPeriod)
    {
      if (*++lpstr == chPeriod)  /* Is this up one directory? */
          ++lpstr;
      if (!*lpstr)
          goto MustBeDir;
      if ((*lpstr != '\\') && (*lpstr != '/'))
        {
          nFileOffset = PARSE_INVALIDPERIOD;
          goto FAILURE;
        }
      else
          ++lpstr;   /* it's saying directory, thus allowed */
    }

  if (!*lpstr)
    {
      goto MustBeDir;
    }

/* Should point to first char in 8.3 filename by now */
  nFileOffset = nExtOffset = nFile = nExt = 0;
  bWildcard = bExt = FALSE;
  while (*lpstr)
    {
/*
 *  The next comparison MUST be unsigned to allow for extended characters!
 *  21 Feb 1991   clarkc
 */
      if (*lpstr < chSpace)
        {
          nFileOffset = PARSE_INVALIDCHAR;
          goto FAILURE;
        }
      switch (*lpstr)
        {
          case '"':             /* All invalid */
          case '+':
          case ',':
          case ':':
          case ';':
          case '<':
          case '=':
          case '>':
          case '[':
          case ']':
          case '|':
            {
              nFileOffset = PARSE_INVALIDCHAR;
              goto FAILURE;
            }

          case '\\':      /* Subdirectory indicators */
          case '/':
            nNetwork++;
            if (bWildcard)
              {
                nFileOffset = PARSE_WILDCARDINDIR;
                goto FAILURE;
              }

            else if (nFile == 0)        /* can't have 2 in a row */
              {
                nFileOffset = PARSE_INVALIDDIRCHAR;
                goto FAILURE;
              }
            else
              {                         /* reset flags */
                ++lpstr;
                if (!nNetwork && !*lpstr)
                  {
                    nFileOffset = PARSE_INVALIDNETPATH;
                    goto FAILURE;
                  }
                nFile = nExt = 0;
                bExt = FALSE;
              }
            break;

          case chSpace:
            {
              ULPSTR lpSpace = lpstr;

              *lpSpace = '\0';
              while (*++lpSpace)
                {
                  if (*lpSpace != chSpace)
                    {
                      *lpstr = chSpace;        /* Reset string, abandon ship */
                      nFileOffset = PARSE_INVALIDSPACE;
                      goto FAILURE;
                    }
                }
            }
            break;

          case chPeriod:
            if (nFile == 0)
              {
                if (*++lpstr == chPeriod)
                    ++lpstr;
                if (!*lpstr)
                    goto MustBeDir;

                if ((*lpstr != '\\') && (*lpstr != '/'))
                  {
                    nFileOffset = PARSE_INVALIDPERIOD;
                    goto FAILURE;
                  }

                ++lpstr;              /* Flags are already set */
              }
            else if (bExt)
              {
                nFileOffset = PARSE_INVALIDPERIOD;  /* can't have one in ext */
                goto FAILURE;
              }
            else
              {
                nExtOffset = 0;
                ++lpstr;
                bExt = TRUE;
              }
            break;

          case '*':
          case '?':
            if (bUNCPath)
              {
                nFileOffset = PARSE_INVALIDNETPATH;
                goto FAILURE;
              }
            bWildcard = TRUE;
/* Fall through to normal character processing */

          default:
            if (bExt)
              {
                if (++nExt == 1)
                    nExtOffset = (short)(lpstr - lpstrFileName);
                else if (nExt > 3)
                  {
                    nFileOffset = PARSE_EXTENTIONTOOLONG;
                    goto FAILURE;
                  }
                if ((nNetwork == -1) && (nFile + nExt > 11))
                  {
                    nFileOffset = PARSE_INVALIDNETPATH;
                    goto FAILURE;
                  }
              }
            else if (++nFile == 1)
                nFileOffset = (short)(lpstr - lpstrFileName);
            else if (nFile > 8)
              {
                /* If it's a server name, it can have 11 characters */
                if (nNetwork != -1)
                  {
                    nFileOffset = PARSE_FILETOOLONG;
                    goto FAILURE;
                  }
                else if (nFile > 11)
                  {
                    nFileOffset = PARSE_INVALIDNETPATH;
                    goto FAILURE;
                  }
              }

            lpstr = (ULPSTR)AnsiNext((LPSTR)lpstr);
            break;
        }
    }

/* Did we start with a double backslash but not have any more slashes? */
  if (nNetwork == -1)
    {
      nFileOffset = PARSE_INVALIDNETPATH;
      goto FAILURE;
    }

  if (!nFile)
    {
MustBeDir:
      nFileOffset = PARSE_DIRECTORYNAME;
      goto FAILURE;
    }

  if ((*(lpstr - 1) == chPeriod) &&          /* if true, no extention wanted */
              (*AnsiNext((LPSTR)(lpstr-2)) == chPeriod))
      *(lpstr - 1) = '\0';               /* Remove terminating period   */
  else if (!nExt)
FAILURE:
      nExtOffset = (short)(lpstr - lpstrFileName);

  return(MAKELONG(nFileOffset, nExtOffset));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\commdlg\font.h ===
/*******************************************************************************
 *
 *  MODULE	: Font.h
 *
 *  DESCRIPTION : Include file for constants and typedefs related only to the
 *		  the font selection routines.
 *
 *  HISTORY	: 11/13/90  - L.Raman
 *
 *  Copyright (c) Microsoft Corporation, 1990-
 *
 *******************************************************************************/

/* struct. passed in to the facename and pt. size enum. functions */
#define CCHCOLORNAMEMAX   16	  /* max. length of color name text	   */
#define CCHCOLORS	  16	  /* max. no of pure colors in color combo */

#define POINTS_PER_INCH     72
#define FFMASK		    0xF0  /* pitch and family mask		   */
#define CCHSTDSTRING	    12	  /* max. length of sample text string	   */

#define FONTPROP (LPSTR)0xA000L

extern HANDLE hinsCur;	      /* DLL's data segment         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\commdlg\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\commdlg\parse.h ===
typedef unsigned char far      *ULPSTR;

#define PARSE_DIRECTORYNAME    -1
#define PARSE_INVALIDDRIVE     -2
#define PARSE_INVALIDPERIOD    -3
#define PARSE_MISSINGDIRCHAR   -4
#define PARSE_INVALIDCHAR      -5
#define PARSE_INVALIDDIRCHAR   -6
#define PARSE_INVALIDSPACE     -7
#define PARSE_EXTENTIONTOOLONG -8
#define PARSE_FILETOOLONG      -9
#define PARSE_EMPTYSTRING     -10
#define PARSE_WILDCARDINDIR   -11
#define PARSE_WILDCARDINFILE  -12
#define PARSE_INVALIDNETPATH  -13

#if DBCS
#define MAX_DIRNAME 128
#else
#define MAX_DIRNAME 64
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\commdlg\privcomd.h ===
/*---------------------------------------------------------------------------*/
/* PrivComd.h : UI dialog header                                             */
/*                                                                           */
/* Copyright (c) Microsoft Corporation, 1991-                                */
/*---------------------------------------------------------------------------*/

#include "commdlg.h"
#include "dlgs.h"
#include "_xlib.h"
#include "isz.h"
#include "cderr.h"

#ifdef FILEOPENDIALOGS
#include "fileopen.h"
#endif

#define	CODESEG		_based(_segname("_CODE"))

#define MAXFILENAMELEN   12
#define SEM_NOERROR      0x8003

/*---------------------------------------------------------------------------
 *  DOS Disk Transfer Area Structure -
 *--------------------------------------------------------------------------*/

typedef struct tagDOSDTA
  {
    BYTE            Reserved[21];        	    /* 21 */
    BYTE	    Attrib;			    /* 22 */
    WORD	    Time;			    /* 24 */
    WORD	    Date;			    /* 26 */
    DWORD	    Length;			    /* 30 */
    char	    szName[MAXFILENAMELEN+1];	    /* 43 */
    char	    buffer[5];			    /* 48 */
  } DOSDTA;
typedef DOSDTA	     *PDOSDTA;
typedef DOSDTA	 FAR *LPDOSDTA;

/* Avoids sharing violations.  Defined 21 Jan 1991   clarkc */
#define SHARE_EXIST                  (OF_EXIST | OF_SHARE_DENY_NONE)

/*---------------------------------------------------------------------------
 *  DOS Extended File Control Block Structure -
 *--------------------------------------------------------------------------*/
typedef struct tagEFCB
  {
    BYTE	    Flag;
    BYTE	    Reserve1[5];
    BYTE	    Attrib;
    BYTE	    Drive;
    BYTE	    Filename[11];
    BYTE	    Reserve2[5];
    BYTE	    NewName[11];
    BYTE	    Reserve3[9];
  } EFCB;

#define ATTR_VOLUME	    0x0008

/*----Globals---------------------------------------------------------------*/

extern HINSTANCE   hinsCur;    /* Instance handle of Library */
extern DWORD    dwExtError; /* Extended error code */

extern short cyCaption, cyBorder, cyVScroll;
extern short cxVScroll, cxBorder, cxSize;


extern char szNull[];
extern char szStar[];
extern char szStarDotStar[];
extern BOOL bMouse;              /* System has a mouse */
extern BOOL bCursorLock;
extern BOOL bWLO;                /* Running with WLO */
extern BOOL bDBCS;               /* Running Double-Byte Character Support? */
extern WORD wWinVer;             /* Windows version */
extern WORD wDOSVer;             /* DOS version */
extern UINT msgHELP;             /* Initialized via RegisterWindowMessage */

extern DOSDTA  DTAGlobal;
extern EFCB    VolumeEFCB;

/*----Functions--------------------------------------------------------------*/
LONG    FAR RgbInvertRgb(LONG);
HBITMAP FAR HbmpLoadBmp(WORD);

void FAR TermFind(void);
void FAR TermColor(void);
void FAR TermFont(void);
void FAR TermFile(void);
void FAR TermPrint(void);


/* Common */

VOID FAR PASCAL HourGlass(BOOL);
HBITMAP FAR PASCAL LoadAlterBitmap(int, DWORD, DWORD);
VOID FAR PASCAL MySetObjectOwner(HANDLE);
VOID FAR PASCAL RepeatMove(LPSTR, LPSTR, WORD);

/* File Open/Save */

#ifdef FILEOPENDIALOGS
BOOL FAR PASCAL SetCurrentDrive(short);
short FAR PASCAL GetCurrentDrive(VOID);
BOOL GetCurDirectory(PSTR);
BOOL FAR PASCAL mygetcwd(LPSTR, int);
BOOL FAR PASCAL mychdir(LPSTR);
BOOL FAR PASCAL FindFirst4E(LPSTR, WORD);
BOOL FAR PASCAL FindNext4F(VOID);
VOID FAR PASCAL MySetDTAAddress(LPDOSDTA);
VOID FAR PASCAL ResetDTAAddress(VOID);
BOOL UpdateListBoxes(HWND, PMYOFN, LPSTR, WORD);
#endif

/* Color */

#ifdef COLORDLG
#include "color.h"
    /* Color */
extern HDC hDCFastBlt;
extern DWORD rgbClient;
extern WORD H,S,L;
extern HBITMAP hRainbowBitmap;
extern BOOL bMouseCapture;
extern WNDPROC lpprocStatic;
extern short nDriverColors;
extern char szOEMBIN[];
extern short nBoxHeight, nBoxWidth;
extern HWND hSave;
extern FARPROC  qfnColorDlg;
BOOL FAR PASCAL ColorDlgProc(HWND, WORD, WORD, LONG);
LONG FAR PASCAL WantArrows(HWND, WORD, WPARAM, LPARAM);

void RainbowPaint(PCOLORINFO, HDC, LPRECT);
VOID NearestSolid(PCOLORINFO);
DWORD HLStoRGB(WORD, WORD, WORD);
VOID RGBtoHLS(DWORD);
VOID HLStoHLSPos(short, PCOLORINFO);
VOID SetRGBEdit(short, PCOLORINFO);
VOID SetHLSEdit(short, PCOLORINFO);
short RGBEditChange(short, PCOLORINFO);
VOID ChangeColorSettings(PCOLORINFO);
VOID CrossHairPaint(HDC, short, short, PCOLORINFO);
void EraseCrossHair(HDC, PCOLORINFO);
VOID LumArrowPaint(HDC, short, PCOLORINFO);
VOID EraseLumArrow(HDC, PCOLORINFO);
VOID HLSPostoHLS(short, PCOLORINFO);
WORD InitColor(HWND, WORD, LPCHOOSECOLOR);
BOOL InitRainbow(PCOLORINFO);
BOOL InitScreenCoords(HWND, PCOLORINFO);
VOID ColorPaint(HWND, PCOLORINFO, HDC, LPRECT);
VOID ChangeBoxSelection(PCOLORINFO, short);
VOID ChangeBoxFocus(PCOLORINFO, short);
VOID PaintBox(PCOLORINFO, HDC, short);
BOOL ColorKeyDown(WORD, int FAR *, PCOLORINFO);
BOOL BoxDrawItem(LPDIS);
VOID SetupRainbowCapture(PCOLORINFO);
void PaintRainbow(HDC, LPRECT, PCOLORINFO);
#endif


/* Dlgs.c */

int  FAR PASCAL LibMain(HANDLE, WORD, WORD, LPSTR);
int  FAR PASCAL WEP(int);

LONG FAR RgbInvertRgb(LONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\commdlg\start.asm ===
;----------------------------------------------------------------------------
;   start.asm -- Start Code for loading the DLGS dll
;                                                                        
;   Copyright (c) Microsoft Corporation, 1990                            
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
;   This module contains the code initially executed to load and         
;   initialize the DLL                       
;----------------------------------------------------------------------------

;-----Includes, Definitions, Externs, Etc.-----------------------------------

.xlist
include     cmacros.inc
include     windows.inc
.list


ExternFP <LibMain>

createSeg   INIT_TEXT, INIT_TEXT, BYTE, PUBLIC, CODE
sBegin      INIT_TEXT
assumes     cs,INIT_TEXT

?PLM=0
ExternA     <_acrtused>

?PLM=1
ExternFP    <LocalInit>

;-------- Entry Points ---------------------------------------------------

cProc   LibEntry, <FAR,PUBLIC>
;
; CX = size of heap
; DI = module handle
; DS = automatic data segment
; ES:SI = address of command line (not used)
;
include     convdll.inc
cBegin
        push    di
        push    ds
        push    cx
        push    es
        push    si

        jcxz    callc
        xor     ax,ax
        cCall   LocalInit <ds, ax, cx>
        or      ax,ax
        jz      error

                ;LibMain(HANDLE, WORD, WORD, LPSTR)
callc:
        call    LibMain                 ; Main C routine
        jmp short exit

error:
        pop     si
        pop     es
        pop     cx
        pop     ds
        pop     di

exit:

cEnd

sEnd    INIT_TEXT

end LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\commdlg\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\commdlg\xlib.h ===
/*---------------------------------------------------------------------------
 *  Xlib.h -- Common definitions.  Windows.h must be included first.
 *---------------------------------------------------------------------------
 */

#define LINT_ARGS
#define HNULL       ((HANDLE) 0)

/* Miscellaneous */
#define cbFindMax   1024

/* Graphics */
#define bhlsMax ((BYTE) 240)             /* Max of H/L/S */
#define brgbMax ((BYTE) 255)             /* Max of R/G/B */
#define bHueNil (bhlsMax*2/3)   /* This value of Hue is undefined if Sat==0 */

#define HLS(h, l, s)            \
    ((DWORD)(((BYTE)(h)|((WORD)(l)<<8))|(((DWORD)(BYTE)(s))<<16)))
#define GetHValue(hls)          ((BYTE)(hls))
#define GetLValue(hls)          ((BYTE)(((WORD)(hls)) >> 8))
#define GetSValue(hls)          ((BYTE)((hls)>>16))

#define cwPointSizes            13

typedef struct tagCF
    {
    char        cfFaceName[LF_FACESIZE];
    int         cfPointSize;
    COLORREF    cfColor;        /* Explicit RGB value... */

    unsigned fBold:          1;
    unsigned fItalic:        1;
    unsigned fStrikeOut:     1;
    unsigned fUnderLine:     1;
    unsigned fExtra:         12;
    }
CHARFORMAT;
typedef CHARFORMAT *        PCHARFORMAT;
typedef CHARFORMAT FAR *    LPCHARFORMAT;


HBITMAP  FAR PASCAL      LoadAlterBitmap(int, DWORD, DWORD);
DWORD    FAR PASCAL      RgbFromHls(BYTE, BYTE, BYTE);
DWORD    FAR PASCAL      HlsFromRgb(BYTE, BYTE, BYTE);
BOOL     FAR PASCAL      GetColorChoice(HWND, DWORD FAR *, DWORD FAR *, FARPROC);
BOOL     FAR PASCAL      GetCharFormat(HWND, LPCHARFORMAT, FARPROC);

/* Memory */
void  FAR PASCAL   StripSpace(LPSTR);
HANDLE  FAR PASCAL GlobalCopy(HANDLE);
HANDLE  FAR PASCAL GlobalDelete(HANDLE, LONG, LONG);
HANDLE  FAR PASCAL GlobalInsert(HANDLE, LONG, LONG, BOOL, BYTE);
HANDLE  FAR PASCAL LocalCopy(HANDLE);
HANDLE  FAR PASCAL LocalDelete(HANDLE, WORD, WORD);
HANDLE  FAR PASCAL LocalInsert(HANDLE, WORD, WORD, BOOL, BYTE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\commdlg\_xlib.h ===
//---------------------------------------------------------------------------
// _xlib.h : Private shared header file for XLIB
//
// Copyright (c) Microsoft Corporation, 1990-
//---------------------------------------------------------------------------

//----Constants--------------------------------------------------------------
#define chKeyValue      '='

#define cbAtomNameMax   32
#define cbResNameMax    32
#define cbClsNameMax    64
#define cbDlgNameMax    32
#define cbCaptionMax    32
#define cbStcTextMax    96

#define mnuFirst  0x0200
#define mnuLast   0x020f
#define icoFirst  0x0210
#define icoLast   0x021f
#define curFirst  0x0220
#define curLast   0x022f
#define aclFirst  0x0230
#define aclLast   0x023f
#define bmpFirst  0x0240
#define bmpLast   0x02ff
#define resFirst  mnuFirst
#define resLast   bmpLast

#define mskKeyDown  0x8000

//----Types------------------------------------------------------------------
typedef void NEAR * PV;
typedef void FAR  * QV;

//----Macros-----------------------------------------------------------------
#define ColOf(col)  *((DWORD *) (&(col)))
#define MAKEWORD(bLo, bHi)  ((WORD)(((BYTE)(bLo)) | ((WORD)((BYTE)(bHi))) << 8))

#define FIsMnu(res)\
   ((res) >= mnuFirst && (res) <= mnuLast)
#define FIsAcl(res)\
   ((res) >= aclFirst && (res) <= aclLast)
#define FIsCur(res)\
   ((res) >= curFirst && (res) <= curLast)
#define FIsIco(res)\
   ((res) >= icoFirst && (res) <= icoLast)
#define FIsBmp(res)\
   ((res) >= bmpFirst && (res) <= bmpLast)

#define HNULL     ((HANDLE) 0)

//----Globals----------------------------------------------------------------

//----Functions--------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ctl3dv2\loaddib.h ===
#ifndef WIN32
#ifndef LPTSTR
#define LPTSTR LPSTR
#endif
#endif

HBITMAP PASCAL  LoadUIBitmap(
    HANDLE      hInstance,          // EXE file to load resource from
	LPTSTR		szName, 			// name of bitmap resource
    COLORREF    rgbText,            // color to use for "Button Text"
    COLORREF    rgbFace,            // color to use for "Button Face"
    COLORREF    rgbShadow,          // color to use for "Button Shadow"
    COLORREF    rgbHighlight,       // color to use for "Button Hilight"
    COLORREF    rgbWindow,          // color to use for "Window Color"
    COLORREF    rgbFrame);           // color to use for "Window Frame"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ctl3dv2\ctl3d.c ===
/*-----------------------------------------------------------------------
|
|   CTL3D
|
|       Copyright Microsoft Corporation 1992.  All Rights Reserved.
|
|
|   This module contains the functions to give windows controls a 3d effect
|
|   This source is made public for your edification and debugging pleasure
|
|   PLEASE do not make any changes or release private versions of this DLL
|       send e-mail to me (wesc) if you have feature requests or bug fixes.
|
|   Thanks -- Wes.
|
|
|   History:
|       1-Jan-92 :  Added OOM handling on GetDC (not really necessary but
|                       XL4 OOM failure testing made GetDC return NULL)
|
|       1-Jan-92    :   Check wasn't getting redrawn when state changed in
|                       the default button proc.
|
|       29-Jan-92:  If button has the focus and app is switched in, we weren't
|                       redrawing the entire button check & text.  Force redraw
|                       of these on WM_SETFOCUS message.
|
|        3-Feb-92:  Fixed switch in via task manager by erasing the buttons
|                       backgound on WM_SETFOCUS (detect this when wParam == NULL)
|
|        4-Apr-92:  Make it work with OWNERDRAW buttons
|
|       22-Apr-92:  Removed Excel specific code
|
|       19-May-92:  Turn it into a DLL
|
|       May-Jun92:  Lots o' fixes & enhancements
|
|       23-Jun-92:  Added support for hiding, sizing & moving
|
|       24-Jun-92:  Make checks & radio button circles draw w/ window
|                       text color 'cause they are drawn on window bkgnd
|
|       30-Jun-92:  (0.984) Fix bug where EnableWindow of StaticText doesn't 
|                       redraw properly.  Also disable ctl3d when verWindows > 3.1
|
|      1-Jul-92:  Added WIN32 support (davegi) (not in this source)
|
|       2-Jul-92:  (0.984) Disable when verWindows >= 4.0
|
|       20-Jul-92:  (0.985) Draw focus rects of checks/radios properly on non
|                       default sized controls.
|
|       21-Jul-92:  (0.990) Ctl3dAutoSubclass
|
|       21-Jul-92:  (0.991) ported DaveGi's WIN32 support
|
|       22-Jul-92:  (0.991) fixed Ctl3dCtlColor returning fFalse bug
|
|        4-Aug-92:  (0.992) Graphic designers bug fixes...Now subclass
|                       regular buttons + disabled states for checks & radios
|
|        6-Aug-92:  (0.993) Fix bug where activate via taskman & group
|                       box has focus, & not centering text in buttons
|
|        6-Aug-92:  (0.993) Tweek drawing next to scroll bars. 
|
|       13-Aug-92:  (0.994) Fix button focus rect bug drawing due to 
|                       Win 3.0 DrawText bug.
|
|       14-Aug-92:  (1.0) Release of version 1.0
|                       Don't draw default button border on BS_DEFPUSHBUTTON
|                       pushbuttons
|                       Fix bogus bug where Windows hangs when in a AUTORADIOBUTTON
|                       hold down space bar and hit arrow key. 
|
|       23-Sep-92:  (1.01) Made Ctl3dCtlColor call DefWindowProc so it works when
|                       called in a windproc.
|
|       28-Sep-92:  (1.02) Added MyGetTextExtent so '&''s not considered in 
|                       text extents.
|
|       08-Dec-92:  (1.03) minor tweeks to the button text centering code
|                       for Publisher
|
|       11-Dec-92:  (1.04) added 3d frames to dialogs
|
|       15-Dec-92:  (1.05) fixed bug where group boxes redraw wrong when
|                       Window text is changed to something shorter
|
|       ??-Dec-92:  (1.06) added 3d borders
|
|       21-Dec-92:  (1.07) added WM_DLGBORDER to disable borders
|
|      4-Jan-93:  (1.08) fixed WM_SETTEXT bug w/ DLG frames & checks/checkboxes
|                       Also, WM_DLGSUBCLASS
|
|       22-Feb-93:  (1.12) disabled it under Chicago
|
|       25-Feb-93:  (1.13) re-add fix which allows dialog procs to
|                       handle WM_CTLCOLOR messages
|
|		26-April-93 (2.0) Changed to allow for second subclass. Now uses class instead of
|						  wndproc for subclass determination.
|						  store next wndproc in properties with global atoms						 
|
|		06-Jun-93  (2.0) Make a static linked library version.
|
|
-----------------------------------------------------------------------*/
#define NO_STRICT
#include <windows.h>

#ifdef _BORLAND
#include <mem.h>
#else
#include <memory.h>
#endif

#include <malloc.h>
#include "ctl3d.h"

#include "stdio.h"

/*-----------------------------------------------------------------------
|CTL3D Types
-----------------------------------------------------------------------*/
#ifdef WIN32

#define Win32Only(e) e
#define Win16Only(e)
#define Win32Or16(e32, e16) e32
#define Win16Or32(e16, e32) e32

#define _loadds
#define __export

#define FValidLibHandle(hlib) ((hlib) != NULL)

//
// No concept of far in Win32.
//

#define MEMCMP	memcmp
#define	NPTSTR	LPTSTR

//
// Control IDs are LONG in Win32.
//

typedef LONG CTLID;
#define GetControlId(hwnd) GetWindowLong(hwnd, GWL_ID)

//
// Send a color button message.
//

#define SEND_COLOR_BUTTON_MESSAGE( hwndParent, hwnd, hdc )      \
    ((HBRUSH) SendMessage(hwndParent, WM_CTLCOLORBTN, (WPARAM) hdc, (LPARAM) hwnd))

//
// Send a color static message.
//

#define SEND_COLOR_STATIC_MESSAGE( hwndParent, hwnd, hdc )      \
    ((HBRUSH) SendMessage(hwndParent, WM_CTLCOLORSTATIC, (WPARAM) hdc, (LPARAM) hwnd))

#else

#define CallWindowProcA  CallWindowProc
#define DefWindowProcA	DefWindowProc
#define MessageBoxA MessageBox

#define TEXT(a)  a
#define TCHAR    char

#ifndef LPTSTR
#define LPTSTR	 LPSTR
#endif
#define LPCTSTR  LPCSTR
#define	NPTSTR	 NPSTR

#define Win32Only(e)
#define Win16Only(e) e
#define Win32Or16(e32, e16) e16
#define Win16Or32(e16, e32) e16


#define FValidLibHandle(hlib) (( hlib ) > 32 )

#define MEMCMP _fmemcmp

typedef WORD CTLID;
#define GetControlId(h) GetWindowWord(h, GWW_ID)

#define SEND_COLOR_BUTTON_MESSAGE( hwndParent, hwnd, hdc )      \
    ((HBRUSH) SendMessage(hwndParent, WM_CTLCOLOR, (WORD) hdc, MAKELONG(hwnd, CTLCOLOR_BTN)))

#define SEND_COLOR_STATIC_MESSAGE( hwndParent, hwnd, hdc )      \
    ((HBRUSH) SendMessage(hwndParent, WM_CTLCOLOR, (WORD) hdc, MAKELONG(hwnd, CTLCOLOR_STATIC)))


typedef struct
	{
	LPARAM lParam;
	WPARAM wParam;
	UINT   message;
	HWND   hwnd;
} CWPSTRUCT;

#endif // WIN32

// DBCS far east short cut key support
#define cchShortCutModeMax 10
#define chShortCutSbcsPrefix '\036'
#define chShortCutDbcsPrefix '\037'

#define cchClassMax 16	// max class is "combolbox"+NUL rounded up to 16


#define Assert(f)

#define PUBLIC
#define PRIVATE static

#define fFalse 0
#define fTrue 1

#define INCBTHOOK	  1
#define OUTCBTHOOK	  0

#ifdef _BORLAND
#define CSCONST(type) type const
#define CodeLpszDecl(lpszVar, szLit) TCHAR *lpszVar = szLit
#define CodeLpszDeclA(lpszVar, szLit) char *lpszVar = szLit
#define _alloca alloca
#define _memcmp memcmp
#else
#ifdef WIN32
#define CSCONST(type) type const
#define CodeLpszDecl(lpszVar, szLit) TCHAR *lpszVar = szLit
#define CodeLpszDeclA(lpszVar, szLit) char *lpszVar = szLit
#else
#define CSCONST(type) type _based(_segname("_CODE")) const
#define CodeLpszDecl(lpszVar, szLit) \
	static CSCONST(char) lpszVar##Code[] = szLit; \
	char far *lpszVar = (char far *)lpszVar##Code
#define CodeLpszDeclA(lpszVar, szLit) \
	static CSCONST(char) lpszVar##Code[] = szLit; \
	char far *lpszVar = (char far *)lpszVar##Code
#endif
#endif


// isomorphic to windows RECT
typedef struct
    {
    int xLeft;
    int yTop;
	int xRight;
    int yBot;
    } RC;


// Windows Versions (Byte order flipped from GetWindowsVersion)
#define ver30  0x0300
#define ver31  0x030a
#define ver40  0x035F

// Border widths
#define dxBorder 1
#define dyBorder 1


// Index Color Table
// WARNING: change mpicvSysColors if you change the icv order
typedef WORD ICV;
#define icvBtnHilite 0
#define icvBtnFace 1
#define icvBtnShadow 2

#define icvBrushMax 3

#define icvBtnText 3
#define icvWindow 4
#define icvWindowText 5
#define icvGrayText 6
#define icvWindowFrame 7
#define icvMax 8

typedef COLORREF CV;

// CoLoR Table
typedef struct
    {
    CV rgcv[icvMax];
    } CLRT;


// BRush Table
typedef struct
    {
    HBRUSH mpicvhbr[icvBrushMax];
    } BRT;


// DrawRec3d flags
#define dr3Left  0x0001
#define dr3Top   0x0002
#define dr3Right 0x0004
#define dr3Bot   0x0008

#define dr3HackBotRight 0x1000  // code size is more important than aesthetics
#define dr3All    0x000f
typedef WORD DR3;


// Control Types
// Commdlg types are necessary because commdlg.dll subclasses certain 
// controls before the app can call Ctl3dSubclassDlg.
#define ctButton			0
#define ctList				1
#define ctEdit				2
#define ctCombo				3
#define ctStatic			4
#define ctComboLBox 		5
#define ctMax				6

// ConTroL 
typedef struct 
    {
    FARPROC lpfn;
    WNDPROC lpfnDefProc;
	TCHAR	szClassName[cchClassMax];
    } CTL;

// Control DEFinition
typedef struct 
    {
	TCHAR sz[20];
    WNDPROC lpfnWndProc;
	BOOL (* lpfnFCanSubclass)(HWND, LONG, WORD, WORD, HWND);
    WORD msk;
    } CDEF;

// CLIent HooK
typedef struct
    {
    HANDLE hinstApp;
    HANDLE htask;
	HHOOK  hhook;
	int    iCount;
	DWORD  dwFlags;

	} CLIHK;

#ifdef WIN32
#define iclihkMaxBig	1024
#define iclihkMaxSmall	128
#else
#define iclihkMaxBig	32
#define iclihkMaxSmall	4
#endif

#ifdef DLL
#define iclihkMax iclihkMaxBig
#else
#ifdef SDLL
#define iclihkMax iclihkMaxBig
#else
#define iclihkMax iclihkMaxSmall
#define _loadds
#endif
#endif

#ifdef SDLL
extern const HINSTANCE _hModule;
#endif

// special styles
// #define bitFCoolButtons 0x0001

/*-----------------------------------------------------------------------
|CTL3D Function Prototypes
-----------------------------------------------------------------------*/
PRIVATE VOID End3dDialogs(VOID);
PRIVATE BOOL FAR FInit3dDialogs(VOID);
PRIVATE BOOL DoSubclassCtl(HWND hwnd, WORD grbit, WORD wCallFlags, HWND hwndParent);
PRIVATE BOOL InternalCtl3dColorChange(BOOL fForce);
PRIVATE VOID DeleteObjectNull(HANDLE FAR *ph);
PRIVATE VOID DeleteObjects(VOID);
PRIVATE int  IclihkFromHinst(HANDLE hinst);

LRESULT __export _loadds WINAPI Ctl3dHook(int code, WPARAM wParam, LPARAM lParam);
LRESULT __export _loadds WINAPI BtnWndProc3d(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam);
LRESULT __export _loadds WINAPI EditWndProc3d(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam);
LRESULT __export _loadds WINAPI ListWndProc3d(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam);
LRESULT __export _loadds WINAPI ComboWndProc3d(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam);
LRESULT __export _loadds WINAPI StaticWndProc3d(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam);
LRESULT __export _loadds WINAPI CDListWndProc3d(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam);
LRESULT __export _loadds WINAPI CDEditWndProc3d(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam);
WORD	__export _loadds WINAPI Ctl3dSetStyle(HANDLE hinst, LPTSTR lpszName, WORD grbit);

LRESULT __export _loadds WINAPI Ctl3dDlgProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam);

BOOL FBtn(HWND, LONG, WORD, WORD, HWND);
BOOL FEdit(HWND, LONG, WORD, WORD, HWND);
BOOL FList(HWND, LONG, WORD, WORD, HWND);
BOOL FComboList(HWND, LONG, WORD, WORD, HWND);
BOOL FCombo(HWND, LONG, WORD, WORD, HWND);
BOOL FStatic(HWND, LONG, WORD, WORD, HWND);

HBITMAP PASCAL LoadUIBitmap(HANDLE, LPCTSTR, COLORREF, COLORREF, COLORREF, COLORREF, COLORREF, COLORREF);

#ifdef WIN32
#ifdef DLL
BOOL CALLBACK LibMain(HANDLE hModule, DWORD dwReason, LPVOID lpReserved);
#else
#ifdef SDLL
FAR BOOL Ctl3dLibMain(HANDLE hModule, DWORD dwReason, LPVOID lpReserved);
#else
FAR BOOL LibMain(HANDLE hModule, DWORD dwReason, LPVOID lpReserved);
#endif
#endif
#else
#ifdef DLL
int WINAPI LibMain(HANDLE hModule, WORD wDataSeg, WORD cbHeapSize, LPSTR lpszCmdLine);
#else
#ifdef SDLL
int FAR Ctl3dLibMain(HANDLE hModule, WORD wDataSeg, WORD cbHeapSize, LPSTR lpszCmdLine);
#else
#ifdef _BORLAND
int FAR PASCAL LibMain(HANDLE hModule, WORD wDataSeg, WORD cbHeapSize, LPSTR lpszCmdLine);
#else
int FAR LibMain(HANDLE hModule, WORD wDataSeg, WORD cbHeapSize, LPSTR lpszCmdLine);
#endif
#endif
#endif
#endif

#ifndef _BORLAND
#ifndef WIN32
#pragma alloc_text(INIT_TEXT, Ctl3dSetStyle)
#pragma alloc_text(INIT_TEXT, Ctl3dColorChange)
#pragma alloc_text(INIT_TEXT, Ctl3dGetVer)
#pragma alloc_text(INIT_TEXT, Ctl3dRegister)
#pragma alloc_text(INIT_TEXT, Ctl3dUnregister)
#pragma alloc_text(INIT_TEXT, Ctl3dAutoSubclass)
#pragma alloc_text(INIT_TEXT, Ctl3dEnabled)
#pragma alloc_text(INIT_TEXT, Ctl3dWinIniChange)
#pragma alloc_text(INIT_TEXT, DeleteObjects)
#pragma alloc_text(INIT_TEXT, DeleteObjectNull)
#pragma alloc_text(INIT_TEXT, InternalCtl3dColorChange)
#ifdef SDLL
#pragma alloc_text(INIT_TEXT, Ctl3dLibMain)
#else
#pragma alloc_text(INIT_TEXT, LibMain)
#endif
#pragma alloc_text(INIT_TEXT, FInit3dDialogs)
#pragma alloc_text(INIT_TEXT, End3dDialogs)
#pragma alloc_text(INIT_TEXT, LoadUIBitmap)
#pragma alloc_text(INIT_TEXT, IclihkFromHinst)
#endif
#endif

#ifndef WIN32
#ifdef DLL
int FAR PASCAL WEP(int);
#pragma alloc_text(WEP_TEXT, WEP)
#endif
#endif

/*-----------------------------------------------------------------------
|CTL3D Globals
-----------------------------------------------------------------------*/
//These static varables are only access when running 16 bit Windows or Win32s
//Since this is single threaded access they are OK to be statics and not protected.
//
static HHOOK	hhookCallWndProcFilterProc;
static FARPROC	lpfnSubclassByHook;
static HWND 	SubclasshWnd;

#ifdef WIN32
CRITICAL_SECTION g_CriticalSection;
#endif

typedef struct _g3d
	{
	BOOL f3dDialogs;
	int cInited;
	ATOM aCtl3dOld;
	ATOM aCtl3dHighOld;
	ATOM aCtl3dLowOld;
	ATOM aCtl3d;
	ATOM aCtl3dHigh;
	ATOM aCtl3dLow;

	ATOM aCtl3dDisable;
	// module & windows stuff
	HANDLE hinstLib;
	HANDLE hmodLib;
	WORD   verWindows;
	WORD   verBase;

	// drawing globals
	CLRT clrt;
	BRT brt;
	HBITMAP hbmpCheckboxes;

	// Hook cache
	HANDLE htaskCache;
	int iclihkCache;
	int iclihkMac;
	CLIHK rgclihk[iclihkMax];

	// Control info
	CTL mpctctl[ctMax];
	FARPROC lpfnDefDlgWndProc;

	// System Metrics
	int dxFrame;
	int dyFrame;
	int dyCaption;
	int dxSysMenu;

	// Windows functions
#ifndef WIN32
#ifdef DLL
	HHOOK (FAR PASCAL *lpfnSetWindowsHookEx)(int, HOOKPROC, HINSTANCE, HANDLE);
	LRESULT (FAR PASCAL *lpfnCallNextHookEx)(HHOOK, int, WPARAM, LPARAM);
	BOOL (FAR PASCAL *lpfnUnhookWindowsHookEx)(HHOOK);
#endif
#endif

	// DBCS stuff
	char chShortCutPrefix;
	char fDBCS;

	} G3D;

G3D g3d;


CSCONST(CDEF) mpctcdef[ctMax] =
{
	{ TEXT("Button"), BtnWndProc3d, FBtn, CTL3D_BUTTONS },
	{ TEXT("ListBox"), ListWndProc3d, FList, CTL3D_LISTBOXES },
	{ TEXT("Edit"), EditWndProc3d, FEdit, CTL3D_EDITS },
	{ TEXT("ComboBox"), ComboWndProc3d, FCombo, CTL3D_COMBOS},
	{ TEXT("Static"), StaticWndProc3d, FStatic, CTL3D_STATICTEXTS|CTL3D_STATICFRAMES },
	{ TEXT("ComboLBox"), ListWndProc3d,	FComboList, CTL3D_LISTBOXES },
};


CSCONST (WORD) mpicvSysColor[] =
	{
	COLOR_BTNHIGHLIGHT,
	COLOR_BTNFACE,
	COLOR_BTNSHADOW,
	COLOR_BTNTEXT,
	COLOR_WINDOW,
	COLOR_WINDOWTEXT,
	COLOR_GRAYTEXT,
	COLOR_WINDOWFRAME
	};

#define WM_CHECKSUBCLASS_OLD (WM_USER+5443)
#define WM_CHECKSUBCLASS (WM_USER+5444)

/*-----------------------------------------------------------------------
|   CTL3D Utility routines
-----------------------------------------------------------------------*/

PRIVATE FARPROC LpfnGetDefWndProcNull(HWND hwnd)
	{                                
	if ( hwnd == NULL ) 
		return NULL;
		
	Win32Only(return (FARPROC) GetProp(hwnd, (LPCTSTR) g3d.aCtl3d));
	Win16Only(return (FARPROC) MAKELONG((UINT) GetProp(hwnd, (LPCSTR) g3d.aCtl3dLow),
		GetProp(hwnd, (LPCSTR) g3d.aCtl3dHigh)));
	}

PRIVATE FARPROC LpfnGetDefWndProc(HWND hwnd, int ct)
        {
        FARPROC lpfnWndProc;

		lpfnWndProc = LpfnGetDefWndProcNull(hwnd);
        if ( lpfnWndProc == NULL ) {
			if ( ct == ctMax )
				{
				lpfnWndProc = (FARPROC) g3d.lpfnDefDlgWndProc;
				}
			else
				{
				lpfnWndProc = (FARPROC) g3d.mpctctl[ct].lpfnDefProc;
				}

			Win32Only(SetProp(hwnd, (LPCTSTR) g3d.aCtl3d, (HANDLE)(DWORD)lpfnWndProc));
			Win16Only(SetProp(hwnd, (LPCTSTR) g3d.aCtl3dLow,  LOWORD(lpfnWndProc)));
			Win16Only(SetProp(hwnd, (LPCTSTR) g3d.aCtl3dHigh, HIWORD(lpfnWndProc)));
		}
        return lpfnWndProc;

        }

PRIVATE VOID SubclassWindow(HWND hwnd, FARPROC lpfnSubclassProc)
	{
	FARPROC lpfnWndProc;

	// Make sure we don't double subclass (16 | 32 bit subclass??)
	if (GetProp(hwnd, (LPCTSTR) g3d.aCtl3dOld) ||
		GetProp(hwnd, (LPCTSTR) g3d.aCtl3d) ||
		GetProp(hwnd, (LPCTSTR) g3d.aCtl3dLow) ||
		GetProp(hwnd, (LPCTSTR) g3d.aCtl3dLowOld) ||
		GetProp(hwnd, (LPCTSTR) g3d.aCtl3dHigh) ||
		GetProp(hwnd, (LPCTSTR) g3d.aCtl3dHighOld))
	{
		return;
	}

	// Is this already subclassed by CTL3D?
	if (LpfnGetDefWndProcNull(hwnd) == (FARPROC) NULL)
		{
#ifdef WIN32
		  if (g3d.fDBCS && !IsWindowUnicode(hwnd)) 
		  {
		    TCHAR szClass[cchClassMax];
		    GetClassName(hwnd, szClass, cchClassMax);
			if (lstrcmpi(szClass, TEXT("edit")) == 0)
			{
				lpfnWndProc = (FARPROC)SetWindowLongA(hwnd, GWL_WNDPROC,(LONG)lpfnSubclassProc);
				goto SetProps;
			}
		  }
#endif

		 lpfnWndProc = (FARPROC)SetWindowLong((HWND) hwnd, GWL_WNDPROC, (LONG) lpfnSubclassProc);
SetProps:
		 Win32Only(SetProp(hwnd, (LPCTSTR) g3d.aCtl3d, (HANDLE)(DWORD)lpfnWndProc));
		 Win16Only(SetProp(hwnd, (LPCTSTR) g3d.aCtl3dLow,	LOWORD(lpfnWndProc)));
		 Win16Only(SetProp(hwnd, (LPCTSTR) g3d.aCtl3dHigh, HIWORD(lpfnWndProc)));
		}
	}

LRESULT __export _loadds WINAPI CallWndProcFilterProc(int code, WPARAM wParam, LPARAM lParam)
{
	CWPSTRUCT FAR *cwpStruct;
	LONG l;

	cwpStruct = (CWPSTRUCT FAR *) lParam;

	l = CallNextHookEx(hhookCallWndProcFilterProc, code, wParam, lParam);

	if ( cwpStruct->hwnd == SubclasshWnd )
		{
		BOOL fSubclass;
		UnhookWindowsHookEx(hhookCallWndProcFilterProc);

		if (g3d.verWindows >= ver40 && (GetWindowLong(cwpStruct->hwnd, GWL_STYLE) & 0x04))
			fSubclass = fFalse;
		else
			fSubclass = fTrue;
		SendMessage(cwpStruct->hwnd, WM_DLGSUBCLASS, 0, (LPARAM)(int FAR *)&fSubclass);
		if (fSubclass)
			SubclassWindow(cwpStruct->hwnd, lpfnSubclassByHook);

		hhookCallWndProcFilterProc = 0L;
		lpfnSubclassByHook = NULL;
		SubclasshWnd = NULL;
		}

	return l;
}


PRIVATE VOID HookSubclassWindow(HWND hWnd, FARPROC lpfnSubclass)
{
	//
	// Windows 3.1 ( 16 bit ) and Win32s can't sublcass in
	// WH_CBT hook. Must set up a MSG hook and subclasss at
	// WM_GETMINMAXINFO ( for dialogs ) or WM_NCCREATE ( for controls )
	// Any other message and we are out of here.
	//
	// Notes from the inside:
	//
	// The only reason not to get the WM_GETMINMAXINFO/WM_NCCREATE message
	// is if another CBT hook did not allow the window create.
	// This code only runs/works on non multithreaded systems. Thus the global
	// to hold the Hook Proc and subclass proc is OK.
	//

	lpfnSubclassByHook = lpfnSubclass;
	SubclasshWnd = hWnd;

	Win32Only(hhookCallWndProcFilterProc = SetWindowsHookEx(WH_CALLWNDPROC, (FARPROC)CallWndProcFilterProc, g3d.hmodLib, GetCurrentThreadId()));
	Win16Only(hhookCallWndProcFilterProc = SetWindowsHookEx(WH_CALLWNDPROC, (FARPROC)CallWndProcFilterProc, g3d.hmodLib, GetCurrentTask()));
}

PRIVATE LRESULT CleanupSubclass(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam, int ct)
	{
	FARPROC lpfnWinProc;
	LRESULT lRet;

	lpfnWinProc = LpfnGetDefWndProc(hwnd, ct);
	lRet = CallWindowProc(lpfnWinProc, hwnd, wm, wParam, lParam);
	Win32Only(RemoveProp(hwnd, (LPCTSTR) g3d.aCtl3d));
	Win16Only(RemoveProp(hwnd, (LPCTSTR) g3d.aCtl3dLow));
	Win16Only(RemoveProp(hwnd, (LPCTSTR) g3d.aCtl3dHigh));
  	RemoveProp(hwnd, (LPCTSTR) g3d.aCtl3dDisable);
  	return lRet;
	}


PRIVATE VOID DeleteObjectNull(HANDLE FAR *ph)
	{
	if (*ph != NULL)
		{
		DeleteObject(*ph);
		*ph = NULL;
		}
	}

PRIVATE VOID DeleteObjects(VOID)
	{
	int icv;
	
	for(icv = 0; icv < icvBrushMax; icv++)
	    DeleteObjectNull(&g3d.brt.mpicvhbr[icv]);
	DeleteObjectNull(&g3d.hbmpCheckboxes);
	}


PRIVATE VOID PatFill(HDC hdc, RC FAR *lprc)
	{
	PatBlt(hdc, lprc->xLeft, lprc->yTop, lprc->xRight-lprc->xLeft, lprc->yBot-lprc->yTop, PATCOPY);
	}


/*-----------------------------------------------------------------------
|   DrawRec3d
|   
|   
|   Arguments:
|       HDC hdc:    
|       RC FAR *lprc:   
|       LONG cvUL:  
|       LONG cvLR:  
|       WORD grbit;
|       
|   Returns:
|       
-----------------------------------------------------------------------*/
PRIVATE VOID DrawRec3d(HDC hdc, RC FAR *lprc, ICV icvUL, ICV icvLR, DR3 dr3)
	{
	COLORREF cvSav;
	RC rc;

	cvSav = SetBkColor(hdc, g3d.clrt.rgcv[icvUL]);

	// top
	rc = *lprc;
	rc.yBot = rc.yTop+1;
	if (dr3 & dr3Top)
		ExtTextOut(hdc, 0, 0, ETO_OPAQUE, (LPRECT) &rc, 
			(LPCTSTR) NULL, 0, (int far *) NULL);

	// left
	rc.yBot = lprc->yBot;
	rc.xRight = rc.xLeft+1;
	if (dr3 & dr3Left)
	ExtTextOut(hdc, 0, 0, ETO_OPAQUE, (LPRECT) &rc, 
		(LPCTSTR) NULL, 0, (int far *) NULL);

	if (icvUL != icvLR)
		SetBkColor(hdc, g3d.clrt.rgcv[icvLR]);

	// right
	rc.xRight = lprc->xRight;
	rc.xLeft = rc.xRight-1;
	if (dr3 & dr3Right)
		ExtTextOut(hdc, 0, 0, ETO_OPAQUE, (LPRECT) &rc, 
			(LPCTSTR) NULL, 0, (int far *) NULL);

	// bot
	if (dr3 & dr3Bot)
		{
		rc.xLeft = lprc->xLeft;
		rc.yTop = rc.yBot-1;
		if (dr3 & dr3HackBotRight)
			rc.xRight -=2;
		ExtTextOut(hdc, 0, 0, ETO_OPAQUE, (LPRECT) &rc, 
			(LPCTSTR) NULL, 0, (int far *) NULL);
		}

	SetBkColor(hdc, cvSav);

	}

#ifdef CANTUSE
// Windows forces dialog fonts to be BOLD...URRRGH
PRIVATE VOID MyDrawText(HWND hwnd, HDC hdc, LPSTR lpch, int cch, RC FAR *lprc, int dt)
	{
	TEXTMETRIC tm;
	BOOL fChisled;

	fChisled = fFalse;
	if (!IsWindowEnabled(hwnd))
		{
		GetTextMetrics(hdc, &tm);
		if (tm.tmWeight > 400)
			SetTextColor(hdc, g3d.clrt.rgcv[icvGrayText]);
		else
			{
			fChisled = fTrue;
			SetTextColor(hdc, g3d.clrt.rgcv[icvBtnHilite]);
			OffsetRect((LPRECT) lprc, -1, -1);
			}
		}
	DrawText(hdc, lpch, cch, (LPRECT) lprc, dt);
	if (fChisled)
		{
		SetTextColor(hdc, g3d.clrt.rgcv[icvBtnHilite]);
		OffsetRect((LPRECT) lprc, 1, 1);
		DrawText(hdc, lpch, cch, (LPRECT) lprc, dt);
		}
	}
#endif


PRIVATE VOID DrawInsetRect3d(HDC hdc, RC FAR *prc, DR3 dr3)
	{
	RC rc;

	rc = *prc;
	DrawRec3d(hdc, &rc, icvWindowFrame, icvBtnFace, (WORD)(dr3 & dr3All));
	rc.xLeft--;
	rc.yTop--;
	rc.xRight++;
	rc.yBot++;
	DrawRec3d(hdc, &rc, icvBtnShadow, icvBtnHilite, dr3);
	}


PRIVATE VOID ClipCtlDc(HWND hwnd, HDC hdc)
	{
	RC rc;

	GetClientRect(hwnd, (LPRECT) &rc);
	IntersectClipRect(hdc, rc.xLeft, rc.yTop, rc.xRight, rc.yBot);
	}


PRIVATE int IclihkFromHinst(HANDLE hinst)
	{
	int iclihk;

	for (iclihk = 0; iclihk < g3d.iclihkMac; iclihk++)
		if (g3d.rgclihk[iclihk].hinstApp == hinst)
			return iclihk;
	return -1;
	}


PRIVATE VOID MyGetTextExtent(HDC hdc, LPTSTR lpsz, int FAR *lpdx, int FAR *lpdy)
	{
	LPTSTR lpch;
	TCHAR  szT[256];

	lpch = szT;
	while(*lpsz != '\000')
		{
		if (*lpsz == '&')
			{
			lpsz++;
			if (*lpsz == '\000')
				break;
			}
//begin DBCS: far east short cut key support
		else if (g3d.fDBCS)
			{
			if (*lpsz == g3d.chShortCutPrefix)
				{ // skip only prefix
				lpsz++;
				if (*lpsz == '\000')
					break;
				}
			else if (*lpsz == chShortCutSbcsPrefix || *lpsz == chShortCutDbcsPrefix)
				{ // skip both prefix and short cut key
				lpsz++;
				if (*lpsz == '\000')
					break;
				lpsz = Win32Or16(CharNext(lpsz),AnsiNext(lpsz));
				continue;
				}
			}
//end DBCS
		*lpch++ = *lpsz++;
		}
	*lpch = '\000';
#ifdef WIN32
	{
	SIZE	pt;

	GetTextExtentPoint(hdc, szT, lstrlen(szT), &pt);
	*lpdx = pt.cx;
	*lpdy = pt.cy;
	}
#else
	{
	long dwExt;

	dwExt = GetTextExtent(hdc, szT, lpch-(char far *)szT);
	*lpdx = LOWORD(dwExt);
	// Check for Hangeul Windows - JeeP 011194
	if ( (g3d.verWindows >= ver31 && GetSystemMetrics(SM_DBCSENABLED)) ||
		 (IsDBCSLeadByte(0xa1) && !IsDBCSLeadByte(0xa0)) )
		*lpdy = HIWORD(dwExt)+1;
	else
		*lpdy = HIWORD(dwExt);
	}
#endif
	}
	

/*-----------------------------------------------------------------------
|   CTL3D Publics
-----------------------------------------------------------------------*/


PUBLIC BOOL WINAPI Ctl3dRegister(HANDLE hinstApp)
	{

#ifdef WIN32
#ifndef DLL
	InitializeCriticalSection(&g_CriticalSection);
#endif
	EnterCriticalSection(&g_CriticalSection);
#endif

	g3d.cInited++;

	Win32Only(LeaveCriticalSection(&g_CriticalSection));

	if (g3d.cInited == 1)
		{
#ifndef DLL
#ifdef SDLL
		Win32Only(Ctl3dLibMain(hinstApp, DLL_PROCESS_ATTACH, (LPVOID) NULL));
		Win16Only(Ctl3dLibMain(hinstApp, 0, 0, (LPSTR) NULL));
#else
		Win32Only(LibMain(hinstApp, DLL_PROCESS_ATTACH, (LPVOID) NULL));
		Win16Only(LibMain(hinstApp, 0, 0, (LPSTR) NULL));
#endif
#endif
		FInit3dDialogs();
		}

	if (Ctl3dIsAutoSubclass())
		Ctl3dAutoSubclass(hinstApp);

	return g3d.f3dDialogs;
	}


PUBLIC BOOL WINAPI Ctl3dUnregister(HANDLE hinstApp)
	{
	int iclihk;
	HANDLE hTask;

	//
	// Find the task's hook
	//
	Win32Only(hTask = (HANDLE)GetCurrentThreadId());
	Win16Only(hTask = GetCurrentTask());

	Win32Only(EnterCriticalSection(&g_CriticalSection));

	for (iclihk = 0; iclihk < g3d.iclihkMac; iclihk++)
		{
		if (g3d.rgclihk[iclihk].htask == hTask)
			{
			g3d.rgclihk[iclihk].iCount--;
			if ( g3d.rgclihk[iclihk].iCount == 0 || hinstApp == g3d.rgclihk[iclihk].hinstApp)
				{
				Win32Only(UnhookWindowsHookEx(g3d.rgclihk[iclihk].hhook));
#ifdef DLL
				Win16Only((*g3d.lpfnUnhookWindowsHookEx)(g3d.rgclihk[iclihk].hhook));
#else
				Win16Only(UnhookWindowsHookEx(g3d.rgclihk[iclihk].hhook));
#endif
				g3d.iclihkMac--;
				while(iclihk < g3d.iclihkMac)
					{
					g3d.rgclihk[iclihk] = g3d.rgclihk[iclihk+1];
					iclihk++;
					}
				}
			}
		}

	g3d.cInited--;

	Win32Only(LeaveCriticalSection(&g_CriticalSection));
		
	if (g3d.cInited == 0)
		{
		End3dDialogs();
		}
	return fTrue;
	}




/*-----------------------------------------------------------------------
|   Ctl3dAutoSubclass
|   
|	   Automatically subclasses all dialogs of the client app.
|
|   Note: Due to bugs in Commdlg, an app should still call Ctl3dSubclassDlg 
|   for the Commdlg OpenFile and PageSetup dialogs.
|   
|   Arguments:
|	   HANDLE hinstApp:	
|	   
|   Returns:
|	   
-----------------------------------------------------------------------*/
PUBLIC BOOL WINAPI Ctl3dAutoSubclass(HANDLE hinstApp)
{
	return Ctl3dAutoSubclassEx(hinstApp, 0);
}

PUBLIC BOOL WINAPI Ctl3dAutoSubclassEx(HANDLE hinstApp, DWORD dwFlags)
	{
	HHOOK  hhook;
	HANDLE htask;
	int    iclihk;

	if (g3d.verWindows < ver31)
		return fFalse;
	if (!g3d.f3dDialogs)
		return fFalse;

#ifdef WIN32
	// CTL3D_SUBCLASS_DYNCREATE is considered default in Win32, but
	// not Win16 for backward compatibility reasons.
	dwFlags |= CTL3D_SUBCLASS_DYNCREATE;
#endif
	// CTL3D_NOSUBCLASS_DYNCREATE always overrides CTL3D_SUBCLASS_DYNCREATE
	if (dwFlags & CTL3D_NOSUBCLASS_DYNCREATE)
		dwFlags &= ~(CTL3D_NOSUBCLASS_DYNCREATE|CTL3D_SUBCLASS_DYNCREATE);

	Win32Only(EnterCriticalSection(&g_CriticalSection));

	if (g3d.iclihkMac == iclihkMax)
		goto Fail;

	Win32Only(htask = (HANDLE)GetCurrentThreadId());
	Win16Only(htask = GetCurrentTask());
	//
	// Don't set the hook twice for the same task....
	//
	for (iclihk = 0; iclihk < g3d.iclihkMac; iclihk++)
		{
		if (g3d.rgclihk[iclihk].htask == htask)
			{
			g3d.rgclihk[iclihk].iCount++;
			goto Success;
			}
		}

	Win32Only(hhook = SetWindowsHookEx(WH_CBT, (HOOKPROC)Ctl3dHook, g3d.hmodLib, (DWORD)htask));
#ifdef DLL
	Win16Only(hhook = (*g3d.lpfnSetWindowsHookEx)(WH_CBT, (HOOKPROC) Ctl3dHook, g3d.hmodLib, hinstApp == NULL ? NULL : htask));
#else
	Win16Only(hhook = SetWindowsHookEx(WH_CBT, (HOOKPROC) Ctl3dHook, g3d.hmodLib, hinstApp == NULL ? NULL : htask));
#endif
	if (hhook != NULL)
		{
		g3d.rgclihk[g3d.iclihkMac].hinstApp = hinstApp;
		g3d.rgclihk[g3d.iclihkMac].htask	= htask;
		g3d.rgclihk[g3d.iclihkMac].hhook	= hhook;
		g3d.rgclihk[g3d.iclihkMac].iCount	= 1;
		g3d.rgclihk[g3d.iclihkMac].dwFlags	= dwFlags;
		g3d.htaskCache = htask;
		g3d.iclihkCache = g3d.iclihkMac;
		g3d.iclihkMac++;
Success:
		Win32Only(LeaveCriticalSection(&g_CriticalSection));
		return fTrue;
		}
Fail:
	Win32Only(LeaveCriticalSection(&g_CriticalSection));
	return fFalse;
	}

/*-----------------------------------------------------------------------
|	Ctl3dIsAutoSubclass
|   
|   Returns:
|		Whether this task has Automatic Subclassing Enabled
|       
-----------------------------------------------------------------------*/
PUBLIC BOOL WINAPI Ctl3dIsAutoSubclass()
	{
		int iclihk;
		HANDLE hTask;

		Win32Only(hTask = (HANDLE)GetCurrentThreadId());
		Win16Only(hTask = GetCurrentTask());

		for (iclihk = 0; iclihk < g3d.iclihkMac; iclihk++)
			{
			if (g3d.rgclihk[iclihk].htask == hTask)
				{
				return TRUE;
				}
			}
		// didn't find task in hook table.
		return FALSE;
	}

/*-----------------------------------------------------------------------
|	Ctl3dUnAutoSubclass
|   
-----------------------------------------------------------------------*/
PUBLIC BOOL WINAPI Ctl3dUnAutoSubclass()
	{
	int iclihk;
	HANDLE hTask;

	// Find the task's hook
	//
	//
	Win32Only(hTask = (HANDLE)GetCurrentThreadId());
	Win16Only(hTask = GetCurrentTask());
	Win32Only(EnterCriticalSection(&g_CriticalSection));
	for (iclihk = 0; iclihk < g3d.iclihkMac; iclihk++)
		{
		if (g3d.rgclihk[iclihk].htask == hTask)
			{
			g3d.rgclihk[iclihk].iCount--;
			if ( g3d.rgclihk[iclihk].iCount == 0 )
				{
				Win32Only(UnhookWindowsHookEx(g3d.rgclihk[iclihk].hhook));
#ifdef DLL
				Win16Only((*g3d.lpfnUnhookWindowsHookEx)(g3d.rgclihk[iclihk].hhook));
#else
				Win16Only(UnhookWindowsHookEx(g3d.rgclihk[iclihk].hhook));
#endif
				g3d.iclihkMac--;
				while(iclihk < g3d.iclihkMac)
					{
					g3d.rgclihk[iclihk] = g3d.rgclihk[iclihk+1];
					iclihk++;
					}
				}
			}
		}
	Win32Only(LeaveCriticalSection(&g_CriticalSection));
	return TRUE;
	}

WORD __export _loadds WINAPI Ctl3dSetStyle(HANDLE hinst, LPTSTR lpszName, WORD grbit)
	{
#ifdef OLD
	WORD grbitOld;

	if (!g3d.f3dDialogs)
		return fFalse;

	grbitOld = grbitStyle;
	if (grbit != 0)
		grbitStyle = grbit;

	if (hinst != NULL && lpszName != NULL)
		{
		HBITMAP hbmpCheckboxesNew;

		hbmpCheckboxesNew = LoadUIBitmap(hinst, (LPCSTR) lpszName,
			g3d.clrt.rgcv[icvWindowText],
			g3d.clrt.rgcv[icvBtnFace],
			g3d.clrt.rgcv[icvBtnShadow],
			g3d.clrt.rgcv[icvBtnHilite],
			g3d.clrt.rgcv[icvWindow],
			g3d.clrt.rgcv[icvWindowFrame]);
		if (hbmpCheckboxesNew != NULL)
			{
			DeleteObjectNull(&g3d.hbmpCheckboxes);
			g3d.hbmpCheckboxes = hbmpCheckboxesNew;
			}
		}
	
	return grbitOld;
#endif
	return 0;
	}


/*-----------------------------------------------------------------------
|   Ctl3dGetVer
|   
|       Returns version of CTL3D library
|   
|   Returns:
|       Major version # in hibyte, minor version # in lobyte
|       
-----------------------------------------------------------------------*/
PUBLIC WORD WINAPI Ctl3dGetVer(void)
    {
	return 0x0231;
    }


/*-----------------------------------------------------------------------
|   Ctl3dEnabled
|   
|   Returns:
|       Whether or not controls will be draw with 3d effects
-----------------------------------------------------------------------*/
PUBLIC BOOL WINAPI Ctl3dEnabled(void)
	{
	return g3d.f3dDialogs;
	}



/*-----------------------------------------------------------------------
|   Ctl3dSubclassCtl
|   
|       Subclasses an individual control
|   
|   Arguments:
|       HWND hwnd:  
|       
|   Returns:
|       fTrue if control was successfully subclassed
|       
-----------------------------------------------------------------------*/
PUBLIC BOOL WINAPI Ctl3dSubclassCtl(HWND hwnd)
	{
	if (!g3d.f3dDialogs)
		return fFalse;
	return DoSubclassCtl(hwnd, CTL3D_ALL, OUTCBTHOOK, NULL);
	}

/*-----------------------------------------------------------------------
|	Ctl3dUnsubclassCtl
|   
|		Un-Subclasses an individual control
|   
|   Arguments:
|		HWND hwnd:
|       
|   Returns:
|       fTrue if control was successfully subclassed
|       
-----------------------------------------------------------------------*/
PUBLIC BOOL WINAPI Ctl3dUnsubclassCtl(HWND hwnd)
	{
	FARPROC lpfnWinProc;
	HWND hwndKids;
	int ct;

	if (!g3d.f3dDialogs)
		return fFalse;

	lpfnWinProc = (FARPROC) GetWindowLong(hwnd, GWL_WNDPROC);

	// Is it a control
	for (ct = 0; ct < ctMax; ct++)
		{
		if ( lpfnWinProc == g3d.mpctctl[ct].lpfn )
			{
			 lpfnWinProc = LpfnGetDefWndProc(hwnd, ct);
			 Win32Only(RemoveProp(hwnd, (LPCTSTR) g3d.aCtl3d));
			 Win16Only(RemoveProp(hwnd, (LPCTSTR) g3d.aCtl3dLow));
			 Win16Only(RemoveProp(hwnd, (LPCTSTR) g3d.aCtl3dHigh));
			 SetWindowLong(hwnd, GWL_WNDPROC, (LONG) lpfnWinProc );
			 lpfnWinProc = NULL;
			 ct = ctMax+10;
			}
		}

	// How about a dlg ?
	if ( ct == ctMax )
		{
		 if ( lpfnWinProc == (FARPROC) Ctl3dDlgProc )
			{
			 lpfnWinProc = LpfnGetDefWndProc(hwnd, ct);
			 Win32Only(RemoveProp(hwnd, (LPCTSTR) g3d.aCtl3d));
			 Win16Only(RemoveProp(hwnd, (LPCTSTR) g3d.aCtl3dLow));
			 Win16Only(RemoveProp(hwnd, (LPCTSTR) g3d.aCtl3dHigh));
			 SetWindowLong(hwnd, GWL_WNDPROC, (LONG) lpfnWinProc );
			 lpfnWinProc = NULL;
			}
		 else
			{
			   // None of the above, add disable property
			   if (GetProp(hwnd, (LPCTSTR) g3d.aCtl3d) ||
			   	   GetProp(hwnd, (LPCTSTR) g3d.aCtl3dLow) ||
			   	   GetProp(hwnd, (LPCTSTR) g3d.aCtl3dHigh))
			   {
			   		SetProp(hwnd,(LPCTSTR) g3d.aCtl3dDisable, (HANDLE) 1);
			   }
			}
		}

	//
	// Now unsubclass all the kids
	//
	for (hwndKids = GetWindow(hwnd, GW_CHILD); hwndKids != NULL;
				hwndKids = GetWindow(hwndKids, GW_HWNDNEXT))
		{
			Ctl3dUnsubclassCtl(hwndKids);
		}

	return fTrue;

	}


/*-----------------------------------------------------------------------
|	Ctl3dSubclassCtlEx
|   
|	   Actually subclass the control
|   
|	   
-----------------------------------------------------------------------*/
PUBLIC BOOL WINAPI Ctl3dSubclassCtlEx(HWND hwnd, int ct)
	{
	LONG style;
	BOOL fCan;

	if (!g3d.f3dDialogs)
		return fFalse;

	if (ct < 0 || ct > ctMax)
		return fFalse;

	// Is this already subclassed by CTL3D?
	if (LpfnGetDefWndProcNull(hwnd) != (FARPROC) NULL)
	   return fFalse;

	// Only subclass it if it is something that we'd normally subclass
	style = GetWindowLong(hwnd, GWL_STYLE);
	fCan = mpctcdef[ct].lpfnFCanSubclass(hwnd, style, CTL3D_ALL,
		OUTCBTHOOK, GetParent(hwnd));
	if (fCan == fTrue)
		SubclassWindow(hwnd, g3d.mpctctl[ct].lpfn);

	return fTrue;
	}

/*-----------------------------------------------------------------------
|   Ctl3dSubclassDlg
|
|	   Call this during WM_INITDIALOG processing.
|
|   Arguments:
|	   hwndDlg:
|
-----------------------------------------------------------------------*/
PUBLIC BOOL WINAPI Ctl3dSubclassDlg(HWND hwndDlg, WORD grbit)
	{
	HWND hwnd;

	if (!g3d.f3dDialogs)
		return fFalse;

	for(hwnd = GetWindow(hwndDlg, GW_CHILD); hwnd != NULL;
		hwnd = GetWindow(hwnd, GW_HWNDNEXT))
		{
		DoSubclassCtl(hwnd, grbit, OUTCBTHOOK, NULL);
		}
	return fTrue;
	}

/*-----------------------------------------------------------------------
|	Ctl3dCheckSubclassDlg
|
|	   Call this during WM_INITDIALOG processing.
|
|   Arguments:
|	   hwndDlg:
|
-----------------------------------------------------------------------*/
PRIVATE void CheckChildSubclass(HWND hwnd, WORD grbit, HWND hwndParent)
{
	// Is this already subclassed by CTL3D?
	// Is our property there ?
	if (LpfnGetDefWndProcNull(hwnd) == (FARPROC) NULL)
		{
		// No, how did this slip by, try a subclass again.
		DoSubclassCtl(hwnd, grbit, OUTCBTHOOK, hwndParent);
		}
	else
		{
		// Yes, we have subclassed this control.
		// Is our subclass still on the chain ?
		BOOL fSubclass;

		// Make sure subclassing isn't disabled...
		if (GetProp(hwnd, (LPCTSTR)g3d.aCtl3dDisable))
			return;

		fSubclass = 666;
		SendMessage((HWND) hwnd, WM_CHECKSUBCLASS, 0, (LPARAM)(int FAR *)&fSubclass);
		if ( fSubclass == 666 )
			SendMessage((HWND) hwnd, WM_CHECKSUBCLASS_OLD, 0, (LPARAM)(int FAR *)&fSubclass);

		if ( fSubclass == 666 )  // Evil
			{
			// We have been un-subclassed by some bad app ( common dialogs in Win16 )
			// Remove the Prop, and subclass again, take that.
			Win32Only(RemoveProp(hwnd, (LPCTSTR) g3d.aCtl3d));
			Win16Only(RemoveProp(hwnd, (LPCTSTR) g3d.aCtl3dLow));
			Win16Only(RemoveProp(hwnd, (LPCTSTR) g3d.aCtl3dHigh));
			DoSubclassCtl(hwnd, grbit, OUTCBTHOOK, hwndParent);
			}
		}
}

PUBLIC BOOL WINAPI Ctl3dCheckSubclassDlg(HWND hwndDlg, WORD grbit)
	{
	HWND hwnd, hwnd2;

	if (!g3d.f3dDialogs)
		return fFalse;

	for (hwnd = GetWindow(hwndDlg, GW_CHILD); hwnd != NULL;
		hwnd = GetWindow(hwnd, GW_HWNDNEXT))
		{
			CheckChildSubclass(hwnd, grbit, NULL);
			for (hwnd2 = GetWindow(hwnd, GW_CHILD); hwnd2 != NULL;
				hwnd2 = GetWindow(hwnd2, GW_HWNDNEXT))
				{
					CheckChildSubclass(hwnd2, grbit, hwnd);
				}
		}

	return fTrue;
	}

/*-----------------------------------------------------------------------
|   Ctl3dSubclassDlgEx
|
|	   Call this during WM_INITDIALOG processing. This is like
|	 Ctl3dSubclassDlg but it also subclasses the dialog window itself
|	 so the app doesn't need to.
|
|   Arguments:
|	   hwndDlg:
|
-----------------------------------------------------------------------*/
PUBLIC BOOL WINAPI Ctl3dSubclassDlgEx(HWND hwndDlg, DWORD grbit)
	{
	HWND hwnd;

	if (!g3d.f3dDialogs)
		return fFalse;

	for(hwnd = GetWindow(hwndDlg, GW_CHILD); hwnd != NULL;
		hwnd = GetWindow(hwnd, GW_HWNDNEXT))
		{
		DoSubclassCtl(hwnd, LOWORD(grbit), OUTCBTHOOK, NULL);
		}

	//
	// Now Subclass the dialog window as well
	//
	SubclassWindow((HWND) hwndDlg, (FARPROC)Ctl3dDlgProc);

	return fTrue;
	}


/*-----------------------------------------------------------------------
|   Ctl3dCtlColor
|
|       Common CTL_COLOR processor for 3d UITF dialogs & alerts.
|
|   Arguments:
|       hdc:
|       lParam:
|
|   Returns:
|       appropriate brush if g3d.f3dDialogs.  Returns fFalse otherwise
|
-----------------------------------------------------------------------*/
PUBLIC HBRUSH WINAPI Ctl3dCtlColor(HDC hdc, LPARAM lParam)
	{
#ifdef WIN32
	return (HBRUSH) fFalse;
#else
	HWND hwndParent;

	Assert(CTLCOLOR_MSGBOX < CTLCOLOR_BTN);
	Assert(CTLCOLOR_EDIT < CTLCOLOR_BTN);
	Assert(CTLCOLOR_LISTBOX < CTLCOLOR_BTN);
	if(g3d.f3dDialogs)
		{
		if (HIWORD(lParam) >= CTLCOLOR_LISTBOX)
			{
			if (HIWORD(lParam) == CTLCOLOR_LISTBOX &&
				(g3d.verWindows >= ver40 ||
				((GetWindow(LOWORD(lParam), GW_CHILD) == NULL ||
				(GetWindowLong(LOWORD(lParam), GWL_STYLE) & 0x03) == CBS_DROPDOWNLIST))))
				{
				// if it doesn't have a child then it must be a list box
				// don't do brush stuff for drop down lists or else
				// it draws funny grey inside the edit rect
				goto DefWP;
				}
			SetTextColor(hdc, g3d.clrt.rgcv[icvBtnText]);
			SetBkColor(hdc, g3d.clrt.rgcv[icvBtnFace]);
			return g3d.brt.mpicvhbr[icvBtnFace];
			}
		}
DefWP:
	hwndParent = GetParent(LOWORD(lParam));
	if (hwndParent == NULL)
		return fFalse;
	return (HBRUSH) DefWindowProc(hwndParent, WM_CTLCOLOR, (WPARAM) hdc, (LONG) lParam);
#endif
	}



/*-----------------------------------------------------------------------
|   Ctl3dCtlColorEx
|
|       Common CTL_COLOR processor for 3d UITF dialogs & alerts.
|
|   Arguments:
|
|   Returns:
|       appropriate brush if g3d.f3dDialogs.  Returns fFalse otherwise
|
-----------------------------------------------------------------------*/
PUBLIC HBRUSH WINAPI Ctl3dCtlColorEx(UINT wm, WPARAM wParam, LPARAM lParam)
	{
#ifdef WIN32
	Assert(WM_CTLCOLORMSGBOX < WM_CTLCOLORBTN);
	Assert(WM_CTLCOLOREDIT < WM_CTLCOLORBTN);
	Assert(WM_CTLCOLORLISTBOX < WM_CTLCOLORBTN);
	if(g3d.f3dDialogs)
		{
		if (wm >= WM_CTLCOLORLISTBOX && wm != WM_CTLCOLORSCROLLBAR)
			{
			if (wm == WM_CTLCOLORLISTBOX &&
				(g3d.verWindows >= ver40 ||
				((GetWindow((HWND) lParam, GW_CHILD) == NULL ||
				(GetWindowLong((HWND) lParam, GWL_STYLE) & 0x03) == CBS_DROPDOWNLIST))))
				{
				// if it doesn't have a child then it must be a list box
				// don't do brush stuff for drop down lists or else
				// it draws funny grey inside the edit rect
				return (HBRUSH) fFalse;
				}
			SetTextColor((HDC) wParam, g3d.clrt.rgcv[icvBtnText]);
			SetBkColor((HDC) wParam, g3d.clrt.rgcv[icvBtnFace]);
			return g3d.brt.mpicvhbr[icvBtnFace];
			}
		}
	return (HBRUSH) fFalse;
#else
	return Ctl3dCtlColor(wParam, lParam);
#endif
	}


/*-----------------------------------------------------------------------
|   Ctl3dColorChange
|   
|	   App calls this when it gets a WM_SYSCOLORCHANGE message
|	   
|   Returns:
|	   TRUE if successful.
|	   
-----------------------------------------------------------------------*/
PUBLIC BOOL WINAPI Ctl3dColorChange(VOID)
	{
	BOOL bResult;
	Win32Only(EnterCriticalSection(&g_CriticalSection));
	bResult = InternalCtl3dColorChange(fFalse);
	Win32Only(LeaveCriticalSection(&g_CriticalSection));
	return bResult;
	}

PRIVATE LONG WINAPI
Ctl3dDlgFramePaintI(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam, BOOL fDefWP);

/*-----------------------------------------------------------------------
|	Ctl3dDlgFramePaint
|   
|	   App calls this when it gets a NC_PAINT message
|	   
|   Returns:
|	   TRUE if successful.
|	   
-----------------------------------------------------------------------*/
PUBLIC LONG WINAPI Ctl3dDlgFramePaint(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
	{
	return Ctl3dDlgFramePaintI(hwnd, wm, wParam, lParam, TRUE);
	}

// Ctl3dDlgFramePaintI used only internally by Ctl3d
PRIVATE LONG WINAPI 
Ctl3dDlgFramePaintI(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam, BOOL fDefWP)
	{
	LONG lResult;
	LONG lStyle;
	BOOL fBorder;

	WNDPROC defProc = fDefWP ? NULL : (WNDPROC) LpfnGetDefWndProc(hwnd, ctMax);

	if (defProc != NULL)
		lResult = CallWindowProc((FARPROC)defProc, hwnd, wm, wParam, lParam);
	else
		lResult = DefWindowProc(hwnd, wm, wParam, lParam);

	if (!g3d.f3dDialogs)
		return lResult;

	if ( IsIconic(hwnd) )
		return lResult;

	fBorder = CTL3D_BORDER;
	SendMessage(hwnd, WM_DLGBORDER, 0, (LPARAM)(int FAR *)&fBorder);
	lStyle = GetWindowLong(hwnd, GWL_STYLE);
	if (fBorder != CTL3D_NOBORDER && (lStyle & (WS_VISIBLE|WS_DLGFRAME|DS_MODALFRAME)) == (WS_VISIBLE|WS_DLGFRAME|DS_MODALFRAME))
		{
		BOOL fCaption;
		HBRUSH hbrSav;
		HDC hdc;
		RC rc;
		RC rcFill;
		int dyFrameTop;

		fCaption = (lStyle & WS_CAPTION) == WS_CAPTION;
		dyFrameTop = g3d.dyFrame - (fCaption ? dyBorder : 0);

		hdc = GetWindowDC(hwnd);
		GetWindowRect(hwnd, (LPRECT) &rc);
		rc.xRight = rc.xRight-rc.xLeft;
		rc.yBot = rc.yBot-rc.yTop;
		rc.xLeft = rc.yTop = 0;

		DrawRec3d(hdc, &rc, icvBtnShadow, icvWindowFrame, dr3All);
		InflateRect((LPRECT) &rc, -dxBorder, -dyBorder);
		DrawRec3d(hdc, &rc, icvBtnHilite, icvBtnShadow, dr3All);
		InflateRect((LPRECT) &rc, -dxBorder, -dyBorder);
		
		hbrSav = SelectObject(hdc, g3d.brt.mpicvhbr[icvBtnFace]);
		rcFill = rc;
		// Left
		rcFill.xRight = rcFill.xLeft+g3d.dxFrame;
		PatFill(hdc, &rcFill);
		// Right
		OffsetRect((LPRECT) &rcFill, rc.xRight-rc.xLeft-g3d.dxFrame, 0);
		PatFill(hdc, &rcFill);
		// Top
		rcFill.xLeft = rc.xLeft + g3d.dxFrame;
		rcFill.xRight = rc.xRight - g3d.dxFrame;
		rcFill.yBot = rcFill.yTop+dyFrameTop;
		PatFill(hdc, &rcFill);
		if (fCaption)
			{
			RC rcT;

			rcT = rcFill;
			rcT.yTop += dyFrameTop;
			rcT.yBot = rcT.yTop + g3d.dyCaption;
			DrawRec3d(hdc, &rcT, icvBtnShadow, icvBtnHilite, dr3All);
			}

		// Bottom
		rcFill.yTop += rc.yBot-rc.yTop-g3d.dxFrame;
		rcFill.yBot = rcFill.yTop + g3d.dyFrame;
		PatFill(hdc, &rcFill);
#ifdef CHISLEBORDER
		if (fBorder == CTL3D_CHISLEBORDER)
			{
			// This code doesn't work because it draws in the client area
			GetClientRect(hwnd, (LPRECT) &rc);
			OffsetRect((LPRECT) &rc, g3d.dxFrame+2*dxBorder, fCaption ? g3d.dyFrame+g3d.dyCaption : g3d.dyFrame+dyBorder);
			DrawRec3d(hdc, &rc, icvBtnShadow, icvBtnHilite, dr3Bot|dr3Left|dr3Right);
			rc.xLeft++;
			rc.xRight--;
			rc.yBot--;
			DrawRec3d(hdc, &rc, icvBtnHilite, icvBtnShadow, dr3Bot|dr3Left|dr3Right);
			}
#endif
		SelectObject(hdc, hbrSav);
		ReleaseDC(hwnd, hdc);
		}
	return lResult;
	}


//begin DBCS: far east short cut key support
/*-----------------------------------------------------------------------
|	CTL3D Far East Support
-----------------------------------------------------------------------*/

/*-----------------------------------------------------------------------
|	Ctl3dWinIniChange
|	
|		App calls this when it gets a WM_WININICHANGE message
|		
|	Returns:
|		none
|		
-----------------------------------------------------------------------*/
PUBLIC VOID WINAPI Ctl3dWinIniChange(void)
	{
	TCHAR szShortCutMode[cchShortCutModeMax];
	CodeLpszDecl(szSectionWindows, TEXT("windows"));
	CodeLpszDecl(szEntryShortCutKK, TEXT("kanjimenu"));
	CodeLpszDecl(szEntryShortCutCH, TEXT("hangeulmenu"));
	CodeLpszDecl(szShortCutSbcsKK, TEXT("roman"));
	CodeLpszDecl(szShortCutSbcsCH, TEXT("english"));
	CodeLpszDecl(szShortCutDbcsKK, TEXT("kanji"));
	CodeLpszDecl(szShortCutDbcsCH, TEXT("hangeul"));

	if (!g3d.fDBCS)
		return;

	Win32Only(EnterCriticalSection(&g_CriticalSection));

	g3d.chShortCutPrefix = chShortCutSbcsPrefix;
	GetProfileString(szSectionWindows, szEntryShortCutKK, szShortCutSbcsKK, szShortCutMode, cchShortCutModeMax - 1);
	if (!lstrcmpi(szShortCutMode, szShortCutDbcsKK))
		g3d.chShortCutPrefix = chShortCutDbcsPrefix;
	GetProfileString(szSectionWindows, szEntryShortCutCH, szShortCutSbcsCH, szShortCutMode, cchShortCutModeMax - 1);
	if (!lstrcmpi(szShortCutMode, szShortCutDbcsCH))
		g3d.chShortCutPrefix = chShortCutDbcsPrefix;

	Win32Only(LeaveCriticalSection(&g_CriticalSection));
	}
//end DBCS



/*-----------------------------------------------------------------------
|   CTL3D Internal Routines
-----------------------------------------------------------------------*/


/*-----------------------------------------------------------------------
|   FInit3dDialogs
|
|	   Initialized 3d stuff
|
-----------------------------------------------------------------------*/
PRIVATE BOOL FAR FInit3dDialogs(VOID)
	{
	HDC hdc;
	WNDCLASS wc;

#ifdef DLL
#ifdef V2
	int nChars;
	LPTSTR pCh;
	static TCHAR MyDirectory[260];
	TCHAR OkDirectory[260];
#endif
#endif

	//if (g3d.verWindows >= ver40)
	//	  {
	//	  g3d.f3dDialogs = fFalse;
	//	  return fFalse;
	//	  }

	Win32Only(EnterCriticalSection(&g_CriticalSection));

#ifdef DLL
#ifdef V2

#ifdef WIN32
	{
		TCHAR szT[2];
		CodeLpszDecl(szSpecial, TEXT("Ctl3d_RunAlways"));
		if (GetEnvironmentVariable(szSpecial, szT, 2) != 0 && szT[0] == '1')
		{
			goto AllowBadInstall;
		}
	}
#endif

#ifdef WIN32
#ifdef UNICODE
	if (GetVersion() & 0x80000000)
	{
		Win16Or32(
			CodeLpszDeclA(lpszCtl3d, "CTL3DV2.DLL"),
			CodeLpszDeclA(lpszCtl3d, "CTL3D32.DLL"));
		CodeLpszDeclA(lpszBadInstMsg,
			"This application uses CTL3D32.DLL, which is not the correct version.  "
			"This version of CTL3D32.DLL is designed only for Windows NT systems.");
		MessageBoxA(NULL, lpszBadInstMsg, lpszCtl3d, MB_ICONSTOP | MB_OK);
		g3d.f3dDialogs = fFalse;
		goto Return;
	}
#else
	if (!(GetVersion() & 0x80000000))
	{
		Win16Or32(
			CodeLpszDeclA(lpszCtl3d, "CTL3DV2.DLL"),
			CodeLpszDeclA(lpszCtl3d, "CTL3D32.DLL"));
		CodeLpszDeclA(lpszBadInstMsg,
			"This application uses CTL3D32.DLL, which is not the correct version.  "
			"This version of CTL3D32.DLL is designed only for Win32s or Windows 95 systems.");
		MessageBoxA(NULL, lpszBadInstMsg, lpszCtl3d, MB_ICONSTOP | MB_OK);
		g3d.f3dDialogs = fFalse;
		goto Return;
	}
#endif
#endif
#ifndef SPECIAL_WOW_VERSION
	nChars = GetModuleFileName(g3d.hinstLib, MyDirectory, sizeof(MyDirectory)Win32Only(/sizeof(TCHAR)));
	for (pCh = (LPTSTR)(MyDirectory+nChars-1);
		 pCh >= (LPTSTR)MyDirectory;
		 pCh = Win32Or16(CharPrev(MyDirectory, pCh),AnsiPrev(MyDirectory, pCh)))
		{
		if (  *pCh == '\\' )
			{
			if ( *(pCh-1) != ':' )
				*pCh = 0;
			else
				*(pCh+1) = 0;
			break;
			}
		}

	nChars = GetSystemDirectory(OkDirectory, sizeof(OkDirectory)Win32Only(/sizeof(TCHAR)));
	if ( lstrcmpi(MyDirectory,OkDirectory ) )
		{
		nChars = GetWindowsDirectory(OkDirectory, sizeof(OkDirectory)Win32Only(/sizeof(TCHAR)));
		if ( lstrcmpi(MyDirectory,OkDirectory ) )
			{
			Win16Or32(
				CodeLpszDeclA(lpszCtl3d, "CTL3DV2.DLL"),
				CodeLpszDeclA(lpszCtl3d, "CTL3D32.DLL"));
			Win16Or32(
			CodeLpszDeclA(lpszBadInstMsg,
				"This application uses CTL3DV2.DLL, which has not been correctly installed.  "
				"CTL3DV2.DLL must be installed in the Windows system directory."),
			CodeLpszDeclA(lpszBadInstMsg,
				"This application uses CTL3D32.DLL, which has not been correctly installed.  "
				"CTL3D32.DLL must be installed in the Windows system directory."));
			Win32Only(LeaveCriticalSection(&g_CriticalSection));
			MessageBoxA(NULL, lpszBadInstMsg, lpszCtl3d, MB_ICONSTOP | MB_OK );
			g3d.f3dDialogs = fFalse;
			goto Return;
			}
		}
#endif //!SPECIAL_WOW_VERSION

Win32Only(AllowBadInstall:;)
#endif
#endif

	hdc = GetDC(NULL);
	g3d.f3dDialogs = GetDeviceCaps(hdc,BITSPIXEL)*GetDeviceCaps(hdc,PLANES) >= 4;
	// Win 3.1 EGA lies to us...
	if(GetSystemMetrics(SM_CYSCREEN) == 350 && GetSystemMetrics(SM_CXSCREEN) == 640)
	    g3d.f3dDialogs = fFalse;
	ReleaseDC(NULL, hdc);
	if (g3d.f3dDialogs)
		{
		int ct; 
		CodeLpszDecl(lpszC3dD, TEXT("C3dD"));
		
		CodeLpszDecl(lpszC3dOld, TEXT("C3d"));
		CodeLpszDecl(lpszC3dLOld, TEXT("C3dL"));
		CodeLpszDecl(lpszC3dHOld, TEXT("C3dH"));
		CodeLpszDecl(lpszC3d, TEXT("C3dNew"));
		CodeLpszDecl(lpszC3dL, TEXT("C3dLNew"));
		CodeLpszDecl(lpszC3dH, TEXT("C3dHNew"));

		g3d.aCtl3dOld = GlobalAddAtom(lpszC3dOld);
		if (g3d.aCtl3dOld == 0)
			{
			g3d.f3dDialogs = fFalse;
			goto Return;
			}
		g3d.aCtl3d	= GlobalAddAtom(lpszC3d);
		if (g3d.aCtl3d == 0)
			{
			g3d.f3dDialogs = fFalse;
			goto Return;
			}

		g3d.aCtl3dLowOld = GlobalAddAtom(lpszC3dLOld);
		g3d.aCtl3dHighOld = GlobalAddAtom(lpszC3dHOld);
		if (g3d.aCtl3dLowOld == 0 || g3d.aCtl3dHighOld == 0)
	  		{
			g3d.f3dDialogs = fFalse;
			return fFalse;
			}

		g3d.aCtl3dLow  = GlobalAddAtom(lpszC3dL);
		g3d.aCtl3dHigh = GlobalAddAtom(lpszC3dH);
		if (g3d.aCtl3dLow == 0 || g3d.aCtl3dHigh == 0)
	  		{
			g3d.f3dDialogs = fFalse;
			return fFalse;
			}

		g3d.aCtl3dDisable = GlobalAddAtom(lpszC3dD);
		if (g3d.aCtl3dDisable == 0)
			{
			g3d.f3dDialogs = fFalse;
			goto Return;
			}

		// DBCS
		g3d.fDBCS = GetSystemMetrics(SM_DBCSENABLED);
		Ctl3dWinIniChange();
                                                     
		if (InternalCtl3dColorChange(fTrue))        // load bitmap & brushes
			{
			for (ct = 0; ct < ctMax; ct++)
				{
				g3d.mpctctl[ct].lpfn = (FARPROC)mpctcdef[ct].lpfnWndProc;
				Assert(g3d.mpctctl[ct].lpfn != NULL);
                GetClassInfo(NULL, mpctcdef[ct].sz, (LPWNDCLASS) &wc);
				g3d.mpctctl[ct].lpfnDefProc = wc.lpfnWndProc;
				}
			if (GetClassInfo(NULL, WC_DIALOG, &wc))
				g3d.lpfnDefDlgWndProc = (FARPROC) wc.lpfnWndProc;
			else
				g3d.lpfnDefDlgWndProc = (FARPROC) DefDlgProc;
			}
		else
			{
			g3d.f3dDialogs = fFalse;
			}
		}
Return:
	Win32Only(LeaveCriticalSection(&g_CriticalSection));
	return g3d.f3dDialogs;
    }



/*-----------------------------------------------------------------------
|   End3dDialogs
|
|       Called at DLL termination to free 3d dialog stuff
-----------------------------------------------------------------------*/
PRIVATE VOID End3dDialogs(VOID)
	{
	int ct;

	Win32Only(EnterCriticalSection(&g_CriticalSection));

	for (ct = 0; ct < ctMax; ct++)
		{											   
		if(g3d.mpctctl[ct].lpfn != NULL)
			{
			FreeProcInstance(g3d.mpctctl[ct].lpfn);
			g3d.mpctctl[ct].lpfn = NULL;
			}
		}
	DeleteObjects();
	g3d.aCtl3dOld ? GlobalDeleteAtom(g3d.aCtl3dOld) : 0;
	g3d.aCtl3d ? GlobalDeleteAtom(g3d.aCtl3d) : 0;
	g3d.aCtl3dLowOld ? GlobalDeleteAtom(g3d.aCtl3dLowOld) : 0;
	g3d.aCtl3dHighOld ? GlobalDeleteAtom(g3d.aCtl3dHighOld) : 0;
	g3d.aCtl3dLow ? GlobalDeleteAtom(g3d.aCtl3dLow) : 0;
	g3d.aCtl3dHigh ? GlobalDeleteAtom(g3d.aCtl3dHigh) : 0;
	g3d.aCtl3dDisable ? GlobalDeleteAtom(g3d.aCtl3dDisable) : 0;

	g3d.f3dDialogs = fFalse;

	Win32Only(LeaveCriticalSection(&g_CriticalSection));

	}


PRIVATE BOOL InternalCtl3dColorChange(BOOL fForce)
	{
	ICV icv;
	CLRT clrtNew;
	HBITMAP hbmpCheckboxesNew;
	BRT brtNew;

	if (!g3d.f3dDialogs)
		return fFalse;

	for (icv = 0; icv < icvMax; icv++)
		clrtNew.rgcv[icv] = GetSysColor(mpicvSysColor[icv]);

	if (g3d.verWindows == ver30)
		clrtNew.rgcv[icvBtnHilite] = RGB(0xff, 0xff, 0xff);

	if (clrtNew.rgcv[icvGrayText] == 0L || clrtNew.rgcv[icvGrayText] == clrtNew.rgcv[icvBtnFace])
		{
		if (clrtNew.rgcv[icvBtnFace] == RGB(0x80, 0x80, 0x80))
			clrtNew.rgcv[icvGrayText] = RGB(0xc0, 0xc0, 0xc0);
		else
			clrtNew.rgcv[icvGrayText] = RGB(0x80, 0x80, 0x80);
		}

	if (fForce || MEMCMP(&g3d.clrt, &clrtNew, sizeof(CLRT)))
		{
		hbmpCheckboxesNew = LoadUIBitmap(g3d.hinstLib, MAKEINTRESOURCE(CTL3D_3DCHECK),
			clrtNew.rgcv[icvWindowText],
			clrtNew.rgcv[icvBtnFace],
			clrtNew.rgcv[icvBtnShadow],
			clrtNew.rgcv[icvBtnHilite],
			clrtNew.rgcv[icvWindow],
			clrtNew.rgcv[icvWindowFrame]);

		for (icv = 0; icv < icvBrushMax; icv++)
			brtNew.mpicvhbr[icv] = CreateSolidBrush(clrtNew.rgcv[icv]);

		for (icv = 0; icv < icvBrushMax; icv++)
			if (brtNew.mpicvhbr[icv] == NULL)
				goto OOM;

		if(hbmpCheckboxesNew != NULL)
			{
			DeleteObjects();
			g3d.brt = brtNew;
			g3d.clrt = clrtNew;
			g3d.hbmpCheckboxes = hbmpCheckboxesNew;
			return fTrue;
			}
		else
			{
OOM:
			for (icv = 0; icv < icvBrushMax; icv++)
				DeleteObjectNull(&brtNew.mpicvhbr[icv]);
			DeleteObjectNull(&hbmpCheckboxesNew);
			return fFalse;
			}
		}
	return fTrue;
	}


/*-----------------------------------------------------------------------
|   Ctl3dDlgProc
|   
|       Subclass DlgProc for use w/ Ctl3dAutoSubclass
|   
|   
|   Arguments:
|       HWND hwnd:  
|       int wm: 
|       WORD wParam:    
|       LPARAM lParam:  
|       
|   Returns:
|       
-----------------------------------------------------------------------*/
LRESULT __export _loadds WINAPI Ctl3dDlgProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
	{
	HBRUSH hbrush;
	FARPROC lpfnDlgProc;
	TCHAR szClass[cchClassMax];

	if ( wm == WM_NCDESTROY )
	return CleanupSubclass(hwnd, wm, wParam, lParam, ctMax);

	if ( GetProp(hwnd,(LPCTSTR) g3d.aCtl3dDisable) )
	return CallWindowProc(LpfnGetDefWndProc(hwnd, ctMax), hwnd, wm, wParam, lParam);

	switch (wm)
		{
	case WM_CHECKSUBCLASS_OLD:
	case WM_CHECKSUBCLASS:
		*(int FAR *)lParam = fTrue;
		return ctMax+1000;

	case WM_INITDIALOG:
	  {
		long l;
		BOOL fSubclass;
		FARPROC lpfnWinProc;

		lpfnWinProc = LpfnGetDefWndProc(hwnd, ctMax);

		if (g3d.verWindows >= ver40 && (GetWindowLong(hwnd, GWL_STYLE) & 0x04))
			fSubclass = fFalse;
		else
			fSubclass = fTrue;
		SendMessage(hwnd, WM_DLGSUBCLASS, 0, (LPARAM)(int FAR *)&fSubclass);

		if (!fSubclass)
			{
			Ctl3dUnsubclassCtl(hwnd);
			return CallWindowProc(lpfnWinProc, hwnd, wm, wParam, lParam);
			}

		l = CallWindowProc(lpfnWinProc, hwnd, wm, wParam, lParam);

		if (g3d.verWindows < ver40 || !(GetWindowLong(hwnd, GWL_STYLE) & 0x04))
			Ctl3dCheckSubclassDlg(hwnd, CTL3D_ALL);

		return l;
	  }

    case WM_NCPAINT:
	case WM_NCACTIVATE:
    case WM_SETTEXT:
		if (g3d.verWindows >= ver40 || IsIconic(hwnd) )
			return CallWindowProc(LpfnGetDefWndProc(hwnd, ctMax), hwnd, wm, wParam, lParam);
		else
			return Ctl3dDlgFramePaintI(hwnd, wm, wParam, lParam, FALSE);

#ifdef WIN32
	case WM_CTLCOLORSCROLLBAR:
	case WM_CTLCOLORBTN:
	case WM_CTLCOLORDLG:
	case WM_CTLCOLOREDIT:
	case WM_CTLCOLORLISTBOX:
	case WM_CTLCOLORMSGBOX:
	case WM_CTLCOLORSTATIC:
#else
	case WM_CTLCOLOR:
#endif
	// Is this really a dialog
	GetClassName(hwnd, szClass, sizeof(szClass)Win32Only(/sizeof(TCHAR)));
	if (lstrcmp(TEXT("#32770"),szClass) != 0 )
	   {
#ifdef WIN32
		  hbrush = (HBRUSH) CallWindowProc(LpfnGetDefWndProc(hwnd, ctMax), hwnd,
						   wm-WM_CTLCOLORMSGBOX+CTLMSGOFFSET, wParam, lParam);
#else
		  hbrush = (HBRUSH) CallWindowProc(LpfnGetDefWndProc(hwnd, ctMax), hwnd,
						   CTL3D_CTLCOLOR, wParam, lParam);
#endif
		  if (hbrush == (HBRUSH) fFalse || hbrush == (HBRUSH)1)
			hbrush = Ctl3dCtlColorEx(wm, wParam, lParam);
	   }
	else
	 {
		lpfnDlgProc = (FARPROC) GetWindowLong(hwnd, DWL_DLGPROC);

		if (lpfnDlgProc == NULL )
			{
			hbrush = Ctl3dCtlColorEx(wm, wParam, lParam);
			}
		else
			{
#ifdef WIN32
			if ( (LONG)lpfnDlgProc > 0xFFFF0000 && g3d.verWindows <= ver31)
				{
				// We have a Uni-code / non Unicode issue.
				// If this is before Daytona, then I CAN NOT call because it may be NULL, but
				// the returned value is not-null. NT Bug.
				// So Just send our own message to the window proc instead
				hbrush = (HBRUSH) CallWindowProc(LpfnGetDefWndProc(hwnd, ctMax), hwnd,
												wm-WM_CTLCOLORMSGBOX+CTLMSGOFFSET, wParam, lParam);
				if (hbrush == (HBRUSH) fFalse || hbrush == (HBRUSH)1)
					hbrush = Ctl3dCtlColorEx(wm, wParam, lParam);
				}
			else
				{
#endif
				hbrush = (HBRUSH) CallWindowProc(lpfnDlgProc, hwnd, wm, wParam, lParam);
				if (hbrush == (HBRUSH) fFalse || hbrush == (HBRUSH)1)
					{
#ifdef WIN32
					hbrush = (HBRUSH) CallWindowProc(LpfnGetDefWndProc(hwnd, ctMax), hwnd,
												wm-WM_CTLCOLORMSGBOX+CTLMSGOFFSET, wParam, lParam);
#else
					hbrush = (HBRUSH) CallWindowProc(LpfnGetDefWndProc(hwnd, ctMax), hwnd,
												CTL3D_CTLCOLOR, wParam, lParam);
#endif
					if (hbrush == (HBRUSH) fFalse || hbrush == (HBRUSH)1)
						hbrush = Ctl3dCtlColorEx(wm, wParam, lParam);
					}
				}
#ifdef WIN32
			}
#endif
	}
		if (hbrush != (HBRUSH) fFalse)
			return  (LRESULT)hbrush;
		break;
		}						  
	return CallWindowProc(LpfnGetDefWndProc(hwnd, ctMax), hwnd, wm, wParam, lParam);
	}

PRIVATE BOOL NEAR DoesChildNeedSubclass(HWND hwnd)
	{
		if (!LpfnGetDefWndProcNull(hwnd))
			return fFalse;
		if (g3d.verWindows >= ver40 && GetWindowLong(hwnd, GWL_STYLE) & 0x04)
			return fFalse;
		return fTrue;
	}

/*-----------------------------------------------------------------------
|   Ctl3dHook
|   
|	   CBT Hook to watch for window creation.  Automatically subclasses all
|   dialogs w/ Ctl3dDlgProc
|   
|   Arguments:
|	   int code:   
|	   WORD wParam:	
|	   LPARAM lParam:  
|	   
|   Returns:
|	   
-----------------------------------------------------------------------*/
LRESULT __export _loadds WINAPI Ctl3dHook(int code, WPARAM wParam, LPARAM lParam)
	{
	int iclihk;
	HANDLE htask;

	htask = Win32Or16((HANDLE)GetCurrentThreadId(), GetCurrentTask());
	Win32Only(EnterCriticalSection(&g_CriticalSection));
	if (htask != g3d.htaskCache)
		{
		for (iclihk = 0; iclihk < g3d.iclihkMac; iclihk++)
			{
			if (g3d.rgclihk[iclihk].htask == htask)
				{
				g3d.iclihkCache = iclihk;
				g3d.htaskCache = htask;
				break;
				}
		}
		if ( iclihk == g3d.iclihkMac )
			{
			// didn't find task in hook table.  This could be bad, but
			// returning 0L is about all we can doo.
			//
			// Actually not. The hhook isn't used anyway just set it to NULL.
			// and call the next hook..... KGM
			Win32Only(LeaveCriticalSection(&g_CriticalSection));
			return CallNextHookEx((HHOOK)0L, code, wParam, lParam);
			}
		}
	iclihk = g3d.iclihkCache;
	Win32Only(LeaveCriticalSection(&g_CriticalSection));

	if (code == HCBT_CREATEWND)
		{
		LPCREATESTRUCT lpcs;
		lpcs = ((LPCBT_CREATEWND)lParam)->lpcs;

		  if (lpcs->lpszClass == WC_DIALOG)
			{
			if (g3d.verBase == 32)
			   {
				BOOL fSubclass;
				if (g3d.verWindows >= ver40 && (GetWindowLong((HWND)wParam, GWL_STYLE) & 0x04))
					fSubclass = fFalse;
				else
					fSubclass = fTrue;
				SendMessage((HWND)wParam, WM_DLGSUBCLASS, 0, (LPARAM)(int FAR *)&fSubclass);
				if (fSubclass)
			   		SubclassWindow((HWND)wParam, (FARPROC) Ctl3dDlgProc);
			   }
			else
			   {
			   HookSubclassWindow((HWND)wParam, (FARPROC) Ctl3dDlgProc);
			   }
			goto Zing;
			}
		  if (!(g3d.rgclihk[iclihk].dwFlags & CTL3D_SUBCLASS_DYNCREATE))
			goto Zing;

		  if (DoesChildNeedSubclass(lpcs->hwndParent) ||
			 (lpcs->hwndParent && g3d.verBase != 24 &&
				DoesChildNeedSubclass(GetParent(lpcs->hwndParent))))
			{
			DoSubclassCtl((HWND)wParam, CTL3D_ALL, INCBTHOOK, lpcs->hwndParent);
			}
		}

Zing:;
	Win32Only(return CallNextHookEx(g3d.rgclihk[iclihk].hhook, code, wParam, lParam));
#ifdef DLL
	Win16Only(return (*g3d.lpfnCallNextHookEx)(g3d.rgclihk[iclihk].hhook, code, wParam, lParam));
#else
	Win16Only(return (CallNextHookEx(g3d.rgclihk[iclihk].hhook, code, wParam, lParam)));
#endif
	}




/*-----------------------------------------------------------------------
|   CTL3D F* routines
|   
|   These routines determine whether or not the given control may be
|	   subclassed.  They may recursively call DoSubclassCtl in the
|	   case of multi-control controls
|
|   Returns:
|	   fTrue if can subclass the given control.
-----------------------------------------------------------------------*/


PRIVATE BOOL FBtn(HWND hwnd, LONG style, WORD grbit, WORD wCallFlags, HWND hwndParent)
	{
	if (g3d.verWindows >= ver40)
	   {
		return fFalse;
	   }
    style &= ~(BS_LEFTTEXT);
	return ( LOWORD(style) >= BS_PUSHBUTTON && LOWORD(style) <= BS_AUTORADIOBUTTON);
	}

PRIVATE BOOL FEdit(HWND hwnd, LONG style, WORD grbit, WORD wCallFlags, HWND hwndParent)
	{
	if (g3d.verWindows >= ver40 && hwndParent)
		{
		 TCHAR szClass[cchClassMax];
		 GetClassName(hwndParent, szClass, sizeof(szClass)Win32Only(/sizeof(TCHAR)));
		 if (lstrcmp(szClass, mpctcdef[ctCombo].sz) == 0 )
			return fFalse;
		 else
			return fTrue;
		}
	else
	return fTrue;
	}

PRIVATE BOOL FList(HWND hwnd, LONG style, WORD grbit, WORD wCallFlags, HWND hwndParent)
	{
	if (g3d.verWindows >= ver40 && hwndParent)
		{
		 TCHAR szClass[cchClassMax];
		 GetClassName(hwndParent, szClass, sizeof(szClass)Win32Only(/sizeof(TCHAR)));
		 if (lstrcmp(szClass, mpctcdef[ctCombo].sz) == 0 )
			return fFalse;
		 else
			return fTrue;
		}
	else
	   return fTrue;
	}

PRIVATE BOOL FComboList(HWND hwnd, LONG style, WORD grbit, WORD wCallFlags, HWND hwndParent)
	{

	if (g3d.verWindows >= ver40)
	   return fFalse;

	if ( wCallFlags == INCBTHOOK )
		{
		LONG style;
		style = GetWindowLong(hwndParent, GWL_STYLE);
		if (!(((style & 0x0003) == CBS_DROPDOWN) || ((style & 0x0003) == CBS_DROPDOWNLIST)))
			return fTrue;
		else
			return fFalse;
		}

	return fTrue;
	}

PRIVATE BOOL FCombo(HWND hwnd, LONG style, WORD grbit, WORD wCallFlags, HWND hwndParent)
	{
	HWND hwndEdit;
	HWND hwndList;

	if (g3d.verWindows >= ver40)
	   return fFalse;

	if ((style & 0x0003) == CBS_DROPDOWN)
		{
		if ( wCallFlags == INCBTHOOK )
			{
			return fFalse;
			}
		// Subclass edit so bottom border of the edit draws properly...This case
		// is specially handled in ListEditPaint3d
		hwndEdit = GetWindow(hwnd, GW_CHILD);
		if (hwndEdit != NULL)
			DoSubclassCtl(hwndEdit, CTL3D_EDITS, wCallFlags, hwnd);
		return fTrue;
		}
	else if ((style & 0x0003) == CBS_DROPDOWNLIST )
		{
		return fTrue;
		}
	else // assume simple // if ((style & 0x0003) == CBS_SIMPLE)
		{
		if ( wCallFlags == INCBTHOOK )
			{
				return fTrue;
			}
		hwndList = GetWindow(hwnd, GW_CHILD);
		if (hwndList != NULL)
			{
			// Subclass list & edit box so they draw properly.  We also
			// subclass the combo so we can hide/show/move it and the
			// 3d effects outside the client area get erased
			DoSubclassCtl(hwndList, CTL3D_LISTBOXES, wCallFlags, hwnd);

			hwndEdit = GetWindow(hwndList, GW_HWNDNEXT);
			if (hwndEdit != NULL)
				DoSubclassCtl(hwndEdit, CTL3D_EDITS, wCallFlags, hwnd);
			return fTrue;
			}
		return fFalse;  
		}
	}

PRIVATE BOOL FStatic(HWND hwnd, LONG style, WORD grbit, WORD wCallFlags, HWND hwndParent)
	{
	int wStyle;

	wStyle = LOWORD(style) & 0x1f;
	return (wStyle != SS_ICON &&
		((grbit & CTL3D_STATICTEXTS) && 
		(wStyle <= SS_RIGHT || wStyle == SS_LEFTNOWORDWRAP) ||
		((grbit & CTL3D_STATICFRAMES) &&
		((wStyle >= SS_BLACKRECT && wStyle <= SS_WHITEFRAME) ||
		 (g3d.verWindows < ver40 && wStyle >= 0x10 && wStyle <= 0x12)))));
	}



/*-----------------------------------------------------------------------
|   DoSubclassCtl
|   
|	   Actually subclass the control
|   
|   
|   Arguments:
|	   HWND hwnd:  
|	   WORD grbit: 
|	   WORD wCallFlags
|   Returns:
|	   
-----------------------------------------------------------------------*/
PRIVATE BOOL DoSubclassCtl(HWND hwnd, WORD grbit, WORD wCallFlags, HWND hwndParent)
	{
	LONG style;
	int ct;
	BOOL fCan;
	TCHAR szClass[cchClassMax];

	// Is this already subclassed by CTL3D?
	if (LpfnGetDefWndProcNull(hwnd) != (FARPROC) NULL)
	   return fFalse;

	GetClassName(hwnd, szClass, sizeof(szClass)Win32Only(/sizeof(TCHAR)));

	for (ct = 0; ct < ctMax; ct++)
		{
		if ((mpctcdef[ct].msk & grbit) &&
			(lstrcmp(mpctcdef[ct].sz,szClass) == 0))
			{
			style = GetWindowLong(hwnd, GWL_STYLE);
			fCan = mpctcdef[ct].lpfnFCanSubclass(hwnd, style, grbit, wCallFlags, hwndParent);
			if (fCan == fTrue)
				{
				if ( wCallFlags == INCBTHOOK && g3d.verBase == 16 )
					HookSubclassWindow(hwnd, g3d.mpctctl[ct].lpfn);
				else
					SubclassWindow(hwnd, g3d.mpctctl[ct].lpfn);
				}
			return fCan != fFalse;
			}
		}

	return fFalse;
	}



/*-----------------------------------------------------------------------
|   Inval3dCtl
|   
|	   Invalidate the controls rect in response to a WM_SHOWWINDOW or
|   WM_WINDOWPOSCHANGING message.  This is necessary because ctl3d draws
|   the 3d effects of listboxes, combos & edits outside the controls client
|   rect.
|   
|   Arguments:
|	   HWND hwnd:  
|	   WINDOWPOS FAR *lpwp:	
|	   
|   Returns:
|	   
-----------------------------------------------------------------------*/
PRIVATE VOID Inval3dCtl(HWND hwnd, WINDOWPOS FAR *lpwp)
	{
	RC rc;
	HWND hwndParent;
	LONG lStyle;
	unsigned flags;

	GetWindowRect(hwnd, (LPRECT) &rc);
	lStyle = GetWindowLong(hwnd, GWL_STYLE);
	if (lStyle & WS_VISIBLE)
		{
		if (lpwp != NULL)
			{
			flags = lpwp->flags;

			//
			// Is all this necessary ? Are we moving or sizing ?
			//
			if ( !((flags & SWP_HIDEWINDOW) || (flags & SWP_SHOWWINDOW)) &&
				(flags & SWP_NOMOVE) && (flags & SWP_NOSIZE) )
			   // Nope
			   return;

			// handle integral height listboxes (or any other control which
			// shrinks from the bottom)
			if ((flags & (SWP_NOMOVE|SWP_NOSIZE)) == SWP_NOMOVE &&
				(lpwp->cx == (rc.xRight-rc.xLeft) && lpwp->cy <= (rc.yBot-rc.yTop)))
				rc.yTop = rc.yTop+lpwp->cy+1;	   // +1 to offset InflateRect
			}
		InflateRect((LPRECT) &rc, 1, 1);
		hwndParent = GetParent(hwnd);
		ScreenToClient(hwndParent, (LPPOINT) &rc);
		ScreenToClient(hwndParent, ((LPPOINT) &rc)+1);
		if(lStyle & WS_VSCROLL)
			rc.xRight ++;
		InvalidateRect(hwndParent, (LPRECT) &rc, fFalse);
		}
	}

/*-----------------------------------------------------------------------
|	Val3dCtl
|	   
-----------------------------------------------------------------------*/
PRIVATE VOID Val3dCtl(HWND hwnd)
	{
	RC rc;
	HWND hwndParent;
	LONG lStyle;

	lStyle = GetWindowLong(hwnd, GWL_STYLE);
	GetWindowRect(hwnd, (LPRECT) &rc);
	InflateRect((LPRECT) &rc, 1, 1);
	hwndParent = GetParent(hwnd);
	ScreenToClient(hwndParent, (LPPOINT) &rc);
	ScreenToClient(hwndParent, ((LPPOINT) &rc)+1);
	if(lStyle & WS_VSCROLL)
		rc.xRight ++;
	ValidateRect(hwndParent, (LPRECT) &rc);
	}

/*-----------------------------------------------------------------------
|   CTL3D Subclass Wndprocs
-----------------------------------------------------------------------*/

/* These values are assumed for bit shifting operations */
#define BFCHECK	 0x0003
#define BFSTATE	 0x0004
#define BFFOCUS	 0x0008
#define BFINCLICK   0x0010  /* Inside click code */
#define BFCAPTURED  0x0020  /* We have mouse capture */
#define BFMOUSE	 0x0040  /* Mouse-initiated */
#define BFDONTCLICK 0x0080  /* Don't check on get focus */

#define bpText  0x0002
#define bpCheck 0x0004
#define bpFocus 0x0008  // must be same as BFFOCUS
#define bpBkgnd 0x0010
#define bpEraseGroupText 0x0020

PRIVATE VOID DrawPushButton(HWND hwnd, HDC hdc, RC FAR *lprc, LPTSTR lpch, int cch, WORD bs, BOOL fDown)
	{
	// int dxyBrdr;
	int dxyShadow;
	HBRUSH hbrSav;
	RC rcInside;
	rcInside = *lprc;

//	if (!(grbitStyle & bitFCoolButtons))
		{
		DrawRec3d(hdc, lprc, icvWindowFrame, icvWindowFrame, dr3All);
		InflateRect((LPRECT) &rcInside, -1, -1);
		if (bs == LOWORD(BS_DEFPUSHBUTTON) && IsWindowEnabled(hwnd))
			{
			// dxyBrdr = 2;
			DrawRec3d(hdc, &rcInside, icvWindowFrame, icvWindowFrame, dr3All);
			InflateRect((LPRECT) &rcInside, -1, -1);
			}
		// else
			// dxyBrdr = 1;

		// Notch the corners
		PatBlt(hdc, lprc->xLeft, lprc->yTop, dxBorder, dyBorder, PATCOPY);
		/* Top xRight corner */
		PatBlt(hdc, lprc->xRight - dxBorder, lprc->yTop, dxBorder, dyBorder, PATCOPY);
		/* yBot xLeft corner */
		PatBlt(hdc, lprc->xLeft, lprc->yBot - dyBorder, dxBorder, dyBorder, PATCOPY);
		/* yBot xRight corner */
		PatBlt(hdc, lprc->xRight - dxBorder, lprc->yBot - dyBorder, dxBorder, dyBorder, PATCOPY);
		dxyShadow = 1 + !fDown;
		}
//	else
//		dxyShadow = 1;

	// draw upper left hilite/shadow

	if (fDown)
		hbrSav = SelectObject(hdc, g3d.brt.mpicvhbr[icvBtnShadow]);
	else
		hbrSav = SelectObject(hdc, g3d.brt.mpicvhbr[icvBtnHilite]);

	PatBlt(hdc, rcInside.xLeft, rcInside.yTop, dxyShadow,
		(rcInside.yBot - rcInside.yTop), PATCOPY);
	PatBlt(hdc, rcInside.xLeft, rcInside.yTop,
		(rcInside.xRight - rcInside.xLeft), dxyShadow, PATCOPY);

	// draw lower right shadow (only if not down)
	if (!fDown) // || (grbitStyle & bitFCoolButtons))
		{
		int i;

		if (fDown)
			SelectObject(hdc, g3d.brt.mpicvhbr[icvBtnHilite]);
		else
			SelectObject(hdc, g3d.brt.mpicvhbr[icvBtnShadow]);

		rcInside.yBot--;
		rcInside.xRight--;

		for (i = 0; i < dxyShadow; i++)
			{
		 PatBlt(hdc, rcInside.xLeft, rcInside.yBot,
				rcInside.xRight - rcInside.xLeft + dxBorder, dyBorder, 
				PATCOPY);
			PatBlt(hdc, rcInside.xRight, rcInside.yTop, dxBorder,
				rcInside.yBot - rcInside.yTop, PATCOPY);
			if (i < dxyShadow-1)
				InflateRect((LPRECT) &rcInside, -dxBorder, -dyBorder);
			}
		}
	// draw the button face

	rcInside.xLeft++;
	rcInside.yTop++;

	SelectObject(hdc, g3d.brt.mpicvhbr[icvBtnFace]);
	PatBlt(hdc, rcInside.xLeft, rcInside.yTop, rcInside.xRight-rcInside.xLeft,
		rcInside.yBot - rcInside.yTop, PATCOPY);

	// Draw the durned text

	if(!IsWindowEnabled(hwnd))
		SetTextColor(hdc, g3d.clrt.rgcv[icvGrayText]);
	
	{
	int dy;
	int dx;

	MyGetTextExtent(hdc, lpch, &dx, &dy);
	rcInside.yTop += (rcInside.yBot-rcInside.yTop-dy)/2;
	rcInside.xLeft += (rcInside.xRight-rcInside.xLeft-dx)/2;
	rcInside.yBot = min(rcInside.yTop+dy, rcInside.yBot);
	rcInside.xRight = min(rcInside.xLeft+dx, rcInside.xRight);
	}

	if (fDown)
		{
		OffsetRect((LPRECT) &rcInside, 1, 1);
		rcInside.xRight = min(rcInside.xRight, lprc->xRight-3);
		rcInside.yBot = min(rcInside.yBot, lprc->yBot-3);
		}

	DrawText(hdc, lpch, cch, (LPRECT) &rcInside, DT_LEFT|DT_SINGLELINE);
	
	if (hwnd == GetFocus())
		{
		InflateRect((LPRECT) &rcInside, 1, 1);
		IntersectRect((LPRECT) &rcInside, (LPRECT) &rcInside, (LPRECT) lprc);
		DrawFocusRect(hdc, (LPRECT) &rcInside);
		}

	if (hbrSav)
		SelectObject(hdc, hbrSav);
	}


/*-----------------------------------------------------------------------
|   BtnPaint
|   
|	   Paint a button
|   
|   Arguments:
|	   HWND hwnd:  
|	   HDC hdc:	
|	   int bp: 
|	   
|   Returns:
|	   
-----------------------------------------------------------------------*/
PRIVATE VOID BtnPaint(HWND hwnd, HDC hdc, int bp)
	{
	RC rc;
	RC rcClient;
	HFONT hfont;
	int bs;
	int bf;
	HBRUSH hbrBtn;
	HWND hwndParent;
	int xBtnBmp;
	int yBtnBmp;
	HBITMAP hbmpSav;
	HDC hdcMem;
	TCHAR szTitle[256];
	int cch;
	BOOL fEnabled;
    BOOL fLeftText;

	bs = (int) GetWindowLong(hwnd, GWL_STYLE);
    fLeftText = (bs & Win32Or16(0x00000020, 0x0020));
	bs &= Win32Or16(0x0000001F, 0x001F);
	hwndParent = GetParent(hwnd);
	SetBkMode(hdc, OPAQUE);
	GetClientRect(hwnd, (LPRECT)&rcClient);
	rc = rcClient;
	if((hfont = (HFONT)SendMessage(hwnd, WM_GETFONT, 0, 0L)) != NULL)
		hfont = SelectObject(hdc, hfont);

	SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));
	SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));
	hbrBtn = SEND_COLOR_BUTTON_MESSAGE(hwndParent, hwnd, hdc);
	hbrBtn = SelectObject(hdc, hbrBtn);
	IntersectClipRect(hdc, rc.xLeft, rc.yTop, rc.xRight, rc.yBot);
	if(bp & bpBkgnd && (bs != BS_GROUPBOX))
		PatBlt(hdc, rc.xLeft, rc.yTop, rc.xRight-rc.xLeft, rc.yBot-rc.yTop, PATCOPY);

	fEnabled = IsWindowEnabled(hwnd);
	bf = (int) SendMessage(hwnd, BM_GETSTATE, 0, 0L);
	yBtnBmp = 0;
	xBtnBmp = (((bf&BFCHECK) != 0) | ((bf&BFSTATE) >> 1)) * 14;
	if (!fEnabled)
		xBtnBmp += 14*(2+((bf&BFCHECK) != 0));
	if(bp & (bpText|bpFocus) || 
			bs == BS_PUSHBUTTON || bs == BS_DEFPUSHBUTTON)
		cch = GetWindowText(hwnd, szTitle, sizeof(szTitle)Win32Only(/sizeof(TCHAR)));
	switch(bs)
		{
#ifdef DEBUG
		default:
			Assert(fFalse);
			break;
#endif
		case BS_PUSHBUTTON:
		case BS_DEFPUSHBUTTON:
			DrawPushButton(hwnd, hdc, &rcClient, szTitle, cch, LOWORD(bs), bf & BFSTATE);
			break;

		case BS_RADIOBUTTON:
		case BS_AUTORADIOBUTTON:
			yBtnBmp = 13;
			goto DrawBtn;
		case BS_3STATE:
		case BS_AUTO3STATE:
			Assert((BFSTATE >> 1) == 2);
			if((bf & BFCHECK) == 2)
				yBtnBmp = 26;
			// fall through
		case BS_CHECKBOX:
		case BS_AUTOCHECKBOX:
DrawBtn:
			if(bp & bpCheck)
				{
				hdcMem = CreateCompatibleDC(hdc);
				if(hdcMem != NULL)
					{
					hbmpSav = SelectObject(hdcMem, g3d.hbmpCheckboxes);
					if(hbmpSav != NULL)
						{
                        if (fLeftText)
						    BitBlt(hdc, rc.xRight - 14, rc.yTop+(rc.yBot-rc.yTop-13)/2,
						    	14, 13, hdcMem, xBtnBmp, yBtnBmp, SRCCOPY);
                        else
						    BitBlt(hdc, rc.xLeft, rc.yTop+(rc.yBot-rc.yTop-13)/2,
						    	14, 13, hdcMem, xBtnBmp, yBtnBmp, SRCCOPY);
				    	SelectObject(hdcMem, hbmpSav);
						}
					DeleteDC(hdcMem);
					}
				}
			if(bp & bpText)
				{
				// BUG! this assumes we have only 1 hbm3dCheck type
                if (fLeftText)
                    rc.xRight = rcClient.xRight - (14+4);
                else
				    rc.xLeft = rcClient.xLeft + 14+4;
				if(!fEnabled)
					SetTextColor(hdc, g3d.clrt.rgcv[icvGrayText]);
				DrawText(hdc, szTitle, cch, (LPRECT) &rc, DT_VCENTER|DT_LEFT|DT_SINGLELINE);
				}
			if(bp & bpFocus)
				{
				int dx;
				int dy;

				MyGetTextExtent(hdc, szTitle, &dx, &dy);
				rc.yTop = (rc.yBot-rc.yTop-dy)/2;
				rc.yBot = rc.yTop+dy;
				rc.xLeft = rcClient.xLeft;
				if (fLeftText)
                {
				    rc.xLeft = rcClient.xLeft;
                    rcClient.xRight -= (14+4);
                }
                else
    				rc.xLeft = rcClient.xLeft + (14+4);
				rc.xRight = rc.xLeft + dx;
				InflateRect((LPRECT) &rc, 1, 1);
				IntersectRect((LPRECT) &rc, (LPRECT) &rc, (LPRECT) &rcClient);
				DrawFocusRect(hdc, (LPRECT) &rc);
				}
			break;
		case BS_GROUPBOX:
			if(bp & (bpText|bpCheck))
				{
				int dy;
				int dx;

				MyGetTextExtent(hdc, szTitle, &dx, &dy);
				if (dy == 0)
					{
					int dxT;
					MyGetTextExtent(hdc, TEXT("X"), &dxT, &dy);
					}
					
				rc.xLeft += 4;
				rc.xRight = rc.xLeft + dx + 4;
				rc.yBot = rc.yTop + dy;

				if (bp & bpEraseGroupText)
					{
					RC rcT;

					rcT = rc;
					rcT.xRight = rcClient.xRight;
					// Hack!
					ClientToScreen(hwnd, (LPPOINT) &rcT);
					ClientToScreen(hwnd, ((LPPOINT) &rcT)+1);
					ScreenToClient(hwndParent, (LPPOINT) &rcT);
					ScreenToClient(hwndParent, ((LPPOINT) &rcT)+1);
					InvalidateRect(hwndParent, (LPRECT) &rcT, fTrue);
					return;
					}

				rcClient.yTop += dy/2;
				rcClient.xRight--;
				rcClient.yBot--;
				DrawRec3d(hdc, &rcClient, icvBtnShadow, icvBtnShadow, dr3All);
				OffsetRect((LPRECT) &rcClient, 1, 1);
				DrawRec3d(hdc, &rcClient, icvBtnHilite, icvBtnHilite, dr3All);

				if(!fEnabled)
					SetTextColor(hdc, g3d.clrt.rgcv[icvGrayText]);
				DrawText(hdc, szTitle, cch, (LPRECT) &rc, DT_LEFT|DT_SINGLELINE);
				}
			break;
		}

	SelectObject(hdc, hbrBtn);
	if(hfont != NULL)
		SelectObject(hdc, hfont);
	}

LRESULT __export _loadds WINAPI BtnWndProc3d(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
	{
	LONG lRet;
	LONG lStyle;
	PAINTSTRUCT ps;
	HDC hdc;
	int bf;
	int bfNew;
	int bp;

	if ( wm == WM_NCDESTROY )
	return CleanupSubclass(hwnd, wm, wParam, lParam, ctButton);

	if ( GetProp(hwnd,(LPCTSTR) g3d.aCtl3dDisable) )
	return CallWindowProc(LpfnGetDefWndProc(hwnd, ctButton), hwnd, wm, wParam, lParam);

	switch(wm)
		{
	case WM_CHECKSUBCLASS_OLD:
	case WM_CHECKSUBCLASS:
		*(int FAR *)lParam = fTrue;
		return ctButton+1000;

	case WM_SETTEXT:
		lStyle = GetWindowLong(hwnd, GWL_STYLE);
		if ((lStyle & WS_VISIBLE) && (LOWORD(lStyle) & 0x1f) == BS_GROUPBOX)
			{
			// total hack -- if group box text length shortens then
			// we have to erase the old text.  BtnPaint will Invalidate
			// the rect of the text so everything will redraw.
			bp = bpText | bpEraseGroupText;
			}
		else
			{
			bp = bpText|bpCheck|bpBkgnd;
			}
		goto DoIt;

	case BM_SETSTATE:
	case BM_SETCHECK:
		bp = bpCheck;
		goto DoIt;
	case WM_KILLFOCUS:
		// HACK! Windows will go into an infinite loop trying to sync the
		// states of the AUTO_RADIOBUTTON in this group.  (we turn off the
		// visible bit so it gets skipped in the enumeration)
		// Disable this code by clearing the STATE bit
		if ((LOWORD(GetWindowLong(hwnd, GWL_STYLE)) & 0x1F) == BS_AUTORADIOBUTTON)
			SendMessage(hwnd, BM_SETSTATE, 0, 0L);
		bp = 0;
		goto DoIt;
	case WM_ENABLE:
		bp = bpCheck | bpText;
		goto DoIt;
	case WM_SETFOCUS:
		// HACK! if wParam == NULL we may be activated via the task manager
		// Erase background of control because a WM_ERASEBKGND messsage has not
		// arrived yet for the dialog
		// bp = wParam == (WPARAM)NULL ? (bpCheck | bpText | bpBkgnd) : (bpCheck | bpText);
		bp = bpCheck | bpText | bpBkgnd;
DoIt:
        bf = (int) SendMessage(hwnd, BM_GETSTATE, 0, 0L);
        if((lStyle = GetWindowLong(hwnd, GWL_STYLE)) & WS_VISIBLE)
			{
			if ( wm != WM_SETFOCUS )
			   SetWindowLong(hwnd, GWL_STYLE, lStyle & ~(WS_VISIBLE));
            lRet = CallWindowProc(LpfnGetDefWndProc(hwnd, ctButton), hwnd, wm, wParam, lParam);

			if ( wm != WM_SETFOCUS )
			   SetWindowLong(hwnd, GWL_STYLE, GetWindowLong(hwnd, GWL_STYLE)|WS_VISIBLE);
			bfNew = (int) SendMessage(hwnd, BM_GETSTATE, 0, 0L);
			if((wm != BM_SETSTATE && wm != BM_SETCHECK) ||
				bf != bfNew)
				{
				hdc = GetDC(hwnd);
				if (hdc != NULL)
					{
					Assert(BFFOCUS == bpFocus);
					/* If the check state changed, redraw no matter what,
						because it won't have during the above call to the def
						wnd proc */
					if ((bf & BFCHECK) != (bfNew & BFCHECK))
						bp |= bpCheck;
					ExcludeUpdateRgn(hdc, hwnd);
					BtnPaint(hwnd, hdc, bp|((bf^bfNew)&BFFOCUS));
					ReleaseDC(hwnd, hdc);
					}
				}
			return lRet;
			}
		break;
	case WM_PAINT:
		bf = (int) SendMessage(hwnd, BM_GETSTATE, 0, 0L);
		if ((hdc = (HDC) wParam) == NULL)
			hdc = BeginPaint(hwnd, &ps);
		if(GetWindowLong(hwnd, GWL_STYLE) & WS_VISIBLE)
			BtnPaint(hwnd, hdc, bpText|bpCheck|(bf&BFFOCUS));
		if (wParam == (WPARAM)NULL)
			EndPaint(hwnd, &ps);
		return 0L;
		}
    return CallWindowProc(LpfnGetDefWndProc(hwnd, ctButton), hwnd, wm, wParam, lParam);
	}


void ListEditPaint3d(HWND hwnd, BOOL fEdit, int ct)
	{
	CTLID id;
	RC rc;
	HDC hdc;
	HWND hwndParent;
	LONG lStyle;
	DR3 dr3;

	if(!((lStyle = GetWindowLong(hwnd, GWL_STYLE)) & WS_VISIBLE))
		return;

	if ((ct == ctCombo && (lStyle & 0x003) == CBS_DROPDOWNLIST))
		{
		if ( SendMessage(hwnd, CB_GETDROPPEDSTATE,0,0L) )
			return;
		}

	if (fEdit)
		HideCaret(hwnd);

	GetWindowRect(hwnd, (LPRECT) &rc);		  

	ScreenToClient(hwndParent = GetParent(hwnd), (LPPOINT) &rc);
	ScreenToClient(hwndParent, ((LPPOINT) &rc)+1);

	hdc = GetDC(hwndParent);

	dr3 = dr3All;

	if(lStyle & WS_HSCROLL)
		dr3 = dr3 & ~dr3Bot;

	if(lStyle & WS_VSCROLL)
		dr3 = dr3 & ~dr3Right;

	// don't draw the top if it's a listbox of a simple combo
	id = GetControlId(hwnd);
	if (id == (CTLID) (1000 + fEdit))
		{
		TCHAR szClass[cchClassMax];
		BOOL fSubclass = 666;
		int ctParent;

		// could be superclassed!
		fSubclass = 666;
		ctParent = (int)SendMessage(hwndParent, WM_CHECKSUBCLASS, 0, (LPARAM)(int FAR *)&fSubclass);
		if (fSubclass == 666)
			ctParent = (int)SendMessage(hwndParent, WM_CHECKSUBCLASS_OLD, 0, (LPARAM)(int FAR *)&fSubclass);


		// could be subclassed!
		GetClassName(hwndParent, szClass, sizeof(szClass)Win32Only(/sizeof(TCHAR)));
		if (lstrcmp(szClass, mpctcdef[ctCombo].sz) == 0 ||
			(fSubclass == fTrue && ctParent == ctCombo+1000))
			{
			HWND hwndComboParent;

			hwndComboParent = GetParent(hwndParent);

			Win16Only(GetWindowRect(hwnd, (LPRECT) &rc));
			Win16Only(ScreenToClient(hwndComboParent, (LPPOINT) &rc));
			Win16Only(ScreenToClient(hwndComboParent, ((LPPOINT) &rc)+1));

			Win32Only(MapWindowPoints(hwndParent, hwndComboParent, (POINT*)&rc, 2));

			ReleaseDC(hwndParent, hdc);
			hdc = GetDC(hwndComboParent);

			if (fEdit)
				{
				RC rcList;
				HWND hwndList;
				long style;

				style = GetWindowLong(hwndParent, GWL_STYLE);
				if (!(((style & 0x0003) == CBS_DROPDOWN)
				   || ((style & 0x0003) == CBS_DROPDOWNLIST)))
					{
					dr3 &= ~dr3Bot;
			
					hwndList = GetWindow(hwndParent, GW_CHILD);
					GetWindowRect(hwndList, (LPRECT) &rcList);		  
			
					
					rc.xRight -= rcList.xRight-rcList.xLeft;
					DrawInsetRect3d(hdc, &rc, dr3Bot|dr3HackBotRight);
					rc.xRight += rcList.xRight-rcList.xLeft;		
					}
				else
					{
					//
					// Is the drop down on the parent down ? if so don't paint.
					//
					if ( SendMessage(hwndParent, CB_GETDROPPEDSTATE,0,0L) )
						{
						ReleaseDC(hwndComboParent, hdc);
						ShowCaret(hwnd);
						return;
						}
					}
				}
			else
				{
				rc.yTop++;
				dr3 &= ~dr3Top;
				}

			hwndParent = hwndComboParent;

			}
		}

	DrawInsetRect3d(hdc, &rc, dr3);

	if ((ct == ctCombo && (lStyle & 0x003) == CBS_DROPDOWNLIST))
		{
		rc.xLeft = rc.xRight - GetSystemMetrics(SM_CXVSCROLL);
		DrawRec3d(hdc, &rc, icvWindowFrame, icvWindowFrame, dr3Right|dr3Bot);
		Val3dCtl(hwnd);
		}
	else {
	if (lStyle & WS_VSCROLL)
		{
		int SaveLeft;

		rc.xRight++;
		DrawRec3d(hdc, &rc, icvBtnHilite, icvBtnHilite, dr3Right);
		rc.xRight--;
		SaveLeft = rc.xLeft;
		rc.xLeft = rc.xRight - GetSystemMetrics(SM_CXVSCROLL);
		DrawRec3d(hdc, &rc, icvWindowFrame, icvWindowFrame, dr3Bot);
		rc.xLeft = SaveLeft;
		}
	if (lStyle & WS_HSCROLL)
		{
		rc.yBot++;
		DrawRec3d(hdc, &rc, icvBtnHilite, icvBtnHilite, dr3Bot);
		rc.yBot--;
		rc.yTop = rc.yBot - GetSystemMetrics(SM_CXHSCROLL);
		DrawRec3d(hdc, &rc, icvWindowFrame, icvWindowFrame, dr3Right);
		}
	}

	ReleaseDC(hwndParent, hdc);
	if (fEdit)
		ShowCaret(hwnd);

	}


LONG ShareEditComboWndProc3d(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam, int ct)
	{
	LONG l;
	LONG style;

	if ( wm == WM_NCDESTROY )
	return CleanupSubclass(hwnd, wm, wParam, lParam, ct);

	if ( GetProp(hwnd,(LPCTSTR) g3d.aCtl3dDisable) )
	return CallWindowProc(LpfnGetDefWndProc(hwnd, ct), hwnd, wm, wParam, lParam);

	l = CallWindowProc(LpfnGetDefWndProc(hwnd,ct), hwnd, wm, wParam, lParam);
	if (ct == ctCombo)
	{
		style = GetWindowLong(hwnd, GWL_STYLE);
		if ((style & 0x0003) == CBS_DROPDOWN)
			return l;
	}

	switch(wm)
		{
	case WM_CHECKSUBCLASS_OLD:
	case WM_CHECKSUBCLASS:
		*(int FAR *)lParam = fTrue;
		return ctEdit+1000;

	case WM_SHOWWINDOW:
		if (g3d.verWindows < ver31 && wParam == 0)
			Inval3dCtl(hwnd, (WINDOWPOS FAR *) NULL);
		break;
	case WM_WINDOWPOSCHANGING:
		if (g3d.verWindows >= ver31)
			Inval3dCtl(hwnd, (WINDOWPOS FAR *) lParam);
		break;

	case WM_PAINT:
		{
		if (ct != ctCombo ||
		   (((style & 0x0003) == CBS_DROPDOWN) || ((style & 0x0003) == CBS_DROPDOWNLIST)))
			ListEditPaint3d(hwnd, TRUE, ct);
		}
		break;
		}
	return l;
	}


LRESULT __export _loadds WINAPI EditWndProc3d(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
	{
	return ShareEditComboWndProc3d(hwnd, wm, wParam, lParam, ctEdit);
	}


LONG SharedListWndProc(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam, unsigned ct)
	{
	LONG l;

	if ( wm == WM_NCDESTROY )
	return CleanupSubclass(hwnd, wm, wParam, lParam, ct);

	if ( GetProp(hwnd,(LPCTSTR) g3d.aCtl3dDisable) )
	return CallWindowProc(LpfnGetDefWndProc(hwnd, ct), hwnd, wm, wParam, lParam);

	switch(wm)
		{
	case WM_CHECKSUBCLASS_OLD:
	case WM_CHECKSUBCLASS:
		*(int FAR *)lParam = fTrue;
		return ctList+1000;

	case WM_SHOWWINDOW:
		if (g3d.verWindows < ver31 && wParam == 0)
			Inval3dCtl(hwnd, (WINDOWPOS FAR *) NULL);
		break;
	case WM_WINDOWPOSCHANGING:
		if (g3d.verWindows >= ver31)
			Inval3dCtl(hwnd, (WINDOWPOS FAR *) lParam);
		break;
	case WM_PAINT:
        l = CallWindowProc(LpfnGetDefWndProc(hwnd, ct), hwnd, wm, wParam, lParam);
        ListEditPaint3d(hwnd, FALSE, ct);
		return l;
	case WM_NCCALCSIZE:
		{
		RC rc;		   
		RC rcNew;
		HWND hwndParent;

		// Inval3dCtl handles this case under Win 3.1
		if (g3d.verWindows >= ver31)
			break;

		GetWindowRect(hwnd, (LPRECT) &rc);		  
#ifdef UNREACHABLE
		if (g3d.verWindows >= ver31)
			{
			hwndParent = GetParent(hwnd);
			ScreenToClient(hwndParent, (LPPOINT) &rc);
			ScreenToClient(hwndParent, ((LPPOINT) &rc)+1);
			}
#endif

        l = CallWindowProc(LpfnGetDefWndProc(hwnd, ct), hwnd, wm, wParam, lParam);

		rcNew = *(RC FAR *)lParam;
		InflateRect((LPRECT) &rcNew, 2, 1); // +1 for border (Should use AdjustWindowRect)
		if (rcNew.yBot < rc.yBot)
			{
			rcNew.yTop = rcNew.yBot+1;
			rcNew.yBot = rc.yBot+1;

#ifdef ALWAYS
			if (g3d.verWindows < ver31)
#endif
				{
				hwndParent = GetParent(hwnd);
				ScreenToClient(hwndParent, (LPPOINT) &rcNew);
				ScreenToClient(hwndParent, ((LPPOINT) &rcNew)+1);
				}

			InvalidateRect(hwndParent, (LPRECT) &rcNew, TRUE);
			}
		return l;
		}
		}
    return CallWindowProc(LpfnGetDefWndProc(hwnd, ct), hwnd, wm, wParam, lParam);
	}

LRESULT __export _loadds WINAPI ListWndProc3d(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
	{
	return SharedListWndProc(hwnd, wm, wParam, lParam, ctList); 
	}



LRESULT __export _loadds WINAPI ComboWndProc3d(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
	{
	switch(wm)
		{
	case WM_CHECKSUBCLASS_OLD:
	case WM_CHECKSUBCLASS:
		*(int FAR *)lParam = fTrue;
		return ctCombo+1000;
		}

	return ShareEditComboWndProc3d(hwnd, wm, wParam, lParam, ctCombo);
	}

void StaticPrint(HWND hwnd, HDC hdc, RC FAR *lprc, LONG style)
	{
	WORD dt;
	LONG cv;
	Win16Or32(HANDLE , LPTSTR )hText;
	int TextLen;

	PatBlt(hdc, lprc->xLeft, lprc->yTop, lprc->xRight-lprc->xLeft, lprc->yBot-lprc->yTop, PATCOPY);

	TextLen = GetWindowTextLength(hwnd);

#ifndef WIN32
	hText = LocalAlloc(LPTR|LMEM_NODISCARD,(TextLen+5)*sizeof(TCHAR));
#else
	hText = _alloca((TextLen+5)*sizeof(TCHAR));
#endif
	if (hText == NULL)
		return;

	if (GetWindowText(hwnd, (NPTSTR)hText, TextLen+2*sizeof(TCHAR)) == 0)
	{
#ifndef WIN32
		LocalFree(hText);
#endif
		return;
	}
	
	if ((style & 0x000f) == SS_LEFTNOWORDWRAP)
		dt = DT_NOCLIP | DT_EXPANDTABS;
	else
		{
		dt = LOWORD(DT_NOCLIP | DT_EXPANDTABS | DT_WORDBREAK | ((style & 0x0000000f)-SS_LEFT));
		}

	if (style & SS_NOPREFIX)
		dt |= DT_NOPREFIX;

	if (style & WS_DISABLED)
		cv = SetTextColor(hdc, g3d.clrt.rgcv[icvGrayText]);

	DrawText(hdc, (NPTSTR)hText, -1, (LPRECT) lprc, dt);

#ifndef WIN32
	LocalFree(hText);
#endif

	if (style & WS_DISABLED)
		cv = SetTextColor(hdc, cv);
	}

void StaticPaint(HWND hwnd, HDC hdc)
	{
	LONG style;
	RC rc;

	style = GetWindowLong(hwnd, GWL_STYLE);
	if(!(style & WS_VISIBLE))
		return;

	GetClientRect(hwnd, (LPRECT) &rc);
	switch(style & 0x1f)
		{
	case SS_BLACKRECT:
	case SS_BLACKFRAME:	 // Inset rect
		DrawRec3d(hdc, &rc, icvBtnShadow, icvBtnHilite, dr3All);
		break;
	case SS_GRAYRECT:
	case SS_GRAYFRAME:
	case 0x10:
	case 0x11:
	case 0x12:
		rc.xLeft++;
		rc.yTop++;
		DrawRec3d(hdc, &rc, icvBtnHilite, icvBtnHilite, dr3All);
		OffsetRect((LPRECT) &rc, -1, -1);
		DrawRec3d(hdc, &rc, icvBtnShadow, icvBtnShadow, dr3All);
		break;
	case SS_WHITERECT:			  // outset rect
	case SS_WHITEFRAME:
		DrawRec3d(hdc, &rc, icvBtnHilite, icvBtnShadow, dr3All);
		break;
	case SS_LEFT:
	case SS_CENTER:
	case SS_RIGHT:
	case SS_LEFTNOWORDWRAP:
		{
		HANDLE hfont;
		HBRUSH hbr;

		if((hfont = (HANDLE)SendMessage(hwnd, WM_GETFONT, 0, 0L)) != NULL)
			hfont = SelectObject(hdc, hfont);
		SetBkMode(hdc, OPAQUE);

		if(( hbr = SEND_COLOR_STATIC_MESSAGE(GetParent(hwnd), hwnd, hdc)) != NULL)
			hbr = SelectObject(hdc, hbr);

		StaticPrint(hwnd, hdc, (RC FAR *)&rc, style);

		if (hfont != NULL)
			SelectObject(hdc, hfont);

		if (hbr != NULL)
			SelectObject(hdc, hbr);
		}
		break;
		}
	}


LRESULT __export _loadds WINAPI StaticWndProc3d(HWND hwnd, UINT wm, WPARAM wParam, LPARAM lParam)
	{
	HDC hdc;
	PAINTSTRUCT ps;

	if ( wm == WM_NCDESTROY )
	return CleanupSubclass(hwnd, wm, wParam, lParam, ctStatic);

	if ( GetProp(hwnd,(LPCTSTR) g3d.aCtl3dDisable) )
	return CallWindowProc(LpfnGetDefWndProc(hwnd, ctStatic), hwnd, wm, wParam, lParam);

	switch (wm)
		{
	case WM_CHECKSUBCLASS_OLD:
	case WM_CHECKSUBCLASS:
		*(int FAR *)lParam = fTrue;
		return ctStatic+1000;

	case WM_PAINT:
		if ((hdc = (HDC) wParam) == NULL)
			{
			hdc = BeginPaint(hwnd, &ps);
			ClipCtlDc(hwnd, hdc);
			}
		StaticPaint(hwnd, hdc);
		if (wParam == (WPARAM)NULL)
			EndPaint(hwnd, &ps);
		return 0L;
		
	case WM_ENABLE:
		hdc = GetDC(hwnd);
		ClipCtlDc(hwnd, hdc);
		StaticPaint(hwnd, hdc);
		ReleaseDC(hwnd, hdc);
		return 0L;
		}
    return CallWindowProc(LpfnGetDefWndProc(hwnd, ctStatic), hwnd, wm, wParam, lParam);
	}


/*-----------------------------------------------------------------------
|   LibMain
-----------------------------------------------------------------------*/
#ifdef WIN32
#ifdef DLL
BOOL CALLBACK LibMain(HANDLE hModule, DWORD dwReason, LPVOID lpReserved)
#else
#ifdef SDLL
BOOL FAR Ctl3dLibMain(HANDLE hModule, DWORD dwReason, LPVOID lpReserved)
#else
BOOL FAR LibMain(HANDLE hModule, DWORD dwReason, LPVOID lpReserved)
#endif
#endif
	{
	WORD wT;
	DWORD dwVersion;
	BOOL (WINAPI* pfnDisableThreadLibraryCalls)(HMODULE);
	HMODULE hKernel;

	switch(dwReason)
		{
	case DLL_PROCESS_ATTACH:
		// call DisableThreadLibraryCalls if available
		hKernel = GetModuleHandleA("KERNEL32.DLL");
		*(FARPROC*)&pfnDisableThreadLibraryCalls =
			GetProcAddress(hKernel, "DisableThreadLibraryCalls");
		if (pfnDisableThreadLibraryCalls != NULL)
			(*pfnDisableThreadLibraryCalls)(hModule);

#ifdef DLL
		InitializeCriticalSection(&g_CriticalSection);
#endif
		EnterCriticalSection(&g_CriticalSection);
#ifdef SDLL
		g3d.hinstLib = g3d.hmodLib = _hModule;
#else
		g3d.hinstLib = g3d.hmodLib = hModule;
#endif

		dwVersion = (DWORD)GetVersion();
		wT = LOWORD(dwVersion);
		// get adjusted windows version
		g3d.verWindows = (LOBYTE(wT) << 8) | HIBYTE(wT);
		// Win32s or Win32 for real (Chicago reports Win32s)
		g3d.verBase =
			(dwVersion & 0x80000000) && g3d.verWindows < ver40 ? 16 : 32;

		g3d.dxFrame = GetSystemMetrics(SM_CXDLGFRAME)-dxBorder;
		g3d.dyFrame = GetSystemMetrics(SM_CYDLGFRAME)-dyBorder;
		g3d.dyCaption = GetSystemMetrics(SM_CYCAPTION);
		g3d.dxSysMenu = GetSystemMetrics(SM_CXSIZE);

		LeaveCriticalSection(&g_CriticalSection);
		}
	return  TRUE;
	}
#else
#ifdef DLL
int WINAPI LibMain(HANDLE hModule, WORD wDataSeg, WORD cbHeapSize, LPSTR lpszCmdLine)
#else
#ifdef SDLL
int FAR Ctl3dLibMain(HANDLE hModule, WORD wDataSeg, WORD cbHeapSize, LPSTR lpszCmdLine)
#else
#ifdef _BORLAND
BOOL FAR PASCAL LibMain(HANDLE hModule, WORD wDataSeg, WORD cbHeapSize, LPSTR lpszCmdLine)
#else
BOOL FAR LibMain(HANDLE hModule, WORD wDataSeg, WORD cbHeapSize, LPSTR lpszCmdLine)
#endif
#endif
#endif
	{
	WORD wT;
#ifdef DLL

#ifdef V2
	CodeLpszDeclA(lpszCtl3d, "CTL3DV2");
#else
	CodeLpszDeclA(lpszCtl3d, "CTL3D");
#endif

	CodeLpszDeclA(lpszUser, "user.exe");
	CodeLpszDeclA(lpszSetWindowsHookEx, "SETWINDOWSHOOKEX");
	CodeLpszDeclA(lpszUnhookWindowsHookEx, "UNHOOKWINDOWSHOOKEX");
	CodeLpszDeclA(lpszCallNextHookEx, "CALLNEXTHOOKEX");
#endif

	g3d.hinstLib = hModule;
#ifdef DLL
	g3d.hmodLib = GetModuleHandle(lpszCtl3d);
#else
#ifdef SDLL
	g3d.hinstLib = _hModule;
	g3d.hmodLib = GetModuleHandle(MAKELP(0,_hModule));
#else
	g3d.hmodLib = hModule;
#endif
#endif
	wT = LOWORD( GetVersion() );
	g3d.verWindows = (LOBYTE(wT) << 8) | HIBYTE(wT);

	if ( GetWinFlags() & 0x4000 )
		g3d.verBase = 24;		 // More then 16, not yet 32....WOW box on NT
	else
		g3d.verBase = 16;		 // Regular old 3.1

	g3d.dxFrame = GetSystemMetrics(SM_CXDLGFRAME)-dxBorder;
	g3d.dyFrame = GetSystemMetrics(SM_CYDLGFRAME)-dyBorder;
	g3d.dyCaption = GetSystemMetrics(SM_CYCAPTION);
	g3d.dxSysMenu = GetSystemMetrics(SM_CXSIZE);

#ifdef DLL
	if (g3d.verWindows >= ver31)
		{
		HANDLE hlib;

		hlib = LoadLibrary(lpszUser);
		if (FValidLibHandle(hlib))
			{
			(FARPROC) g3d.lpfnSetWindowsHookEx = GetProcAddress(hlib, lpszSetWindowsHookEx);
			(FARPROC) g3d.lpfnUnhookWindowsHookEx = GetProcAddress(hlib, lpszUnhookWindowsHookEx);
			(FARPROC) g3d.lpfnCallNextHookEx = GetProcAddress(hlib, lpszCallNextHookEx);
			FreeLibrary(hlib);
			}
		}
#endif
   return 1;
	}
#endif  // win32

// convert a RGB into a RGBQ
#define RGBQ(dw) RGB(GetBValue(dw),GetGValue(dw),GetRValue(dw))

//
//  LoadUIBitmap() - load a bitmap resource
//
//	 load a bitmap resource from a resource file, converting all
//	 the standard UI colors to the current user specifed ones.
//
//	 this code is designed to load bitmaps used in "gray ui" or
//	 "toolbar" code.
//
//	 the bitmap must be a 4bpp windows 3.0 DIB, with the standard
//	 VGA 16 colors.
//
//	 the bitmap must be authored with the following colors
//
//		Window Text      Black	   (index 0)
//		Button Shadow	  gray		(index 7)
//		Button Face	     lt gray   (index 8)
//		Button Highlight white	   (index 15)
//		Window Color	  yellow	   (index 11)
//		Window Frame	  green	   (index 10)
//
//	 Example:
//
//		hbm = LoadUIBitmap(hInstance, "TestBmp",
//			GetSysColor(COLOR_WINDOWTEXT),
//			GetSysColor(COLOR_BTNFACE),
//			GetSysColor(COLOR_BTNSHADOW),
//			GetSysColor(COLOR_BTNHIGHLIGHT),
//			GetSysColor(COLOR_WINDOW),
//			GetSysColor(COLOR_WINDOWFRAME));
//
//	 Author:	JimBov, ToddLa
//
//
#ifdef WIN32

HBITMAP PASCAL	LoadUIBitmap(
    HANDLE      hInstance,          // EXE file to load resource from
	LPCTSTR 	 szName,			 // name of bitmap resource
    COLORREF    rgbText,            // color to use for "Button Text"
    COLORREF    rgbFace,            // color to use for "Button Face"
    COLORREF    rgbShadow,          // color to use for "Button Shadow"
    COLORREF    rgbHighlight,       // color to use for "Button Hilight"
    COLORREF    rgbWindow,          // color to use for "Window Color"
    COLORREF    rgbFrame)           // color to use for "Window Frame"
{
    HBITMAP             hbm;
    LPBITMAPINFO        lpbi;
    HRSRC               hrsrc;
    HGLOBAL             h;
    HDC                 hdc;
    DWORD               size;

    //
    // Load the bitmap resource and make a writable copy.
    //

    hrsrc = FindResource(hInstance, szName, RT_BITMAP);
    if (!hrsrc)
        return(NULL);
    size = SizeofResource( hInstance, hrsrc );
    h = LoadResource(hInstance,hrsrc);
    if (!h)
        return(NULL);

    lpbi = ( LPBITMAPINFO ) GlobalAlloc( GPTR, size );

    if (!lpbi)
        return(NULL);

    CopyMemory( lpbi, h, size );

	*( LPCOLORREF ) &lpbi->bmiColors[0]  = RGBQ(rgbText);			// Black
	*( LPCOLORREF ) &lpbi->bmiColors[7]  = RGBQ(rgbShadow); 	   // gray
	*( LPCOLORREF ) &lpbi->bmiColors[8]  = RGBQ(rgbFace);		   // lt gray
	*( LPCOLORREF ) &lpbi->bmiColors[15] = RGBQ(rgbHighlight);	   // white
	*( LPCOLORREF ) &lpbi->bmiColors[11] = RGBQ(rgbWindow); 	   // yellow
	*( LPCOLORREF ) &lpbi->bmiColors[10] = RGBQ(rgbFrame);		   // green

    hdc = GetDC(NULL);

    hbm = CreateDIBitmap(hdc, &lpbi->bmiHeader, CBM_INIT, (LPBYTE)(&lpbi->bmiColors[ 16 ]),
            lpbi, DIB_RGB_COLORS);

    ReleaseDC(NULL, hdc);
    GlobalFree( lpbi );

    return(hbm);
}

#else

HBITMAP PASCAL	LoadUIBitmap(
		HANDLE		hInstance,		// EXE file to load resource from
		LPCTSTR 	szName,		   // name of bitmap resource
		COLORREF	rgbText,		  // color to use for "Button Text"
		COLORREF	rgbFace,		  // color to use for "Button Face"
		COLORREF	rgbShadow,		// color to use for "Button Shadow"
		COLORREF	rgbHighlight,	  // color to use for "Button Hilight"
		COLORREF	rgbWindow,		// color to use for "Window Color"
		COLORREF	rgbFrame)		 // color to use for "Window Frame"
	{
   LPBYTE			lpb;
	HBITMAP		   hbm;
	LPBITMAPINFOHEADER  lpbi;
	HANDLE			h;
	HDC			  hdc;
	LPDWORD		   lprgb;

	h = LoadResource(hInstance,FindResource(hInstance, szName, RT_BITMAP));

	lpbi = (LPBITMAPINFOHEADER)LockResource(h);

	if (!lpbi)
	   return(NULL);

#ifdef NOTNEEDEDFORCTL3D
	if (lpbi->biSize != sizeof(BITMAPINFOHEADER))
	   return NULL;

	if (lpbi->biBitCount != 4)
	   return NULL;
#endif

	lprgb = (LPDWORD)((LPBYTE)lpbi + (int)lpbi->biSize);
	lpb   = (LPBYTE)(lprgb + 16);

	lprgb[0]  = RGBQ(rgbText);		// Black

//	lprgb[7]  = RGBQ(rgbFace);		// lt gray
//	lprgb[8]  = RGBQ(rgbShadow);	// gray

	lprgb[7]  = RGBQ(rgbShadow);	// gray
	lprgb[8]  = RGBQ(rgbFace);		// lt gray

	lprgb[15] = RGBQ(rgbHighlight);	// white
	lprgb[11] = RGBQ(rgbWindow);	// yellow
	lprgb[10] = RGBQ(rgbFrame);		// green

	hdc = GetDC(NULL);

	hbm = CreateDIBitmap(hdc, lpbi, CBM_INIT, (LPVOID)lpb,
	   (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

	ReleaseDC(NULL, hdc);
	UnlockResource(h);
	FreeResource(h);

	return(hbm);
	}


#endif  // win32


/*-----------------------------------------------------------------------
|	
| DLL specific routines
|	
---------------------------------------------------------------WESC----*/

#ifndef WIN32
#ifdef DLL
/*-----------------------------------------------------------------------
|   WEP
-----------------------------------------------------------------------*/
int FAR PASCAL WEP (int wSystemExit)
	{
   return 1;
	}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ctl3dv2\ctl3d.h ===
/*-----------------------------------------------------------------------
|	CTL3D.DLL
|	
|	Adds 3d effects to Windows controls
|
|	See ctl3d.doc for info
|		
-----------------------------------------------------------------------*/
#ifdef __cplusplus
extern "C" {
#endif


BOOL WINAPI Ctl3dSubclassDlg(HWND, WORD);
BOOL WINAPI Ctl3dSubclassDlgEx(HWND, DWORD);

WORD WINAPI Ctl3dGetVer(void);
BOOL WINAPI Ctl3dEnabled(void);

HBRUSH WINAPI Ctl3dCtlColor(HDC, LONG);	// ARCHAIC, use Ctl3dCtlColorEx
HBRUSH WINAPI Ctl3dCtlColorEx(UINT wm, WPARAM wParam, LPARAM lParam);

BOOL WINAPI Ctl3dColorChange(void);

BOOL WINAPI Ctl3dSubclassCtl(HWND);
BOOL WINAPI Ctl3dSubclassCtlEx(HWND, int);
BOOL WINAPI Ctl3dUnsubclassCtl(HWND);

LONG WINAPI Ctl3dDlgFramePaint(HWND, UINT, WPARAM, LPARAM);

BOOL WINAPI Ctl3dAutoSubclass(HINSTANCE);
BOOL WINAPI Ctl3dAutoSubclassEx(HINSTANCE, DWORD);
BOOL WINAPI Ctl3dIsAutoSubclass(VOID);
BOOL WINAPI Ctl3dUnAutoSubclass(VOID);

BOOL WINAPI Ctl3dRegister(HINSTANCE);
BOOL WINAPI Ctl3dUnregister(HINSTANCE);

//begin DBCS: far east short cut key support
VOID WINAPI Ctl3dWinIniChange(void);
//end DBCS

/* Ctl3dAutoSubclassEx flags */
#define CTL3D_SUBCLASS_DYNCREATE	0x0001
#define CTL3D_NOSUBCLASS_DYNCREATE	0x0002

/* Ctl3d Control ID */
#define CTL3D_BUTTON_CTL	0
#define CTL3D_LISTBOX_CTL	1
#define CTL3D_EDIT_CTL		2
#define CTL3D_COMBO_CTL 	3
#define CTL3D_STATIC_CTL	4

/* Ctl3dSubclassDlg3d flags */
#define CTL3D_BUTTONS		0x0001
#define CTL3D_LISTBOXES		0x0002		
#define CTL3D_EDITS			0x0004	
#define CTL3D_COMBOS		0x0008
#define CTL3D_STATICTEXTS	0x0010		
#define CTL3D_STATICFRAMES	0x0020

#define CTL3D_NODLGWINDOW       0x00010000
#define CTL3D_ALL				0xffff

#define WM_DLGBORDER (WM_USER+3567)
/* WM_DLGBORDER *(int FAR *)lParam return codes */
#define CTL3D_NOBORDER		0
#define CTL3D_BORDER			1

#define WM_DLGSUBCLASS (WM_USER+3568)
/* WM_DLGSUBCLASS *(int FAR *)lParam return codes */
#define CTL3D_NOSUBCLASS	0
#define CTL3D_SUBCLASS		1

#define CTLMSGOFFSET 3569
#ifdef WIN32
#define CTL3D_CTLCOLORMSGBOX	(WM_USER+CTLMSGOFFSET)
#define CTL3D_CTLCOLOREDIT		(WM_USER+CTLMSGOFFSET+1)
#define CTL3D_CTLCOLORLISTBOX	(WM_USER+CTLMSGOFFSET+2)
#define CTL3D_CTLCOLORBTN		(WM_USER+CTLMSGOFFSET+3)
#define CTL3D_CTLCOLORSCROLLBAR (WM_USER+CTLMSGOFFSET+4)
#define CTL3D_CTLCOLORSTATIC	(WM_USER+CTLMSGOFFSET+5)
#define CTL3D_CTLCOLORDLG		(WM_USER+CTLMSGOFFSET+6)
#else
#define CTL3D_CTLCOLOR (WM_USER+CTLMSGOFFSET)
#endif


/* Resource ID for 3dcheck.bmp (for .lib version of ctl3d) */
#define CTL3D_3DCHECK 26567


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\ddeml.c ===
/****************************** Module Header ******************************\
* Module Name: ddeml.C
*
* DDE Manager main module - Contains all exported ddeml functions.
*
* Created: 12/12/88 Sanford Staab
*
* Copyright (c) 1988, 1989  Microsoft Corporation
* 4/5/89        sanfords        removed need for hwndFrame registration parameter
* 6/5/90        sanfords        Fixed callbacks so they are blocked during
*                               timeouts.
*                               Fixed SendDDEInit allocation bug.
*                               Added hApp to ConvInfo structure.
*                               Allowed QueryConvInfo() to work on server hConvs.
* 11/29/90      sanfords        eliminated SendDDEInit()
*
\***************************************************************************/

#include "ddemlp.h"
#include "verddeml.h"

/****** Globals *******/

HANDLE      hInstance        = 0;       // initialized by LoadProc
HANDLE      hheapDmg         = 0;       // main DLL heap
PAPPINFO    pAppInfoList     = NULL;    // registered app/thread data list
PPILE       pDataInfoPile    = NULL;    // Data handle tracking pile
PPILE       pLostAckPile     = NULL;    // Ack tracking pile
WORD        hwInst           = 1;       // used to validate stuff.
CONVCONTEXT CCDef            = { sizeof(CONVCONTEXT), 0, 0, CP_WINANSI, 0L, 0L };   // default context.
char        szNull[]         = "";
char        szT[20];
WORD        cMonitor         = 0;       // number of registered monitors
FARPROC     prevMsgHook      = NULL;    // used for hook links
FARPROC     prevCallHook     = NULL;    // used for hook links
ATOM        gatomDDEMLMom    = 0;
ATOM        gatomDMGClass    = 0;
DWORD       ShutdownTimeout;
DWORD       ShutdownRetryTimeout;
LPMQL       gMessageQueueList = NULL;   // see PostDdeMessage();
#ifdef DEBUG
int         bDbgFlags        = 0;
#endif

/****** class strings ******/

char SZFRAMECLASS[] =       "DMGFrame";
char SZDMGCLASS[] =         "DMGClass";
char SZCLIENTCLASS[] =      "DMGClientClass";
char SZSERVERCLASS[] =      "DMGServerClass";
char SZMONITORCLASS[] =     "DMGMonitorClass";
char SZCONVLISTCLASS[] =    "DMGHoldingClass";
char SZHEAPWATCHCLASS[] =   "DMGHeapWatchClass";

#ifdef DEBUG
WORD        cAtoms           = 0;       // for debugging hszs!
#endif


// PROGMAN HACK!!!!
// This is here so DDEML works properly with PROGMAN 3.0 which incorrectly
// deletes its initiate-ack atoms after sending its ack.
ATOM aProgmanHack = 0;


/*
 * maps XTYP_CONSTANTS to filter flags
 */
DWORD aulmapType[] = {
        0L,                             // nothing
        0L,                             // XTYP_ADVDATA
        0L,                             // XTYP_ADVREQ
        CBF_FAIL_ADVISES,               // XTYP_ADVSTART
        0L,                             // XTYP_ADVSTOP
        CBF_FAIL_EXECUTES,              // XTYP_EXECUTE
        CBF_FAIL_CONNECTIONS,           // XTYP_CONNECT
        CBF_SKIP_CONNECT_CONFIRMS,      // XTYP_CONNECT_CONFIRM
        0L,                             // XTYP_MONITOR
        CBF_FAIL_POKES,                 // XTYP_POKE
        CBF_SKIP_REGISTRATIONS,         // XTYP_REGISTER
        CBF_FAIL_REQUESTS,              // XTYP_REQUEST
        CBF_SKIP_DISCONNECTS,           // XTYP_DISCONNECT
        CBF_SKIP_UNREGISTRATIONS,       // XTYP_UNREGISTER
        CBF_FAIL_CONNECTIONS,           // XTYP_WILDCONNECT
        0L,                             // XTYP_XACT_COMPLETE
    };




UINT EXPENTRY DdeInitialize(
LPDWORD pidInst,
PFNCALLBACK pfnCallback,
DWORD afCmd,
DWORD ulRes)
{
    WORD wRet;

#ifdef DEBUG
    if (!hheapDmg) {
        bDbgFlags = GetProfileInt("DDEML", "DebugFlags", 0);
    }
#endif
    TRACEAPIIN((szT, "DdeInitialize(%lx(->%lx), %lx, %lx, %lx)\n",
            pidInst, *pidInst, pfnCallback, afCmd, ulRes));

    if (ulRes != 0L) {
        wRet = DMLERR_INVALIDPARAMETER;
    } else {
        wRet = Register(pidInst, pfnCallback, afCmd);
    }
    TRACEAPIOUT((szT, "DdeInitialize:%x\n", wRet));
    return(wRet);
}


DWORD Myatodw(LPCSTR psz)
{
    DWORD dwRet = 0;

    if (psz == NULL) {
        return(0);
    }
    while (*psz) {
        dwRet = (dwRet << 1) + (dwRet << 3) + (*psz - '0');
        psz++;
    }
    return(dwRet);
}


WORD Register(
LPDWORD pidInst,
PFNCALLBACK pfnCallback,
DWORD afCmd)
{
    PAPPINFO    pai = 0L;

    SEMENTER();

    if (afCmd & APPCLASS_MONITOR) {
        if (cMonitor == MAX_MONITORS) {
            return(DMLERR_DLL_USAGE);
        }
        // ensure monitors only get monitor callbacks.
        afCmd |= CBF_MONMASK;
    }

    if ((pai = (PAPPINFO)(*pidInst)) != NULL) {
        if (pai->instCheck != HIWORD(*pidInst)) {
            return(DMLERR_INVALIDPARAMETER);
        }
        /*
         * re-registration - only allow CBF_ and MF_ flags to be altered
         */
        pai->afCmd = (pai->afCmd & ~(CBF_MASK | MF_MASK)) |
                (afCmd & (CBF_MASK | MF_MASK));
        return(DMLERR_NO_ERROR);
    }

    if (!hheapDmg) {

        // Read in any alterations to the zombie terminate timeouts
        GetProfileString("DDEML", "ShutdownTimeout", "3000", szT, 20);
        ShutdownTimeout = Myatodw(szT);
        if (!ShutdownTimeout) {
            ShutdownTimeout = 3000;
        }

        GetProfileString("DDEML", "ShutdownRetryTimeout", "30000", szT, 20);
        ShutdownRetryTimeout = Myatodw(szT);
        if (!ShutdownRetryTimeout) {
            ShutdownRetryTimeout = 30000;
        }

        // PROGMAN HACK!!!!
        aProgmanHack = GlobalAddAtom("Progman");

        /* UTTER GREASE to fool the pile routines into making a local pile */
        hheapDmg = HIWORD((LPVOID)(&pDataInfoPile));
        RegisterClasses();
    }

    if (!pDataInfoPile) {
        if (!(pDataInfoPile = CreatePile(hheapDmg, sizeof(DIP), 8))) {
            goto Abort;
        }
    }

    if (!pLostAckPile) {
        if (!(pLostAckPile = CreatePile(hheapDmg, sizeof(LAP), 8))) {
            goto Abort;
        }
    }

    pai = (PAPPINFO)(DWORD)FarAllocMem(hheapDmg, sizeof(APPINFO));
    if (pai == NULL) {
        goto Abort;
    }


    if (!(pai->hheapApp = DmgCreateHeap(4096))) {
        FarFreeMem((LPSTR)pai);
        pai = 0L;
        goto Abort;
    }

    /*
     * We NEVER expect a memory allocation failure here because we just
     * allocated the heap.
     */
    pai->next = pAppInfoList;
    pai->pfnCallback = pfnCallback;
    // pai->pAppNamePile = NULL;  LMEM_ZEROINIT
    pai->pHDataPile = CreatePile(pai->hheapApp, sizeof(HDDEDATA), 32);
    pai->pHszPile = CreatePile(pai->hheapApp, sizeof(ATOM), 16);
    // pai->plstCBExceptions = NULL;  LMEM_ZEROINIT
    // pai->hwndSvrRoot = 0;  may never need it  LMEM_ZEROINIT
    pai->plstCB = CreateLst(pai->hheapApp, sizeof(CBLI));
    pai->afCmd = afCmd | APPCMD_FILTERINITS;
    pai->hTask = GetCurrentTask();
    // pai->hwndDmg =   LMEM_ZEROINIT
    // pai->hwndFrame = LMEM_ZEROINIT
    // pai->hwndMonitor = LMEM_ZEROINIT
    // pai->hwndTimer = 0; LMEM_ZEROINIT
    // pai->LastError = DMLERR_NO_ERROR;  LMEM_ZEROINIT
    // pai->wFlags = 0;
    // pai->fEnableOneCB = FALSE;  LMEM_ZEROINIT
    // pai->cZombies = 0;  LMEM_ZEROINIT
    // pai->cInProcess = 0; LMEM_ZEROINIT
    pai->instCheck = ++hwInst;
    pai->pServerAdvList = CreateLst(pai->hheapApp, sizeof(ADVLI));
    pai->lpMemReserve = FarAllocMem(pai->hheapApp, CB_RESERVE);

    pAppInfoList = pai;

    *pidInst = (DWORD)MAKELONG((WORD)pai, pai->instCheck);

    // NB We pass a pointer to pai in this CreateWindow because
    // 32bit MFC has a habit of subclassing our dde windows so this
    // param ends up getting thunked and since it's not really
    // a pointer things get a bit broken by the thunks.

    if ((pai->hwndDmg = CreateWindow(
            SZDMGCLASS,
            szNull,
            WS_OVERLAPPED,
            0, 0, 0, 0,
            (HWND)NULL,
            (HMENU)NULL,
            hInstance,
            &pai)) == 0L) {
        goto Abort;
    }

    if (pai->afCmd & APPCLASS_MONITOR) {
        pai->afCmd |= CBF_MONMASK;     // monitors only get MONITOR and REGISTER callbacks!

        if ((pai->hwndMonitor = CreateWindow(
                SZMONITORCLASS,
                szNull,
                WS_OVERLAPPED,
                0, 0, 0, 0,
                (HWND)NULL,
                (HMENU)NULL,
                hInstance,
                &pai)) == 0L) {
            goto Abort;
        }

        if (++cMonitor == 1) {
            prevMsgHook = SetWindowsHook(WH_GETMESSAGE, (FARPROC)DdePostHookProc);
            prevCallHook = SetWindowsHook(WH_CALLWNDPROC, (FARPROC)DdeSendHookProc);
        }
    } else if (afCmd & APPCMD_CLIENTONLY) {
    /*
     * create an invisible top-level frame for initiates. (if server ok)
     */
        afCmd |= CBF_FAIL_ALLSVRXACTIONS;
    } else {
        if ((pai->hwndFrame = CreateWindow(
                SZFRAMECLASS,
                szNull,
                WS_POPUP,
                0, 0, 0, 0,
                (HWND)NULL,
                (HMENU)NULL,
                hInstance,
                &pai)) == 0L) {
            goto Abort;
        }
    }

    // SetMessageQueue(200);

    SEMLEAVE();

    return(DMLERR_NO_ERROR);

Abort:
    SEMLEAVE();

    if (pai) {
        DdeUninitialize((DWORD)(LPSTR)pai);
    }

    return(DMLERR_SYS_ERROR);
}


LRESULT FAR PASCAL TermDlgProc(
HWND hwnd,
UINT msg,
WPARAM wParam,
LPARAM lParam)
{
    switch (msg) {
    case WM_INITDIALOG:
        return(TRUE);

    case WM_COMMAND:
        switch (wParam) {
        case IDABORT:
        case IDRETRY:
        case IDIGNORE:
            EndDialog(hwnd, wParam);
            return(0);
        }
        break;
    }
    return(0);
}


/***************************** Public  Function ****************************\
* PUBDOC START
* BOOL EXPENTRY DdeUninitialize(void);
*     This unregisters the application from the DDEMGR.  All DLL resources
*     associated with the application are destroyed.
*
* PUBDOC END
*
* History:
*   Created     12/14/88    Sanfords
\***************************************************************************/
BOOL EXPENTRY DdeUninitialize(
DWORD idInst)
{
    register PAPPINFO pai;
    PAPPINFO paiT;
    ATOM    a;
    DWORD   hData;
    MSG msg;
    extern VOID DumpGlobalLogs(VOID);

    TRACEAPIIN((szT, "DdeUninitialize(%lx)\n", idInst));

    pai = (PAPPINFO)LOWORD(idInst);
    if (pai == NULL || pai->instCheck != HIWORD(idInst)) {
        TRACEAPIOUT((szT, "DdeUninitialize:0\n"));
        return(FALSE);
    }
    pai->LastError = DMLERR_NO_ERROR;

    /*
     * This is a hack to catch apps that call DdeUninitialize while within
     * a synchronous transaction modal loop.
     */
    pai->wFlags |= AWF_UNINITCALLED;
    if (pai->wFlags & AWF_INSYNCTRANSACTION) {
        TRACEAPIOUT((szT, "DdeUninitialize:1\n"));
        return(TRUE);
    }

    /*
     * inform others of DeRegistration
     */
    if (pai->pAppNamePile != NULL) {
        DdeNameService(idInst, (HSZ)NULL, (HSZ)NULL, DNS_UNREGISTER);
    }

    /*
     * Let any lagging dde activity die down.
     */
    while (EmptyDDEPostQ()) {
        Yield();
        while (PeekMessage((MSG FAR *)&msg, (HWND)NULL,
                WM_DDE_FIRST, WM_DDE_LAST, PM_REMOVE)) {
            DispatchMessage((MSG FAR *)&msg);
            Yield();
        }
        for (paiT = pAppInfoList; paiT != NULL; paiT = paiT->next) {
            if (paiT->hTask == pai->hTask) {
                CheckCBQ(paiT);
            }
        }
    }

    // Let all windows left begin to self destruct.
    ChildMsg(pai->hwndDmg, UM_DISCONNECT, ST_PERM2DIE, 0L, FALSE);

    if (ShutdownTimeout && pai->cZombies) {
        WORD wRet;
        WORD hiTimeout;
        /*
         * This ugly mess is here to prevent DDEML from closing down and
         * destroying windows that are not properly terminated.  Any
         * windows waiting on WM_DDE_TERMINATE messages set the cZombies
         * count.  If there are any left we go into a modal loop till
         * things clean up.  This should, in most cases happen fairly
         * quickly.
         */

        hiTimeout = HIWORD(ShutdownTimeout);
        SetTimer(pai->hwndDmg, TID_SHUTDOWN, LOWORD(ShutdownTimeout), NULL);
        TRACETERM((szT, "DdeUninitialize: Entering terminate modal loop. cZombies=%d[%x:%x]\n",
                ((LPAPPINFO)pai)->cZombies,
                HIWORD(&((LPAPPINFO)pai)->cZombies),
                LOWORD(&((LPAPPINFO)pai)->cZombies)));
        while (pai->cZombies > 0) {
            Yield();        // give other apps a chance to post terminates.
            GetMessage(&msg, (HWND)NULL, 0, 0xffff);
            if (msg.message == WM_TIMER && msg.wParam == TID_SHUTDOWN &&
                    msg.hwnd == pai->hwndDmg) {
                if (hiTimeout--) {
                    SetTimer(pai->hwndDmg, TID_SHUTDOWN, 0xFFFF, NULL);
                } else {
                    FARPROC lpfn;

                    KillTimer(pai->hwndDmg, TID_SHUTDOWN);
                    if (!pai->cZombies) {
                        break;
                    }

                    TRACETERM((szT,
                        "DdeUninitialize Zombie hangup: pai=%x:%x\n",
                        HIWORD((LPAPPINFO)pai), (WORD)(pai)));
                    /*
                     * If the partner window died in any remaining zombie
                     * windows, get them shut down.
                     */
                    ChildMsg(pai->hwndDmg, UM_DISCONNECT, ST_CHECKPARTNER, 0L, FALSE);

                    if (pai->cZombies > 0) {
                        lpfn = MakeProcInstance((FARPROC)TermDlgProc, hInstance);
                        wRet = DialogBox(hInstance, "TermDialog", (HWND)NULL, lpfn);
                        FreeProcInstance(lpfn);
                        if (wRet == IDABORT || wRet == -1) {
                            pai->cZombies = 0;
                            break;      // ignore zombies!
                        }
                        if (wRet == IDRETRY) {
                            hiTimeout = HIWORD(ShutdownRetryTimeout);
                            SetTimer(pai->hwndDmg, TID_SHUTDOWN,
                                    LOWORD(ShutdownRetryTimeout), NULL);
                        }
                        // IDIGNORE - loop forever!
                    }
                }
            }
            // app should already be shut-down so we don't bother with
            // accelerator or menu translations.
            DispatchMessage(&msg);
            /*
             * tell all instances in this task to process their
             * callbacks so we can clear our queue.
             */
            EmptyDDEPostQ();
            for (paiT = pAppInfoList; paiT != NULL; paiT = paiT->next) {
                if (paiT->hTask == pai->hTask) {
                    CheckCBQ(paiT);
                }
            }
        }
    }
#if 0 // don't need this anymore
    if (pai->hwndTimer) {
        pai->wTimeoutStatus |= TOS_ABORT;
        PostMessage(pai->hwndTimer, WM_TIMER, TID_TIMEOUT, 0);
        // if this fails, no big deal because it means the queue is full
        // and the modal loop will catch our TOS_ABORT quickly.
        // We need to do this in case no activity is happening in the
        // modal loop.
    }
#endif
    if (pai->hwndMonitor) {
        DmgDestroyWindow(pai->hwndMonitor);
        if (!--cMonitor) {
            UnhookWindowsHook(WH_GETMESSAGE, (FARPROC)DdePostHookProc);
            UnhookWindowsHook(WH_CALLWNDPROC, (FARPROC)DdeSendHookProc);
        }
    }
    UnlinkAppInfo(pai);

    DmgDestroyWindow(pai->hwndDmg);
    DmgDestroyWindow(pai->hwndFrame);

    while (PopPileSubitem(pai->pHDataPile, (LPBYTE)&hData))
        FreeDataHandle(pai, hData, FALSE);
    DestroyPile(pai->pHDataPile);

    while (PopPileSubitem(pai->pHszPile, (LPBYTE)&a)) {
        MONHSZ(a, MH_CLEANUP, pai->hTask);
        FreeHsz(a);
    }
    DestroyPile(pai->pHszPile);
    DestroyPile(pai->pAppNamePile);
    DestroyLst(pai->pServerAdvList);
    DmgDestroyHeap(pai->hheapApp);
    pai->instCheck--;   // make invalid on later attempts to reinit.
    FarFreeMem((LPSTR)pai);

    /* last one out.... trash the data info heap */
    if (!pAppInfoList) {
#ifdef DEBUG
        DIP dip;

        AssertF(!PopPileSubitem(pDataInfoPile, (LPBYTE)&dip),
                "leftover APPOWNED handles");
#endif
        DestroyPile(pDataInfoPile);
        DestroyPile(pLostAckPile);
        pDataInfoPile = NULL;
        pLostAckPile = NULL;
        AssertFW(cAtoms == 0, "DdeUninitialize() - leftover atoms");

        // PROGMAN HACK!!!!
        GlobalDeleteAtom(aProgmanHack);
        // CLOSEHEAPWATCH();
    }

#ifdef DEBUG
    DumpGlobalLogs();
#endif

    TRACEAPIOUT((szT, "DdeUninitialize:1\n"));
    return(TRUE);
}






HCONVLIST EXPENTRY DdeConnectList(
DWORD idInst,
HSZ hszSvcName,
HSZ hszTopic,
HCONVLIST hConvList,
PCONVCONTEXT pCC)
{
    PAPPINFO            pai;
    HWND                hConv, hConvNext, hConvNew, hConvLast;
    HWND                hConvListNew;
    PCLIENTINFO         pciOld, pciNew;


    TRACEAPIIN((szT, "DdeConnectList(%lx, %lx, %lx, %lx, %lx)\n",
            idInst, hszSvcName, hszTopic, hConvList, pCC));

    pai = (PAPPINFO)idInst;
    if (pai == NULL || pai->instCheck != HIWORD(idInst)) {
        TRACEAPIOUT((szT, "DdeConnectList:0\n"));
        return(0L);
    }

    pai->LastError = DMLERR_NO_ERROR;

    if (hConvList && !ValidateHConv(hConvList)) {
        SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
        TRACEAPIOUT((szT, "DdeConnectList:0\n"));
        return(0L);
    }

    /*
     * destroy any dead old clients
     */
    if ((HWND)hConvList && (hConv = GetWindow((HWND)hConvList, GW_CHILD))) {
        do {
            hConvNext = GetWindow((HWND)hConv, GW_HWNDNEXT);
            pciOld = (PCLIENTINFO)GetWindowLong(hConv, GWL_PCI);
            if (!(pciOld->ci.fs & ST_CONNECTED)) {
                SetParent(hConv, pai->hwndDmg);
                Disconnect(hConv, ST_PERM2DIE, pciOld);
            }
        } while (hConv = hConvNext);
    }

    // create a new list window

    if ((hConvListNew = CreateWindow(
            SZCONVLISTCLASS,
            szNull,
            WS_CHILD,
            0, 0, 0, 0,
            pai->hwndDmg,
            (HMENU)NULL,
            hInstance,
            &pai)) == NULL) {
        SETLASTERROR(pai, DMLERR_SYS_ERROR);
        TRACEAPIOUT((szT, "DdeConnectList:0\n"));
        return(0L);
    }

    // Make all possible connections to new list window

    hConvNew = GetDDEClientWindow(pai, hConvListNew, HIWORD(hszSvcName), LOWORD(hszSvcName), LOWORD(hszTopic), pCC);

    /*
     * If no new hConvs created, return old list.
     */
    if (hConvNew == NULL) {
        // if no old hConvs as well, destroy all and return NULL
        if ((HWND)hConvList && GetWindow((HWND)hConvList, GW_CHILD) == NULL) {
            SendMessage((HWND)hConvList, UM_DISCONNECT,
                    ST_PERM2DIE, 0L);
            SETLASTERROR(pai, DMLERR_NO_CONV_ESTABLISHED);
            TRACEAPIOUT((szT, "DdeConnectList:0\n"));
            return(NULL);
        }
        // else just return old list (- dead convs)
        if (hConvList == NULL) {
            DestroyWindow(hConvListNew);
            SETLASTERROR(pai, DMLERR_NO_CONV_ESTABLISHED);
        }
        TRACEAPIOUT((szT, "DdeConnectList:%lx\n", hConvList));
        return(hConvList);
    }

    /*
     * remove duplicates from the new list
     */
    if ((HWND)hConvList && (hConv = GetWindow((HWND)hConvList, GW_CHILD))) {
        // go throuch old list...
        do {
            pciOld = (PCLIENTINFO)GetWindowLong(hConv, GWL_PCI);
            /*
             * destroy any new clients that are duplicates of the old ones.
             */
            hConvNew = GetWindow(hConvListNew, GW_CHILD);
            hConvLast = GetWindow(hConvNew, GW_HWNDLAST);
            while (hConvNew) {
                if (hConvNew == hConvLast) {
                    hConvNext = NULL;
                } else {
                    hConvNext = GetWindow(hConvNew, GW_HWNDNEXT);
                }
                pciNew = (PCLIENTINFO)GetWindowLong(hConvNew, GWL_PCI);
                if (pciOld->ci.aServerApp == pciNew->ci.aServerApp &&
                        pciOld->ci.aTopic == pciNew->ci.aTopic &&
                        pciOld->ci.hwndFrame == pciNew->ci.hwndFrame) {
                    /*
                     * assume same app, same topic, same hwndFrame is a duplicate.
                     *
                     * Move dieing window out of the list since it
                     * dies asynchronously and will still be around
                     * after this API exits.
                     */
                    SetParent(hConvNew, pai->hwndDmg);
                    Disconnect(hConvNew, ST_PERM2DIE,
                            (PCLIENTINFO)GetWindowLong(hConvNew, GWL_PCI));
                }
                hConvNew = hConvNext;
            }
            hConvNext = GetWindow(hConv, GW_HWNDNEXT);
            if (hConvNext && (GetParent(hConvNext) != (HWND)hConvList)) {
                hConvNext = NULL;
            }
            /*
             * move the unique old client to the new list
             */
            SetParent(hConv, hConvListNew);
        } while (hConv = hConvNext);
        // get rid of the old list
        SendMessage((HWND)hConvList, UM_DISCONNECT, ST_PERM2DIE, 0L);
    }

    /*
     * If none are left, fail because no conversations were established.
     */
    if (GetWindow(hConvListNew, GW_CHILD) == NULL) {
        SendMessage(hConvListNew, UM_DISCONNECT, ST_PERM2DIE, 0L);
        SETLASTERROR(pai, DMLERR_NO_CONV_ESTABLISHED);
        TRACEAPIOUT((szT, "DdeConnectList:0\n"));
        return(NULL);
    } else {
        TRACEAPIOUT((szT, "DdeConnectList:%lx\n", MAKEHCONV(hConvListNew)));
        return(MAKEHCONV(hConvListNew));
    }
}






HCONV EXPENTRY DdeQueryNextServer(
HCONVLIST hConvList,
HCONV hConvPrev)
{
    HWND hwndMaybe;
    PAPPINFO pai;

    TRACEAPIIN((szT, "DdeQueryNextServer(%lx, %lx)\n",
            hConvList, hConvPrev));

    if (!ValidateHConv(hConvList)) {
        pai = NULL;
        while (pai = GetCurrentAppInfo(pai)) {
            SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
        }
        TRACEAPIOUT((szT, "DdeQueryNextServer:0\n"));
        return NULL;
    }

    pai = EXTRACTHCONVLISTPAI(hConvList);
    pai->LastError = DMLERR_NO_ERROR;

    if (hConvPrev == NULL) {
        TRACEAPIOUT((szT, "DdeQueryNextServer:%lx\n",
            MAKEHCONV(GetWindow((HWND)hConvList, GW_CHILD))));
        return MAKEHCONV(GetWindow((HWND)hConvList, GW_CHILD));
    } else {
        if (!ValidateHConv(hConvPrev)) {
            SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
            TRACEAPIOUT((szT, "DdeQueryNextServer:0\n"));
            return NULL;
        }
        hwndMaybe = GetWindow((HWND)hConvPrev, GW_HWNDNEXT);
        if (!hwndMaybe) {
            TRACEAPIOUT((szT, "DdeQueryNextServer:0\n"));
            return NULL;
        }

        // make sure it's got the same parent and isn't the first child
        // ### maybe this code can go - I'm not sure how GW_HWNDNEXT acts. SS
        if (GetParent(hwndMaybe) == (HWND)hConvList &&
                hwndMaybe != GetWindow((HWND)hConvList, GW_CHILD)) {
            TRACEAPIOUT((szT, "DdeQueryNextServer:%lx\n", MAKEHCONV(hwndMaybe)));
            return MAKEHCONV(hwndMaybe);
        }
        TRACEAPIOUT((szT, "DdeQueryNextServer:0\n"));
        return NULL;
    }
}






BOOL EXPENTRY DdeDisconnectList(
HCONVLIST hConvList)
{
    PAPPINFO pai;

    TRACEAPIIN((szT, "DdeDisconnectList(%lx)\n", hConvList));

    if (!ValidateHConv(hConvList)) {
        pai = NULL;
        while (pai = GetCurrentAppInfo(pai)) {
            SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
        }
        TRACEAPIOUT((szT, "DdeDisconnectList:0\n"));
        return(FALSE);
    }
    pai = EXTRACTHCONVLISTPAI(hConvList);
    pai->LastError = DMLERR_NO_ERROR;

    SendMessage((HWND)hConvList, UM_DISCONNECT, ST_PERM2DIE, 0L);
    TRACEAPIOUT((szT, "DdeDisconnectList:1\n"));
    return(TRUE);
}





HCONV EXPENTRY DdeConnect(
DWORD idInst,
HSZ hszSvcName,
HSZ hszTopic,
PCONVCONTEXT pCC)
{
    PAPPINFO pai;
    HWND hwnd;

    TRACEAPIIN((szT, "DdeConnect(%lx, %lx, %lx, %lx)\n",
            idInst, hszSvcName, hszTopic, pCC));

    pai = (PAPPINFO)idInst;
    if (pai == NULL || pai->instCheck != HIWORD(idInst)) {
        TRACEAPIOUT((szT, "DdeConnect:0\n"));
        return(FALSE);
    }
    pai->LastError = DMLERR_NO_ERROR;

    if (pCC && pCC->cb != sizeof(CONVCONTEXT)) {
        SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
        TRACEAPIOUT((szT, "DdeConnect:0\n"));
        return(0);
    }


    hwnd = GetDDEClientWindow(pai, pai->hwndDmg, (HWND)HIWORD(hszSvcName),
            LOWORD(hszSvcName), LOWORD(hszTopic), pCC);

    if (hwnd == 0) {
        SETLASTERROR(pai, DMLERR_NO_CONV_ESTABLISHED);
    }

    TRACEAPIOUT((szT, "DdeConnect:%lx\n", MAKEHCONV(hwnd)));
    return(MAKEHCONV(hwnd));
}





BOOL EXPENTRY DdeDisconnect(
HCONV hConv)
{
    PAPPINFO pai;
    PCLIENTINFO pci;

    TRACEAPIIN((szT, "DdeDisconnect(%lx)\n", hConv));

    if (!ValidateHConv(hConv)) {
        pai = NULL;
        while (pai = GetCurrentAppInfo(pai)) {
            SETLASTERROR(pai, DMLERR_NO_CONV_ESTABLISHED);
        }
        TRACEAPIOUT((szT, "DdeDisconnect:0\n"));
        return(FALSE);
    }
    pai = EXTRACTHCONVPAI(hConv);
    pci = (PCLIENTINFO)GetWindowLong((HWND)hConv, GWL_PCI);
    if (pai->cInProcess) {
        // do asynchronously if this is called within a callback
        if (!PostMessage((HWND)hConv, UM_DISCONNECT, ST_PERM2DIE, (LONG)pci)) {
            SETLASTERROR(pai, DMLERR_SYS_ERROR);
            TRACEAPIOUT((szT, "DdeDisconnect:0\n"));
            return(FALSE);
        }
    } else {
        Disconnect((HWND)hConv, ST_PERM2DIE, pci);
    }
    TRACEAPIOUT((szT, "DdeDisconnect:1\n"));
    return(TRUE);
}





HCONV EXPENTRY DdeReconnect(
HCONV hConv)
{
    HWND hwnd;
    PAPPINFO pai;
    PCLIENTINFO pci;

    TRACEAPIIN((szT, "DdeReconnect(%lx)\n", hConv));

    if (!ValidateHConv(hConv)) {
        pai = NULL;
        while (pai = GetCurrentAppInfo(pai)) {
            SETLASTERROR(pai, DMLERR_NO_CONV_ESTABLISHED);
        }
        TRACEAPIOUT((szT, "DdeReconnect:0\n"));
        return(FALSE);
    }
    pai = EXTRACTHCONVPAI(hConv);
    pai->LastError = DMLERR_NO_ERROR;
    pci = (PCLIENTINFO)GetWindowLong((HWND)hConv, GWL_PCI);

    // The dyeing window MUST be a client to reconnect.

    if (!(pci->ci.fs & ST_CLIENT)) {
        SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
        TRACEAPIOUT((szT, "DdeReconnect:0\n"));
        return(FALSE);
    }

    hwnd = GetDDEClientWindow(pai, pai->hwndDmg, pci->ci.hwndFrame,
            pci->ci.aServerApp, pci->ci.aTopic, &pci->ci.CC);

    if (hwnd == 0) {
        SETLASTERROR(pai, DMLERR_NO_CONV_ESTABLISHED);
        TRACEAPIOUT((szT, "DdeReconnect:0\n"));
        return(FALSE);
    }

    if (pci->ci.fs & ST_INLIST) {
        SetParent(hwnd, GetParent((HWND)hConv));
    }

    if (pci->ci.fs & ST_ADVISE) {
        DWORD result;
        PADVLI pali, paliNext;

        // recover advise loops here

        for (pali = (PADVLI)pci->pClientAdvList->pItemFirst; pali; pali = paliNext) {
            paliNext = (PADVLI)pali->next;
            if (pali->hwnd == (HWND)hConv) {
                XFERINFO xi;

                xi.pulResult = &result;
                xi.ulTimeout = (DWORD)TIMEOUT_ASYNC;
                xi.wType = XTYP_ADVSTART |
                       (pali->fsStatus & (XTYPF_NODATA | XTYPF_ACKREQ));
                xi.wFmt = pali->wFmt;
                xi.hszItem = (HSZ)pali->aItem;
                xi.hConvClient = MAKEHCONV(hwnd);
                xi.cbData = 0;
                xi.hDataClient = NULL;
                ClientXferReq(&xi, hwnd,
                        (PCLIENTINFO)GetWindowLong(hwnd, GWL_PCI));
            }
        }
    }

    TRACEAPIOUT((szT, "DdeReconnect:%lx\n", MAKEHCONV(hwnd)));
    return(MAKEHCONV(hwnd));
}



UINT EXPENTRY DdeQueryConvInfo(
HCONV hConv,
DWORD idTransaction,
PCONVINFO pConvInfo)
{
    PCLIENTINFO pci;
    PAPPINFO pai;
    PXADATA pxad;
    PCQDATA pqd;
    BOOL fClient;
    WORD cb;
    CONVINFO ci;

    SEMCHECKOUT();

    TRACEAPIIN((szT, "DdeQueryConvInfo(%lx, %lx, %lx(->cb=%lx))\n",
        hConv, idTransaction, pConvInfo, pConvInfo->cb));

    if (!ValidateHConv(hConv) ||
            !(pci = (PCLIENTINFO)GetWindowLong((HWND)hConv, GWL_PCI))) {
        pai = NULL;
        while (pai = GetCurrentAppInfo(pai)) {
            SETLASTERROR(pai, DMLERR_NO_CONV_ESTABLISHED);
        }
        TRACEAPIOUT((szT, "DdeQueryConvInfo:0\n"));
        return(FALSE);
    }
    pai = pci->ci.pai;
    pai->LastError = DMLERR_NO_ERROR;

    /*
     * This check attempts to prevent improperly coded apps from
     * crashing due to having not initialized the cb field.
     */
    if (pConvInfo->cb > sizeof(CONVINFO) || pConvInfo->cb == 0) {
        pConvInfo->cb = sizeof(CONVINFO) -
                sizeof(HWND) -  // for new hwnd field
                sizeof(HWND);   // for new hwndPartner field
    }

    fClient = (BOOL)SendMessage((HWND)hConv, UM_QUERY, Q_CLIENT, 0L);

    if (idTransaction == QID_SYNC || !fClient) {
        pxad = &pci->ci.xad;
    } else {
        if (pci->pQ != NULL &&  (pqd = (PCQDATA)Findqi(pci->pQ, idTransaction))) {
            pxad = &pqd->xad;
        } else {
            SETLASTERROR(pai, DMLERR_UNFOUND_QUEUE_ID);
            TRACEAPIOUT((szT, "DdeQueryConvInfo:0\n"));
            return(FALSE);
        }
    }
    SEMENTER();
    ci.cb = sizeof(CONVINFO);
    ci.hConvPartner = (IsWindow((HWND)pci->ci.hConvPartner) &&
            ((pci->ci.fs & (ST_ISLOCAL | ST_CONNECTED)) == (ST_ISLOCAL | ST_CONNECTED)))
            ? pci->ci.hConvPartner : NULL;
    ci.hszSvcPartner = fClient ? pci->ci.aServerApp : 0;
    ci.hszServiceReq = pci->ci.hszSvcReq;
    ci.hszTopic = pci->ci.aTopic;
    ci.wStatus = pci->ci.fs;
    ci.ConvCtxt = pci->ci.CC;
    if (fClient) {
        ci.hUser = pxad->hUser;
        ci.hszItem = pxad->pXferInfo->hszItem;
        ci.wFmt = pxad->pXferInfo->wFmt;
        ci.wType = pxad->pXferInfo->wType;
        ci.wConvst = pxad->state;
        ci.wLastError = pxad->LastError;
    } else {
        ci.hUser = pci->ci.xad.hUser;
        ci.hszItem = NULL;
        ci.wFmt = 0;
        ci.wType = 0;
        ci.wConvst = pci->ci.xad.state;
        ci.wLastError = pci->ci.pai->LastError;
    }
    ci.hConvList = (pci->ci.fs & ST_INLIST) ?
            MAKEHCONV(GetParent((HWND)hConv)) : 0;

    cb = min(sizeof(CONVINFO), (WORD)pConvInfo->cb);
    ci.hwnd = (HWND)hConv;
    ci.hwndPartner = (HWND)pci->ci.hConvPartner;

    hmemcpy((LPBYTE)pConvInfo, (LPBYTE)&ci, cb);
    pConvInfo->cb = cb;
    SEMLEAVE();
    TRACEAPIOUT((szT, "DdeQueryConvInfo:%x\n", cb));
    return(cb);
}






BOOL EXPENTRY DdeSetUserHandle(
HCONV hConv,
DWORD id,
DWORD hUser)
{
    PAPPINFO pai;
    PCLIENTINFO pci;
    PXADATA pxad;
    PCQDATA pqd;

    TRACEAPIIN((szT, "DdeSetUserHandle(%lx, %lx, %lx)\n",
            hConv, id, hUser));

    if (!ValidateHConv(hConv)) {
        pai = NULL;
        while (pai = GetCurrentAppInfo(pai)) {
            SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
        }
        TRACEAPIOUT((szT, "DdeSetUserHandle:0\n"));
        return(FALSE);
    }
    pai = EXTRACTHCONVPAI(hConv);
    pai->LastError = DMLERR_NO_ERROR;

    SEMCHECKOUT();

    pci = (PCLIENTINFO)GetWindowLong((HWND)hConv, GWL_PCI);
    if (!pci) {
Error:
        SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
        TRACEAPIOUT((szT, "DdeSetUserHandle:0\n"));
        return(FALSE);
    }
    pxad = &pci->ci.xad;
    if (id != QID_SYNC) {
        if (!SendMessage((HWND)hConv, UM_QUERY, Q_CLIENT, 0)) {
            goto Error;
        }
        if (pci->pQ != NULL &&  (pqd = (PCQDATA)Findqi(pci->pQ, id))) {
            pxad = &pqd->xad;
        } else {
            SETLASTERROR(pai, DMLERR_UNFOUND_QUEUE_ID);
            TRACEAPIOUT((szT, "DdeSetUserHandle:0\n"));
            return(FALSE);
        }
    }
    pxad->hUser = hUser;
    TRACEAPIOUT((szT, "DdeSetUserHandle:1\n"));
    return(TRUE);
}





BOOL EXPENTRY DdePostAdvise(
DWORD idInst,
HSZ hszTopic,
HSZ hszItem)
{
    PAPPINFO pai;
    PSERVERINFO psi = NULL;
    register PADVLI pali;
    PADVLI paliPrev, paliEnd, paliMove;

    TRACEAPIIN((szT, "DdePostAdvise(%lx, %lx, %lx)\n",
            idInst, hszTopic, hszItem));

    pai = (PAPPINFO)idInst;
    if (pai == NULL || pai->instCheck != HIWORD(idInst)) {
        TRACEAPIOUT((szT, "DdePostAdvise:0\n"));
        return(FALSE);
    }

    pai->LastError = DMLERR_NO_ERROR;
    if (pai->afCmd & APPCMD_CLIENTONLY) {
        SETLASTERROR(pai, DMLERR_DLL_USAGE);
        TRACEAPIOUT((szT, "DdePostAdvise:0\n"));
        return(FALSE);
    }

    paliPrev = NULL;
    paliEnd = NULL;
    paliMove = NULL;
    pali = (PADVLI)pai->pServerAdvList->pItemFirst;
    while (pali && pali != paliMove) {
        if ((!hszItem || pali->aItem == (ATOM)hszItem) &&
            (!hszTopic || pali->aTopic == (ATOM)hszTopic)) {
            /*
             * Advise loops are tricky because of the desireable FACKREQ feature
             * of DDE.  The advise loop list holds information in its fsStatus
             * field to maintain the state of the advise loop.
             *
             * if the ADVST_WAITING bit is set, the server is still waiting for
             * the client to give it the go-ahead for more data with an
             * ACK message on this item. (FACKREQ is set)  Without a go-ahead,
             * the server will not send any more advise data to the client but
             * will instead set the ADVST_CHANGED bit which will cause another
             * WM_DDE_DATA message to be sent to the client as soon as the
             * go-ahead ACK is received.  This keeps the client up to date
             * but never overloads it.
             */
            if (pali->fsStatus & ADVST_WAITING) {
                /*
                 * if the client has not yet finished with the last data
                 * we gave him, just update the advise loop status
                 * instead of sending data now.
                 */
                pali->fsStatus |= ADVST_CHANGED;
                goto NextLink;
            }

            psi = (PSERVERINFO)GetWindowLong(pali->hwnd, GWL_PCI);

            if (pali->fsStatus & DDE_FDEFERUPD) {
                /*
                 * In the nodata case, we don't bother the server.  Just
                 * pass the client an apropriate DATA message.
                 */
                IncHszCount(pali->aItem);   // message copy
#ifdef DEBUG
                cAtoms--;   // don't count this add
#endif
                PostDdeMessage(&psi->ci, WM_DDE_DATA, pali->hwnd,
                        MAKELONG(0, pali->aItem), 0, 0);
            } else {
                PostServerAdvise(pali->hwnd, psi, pali, CountAdvReqLeft(pali));
            }

            if (pali->fsStatus & DDE_FACKREQ && pali->next) {
                /*
                 * In order to know what ack goes with what data sent out, we
                 * place any updated advise loops at the end of the list so
                 * that acks associated with them are found last.  ie First ack
                 * back goes with oldest data out.
                 */

                // Unlink

                if (paliPrev) {
                    paliPrev->next = pali->next;
                } else {
                    pai->pServerAdvList->pItemFirst = (PLITEM)pali->next;
                }

                // put on the end

                if (paliEnd) {
                    paliEnd->next = (PLITEM)pali;
                    paliEnd = pali;
                } else {
                    for (paliEnd = pali;
                            paliEnd->next;
                            paliEnd = (PADVLI)paliEnd->next) {
                    }
                    paliEnd->next = (PLITEM)pali;
                    paliMove = paliEnd = pali;
                }
                pali->next = NULL;

                if (paliPrev) {
                    pali = (PADVLI)paliPrev->next;
                } else {
                    pali = (PADVLI)pai->pServerAdvList->pItemFirst;
                }
                continue;
            }
        }
NextLink:
        paliPrev = pali;
        pali = (PADVLI)pali->next;
    }
    TRACEAPIOUT((szT, "DdePostAdvise:1\n"));
    return(TRUE);
}


/*
 * History:  4/18/91 sanfords - now always frees any incomming data handle
 *                              thats not APPOWNED regardless of error case.
 */
HDDEDATA EXPENTRY DdeClientTransaction(
LPBYTE pData,
DWORD cbData,
HCONV hConv,
HSZ hszItem,
UINT wFmt,
UINT wType,
DWORD ulTimeout,
LPDWORD pulResult)
{
    PAPPINFO pai;
    PCLIENTINFO pci;
    HDDEDATA hData, hDataBack, hRet = 0;

    SEMCHECKOUT();

    TRACEAPIIN((szT, "DdeClientTransaction(%lx, %lx, %lx, %lx, %x, %x, %lx, %lx)\n",
            pData, cbData, hConv, hszItem, wFmt, wType, ulTimeout, pulResult));

    if (!ValidateHConv(hConv)) {
        pai = NULL;
        while (pai = GetCurrentAppInfo(pai)) {
            SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
        }
        goto FreeErrExit;
    }

    pci = (PCLIENTINFO)GetWindowLong((HWND)hConv, GWL_PCI);
    pai = pci->ci.pai;

    /*
     * Don't let transactions happen if we are shutting down
     * or are already doing a sync transaction.
     */
    if ((ulTimeout != TIMEOUT_ASYNC && pai->wFlags & AWF_INSYNCTRANSACTION) ||
            pai->wFlags & AWF_UNINITCALLED) {
        SETLASTERROR(pai, DMLERR_REENTRANCY);
        goto FreeErrExit;
    }

    pci->ci.pai->LastError = DMLERR_NO_ERROR;

    if (!(pci->ci.fs & ST_CONNECTED)) {
        SETLASTERROR(pai, DMLERR_NO_CONV_ESTABLISHED);
        goto FreeErrExit;
    }

    // If local, check filters first

    if (pci->ci.fs & ST_ISLOCAL) {
        PAPPINFO paiServer;
        PSERVERINFO psi;

        // we can do this because the app heaps are in global shared memory

        psi = (PSERVERINFO)GetWindowLong((HWND)pci->ci.hConvPartner, GWL_PCI);

        if (!psi) {
            // SERVER DIED! - simulate a terminate received.

            Terminate((HWND)hConv, (HWND)pci->ci.hConvPartner, pci);
            SETLASTERROR(pai, DMLERR_NO_CONV_ESTABLISHED);
            goto FreeErrExit;
        }

        paiServer = psi->ci.pai;

        if (paiServer->afCmd & aulmapType[(wType & XTYP_MASK) >> XTYP_SHIFT]) {
            SETLASTERROR(pai, DMLERR_NOTPROCESSED);
FreeErrExit:
            if ((wType == XTYP_POKE || wType == XTYP_EXECUTE) && cbData == -1 &&
                    !(LOWORD((DWORD)pData) & HDATA_APPOWNED)) {
                FREEEXTHDATA(pData);
            }
            TRACEAPIOUT((szT, "DdeClientTransaction:0\n"));
            return(0);
        }
    }

    pai = pci->ci.pai;
    switch (wType) {
    case XTYP_POKE:
    case XTYP_EXECUTE:

        // prepair the outgoing handle

        if (cbData == -1L) {    // handle given, not pointer

            hData = ((LPEXTDATAINFO)pData)->hData;
            if (!(LOWORD(hData) & HDATA_APPOWNED)) {
                FREEEXTHDATA(pData);
            }
            if (!(hData = DllEntry(&pci->ci, hData))) {
                TRACEAPIOUT((szT, "DdeClientTransaction:0\n"));
                return(0);
            }
            pData = (LPBYTE)hData;  // place onto stack for pass on to ClientXferReq.

        } else {    // pointer given, create handle from it.

            if (!(pData = (LPBYTE)PutData(pData, cbData, 0, LOWORD(hszItem), wFmt, 0, pai))) {
                SETLASTERROR(pai, DMLERR_MEMORY_ERROR);
                TRACEAPIOUT((szT, "DdeClientTransaction:0\n"));
                return(0);
            }
        }
        hData = (HDDEDATA)pData; // used to prevent compiler over-optimization.

    case XTYP_REQUEST:
    case XTYP_ADVSTART:
    case XTYP_ADVSTART | XTYPF_NODATA:
    case XTYP_ADVSTART | XTYPF_ACKREQ:
        if (wType != XTYP_EXECUTE && !hszItem) {
            SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
            TRACEAPIOUT((szT, "DdeClientTransaction:0\n"));
            return(0);
        }
    case XTYP_ADVSTART | XTYPF_NODATA | XTYPF_ACKREQ:
        if (wType != XTYP_EXECUTE && !wFmt) {
            SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
            TRACEAPIOUT((szT, "DdeClientTransaction:0\n"));
            return(0);
        }
    case XTYP_ADVSTOP:

        pai->LastError = DMLERR_NO_ERROR;   // reset before start.

        if (ulTimeout == TIMEOUT_ASYNC) {
            hRet = (HDDEDATA)ClientXferReq((PXFERINFO)&pulResult, (HWND)hConv, pci);
        } else {
            pai->wFlags |= AWF_INSYNCTRANSACTION;
            hDataBack = (HDDEDATA)ClientXferReq((PXFERINFO)&pulResult, (HWND)hConv, pci);
            pai->wFlags &= ~AWF_INSYNCTRANSACTION;

            if ((wType & XCLASS_DATA) && hDataBack) {
                LPEXTDATAINFO pedi;

                //if (AddPileItem(pai->pHDataPile, (LPBYTE)&hDataBack, CmpHIWORD) == API_ERROR) {
                //    SETLASTERROR(pai, DMLERR_MEMORY_ERROR);
                //    goto ReturnPoint;
                //}

                // use app heap so any leftovers at Uninitialize time go away.
                pedi = (LPEXTDATAINFO)FarAllocMem(pai->hheapApp, sizeof(EXTDATAINFO));
                if (pedi) {
                    pedi->pai = pai;
                    pedi->hData = hDataBack;
                } else {
                    SETLASTERROR(pai, DMLERR_MEMORY_ERROR);
                }
                hRet = (HDDEDATA)pedi;
                goto ReturnPoint;
            } else if (hDataBack) {
                hRet = TRUE;
            }
        }
        goto ReturnPoint;
    }
    SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
ReturnPoint:

    if (pai->wFlags & AWF_UNINITCALLED) {
        pai->wFlags &= ~AWF_UNINITCALLED;
        DdeUninitialize(MAKELONG((WORD)pai, pai->instCheck));
    }
    TRACEAPIOUT((szT, "DdeClientTransaction:%lx\n", hRet));
    return(hRet);
}



/***************************** Public  Function ****************************\
* PUBDOC START
* WORD EXPENTRY DdeGetLastError(void)
*
* This API returns the most recent error registered by the DDE manager for
* the current thread.  This should be called anytime a DDE manager API
* returns in a failed state.
*
* returns an error code which corresponds to a DMLERR_ constant found in
* ddeml.h.  This error code may be passed on to DdePostError() to
* show the user the reason for the error.
*
* PUBDOC END
*
* History:
*   Created     12/14/88    Sanfords
\***************************************************************************/
UINT EXPENTRY DdeGetLastError(
DWORD idInst)
{
    register PAPPINFO pai;
    register WORD err = DMLERR_DLL_NOT_INITIALIZED;

    TRACEAPIIN((szT, "DdeGetLastError(%lx)\n", idInst));

    pai = (PAPPINFO)idInst;

    if (pai) {
        if (pai->instCheck != HIWORD(idInst)) {
            TRACEAPIOUT((szT, "DdeGetLastError:%x [bad instance]\n",
                    DMLERR_INVALIDPARAMETER));
            return(DMLERR_INVALIDPARAMETER);
        }
        err = pai->LastError;
        pai->LastError = DMLERR_NO_ERROR;
    }
    TRACEAPIOUT((szT, "DdeGetLastError:%x\n", err));
    return(err);
}


/*\
* Data Handles:
*
* Control flags:
*
*         HDCF_APPOWNED
*                 Only the app can free this in the apps PID/TID context.
*                   SET - when DdeCreateDataHandle is called with this flag given.
*                         The hData is Logged at this time.
*
*         HDCF_READONLY - set by ClientXfer and callback return.
*                 The app cannot add data to handles in this state.
*                   SET - when ClientXfer is entered
*                   SET - when callback is left
*
*         The DLL can free:
*                 any hData EXCEPT those hDatas which are
*                 APPOWNED where PIDcurrent == PIDowner.
*
*                 any unfreed logged hDatas are freed at unregistration time.
*
*         The APP can free:
*                 any logged hData.
*
* Logging points:   ClientXfer return, CheckQueue return, PutData(APPOWNED).
*
* WARNING:
*
*         Apps with multiple thread registration that talk to themselves
*         must not free hDatas until all threads are done with them.
*
\*/


/***************************** Public  Function ****************************\
* PUBDOC START
* HDDEDATA EXPENTRY DdeCreateDataHandle(pSrc, cb, cbOff, hszItem, wFmt, afCmd)
* LPBYTE pSrc;
* DWORD cb;
* DWORD cbOff;
* HSZ hszItem;
* WORD wFmt;
* WORD afCmd;
*
* This api allows a server application to create a hData apropriate
* for return from its call-back function.
* The passed in data is stored into the hData which is
* returned on success.  Any portions of the data handle not filled are
* undefined.  afCmd contains any of the HDATA_ constants described below:
*
* HDATA_APPOWNED
*   This declares the created data handle to be the responsability of
*   the application to free it.  Application owned data handles may
*   be returned from the callback function multiple times.  This allows
*   a server app to be able to support many clients without having to
*   recopy the data for each request.
*
* NOTES:
*   If an application expects this data handle to hold >64K of data via
*   DdeAddData(), it should specify a cb + cbOff to be as large as
*   the object is expected to get to avoid unnecessary data copying
*   or reallocation by the DLL.
*
*   if psrc==NULL, no actual data copying takes place.
*
*   Data handles given to an application via the DdeMgrClientXfer() or
*   DdeMgrCheckQueue() functions are the responsability of the client
*   application to free and MUST NOT be returned from the callback
*   function as server data!
*
* PUBDOC END
*
* History:
*   Created     12/14/88    Sanfords
\***************************************************************************/
HDDEDATA EXPENTRY DdeCreateDataHandle(
DWORD idInst,
LPBYTE pSrc,
DWORD cb,
DWORD cbOff,
HSZ hszItem,
UINT wFmt,
UINT afCmd)
{
    PAPPINFO pai;
    HDDEDATA hData;

    TRACEAPIIN((szT, "DdeCreateDataHandle(%lx, %lx, %lx, %lx, %lx, %x, %x)\n",
            idInst, pSrc, cb, cbOff, hszItem, wFmt, afCmd));

    pai = (PAPPINFO)idInst;
    if (pai == NULL || pai->instCheck != HIWORD(idInst)) {
        TRACEAPIOUT((szT, "DdeCreateDataHandle:0\n"));
        return(0);
    }
    pai->LastError = DMLERR_NO_ERROR;

    if (afCmd & ~(HDATA_APPOWNED)) {
        SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
        TRACEAPIOUT((szT, "DdeCreateDataHandle:0\n"));
        return(0L);
    }

    hData = PutData(pSrc, cb, cbOff, LOWORD(hszItem), wFmt, afCmd, pai);
    if (hData) {
        LPEXTDATAINFO pedi;

        // use app heap so any leftovers at Uninitialize time go away.
        pedi = (LPEXTDATAINFO)FarAllocMem(pai->hheapApp, sizeof(EXTDATAINFO));
        if (pedi) {
            pedi->pai = pai;
            pedi->hData = hData;
        }
        hData = (HDDEDATA)(DWORD)pedi;
    }
    TRACEAPIOUT((szT, "DdeCreateDataHandle:%lx\n", hData));
    return(hData);
}




HDDEDATA EXPENTRY DdeAddData(
HDDEDATA hData,
LPBYTE pSrc,
DWORD cb,
DWORD cbOff)
{

    PAPPINFO    pai;
    HDDEDATA FAR * phData;
    DIP         newDip;
    HANDLE      hd, hNewData;
    LPEXTDATAINFO pedi;

    TRACEAPIIN((szT, "DdeAddData(%lx, %lx, %lx, %lx)\n",
            hData, pSrc, cb, cbOff));

    if (!hData)
        goto DdeAddDataError;

    pedi = (LPEXTDATAINFO)hData;
    pai = pedi->pai;
    pai->LastError = DMLERR_NO_ERROR;
    hData = pedi->hData;

    /* if the datahandle is bogus, abort */
    hd = hNewData = HIWORD(hData);
    if (!hd || (LOWORD(hData) & HDATA_READONLY)) {
DdeAddDataError:
        SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
        TRACEAPIOUT((szT, "DdeAddData:0\n"));
        return(0L);
    }

    /*
     * we need this check in case the owning app is trying to reallocate
     * after giving the hData away. (his copy of the handle would not have
     * the READONLY flag set)
     */
    phData = (HDDEDATA FAR *)FindPileItem(pai->pHDataPile, CmpHIWORD, (LPBYTE)&hData, 0);
    if (!phData || LOWORD(*phData) & HDATA_READONLY) {
        SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
        TRACEAPIOUT((szT, "DdeAddData:0\n"));
        return(0L);
    }

    /* HACK ALERT!
     * make sure the first two words req'd by windows dde is there,
     * that is if the data isn't from an execute
     */
    if (!(LOWORD(hData) & HDATA_EXEC)) {
        cbOff += 4L;
    }
    if (GlobalSize(hd) < cb + cbOff) {
        /*
         * need to grow the block before putting new data in...
         */
        if (!(hNewData = GLOBALREALLOC(hd, cb + cbOff, GMEM_MOVEABLE))) {
            /*
             * We can't grow the seg. Try allocating a new one.
             */
            if (!(hNewData = GLOBALALLOC(GMEM_MOVEABLE | GMEM_DDESHARE,
                cb + cbOff))) {
                /* failed.... die */
                SETLASTERROR(pai, DMLERR_MEMORY_ERROR);
                TRACEAPIOUT((szT, "DdeAddData:0\n"));
                return(0);
            } else {
                /*
                 * got a new block, now copy data and trash old one
                 */
                CopyHugeBlock(GLOBALPTR(hd), GLOBALPTR(hNewData), GlobalSize(hd));
                GLOBALFREE(hd);  // objects flow through - no need to free.
            }
        }
        if (hNewData != hd) {
            /* if the handle is different and in piles, update data piles */
            if (FindPileItem(pai->pHDataPile, CmpHIWORD, (LPBYTE)&hData, FPI_DELETE)) {
                DIP *pDip;
                HDDEDATA hdT;

                // replace entry in global data info pile.

                if (pDip = (DIP *)(DWORD)FindPileItem(pDataInfoPile,  CmpWORD, (LPBYTE)&hd, 0)) {
                    newDip.hData = hNewData;
                    newDip.hTask = pDip->hTask;
                    newDip.cCount = pDip->cCount;
                    newDip.fFlags = pDip->fFlags;
                    FindPileItem(pDataInfoPile, CmpWORD,  (LPBYTE)&hd, FPI_DELETE);
                    /* following assumes addpileitem will not fail...!!! */
                    AddPileItem(pDataInfoPile, (LPBYTE)&newDip, CmpWORD);
                }
                hdT = (HDDEDATA)MAKELONG(newDip.fFlags, hNewData);
                AddPileItem(pai->pHDataPile, (LPBYTE)&hdT, CmpHIWORD);

            }
            hData = MAKELONG(LOWORD(hData), hNewData);
        }
    }
    if (pSrc) {
        CopyHugeBlock(pSrc, HugeOffset(GLOBALLOCK(HIWORD(hData)), cbOff), cb);
    }
    pedi->hData = hData;
    TRACEAPIOUT((szT, "DdeAddData:%lx\n", pedi));
    return((HDDEDATA)pedi);
}




DWORD EXPENTRY DdeGetData(hData, pDst, cbMax, cbOff)
HDDEDATA hData;
LPBYTE pDst;
DWORD cbMax;
DWORD cbOff;
{
    PAPPINFO pai;
    DWORD   cbSize;
    BOOL fExec = TRUE;

    TRACEAPIIN((szT, "DdeGetData(%lx, %lx, %lx, %lx)\n",
            hData, pDst, cbMax, cbOff));

    //
    // Check for NULL.
    // Packard Bell Navigator passes NULL at startup.  In 3.1 we'd
    // maybe trash our local heap using ds:0.  But now touching pai will
    // fault since it's a far pointer and 0:0 is bad.
    //
    // Also makes your system stabler.
    //
    if (!hData)
        goto DdeGetDataError;

    pai = EXTRACTHDATAPAI(hData);
    pai->LastError = DMLERR_NO_ERROR;
    hData = ((LPEXTDATAINFO)hData)->hData;
    cbSize = GlobalSize(HIWORD(hData));

    /* HACK ALERT!
     * make sure the first two words req'd by windows dde is there,
     * as long as it's not execute data
     */
    if (!(LOWORD(hData) & HDATA_EXEC)) {
        cbOff += 4;
        fExec = FALSE;
    }

    if (cbOff >= cbSize)
    {
DdeGetDataError:
        SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
        TRACEAPIOUT((szT, "DdeGetData:0\n"));
        return(0L);
    }

    cbMax = min(cbMax, cbSize - cbOff);
    if (pDst == NULL) {
        TRACEAPIOUT((szT, "DdeGetData:%lx\n", fExec ? cbSize : cbSize - 4));
        return(fExec ? cbSize : cbSize - 4);
    } else {
        CopyHugeBlock(HugeOffset(GLOBALLOCK(HIWORD(hData)), cbOff),
                pDst, cbMax);
        TRACEAPIOUT((szT, "DdeGetData:%lx\n", cbMax));
        return(cbMax);
    }
}



LPBYTE EXPENTRY DdeAccessData(
HDDEDATA hData,
LPDWORD pcbDataSize)
{
    PAPPINFO pai;
    DWORD    offset;
    LPBYTE   lpRet;

    TRACEAPIIN((szT, "DdeAccessData(%lx, %lx)\n",
            hData, pcbDataSize));

    if (!hData)
        goto DdeAccessDataError;

    pai = EXTRACTHDATAPAI(hData);
    pai->LastError = DMLERR_NO_ERROR;
    hData = ((LPEXTDATAINFO)hData)->hData;

    if (HIWORD(hData) && (HIWORD(hData) != 0xFFFF) ) {
        /* messed around here getting past the first two words, which
         * aren't even there if this is execute data
         */
        offset = (LOWORD(hData) & HDATA_EXEC) ? 0L : 4L;
        if (pcbDataSize) {
            *pcbDataSize = GlobalSize(HIWORD(hData)) - offset;
        }
        lpRet = (LPBYTE)GLOBALLOCK(HIWORD(hData)) + offset;
        TRACEAPIOUT((szT, "DdeAccessData:%lx\n", lpRet));
        return(lpRet);
    }

DdeAccessDataError:
    SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
    TRACEAPIOUT((szT, "DdeAccessData:0\n"));
    return(0L);
}




BOOL EXPENTRY DdeUnaccessData(
HDDEDATA hData)
{
    PAPPINFO pai;

    TRACEAPIIN((szT, "DdeUnaccessData(%lx)\n", hData));

    //
    // BOGUS -- we should set last error and RIP also.
    //
    if (hData)
    {
        pai = EXTRACTHDATAPAI(hData);
        pai->LastError = DMLERR_NO_ERROR;
    }
    TRACEAPIOUT((szT, "DdeUnaccessData:1\n"));
    return(TRUE);
}


// Diamond Multimedia Kit 5000 creates a non-app-owned data handle,
// uses it in a client transaction (which free's it) and then
// calls DDEFreeDataHandle which can fault (depending on what junk
// gets left behind). To handle this we validate the data handle
// before doing anything else.
BOOL HDdeData_Validate(HDDEDATA hData)
{
    WORD wSaveDS;
    UINT nRet;

    // we better check HIWORD(hData) before we try to stuff it into ds
    if(IsBadReadPtr((LPCSTR)hData, 1)) {
#ifdef DEBUG
        OutputDebugString("DDEML: Invalid HDDEDATA.\n\r");
#endif
        return(FALSE);
    }

    wSaveDS = SwitchDS(HIWORD(hData));

    // Use the validation layer to check the handle
    // We can call LocalSize with the near ptr as the handle because:
    //  1. The HDDEDATA was allocated with LPTR (LMEM_FIXED | LMEM_ZEROINIT)
    //  2. Local mem that is alloc'd LMEM_FIXED, the offset is the handle
    //  3. We don't want to call LocalHandle to get the handle because it has
    //     no parameter vailidation & blows up for bad handles
    nRet = LocalSize((HANDLE)LOWORD(hData));

    SwitchDS(wSaveDS);

#ifdef DEBUG
    if (!nRet) {
        OutputDebugString("DDEML: Invalid HDDEDATA.\n\r");
    }
#endif

    return nRet;
}

BOOL EXPENTRY DdeFreeDataHandle(
HDDEDATA hData)
{
    PAPPINFO pai;
    LPEXTDATAINFO pedi;

    TRACEAPIIN((szT, "DdeFreeDataHandle(%lx)\n", hData));

    pedi = (LPEXTDATAINFO)hData;

    if ( !pedi || !HDdeData_Validate(hData) ) {
        TRACEAPIOUT((szT, "DdeFreeDataHandle:1\n"));
        return(TRUE);
    }

    pai = EXTRACTHDATAPAI(hData);
    pai->LastError = DMLERR_NO_ERROR;

    if (!(LOWORD(pedi->hData) & HDATA_NOAPPFREE)) {
        FreeDataHandle(pedi->pai, pedi->hData, FALSE);
        FarFreeMem((LPSTR)pedi);
    }

    TRACEAPIOUT((szT, "DdeFreeDataHandle:2\n"));
    return(TRUE);
}




/***************************************************************************\
* PUBDOC START
* HSZ management notes:
*
*   HSZs are used in this DLL to simplify string handling for applications
*   and for inter-process communication.  Since many applications use a
*   fixed set of Application/Topic/Item names, it is convenient to convert
*   them to HSZs and allow quick comparisons for lookups.  This also frees
*   the DLL up from having to constantly provide string buffers for copying
*   strings between itself and its clients.
*
*   HSZs are the same as atoms except they have no restrictions on length or
*   number and are 32 bit values.  They are case preserving and can be
*   compared directly for case sensitive comparisons or via DdeCmpStringHandles()
*   for case insensitive comparisons.
*
*   When an application creates an HSZ via DdeCreateStringHandle() or increments its
*   count via DdeKeepStringHandle() it is essentially claiming the HSZ for
*   its own use.  On the other hand, when an application is given an
*   HSZ from the DLL via a callback, it is using another application's HSZ
*   and should not free that HSZ via DdeFreeStringHandle().
*
*   The DLL insures that during the callback any HSZs given will remain
*   valid for the duration of the callback.
*
*   If an application wishes to keep that HSZ to use for itself as a
*   standard for future comparisons, it should increment its count so that,
*   should the owning application free it, the HSZ will not become invalid.
*   This also prevents an HSZ from changing its value.  (ie, app A frees it
*   and then app B creates a new one that happens to use the same HSZ code,
*   then app C, which had the HSZ stored all along (but forgot to increment
*   its count) now is holding a handle to a different string.)
*
*   Applications may free HSZs they have created or incremented at any time
*   by calling DdeFreeStringHandle().
*
*   The DLL internally increments HSZ counts while in use so that they will
*   not be destroyed until both the DLL and all applications concerned are
*   through with them.
*
*   IT IS THE APPLICATIONS RESPONSIBILITY TO PROPERLY CREATE AND FREE HSZs!!
*
* PUBDOC END
\***************************************************************************/


HSZ EXPENTRY DdeCreateStringHandle(
DWORD idInst,
LPCSTR psz,
int iCodePage)
{
#define pai ((PAPPINFO)idInst)
    ATOM a;

    TRACEAPIIN((szT, "DdeCreateStringHandle(%lx, %s, %x)\n",
            idInst, psz, iCodePage));

    if (pai == NULL | pai->instCheck != HIWORD(idInst)) {
        TRACEAPIOUT((szT, "DdeCreateStringHandle:0\n"));
        return(0);
    }
    pai->LastError = DMLERR_NO_ERROR;

    if (psz == NULL || *psz == '\0') {
        TRACEAPIOUT((szT, "DdeCreateStringHandle:0\n"));
        return(0);
    }
    if (iCodePage == 0 || iCodePage == CP_WINANSI || iCodePage == GetKBCodePage()) {
        SEMENTER();
        a = FindAddHsz((LPSTR)psz, TRUE);
        SEMLEAVE();

        MONHSZ(a, MH_CREATE, pai->hTask);
        if (AddPileItem(pai->pHszPile, (LPBYTE)&a, NULL) == API_ERROR) {
            SETLASTERROR(pai, DMLERR_MEMORY_ERROR);
            a = 0;
        }
        TRACEAPIOUT((szT, "DdeCreateStringHandle:%x\n", a));
        return((HSZ)a);
    } else {
        SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
        TRACEAPIOUT((szT, "DdeCreateStringHandle:0\n"));
        return(0);
    }
#undef pai
}



BOOL EXPENTRY DdeFreeStringHandle(
DWORD idInst,
HSZ hsz)
{
    PAPPINFO pai;
    ATOM a = LOWORD(hsz);
    BOOL fRet;

    TRACEAPIIN((szT, "DdeFreeStringHandle(%lx, %lx)\n",
            idInst, hsz));

    pai = (PAPPINFO)idInst;
    if (pai == NULL || pai->instCheck != HIWORD(idInst)) {
        TRACEAPIOUT((szT, "DdeFreeStringHandle:0\n"));
        return(FALSE);
    }
    pai->LastError = DMLERR_NO_ERROR;

    MONHSZ(a, MH_DELETE, pai->hTask);
    FindPileItem(pai->pHszPile, CmpWORD, (LPBYTE)&a, FPI_DELETE);
    fRet = FreeHsz(a);
    TRACEAPIOUT((szT, "DdeFreeStringHandle:%x\n", fRet));
    return(fRet);
}



BOOL EXPENTRY DdeKeepStringHandle(
DWORD idInst,
HSZ hsz)
{
    PAPPINFO pai;
    ATOM a = LOWORD(hsz);
    BOOL fRet;

    TRACEAPIIN((szT, "DdeKeepStringHandle(%lx, %lx)\n",
            idInst, hsz));

    pai = (PAPPINFO)idInst;
    if (pai == NULL || pai->instCheck != HIWORD(idInst)) {
        TRACEAPIOUT((szT, "DdeKeepStringHandle:0\n"));
        return(FALSE);
    }
    pai->LastError = DMLERR_NO_ERROR;
    MONHSZ(a, MH_KEEP, pai->hTask);
    AddPileItem(pai->pHszPile, (LPBYTE)&a, NULL);
    fRet = IncHszCount(a);
    TRACEAPIOUT((szT, "DdeKeepStringHandle:%x\n", fRet));
    return(fRet);
}





DWORD EXPENTRY DdeQueryString(
DWORD idInst,
HSZ hsz,
LPSTR psz,
DWORD cchMax,
int iCodePage)
{
    PAPPINFO pai;
    DWORD dwRet;

    TRACEAPIIN((szT, "DdeQueryString(%lx, %lx, %lx, %lx, %x)\n",
            idInst, hsz, psz, cchMax, iCodePage));

    pai = (PAPPINFO)idInst;
    if (pai == NULL || pai->instCheck != HIWORD(idInst)) {
        TRACEAPIOUT((szT, "DdeQueryString:0\n"));
        return(FALSE);
    }
    pai->LastError = DMLERR_NO_ERROR;

    if (iCodePage == 0 || iCodePage == CP_WINANSI || iCodePage == GetKBCodePage()) {
        if (psz) {
            if (hsz) {
                dwRet = QueryHszName(hsz, psz, (WORD)cchMax);
                TRACEAPIOUT((szT, "DdeQueryString:%lx(%s)\n", dwRet, psz));
                return(dwRet);
            } else {
                *psz = '\0';
                TRACEAPIOUT((szT, "DdeQueryString:0\n"));
                return(0);
            }
        } else if (hsz) {
            dwRet = QueryHszLength(hsz);
            TRACEAPIOUT((szT, "DdeQueryString:%lx\n", dwRet));
            return(dwRet);
        } else {
            TRACEAPIOUT((szT, "DdeQueryString:0\n"));
            return(0);
        }
    } else {
        SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
        TRACEAPIOUT((szT, "DdeQueryString:0\n"));
        return(0);
    }
}



int EXPENTRY DdeCmpStringHandles(
HSZ hsz1,
HSZ hsz2)
{
    int iRet;

    TRACEAPIIN((szT, "DdeCmpStringHandles(%lx, %lx)\n",
            hsz1, hsz2));

    if (hsz2 > hsz1) {
        iRet = -1;
    } else if (hsz2 < hsz1) {
        iRet = 1;
    } else {
        iRet = 0;
    }
    TRACEAPIOUT((szT, "DdeCmpStringHandles:%x\n", iRet));
    return(iRet);
}




BOOL EXPENTRY DdeAbandonTransaction(
DWORD idInst,
HCONV hConv,
DWORD idTransaction)
{
    PAPPINFO pai;

    TRACEAPIIN((szT, "DdeAbandonTransaction(%lx, %lx, %lx)\n",
            idInst, hConv, idTransaction));

    pai = (PAPPINFO)idInst;
    if (pai == NULL || pai->instCheck != HIWORD(idInst)) {
        TRACEAPIOUT((szT, "DdeAbandonTransaction:0\n"));
        return(FALSE);
    }
    pai->LastError = DMLERR_NO_ERROR;

    if ((hConv && !ValidateHConv(hConv)) || idTransaction == QID_SYNC) {
        SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
        TRACEAPIOUT((szT, "DdeAbandonTransaction:0\n"));
        return(FALSE);
    }
    if (hConv == NULL) {

        // do all conversations!

        register HWND hwnd;
        register HWND hwndLast;

        if (!(hwnd = GetWindow(pai->hwndDmg, GW_CHILD))) {
            TRACEAPIOUT((szT, "DdeAbandonTransaction:1\n"));
            return(TRUE);
        }
        hwndLast = GetWindow(hwnd, GW_HWNDLAST);
        do {
            AbandonTransaction(hwnd, pai, idTransaction, TRUE);
            if (hwnd == hwndLast) {
                break;
            }
            hwnd = GetWindow(hwnd, GW_HWNDNEXT);
        } while (TRUE);
    } else {
        BOOL fRet;

        fRet = AbandonTransaction((HWND)hConv, pai, idTransaction, TRUE);
        TRACEAPIOUT((szT, "DdeAbandonTransaction:%x\n", fRet));
        return(fRet);
    }
    TRACEAPIOUT((szT, "DdeAbandonTransaction:1\n"));
    return(TRUE);
}



BOOL AbandonTransaction(
HWND hwnd,
PAPPINFO pai,
DWORD id,
BOOL fMarkOnly)
{
    PCLIENTINFO pci;
    PCQDATA pcqd;
    WORD err;


    SEMCHECKOUT();
    SEMENTER();

    pci = (PCLIENTINFO)GetWindowLong(hwnd, GWL_PCI);

    if (!pci->ci.fs & ST_CLIENT) {
        err = DMLERR_INVALIDPARAMETER;
failExit:
        SETLASTERROR(pai, err);
        SEMLEAVE();
        SEMCHECKOUT();
        return(FALSE);
    }

    do {
        /*
         * HACK: id == 0 -> all ids so we cycle
         */
        pcqd = (PCQDATA)Findqi(pci->pQ, id);

        if (!pcqd) {
            if (id) {
                err = DMLERR_UNFOUND_QUEUE_ID;
                goto failExit;
            }
            break;
        }
        if (fMarkOnly) {
            pcqd->xad.fAbandoned = TRUE;
            if (!id) {
                while (pcqd = (PCQDATA)FindNextQi(pci->pQ, (PQUEUEITEM)pcqd,
                        FALSE)) {
                    pcqd->xad.fAbandoned = TRUE;
                }
                break;
            }
        } else {
            if (pcqd->xad.pdata && pcqd->xad.pdata != 1 &&
                    !FindPileItem(pai->pHDataPile, CmpHIWORD,
                            (LPBYTE)&pcqd->xad.pdata, 0)) {

                FreeDDEData(LOWORD(pcqd->xad.pdata), pcqd->xad.pXferInfo->wFmt);
            }

            /*
             * Decrement the use count we incremented when the client started
             * this transaction.
             */
            FreeHsz(LOWORD(pcqd->XferInfo.hszItem));
            Deleteqi(pci->pQ, MAKEID(pcqd));
        }

    } while (!id);

    SEMLEAVE();
    SEMCHECKOUT();
    return(TRUE);
}



BOOL EXPENTRY DdeEnableCallback(
DWORD idInst,
HCONV hConv,
UINT wCmd)
{
    PAPPINFO pai;
    BOOL fRet;

    TRACEAPIIN((szT, "DdeEnableCallback(%lx, %lx, %x)\n",
            idInst, hConv, wCmd));

    pai = (PAPPINFO)idInst;
    if (pai == NULL || pai->instCheck != HIWORD(idInst)) {
        TRACEAPIOUT((szT, "DdeEnableCallback:0\n"));
        return(FALSE);
    }
    pai->LastError = DMLERR_NO_ERROR;

    if ((hConv && !ValidateHConv(hConv)) ||
            (wCmd & ~(EC_ENABLEONE | EC_ENABLEALL |
            EC_DISABLE | EC_QUERYWAITING))) {
        SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
        TRACEAPIOUT((szT, "DdeEnableCallback:0\n"));
        return(FALSE);
    }

    SEMCHECKOUT();

    if (wCmd & EC_QUERYWAITING) {
        PCBLI pli;
        int cWaiting = 0;

        SEMENTER();
        for (pli = (PCBLI)pai->plstCB->pItemFirst;
            pli && cWaiting < 2;
                pli = (PCBLI)pli->next) {
            if (hConv || pli->hConv == hConv) {
                cWaiting++;
            }
        }
        SEMLEAVE();
        fRet = cWaiting > 1 || (cWaiting == 1 && pai->cInProcess == 0);
        TRACEAPIOUT((szT, "DdeEnableCallback:%x\n", fRet));
        return(fRet);
    }

    /*
     * We depend on the fact that EC_ constants relate to ST_ constants.
     */
    if (hConv == NULL) {
        if (wCmd & EC_DISABLE) {
            pai->wFlags |= AWF_DEFCREATESTATE;
        } else {
            pai->wFlags &= ~AWF_DEFCREATESTATE;
        }
        ChildMsg(pai->hwndDmg, UM_SETBLOCK, wCmd, 0, FALSE);
    } else {
        SendMessage((HWND)hConv, UM_SETBLOCK, wCmd, 0);
    }

    if (!(wCmd & EC_DISABLE)) {

        // This is synchronous!  Fail if we made this from within a callback.

        if (pai->cInProcess) {
            SETLASTERROR(pai, DMLERR_REENTRANCY);
            TRACEAPIOUT((szT, "DdeEnableCallback:0\n"));
            return(FALSE);
        }

        SendMessage(pai->hwndDmg, UM_CHECKCBQ, 0, (DWORD)(LPSTR)pai);
    }

    TRACEAPIOUT((szT, "DdeEnableCallback:1\n"));
    return(TRUE); // TRUE implies the callback queue is free of unblocked calls.
}



HDDEDATA EXPENTRY DdeNameService(
DWORD idInst,
HSZ hsz1,
HSZ hsz2,
UINT afCmd)
{
    PAPPINFO pai;
    PPILE panp;

    TRACEAPIIN((szT, "DdeNameService(%lx, %lx, %lx, %x)\n",
            idInst, hsz1, hsz2, afCmd));

    pai = (PAPPINFO)idInst;
    if (pai == NULL || pai->instCheck != HIWORD(idInst)) {
        TRACEAPIOUT((szT, "DdeNameService:0\n"));
        return(FALSE);
    }
    pai->LastError = DMLERR_NO_ERROR;

    if (afCmd & DNS_FILTERON) {
        pai->afCmd |= APPCMD_FILTERINITS;
    }

    if (afCmd & DNS_FILTEROFF) {
        pai->afCmd &= ~APPCMD_FILTERINITS;
    }

    if (afCmd & (DNS_REGISTER | DNS_UNREGISTER)) {

        if (pai->afCmd & APPCMD_CLIENTONLY) {
            SETLASTERROR(pai, DMLERR_DLL_USAGE);
            TRACEAPIOUT((szT, "DdeNameService:0\n"));
            return(FALSE);
        }

        panp = pai->pAppNamePile;

        if (hsz1 == NULL) {
            if (afCmd & DNS_REGISTER) {
                /*
                 * registering NULL is not allowed!
                 */
                SETLASTERROR(pai, DMLERR_INVALIDPARAMETER);
                TRACEAPIOUT((szT, "DdeNameService:0\n"));
                return(FALSE);
            }
            /*
             * unregistering NULL is just like unregistering each
             * registered name.
             *
             * 10/19/90 - made this a synchronous event so that hsz
             * can be freed by calling app after this call completes
             * without us having to keep a copy around forever.
             */
            while (PopPileSubitem(panp, (LPBYTE)&hsz1)) {
                RegisterService(FALSE, (GATOM)hsz1, pai->hwndFrame);
                FreeHsz(LOWORD(hsz1));
            }
            TRACEAPIOUT((szT, "DdeNameService:1\n"));
            return(TRUE);
        }

        if (afCmd & DNS_REGISTER) {
            if (panp == NULL) {
                panp = pai->pAppNamePile =
                        CreatePile(pai->hheapApp, sizeof(HSZ), 8);
            }
            IncHszCount(LOWORD(hsz1));
            AddPileItem(panp, (LPBYTE)&hsz1, NULL);
        } else { // DNS_UNREGISTER
            FindPileItem(panp, CmpDWORD, (LPBYTE)&hsz1, FPI_DELETE);
        }
        // see 10/19/90 note above.
        RegisterService(afCmd & DNS_REGISTER ? TRUE : FALSE, (GATOM)hsz1,
                pai->hwndFrame);

        if (afCmd & DNS_UNREGISTER) {
            FreeHsz(LOWORD(hsz1));
        }

        TRACEAPIOUT((szT, "DdeNameService:1\n"));
        return(TRUE);
    }
    TRACEAPIOUT((szT, "DdeNameService:0\n"));
    return(0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ctl3dv2\version.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds          *
 *									    *
 *	This file is only modified by the official builder to update the    *
 *	VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 ****************************************************************************/

#ifndef VS_FF_DEBUG 
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <ver.h> 
#endif 

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/

#define VERSION 					"2.1.500"
#define VER_PRODUCTVERSION_STR		"2,1,5,0\0"
#define VER_PRODUCTVERSION			2,1,5,00

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\ddemlp.h ===
/****************************** Module Header ******************************\
* Module Name: DDEMLP.H
*
* Private header for DDE manager DLL.
*
* Created:      12/16/88    by Sanford Staab
* Modified for Win 3.0:       5/31/90    by Rich Gartland, Aldus
* Cleaned up:   11/14/90    Sanford Staab
*
* Copyright (c) 1988, 1989  Microsoft Corporation
* Copyright (c) 1990        Aldus Corporation
\***************************************************************************/
#define  NOGDICAPMASKS
#define  NOVIRTUALKEYCODES
#define  NOSYSMETRICS
#define  NOKEYSTATES
#define  OEMRESOURCE
#define  NOCOLOR
// #define  NOCTLMGR
#define  NODRAWTEXT
// #define  NOMETAFILE
#define  NOMINMAX
#define  NOSCROLL
#define  NOSOUND
#define  NOCOMM
#define  NOKANJI
#define  NOHELP
#define  NOPROFILER


#include <windows.h>
#include <dde.h>

#define DDEMLDB
#include <ddeml.h>

#ifdef DEBUG
extern int  bDbgFlags;
#define DBF_STOPONTRACE 0x01
#define DBF_TRACETERM   0x02
#define DBF_LOGALLOCS   0x04
#define DBF_TRACEATOMS  0x08
#define DBF_TRACEAPI    0x10

#define TRACETERM(x) if (bDbgFlags & DBF_TRACETERM) { \
    char szT[100];                              \
    wsprintf##x;                                \
    OutputDebugString(szT);                     \
    if (bDbgFlags & DBF_STOPONTRACE) {          \
        DebugBreak();                           \
    }                                           \
}
#define TRACETERMBREAK(x) if (bDbgFlags & DBF_TRACETERM) { \
    char szT[100];                              \
    wsprintf##x;                                \
    OutputDebugString(szT);                     \
    DebugBreak();                               \
}

VOID TraceApiIn(LPSTR psz);
#define TRACEAPIIN(x) if (bDbgFlags & DBF_TRACEAPI) { \
    char szT[100];                              \
    wsprintf##x;                                \
    TraceApiIn(szT);                            \
}

VOID TraceApiOut(LPSTR psz);
#define TRACEAPIOUT(x) if (bDbgFlags & DBF_TRACEAPI) { \
    char szT[100];                              \
    wsprintf##x;                                \
    TraceApiOut(szT);                           \
}
#else
#define TRACETERM(x)
#define TRACETERMBREAK(x)
#define TRACEAPIIN(x)
#define TRACEAPIOUT(x)
#endif

// PRIVATE CONSTANTS

#define     CBF_MASK                     0x003ff000L
#define     CBF_MONMASK                  0x0027f000L

#define     ST_TERM_WAITING     0x8000
#define     ST_NOTIFYONDEATH    0x4000
#define     ST_PERM2DIE         0x2000
#define     ST_IM_DEAD          0x1000
#define     ST_DISC_ATTEMPTED   0x0800
#define     ST_CHECKPARTNER     0x0400

#define     DDEFMT_TEXT         CF_TEXT

#define     TID_TIMEOUT             1
#define     TID_SHUTDOWN            2
#define     TID_EMPTYPOSTQ          4

#define     TIMEOUT_QUEUECHECK      200

//
// values for pai->wTimeoutStatus
//
#define     TOS_CLEAR               0x00
#define     TOS_TICK                0x01
#define     TOS_ABORT               0x02
#define     TOS_DONE                0x80

#define     GWL_PCI                 0          // ties conv windows to data.
#define     GWW_PAI                 0          // other windows have pai here.
#define     GWW_CHECKVAL            4          // for verification of hwnds.
#define     GWW_STATE               6          // conv list state

#define MH_INTCREATE 5
#define MH_INTKEEP   6
#define MH_INTDELETE 7

// MACROS

#define MAKEHCONV(hwnd)     (IsWindow(hwnd) ? hwnd | ((DWORD)GetWindowWord(hwnd, GWW_CHECKVAL) << 16) : 0)
#define UNUSED
#define max(a,b)    (((a) > (b)) ? (a) : (b))
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#define PHMEM(hData) ((LPBYTE)&((LPWORD)&(hData))[1])
#define MONHSZ(a, fsAction, hTask) if (cMonitor) MonHsz(a, fsAction, hTask)
#define MONERROR(pai, e) MonError(pai, e)
#define MONLINK(pai, fEst, fNoData, hszSvc, hszTopic, hszItem, wFmt, fServer, hConvS, hConvC) \
        if (cMonitor) \
            MonLink(pai, fEst, fNoData, hszSvc, hszTopic, \
                    hszItem, wFmt, fServer, hConvS, hConvC)
#define MONCONN(pai, hszSvcInst, hszTopic, hwndC, hwndS, fConnect) \
        if (cMonitor) \
            MonConn(pai, hszSvcInst, hszTopic, hwndC, hwndS, fConnect)

#define SETLASTERROR(pai, e)  MonError(pai, e)
#define SEMCHECKIN()
#define SEMCHECKOUT()
#define SEMENTER()
#define SEMLEAVE()
#define SEMINIT()

#ifdef DEBUG

VOID _loadds fAssert(BOOL f, LPSTR psz, WORD line, LPSTR szFile, BOOL fWarning);
#define AssertF(f, psz)  fAssert(f, psz, __LINE__, __FILE__, FALSE);
#define AssertFW(f, psz) fAssert(f, psz, __LINE__, __FILE__, TRUE);
#define DEBUGBREAK() DebugBreak()
#define GLOBALREALLOC   LogGlobalReAlloc
#define GLOBALALLOC     LogGlobalAlloc
#define GLOBALFREE      LogGlobalFree
#define GLOBALLOCK      LogGlobalLock
#define GLOBALUNLOCK    LogGlobalUnlock
#include "heapwach.h"

#else

#define AssertF(f, psz)
#define AssertFW(f, psz)
#define DEBUGBREAK()
#define GLOBALREALLOC   GlobalReAlloc
#define GLOBALALLOC     GlobalAlloc
#define GLOBALFREE      GlobalFree
#define GLOBALLOCK      GlobalLock
#define GLOBALUNLOCK    GlobalUnlock

#endif /* DEBUG */
#define GLOBALPTR(h)    (LPVOID)MAKELONG(0,h)


typedef ATOM GATOM;
typedef ATOM LATOM;

// -------------- LISTS --------------


typedef struct _LITEM {         // generic list item
    struct _LITEM FAR *next;
} LITEM;
typedef LITEM FAR *PLITEM;

typedef struct _LST {           // generic list header
    PLITEM pItemFirst;
    HANDLE hheap;
    WORD cbItem;
} LST;
typedef LST FAR *PLST;

#define ILST_LAST       0x0000  // flags for list lookups
#define ILST_FIRST      0x0001
#define ILST_NOLINK     0x0002


typedef struct _HSZLI {     // HSZ list item
    PLITEM next;
    ATOM a;
} HSZLI;

typedef struct _HWNDLI {    // HWND list item
    PLITEM next;
    HWND   hwnd;
} HWNDLI;

typedef struct _ACKHWNDLI { // extra ACK list item
    PLITEM next;
    HWND   hwnd;            // same as HWNDLI to here
    HSZ    hszSvc;
    HSZ    aTopic;
} ACKHWNDLI;

typedef struct _HWNDHSZLI { // HWND-HSZ pair list item
    PLITEM next;
    ATOM   a;             // same as HSZLI to here
    HWND   hwnd;
} HWNDHSZLI;
typedef HWNDHSZLI FAR *PHWNDHSZLI;

typedef struct _ADVLI {     // ADVISE loop list item
    PLITEM  next;
    ATOM    aItem;          // same as HSZLI to here
    ATOM    aTopic;
    WORD    wFmt;
    WORD    fsStatus;       // used to remember NODATA and FACKREQ state */
    HWND    hwnd;           // hwnd that has advise loop
} ADVLI;
typedef ADVLI FAR *PADVLI;



// ------------ PILES -------------


typedef struct _PILEB {      // generic pile block header
    struct _PILEB FAR *next; // same as LITEM structure
    WORD cItems;
    WORD reserved;
} PILEB;
typedef PILEB FAR *PPILEB;

typedef struct PILE {        // generic pile header
    PPILEB pBlockFirst;
    HANDLE hheap;
    WORD cbBlock;            // same as LST structure
    WORD cSubItemsMax;
    WORD cbSubItem;
} PILE;
typedef PILE FAR *PPILE;

typedef BOOL (*NPFNCMP)(LPBYTE, LPBYTE);    // item comparison function pointer

#define PTOPPILEITEM(p) ((LPBYTE)p->pBlockFirst + sizeof(PILEB))

#define FPI_DELETE 0x1      // pile search flags
#define FPI_COUNT  0x2

#define API_ADDED  1        // AddPileItem flags
#define API_FOUND  2
#define API_ERROR  0

typedef struct _DIP {   /* Data handle tracking pile */
    HANDLE  hData;      /* the handle to the data */
    HANDLE  hTask;      /* task owning the data */
    WORD    cCount;     /* use count = # datapiles using the handle */
    WORD    fFlags;     /* readonly, etc. */
} DIP;


typedef struct _LAP {   /* Lost Ack Pile item */
    WORD object;        /* either a handle or an atom */
    WORD type;          /* transaction type the ack was meant for */
} LAP;


/*
 * These bits are used to keep track of advise loop states.
 */
#define ADVST_WAITING   0x0080  /* fReserved bit - set if still waiting for FACK */
#define ADVST_CHANGED   0x0040  /* fReserved bit - set if data changed while waiting */



// ------------ QUEUES -------------


typedef struct _QUEUEITEM {         // generic queue item
    struct _QUEUEITEM FAR *next;
    struct _QUEUEITEM FAR *prev;
    WORD   inst;
} QUEUEITEM;
typedef QUEUEITEM FAR *PQUEUEITEM;

typedef struct _QST {               // generic queue header
    WORD cItems;
    WORD instLast;
    WORD cbItem;
    HANDLE hheap;
    PQUEUEITEM pqiHead;
} QST;
typedef QST FAR *PQST;

#define MAKEID(pqd) (LOWORD((DWORD)pqd) + ((DWORD)((pqd)->inst) << 16))
#define PFROMID(pQ, id) ((PQUEUEITEM)MAKELONG(LOWORD(id), HIWORD(pQ)))

#define     QID_NEWEST              -2L
#define     QID_OLDEST              0L


// ------------- STRUCTURES -------------

typedef struct _PMQI {    // post message queue
    PQUEUEITEM FAR *next;
    PQUEUEITEM FAR *prev;
    WORD inst;              // same as QUEUEITEM to here!
    WORD msg;
    LONG lParam;
    WORD wParam;
    HWND hwndTo;
    HGLOBAL hAssoc;
    WORD msgAssoc;
} PMQI;
typedef PMQI FAR *PPMQI;

typedef struct _MQL {   // message queue list
    struct _MQL FAR*next;
    HANDLE hTaskTo;
    PQST pMQ;
} MQL, FAR *LPMQL;

typedef struct _XFERINFO {  // DdeClientTransaction parameters reversed!!!
    LPDWORD     pulResult;  // sync->flags, async->ID
    DWORD       ulTimeout;
    WORD        wType;
    WORD        wFmt;
    HSZ         hszItem;
    HCONV       hConvClient;
    DWORD       cbData;
    HDDEDATA    hDataClient;
} XFERINFO;
typedef XFERINFO FAR *PXFERINFO;

typedef struct _XADATA {      // internal transaction specif info
    WORD       state;         // state of this transaction (XST_)
    WORD       LastError;     // last error logged in this transaction
    DWORD      hUser;         // set with DdeSetUserHandle
    PXFERINFO  pXferInfo;     // associated transaction info
    DWORD      pdata;         // data for the client from the server
    WORD       DDEflags;      // DDE flags resulting from transaction
    BOOL       fAbandoned;    // set if this transaction is abandoned.
} XADATA;
typedef XADATA FAR *PXADATA;

typedef struct _CQDATA {   // Client transaction queue
    PQUEUEITEM FAR *next;
    PQUEUEITEM FAR *prev;
    WORD            inst;
    XADATA          xad;
    XFERINFO        XferInfo;
} CQDATA;
typedef CQDATA FAR *PCQDATA;

typedef struct _APPINFO {               // App wide information
    struct  _APPINFO *next;             // local heap object
    WORD            cZombies;           // number of hwnd's awaiting terminates
    PFNCALLBACK     pfnCallback;        // callback address
    PPILE           pAppNamePile;       // registered service names list
    PPILE           pHDataPile;         // data handles not freed
    PPILE           pHszPile;           // hsz cleanup tracking pile.
    HWND            hwndSvrRoot;        // root of all server windows.
    PLST            plstCB;             // callback queue
    DWORD           afCmd;              // app filter and command flags
    HANDLE          hTask;              // app task
    HANDLE          hheapApp;           // app heap
    HWND            hwndDmg;            // main app window
    HWND            hwndFrame;          // main app initiate window
    HWND            hwndMonitor;        // monitor window
    HWND            hwndTimer;          // current timer window
    WORD            LastError;          // last error
    WORD            wFlags;             // set to ST_BLOCKED or not.
    WORD            cInProcess;         // recursion guard
    WORD            instCheck;          // to validate idInst param.
    PLST            pServerAdvList;     // active ADVISE loops for servers
    LPSTR           lpMemReserve;       // reserve memory in case of crunch
    WORD            wTimeoutStatus;     // used to alert timeout modal loop
} APPINFO;
typedef APPINFO *PAPPINFO;              // local heap object
typedef APPINFO FAR *LPAPPINFO;
typedef PAPPINFO FAR *LPPAPPINFO;

#define LPCREATESTRUCT_GETPAI(lpcs) (*((LPPAPPINFO)(((LPCREATESTRUCT)lpcs)->lpCreateParams)))

// defines for wFlags field

#define AWF_DEFCREATESTATE      0x0001
#define AWF_INSYNCTRANSACTION   0x0002
#define AWF_UNINITCALLED        0x0004
#define AWF_INPOSTDDEMSG        0x0008

#define CB_RESERVE              256     // size of memory reserve block

typedef struct _COMMONINFO {    // Common (client & server) Conversation info
    PAPPINFO   pai;             // associated app info
    HSZ        hszSvcReq;       // app name used to make connection
    ATOM       aServerApp;      // app name returned by server
    ATOM       aTopic;          // conversation topic returned by server
    HCONV      hConvPartner;    // conversation partner window
    XADATA     xad;             // synchronous transaction data
    WORD       fs;              // conversation status (ST_ flags)
    HWND       hwndFrame;       // initiate window used to make connection
    CONVCONTEXT CC;             // conversation context values
    PQST       pPMQ;            // post message queue - if needed.
} COMMONINFO;
typedef COMMONINFO far *PCOMMONINFO;

typedef struct _CBLI {      /* callback list item */
    PLITEM next;
    HCONV hConv;            /* perameters for callback */
    HSZ hszTopic;
    HSZ hszItem;
    WORD wFmt;
    WORD wType;
    HDDEDATA hData;
    DWORD dwData1;
    DWORD dwData2;
    WORD msg;               /* message received that created this item */
    WORD fsStatus;          /* Status from DDE msg */
    HWND hwndPartner;
    PAPPINFO pai;
    HANDLE hMemFree;        /* used for holding memory to free after callback */
    BOOL fQueueOnly;        /* used to properly order replies to non-callback cases. */
} CBLI;
typedef CBLI FAR *PCBLI;

typedef struct _CLIENTINFO {    /* Client specific conversation info */
    COMMONINFO ci;
    HWND       hwndInit;        // frame window last INITIATE was sent to.
    PQST       pQ;              // assync transaction queue
    PLST       pClientAdvList;  // active ADVISE loops for client
} CLIENTINFO;
typedef CLIENTINFO FAR *PCLIENTINFO;

typedef struct _SERVERINFO {    /* Server specific conversation info */
    COMMONINFO ci;
} SERVERINFO;
typedef SERVERINFO FAR *PSERVERINFO;

typedef struct _EXTDATAINFO {   /* used to tie instance info to hDatas */
    PAPPINFO pai;
    HDDEDATA hData;
} EXTDATAINFO;
typedef EXTDATAINFO FAR *LPEXTDATAINFO;

#define EXTRACTHCONVPAI(hConv)    ((PCLIENTINFO)GetWindowLong((HWND)hConv, GWL_PCI))->ci.pai
#define EXTRACTHCONVLISTPAI(hcl)  (PAPPINFO)GetWindowWord((HWND)hcl, GWW_PAI)
#define EXTRACTHDATAPAI(XhData)   ((LPEXTDATAINFO)(XhData))->pai
#define FREEEXTHDATA(XhData)      FarFreeMem((LPSTR)XhData);

typedef struct _DDE_DATA {
    WORD wStatus;
    WORD wFmt;
    WORD wData;
} DDE_DATA, FAR *LPDDE_DATA;


/******** structure for hook functions *******/

typedef struct _HMSTRUCT {
    WORD    hlParam;
    WORD    llParam;
    WORD    wParam;
    WORD    wMsg;
    WORD    hWnd;
} HMSTRUCT, FAR *LPHMSTRUCT;


typedef struct _IE {   // InitEnum structure used to pass data to the fun.
    HWND hwnd;
    PCLIENTINFO pci;
    ATOM aTopic;
} IE;

/***** private window messages and constants ******/

#define     HDATA_READONLY          0x8000
#define     HDATA_NOAPPFREE         0x4000   // set on loaned handles (callback)
#define     HDATA_EXEC              0x0100   // this data was from execute

#define     UMSR_POSTADVISE         (WM_USER + 104)
#define     UMSR_CHGPARTNER         (WM_USER + 107)

#define     UM_REGISTER             (WM_USER + 200)
#define     UM_UNREGISTER           (WM_USER + 201)
#define     UM_MONITOR              (WM_USER + 202)
#define     UM_QUERY                (WM_USER + 203)
#define         Q_CLIENT            0
#define         Q_APPINFO           1
#define     UM_CHECKCBQ             (WM_USER + 204)
#define     UM_DISCONNECT           (WM_USER + 206)
#define     UM_SETBLOCK             (WM_USER + 207)
#define     UM_FIXHEAP              (WM_USER + 208)
#define     UM_TERMINATE            (WM_USER + 209)


// GLOBALS

extern HANDLE       hInstance;
extern HWND         hwndDmgMonitor;
extern HANDLE       hheapDmg;
extern PAPPINFO     pAppInfoList;
extern PPILE        pDataInfoPile;
extern PPILE        pLostAckPile;
extern WORD         hwInst;
extern DWORD        aulmapType[];
extern CONVCONTEXT  CCDef;
extern char         szNull[];
extern WORD         cMonitor;
extern FARPROC      prevMsgHook;
extern FARPROC      prevCallHook;
extern DWORD        ShutdownTimeout;
extern DWORD        ShutdownRetryTimeout;
extern LPMQL        gMessageQueueList;

extern char SZFRAMECLASS[];
extern char SZDMGCLASS[];
extern char SZCLIENTCLASS[];
extern char SZSERVERCLASS[];
extern char SZMONITORCLASS[];
extern char SZCONVLISTCLASS[];
extern char SZHEAPWATCHCLASS[];






//#ifdef DEBUG
extern WORD cAtoms;
//#endif

// PROGMAN HACK!!!!
extern ATOM aProgmanHack;

// PROC DEFS

/* from dmgutil.asm */

LPBYTE NEAR HugeOffset(LPBYTE pSrc, DWORD cb);
#ifdef DEBUG
VOID StkTrace(WORD cFrames, LPVOID lpBuf);
#endif
extern WORD NEAR SwitchDS(WORD newDS);

/* dmg.c entrypoints are exported by ddeml.h */

/* from ddeml.c */

WORD Register(LPDWORD pidInst, PFNCALLBACK pfnCallback, DWORD afCmd);
BOOL AbandonTransaction(HWND hwnd, PAPPINFO pai, DWORD id, BOOL fMarkOnly);

/* from dmgwndp.c */

VOID ChildMsg(HWND hwndParent, WORD msg, WORD wParam, DWORD lParam, BOOL fPost);
long EXPENTRY DmgWndProc(HWND hwnd, WORD msg, WORD wParam, DWORD lParam);
long EXPENTRY ClientWndProc(HWND hwnd, WORD msg, WORD wParam, DWORD lParam);
BOOL DoClientDDEmsg(PCLIENTINFO pci, HWND hwndClient, WORD msg, HWND hwndServer,
        DWORD lParam);
BOOL fExpectedMsg(PXADATA pXad, DWORD lParam, WORD msg);
BOOL AdvanceXaction(HWND hwnd, PCLIENTINFO pci, PXADATA pXad,
        DWORD lParam, WORD msg, LPWORD pErr);
VOID CheckCBQ(PAPPINFO pai);
VOID Disconnect(HWND hwnd, WORD afCmd, PCLIENTINFO pci);
VOID Terminate(HWND hwnd, HWND hwndFrom, PCLIENTINFO pci);
long EXPENTRY ServerWndProc(HWND hwnd, WORD msg, WORD wParam, DWORD lParam);
long EXPENTRY subframeWndProc(HWND hwnd, WORD msg, WORD wParam, DWORD lParam);
long EXPENTRY ConvListWndProc(HWND hwnd, WORD msg, WORD wParam, DWORD lParam);
HDDEDATA DoCallback(PAPPINFO pai, HCONV hConv, HSZ hszTopic, HSZ hszItem,
    WORD wFmt, WORD wType, HDDEDATA hData, DWORD dwData1, DWORD dwData2);

/* from dmgdde.c */

BOOL    timeout(PAPPINFO pai, DWORD ulTimeout, HWND hwndTimeout);
HANDLE AllocDDESel(WORD fsStatus, WORD wFmt, DWORD cbData);
BOOL    MakeCallback(PCOMMONINFO pci, HCONV hConv, HSZ hszTopic, HSZ hszItem,
        WORD wFmt, WORD wType, HDDEDATA hData, DWORD dwData1, DWORD dwData2,
        WORD msg, WORD fsStatus, HWND hwndPartner, HANDLE hMemFree,
        BOOL fQueueOnly);
BOOL PostDdeMessage(PCOMMONINFO pci, WORD msg, HWND hwndFrom, LONG lParam,
        WORD msgAssoc, HGLOBAL hAssoc);
BOOL EmptyDDEPostQ(VOID);
void CALLBACK EmptyQTimerProc(HWND hwnd, UINT msg, UINT tid, DWORD dwTime);

/* from dmgmon.c */

//#ifdef DEBUG
long EXPENTRY DdePostHookProc(int nCode, WORD wParam, LPMSG lParam);
long EXPENTRY DdeSendHookProc(int nCode, WORD wParam, LPHMSTRUCT lParam);
VOID    MonBrdcastCB(PAPPINFO pai, WORD wType, WORD wFmt, HCONV hConv,
        HSZ hszTopic, HSZ hszItem, HDDEDATA hData, DWORD dwData1,
        DWORD dwData2, DWORD dwRet);
VOID MonHsz(ATOM a, WORD fsAction, HANDLE hTask);
WORD MonError(PAPPINFO pai, WORD error);
VOID MonLink(PAPPINFO pai, BOOL fEstablished, BOOL fNoData, HSZ  hszSvc,
        HSZ  hszTopic, HSZ  hszItem, WORD wFmt, BOOL fServer,
        HCONV hConvServer, HCONV hConvClient);
VOID MonConn(PAPPINFO pai, ATOM aApp, ATOM aTopic, HWND hwndClient,
        HWND hwndServer, BOOL fConnect);
VOID MonitorBroadcast(HDDEDATA hData, WORD filter);
HDDEDATA allocMonBuf(WORD cb, WORD filter);
long EXPENTRY MonitorWndProc(HWND hwnd, WORD msg, WORD wParam, DWORD lParam);
//#endif

/* from dmghsz.c */

BOOL FreeHsz(ATOM a);
BOOL IncHszCount(ATOM a);
WORD QueryHszLength(HSZ hsz);
WORD QueryHszName(HSZ hsz, LPSTR psz, WORD cchMax);
ATOM FindAddHsz(LPSTR psz, BOOL fAdd);
HSZ MakeInstAppName(ATOM a, HWND hwndFrame);


/* from dmgdb.c */

PAPPINFO GetCurrentAppInfo(PAPPINFO);
VOID UnlinkAppInfo(PAPPINFO pai);

PLST CreateLst(HANDLE hheap, WORD cbItem);
VOID DestroyLst(PLST pLst);
VOID DestroyAdvLst(PLST pLst);
VOID CleanupAdvList(HWND hwndClient, PCLIENTINFO pci);
PLITEM FindLstItem(PLST pLst, NPFNCMP npfnCmp, PLITEM piSearch);
BOOL CmpWORD(LPBYTE pb1, LPBYTE pb2);
BOOL CmpHIWORD(LPBYTE pb1, LPBYTE pb2);
BOOL CmpDWORD(LPBYTE pb1, LPBYTE pb2);
PLITEM NewLstItem(PLST pLst, WORD afCmd);
BOOL RemoveLstItem(PLST pLst, PLITEM pi);

PPILE CreatePile(HANDLE hheap, WORD cbItem, WORD cItemsPerBlock);
PPILE DestroyPile(PPILE pPile);
WORD QPileItemCount(PPILE pPile);
LPBYTE FindPileItem(PPILE pPile, NPFNCMP npfnCmp, LPBYTE pbSearch, WORD afCmd);
WORD AddPileItem(PPILE pPile, LPBYTE pb, NPFNCMP npfncmp);
BOOL PopPileSubitem(PPILE pPile, LPBYTE pb);

VOID AddHwndHszList(ATOM a, HWND hwnd, PLST pLst);
VOID DestroyHwndHszList(PLST pLst);
HWND HwndFromHsz(ATOM a, PLST pLst);

BOOL CmpAdv(LPBYTE pb1, LPBYTE pb2);
WORD CountAdvReqLeft(register PADVLI pali);
BOOL AddAdvList(PLST pLst, HWND hwnd, ATOM aTopic, ATOM aItem, WORD fsStatus, WORD usFormat);
BOOL DeleteAdvList(PLST pLst, HWND hwnd, ATOM aTopic, ATOM aItem, WORD wFmt);
PADVLI FindAdvList(PLST pLst, HWND hwnd, ATOM aTopic, ATOM aItem, WORD wFmt);
PADVLI FindNextAdv(PADVLI padvli, HWND hwnd, ATOM aTopic, ATOM aItem);

VOID SemInit(VOID);
VOID SemCheckIn(VOID);
VOID SemCheckOut(VOID);
VOID SemEnter(VOID);
VOID SemLeave(VOID);

BOOL CopyHugeBlock(LPBYTE pSrc, LPBYTE pDst, DWORD cb);
BOOL DmgDestroyWindow(HWND hwnd);
BOOL ValidateHConv(HCONV hConv);

/* from dmgq.c */

PQST CreateQ(WORD cbItem);
BOOL DestroyQ(PQST pQ);
PQUEUEITEM Addqi(PQST pQ);
VOID Deleteqi(PQST pQ, DWORD id);
PQUEUEITEM Findqi(PQST pQ, DWORD id);
PQUEUEITEM FindNextQi(PQST pQ, PQUEUEITEM pqi, BOOL fDelete);

/* from dmgmem.c */
HANDLE DmgCreateHeap(WORD wSize);
HANDLE DmgDestroyHeap(HANDLE hheap);
LPVOID FarAllocMem(HANDLE hheap, WORD wSize);
VOID FarFreeMem(LPVOID lpMem);
VOID RegisterClasses(VOID);
// VOID UnregisterClasses(VOID);
#ifdef DEBUG
HGLOBAL LogGlobalReAlloc(HGLOBAL h, DWORD cb, UINT flags);
HGLOBAL LogGlobalAlloc(UINT flags, DWORD cb);
void FAR * LogGlobalLock(HGLOBAL h);
BOOL LogGlobalUnlock(HGLOBAL h);
HGLOBAL LogGlobalFree(HGLOBAL h);
VOID LogDdeObject(UINT msg, LONG lParam);
VOID DumpGlobalLogs(VOID);
#endif

/* from hData.c */

HDDEDATA PutData(LPBYTE pSrc, DWORD cb, DWORD cbOff, ATOM aItem, WORD wFmt,
        WORD afCmd, PAPPINFO pai);
VOID FreeDataHandle(PAPPINFO pai,  HDDEDATA hData, BOOL fInternal);
HDDEDATA DllEntry(PCOMMONINFO pcomi, HDDEDATA hData);
VOID XmitPrep(HDDEDATA hData, PAPPINFO pai);
HDDEDATA RecvPrep(PAPPINFO pai, HANDLE hMem, WORD afCmd);
HANDLE CopyDDEShareHandle(HANDLE hMem);
HBITMAP CopyBitmap(PAPPINFO pai, HBITMAP hbm);
HDDEDATA CopyHDDEDATA(PAPPINFO pai, HDDEDATA hData);
VOID FreeDDEData(HANDLE hMem, WORD wFmt);


/* from stdinit.c */

long ClientCreate(HWND hwnd, PAPPINFO pai);
HWND GetDDEClientWindow(PAPPINFO pai, HWND hwndParent, HWND hwndSend, HSZ hszSvc, ATOM aTopic, PCONVCONTEXT pCC);
BOOL FAR PASCAL InitEnum(HWND hwnd, IE FAR *pie);
HWND CreateServerWindow(PAPPINFO pai, ATOM aTopic, PCONVCONTEXT pCC);
VOID ServerFrameInitConv(PAPPINFO pai, HWND hwndFrame, HWND hwndClient, ATOM aApp, ATOM aTopic);
long ServerCreate(HWND hwnd, PAPPINFO pai);
BOOL ClientInitAck(HWND hwnd, PCLIENTINFO pci, HWND hwndServer,
        ATOM aApp, ATOM aTopic);


/* from stdptcl.c */

long ClientXferReq(PXFERINFO pXferInfo, HWND hwnd, PCLIENTINFO pci);
WORD SendClientReq(PAPPINFO pai, PXADATA pXad, HWND hwndServer, HWND hwnd);
VOID ServerProcessDDEMsg(PSERVERINFO psi, WORD msg, HWND hwndServer,
        HWND hwndClient, WORD lo, WORD hi);
VOID PostServerAdvise(HWND hwnd, PSERVERINFO psi, PADVLI pali, WORD cLoops);
VOID QReply(PCBLI pcbi, HDDEDATA hDataRet);
long ClientXferRespond(HWND hwndClient, PXADATA pXad, LPWORD pErr);

/* from register.c */

LRESULT ProcessRegistrationMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
VOID RegisterService(BOOL fRegister, GATOM gaApp, HWND hwndListen);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\dmgdb.c ===
/****************************** Module Header ******************************\
* Module Name: DMGDB.C
*
* DDE manager data handling routines
*
* Created: 12/14/88 Sanford Staab
*
* Copyright (c) 1988, 1989  Microsoft Corporation
\***************************************************************************/
#include "ddemlp.h"

/***************************** Private Function ****************************\
* PAPPINFO GetCurrentAppInfo()
*
* DESCRIPTION:
* This routine uses the pid of the current thread to locate the information
* pertaining to that thread.  If not found, 0 is returned.
*
* This call fails if the DLL is in a callback state to prevent recursion.
* if fChkCallback is set.
*
* History:      1/1/89  Created         sanfords
\***************************************************************************/
PAPPINFO GetCurrentAppInfo(
PAPPINFO paiStart)
{
    register PAPPINFO pai;
    HANDLE hTaskCurrent;

    SEMENTER();
    if (pAppInfoList == NULL) {
        SEMLEAVE();
        return(0);
    }
    pai = paiStart ? paiStart->next : pAppInfoList;
    hTaskCurrent = GetCurrentTask();
    while (pai) {
        if (pai->hTask == hTaskCurrent) {
            SEMLEAVE();
            return(pai);
        }
        pai = pai->next;
    }
    SEMLEAVE();
    return(0);
}


/***************************** Private Function ****************************\
* void UnlinkAppInfo(pai)
* PAPPINFO pai;
*
* DESCRIPTION:
*   unlinks an pai safely.  Does nothing if not linked.
*
* History:      1/1/89  Created         sanfords
\***************************************************************************/
void UnlinkAppInfo(pai)
PAPPINFO pai;
{
    PAPPINFO paiT;

    AssertF(pai != NULL, "UnlinkAppInfo - NULL input");
    SEMENTER();
    if (pai == pAppInfoList) {
        pAppInfoList = pai->next;
        SEMLEAVE();
        return;
    }
    paiT = pAppInfoList;
    while (paiT && paiT->next != pai)
        paiT = paiT->next;
    if (paiT)
        paiT->next = pai->next;
    SEMLEAVE();
    return;
}





/***************************** Private Functions ***************************\
* General List management functions.
*
* History:
*   Created     12/15/88    sanfords
\***************************************************************************/
PLST CreateLst(hheap, cbItem)
HANDLE hheap;
WORD cbItem;
{
    PLST pLst;

    SEMENTER();
    if (!(pLst = (PLST)FarAllocMem(hheap, sizeof(LST)))) {
        SEMLEAVE();
        return(NULL);
    }
    pLst->hheap = hheap;
    pLst->cbItem = cbItem;
    pLst->pItemFirst = (PLITEM)NULL;
    SEMLEAVE();
    return(pLst);
}




void DestroyLst(pLst)
PLST pLst;
{
    if (pLst == NULL)
        return;
    SEMENTER();
    while (pLst->pItemFirst)
        RemoveLstItem(pLst, pLst->pItemFirst);
    FarFreeMem((LPSTR)pLst);
    SEMLEAVE();
}



void DestroyAdvLst(pLst)
PLST pLst;
{
    if (pLst == NULL)
        return;
    SEMENTER();
    while (pLst->pItemFirst) {
        FreeHsz(((PADVLI)(pLst->pItemFirst))->aItem);
        RemoveLstItem(pLst, pLst->pItemFirst);
    }
    FarFreeMem((LPSTR)pLst);
    SEMLEAVE();
}



PLITEM FindLstItem(pLst, npfnCmp, piSearch)
PLST pLst;
NPFNCMP npfnCmp;
PLITEM piSearch;
{
    PLITEM pi;

    if (pLst == NULL)
        return(NULL);
    SEMENTER();
    pi = pLst->pItemFirst;
    while (pi) {
        if ((*npfnCmp)((LPBYTE)pi + sizeof(LITEM), (LPBYTE)piSearch + sizeof(LITEM))) {
            SEMLEAVE();
            return(pi);
        }
        pi = pi->next;
    }
    SEMLEAVE();
    return(pi);
}



/*
 * Comparison functions for FindLstItem() and FindPileItem()
 */

BOOL CmpDWORD(pb1, pb2)
LPBYTE pb1;
LPBYTE pb2;
{
    return(*(LPDWORD)pb1 == *(LPDWORD)pb2);
}


BOOL CmpWORD(pb1, pb2)
LPBYTE pb1;
LPBYTE pb2;
{
    return(*(LPWORD)pb1 == *(LPWORD)pb2);
}

BOOL CmpHIWORD(pb1, pb2)
LPBYTE pb1;
LPBYTE pb2;
{
    return(*(LPWORD)(pb1 + 2) == *(LPWORD)(pb2 + 2));
}





/***************************** Private Function ****************************\
* This routine creates a new list item for pLst and links it in according
* to the ILST_ constant in afCmd.  Returns a pointer to the new item
* or NULL on failure.
*
* Note:  This MUST be in the semaphore for use since the new list item
* is filled with garbage on return yet is linked in.
*
*
* History:
*   Created     9/12/89    Sanfords
\***************************************************************************/
PLITEM NewLstItem(pLst, afCmd)
PLST pLst;
WORD afCmd;
{
    PLITEM pi, piT;

    if (pLst == NULL)
        return(NULL);
    SEMCHECKIN();

    pi = (PLITEM)FarAllocMem(pLst->hheap, pLst->cbItem + sizeof(LITEM));
    if (pi == NULL) {
        AssertF(FALSE, "NewLstItem - memory failure");
        return(NULL);
    }

    if (afCmd & ILST_NOLINK)
        return(pi);

    if (((piT = pLst->pItemFirst) == NULL) || (afCmd & ILST_FIRST)) {
        pi->next = piT;
        pLst->pItemFirst = pi;
    } else {                            /* ILST_LAST assumed */
        while (piT->next != NULL)
            piT = piT->next;
        piT->next = pi;
        pi->next = NULL;
    }
    return(pi);
}



/***************************** Private Function ****************************\
* This routine unlinks and frees pi from pLst.  If pi cannot be located
* within pLst, it is freed anyway.
*
* History:
*   Created     9/12/89    Sanfords
\***************************************************************************/
BOOL RemoveLstItem(pLst, pi)
PLST pLst;
PLITEM pi;
{
    PLITEM piT;

    if (pLst == NULL || pi == NULL)
        return(FALSE);

    SEMCHECKIN();

    if ((piT = pLst->pItemFirst) != NULL) {
        if (pi == piT) {
            pLst->pItemFirst = pi->next;
        } else {
            while (piT->next != pi && piT->next != NULL)
                piT = piT->next;
            if (piT->next != NULL)
                piT->next = pi->next; /* unlink */
        }
    } else {
        AssertF(FALSE, "Improper list item removal");
        return(FALSE);
    }
    FarFreeMem((LPSTR)pi);
    return(TRUE);
}





/*
 * ------------- Specific list routines -------------
 */

/***************************** Private Function ****************************\
* hwnd-hsz list functions
*
* History:      1/20/89     Created         sanfords
\***************************************************************************/
void AddHwndHszList(
ATOM a,
HWND hwnd,
PLST pLst)
{
    PHWNDHSZLI phhi;

    AssertF(pLst->cbItem == sizeof(HWNDHSZLI), "AddHwndHszList - Bad item size");
    SEMENTER();
    if (!a || (BOOL)HwndFromHsz(a, pLst)) {
        SEMLEAVE();
        return;
    }
    phhi = (PHWNDHSZLI)NewLstItem(pLst, ILST_FIRST);
    phhi->hwnd = hwnd;
    phhi->a = a;
    IncHszCount(a); // structure copy
    SEMLEAVE();
}


void DestroyHwndHszList(pLst)
PLST pLst;
{
    if (pLst == NULL)
        return;
    AssertF(pLst->cbItem == sizeof(HWNDHSZLI), "DestroyHwndHszList - Bad item size");
    SEMENTER();
    while (pLst->pItemFirst) {
        FreeHsz(((PHWNDHSZLI)pLst->pItemFirst)->a);
        RemoveLstItem(pLst, pLst->pItemFirst);
    }
    FarFreeMem((LPSTR)pLst);
    SEMLEAVE();
}



HWND HwndFromHsz(
ATOM a,
PLST pLst)
{
    HWNDHSZLI hhli;
    PHWNDHSZLI phhli;

    hhli.a = a;
    if (!(phhli = (PHWNDHSZLI)FindLstItem(pLst, CmpWORD, (PLITEM)&hhli)))
        return(NULL);
    return(phhli->hwnd);
}



/***************************** Private Function ****************************\
* DESCRIPTION:
*   Advise list helper functions.
*
* History:      1/20/89     Created         sanfords
\***************************************************************************/
/*
 * This will match an exact hsz/fmt pair with a 0 format or 0 item or 0 hwnd
 * being wild.
 */
BOOL CmpAdv(
LPBYTE pb1, // entry being compared
LPBYTE pb2) // search for
{
    PADVLI pali1 = (PADVLI)(pb1 - sizeof(LITEM));
    PADVLI pali2 = (PADVLI)(pb2 - sizeof(LITEM));

    if (pali2->aTopic == 0 || pali1->aTopic == pali2->aTopic) {
        if (pali2->hwnd == 0 || pali1->hwnd == pali2->hwnd) {
            if (pali2->aItem == 0 || pali1->aItem == pali2->aItem ) {
                if (pali2->wFmt == 0 || pali1->wFmt == pali2->wFmt) {
                    return(TRUE);
                }
            }
        }
    }

    return(FALSE);
}


WORD CountAdvReqLeft(
PADVLI pali)
{
    ADVLI aliKey;
    register WORD cLoops = 0;

    SEMENTER();
    aliKey = *pali;
    aliKey.hwnd = 0;    // all hwnds
    pali = (PADVLI)aliKey.next;
    while (pali) {
        if (CmpAdv(((LPBYTE)pali) + sizeof(LITEM),
                ((LPBYTE)&aliKey) + sizeof(LITEM))) {
            cLoops++;
        }
        pali = (PADVLI)pali->next;
    }
    SEMLEAVE();
    return(cLoops);
}

BOOL AddAdvList(
PLST pLst,
HWND hwnd,
ATOM aTopic,
ATOM aItem,
WORD fsStatus,
WORD wFmt)
{
    PADVLI pali;

    AssertF(pLst->cbItem == sizeof(ADVLI), "AddAdvList - bad item size");
    if (!aItem)
        return(TRUE);
    SEMENTER();
    if (!(pali = FindAdvList(pLst, hwnd, aTopic, aItem, wFmt))) {
        IncHszCount(aItem); // structure copy
        pali = (PADVLI)NewLstItem(pLst, ILST_FIRST);
    }
    AssertF((BOOL)(DWORD)pali, "AddAdvList - NewLstItem() failed")
    if (pali != NULL) {
        pali->aItem = aItem;
        pali->aTopic = aTopic;
        pali->wFmt = wFmt;
        pali->fsStatus = fsStatus;
        pali->hwnd = hwnd;
    }
    SEMLEAVE();
    return((BOOL)(DWORD)pali);
}



/*
 * This will delete the matching Advise loop entry.  If wFmt is 0, all
 * entries with the same hszItem are deleted.
 * Returns fNotEmptyAfterDelete.
 */
BOOL DeleteAdvList(
PLST pLst,
HWND hwnd,
ATOM aTopic,
ATOM aItem,
WORD wFmt)
{
    PADVLI pali;

    AssertF(pLst->cbItem == sizeof(ADVLI), "DeleteAdvList - bad item size");
    SEMENTER();
    while (pali = (PADVLI)FindAdvList(pLst, hwnd, aTopic, aItem, wFmt)) {
        FreeHsz(pali->aItem);
        RemoveLstItem(pLst, (PLITEM)pali);
    }
    SEMLEAVE();
    return((BOOL)(DWORD)pLst->pItemFirst);
}



/***************************** Private Function ****************************\
* This routine searches the advise list for and entry in hszItem.  It returns
* pAdvli only if the item is found.
*
* History:
*   Created     9/12/89    Sanfords
\***************************************************************************/
PADVLI FindAdvList(
PLST pLst,
HWND hwnd,
ATOM aTopic,
ATOM aItem,
WORD wFmt)
{
    ADVLI advli;

    AssertF(pLst->cbItem == sizeof(ADVLI), "FindAdvList - bad item size");
    advli.aItem = aItem;
    advli.aTopic = aTopic;
    advli.wFmt = wFmt;
    advli.hwnd = hwnd;
    return((PADVLI)FindLstItem(pLst, CmpAdv, (PLITEM)&advli));
}


/***************************** Private Function ****************************\
* This routine searches for the next entry for hszItem.  It returns
* pAdvli only if the item is found.  aTopic and hwnd should NOT be 0.
*
* History:
*   Created     11/15/89    Sanfords
\***************************************************************************/
PADVLI FindNextAdv(
PADVLI padvli,
HWND hwnd,
ATOM aTopic,
ATOM aItem)
{

    SEMENTER();
    while ((padvli = (PADVLI)padvli->next) != NULL) {
        if (hwnd == 0 || hwnd == padvli->hwnd) {
            if (aTopic == 0 || aTopic == padvli->aTopic) {
                if (aItem == 0 || padvli->aItem == aItem) {
                    break;
                }
            }
        }
    }
    SEMLEAVE();
    return(padvli);
}



/***************************** Private Function ****************************\
* This routine removes all list items associated with hwnd.
*
* History:
*   Created     4/17/91    Sanfords
\***************************************************************************/
VOID CleanupAdvList(
HWND hwnd,
PCLIENTINFO pci)
{
    PADVLI pali, paliNext;
    PLST plst;

    if (pci->ci.fs & ST_CLIENT) {
        plst = pci->pClientAdvList;
    } else {
        plst = pci->ci.pai->pServerAdvList;
    }
    AssertF(plst->cbItem == sizeof(ADVLI), "CleanupAdvList - bad item size");
    SEMENTER();
    for (pali = (PADVLI)plst->pItemFirst; pali; pali = paliNext) {
        paliNext = (PADVLI)pali->next;
        if (pali->hwnd == hwnd) {
            MONLINK(pci->ci.pai, FALSE, pali->fsStatus & DDE_FDEFERUPD,
                    (HSZ)pci->ci.aServerApp, (HSZ)pci->ci.aTopic,
                    (HSZ)pali->aItem, pali->wFmt,
                    (pci->ci.fs & ST_CLIENT) ? FALSE : TRUE,
                    (pci->ci.fs & ST_CLIENT) ?
                        pci->ci.hConvPartner : MAKEHCONV(hwnd),
                    (pci->ci.fs & ST_CLIENT) ?
                        MAKEHCONV(hwnd) : pci->ci.hConvPartner);
            FreeHsz(pali->aItem);
            RemoveLstItem(plst, (PLITEM)pali);
        }
    }
    SEMLEAVE();
}



/***************************** Pile Functions ********************************\
*
*  A pile is a list where each item is an array of subitems.  This allows
*  a more memory efficient method of handling unordered lists.
*
\*****************************************************************************/

PPILE CreatePile(hheap, cbItem, cItemsPerBlock)
HANDLE hheap;
WORD cbItem;
WORD cItemsPerBlock;
{
    PPILE ppile;

    if (!(ppile = (PPILE)FarAllocMem(hheap, sizeof(PILE)))) {
        SEMLEAVE();
        return(NULL);
    }
    ppile->pBlockFirst = NULL;
    ppile->hheap = hheap;
    ppile->cbBlock = cbItem * cItemsPerBlock + sizeof(PILEB);
    ppile->cSubItemsMax = cItemsPerBlock;
    ppile->cbSubItem = cbItem;
    return(ppile);
}


PPILE DestroyPile(pPile)
PPILE pPile;
{
    if (pPile == NULL)
        return(NULL);
    SEMENTER();
    while (pPile->pBlockFirst)
        RemoveLstItem((PLST)pPile, (PLITEM)pPile->pBlockFirst);
    FarFreeMem((LPSTR)pPile);
    SEMLEAVE();
    return(NULL);
}


WORD QPileItemCount(pPile)
PPILE pPile;
{
    register WORD c;
    PPILEB pBlock;

    if (pPile == NULL)
        return(0);

    SEMENTER();
    pBlock = pPile->pBlockFirst;
    c = 0;
    while (pBlock) {
        c += pBlock->cItems;
        pBlock = pBlock->next;
    }
    SEMLEAVE();
    return(c);
}



/***************************** Private Function ****************************\
* Locate and return the pointer to the pile subitem who's key fields match
* pbSearch using npfnCmp to compare the fields.  If pbSearch == NULL, or
* npfnCmp == NULL, the first subitem is returned.
*
* afCmd may be:
* FPI_DELETE - delete the located item
* In this case, the returned pointer is not valid.
*
* pppb points to where to store a pointer to the block which contained
* the located item.
*
* if pppb == NULL, it is ignored.
*
* NULL is returned if pbSearch was not found or if the list was empty.
*
* History:
*   Created     9/12/89    Sanfords
\***************************************************************************/
LPBYTE FindPileItem(pPile, npfnCmp, pbSearch, afCmd)
PPILE pPile;
NPFNCMP npfnCmp;
LPBYTE pbSearch;
WORD afCmd;
{
    LPBYTE psi;     // subitem pointer.
    PPILEB pBlockCur;    // current block pointer.
    register WORD i;

    if (pPile == NULL)
        return(NULL);
    SEMENTER();
    pBlockCur = pPile->pBlockFirst;
    /*
     * while this block is not the end...
     */
    while (pBlockCur) {
        for (psi = (LPBYTE)pBlockCur + sizeof(PILEB), i = 0;
            i < pBlockCur->cItems;
                psi += pPile->cbSubItem, i++) {

            if (pbSearch == NULL || npfnCmp == NULL || (*npfnCmp)(psi, pbSearch)) {
                if (afCmd & FPI_DELETE) {
                    /*
                     * remove entire block if this was the last subitem in it.
                     */
                    if (--pBlockCur->cItems == 0) {
                        RemoveLstItem((PLST)pPile, (PLITEM)pBlockCur);
                    } else {
                        /*
                         * copy last subitem in the block over the removed item.
                         */
                        hmemcpy(psi, (LPBYTE)pBlockCur + sizeof(PILEB) +
                                pPile->cbSubItem * pBlockCur->cItems,
                                pPile->cbSubItem);
                    }
                }
                return(psi);    // found
            }
        }
        pBlockCur = (PPILEB)pBlockCur->next;
    }
    SEMLEAVE();
    return(NULL);   // not found.
}


/***************************** Private Function ****************************\
* Places a copy of the subitem pointed to by pb into the first available
* spot in the pile pPile.  If npfnCmp != NULL, the pile is first searched
* for a pb match.  If found, pb replaces the located data.
*
* Returns:
*               API_FOUND       if already there
*               API_ERROR       if an error happened
*               API_ADDED       if not found and added
*
* History:
*   Created     9/12/89    Sanfords
\***************************************************************************/
WORD AddPileItem(pPile, pb, npfnCmp)
PPILE pPile;
LPBYTE pb;
BOOL (*npfnCmp)(LPBYTE pbb, LPBYTE pbSearch);
{
    LPBYTE pbDst;
    PPILEB ppb;

    if (pPile == NULL)
        return(FALSE);
    SEMENTER();
    if (npfnCmp != NULL &&  (pbDst = FindPileItem(pPile, npfnCmp, pb, 0)) !=
        NULL) {
        hmemcpy(pbDst, pb, pPile->cbSubItem);
        SEMLEAVE();
        return(API_FOUND);
    }
    ppb = pPile->pBlockFirst;
    /*
     * locate a block with room
     */
    while ((ppb != NULL) && ppb->cItems == pPile->cSubItemsMax) {
        ppb = (PPILEB)ppb->next;
    }
    /*
     * If all full or no blocks, make a new one, link it on the bottom.
     */
    if (ppb == NULL) {
        ppb = (PPILEB)NewLstItem((PLST)pPile, ILST_LAST);
        if (ppb == NULL) {
            SEMLEAVE();
            return(API_ERROR);
        }
        ppb->cItems = 0;
    }
    /*
     * add the subitem
     */
    hmemcpy((LPBYTE)ppb + sizeof(PILEB) + pPile->cbSubItem * ppb->cItems++,
                pb, pPile->cbSubItem);

    SEMLEAVE();
    return(API_ADDED);
}




/***************************** Private Function ****************************\
* Fills pb with a copy of the top item's data and removes it from the pile.
* returns FALSE if the pile was empty.
*
* History:
*   Created     9/12/89    Sanfords
\***************************************************************************/
BOOL PopPileSubitem(pPile, pb)
PPILE pPile;
LPBYTE pb;
{
    PPILEB ppb;
    LPBYTE pSrc;


    if ((pPile == NULL) || ((ppb = pPile->pBlockFirst) == NULL))
        return(FALSE);

    SEMENTER();
    pSrc = (LPBYTE)pPile->pBlockFirst + sizeof(PILEB);
    hmemcpy(pb, pSrc, pPile->cbSubItem);
    /*
     * remove entire block if this was the last subitem in it.
     */
    if (pPile->pBlockFirst->cItems == 1) {
        RemoveLstItem((PLST)pPile, (PLITEM)pPile->pBlockFirst);
    } else {
        /*
         * move last item in block to replace copied subitem and decrement
         * subitem count.
         */
        hmemcpy(pSrc, pSrc + pPile->cbSubItem * --pPile->pBlockFirst->cItems,
                            pPile->cbSubItem);
    }
    SEMLEAVE();
    return(TRUE);
}



#if 0

/***************************** Semaphore Functions *************************\
* SEMENTER() and SEMLEAVE() are macros.
*
* History:      1/1/89  Created         sanfords
\***************************************************************************/
void SemInit()
{
    LPBYTE pSem;
    SHORT c;

    pSem = (LPBYTE) & FSRSemDmg;
    c = 0;
    while (c++ < sizeof(DOSFSRSEM)) {
        *pSem++ = 0;
    }
    FSRSemDmg.cb = sizeof(DOSFSRSEM);
}


void SemCheckIn()
{
    PIDINFO pi;
    BOOL fin;

    DosGetPID(&pi);
    fin = (FSRSemDmg.cUsage > 0) &&  (FSRSemDmg.pid == pi.pid) &&  ((FSRSemDmg.tid ==
        pi.tid) || (FSRSemDmg.tid == -1));
    /*
     * !!! NOTE: during exitlists processing, semaphore TIDs are set to -1
     */
    AssertF(fin, "SemCheckIn - Out of Semaphore");
    if (!fin)
        SEMENTER();
}


void SemCheckOut()
{
    PIDINFO pi;
    BOOL fOut;

    DosGetPID(&pi);
    fOut = FSRSemDmg.cUsage == 0 || FSRSemDmg.pid != pi.pid ||  FSRSemDmg.tid !=
        pi.tid;
    AssertF(fOut, "SemCheckOut - In Semaphore");
    if (!fOut)
        while (FSRSemDmg.cUsage)
            SEMLEAVE();
}


void SemEnter()
{
    DosFSRamSemRequest(&FSRSemDmg, SEM_INDEFINITE_WAIT);
}


void SemLeave()
{
    DosFSRamSemClear(&FSRSemDmg);
}


#endif // 0

BOOL CopyHugeBlock(pSrc, pDst, cb)
LPBYTE pSrc;
LPBYTE pDst;
DWORD cb;
{
    DWORD cFirst;
    /*
     *  |____________|   |___________|   |____________|  |____________|
     *     ^src                                 ^
     *
     *  |____________|   |___________|   |____________|  |____________|
     *             ^dst                                   ^
     */
    /*
      * The following check determines whether the copy can be done
      * in one short copy operation.  Checks whether the byte count
      * is small enough to span the bytes to the right of the greater
      * of pSrc and pDst.
      */
    cFirst = (DWORD)min(~LOWORD((DWORD)pSrc), ~LOWORD((DWORD)pDst)) + 1L;
    /* cFirst is # of bytes to end of seg, for buffer w/ biggest offset */
    if (cb < cFirst) {
        hmemcpy(pDst, pSrc, (WORD)cb);
        return(TRUE);
    }

    goto copyit;    /* if not, jump into while loop */

    /*
     * Now at least one of the pointers is on a segment boundry.
     */
    while (cb) {
        cFirst = min(0x10000 - (LOWORD((DWORD)pSrc) | LOWORD((DWORD)pDst)), (LONG)cb);
copyit:
        if (HIWORD(cFirst)) {
            /*
             * special case where pSrc and pDst both are on segment
             * bounds.  Copy half at a time.  First half first.
             */
            /*
             *  |___________|   |____________|  |____________|
             *  ^src                               ^
             *
             *  |___________|   |____________|  |____________|
             *  ^dst                               ^
             */
            cFirst >>= 1;           /* half the span */
            hmemcpy(pDst, pSrc, (WORD)cFirst);
            pSrc += cFirst;     /* inc ptrs */
            pDst += cFirst;
            cb -= cFirst;           /* dec bytecount */
        }
        hmemcpy(pDst, pSrc, (WORD)cFirst);
        pSrc = HugeOffset(pSrc, cFirst);
        pDst = HugeOffset(pDst, cFirst);
        cb -= cFirst;
        /*
     *  |____________|   |___________|   |____________|  |____________|
     *           ^src                           ^
     *
     *  |____________|   |___________|   |____________|  |____________|
     *                   ^dst                             ^
     */
    }
    return(TRUE);
}




/***************************************************************************\
* Kills windows but avoids invalid window rips in debugger.
\***************************************************************************/
BOOL DmgDestroyWindow(hwnd)
HWND hwnd;
{
    if (IsWindow(hwnd))
        return(DestroyWindow(hwnd));
    return(TRUE);
}



BOOL ValidateHConv(
HCONV hConv)
{
    return(IsWindow((HWND)hConv) &&
            GetWindowWord((HWND)hConv, GWW_CHECKVAL) == HIWORD(hConv));
}



#ifdef DEBUG
void _loadds fAssert(
BOOL f,
LPSTR pszComment,
WORD line,
LPSTR szfile,
BOOL fWarning)
{
    char szT[90];

    if (!f) {
        wsprintf(szT, "\n\rAssertion failure: %s:%d %s\n\r",
                szfile, line, pszComment);
        OutputDebugString((LPSTR)szT);
        if (!fWarning)
            DEBUGBREAK();
    }
}
#endif /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\dmgmon.c ===
/****************************** Module Header ******************************\
* Module Name: DMGMON.C
*
* This module contains functions used for DDE monitor control.
*
* Created:  8/2/88    sanfords
*
* Copyright (c) 1988, 1989  Microsoft Corporation
\***************************************************************************/
#include "ddemlp.h"


long EXPENTRY DdeSendHookProc(
int nCode,
WORD wParam,
LPHMSTRUCT lParam)
{
    HDDEDATA hData;
    MONMSGSTRUCT FAR *pmsgs;

    if (cMonitor && lParam &&
            lParam->wMsg >= WM_DDE_FIRST && lParam->wMsg <= WM_DDE_LAST) {
        if (hData = allocMonBuf(sizeof(MONMSGSTRUCT), HIWORD(MF_SENDMSGS))) {
            pmsgs = (MONMSGSTRUCT FAR *)GlobalLock(HIWORD(hData));
            pmsgs->cb = sizeof(MONMSGSTRUCT);
            pmsgs->dwTime = GetCurrentTime();
            pmsgs->hwndTo = lParam->hWnd;
            pmsgs->hTask = GetWindowTask(lParam->hWnd);
            pmsgs->wMsg = lParam->wMsg;
            pmsgs->wParam = lParam->wParam;
            pmsgs->lParam = *(DWORD FAR *)&lParam->hlParam;
            MonitorBroadcast(hData, HIWORD(MF_SENDMSGS));
        }
    }
    return DefHookProc(nCode, wParam, (DWORD)lParam, &prevCallHook);
}




long EXPENTRY DdePostHookProc(nCode, wParam, lParam)
int nCode;
WORD wParam;
LPMSG lParam;
{
    HDDEDATA hData;
    MONMSGSTRUCT FAR *pmsgs;

    if (cMonitor && lParam &&
            lParam->message >= WM_DDE_FIRST && lParam->message <= WM_DDE_LAST) {
        if (hData = allocMonBuf(sizeof(MONMSGSTRUCT), HIWORD(MF_POSTMSGS))) {
            pmsgs = (MONMSGSTRUCT FAR *)GlobalLock(HIWORD(hData));
            pmsgs->cb = sizeof(MONMSGSTRUCT);
            pmsgs->dwTime = lParam->time;
            pmsgs->hwndTo = lParam->hwnd;
            pmsgs->hTask = GetWindowTask(lParam->hwnd);
            pmsgs->wMsg = lParam->message;
            pmsgs->wParam = lParam->wParam;
            pmsgs->lParam = lParam->lParam;
            MonitorBroadcast(hData, HIWORD(MF_POSTMSGS));
        }
    }
    return DefHookProc(nCode, wParam, (DWORD)lParam, &prevMsgHook);
}


VOID MonBrdcastCB(
PAPPINFO pai,
WORD wType,
WORD wFmt,
HCONV hConv,
HSZ hszTopic,
HSZ hszItem,
HDDEDATA hData,
DWORD dwData1,
DWORD dwData2,
DWORD dwRet)
{
    MONCBSTRUCT FAR *pcbs;
    HDDEDATA hDataBuf;

    SEMCHECKOUT();
    SEMENTER();
    if (pai) {
        if (hDataBuf = allocMonBuf(sizeof(MONCBSTRUCT), HIWORD(MF_CALLBACKS))) {
            pcbs = (MONCBSTRUCT FAR *)GlobalLock(HIWORD(hDataBuf));
            pcbs->cb = sizeof(MONCBSTRUCT);
            pcbs->dwTime = GetCurrentTime();
            pcbs->hTask = pai->hTask;
            pcbs->dwRet = dwRet;
            pcbs->wType = wType;
            pcbs->wFmt = wFmt;
            pcbs->hConv = hConv;
            pcbs->hsz1 = hszTopic;
            pcbs->hsz2 = hszItem;
            pcbs->hData = hData;
            pcbs->dwData1 = dwData1;
            pcbs->dwData2 = dwData2;
            MonitorBroadcast(hDataBuf, HIWORD(MF_CALLBACKS));
        }
    }
    SEMLEAVE();
}




void MonHsz(
ATOM a,
WORD fsAction,
HANDLE hTask)
{
    MONHSZSTRUCT FAR *phszs;
    HDDEDATA hData;
    WORD cb;

    if (hData = allocMonBuf(sizeof(MONHSZSTRUCT) + (cb = QueryHszLength((HSZ)a)),
            HIWORD(MF_HSZ_INFO))) {
        phszs = (MONHSZSTRUCT FAR *)GlobalLock(HIWORD(hData));
        phszs->cb = sizeof(MONHSZSTRUCT) + cb + 1;
        phszs->dwTime = GetCurrentTime();
        phszs->hTask = hTask;
        phszs->fsAction = fsAction;
        phszs->hsz = (HSZ)a;
        QueryHszName((HSZ)a, phszs->str, ++cb);
        MonitorBroadcast(hData, HIWORD(MF_HSZ_INFO));
    }
}




WORD MonError(
PAPPINFO pai,
WORD error)
{
    MONERRSTRUCT FAR *perrs;
    HDDEDATA hData;

    if (error) {
        if (hData = allocMonBuf(sizeof(MONERRSTRUCT), HIWORD(MF_ERRORS))) {
            perrs = (MONERRSTRUCT FAR *)GlobalLock(HIWORD(hData));
            perrs->cb = sizeof(MONERRSTRUCT);
            perrs->dwTime = GetCurrentTime();
            perrs->hTask = pai->hTask;
            perrs->wLastError = error;
            MonitorBroadcast(hData, HIWORD(MF_ERRORS));
        }
    }
    pai->LastError = error;
    return(error);
}


VOID MonLink(
PAPPINFO pai,
BOOL fEstablished,
BOOL fNoData,
HSZ  hszSvc,
HSZ  hszTopic,
HSZ  hszItem,
WORD wFmt,
BOOL fServer,
HCONV hConvServer,
HCONV hConvClient)
{
    MONLINKSTRUCT FAR *plink;
    HDDEDATA hData;

    if (hData = allocMonBuf(sizeof(MONLINKSTRUCT), HIWORD(MF_LINKS))) {
        plink = (MONLINKSTRUCT FAR *)GlobalLock(HIWORD(hData));
        plink->cb = sizeof(MONLINKSTRUCT);
        plink->dwTime = GetCurrentTime();
        plink->hTask = pai->hTask;
        plink->fEstablished = fEstablished;
        plink->fNoData = fNoData;
        plink->hszSvc = hszSvc;
        plink->hszTopic = hszTopic;
        plink->hszItem = hszItem;
        plink->wFmt = wFmt;
        plink->fServer = fServer;
        plink->hConvServer = hConvServer;
        plink->hConvClient = hConvClient;

        MonitorBroadcast(hData, HIWORD(MF_LINKS));
    }
}



VOID MonConn(
PAPPINFO pai,
ATOM aApp,
ATOM aTopic,
HWND hwndClient,
HWND hwndServer,
BOOL fConnect)
{
    MONCONVSTRUCT FAR *pconv;
    HDDEDATA hData;

    if (hData = allocMonBuf(sizeof(MONCONVSTRUCT), HIWORD(MF_CONV))) {
        pconv = (MONCONVSTRUCT FAR *)GlobalLock(HIWORD(hData));
        pconv->cb = sizeof(MONCONVSTRUCT);
        pconv->dwTime = GetCurrentTime();
        pconv->hTask = pai->hTask;
        pconv->hszSvc = (HSZ)aApp;
        pconv->hszTopic = (HSZ)aTopic;
        pconv->hConvClient = MAKEHCONV(hwndClient);
        pconv->hConvServer = MAKEHCONV(hwndServer);
        pconv->fConnect = fConnect;

        MonitorBroadcast(hData, HIWORD(MF_CONV));
    }
}

/*
 * This guy sends a UM_MONITOR to all the monitor windows who's filters accept
 * the callback.
 */
void MonitorBroadcast(
HDDEDATA hData,
WORD filterClass)  // set to class of filter or 0
{
    PAPPINFO pai;
    register WORD i = 0;

    SEMCHECKOUT();
    SEMENTER();
    pai = pAppInfoList;
    while (pai && (i < cMonitor)) {
        if (pai->hwndMonitor) {
            if (filterClass & HIWORD(pai->afCmd)) {
                SendMessage(pai->hwndMonitor, UM_MONITOR, filterClass, hData);
            }
            i++;
        }
        pai = pai->next;
    }
    SEMLEAVE();
    GlobalUnlock(HIWORD(hData));
    GLOBALFREE(HIWORD(hData));
}



HDDEDATA allocMonBuf(
WORD cb,
WORD filter)
{
    PAPPINFO pai;
    register WORD i;

    SEMENTER();
    if (cMonitor == 0)
        return(FALSE);
    pai = pAppInfoList;
    i = 0;
    while (pai && i < cMonitor) {
        if (HIWORD(pai->afCmd) & filter)
            return(MAKELONG(HDATA_EXEC, AllocDDESel(0, 0, cb)));
        if (pai->afCmd & APPCLASS_MONITOR)
            i++;
        pai = pai->next;
    }
    return(NULL);
}


long    EXPENTRY MonitorWndProc(hwnd, msg, wP, lP)
HWND hwnd;
WORD msg;
WORD wP;
register DWORD lP;
{
    switch (msg) {
    case WM_CREATE:
        SetWindowWord(hwnd, GWW_PAI, (WORD)LPCREATESTRUCT_GETPAI(lP));
        break;

    case UM_MONITOR:
        /*
         * lP = hData
         * wP = HIWORD(MF_)
         */
        DoCallback((PAPPINFO)GetWindowWord(hwnd, GWW_PAI), 0, 0L, 0L, 0, XTYP_MONITOR, lP, 0L, (DWORD)wP << 16);
        break;

    default:
        return(DefWindowProc(hwnd, msg, wP, lP));
        break;
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\dmgmem.c ===
/****************************** Module Header ******************************\
* Module Name: DMGMEM.C
*
* DDE Manager memory management functions.
*
* Created: 5/31/90 Rich Gartland
*
* This module contains routines which mimic memory management functions
* used by the OS/2 version of the DDEMGR library.  Some are emulations
* of OS/2 calls, and others emulate DDEMGR macros built on OS/2 calls.
*   Old function            new function
*   --------------------------------------
*   WinCreateHeap           DmgCreateHeap
*   WinDestroyHeap          DmgDestroyHeap
*   FarAllocMem             FarAllocMem
*   FarFreeMem              FarFreeMem
*
* Copyright (c) 1990, Aldus Corporation
\***************************************************************************/

#include "ddemlp.h"
#include <memory.h>

#ifdef DEBUG

#define GML_FREE    1
#define GML_ALLOC   2
#define MAX_CLOGS   500
#define STKTRACE_LEN    3

typedef struct _GMLOG {
    HGLOBAL h;
    WORD flags; // GML_
    WORD msg;
    WORD cLocks;
    WORD stktrace[STKTRACE_LEN];
    WORD stktracePrev[STKTRACE_LEN];
} GMLOG, far * LPGMLOG;

GMLOG gmlog[MAX_CLOGS];
WORD cGmLogs = 0;
int TraceApiLevel = 0;


VOID TraceApiIn(
LPSTR psz)
{
    char szT[10];

    wsprintf(szT, "%2d | ", TraceApiLevel);
    TraceApiLevel++;
    OutputDebugString(szT);
    OutputDebugString(psz);
    if (bDbgFlags & DBF_STOPONTRACE) {
        DebugBreak();
    }
}

VOID TraceApiOut(
LPSTR psz)
{
    char szT[10];

    TraceApiLevel--;
    wsprintf(szT, "%2d | ", TraceApiLevel);
    OutputDebugString(szT);
    OutputDebugString(psz);
    if (bDbgFlags & DBF_STOPONTRACE) {
        DebugBreak();
    }
}

VOID DumpGmObject(
LPGMLOG pgmlog)
{
    char szT[100];

    wsprintf(szT,
            "\n\rh=%4x flags=%4x msg=%4x stacks:\n\r%04x %04x %04x %04x %04x\n\r%04x %04x %04x %04x %04x",
            pgmlog->h,
            pgmlog->flags,
            pgmlog->msg,
            pgmlog->stktrace[0],
            pgmlog->stktrace[1],
            pgmlog->stktrace[2],
            pgmlog->stktrace[3],
            pgmlog->stktrace[4],
            pgmlog->stktracePrev[0],
            pgmlog->stktracePrev[1],
            pgmlog->stktracePrev[2],
            pgmlog->stktracePrev[3],
            pgmlog->stktracePrev[4]
            );
    OutputDebugString(szT);
}


HGLOBAL LogGlobalReAlloc(
HGLOBAL h,
DWORD cb,
UINT flags)
{
    HGLOBAL hRet;
    WORD i;

    hRet = GlobalReAlloc(h, cb, flags);
    if (bDbgFlags & DBF_LOGALLOCS && h != hRet) {
        if (hRet != NULL) {
            for (i = 0; i < cGmLogs; i++) {
                if ((gmlog[i].h & 0xFFFE) == (h & 0xFFFE)) {
                    gmlog[i].flags = GML_FREE;
                    hmemcpy(gmlog[i].stktracePrev, gmlog[i].stktrace,
                            sizeof(WORD) * STKTRACE_LEN);
                    StkTrace(STKTRACE_LEN, gmlog[i].stktrace);
                }
                if ((gmlog[i].h & 0xFFFE) == (hRet & 0xFFFE)) {
                    gmlog[i].flags = GML_ALLOC;
                    hmemcpy(gmlog[i].stktracePrev, gmlog[i].stktrace,
                            sizeof(WORD) * STKTRACE_LEN);
                    StkTrace(STKTRACE_LEN, gmlog[i].stktrace);
                    return(hRet);
                }
            }
            if (cGmLogs >= MAX_CLOGS) {
                OutputDebugString("\n\rGlobal logging table overflow.");
                DumpGlobalLogs();
                DebugBreak();
                return(hRet);
            }

            gmlog[cGmLogs].flags = GML_ALLOC;
            gmlog[cGmLogs].msg = 0;
            gmlog[cGmLogs].h = hRet;
            gmlog[cGmLogs].cLocks = 0;
            hmemcpy(gmlog[cGmLogs].stktracePrev, gmlog[cGmLogs].stktrace,
                    sizeof(WORD) * STKTRACE_LEN);
            StkTrace(STKTRACE_LEN, gmlog[cGmLogs].stktrace);
            cGmLogs++;
        }
    }
    return(hRet);
}



HGLOBAL LogGlobalAlloc(
UINT flags,
DWORD cb)
{
    HGLOBAL hRet;
    WORD i;

    hRet = GlobalAlloc(flags, cb);
    if (bDbgFlags & DBF_LOGALLOCS) {
        if (hRet != NULL) {
            for (i = 0; i < cGmLogs; i++) {
                if ((gmlog[i].h & 0xFFFE) == (hRet & 0xFFFE)) {
                    gmlog[i].flags = GML_ALLOC;
                    hmemcpy(gmlog[i].stktracePrev, gmlog[i].stktrace,
                            sizeof(WORD) * STKTRACE_LEN);
                    StkTrace(STKTRACE_LEN, gmlog[i].stktrace);
                    return(hRet);
                }
            }
            if (cGmLogs >= MAX_CLOGS) {
                OutputDebugString("\n\rGlobal logging table overflow.");
                DumpGlobalLogs();
                DebugBreak();
                return(hRet);
            }

            gmlog[cGmLogs].flags = GML_ALLOC;
            gmlog[cGmLogs].msg = 0;
            gmlog[cGmLogs].h = hRet;
            gmlog[cGmLogs].cLocks = 0;
            hmemcpy(gmlog[cGmLogs].stktracePrev, gmlog[cGmLogs].stktrace,
                    sizeof(WORD) * STKTRACE_LEN);
            StkTrace(STKTRACE_LEN, gmlog[cGmLogs].stktrace);
            cGmLogs++;
        }
    }
    return(hRet);
}


void FAR * LogGlobalLock(
HGLOBAL h)
{
    WORD i;

    if (bDbgFlags & DBF_LOGALLOCS) {
        for (i = 0; i < cGmLogs; i++) {
            if ((gmlog[i].h & 0xFFFE) == (h & 0xFFFE)) {
                break;
            }
        }
        if (i < cGmLogs) {
            gmlog[i].cLocks++;
            if (gmlog[i].flags == GML_FREE) {
                DumpGmObject(&gmlog[i]);
                OutputDebugString("\n\rGlobalLock will fail.");
                DebugBreak();
            }
        }
    }
    return(GlobalLock(h));
}


BOOL LogGlobalUnlock(
HGLOBAL h)
{
    WORD i;

    if (bDbgFlags & DBF_LOGALLOCS) {
        for (i = 0; i < cGmLogs; i++) {
            if ((gmlog[i].h & 0xFFFE) == (h & 0xFFFE)) {
                break;
            }
        }
        if (i < cGmLogs) {
            if (gmlog[i].cLocks == 0 || gmlog[i].flags == GML_FREE) {
                DumpGmObject(&gmlog[i]);
                OutputDebugString("\n\rGlobalUnlock will fail.");
                DebugBreak();
            }
            gmlog[i].cLocks--;
        }
    }
    return(GlobalUnlock(h));
}


HGLOBAL LogGlobalFree(
HGLOBAL h)
{
    WORD i;

    if (bDbgFlags & DBF_LOGALLOCS) {
        for (i = 0; i < cGmLogs; i++) {
            if ((gmlog[i].h & 0xFFFE) == (h & 0xFFFE)) {
                if (gmlog[i].flags == GML_FREE) {
                    DumpGmObject(&gmlog[i]);
                    OutputDebugString("\n\rFreeing free object.\n\r");
                    DebugBreak();
                }
                gmlog[i].flags = GML_FREE;
                hmemcpy(gmlog[i].stktracePrev, gmlog[i].stktrace,
                        sizeof(WORD) * STKTRACE_LEN);
                StkTrace(STKTRACE_LEN, gmlog[i].stktrace);
                return(GlobalFree(h));
            }
        }
        OutputDebugString("\n\rGlobal object being freed not found in logs.");
        DebugBreak();
    }
    return(GlobalFree(h));
}


VOID LogDdeObject(
UINT msg,
LONG lParam)
{
    HGLOBAL h;
    WORD i;
    char szT[100];

    if (bDbgFlags & DBF_LOGALLOCS) {
        switch (msg & 0x0FFF) {
        case WM_DDE_DATA:
        case WM_DDE_POKE:
        case WM_DDE_ADVISE:
        case 0:
            h = LOWORD(lParam);
            break;

        case WM_DDE_EXECUTE:
            h = HIWORD(lParam);
            break;

        default:
            return;
        }
        if (h == 0) {
            return;
        }
        for (i = 0; i < cGmLogs; i++) {
            if ((gmlog[i].h & 0xFFFE) == (h & 0xFFFE)) {
                if (gmlog[i].flags == GML_FREE) {
                    DumpGmObject(&gmlog[i]);
                    wsprintf(szT, "\n\rLogging free DDE Object! [%4x]\n\r", msg);
                    OutputDebugString(szT);
                    DebugBreak();
                }
                if (msg & 0xFFF) {
                    gmlog[i].msg = msg;
                } else {
                    gmlog[i].msg = (gmlog[i].msg & 0x0FFF) | msg;
                }
                break;
            }
        }
    }
}


VOID DumpGlobalLogs()
{
    WORD i;
    char szT[100];

    if (bDbgFlags & DBF_LOGALLOCS) {
        wsprintf(szT, "\n\rDumpGlobalLogs - cGmLogs = %d", cGmLogs);
        OutputDebugString(szT);
        for (i = 0; i < cGmLogs; i++) {
            if (gmlog[i].flags == GML_ALLOC) {
                DumpGmObject(&gmlog[i]);
            }
        }
        wsprintf(szT, "\n\rDDEML CS=%04x\n\r", HIWORD((LPVOID)DumpGlobalLogs));
        OutputDebugString(szT);
    }
}

#endif // DEBUG

/***************************** Private Function ****************************\
*
* Creates a new heap and returns a handle to it.
* Returns NULL on error.
*
*
* History:
*   Created     5/31/90     Rich Gartland
\***************************************************************************/
HANDLE DmgCreateHeap(wSize)
WORD wSize;
{
    HANDLE hMem;
    DWORD  dwSize;

    dwSize = wSize;
    /* Allocate the memory from a global data segment */
    if (!(hMem = GLOBALALLOC(GMEM_MOVEABLE, dwSize)))
        return(NULL);

    /* use LocalInit to establish heap mgmt structures in the seg */
    if (!LocalInit(hMem, NULL, wSize - 1)) {
        GLOBALFREE(hMem);
        return(NULL);
    }

    return(hMem);
}


/***************************** Private Function ****************************\
*
* Destroys a heap previously created with DmgCreateHeap.
* Returns nonzero on error.
*
*
* History:
*   Created     5/31/90     Rich Gartland
\***************************************************************************/
HANDLE DmgDestroyHeap(hheap)
HANDLE hheap;
{
    /* now free the block and return the result (NULL if success) */
    return(GLOBALFREE(hheap));
}



/*
 * Attempts to recover from memory allocation errors.
 *
 * Returns fRetry - ok to attempt reallocation.
 */
BOOL ProcessMemError(
HANDLE hheap)
{
    PAPPINFO pai;

    // first locate what instance this heap is assocaited with

    SEMENTER();
    pai = pAppInfoList;
    while (pai && pai->hheapApp != hheap) {
        pai = pai->next;
    }
    if (!pai) {
        SEMLEAVE();
        return(FALSE);      // not associated with an instance, no recourse.
    }

    /*
     * Free our emergency reserve memory and post a message to our master
     * window to handle heap cleanup.
     */
    if (pai->lpMemReserve) {
        FarFreeMem(pai->lpMemReserve);
        pai->lpMemReserve = NULL;
        MONERROR(pai, DMLERR_LOW_MEMORY);
        DoCallback(pai, NULL, 0, 0, 0, XTYP_ERROR, NULL, DMLERR_LOW_MEMORY, 0L);
        SEMLEAVE();
        if (!PostMessage(pai->hwndDmg, UM_FIXHEAP, 0, (LONG)(LPSTR)pai)) {
            SETLASTERROR(pai, DMLERR_SYS_ERROR);
            return(FALSE);
        }
        return(TRUE);
    }

    return(FALSE);  // no reserve memory, were dead bud.
}



/***************************** Private Function ****************************\
*
* Allocates a new block of a given size from a heap.
* Returns NULL on error, far pointer to the block otherwise.
*
*
* History:
*   Created     5/31/90     Rich Gartland
\***************************************************************************/

LPVOID FarAllocMem(hheap, wSize)
HANDLE hheap;
WORD wSize;
{

    LPSTR   lpMem;
    PSTR    pMem;
    WORD    wSaveDS;

    /* lock the handle to get a far pointer */
    lpMem = (LPSTR)GLOBALPTR(hheap);
    if (!lpMem)
        return(NULL);

    do {
        /* Do some magic here using the segment selector, to switch our
         * ds to the heap's segment.  Then, our LocalAlloc will work fine.
         */
        wSaveDS = SwitchDS(HIWORD(lpMem));

        /* Allocate the block */
        // Note: if you remove the LMEM_FIXED flag you will break the handle
        //       validation in DdeFreeDataHandle & get a big handle leak!!
        pMem = (PSTR)LocalAlloc((WORD)LPTR, wSize);  // LPTR = fixed | zeroinit

        SwitchDS(wSaveDS);
    } while (pMem == NULL && ProcessMemError(hheap));

#ifdef WATCHHEAPS
    if (pMem) {
        LogAlloc((DWORD)MAKELONG(pMem, HIWORD(lpMem)), wSize,
                RGB(0xff, 0, 0), hInstance);
    }
#endif
    /* set up the far return value, based on the success of LocalAlloc */
    return (LPSTR)(pMem ? MAKELONG(pMem, HIWORD(lpMem)) : NULL);
}




/***************************** Private Function ****************************\
*
* Frees a block of a given size from a heap.
* Returns NULL on success, far pointer to the block otherwise.
*
*
* History:
*   Created     5/31/90     Rich Gartland
\***************************************************************************/

void FarFreeMem(
LPVOID lpMem)
{

    WORD    wSaveDS;
#ifdef WATCHHEAPS
    WORD    sz;
#endif

    /* Do some magic here using the segment selector, to switch our
     * ds to the heap's segment.  Then, our LocalFree will work fine.
     */
    wSaveDS = SwitchDS(HIWORD(lpMem));
#ifdef WATCHHEAPS
    sz = LocalSize((LOWORD((DWORD)lpMem)));
#endif
    /* Free the block */
    LocalFree(LocalHandle(LOWORD((DWORD)lpMem)));

    SwitchDS(wSaveDS);
#ifdef WATCHHEAPS
    LogAlloc((DWORD)lpMem, sz, RGB(0x80, 0x80, 0x80), hInstance);
#endif
}


int     FAR PASCAL WEP (int);
int     FAR PASCAL LibMain(HANDLE, WORD, WORD, LPCSTR);
#pragma alloc_text(INIT_TEXT,LibMain,WEP)

/***************************** Private Function ****************************\
*
* Does some initialization for the DLL.  Called from LibEntry.asm
* Returns 1 on success, 0 otherwise.
*
*
* History:
*   Created     6/5/90      Rich Gartland
\***************************************************************************/

int     FAR PASCAL LibMain (hI, wDS, cbHS, lpszCL)
HANDLE hI;      /* instance handle */
WORD wDS;       /* data segment */
WORD cbHS;      /* heapsize */
LPCSTR lpszCL;   /* command line */
{
    extern ATOM gatomDDEMLMom;
    extern ATOM gatomDMGClass;


#if 0
    /* We won't unlock the data segment, as typically happens here */

    /* Init the semaphore -- probably just a stub now */
    SEMINIT();
#endif
    /* set up the global instance handle variable */
    hInstance = hI;

    /* set up class atoms.  Note we use RegisterWindowMessage because
     * it comes from the same user atom table used for class atoms.
     */
    gatomDDEMLMom = RegisterWindowMessage("DDEMLMom");
    gatomDMGClass = RegisterWindowMessage("DMGClass");

    return(1);

}


VOID RegisterClasses()
{
    WNDCLASS    cls;

    cls.hIcon = NULL;
    cls.hCursor = NULL;
    cls.lpszMenuName = NULL;
    cls.hbrBackground = NULL;
    cls.style = 0; // CS_GLOBALCLASS
    cls.hInstance = hInstance;
    cls.cbClsExtra = 0;

    cls.cbWndExtra = sizeof(VOID FAR *) + sizeof(WORD);
    cls.lpszClassName = SZCLIENTCLASS;
    cls.lpfnWndProc = (WNDPROC)ClientWndProc;
    RegisterClass(&cls);

    // cls.cbWndExtra = sizeof(VOID FAR *) + sizeof(WORD);
    cls.lpszClassName = SZSERVERCLASS;
    cls.lpfnWndProc = (WNDPROC)ServerWndProc;
    RegisterClass(&cls);

    // cls.cbWndExtra = sizeof(VOID FAR *) + sizeof(WORD);
    cls.lpszClassName = SZDMGCLASS;
    cls.lpfnWndProc = (WNDPROC)DmgWndProc;
    RegisterClass(&cls);

    cls.cbWndExtra = sizeof(VOID FAR *) + sizeof(WORD) + sizeof(WORD);
    cls.lpszClassName = SZCONVLISTCLASS;
    cls.lpfnWndProc = (WNDPROC)ConvListWndProc;
    RegisterClass(&cls);

    cls.cbWndExtra = sizeof(VOID FAR *);
    cls.lpszClassName = SZMONITORCLASS;
    cls.lpfnWndProc = (WNDPROC)MonitorWndProc;
    RegisterClass(&cls);

    cls.cbWndExtra = sizeof(VOID FAR *);
    cls.lpszClassName = SZFRAMECLASS;
    cls.lpfnWndProc = (WNDPROC)subframeWndProc;
    RegisterClass(&cls);

#ifdef WATCHHEAPS
    cls.cbWndExtra = 0;
    cls.lpszClassName = SZHEAPWATCHCLASS;
    cls.lpfnWndProc = DefWindowProc;
    cls.hCursor = LoadCursor(NULL, IDC_ARROW);
    cls.hbrBackground = GetStockObject(WHITE_BRUSH);
    RegisterClass(&cls);
#endif  // WATCHHEAPS
}


#if 0
VOID UnregisterClasses()
{
        UnregisterClass(SZCLIENTCLASS, hInstance);
        UnregisterClass(SZSERVERCLASS, hInstance);
        UnregisterClass(SZDMGCLASS, hInstance);
        UnregisterClass(SZCONVLISTCLASS, hInstance);
        UnregisterClass(SZMONITORCLASS, hInstance);
        UnregisterClass(SZFRAMECLASS, hInstance);
#ifdef WATCHHEAPS
        UnregisterClass(SZHEAPWATCHCLASS, hInstance);
#endif
}
#endif


/***************************** Private Function ****************************\
*
* Does the termination for the DLL.
* Returns 1 on success, 0 otherwise.
*
*
* History:
*   Created     6/5/90      Rich Gartland
\***************************************************************************/

int     FAR PASCAL WEP (nParameter)
int     nParameter;
{

    if (nParameter == WEP_SYSTEM_EXIT) {
        /*      DdeUninitialize(); */
        return(1);
    } else {
        if (nParameter == WEP_FREE_DLL) {
            /*          DdeUninitialize(); */
            return(1);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\dmgdde.c ===
/****************************** Module Header ******************************\
* Module Name: DMGDDE.C
*
* This module contains functions used for interfacing with DDE structures
* and such.
*
* Created:  12/23/88    sanfords
*
* Copyright (c) 1988, 1989  Microsoft Corporation
\***************************************************************************/
#include "ddemlp.h"

VOID FreeDdeMsgData(WORD msg, LPARAM lParam);

UINT EmptyQueueTimerId = 0;

/***************************** Private Function ****************************\
* timeout()
*
* This routine creates a timer for hwndTimeout.  It then runs a modal loop
* which will exit once the pai->wTimeoutStatus word indicates things are
* either done (TOS_DONE), aborted (TOS_ABORT), or the system is shutting
* down (TOS_SHUTDOWN).  A values of TOS_TICK is used to support timouts
* >64K in length.
*
* Returns fSuccess, ie TRUE if TOS_DONE was received. before TOS_ABORT.
*
* PUBDOC START
* Synchronous client transaction modal loops:
*
* During Synchronous transactions, a client application will enter a modal
* loop while waiting for the server to respond to the request.  If an
* application wishes to filter messages to the modal loop, it may do so
* by setting a message filter tied to MSGF_DDEMGR.  Applications should
* be aware however that the DDEMGR modal loop processes private messages
* in the WM_USER range, WM_DDE messages, and WM_TIMER messages with timer IDs
* using the TID_ constants defined in ddeml.h.
* These messages must not be filtered by an application!!!
*
* PUBDOC END
*
* History:
*   Created     sanfords    12/19/88
\***************************************************************************/
BOOL timeout(
PAPPINFO pai,
DWORD ulTimeout,
HWND hwndTimeout)
{
    MSG msg;
    PAPPINFO paiT;

    SEMENTER();
    /*
     * We check all instances in this task (thread) since we cannot let
     * one thread enter a modal loop two levels deep.
     */
    paiT = NULL;
    while (paiT = GetCurrentAppInfo(paiT)) {
        if (paiT->hwndTimer) {
            SETLASTERROR(pai, DMLERR_REENTRANCY);
            AssertF(FALSE, "Recursive timeout call");
            SEMLEAVE();
            return(FALSE);
        }
    }
    pai->hwndTimer = hwndTimeout;
    SEMLEAVE();

    if (!SetTimer(hwndTimeout, TID_TIMEOUT,
            ulTimeout > 0xffffL ? 0xffff : (WORD)ulTimeout, NULL)) {
        SETLASTERROR(pai, DMLERR_SYS_ERROR);
        return(FALSE);
    }


    if (ulTimeout < 0xffff0000) {
        ulTimeout += 0x00010000;
    }

    //
    // We use this instance-wide global variable to note timeouts so that
    // we don't need to rely on PostMessage() to work when faking timeouts.
    //

    do {

        ulTimeout -= 0x00010000;
        if (ulTimeout <= 0xffffL) {
            // the last timeout should be shorter than 0xffff
            SetTimer(hwndTimeout, TID_TIMEOUT, (WORD)ulTimeout, NULL);
        }
        pai->wTimeoutStatus = TOS_CLEAR;

        /*
         * stay in modal loop until a timeout happens.
         */

        while (pai->wTimeoutStatus == TOS_CLEAR) {

            if (!GetMessage(&msg, (HWND)NULL, 0, 0)) {
                /*
                 * Somebody posted a WM_QUIT message - get out of this
                 * timer loop and repost so main loop gets it.  This
                 * fixes a bug where some apps (petzolds ShowPop) use
                 * rapid synchronous transactions which interfere with
                 * their proper closing.
                 */
                pai->wTimeoutStatus = TOS_ABORT;
                PostMessage(msg.hwnd, WM_QUIT, 0, 0);
            } else {
                if (!CallMsgFilter(&msg, MSGF_DDEMGR))
                    DispatchMessage(&msg);
            }
        }

    } while (pai->wTimeoutStatus == TOS_TICK && HIWORD(ulTimeout));

    KillTimer(hwndTimeout, TID_TIMEOUT);

    //
    // remove any remaining timeout message in the queue.
    //

    while (PeekMessage(&msg, hwndTimeout, WM_TIMER, WM_TIMER,
            PM_NOYIELD | PM_REMOVE)) {
        if (msg.message == WM_QUIT) {
            /*
             * Windows BUG: This call will succeed on WM_QUIT messages!
             */
            PostQuitMessage(0);
            break;
        }
    }

    SEMENTER();
    pai->hwndTimer = 0;
    SEMLEAVE();
    /*
     * post a callback check incase we blocked callbacks due to being
     * in a timeout.
     */
    if (!PostMessage(pai->hwndDmg, UM_CHECKCBQ, 0, (DWORD)(LPSTR)pai)) {
        SETLASTERROR(pai, DMLERR_SYS_ERROR);
    }
    return(TRUE);
}


/***************************** Private Function ****************************\
* Allocates global DDE memory and fills in first two words with fsStatus
* and wFmt.
*
* History:  created     6/15/90 rich gartland
\***************************************************************************/
HANDLE AllocDDESel(fsStatus, wFmt, cbData)
WORD fsStatus;
WORD wFmt;
DWORD cbData;
{
    HANDLE hMem = NULL;
    DDEDATA FAR * pMem;

    SEMENTER();

    if (!cbData)
        cbData++; // fixes GLOBALALLOC bug where 0 size object allocation fails

    if ((hMem = GLOBALALLOC(GMEM_DDESHARE, cbData))) {
        pMem = (DDEDATA FAR * )GLOBALPTR(hMem);
        *(WORD FAR * )pMem = fsStatus;
        pMem->cfFormat = wFmt;
    }

    SEMLEAVE();
    return(hMem);
}


/***************************** Private Function ****************************\
* This routine institutes a callback directly if psi->fEnableCB is set
* and calls QReply to complete the transaction,
* otherwise it places the data into the queue for processing.
*
* Since hData may be freed by the app at any time once the callback is
* issued, we cannot depend on it being there for QReply.  Therefore we
* save all the pertinant data in the queue along with it.
*
* Returns fSuccess.
*
* History:
*   Created     9/12/89    Sanfords
\***************************************************************************/
BOOL MakeCallback(
PCOMMONINFO pcoi,
HCONV hConv,
HSZ hszTopic,
HSZ hszItem,
WORD wFmt,
WORD wType,
HDDEDATA hData,
DWORD dwData1,
DWORD dwData2,
WORD msg,
WORD fsStatus,
HWND hwndPartner,
HANDLE hMemFree,
BOOL fQueueOnly)
{
    PCBLI pcbli;

    SEMENTER();

    pcbli = (PCBLI)NewLstItem(pcoi->pai->plstCB, ILST_LAST);
    if (pcbli == NULL) {
        SETLASTERROR(pcoi->pai, DMLERR_MEMORY_ERROR);
        SEMLEAVE();
        return(FALSE);
    }
    pcbli->hConv = hConv;
    pcbli->hszTopic = hszTopic;
    pcbli->hszItem = hszItem;
    pcbli->wFmt = wFmt;
    pcbli->wType = wType;
    pcbli->hData = hData;
    pcbli->dwData1 = dwData1;
    pcbli->dwData2 = dwData2;
    pcbli->msg = msg;
    pcbli->fsStatus = fsStatus;
    pcbli->hwndPartner = hwndPartner;
    pcbli->hMemFree = hMemFree;
    pcbli->pai = pcoi->pai;
    pcbli->fQueueOnly = fQueueOnly;

    SEMLEAVE();

    if (!(pcoi->fs & ST_BLOCKED))
        if (!PostMessage(pcoi->pai->hwndDmg, UM_CHECKCBQ,
                0, (DWORD)(LPSTR)pcoi->pai)) {
            SETLASTERROR(pcoi->pai, DMLERR_SYS_ERROR);
        }

#ifdef DEBUG
    if (hMemFree) {
        LogDdeObject(0xB000, hMemFree);
    }
#endif
    return(TRUE);
}


#define MAX_PMRETRIES 3


//
// This routine extends the size of the windows message queue by queueing
// up failed posts on the sender side.  This avoids the problems of full
// client queues and of windows behavior of giving DDE messages priority.
//
BOOL PostDdeMessage(
PCOMMONINFO pcoi,    // senders COMMONINFO
WORD msg,
HWND hwndFrom,      // == wParam
LONG lParam,
WORD msgAssoc,
HGLOBAL hAssoc)
{
    LPMQL pmql;
    PPMQI ppmqi;
    int cTries;
    HANDLE hTaskFrom, hTaskTo;
    HWND hwndTo;
    PQST pMQ;

    hwndTo = (HWND)pcoi->hConvPartner;
    if (!IsWindow(hwndTo)) {
        return(FALSE);
    }

    hTaskTo = GetWindowTask(hwndTo);
    /*
     * locate message overflow queue for our target task (pMQ)
     */
    for (pmql = gMessageQueueList; pmql; pmql = pmql->next) {
        if (pmql->hTaskTo == hTaskTo) {
            break;
        }
    }
    if (pmql != NULL) {
        pMQ = pmql->pMQ;
    } else {
        pMQ = NULL;
    }

    /*
     * See if any messages are already queued up
     */
    if (pMQ && pMQ->cItems) {
        if (msg == WM_DDE_TERMINATE) {
            /*
             * remove any non-terminate queued messages from us to them.
             */
            ppmqi = (PPMQI)FindNextQi(pMQ, NULL, FALSE);
            while (ppmqi) {
                FreeDdeMsgData(ppmqi->msg, ppmqi->lParam);
                FreeDdeMsgData(ppmqi->msgAssoc,
                        MAKELPARAM(ppmqi->hAssoc, ppmqi->hAssoc));
                ppmqi = (PPMQI)FindNextQi(pMQ, (PQUEUEITEM)ppmqi,
                    ppmqi->hwndTo == hwndTo &&
                    ppmqi->wParam == hwndFrom);
            }
            pMQ = NULL;     // so we just post it
        } else {
            // add the latest post attempt

            ppmqi = (PPMQI)Addqi(pMQ);

            if (ppmqi == NULL) {
                SETLASTERROR(pcoi->pai, DMLERR_MEMORY_ERROR);
                return(FALSE);      // out of memory
            }
            ppmqi->hwndTo = hwndTo;
            ppmqi->msg = msg;
            ppmqi->wParam = hwndFrom;
            ppmqi->lParam = lParam;
            ppmqi->hAssoc = hAssoc;
            ppmqi->msgAssoc = msgAssoc;
        }
    }

    if (pMQ == NULL || pMQ->cItems == 0) {

        // just post the given message - no queue involved.

        cTries = 0;
        hTaskFrom = GetWindowTask(hwndFrom);
        while (!PostMessage(hwndTo, msg, hwndFrom, lParam)) {
            /*
             * we yielded so recheck target window
             */
            if (!IsWindow(hwndTo)) {
                return(FALSE);
            }

            /*
             * Give reciever a chance to clean out his queue
             */
            if (hTaskTo != hTaskFrom) {
                Yield();
            } else if (!(pcoi->pai->wFlags & AWF_INPOSTDDEMSG)) {
                MSG msgs;
                PAPPINFO pai;

                pcoi->pai->wFlags |= AWF_INPOSTDDEMSG;
                /*
                 * Reciever is US!
                 *
                 * We need to empty our queue of stuff so we can post more
                 * to ourselves.
                 */
                while (PeekMessage((MSG FAR *)&msgs, NULL,
                        WM_DDE_FIRST, WM_DDE_LAST, PM_REMOVE)) {
                    DispatchMessage((MSG FAR *)&msgs);
                }

                /*
                 * tell all instances in this task to process their
                 * callbacks so we can clear our queue.
                 */
                for (pai = pAppInfoList; pai != NULL; pai = pai->next) {
                    if (pai->hTask == hTaskFrom) {
                        CheckCBQ(pai);
                    }
                }

                pcoi->pai->wFlags &= ~AWF_INPOSTDDEMSG;
            }

            if (cTries++ > MAX_PMRETRIES) {
                /*
                 * relocate message overflow queue for our target task (pMQ)
                 * We need to do this again because we gave up control
                 * with the dispatch message and CheckCBQ calls.
                 */
                for (pmql = gMessageQueueList; pmql; pmql = pmql->next) {
                    if (pmql->hTaskTo == hTaskTo) {
                        break;
                    }
                }

                if (pmql == NULL) {
                    /*
                     * create and link in a new queue for the target task
                     */
                    pmql = (LPMQL)FarAllocMem(hheapDmg, sizeof(MQL));
                    if (pmql == NULL) {
                        SETLASTERROR(pcoi->pai, DMLERR_MEMORY_ERROR);
                        return(FALSE);
                    }
                    pmql->pMQ = CreateQ(sizeof(PMQI));
                    if (pmql->pMQ == NULL) {
                        FarFreeMem(pmql);
                        SETLASTERROR(pcoi->pai, DMLERR_MEMORY_ERROR);
                        return(FALSE);
                    }
                    pmql->hTaskTo = hTaskTo;
                    pmql->next = gMessageQueueList;
                    gMessageQueueList = pmql;
                }
                pMQ = pmql->pMQ;

                ppmqi = (PPMQI)Addqi(pMQ);

                if (ppmqi == NULL) {
                    SETLASTERROR(pcoi->pai, DMLERR_MEMORY_ERROR);
                    return(FALSE);      // out of memory
                }

                ppmqi->hwndTo = hwndTo;
                ppmqi->msg = msg;
                ppmqi->wParam = hwndFrom;
                ppmqi->lParam = lParam;
                ppmqi->hAssoc = hAssoc;
                ppmqi->msgAssoc = msgAssoc;

                return(TRUE);
            }
        }
#ifdef DEBUG
        LogDdeObject(msg | 0x1000, lParam);
        if (msgAssoc) {
            LogDdeObject(msgAssoc | 0x9000, MAKELPARAM(hAssoc, hAssoc));
        }
#endif
        return(TRUE);
    }

    // come here if the queue exists - empty it as far as we can.

    EmptyDDEPostQ();
    return(TRUE);
}


//
// EmptyDDEPost
//
// This function checks the DDE post queue list and emptys it as far as
// possible.
//
BOOL EmptyDDEPostQ()
{
    PPMQI ppmqi;
    LPMQL pPMQL, pPMQLPrev;
    PQST pMQ;
    BOOL fMoreToDo = FALSE;

    pPMQLPrev = NULL;
    pPMQL = gMessageQueueList;
    while (pPMQL) {
        pMQ = pPMQL->pMQ;

        while (pMQ->cItems) {
            ppmqi = (PPMQI)Findqi(pMQ, QID_OLDEST);
            if (!PostMessage(ppmqi->hwndTo, ppmqi->msg, ppmqi->wParam, ppmqi->lParam)) {
                if (IsWindow(ppmqi->hwndTo)) {
                    fMoreToDo = TRUE;
                    break;  // skip to next target queue
                } else {
                    FreeDdeMsgData(ppmqi->msg, ppmqi->lParam);
                    FreeDdeMsgData(ppmqi->msgAssoc,
                            MAKELPARAM(ppmqi->hAssoc, ppmqi->hAssoc));
                }
            } else {
#ifdef DEBUG
                LogDdeObject(ppmqi->msg | 0x2000, ppmqi->lParam);
                if (ppmqi->msgAssoc) {
                    LogDdeObject(ppmqi->msgAssoc | 0xA000,
                            MAKELPARAM(ppmqi->hAssoc, ppmqi->hAssoc));
                }
#endif
            }
            Deleteqi(pMQ, QID_OLDEST);
        }

        if (pMQ->cItems == 0) {
            /*
             * Delete needless queue (selector)
             */
            DestroyQ(pMQ);
            if (pPMQLPrev) {
                pPMQLPrev->next = pPMQL->next;
                FarFreeMem(pPMQL);
                pPMQL = pPMQLPrev;
            } else {
                gMessageQueueList = gMessageQueueList->next;
                FarFreeMem(pPMQL);
                pPMQL = gMessageQueueList;
                continue;
            }
        }

        pPMQLPrev = pPMQL;
        pPMQL = pPMQL->next;
    }
    if (fMoreToDo & !EmptyQueueTimerId) {
        EmptyQueueTimerId = SetTimer(NULL, TID_EMPTYPOSTQ,
                TIMEOUT_QUEUECHECK, (TIMERPROC)EmptyQTimerProc);
    }

    return(fMoreToDo);
}

/*
 * Used to asynchronously check overflow message queues w/o using PostMessage()
 */
void CALLBACK EmptyQTimerProc(
HWND hwnd,
UINT msg,
UINT tid,
DWORD dwTime)
{
    KillTimer(NULL, EmptyQueueTimerId);
    EmptyQueueTimerId = 0;
    EmptyDDEPostQ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\dmghsz.c ===
/****************************** Module Header ******************************\
* Module Name: DMGHSZ.C
*
* This module contains functions used for HSZ control.
*
* Created:  8/2/88    sanfords, Microsoft
* Modified: 6/5/90   Rich Gartland, Aldus (Win 3.0)
*
* Copyright (c) 1988, 1989  Microsoft Corporation
* Copyright (c) 1990             Aldus Corporation
\***************************************************************************/
#include "ddemlp.h"


ATOM FindAddHszHelper(LPSTR psz, BOOL fAdd);

/*********************** HSZ management functions *************************\
* An HSZ is an atom with a NULL tacked onto it in the HIWORD
* of the HSZ.
*
* WINDOWS 3.0 IMPLEMENTATION NOTE:
*   Since under Windows there is only the local atom table or the (single)
*   global atom table (and we need to use the global table to work right),
*   we always have an atom table index of 0.  When we run out of atom table
*   space, future hsz adds return failure.
*
* History:
*   Created     9/12/89    Sanfords
\***************************************************************************/


BOOL FreeHsz(a)
ATOM a;
{
    if (!a)
        return(TRUE);
#ifdef DEBUG
    cAtoms--;
#endif
    MONHSZ(a, MH_INTDELETE, GetCurrentTask());
    if (GlobalDeleteAtom(a)) {
        DEBUGBREAK();
        return(FALSE);
    }
    return(TRUE);
}



BOOL IncHszCount(a)
ATOM a;
{
    char aChars[255];

    if (a == NULL)
        return(TRUE);
#ifdef DEBUG
    cAtoms++;
#endif
    MONHSZ(a, MH_INTKEEP, GetCurrentTask());
    if (GlobalGetAtomName(a, (LPSTR)aChars, 255))
        return(GlobalAddAtom((LPSTR)aChars));
    else {
        AssertF(FALSE, "Cant increment atom");
        return(FALSE);
    }
}



/***************************** Private Function ****************************\
* Returns the length of the hsz given without NULL terminator.
* Wild HSZs have a length of 0.
*
* History:
*   Created     9/12/89    Sanfords
\***************************************************************************/
WORD QueryHszLength(hsz)
HSZ hsz;
{
    WORD cb;
    char        aChars[255];

    if (LOWORD(hsz) == 0L)
        return(0);

    if (!(cb = GlobalGetAtomName(LOWORD(hsz), (LPSTR)aChars, 255))) {
        AssertF(FALSE, "Cant get atom length");
        return(0);
    }

    if (HIWORD(hsz))
        cb += 7;

    return(cb);
}




WORD QueryHszName(hsz, psz, cchMax)
HSZ hsz;
LPSTR psz;
WORD cchMax;
{
    register WORD cb;

    if (LOWORD(hsz) == 0) {
        if (cchMax)
            *psz = '\0';
        return(0);
    }

    cb = GlobalGetAtomName(LOWORD(hsz), psz, cchMax);
    if (cb && HIWORD(hsz) && (cb < cchMax - 7)) {
        wsprintf(&psz[cb], ":(%04x)", HIWORD(hsz));
        cb += 7;
    }
    return cb;
}







/***************************** Private Function ****************************\
* This finds the hsz for psz depending on fAdd.
*
* History:
*   Created     9/12/89    Sanfords
\***************************************************************************/
ATOM FindAddHsz(psz, fAdd)
LPSTR psz;
BOOL fAdd;
{
    if (psz == NULL || *psz == '\0')
        return(0L);

    return(FindAddHszHelper(psz, fAdd));
}




ATOM FindAddHszHelper(psz, fAdd)
LPSTR psz;
BOOL fAdd;
{
    ATOM atom;

    atom = fAdd ? GlobalAddAtom(psz) : GlobalFindAtom(psz);
    if (fAdd) {
#ifdef DEBUG
        cAtoms++;
#endif
        MONHSZ(atom, MH_INTCREATE, GetCurrentTask());
    }

    return(atom);
}



HSZ MakeInstAppName(
ATOM a,
HWND hwndFrame)
{
    // make upper half of HSZ be HWND FRAME for now.
    IncHszCount(a);
    return((HSZ)MAKELONG(a, hwndFrame));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\dmgq.c ===
/****************************** Module Header ******************************\
* Module Name: DMGQ.C
*
* DDE Manager queue control functions.
*
* Created: 9/1/89 Sanford Staab
* Modified:5/31/90 Rich Gartland, Aldus (Windows 3.0 port)
*
* This is a general queue manager - yes another one!
* Queues are each allocated within their own segment and have a
* QST structure associated with that heap.  Each queue item
* is allocated within the heap segment.  The offset of the items
* address combined with an instance count is used as the item ID.
* This is both unique and allows for instant location of an item.
* New items are added to the head of the queue which is a doubly linked
* list.  The next links point to more recent entries, the prev pointers
* to older entries.  The next of the head is the tail.  The prev of the
* tail is the head.  All pointers are far.
* Queue Data may be of any structure type that begins identical to
* a QUEUEITEM structure.  Functions that require an cbItem perameter
* should be given the size of the specialized queue item structure.
*
* Copyright (c) 1988, 1989  Microsoft Corporation
\***************************************************************************/

#include "ddemlp.h"


/***************************** Private Function ****************************\
*
* Creates a Queue for items of cbItem.
* Returns NULL on error.
*
*
* History:
*   Created     9/1/89    Sanfords
\***************************************************************************/
PQST CreateQ(cbItem)
WORD cbItem;
{
    QST cq;
    PQST pQ;

    cq.cItems = 0;
    cq.instLast = 0;
    cq.cbItem = cbItem;
    cq.pqiHead = NULL;
    if (!(cq.hheap = DmgCreateHeap(sizeof(QST) + cbItem << 3)))
        return(NULL);
    if (!(pQ = (PQST)FarAllocMem(cq.hheap, sizeof(QST)))) {
        DmgDestroyHeap(cq.hheap);
        return(0);
    }
    *pQ = cq;
    return(pQ);
}



/***************************** Private Function ****************************\
*
*
* History:
*   Created     9/1/89    Sanfords
\***************************************************************************/
BOOL DestroyQ(pQ)
PQST pQ;
{
    if (pQ)
        DmgDestroyHeap(pQ->hheap);
    return(TRUE);
}



/***************************** Private Function ****************************\
*
* returns a long pointer to the queue item data created.  The new item
* is added to the head of the queue.  The queue's cbItem specified at
* creation is used for allocation.
*
*
* History:
*   Created     9/1/89    Sanfords
\***************************************************************************/
PQUEUEITEM Addqi(pQ)
PQST pQ;
{
    PQUEUEITEM pqi;

    if ((pqi = (PQUEUEITEM)FarAllocMem(pQ->hheap, pQ->cbItem)) == NULL) {
        return(NULL);
    }

    SEMENTER();
    if (pQ->cItems == 0) {
        pQ->pqiHead = pqi->prev = pqi->next = pqi;
    } else {
        pqi->prev = pQ->pqiHead;
        pqi->next = pQ->pqiHead->next;
        pQ->pqiHead->next->prev = pqi;
        pQ->pqiHead->next = pqi;
        pQ->pqiHead = pqi;
    }
    SEMLEAVE();
    pQ->cItems++;
    pqi->inst = ++pQ->instLast;
    return(pqi);
}




/***************************** Private Function ****************************\
*
*  The id given is an external LONG id, not an item instance number.
*  If id is QID_NEWEST, the head item is deleted.
*  If id is QID_OLDEST, the tail item is deleted.
*
*
* History:
*   Created     9/1/89    Sanfords
\***************************************************************************/
void Deleteqi(pQ, id)
PQST pQ;
DWORD id;
{
    PQUEUEITEM pqi;

    SEMENTER();
    pqi = Findqi(pQ, id);
    if (pqi == NULL) {
        SEMLEAVE();
        return;
    }
    pqi->prev->next = pqi->next;
    pqi->next->prev = pqi->prev;
    if (pqi == pQ->pqiHead)
        pQ->pqiHead = pqi->prev;
    if (!(--pQ->cItems))
        pQ->pqiHead = NULL;
    FarFreeMem((LPSTR)pqi);
    SEMLEAVE();
}






/***************************** Private Function ****************************\
*
*  The id given is an external LONG id, not an item instance number.
*
*  if id == QID_NEWEST, returns the head queue data item.
*  if id == QID_OLDEST == 0L, returns the tail queue data item.
*  if the id is not found or the queue is empty, NULL is returned.
*  if found, pqi is returned.
*
*
* History:
*   Created     9/1/89    Sanfords
\***************************************************************************/
PQUEUEITEM Findqi(pQ, id)
PQST pQ;
DWORD id;
{
    PQUEUEITEM pqi;

    SEMCHECKIN();
    if (pQ == NULL || pQ->pqiHead == NULL)
        return(NULL);

    if (id == QID_OLDEST)
        return(pQ->pqiHead->next);

    if (id == QID_NEWEST)
        return(pQ->pqiHead);

    if (id) {
        pqi = PFROMID(pQ, id);
        if (pqi->inst == HIWORD(id)) {
            return(pqi);
        }
        return(NULL);
    }
}


/*
 * useful for traversing queues and deleting particular stuff in them.
 */
PQUEUEITEM FindNextQi(
PQST pQ,
PQUEUEITEM pqi,
BOOL fDelete)
{
    PQUEUEITEM pqiNext;

    if (pqi == NULL) {
        return(pQ->cItems ? pQ->pqiHead : NULL);
    }

    pqiNext = pqi->next;
    if (fDelete) {
        Deleteqi(pQ, MAKEID(pqi));
    }
    return(pqiNext != pQ->pqiHead && pQ->cItems ? pqiNext : NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\dmgutil.asm ===
.286p
include cmacros.inc

?WIN=1      ; Use Windows prolog/epilog
?PLM=1      ; Use PASCAL calling convention

externW __ahincr

sBegin  CODE            ;INIT_TEXT
assumes cs,CODE ;INIT_TEXT
assumes ds,DATA

cProc HugeOffset,<NEAR, PUBLIC>
parmD   pSrc
parmD   cb
cBegin
        mov     ax, SEG_cb
        mov     dx, ax
        mov     ax, OFF_pSrc
        add     ax, OFF_cb      ;add src offset and bytecount
        adc     dx, 0           ;dx = # segments to increment
        mov     cx, ax          ;save new offset
        mov     ax, dx          ;#segs into ax
        lea     bx, __ahincr
        mul     bx  ;__ahincr   ;mul by windows magic #
        mov     dx, ax          ;restore to dx for output
        mov     ax, cx          ;restore for output
        add     dx, SEG_pSrc
cEnd


ifdef DEBUG
cProc StkTrace,<NEAR, PUBLIC>
        parmW   cFrames
        parmD   lpBuf
cBegin
        push    es
        mov     cx, cFrames
        mov     bx, bp
        les     di, lpBuf
        cld
x:
        mov     bx, ss:[bx]
        and     bx, 0FFFEh
        mov     ax, ss:[bx+2]
        stosw
        loopnz  x
        pop     es
cEnd
endif

?WIN=0          ; turn off windows prolog/epilog stuff

;
;       SwitchDS
;
;  Routine to switch the DS to word argument
;  Called from C but without C DS glue.
;
cProc SwitchDS,<NEAR, PUBLIC>
parmW   newDS
cBegin
        mov     ax,ds           ; old DS is return value
        mov     ds,newDS
cEnd


sEnd    CODE            ;INIT_TEXT
end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\heapwach.c ===
#include "ddemlp.h"
#include "heapwach.h"
#ifdef WATCHHEAPS

extern char FAR SZHEAPWATCHCLASS[];
#define MAX_WINDOWS  20

typedef struct {
   WORD sel;
   HWND hwnd;
} SELWND;

char szT[30];

SELWND sw[MAX_WINDOWS];
int cHwnds = 0;


VOID LogAlloc(
DWORD lpstr,
WORD cb,
DWORD color,
HANDLE hInstance)
{
   int i;
   HWND hwnd;
   WORD sel;
   WORD off;
   int mj, mn, cl;
   HDC hdc;
   RECT rc, rcClient;
   HBRUSH hbr;

   sel = HIWORD(lpstr);
   hwnd = NULL;
   for (i = 0; i < cHwnds; i++) {
      if (sel == sw[i].sel) {
         hwnd = sw[i].hwnd;
         if (!IsWindow(hwnd)) {
             // this must have been destroyed and we are now reusing the sel.
             sw[i] = sw[--cHwnds];
             hwnd = NULL;
         }
         break;
      }
   }
   if (!hwnd && cHwnds < MAX_WINDOWS) {
      itoa((int)sel, szT, 16);
      sw[cHwnds].sel = sel;
      sw[cHwnds].hwnd = hwnd = CreateWindow(SZHEAPWATCHCLASS, szT,
            WS_POPUP | WS_CAPTION, CW_USEDEFAULT, CW_USEDEFAULT, 64, 64,
            NULL, NULL, hInstance, NULL);
      if (hwnd) {
         cHwnds++;
         GetWindowRect(hwnd, &rc);
         GetClientRect(hwnd, &rcClient);
         rc.bottom += 128 - (rcClient.bottom - rcClient.top);
         rc.right += 128 - (rcClient.right - rcClient.left);
         MoveWindow(hwnd, 0, 0, rc.right - rc.left, rc.bottom - rc.top, FALSE);
         ShowWindow(hwnd, SW_SHOWNORMAL);
      }
   }
   if (!hwnd) {
      return;
   }
   off = LOWORD(lpstr) >> 2;
   mj = off >> 7;
   mn = off & 0x7f;
   cl = cb >> 2;
   hdc = GetDC(hwnd);
   hbr = CreateSolidBrush(color);
   rc.top = mj;
   rc.bottom = rc.top + 1;
   rc.left = (int)mn;
   rc.right = min(127, mn + cl);
   FillRect(hdc, &rc, hbr);
   cl -= (int)(rc.right - rc.left);
   if (cl > 127) {
      rc.top++;
      rc.bottom = rc.top + cl / 128;
      rc.left = 0;
      rc.right = 127;
      FillRect(hdc, &rc, hbr);
      cl -= 128 * (cl / 128);
   }
   if (cl > 0) {
      rc.top = rc.bottom;
      rc.bottom++;
      rc.left = 0;
      rc.right = cl;
      FillRect(hdc, &rc, hbr);
   }
   DeleteObject(hbr);
   ReleaseDC(hwnd, hdc);
}


VOID CloseHeapWatch()
{
    int i;

    for (i = 0; i < cHwnds; i++) {
        DestroyWindow(sw[i].hwnd);
    }
    cHwnds = 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\heapwach.h ===
VOID LogAlloc(DWORD lpstr, WORD cb, DWORD color, HANDLE hInstance);
VOID CloseHeapWatch(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\libentry.asm ===
PAGE,132
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       LIBENTRY.ASM
;
;       Windows dynamic link library entry routine
;
;   This module generates a code segment called INIT_TEXT.
;   It initializes the local heap if one exists and then calls
;   the C routine LibMain() which should have the form:
;   BOOL FAR PASCAL LibMain(HANDLE hInstance,
;                           WORD   wDataSeg,
;                           WORD   cbHeap,
;                           LPSTR  lpszCmdLine);
;
;   The result of the call to LibMain is returned to Windows.
;   The C routine should return TRUE if it completes initialization
;   successfully, FALSE if some error occurs.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

include cmacros.inc

externFP <LibMain>               ; the C routine to be called

createSeg INIT_TEXT, INIT_TEXT, BYTE, PUBLIC, CODE
sBegin  INIT_TEXT
assumes CS,INIT_TEXT

?PLM=0                           ; 'C'naming
externA  <_acrtused>             ; ensures that Win DLL startup code is linked

?PLM=1                           ; 'PASCAL' naming
externFP <LocalInit>             ; Windows heap init routine

cProc   LibEntry, <PUBLIC,FAR>   ; entry point into DLL

include convdll.inc

cBegin
        push    di               ; handle of the module instance
        push    ds               ; library data segment
        push    cx               ; heap size
        push    es               ; command line segment
        push    si               ; command line offset

        ; if we have some heap then initialize it
        jcxz    callc            ; jump if no heap specified

        ; call the Windows function LocalInit() to set up the heap
        ; LocalInit((LPSTR)start, WORD cbHeap);

        xor     ax,ax
        cCall   LocalInit <ds, ax, cx>
        or      ax,ax            ; did it do it ok ?
        jz      error            ; quit if it failed

        ; invoke the C routine to do any special initialization

callc:
        call    LibMain          ; invoke the 'C' routine (result in AX)
        jmp short exit           ; LibMain is responsible for stack clean up

error:
        pop     si               ; clean up stack on a LocalInit error
        pop     es
        pop     cx
        pop     ds
        pop     di

exit:

cEnd

sEnd    INIT_TEXT

end LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\dmgwndp.c ===
/****************************** Module Header ******************************\
*
* Module Name: DMGWNDP.C
*
* This module contains all the window procs for the DDE manager.
*
* Created: 12/23/88 sanfords
*
* Copyright (c) 1988, 1989  Microsoft Corporation
\***************************************************************************/
#include "ddemlp.h"

VOID FreeDdeMsgData(WORD msg, LPARAM lParam);


/*
 * ----------------CLIENT SECTION------------------
 *
 * Each client conversation has associated with it a window and a queue.
 * A conversation has one synchronous transaction and may have many
 * asynchronous transactions.  A transaction is differientiated by its
 * state and other pertinant data.  A transaction may be synchronous,
 * asynchronous, (initiated by DdeMgrClientTransaction()), or it may be external,
 * (initiated by an advise loop.)
 *
 * A transaction is active if it is in the middle of tranfer, otherwise
 * it is shutdown.  A shutdown transaction is either successful or
 * failed.  When an asynchronous transaction shuts down, the client
 * is notified via the callback function. (XTYP_XACT_COMPLETE)
 *
 * The synchronous transaction, when active, is in a timeout loop which
 * can shut-down the transaction at the end of a predefined time period.
 * Shutdown synchronous transactions imediately transfer their information
 * to the client application by returning to DdeClientTransaction().
 *
 * active asynchronous transactions remain in the client queue until removed
 * by the client application via DdeAbandonTransaction() or by transaction
 * completion.
 *
 * external transactions take place when the client is in an advise
 * data loop.  These transactions pass through the callback function to
 * the client to be accepted.(XTYP_ADVDATA)
 */


/***************************** Private Function ****************************\
* long EXPENTRY ClientWndProc(hwnd, msg, mp1, mp2);
*
*   This window controls a single DDE conversation from the CLIENT side.
*   If closed, it will automaticly abort any conversationn in progress.
*   It maintains an internal list of any extra WM_DDEINITIATEACK messages
*   it receives so that it can be queried later about this information.
*   Any extra WM_DDEINITIATEACK messages comming in will be immediately
*   terminated.
*   It also maintains an internal list of all items which currently are
*   in active ADVISE loops.
*
* History:
*   Created     12/16/88    SANFORDS
\***************************************************************************/
LONG EXPENTRY ClientWndProc(hwnd, msg, wParam, lParam)
HWND hwnd;
WORD msg;
WORD wParam;
DWORD lParam;
{
    register PCLIENTINFO pci;
    long mrData;

#ifdef DEBUG
    LogDdeObject(msg | 0x4000, lParam);
#endif
    pci = (PCLIENTINFO)GetWindowLong(hwnd, GWL_PCI);

    switch (msg) {
    case WM_CREATE:
        return(ClientCreate(hwnd, LPCREATESTRUCT_GETPAI(lParam)));
        break;

    case UM_SETBLOCK:
        pci->ci.fs = (pci->ci.fs & ~(ST_BLOCKED | ST_BLOCKNEXT)) | wParam;
        if (!wParam || wParam & ST_BLOCKNEXT) {
            EmptyDDEPostQ();
        }
        break;

    case WM_DDE_ACK:
        if (pci->ci.xad.state == XST_INIT1 || pci->ci.xad.state == XST_INIT2) {
            ClientInitAck(hwnd, pci, wParam, (ATOM)LOWORD(lParam),(ATOM)HIWORD(lParam));
            //
            // This always returns TRUE -NOT BECAUSE THAT'S WHAT THE PROTOCOL
            // CALLS FOR but because some bad sample code got out and so
            // a lot of apps out there will delete the WM_DDE_ACK atoms
            // if a FALSE is returned.
            //
            return(TRUE);
        } else {
            DoClientDDEmsg(pci, hwnd, msg, (HWND)wParam, lParam);
            return(0);
        }
        break;

    case WM_DDE_DATA:
        DoClientDDEmsg(pci, hwnd, msg, (HWND)wParam, lParam);
        break;

    case UM_QUERY:
        /*
         * wParam = info index.
         * lParam = pData. If pData==0, return data else copy into pData.
         */
        switch (wParam) {
        case Q_CLIENT:
             mrData = TRUE;
             break;

        case Q_APPINFO:
             mrData = (long)(LPSTR)pci->ci.pai;
             break;
        }
        if (lParam == 0)
            return(mrData);
        else
            *(long FAR *)lParam = mrData;
        return(1);
        break;

    case WM_DDE_TERMINATE:
    case UM_TERMINATE:
        Terminate(hwnd, wParam, pci);
        break;

    case WM_TIMER:
        if (wParam == TID_TIMEOUT) {
            pci->ci.pai->wTimeoutStatus |= TOS_TICK;
        }
        break;

    case UM_DISCONNECT:
        Disconnect(hwnd, wParam, pci);
        break;

    case WM_DESTROY:
        SEMCHECKOUT();
        if (pci->ci.fs & ST_CONNECTED) {
            pci->ci.fs &= ~ST_PERM2DIE; // stops infinite loop
            Disconnect(hwnd, 0, pci);
        }
        if (pci->ci.fs & ST_NOTIFYONDEATH) {
            HWND hwndOwner;

            hwndOwner = GetWindow(hwnd, GW_OWNER);
            if (hwndOwner)
                PostMessage(hwndOwner, UM_DISCONNECT, ST_IM_DEAD, 0L);
        }
        SEMENTER();
        DestroyQ(pci->pQ);
        pci->pQ = NULL;
        DestroyQ(pci->ci.pPMQ);
        pci->ci.pPMQ = NULL;
        CleanupAdvList(hwnd, pci);
        DestroyLst(pci->pClientAdvList);
        if (pci->ci.xad.state != XST_INIT1) {
            FreeHsz(LOWORD(pci->ci.hszSvcReq));
            FreeHsz(pci->ci.aServerApp);
            FreeHsz(pci->ci.aTopic);
        }
        /*
         * remove all plstCB entries that reference this window.
         */
        {
            PCBLI pli, pliNext;

            for (pli = (PCBLI)pci->ci.pai->plstCB->pItemFirst;
                pli != NULL;
                    pli = (PCBLI)pliNext) {
                pliNext = (PCBLI)pli->next;
                if ((HWND)pli->hConv == hwnd) {
                    if (((PCBLI)pli)->hMemFree) {
                        GLOBALFREE(((PCBLI)pli)->hMemFree);
                    }
                    RemoveLstItem(pci->ci.pai->plstCB, (PLITEM)pli);
                }
            }
        }
        FarFreeMem((LPBYTE)pci);
        SEMLEAVE();
        // fall through

    default:
        return(DefWindowProc(hwnd, msg, wParam, lParam));
        break;
    }
    return(0);
}




/***************************** Private Function ****************************\
* This handles client window processing of WM_DDE_ACK and WM_DDE_DATA msgs.
* (Note that Acks to INITIATE messages are handled in ClientInitAck.)
* On exit pddes is freed.
*
* History:
*   Created     9/1/89    Sanfords
\***************************************************************************/
BOOL DoClientDDEmsg(
PCLIENTINFO pci,
HWND hwndClient,
WORD msg,
HWND hwndServer,
DWORD lParam)
{
    PCQDATA pqd;
    int i;
    ATOM aItem;
    LAP     far *lpLostAck;

    if (!(pci->ci.fs & ST_CONNECTED)) {
        FreeDdeMsgData(msg, lParam);
        return(FALSE);
    }

    /*
     * Check if it fits the synchronous transaction data
     */
    if (fExpectedMsg(&pci->ci.xad, lParam, msg)) {
        if (AdvanceXaction(hwndClient, pci, &pci->ci.xad, lParam, msg,
                &pci->ci.pai->LastError)) {
            if (pci->ci.pai->hwndTimer) {
                pci->ci.pai->wTimeoutStatus |= TOS_DONE;
            }
        }
        return TRUE;
    }

    /*
     * See if it fits any asynchronous transaction data - if any exist
     */
    if (pci->pQ != NULL && pci->pQ->pqiHead != NULL) {
        SEMENTER();
        pqd = (PCQDATA)pci->pQ->pqiHead;
        /*
         * cycle from oldest to newest.
         */
        for (i = pci->pQ->cItems; i; i--) {
            pqd = (PCQDATA)pqd->next;
            if (!fExpectedMsg(&pqd->xad, lParam, msg))
                continue;
            if (AdvanceXaction(hwndClient, pci, &pqd->xad, lParam, msg,
                    &pqd->xad.LastError)) {
                ClientXferRespond(hwndClient, &pqd->xad, &pqd->xad.LastError);
                SEMLEAVE();
                pci->ci.pai->LastError = pqd->xad.LastError;
                if (!pqd->xad.fAbandoned) {
                    MakeCallback(&pci->ci, MAKEHCONV(hwndClient), (HSZ)pci->ci.aTopic,
                            pqd->xad.pXferInfo->hszItem, pqd->xad.pXferInfo->wFmt,
                            XTYP_XACT_COMPLETE, pqd->xad.pdata,
                            MAKEID(pqd), (DWORD)pqd->xad.DDEflags, 0, 0, hwndServer,
                            0, FALSE);
                }
                return TRUE;
            }
            SEMLEAVE();
            return FALSE;
        }
        SEMLEAVE();
    }
    /*
     * It doesn't fit anything, assume its an advise data message.
     */
    if (msg == WM_DDE_DATA) {
        DDE_DATA FAR *pMem;
        PADVLI padvli;
        WORD wStatus;
        WORD wFmt;

        aItem = HIWORD(lParam);
        if (LOWORD(lParam)) {
            pMem = (DDE_DATA FAR*)GLOBALLOCK((HANDLE)LOWORD(lParam));
            if (pMem == NULL) {
                SETLASTERROR(pci->ci.pai, DMLERR_MEMORY_ERROR);
                return(FALSE);
            }
            wFmt = pMem->wFmt;
            wStatus = pMem->wStatus;
            GLOBALUNLOCK((HANDLE)LOWORD(lParam));
        } else {
            padvli = FindAdvList(pci->pClientAdvList, 0, 0, aItem, 0);
            if (padvli != NULL) {
                wFmt = padvli->wFmt;
            } else {
                wFmt = 0;
            }
            wStatus = DDE_FACK;
        }

        if (wStatus & DDE_FREQUESTED) {

            // Its out of line - drop it.

            if (wStatus & DDE_FACKREQ) {
                // ACK it
                PostDdeMessage(&pci->ci, WM_DDE_ACK, hwndClient,
                        MAKELONG(DDE_FACK, aItem), 0, 0);
            }
            FreeDDEData((HANDLE)LOWORD(lParam), wFmt);
            if (aItem)
                GlobalDeleteAtom(aItem);
            return FALSE;
        }
        MakeCallback(&pci->ci, MAKEHCONV(hwndClient), (HSZ)pci->ci.aTopic,
            (HSZ)aItem,
            wFmt,
            XTYP_ADVDATA,
            RecvPrep(pci->ci.pai, LOWORD(lParam), HDATA_NOAPPFREE),
            0, 0, msg, pMem ? wStatus : 0, (HWND)pci->ci.hConvPartner, 0, FALSE);
        return TRUE;
    }

    AssertF(pci->ci.xad.state != XST_INIT1 && pci->ci.xad.state != XST_INIT2,
        "Init logic problem");
    AssertF(msg == WM_DDE_ACK, "DoClientDDEMsg() logic problem");

    /*
     * throw it away ... first find the lost ack in in the lost ack pile
     */

    if (lpLostAck = (LAP far *)FindPileItem(pLostAckPile, CmpWORD,
            PHMEM(lParam), FPI_DELETE)) {
        if (lpLostAck->type == XTYP_EXECUTE) {
            GLOBALFREE((HANDLE)HIWORD(lParam));
        } else {
            if (HIWORD(lParam)) {
                GlobalDeleteAtom(HIWORD(lParam));    // message copy
            }
        }
    } else {
        AssertF(FALSE, "DoClientDDEmsg: could not find lost ack");
        // its a fairly safe assumption we didn't get a random execute ACK
        // back so free the atom.
        if (HIWORD(lParam)) {
            GlobalDeleteAtom(HIWORD(lParam));    // message copy
        }
    }

    return FALSE;
}



/***************************** Private Function ****************************\
* This routine matches a conversation transaction with a DDE message.  If
* the state, wType, format, itemname dde structure data and the message
* received all agree, TRUE is returned.  It only handles DATA or ACK messages.
*
* History:
*   Created     9/1/89    Sanfords
\***************************************************************************/
BOOL fExpectedMsg(
PXADATA pXad,
DWORD lParam,
WORD msg)
{
    DDEDATA FAR *pMem;

    if (msg == WM_DDE_DATA) {
        BOOL fRet;

        if (pXad->state != XST_REQSENT)
            return(FALSE);

        if (!(pMem = (DDEDATA FAR*)GLOBALLOCK(LOWORD(lParam))))
            return(FALSE);

        /* make sure the format and item name match  */

        fRet = pMem->fResponse &&
                ((WORD)pMem->cfFormat == pXad->pXferInfo->wFmt) &&
                (HIWORD(lParam) == LOWORD(pXad->pXferInfo->hszItem));
        GLOBALUNLOCK(LOWORD(lParam));
        return(fRet);
    }

    switch (pXad->state) {
    case XST_REQSENT:
    case XST_POKESENT:
    case XST_ADVSENT:
    case XST_UNADVSENT:
        return((msg == WM_DDE_ACK) &&
                HIWORD(lParam) == LOWORD(pXad->pXferInfo->hszItem));
        break;

    case XST_EXECSENT:
        /* we expect an ACK with a data handle matching that sent */
        return((msg == WM_DDE_ACK) &&
                (HIWORD(lParam) == HIWORD(pXad->pXferInfo->hDataClient)));
        break;
    }

    return(FALSE);
}



/***************************** Private Function ****************************\
* This function assumes that msg is an apropriate message for the transaction
* referenced by pXad.  It acts on msg as apropriate.  pddes is the DDESTRUCT
* associated with msg.
*
* Returns fSuccess ie: transaction is ready to close up.
*
* History:
*   Created     9/1/89    Sanfords
\***************************************************************************/
BOOL AdvanceXaction(hwnd, pci, pXad, lParam, msg, pErr)
HWND hwnd;
PCLIENTINFO pci;
PXADATA pXad;
DWORD lParam;
WORD msg;
LPWORD pErr;
{
    HANDLE  hData;
    LPSTR   pMem;
    WORD    lo,hi;

    pXad->DDEflags = 0;
    lo = LOWORD(lParam);
    hi = HIWORD(lParam);

    switch (msg) {
    case WM_DDE_ACK:
        if (pXad->state == XST_EXECSENT || !(lo & DDE_FACK))
            FreeDataHandle(pci->ci.pai, pXad->pXferInfo->hDataClient, TRUE);
        if (pXad->pXferInfo->pulResult != NULL)
            *(LPWORD)pXad->pXferInfo->pulResult = lo;

        switch (pXad->state) {
        case XST_ADVSENT:
        case XST_EXECSENT:
        case XST_POKESENT:
        case XST_REQSENT:
        case XST_UNADVSENT:
            if (lo & DDE_FACK) {
                /*
                 * handle successes
                 */
                switch (pXad->state) {
                case XST_POKESENT:
                    pXad->state = XST_POKEACKRCVD;
                    break;

                case XST_EXECSENT:
                    pXad->state = XST_EXECACKRCVD;
                    break;

                case XST_ADVSENT:
                    pXad->state = XST_ADVACKRCVD;
                    break;

                case XST_UNADVSENT:
                    pXad->state = XST_UNADVACKRCVD;
                    break;

                case XST_REQSENT:
                    /*
                     * requests are not expected to send a +ACK.  only
                     * -ACK or data.  We ignore a +ACK to a request.
                     */
                    return(FALSE);
                }
            } else {    // NACK
                /*
                 * handle the expected ACK failures.
                 */
                hData = (HANDLE)HIWORD(pXad->pXferInfo->hDataClient);
                *pErr = DMLERR_NOTPROCESSED;
                if (lo & DDE_FBUSY)
                    *pErr = DMLERR_BUSY;
                switch (pXad->state) {
                case XST_POKESENT:
                    /* free the hData sent with original message */
                    /* but only if fRelease was set */
                    pMem = GLOBALLOCK(hData);
                    /* we stowed the handle in lo word */
                    if (pMem && ((DDEPOKE FAR*)pMem)->fRelease)
                            FreeDDEData(hData, ((DDEPOKE FAR*)pMem)->cfFormat);
                    break;

                case XST_ADVSENT:
                    /* free the hOptions sent with original message */
                    /* we stowed the handle in hDataClient */
                    GLOBALFREE(hData);
                    break;

                }
                pXad->state = XST_INCOMPLETE;
            }
        }
        return(TRUE);
        break;

    case WM_DDE_DATA:
        switch (pXad->state) {
        case XST_REQSENT:
        case XST_ADVSENT:
            pXad->state = XST_DATARCVD;
            /*
             * send an ack if requested - we dare not return the given
             * lParam because it may be a data item sent to several
             * clients and we would mess up the fsStatus word for
             * all processes involved.
             */
            pMem = GLOBALLOCK((HANDLE)lo);

            if (pMem != NULL) {
                if (!((DDEDATA FAR*)pMem)->fRelease) {
                    //
                    // Since this is potentially a synchronous request which
                    // the app has to free, we must give the app a copy
                    // so the origonal one can safely be freed by the server.
                    //
                    pXad->pdata = CopyHDDEDATA(pci->ci.pai, MAKELONG(0, lo));
                } else {
                    pXad->pdata = RecvPrep(pci->ci.pai, lo, 0);
                }
                if (((DDEDATA FAR*)pMem)->fAckReq) {
                    // reuse atom from data message
                    PostDdeMessage(&pci->ci, WM_DDE_ACK, hwnd, MAKELONG(DDE_FACK, hi), 0, 0);
                } else {
                    if (hi) {
                        GlobalDeleteAtom(hi);   // free message copy
                    }
                }
            }
            return(TRUE);
            break;
        }
    }
    return(FALSE);
}




VOID CheckCBQ(
PAPPINFO pai)
{
    PCBLI pli, pliNext;
    PCLIENTINFO pci;
    BOOL fBreak;
    DWORD dwRet;

    /*
     * This is where we actually do callbacks.  We do them via this
     * window proc so that we can asynchronously institute callbacks
     * via a PostMsg().
     */
    SEMCHECKOUT();
    SEMENTER();
    /*
     * process all enabled conversation callbacks.
     */
    fBreak = FALSE;
    for (pli = (PCBLI)pai->plstCB->pItemFirst;
        pai->lpMemReserve && !fBreak && pli; pli = (PCBLI)pliNext) {
            pliNext = (PCBLI)pli->next;

        if (pai->cInProcess) // covers us on recursion
            break;

        // auto-flush for dead conversations.
        if (!IsWindow((HWND)pli->hConv) ||
                ((pci = (PCLIENTINFO)GetWindowLong((HWND)pli->hConv, GWL_PCI)) == NULL) ||
                !(pci->ci.fs & ST_CONNECTED)) {
            /*
             * auto-flush for disconnected conversations.
             */
            if (((PCBLI)pli)->hMemFree) {
                GLOBALFREE(((PCBLI)pli)->hMemFree);
            }
            RemoveLstItem(pai->plstCB, (PLITEM)pli);
            continue;
        }

        if (pci->ci.fs & ST_BLOCKED)
            continue;

        if (pci->ci.fs & ST_BLOCKNEXT) {
            pci->ci.fs |= ST_BLOCKED;
            pci->ci.fs &= ~ST_BLOCKNEXT;
        }

        if (pli->fQueueOnly) {
            dwRet = 0;
#ifdef DEBUG
            if (pli->hMemFree) {
                LogDdeObject(0xE000, pli->hMemFree);
            }
#endif
        } else {
            /*
             * make the actual callback here.
             */
#ifdef DEBUG
            if (pli->hMemFree) {
                LogDdeObject(0xD000, pli->hMemFree);
            }
#endif
            dwRet = DoCallback(pai, pli->hConv, pli->hszTopic,
                    pli->hszItem, pli->wFmt, pli->wType, pli->hData,
                    pli->dwData1, pli->dwData2);
        }

        /*
         * If the callback resulted in a BLOCK, disable this conversation.
         */
        if (dwRet == CBR_BLOCK && !(pli->wType & XTYPF_NOBLOCK)) {
            pci->ci.fs |= ST_BLOCKED;
            continue;
        } else {
            /*
             * otherwise finish processing the callback.
             */
            QReply(pli, dwRet);
            RemoveLstItem(pai->plstCB, (PLITEM)pli);
        }
    }
    SEMLEAVE();
}





/*
 * This function handles disconnecting a conversation window.  afCmd contains
 * ST_ flags that describe what actions to take.
 */
void Disconnect(
HWND hwnd,
WORD afCmd,
PCLIENTINFO pci)
{
    if (afCmd & ST_CHECKPARTNER) {
        if (!IsWindow((HWND)pci->ci.hConvPartner)) {
            if (pci->ci.fs & ST_TERM_WAITING) {
                pci->ci.fs &= ~ST_TERM_WAITING;
                pci->ci.pai->cZombies--;
                TRACETERM((szT, "Disconnect: Checked partner is dead.  Zombies decremented.\n"));
                pci->ci.fs |= ST_TERMINATED;
            }
        }
        afCmd &= ~ST_CHECKPARTNER;
    }

    // Do NOT do disconnects within timeout loops!
    if (pci->ci.pai->hwndTimer == hwnd) {
        pci->ci.pai->wTimeoutStatus |= TOS_ABORT;
        pci->ci.fs |= ST_DISC_ATTEMPTED;
        TRACETERM((szT, "Disconnect: defering disconnect of %x.  Aborting timeout loop.\n",
                hwnd));
        return;
    }
    /*
     * note disconnect call for ddespy apps
     */
    MONCONN(pci->ci.pai, pci->ci.aServerApp, pci->ci.aTopic,
            ((pci->ci.fs & ST_CLIENT) ? hwnd : (HWND)pci->ci.hConvPartner),
            ((pci->ci.fs & ST_CLIENT) ? (HWND)pci->ci.hConvPartner : hwnd),
            FALSE);
    /*
     * or in optional ST_PERM2DIE bit from caller
     */
    pci->ci.fs |= afCmd;

    /*
     * Terminate states fall through the following stages:
     *
     * 1) connected, not_waiting(for ack term)
     * 2) disconnected, waiting
     * 3) disconnected, not_waiting, terminated
     * 4) disconnected, not_waiting, terminated, perm to die
     * 5) self destruct window
     *
     * If the disconnect operation was originated by the other side:
     *
     * 1) connected, not_waiting
     * 2) disconected, not_waiting, terminated
     * 3) disconnected, not_waiting, teriminated perm to die
     * 4) self desstruct window
     *
     * Note that a postmessage may fail for 2 reasons:
     * 1) the partner window is dead - in which case we just dispense
     *    with terminates altogether and pretend we are terminated.
     * 2) the target queue is full.  This won't happen on NT but
     *    could on win31.  PostDdeMessage handles this case by
     *    queueing the outgoing message on our side and continuing
     *    to try to get it posted and hangs around for the ACK.
     *    This function can only fail if the target window died or
     *    we ran out of memory.  In either case, we have to punt on
     *    terminates and consider ourselves disconnected and terminated.
     *
     *    When we do get into a state where we are waiting for a
     *    terminate, we increment our zombie count.  This gets
     *    decremented when either we get the expected terminate or
     *    our partner window dies/postmessage fails.
     */

    if (pci->ci.fs & ST_CONNECTED) {
        if (pci->ci.fs & ST_CLIENT) {
            AbandonTransaction(hwnd, pci->ci.pai, NULL, FALSE);
        }
        CleanupAdvList(hwnd, pci);

        pci->ci.fs &= ~ST_CONNECTED;

        if (PostDdeMessage(&pci->ci, WM_DDE_TERMINATE, hwnd, 0L, 0, 0)) {
            if (!(pci->ci.fs & ST_TERM_WAITING)) {
                pci->ci.fs |= ST_TERM_WAITING;
                pci->ci.pai->cZombies++;
                TRACETERM((szT, "cZombies incremented..."));
            }
            TRACETERM((szT,
                    "Disconnect: Posted Terminate(%x->%x)\n",
                    hwnd, (HWND)pci->ci.hConvPartner,
                    ((LPAPPINFO)pci->ci.pai)->cZombies));
        } else {
            pci->ci.fs |= ST_TERMINATED;
            if (pci->ci.fs & ST_TERM_WAITING) {
                pci->ci.fs &= ~ST_TERM_WAITING;
                pci->ci.pai->cZombies--;
                TRACETERM((szT, "cZombies decremented..."));
            }
            TRACETERM((szT,
                    "Disconnect: Terminate post(%x->%x) failed.\n",
                    hwnd,
                    (HWND)pci->ci.hConvPartner));
        }
        pci->ci.xad.state = XST_NULL;
    }

    TRACETERM((szT,
               "Disconnect: cZombies=%d[%x:%x].\n",
               pci->ci.pai->cZombies,
               HIWORD(&((LPAPPINFO)pci->ci.pai)->cZombies),
               LOWORD(&((LPAPPINFO)pci->ci.pai)->cZombies)));

    /*
     * Self destruction is only allowed when we have permission to die,
     * are disconnected, are not waiting for a terminate, and are
     * terminated.
     */
    if ((pci->ci.fs & (ST_CONNECTED | ST_PERM2DIE | ST_TERMINATED | ST_TERM_WAITING)) ==
            (ST_PERM2DIE | ST_TERMINATED)) {
        DestroyWindow(hwnd);
        TRACETERM((szT, "Disconnect: Destroying %x.\n", hwnd));
    }
}


/*
 * This function handles WM_DDE_TERMINATE processing for a conversation window.
 */
void Terminate(
HWND hwnd,
HWND hwndFrom,
PCLIENTINFO pci)
{
    SEMCHECKOUT();


    /*
     * Only accept terminates from whom we are talking to.  Anything else
     * is noise.
     */
    if (hwndFrom != (HWND)pci->ci.hConvPartner) {
        // bogus extra-ack terminate - ignore
        TRACETERM((szT, "Terminate: %x is ignoring terminate from %x.  Partner should be %x!\n",
                hwnd, hwndFrom, (HWND)pci->ci.hConvPartner));
        return;
    }

    /*
     * If we are in a timeout loop, cancel it first.  We will come back
     * here when we recieve our self-posted terminate message.
     */
    if (pci->ci.pai->hwndTimer == hwnd) {
        pci->ci.pai->wTimeoutStatus |= TOS_ABORT;
        PostMessage(hwnd, UM_TERMINATE, hwndFrom, 0);
        TRACETERM((szT, "Terminate: Canceling timeout loop for %x.\n",
                pci->ci.pai));
        return;
    }

    if (pci->ci.fs & ST_CONNECTED) {
        /*
         * unexpected/initial external terminate case
         */
        if (pci->ci.fs & ST_CLIENT) {
            /*
             * Abandon any async transactions that may be in progress
             * on this conversation.
             */
            AbandonTransaction(hwnd, pci->ci.pai, NULL, FALSE);
        }

        /*
         * Make any remaining queued up callbacks first.
         */
        CheckCBQ(pci->ci.pai);

        pci->ci.fs &= ~ST_CONNECTED;
        pci->ci.fs |= ST_TERMINATED  | ST_PERM2DIE;
        TRACETERM((szT, "Terminate: received in connected state.(%x<-%x), fs=%x\n",
                hwnd, (HWND)pci->ci.hConvPartner, pci->ci.fs));
        MONCONN(pci->ci.pai, pci->ci.aServerApp, pci->ci.aTopic,
                (pci->ci.fs & ST_CLIENT) ? hwnd : (HWND)pci->ci.hConvPartner,
                (pci->ci.fs & ST_CLIENT) ? (HWND)pci->ci.hConvPartner : hwnd, FALSE);

        if (PostDdeMessage(&pci->ci, WM_DDE_TERMINATE, hwnd, 0L, 0, 0)) {
            TRACETERM((szT, "Terminate: Posting ack terminate(%x->%x).\n",
                    hwnd, (HWND)pci->ci.hConvPartner));
        } else {
            TRACETERM((szT, "Terminate: Posting ack terminate(%x->%x) failed.\n",
                    hwnd, (HWND)pci->ci.hConvPartner));
        }
        DoCallback(pci->ci.pai, MAKEHCONV(hwnd), 0, 0, 0, XTYP_DISCONNECT, 0L, 0L,
                pci->ci.fs & ST_ISSELF ? 1 : 0);
        pci->ci.xad.state = XST_NULL;

        CleanupAdvList(hwnd, pci);

    }

    if (pci->ci.fs & ST_TERM_WAITING) {
        pci->ci.fs &= ~ST_TERM_WAITING;
        pci->ci.pai->cZombies--;
        TRACETERM((szT, "cZombies decremented..."));
        /*
         * expected external terminate case
         */
        TRACETERM((szT, "Terminate: Received ack terminate(%x<-%x), cZombies=%d[%x:%x].\n",
                hwnd, (HWND)pci->ci.hConvPartner,
                ((LPAPPINFO)pci->ci.pai)->cZombies,
                HIWORD(&((LPAPPINFO)pci->ci.pai)->cZombies),
                LOWORD(&((LPAPPINFO)pci->ci.pai)->cZombies)));

    }

    pci->ci.fs |= ST_TERMINATED;

    if (pci->ci.fs & ST_PERM2DIE) {
        DestroyWindow(hwnd);
        TRACETERM((szT, "Terminate: Destroying %x.\n", hwnd));
    }
}





/*
 * ----------------------------SERVER SECTION--------------------------------
 */



/***************************** Public  Function ****************************\
* long EXPENTRY ServerWndProc(hwnd, msg, mp1, mp2)
* HWND hwnd;
* WORD msg;
* MPARAM mp1;
* MPARAM mp2;
*
* DESCRIPTION:
*   This processes DDE conversations from the server end.
*   It stores internal information and acts much like a state machine.
*   If closed, it will automaticly abort any conversation in progress.
*   It also maintains an internal list of all items which currently are
*   in active ADVISE loops.
* PUBDOC START
*   These server windows have the feature that a conversation can be
*   re-initiated with them by a client.  The Client merely terminates
*   the conversation and then re-initiates by using a SendMsg to this
*   window.  This allows a client to change the topic of the conversation
*   or to pass the conversation on to another client window without
*   loosing the server it initiated with.   This is quite useful for
*   wild initiates.
* PUBDOC END
*
* History:
* 10/18/89 sanfords Added hack to make hszItem==0L when offszItem==offabData.
* 1/4/89   sanfords created
\***************************************************************************/
long EXPENTRY ServerWndProc(hwnd, msg, wParam, lParam)
HWND hwnd;
WORD msg;
WORD wParam;
DWORD lParam;
{

    register PSERVERINFO psi;
    long mrData;
    HDDEDATA hData = 0L;
    WORD wFmt = 0;
    WORD wStat = 0;

#ifdef DEBUG
    LogDdeObject(msg | 0x8000, lParam);
#endif
    psi = (PSERVERINFO)GetWindowLong(hwnd, GWL_PCI);

    switch (msg) {
    case WM_DDE_REQUEST:
    case WM_DDE_ACK:
    case WM_DDE_ADVISE:
    case WM_DDE_UNADVISE:
    case WM_DDE_POKE:
    case WM_DDE_EXECUTE:
        ServerProcessDDEMsg(psi, msg, hwnd, (HWND)wParam, LOWORD(lParam), HIWORD(lParam));
        return(0);
    }

    switch (msg) {
    case WM_CREATE:
        return(ServerCreate(hwnd, LPCREATESTRUCT_GETPAI(lParam)));
        break;

    case UM_SETBLOCK:
        psi->ci.fs = (psi->ci.fs & ~(ST_BLOCKED | ST_BLOCKNEXT)) | wParam;
        if (!wParam || wParam & ST_BLOCKNEXT) {
            EmptyDDEPostQ();
        }
        break;

    case UMSR_CHGPARTNER:
        psi->ci.hConvPartner = MAKEHCONV(wParam);
        break;

    case UM_QUERY:
        /*
         * wParam = info index.
         * lParam = pData.     If pData==0, return data else copy into pData.
         */
        switch (wParam) {
        case Q_CLIENT:
             mrData = FALSE;
             break;

        case Q_APPINFO:
             mrData = (long)(LPSTR)psi->ci.pai;
             break;
        }
        if (lParam == 0)
            return(mrData);
        else
            *(long FAR *)lParam = mrData;
        return(1);
        break;

    case WM_DDE_TERMINATE:
    case UM_TERMINATE:
        Terminate(hwnd, (HWND)wParam, (PCLIENTINFO)psi);
        break;

    case UM_DISCONNECT:
        Disconnect(hwnd, wParam, (PCLIENTINFO)psi);
        break;

    case WM_TIMER:
        if (wParam == TID_TIMEOUT) {
            psi->ci.pai->wTimeoutStatus |= TOS_TICK;
        }
        break;

    case WM_DESTROY:
        SEMCHECKOUT();
        /*
         * Send ourselves a terminate and free local data.
         */
        if (psi->ci.fs & ST_CONNECTED) {
            psi->ci.fs &= ~ST_PERM2DIE; // stops infinite loop
            Disconnect(hwnd, 0, (PCLIENTINFO)psi);
        }
        if (psi->ci.fs & ST_NOTIFYONDEATH) {
            PostMessage(psi->ci.pai->hwndSvrRoot, UM_DISCONNECT, ST_IM_DEAD, 0L);
        }
        SEMENTER();
        CleanupAdvList(hwnd, (PCLIENTINFO)psi);
        FreeHsz(psi->ci.aServerApp);
        FreeHsz(LOWORD(psi->ci.hszSvcReq));
        FreeHsz(psi->ci.aTopic);
        DestroyQ(psi->ci.pPMQ);
        psi->ci.pPMQ = NULL;
        /*
         * remove all plstCB entries that reference this window.
         */
        {
            PCBLI pli, pliNext;

            for (pli = (PCBLI)psi->ci.pai->plstCB->pItemFirst;
                pli != NULL;
                    pli = (PCBLI)pliNext) {
                pliNext = (PCBLI)pli->next;
                if ((HWND)pli->hConv == hwnd) {
                    if (((PCBLI)pli)->hMemFree) {
                        GLOBALFREE(((PCBLI)pli)->hMemFree);
                    }
                    RemoveLstItem(psi->ci.pai->plstCB, (PLITEM)pli);
                }
            }
        }
        FarFreeMem((LPBYTE)psi);
        SEMLEAVE();
        // fall through

    default:
        return(DefWindowProc(hwnd, msg, wParam, lParam));
        break;
    }
    return(0);
}



/*
 * ----------------FRAME SECTION------------------
 *
 * A frame window exists on behalf of every registered thread.  It
 * handles conversation initiation and therefore issues callbacks
 * to the server app as needed to notify or query the server app.
 * The callback queue is always bypassed for these synchronous
 * events.
 */

/***************************** Private Function ****************************\
* long EXPENTRY subframeWndProc(hwnd, msg, mp1, mp2)
* HWND hwnd;
* WORD msg;
* MPARAM mp1;
* MPARAM mp2;
*
* This routine takes care of setting up server windows as needed to respond
* to incomming WM_DDE_INTIIATE messages.  It is subclassed from the top
* level frame of the server application.
*
* History:  created 12/20/88    sanfords
\***************************************************************************/
long EXPENTRY subframeWndProc(hwnd, msg, wParam, lParam)
HWND hwnd;
WORD msg;
WORD wParam;
DWORD lParam;
{
    switch (msg) {
    case WM_CREATE:
        SetWindowWord(hwnd, GWW_PAI, (WORD)LPCREATESTRUCT_GETPAI(lParam));
        break;

    case WM_DDE_INITIATE:
        ServerFrameInitConv((PAPPINFO)GetWindowWord(hwnd, GWW_PAI), hwnd, (HWND)wParam, LOWORD(lParam), HIWORD(lParam));
        break;

    default:
        return(DefWindowProc(hwnd, msg, wParam, lParam));
        break;
    }
}





/*
 * This version only goes one level deep
 */
VOID ChildMsg(
HWND hwndParent,
WORD msg,
WORD wParam,
DWORD lParam,
BOOL fPost)
{
    register HWND hwnd;
    register HWND hwndNext;

    if (!IsWindow(hwndParent)) {
        return;
    }

    if (!(hwnd = GetWindow(hwndParent, GW_CHILD)))
        return;

    do {
        // incase hwnd goes away during send or post
        hwndNext = GetWindow(hwnd, GW_HWNDNEXT);
        if (fPost) {
            PostMessage(hwnd, msg, wParam, lParam);
        } else {
            SendMessage(hwnd, msg, wParam, lParam);
        }
        hwnd = hwndNext;
    } while (hwnd);
}


/*
 * main application window - parent of all others in app.
 */
long EXPENTRY DmgWndProc(hwnd, msg, wParam, lParam)
HWND hwnd;
WORD msg;
WORD wParam;
DWORD lParam;
{
#define pai ((PAPPINFO)lParam)
    hwnd;
    wParam;

    switch (msg) {
    case WM_CREATE:
        SetWindowWord(hwnd, GWW_PAI, (WORD)LPCREATESTRUCT_GETPAI(lParam));
        break;

    case UM_REGISTER:
    case UM_UNREGISTER:
        return(ProcessRegistrationMessage(hwnd, msg, wParam, lParam));
        break;

    case UM_FIXHEAP:
        {
            // lParam = pai;
            PCBLI pcbli;            // current point of search
            PCBLI pcbliStart;       // search start point
            PCBLI pcbliNextStart;   // next search start point

            if (pai->cInProcess) {
                // repost and wait till this is clear.
                PostMessage(hwnd, UM_FIXHEAP, 0, lParam);
                return(0);
            }

            /*
             * We are probably in an impossible situation here - the callback queue
             * is likely stuffed full of advise data callbacks because the
             * server data changes are outrunning the client's ability to
             * process them.
             *
             * Here we attempt to remove all duplicated advise data callbacks from
             * the queue leaving only the most recent entries.  We assume we can
             * do this now because we are not InProcess and this is in response
             * to a post message.
             */

            SEMENTER();

            pcbliStart = (PCBLI)pai->plstCB->pItemFirst;

            do {

                while (pcbliStart && pcbliStart->wType != XTYP_ADVDATA) {
                    pcbliStart = (PCBLI)pcbliStart->next;
                }

                if (!pcbliStart) {
                    break;
                }

                pcbli = (PCBLI)pcbliStart->next;

                if (!pcbli) {
                    break;
                }

                while (pcbli) {

                    if (pcbli->wType    == XTYP_ADVDATA         &&
                        pcbli->hConv    == pcbliStart->hConv    &&
                        pcbli->hszItem  == pcbliStart->hszItem  &&
                        pcbli->wFmt     == pcbliStart->wFmt) {

                        // Match, remove older copy
                        QReply(pcbliStart, DDE_FBUSY);
                        pcbliNextStart = (PCBLI)pcbliStart->next;
                        RemoveLstItem(pai->plstCB, (PLITEM)pcbliStart);
                        pcbliStart = pcbliNextStart;
                        break;
                    } else {

                        pcbli = (PCBLI)pcbli->next;
                    }
                }
                if (!pcbli) {
                    pcbliStart = (PCBLI)pcbliStart->next;
                }
            } while (TRUE);

            if (pai->lpMemReserve == NULL) {
                pai->lpMemReserve = FarAllocMem(pai->hheapApp, CB_RESERVE);
            }

            SEMLEAVE();
        }
        // Fall Through...

    case UM_CHECKCBQ:
        CheckCBQ(pai);
        return(0);
        break;

    default:
        DefWindowProc(hwnd, msg, wParam, lParam);
        break;
    }
#undef pai
}


// this proc creates a window that only hangs around till its children are
// all gone and its been given the ok to go.
long EXPENTRY ConvListWndProc(hwnd, msg, wParam, lParam)
HWND hwnd;
WORD msg;
WORD wParam;
DWORD lParam;
{
    switch (msg) {
    case WM_CREATE:
        SetWindowWord(hwnd, GWW_STATE, 0);
        SetWindowWord(hwnd, GWW_CHECKVAL, ++hwInst);
        if (((LPCREATESTRUCT)lParam)->lpCreateParams) {
            SetWindowWord(hwnd, GWW_PAI, (WORD)LPCREATESTRUCT_GETPAI(lParam));
        }
        else {
            SetWindowWord(hwnd, GWW_PAI, 0);
        }

        break;

    case UM_SETBLOCK:
        ChildMsg(hwnd, UM_SETBLOCK, wParam, lParam, FALSE);
        break;

    case UM_DISCONNECT:
        switch (wParam) {

        case ST_PERM2DIE:
            SetWindowWord(hwnd, GWW_STATE, ST_PERM2DIE);
            ChildMsg(hwnd, UM_DISCONNECT, ST_PERM2DIE | ST_NOTIFYONDEATH, 0L, FALSE);
        case ST_IM_DEAD:
            if (GetWindowWord(hwnd, GWW_STATE) == ST_PERM2DIE &&
                    !GetWindow(hwnd, GW_CHILD)) {
                DestroyWindow(hwnd);
            }
            break;
        }
        break;

    default:
        return(DefWindowProc(hwnd, msg, wParam, lParam));
        break;
    }
}


HDDEDATA DoCallback(
PAPPINFO pai,
HCONV hConv,
HSZ hszTopic,
HSZ hszItem,
WORD wFmt,
WORD wType,
HDDEDATA hData,
DWORD dwData1,
DWORD dwData2)
{
    HDDEDATA dwRet, dwT;
    EXTDATAINFO edi;

    SEMCHECKIN();

    /*
     * in case we somehow call this before initialization is complete.
     */
    if (pai == NULL || pai->pfnCallback == NULL)
        return(0);

    /*
     * skip callbacks filtered out.
     */
    if (aulmapType[(wType & XTYP_MASK) >> XTYP_SHIFT] & pai->afCmd) {
        /*
         * filtered.
         */
        return(0);
    }
    /*
     * neuter callbacks once in DdeUninitiate() mode. (No data in or out)
     */
    if (pai->wFlags & AWF_UNINITCALLED &&
            wType & (XCLASS_DATA | XCLASS_FLAGS)) {
        return(0);
    }


    if (hData) {        // map ingoing data handle
        edi.pai = pai;
        edi.hData = hData | HDATA_NOAPPFREE;
        hData = (HDDEDATA)(LPSTR)&edi;
    }

    pai->cInProcess++;

    TRACEAPIIN((szT, "DDEMLCallback(%hx, %hx, %x, %x, %x, %x, %x, %x)\n",
            wType, wFmt, hConv, hszTopic, hszItem, hData, dwData1, dwData2));

    SEMLEAVE();
    dwRet = (*pai->pfnCallback)
            (wType, wFmt, hConv, hszTopic, hszItem, hData, dwData1, dwData2);

    TRACEAPIOUT((szT, "DDEMLCallback:%x\n", dwRet));

    if (cMonitor &&  wType != XTYP_MONITOR) {
    // Copy the hData otherwise we SendMsg a pointer to stuff on the stack
    // which doesn't work too well if we're running from a 32bit app!
    if (hData) {
        LPBYTE pDataNew = GLOBALPTR(GLOBALALLOC(GPTR, sizeof(edi)));
        if (pDataNew) {
                hmemcpy(pDataNew, &edi, sizeof(edi));
                MonBrdcastCB(pai, wType, wFmt, hConv, hszTopic, hszItem, (HDDEDATA)pDataNew,
                    dwData1, dwData2, dwRet);
                GLOBALFREE((HGLOBAL)HIWORD(pDataNew));
            }
    }
    else {
            MonBrdcastCB(pai, wType, wFmt, hConv, hszTopic, hszItem, hData,
                dwData1, dwData2, dwRet);
    }
    }

    SEMENTER();
    pai->cInProcess--;

    // unmap outcomming data handle.
    if (dwRet && wType & XCLASS_DATA && dwRet != CBR_BLOCK) {
        dwT = (HDDEDATA)((LPEXTDATAINFO)dwRet)->hData;
        if (!(LOWORD(dwT) & HDATA_APPOWNED)) {
            FarFreeMem((LPSTR)dwRet);
        }
        dwRet = dwT;
    }

    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\hdata.c ===
/****************************** Module Header ******************************\
* Module Name: HDATA.C
*
* DDE manager data handle handling routines
*
* Created: 12/14/90 Sanford Staab
*
* Copyright (c) 1988, 1989, 1990 Microsoft Corporation
\***************************************************************************/

#include "ddemlp.h"

HDDEDATA PutData(pSrc, cb, cbOff, aItem, wFmt, afCmd, pai)
LPBYTE pSrc;
DWORD cb;
DWORD cbOff;
ATOM aItem;
WORD wFmt;
WORD afCmd;
PAPPINFO pai;
{
    HANDLE hMem;
    HDDEDATA hdT;
    DIP   dip;

    /* HACK ALERT!
     * make sure the first two words req'd by windows dde is there,
     * UNLESS aItem is null in which case we assume it is EXECUTE
     * data and don't bother.
     */
    if (aItem)
        cbOff += 4L;
    else
        afCmd |= HDATA_EXEC;

    if ((hMem = AllocDDESel(
            (afCmd & HDATA_APPOWNED) ? DDE_FACKREQ : DDE_FRELEASE,
            wFmt, cb + cbOff)) == NULL) {
        SETLASTERROR(pai, DMLERR_MEMORY_ERROR);
        return(0L);
    }


    // add to local list - make sure a similar handle isn't already there.

    hdT = MAKELONG(afCmd, hMem);
#ifdef DEBUG
    if (FindPileItem(pai->pHDataPile, CmpHIWORD, (LPBYTE)&hdT, FPI_DELETE)) {
        AssertF(FALSE, "PutData - unexpected handle in hDataPile");
    }
#endif // DEBUG

    if (AddPileItem(pai->pHDataPile, (LPBYTE)&hdT, CmpHIWORD) == API_ERROR) {
        GLOBALFREE(hMem);
        SETLASTERROR(pai, DMLERR_MEMORY_ERROR);
        return(0L);
    }

    // add to global list if appowned

    if (afCmd & HDATA_APPOWNED) {
        dip.hData = hMem;
        dip.hTask = pai->hTask;
        dip.cCount = 1;
        dip.fFlags = afCmd;
        if (AddPileItem(pDataInfoPile, (LPBYTE)&dip, CmpWORD) == API_ERROR) {
            GLOBALFREE(hMem);
            SETLASTERROR(pai, DMLERR_MEMORY_ERROR);
            return(0L);
        }
    }

    if (pSrc)
        CopyHugeBlock(pSrc, HugeOffset(GLOBALLOCK(hMem), cbOff), cb);

    // LOWORD(hData) always == afCmd flags

    return(MAKELONG(afCmd, hMem));
}



/*
 * This is the internal data handle freeing function.  fInternal is TRUE if
 * this is called from within the DDEML (vs called via DdeFreeDataHandle())
 * It only frees the handle if it is in the local list.
 * Appowned data handles are only freed internally if a non-owner task is
 * doing the freeing.
 * It is important that the LOWORD(hData) be set properly.
 *
 * These features give this function the folowing desired characteristics:
 * 1) Apps cannot free data handles more than once.
 * 2) The DDEML cannot free APPOWNED data handles on behalf of the owner
 *    task. (except on cleanup)
 */
VOID FreeDataHandle(
PAPPINFO pai,
HDDEDATA hData,
BOOL fInternal)
{
    DIP *pDip;
    BOOL fRelease = 0;
    DDEPOKE FAR *pDdeMem;
    WORD fmt;

    TRACEAPIIN((szT, "FreeDataHandle(%lx, %lx, %d)\n", pai, hData, fInternal));

    // appowned data handles are not freed till their count reaches 0.

    if ((LOWORD(hData) & HDATA_APPOWNED) &&
            (pDip = (DIP *)(DWORD)FindPileItem(pDataInfoPile, CmpWORD, PHMEM(hData), 0))) {

        // don't internally free if in the context of the owner

        if (fInternal && (pDip->hTask == pai->hTask)) {
            TRACEAPIOUT((szT, "FreeDataHandle: Internal and of this task - not freed.\n"));
            return;
        }

        if (--pDip->cCount != 0) {
            TRACEAPIOUT((szT, "FreeDataHandle: Ref count not 0 - not freed.\n"));
            return;
        }

        FindPileItem(pDataInfoPile, CmpWORD, PHMEM(hData), FPI_DELETE);
        fRelease = TRUE;
    }

    /*
     * Apps can only free handles in their local list - this guards against
     * multiple frees by an app. (my arnt we nice)
     */
    if (!HIWORD(hData) ||
            !FindPileItem(pai->pHDataPile, CmpHIWORD, (LPBYTE)&hData, FPI_DELETE)) {
        TRACEAPIOUT((szT, "FreeDataHandle: Not in local list - not freed.\n"));
        return;
    }

    if (LOWORD(hData) & HDATA_EXEC) {
        fRelease |= !(LOWORD(hData) & HDATA_APPOWNED);
    } else {
        pDdeMem = (DDEPOKE FAR *)GLOBALLOCK(HIWORD(hData));
        if (pDdeMem == NULL) {
            TRACEAPIOUT((szT, "FreeDataHandle: Lock failed - not freed.\n"));
            return;
        }
        fRelease |= pDdeMem->fRelease;
        fmt = pDdeMem->cfFormat;
        GLOBALUNLOCK(HIWORD(hData));
    }

    if (fRelease) {
        if (LOWORD(hData) & HDATA_EXEC)
            GLOBALFREE(HIWORD(hData));
        else
            FreeDDEData(HIWORD(hData), fmt);
    }
    TRACEAPIOUT((szT, "FreeDataHandle: freed.\n"));
}





/*
 * This function prepairs data handles on entry into the DDEML API.  It has
 * the following characteristics:
 * 1) APPOWNED data handles are copied to a non-appowned handle if being
 *    passed to a non-local app.
 * 2) non-APPOWNED data handles on loan to a callback are copied so they
 *    don't get prematurely freed.
 * 3) The READONLY bit is set. (in the local list)
 */
HDDEDATA DllEntry(
PCOMMONINFO pcomi,
HDDEDATA hData)
{
    if ((!(pcomi->fs & ST_ISLOCAL)) && (LOWORD(hData) & HDATA_APPOWNED) ||
            LOWORD(hData) & HDATA_NOAPPFREE && !(LOWORD(hData) & HDATA_APPOWNED)) {

        // copy APPOWNED data handles to a fresh handle if not a local conv.
        // copy app loaned, non appowned handles as well (this is the
        // relay server case)

        hData = CopyHDDEDATA(pcomi->pai, hData);
    }

    LOWORD(hData) |= HDATA_READONLY;

    AddPileItem(pcomi->pai->pHDataPile, (LPBYTE)&hData, CmpHIWORD);

    // NOTE: the global lists READONLY flag set but thats
    // ok because any hData received from a transaction will always be in
    // the local list due to RecvPrep().

    return(hData);
}



/*
 * removes the data handle from the local list.  This removes responsibility
 * for the data handle from the sending app.   APPOWNED handles are not
 * removed.
 */
VOID XmitPrep(
HDDEDATA hData,
PAPPINFO pai)
{
    if (!(LOWORD(hData) & HDATA_APPOWNED)) {
        FindPileItem(pai->pHDataPile, CmpHIWORD, (LPBYTE)&hData, FPI_DELETE);
    }
}



/*
 * Places the received data handle into the apropriate lists and returns
 * it with the proper flags set.  Returns 0 if invalid hMem.  afCmd should
 * contain any extra flags desired.
 */
HDDEDATA RecvPrep(
PAPPINFO pai,
HANDLE hMem,
WORD afCmd)
{
    DIP *pdip;
    HDDEDATA hData;

    if (!hMem)
        return(0);

    // check if its an APPOWNED one, if so, log entry.

    if (pdip = (DIP *)(DWORD)FindPileItem(pDataInfoPile, CmpWORD, (LPBYTE)&hMem, 0)) {
        afCmd |= pdip->fFlags;
        pdip->cCount++;
    }

    // if we got one that isnt fRelease, treat it as appowed.

    if (!(*(LPWORD)GLOBALLOCK(hMem) & DDE_FRELEASE))
        afCmd |= HDATA_APPOWNED;

    GLOBALUNLOCK(hMem);

    // all received handles are readonly.

    hData = (HDDEDATA)MAKELONG(afCmd | HDATA_READONLY, hMem);
    /*
     * Add (or replace) into local list
     */
    AddPileItem(pai->pHDataPile, (LPBYTE)&hData, CmpHIWORD);

    return(hData);
}


HANDLE CopyDDEShareHandle(
HANDLE hMem)
{
    DWORD cb;
    LPBYTE pMem;

    cb = GlobalSize(hMem);
    pMem = GLOBALLOCK(hMem);
    if (pMem == NULL) {
        return(0);
    }
    hMem = GLOBALALLOC(GMEM_DDESHARE, cb);
    CopyHugeBlock(pMem, GLOBALPTR(hMem), cb);
    return(hMem);
}



HBITMAP CopyBitmap(
PAPPINFO pai,
HBITMAP hbm)
{
    BITMAP bm;
    HBITMAP hbm2, hbmOld1, hbmOld2;
    HDC hdc, hdcMem1, hdcMem2;

    if (!GetObject(hbm, sizeof(BITMAP), &bm)) {
        return(0);
    }
    hdc = GetDC(pai->hwndDmg);
    if (!hdc) {
        return(0);
    }
    hdcMem1 = CreateCompatibleDC(hdc);
    if (!hdcMem1) {
        goto Cleanup3;
    }
    hdcMem2 = CreateCompatibleDC(hdc);
    if (!hdcMem2) {
        goto Cleanup2;
    }
    hbmOld1 = SelectObject(hdcMem1, hbm);
    hbm2 = CreateCompatibleBitmap(hdcMem1, bm.bmWidth, bm.bmHeight);
    if (!hbm2) {
        goto Cleanup1;
    }
    hbmOld2 = SelectObject(hdcMem2, hbm2);
    BitBlt(hdcMem2, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem1, 0, 0, SRCCOPY);
    SelectObject(hdcMem1, hbmOld1);
    SelectObject(hdcMem2, hbmOld2);
Cleanup1:
    DeleteDC(hdcMem2);
Cleanup2:
    DeleteDC(hdcMem1);
Cleanup3:
    ReleaseDC(pai->hwndDmg, hdc);
    return(hbm2);
}



HPALETTE CopyPalette(
HPALETTE hpal)
{
    int cPalEntries;
    LOGPALETTE *plp;

    if (!GetObject(hpal, sizeof(int), &cPalEntries)) {
        return(0);
    }
    plp = (LOGPALETTE *)LocalAlloc(LPTR, sizeof(LOGPALETTE) +
            (cPalEntries - 1) * sizeof(PALETTEENTRY));
    if (!plp) {
        return(0);
    }
    if (!GetPaletteEntries(hpal, 0, cPalEntries, plp->palPalEntry)) {
        LocalFree((HLOCAL)plp);
        return(0);
    }
    plp->palVersion = 0x300;
    plp->palNumEntries = (WORD)cPalEntries;
    hpal = CreatePalette(plp);
    if (hpal  &&
            !SetPaletteEntries(hpal, 0, cPalEntries, plp->palPalEntry)) {
        hpal = 0;
    }
    LocalFree((HLOCAL)plp);
    return(hpal);
}




HDDEDATA CopyHDDEDATA(
PAPPINFO pai,
HDDEDATA hData)
{
    HANDLE hMem;
    LPDDE_DATA lpdded;
    HDDEDATA hdT;
    LPMETAFILEPICT pmfPict;

    if (!HIWORD(hData))
        return(hData);
    hMem = CopyDDEShareHandle((HANDLE)HIWORD(hData));

    if (!hMem)
        return(NULL);

    if (!(LOWORD(hData) & HDATA_EXEC)) {
        lpdded = (LPDDE_DATA)GLOBALLOCK(hMem);
        if (lpdded == NULL) {
            return(NULL);
        }
        lpdded->wStatus |= DDE_FRELEASE;
        if (lpdded != NULL) {
            switch (lpdded->wFmt) {
            case CF_BITMAP:
            case CF_DSPBITMAP:
                lpdded->wData = CopyBitmap(pai, lpdded->wData);
                break;

            case CF_PALETTE:
                lpdded->wData = (WORD)CopyPalette((HPALETTE)lpdded->wData);
                break;

            case CF_DIB:
                lpdded->wData = (WORD)CopyDDEShareHandle((HANDLE)lpdded->wData);
                break;

            case CF_METAFILEPICT:
            case CF_DSPMETAFILEPICT:
                lpdded->wData = (WORD)CopyDDEShareHandle((HANDLE)lpdded->wData);
                if (lpdded->wData) {
                    pmfPict = (LPMETAFILEPICT)GLOBALLOCK((HANDLE)lpdded->wData);
                    if (pmfPict != NULL) {
                        pmfPict->hMF = CopyMetaFile(pmfPict->hMF, NULL);
                        GLOBALUNLOCK((HANDLE)lpdded->wData);
                    }
                    GLOBALUNLOCK((HANDLE)lpdded->wData);
                }
                break;
#ifdef CF_ENHMETAFILE
            case CF_ENHMETAFILE:
                lpdded->wData = (WORD)CopyEnhMetaFile(*((HENHMETAFILE FAR *)(&lpdded->wData)), NULL);
                break;
#endif   // bad because it makes chicago and NT binaries different.
            }
            GLOBALUNLOCK(hMem);
        }
    }

    hdT = MAKELONG(LOWORD(hData) & ~(HDATA_APPOWNED | HDATA_NOAPPFREE), hMem);
    AddPileItem(pai->pHDataPile, (LPBYTE)&hdT, NULL);

    return(hdT);
}


VOID FreeDDEData(
HANDLE hMem,
WORD wFmt)
{
    DDEDATA FAR *pDdeData;

    /*
     * This handles the special cases for formats that hold imbedded
     * objects.  (CF_BITMAP, CF_METAFILEPICT).
     *
     * The data handle is assumed to be unlocked.
     */

    // may need to add "Printer_Picture" for excel/word interaction" but
    // this is just between the two of them and they don't use DDEML.
    // raor says OLE only worries about these formats as well.

    pDdeData = (DDEDATA FAR *)GLOBALLOCK(hMem);
    if (pDdeData == NULL) {
        return;
    }

    switch (wFmt) {
    case CF_BITMAP:
    case CF_DSPBITMAP:
    case CF_PALETTE:
        DeleteObject(*(HANDLE FAR *)(&pDdeData->Value));
        break;

    case CF_DIB:
        /*
         * DIBs are allocated by app so we don't use the macro here.
         */
        GlobalFree(*(HANDLE FAR *)(&pDdeData->Value));
        break;

    case CF_METAFILEPICT:
    case CF_DSPMETAFILEPICT:
        {
            HANDLE hmfPict;
            LPMETAFILEPICT pmfPict;

            /*
             * EXCEL sickness -  metafile is a handle to a METAFILEPICT
             * struct which holds a metafile.  (2 levels of indirection!)
             *
             * We don't use the GLOBAL macros here because these objects
             * are allocated by the app.  DDEML knows not their history.
             */

        hmfPict = *(HANDLE FAR *)(&pDdeData->Value);
        pmfPict = (LPMETAFILEPICT)GlobalLock(hmfPict);
        if (pmfPict != NULL) {
            DeleteMetaFile(pmfPict->hMF);
        }
        GlobalUnlock(hmfPict);
        GlobalFree(hmfPict);
        }
        break;

#ifdef CF_ENHMETAFILE
    case CF_ENHMETAFILE:
        DeleteEnhMetaFile(*(HENHMETAFILE FAR *)(&pDdeData->Value));
        break;
#endif  // This is bad - it forces different binaries for chicago and NT!
    }

    GLOBALUNLOCK(hMem);
    GLOBALFREE(hMem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\verddeml.h ===
WORD	rup = 1;
	WORD	rmm = 0;
	WORD	rmj = 1;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\register.c ===
/****************************** Module Header ******************************\
* Module Name: register.c
*
* DDE Manager - server registration module
*
* Created: 4/15/94 sanfords
*       to allow interoperability between DDEML16 and DDEML32
\***************************************************************************/

#include <windows.h>
#include <string.h>
#include "ddemlp.h"

/*
 * interoperable DDEML service registration is accomplished via the
 * two messages UM_REGISTER and UM_UNREGISTER. (WM_USER range)
 * wParam=gaApp,
 * lParam=src hwndListen, (for instance specific HSZ generation.)
 * These messages are sent and the sender is responsible for freeing
 * the gaApp.
 */


/*
 * Broadcast-sends the given message to all top-level windows of szClass
 * except to hwndSkip.
 */
VOID SendMessageToClass(
ATOM atomClass,
UINT msg,
GATOM ga,
HWND hwndFrom,
HWND *ahwndSkip,
int chwndSkip,
BOOL fPost)
{
    HWND hwnd;
    int i;
    BOOL fSkipIt;

    hwnd = GetWindow(GetDesktopWindow(), GW_CHILD);
    while (hwnd != NULL) {
        if (GetClassWord(hwnd, GCW_ATOM) == atomClass) {
            fSkipIt = FALSE;
            for (i = 0; i < chwndSkip; i++) {
                if (hwnd == ahwndSkip[i]) {
                    fSkipIt = TRUE;
                    break;
                }
            }
            if (!fSkipIt) {
                IncHszCount(ga);    // receiver frees
                if (fPost) {
                    PostMessage(hwnd, msg, (WPARAM)ga, (LPARAM)hwndFrom);
                } else {
                    SendMessage(hwnd, msg, (WPARAM)ga, (LPARAM)hwndFrom);
                }
            }
        }
        hwnd = GetWindow(hwnd, GW_HWNDNEXT);
    }
}


/*
 * Broadcast-sends a UM_REGISTER or UM_UNREGISTER message to all DDEML16
 * and DDEML32 listening windows in the system except hwndSkip.
 */
VOID RegisterService(
BOOL fRegister,
GATOM gaApp,
HWND hwndListen)
{
    PAPPINFO paiT;
    int cSkips = 1;
    HWND *ahwndSkip;
    int i;
    extern ATOM gatomDDEMLMom;
    extern ATOM gatomDMGClass;

    /*
     * First send (always!) to our own guys the same way we used to
     * for compatability.  WordPerfect 6.0a relies on this!
     */
    for (paiT = pAppInfoList; paiT != NULL; paiT = paiT->next) {
        IncHszCount(gaApp);    // receiver frees atom
        SendMessage(paiT->hwndDmg,
                fRegister ? UM_REGISTER : UM_UNREGISTER,
                (WPARAM)gaApp, (LPARAM)hwndListen);
        cSkips++;
    }
    /*
     * build up the hwndskip list.
     */
    ahwndSkip = (HWND *)LocalAlloc(LPTR, sizeof(HWND) * cSkips);
    if (ahwndSkip == NULL) {
        return;
    }
    for (paiT = pAppInfoList, i = 0;
        paiT != NULL;
            paiT = paiT->next, i++) {
        ahwndSkip[i] = paiT->hwndDmg;
    }

    AssertF(gatomDDEMLMom, "gatomDDEMLMom not initialized in RegisterService");
    AssertF(gatomDMGClass, "gatomDMGClass not initialized in RegisterService");

    /*
     * Send notification to each DDEML32 listening window.
     */
    SendMessageToClass(gatomDDEMLMom, fRegister ? UM_REGISTER : UM_UNREGISTER,
            gaApp, hwndListen, ahwndSkip, i, fRegister);
    /*
     * Send notification to each DDEML16 listening window.
     */
    SendMessageToClass(gatomDMGClass, fRegister ? UM_REGISTER : UM_UNREGISTER,
            gaApp, hwndListen, ahwndSkip, i, fRegister);

    LocalFree((HLOCAL)ahwndSkip);
}


LRESULT ProcessRegistrationMessage(
HWND hwnd,
UINT msg,
WPARAM wParam,
LPARAM lParam)
{
    /*
     * wParam = GATOM of app
     * lParam = hwndListen of source
     */
    DoCallback((PAPPINFO)GetWindowWord(hwnd, GWW_PAI), (HCONV)0L, (HSZ)wParam,
            MakeInstAppName(wParam, (HWND)lParam), 0,
            msg == UM_REGISTER ? XTYP_REGISTER : XTYP_UNREGISTER,
            (HDDEDATA)0, 0L, 0L);
    GlobalDeleteAtom((ATOM)wParam); // receiver frees.
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\ddestrs\client.c ===
#include <windows.h>
#include <port1632.h>
#include <ddeml.h>
#include <string.h>
#include "wrapper.h"
#include "ddestrs.h"

extern INT iAvailFormats[];
extern BOOL UpdateCount(HWND,INT,INT);
extern HANDLE hmemNet;

void CALLBACK TimerFunc( HWND hwnd, UINT msg, UINT id, DWORD dwTime)
{
    HCONV hConv;
    HCONVLIST hConvList;
    LONG lflags;

    switch (id%2) {
    case 1:
	hConv = 0;
	hConvList=(HCONVLIST)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HCONVLIST);
	while (hConv = DdeQueryNextServer(hConvList, hConv)) {

// POKE CHANGES
#if 0
	    idI=GetThreadLong(GETCURRENTTHREADID(),OFFSET_IDINST);

	    if(DdeClientTransaction("Poke Transaction",
				    strlen("Poke Transaction")+1,
				    hConv,
				    DdeCreateStringHandle(idI,"TestItem",CP_WINANSI),
				    CF_TEXT,
				    XTYP_POKE,
				    TIMEOUT_ASYNC,
				    NULL)==0){
		 DDEMLERROR("DdeStrs.Exe -- DdeClientTransaction failed:XTYP_POKE\r\n");
		 }
#endif

// END OF POKE CHANGES

	    // Allow 'Pause' functionality -p on command line.

	    lflags=GetWindowLong(hwndMain,OFFSET_FLAGS);
	    if((lflags&FLAG_PAUSE)!=FLAG_PAUSE)
		{

		if(DdeClientTransaction(szExecRefresh,
					strlen(szExecRefresh) + 1,
					hConv,
					0,
					0,
					XTYP_EXECUTE,
					TIMEOUT_ASYNC,
					NULL)==0){
		     DDEMLERROR("DdeStrs.Exe -- DdeClientTransaction failed:XTYP_EXECUTE\r\n");
		     }
		}
        }
    }
    return;
}

BOOL InitClient()
{
UINT uid;

    ReconnectList();

    uid = SetTimer( hwndMain,
		   (UINT)GetThreadLong(GETCURRENTTHREADID(),OFFSET_CLIENTTIMER),
		   (UINT)(GetWindowLong(hwndMain,OFFSET_DELAY)),
		    TimerFunc);

    // This starts the test immidiatly.  No delay waiting for the first
    // WM_TIMER call.

    TimerFunc(hwndMain,WM_TIMER,uid,0);

    return(TRUE);
}

VOID CloseClient()
{
HCONVLIST hConvList;

    hConvList=(HCONVLIST)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HCONVLIST);
    KillTimer(hwndMain,(UINT)GetThreadLong(GETCURRENTTHREADID(),OFFSET_CLIENTTIMER));
    if (!DdeDisconnectList(hConvList)) {
	DDEMLERROR("DdeStrs.Exe -- DdeDisconnectList failed\r\n");
    }

}

VOID ReconnectList()
{
    HCONV hConv;
    HCONVLIST hConvList=0;
    LONG cClienthConvs;
    INT i;
    DWORD dwid;

    dwid=GetThreadLong(GETCURRENTTHREADID(),OFFSET_IDINST);
    if(dwid==0) {
	DDEMLERROR("DdeStrs.Exe -- Null IdInst, aborting Connect!\r\n");
	return;
	}

    hConvList = DdeConnectList(dwid,
			       ServiceInfoTable[0].hszService,
                               Topics[0].hszTopic,
			       GetThreadLong(GETCURRENTTHREADID(),OFFSET_HCONVLIST),
                               NULL);
    if (hConvList == 0) {

        // This call is expected to fail in the case of a client
        // starting when there is no available server.  Just return
        // from the routine and continue.

        return;
	}

    SetThreadLong(GETCURRENTTHREADID(),OFFSET_HCONVLIST,hConvList);

    hConv = 0;
    cClienthConvs = 0L;

    while (hConv = DdeQueryNextServer(hConvList, hConv)) {
	for (i=0; i<(int)Items[0].cFormats; i++) {
	    if (iAvailFormats[i]) {
		if (!DdeClientTransaction( NULL,
					   0,
					   hConv,
					   Items[0].hszItem,
					   TestItemFormats[i].wFmt,
					   XTYP_ADVSTART|XTYPF_ACKREQ,
					   TIMEOUT_ASYNC,
					   NULL)){
			   DDEMLERROR("DdeStrs.Exe -- Error DdeClientTransaction failed\r\n");
			   return;
			   }  // if

		} // if

	    } // for

	cClienthConvs++;

	} // while

    // Update the client count for the current thread.

    dwid=GETCURRENTTHREADID();

    SetThreadLong(dwid,OFFSET_CCLIENTCONVS,cClienthConvs);

    UpdateCount(hwndMain,OFFSET_CLIENT_CONNECT,PNT);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\stdinit.c ===
/****************************** Module Header ******************************\
* Module Name: STDINIT.C
*
* This module contains functions used in the involved initiate sequence.
*
* Created:  3/21/91 Sanfords
*
* Copyright (c) 1991  Microsoft Corporation
\***************************************************************************/

#include "ddemlp.h"

/*
 * WM_CREATE ClientWndProc processing
 */
long ClientCreate(
HWND hwnd,
PAPPINFO pai)
{
    PCLIENTINFO pci;

    static DWORD defid = (DWORD)QID_SYNC;
    static XFERINFO defXferInfo = {
            &defid,
            1L,
            XTYP_CONNECT,
            DDEFMT_TEXT,
            0L,
            0L,
    };

    /*
     * allocate and initialize the client window info.
     */
    SEMENTER();

    if(!(pci = (PCLIENTINFO)FarAllocMem(pai->hheapApp, sizeof(CLIENTINFO)))) {
        SEMLEAVE();
        SETLASTERROR(pai, DMLERR_MEMORY_ERROR);
        return(1);          /* aboart creation - low memory */
    }

    SetWindowLong(hwnd, GWL_PCI, (DWORD)pci);
    SetWindowWord(hwnd, GWW_CHECKVAL, ++hwInst);
    pci->ci.pai = pai;
 // pci->ci.xad.hUser = 0L;
    pci->ci.xad.state = XST_NULL;
    pci->ci.xad.pXferInfo = &defXferInfo;   //???
    pci->ci.fs = ST_CLIENT | (pai->wFlags & AWF_DEFCREATESTATE ? ST_BLOCKED : 0);
    if (GetWindowLong(GetParent(hwnd), GWL_WNDPROC) == (LONG)ConvListWndProc)
        pci->ci.fs |= ST_INLIST;
 // pci->ci.hConvPartner = NULL;
 // pci->ci.hszServerApp = NULL;
 // pci->ci.hszTopic = NULL;
    pci->pQ = NULL;    /* don't create until we need one */
    pci->pClientAdvList = CreateLst(pai->hheapApp, sizeof(ADVLI));
    SEMLEAVE();

}




/***************************** Private Function ****************************\
* This routine returns the hwnd of a newly created and connected DDE
* client or NULL if failure.
*
* History:  created     1/6/89  sanfords
\***************************************************************************/
HWND GetDDEClientWindow(
PAPPINFO pai,
HWND hwndParent,
HWND hwndSend,          // NULL -> broadcast
HSZ hszSvc,
ATOM aTopic,
PCONVCONTEXT pCC)
{
    HWND hwnd;
    PCLIENTINFO pci;

    SEMCHECKOUT();
    if(!(hwnd = CreateWindow(SZCLIENTCLASS, szNull, WS_CHILD, 0, 0, 0, 0, hwndParent,
         NULL, hInstance, &pai))) {
        return(NULL);
    }

    pci = (PCLIENTINFO)GetWindowLong(hwnd, GWL_PCI);

    SEMENTER();
    /*
     * we need to set this info BEFORE we do the synchronous initiate
     * so the INITIATEACK msg is done correctly.
     */
    pci->ci.xad.state = XST_INIT1;
    pci->ci.xad.LastError = DMLERR_NO_ERROR;
    pci->ci.hszSvcReq = hszSvc;
    pci->ci.aServerApp = LOWORD(hszSvc);
    pci->ci.aTopic = aTopic;
    pci->ci.CC = pCC ? *pCC : CCDef;
    SEMLEAVE();

    if (hwndSend) {
        pci->hwndInit = hwndSend;
        SendMessage(hwndSend, WM_DDE_INITIATE, hwnd,
                MAKELONG((ATOM)hszSvc, aTopic));
    } else {
        IE ie = {
            hwnd, pci, aTopic
        };

        EnumWindows(InitEnum, (LONG)(IE FAR *)&ie);
    }


    if (pci->ci.xad.state == XST_INIT1) {    // no connections?
        DestroyWindow(hwnd);
        return(NULL);
    }

    pci->ci.xad.state = XST_CONNECTED;  // fully ready now.
    pci->ci.fs |= ST_CONNECTED;

    return(hwnd);
}



BOOL FAR PASCAL InitEnum(
HWND hwnd,
IE FAR *pie)
{
    pie->pci->hwndInit = hwnd;
    SendMessage(hwnd, WM_DDE_INITIATE, pie->hwnd,
            MAKELONG((ATOM)pie->pci->ci.hszSvcReq, pie->aTopic));
    return((pie->pci->ci.fs & ST_INLIST) || pie->pci->ci.xad.state == XST_INIT1);
}




void ServerFrameInitConv(
PAPPINFO pai,
HWND hwndFrame,
HWND hwndClient,
ATOM aApp,
ATOM aTopic)
{
    HSZPAIR hp[2];
    PHSZPAIR php;
    DWORD dwRet;
    LPBYTE pdata;
    HWND hwndServer;
    BOOL fWild, fIsLocal, fIsSelf = FALSE;
    PCLIENTINFO pci;

    SEMCHECKOUT();

    if (pai->afCmd & CBF_FAIL_CONNECTIONS) {
        return;
    }

    /*
     * If we are filtering and no app names are registered, quit.
     */
    if ((pai->afCmd & APPCMD_FILTERINITS) &&
            QPileItemCount(pai->pAppNamePile) == 0) {
        return;
    }
    fIsLocal = ((FARPROC)GetWindowLong(hwndClient,GWL_WNDPROC) == (FARPROC)ClientWndProc);
    if (fIsLocal) {
        pci = (PCLIENTINFO)GetWindowLong(hwndClient, GWL_PCI);
        fIsSelf = (pci->ci.pai == pai);

         /*
         * filter out inits from ourselves
         */
        if (pai->afCmd & CBF_FAIL_SELFCONNECTIONS && fIsSelf) {
            return;
        }
    }

    hp[0].hszSvc = (HSZ)aApp;

    /*
     * filter out unwanted app names.
     */
    if (aApp && (pai->afCmd & APPCMD_FILTERINITS) &&
            !FindPileItem(pai->pAppNamePile, CmpWORD, (LPBYTE)&aApp, 0))
        return;

    hp[0].hszTopic = aTopic;
    hp[1].hszSvc = hp[1].hszTopic = 0L;
    fWild = (hp[0].hszSvc == 0L || hp[0].hszTopic == 0L);

    dwRet = DoCallback(pai, NULL, hp[0].hszTopic,
                hp[0].hszSvc, 0, (fWild ? XTYP_WILDCONNECT : XTYP_CONNECT),
                0L, fIsLocal ? (DWORD)&pci->ci.CC : 0L, fIsSelf ? 1 : 0);

    if (dwRet == NULL)
        return;

    if (fWild) {
        pdata  = GLOBALLOCK(HIWORD(dwRet));
        php = (PHSZPAIR)pdata;
    } else {
        php = &hp[0];
        pdata = NULL;
    }

    /*
     * now php points to a 0 terminated list of hszpairs to respond to.
     */
    SEMENTER();
    while (QueryHszLength(php->hszSvc) && QueryHszLength(php->hszTopic)) {
        PSERVERINFO psi;

        SEMLEAVE();
        if ((hwndServer = CreateServerWindow(pai, (ATOM)php->hszTopic,
                fIsLocal ? &pci->ci.CC : &CCDef)) == 0)
            return;
        SEMENTER();

        /*
         * have the server respond
         */
        psi = (PSERVERINFO)GetWindowLong(hwndServer, GWL_PCI);
        psi->ci.hConvPartner = fIsLocal ? MAKEHCONV(hwndClient) : (HCONV)hwndClient;
        psi->ci.hwndFrame = hwndFrame;
        psi->ci.fs |= ST_CONNECTED;
        if (fIsSelf) {
            psi->ci.fs |= ST_ISSELF;
            pci->ci.fs |= ST_ISSELF;
        }
        psi->ci.xad.state = XST_CONNECTED;
        psi->ci.hszSvcReq = (HSZ)aApp;
        psi->ci.aServerApp = (ATOM)php->hszSvc;
        psi->ci.aTopic = (ATOM)php->hszTopic;

        MONCONN(psi->ci.pai, psi->ci.aServerApp, psi->ci.aTopic,
                hwndClient, hwndServer, TRUE);

        IncHszCount(aApp);     // for server window to keep
        IncHszCount(LOWORD(php->hszSvc));
        IncHszCount(LOWORD(php->hszTopic));

        IncHszCount(LOWORD(php->hszSvc));   // for client to remove on ack
        IncHszCount(LOWORD(php->hszTopic));

#ifdef DEBUG
        cAtoms -= 2;    // we are giving these away
#endif

        SEMLEAVE();
        SendMessage(hwndClient, WM_DDE_ACK, hwndServer,
                MAKELONG(LOWORD(php->hszSvc), LOWORD(php->hszTopic)));
        /*
         * confirm initialization to server app - synchronously
         */
        DoCallback(pai, MAKEHCONV(hwndServer), php->hszTopic, php->hszSvc,
                0, XTYP_CONNECT_CONFIRM, 0L, 0L, fIsSelf ? 1 : 0);

        SEMENTER();
        php++;
    }
    if (pdata) {
        GLOBALUNLOCK(HIWORD(dwRet));
        FreeDataHandle(pai, dwRet, TRUE);
    }
    SEMLEAVE();
    SEMCHECKOUT();
}






HWND CreateServerWindow(
PAPPINFO pai,
ATOM aTopic,
PCONVCONTEXT pCC)
{
    HWND hwndServer;

    SEMCHECKOUT();

    /*
     * make a server root window if needed....
     */
    if (pai->hwndSvrRoot == 0) {
        /*
         * NO - make one.
         */
        if ((pai->hwndSvrRoot = CreateWindow(SZCONVLISTCLASS, szNull, WS_CHILD,
                0, 0, 0, 0, pai->hwndDmg, NULL, hInstance, 0L)) == NULL) {
            SETLASTERROR(pai, DMLERR_SYS_ERROR);
            return(NULL);
        }
    }

    /*
     * Create the server window
     */
    if ((hwndServer = CreateWindow(SZSERVERCLASS, szNull, WS_CHILD,
            0, 0, 0, 0, pai->hwndSvrRoot, NULL, hInstance, &pai)) == NULL) {
        SETLASTERROR(pai, DMLERR_SYS_ERROR);
        return(NULL);
    }
    ((PSERVERINFO)GetWindowLong(hwndServer, GWL_PCI))->ci.CC = *pCC;
    return(hwndServer);
}






/*
 * WM_CREATE ServerWndProc processing
 */
long ServerCreate(
HWND hwnd,
PAPPINFO pai)
{
    PSERVERINFO psi;

    /*
     * allocate and initialize the server window info.
     */

    SEMENTER();

    if (!(psi = (PSERVERINFO)FarAllocMem(pai->hheapApp, sizeof(SERVERINFO)))) {
        SETLASTERROR(pai, DMLERR_MEMORY_ERROR);
        return(1);
    }

    SEMLEAVE();
    psi->ci.pai = pai;
    // psi->ci.xad.hUser = 0L;
    psi->ci.xad.state = XST_NULL;
    psi->ci.fs = pai->wFlags & AWF_DEFCREATESTATE ? ST_BLOCKED : 0;
    SetWindowLong(hwnd, GWL_PCI, (DWORD)psi);
    SetWindowWord(hwnd, GWW_CHECKVAL, ++hwInst);
    return(0);
}





/*
 * Client response to a WM_DDE_ACK message when ACK to INITIATE expected.
 */
BOOL ClientInitAck(hwnd, pci, hwndServer, aApp, aTopic)
HWND hwnd;
PCLIENTINFO pci;
HWND hwndServer;
ATOM aApp;
ATOM aTopic;
{
    HWND hwndClient;
    PCLIENTINFO pciNew;

#ifdef DEBUG
    cAtoms += 2;    // the incomming atoms need to be accounted for.
#endif
    SEMCHECKOUT();

    switch (pci->ci.xad.state) {

    case XST_INIT1:

        /*
         * first one back... lock in!
         */
        pci->ci.xad.state = XST_INIT2;
        MONCONN(pci->ci.pai, aApp, aTopic, hwnd, hwndServer, TRUE);
        if (GetWindowLong(hwndServer, GWL_WNDPROC) == (LONG)ServerWndProc) {
            pci->ci.fs |= ST_ISLOCAL;
            pci->ci.hConvPartner = MAKEHCONV(hwndServer);
        } else {
            pci->ci.hConvPartner = (HCONV)hwndServer;
            if (aApp == aProgmanHack) {
                // PROGMAN HACK!!!!
                IncHszCount(aApp);
                IncHszCount(aTopic);
#ifdef DEBUG
                cAtoms -= 2;
#endif
            }
        }

        pci->ci.aServerApp = aApp;
        pci->ci.aTopic = aTopic;
        if (!pci->ci.hwndFrame)            // remember the frame this was sent to.
            pci->ci.hwndFrame = pci->hwndInit;
        IncHszCount(LOWORD(pci->ci.hszSvcReq)); // keep this for ourselves
        break;


    case XST_INIT2:

        // Extra ack...

        // throw away if from our partner or if we are not in a list.
        if (hwndServer == (HWND)pci->ci.hConvPartner ||
                GetParent(hwnd) == pci->ci.pai->hwndDmg) {
Abort:
            TRACETERM((szT, "ClientInitAck: Extra ack terminate: %x->%x\n", hwndServer, hwnd));
            PostMessage(hwndServer, WM_DDE_TERMINATE, hwnd, 0L);
            FreeHsz(aApp);
            FreeHsz(aTopic);
            break;
        }

        if (GetWindowLong(hwndServer, GWL_WNDPROC) != (LONG)ServerWndProc) {

            // Non Local Extra Ack... terminate and attempt reconnection.

            TRACETERM((szT, "ClientInitAck: Extra ack terminate and reconnect: %x->%x\n", hwndServer, hwnd));
            PostMessage(hwndServer, WM_DDE_TERMINATE, hwnd, 0L);
            GetDDEClientWindow(pci->ci.pai, GetParent(hwnd),
                    pci->hwndInit, aApp, aTopic, &pci->ci.CC);

            // PROGMAN HACK!!!!
            if (aApp != aProgmanHack) {
                FreeHsz(aApp);
                FreeHsz(aTopic);
            }
            break;
        }
        // Local Extra Ack... create a client window, set it up to be talking
        //    to the server window and tell the server window to change
        //    partners.


        hwndClient = CreateWindow(SZCLIENTCLASS, szNull, WS_CHILD,
            0, 0, 0, 0, GetParent(hwnd), NULL, hInstance, &(pci->ci.pai));

        if (!hwndClient) {
            SETLASTERROR(pci->ci.pai, DMLERR_SYS_ERROR);
            goto Abort;
        }

        pciNew = (PCLIENTINFO)GetWindowLong(hwndClient, GWL_PCI);
        pciNew->ci.xad.state = XST_CONNECTED;
        pciNew->ci.xad.LastError = DMLERR_NO_ERROR;
        pciNew->ci.aServerApp = aApp;
        pciNew->ci.hszSvcReq = pci->ci.hszSvcReq;
        IncHszCount(LOWORD(pciNew->ci.hszSvcReq));
        pciNew->ci.aTopic = aTopic;
        pciNew->ci.hConvPartner = MAKEHCONV(hwndServer);
        pciNew->ci.hwndFrame = pci->hwndInit;
        pciNew->ci.fs |= ST_CONNECTED | ST_ISLOCAL;
        MONCONN(pciNew->ci.pai, aApp, aTopic, hwnd, hwndServer, TRUE);
        SendMessage(hwndServer, UMSR_CHGPARTNER, hwndClient, 0L);

        break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\stdptcl.c ===
/****************************** Module Header ******************************\
* Module Name: STDPTCL.C
*
* This module contains functions that implement the standard DDE protocol
*
* Created:  4/2/91 Sanfords
*
* Copyright (c) 1991  Microsoft Corporation
\***************************************************************************/

#include <string.h>
#include <memory.h>
#include "ddemlp.h"


VOID FreeDdeMsgData(
WORD msg,
LPARAM lParam)
{
    WORD fmt;

    switch (msg) {
    case WM_DDE_DATA:
    case WM_DDE_POKE:
        /*
         * Only free if fRelease is set!
         */
        {
            DDEDATA FAR *pDdeData = (DDEDATA FAR *)GLOBALLOCK(LOWORD(lParam));
            if (pDdeData != NULL) {
                if (pDdeData->fRelease) {
                    fmt = pDdeData->cfFormat;
                    GlobalUnlock(LOWORD(lParam));
                    FreeDDEData(LOWORD(lParam), fmt);
                } else {
                    GlobalUnlock(LOWORD(lParam));
                }
            }
        }
        break;

    case WM_DDE_ADVISE:
        GLOBALFREE(LOWORD(lParam));
        break;

    case WM_DDE_EXECUTE:
        GLOBALFREE(HIWORD(lParam));
        break;
    }
}


/***************************** Private Function ****************************\
* Processes a client transfer request issued by DdeClientTransaction
* function.  This may be synchronous or asynchronous.
*
* This function is responsible for properly filling in pXferInfo->pulResult.
*
* History:
*   Created     9/1/89    Sanfords
\***************************************************************************/
long ClientXferReq(
PXFERINFO pXferInfo,
HWND hwnd,
PCLIENTINFO pci)
{
    PCQDATA pcqd;
    LAP myLostAck;
    long retVal;

    if (pci->ci.xad.state != XST_CONNECTED) {
        SETLASTERROR(pci->ci.pai, DMLERR_SERVER_DIED);
        return(0);
    }

    if (pXferInfo->ulTimeout == TIMEOUT_ASYNC) {
        /*
         * Create a client async queue if needed.
         */
        if (pci->pQ == NULL)
            pci->pQ = CreateQ(sizeof(CQDATA));
        if (pci->pQ == NULL) {
            SETLASTERROR(pci->ci.pai, DMLERR_MEMORY_ERROR);
            return(0);
        }

        /*
         * add a client queue item to track this transaction and return
         * the ID.
         */
        pcqd = (PCQDATA)Addqi(pci->pQ);
        if (pcqd == NULL) {
            SETLASTERROR(pci->ci.pai, DMLERR_MEMORY_ERROR);
            return(0);
        }

        IncHszCount(LOWORD(pXferInfo->hszItem));    // structure copy
        hmemcpy((LPBYTE)&pcqd->XferInfo, (LPBYTE)pXferInfo, sizeof(XFERINFO));
        pcqd->xad.state = XST_CONNECTED;
        pcqd->xad.pdata = 0L;
        pcqd->xad.LastError = DMLERR_NO_ERROR;
        pcqd->xad.pXferInfo = &pcqd->XferInfo;
        pcqd->xad.DDEflags = 0;
        /*
         * point pulResult to a safe place
         */
        pcqd->XferInfo.pulResult = (LPDWORD)&pcqd->xad.DDEflags;
        /*
         * Get transaction started - if it fails, quit now.
         */
        if ((pcqd->xad.LastError = SendClientReq(pci->ci.pai, &pcqd->xad,
                (HWND)pci->ci.hConvPartner, hwnd)) == DMLERR_SERVER_DIED) {
            pci->ci.fs = pci->ci.fs & ~ST_CONNECTED;
            FreeHsz(LOWORD(pcqd->XferInfo.hszItem));
            Deleteqi(pci->pQ, MAKEID(pcqd));
            /*
             * RARE case of server dyeing in the middle of transaction
             * initiation.
             */
            SETLASTERROR(pci->ci.pai, DMLERR_SERVER_DIED);
            return(0);
        }
        if (pXferInfo->pulResult != NULL) {
            *pXferInfo->pulResult = MAKEID(pcqd);
        }
        return(1);

    }

    /*
     * Set this so messages comming in during the conversation know whats up
     */
    pci->ci.xad.pXferInfo = pXferInfo;

    if (SETLASTERROR(pci->ci.pai,
            SendClientReq(pci->ci.pai, &pci->ci.xad, (HWND)pci->ci.hConvPartner, hwnd)) ==
            DMLERR_SERVER_DIED) {
        return(0);
    }

    // HACK
    // If this is an EXEC and the timeout is 1 sec then this
    // is probably PC Tools 2.0 trying to add items to the shell so
    // crank up the timout.

    if ((pXferInfo->wType == XTYP_EXECUTE) && (pXferInfo->ulTimeout == 1*1000))
    {
        pXferInfo->ulTimeout = 10*1000;
    }

    timeout(pci->ci.pai, pXferInfo->ulTimeout, hwnd);

    retVal = ClientXferRespond(hwnd, &pci->ci.xad, &pci->ci.pai->LastError);
    switch (pci->ci.xad.state) {
    case XST_INCOMPLETE:
        /* now add a record of the ack we expect to eventually get
         * to the lost ack pile.  When it arrives we'll know what to
         * free up -- either a memory handle or an atom.
         */
        myLostAck.type = pXferInfo->wType;
        if (pXferInfo->wType == XTYP_EXECUTE)
            myLostAck.object = HIWORD(pXferInfo->hDataClient);
        else
            myLostAck.object = LOWORD(pXferInfo->hszItem);
        AddPileItem(pLostAckPile, (LPBYTE)&myLostAck, NULL);
        pci->ci.xad.state = XST_CONNECTED;
    }
    if (pci->ci.fs & ST_DISC_ATTEMPTED) {
        /*
         * During this transaction a call to DdeDisconnect was attempted.
         * complete the call now.
         */
        Disconnect(hwnd, ST_PERM2DIE, pci);
    }
    return(retVal);
}



/***************************** Private Function ****************************\
* This routine sends the apropriate initiation messages for starting a
* client request according to the transaction data given.
*
* returns any appropriate DMLERR_
*
* History:
*   Created     9/1/89    Sanfords
\***************************************************************************/
WORD SendClientReq(
PAPPINFO pai,
PXADATA pXad,
HWND hwndServer,
HWND hwnd)
{
    WORD    fsStatus = 0;
    WORD    msg;
    WORD    lo, hi;
    HANDLE  hData;

    hi = LOWORD(pXad->pXferInfo->hszItem);  /* all but exec need this */

    switch (pXad->pXferInfo->wType) {
    case XTYP_REQUEST:
        msg = WM_DDE_REQUEST;
        IncHszCount(hi);  // message copy
#ifdef DEBUG
        cAtoms--;   // don't count this
#endif
        lo = pXad->pXferInfo->wFmt;
        pXad->state = XST_REQSENT;
        break;

    case XTYP_POKE:
        msg = WM_DDE_POKE;
        lo = HIWORD(pXad->pXferInfo->hDataClient);
        if (!LOWORD(pXad->pXferInfo->hDataClient & HDATA_APPOWNED))
            hData = lo;     // need to free this on failed post.
        pXad->state = XST_POKESENT;
        XmitPrep(pXad->pXferInfo->hDataClient, pai);
        break;

    case XTYP_EXECUTE:
        msg = WM_DDE_EXECUTE;
        hi = HIWORD(pXad->pXferInfo->hDataClient);
        if (!LOWORD(pXad->pXferInfo->hDataClient & HDATA_APPOWNED))
            hData = hi;     // need to free this on failed post.
        lo = 0;
        pXad->state = XST_EXECSENT;
        // we DONT XmitPrep() because we retain responsibility over the
        // data handle during the execute transaction regardless of
        // the server's response.
        // XmitPrep(pXad->pXferInfo->hDataClient, pai);
        break;

    case XTYP_ADVSTART:
    case XTYP_ADVSTART | XTYPF_NODATA:
    case XTYP_ADVSTART | XTYPF_ACKREQ:
    case XTYP_ADVSTART | XTYPF_NODATA | XTYPF_ACKREQ:
        fsStatus = DDE_FRELEASE | ((pXad->pXferInfo->wType &
                (XTYPF_ACKREQ | XTYPF_NODATA)) << 12);
        msg = WM_DDE_ADVISE;
        if ((hData = AllocDDESel(fsStatus, pXad->pXferInfo->wFmt,
                (DWORD)sizeof(DWORD))) == 0) {
            pXad->state = XST_CONNECTED;
            return(DMLERR_MEMORY_ERROR);
        }
        lo = hData;
        pXad->pXferInfo->hDataClient = (HDDEDATA)MAKELONG(0, hData);
        /* free later if we get nack */
        pXad->state = XST_ADVSENT;
        break;

    case XTYP_ADVSTOP:
        msg = WM_DDE_UNADVISE;
        lo = pXad->pXferInfo->wFmt;
        pXad->state = XST_UNADVSENT;
        break;

    default:
        return(DMLERR_INVALIDPARAMETER);
        break;
    }

    /*
     * Send transfer
     */
    if (IsWindow(hwndServer)) {

        PCLIENTINFO pci;

        pci = (PCLIENTINFO)GetWindowLong(hwnd, GWL_PCI);

        if (!PostDdeMessage(&pci->ci, msg, hwnd, MAKELONG(lo,hi), 0, 0)) {
            pXad->state = XST_CONNECTED;
            if (hData)
                FreeDDEData(hData, pXad->pXferInfo->wFmt);
            return(DMLERR_POSTMSG_FAILED);
        }
    } else {
        /*
         * We lost the server, we are TERMINATED arnold!
         */
        pXad->state = XST_NULL;
        if (hData)
            FreeDDEData(hData, pXad->pXferInfo->wFmt);
        return(DMLERR_SERVER_DIED);
    }
    return(DMLERR_NO_ERROR);
}




VOID ServerProcessDDEMsg(
PSERVERINFO psi,
WORD msg,
HWND hwndServer,
HWND hwndClient,
WORD lo,
WORD hi)
{
    PADVLI pAdviseItem;
    WORD wType;
    DWORD dwData1 = 0;
    HDDEDATA hData = 0L;
    WORD wFmt = 0;
    WORD wStat = 0;
    LPSTR pMem;
    HANDLE hMemFree = 0;
    BOOL fQueueOnly = FALSE;

    /*
     * only respond if this is for us.
     */
    if (hwndClient != (HWND)psi->ci.hConvPartner)
        return;

    if (!(psi->ci.fs & ST_CONNECTED)) {
        /*
         * Dde messages have been received AFTER we have terminated.  Free up
         * the information if appropriate.
         * BUG: This doesn't handle NACK freeing of associated data.
         */
        FreeDdeMsgData(msg, MAKELPARAM(lo, hi));
    }

    switch (msg) {
    case WM_DDE_REQUEST:
        wType = XTYP_REQUEST;
        wFmt = lo;
        break;

    case WM_DDE_EXECUTE:
        wType = XTYP_EXECUTE;
        /* stuff a special flag into the low word to mark as exec data */
        // We don't call RecvPrep() because we never have responsability for
        // freeing this data.
        hData = (HDDEDATA)MAKELONG(HDATA_EXEC | HDATA_NOAPPFREE | HDATA_READONLY, hi);
        break;

    case WM_DDE_POKE:
        wType = XTYP_POKE;
        pMem = GLOBALLOCK(lo);
        if (pMem == NULL) {
            SETLASTERROR(psi->ci.pai, DMLERR_MEMORY_ERROR);
            return;
        }
        wFmt = ((DDEPOKE FAR*)pMem)->cfFormat;
        wStat = *(WORD FAR*)pMem;
        hData = RecvPrep(psi->ci.pai, lo, HDATA_NOAPPFREE);
        break;

    case WM_DDE_ADVISE:
        wType = XTYP_ADVSTART; /* set ST_ADVISE AFTER app oks advise loop */
        pMem = GLOBALLOCK(lo);
        if (pMem == NULL) {
            SETLASTERROR(psi->ci.pai, DMLERR_MEMORY_ERROR);
            return;
        }
        wFmt = ((DDEADVISE FAR*)pMem)->cfFormat;
        wStat = *(WORD FAR*)pMem;
        // If this is NACKed, we don't free it (sicko protocol!#$@) so we
        // have to have this hang around till qreply gets it.
        hMemFree = lo;

        /*
         * Check if we already are linked on this topic/item/format.  If so,
         * skip the callback.
         */
        fQueueOnly = (BOOL)(DWORD)FindAdvList(psi->ci.pai->pServerAdvList, hwndServer,
                    psi->ci.aTopic, (ATOM)hi, wFmt);
        break;

    case WM_DDE_UNADVISE:
        {
            PADVLI padvli;
            ATOM aItem;

            if (padvli = FindAdvList(psi->ci.pai->pServerAdvList,
                    hwndServer, 0, hi, lo)) {
                wFmt = padvli->wFmt;
                aItem = padvli->aItem;
                wType = XTYP_ADVSTOP;
                MONLINK(psi->ci.pai, FALSE, 0,
                    (HSZ)psi->ci.aServerApp, (HSZ)psi->ci.aTopic,
                    (HSZ)aItem, wFmt, TRUE,
                    MAKEHCONV(hwndServer), psi->ci.hConvPartner);
                if (!DeleteAdvList(psi->ci.pai->pServerAdvList,
                        hwndServer, 0, aItem, wFmt)) {
                    psi->ci.fs &= ~ST_ADVISE;
                } else {
                    while (padvli = FindAdvList(psi->ci.pai->pServerAdvList,
                            hwndServer, 0, hi, lo)) {
                        /*
                         * simulate extra XTYP_ADVSTOP callbacks to server here
                         */
                        MONLINK(psi->ci.pai, FALSE, 0,
                            (HSZ)psi->ci.aServerApp, (HSZ)psi->ci.aTopic,
                            (HSZ)padvli->aItem, padvli->wFmt, TRUE,
                            MAKEHCONV(hwndServer), psi->ci.hConvPartner);
                        MakeCallback(&psi->ci, MAKEHCONV(hwndServer),
                                (HSZ)psi->ci.aTopic,
                                (HSZ)padvli->aItem, padvli->wFmt,
                                XTYP_ADVSTOP, 0, 0, 0, msg, wStat,
                                NULL,    // signals qreply to NOT ack
                                0, FALSE);
                        if (!DeleteAdvList(psi->ci.pai->pServerAdvList,
                                hwndServer, 0, padvli->aItem, padvli->wFmt)) {
                            psi->ci.fs &= ~ST_ADVISE;
                        }
                    }
                }
                MakeCallback(&psi->ci, MAKEHCONV(hwndServer), (HSZ)psi->ci.aTopic,
                        (HSZ)aItem, wFmt, XTYP_ADVSTOP, 0, 0,
                        (HSZ)hi,    // item for ACK - see qreply
                        msg, wStat, (HWND)psi->ci.hConvPartner, 0, FALSE);
            } else {
                /* unexpected unadvise, NACK it. */
                PostDdeMessage(&psi->ci, WM_DDE_ACK,
                        hwndServer, MAKELONG(0, hi), 0, 0);
                return;
            }
            return;
        }

    case WM_DDE_ACK:
        /*
         * This is an ack in response to the FACKREQ bit being set.
         * See if this refers to one of the advise loops.
         */
        if ((pAdviseItem = FindAdvList(psi->ci.pai->pServerAdvList,
                hwndServer, 0, hi, wFmt)) &&
                (pAdviseItem->fsStatus & DDE_FACKREQ)) {
            /*
             * Update advise loop status - no longer waiting for an ack.
             */
            pAdviseItem->fsStatus &= ~ADVST_WAITING;
            if (pAdviseItem->fsStatus & ADVST_CHANGED) {
                PostServerAdvise(hwndServer, psi, pAdviseItem, CADV_LATEACK);
            }
        }
        if (hi)
            GlobalDeleteAtom(hi); // message copy
        // BUG: if a NACK is posted to us, WE need to free any data associated
        // with it.
        return;
    }

    MakeCallback(&psi->ci, MAKEHCONV(hwndServer), (HSZ)psi->ci.aTopic,
            /* don't know the item on an execute */
            wType == XTYP_EXECUTE ? 0L : MAKELONG(hi,0),
            wFmt, wType, hData, dwData1, 0, msg, wStat, (HWND)psi->ci.hConvPartner,
            hMemFree, fQueueOnly);
    /*
     * all freeing of atoms and hXXXX stuff is in QReply
     */
    return;
}


VOID PostServerAdvise(
HWND hwnd,
PSERVERINFO psi,
PADVLI pali,
WORD cLoops)
{
    HDDEDATA hData;
    HANDLE hMem;

    /*
     * get the data from the server.
     */
    hData = DoCallback(psi->ci.pai, MAKEHCONV(hwnd), (HSZ)psi->ci.aTopic,
            (HSZ)pali->aItem, pali->wFmt, XTYP_ADVREQ, 0L,
            (DWORD)cLoops, 0L);

    if (!hData) {
        return;
    }

    hData = DllEntry(&psi->ci, hData);

    pali->fsStatus &= ~ADVST_CHANGED;

    /*
     * set Ack Request bit if advise loop calls for it.
     */
    if (pali->fsStatus & DDE_FACKREQ) {
        LPWORD lpFlags;

        pali->fsStatus |= ADVST_WAITING;

        lpFlags = (LPWORD)GLOBALPTR(HIWORD(hData));
        if (lpFlags == NULL) {
            SETLASTERROR(psi->ci.pai, DMLERR_MEMORY_ERROR);
            return;
        }
        if (!(*lpFlags & DDE_FACKREQ)) {
            if (LOWORD(hData) & HDATA_APPOWNED) {
                // can't mess with it, must use a copy.
                hMem = HIWORD(hData);
                hData = CopyHDDEDATA(psi->ci.pai, hData);
                lpFlags = (LPWORD)GLOBALLOCK(HIWORD(hData));
            }
            *lpFlags |= DDE_FACKREQ;
        }
    }
    /*
     * remove local data handle from local list
     */
    FindPileItem(psi->ci.pai->pHDataPile, CmpHIWORD, (LPBYTE)&hData, FPI_DELETE);

    /*
     * post data to waiting client.
     */

    IncHszCount(pali->aItem);   // message copy
#ifdef DEBUG
    cAtoms--;       // Don't count this because its being shipped out.
#endif
    if (!PostDdeMessage(&psi->ci, WM_DDE_DATA, hwnd,
            MAKELONG(HIWORD(hData), pali->aItem), 0, 0)) {
        FreeDataHandle(psi->ci.pai, hData, TRUE);
    }
}


/***************************** Private Function ****************************\
* This routine handles callback replys.
* QReply is responsible for freeing any atoms or handles used
* with the message that generated the callback.
* It also must recover from dead partner windows.
*
* History:
*   Created     9/12/89    Sanfords
\***************************************************************************/
void QReply(
PCBLI pcbi,
HDDEDATA hDataRet)
{
    PSERVERINFO psi;
    WORD fsStatus, msg;
    WORD loOut, StatusRet, msgAssoc = 0;
    HGLOBAL hGMemRet;
    HGLOBAL hAssoc = 0;

    SEMCHECKOUT();

    // most notification callbacks require no work here.

    if (((pcbi->wType & XCLASS_MASK) == XCLASS_NOTIFICATION) &&
            (pcbi->wType != XTYP_ADVSTOP) &&
            (pcbi->wType != XTYP_XACT_COMPLETE))
        return;

    StatusRet = LOWORD(hDataRet);
    hGMemRet = HIWORD(hDataRet);

    if (!IsWindow((HWND)pcbi->hConv)) {
        if (pcbi->wType & XCLASS_DATA && hDataRet && hDataRet != CBR_BLOCK) {
            FreeDataHandle(pcbi->pai, hDataRet, TRUE);
        }
        return;
    }

    psi = (PSERVERINFO)GetWindowLong((HWND)pcbi->hConv, GWL_PCI);

    switch (pcbi->msg) {
    case WM_DDE_REQUEST:
        if (hGMemRet) {
            hDataRet = DllEntry(&psi->ci, hDataRet);
            loOut = HIWORD(hDataRet);
            *(WORD FAR*)GLOBALLOCK(loOut) |=
                    ((pcbi->fsStatus & DDE_FACKREQ) | DDE_FREQUESTED);
            GlobalUnlock(loOut);
            XmitPrep(hDataRet, psi->ci.pai);
            msg = WM_DDE_DATA;
        } else {
            /*
             * send a -ACK
             */
            loOut = (StatusRet & (DDE_FBUSY | DDE_FAPPSTATUS));
            msg = WM_DDE_ACK;
        }
        // reuse atom from request message
        if (!PostDdeMessage(&psi->ci, msg, (HWND)pcbi->hConv,
                MAKELONG(loOut, LOWORD(pcbi->hszItem)), 0, 0) && msg == WM_DDE_DATA)
            FreeDataHandle(psi->ci.pai, hDataRet, TRUE);
        break;

    case WM_DDE_POKE:
        if (StatusRet & DDE_FACK) {
            FreeDataHandle(psi->ci.pai, pcbi->hData, TRUE);
        } else {
            // NACKS are properly freed by the 'poker'
            FindPileItem(psi->ci.pai->pHDataPile, CmpHIWORD,
                    (LPBYTE)&pcbi->hData, FPI_DELETE);
            hAssoc = hGMemRet;
            msgAssoc = WM_DDE_POKE;
        }
        if (!PostDdeMessage(&psi->ci, WM_DDE_ACK, (HWND)pcbi->hConv,
                MAKELONG(StatusRet & ~DDE_FACKRESERVED, LOWORD(pcbi->hszItem)),
                msgAssoc, hAssoc)) {
            if (!(StatusRet & DDE_FACK)) {
                FreeDDEData(hGMemRet, pcbi->wFmt);
            }
        }
        break;

    case WM_DDE_EXECUTE:
        /*
         * LOWORD(hDataRet) is supposed to be the proper DDE_ constants to return.
         * we just stick them in the given hData and return
         * it as an ACK.
         */
        PostDdeMessage(&psi->ci, WM_DDE_ACK, (HWND)pcbi->hConv,
                MAKELONG(StatusRet & ~DDE_FACKRESERVED,HIWORD(pcbi->hData)),
                0, 0);
        break;

    case WM_DDE_ADVISE:
        /*
         * hDataRet is fStartAdvise
         */
        if ((BOOL)hDataRet) {
            if (!AddAdvList(psi->ci.pai->pServerAdvList, (HWND)pcbi->hConv, psi->ci.aTopic,
                    (ATOM)pcbi->hszItem,
                    pcbi->fsStatus & (DDE_FDEFERUPD | DDE_FACKREQ),
                    pcbi->wFmt)) {
                SETLASTERROR(psi->ci.pai, DMLERR_MEMORY_ERROR);
                fsStatus = 0;
            } else {
                MONLINK(psi->ci.pai, TRUE, pcbi->fsStatus & DDE_FDEFERUPD,
                            (HSZ)psi->ci.aServerApp, (HSZ)psi->ci.aTopic,
                            pcbi->hszItem, pcbi->wFmt, TRUE,
                            pcbi->hConv, psi->ci.hConvPartner);
                psi->ci.fs |= ST_ADVISE;
                fsStatus = DDE_FACK;
            }
            GlobalUnlock(pcbi->hMemFree);
            GLOBALFREE(pcbi->hMemFree); /* we free the hOptions on ACK */
        } else {
            fsStatus = 0;
            hAssoc = hGMemRet;
            msgAssoc = WM_DDE_ADVISE;
#ifdef DEBUG
            if (pcbi->hMemFree) {
                LogDdeObject(0xF000, pcbi->hMemFree);
            }
#endif
        }
        goto AckBack;
        break;

    case WM_DDE_UNADVISE:
        fsStatus = DDE_FACK;
        if (pcbi->hwndPartner) {    // set to null for simulated stops due to WILD stuff
            // dwData2 == aItem to ack - this could have been wild.
            PostDdeMessage(&psi->ci, WM_DDE_ACK, (HWND)pcbi->hConv,
                     MAKELONG(fsStatus, LOWORD(pcbi->dwData2)), 0, 0);
        }
        break;

    case WM_DDE_DATA:
        /*
         * must be an advise data item for the CLIENT or maybe some requested
         * data mistakenly sent here due to the client queue being flushed.
         * hDataRet is fsStatus.
         */
        /*
         * Clean up the status incase the app is messed up.
         */
        fsStatus = StatusRet & ~DDE_FACKRESERVED;

        if (HIWORD(pcbi->hData) &&
                (pcbi->fsStatus & DDE_FRELEASE) &&
                (fsStatus & DDE_FACK || !(pcbi->fsStatus & DDE_FACKREQ)))
            FreeDataHandle(psi->ci.pai, pcbi->hData, TRUE);

        if (fsStatus & DDE_FBUSY)
            fsStatus &= ~DDE_FACK;

        if (HIWORD(pcbi->hData) && !(fsStatus & DDE_FACK)) {
            msgAssoc = WM_DDE_DATA;
            hAssoc = HIWORD(pcbi->hData);
        }
        /*
         * send an ack back if requested.
         */
        if (pcbi->fsStatus & DDE_FACKREQ) {
AckBack:
            PostDdeMessage(&psi->ci, WM_DDE_ACK, (HWND)pcbi->hConv,
                     MAKELONG(fsStatus, LOWORD(pcbi->hszItem)),
                     msgAssoc, hAssoc);
        } else {
            if (LOWORD(pcbi->hszItem)) {
                GlobalDeleteAtom(LOWORD(pcbi->hszItem));  // data message copy
            }
        }
        break;

    case 0:
        switch (pcbi->wType) {
        case XTYP_XACT_COMPLETE:
            FreeHsz(LOWORD(pcbi->hszItem));
            FreeDataHandle(psi->ci.pai, pcbi->hData, TRUE);
            Deleteqi(((PCLIENTINFO)psi)->pQ, pcbi->dwData1);
        }
    }
}




/***************************** Private Function ****************************\
* This function assumes that a client transfer request has been completed -
* or should be completed by the time this is called.
*
* pci contains general client info
* pXad contains the transaction info
* pErr points to where to place the LastError code.
*
* Returns 0 on failure
* Returns TRUE or a Data Selector on success.
* On failure, the conversation is left in a XST_INCOMPLETE state.
* On success, the conversation is left in a XST_CONNECTED state.
*
* History:
*   Created     9/1/89    Sanfords
\***************************************************************************/
long ClientXferRespond(
HWND hwndClient,
PXADATA pXad,
LPWORD pErr)
{
    PCLIENTINFO pci;

    if (pXad->state == XST_INCOMPLETE)
        return(0);

    pci = (PCLIENTINFO)GetWindowLong(hwndClient, GWL_PCI);
    switch (pXad->pXferInfo->wType) {
    case XTYP_REQUEST:
        if (pXad->state != XST_DATARCVD) {
            if (*pErr == DMLERR_NO_ERROR)
                *pErr = DMLERR_DATAACKTIMEOUT;
            goto failexit;
        }
        pXad->state = XST_CONNECTED;
        return(pXad->pdata);    /* this has the handle in low word */
        break;

    case XTYP_POKE:
        if (pXad->state != XST_POKEACKRCVD) {
            if (*pErr == DMLERR_NO_ERROR)
                *pErr = DMLERR_POKEACKTIMEOUT;
            goto failexit;
        }
passexit:
        pXad->state = XST_CONNECTED;
        pXad->pdata = TRUE;
        return(TRUE);
        break;

    case XTYP_EXECUTE:
        if (pXad->state != XST_EXECACKRCVD) {
            if (*pErr == DMLERR_NO_ERROR)
                *pErr = DMLERR_EXECACKTIMEOUT;
            goto failexit;
        }
        goto passexit;

    case XTYP_ADVSTART:
    case XTYP_ADVSTART | XTYPF_NODATA:
    case XTYP_ADVSTART | XTYPF_ACKREQ:
    case XTYP_ADVSTART | XTYPF_NODATA | XTYPF_ACKREQ:
        if (pXad->state != XST_ADVACKRCVD) {
            if (*pErr == DMLERR_NO_ERROR)
                *pErr = DMLERR_ADVACKTIMEOUT;
            goto failexit;
        }
        AssertF((UINT)(XTYPF_ACKREQ << 12) == DDE_FACKREQ &&
                (UINT)(XTYPF_NODATA << 12) == DDE_FDEFERUPD,
                "XTYPF_ constants are wrong");
        if (!AddAdvList(pci->pClientAdvList, hwndClient, 0,
                LOWORD(pXad->pXferInfo->hszItem),
                (pXad->pXferInfo->wType & (XTYPF_ACKREQ | XTYPF_NODATA)) << 12,
                pXad->pXferInfo->wFmt)) {
            pXad->state = XST_INCOMPLETE;
            SETLASTERROR(pci->ci.pai, DMLERR_MEMORY_ERROR);
            return(FALSE);
        } else {
            pci->ci.fs |= ST_ADVISE;
            MONLINK(pci->ci.pai, TRUE, pXad->pXferInfo->wType & XTYPF_NODATA,
                        (HSZ)pci->ci.aServerApp, (HSZ)pci->ci.aTopic,
                        pXad->pXferInfo->hszItem, pXad->pXferInfo->wFmt, FALSE,
                        pci->ci.hConvPartner, MAKEHCONV(hwndClient));
            goto passexit;
        }
        break;

    case XTYP_ADVSTOP:
        if (pXad->state != XST_UNADVACKRCVD) {
            if (*pErr == DMLERR_NO_ERROR)
                *pErr = DMLERR_UNADVACKTIMEOUT;
            goto failexit;
        }
        if (!DeleteAdvList(pci->pClientAdvList, 0, 0,
                (ATOM)pXad->pXferInfo->hszItem, pXad->pXferInfo->wFmt))
            pci->ci.fs &= ~ST_ADVISE;
        MONLINK(pci->ci.pai, FALSE, pXad->pXferInfo->wType & XTYPF_NODATA,
                    (HSZ)pci->ci.aServerApp, (HSZ)pci->ci.aTopic,
                    pXad->pXferInfo->hszItem, pXad->pXferInfo->wFmt, FALSE,
                    pci->ci.hConvPartner, MAKEHCONV(hwndClient));
        goto passexit;
    }

failexit:
    pXad->state = XST_INCOMPLETE;
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\ddestrs\ddestrs.h ===
#ifdef WIN16

typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;

#define GETCURRENTTHREADID() 1

#else

#define GETCURRENTTHREADID() GetCurrentThreadId()

#endif

#define WHITE			  RGB(255,255,255)
#define GREEN			  RGB(0,128,128)
#define GREY			  RGB(192,192,192)
#define TOPIC			  "Test"

extern HANDLE hExtraMem;

#ifdef WIN32
#define PNT_INTERVAL 60000
#else
#define PNT_INTERVAL 30000
#endif

#define _5SEC			  5000 // milliseconds
#define _1MIN			  1
#define _1HOUR			  60
#define _1DAY			  1440
#define _1WEEKEND		  4320
#define _1WEEK			  10080
#define SERVER			  0
#define CLIENT			  1

#ifdef WIN16
#define NUM_FORMATS		  5
#else
#define NUM_FORMATS		  6
#endif

// The below offsets are used with Set/GetThreadLong()	   "THREAD"
// Offset defines cannot be interchanged between window
// and thread use because of collisions.

#define OFFSET_IDINST		  0
#define OFFSET_HCONVLIST	  4
#define OFFSET_CSERVERCONVS	  8
#define OFFSET_HSERVERCONVS	 12
#define OFFSET_HAPPOWNED	 16
#define OFFSET_CCLIENTCONVS	 20
#define OFFSET_HWNDDISPLAY	 24
#define OFFSET_CLIENTTIMER	 28
#define OFFSET_SERVERTIMER	 32
#define DELAY_METRIC		 2

#define EXTRA_THREAD_MEM	 OFFSET_SERVERTIMER+4
#define S2L(s)	 (LONG)(MAKELONG((WORD)(s),0))

// The below offsets are used with Set/GetWindowLong()	  "WINDOW"

#define OFFSET_FLAGS		  0
#define OFFSET_RUNTIME		  4
#define OFFSET_STARTTIME_SEC	  8
#define OFFSET_STARTTIME_MIN	  12
#define OFFSET_STARTTIME_HOUR	  16
#define OFFSET_STARTTIME_DAY	  20
#define OFFSET_LAST_MIN 	  24
#define OFFSET_LAST_HOUR	  28
#define OFFSET_TIME_ELAPSED	  32
#define OFFSET_DELAY		  36
#define OFFSET_STRESS		  40
#define OFFSET_SERVER_CONNECT	  44
#define OFFSET_CLIENT_CONNECT	  48
#define OFFSET_CLIENT		  52
#define OFFSET_SERVER		  56

#define OFFSET_THRDMAIN 	  60	  // <== ***
#define OFFSET_THRD2		  64	  // <== *** Ordering here is relied
#define OFFSET_THRD3		  68	  // <== *** upon in the test.	Keep
#define OFFSET_THRD4		  72	  // <== *** This group of values
#define OFFSET_THRD5		  76	  // <== *** in sequential order.
#define OFFSET_THRDMID		  80	  // <== ***
#define OFFSET_THRD2ID		  84	  // <== ***
#define OFFSET_THRD3ID		  88	  // <== ***
#define OFFSET_THRD4ID		  92	  // <== ***
#define OFFSET_THRD5ID		  96	  // <== ***
#define OFFSET_THRD2EVENT	  100	  // <== ***
#define OFFSET_THRD3EVENT	  104	  // <== ***
#define OFFSET_THRD4EVENT	  108	  // <== ***
#define OFFSET_THRD5EVENT	  112	  // <== ***

#define OFFSET_CRITICALSECT	  116
#define OFFSET_THRDCOUNT	  120
#define OFFSET_EXTRAMEM 	  124
#define OFFSET_DISPWNDHEIGHT	  128
#define OFFSET_BASE_DELAY	  132
#define OFFSET_MEM_ALLOCATED	  136

#define WND			  OFFSET_MEM_ALLOCATED+4

#define ID_OFFSET		  20
#define INC			  1
#define DEC			  0
#define STP			  2
#define PNT			  3
#define ALL			  -1

#define ON			  1
#define OFF			  0

#define AT_SWITCH		  1
#define AT_FILE 		  2
#define AT_STRESS		  3
#define AT_DELAY		  4
#define AT_TIME 		  5
#define AT_WND			  6
#define AT_MSG			  7
#define AT_FORMAT		  8
#define AT_THRD 		  9

#define FLAG_BACKGROUND 	  0x00000001
#define FLAG_AUTO		  0x00000002
#define FLAG_TIME		  0x00000004
#define FLAG_STOP		  0x00000008
#define FLAG_LOG		  0x00000010
#define FLAG_USRWNDCOUNT	  0x00000020
#define FLAG_USRMSGCOUNT	  0x00000040
#define FLAG_USRDELAY		  0x00000080
#define FLAG_DEBUG		  0x00000100
#define FLAG_CHARINFO		  0x00000200
#define FLAG_DELAYON		  0x00000400
#define FLAG_TEST_MSG_ON	  0x00000800
#define FLAG_MSGDELAYON 	  0x00001000
#define FLAG_APPOWNED		  0x00002000
#define FLAG_MULTTHREAD 	  0x00004000

#define FLAG_THRD2		  0x00008000
#define FLAG_THRD3		  0x00010000
#define FLAG_THRD4		  0x00020000
#define FLAG_THRD5		  0x00040000

#define FLAG_NET		  0x00080000
#define FLAG_SYNCPAINT		  0x00100000
#define FLAG_USRTHRDCOUNT	  0x00200000
#define FLAG_PAUSE_BUTTON	  0X00400000
#define FLAG_PAUSE		  0X00800000

#define THREADLIMIT		  5

#define STD_EXIT		  1
#define ABNORMAL_EXIT		  0

#define FLAGON(a,b)		  (LONG)(a|b)
#define FLAGOFF(a,b)		  (LONG)(a&(~b))

//#define MAX_SERVER_HCONVS   1000
#define MAX_SERVER_HCONVS   500

#define IDR_ICON    1
#define IDR_MENU    2
#define IDM_DIE     100

#define DIGITS_IN_TENMILL 8
#define BLANK_SPACE    3
#define LONGEST_LINE 15

#define NUM_COLUMNS (LONGEST_LINE+BLANK_SPACE+DIGITS_IN_TENMILL)
#define NUM_ROWS    16
#define MAX_TITLE_LENGTH 100

#define TXT	  0
#define DIB	  1
#define BITMAP	  2
#define ENHMETA   3
#define METAPICT  4
#define PALETTE   5

#define EXIT_THREAD  WM_USER+6
#define START_DISCONNECT WM_USER+7

#include "globals.h"

/*
 * Prototypes
 */

/*
 * ddestrs.c
 */

LONG FAR PASCAL MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LONG lParam);

VOID InitArgsError(HWND,unsigned);
VOID SysTime(LPSYSTEMTIME);
BOOL ParseCommandLine(HWND,LPSTR);
int SetupArgv( char **, char *, LPSTR);
BOOL PASCAL get_cmd_arg(HWND,LPSTR);
BOOL IsTimeExpired(HWND);

INT DIV(INT,INT);

BOOL TStrCmp(LPSTR,LPSTR);
LPSTR TStrCpy(LPSTR,LPSTR);
LPSTR TStrCat(LPSTR,LPSTR);
INT TStrLen(LPSTR);

LPSTR FAR PASCAL itola(int,LPSTR);
int APIENTRY latoi(LPSTR);

BOOL DOut(HWND,LPSTR,LPSTR,INT);
BOOL EOut(LPSTR);


#ifdef WIN32
BOOL ThreadShutdown(VOID);
BOOL ThreadDisconnect(VOID);
#endif

#define DDEMLERROR(a) EOut(a)
#define LOGDDEMLERROR(a) EOut(a)


/*
 * client.c
 */

void CALLBACK TimerFunc(HWND,UINT,UINT,DWORD);
VOID PaintClient(HWND hwnd, PAINTSTRUCT *pps);
VOID ReconnectList(VOID);
BOOL InitClient(VOID);
VOID CloseClient(VOID);

/*
 * server.c
 */

HDDEDATA RenderHelp_Text(HDDEDATA hData);
BOOL PokeTestItem_Text(HDDEDATA hData);
HDDEDATA RenderTestItem_Text(HDDEDATA hData);
BOOL PokeTestItem_DIB(HDDEDATA hData);
HDDEDATA RenderTestItem_DIB(HDDEDATA hData);
BOOL PokeTestItem_BITMAP(HDDEDATA hData);
HDDEDATA RenderTestItem_BITMAP(HDDEDATA hData);
BOOL PokeTestItem_METAPICT(HDDEDATA hData);
HDDEDATA RenderTestItem_METAPICT(HDDEDATA hData);
BOOL PokeTestItem_ENHMETA(HDDEDATA hData);
HDDEDATA RenderTestItem_ENHMETA(HDDEDATA hData);
BOOL PokeTestItem_PALETTE(HDDEDATA hData);
HDDEDATA RenderTestItem_PALETTE(HDDEDATA hData);
HINSTANCE GetHINSTANCE(HWND);

BOOL Execute(HDDEDATA hData);
VOID PaintServer(HWND hwnd, PAINTSTRUCT *pps);
HDDEDATA FAR PASCAL CustomCallback(UINT wType, UINT wFmt, HCONV hConv, HSZ hsz1,
	HSZ hsz2, HDDEDATA hData, DWORD dwData1, DWORD dwData2);

#ifdef WIN32
VOID ThreadWait(HWND);
DWORD SecondaryThreadMain(DWORD);
BOOL ThreadInit(HWND);
#endif

LONG SetFlag(HWND,LONG,INT);
LONG SetCount(HWND,INT,LONG,INT);
LPSTR GetMem(INT, LPHANDLE);
BOOL FreeMem(HANDLE);
BOOL FreeMemHandle(HANDLE);
HANDLE GetMemHandle(INT);
LONG SetThreadLong(DWORD,INT,LONG);
LONG GetThreadLong(DWORD,INT);
BOOL FreeThreadExtraMem(void);
BOOL CreateThreadExtraMem(INT,INT);
BOOL InitThreadInfo(DWORD);
BOOL FreeThreadInfo(DWORD);
INT IDtoTHREADNUM(DWORD);
HWND CreateDisplayWindow(HWND,INT);
LONG GetCurrentCount(HWND,INT);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\ddestrs\globals.c ===
#include <windows.h>
#include <port1632.h>
#include <ddeml.h>
#include "wrapper.h"
#include "ddestrs.h"

/* Truley global variables */

CHAR szClass[] = "DdeStrs";
int cyText = 0;
int cxText = 0;
BOOL fClient = FALSE;
BOOL fServer = FALSE;
HINSTANCE hInst;

HWND hwndMain;
CHAR szExecDie[] = "Die";
CHAR szExecDisconnect[] = "Disconnect";
CHAR szExecRefresh[] = "Refresh";

// This array contains storage for each supported
// format (CF_TEXT,CF_BITMAP,CF_DIB,..CF_ENHMETAFILE)

INT iAvailFormats[] = { 0, 0, 0, 0, 0, 0 };

/*
 * Service tables - read bottom up
 */
DDEFORMATTBL TestItemFormats[] = {
    {
        "TEXT",
        CF_TEXT,
        0,
        PokeTestItem_Text,
	RenderTestItem_Text
    },
    {
	"DIB",
	CF_DIB,
        0,
	PokeTestItem_DIB,
	RenderTestItem_DIB
    },
    {
	"BITMAP",
	CF_BITMAP,
        0,
	PokeTestItem_BITMAP,
	RenderTestItem_BITMAP
    },
#ifdef WIN32
    {
	"ENHMETAFILE",
	CF_ENHMETAFILE,
        0,
	PokeTestItem_ENHMETA,
	RenderTestItem_ENHMETA
    },
#endif
    {
	"METAFILEPICT",
	CF_METAFILEPICT,
        0,
	PokeTestItem_METAPICT,
	RenderTestItem_METAPICT
    },
    {
	"PALETTE",
	CF_PALETTE,
        0,
	PokeTestItem_PALETTE,
	RenderTestItem_PALETTE
    }
};

DDEITEMTBL Items[] = {
    {
        "TestItem",
        0,
        sizeof(TestItemFormats) / sizeof(DDEFORMATTBL),
        0,
        TestItemFormats
    }
};

DDETOPICTBL Topics[] = {
    {
	TOPIC,
        0,
        sizeof(Items) / sizeof(DDEITEMTBL),
        0,
        Items,
        Execute
    }
};

DDESERVICETBL ServiceInfoTable[] = {
    {
	"DdeStrs",
        0,
        sizeof(Topics) / sizeof(DDETOPICTBL),
        0,
        Topics
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\ddestrs\globals.h ===
extern CHAR szClass[];
extern int cyText;
extern int cxText;
extern BOOL fClient;
extern BOOL fServer;
extern HINSTANCE hInst;
extern HCONV pServerhConvs[MAX_SERVER_HCONVS];
extern HWND hwndMain;
extern CHAR szExecDie[];
extern CHAR szExecDisconnect[];
extern CHAR szExecRefresh[];
extern INT iAvailFormats[];

DDEFORMATTBL TestItemFormats[];
DDEITEMTBL Items[];
DDETOPICTBL Topics[];
DDESERVICETBL ServiceInfoTable[];

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\ddestrs\ddestrs.c ===
#include <windows.h>
#include <port1632.h>
#include <ddeml.h>
#include "wrapper.h"
#include "ddestrs.h"

VOID PaintTest(HWND,PAINTSTRUCT *);
HWND CreateButton(HWND);
HANDLE hExtraMem=0;
LPSTR pszNetName=NULL;
HANDLE hmemNet=NULL;
BOOL fnoClose=TRUE;

LONG FAR PASCAL MainWndProc(
HWND hwnd,
UINT message,
WPARAM wParam,
LONG lParam)
{
    PAINTSTRUCT ps;
    HBRUSH hBrush;
    MSG msg;
    LONG l;
    LONG lflags;
    HWND hbutton;

#ifdef WIN32
    HANDLE hmem;
    LPCRITICAL_SECTION lpcs;
#endif

    switch (message) {
    case WM_COMMAND:

#ifdef WIN32
		 if(LOWORD(wParam)==0 && HIWORD(wParam)==BN_CLICKED)
		     SendMessage(hwnd,WM_CLOSE,0,0L);

		 if(LOWORD(wParam)==1 && HIWORD(wParam)==BN_CLICKED) {

		     hbutton=GetDlgItem(hwnd,1);
		     lflags=GetWindowLong(hwnd,OFFSET_FLAGS);

		     if(lflags&FLAG_PAUSE) {
			  SetFlag(hwnd,FLAG_PAUSE,OFF);
			  SetWindowText(hbutton,"Pause");
			  CheckDlgButton(hwnd,1,0);
			  SetFocus(hwnd);
			  UpdateWindow(hbutton);
			  TimerFunc(hwndMain,WM_TIMER,1,0);
			  }
		     else {
			  SetFlag(hwnd,FLAG_PAUSE,ON);
			  SetWindowText(hbutton,"Start");
			  CheckDlgButton(hwnd,1,0);
			  SetFocus(hwnd);
			  InvalidateRect(hbutton,NULL,FALSE);
			  UpdateWindow(hbutton);
			  }
		     }

#else
		 if(wParam==1 && HIWORD(lParam)==BN_CLICKED) {

		     hbutton=GetDlgItem(hwnd,1);
		     lflags=GetWindowLong(hwnd,OFFSET_FLAGS);

		     if(lflags&FLAG_PAUSE) {
			  SetFlag(hwnd,FLAG_PAUSE,OFF);
			  SetWindowText(GetDlgItem(hwnd,1),"Pause");
			  TimerFunc(hwndMain,WM_TIMER,1,0);
			  CheckDlgButton(hwnd,1,0);
			  SetFocus(hwnd);
			  InvalidateRect(hbutton,NULL,FALSE);
			  UpdateWindow(hbutton);
			  }
		     else {
			  SetFlag(hwnd,FLAG_PAUSE,ON);
			  SetWindowText(GetDlgItem(hwnd,1),"Start");
			  CheckDlgButton(hwnd,1,0);
			  SetFocus(hwnd);
			  InvalidateRect(hbutton,NULL,FALSE);
			  UpdateWindow(hbutton);
			  }
		     }


		 if(wParam==0 && HIWORD(lParam)==BN_CLICKED)
		     SendMessage(hwnd,WM_CLOSE,0,0L);
#endif
        break;

    case WM_ENDSESSION:
    case WM_CLOSE:

        // Shutdown timers

	if (fClient)
	     {
	     CloseClient();
	     }
	else {
	     KillTimer(hwndMain,(UINT)GetThreadLong(GETCURRENTTHREADID(),OFFSET_SERVERTIMER));
	     }

	l=GetWindowLong(hwndMain,OFFSET_FLAGS);

#ifdef WIN32
	if(l&FLAG_MULTTHREAD) {

	    // Start conversations disconnecting.

	    ThreadDisconnect();

	    // Start child thread exit

	    ThreadShutdown();

            }
#endif

        // This will stop us using hwndDisplay and hwndMain
	// after there destroyed.

	SetFlag(hwnd,FLAG_STOP,ON);

	UninitializeDDE();

	// Free memory allocated for Net address.

	if(l&FLAG_NET) {
	    if(hmemNet) FreeMem(hmemNet);
	    hmemNet=0;
	    }

        // Clean out message queue (main thread)

	while (PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
	    if(msg.message!=WM_TIMER) {
		 TranslateMessage (&msg);
		 DispatchMessage (&msg);
		 }
	    }

#ifdef WIN32
	// Can Not rely on the critical section for our flag update
	// after this point.

	SetFlag(hwnd,FLAG_SYNCPAINT,OFF);

        // OK, Shutdown is now under way.  We need to wait until
        // all child threads exit before removing our critical section
        // and completing shutdown for main thread.


        if(l&FLAG_MULTTHREAD) {

            ThreadWait(hwndMain);

	    hmem=(HANDLE)GetWindowLong(hwndMain,OFFSET_CRITICALSECT);
	    SetWindowLong(hwndMain,OFFSET_CRITICALSECT,0L);

	    if(hmem)
		{
		lpcs=GlobalLock(hmem);
		if(lpcs) DeleteCriticalSection(lpcs);
		GlobalUnlock(hmem);
		GlobalFree(hmem);
		}
            }
#endif

        FreeThreadInfo(GETCURRENTTHREADID());


        // Say goodbye to main window.  Child threads must be finished
        // before making this call.

	DestroyWindow(hwnd);
	break;


    case WM_DESTROY:
        PostQuitMessage(0);
	break;


    case WM_ERASEBKGND:
	return 1;


    case WM_PAINT:
	BeginPaint(hwnd, &ps);
	hBrush=CreateSolidBrush(WHITE);
	FillRect(ps.hdc,&ps.rcPaint,hBrush);
	DeleteObject(hBrush);
	PaintTest(hwnd,&ps);
        EndPaint(hwnd, &ps);
        break;

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }
    return(0L);
}

#ifdef WIN32
BOOL ThreadShutdown( VOID ) {
INT i,nCount,nId,nOffset;


    nCount=GetWindowLong(hwndMain,OFFSET_THRDCOUNT);

    nOffset=OFFSET_THRD2ID;

    for(i=0;i<nCount-1;i++) {
        nId=GetWindowLong(hwndMain,nOffset);

        if(!PostThreadMessage(nId,EXIT_THREAD,0,0L))
	    {
	    Sleep(200);
	    if(!PostThreadMessage(nId,EXIT_THREAD,0,0L)) {
		DOut(hwndMain,"DdeStrs.Exe -- ERR:PostThreadMessage failed 4 EXIT_THREAD\r\n",NULL,0);
		}
            }

        nOffset=nOffset+4;
        }

    return TRUE;

}

BOOL ThreadDisconnect( VOID ) {
INT i,nCount,nId,nOffset;


    nCount=GetWindowLong(hwndMain,OFFSET_THRDCOUNT);

    nOffset=OFFSET_THRD2ID;

    for(i=0;i<nCount-1;i++) {
        nId=GetWindowLong(hwndMain,nOffset);

	if(!PostThreadMessage(nId,START_DISCONNECT,0,0L))
            {
	    Sleep(200);
	    if(!PostThreadMessage(nId,START_DISCONNECT,0,0L)) {
		DOut(hwndMain,"DdeStrs.Exe -- ERR:PostThreadMessage failed 4 START_DISCONNECT\r\n",NULL,0);
		}
            }

        nOffset=nOffset+4;
        }

    return TRUE;

}

#endif

VOID PaintTest(
HWND hwnd,
PAINTSTRUCT *pps)
{
    RECT rc,r;
    static CHAR szT[40];
    LONG cClienthConvs,cServerhConvs;

    GetClientRect(hwnd, &rc);
    OffsetRect(&rc, 0, cyText);
    rc.bottom = rc.top + cyText;


#ifdef WIN16

    // Test Mode

    if(IntersectRect(&r,&(pps->rcPaint),&rc)) {
	if(fServer && fClient)
	     {
	     DrawText(pps->hdc, "Client/Server (w16)", -1, &rc, DT_LEFT);
	     }
	else {
	     if(fServer)
		  {
		  DrawText(pps->hdc, "Server (w16)", -1, &rc, DT_LEFT);
		  }
	     else {
		  DrawText(pps->hdc, "Client (w16)", -1, &rc, DT_LEFT);
		  }
	     }
	}

    OffsetRect(&rc, 0, 2*cyText);  // Skip a line before next item

#else

    // Test Mode

    if(IntersectRect(&r,&(pps->rcPaint),&rc)) {
	if(fServer && fClient)
	     {
	     DrawText(pps->hdc, "Client/Server (w32)", -1, &rc, DT_LEFT);
	     }
	else {
	     if(fServer)
		  {
		  DrawText(pps->hdc, "Server (w32)", -1, &rc, DT_LEFT);
		  }
	     else {
		  DrawText(pps->hdc, "Client (w32)", -1, &rc, DT_LEFT);
		  }
	     }
	}

    OffsetRect(&rc, 0, 2*cyText);  // Skip a line before next item

#endif


    // Stress Percentage

    if(IntersectRect(&r,&(pps->rcPaint),&rc)) {
	DrawText(pps->hdc,"Stress %", -1, &rc, DT_LEFT);

#ifdef WIN32
	wsprintf(szT, "%d", GetWindowLong(hwndMain,OFFSET_STRESS));
#else
	wsprintf(szT, "%ld", GetWindowLong(hwndMain,OFFSET_STRESS));
#endif
	CopyRect(&r,&rc);
	r.left=cxText*LONGEST_LINE;
	DrawText(pps->hdc, szT, -1, &r, DT_LEFT);

	}

    OffsetRect(&rc, 0, cyText);


    // Run Time

    if(IntersectRect(&r,&(pps->rcPaint),&rc)) {
	DrawText(pps->hdc,"Run Time", -1, &rc, DT_LEFT);

#ifdef WIN32
	wsprintf(szT, "%d", GetWindowLong(hwndMain,OFFSET_RUNTIME));
#else
	wsprintf(szT, "%ld", GetWindowLong(hwndMain,OFFSET_RUNTIME));
#endif

	CopyRect(&r,&rc);
	r.left=cxText*LONGEST_LINE;
	DrawText(pps->hdc, szT, -1, &r, DT_LEFT);
	}

    OffsetRect(&rc, 0, cyText);


    // Time Elapsed

    if(IntersectRect(&r,&(pps->rcPaint),&rc)) {
	DrawText(pps->hdc, "Time Elapsed", -1, &rc, DT_LEFT);

#ifdef WIN32
	wsprintf(szT, "%d", GetWindowLong(hwndMain,OFFSET_TIME_ELAPSED));
#else
	wsprintf(szT, "%ld", GetWindowLong(hwndMain,OFFSET_TIME_ELAPSED));
#endif

	CopyRect(&r,&rc);
	r.left=cxText*LONGEST_LINE;
	DrawText(pps->hdc, szT, -1, &r, DT_LEFT);

	}

    OffsetRect(&rc, 0, cyText);


    // *** Count Client Connections ****

    if(IntersectRect(&r,&(pps->rcPaint),&rc)) {

	cClienthConvs=GetCurrentCount(hwnd,OFFSET_CCLIENTCONVS);
	DrawText(pps->hdc,"Client Connect", -1, &rc, DT_LEFT);

#ifdef WIN32
	wsprintf(szT, "%d", cClienthConvs);
#else
	wsprintf(szT, "%ld", cClienthConvs);
#endif
	CopyRect(&r,&rc);
	r.left=cxText*LONGEST_LINE;
	DrawText(pps->hdc, szT, -1, &r, DT_LEFT);

	} // if IntersectRect

    OffsetRect(&rc, 0, cyText);


    // *** Server Connections ***

    if(IntersectRect(&r,&(pps->rcPaint),&rc)) {
	DrawText(pps->hdc,"Server Connect", -1, &rc, DT_LEFT);

	cServerhConvs=GetCurrentCount(hwnd,OFFSET_CSERVERCONVS);

#ifdef WIN32
	wsprintf(szT, "%d", cServerhConvs );
#else
	wsprintf(szT, "%ld", cServerhConvs );
#endif
	CopyRect(&r,&rc);
	r.left=cxText*LONGEST_LINE;
	DrawText(pps->hdc, szT, -1, &r, DT_LEFT);
	}

    OffsetRect(&rc, 0, cyText);


    // Client Count (for checking balence between apps)

    if(IntersectRect(&r,&(pps->rcPaint),&rc)) {
	DrawText(pps->hdc,"Client Count", -1, &rc, DT_LEFT);

#ifdef WIN32
	wsprintf(szT, "%d",GetWindowLong(hwnd,OFFSET_CLIENT));
#else
	wsprintf(szT, "%ld",GetWindowLong(hwnd,OFFSET_CLIENT));
#endif
	CopyRect(&r,&rc);
	r.left=cxText*LONGEST_LINE;
	DrawText(pps->hdc, szT, -1, &r, DT_LEFT);
	}

    OffsetRect(&rc, 0, cyText);


    // Server Count (for checking balence between apps)

    if(IntersectRect(&r,&(pps->rcPaint),&rc)) {
	DrawText(pps->hdc,"Server Count", -1, &rc, DT_LEFT);

#ifdef WIN32
	wsprintf(szT, "%d", GetWindowLong(hwnd,OFFSET_SERVER));
#else
	wsprintf(szT, "%ld", GetWindowLong(hwnd,OFFSET_SERVER));
#endif
	CopyRect(&r,&rc);
	r.left=cxText*LONGEST_LINE;
	DrawText(pps->hdc, szT, -1, &r, DT_LEFT);
    }

    OffsetRect(&rc, 0, cyText);


    // Delay

    if(IntersectRect(&r,&(pps->rcPaint),&rc)) {
	DrawText(pps->hdc,"Delay", -1, &rc, DT_LEFT);

#ifdef WIN32
	wsprintf(szT, "%d", GetWindowLong(hwndMain,OFFSET_DELAY));
#else
	wsprintf(szT, "%ld", GetWindowLong(hwndMain,OFFSET_DELAY));
#endif
	CopyRect(&r,&rc);
	r.left=cxText*LONGEST_LINE;
	DrawText(pps->hdc, szT, -1, &r, DT_LEFT);
	}

    OffsetRect(&rc, 0, cyText);

}

int PASCAL WinMain(
HINSTANCE hInstance,
HINSTANCE hPrev,
LPSTR lpszCmdLine,
int cmdShow)
{
    MSG       msg;
    HDC       hdc;
    WNDCLASS  wc;
    TEXTMETRIC tm;
    INT       x,y,cx,cy;
#ifdef WIN32
    LONG      lflags;
#endif
    DWORD     idI;
    HWND      hwndDisplay;
    INT       nThrd;

    CHAR sz[250];
    CHAR sz2[250];
    LPSTR lpszOut=&sz[0];
    LPSTR lpsz=&sz2[0];

#ifdef WIN32
    DWORD dwer;
#endif

    hInst=hInstance;

    if(!SetMessageQueue(100)) {
	MessageBox(NULL,"SetMessageQueue failed. Test aborting.","Error:DdeStrs",MB_ICONSTOP|MB_OK);
	return FALSE;
	}

    wc.style         = 0;
    wc.lpfnWndProc   = MainWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = WND;
    wc.hInstance     = hInst;
    wc.hIcon	     = LoadIcon(hInst,MAKEINTRESOURCE(IDR_ICON));
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE+1);
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = szClass;

    if(!hPrev) {
	if (!RegisterClass(&wc) )
	    {
#if 0
	    // This was removed because the system was running out of resources (ALPHA only)
	    // which caused this occasionaly to fail.  Rather than continue to bring
	    // the message box up (for a known stress situation) the test will abort
	    // and try again.

	    MessageBox(NULL,"RegisterClass failed. Test aborting.","Error:DdeStrs",MB_ICONSTOP|MB_OK);
#endif
	    return FALSE;
	    }
	}

    hwndMain = CreateWindowEx( WS_EX_DLGMODALFRAME,
			       szClass,
			       szClass,
			       WS_OVERLAPPED|WS_MINIMIZEBOX|WS_CLIPCHILDREN,
			       0,
			       0,
			       0,
			       0,
			       NULL,
			       NULL,
			       hInst,
			       NULL);

#ifdef WIN32
    dwer=GetLastError();  // We want LastError Associated with CW call
#endif

    if (!hwndMain) {
	MessageBox(NULL,"Could Not Create Main Window. Test aborting.","Error:DdeStrs",MB_ICONSTOP|MB_OK);
	UnregisterClass(szClass,hInst);
	return FALSE;
	}

#ifdef WIN32
    if (!IsWindow(hwndMain)) {
	TStrCpy(lpsz,"CreateWindowEx failed for Main Window but did not return NULL! Test aborting. HWND=%u, LastEr=%u");
	wsprintf(lpszOut,lpsz,hwndMain,dwer);
	MessageBox(NULL,lpszOut,"Error:DdeStrs",MB_ICONSTOP|MB_OK);
	UnregisterClass(szClass,hInst);
	return FALSE;
	}
#else
    if (!IsWindow(hwndMain)) {
	TStrCpy(lpsz,"CreateWindowEx failed for Main Window but did not return NULL! Test aborting. HWND=%u");
	wsprintf(lpszOut,lpsz,hwndMain);
	MessageBox(NULL,lpszOut,"Error:DdeStrs",MB_ICONSTOP|MB_OK);
	UnregisterClass(szClass,hInst);
	return FALSE;
	}
#endif

    if (!ParseCommandLine(hwndMain,lpszCmdLine)) {
	DestroyWindow(hwndMain);
	UnregisterClass(szClass,hInst);
	return FALSE;
	}

    // Note:  This needs to be there even for win 16 execution.  The
    //	      name may be confusing.  for win 16 there is obviously only
    //	      a single thread.	This is handled by the call.


    nThrd=GetWindowLong(hwndMain,OFFSET_THRDCOUNT);

    // Currently ddestrs has a hardcoded thread limit (at THREADLIMIT).  So
    // this should NEVER be less than one or greater than THREADLIMIT.

#ifdef WIN32
    if(nThrd<1 || nThrd>THREADLIMIT) {
	BOOL fVal;

	dwer=GetLastError();

	if(IsWindow(hwndMain)) fVal=TRUE;
	else		       fVal=FALSE;

	TStrCpy(lpsz,"GetWindowLong failed querying thread count!. Test aborting...  INFO:hwnd=%u, LastEr=%u, Is hwnd valid=%u, nThrd=%u");

	wsprintf(lpszOut,lpsz,hwndMain,dwer,fVal,nThrd);
	MessageBox(NULL,lpszOut,"Error:DdeStrs",MB_ICONSTOP|MB_OK);

	DestroyWindow(hwndMain);
	UnregisterClass(szClass,hInst);
	return FALSE;
	}
#endif

    if(!CreateThreadExtraMem( EXTRA_THREAD_MEM,nThrd)) {
	MessageBox(NULL,"Could Not Alocate Get/SetThreadLong(). Test aborting.","Error:DdeStrs",MB_ICONSTOP|MB_OK);
	DestroyWindow(hwndMain);
	UnregisterClass(szClass,hInst);
	return FALSE;
	}

    // We always need the thread id for the main thread.  (for use
    // in Get/SetThreadLong().	Other thread id's are initialized in
    // ThreadInit().

    SetWindowLong(hwndMain,OFFSET_THRDMID,GETCURRENTTHREADID());

    if(!InitThreadInfo(GETCURRENTTHREADID())) {
	MessageBox(NULL,"Could Not Alocate Thread Local Storage. Test aborting.","Error:DdeStrs",MB_ICONSTOP|MB_OK);
	DestroyWindow(hwndMain);
	UnregisterClass(szClass,hInst);
	return FALSE;
        }

    hdc = GetDC(hwndMain);
    GetTextMetrics(hdc, &tm);

    cyText = tm.tmHeight;
    cxText = tm.tmAveCharWidth;

    // We need to add in extra area for each additional DisplayWindow
    // used for each addtional thread.

    nThrd=(INT)GetWindowLong(hwndMain,OFFSET_THRDCOUNT);
    cy	   = tm.tmHeight*NUM_ROWS+((nThrd-1)*(3*cyText));
    cx	   = tm.tmAveCharWidth*NUM_COLUMNS;

    ReleaseDC(hwndMain,hdc);

    // Old ways of positioning.

    // y=DIV((GetSystemMetrics(SM_CYSCREEN)-cy),3)*2;
    // y=(DIV(GetSystemMetrics(SM_CYSCREEN),10)*3);

    // Position as if 5 threads with bottom of window at bottom of
    // screen.

    y=GetSystemMetrics(SM_CYSCREEN)-(tm.tmHeight*NUM_ROWS+(12*cyText));

    x=GetSystemMetrics(SM_CXSCREEN);

    if(fServer && fClient) {
	 x=x-(cx*3); // Init for standard values.
	 }
    else {
	 if(fServer)
	      {
	      x=x-cx;
	      }
	 else {
	      x=x-(cx*2);
	      }
	 }

    SetWindowPos( hwndMain,
		  NULL,
		  x,
		  y,
		  cx,
		  cy,
		  SWP_NOZORDER|SWP_NOACTIVATE );

    ShowWindow (hwndMain, cmdShow);

    CreateButton(hwndMain);

    UpdateWindow (hwndMain);

#ifdef WIN32
    SetFlag(hwndMain,FLAG_SYNCPAINT,ON);

    lflags=GetWindowLong(hwndMain,OFFSET_FLAGS);
    if(lflags&FLAG_MULTTHREAD) {      // CreateThreads
	if(!ThreadInit(hwndMain)) {
	    DestroyWindow(hwndMain);
	    UnregisterClass(szClass,hInst);
	    return FALSE;
	    }
	}
#endif

    hwndDisplay=CreateDisplayWindow(hwndMain,1);

    if(!hwndDisplay) {
	 MessageBox(NULL,"Could Not Create Test Display Window. Test aborting.","Error:DdeStrs",MB_ICONSTOP|MB_OK);
	 DestroyWindow(hwndMain);
	 UnregisterClass(szClass,hInst);
	 return FALSE;
	 }
    else {
	 SetThreadLong(GETCURRENTTHREADID(),OFFSET_HWNDDISPLAY,(LONG)hwndDisplay);
	 }

    if (!InitializeDDE((PFNCALLBACK)CustomCallback,
		       &idI,
                       ServiceInfoTable,
                       fServer ?
                            APPCLASS_STANDARD
                       :
			    APPCLASS_STANDARD | APPCMD_CLIENTONLY,
                       hInst)) {
	DDEMLERROR("DdeStrs.Exe -- Error Dde inititialization failed\r\n");
	DestroyWindow(hwndMain);
	UnregisterClass(szClass,hInst);
        return(FALSE);
    }

    SetThreadLong(GETCURRENTTHREADID(),OFFSET_IDINST,idI);

    if (fClient)
	 {
	 InitClient();
	 }
    else {

	 // Only needed if we are not a client.  In case of
	 // client/server only call InitClient() which start
	 // a timer which can be used for time checks.

	 SetTimer( hwndMain,
		   (UINT)GetThreadLong(GETCURRENTTHREADID(),OFFSET_SERVERTIMER),
		   PNT_INTERVAL,
		   TimerFunc);
	 }

    while (GetMessage(&msg, NULL, 0, 0)) {

	    if(IsTimeExpired(hwndMain)) {

		// We only want to send a single WM_CLOSE

		if(fnoClose) {
		    fnoClose=FALSE;
		    PostMessage(hwndMain,WM_CLOSE,0,0L);
		    }
		}

        TranslateMessage (&msg);
        DispatchMessage (&msg);
	}

    FreeThreadExtraMem();

    return(TRUE);
}

#ifdef WIN32
/**************************  Private Function  ****************************\
*
* ThreadInit
*
* Create secondary test threads
*
\**************************************************************************/

BOOL ThreadInit( HWND hwnd ) {
LONG	l,ll;
PLONG	lpIDThread=&ll;
HANDLE	hthrd;
INT	nOffset,nCount,i,n;
HANDLE	hmem;
HANDLE *lph;
char   sz[20];
LPSTR  lpsz=&sz[0];

    nCount=GetWindowLong(hwnd,OFFSET_THRDCOUNT);
    nOffset=OFFSET_THRD2;

    for(i=1;i<nCount;i++) {

	hmem=GetMemHandle(((sizeof(HANDLE)*2)+sizeof(INT)));
	lph=(HANDLE *)GlobalLock(hmem);

	*lph=hwnd;
	*(lph+1)=hmem;
	*(lph+2)=(HANDLE)(i+1);

	hthrd=CreateThread(NULL,0,SecondaryThreadMain,(LPVOID)lph,0,lpIDThread);

	if (!hthrd) {

	    DOut(hwnd,"DdeStrs.Exe -- ERR:Could not Create Thread #%u\r\n",0,i+1);

	    GlobalUnlock(hmem);
	    FreeMemHandle(hmem);

	    // it's important we turn this flag off since no threads
	    // where successfully created (cleanup code)

	    SetFlag(hwnd,FLAG_MULTTHREAD,OFF);

	    if (i==1) return FALSE;
	    else {

		 // Cleanup threads before we abort.

		 for(n=1;n<i;n++) {
		     nOffset=OFFSET_THRD2;
		     TerminateThread((HANDLE)GetWindowLong(hwnd,nOffset),0);
		     SetWindowLong(hwnd,nOffset,0L);
		     nOffset=nOffset+4;
		     } // for

		 return FALSE;

		 } // else

	    } // if

	SetWindowLong(hwnd,nOffset+ID_OFFSET,(LONG)(*lpIDThread));
	SetWindowLong(hwnd,nOffset,(LONG)hthrd);

	nOffset=nOffset+4;

	} // for


	return TRUE;

}  // ThreadInit

/*************************** Private Function ******************************\
SecondaryThreadMain

Effects: Start of execution for second thread.	First order of buisness is
	 create the test window and start queue processing.

Return value:

\***************************************************************************/

DWORD SecondaryThreadMain( DWORD dw )
{
HWND	  hwndMain;
MSG	  msg;
HANDLE *  lph;
HANDLE	  hmem;
INT	  nThrd;
DWORD	  idI;
HWND	  hwndDisplay;
LONG	  nTc;

    lph=(HANDLE *)dw;

    hwndMain=(HWND)*lph;
    hmem  =(HANDLE)*(lph+1);
    nThrd =(INT)*(lph+2);

    GlobalUnlock(hmem);
    FreeMemHandle(hmem);

    if(!InitThreadInfo(GETCURRENTTHREADID())) {
	DDEMLERROR("DdeStrs.Exe -- Error InitThreadInfo failed, Aborting thread\r\n");
	nTc=GetWindowLong(hwndMain,OFFSET_THRDCOUNT);
	SetWindowLong(hwndMain,OFFSET_THRDCOUNT,(LONG)(nTc-1));
	ExitThread(1L);
	}

    SetThreadLong(GETCURRENTTHREADID(),OFFSET_IDINST,idI);

    hwndDisplay=CreateDisplayWindow( hwndMain,
				     IDtoTHREADNUM(GETCURRENTTHREADID()));

    if(!IsWindow(hwndDisplay)) {
	 DDEMLERROR("DdeStrs.Exe -- ERR:Could not create Display Window, Thread aborting\r\n");
	 nTc=GetWindowLong(hwndMain,OFFSET_THRDCOUNT);
	 SetWindowLong(hwndMain,OFFSET_THRDCOUNT,(LONG)(nTc-1));
	 ExitThread(1L);
	 return FALSE;
	 }
    else {
	 SetThreadLong(GETCURRENTTHREADID(),OFFSET_HWNDDISPLAY,hwndDisplay);
	 }

    if (!InitializeDDE((PFNCALLBACK)CustomCallback,
		       &idI,
                       ServiceInfoTable,
                       fServer ?
                            APPCLASS_STANDARD
                       :
			    APPCLASS_STANDARD | APPCMD_CLIENTONLY,
                       hInst)) {
	DDEMLERROR("DdeStrs.Exe -- Error Dde inititialization failed for secondary thread!\r\n");
	FreeThreadInfo(GETCURRENTTHREADID());
	nTc=GetWindowLong(hwndMain,OFFSET_THRDCOUNT);
	SetWindowLong(hwndMain,OFFSET_THRDCOUNT,(LONG)(nTc-1));
	ExitThread(1L);
    }

    if (fClient)
	 {
	 InitClient();
	 }
    else {

	 // Only needed if we are not a client.  In case of
	 // client/server only call InitClient() which start
	 // a timer which can be used for time checks.

	 SetTimer( hwndMain,
		   (UINT)GetThreadLong(GETCURRENTTHREADID(),OFFSET_SERVERTIMER),
		   PNT_INTERVAL,
		   TimerFunc);
	 }

    while (GetMessage(&msg,NULL,0,0)) {

	if(msg.message==START_DISCONNECT)
	     {
	     if (fClient)
		 {
		 CloseClient();
		 }
             }
	else {
	     if(msg.message==EXIT_THREAD)
		  {
		  PostQuitMessage(1);
		  }
	     else {
		  TranslateMessage(&msg);
		  DispatchMessage(&msg);
		  }  // EXIT_THREAD

	     }	// START_DISCONNECT

	} // while

    SetFlag(hwndMain,FLAG_STOP,ON);

    // Shutdown timers

    if (!fClient)
       {
       KillTimer(hwndMain,GetThreadLong(GETCURRENTTHREADID(),OFFSET_SERVERTIMER));
       }

    UninitializeDDE();

    FreeThreadInfo(GETCURRENTTHREADID());


    // This is to release the semaphore set before completing
    // exit on main thread.


    switch (nThrd) {

       case 2: SetFlag(hwndMain,FLAG_THRD2,ON);
           break;
       case 3: SetFlag(hwndMain,FLAG_THRD3,ON);
           break;
       case 4: SetFlag(hwndMain,FLAG_THRD4,ON);
           break;
       case 5: SetFlag(hwndMain,FLAG_THRD5,ON);
           break;
       default:
	   DOut(hwndMain,"DdeStrs.Exe -- ERR: Unexpected switch value in SecondaryThreadMain, value=%u\r\n",0,nThrd);
           break;

       }  // switch

    ExitThread(1L);

    return 1;

}

#endif

/**************************  Public Function  *****************************\
*
* InitThrdInfo - This routine allocates memory needed for storage for
*		 thread local variables.  This routine needs to be called
*		 for each thread.
*
* Note: I am relying on the fact that the call GetMemHandle() calls
*	GlobalAlloc() specifying the GMEM_ZEROINIT flag.  These value need
*	to be zero starting off.
\**************************************************************************/

BOOL InitThreadInfo( DWORD dwid ) {
HANDLE hmem;
INT nThrd;

     hmem = GetMemHandle(sizeof(HCONV)*MAX_SERVER_HCONVS);
     SetThreadLong(dwid,OFFSET_HSERVERCONVS,(LONG)hmem);

     if( hmem==NULL ) {
	DOut(hwndMain,"DdeStrs.Exe -- ERR: Could not allocate thread local storage(Server Conversation List)\r\n",0,0);
	return FALSE;
	}

     hmem = GetMemHandle(sizeof(HANDLE)*NUM_FORMATS);
     SetThreadLong(dwid,OFFSET_HAPPOWNED,(LONG)hmem);

     if( hmem==NULL ) {
	DOut(hwndMain,"DdeStrs.Exe -- ERR: Could not allocate thread local storage(AppOwned Flag List)\r\n",0,0);
	FreeMemHandle((HANDLE)GetThreadLong(dwid,OFFSET_HSERVERCONVS));
	return FALSE;
	}

     nThrd=IDtoTHREADNUM(dwid);

     SetThreadLong(dwid,OFFSET_SERVERTIMER,nThrd*2);
     SetThreadLong(dwid,OFFSET_CLIENTTIMER,(nThrd*2)+1);

     return TRUE;

}

#ifdef WIN32

/**************************  Private Function  ****************************\
*
* IDtoTHREADNUM - Find out current thread.
*
\**************************************************************************/

INT IDtoTHREADNUM( DWORD dwid ) {
INT nWndOff,nThrd,nThrdCount,n;

    nWndOff=OFFSET_THRDMID;
    nThrdCount=GetWindowLong(hwndMain,OFFSET_THRDCOUNT);
    n=nThrdCount;
    nThrd=1;

    while( n>0 ) {

	if(dwid==(DWORD)GetWindowLong(hwndMain,nWndOff))
	     {
	     n=-1;     // Exit loop
	     } // if
	else {
	     nWndOff=nWndOff+4;
	     nThrd++;
	     n--;
	     }
	} // while

    if(nThrd>nThrdCount) {
	DDEMLERROR("DdeStrs.Exe -- ERR:Thread Count exceeded!!! in IDtoTHREADNUM()\r\n");
	nThrd=nThrdCount;
	}

    return nThrd;

}

#else

/**************************  Private Function  ****************************\
*
* IDtoTHREADNUM - Find out current thread.
*
\**************************************************************************/

INT IDtoTHREADNUM( DWORD dwid ) {

    return 1;

}

#endif

/**************************  Public Function  *****************************\
*
* FreeThreadInfo - Free thread information memory.
*
\**************************************************************************/

BOOL FreeThreadInfo( DWORD dwid ) {
HANDLE hmem;

     hmem=(HANDLE)GetThreadLong(dwid,OFFSET_HSERVERCONVS);
     FreeMemHandle(hmem);
     return TRUE;

}

#ifdef WIN32

/**************************  Public Function  *****************************\
*
* ThreadWait - This routine waits while processing messages until the
*	       other threads signal they've completed work that must
*	       be finished before preceeding.
*
\**************************************************************************/

VOID ThreadWait( HWND hwnd ) {
LONG lflags;
INT  nCount,nWait;
MSG  msg;

    lflags=GetWindowLong(hwnd,OFFSET_FLAGS);
    nCount=GetWindowLong(hwnd,OFFSET_THRDCOUNT);

    nWait=nCount-1;

    if(lflags&FLAG_THRD2) nWait-=1;
    if(lflags&FLAG_THRD3) nWait-=1;
    if(lflags&FLAG_THRD4) nWait-=1;
    if(lflags&FLAG_THRD5) nWait-=1;

    while (nWait>0) {

	while(PeekMessage(&msg,NULL,0,WM_USER-1,PM_REMOVE)) {
	   TranslateMessage(&msg);
	   DispatchMessage(&msg);
	   } // while peekmessage

	nWait=nCount-1;
	lflags=GetWindowLong(hwnd,OFFSET_FLAGS);

	if(lflags&FLAG_THRD2) nWait-=1;
	if(lflags&FLAG_THRD3) nWait-=1;
	if(lflags&FLAG_THRD4) nWait-=1;
	if(lflags&FLAG_THRD5) nWait-=1;

	} // while nWait

    // Reset for next wait

    SetFlag(hwnd,(FLAG_THRD5|FLAG_THRD4|FLAG_THRD3|FLAG_THRD2),OFF);

}

#endif // WIN32

/**************************  Private Function  ****************************\
*
* SetCount
*
* This routine updates the count under semaphore protection.  Not needed for
* one thread, but a must for multithread execution.
*
\**************************************************************************/

LONG SetCount( HWND hwnd, INT nOffset, LONG l, INT ntype ) {
LONG ll;

#if 0
LONG lflags;
#endif

#ifdef WIN32
LPCRITICAL_SECTION lpcs;
HANDLE hmem;
BOOL f=FALSE;
#endif

#if 0

    lflags=GetWindowLong(hwnd,OFFSET_FLAGS);
    if(ll&FLAG_MULTTHREAD) {
	f=TRUE;
	hmem=(HANDLE)GetWindowLong(hwnd,OFFSET_CRITICALSECT);

	// If we have a valid handle then enter critical section. If
	// the handle is still null proceed without a critical section.
	// The first calls to this routine are used to setup the
	// critical section so we do expect those first calls (while
	// we are still sencronized ) for the hmem to be null.

	if(hmem) {
	    lpcs=GlobalLock(hmem);
	    EnterCriticalSection(lpcs);
	    }
	}

#endif

    // This second GetWindowLong call is needed in the critical
    // section.  The test relies very hevily on the flags and
    // it's important to be accurate.

    ll=GetWindowLong(hwnd,nOffset);

    if(ntype==INC) l=SetWindowLong(hwnd,nOffset,ll+l);
    else	   l=SetWindowLong(hwnd,nOffset,ll-l);

#if 0

    if(f) {
	if(hmem) {
	     LeaveCriticalSection(lpcs);
	     GlobalUnlock(hmem);
	     }
	}

#endif

    return l;
}

/**************************  Private Function  ****************************\
*
* SetFlag
*
* This routine sets a flag under semaphore protection.	Not needed for
* one thread, but a must for multithread execution.
*
\**************************************************************************/

LONG SetFlag( HWND hwnd, LONG l, INT ntype ) {
LONG lflags;

#ifdef WIN32
BOOL   fCriticalSect=TRUE;
LPCRITICAL_SECTION lpcs;
HANDLE hmem;
BOOL   f=FALSE;
#endif

#ifdef WIN32

    lflags=GetWindowLong(hwnd,OFFSET_FLAGS);
    if(lflags&FLAG_MULTTHREAD &&
       lflags&FLAG_SYNCPAINT) {
	f=TRUE;
	hmem=(HANDLE)GetWindowLong(hwnd,OFFSET_CRITICALSECT);
	if(hmem) {
	     lpcs=GlobalLock(hmem);
	     EnterCriticalSection(lpcs);
	     }
	else {
	     fCriticalSect=FALSE;
	     }
	}

#endif

    // This second GetWindowLong call is needed in the critical
    // section.  The test relies very hevily on the flags and
    // it's important to be accurate.

    lflags=GetWindowLong(hwnd,OFFSET_FLAGS);

    if(ntype==ON) l=SetWindowLong(hwnd,OFFSET_FLAGS,FLAGON(lflags,l));
    else	  l=SetWindowLong(hwnd,OFFSET_FLAGS,FLAGOFF(lflags,l));

#ifdef WIN32

    if(f) {
	if(fCriticalSect) {
	    LeaveCriticalSection(lpcs);
	    GlobalUnlock(hmem);
	    }
	}

#endif

    return l;
}

/******************************************************************\
*  DIV
*  05/06/91
*
*  Performs integer division  (format x/y) where DIV(x,y)
*  Works for negative numbers and y==0;
*
\******************************************************************/

INT DIV( INT x, INT y)
{
INT  i=0;
BOOL fNgOn=FALSE;

     if (!y) return 0;		  // if div by 0 retrun error.

     if (x<0 && y>0) fNgOn=TRUE;  // keep tabs for negitive numbers
     if (x>0 && y<0) fNgOn=TRUE;

     if (x<0) x=x*-1;
     if (y<0) y=y*-1;

     x=x-y;

     while (x>=0) {		  // count
	x=x-y;
	i++;
	}

     if (fNgOn) i=i*(-1);	  // should result be negative

     return( i );
}

/*************************** Private Function ******************************\
*
* CreateButton
*
\***************************************************************************/

HWND CreateButton( HWND hwnd ) {
RECT r;
HWND hwndB;
HWND hwndP;
INT  iButWidth;
LONG lflags;

     GetClientRect(hwnd,&r);

     lflags=GetWindowLong(hwnd,OFFSET_FLAGS);
     if(lflags&FLAG_PAUSE_BUTTON) {

	   iButWidth=DIV(r.right-r.left,2);

	   hwndP=CreateWindow("button",
			      "Start",
			       BS_PUSHBUTTON|WS_VISIBLE|WS_CHILD|WS_CLIPSIBLINGS,
			       iButWidth,
			       0,
			       r.right-iButWidth,
			       cyText,
			       hwnd,
			       1,
			       GetHINSTANCE(hwnd),
			       0L);

	  if (!hwndP) {
	      DDEMLERROR("DdeStrs.Exe -- ERR:Failed to create exit button: Continuing...\r\n");
	      SetFlag(hwnd,FLAG_PAUSE_BUTTON,OFF);
	      iButWidth=r.right-r.left;
	      }


	  hwndB=CreateWindow("button",
			     "Exit",
			      BS_PUSHBUTTON|WS_VISIBLE|WS_CHILD|WS_CLIPSIBLINGS,
			      0,
			      0,
			      iButWidth,
			      cyText,
			      hwnd,
			      0,
			      GetHINSTANCE(hwnd),
			      0L);

	  }
     else {

	  hwndB=CreateWindow("button",
			     "Exit",
			      BS_PUSHBUTTON|WS_VISIBLE|WS_CHILD|WS_CLIPSIBLINGS,
			      0,
			      0,
			      r.right-r.left,
			      cyText,
			      hwnd,
			      0,
			      GetHINSTANCE(hwnd),
			      0L);
	  }

     if (!hwndB) {
	 DDEMLERROR("DdeStrs.Exe -- ERR:Failed to create exit button: Continuing...\r\n");
	 }

     return hwndB;
}

/***************************************************************************\
*
*  UpdClient
*
*  The purpose of this routine update only the area invalidated
*  by the test statistics update.  If an error occurs in the area
*  calcualation then update the whole client areaa.
*
\***************************************************************************/

BOOL UpdClient( HWND hwnd, INT iOffset ) {
RECT r;
INT  iCH,iCW,nThrd;

#ifdef WIN32
DWORD dw;
#endif

    // This call aquires the r.right value.

    GetClientRect(hwnd,&r);

    // We need text information for the monitor being used.  This
    // was initialized in CreateFrame.
    iCH=cyText;
    iCW=cxText;

    // Do a quick check, if either of these values are NULL then
    // update the whole client area.  This is slower and less
    // elegant but will work in the case of an error.

    if((!iCH) || (!iCW))
	InvalidateRect(hwnd,NULL,TRUE);
    else {

	 // Next Calculate r.top and r.bottom

	 switch(iOffset) {

	    case ALL:	// Update all values.
		break;

	    case OFFSET_STRESS:
		r.bottom =iCH*4;
		r.top	 =iCH*3;
		break;

	    case OFFSET_RUNTIME:
		r.bottom =iCH*5;
		r.top	 =iCH*4;
		break;

	    case OFFSET_TIME_ELAPSED:
		r.bottom =iCH*6;
		r.top	 =iCH*5;
		break;

	    case OFFSET_CLIENT_CONNECT:
		r.bottom =iCH*7;
		r.top	 =iCH*6;
		break;

	    case OFFSET_SERVER_CONNECT:
		r.bottom =iCH*8;
		r.top	 =iCH*7;
	       break;

	    case OFFSET_CLIENT:
		nThrd=(INT)GetWindowLong(hwnd,OFFSET_THRDCOUNT);
		if((GetWindowLong(hwnd,OFFSET_CLIENT)%(NUM_FORMATS*nThrd))==0)
		     {
		     r.bottom =iCH*9;
		     r.top    =iCH*8;
		     }
		else return TRUE;
		break;

	    case OFFSET_SERVER:
		nThrd=(INT)GetWindowLong(hwnd,OFFSET_THRDCOUNT);
		if((GetWindowLong(hwnd,OFFSET_SERVER)%(NUM_FORMATS*nThrd))==0)
		     {
		     r.bottom =iCH*10;
		     r.top    =iCH*9;
		     }
		else return TRUE;
		break;

	    case OFFSET_DELAY:
		r.bottom =iCH*11;
		r.top	 =iCH*10;
		break;
	    default:
		break;

	    }  // switch

	 // Last we set the r.left and the update rect is complete

	 if(iOffset!=OFFSET_FLAGS)
	      r.left = iCW*LONGEST_LINE;

	 InvalidateRect(hwnd,&r,TRUE);

         }  // else

#ifdef WIN16
    UpdateWindow(hwnd);
#else
    SendMessageTimeout(hwnd,WM_PAINT,0,0L,SMTO_NORMAL,500,&dw);
#endif

    return TRUE;

}  // UpdClient

/***************************************************************************\
*
*  GetCurrentCount
*
\***************************************************************************/

LONG GetCurrentCount( HWND hwnd, INT nOffset ) {
LONG cClienthConvs =0L;
INT nThrd,i;
DWORD dwid;

     nThrd=(INT)GetWindowLong(hwnd,OFFSET_THRDCOUNT);
     for(i=0;i<nThrd;i++) {
	 dwid=(DWORD)GetWindowLong(hwnd,OFFSET_THRDMID+(i*4));
	 if(nOffset==OFFSET_CCLIENTCONVS)
	      cClienthConvs=cClienthConvs+(INT)GetThreadLong(dwid,OFFSET_CCLIENTCONVS);
	 else cClienthConvs=cClienthConvs+(INT)GetThreadLong(dwid,OFFSET_CSERVERCONVS);
	 } // for i

     return cClienthConvs;

}

/***************************************************************************\
*
*  UpdateCount
*
\***************************************************************************/

BOOL UpdateCount( HWND hwnd, INT iOffset, INT i) {
LONG ll;

    if(iOffset!=ALL) {
	ll=GetWindowLong(hwnd,iOffset);

	switch(i) {

	    case INC:  SetCount(hwnd,iOffset,1,INC);
		break;

	    case DEC:  SetCount(hwnd,iOffset,1,DEC);
		break;

	    case STP:  SetFlag(hwnd,FLAG_STOP,ON);
		break;

	    case PNT:  // Paint only!
		break;

	    default:
		DDEMLERROR("DdeStrs.Exe - UpdateCount - Unexpected value");
		break;

	    } // switch

	} // if

    UpdClient(hwnd,iOffset);

    return TRUE;

}

/*****************************************************************************\
| DOUT
|
| created: 29-Jul-91
| history: 03-Aug-91 <johnsp> created.
|
\*****************************************************************************/

BOOL DOut( HWND hwnd, LPSTR lpsz, LPSTR lpszi, INT i ) {
char  sz[MAX_TITLE_LENGTH];
LPSTR lpszOut=&sz[0];
LONG  lflags;

#ifdef WIN32
LPCRITICAL_SECTION lpcs;
HANDLE hmem;
DWORD dwer=0L;
BOOL   fCriticalSect=TRUE;
BOOL   f=FALSE;

    if(!hwnd) hwnd=hwndMain;
    lflags=GetWindowLong(hwnd,OFFSET_FLAGS);

    // FLAG_SYNCPAINT implies FLAG_MULTTHREAD with the addition that
    // we have allocated needed resources to start using the
    // critical section code.

    if(lflags&FLAG_SYNCPAINT) {
	f=TRUE;
	hmem=(HANDLE)GetWindowLong(hwnd,OFFSET_CRITICALSECT);
	if(hmem) {
	     lpcs=GlobalLock(hmem);
	     EnterCriticalSection(lpcs);
	     }
	else {
	     fCriticalSect=FALSE;
	     }
	}

#endif

    if (lflags&FLAG_DEBUG) {

	if (lpszi) wsprintf(lpszOut,lpsz,lpszi);
	else	   wsprintf(lpszOut,lpsz,i);

	OutputDebugString(lpszOut);

#ifdef WIN32

	dwer=GetLastError();
	wsprintf(lpszOut,"DdeStrs.Exe -- ERR:Val from GetLastError()=%u\n\r",dwer);
	OutputDebugString(lpszOut);

#endif
	} // if FLAG_DEBUG

#ifdef WIN32

    // FLAG_SYNCPAINT implies FLAG_MULTTHREAD with the addition that
    // we have allocated needed resources to start using the
    // critical section code.

    if(f) {
	if(fCriticalSect) {
	    LeaveCriticalSection(lpcs);
	    GlobalUnlock(hmem);
	    }
	}

#endif

    return TRUE;

}

/*****************************************************************************\
| EOUT
|
| created: 19-Aug-92
| history: 19-Aug-92 <johnsp> created.
|
\*****************************************************************************/

BOOL EOut( LPSTR lpsz ) {

    DOut((HWND)NULL,lpsz,(LPSTR)NULL,0);

    return TRUE;
}

/*************************** Private Function ******************************\

GetMemHandle

\***************************************************************************/

HANDLE GetMemHandle( INT ic ) {
HANDLE hmem;

    hmem=GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,ic);

    if(hmem) {
	 SetCount(hwndMain,OFFSET_MEM_ALLOCATED,GlobalSize(hmem),INC);
	 }
    else {
	 DOut(hwndMain,"DdeStrs.Exe -- ERR:GlobalAlloc ret=%u\n\r",0,0);
	 }

    return hmem;

}

/*************************** Private Function ******************************\

GetMem

\***************************************************************************/

LPSTR GetMem( INT ic, LPHANDLE lphmem) {
LPSTR lpsz;

    *lphmem=GetMemHandle(ic);
    lpsz=GlobalLock(*lphmem);

    if(!lpsz) {
	 DOut(hwndMain,"DdeStrs.Exe -- ERR:GlobalLock ret=%u (not locked)\n\r",0,0);
	 FreeMemHandle(*lphmem);
	 return NULL;
	 }

    return lpsz;

}

/*************************** Private Function ******************************\

FreeMem

\***************************************************************************/

BOOL FreeMem( HANDLE hmem ) {

    if(GlobalUnlock(hmem)) {
	DOut(hwndMain,"DdeStrs.Exe -- ERR:GlobalUnlock ret=%u (still locked)\n\r",0,(INT)TRUE);
	}

    FreeMemHandle(hmem);

    return TRUE;

}

/*************************** Private Function ******************************\

FreeMemHandle

\***************************************************************************/

BOOL FreeMemHandle( HANDLE hmem ) {
LONG ll;

    ll=GlobalSize(hmem);

    if(!GlobalFree(hmem)) {
	 SetCount(hwndMain,OFFSET_MEM_ALLOCATED,ll,DEC);
	 }
    else {
	 DOut(hwndMain,"DdeStrs.Exe -- ERR:GlobalFree returned %u (not free'd)\n\r",0,(INT)hmem);
	 return FALSE;
	 }

    return TRUE;

}

/**************************** Private *******************************\
*  CreateThreadExtraMem - This routine creates extra thread memory
*			  to be used in conjuction with the functions
*			  Get/SetThreadLong.
*
\********************************************************************/

BOOL CreateThreadExtraMem( INT nExtra, INT nThrds ) {

    hExtraMem=GetMemHandle(nExtra*nThrds);
    SetWindowLong(hwndMain,OFFSET_EXTRAMEM,nExtra);

    if(hExtraMem==NULL) return FALSE;
    else		return TRUE;

}

/**************************** Private *******************************\
*  FreeThreadExtraMem - This routine frees extra thread memory
*			to be used in conjuction with the functions
*			Get/SetThreadLong.
*
*  Note: FreeMemHandle can not be used here because it relies on
*	 the main window still being around.  At this point our
*	 main window has already been destroied.
*
\********************************************************************/

BOOL FreeThreadExtraMem( void ) {

    GlobalFree(hExtraMem);

    return TRUE;

}

/**************************** Private *******************************\
*  GetThreadLong - This routine queries the value specified by the
*		   nOffset parameter from the threads memory areas
*		   specified by the dwid value.
*
*  Memory layout - thread 1: OFFSET1, OFFSET2, ..., OFFSETN
*		   thread 2: OFFSET1, OFFSET2, ..., OFFSETN
*		   .
*		   .
*		   thread n: OFFSET1, OFFSET2, ..., OFFSETN
*
\********************************************************************/

LONG GetThreadLong( DWORD dwid, INT nOffset ) {
INT nThrd;
LONG l,lExMem;
LPBYTE lp;
LONG FAR *lpl;

    lp=GlobalLock(hExtraMem);

    // Find out which thread is making the call.

    nThrd=IDtoTHREADNUM(dwid);

    // This is the amount of extra memory for one thread.

    lExMem=GetWindowLong(hwndMain,OFFSET_EXTRAMEM);

    // Value at thread and offset.  See above for storage layout.

    lpl=(LONG FAR *)(lp+((nThrd-1)*lExMem)+nOffset);

    l=*lpl;

    GlobalUnlock(hExtraMem);

    return l;

}

/**************************** Private *******************************\
*  SetThreadLong - This routine sets the value specified by the
*		   nOffset parameter from the threads memory areas
*		   specified by the dwid value.
*
*  Memory layout - thread 1: OFFSET1, OFFSET2, ..., OFFSETN
*		   thread 2: OFFSET1, OFFSET2, ..., OFFSETN
*		   .
*		   .
*		   thread n: OFFSET1, OFFSET2, ..., OFFSETN
*
\********************************************************************/

LONG SetThreadLong( DWORD dwid, INT nOffset, LONG l ) {
INT nThrd;
LONG lPrevValue,lExMem;
LPBYTE lp;
LPLONG lpl;

    lp=GlobalLock(hExtraMem);

    // Find out which thread is making the call.

    nThrd=IDtoTHREADNUM(dwid);

    // This is the amount of extra memory for one thread.

    lExMem=GetWindowLong(hwndMain,OFFSET_EXTRAMEM);

    // Value at thread and offset.  See above for storage layout.

    lPrevValue=(LONG)(*(lp+((nThrd-1)*lExMem)+nOffset));
    lpl=(LPLONG)(lp+((nThrd-1)*lExMem)+nOffset);

    *lpl=l;

    GlobalUnlock(hExtraMem);

    return lPrevValue;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\ddestrs\cmdln.c ===
#include <windows.h>
#include <port1632.h>
#include <ddeml.h>
#include "wrapper.h"
#include "ddestrs.h"

#ifdef WIN16
#include <time.h>
#endif

extern BOOL fServer;
extern BOOL fClient;
extern INT iAvailFormats[];
extern BOOL UpdateCount(HWND,INT,INT);
extern LPSTR pszNetName;
extern HANDLE hmemNet;
BOOL IsTopicNameFromNetDde(LPSTR,LPSTR);
BOOL FixForNetDdeStartup(HWND,LPSTR);
BOOL FixForStressPercentage(HWND,LPSTR);
BOOL SetStress(HWND,LONG);


/***************************************************************************\
*
*  InitArgsError
*
\***************************************************************************/

VOID InitArgsError(HWND hwnd, unsigned at)
{
    /* This function informs the user of an error. */

    static char *mpatszError[] = {
	"DdeStrs.Exe -- Invalid command line\r\nTry DdeStrs -5% for standard run or DdeStrs -? for help",
	"DdeStrs.Exe -- Invalid number, possibly missing option value",
	"DdeStrs.Exe -- Invalid log level",
	"DdeStrs.Exe -- Invalid number of test to execute",
	"DdeStrs.Exe -- Invalid starting test number"
    };

    MessageBox(NULL,mpatszError[at],"Error:DdeStrs",MB_OK|MB_ICONEXCLAMATION);
}

/***************************************************************************\
*
*  SysTime  -  This routine is intended to hide the differences between
*	       the 16 bit time routines and win 32.  All time queries
*	       come through this point.
*
\***************************************************************************/

VOID SysTime( LPSYSTEMTIME lpst ) {

#ifdef WIN32
    GetSystemTime( lpst );
#else

time_t t;
struct tm ttmm;
struct tm far *ptm=&ttmm;

    t=time(&t);
    ptm=localtime(&t);

    lpst->wYear 	=ptm->tm_year;
    lpst->wMonth	=ptm->tm_mon;
    lpst->wDayOfWeek	=ptm->tm_wday;
    lpst->wDay		=ptm->tm_yday;
    lpst->wHour 	=ptm->tm_hour;
    lpst->wMinute	=ptm->tm_min;
    lpst->wSecond	=ptm->tm_sec;
    lpst->wMilliseconds =0;

#endif

}

/**************************  Private Function  ****************************\
*
* ParseCommandLine - This routine controls parsing the command line and
*		     initializing command line settings.
*
\**************************************************************************/

BOOL ParseCommandLine( HWND hwnd, LPSTR lpcmd ) {
SYSTEMTIME   t;
LPSYSTEMTIME lptime=&t;
LONG	     lflags=0L;
INT          i,nThrd,num,nFmts;
BOOL	     fSelect=FALSE;

#ifdef WIN32
LPCRITICAL_SECTION lpcs;
HANDLE	     hmem;
#endif

    // Defaults

    SetWindowLong(hwnd,OFFSET_FLAGS,FLAG_AUTO);
    SetWindowLong(hwnd,OFFSET_RUNTIME,_1WEEKEND);
    SetWindowLong(hwnd,OFFSET_STRESS,5L);
    SetWindowLong(hwnd,OFFSET_DELAY,(100-GetWindowLong(hwnd,OFFSET_STRESS))*DELAY_METRIC);
    SetWindowLong(hwnd,OFFSET_TIME_ELAPSED,0L);
    SetWindowLong(hwnd,OFFSET_THRDCOUNT,1L);
    SetWindowLong(hwnd,OFFSET_CRITICALSECT,0L);

    if(!get_cmd_arg(hwnd,lpcmd))
	return FALSE;

    // We need to make a change at this point for the
    // default client/server settings.	If at this point
    // fClient==fServer==FALSE then we want to turn on
    // both of these as the default.

    if(!fClient && !fServer) {
	fClient=TRUE;
	fServer=TRUE;
	}

    // We need to check to see if specific formats where
    // specified.  If not then select all of them.

    nFmts=0;
    for(i=0;i<NUM_FORMATS;i++)
        if(iAvailFormats[i]) {
            nFmts=nFmts++;
            fSelect=TRUE;
            }

    if(!fSelect) {
        for(i=0;i<NUM_FORMATS;i++) iAvailFormats[i]=1;
        nFmts=NUM_FORMATS;
        }

    // We have now read all of the command line.  Make needed adjustment
    // to the delay as needed by addtional threads.

    // This adjustment code works with the routine SetStress.  It
    // does not simply recalculate values.  A change to SetStress will
    // cause changes in the final value.

    lflags=GetWindowLong(hwnd,OFFSET_FLAGS);
    if(!(lflags&FLAG_USRDELAY)) {

	num=(INT)GetWindowLong(hwnd,OFFSET_DELAY);
	nThrd=(INT)GetWindowLong(hwnd,OFFSET_THRDCOUNT);

	// 200 is the base value for basic overhead.

	num=(200)+(num*(nThrd*nThrd)*nFmts);

	SetWindowLong(hwnd,OFFSET_DELAY,num);
	}

    SetWindowLong(hwnd,OFFSET_BASE_DELAY,GetWindowLong(hwnd,OFFSET_DELAY));

    // We need to know the starting time to calculate
    // time to quit test.

    SysTime(lptime);

    SetWindowLong(hwnd,OFFSET_STARTTIME_SEC,lptime->wSecond);
    SetWindowLong(hwnd,OFFSET_STARTTIME_MIN,lptime->wMinute);
    SetWindowLong(hwnd,OFFSET_STARTTIME_HOUR,lptime->wHour);
    SetWindowLong(hwnd,OFFSET_STARTTIME_DAY,lptime->wDay);

    SetWindowLong(hwnd,OFFSET_LAST_MIN,lptime->wMinute);
    SetWindowLong(hwnd,OFFSET_LAST_HOUR,lptime->wHour);
    SetWindowLong(hwnd,OFFSET_TIME_ELAPSED,0L);

#ifdef WIN32
    /* Setup our critical section if in multi-thread mode */

    lflags=GetWindowLong(hwnd,OFFSET_FLAGS);
    if(lflags&FLAG_MULTTHREAD) {
	hmem=GetMemHandle(sizeof(CRITICAL_SECTION));
	lpcs=GlobalLock(hmem);

	InitializeCriticalSection(lpcs);

	GlobalUnlock(hmem);
	SetWindowLong(hwnd,OFFSET_CRITICALSECT,(LONG)hmem);
	}
#endif

    return TRUE;

}

/***************************************************************************\
*
*  SetupArgv - This is a conversion routine to go from the window worlds
*	       command line format to the more standard argv, argc
*	       format.	The routine get_cmd_arg was setup for the
*	       argv/argc format.
*
\***************************************************************************/

int SetupArgv( char *argv[], char *buff, LPSTR cmdline )
{
int i=1;

    while( *cmdline != '\0' ) {
	argv[i] = &buff[0];
	while ( *cmdline != ' ' && *cmdline != '\0')
	   *buff++ = *cmdline++;
	*buff++='\0';
	while(*cmdline == ' ') cmdline++;
	i++;
	}

    return i;

}

/***************************************************************************\
*
*  get_cmd_arg	- This routine parses a argv\argc formatted command
*		  line and stores away the values.
*
\***************************************************************************/

BOOL PASCAL get_cmd_arg( HWND hwnd, LPSTR cmdline ) {

/* This function parses the command line for valid options. TRUE is
   returned if all of the options are valid; otherwise, FALSE is returned. */

char	*pch;
int	 iarg;
unsigned at = AT_SWITCH;
unsigned num;
int	 argc;
char	*argv[10];
char	 buff[200];
LONG	 lflags=0L;

#ifdef WIN32
int	 nThrd;
#endif

    FixForStressPercentage(hwnd,cmdline);
    FixForNetDdeStartup(hwnd,cmdline);

    argc = SetupArgv( argv, buff, cmdline );

    /* Iterate over the arguments in the command line. */
    iarg=1;
    while(iarg<argc && argv[iarg]!='\0') {

        /* Get the next argument. */
	pch = argv[iarg];

	/* Process the argument depending upon the arguement
	 * type we are looking for.
	 */

	switch (at) {

	case AT_SWITCH:

	    /* All options begin with a switch character. */

	    if (*pch != '-' && *pch != '/') {
		InitArgsError(hwnd,0);
		return FALSE;
		}

            /* Skip over the switch character. */
            pch++;

            /* Look for an option character. */
            do {
		switch (*pch) {
		case 'a':
		    /* Run the test in the background */
		    lflags=GetWindowLong(hwnd,OFFSET_FLAGS);
		    SetWindowLong(hwnd,OFFSET_FLAGS,FLAGON(lflags,FLAG_APPOWNED));
		    break;

		case 'p':
		    /* Run the test in the background */
		    lflags=GetWindowLong(hwnd,OFFSET_FLAGS);
		    SetWindowLong(hwnd,OFFSET_FLAGS,FLAGON(lflags,FLAG_PAUSE_BUTTON|FLAG_PAUSE));
		    break;

		case '?':
		    /* Give brief help.  For more detailed information see ddestrs.txt in source directory */
		    MessageBox(NULL,"DdeStrs Options...\r\n-#% stress\r\n-e# delay\r\n-t# run time\r\n-d debug\r\n-a appowned\r\n-s server\r\n-c client\r\n-f# format\r\n-nNAME netdde\r\n-i# threads\r\n-p pause\r\n\nSee DdeStrs.Txt","DdeStrs Help",MB_OK);
		    return FALSE;
                    break;


		case 'b':
		    /* Run the test in the background */
		    lflags=GetWindowLong(hwnd,OFFSET_FLAGS);
		    SetWindowLong(hwnd,OFFSET_FLAGS,FLAGON(lflags,FLAG_BACKGROUND));
                    break;

		case 'l':
                    /* Set the name of the log file. */
                    if (*(++pch) == '\0') {
                        /* The next argument should be a filename. */
                        at = AT_FILE;
                        goto NextArg;
			}

		case 'c':
		    /* This is a client */
		    fClient = TRUE;
		    break;

		case 's':
		    /* This is a server */
		    fServer = TRUE;
		    break;

		case 'i':

		    /* The next argument should be the number of threads (w32 only)  The
		       range for this = [1...5] */
#ifdef WIN32
		    lflags=GetWindowLong(hwnd,OFFSET_FLAGS);
		    SetWindowLong(hwnd,OFFSET_FLAGS,FLAGON(lflags,FLAG_MULTTHREAD));
#endif
		    at = AT_THRD;
		    goto ParseNumber;

		case 'x':
		    /* The next argument should be the stress level. */
		    at = AT_STRESS;
		    goto ParseNumber;

		case 'e':
		    /* The next argument is the delay in milliseconds */
		    lflags=GetWindowLong(hwnd,OFFSET_FLAGS);
		    SetWindowLong(hwnd,OFFSET_FLAGS,FLAGON(lflags,FLAG_USRDELAY));
		    at = AT_DELAY;
		    goto ParseNumber;

		case 'd':
		    /* The next argument is whether we are in debug mode */
		    lflags=GetWindowLong(hwnd,OFFSET_FLAGS);
		    SetWindowLong(hwnd,OFFSET_FLAGS,FLAGON(lflags,FLAG_DEBUG));
		    break;

		case 'n':
		    /*	Process the network name */
		    pch++;

		    while( *pch==' ' ||
			   *pch=='\\') pch++;

		    pszNetName=GetMem(MAX_TITLE_LENGTH,&hmemNet);
		    pszNetName=TStrCpy(pszNetName,pch);

		    lflags=GetWindowLong(hwnd,OFFSET_FLAGS);
		    SetWindowLong(hwnd,OFFSET_FLAGS,FLAGON(lflags,FLAG_NET));

		    while(*pch!='\0') {
			pch++;
			}

		    pch--;

		    break;

		case 'f':
		    at = AT_FORMAT;
		    goto ParseNumber;

		case 't':
		    lflags=GetWindowLong(hwnd,OFFSET_FLAGS);
		    SetWindowLong(hwnd,OFFSET_FLAGS,FLAGON(lflags,FLAG_TIME));

		    /* The next argument is the time (in minutes)
		       to run the test. */

		    at = AT_TIME;
		    goto ParseNumber;

                default:
		    InitArgsError(hwnd,0);
		    return FALSE;

		}  // switch

	    } while (*(++pch) != '\0'); // do-while loop

	    break;

	case AT_FILE:

            /* The next argument should be a switch. */
	    at = AT_SWITCH;

            break;

ParseNumber:
            /* Does this arg have the number? */
	    if (*(++pch) == '\0') goto NextArg;

	case AT_STRESS:
	case AT_DELAY:
	case AT_TIME:
	case AT_WND:
	case AT_MSG:
	case AT_THRD:

	    /* Set the number of tests to run. */

	    if ((num = latoi(pch))==0) {
		/* Indicate that an invalid number has been specified. */
		if(at!=AT_DELAY) {
		    InitArgsError(hwnd,0);
		    return FALSE;
		    }
		}

	    switch (at) {
	    case AT_FORMAT:
		if (num>0 && num<=NUM_FORMATS) {
		    iAvailFormats[num-1]=1;
		    }
		break;

	    case AT_STRESS:
		SetStress(hwnd,num);
                break;

	    case AT_DELAY:
		SetWindowLong(hwnd,OFFSET_DELAY,num);
		lflags=GetWindowLong(hwnd,OFFSET_FLAGS);
		SetWindowLong(hwnd,OFFSET_FLAGS,FLAGON(lflags,FLAG_USRDELAY));
		break;

	    case AT_TIME:
		SetWindowLong(hwnd,OFFSET_RUNTIME,num);
		break;

	    case AT_THRD:
#ifdef WIN32
		if(num>THREADLIMIT) num=THREADLIMIT;

		// One is not really Mult-thread, shutoff the thread
		// code and run in normal form.

		if(num==1)
		     {
		     lflags=GetWindowLong(hwnd,OFFSET_FLAGS);

		     lflags=FLAGOFF(lflags,FLAG_MULTTHREAD);
		     lflags=FLAGON(lflags,FLAG_USRTHRDCOUNT);

		     SetWindowLong(hwnd,OFFSET_FLAGS,lflags);

		     SetWindowLong(hwnd,OFFSET_THRDCOUNT,num);
		     }
		else {
		     SetWindowLong(hwnd,OFFSET_THRDCOUNT,num);
		     lflags=GetWindowLong(hwnd,OFFSET_FLAGS);
		     SetWindowLong(hwnd,OFFSET_FLAGS,FLAGON(lflags,FLAG_USRTHRDCOUNT));
		     }
#endif
		break;

	    default:
		InitArgsError(hwnd,0);
		return FALSE;
		break;

	    } //switch (inside)

	    /* The next argument should be a switch. */
            at = AT_SWITCH;
	    break;

	} // switch (outside)

NextArg:;
    iarg++;
    } // While loop


    /* Are we still looking for a filename or number? */
    if (at != AT_SWITCH) {
        /* Tell the user about the filename or number not found. */
	InitArgsError(hwnd,0);
        return FALSE;
	}

    return TRUE;

} // end get_cmd_args

/***************************************************************************\
*
*  SetStress
*
\***************************************************************************/

BOOL SetStress(HWND hwnd, LONG num) {
LONG lflags;

#ifdef WIN32
LONG l;
#endif

INT n;

     lflags=GetWindowLong(hwnd,OFFSET_FLAGS);
     SetWindowLong(hwnd,OFFSET_STRESS,num);

#ifdef WIN32

     if(!(lflags&FLAG_USRTHRDCOUNT)) {

         l=S2L(DIV(num,20)+1);
         if(num>9 && num<20) l++;

         if(l>5) l=5;
         if(l<1) l=1;

         SetWindowLong(hwnd,OFFSET_THRDCOUNT,l);

	 if(l>1) {
	    lflags=GetWindowLong(hwnd,OFFSET_FLAGS);
	    SetWindowLong(hwnd,OFFSET_FLAGS,FLAGON(lflags,FLAG_MULTTHREAD));
	    }
	 }
#endif

     if(!(lflags&FLAG_USRDELAY)) {
	 n=(int)(100-num)*DELAY_METRIC;
	 SetWindowLong(hwnd,OFFSET_DELAY,n);

	 // since dde messages have highest priority we don't
	 // want to swamp the system.  Always have some
	 // minimal delay.

	 if(n<10) {
	     SetWindowLong(hwnd,OFFSET_DELAY,10);
	     lflags=GetWindowLong(hwnd,OFFSET_FLAGS);
	     SetWindowLong(hwnd,OFFSET_FLAGS,FLAGOFF(lflags,FLAG_DELAYON));
	     }
	 }

     return TRUE;
}

/******************************************************************\
*  TStrLen
*  11/20/88
*
*  Finds the length of a string
\******************************************************************/

INT TStrLen( LPSTR pStr )
{
INT len = 0;

    while( *pStr++!='\0' ) len++;

    return( len );
}

/******************************************************************\
*  TStrCat
*  7/16/92
*
*  Appends source string to destination string.  Source string and
*  destination string must be zero terminated!
\******************************************************************/

LPSTR TStrCat( LPSTR dest, LPSTR source)
{
LPSTR start_source;
LPSTR start_dest;
INT i=0;

     /* If we have a NULL pointer set destination to NULL and
	continue */

     if (!dest || !source) {
	MessageBox(NULL,"TStrCat - NULL ptr for dest or source string!","Error : WmStress",MB_ICONEXCLAMATION);
	return NULL;
	}

     start_dest   = dest;
     start_source = source;

     while (*dest++!='\0' && i++<=MAX_TITLE_LENGTH)
	;

     TStrCpy(dest,source);

     source = start_source;
     dest   = start_dest;

     return( start_dest );
}

/*************************** Private Function ******************************\
*
*  TStrCmp
*
*  Compares two NULL terminated strings ( returns TRUE if equal )
*
\***************************************************************************/

BOOL TStrCmp(LPSTR s, LPSTR t)
{
				  // Valid pointer?

    if ( !s && !t ) return TRUE;  // If either is NULL then they should
    if ( (!s&&t)||(s&&!t) )	  // both be NULL.  Otherwise error.
	return FALSE;

    for (; *s == *t; s++, t++)	  // Compare strings
	if (*s=='\0')
	    return TRUE;

    if ((*s-*t)== 0) return TRUE;
	else	     return FALSE;
}

/******************************************************************\
*  TStrCpy
*  11/20/88
*
*  Copies a string from source to destination
\******************************************************************/

LPSTR TStrCpy( LPSTR dest, LPSTR source)
{
LPSTR start_source;
LPSTR start_dest;
INT i;

     /* If we have a NULL pointer set destination to NULL and
	continue */

     if(!source) {
	 dest=NULL;
	 return NULL;
	 }

     if (!dest) {
	MessageBox(NULL,"TStrCpy - NULL ptr for dest!","Error:WmStress",MB_ICONEXCLAMATION);
	return NULL;
	}

     start_dest   = dest;
     start_source = source;

     i=0;
     while (*dest++ = *source++){
	i++;
	}

     source = start_source;
     dest   = start_dest;

     return( start_dest );
}

/***************************************************************************\
*
*  FixForStressPercentage - This is a fix for the command line -5%.  The
*			    origional get_cmd_args() did not handle this
*			    case.  This routine handles string modifications
*			    to the command line parse will be correct.
*
\***************************************************************************/

BOOL FixForStressPercentage(HWND hwnd, LPSTR lpszStart )
{
CHAR  ac[6];
INT   i;
LPSTR lpsz,lpszdash;
BOOL  bLastTime;

    lpsz     =lpszStart;
    lpszdash =NULL;

    ac[0]='x';

    while(*lpsz!='\0') {

	if( *lpsz=='-') lpszdash=lpsz;

	if( *lpsz=='%') {

	     if(lpszdash==NULL) return FALSE;
	     else		lpsz=(LPSTR)(lpszdash+1);

	     // Basically what we do hear is replace the '%' by an 'x'
	     // and shift characters...(-60% becomes -x60).

	     i=0;
	     bLastTime=FALSE;

	     while(!bLastTime) {
		 ac[i+1]=*lpsz;
		 if(*lpsz=='%') bLastTime=TRUE;
		 *lpsz=ac[i];
		 lpsz++;
		 i++;
		 }

	     }	// if

	lpsz++;

	} // while

   return TRUE;
   hwnd;

}  // FixForStressPercentage

/***************************************************************************\
*
*  FixForNetDdeStartup - This is a fix for the command line "Test".  The
*			 origional get_cmd_args() did not handle this
*			 case.	This routine modifies the string from
*			 "Test" to "-s".
*
*			 The reason for this change is to make ddestrs.exe
*			 netdde aware for the startup situation.  When
*			 netdde starts up the application is passed the topic
*			 name (in this case Test) to the application on the
*			 command line.
*
*  NOTE!!!  The below code relies on TOPIC="Test".  If this has changed then
*	    update FixForNetDdeStartup() and IsTopicNameFromNetDde().
*
\***************************************************************************/

BOOL FixForNetDdeStartup( HWND hwnd, LPSTR lpszStart )
{
INT   i;
LPSTR lpsz;

    lpsz     =lpszStart;

    i=1;
    while(*lpsz!='\0') {

	// Important.  I am relying on lpsz being the same
	// exiting IsTopicNameFromNetDde as it was going in!!!

	if(IsTopicNameFromNetDde(lpsz,TOPIC)) {

	    // We have one last check before we make the change.  lpsz-2
	    // must not be '-' or '/' and lpsz must not be 'n' or 'N'.

	    // Are we at the 3rd char or later?  We can't make this
	    // final check unless we have previous character to see.

	    if(i>=3) {
		 if( *(lpsz-1)!='n' &&
		     *(lpsz-1)!='N' &&
		     *(lpsz-2)!='-' &&
		     *(lpsz-2)!='/' )
		     {
		     *lpsz='-';
		     *(lpsz+1)='s';  // change "Test" to "-s  "
		     *(lpsz+2)=' ';
		     *(lpsz+3)=' ';
		     } // if check for -,n,N,/

		 } // if i>=3
	    else {
		 *lpsz='-';
		 *(lpsz+1)='s';  // change "Test" to "-s  "
		 *(lpsz+2)=' ';
		 *(lpsz+3)=' ';
		 }

	    }  // IsTopicName...

	lpsz++;
	i++;	  // We use this to keep charater position.

	} // while

   return TRUE;
   hwnd;

}  // FixForNetDdeStartup

/***************************************************************************\
*
*  IsTopicNameFromNetDde
*
\***************************************************************************/

BOOL IsTopicNameFromNetDde(LPSTR lpsz, LPSTR lpszTopic )
{
LPSTR lpstr;

    // Check to see that string is >=4 characters not including NULL
    // terminator.

    lpstr=lpsz;

    if(TStrLen(lpstr)<TStrLen(lpszTopic)) return FALSE;


    // Is our topic string present.

    if(*lpsz!='T' && *lpsz!='t') {
	return FALSE;
	}

    if(*(lpsz+1)!='e' && *(lpsz+1)!='E') {
	return FALSE;
	}

    if(*(lpsz+2)!='s' && *(lpsz+2)!='S') {
	return FALSE;
	}

    if(*(lpsz+3)!='t' && *(lpsz+3)!='T') {
	return FALSE;
	}

    if(*(lpsz+4)!=' ' && *(lpsz+4)!='\0') {
	return FALSE;
	}

   return TRUE;

}  // IsTopicNameFromNetDde

/**************************  Private Function  ****************************\
*
* IsTimeExpired - This routine is called periodically to check if its
*		  time to quit.
*
\**************************************************************************/

BOOL IsTimeExpired( HWND hwnd ) {
LONG	     lrtime, lrtPMin, lrtPHour, lrt, l, ll;
SYSTEMTIME   t;
LPSYSTEMTIME lptime=&t;
LONG	     lflags=0L;

    lflags=GetWindowLong(hwnd,OFFSET_FLAGS);

    if(!(lflags&FLAG_STOP)) {
	// This is how long we should run.  In minutes

	lrtime =GetWindowLong(hwnd,OFFSET_RUNTIME);

	// This is how long we have run.  In minutes.

	lrt    =GetWindowLong(hwnd,OFFSET_TIME_ELAPSED);
	l=lrt;

	// Time at last check.

	lrtPMin =GetWindowLong(hwnd,OFFSET_LAST_MIN);
	lrtPHour=GetWindowLong(hwnd,OFFSET_LAST_HOUR);

	SysTime(lptime);

	if(lrtPHour!=(LONG)(lptime->wHour)) {

	     // Calc update minutes for the wrap case.

	     lrt=(((_1HOUR-lrtPMin)+lptime->wMinute)+lrt);

	     // We need to check for multiple hours since last
	     // update.

	     if(lrtPHour>lptime->wHour) {

		  // In case clock does not rap at 12:00.

		  if(lptime->wHour>12) ll=lptime->wHour-12;
		  else		       ll=lptime->wHour;

		  l=(12-lrtPHour)+ll;
		  }
	     else			l=lptime->wHour-lrtPHour;

	     if(l>1) {
		lrt=lrt+((l-1)*_1HOUR);
		}

	     }

	else lrt=((lptime->wMinute-lrtPMin)+lrt);

	SetWindowLong(hwnd,OFFSET_LAST_MIN,(LONG)lptime->wMinute);
	SetWindowLong(hwnd,OFFSET_LAST_HOUR,(LONG)lptime->wHour);
	SetWindowLong(hwnd,OFFSET_TIME_ELAPSED,lrt);

	if(lptime->wMinute!=LOWORD(lrtPMin))
	    UpdateCount(hwnd,OFFSET_TIME_ELAPSED,PNT);

	// if elapsed time > runtime time has expired.

	if(lrt>=lrtime)
	     return TRUE;
	else return FALSE;
	}

    // If we are already shutting down no need to trigger other WM_CLOSE
    // messages.

    else return FALSE;

}

/*---------------------------------------------------------------------------*\
| ASCII TO INTEGER
|   This routine converts an ascii string to a decimal integer.
|
| created: 12-Oct-90
| history: 12-Oct-90 <chriswil> created.
|
\*---------------------------------------------------------------------------*/
int APIENTRY latoi(LPSTR lpString)
{
    int nInt,nSign;


    if(*lpString == '-')
    {
         nSign = -1;
         lpString++;
    }
    else
    {
         if(*lpString == '+')
              lpString++;
         nSign = 1;
    }

    nInt = 0;
    while(*lpString)
        nInt = (nInt*10) + (*lpString++ - 48);

   return(nInt * nSign);
}

/*****************************************************************************\
| INTEGER TO ASCI
|   This routine converts an decimal integer to an ascii string.
|
| created: 29-Jul-91
| history: 29-Jul-91 <johnsp> created.
|
\*****************************************************************************/
LPSTR FAR PASCAL itola(INT i, LPSTR lpsz)
{
LPSTR lpsz_start;
INT   irange=1;
INT   id=0;

    lpsz_start=lpsz;		   // Keep track of the beginning of the
				   // string.
    while (id=DIV(i,irange)>0)
	irange=irange*10;

    irange=DIV(irange,10);

    if(i==0) {			   // If i==0 set string and we
	*lpsz='0';		   // will skip loop
	lpsz++;
	}

    while (irange>0) {

	id=DIV(i,irange);	   // Calculate character
	*lpsz=(CHAR)(id+48);

	lpsz++;
	i=i-(irange*id);	   // Adjust values for next time
	irange=DIV(irange,10);	   // through the loop.

	}

    *lpsz='\0'; 		   // Null terminate the string

    return lpsz_start;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\ddestrs\wrapper.c ===
/***************************************************************************\

   PROGRAM     : wrapper.c

   PURPOSE     : This is not a full program but a module you can include
                 in your code.  It implements a standard DDEML callback
                 function that allows you to have most of your DDE table
                 driven.  The default callback function handles all basic
                 System Topic information based on the tables you give
                 to this app.

   LIMITATIONS : This only supports servers that:
                 have only one service name
                 have enumerable topics and items
                 do not change the topics or items they support over time.


   EXPORTED ROUTINES:

    InitializeDDE()
        Use this to initialize the callback function tables and the DDEML

    UninitializeDDE()
        Use this to cleanup this module and uninitialize the DDEML instance.

\***************************************************************************/

#include <windows.h>
#include <ddeml.h>
#include <string.h>
#include "wrapper.h"
#include <port1632.h>
#include "ddestrs.h"

extern BOOL fServer;
extern LPSTR pszNetName;
extern LONG SetThreadLong(DWORD,INT,LONG);
extern LONG GetThreadLong(DWORD,INT);
extern LPSTR TStrCpy( LPSTR, LPSTR);

BOOL InExit(VOID);
VOID InitHszs(LPDDESERVICETBL psi);
UINT GetFormat(LPSTR pszFormat);
VOID FreeHszs(LPDDESERVICETBL psi);
HDDEDATA APIENTRY WrapperCallback(UINT wType, UINT wFmt, HCONV hConv, HSZ hsz1,
	HSZ hsz2, HDDEDATA hData, DWORD dwData1, DWORD dwData2);

BOOL DoCallback(HCONV,HSZ,HSZ,UINT,UINT,HDDEDATA,LPDDESERVICETBL,HDDEDATA *);

HDDEDATA ReqItems(HDDEDATA hDataOut, LPDDETOPICTBL ptpc);
HDDEDATA AddReqFormat(HDDEDATA hDataOut, LPSTR pszFmt);
HDDEDATA ReqFormats(HDDEDATA hDataOut, LPDDETOPICTBL ptpc);
HDDEDATA DoWildConnect(HSZ hszTopic);

PFNCALLBACK lpfnUserCallback = NULL;
PFNCALLBACK lpfnWrapperCallback = NULL;

LPDDESERVICETBL pasi = NULL;
char tab[] = "\t";

#define FOR_EACH_TOPIC(psvc, ptpc, i)  for (i = 0, ptpc=(psvc)->topic; i < (int)(psvc)->cTopics; i++, ptpc++)
#define FOR_EACH_ITEM(ptpc, pitm, i)   for (i = 0, pitm=(ptpc)->item;  i < (int)(ptpc)->cItems;  i++, pitm++)
#define FOR_EACH_FORMAT(pitm, pfmt, i) for (i = 0, pfmt=(pitm)->fmt;   i < (int)(pitm)->cFormats;i++, pfmt++)



/*     STANDARD PREDEFINED FORMATS     */

#ifdef WIN32
#define CSTDFMTS    14
#else
#define CSTDFMTS    12
#endif

struct {
    UINT wFmt;
    PSTR pszFmt;
} StdFmts[CSTDFMTS] = {
    {   CF_TEXT        ,  "TEXT"          } ,
    {   CF_BITMAP      ,  "BITMAP"        } ,
    {   CF_METAFILEPICT,  "METAFILEPICT"  } ,
    {   CF_SYLK        ,  "SYLK"          } ,
    {   CF_DIF         ,  "DIF"           } ,
    {   CF_TIFF        ,  "TIFF"          } ,
    {   CF_OEMTEXT     ,  "OEMTEXT"       } ,
    {   CF_DIB         ,  "DIB"           } ,
    {   CF_PALETTE     ,  "PALETTE"       } ,
    {   CF_PENDATA     ,  "PENDATA"       } ,
    {   CF_RIFF        ,  "RIFF"          } ,
    {	CF_WAVE        ,  "WAVE"	  } ,
#ifdef WIN32
    {   CF_UNICODETEXT ,  "UNICODETEXT"   } ,
    {	CF_ENHMETAFILE ,  "ENHMETAFILE"   } ,
#endif
};



HDDEDATA SysReqTopics(HDDEDATA hDataOut);
HDDEDATA SysReqSysItems(HDDEDATA hDataOut);
HDDEDATA SysReqFormats(HDDEDATA hDataOut);

       /*      STANDARD SERVICE INFO TABLES        */

DDEFORMATTBL StdSvcSystopicTopicsFormats[] = {
    "TEXT", 0, 0, NULL, SysReqTopics
};

DDEFORMATTBL StdSvcSystopicSysitemsFormats[] = {
    "TEXT", 0, 0, NULL, SysReqSysItems
};

DDEFORMATTBL StdSvcSystopicFormatsFormats[] = {
    "TEXT", 0, 0, NULL, SysReqFormats
};

#define ITPC_TOPICS     0
#define ITPC_SYSITEMS   1
#define ITPC_FORMATS    2
#define ITPC_ITEMLIST   3

#define ITPC_COUNT      4

DDEITEMTBL StdSvcSystopicItems[] = {
    { SZDDESYS_ITEM_TOPICS,   0, 1, 0, StdSvcSystopicTopicsFormats   },
    { SZDDESYS_ITEM_SYSITEMS, 0, 1, 0, StdSvcSystopicSysitemsFormats },
    { SZDDESYS_ITEM_FORMATS,  0, 1, 0, StdSvcSystopicFormatsFormats  },
    { SZDDE_ITEM_ITEMLIST,    0, 1, 0, StdSvcSystopicSysitemsFormats },
};

DDETOPICTBL StdSvc[] = {
    SZDDESYS_TOPIC, 0, ITPC_COUNT, 0, StdSvcSystopicItems
};

DDESERVICETBL SSI = {
    NULL, 0, 1, 0, StdSvc
};

/*********************************************************************/


BOOL InitializeDDE(
PFNCALLBACK lpfnCustomCallback,
LPDWORD pidInst,
LPDDESERVICETBL AppSvcInfo,
DWORD dwFilterFlags,
HANDLE hInst)
{
DWORD idI=0;

    if (lpfnCustomCallback) {
        lpfnUserCallback = (PFNCALLBACK)MakeProcInstance((FARPROC)lpfnCustomCallback, hInst);
    }
    lpfnWrapperCallback = (PFNCALLBACK)MakeProcInstance((FARPROC)WrapperCallback, hInst);

    if (DdeInitialize(&idI, lpfnWrapperCallback, dwFilterFlags, 0)) {
	 SetThreadLong(GETCURRENTTHREADID(),OFFSET_IDINST,idI);
	 if (lpfnCustomCallback) {
	     FreeProcInstance((FARPROC)lpfnUserCallback);
	     }
	 FreeProcInstance((FARPROC)lpfnWrapperCallback);
	 return(FALSE);
	 }
    else SetThreadLong(GETCURRENTTHREADID(),OFFSET_IDINST,idI);
    *pidInst = idI;
    InitHszs(AppSvcInfo);
    InitHszs(&SSI);
    pasi = AppSvcInfo;

    if (fServer) {
       DdeNameService(idI, pasi->hszService, 0, DNS_REGISTER);
       }

    return(TRUE);
}



VOID InitHszs(
LPDDESERVICETBL psi)
{
    int iTopic, iItem, iFmt;
    LPDDETOPICTBL ptpc;
    LPDDEITEMTBL pitm;
    LPDDEFORMATTBL pfmt;
    DWORD idI;
    CHAR sz[120];
    LPBYTE psz;
    LPBYTE pNet;

    pNet=pszNetName;

    idI=GetThreadLong(GETCURRENTTHREADID(),OFFSET_IDINST);

    if (psi->pszService) {

	// This area of code inplements the clients ability
	// to see net drives.  This is the -n option.

	if(pNet)
	     {

	     sz[0]='\\';
	     sz[1]='\\';
	     psz=&sz[2];

	     psz=TStrCpy(psz,pNet);

	     while(*++psz!='\0');

	     *psz++='\\';

	     psz=TStrCpy(psz,psi->pszService);
	     psz=&sz[0];

	     psi->hszService = DdeCreateStringHandle(idI, psz, 0);

	     } // pNet

	else psi->hszService = DdeCreateStringHandle(idI, psi->pszService, 0);
    }
    FOR_EACH_TOPIC(psi, ptpc, iTopic) {
	ptpc->hszTopic = DdeCreateStringHandle(idI, ptpc->pszTopic, 0);
        FOR_EACH_ITEM(ptpc, pitm, iItem) {
	    pitm->hszItem = DdeCreateStringHandle(idI, pitm->pszItem, 0);
            FOR_EACH_FORMAT(pitm, pfmt, iFmt) {
                pfmt->wFmt = GetFormat(pfmt->pszFormat);
            }
        }
    }
}


/*
 * This function allows apps to use standard CF_ formats.  The string
 * given may be in the StdFmts[] table.
 */

UINT GetFormat(
LPSTR pszFormat)
{
    int iFmt;

    for (iFmt = 0; iFmt < CSTDFMTS; iFmt++) {
        if (!lstrcmp(pszFormat, StdFmts[iFmt].pszFmt)) {
            return(StdFmts[iFmt].wFmt);
        }
    }
    return(RegisterClipboardFormat(pszFormat));
}



VOID UninitializeDDE()
{
DWORD idI;

    if (pasi == NULL) {
        return;
    }

    idI=GetThreadLong(GETCURRENTTHREADID(),OFFSET_IDINST);

    DdeNameService(idI, pasi->hszService, 0, DNS_UNREGISTER);
    FreeHszs(pasi);
    FreeHszs(&SSI);
    DdeUninitialize(idI);
    if (lpfnUserCallback) {
        FreeProcInstance((FARPROC)lpfnUserCallback);
    }
    FreeProcInstance((FARPROC)lpfnWrapperCallback);
}



VOID FreeHszs(
LPDDESERVICETBL psi)
{
    int iTopic, iItem;
    LPDDETOPICTBL ptpc;
    LPDDEITEMTBL pitm;
    DWORD idI;

    idI=GetThreadLong(GETCURRENTTHREADID(),OFFSET_IDINST);

    DdeFreeStringHandle(idI, psi->hszService);
    FOR_EACH_TOPIC(psi, ptpc, iTopic) {
	DdeFreeStringHandle(idI, ptpc->hszTopic);
        FOR_EACH_ITEM(ptpc, pitm, iItem) {
	    DdeFreeStringHandle(idI, pitm->hszItem);
        }
    }
}

BOOL InExit( VOID ) {
LONG l;

    if(!IsWindow((HWND)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HWNDDISPLAY))) {
	DDEMLERROR("DdeStrs.Exe -- INF:Invalid hwndDisplay, returning NAck!\r\n");
	return TRUE;
	}

    if(!IsWindow(hwndMain)) {
	DDEMLERROR("DdeStrs.Exe -- INF:Invalid hwndMain, returning NAck!\r\n");
	return TRUE;
	}

    // No need for error message on this one.  This is expected to happen
    // when queues fill up under extreme conditions.

    l=GetWindowLong(hwndMain,OFFSET_FLAGS);
    if(l&FLAG_STOP) {
	return TRUE;
	}

    return FALSE;

}

HDDEDATA APIENTRY WrapperCallback(
UINT wType,
UINT wFmt,
HCONV hConv,
HSZ hsz1,
HSZ hsz2,
HDDEDATA hData,
DWORD dwData1,
DWORD dwData2)
{
    HDDEDATA hDataRet;

    switch (wType) {
    case XTYP_WILDCONNECT:
        if (!hsz2 || !DdeCmpStringHandles(hsz2, pasi->hszService)) {
            return(DoWildConnect(hsz1));
        }
	break;

    case XTYP_CONNECT:

	if(!fServer) {
	    DDEMLERROR("DdeStrs.Exe -- Recieved XTYP_CONNECT when client!\r\n");
	    }

    case XTYP_ADVSTART:
    case XTYP_EXECUTE:
    case XTYP_REQUEST:
    case XTYP_ADVREQ:
    case XTYP_ADVDATA:
    case XTYP_POKE:

	if(InExit()) return(0);

	if(DoCallback(hConv, hsz1, hsz2, wFmt, wType, hData,
                &SSI, &hDataRet))
            return(hDataRet);

	if (DoCallback(hConv, hsz1, hsz2, wFmt, wType, hData,
                pasi, &hDataRet))
            return(hDataRet);

        /* Fall Through */
    default:
        if (lpfnUserCallback != NULL) {
            return(lpfnUserCallback(wType, wFmt, hConv, hsz1, hsz2, hData,
                dwData1, dwData2));
        }
    }
    return(0);
}




BOOL DoCallback(
HCONV hConv,
HSZ hszTopic,
HSZ hszItem,
UINT wFmt,
UINT wType,
HDDEDATA hDataIn,
LPDDESERVICETBL psi,
HDDEDATA *phDataRet)
{
    int iTopic, iItem, iFmt;
    LPDDEFORMATTBL pfmt;
    LPDDEITEMTBL pitm;
    LPDDETOPICTBL ptpc;
#ifdef WIN32
    CONVINFO ci;
#endif
    LONG l;
    BOOL fCreate=FALSE;
    HANDLE hmem;
    HDDEDATA FAR *hAppOwned;

    FOR_EACH_TOPIC(psi, ptpc, iTopic) {
        if (DdeCmpStringHandles(ptpc->hszTopic, hszTopic))
            continue;

        if (wType == XTYP_EXECUTE) {
            if (ptpc->lpfnExecute) {
                if ((*ptpc->lpfnExecute)(hDataIn))
                    *phDataRet = (HDDEDATA)DDE_FACK;
            } else {
                *phDataRet = (HDDEDATA)DDE_FNOTPROCESSED;
            }
            return(TRUE);
        }

        if (wType == XTYP_CONNECT) {
            *phDataRet = (HDDEDATA)TRUE;
            return(TRUE);
        }

        FOR_EACH_ITEM(ptpc, pitm, iItem) {
            if (DdeCmpStringHandles(pitm->hszItem, hszItem))
                continue;

            FOR_EACH_FORMAT(pitm, pfmt, iFmt) {
                if (pfmt->wFmt != wFmt)
                    continue;

                switch (wType) {
                case XTYP_ADVSTART:
                    *phDataRet = (HDDEDATA)TRUE;
                    break;

// XTYP_POKE CHANGE
#if 0
		case XTYP_POKE:
#endif

		case XTYP_ADVDATA:
                    if (pfmt->lpfnPoke) {
			if ((*pfmt->lpfnPoke)(hDataIn))
			   {
			   *phDataRet = (HDDEDATA)DDE_FACK;
			   break;
			   }
                    } else {
                        *phDataRet = (HDDEDATA)DDE_FNOTPROCESSED;
		    }
                    break;

// XTYP_POKE CHANGE
#ifdef WIN32  // TURNED BACK ON
		case XTYP_POKE:
		    *phDataRet = (HDDEDATA)DDE_FACK;
		     ci.cb = sizeof(CONVINFO);

		     if (DdeQueryConvInfo(hConv, QID_SYNC, &ci))
			 {
			 if (!(ci.wStatus & ST_ISSELF)) {
			     DdePostAdvise(GetThreadLong(GETCURRENTTHREADID(),OFFSET_IDINST), hszTopic, hszItem);
			     }
			 }
		     else
			 {
			 *phDataRet = (HDDEDATA)DDE_FNOTPROCESSED;
			 }
		    break;
#endif


                case XTYP_REQUEST:
                case XTYP_ADVREQ:
                    if (pfmt->lpfnRequest) {
			HDDEDATA hDataOut;

			l=GetWindowLong(hwndMain,OFFSET_FLAGS);
			if(l&FLAG_APPOWNED) {

			     hmem=(HANDLE)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HAPPOWNED);
			     hAppOwned=(HDDEDATA FAR *)GlobalLock(hmem);

			     switch (pfmt->wFmt) {
				case CF_TEXT:	      if(hAppOwned[TXT]==0L) fCreate=TRUE;
				    break;
				case CF_DIB:	      if(hAppOwned[DIB]==0L) fCreate=TRUE;
				    break;
				case CF_BITMAP:       if(hAppOwned[BITMAP]==0L) fCreate=TRUE;
				    break;
#ifdef WIN32
				case CF_ENHMETAFILE:  if(hAppOwned[ENHMETA]==0L) fCreate=TRUE;
				    break;
#endif
				case CF_METAFILEPICT: if(hAppOwned[METAPICT]==0L) fCreate=TRUE;
				    break;
				case CF_PALETTE:      if(hAppOwned[PALETTE]==0L) fCreate=TRUE;
				    break;
				default:
				    DDEMLERROR("DdeStrs.Exe -- ERR: Unexpected switch constant in DoCallback!\r\n");
				    break;

				} // switch

			     GlobalUnlock(hmem);

			     if (fCreate) {
				  hDataOut = DdeCreateDataHandle( GetThreadLong(GETCURRENTTHREADID(),OFFSET_IDINST),
								  NULL,
								  0,
								  0,
								  pitm->hszItem,
								  pfmt->wFmt,
								  HDATA_APPOWNED);
				  } // fCreate

			     } // l&FLAG_APPOWNED
			else {
			     hDataOut = DdeCreateDataHandle( GetThreadLong(GETCURRENTTHREADID(),OFFSET_IDINST),
							     NULL,
							     0,
							     0,
							     pitm->hszItem,
							     pfmt->wFmt,
							     0);
			     } // else l&FLAG_APPOWNED

                        *phDataRet = (HDDEDATA)(*pfmt->lpfnRequest)(hDataOut);
                        if (!*phDataRet) {
                            DdeFreeDataHandle(hDataOut);
			    }
                    } else {
                        *phDataRet = 0;
                    }
                    break;
                }
                return(TRUE);
            }
        }

        /* item not found in tables */

        if (wFmt == CF_TEXT && (wType == XTYP_REQUEST || wType == XTYP_ADVREQ)) {
            /*
             * If formats item was requested and not found in the tables,
             * return a list of formats supported under this topic.
             */
            if (!DdeCmpStringHandles(hszItem, SSI.topic[0].item[ITPC_FORMATS].hszItem)) {
		*phDataRet = DdeCreateDataHandle(GetThreadLong(GETCURRENTTHREADID(),OFFSET_IDINST),
						 NULL,
						 0,
						 0,
						 hszItem,
						 wFmt,
						 0);
                *phDataRet = ReqFormats(*phDataRet, ptpc);
                return(TRUE);
            }
            /*
             * If sysitems or topicitemlist item was requested and not found,
             * return a list of items supported under this topic.
             */
            if (!DdeCmpStringHandles(hszItem, SSI.topic[0].item[ITPC_SYSITEMS].hszItem) ||
                !DdeCmpStringHandles(hszItem, SSI.topic[0].item[ITPC_ITEMLIST].hszItem)) {
		*phDataRet = ReqItems(DdeCreateDataHandle(GetThreadLong(GETCURRENTTHREADID(),OFFSET_IDINST),
							  NULL,
							  0,
							  0,
							  hszItem,
							  wFmt,
							  0),
				      ptpc);
                return(TRUE);
            }
        }
    }

    /* no topics fit */

    return(FALSE);
}


/*
 * These are Request routines for supporting the system topic.
 * Their behavior depends on the table contents.
 */

HDDEDATA SysReqTopics(
HDDEDATA hDataOut)         // data handle to add output data to.
{
    int iTopic, cb, cbOff;
    LPDDETOPICTBL ptpc;

    /*
     * This code assumes SSI only contains the system topic.
     */

    cbOff = 0;
    FOR_EACH_TOPIC(pasi, ptpc, iTopic) {
        if (!DdeCmpStringHandles(ptpc->hszTopic, SSI.topic[0].hszTopic)) {
            continue;       // don't add systopic twice.
        }
        cb = lstrlen(ptpc->pszTopic);
        hDataOut = DdeAddData(hDataOut, ptpc->pszTopic, (DWORD)cb, (DWORD)cbOff);
        cbOff += cb;
        hDataOut = DdeAddData(hDataOut, (LPBYTE)&tab, (DWORD)1, (DWORD)cbOff);
        cbOff++;
    }

    hDataOut = DdeAddData(hDataOut, SSI.topic[0].pszTopic,
            (DWORD)lstrlen(SSI.topic[0].pszTopic) + 1, (DWORD)cbOff);

    return(hDataOut);
}



HDDEDATA SysReqSysItems(
HDDEDATA hDataOut)
{
    return(ReqItems(hDataOut, &SSI.topic[ITPC_SYSITEMS]));
}


/*
 * Given a topic table, this function returns a tab delimited list of
 * items supported under that topic.
 */
HDDEDATA ReqItems(
HDDEDATA hDataOut,
LPDDETOPICTBL ptpc)
{
    int cb, iItem, cbOff = 0;
    LPDDEITEMTBL pitm;

    /*
     * return a list of all the items within this topic
     */
    FOR_EACH_ITEM(ptpc, pitm, iItem) {
        cb = lstrlen(pitm->pszItem);
        hDataOut = DdeAddData(hDataOut, pitm->pszItem, (DWORD)cb, (DWORD)cbOff);
        cbOff += cb;
        hDataOut = DdeAddData(hDataOut, (LPBYTE)&tab, (DWORD)1, (DWORD)cbOff);
        cbOff++;
    }


    /*
     * if this is for the System Topic, add to the list our default items.
     */

    if (!DdeCmpStringHandles(ptpc->hszTopic, SSI.topic[0].hszTopic)) {
        ptpc = &SSI.topic[0];
        FOR_EACH_ITEM(ptpc, pitm, iItem) {
            cb = lstrlen(pitm->pszItem);
            hDataOut = DdeAddData(hDataOut, pitm->pszItem, (DWORD)cb, (DWORD)cbOff);
            cbOff += cb;
            hDataOut = DdeAddData(hDataOut, (LPBYTE)&tab, (DWORD)1, (DWORD)cbOff);
            cbOff++;
        }
    } else {
        /*
         * Add the standard TopicListItems and SysItem items.
         */
        cb = lstrlen(SSI.topic[0].item[ITPC_SYSITEMS].pszItem);
        hDataOut = DdeAddData(hDataOut,
            SSI.topic[0].item[ITPC_SYSITEMS].pszItem, (DWORD)cb, (DWORD)cbOff);
        cbOff += cb;
        hDataOut = DdeAddData(hDataOut, (LPBYTE)&tab, (DWORD)1, (DWORD)cbOff);
        cbOff++;

        cb = lstrlen(SSI.topic[0].item[ITPC_ITEMLIST].pszItem);
        hDataOut = DdeAddData(hDataOut,
            SSI.topic[0].item[ITPC_ITEMLIST].pszItem, (DWORD)cb, (DWORD)cbOff);
        cbOff += cb;
        hDataOut = DdeAddData(hDataOut, (LPBYTE)&tab, (DWORD)1, (DWORD)cbOff);
        cbOff++;

        cb = lstrlen(SSI.topic[0].item[ITPC_FORMATS].pszItem);
        hDataOut = DdeAddData(hDataOut,
            SSI.topic[0].item[ITPC_FORMATS].pszItem, (DWORD)cb, (DWORD)cbOff);
        cbOff += cb;
        hDataOut = DdeAddData(hDataOut, (LPBYTE)&tab, (DWORD)1, (DWORD)cbOff);
        cbOff++;
    }

    hDataOut = DdeAddData(hDataOut, '\0', (DWORD)1, (DWORD)--cbOff);
    return(hDataOut);
}




HDDEDATA SysReqFormats(
HDDEDATA hDataOut)
{
    int iTopic, iItem, iFmt;
    LPDDETOPICTBL ptpc;
    LPDDEITEMTBL pitm;
    LPDDEFORMATTBL pfmt;

    hDataOut = DdeAddData(hDataOut, (LPBYTE)"TEXT", 5, 0);
    FOR_EACH_TOPIC(pasi, ptpc, iTopic) {
        FOR_EACH_ITEM(ptpc, pitm, iItem) {
            FOR_EACH_FORMAT(pitm, pfmt, iFmt) {
                hDataOut = AddReqFormat(hDataOut, pfmt->pszFormat);
            }
        }
    }
    return(hDataOut);
}



HDDEDATA AddReqFormat(
HDDEDATA hDataOut,
LPSTR pszFmt)
{
    LPSTR pszList;
    DWORD cbOff;

    pszList = DdeAccessData(hDataOut, NULL);

#if WIN16
    if (_fstrstr(pszList, pszFmt) == NULL) {
#else
    if (strstr(pszList, pszFmt) == NULL) {
#endif
        cbOff = lstrlen(pszList);
        DdeUnaccessData(hDataOut);
        hDataOut = DdeAddData(hDataOut, (LPBYTE)&tab, 1, cbOff++);
        hDataOut = DdeAddData(hDataOut, (LPBYTE)pszFmt, lstrlen(pszFmt) + 1, cbOff);
    } else {
        DdeUnaccessData(hDataOut);
    }

    return(hDataOut);
}


HDDEDATA ReqFormats(
HDDEDATA hDataOut,
LPDDETOPICTBL ptpc)
{
    int iItem, iFmt;
    LPDDEITEMTBL pitm;
    LPDDEFORMATTBL pfmt;

    hDataOut = DdeAddData(hDataOut, "", 1, 0);
    FOR_EACH_ITEM(ptpc, pitm, iItem) {
        FOR_EACH_FORMAT(pitm, pfmt, iFmt) {
            hDataOut = AddReqFormat(hDataOut, pfmt->pszFormat);
        }
    }
    return(hDataOut);
}



HDDEDATA DoWildConnect(
HSZ hszTopic)
{
    LPDDETOPICTBL ptpc;
    HDDEDATA hData;
    PHSZPAIR pHszPair;
    int iTopic, cTopics = 2;

    if (!hszTopic) {
        cTopics += pasi->cTopics;
    }

    hData = DdeCreateDataHandle(GetThreadLong(GETCURRENTTHREADID(),OFFSET_IDINST),
				NULL,
				cTopics * sizeof(HSZPAIR),
				0,
				0,
				0,
				0);
    pHszPair = (HSZPAIR FAR *)DdeAccessData(hData, NULL);
    pHszPair->hszSvc = pasi->hszService;
    pHszPair->hszTopic = SSI.topic[0].hszTopic;  // always support systopic.
    pHszPair++;
    ptpc = &pasi->topic[0];
    FOR_EACH_TOPIC(pasi, ptpc, iTopic) {
        if (hszTopic && DdeCmpStringHandles(hszTopic, ptpc->hszTopic)) {
            continue;
        }
        if (!DdeCmpStringHandles(ptpc->hszTopic, SSI.topic[0].hszTopic)) {
            continue;       // don't enter systopic twice.
        }
        pHszPair->hszSvc = pasi->hszService;
        pHszPair->hszTopic = ptpc->hszTopic;
        pHszPair++;
    }
    pHszPair->hszSvc = 0;
    pHszPair->hszTopic = 0;
    DdeUnaccessData(hData);
    return(hData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\src\client\clinit.c ===
/***************************************************************************
 *                                                                         *
 *  MODULE      : clinit.c                                                 *
 *                                                                         *
 *  PURPOSE     : Contains initialization code for Client                  *
 *                                                                         *
 ***************************************************************************/

#include "ddemlcl.h"

char szFrame[] = "mpframe";   /* Class name for "frame" window */
char szChild[] = "mpchild";   /* Class name for MDI window     */
char szList[] =  "mplist";    /* Class name for MDI window     */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : InitializeApplication ()                                   *
 *                                                                          *
 *  PURPOSE    : Sets up the class data structures and does a one-time      *
 *               initialization of the app by registering the window classes*
 *               Also registers the Link clipboard format                   *
 *                                                                          *
 *  RETURNS    : TRUE  - If successful.                                     *
 *               FALSE - otherwise.                                         *
 *                                                                          *
 ****************************************************************************/

BOOL FAR PASCAL InitializeApplication()
{
    WNDCLASS    wc;

    fmtLink = RegisterClipboardFormat("Link");

    if (!fmtLink)
        return FALSE;

    /* Register the frame class */
    wc.style         = 0;
    wc.lpfnWndProc   = FrameWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInst;
    wc.hIcon         = LoadIcon(hInst,MAKEINTRESOURCE(IDCLIENT));
    wc.hCursor       = LoadCursor(NULL,IDC_ARROW);
    wc.hbrBackground = COLOR_APPWORKSPACE+1;
    wc.lpszMenuName  = MAKEINTRESOURCE(IDCLIENT);
    wc.lpszClassName = szFrame;

    if (!RegisterClass (&wc) )
        return FALSE;

    /* Register the MDI child class */
    wc.lpfnWndProc   = MDIChildWndProc;
    wc.hIcon         = LoadIcon(hInst,MAKEINTRESOURCE(IDCONV));
    wc.lpszMenuName  = NULL;
    wc.cbWndExtra    = CHILDCBWNDEXTRA;
    wc.lpszClassName = szChild;

    if (!RegisterClass(&wc))
        return FALSE;

    wc.hIcon         = LoadIcon(hInst, MAKEINTRESOURCE(IDLIST));
    wc.lpszClassName = szList;

    if (!RegisterClass(&wc))
        return FALSE;

    return TRUE;

}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : InitializeInstance ()                                      *
 *                                                                          *
 *  PURPOSE    : Performs a per-instance initialization of Client.          *
 *               - Enlarges message queue to handle lots of DDE messages.   *
 *               - Initializes DDEML for this app                           *
 *               - Creates atoms for our custom formats                     *
 *               - Creates the main frame window                            *
 *               - Loads accelerator table                                  *
 *               - Shows main frame window                                  *
 *                                                                          *
 *  RETURNS    : TRUE  - If initialization was successful.                  *
 *               FALSE - otherwise.                                         *
 *                                                                          *
 ****************************************************************************/
BOOL FAR PASCAL InitializeInstance(
WORD nCmdShow)
{
    extern HWND  hwndMDIClient;
    char         sz[80];
    int          i;

    if (DdeInitialize(&idInst, (PFNCALLBACK)MakeProcInstance(
            (FARPROC)DdeCallback, hInst), APPCMD_CLIENTONLY, 0L))
        return FALSE;

    CCFilter.iCodePage = CP_WINANSI;

    for (i = 0; i < CFORMATS; i++) {
        if (aFormats[i].atom == 0)
            aFormats[i].atom = RegisterClipboardFormat(aFormats[i].sz);
    }

    /* Get the base window title */
    LoadString(hInst, IDS_APPNAME, sz, sizeof(sz));

    /* Create the frame */
    hwndFrame = CreateWindow (szFrame,
                              sz,
                              WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              400,
                              200,
                              NULL,
                              NULL,
                              hInst,
                              NULL);

    if (!hwndFrame || !hwndMDIClient)
        return FALSE;

    /* Load main menu accelerators */
    if (!(hAccel = LoadAccelerators (hInst, MAKEINTRESOURCE(IDCLIENT))))
        return FALSE;

    /* Display the frame window */
    ShowWindow (hwndFrame, nCmdShow);
    UpdateWindow (hwndFrame);

    /*
     * We set this hook up so that we can catch the MSGF_DDEMGR filter
     * which is called when DDEML is in a modal loop during synchronous
     * transaction processing.
     */
    (FARPROC)lpMsgFilterProc = (FARPROC)MakeProcInstance((FARPROC)MyMsgFilterProc, hInst);
    SetWindowsHook(WH_MSGFILTER, (FARPROC)lpMsgFilterProc);

    return TRUE;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\ddestrs\server.c ===
#include <windows.h>
#include <port1632.h>
#include <ddeml.h>
#include <string.h>
#include "wrapper.h"
#include "ddestrs.h"

extern BOOL UpdateCount(HWND,INT,INT);
BOOL Balance(INT);

/*
 * Service routines
 */

/*************************** Private Function ******************************\

GetHINSTANCE

\***************************************************************************/

HINSTANCE GetHINSTANCE( HWND hwnd ) {
HINSTANCE hInstance;

#ifdef WIN32
     hInstance=(HINSTANCE)GetWindowLong(hwnd,GWL_HINSTANCE);
#else
     hInstance=(HINSTANCE)GetWindowWord(hwnd,GWW_HINSTANCE);
#endif

     return hInstance;

}

//*****************************************************************************
//**************************	  DispWndProc	     **************************
//*****************************************************************************

LONG FAR PASCAL DispWndProc( HWND hwnd , UINT msg, WPARAM wp, LONG lp) {

    return DefWindowProc(hwnd,msg,wp,lp);

}

/*************************** Private Function ******************************\
*
* CreateDisplayWindow
*
\***************************************************************************/

HWND CreateDisplayWindow( HWND hwndParent, int nPosIndex ) {
WNDCLASS wc,wcc;
LPWNDCLASS lpWndClass=&wc;
HWND hwnd;
RECT r;
int  stpy,stpx,cy;
char sz[100];
LPSTR lpstr=&sz[0];

#ifdef WIN32
LPCTSTR lpsz;
#else
LPSTR lpsz;
#endif

char szname[100];

     strcpy(&szname[0],"Display Window");

     wc.style	      = 0;
     wc.lpfnWndProc   = DispWndProc;
     wc.cbClsExtra    = 0;
     wc.cbWndExtra    = 0;
     wc.hInstance     = GetHINSTANCE(hwndParent);
     wc.hIcon	      = LoadIcon(NULL,IDI_EXCLAMATION );
     wc.hCursor       = LoadCursor(NULL,IDC_ARROW );
     wc.lpszMenuName  = NULL;
     wc.lpszClassName = "Display Window";
     wc.hbrBackground = CreateSolidBrush(RGB(0,255,255));

     lpsz=(LPSTR)wc.lpszClassName;

     if(!GetClassInfo(wc.hInstance,lpsz,&wcc)) {
	 RegisterClass(lpWndClass);
	 }

     GetClientRect(hwndParent,&r);

     stpx =r.right-r.left;
     stpy =((r.bottom-r.top)/3);

     switch(nPosIndex) {
	case 1:   cy=r.bottom-(3*cyText);
	   break;
	case 2:   cy=r.bottom-(6*cyText);
	   break;
	case 3:   cy=r.bottom-(9*cyText);
	   break;
	case 4:   cy=r.bottom-(12*cyText);
	   break;
	case 5:   cy=r.bottom-(15*cyText);
	   break;
	default:  cy=r.bottom-(18*cyText);
	   break;
	}

     if (!IsWindow(hwndParent)) DOut((HWND)NULL,"DdeStrs.exe -- ERR:Bad parent hwnd=%u!\r\n",0,(LONG)hwndParent);

     hwnd = CreateWindowEx(WS_EX_DLGMODALFRAME,
			   "Display Window",
			   &szname[0],
			   WS_CHILD|WS_VISIBLE|WS_CAPTION|WS_DISABLED,
			   0,
			   cy,
			   stpx,
			   3*cyText,
			   hwndParent,
			   NULL,
			   lpWndClass->hInstance,
			   NULL );

     if ( !IsWindow(hwnd) )
	  {
	  DDEMLERROR("DdeStrs.Exe -- ERR:Display window not created\r\n");
	  UnregisterClass("Display Window",wc.hInstance);
	  }

     return hwnd;

}

BOOL PokeTestItem_Text(
HDDEDATA hData)
{
LPBYTE lpData;
HDC hdc;
HBRUSH hBrush;
PAINTSTRUCT ps;
RECT rc;
DWORD cbData;
HWND hwndDisplay;

    Balance(OFFSET_CLIENT);

    hwndDisplay=(HWND)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HWNDDISPLAY);
    SetWindowText(hwndDisplay,"Client - CF_TEXT");

    lpData = (LPBYTE) DdeAccessData( hData, &cbData );

    hdc = GetDC(hwndDisplay);
    if(!hdc) {
	DDEMLERROR("DdeStrs.Exe -- ERR:NULL hdc ret from GetDC (client:CF_TEXT)!\r\n");
	DdeUnaccessData(hData);   //JOHNSP:CHANGE
	return 0;
	}

    hBrush=CreateSolidBrush(WHITE);
    if(!hBrush) {
	DDEMLERROR("DdeStrs.Exe -- ERR:NULL hBrush ret from CreateSolidBrush (client:CF_TEXT)!\r\n");
	DdeUnaccessData(hData);   //JOHNSP:CHANGE
	EndPaint(hwndDisplay,&ps);
	return 0;
	}

    GetClientRect(hwndDisplay,&rc);

    FillRect(hdc,&rc,hBrush);
    DeleteObject(hBrush);

    DrawText(hdc, lpData, -1, &rc, DT_LEFT|DT_TOP);
    ReleaseDC(hwndDisplay,hdc);

    DdeUnaccessData(hData);   //JOHNSP:CHANGE

    return(TRUE);

}

BOOL PokeTestItem_DIB(
HDDEDATA hData)
{
HWND hwnd;
HDC  hdc;
RECT r;
INT  width,height;
LPBITMAPINFO lpbitinfo;
LPBYTE lpbits;
HANDLE hmem;
LPBYTE lpData;
DWORD cbData;
LPBYTE lp;
int	     iexRGB;

    Balance(OFFSET_CLIENT);

    lpData = (LPBYTE) DdeAccessData( hData, &cbData );

    hwnd=(HWND)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HWNDDISPLAY);
    SetWindowText(hwnd,"Client - CF_DIB");

    hdc = GetDC(hwnd);
    if(!hdc) {
	DDEMLERROR("DdeStrs.Exe -- ERR:NULL hdc (client)\r\n");
	DdeUnaccessData(hData);   //JOHNSP:CHANGE
	return 0;
	}

    GetClientRect(hwnd,&r);
    width=r.right-r.left;
    height=r.bottom-r.top;

#ifdef WIN32
    memcpy(&hmem,lpData,sizeof(HANDLE));
#else
    _fmemcpy(&hmem,lpData,sizeof(HANDLE));
#endif

    if(!hmem) {
	DDEMLERROR("DdeStrs.Exe -- ERR:hmem recieved from server=NULL (client)\r\n");
	DdeUnaccessData(hData);   //JOHNSP:CHANGE
	ReleaseDC(hwnd,hdc);
	return 0;
	}

    lp	     =(LPBYTE)GlobalLock(hmem);
    lpbitinfo=(LPBITMAPINFO)lp;

    // iexRGB is ((2^n)-1) where n=biBitCount and we are computing the
    // number of RGBQUAD structures.  Remember that part of the
    // BITMAPINFO structure contains 1 RGBQUAD already.

    iexRGB =((0x0001<<lpbitinfo->bmiHeader.biBitCount)-1)*sizeof(RGBQUAD);
    lpbits=lp+(sizeof(BITMAPINFO)+iexRGB);

    SetDIBitsToDevice(hdc,
		      0,
		      0,
		      (UINT)lpbitinfo->bmiHeader.biWidth,
		      (UINT)lpbitinfo->bmiHeader.biHeight,
		      0,
		      0,
		      0,
		      (UINT)(lpbitinfo->bmiHeader.biHeight),
		      lpbits,
		      lpbitinfo,
		      DIB_RGB_COLORS);

    ReleaseDC(hwnd,hdc);

    DdeUnaccessData(hData);   //JOHNSP:CHANGE

    return(TRUE);
}

BOOL PokeTestItem_BITMAP(
HDDEDATA hData)
{
HWND hwnd;
HDC  hdc,hdcMem;
RECT r;
INT  width,height;
HBITMAP hbmap;
HANDLE hobj;
LPBYTE lpData;
DWORD cbData;

    Balance(OFFSET_CLIENT);

    hwnd=(HWND)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HWNDDISPLAY);
    SetWindowText(hwnd,"Client - CF_BITMAP");

    lpData = (LPBYTE) DdeAccessData( hData, &cbData );

#ifdef WIN32
    memcpy(&hbmap,lpData,sizeof(HBITMAP));
#else
    _fmemcpy(&hbmap,lpData,sizeof(HBITMAP));
#endif

    hdc    = GetDC(hwnd);
    hdcMem = CreateCompatibleDC(hdc);

    if(!hdc||!hdcMem) {
	DDEMLERROR("DdeStrs.Exe -- ERR:NULL hdc (client)\r\n");
	DdeUnaccessData(hData);   //JOHNSP:CHANGE
	if(hdc) ReleaseDC(hwndMain,hdc);
	if(hdcMem) DeleteDC(hdcMem);
	return 0;
	}

    if(!hbmap) {
	DDEMLERROR("DdeStrs.Exe -- ERR:NULL hbmap (client)\r\n");
	DdeUnaccessData(hData);   //JOHNSP:CHANGE
	DeleteDC(hdcMem);
	ReleaseDC(hwndMain,hdc);
	return 0;
	}

    GetClientRect(hwnd,&r);
    width=r.right-r.left;
    height=r.bottom-r.top;

    hobj=SelectObject(hdcMem,hbmap);
    if(!hobj) {
	DDEMLERROR("DdeStrs.Exe -- ERR:SelectObject failed (client)\r\n");
	DdeUnaccessData(hData);   //JOHNSP:CHANGE
	DeleteDC(hdcMem);
	ReleaseDC(hwndMain,hdc);
	return 0;
	}

    if(!BitBlt(hdc,0,0,width,height,hdcMem,0,0,SRCCOPY))
	DDEMLERROR("DdeStrs.Exe -- ERR:BitBlt failed (client)\r\n");

    hobj=SelectObject(hdcMem,hobj);
    DeleteDC(hdcMem);
    ReleaseDC(hwnd,hdc);

    DdeUnaccessData(hData);   //JOHNSP:CHANGE

    return(TRUE);

}

#ifdef WIN32
BOOL PokeTestItem_ENHMETA(
HDDEDATA hData)
{
LPBYTE lpData;
HWND hwnd;
HDC hdc;
HANDLE hemf;
DWORD cbData;
RECT	 r;

    Balance(OFFSET_CLIENT);

    hwnd=(HWND)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HWNDDISPLAY);
    SetWindowText(hwnd,"Client - CF_ENHMETAFILE");

    lpData = (LPBYTE) DdeAccessData( hData, &cbData );

    hdc = GetDC(hwnd);
    if(!hdc) {
	DDEMLERROR("DdeStrs.Exe -- ERR:NULL hdc (client)\r\n");
	DdeUnaccessData(hData);   //JOHNSP:CHANGE
	return 0;
	}

#ifdef WIN32
    memcpy(&hemf,lpData,sizeof(HANDLE));
#else
    _fmemcpy(&hemf,lpData,sizeof(HANDLE));
#endif

    GetClientRect(hwnd,&r);
    if(!PlayEnhMetaFile(hdc,hemf,&r))
	DDEMLERROR("DdeStrs.Exe -- ERR:PlayMetaFile failed (client)\r\n");

    ReleaseDC(hwnd,hdc);

    DdeUnaccessData(hData);   //JOHNSP:CHANGE

    return(TRUE);

}
#endif

BOOL PokeTestItem_METAPICT(
HDDEDATA hData)
{
LPBYTE lpData;
HWND hwnd;
HDC hdc;
HANDLE hmf;
LPMETAFILEPICT lpMfp;
HANDLE hmem;
DWORD cbData;

    Balance(OFFSET_CLIENT);

    hwnd=(HWND)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HWNDDISPLAY);
    SetWindowText(hwnd,"Client - CF_METAFILEPICT");

    lpData = (LPBYTE) DdeAccessData( hData, &cbData );

    hdc = GetDC(hwnd);
    if(!hdc) {
	DDEMLERROR("DdeStrs.Exe -- ERR:NULL hdc (client)\r\n");
	DdeUnaccessData(hData);   //JOHNSP:CHANGE
	return 0;
	}

#ifdef WIN32
    memcpy(&hmem,lpData,sizeof(HANDLE));
#else
    _fmemcpy(&hmem,lpData,sizeof(HANDLE));
#endif

    lpMfp=(LPMETAFILEPICT)GlobalLock(hmem);
    hmf=lpMfp->hMF;

    if(!PlayMetaFile(hdc,hmf))
	DDEMLERROR("DdeStrs.Exe -- ERR:PlayMetaFile failed (client)\r\n");

    ReleaseDC(hwnd,hdc);

    DdeUnaccessData(hData);   //JOHNSP:CHANGE

    return(TRUE);

}

BOOL PokeTestItem_PALETTE(
HDDEDATA hData)
{
LPBYTE lpData;
HWND hwnd;
HPALETTE hpal;
HDC hdc;
RECT r;
HANDLE hobj;
HANDLE hbrush;
DWORD cbData;

    Balance(OFFSET_CLIENT);

    hwnd=(HWND)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HWNDDISPLAY);
    SetWindowText(hwnd,"Client - CF_PALETTE");

    lpData = (LPBYTE) DdeAccessData( hData, &cbData );

    GetClientRect(hwnd,&r);

    hdc=GetDC(hwnd);

    if(!hdc) {
	 DDEMLERROR("DdeStrs.Exe -- ERR:NULL hdc (client)\r\n");
	 DdeUnaccessData(hData);   //JOHNSP:CHANGE
	 return 0;
	 }

#ifdef WIN32
    memcpy(&hpal,lpData,sizeof(HPALETTE));
#else
    _fmemcpy(&hpal,lpData,sizeof(HPALETTE));
#endif

    hobj=(HPALETTE)SelectPalette(hdc,hpal,FALSE);

    if(!hobj) {
	 DDEMLERROR("DdeStrs.Exe -- ERR:NULL hobj:SelectPalette failed (client)\r\n");
	 DdeUnaccessData(hData);   //JOHNSP:CHANGE
	 ReleaseDC(hwnd,hdc);
	 return 0;
	 }

    RealizePalette(hdc);

    hbrush=CreateSolidBrush(PALETTEINDEX(0));
    if(!hbrush) {
	DDEMLERROR("DdeStrs.Exe -- ERR:NULL hbrush ret from CreatSolidBrush (client)\r\n");
	DdeUnaccessData(hData);   //JOHNSP:CHANGE
	SelectPalette(hdc,(HPALETTE)hobj,FALSE);
	ReleaseDC(hwnd,hdc);
	return 0;
	}

    FillRect(hdc,&r,hbrush);
    DeleteObject(hbrush);

    SelectPalette(hdc,(HPALETTE)hobj,FALSE);
    ReleaseDC(hwnd,hdc);

    DdeUnaccessData(hData);   //JOHNSP:CHANGE

    return(TRUE);

}

HDDEDATA RenderTestItem_Text(
HDDEDATA hData)
{
HDC hdc;
HBRUSH hBrush;
PAINTSTRUCT ps;
RECT rc;
HDDEDATA hddedata;
LONG l;
HDDEDATA FAR *hAppOwned;
HANDLE hmem;
HWND hwndDisplay;

    Balance(OFFSET_SERVER);

    hwndDisplay=(HWND)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HWNDDISPLAY);
    SetWindowText(hwndDisplay,"Server - CF_TEXT");

    // if we are running app owned then we just reuse our
    // last handle.

    hmem=(HANDLE)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HAPPOWNED);
    hAppOwned=(HDDEDATA FAR *)GlobalLock(hmem);

    if(hAppOwned[TXT]!=0L) {
	 hddedata=hAppOwned[TXT];
	 GlobalUnlock(hmem);
	 return hddedata;
	 }

    hdc=GetDC(hwndDisplay);
    if(!hdc) {
	DDEMLERROR("DdeStrs.Exe -- ERR:NULL hdc ret from GetDC! (server)\r\n");
	GlobalUnlock(hmem);
	return 0;
	}

    hBrush=CreateSolidBrush(WHITE);
    if(!hBrush) {
	DDEMLERROR("DdeStrs.Exe -- ERR:NULL hBrush ret from CreateSolidBrush! (server)\r\n");
	EndPaint(hwndDisplay,&ps);
	GlobalUnlock(hmem);
	return 0;
	}

    GetClientRect(hwndDisplay,&rc);
    FillRect(hdc,&rc,hBrush);
    DeleteObject(hBrush);

    DrawText(hdc, "Data:CF_TEXT format", -1, &rc, DT_LEFT|DT_TOP);
    ReleaseDC(hwndDisplay,hdc);

    hddedata=DdeAddData(hData, "Data:CF_TEXT format", 20, 0);

    l=GetWindowLong(hwndMain,OFFSET_FLAGS);
    if(l&FLAG_APPOWNED) {
	hAppOwned[TXT]=hddedata;
	}

    GlobalUnlock(hmem);

    return hddedata;
}

HDDEDATA RenderTestItem_DIB(
HDDEDATA hData)
{
HWND hwnd;
LONG length;
HDC  hdc,hdcMem;
RECT r;
INT  width,height,dibhdr;
HBITMAP hbmap;
HANDLE hobj;
LPBITMAPINFO lpbitinfo;
LPBITMAPINFOHEADER lpbithdr;
LPBYTE lpbits;
LPBYTE lpdata;
HDDEDATA hddedata;
INT	 ip,ibpp;
CHAR	 sz[100];
LONG l;
HDDEDATA FAR *hAppOwned;
HANDLE hmem,hm;

    Balance(OFFSET_SERVER);

    hwnd=(HWND)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HWNDDISPLAY);
    SetWindowText(hwnd,"Server - CF_DIB");

    // if we are running app owned then we just reuse our
    // last handle.

    hmem=(HANDLE)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HAPPOWNED);
    hAppOwned=(HDDEDATA FAR *)GlobalLock(hmem);

    if(hAppOwned[DIB]!=0L) {
	 hddedata=hAppOwned[DIB];
	 GlobalUnlock(hmem);
	 return hddedata;
	 }

    length = sizeof(HBITMAP);

    hdc=GetDC(hwnd);
    if(!hdc) {
	DDEMLERROR("DdeStrs.Exe -- ERR:NULL hdc (server)\r\n");
	GlobalUnlock(hmem);
	return 0;
	}

    ibpp=GetDeviceCaps(hdc,BITSPIXEL);
    ip=GetDeviceCaps(hdc,PLANES);

    hdcMem=CreateCompatibleDC(hdc);

    if(!hdcMem) {
	DDEMLERROR("DdeStrs.Exe -- ERR:NULL hdc (server)\r\n");
	ReleaseDC(hwnd,hdc);
	GlobalUnlock(hmem);
	return 0;
	}

    GetClientRect(hwnd,&r);
    width=r.right-r.left;
    height=r.bottom-r.top;

    hbmap=CreateCompatibleBitmap(hdcMem,width,height);
    if(!hbmap) {
	DDEMLERROR("DdeStrs.Exe -- ERR:NULL hbmap-CreateCompatibleBitmap failed (server)\r\n");
	DeleteDC(hdcMem);
	ReleaseDC(hwnd,hdc);
	GlobalUnlock(hmem);
	return 0;
	}

    hobj=SelectObject(hdcMem,hbmap);
    if(!hobj) {
	DDEMLERROR("DdeStrs.Exe -- ERR (Server), SelectObject failed\r\n");
	DeleteObject(hbmap);
	DeleteDC(hdcMem);
	ReleaseDC(hwnd,hdc);
	GlobalUnlock(hmem);
	return 0;
	}

    if(!PatBlt(hdcMem,r.left,r.top,width,height,WHITENESS))
       DDEMLERROR("DdeStrs.Exe -- ERR (Server), PatBlt failed\r\n");

    // Deselect object (must be done according to docs)

    hobj=SelectObject(hdcMem,hobj);
    if(!hobj) DDEMLERROR("DdeStrs.Exe -- ERR (Server), SelectObject [call 2] failed\r\n");


    // Set up for a monochrome bitmap.

    dibhdr =sizeof(BITMAPINFO)+(sizeof(RGBQUAD));


    // dib header plus area for raw bits

    length =dibhdr+(((width*ibpp)+31)/32)*ip*height*4;

    // Allocate memory for the DIB

    hm=GlobalAlloc(GMEM_ZEROINIT|GMEM_DDESHARE,length);
    if(!hm) {
	DDEMLERROR("DdeStrs.Exe - RenderTestItem_DIB\r\n");
	wsprintf(sz, "DdeStrs.Exe - GobalAlloc failed, allocation size = %d\r\n", length );
	DDEMLERROR(&sz[0]);

	DeleteObject(hbmap);
	DeleteDC(hdcMem);
	ReleaseDC(hwnd,hdc);
	GlobalUnlock(hmem);
	return 0;
	}

    lpdata=(LPBYTE)GlobalLock(hm);

    lpbitinfo=(LPBITMAPINFO)lpdata;
    lpbithdr=&(lpbitinfo->bmiHeader);

    lpbits=lpdata+dibhdr;

    lpbitinfo->bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
    lpbitinfo->bmiHeader.biWidth=width;
    lpbitinfo->bmiHeader.biHeight=height;
    lpbitinfo->bmiHeader.biPlanes=1;
    lpbitinfo->bmiHeader.biBitCount=1;

    // I allocated zero init memory so the other values should
    // be 0 and will use the default.

    if(!GetDIBits(hdcMem,
		  hbmap,
		  0,
		  height,
		  lpbits,
		  lpbitinfo,
		  DIB_RGB_COLORS))
	{
	DDEMLERROR("DdeStrs.Exe -- ERR (Server), GetDIBits failed\r\n");
	}

    SetDIBitsToDevice(hdc,
		      0,
		      0,
		      (UINT)lpbitinfo->bmiHeader.biWidth,
		      (UINT)lpbitinfo->bmiHeader.biHeight,
		      0,
		      0,
		      0,
		      (UINT)(lpbitinfo->bmiHeader.biHeight),
		      lpbits,
		      lpbitinfo,
		      DIB_RGB_COLORS);

    hddedata=DdeAddData(hData, &hm, sizeof(HANDLE), 0);

    GlobalUnlock(hm);

    DeleteObject(hbmap);

    DeleteDC(hdcMem);
    ReleaseDC(hwnd,hdc);

    l=GetWindowLong(hwndMain,OFFSET_FLAGS);
    if(l&FLAG_APPOWNED) {
	hAppOwned[DIB]=hddedata;
	}

    GlobalUnlock(hmem);

    return hddedata;
}

HDDEDATA RenderTestItem_BITMAP(
HDDEDATA hData)
{
HWND hwnd;
LONG length;
HDC  hdc,hdcMem;
RECT r;
INT  width,height;
HBITMAP hbmap;
HANDLE hobj;
HDDEDATA hddedata;
DWORD  d;
LPBYTE lpdata=(LPBYTE)&d;
LONG l;
HDDEDATA FAR *hAppOwned;
HANDLE hmem;

    Balance(OFFSET_SERVER);

    hwnd=(HWND)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HWNDDISPLAY);
    SetWindowText(hwnd,"Server - CF_BITMAP");

    // if we are running app owned then we just reuse our
    // last handle.

    hmem=(HANDLE)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HAPPOWNED);
    hAppOwned=(HDDEDATA FAR *)GlobalLock(hmem);

    if(hAppOwned[BITMAP]!=0L) {
	 hddedata=hAppOwned[BITMAP];
	 GlobalUnlock(hmem);
	 return hddedata;
	 }

    length = sizeof(HBITMAP);

    hdc=GetDC(hwnd);
    hdcMem=CreateCompatibleDC(hdc);

    if(!hdc) {
	DDEMLERROR("DdeStrs.Exe -- ERR (Server), NULL hdc\r\n");
	GlobalUnlock(hmem);
	return 0;
	}

    if(!hdcMem) {
	DDEMLERROR("DdeStrs.Exe -- ERR (Server), NULL hdc\r\n");
	ReleaseDC(hwnd,hdc);
	GlobalUnlock(hmem);
	return 0;
	}

    GetClientRect(hwnd,&r);
    width=r.right-r.left;
    height=r.bottom-r.top;

    hbmap=CreateCompatibleBitmap(hdcMem,width,height);
    if(!hbmap) {
	DDEMLERROR("DdeStrs.Exe -- ERR (Server), NULL hbmap\r\n");
	DeleteDC(hdcMem);
	ReleaseDC(hwnd,hdc);
	GlobalUnlock(hmem);
	return 0;
	}

    hobj=SelectObject(hdcMem,hbmap);

    if(!hobj) {
	DDEMLERROR("DdeStrs.Exe -- ERR (Server), SelectObject failed\r\n");
	DeleteObject(hbmap);
	DeleteDC(hdcMem);
	ReleaseDC(hwnd,hdc);
	GlobalUnlock(hmem);
	return 0;
	}

    if(!PatBlt(hdcMem,r.left,r.top,width,height,WHITENESS))
       DDEMLERROR("DdeStrs.Exe -- ERR (Server), PatBlt failed\r\n");

    if(!BitBlt(hdc,0,0,width,height,hdcMem,0,0,SRCCOPY))
	DDEMLERROR("DdeStrs.Exe -- ERR (Server), BitBlt failed\r\n");

#ifdef WIN32
    memcpy(lpdata,&hbmap,(INT)length);
#else
    _fmemcpy(lpdata,&hbmap,(INT)length);
#endif

    hddedata=DdeAddData(hData, lpdata, length, 0);

    // Object will be deleted by client! Not server.

    SelectObject(hdcMem,hobj);
    DeleteDC(hdcMem);
    ReleaseDC(hwnd,hdc);

    l=GetWindowLong(hwndMain,OFFSET_FLAGS);
    if(l&FLAG_APPOWNED) {
	hAppOwned[BITMAP]=hddedata;
	}

    GlobalUnlock(hmem);

    return hddedata;
}

#ifdef WIN32
HDDEDATA RenderTestItem_ENHMETA(
HDDEDATA hData)
{
HWND hwnd;
HDDEDATA hddedata;
HDC hdc,hdcMem;
INT width,height,length;
RECT r;
HANDLE hemf;
DWORD d;
LPBYTE lpdata=(LPBYTE)&d;
LONG l;
HDDEDATA FAR *hAppOwned;
HANDLE hmem;

#ifdef WIN32
XFORM  xp;
LPXFORM  lpxform=&xp;
#endif

    Balance(OFFSET_SERVER);

    hwnd=GetThreadLong(GETCURRENTTHREADID(),OFFSET_HWNDDISPLAY);
    SetWindowText(hwnd,"Server - CF_ENHMETAFILE");

    // if we are running app owned then we just reuse our
    // last handle.

    hmem=(HANDLE)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HAPPOWNED);
    hAppOwned=GlobalLock(hmem);

    if(hAppOwned[ENHMETA]!=0L) {
	 hddedata=hAppOwned[ENHMETA];
	 GlobalUnlock(hmem);
	 return hddedata;
	 }

    hdc=GetDC(hwnd); //JOHNSP:CHANGE - below few lines

    if(!hdc) {
	DDEMLERROR("DdeStrs.Exe -- ERR (Server), NULL hdc\r\n");
	GlobalUnlock(hmem);
	return 0;
	}

    hdcMem=CreateEnhMetaFile(hdc,NULL,NULL,NULL);

    if(!hdcMem) {
	DDEMLERROR("DdeStrs.Exe -- ERR (Server), NULL hdc\r\n");
	ReleaseDC(hwnd,hdc);
	GlobalUnlock(hmem);
	return 0;
	}

    length=sizeof(HANDLE);

    GetClientRect(hwnd,&r);
    width=r.right-r.left;
    height=r.bottom-r.top;

    if(!PatBlt(hdcMem,r.left,r.top,width,height,WHITENESS))
       DDEMLERROR("DdeStrs.Exe -- ERR:PatBlt failed (server)\r\n");

    hemf=CloseEnhMetaFile(hdcMem);
    if(!hemf) {
	DDEMLERROR("DdeStrs.Exe -- ERR:CloseEnhMetaFile failed (server)\r\n");
	ReleaseDC(hwnd,hdc);
	GlobalUnlock(hmem);
	return 0;
	}

#ifdef WIN32
    memcpy(lpdata,&hemf,length);
#else
    _fmemcpy(lpdata,&hemf,length);
#endif

    if(!PlayEnhMetaFile(hdc,hemf,&r))
	DDEMLERROR("DdeStrs.Exe -- ERR:PlayEnhMetaFile failed (server)\r\n");

    hddedata=DdeAddData(hData, lpdata, length, 0);

    ReleaseDC(hwnd,hdc);

    l=GetWindowLong(hwndMain,OFFSET_FLAGS);
    if(l&FLAG_APPOWNED) {
	hAppOwned[ENHMETA]=hddedata;
	}

    GlobalUnlock(hmem);

    return hddedata;

}
#endif

HDDEDATA RenderTestItem_METAPICT(
HDDEDATA hData)
{
HWND hwnd;
HDDEDATA hddedata;
HDC hdc,hdcMem;
INT width,height,length;
RECT r;
HANDLE hmf;
LPMETAFILEPICT lpMfp;
DWORD d;
LPBYTE lpdata=(LPBYTE)&d;
CHAR sz[100];
LONG l;
HDDEDATA FAR *hAppOwned;
HANDLE hmem,hm;

    Balance(OFFSET_SERVER);

    hwnd=(HWND)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HWNDDISPLAY);
    SetWindowText(hwnd,"Server - CF_METAFILEPICT");

    // if we are running app owned then we just reuse our
    // last handle.

    hmem=(HANDLE)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HAPPOWNED);
    hAppOwned=(HDDEDATA FAR *)GlobalLock(hmem);

    if(hAppOwned[METAPICT]!=0L) {
	 hddedata=hAppOwned[METAPICT];
	 GlobalUnlock(hmem);
	 return hddedata;
	 }

    hdcMem=CreateMetaFile(NULL);
    if(!hdcMem) {
	DDEMLERROR("DdeStrs.Exe -- ERR: NULL hdc ret from CreateMetaFile, (Server)\r\n");
	GlobalUnlock(hmem);
	return 0;
	}

    length=sizeof(HANDLE);

    GetClientRect(hwnd,&r);
    width=r.right-r.left;
    height=r.bottom-r.top;

    if(!PatBlt(hdcMem,r.left,r.top,width,height,WHITENESS))
       DDEMLERROR("DdeStrs.Exe -- ERR:PatBlt failed (server)\r\n");

    hmf=CloseMetaFile(hdcMem);
    if(!hmf) {
	DDEMLERROR("DdeStrs.Exe -- ERR:NULL hmf ret CloseMetaFile! (Server)\r\n");
	GlobalUnlock(hmem);
	return 0;
	}

    hm=GlobalAlloc(GMEM_ZEROINIT|GMEM_DDESHARE,sizeof(METAFILEPICT));
    if(!hm) {
	DDEMLERROR("DdeStrs.Exe - RenderTestItem_METAPICT\r\n");
	wsprintf(sz, "DdeStrs.Exe - GlobalAlloc failed, allocation size = %d\r\n", sizeof(METAFILEPICT) );
	DDEMLERROR(&sz[0]);
	DeleteMetaFile(hmf);  //JOHNSP:CHANGE
	GlobalUnlock(hmem);
	return 0;
	}

    lpMfp=(LPMETAFILEPICT)GlobalLock(hm);

    lpMfp->mm	= MM_TEXT;
    lpMfp->xExt = width;
    lpMfp->yExt = height;
    lpMfp->hMF	= hmf;

    GlobalUnlock(hm);

#ifdef WIN32
    memcpy(lpdata,&hm,length);
#else
    _fmemcpy(lpdata,&hm,length);
#endif

    hdc=GetDC(hwnd);
    if(!hdc) {
	 DDEMLERROR("DdeStrs.Exe -- ERR:NULL hdc ret from GetDC, (Server)\r\n");
	 GlobalFree(hm);     //JOHNSP:CHANGE
	 DeleteMetaFile(hmf);  //JOHNSP:CHANGE
	 GlobalUnlock(hmem);
	 return 0;
	 }
    else {
	 hddedata=DdeAddData(hData, lpdata, length, 0); //JOHNSP:CHANGE
	 PlayMetaFile(hdc,hmf);
	 ReleaseDC(hwnd,hdc);
	 }

    l=GetWindowLong(hwndMain,OFFSET_FLAGS);
    if(l&FLAG_APPOWNED) {
	hAppOwned[METAPICT]=hddedata;
	}

    GlobalUnlock(hmem);

    return hddedata;

}

HDDEDATA RenderTestItem_PALETTE(
HDDEDATA hData)
{
HWND hwnd;
HPALETTE hpal;
LPLOGPALETTE lppal;
HDDEDATA hddedata;
INT length;
DWORD d;
LPBYTE lpdata=(LPBYTE)&d;
CHAR	 sz[100];
LONG l;
HDDEDATA FAR *hAppOwned;
HANDLE hmem,hm;

HDC hdc;
HANDLE hobj;
HANDLE hbrush;
RECT r;


    Balance(OFFSET_SERVER);

    hwnd=(HWND)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HWNDDISPLAY);
    SetWindowText(hwnd,"Server - CF_PALETTE");

    // if we are running app owned then we just reuse our
    // last handle.

    hmem=(HANDLE)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HAPPOWNED);
    hAppOwned=(HDDEDATA FAR *)GlobalLock(hmem);

    if(hAppOwned[PALETTE]!=0L) {
	 hddedata=hAppOwned[PALETTE];
	 GlobalUnlock(hmem);
	 return hddedata;
	 }

    length=sizeof(LOGPALETTE)+sizeof(PALETTEENTRY);

    lppal=(LPLOGPALETTE)GetMem(length,&hm);

    if(!hm) {
	DDEMLERROR("DdeStrs.Exe - RenderTestItem_PALETTE\r\n");
	wsprintf(sz, "DdeStrs.Exe - GlobalAlloc failed, allocation size = %d\r\n", length );
	DDEMLERROR(&sz[0]);
	GlobalUnlock(hmem);
	return 0;
	}

    lppal->palNumEntries=1;
    lppal->palVersion=0x0300;

    lppal->palPalEntry[0].peRed  =(BYTE)255;
    lppal->palPalEntry[0].peGreen=(BYTE)255;
    lppal->palPalEntry[0].peBlue =(BYTE)255;
    lppal->palPalEntry[0].peFlags=(BYTE)0;

    hpal=CreatePalette(lppal);
    if(!hpal) {
	DDEMLERROR("DdeStrs.Exe - NULL hpal ret CreatePalette! (server)\r\n");
        FreeMem(hm);
	GlobalUnlock(hmem);
	return 0;
	}

    FreeMem(hm);

#ifdef WIN32
    memcpy(lpdata,&hpal,sizeof(HANDLE));
#else
    _fmemcpy(lpdata,&hpal,sizeof(HANDLE));
#endif

    hddedata=DdeAddData(hData, lpdata, sizeof(HPALETTE), 0);

    // Show that palette works.

    // NOTE: From here down if we get a failure we don't abort but
    // return hddedata to pass to the client.  More basically if
    // an error is encountered below it only affects the display
    // on the server side!

    GetClientRect(hwnd,&r);

    hdc=GetDC(hwnd);

    if(!hdc) {
	 DDEMLERROR("DdeStrs.Exe -- ERR:Null hdc (client)\r\n");
	 return hddedata;
	 }

    hobj=(HPALETTE)SelectPalette(hdc,hpal,FALSE);

    if(!hobj) {
	 DDEMLERROR("DdeStrs.Exe -- ERR:Null hobj:SelectPalette failed (client)\r\n");
	 ReleaseDC(hwnd,hdc);
	 return hddedata;
	 }

    RealizePalette(hdc);

    hbrush=CreateSolidBrush(PALETTEINDEX(0));
    if(!hbrush) {
	DDEMLERROR("DdeStrs.Exe -- ERR:Null hbrush ret from CreatSolidBrush (client)\r\n");
	SelectPalette(hdc,(HPALETTE)hobj,FALSE);
	ReleaseDC(hwnd,hdc);
	return hddedata;
	}

    FillRect(hdc,&r,hbrush);
    DeleteObject(hbrush);

    SelectPalette(hdc,(HPALETTE)hobj,FALSE);
    ReleaseDC(hwnd,hdc);

    // if we are running appowned, save first created handle
    // away for futher use.

    l=GetWindowLong(hwndMain,OFFSET_FLAGS);
    if(l&FLAG_APPOWNED) {
	hAppOwned[PALETTE]=hddedata;
	}

    GlobalUnlock(hmem);

    return hddedata;

}

BOOL Execute(
HDDEDATA hData)
{
    LPSTR psz,psz2;
    BOOL fRet = FALSE;
    LONG cServerhConvs;
    int i;
    HANDLE hmem;
    HCONV FAR *pServerhConvs;

    psz = DdeAccessData(hData, NULL);

#ifdef WIN16
    if (!_fstricmp(psz, szExecDie)) {
#else
    if (!stricmp(psz, szExecDie)) {
#endif
	psz2=(LPSTR)-1;
	*psz;		   // GP Fault!
	fRet = TRUE;

#ifdef WIN16
    } else if (!_fstricmp(psz, szExecRefresh)) {
#else
    } else if (!stricmp(psz, szExecRefresh)) {
#endif

	if (!DdePostAdvise(GetThreadLong(GETCURRENTTHREADID(),OFFSET_IDINST), 0, 0)) {
	    DDEMLERROR("DdeStrs.Exe -- ERR DdePostAdvise failed\r\n");
        }
	fRet = TRUE;

#ifdef WIN16
    } else if (!_fstricmp(psz, szExecDisconnect)) {
#else
    } else if (!stricmp(psz, szExecDisconnect)) {
#endif

	cServerhConvs=(INT)GetThreadLong(GETCURRENTTHREADID(),OFFSET_CSERVERCONVS);
	hmem=(HANDLE)GetThreadLong(GETCURRENTTHREADID(),OFFSET_HSERVERCONVS);
	pServerhConvs=(HCONV FAR *)GlobalLock(hmem);

	for (i = 0; i < cServerhConvs; i++) {
            if (!DdeDisconnect(pServerhConvs[i])) {
		DDEMLERROR("DdeStrs.Exe -- ERR DdeDisconnect failed\r\n");
            }
	}

	GlobalUnlock(hmem);

	SetThreadLong(GETCURRENTTHREADID(),OFFSET_CSERVERCONVS,0L);
	UpdateCount(hwndMain,OFFSET_SERVER_CONNECT,PNT);
        fRet = TRUE;
    }
    DdeUnaccessData(hData);
    return(fRet);
}

VOID PaintServer(
HWND hwnd,
PAINTSTRUCT *pps)
{
    RECT rc;
    static CHAR szT[40];

    GetClientRect(hwnd, &rc);

    if (fServer) {
        rc.left += (rc.right - rc.left) >> 1;      // server info is on right half
    }
    rc.bottom = rc.top + cyText;

    wsprintf(szT, "%d server connections", GetThreadLong(GETCURRENTTHREADID(),OFFSET_CSERVERCONVS));
    DrawText(pps->hdc, szT, -1, &rc, DT_RIGHT);
    OffsetRect(&rc, 0, cyText);

    wsprintf(szT, "%d server count", GetWindowLong(hwnd,OFFSET_SERVER));
    DrawText(pps->hdc, szT, -1, &rc, DT_RIGHT);
    OffsetRect(&rc, 0, cyText);

}


HDDEDATA FAR PASCAL CustomCallback(
UINT wType,
UINT wFmt,
HCONV hConv,
HSZ hsz1,
HSZ hsz2,
HDDEDATA hData,
DWORD dwData1,
DWORD dwData2)
{
    LONG cServerhConvs,cClienthConvs;
    int i;
    HANDLE hmem;
    HCONV FAR *pServerhConvs;
    HCONV hC;
    HCONVLIST hConvList=0;
    DWORD dwid;
    LONG  lflags;


    dwid=GETCURRENTTHREADID();
    cServerhConvs=(INT)GetThreadLong(dwid,OFFSET_CSERVERCONVS);

    switch (wType) {
    case XTYP_CONNECT_CONFIRM:

        hmem=(HANDLE)GetThreadLong(dwid,OFFSET_HSERVERCONVS);
	pServerhConvs=(HCONV FAR *)GlobalLock(hmem);

	pServerhConvs[cServerhConvs] = hConv;
	cServerhConvs++;
        SetThreadLong(dwid,OFFSET_CSERVERCONVS,cServerhConvs);
	UpdateCount(hwndMain,OFFSET_SERVER_CONNECT,PNT);
	if (cServerhConvs >= MAX_SERVER_HCONVS) {
	    LOGDDEMLERROR("DdeStrs.Exe -- ERR-Number of connections > MAX\r\n");
	    cServerhConvs--;
            SetThreadLong(dwid,OFFSET_CSERVERCONVS,cServerhConvs);
	    UpdateCount(hwndMain,OFFSET_SERVER_CONNECT,PNT);
        }
        GlobalUnlock(hmem);
        break;

    case XTYP_DISCONNECT:

        if(fServer)
             {

             hmem=(HANDLE)GetThreadLong(dwid,OFFSET_HSERVERCONVS);
	     pServerhConvs=(HCONV FAR *)GlobalLock(hmem);

             for (i = 0; i < cServerhConvs; i++)
                 {

                 if (pServerhConvs[i] == hConv)
                     {
                     cServerhConvs--;
                     SetThreadLong(dwid,OFFSET_CSERVERCONVS,cServerhConvs);
                     UpdateCount(hwndMain,OFFSET_SERVER_CONNECT,PNT);

                     for (; i < cServerhConvs; i++)
                         {
                         pServerhConvs[i] = pServerhConvs[i+1];
                         }  // for

                     break;

                     }  // if pServerhConvs

                 }  // for i

             GlobalUnlock(hmem);

             } // fServer

        // If the server is shutting down the conversation then we need
        // to change our client connection count.  Remember that the
        // current conversation is valid until we return from this callback
        // so don't count the current conversation.

        if(fClient)
             {

             // *** Count Client Connections ****

             cClienthConvs = 0;
             hConvList=GetThreadLong(dwid,OFFSET_HCONVLIST);

             if (hConvList)
                 {
                 hC = 0;
                 while (hC = DdeQueryNextServer(hConvList, hC))
                     {
                     if (hC!=hConv) cClienthConvs++;
                     } // while

                 }  // if hConvList

             SetThreadLong(dwid,OFFSET_CCLIENTCONVS,cClienthConvs);

             }  // if fClient

        InvalidateRect(hwndMain, NULL, TRUE);

        break;

    case XTYP_REGISTER:
    case XTYP_UNREGISTER:
	lflags=GetWindowLong(hwndMain,OFFSET_FLAGS);
	if(fClient && (FLAG_STOP!=(lflags&FLAG_STOP)))
	    {
	    ReconnectList();
	    }
        break;
    }

    return(0);
}

BOOL Balance( INT itype ) {

     if(itype==OFFSET_SERVER) {
	  UpdateCount(hwndMain,OFFSET_SERVER,INC);
	  }
     else {
	  UpdateCount(hwndMain,OFFSET_CLIENT,INC);
	  }

     return TRUE;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\ddestrs\wrapper.h ===
/***************************************************************************\

   MODULE      : wrapper.h

   PURPOSE     : This is not a full program but a module you can include
                 in your code.  It implements a standard DDEML callback
                 function that allows you to have most of your DDE table
                 driven.  The default callback function handles all basic
                 System Topic information based on the tables you give
                 to this app.

   LIMITATIONS : This only supports servers that:
                 have only one service name
                 have enumerable topics and items
                 do not change the topics or items they support over time.

\***************************************************************************/


/*      TYPES           */

typedef BOOL	    (*CBFNIN)(HDDEDATA);
typedef HDDEDATA    (*CBFNOUT)(HDDEDATA);



/*  STRUCTURES  */

typedef struct _DDEFORMATTBL {
    LPSTR           pszFormat;
    UINT	    wFmt;
    UINT	    wFmtFlags;
    CBFNIN          lpfnPoke;
    CBFNOUT         lpfnRequest;
} DDEFORMATTBL;
typedef DDEFORMATTBL *PDDEFORMATTBL;
typedef DDEFORMATTBL FAR *LPDDEFORMATTBL;

typedef struct _DDEITEMTBL {
    LPSTR           pszItem;
    HSZ             hszItem;
    UINT	    cFormats;
    UINT	    wItemFlags;
    LPDDEFORMATTBL  fmt;
} DDEITEMTBL;
typedef DDEITEMTBL *PDDEITEMTBL;
typedef DDEITEMTBL FAR *LPDDEITEMTBL;


typedef struct _DDETOPICTBL {
    LPSTR           pszTopic;
    HSZ             hszTopic;
    UINT	    cItems;
    UINT	    wTopicFlags;
    LPDDEITEMTBL     item;
    CBFNIN          lpfnExecute;
} DDETOPICTBL;
typedef DDETOPICTBL *PDDETOPICTBL;
typedef DDETOPICTBL FAR *LPDDETOPICTBL;

typedef struct _DDESERVICETBL {
    LPSTR           pszService;
    HSZ             hszService;
    UINT	    cTopics;
    UINT	    wServiceFlags;
    LPDDETOPICTBL    topic;
} DDESERVICETBL;
typedef DDESERVICETBL *PDDESERVICETBL;
typedef DDESERVICETBL FAR *LPDDESERVICETBL;



/*      PROTOTYPES      */

BOOL InitializeDDE(PFNCALLBACK lpfnCustomCallback, LPDWORD pidInst,
    LPDDESERVICETBL AppSvcInfo,  DWORD dwFilterFlags, HANDLE hInst);

VOID UninitializeDDE(VOID);


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\src\client\dde.c ===
/***************************************************************************
 *                                                                         *
 *  MODULE      : dde.c                                                    *
 *                                                                         *
 *  PURPOSE     : Contains routines for handling of DDE interaction with   *
 *                DDEML.                                                   *
 *                                                                         *
 ***************************************************************************/
#include "ddemlcl.h"
#include <string.h>
#include <memory.h>
#include "infoctrl.h"

char szT[100];
    
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : CreateXactionWindow()                                      *
 *                                                                          *
 *  PURPOSE    : Creates a transaction window for the given transaction     *
 *               under the given conversation window.                       *
 *                                                                          *
 *  RETURNS    : TRUE  - If successful.                                     *
 *               FALSE - otherwise.                                         *
 *                                                                          *
 ****************************************************************************/
HWND CreateXactionWindow(
HWND hwndMDI,
XACT *pxact)
{
    PSTR pszFmt, pszItem;
    PSTR pData;
    HWND hwnd;
    
    pszItem = GetHSZName(pxact->hszItem);
    pszFmt = GetFormatName(pxact->wFmt);
    pData = GetTextData(pxact->hDdeData);

    /*
     *   type/opts ITEM retĿ    GWW_WUSER=pxact
     *                                            
     *                                            
     *                                            
     *                                            
     *                    DATA                    
     *                                            
     *                                            
     *                                            
     *                                            
     *   state/error FORMAT Result
     */
    hwnd = CreateInfoCtrl((LPSTR)pData,
            (int)SendMessage(hwndMDI, UM_GETNEXTCHILDX, 0, 0L),
            (int)SendMessage(hwndMDI, UM_GETNEXTCHILDY, 0, 0L),
            200, 100, hwndMDI, hInst,
            Type2String(pxact->wType, pxact->fsOptions), pszItem, NULL,
            "Starting", (LPSTR)pszFmt, NULL,
            ICSTY_SHOWFOCUS, 0, (DWORD)(LPSTR)pxact);
    MyFree(pszItem);
    MyFree(pszFmt);
    MyFree(pData);
    return(hwnd);
}




/****************************************************************************
 *                                                                          *
 *  FUNCTION   : ProcessTransaction()                                       *
 *                                                                          *
 *  PURPOSE    : Processes synchronous transactions entirely and starts     *
 *               async transactions.  Transaction attempts result in a      *
 *               transaction window being created which displays the state  *
 *               or results of the transaction.  (the callback function     *
 *               updates these windows as it gets calls) Transaction        *
 *               windows stay around until abandoned by the user or until   *
 *               the conversation is disconnected.  Advise Data and Advise  *
 *               Stop transactions are special.  We don't create a new      *
 *               window if the associated advise start transaction window   *
 *               can be found.                                              *
 *                                                                          *
 *  RETURNS    : TRUE  - If successful.                                     *
 *               FALSE - otherwise.                                         *
 *                                                                          *
 ****************************************************************************/
BOOL ProcessTransaction(
XACT *pxact)
{
    CONVINFO ci;
    HWND hwndInfoCtrl = 0;
    
    /* create transaction window to show we tried (except in ADVSTOP case) */
    
    pxact = (XACT *)memcpy(MyAlloc(sizeof(XACT)), (PSTR)pxact, sizeof(XACT));
    ci.cb = sizeof(CONVINFO);
    DdeQueryConvInfo(pxact->hConv, (DWORD)QID_SYNC, &ci); // ci.hUser==hConv
    if (pxact->wType == XTYP_ADVSTOP) {
        hwndInfoCtrl = FindAdviseChild((HWND)ci.hUser, pxact->hszItem,
                pxact->wFmt);
        if (hwndInfoCtrl) {
            SendMessage(hwndInfoCtrl, ICM_SETSTRING, ICSID_UL,
                    (DWORD)(LPSTR)Type2String(pxact->wType, pxact->fsOptions));
            DdeFreeStringHandle(idInst, pxact->hszItem);
        }
    }
    /*
     * If we still need to create a transaction window, do so here.
     */
    if (!hwndInfoCtrl) {
        hwndInfoCtrl = CreateXactionWindow((HWND)ci.hUser, pxact);
        if (!hwndInfoCtrl) {
            MyFree(pxact);
            return 0;
        }
        SetFocus(hwndInfoCtrl);
    }
    /*
     * Disable callbacks for this conversation now if the XOPT_DISABLEFIRST
     * option is set.  This tests disabling asynchronous transactions
     * before they are completed.
     */
    if (pxact->fsOptions & XOPT_DISABLEFIRST) 
        DdeEnableCallback(idInst, pxact->hConv, EC_DISABLE);
    /*
     * Adjust the timeout for asynchronous transactions.
     */
    if (pxact->fsOptions & XOPT_ASYNC)
	pxact->ulTimeout = (DWORD)TIMEOUT_ASYNC;

    /*
     * start transaction with DDEML here
     */
    pxact->ret = DdeClientTransaction((LPBYTE)pxact->hDdeData, (DWORD)-1,
            pxact->hConv, pxact->hszItem, pxact->wFmt,
            pxact->wType,
            pxact->ulTimeout, (LPDWORD)&pxact->Result);
            
    /*
     * show return value in transaction window
     */
    wsprintf(szT, "ret=%lx", pxact->ret);
    SendMessage(hwndInfoCtrl, ICM_SETSTRING, ICSID_UR, (DWORD)(LPSTR)szT);

    /*
     * show result or ID value in transaction window
     */
    wsprintf(szT, pxact->fsOptions & XOPT_ASYNC ? "ID=%ld" :
            "result=0x%lx", pxact->Result);
    SendMessage(hwndInfoCtrl, ICM_SETSTRING, ICSID_LR, (DWORD)(LPSTR)szT);
    
    if ((pxact->fsOptions & XOPT_ASYNC) && pxact->ret) {
        /*
         * asynchronous successful start - link transaction to window.
         */
        DdeSetUserHandle(pxact->hConv, pxact->Result, (DWORD)hwndInfoCtrl);

        /*
         * Abandon started async transaction after initiated if
         * XOPT_ABANDONAFTERSTART is chosen.  This tests the mid-transaction
         * abandoning code.
         */
        if (pxact->fsOptions & XOPT_ABANDONAFTERSTART) 
            DdeAbandonTransaction(idInst, pxact->hConv, pxact->Result);
        /*
         * show actual status
         */
        ci.cb = sizeof(CONVINFO);
        DdeQueryConvInfo(pxact->hConv, pxact->Result, &ci);
        SendMessage(hwndInfoCtrl, ICM_SETSTRING, ICSID_LL,
                (DWORD)(LPSTR)State2String(ci.wConvst));
    } else {
        /*
         * Synchronous transactions are completed already so pass on to
         * CompleteTransaction right away.
         */
        CompleteTransaction(hwndInfoCtrl, pxact);
    }
    return TRUE;
}





/****************************************************************************
 *                                                                          *
 *  FUNCTION   : CompleteTransaction()                                      *
 *                                                                          *
 *  PURPOSE    : This handles completed synchronous and asynchronous        *
 *               transactions as well as failed attempted transactions.     *
 *                                                                          *
 *  RETURNS    : TRUE  - If successful.                                     *
 *               FALSE - otherwise.                                         *
 *                                                                          *
 ****************************************************************************/
VOID CompleteTransaction(
HWND hwndInfoCtrl,
XACT *pxact)
{
    PSTR psz;
    
    if (pxact->ret) {
        /*
         * Successful transaction case
         */
        SendMessage(hwndInfoCtrl, ICM_SETSTRING, ICSID_LL,
                (DWORD)(LPSTR)"Completed");
    
        if (pxact->wType == XTYP_REQUEST) {
            /*
             * Show resulting data
             */
            psz = GetTextData((HDDEDATA)pxact->ret);
            SendMessage(hwndInfoCtrl, ICM_SETSTRING, ICSID_CENTER,
                    (DWORD)(LPSTR)psz);
            MyFree(psz);
            /*
             * free returned data since it is displayed.
             */
            DdeFreeDataHandle(pxact->ret);
            pxact->ret = 0L;
            SendMessage(hwndInfoCtrl, ICM_SETSTRING, ICSID_UR, NULL);
        }
    } else {
        /*
         * failed - show error result.
         */
        SendMessage(hwndInfoCtrl, ICM_SETSTRING, ICSID_LL,
                (DWORD)(LPSTR)Error2String(DdeGetLastError(idInst)));
    }
    pxact->fsOptions |= XOPT_COMPLETED;
}




/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DdeCallback()                                              *
 *                                                                          *
 *  PURPOSE    : This handles all callbacks from the DDEML.  This handles   *
 *               updating of the associated conversation and any special    *
 *               testing cases such as blocking callbacks etc.              *
 *                                                                          *
 *               For the most part, clients only handle advise data and     *
 *               asynchronous transaction completion here.                  *
 *                                                                          *
 *  RETURNS    : Results vary depending on transaction type.                *
 *                                                                          *
 ****************************************************************************/
HDDEDATA EXPENTRY DdeCallback(
WORD wType,
WORD wFmt,
HCONV hConv,
HSZ hsz1,
HSZ hsz2,
HDDEDATA hData,
DWORD lData1,
DWORD lData2)
{
    HWND hwnd;
    CONVINFO ci;
    XACT *pxact;

    if (hConv) {
        /*
         * update conversation status if it changed.
         */
        MYCONVINFO *pmci;
        
        ci.cb = sizeof(CONVINFO);
	if (!DdeQueryConvInfo(hConv,(DWORD) QID_SYNC, &ci) || (!IsWindow((HWND)ci.hUser))) {
            /*
             * This conversation does not yet have a corresponding MDI window
             * or is disconnected.
             */
            return 0;
        }
        if (pmci = (MYCONVINFO *)GetWindowWord((HWND)ci.hUser, 0)) {
            if (pmci->ci.wStatus != ci.wStatus ||
                    pmci->ci.wConvst != ci.wConvst ||
                    pmci->ci.wLastError != ci.wLastError) {
                /*
                 * Things have changed, updated the conversation window.
                 */
                InvalidateRect((HWND)ci.hUser, NULL, TRUE);
            }
            if (ci.wConvst & ST_INLIST) {
                /*
                 * update the associated list window (if any) as well.
                 */
                if (hwnd = FindListWindow(ci.hConvList))
                    InvalidateRect(hwnd, NULL, TRUE);
            }
        }
    }

    /*
     * handle special block on next callback option here.  This demonstrates
     * the CBR_BLOCK feature.
     */
    if (fBlockNextCB && !(wType & XTYPF_NOBLOCK)) {
        fBlockNextCB = FALSE;
        return(CBR_BLOCK);
    }

    /*
     * handle special termination here.  This demonstrates that at any time
     * a client can drop a conversation.
     */
    if (fTermNextCB && hConv && wType != XTYP_DISCONNECT) {
        fTermNextCB = FALSE;
        MyDisconnect(hConv);
        return(0);
    }

    /*
     * Now we begin sort out what to do.
     */
    switch (wType) {
    case XTYP_REGISTER:
    case XTYP_UNREGISTER:
        /*
         * This is where the client would insert code to keep track of
         * what servers are available.  This could cause the initiation
         * of some conversations.
         */
        break;

    case XTYP_DISCONNECT:
        if (fAutoReconnect) {
            /*
             * attempt a reconnection
             */
            if (hConv = DdeReconnect(hConv)) {
                AddConv(ci.hszServiceReq, ci.hszTopic, hConv, FALSE);
                return 0;
            }
        }
        
        /*
         * update conv window to show its new state.
         */
        SendMessage((HWND)ci.hUser, UM_DISCONNECTED, 0, 0);
        return 0;
        break;

    case XTYP_ADVDATA:
        /*
         * data from an active advise loop (from a server)
         */
        Delay(wDelay);
        hwnd = FindAdviseChild((HWND)ci.hUser, hsz2, wFmt);
        if (!IsWindow(hwnd)) {
            PSTR pszItem, pszFmt;
            /*
             * AdviseStart window is gone, make a new one.
             */
            pxact = (XACT *)MyAlloc(sizeof(XACT));
            pxact->wType = wType;
            pxact->hConv = hConv;
            pxact->wFmt = wFmt;
            pxact->hszItem = hsz2;
            DdeKeepStringHandle(idInst, hsz2);
            
            pszItem = GetHSZName(hsz2);
            pszFmt = GetFormatName(wFmt);
            
            hwnd = CreateInfoCtrl(NULL, 
                    (int)SendMessage((HWND)ci.hUser, UM_GETNEXTCHILDX, 0, 0L),
                    (int)SendMessage((HWND)ci.hUser, UM_GETNEXTCHILDY, 0, 0L),
                    200, 100,
                    (HWND)ci.hUser, hInst,
                    Type2String(wType, 0), (LPSTR)pszItem, NULL,
                    NULL, (LPSTR)pszFmt, NULL,
                    ICSTY_SHOWFOCUS, 0, (DWORD)(LPSTR)pxact);
                    
            MyFree(pszFmt);
            MyFree(pszItem);

            if (!IsWindow(hwnd))
                return(DDE_FNOTPROCESSED); 
        }
        if (!hData) {
            /*
             * XTYPF_NODATA case - request the info. (we do this synchronously
             * for simplicity)
             */
            hData = DdeClientTransaction(NULL, 0L, hConv, hsz2, wFmt,
                    XTYP_REQUEST, DefTimeout, NULL);
        }
        if (hData) {
            PSTR pData;
            /*
             * Show incomming data on corresponding transaction window.
             */
            pData = GetTextData(hData);
            SendMessage(hwnd, ICM_SETSTRING, ICSID_CENTER, (DWORD)(LPSTR)pData);
            MyFree(pData);
            DdeFreeDataHandle(hData);
        }
        SendMessage(hwnd, ICM_SETSTRING, ICSID_LL, (DWORD)(LPSTR)"Advised");
        return(DDE_FACK);
        break;
        
    case XTYP_XACT_COMPLETE:
        /*
         * An asynchronous transaction has completed.  Show the results.
         *
         * ...unless the XOPT_BLOCKRESULT is chosen.
         */
        
        ci.cb = sizeof(CONVINFO);
        if (DdeQueryConvInfo(hConv, lData1, &ci) &&
                IsWindow((HWND)ci.hUser) && 
                (pxact = (XACT *)GetWindowWord((HWND)ci.hUser, GWW_WUSER))) {
                
            if (pxact->fsOptions & XOPT_BLOCKRESULT) {
                pxact->fsOptions &= ~XOPT_BLOCKRESULT;
                return(CBR_BLOCK);
            }
            
            pxact->Result = lData2;
            pxact->ret = hData;
            CompleteTransaction((HWND)ci.hUser, pxact);
        }
        break;
    }
}







/****************************************************************************
 *                                                                          *
 *  FUNCTION   : FindAdviseChild()                                          *
 *                                                                          *
 *  PURPOSE    : Search through the child windows of hwndMDI for an info    *
 *               ctrl that has the same Item and format and is an           *
 *               ADVSTART ADVSTOP or ADVDATA transaction window.            *
 *                                                                          *
 *               We use these to show the associated advise data.           *
 *                                                                          *
 *  RETURNS    : The transaction window handle or 0 on failure.             *
 *                                                                          *
 ****************************************************************************/
HWND FindAdviseChild(
HWND hwndMDI,
HSZ hszItem,
WORD wFmt)
{
    HWND hwnd, hwndStart;
    XACT *pxact;

    if (!IsWindow(hwndMDI))
        return 0;
    
    hwnd = hwndStart = GetWindow(hwndMDI, GW_CHILD);
    while (hwnd && IsChild(hwndMDI, hwnd)) {
        pxact = (XACT *)GetWindowWord(hwnd, GWW_WUSER);
        if (pxact &&
                (pxact)->wFmt == wFmt &&
                (pxact)->hszItem == hszItem &&
                (
                    ((pxact->wType & XTYP_ADVSTART) == XTYP_ADVSTART) ||
                    (pxact->wType == XTYP_ADVSTOP) ||
                    (pxact->wType == XTYP_ADVDATA)
                )
           ) {
            return(hwnd);
        }
        hwnd = GetWindow(hwnd, GW_HWNDNEXT);
        if (hwnd == hwndStart) 
            return 0;
    }
    return 0;
}



/****************************************************************************
 *                                                                          *
 *  FUNCTION   : FindListWindow()                                           *
 *                                                                          *
 *  PURPOSE    : Locates the list window associated with this conversation  *
 *               list.                                                      *
 *                                                                          *
 *  RETURNS    : The window handle of the list window or 0 on failure.      *
 *                                                                          *
 ****************************************************************************/
HWND FindListWindow(
HCONVLIST hConvList)
{
    HWND hwnd;
    MYCONVINFO *pmci;
    
    hwnd = GetWindow(hwndMDIClient, GW_CHILD);
    while (hwnd) {
        pmci = (MYCONVINFO *)GetWindowWord(hwnd, 0);
        if (pmci->fList && pmci->hConv == hConvList)
            return(hwnd);
        hwnd = GetWindow(hwnd, GW_HWNDNEXT);
    }
    return 0;
}




/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GetTextData()                                              *
 *                                                                          *
 *  PURPOSE    : Allocates and returns a pointer to the data contained in   *
 *               hData.  This assumes that hData points to text data and    *
 *               will properly handle huge text data by leaving out the     *
 *               middle of the string and placing the size of the string    *
 *               into this string portion.                                  *
 *                                                                          *
 *  RETURNS    : A pointer to the allocated string.                         *
 *                                                                          *
 ****************************************************************************/
PSTR GetTextData(
HDDEDATA hData)
{
    PSTR psz;
    DWORD cb;

#define CBBUF  1024

    if (hData == NULL) {
        return(NULL);
    }
    
    cb = DdeGetData(hData, NULL, 0, 0);
    if (!hData || !cb)
        return NULL;

    if (cb > CBBUF) {                // possibly HUGE object!
        psz = MyAlloc(CBBUF);
        DdeGetData(hData, psz, CBBUF - 46, 0L);
        wsprintf(&psz[CBBUF - 46], "<---Size=%ld", cb);
    } else {
        psz = MyAlloc((WORD)cb);
        DdeGetData(hData, (LPBYTE)psz, cb, 0L);
    }
    return psz;
#undef CBBUF    
}






 
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MyGetClipboardFormatName()                                 *
 *                                                                          *
 *  PURPOSE    : Properly retrieves the string associated with a clipboard  *
 *               format.  If the format does not have a string associated   *
 *               with it, the string #dddd is returned.                     *
 *                                                                          *
 *  RETURNS    : The number of characters copied into lpstr or 0 on error.  *
 *                                                                          *
 ****************************************************************************/
int MyGetClipboardFormatName(
WORD fmt,
LPSTR lpstr,
int cbMax)
{
    if (fmt < 0xc000) {
        // predefined or integer format - just get the atom string
        // wierdly enough, GetClipboardFormatName() doesn't support this.
        return(GlobalGetAtomName(fmt, lpstr, cbMax));
    } else {
        return(GetClipboardFormatName(fmt, lpstr, cbMax));
    }
}





/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GetFormatName()                                            *
 *                                                                          *
 *  PURPOSE    : allocates and returns a pointer to a string representing   *
 *               a format.  Use MyFree() to free this string.               *
 *                                                                          *
 *  RETURNS    : The number of characters copied into lpstr or 0 on error.  *
 *                                                                          *
 ****************************************************************************/
PSTR GetFormatName(
WORD wFmt)
{
    PSTR psz;
    WORD cb;

    if (wFmt == 1) {
        psz = MyAlloc(8);
        strcpy(psz, "CF_TEXT");
        return psz;
    }
    psz = MyAlloc(255);
    *psz = '\0';
    cb = GetClipboardFormatName(wFmt, psz, 255) + 1;
    return((PSTR)LocalReAlloc((HANDLE)psz, cb, LMEM_MOVEABLE));
}




/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MyDisconnect()                                             *
 *                                                                          *
 *  PURPOSE    : Disconnects the given conversation after updating the      *
 *               associated conversation window.                            *
 *                                                                          *
 *  RETURNS    : TRUE on success, FALSE on failuer.                         *
 *                                                                          *
 ****************************************************************************/
BOOL MyDisconnect(
HCONV hConv)
{
    CONVINFO ci;
    HWND hwnd;
    // before we disconnect, invalidate the associated list window - if
    // applicable.

    ci.cb = sizeof(CONVINFO);
    
    if (DdeQueryConvInfo(hConv, (DWORD)QID_SYNC, &ci) && ci.hConvList &&
            (hwnd = FindListWindow(ci.hConvList)))
        InvalidateRect(hwnd, NULL, TRUE);
    return(DdeDisconnect(hConv));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\src\client\ddemlcl.c ===
/***************************************************************************
 *                                                                         *
 *  PROGRAM	: ddemlcl.c						    *
 *                                                                         *
 *  PURPOSE     : To demonstrate how to use the DDEML library from the     *
 *                client side and for basic testing of the DDEML API.      *
 *                                                                         *
 ***************************************************************************/

#include "ddemlcl.h"
#include <string.h>
#include <memory.h>
#include "infoctrl.h"

/* global variables used in this module or among more than one module */
CONVCONTEXT CCFilter = { sizeof(CONVCONTEXT), 0, 0, 0, 0L, 0L };
DWORD idInst = 0;
HANDLE hInst;                       /* Program instance handle               */
HANDLE hAccel;                      /* Main accelerator resource             */
HWND hwndFrame           = NULL;    /* Handle to main window                 */
HWND hwndMDIClient       = NULL;    /* Handle to MDI client                  */
HWND hwndActive          = NULL;    /* Handle to currently activated child   */
LONG DefTimeout      = DEFTIMEOUT;  /* default synchronous transaction timeout */
WORD wDelay = 0;
BOOL fBlockNextCB = FALSE;     /* set if next callback causes a CBR_BLOCK    */
BOOL fTermNextCB = FALSE;      /* set to call DdeDisconnect() on next callback */
BOOL fAutoReconnect = FALSE;   /* set if DdeReconnect() is to be called on XTYP_DISCONNECT callbacks */
WORD fmtLink = 0;                   /* link clipboard format number          */
WORD DefOptions = 0;                /* default transaction optons            */
OWNED aOwned[MAX_OWNED];            /* list of all owned handles.            */
WORD cOwned = 0;                    /* number of existing owned handles.     */
FILTERPROC *lpMsgFilterProc;	    /* instance proc from MSGF_DDEMGR filter */


 /*
 * This is the array of formats we support
 */
FORMATINFO aFormats[] = {
    { CF_TEXT, "CF_TEXT" },       // exception!  predefined format
    { 0, "Dummy1"  },
    { 0, "Dummy2"  },
};

/* Forward declarations of helper functions in this module */
VOID NEAR PASCAL CloseAllChildren(VOID);
VOID NEAR PASCAL InitializeMenu (HANDLE);
VOID NEAR PASCAL CommandHandler (HWND,WORD);
VOID NEAR PASCAL SetWrap (HWND,BOOL);

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : WinMain(HANDLE, HANDLE, LPSTR, int)                        *
 *                                                                          *
 *  PURPOSE    : Creates the "frame" window, does some initialization and   *
 *               enters the message loop.                                   *
 *                                                                          *
 ****************************************************************************/
int PASCAL WinMain(hInstance, hPrevInstance, lpszCmdLine, nCmdShow)

HANDLE hInstance;
HANDLE hPrevInstance;
LPCSTR  lpszCmdLine;
int    nCmdShow;
{
    MSG msg;

    hInst = hInstance;

    /* If this is the first instance of the app. register window classes */
    if (!hPrevInstance){
        if (!InitializeApplication ())
            return 0;
    }

    /* Create the frame and do other initialization */
    if (!InitializeInstance(nCmdShow))
        return 0;

    /* Enter main message loop */
    while (GetMessage (&msg, NULL, 0, 0)){
	(*lpMsgFilterProc)(MSGF_DDEMGR, 0, (LONG)(LPMSG)&msg);
    }

    // free up any appowned handles
    while (cOwned) {
        DdeFreeDataHandle(aOwned[--cOwned].hData);
    }
    DdeUninitialize(idInst);

    UnhookWindowsHook(WH_MSGFILTER, (FARPROC)lpMsgFilterProc);
    FreeProcInstance((FARPROC)lpMsgFilterProc);

    return 0;
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : FrameWndProc (hwnd, msg, wParam, lParam )                  *
 *                                                                          *
 *  PURPOSE    : The window function for the "frame" window, which controls *
 *               the menu and encompasses all the MDI child windows. Does   *
 *               the major part of the message processing. Specifically, in *
 *               response to:                                               *
 *                                                                          *
 ****************************************************************************/
LONG FAR PASCAL FrameWndProc ( hwnd, msg, wParam, lParam )

register HWND    hwnd;
UINT		 msg;
register WPARAM    wParam;
LPARAM		   lParam;

{
    switch (msg){
        case WM_CREATE:{
            CLIENTCREATESTRUCT ccs;

            /* Find window menu where children will be listed */
            ccs.hWindowMenu = GetSubMenu (GetMenu(hwnd),WINDOWMENU);
            ccs.idFirstChild = IDM_WINDOWCHILD;

            /* Create the MDI client filling the client area */
            hwndMDIClient = CreateWindow ("mdiclient",
                                          NULL,
                                          WS_CHILD | WS_CLIPCHILDREN |
                                          WS_VSCROLL | WS_HSCROLL,
                                          0,
                                          0,
                                          0,
                                          0,
                                          hwnd,
                                          0xCAC,
                                          hInst,
                                          (LPSTR)&ccs);


            ShowWindow (hwndMDIClient,SW_SHOW);
            break;
        }

        case WM_INITMENU:
            InitializeMenu ((HMENU)wParam);
            break;

        case WM_COMMAND:
            CommandHandler (hwnd,wParam);
            break;

        case WM_CLOSE:
            CloseAllChildren();
            DestroyWindow(hwnd);
            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        default:
            /*  use DefFrameProc() instead of DefWindowProc() since there
             *  are things that have to be handled differently because of MDI
             */
            return DefFrameProc (hwnd,hwndMDIClient,msg,wParam,lParam);
    }
    return 0;
}





/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MDIChildWndProc                                            *
 *                                                                          *
 *  PURPOSE    : The window function for the "child" conversation and list  *
 *               windows.                                                   *
 *                                                                          *
 ****************************************************************************/
LONG FAR PASCAL MDIChildWndProc( hwnd, msg, wParam, lParam )
register HWND   hwnd;
UINT		msg;
register WPARAM   wParam;
LPARAM		  lParam;
{
    MYCONVINFO *pmci;
    RECT rc;

    switch (msg){
    case WM_CREATE:
        /*
         * Create a coresponding conversation info structure to link this
         * window to the conversation or conversation list it represents.
         *
         * lParam: points to the conversation info to initialize our copy to.
         */
        pmci = (MYCONVINFO *)MyAlloc(sizeof(MYCONVINFO));
        if (pmci != NULL) {
            _fmemcpy(pmci,
                    (LPSTR)((LPMDICREATESTRUCT)((LPCREATESTRUCT)lParam)->lpCreateParams)->lParam,
                    sizeof(MYCONVINFO));
            pmci->hwndXaction = 0;              /* no current transaction yet */
            pmci->x = pmci->y = 0;              /* new transaction windows start here */
            DdeKeepStringHandle(idInst, pmci->hszTopic);/* keep copies of the hszs for us */
            DdeKeepStringHandle(idInst, pmci->hszApp);

             // link hConv and hwnd together
            SetWindowWord(hwnd, 0, (WORD)pmci);

            /*
             * non-list windows link the conversations to the windows via the
             * conversation user handle.
             */
            if (!pmci->fList)
		DdeSetUserHandle(pmci->hConv, (DWORD)QID_SYNC, (DWORD)hwnd);
        }
        goto CallDCP;
        break;

    case UM_GETNEXTCHILDX:
    case UM_GETNEXTCHILDY:
        /*
         * Calculate the next place to put the next transaction window.
         */
        {
            pmci = (MYCONVINFO *)GetWindowWord(hwnd, 0);
            GetClientRect(hwnd, &rc);
            if (msg == UM_GETNEXTCHILDX) {
                pmci->x += 14;
                if (pmci->x > (rc.right - 200 - rc.left))
                    pmci->x = 0;
                return(pmci->x);
            } else {
                pmci->y += 12;
                if (pmci->y > (rc.bottom - 100 - rc.top))
                    pmci->y = 0;
                return(pmci->y);
            }
        }
        break;

    case UM_DISCONNECTED:
        /*
         * Disconnected conversations can't have any transactions so we
         * remove all the transaction windows here to show whats up.
         */
        {
            HWND hwndT;
            while (hwndT = GetWindow(hwnd, GW_CHILD))
                DestroyWindow(hwndT);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        break;

    case WM_DESTROY:
        /*
         * Cleanup our conversation info structure, and disconnect all
         * conversations associated with this window.
         */
        pmci = (MYCONVINFO *)GetWindowWord(hwnd, 0);
        pmci->hwndXaction = 0;      /* clear this to avoid focus problems */
        if (pmci->hConv) {
            if (pmci->fList) {
                DdeDisconnectList((HCONVLIST)pmci->hConv);
            } else {
                MyDisconnect(pmci->hConv);
            }
        }
        DdeFreeStringHandle(idInst, pmci->hszTopic);
        DdeFreeStringHandle(idInst, pmci->hszApp);
        MyFree(pmci);
        goto CallDCP;
        break;

    case WM_SETFOCUS:
        /*
         * This catches focus changes caused by dialogs.
         */
        wParam = TRUE;
        // fall through

    case WM_MDIACTIVATE:
        hwndActive = wParam ? hwnd : NULL;
        pmci = (MYCONVINFO *)GetWindowWord(hwnd, 0);
        /*
         * pass the focus onto the current transaction window.
         */
        if (wParam && IsWindow(pmci->hwndXaction))
            SetFocus(pmci->hwndXaction);
        break;

    case ICN_HASFOCUS:
        /*
         * update which transaction window is the main one.
         */
        pmci = (MYCONVINFO *)GetWindowWord(hwnd, 0);
        pmci->hwndXaction = wParam ? HIWORD(lParam) : NULL;
        break;

    case ICN_BYEBYE:
        /*
         * Transaction window is closing...
         *
         * wParam = hwndXact
         * lParam = lpxact
         */
        pmci = (MYCONVINFO *)GetWindowWord(hwnd, 0);
        {
            XACT *pxact;

            pxact = (XACT *)LOWORD(lParam);
            /*
             * If this transaction is active, abandon it first.
             */
            if (pxact->fsOptions & XOPT_ASYNC &&
                    !(pxact->fsOptions & XOPT_COMPLETED)) {
                DdeAbandonTransaction(idInst, pmci->hConv, pxact->Result);
            }
            /*
             * release resources associated with transaction.
             */
            DdeFreeStringHandle(idInst, pxact->hszItem);
            MyFree((PSTR)pxact);
            /*
             * Locate next apropriate transaction window to get focus.
             */
            if (!pmci->hwndXaction || pmci->hwndXaction == wParam)
                pmci->hwndXaction = GetWindow(hwnd, GW_CHILD);
            if (pmci->hwndXaction == wParam)
                pmci->hwndXaction = GetWindow(wParam, GW_HWNDNEXT);
            if (pmci->hwndXaction == wParam ||
                    !IsWindow(pmci->hwndXaction) ||
                    !IsChild(hwnd, pmci->hwndXaction))
                pmci->hwndXaction = NULL;
            else
                SetFocus(pmci->hwndXaction);
        }
        break;

    case WM_PAINT:
        /*
         * Paint this conversation's related information.
         */
        pmci = (MYCONVINFO *)GetWindowWord(hwnd, 0);
        {
            PAINTSTRUCT ps;
            PSTR psz;

            BeginPaint(hwnd, &ps);
            SetBkMode(ps.hdc, TRANSPARENT);
            psz = pmci->fList ? GetConvListText(pmci->hConv) :
                    GetConvInfoText(pmci->hConv, &pmci->ci);
            if (psz) {
                GetClientRect(hwnd, &rc);
                DrawText(ps.hdc, psz, -1, &rc,
                        DT_WORDBREAK | DT_LEFT | DT_NOPREFIX | DT_TABSTOP);
                MyFree(psz);
            }
            EndPaint(hwnd, &ps);
        }
        break;

    case WM_QUERYENDSESSION:
        return TRUE;

    default:
CallDCP:
        /* Again, since the MDI default behaviour is a little different,
         * call DefMDIChildProc instead of DefWindowProc()
         */
        return DefMDIChildProc (hwnd, msg, wParam, lParam);
    }
    return FALSE;
}


/****************************************************************************
 *                                                                          *
 *  FUNCTION   : Initializemenu ( hMenu )                                   *
 *                                                                          *
 *  PURPOSE    : Sets up greying, enabling and checking of main menu items  *
 *               based on the app's state.                                  *
 *                                                                          *
 ****************************************************************************/
VOID NEAR PASCAL InitializeMenu ( hmenu )
register HANDLE hmenu;
{
    BOOL fLink      = FALSE; // set if Link format is on the clipboard;
    BOOL fAny       = FALSE; // set if hwndActive exists
    BOOL fList      = FALSE; // set if hwndActive is a list window
    BOOL fConnected = FALSE; // set if hwndActive is a connection conversation.
    BOOL fXaction   = FALSE; // set if hwndActive has a selected transaction window
    BOOL fXactions  = FALSE; // set if hwndActive contains transaction windows
    BOOL fBlocked   = FALSE; // set if hwndActive conversation is blocked.
    BOOL fBlockNext = FALSE; // set if handActive conversation is blockNext.
    MYCONVINFO *pmci = NULL;

    if (OpenClipboard(hwndFrame)) {
        fLink = (IsClipboardFormatAvailable(fmtLink));
        CloseClipboard();
    }

    if (fAny = (IsWindow(hwndActive) &&
            (pmci = (MYCONVINFO *)GetWindowWord(hwndActive, 0)))) {
        fXactions = GetWindow(hwndActive, GW_CHILD);
        if (!(fList = pmci->fList)) {
            CONVINFO ci;

            ci.cb = sizeof(CONVINFO);
	    DdeQueryConvInfo(pmci->hConv, (DWORD)QID_SYNC, &ci);
	    fConnected = (BOOL)(ci.wStatus & ST_CONNECTED);
            fXaction = IsWindow(pmci->hwndXaction);
            fBlocked = ci.wStatus & ST_BLOCKED;
            fBlockNext = ci.wStatus & ST_BLOCKNEXT;
        }
    }

    EnableMenuItem(hmenu,   IDM_EDITPASTE,
            fLink           ? MF_ENABLED    : MF_GRAYED);

    // IDM_CONNECTED - always enabled.

    EnableMenuItem(hmenu,   IDM_RECONNECT,
            fList           ? MF_ENABLED    : MF_GRAYED);

    EnableMenuItem (hmenu,  IDM_DISCONNECT,
            fConnected      ? MF_ENABLED    : MF_GRAYED);

    EnableMenuItem (hmenu,  IDM_TRANSACT,
            fConnected      ? MF_ENABLED    : MF_GRAYED);

    EnableMenuItem(hmenu,   IDM_ABANDON,
            fXaction        ? MF_ENABLED    : MF_GRAYED);

    EnableMenuItem(hmenu,   IDM_ABANDONALL,
            fXactions ? MF_ENABLED : MF_GRAYED);


    EnableMenuItem (hmenu,  IDM_BLOCKCURRENT,
            fConnected && !fBlocked ? MF_ENABLED    : MF_GRAYED);
    CheckMenuItem(hmenu, IDM_BLOCKCURRENT,
            fBlocked        ? MF_CHECKED    : MF_UNCHECKED);

    EnableMenuItem (hmenu,  IDM_ENABLECURRENT,
            fConnected && (fBlocked || fBlockNext) ? MF_ENABLED : MF_GRAYED);
    CheckMenuItem(hmenu,    IDM_ENABLECURRENT,
            !fBlocked       ? MF_CHECKED    : MF_UNCHECKED);

    EnableMenuItem (hmenu,  IDM_ENABLEONECURRENT,
            fConnected && (fBlocked) ? MF_ENABLED : MF_GRAYED);
    CheckMenuItem(hmenu,    IDM_ENABLEONECURRENT,
            fBlockNext      ? MF_CHECKED    : MF_UNCHECKED);

    EnableMenuItem (hmenu,  IDM_BLOCKALLCBS,
            fAny            ? MF_ENABLED    : MF_GRAYED);

    EnableMenuItem (hmenu,  IDM_ENABLEALLCBS,
            fAny            ? MF_ENABLED    : MF_GRAYED);

    EnableMenuItem (hmenu,  IDM_ENABLEONECB,
            fAny            ? MF_ENABLED    : MF_GRAYED);

    EnableMenuItem(hmenu,   IDM_BLOCKNEXTCB,
            fAny || fBlockNextCB ? MF_ENABLED    : MF_GRAYED);
    CheckMenuItem(hmenu,    IDM_BLOCKNEXTCB,
            fBlockNextCB    ? MF_CHECKED    : MF_UNCHECKED);

    EnableMenuItem(hmenu,   IDM_TERMNEXTCB,
            fAny || fTermNextCB ? MF_ENABLED    : MF_GRAYED);
    CheckMenuItem(hmenu,    IDM_TERMNEXTCB,
            fTermNextCB     ? MF_CHECKED    : MF_UNCHECKED);

    // IDM_DELAY - always enabled.

    // IDM_TIMEOUT - alwasy enabled.

    EnableMenuItem (hmenu,  IDM_WINDOWTILE,
            fAny            ? MF_ENABLED    : MF_GRAYED);

    EnableMenuItem (hmenu,  IDM_WINDOWCASCADE,
            fAny            ? MF_ENABLED    : MF_GRAYED);

    EnableMenuItem (hmenu,  IDM_WINDOWICONS,
            fAny            ? MF_ENABLED    : MF_GRAYED);

    EnableMenuItem (hmenu,  IDM_WINDOWCLOSEALL,
            fAny            ? MF_ENABLED    : MF_GRAYED);

    EnableMenuItem (hmenu,  IDM_XACTTILE,
            fXactions       ? MF_ENABLED    : MF_GRAYED);

    EnableMenuItem (hmenu,  IDM_XACTCASCADE,
            fXactions       ? MF_ENABLED    : MF_GRAYED);

    CheckMenuItem(hmenu,   IDM_AUTORECONNECT,
            fAutoReconnect  ? MF_CHECKED    : MF_UNCHECKED);

    // IDM_HELPABOUT - always enabled.
}



/****************************************************************************
 *                                                                          *
 *  FUNCTION   : CloseAllChildren ()                                        *
 *                                                                          *
 *  PURPOSE    : Destroys all MDI child windows.                            *
 *                                                                          *
 ****************************************************************************/
VOID NEAR PASCAL CloseAllChildren ()
{
    register HWND hwndT;

    /* hide the MDI client window to avoid multiple repaints */
    ShowWindow(hwndMDIClient,SW_HIDE);

    /* As long as the MDI client has a child, destroy it */
    while ( hwndT = GetWindow (hwndMDIClient, GW_CHILD)){

        /* Skip the icon title windows */
        while (hwndT && GetWindow (hwndT, GW_OWNER))
            hwndT = GetWindow (hwndT, GW_HWNDNEXT);

        if (!hwndT)
            break;

        SendMessage(hwndMDIClient, WM_MDIDESTROY, (WORD)hwndT, 0L);
    }

    ShowWindow( hwndMDIClient, SW_SHOW);
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : CommandHandler ()                                          *
 *                                                                          *
 *  PURPOSE    : Processes all "frame" WM_COMMAND messages.                 *
 *                                                                          *
 ****************************************************************************/
VOID NEAR PASCAL CommandHandler (
register HWND hwnd,
register WORD wParam)

{
    MYCONVINFO *pmci = NULL;

    if (hwndActive)
        pmci = (MYCONVINFO *)GetWindowWord(hwndActive, 0);

    switch (wParam){
        case IDM_EDITPASTE:
            {
                HANDLE hClipData;
                LPSTR psz;
                XACT xact;

                if (OpenClipboard(hwnd)) {
                    if (hClipData = GetClipboardData(fmtLink)) {
                        if (psz = GlobalLock(hClipData)) {
                            /*
                             * Create a conversation with the link app and
                             * begin a request and advise start transaction.
                             */
                            xact.hConv = CreateConv(DdeCreateStringHandle(idInst, psz, NULL),
                                    DdeCreateStringHandle(idInst, &psz[_fstrlen(psz) + 1], NULL),
                                    FALSE, NULL);
                            if (xact.hConv) {
                                psz += _fstrlen(psz) + 1;
                                psz += _fstrlen(psz) + 1;
                                xact.ulTimeout = DefTimeout;
                                xact.wType = XTYP_ADVSTART;
                                xact.hDdeData = 0;
                                xact.wFmt = CF_TEXT;
                                xact.hszItem = DdeCreateStringHandle(idInst, psz, NULL);
                                xact.fsOptions = 0;
                                ProcessTransaction(&xact);
                                xact.wType = XTYP_REQUEST;
                                ProcessTransaction(&xact);
                            }
                            GlobalUnlock(hClipData);
                        }
                    }
                    CloseClipboard();
                }
            }
            break;

        case IDM_CONNECT:
        case IDM_RECONNECT:
            DoDialog(MAKEINTRESOURCE(IDD_CONNECT), ConnectDlgProc,
                    wParam == IDM_RECONNECT, FALSE);
            break;

        case IDM_DISCONNECT:
            if (hwndActive) {
                SendMessage(hwndMDIClient, WM_MDIDESTROY, (WORD)hwndActive, 0L);
            }
            break;

        case IDM_TRANSACT:
            if (DoDialog(MAKEINTRESOURCE(IDD_TRANSACT), TransactDlgProc,
                    (DWORD)(LPSTR)pmci->hConv, FALSE))
                SetFocus(GetWindow(hwndActive, GW_CHILD));
            break;

        case IDM_ABANDON:
            if (pmci != NULL && IsWindow(pmci->hwndXaction)) {
                DestroyWindow(pmci->hwndXaction);
            }
            break;

        case IDM_ABANDONALL:
            DdeAbandonTransaction(idInst, pmci->hConv, NULL);
            {
                HWND hwndXaction;

                hwndXaction = GetWindow(hwndActive, GW_CHILD);
                while (hwndXaction) {
                    DestroyWindow(hwndXaction);
                    hwndXaction = GetWindow(hwndActive, GW_CHILD);
                }
            }
            break;

        case IDM_BLOCKCURRENT:
            DdeEnableCallback(idInst, pmci->hConv, EC_DISABLE);
            InvalidateRect(hwndActive, NULL, TRUE);
            break;

        case IDM_ENABLECURRENT:
            DdeEnableCallback(idInst, pmci->hConv, EC_ENABLEALL);
            InvalidateRect(hwndActive, NULL, TRUE);
            break;

        case IDM_ENABLEONECURRENT:
            DdeEnableCallback(idInst, pmci->hConv, EC_ENABLEONE);
            InvalidateRect(hwndActive, NULL, TRUE);
            break;

        case IDM_BLOCKALLCBS:
            DdeEnableCallback(idInst, NULL, EC_DISABLE);
            InvalidateRect(hwndMDIClient, NULL, TRUE);
            break;

        case IDM_ENABLEALLCBS:
            DdeEnableCallback(idInst, NULL, EC_ENABLEALL);
            InvalidateRect(hwndMDIClient, NULL, TRUE);
            break;

        case IDM_ENABLEONECB:
            DdeEnableCallback(idInst, NULL, EC_ENABLEONE);
            InvalidateRect(hwndMDIClient, NULL, TRUE);
            break;

        case IDM_BLOCKNEXTCB:
            fBlockNextCB = !fBlockNextCB;
            break;

        case IDM_TERMNEXTCB:
            fTermNextCB = !fTermNextCB;
            break;

        case IDM_DELAY:
            DoDialog(MAKEINTRESOURCE(IDD_VALUEENTRY), DelayDlgProc, NULL,
                    TRUE);
            break;

        case IDM_TIMEOUT:
            DoDialog(MAKEINTRESOURCE(IDD_VALUEENTRY), TimeoutDlgProc, NULL,
                    TRUE);
            break;

        case IDM_CONTEXT:
            DoDialog(MAKEINTRESOURCE(IDD_CONTEXT), ContextDlgProc, NULL, TRUE);
            break;

        case IDM_AUTORECONNECT:
            fAutoReconnect = !fAutoReconnect;
            break;

        /* The following are window commands - these are handled by the
         * MDI Client.
         */
        case IDM_WINDOWTILE:
            /* Tile MDI windows */
            SendMessage (hwndMDIClient, WM_MDITILE, 0, 0L);
            break;

        case IDM_WINDOWCASCADE:
            /* Cascade MDI windows */
            SendMessage (hwndMDIClient, WM_MDICASCADE, 0, 0L);
            break;

        case IDM_WINDOWICONS:
            /* Auto - arrange MDI icons */
            SendMessage (hwndMDIClient, WM_MDIICONARRANGE, 0, 0L);
            break;

        case IDM_WINDOWCLOSEALL:
            CloseAllChildren();
            break;

        case IDM_XACTTILE:
            TileChildWindows(hwndActive);
            break;

        case IDM_XACTCASCADE:
            CascadeChildWindows(hwndActive);
            break;

        case IDM_HELPABOUT:{
            DoDialog(MAKEINTRESOURCE(IDD_ABOUT), AboutDlgProc, NULL, TRUE);
            break;
        }

        default:
           /*
            * This is essential, since there are frame WM_COMMANDS generated
            * by the MDI system for activating child windows via the
            * window menu.
            */
            DefFrameProc(hwnd, hwndMDIClient, WM_COMMAND, wParam, 0L);
    }
}


/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MPError ( hwnd, flags, id, ...)                            *
 *                                                                          *
 *  PURPOSE    : Flashes a Message Box to the user. The format string is    *
 *               taken from the STRINGTABLE.                                *
 *                                                                          *
 *  RETURNS    : Returns value returned by MessageBox() to the caller.      *
 *                                                                          *
 ****************************************************************************/
short FAR CDECL MPError(hwnd, bFlags, id, ...)
HWND hwnd;
WORD bFlags;
WORD id;
{
    char sz[160];
    char szFmt[128];

    LoadString (hInst, id, szFmt, sizeof (szFmt));
    wvsprintf (sz, szFmt, (LPSTR)(&id + 1));
    LoadString (hInst, IDS_APPNAME, szFmt, sizeof (szFmt));
    return MessageBox (hwndFrame, sz, szFmt, bFlags);
}



/****************************************************************************
 *                                                                          *
 *  FUNCTION   : CreateConv()                                               *
 *                                                                          *
 *  PURPOSE    :                                                            *
 *                                                                          *
 *  RETURNS    :                                                            *
 *                                                                          *
 ****************************************************************************/
HCONV CreateConv(
HSZ hszApp,
HSZ hszTopic,
BOOL fList,
WORD *pError)
{
    HCONV hConv;
    HWND hwndConv = 0;
    CONVINFO ci;

    if (fList) {
        hConv = (HCONV)DdeConnectList(idInst, hszApp, hszTopic, NULL, &CCFilter);
    } else {
        hConv = DdeConnect(idInst, hszApp, hszTopic, &CCFilter);
    }
    if (hConv) {
        if (fList) {
            ci.hszSvcPartner = hszApp;
            ci.hszTopic = hszTopic;
        } else {
            ci.cb = sizeof(CONVINFO);
	    DdeQueryConvInfo(hConv, (DWORD)QID_SYNC, &ci);
        }
        hwndConv = AddConv(ci.hszSvcPartner, ci.hszTopic, hConv, fList);
        // HSZs get freed when window dies.
    }
    if (!hwndConv) {
        if (pError != NULL) {
            *pError = DdeGetLastError(idInst);
        }
        DdeFreeStringHandle(idInst, hszApp);
        DdeFreeStringHandle(idInst, hszTopic);
    }
    return(hConv);
}






/****************************************************************************
 *                                                                          *
 *  FUNCTION   : AddConv()                                                  *
 *                                                                          *
 *  PURPOSE    : Creates an MDI window representing a conversation          *
 *               (fList = FALSE) or a set of MID windows for the list of    *
 *               conversations (fList = TRUE).                              *
 *                                                                          *
 *  EFFECTS    : Sets the hUser for the conversation to the created MDI     *
 *               child hwnd.  Keeps the hszs if successful.                 *
 *                                                                          *
 *  RETURNS    : created MDI window handle.                                 *
 *                                                                          *
 ****************************************************************************/
HWND FAR PASCAL AddConv(
HSZ hszApp,     // these parameters MUST match the MYCONVINFO struct.
HSZ hszTopic,
HCONV hConv,
BOOL fList)
{
    HWND hwnd;
    MDICREATESTRUCT mcs;

    if (fList) {
        /*
         * Create all child windows FIRST so we have info for list window.
         */
        CONVINFO ci;
        HCONV hConvChild = 0;

        ci.cb = sizeof(CONVINFO);
        while (hConvChild = DdeQueryNextServer((HCONVLIST)hConv, hConvChild)) {
	    if (DdeQueryConvInfo(hConvChild, (DWORD)QID_SYNC, &ci)) {
                AddConv(ci.hszSvcPartner, ci.hszTopic, hConvChild, FALSE);
            }
        }
    }

    mcs.szTitle = GetConvTitleText(hConv, hszApp, hszTopic, fList);

    mcs.szClass = fList ? szList : szChild;
    mcs.hOwner  = hInst;
    mcs.x = mcs.cx = CW_USEDEFAULT;
    mcs.y = mcs.cy = CW_USEDEFAULT;
    mcs.style = GetWindow(hwndMDIClient, GW_CHILD) ? 0L : WS_MAXIMIZE;
    mcs.lParam = (DWORD)(LPSTR)&fList - 2;      // -2 for hwndXaction field
    hwnd = (WORD)SendMessage (hwndMDIClient, WM_MDICREATE, 0,
             (LONG)(LPMDICREATESTRUCT)&mcs);

    MyFree((PSTR)(DWORD)mcs.szTitle);

    return hwnd;
}





/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GetConvListText()                                          *
 *                                                                          *
 *  RETURN     : Returns a ponter to a string containing a list of          *
 *               conversations contained in the given hConvList freeable    *
 *               by MyFree();                                               *
 *                                                                          *
 ****************************************************************************/
PSTR GetConvListText(
HCONVLIST hConvList)
{
    HCONV hConv = 0;
    WORD cConv = 0;
    CONVINFO ci;
    WORD cb = 0;
    char *psz, *pszStart;

    ci.cb = sizeof(CONVINFO);

    // find out size needed.

    while (hConv = DdeQueryNextServer(hConvList, hConv)) {
	if (DdeQueryConvInfo(hConv, (DWORD)QID_SYNC, &ci)) {
            if (!IsWindow((HWND)ci.hUser)) {
                if (ci.wStatus & ST_CONNECTED) {
                    /*
                     * This conversation doesn't have a corresponding
                     * MDI window.  This is probably due to a reconnection.
                     */
                    ci.hUser = AddConv(ci.hszSvcPartner, ci.hszTopic, hConv, FALSE);
                } else {
                    continue;   // skip this guy - he was closed locally.
                }
            }
            cb += GetWindowTextLength((HWND)ci.hUser);
            if (cConv++)
                cb += 2;        // room for CRLF
        }
    }
    cb++;                       // for terminator.

    // allocate and fill

    if (pszStart = psz = MyAlloc(cb)) {
        *psz = '\0';
        hConv = 0;
        while (hConv = DdeQueryNextServer(hConvList, hConv)) {
	    if (DdeQueryConvInfo(hConv, (DWORD)QID_SYNC, &ci) &&
                    IsWindow((HWND)ci.hUser)) {
                psz += GetWindowText((HWND)ci.hUser, psz, cb);
                if (--cConv) {
                    *psz++ = '\r';
                    *psz++ = '\n';
                }
            }
        }
    }
    return(pszStart);
}


/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GetConvInfoText()                                          *
 *                                                                          *
 *  PURPOSE    : Returns a pointer to a string that reflects a              *
 *               conversation's information.  Freeable by MyFree();         *
 *                                                                          *
 ****************************************************************************/
PSTR GetConvInfoText(
HCONV hConv,
CONVINFO *pci)
{
    PSTR psz;
    PSTR szApp;

    psz = MyAlloc(300);
    pci->cb = sizeof(CONVINFO);
    if (hConv) {
	if (!DdeQueryConvInfo(hConv, (DWORD)QID_SYNC, (PCONVINFO)pci)) {
            strcpy(psz, "State=Disconnected");
            return(psz);
        }
        szApp = GetHSZName(pci->hszServiceReq);
        wsprintf(psz,
                "hUser=0x%lx\r\nhConvPartner=0x%lx\r\nhszServiceReq=%s\r\nStatus=%s\r\nState=%s\r\nLastError=%s",
                pci->hUser, pci->hConvPartner, (LPSTR)szApp,
                (LPSTR)Status2String(pci->wStatus),
                (LPSTR)State2String(pci->wConvst),
                (LPSTR)Error2String(pci->wLastError));
        MyFree(szApp);
    } else {
        strcpy(psz, Error2String(DdeGetLastError(idInst)));
    }
    return(psz);
}



/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GetConvTitleText()                                         *
 *                                                                          *
 *  PURPOSE    : Creates standard window title text based on parameters.    *
 *                                                                          *
 *  RETURNS    : psz freeable by MyFree()                                   *
 *                                                                          *
 ****************************************************************************/
PSTR GetConvTitleText(
HCONV hConv,
HSZ hszApp,
HSZ hszTopic,
BOOL fList)
{
    WORD cb;
    PSTR psz;

    cb = (WORD)DdeQueryString(idInst, hszApp, NULL, 0, 0) +
            (WORD)DdeQueryString(idInst, hszTopic, (LPSTR)NULL, 0, 0) +
            (fList ? 30 : 20);

    if (psz = MyAlloc(cb)) {
        DdeQueryString(idInst, hszApp, psz, cb, 0);
        strcat(psz, "|");
        DdeQueryString(idInst, hszTopic, &psz[strlen(psz)], cb, 0);
        if (fList)
            strcat(psz, " - LIST");
        wsprintf(&psz[strlen(psz)], " - (%lx)", hConv);
    }
    return(psz);
}



/****************************************************************************
 *                                                                          *
 *  FUNCTION   : Status2String()                                            *
 *                                                                          *
 *  PURPOSE    : Converts a conversation status word to a string and        *
 *               returns a pointer to that string.  The string is valid     *
 *               till the next call to this function.                       *
 *                                                                          *
 ****************************************************************************/
PSTR Status2String(
WORD status)
{
    WORD c, i;
    static char szStatus[6 * 18];
    static struct {
        char *szStatus;
        WORD status;
    } s2s[] = {
        { "Connected"    ,   ST_CONNECTED },
        { "Advise"       ,   ST_ADVISE },
        { "IsLocal"      ,   ST_ISLOCAL },
        { "Blocked"      ,   ST_BLOCKED },
        { "Client"       ,   ST_CLIENT },
        { "Disconnected" ,   ST_TERMINATED },
        { "BlockNext"    ,   ST_BLOCKNEXT },
    };
#define CFLAGS 7
    szStatus[0] = '\0';
    c = 0;
    for (i = 0; i < CFLAGS; i++) {
        if (status & s2s[i].status) {
            if (c++)
                strcat(szStatus, " | ");
            strcat(szStatus, s2s[i].szStatus);
        }
    }
    return szStatus;
#undef CFLAGS
}




/****************************************************************************
 *                                                                          *
 *  FUNCTION   : State2String()                                             *
 *                                                                          *
 *  PURPOSE    : converts a conversation state word to a string and         *
 *               returns a pointer to that string.  The string is valid     *
 *               till the next call to this routine.                        *
 *                                                                          *
 ****************************************************************************/
PSTR State2String(
WORD state)
{
    static char *s2s[] = {
        "NULL"             ,
        "Incomplete"       ,
        "Standby"          ,
        "Initiating"       ,
        "ReqSent"          ,
        "DataRcvd"         ,
        "PokeSent"         ,
        "PokeAckRcvd"      ,
        "ExecSent"         ,
        "ExecAckRcvd"      ,
        "AdvSent"          ,
        "UnadvSent"        ,
        "AdvAckRcvd"       ,
        "UnadvAckRcvd"     ,
        "AdvDataSent"      ,
        "AdvDataAckRcvd"   ,
        "?"                ,    // 16
    };

    if (state >= 17)
        return s2s[17];
    else
        return s2s[state];
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : Error2String()                                             *
 *                                                                          *
 *  PURPOSE    : Converts an error code to a string and returns a pointer   *
 *               to that string.  The string is valid until the next call   *
 *               to this function.                                          *
 *                                                                          *
 ****************************************************************************/
PSTR Error2String(
WORD error)
{
    static char szErr[23];
    static char *e2s[] = {
        "Advacktimeout"              ,
        "Busy"                       ,
        "Dataacktimeout"             ,
        "Dll_not_initialized"        ,
        "Dll_usage"                  ,
        "Execacktimeout"             ,
        "Invalidparameter"           ,
        "Low Memory warning"         ,
        "Memory_error"               ,
        "Notprocessed"               ,
        "No_conv_established"        ,
        "Pokeacktimeout"             ,
        "Postmsg_failed"             ,
        "Reentrancy"                 ,
        "Server_died"                ,
        "Sys_error"                  ,
        "Unadvacktimeout"            ,
        "Unfound_queue_id"           ,
    };
    if (!error) {
        strcpy(szErr, "0");
    } else if (error > DMLERR_LAST || error < DMLERR_FIRST) {
        strcpy(szErr, "???");
    } else {
        strcpy(szErr, e2s[error - DMLERR_FIRST]);
    }
    return(szErr);
}





/****************************************************************************
 *                                                                          *
 *  FUNCTION   : Type2String()                                              *
 *                                                                          *
 *  PURPOSE    : Converts a wType word and fsOption flags to a string and   *
 *               returns a pointer to that string.  the string is valid     *
 *               until the next call to this function.                      *
 *                                                                          *
 ****************************************************************************/
PSTR Type2String(
WORD wType,
WORD fsOptions)
{
    static char sz[30];
    static char o2s[] = "^!#$X*<?";
    static char *t2s[] = {
        ""                 ,
        "AdvData"          ,
        "AdvReq"           ,
        "AdvStart"         ,
        "AdvStop"          ,
        "Execute"          ,
        "Connect"          ,
        "ConnectConfirm"   ,
        "XactComplete"    ,
        "Poke"             ,
        "Register"         ,
        "Request"          ,
        "Term"             ,
        "Unregister"       ,
        "WildConnect"      ,
        ""                 ,
    };
    WORD bit, c, i;

    strcpy(sz, t2s[((wType & XTYP_MASK) >> XTYP_SHIFT)]);
    c = strlen(sz);
    sz[c++] = ' ';
    for (i = 0, bit = 1; i < 7; bit = bit << 1, i++) {
        if (fsOptions & bit)
            sz[c++] = o2s[i];
    }
    sz[c] = '\0';
    return(sz);
}




/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GetHSZName()                                               *
 *                                                                          *
 *  PURPOSE    : Allocates local memory for and retrieves the string form   *
 *               of an HSZ.  Returns a pointer to the local memory or NULL  *
 *               if failure.  The string must be freed via MyFree().        *
 *                                                                          *
 ****************************************************************************/
PSTR GetHSZName(
HSZ hsz)
{
    PSTR psz;
    WORD cb;

    cb = (WORD)DdeQueryString(idInst, hsz, NULL, 0, 0) + 1;
    psz = MyAlloc(cb);
    DdeQueryString(idInst, hsz, psz, cb, 0);
    return(psz);
}


/****************************************************************************
 *
 *  FUNCTION   : MyMsgFilterProc
 *
 *  PURPOSE    : This filter proc gets called for each message we handle.
 *               This allows our application to properly dispatch messages
 *               that we might not otherwise see because of DDEMLs modal
 *               loop that is used while processing synchronous transactions.
 *
 *               Generally, applications that only do synchronous transactions
 *               in response to user input (as this app does) does not need
 *               to install such a filter proc because it would be very rare
 *               that a user could command the app fast enough to cause
 *               problems.  However, this is included as an example.
 *
 ****************************************************************************/
DWORD FAR PASCAL MyMsgFilterProc(
int nCode,
WORD wParam,
DWORD lParam)
{
    wParam; // not used

#define lpmsg ((LPMSG)lParam)
    if (nCode == MSGF_DDEMGR) {

        /* If a keyboard message is for the MDI , let the MDI client
         * take care of it.  Otherwise, check to see if it's a normal
         * accelerator key.  Otherwise, just handle the message as usual.
         */

        if ( !TranslateMDISysAccel (hwndMDIClient, lpmsg) &&
             !TranslateAccelerator (hwndFrame, hAccel, lpmsg)){
            TranslateMessage (lpmsg);
            DispatchMessage (lpmsg);
        }
        return(1);
    }
    return(0);
#undef lpmsg
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\src\client\ddemlcl.h ===
#include <windows.h>
#include <ddeml.h>

#define WINDOWMENU  3	/* position of window menu		 */

/* resource ID's */
#define IDCLIENT  1
#define IDCONV	  2
#define IDLIST	  3


/* menu ID's */

#define IDM_EDITPASTE	        2004

#define IDM_CONNECT             3000    // enabled always
#define IDM_RECONNECT           3001    // enabled if list selected
#define IDM_DISCONNECT          3002    // enabled if conversation selected
#define IDM_TRANSACT            3003    // enabled if conversation selected
#define IDM_ABANDON             3004    // enabled if transaction selected
#define IDM_ABANDONALL          3005    // enabled if conv. selected &&
                                        // and any transaction windows exist

#define IDM_BLOCKCURRENT        3010    // enabled if conv. sel.  chkd if conv. blocked
#define IDM_ENABLECURRENT       3011    // enabled if conv. sel.  chkd if not blocked
#define IDM_ENABLEONECURRENT    3012    // enabled if conv. sel.

#define IDM_BLOCKALLCBS         3013    // enabled if any convs.
#define IDM_ENABLEALLCBS        3014    // enabled if any convs.
#define IDM_ENABLEONECB         3015    // enabled if any convs.

#define IDM_BLOCKNEXTCB         3016    // enabled always, chkd if set.
#define IDM_TERMNEXTCB          3017    // enabled if any convs.  chked if set.

#define IDM_TIMEOUT             3021
#define IDM_DELAY               3022
#define IDM_CONTEXT             3023
#define IDM_AUTORECONNECT       3024

#define IDM_WINDOWTILE	        4001
#define IDM_WINDOWCASCADE       4002
#define IDM_WINDOWCLOSEALL      4003
#define IDM_WINDOWICONS         4004

#define IDM_XACTTILE	        4005
#define IDM_XACTCASCADE         4006
#define IDM_XACTCLOSEALL        4007

#define IDM_WINDOWCHILD         4100

#define IDM_HELP	        5001
#define IDM_HELPABOUT	        5002


#define DEFTIMEOUT              1000

#include "dialog.h"

// predefined format list item

typedef struct {
    ATOM atom;
    PSTR sz;
} FORMATINFO;
#define CFORMATS 3

// conversation (MDI child) window information
typedef struct {
    HWND hwndXaction;       // last xaction window with focus, 0 if none.
    BOOL fList;
    HCONV hConv;
    HSZ hszTopic;
    HSZ hszApp;
    int x;          // next child coord.
    int y;
    CONVINFO ci; // most recent status info.
} MYCONVINFO;       // parameters to AddConv() in reverse order.
#define CHILDCBWNDEXTRA	    2
#define UM_GETNEXTCHILDX    (WM_USER + 200)
#define UM_GETNEXTCHILDY    (WM_USER + 201)
#define UM_DISCONNECTED     (WM_USER + 202)

// transaction processing structure - this structure is associated with
// infoctrl control windows.  A handle to this structure is placed into
// the first window word of the control.
typedef struct {    // used to passinfo to/from TransactionDlgProc and
    DWORD ret;      // TextEntryDlgProc.
    DWORD Result;
    DWORD ulTimeout;
    WORD wType;
    HCONV hConv;
    HDDEDATA hDdeData;
    WORD wFmt;
    HSZ hszItem;
    WORD fsOptions;
} XACT;

typedef struct {
    HDDEDATA hData;
    HSZ hszItem;
    WORD wFmt;
} OWNED;

// transaction option flags - for fsOptions field and DefOptions global.

#define XOPT_NODATA             0x0001
#define XOPT_ACKREQ             0x0002
#define XOPT_DISABLEFIRST       0x0004
#define XOPT_ABANDONAFTERSTART  0x0008
#define XOPT_BLOCKRESULT        0x0010
#define XOPT_ASYNC              0x0020
#define XOPT_COMPLETED          0x8000      // used internally only.

/* strings */
#define IDS_ILLFNM	        1
#define IDS_ADDEXT	        2
#define IDS_CLOSESAVE	    3
#define IDS_HELPNOTAVAIL    4
#define IDS_CLIENTTITLE     5
#define IDS_APPNAME	        6
#define IDS_DDEMLERR        7
#define IDS_BADLENGTH       8

/* attribute flags for DlgDirList */
#define ATTR_DIRS	0xC010		/* find drives and directories */
#define ATTR_FILES	0x0000		/* find ordinary files	       */
#define PROP_FILENAME	szPropertyName	/* name of property for dialog */
#define MAX_OWNED   20

/*
 *  GLOBALS
 */
extern CONVCONTEXT CCFilter;
extern DWORD idInst;
extern HANDLE hInst;		/* application instance handle		  */
extern HANDLE hAccel;		/* resource handle of accelerators	  */
extern HWND hwndFrame;		/* main window handle			  */
extern HWND hwndMDIClient;	/* handle of MDI Client window		  */
extern HWND hwndActive; 	/* handle of current active MDI child	  */
extern HWND hwndActiveEdit;	/* handle of edit control in active child */
extern LONG styleDefault;	/* default child creation state 	  */
extern WORD SyncTimeout;
extern LONG DefTimeout;
extern WORD wDelay;
extern BOOL fEnableCBs;
extern BOOL fEnableOneCB;
extern BOOL fBlockNextCB;
extern BOOL fTermNextCB;
extern BOOL fAutoReconnect;
extern HDDEDATA hDataOwned;
extern WORD fmtLink;        // registered LINK clipboard fmt
extern WORD DefOptions;
extern char szChild[];		/* class of child			  */
extern char szList[];		/* class of child			  */
extern char szSearch[]; 	/* search string			  */
extern char *szDriver;		/* name of printer driver		  */
extern char szPropertyName[];	/* filename property for dialog box	  */
extern int iPrinter;		/* level of printing capability 	  */
extern BOOL fCase;		/* searches case sensitive		  */
extern WORD cFonts;		/* number of fonts enumerated		  */
extern FORMATINFO aFormats[];
extern OWNED aOwned[MAX_OWNED];
extern WORD cOwned;


// MACROS

#ifdef NODEBUG
#define MyAlloc(cb)     (PSTR)LocalAlloc(LPTR, (cb))
#define MyFree(p)       (LocalUnlock((HANDLE)(p)), LocalFree((HANDLE)(p)))
#else   // DEBUG

#define MyAlloc(cb)     DbgAlloc((WORD)cb)
#define MyFree(p)       DbgFree((PSTR)p)
#endif //NODEBUG


/*  externally declared functions
 */

// ddemlcl.c

BOOL FAR PASCAL InitializeApplication(VOID);
BOOL FAR PASCAL InitializeInstance(WORD);
HWND FAR PASCAL AddFile(char *);
VOID FAR PASCAL ReadFile(HWND);
VOID FAR PASCAL SaveFile(HWND);
BOOL FAR PASCAL ChangeFile(HWND);
int FAR PASCAL LoadFile(HWND, char *);
VOID FAR PASCAL PrintFile(HWND);
BOOL FAR PASCAL GetInitializationData(HWND);
short FAR CDECL MPError(HWND,WORD,WORD,...);
VOID FAR PASCAL Find(void);
VOID FAR PASCAL FindNext(void);
VOID FAR PASCAL FindPrev(void);
VOID FAR PASCAL MPSpotHelp(HWND,POINT);
LONG FAR PASCAL FrameWndProc(HWND,UINT,WPARAM,LPARAM);
LONG FAR PASCAL MDIChildWndProc(HWND,UINT,WPARAM,LPARAM);
HDC FAR PASCAL GetPrinterDC(void);
VOID NEAR PASCAL SetSaveFrom (HWND, PSTR);
BOOL NEAR PASCAL RealSlowCompare (PSTR, PSTR);
VOID FAR PASCAL FindPrev (void);
VOID FAR PASCAL FindNext (void);
BOOL NEAR PASCAL IsWild (PSTR);
VOID NEAR PASCAL SelectFile (HWND);
VOID NEAR PASCAL FindText ( int );
HCONV CreateConv(HSZ hszApp, HSZ hszTopic, BOOL fList, WORD *pError);
HWND FAR PASCAL AddConv(HSZ hszApp, HSZ hszTopic, HCONV hConv, BOOL fList);
PSTR GetConvListText(HCONVLIST hConvList);
PSTR GetConvInfoText(HCONV hConv, CONVINFO *pci);
PSTR GetConvTitleText(HCONV hConv, HSZ hszApp, HSZ hszTopic, BOOL fList);
PSTR Status2String(WORD status);
PSTR State2String(WORD state);
PSTR Error2String(WORD error);
PSTR Type2String(WORD wType, WORD fsOptions);
PSTR GetHSZName(HSZ hsz);
DWORD FAR PASCAL MyMsgFilterProc(int nCode, WORD wParam, DWORD lParam);
typedef DWORD FAR PASCAL FILTERPROC(int nCode, WORD wParam, DWORD lParam);
extern FILTERPROC  *lpMsgFilterProc;

// dialog.c


int FAR DoDialog(LPCSTR lpTemplateName, FARPROC lpDlgProc, DWORD param,
        BOOL fRememberFocus);
BOOL FAR PASCAL AboutDlgProc(HWND,WORD,WORD,LONG);
BOOL FAR PASCAL ConnectDlgProc(HWND,WORD,WORD,LONG);
BOOL FAR PASCAL TransactDlgProc(HWND,WORD,WORD,LONG);
BOOL FAR PASCAL AdvOptsDlgProc(HWND, WORD, WORD, LONG);
BOOL FAR PASCAL TextEntryDlgProc(HWND, WORD, WORD, LONG);
BOOL FAR PASCAL ViewHandleDlgProc(HWND, WORD, WORD, LONG);
BOOL FAR PASCAL TimeoutDlgProc(HWND,WORD,WORD,LONG);
BOOL FAR PASCAL DelayDlgProc(HWND,WORD,WORD,LONG);
BOOL FAR PASCAL ContextDlgProc(HWND,WORD,WORD,LONG);
VOID Delay(DWORD delay);

// dde.c


BOOL ProcessTransaction(XACT *pxact);
VOID CompleteTransaction(HWND hwndInfoCtr, XACT *pxact);
HDDEDATA EXPENTRY DdeCallback(WORD wType, WORD wFmt, HCONV hConv, HSZ hsz1,
        HSZ hsz2, HDDEDATA hData, DWORD lData1, DWORD lData2);
HWND MDIChildFromhConv(HCONV hConv);
HWND FindAdviseChild(HWND hwndMDI, HSZ hszItem, WORD wFmt);
HWND FindListWindow(HCONVLIST hConvList);
PSTR GetTextData(HDDEDATA hData);
PSTR GetFormatData(HDDEDATA hData);
int MyGetClipboardFormatName(WORD fmt, LPSTR lpstr, int cbMax);
PSTR GetFormatName(WORD wFmt);
BOOL MyDisconnect(HCONV hConv);

// mem.c


PSTR DbgAlloc(WORD cb);
PSTR DbgFree(PSTR p);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\src\client\dialog.h ===
#define IDEF_DATA           101
#define IDCH_NODATA         102
#define IDCH_ACKREQ         103
#define IDCH_DISABLEFIRST   104
#define IDCH_ABANDON        105
#define IDCH_BLOCKRESULT    106
#define IDCH_ASYNC          107
#define IDEF_TIMEOUT        109
#define IDEF_ITEM           110
#define IDCB_FORMAT         111
#define IDBN_OPTIONS        112
#define IDCH_REQUEST        113
#define IDCH_ADVISE         114
#define IDCH_UNADVISE       115
#define IDCH_POKE           116
#define IDCH_EXECUTE        117
#define IDEF_APPLICATION    118
#define IDEF_TOPIC          119
#define IDCH_CONNECTLIST    120
#define IDEF_VALUE          121
#define IDTX_VALUE          122
#define IDBN_GENHUGE        123
#define IDTX_ITEM           124
#define IDBN_USEOWNED       125
#define IDEF_FLAGS          126
#define IDEF_COUNTRY        127
#define IDEF_CODEPAGE       128
#define IDEF_LANG           129
#define IDEF_SECURITY       130
#define IDD_TEXTENTRY       900
#define IDD_ADVISEOPTS      901
#define IDD_TRANSACT        902
#define IDD_CONNECT         903
#define IDD_VALUEENTRY      904
#define IDD_ABOUT           905
#define IDD_CONTEXT         906
#define IDD_HDATAVIEW       100
#define IDBN_VIEW           131
#define IDCH_MAKEOWNED      132
#define IDBN_DELETE         133
#define IDLB_HANDLES        134
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\src\client\dialog.c ===
/***************************************************************************
 *                                                                         *
 *  MODULE      : dialog.c                                                 *
 *                                                                         *
 *  PURPOSE     : Contains all dialog procedures and related functions.    *
 *                                                                         *
 ***************************************************************************/
#include "ddemlcl.h"
#include "infoctrl.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "huge.h"

#define MAX_NAME 100    // max size for edit controls with app/topic/item names.
char szWild[] = "*";    // used to indicate wild names ("" is also cool)
char szT[MAX_NAME];     // temp buf for munging names.


LONG GetDlgItemLong(HWND hwnd, WORD id, BOOL *pfTranslated, BOOL fSigned);
VOID SetDlgItemLong(HWND hwnd, WORD id, LONG l, BOOL fSigned);

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DoDialog()                                                 *
 *                                                                          *
 *  PURPOSE    : Generic dialog invocation routine.  Handles procInstance   *
 *               stuff, focus management and param passing.                 *
 *  RETURNS    : result of dialog procedure.                                *
 *                                                                          *
 ****************************************************************************/
int FAR DoDialog(
LPCSTR lpTemplateName,
FARPROC lpDlgProc,
DWORD param,
BOOL fRememberFocus)
{
    WORD wRet;
    HWND hwndFocus;

    if (fRememberFocus)
        hwndFocus = GetFocus();
    lpDlgProc = MakeProcInstance(lpDlgProc, hInst);
    wRet = DialogBoxParam(hInst, lpTemplateName, hwndFrame, lpDlgProc, param);
    FreeProcInstance(lpDlgProc);
    if (fRememberFocus)
        SetFocus(hwndFocus);
    return wRet;
}



/****************************************************************************
 *                                                                          *
 *  FUNCTION   :                                                            *
 *                                                                          *
 *  PURPOSE    :                                                            *
 *                                                                          *
 *  RETURNS    :                                                            *
 *                                                                          *
 ****************************************************************************/
BOOL FAR PASCAL AboutDlgProc ( hwnd, msg, wParam, lParam )
HWND          hwnd;
register WORD msg;
register WORD wParam;
LONG          lParam;
{
    switch (msg){
        case WM_INITDIALOG:
            /* nothing to initialize */
            break;

        case WM_COMMAND:
            switch (wParam){
                case IDOK:
                case IDCANCEL:
                    EndDialog(hwnd, 0);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return(FALSE);
    }

    return TRUE;
}




/****************************************************************************
 *                                                                          *
 *  FUNCTION   :                                                            *
 *                                                                          *
 *  PURPOSE    :                                                            *
 *                                                                          *
 *  RETURNS    :                                                            *
 *                                                                          *
 ****************************************************************************/
BOOL FAR PASCAL ConnectDlgProc(
HWND          hwnd,
register WORD msg,
register WORD wParam,
LONG          lParam)
{
    static BOOL fReconnect;
    char szT[MAX_NAME];
    HSZ hszApp, hszTopic;
    MYCONVINFO *pmci;
    WORD error;

    switch (msg){
    case WM_INITDIALOG:
        SendDlgItemMessage(hwnd, IDEF_APPLICATION, EM_LIMITTEXT, MAX_NAME, 0);
        SendDlgItemMessage(hwnd, IDEF_TOPIC, EM_LIMITTEXT, MAX_NAME, 0);
        fReconnect = (BOOL)lParam;
        if (fReconnect) {
            PSTR psz;

            pmci = (MYCONVINFO *)GetWindowWord(hwndActive, 0);
            SetWindowText(hwnd, "DDE Reconnect List");
            psz = GetHSZName(pmci->hszApp);
            SetDlgItemText(hwnd, IDEF_APPLICATION, psz);
            MyFree(psz);
            psz = GetHSZName(pmci->hszTopic);
            SetDlgItemText(hwnd, IDEF_TOPIC, psz);
            MyFree(psz);
            ShowWindow(GetDlgItem(hwnd, IDCH_CONNECTLIST), SW_HIDE);
        }
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            GetDlgItemText(hwnd, IDEF_APPLICATION, szT, MAX_NAME);
            if (!strcmp(szT, szWild))
                szT[0] = '\0';
            hszApp = DdeCreateStringHandle(idInst, szT, 0);

            GetDlgItemText(hwnd, IDEF_TOPIC, szT, MAX_NAME);
            if (!strcmp(szT, szWild))
                szT[0] = '\0';
            hszTopic = DdeCreateStringHandle(idInst, szT, 0);

            if (fReconnect) {
                HCONV hConv;
                CONVINFO ci;
                WORD cHwnd;
                HWND *aHwnd, *pHwnd, hwndSave;

                ci.cb = sizeof(CONVINFO);
                pmci = (MYCONVINFO *)GetWindowWord(hwndActive, 0);
                hwndSave = hwndActive;

                // count the existing conversations and allocate aHwnd

                cHwnd = 0;
                hConv = NULL;
                while (hConv = DdeQueryNextServer((HCONVLIST)pmci->hConv, hConv))
                    cHwnd++;
                aHwnd = (HWND *)MyAlloc(cHwnd * sizeof(HWND));

                // save all the old conversation windows into aHwnd.

                pHwnd = aHwnd;
                hConv = NULL;
                while (hConv = DdeQueryNextServer((HCONVLIST)pmci->hConv, hConv)) {
		    DdeQueryConvInfo(hConv, (DWORD)QID_SYNC, &ci);
                    *pHwnd++ = (HWND)ci.hUser;
                }

                // reconnect

                if (!(hConv = DdeConnectList(idInst, hszApp, hszTopic, pmci->hConv, &CCFilter))) {
                    MPError(hwnd, MB_OK, IDS_DDEMLERR, (LPSTR)Error2String(DdeGetLastError(idInst)));
                    DdeFreeStringHandle(idInst, hszApp);
                    DdeFreeStringHandle(idInst, hszTopic);
                    return 0;
                }

                // fixup windows corresponding to the new conversations.

                pmci->hConv = hConv;
                hConv = NULL;
                while (hConv = DdeQueryNextServer((HCONVLIST)pmci->hConv, hConv)) {
		    DdeQueryConvInfo(hConv, (DWORD)QID_SYNC, &ci);
                    // preserve corresponding window by setting its list
                    // entry to 0
                    for (pHwnd = aHwnd; pHwnd < &aHwnd[cHwnd]; pHwnd++) {
                        if (*pHwnd == (HWND)ci.hUser) {
                            *pHwnd = NULL;
                            break;
                        }
                    }
                }

                // destroy all windows left in the old list

                for (pHwnd = aHwnd; pHwnd < &aHwnd[cHwnd]; pHwnd++)
                    if (*pHwnd)
                        SendMessage(hwndMDIClient, WM_MDIDESTROY, *pHwnd, 0L);
                MyFree((PSTR)aHwnd);

                // create any new windows needed

                hConv = NULL;
                while (hConv = DdeQueryNextServer((HCONVLIST)pmci->hConv, hConv)) {
		    DdeQueryConvInfo(hConv, (DWORD)QID_SYNC, &ci);
                    if (ci.hUser) {
                        InvalidateRect((HWND)ci.hUser, NULL, TRUE);
                    } else {
                        AddConv(ci.hszSvcPartner, ci.hszTopic, hConv, FALSE);
                    }
                }

                // make list window update itself

                InvalidateRect(hwndSave, NULL, TRUE);
                SetFocus(hwndSave);
            } else {
                if (!CreateConv(hszApp, hszTopic,
                        IsDlgButtonChecked(hwnd, IDCH_CONNECTLIST), &error)) {
                    MPError(hwnd, MB_OK, IDS_DDEMLERR, (LPSTR)Error2String(error));
                    return 0;
                }
            }
            DdeFreeStringHandle(idInst, hszApp);
            DdeFreeStringHandle(idInst, hszTopic);
            // fall through
        case IDCANCEL:
            EndDialog(hwnd, 0);
            break;

        default:
            return(FALSE);
        }
        break;

    default:
        return(FALSE);
    }
}




/*
 * Fills a XACT structure and calls ProcessTransaction.
 *
 * On initiation lParam == hConv.
 */
/****************************************************************************
 *                                                                          *
 *  FUNCTION   :                                                            *
 *                                                                          *
 *  PURPOSE    :                                                            *
 *                                                                          *
 *  RETURNS    :                                                            *
 *                                                                          *
 ****************************************************************************/
BOOL FAR PASCAL TransactDlgProc(
HWND          hwnd,
register WORD msg,
register WORD wParam,
LONG          lParam)
{
    static WORD id2type[] = {
        XTYP_REQUEST,       // IDCH_REQUEST
        XTYP_ADVSTART,      // IDCH_ADVISE
        XTYP_ADVSTOP,       // IDCH_UNADVISE
        XTYP_POKE,          // IDCH_POKE
        XTYP_EXECUTE,       // IDCH_EXECUTE
    };
    static XACT *pxact;     // ONLY ONE AT A TIME!
    int i;

    switch (msg){
    case WM_INITDIALOG:
        pxact = (XACT *)MyAlloc(sizeof(XACT));
        pxact->hConv = (HCONV)lParam;
        pxact->fsOptions = DefOptions;
        pxact->ulTimeout = DefTimeout;

        // The item index == the index to the format atoms in aFormats[].
        for (i = 0; i < CFORMATS; i++)
            SendDlgItemMessage(hwnd, IDCB_FORMAT, CB_INSERTSTRING, i,
                    (DWORD)(LPSTR)aFormats[i].sz);
        SendDlgItemMessage(hwnd, IDCB_FORMAT, CB_INSERTSTRING, i,
                (DWORD)(LPSTR)"NULL");
        SendDlgItemMessage(hwnd, IDCB_FORMAT, CB_SETCURSEL, 0, 0);
        CheckRadioButton(hwnd, IDCH_REQUEST, IDCH_EXECUTE, IDCH_REQUEST);
        SendDlgItemMessage(hwnd, IDEF_ITEM, EM_LIMITTEXT, MAX_NAME, 0);

        // If there is a top transaction window, use its contents to
        // anticipate what the user will want to do.

        if (IsWindow(hwndActive)) {
            HWND hwndXaction;
            XACT *pxact;
            PSTR pszItem;

            hwndXaction = GetWindow(hwndActive, GW_CHILD);
            if (IsWindow(hwndXaction)) {
                pxact = (XACT *)GetWindowWord(hwndXaction, GWW_WUSER);
                pszItem = GetHSZName(pxact->hszItem);
                if ((pxact->wType & XTYP_ADVSTART) == XTYP_ADVSTART ||
                        pxact->wType == XTYP_ADVDATA) {
                    CheckRadioButton(hwnd, IDCH_REQUEST, IDCH_EXECUTE, IDCH_UNADVISE);
                }
                SetDlgItemText(hwnd, IDEF_ITEM, pszItem);
                for (i = 0; i < CFORMATS; i++) {
                    if (aFormats[i].atom == pxact->wFmt) {
                        SendDlgItemMessage(hwnd, IDCB_FORMAT, CB_SETCURSEL, i, 0);
                        break;
                    }
                }
                MyFree(pszItem);
            }
        }
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDCH_EXECUTE:
            SetDlgItemText(hwnd, IDEF_ITEM, "");
        case IDCH_REQUEST:
        case IDCH_ADVISE:
        case IDCH_UNADVISE:
        case IDCH_POKE:
            EnableWindow(GetDlgItem(hwnd, IDEF_ITEM), wParam != IDCH_EXECUTE);
            EnableWindow(GetDlgItem(hwnd, IDTX_ITEM), wParam != IDCH_EXECUTE);
            break;

        case IDOK:
        case IDBN_OPTIONS:
            {
                int id;

                // set pxact->wType

                for (id = IDCH_REQUEST; id <= IDCH_EXECUTE; id++) {
                    if (IsDlgButtonChecked(hwnd, id)) {
                        pxact->wType = id2type[id - IDCH_REQUEST];
                        break;
                    }
                }

                if (wParam == IDBN_OPTIONS) {
                    DoDialog(MAKEINTRESOURCE(IDD_ADVISEOPTS),
                            AdvOptsDlgProc, MAKELONG(pxact->fsOptions, pxact),
                            TRUE);
                    return 0;
                }

                id = (int)SendDlgItemMessage(hwnd, IDCB_FORMAT, CB_GETCURSEL, 0, 0);
                if (id == LB_ERR) {
                    return 0;
                }
                if (id == CFORMATS)
                    pxact->wFmt = 0;
                else
                    pxact->wFmt = aFormats[id].atom;

                if (pxact->wType == XTYP_ADVSTART) {
                    if (pxact->fsOptions & XOPT_NODATA)
                        pxact->wType |= XTYPF_NODATA;
                    if (pxact->fsOptions & XOPT_ACKREQ)
                        pxact->wType |= XTYPF_ACKREQ;
                }

                GetDlgItemText(hwnd, IDEF_ITEM, szT, MAX_NAME);
                pxact->hszItem = DdeCreateStringHandle(idInst, szT, NULL);

                pxact->hDdeData = 0;
                /*
                 * If this transaction needs data, invoke data input dialog.
                 */
                if (pxact->wType == XTYP_POKE || pxact->wType == XTYP_EXECUTE) {
                    if (!DoDialog(MAKEINTRESOURCE(IDD_TEXTENTRY),
                            TextEntryDlgProc, (DWORD)(LPSTR)pxact,
                            TRUE))
                        return 0;
                }

                // now start the transaction

                ProcessTransaction(pxact);
                MyFree((PSTR)pxact);
            }
            EndDialog(hwnd, 1);
            break;

        case IDCANCEL:
            MyFree((PSTR)pxact);
            EndDialog(hwnd, 0);
            break;

        default:
            return(FALSE);
        }
        break;

    case WM_DESTROY:
        break;

    default:
        return(FALSE);
    }
    return 0;
}







/****************************************************************************
 *                                                                          *
 *  FUNCTION   : AdvOptsDlgProc                                             *
 *                                                                          *
 *  RETURNS    :                                                            *
 *                                                                          *
 ****************************************************************************/
BOOL FAR PASCAL AdvOptsDlgProc(
HWND          hwnd,
register WORD msg,
register WORD wParam,
LONG          lParam)
{
    static struct {
        WORD id;
        WORD opt;
    } id2Opt[] = {
        {   IDCH_NODATA        ,   XOPT_NODATA             }   ,
        {   IDCH_ACKREQ        ,   XOPT_ACKREQ             }   ,
        {   IDCH_DISABLEFIRST  ,   XOPT_DISABLEFIRST       }   ,
        {   IDCH_ABANDON       ,   XOPT_ABANDONAFTERSTART  }   ,
        {   IDCH_BLOCKRESULT   ,   XOPT_BLOCKRESULT        }   ,
        {   IDCH_ASYNC         ,   XOPT_ASYNC              }   ,
    };
#define CCHBOX  6
    int i;
    static XACT *pxact; // only one instance at a time!!

    switch (msg){
    case WM_INITDIALOG:
        pxact = (XACT *)HIWORD(lParam);

        for (i = 0; i < CCHBOX; i++) {
            CheckDlgButton(hwnd, id2Opt[i].id, pxact->fsOptions & id2Opt[i].opt);
        }
        SetDlgItemLong(hwnd, IDEF_TIMEOUT, pxact->ulTimeout, FALSE);
        if (pxact->wType != XTYP_ADVSTART) {
            EnableWindow(GetDlgItem(hwnd, IDCH_NODATA), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDCH_ACKREQ), FALSE);
        }
        SendMessage(hwnd, WM_COMMAND, IDCH_ASYNC, 0);   // enable async checkboxes
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDCH_ASYNC:
            {
                BOOL fEnable;

                fEnable = IsDlgButtonChecked(hwnd, IDCH_ASYNC);
                EnableWindow(GetDlgItem(hwnd, IDCH_DISABLEFIRST), fEnable);
                EnableWindow(GetDlgItem(hwnd, IDCH_ABANDON), fEnable);
                EnableWindow(GetDlgItem(hwnd, IDCH_BLOCKRESULT), fEnable);
                EnableWindow(GetDlgItem(hwnd, IDEF_TIMEOUT), !fEnable);
            }
            break;

        case IDOK:
            pxact->fsOptions = 0;
            for (i = 0; i < CCHBOX; i++) {
                if (IsDlgButtonChecked(hwnd, id2Opt[i].id))
                    pxact->fsOptions |= id2Opt[i].opt;
            }
            if (!(pxact->fsOptions & XOPT_ASYNC))
                pxact->ulTimeout = (DWORD)GetDlgItemLong(hwnd, IDEF_TIMEOUT,
                    &i, FALSE);
            // fall through
        case IDCANCEL:
            EndDialog(hwnd, GetWindowWord(hwnd, 0));
            break;
        }
        break;

    default:
        return(FALSE);
    }
    return 0;
#undef CCHBOX
}






/****************************************************************************
 *                                                                          *
 *  FUNCTION   : TextEntryDlgProc                                           *
 *                                                                          *
 *  PURPOSE    : Allows user to enter text data which is to be sent to a    *
 *               server.  The user can opt to have a huge text piece of     *
 *               data created automaticlly.                                 *
 *               It uses the XACT structure for passing info in and out.    *
 *               Must have wFmt and hszItem set on entry.                   *
 *               Sets hDDEData on return if TRUE was returned.              *
 *                                                                          *
 *  RETURNS    : TRUE on success, FALSE on failure or cancel                *
 *                                                                          *
 ****************************************************************************/
BOOL FAR PASCAL TextEntryDlgProc(
HWND          hwnd,
register WORD msg,
register WORD wParam,
LONG          lParam)
{
    static XACT FAR *pxact;
    DWORD cb;
    LONG length;
    LPBYTE pData;
    BOOL fOwned;
    int id, i;

    switch (msg){
    case WM_INITDIALOG:
        pxact = (XACT FAR *)lParam;
        fOwned = FALSE;
        for (i = 0; i < (int)cOwned; i++) {
            if (aOwned[i].wFmt == pxact->wFmt &&
                    aOwned[i].hszItem == pxact->hszItem) {
                fOwned = TRUE;
                break;
            }
        }
        EnableWindow(GetDlgItem(hwnd, IDBN_USEOWNED), fOwned);
        CheckDlgButton(hwnd, IDCH_MAKEOWNED, 0);
        EnableWindow(GetDlgItem(hwnd, IDCH_MAKEOWNED), cOwned < MAX_OWNED);
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
        case IDBN_GENHUGE:
            fOwned = IsDlgButtonChecked(hwnd, IDCH_MAKEOWNED);
            cb = SendDlgItemMessage(hwnd, IDEF_DATA, WM_GETTEXTLENGTH, 0, 0) + 1;
            pxact->hDdeData = DdeCreateDataHandle(idInst, NULL, 0, cb, pxact->hszItem,
                    pxact->wFmt, fOwned ? HDATA_APPOWNED : 0);
            //
            // Note that at this time we have not yet given the data handle
            // to DDEML for transmission to any application, therefore, we
            // are at liberty to write to it using DdeAccessData() or any
            // other DDEML api.  It is only data handles received from DDEML
            // or given to DDEML for transmission that are readonly.
            //
            pData = DdeAccessData(pxact->hDdeData, NULL);
            GetDlgItemText(hwnd, IDEF_DATA, pData, (WORD)cb);
            DdeUnaccessData(pxact->hDdeData);
            if (wParam == IDBN_GENHUGE) {
                char szT[40];

                /*
                 * we assume in this case that the text entered is the decimal
                 * value of the size of the huge object desired.  We parse
                 * this string and create a randomly generated huge block
                 * of text data and place it into pxact->hDdeData.
                 */
                _fmemcpy(szT, pData, min((WORD)cb, 40));
                szT[39] = '\0';
                if (sscanf(szT, "%ld", &length) == 1) {
                    DdeFreeDataHandle(pxact->hDdeData);
                    pxact->hDdeData = CreateHugeDataHandle(length, 4325,
                            345, 5, pxact->hszItem, pxact->wFmt,
                            fOwned ? HDATA_APPOWNED : 0);
                } else {
                    /*
                     * The string cannot be parsed.  Inform the user of
                     * what is expected.
                     */
                    MPError(hwnd, MB_OK, IDS_BADLENGTH);
                    return 0;
                }
            }
            if (fOwned) {
                aOwned[cOwned].hData = pxact->hDdeData;
                aOwned[cOwned].hszItem = pxact->hszItem;
                aOwned[cOwned].wFmt = pxact->wFmt;
                cOwned++;
            }
            EndDialog(hwnd, TRUE);
            break;

        case IDBN_USEOWNED:
            /*
             * the user has chosen to use an existing owned data for sending
             * to the server.
             */
            id = DoDialog(MAKEINTRESOURCE(IDD_HDATAVIEW), ViewHandleDlgProc,
                    (DWORD)pxact, TRUE);

            switch (id) {
            case IDCANCEL:
                return(0);

            case IDOK:
                EndDialog(hwnd, TRUE);

            case IDBN_VIEW:
                pData = DdeAccessData(pxact->hDdeData, NULL);
                SetDlgItemText(hwnd, IDEF_DATA, pData);
                DdeUnaccessData(pxact->hDdeData);
                break;
            }
            break;

        case IDCANCEL:
            EndDialog(hwnd, FALSE);
            break;
        }
        break;

    default:
        return(FALSE);
    }
}



BOOL FAR PASCAL ViewHandleDlgProc(
HWND          hwnd,
register WORD msg,
register WORD wParam,
LONG          lParam)
{
    static XACT FAR *pxact;
    int i, itm;

    switch (msg){
    case WM_INITDIALOG:
        pxact = (XACT FAR *)lParam;
        // load listbox with handles that fit pxact constraints

        for (i = 0; i < (int)cOwned; i++) {
            if (aOwned[i].hszItem == pxact->hszItem &&
                    aOwned[i].wFmt == pxact->wFmt) {
                wsprintf(szT, "[%d] %lx : length=%ld", i, aOwned[i].hData,
                        DdeGetData(aOwned[i].hData, NULL, 0, 0));
                SendDlgItemMessage(hwnd, IDLB_HANDLES, LB_ADDSTRING, 0, (LONG)(LPSTR)szT);
            }
        }
        SendDlgItemMessage(hwnd, IDLB_HANDLES, LB_SETCURSEL, 0, 0);
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:          // use selectted handle
        case IDBN_DELETE:   // delete selected handle
        case IDBN_VIEW:     // view selected handle
            itm = (int)SendDlgItemMessage(hwnd, IDLB_HANDLES, LB_GETCURSEL, 0, 0);
            if (itm != LB_ERR) {
                SendDlgItemMessage(hwnd, IDLB_HANDLES, LB_GETTEXT, itm, (LONG)(LPSTR)szT);
                sscanf(szT, "[%d]", &i);
                pxact->hDdeData = aOwned[i].hData;
                switch (wParam) {
                case IDOK:          // use selectted handle
                    EndDialog(hwnd, wParam);
                    break;

                case IDBN_DELETE:   // delete selected handle
                    DdeFreeDataHandle(aOwned[i].hData);
                    aOwned[i] = aOwned[--cOwned];
                    SendDlgItemMessage(hwnd, IDLB_HANDLES, LB_DELETESTRING, itm, 0);
                    if (SendDlgItemMessage(hwnd, IDLB_HANDLES, LB_GETCOUNT, 0, 0) == 0)
                        EndDialog(hwnd, IDCANCEL);
                    break;

                case IDBN_VIEW:     // view selected handle
                    EndDialog(hwnd, wParam);
                }
            }
            break;

        case IDCANCEL:
            EndDialog(hwnd, FALSE);
            break;
        }
        break;

    default:
        return(FALSE);
    }
}



BOOL FAR PASCAL DelayDlgProc(
HWND          hwnd,
register WORD msg,
register WORD wParam,
LONG          lParam)
{
    switch (msg){
    case WM_INITDIALOG:
        SetWindowText(hwnd, "Advise data response time");
        SetDlgItemInt(hwnd, IDEF_VALUE, wDelay, FALSE);
        SetDlgItemText(hwnd, IDTX_VALUE, "Delay in milliseconds:");
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            wDelay = (WORD)GetDlgItemInt(hwnd, IDEF_VALUE, NULL, FALSE);
        case IDCANCEL:
            EndDialog(hwnd, 0);
            break;

        default:
            return(FALSE);
        }
        break;

    default:
        return(FALSE);
    }
}





/****************************************************************************
 *                                                                          *
 *  FUNCTION   : TimeoutDlgProc()                                           *
 *                                                                          *
 *  PURPOSE    : Allows user to alter the synchronous timeout value.        *
 *                                                                          *
 *  RETURNS    : TRUE on success, FALSE on cancel or failure.               *
 *                                                                          *
 ****************************************************************************/
BOOL FAR PASCAL TimeoutDlgProc(
HWND          hwnd,
register WORD msg,
register WORD wParam,
LONG          lParam)
{
    switch (msg){
    case WM_INITDIALOG:
        SetWindowText(hwnd, "Synchronous transaction timeout");
        SetDlgItemLong(hwnd, IDEF_VALUE, DefTimeout, FALSE);
        SetDlgItemText(hwnd, IDTX_VALUE, "Timeout in milliseconds:");
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            DefTimeout = GetDlgItemLong(hwnd, IDEF_VALUE, NULL, FALSE);
        case IDCANCEL:
            EndDialog(hwnd, 0);
            break;

        default:
            return(FALSE);
        }
        break;

    default:
        return(FALSE);
    }
}




BOOL FAR PASCAL ContextDlgProc(
HWND          hwnd,
register WORD msg,
register WORD wParam,
LONG          lParam)
{
    BOOL fSuccess;

    switch (msg){
    case WM_INITDIALOG:
        SetDlgItemInt(hwnd, IDEF_FLAGS, CCFilter.wFlags, FALSE);
        SetDlgItemInt(hwnd, IDEF_COUNTRY, CCFilter.wCountryID, FALSE);
        SetDlgItemInt(hwnd, IDEF_CODEPAGE, CCFilter.iCodePage, TRUE);
        SetDlgItemLong(hwnd, IDEF_LANG, CCFilter.dwLangID, FALSE);
        SetDlgItemLong(hwnd, IDEF_SECURITY, CCFilter.dwSecurity, FALSE);
        return(1);
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            CCFilter.wFlags = GetDlgItemInt(hwnd, IDEF_FLAGS, &fSuccess, FALSE);
            if (!fSuccess) return(0);
            CCFilter.wCountryID = GetDlgItemInt(hwnd, IDEF_COUNTRY, &fSuccess, FALSE);
            if (!fSuccess) return(0);
            CCFilter.iCodePage = GetDlgItemInt(hwnd, IDEF_CODEPAGE, &fSuccess, TRUE);
            if (!fSuccess) return(0);
            LOWORD(CCFilter.dwLangID) = GetDlgItemInt(hwnd, IDEF_LANG, &fSuccess, FALSE);
            if (!fSuccess) return(0);
            LOWORD(CCFilter.dwSecurity) = GetDlgItemInt(hwnd, IDEF_SECURITY, &fSuccess, FALSE);
            if (!fSuccess) return(0);
            // fall through
        case IDCANCEL:
            EndDialog(hwnd, 0);
            break;

        default:
            return(FALSE);
        }
        break;
    }
    return(FALSE);
}


void Delay(
DWORD delay)
{
    MSG msg;

    delay = GetCurrentTime() + delay;
    while (GetCurrentTime() < delay) {
        if (PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
}


LONG GetDlgItemLong(
HWND hwnd,
WORD id,
BOOL *pfTranslated,
BOOL fSigned)
{
    char szT[20];

    if (!GetDlgItemText(hwnd, id, szT, 20)) {
        if (pfTranslated != NULL) {
            *pfTranslated = FALSE;
        }
        return(0L);
    }
    if (pfTranslated != NULL) {
        *pfTranslated = TRUE;
    }
    return(atol(szT));
}


VOID SetDlgItemLong(
HWND hwnd,
WORD id,
LONG l,
BOOL fSigned)
{
    char szT[20];

    ltoa(l, szT, 10);
    SetDlgItemText(hwnd, id, szT);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\src\client\huge.h ===
// header file for HUGE data handle testing module


// PROCS

HDDEDATA CreateHugeDataHandle(LONG length, LONG seed, LONG mult, LONG add,
        HSZ hszItem, WORD wFmt, WORD afCmd);
BOOL CheckHugeData(HDDEDATA hData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\src\client\infoctrl.h ===
/*
 * INFOCTRL.H
 *
 * This module implements a custom information display control which
 * can present up to 7 seperate strings of information at once and is
 * sizeable and moveable with the mouse.
 */

// STYLES

#define ICSTY_OWNERDRAW     0x0001    // set if the central information is not
                                      // standard text.
#define ICSTY_SHOWFOCUS     0x0002    // set to allow focus painting an movement

#define ICSTY_HASFOCUS      0x8000

#define ICN_OWNERDRAW       (WM_USER + 676)     // notifies to draw
            // wParam=id, lParam=OWNERDRAWPS FAR *
#define ICN_HASFOCUS        (WM_USER + 677)     // notifies of focus set
            // wParam=fFocus, lParam=(hMemCtrlData, hwnd)
#define ICN_BYEBYE          (WM_USER + 678)     // notifies of imminent death
            // wParam=hwnd, lParam=dwUser
                  
#define ICM_SETSTRING       (WM_USER + 776)     // alters a string     
            // wParam=index, lParam=LPSTR

#define ICSID_UL            0
#define ICSID_UC            1
#define ICSID_UR            2
#define ICSID_LL            3
#define ICSID_LC            4
#define ICSID_LR            5
#define ICSID_CENTER        6

#define GWW_WUSER           0   // == LOWORD(GWL_LUSER)
#define GWL_LUSER           0
#define GWW_INFODATA        4
#define ICCBWNDEXTRA        6

HWND CreateInfoCtrl(
LPSTR szTitle,
int x,
int y,
int cx,
int cy,
HWND hwndParent,
HANDLE hInst,
LPSTR pszUL,                // NULLs here are fine.
LPSTR pszUC,
LPSTR pszUR,
LPSTR pszLL,
LPSTR pszLC,
LPSTR pszLR,
WORD  style,
HMENU id,
DWORD dwUser);

void CascadeChildWindows(HWND hwndParent);
void TileChildWindows(HWND hwndParent);

typedef struct {
    PSTR pszUL;
    PSTR pszUC;
    PSTR pszUR;
    PSTR pszLL;
    PSTR pszLC;
    PSTR pszLR;
    PSTR pszCenter;
    WORD  style;
    RECT rcFocusUL;
    RECT rcFocusUR;
    RECT rcFocusLL;
    RECT rcFocusLR;
    HANDLE hInst;
} INFOCTRL_DATA;

typedef struct {
    RECT rcBound;
    RECT rcPaint;
    HDC  hdc;
    DWORD dwUser;
} OWNERDRAWPS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\src\client\huge.c ===
/***************************************************************************
 *                                                                         *
 *  MODULE      : huge.c                                                   *
 *                                                                         *
 *  PURPOSE     : This contains functions useful for generating and        *
 *                verifying huge text data blocks.                         *
 *                                                                         *
 ***************************************************************************/

#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <ddeml.h>
#include "huge.h"

extern DWORD idInst;
#define BUFSZ   435

LONG lseed, lmult, ladd;
char szT[BUFSZ];

VOID SetMyRand(LONG seed, LONG mult, LONG add);
char MyRand(VOID);
BOOL RandTest(LONG length, LONG seed, LONG mult, LONG add);

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SetMyRand()                                                *
 *                                                                          *
 *  PURPOSE    : Transfers random sequence generation variables to globals. *
 *                                                                          *
 ****************************************************************************/
VOID SetMyRand(
LONG seed,
LONG mult,
LONG add)
{
    lseed = seed;
    lmult = mult;
    ladd = add;
}


/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MyRand()                                                   *
 *                                                                          *
 *  PURPOSE    : Generates the next random character in a sequence.         *
 *                                                                          *
 *  RETURNS    : the character generated                                    *
 *                                                                          *
 ****************************************************************************/
char MyRand()
{
    char c;
    
    lseed = lseed * lmult + ladd;
    c = (char)(LOWORD(lseed) ^ HIWORD(lseed));
    return((char)((c & (char)0x4f) + ' '));   // 0x20 - 0x6f - all printable
}


/*
 * This function allocates and fills a HUGE data handle with a verifiable
 * text string.
 *
 * The format of the text string is:
 * "<length>=<seed>*<mult>+<add>;---data of length <length>---\0"
 * all values are stored in base 16 numbers.
 */
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : CreateHugeDataHandle()                                     *
 *                                                                          *
 *  PURPOSE    : Generates a huge pseudo-random sequence of printable       *
 *               characters of the length given and places then into        *
 *               a DDEML data handle.                                       *
 *                                                                          *
 *  RETURNS    : The data handle created or 0 on failure.                   *
 *                                                                          *
 ****************************************************************************/
HDDEDATA CreateHugeDataHandle(
LONG length,
LONG seed,
LONG mult,
LONG add,
HSZ hszItem,
WORD wFmt,
WORD afCmd)
{
    register WORD cb;
    HDDEDATA hData;
    DWORD cbData;
    char *psz;

    wsprintf(szT, "%ld=%ld*%ld+%ld;", length, seed, mult, add);
    cb = strlen(szT);
    hData = DdeCreateDataHandle(idInst, szT, cb + 1, 0, hszItem, wFmt, afCmd);
    if (hData) 
        hData = DdeAddData(hData, NULL, 0, cb + length + 1);
    cbData = cb;
    SetMyRand(seed, mult, add);
    while (hData && (length > 0)) {
        psz = szT;
        cb = BUFSZ;
        while (cb--) 
            *psz++ = MyRand();
        hData = DdeAddData(hData, szT, min(length, BUFSZ), cbData);
        cbData += BUFSZ;
        length -= BUFSZ;
    }
    return(hData);
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : CheckHugeData()                                            *
 *                                                                          *
 *  PURPOSE    : Verifies the correctness of a pseudo-random character      *
 *               sequence generated by CreateHugeData.                      *
 *                                                                          *
 *  RETURNS    : TRUE if verified ok, FALSE otherwise.                      *
 *                                                                          *
 ****************************************************************************/
BOOL CheckHugeData(
HDDEDATA hData)
{
    LONG length;
    LONG seed;
    LONG mult;
    LONG add;
    char *psz;
    DWORD cbOff;
    WORD cb;
    
    if (!DdeGetData(hData, szT, BUFSZ, 0))
        return(FALSE);
    szT[BUFSZ - 1] = '\0';
    psz = strchr(szT, ';');
    if (psz == NULL) 
        return(FALSE);
    *psz = '\0';
        
    if (sscanf(szT, "%ld=%ld*%ld+%ld", &length, &seed, &mult, &add) != 4)
        return(FALSE);

    if (length < 0)
        return(FALSE);
    SetMyRand(seed, mult, add);        
    cbOff = strlen(szT) + 1;
    while (length > 0) {
        DdeGetData(hData, szT, BUFSZ, cbOff);
        psz = szT;
        cb = BUFSZ;
        while (length-- && cb--) 
            if (*psz++ != MyRand())
                return(FALSE);
        cbOff += BUFSZ;
        length -= BUFSZ;
    }
    return(TRUE);
}

#if 0
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : RandTest()                                                 *
 *                                                                          *
 *  PURPOSE    : Verifies the correctness of CreateHugeDataHandle() and     *
 *               CheckHugeData().                                           *
 *                                                                          *
 *  RETURNS    :                                                            *
 *                                                                          *
 ****************************************************************************/
BOOL RandTest(
LONG length,
LONG seed,
LONG mult,
LONG add)
{
    HDDEDATA hData;
    BOOL fSuccess;

    hData = CreateHugeDataHandle(length, seed, mult, add, 0, 1, 0);
    if (!hData)
        return(FALSE);
    fSuccess = CheckHugeData(hData);
    DdeFreeDataHandle(hData);
    return(fSuccess);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\src\client\mem.c ===
/***************************************************************************
 *                                                                         *
 *  MODULE      : mem.c                                                    *
 *                                                                         *
 *  PURPOSE     : Functions for debugging memory allocation bugs.          *
 *                                                                         *
 ***************************************************************************/
#include <windows.h>

#define MAX_OBJECTS 200

PSTR aptrs[MAX_OBJECTS];
WORD cptrs = 0;

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DbgAlloc()                                                 *
 *                                                                          *
 *  PURPOSE    : Useful routine for catching memory allocation errors.      *
 *               Enters allocated objects into an array to check when freed *
 *                                                                          *
 *  RETURNS    : pointer to object allocated.                               *
 *                                                                          *
 ****************************************************************************/
PSTR DbgAlloc(
register WORD cb)
{
    register PSTR p;
    
    p = (PSTR)LocalAlloc(LPTR, cb);
    aptrs[cptrs++] = p;
    if (cptrs >= MAX_OBJECTS) 
        OutputDebugString("Too many objects to track");
    return p;
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DbgFree()                                                  *
 *                                                                          *
 *  PURPOSE    : To free an object allocated with DbgAlloc().  Checks the   *
 *               object array to make sure an object isn't freed twice.     *
 *                                                                          *
 *  RETURNS    :                                                            *
 *                                                                          *
 ****************************************************************************/
PSTR DbgFree(
register PSTR p)
{
    register WORD i;

    if (p == NULL) 
        return p;
        
    for (i = 0; i < cptrs; i++) {
        if (aptrs[i] == p) {
            aptrs[i] = aptrs[cptrs - 1];
            break;
        }
    }
    if (i == cptrs) {
        OutputDebugString("Free on non-allocated object");
        DebugBreak();
    } else {
        LocalUnlock((HANDLE)p);
        p = (PSTR)LocalFree((HANDLE)p);
    }
    cptrs--;
    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\src\client\track.h ===
/*
 * TRACK.H
 *
 * This module implements a general rectangle tracking service
 */

/* TrackRect() flags */

#define TF_LEFT			        0x0001
#define TF_TOP			        0x0002
#define TF_RIGHT		        0x0004
#define TF_BOTTOM		        0x0008
#define TF_MOVE			        0x000F
                                
#define TF_SETPOINTERPOS        0x0010
#define TF_ALLINBOUNDARY        0x0080

BOOL TrackRect(HANDLE hInst, HWND hwnd, int left, int top, int right,
        int bottom, int cxMin, int cyMin, WORD fs, LPRECT prcResult);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\wow16\ddeml\tests\src\client\infoctrl.c ===
/***************************************************************************
 *                                                                         *
 *  MODULE      : infoctrl.c                                               *
 *                                                                         *
 *  PURPOSE     : Functions for the infoctrl control class                 *
 *                                                                         *
 ***************************************************************************/
/*
 * INFOCTRL.C
 *
 * This module implements a custom information display control which
 * can present up to 7 seperate strings of information at once and is
 * sizeable and moveable with the mouse.
 */

#include <windows.h>
#include <string.h>
#include <memory.h>
#include "infoctrl.h"
#include "track.h"

char szClass[] = "InfoCtrl_class";
WORD cCreated = 0;
char szNULL[] = "";
int cxMargin = 0;
int cyMargin = 0;
HBRUSH hFocusBrush;


long FAR PASCAL InfoCtrlWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
VOID MyDrawText(HDC hdc, LPRECT lprc, PSTR psz, WORD wFormat);
void DrawFocus(HDC hdc, HWND hwnd, WORD style);
int CountWindows(HWND hwndParent);
void GetCascadeWindowPos(HWND hwndParent, int  iWindow, LPRECT lprc);


/****************************************************************************
 *                                                                          *
 *  FUNCTION   :                                                            *
 *                                                                          *
 *  PURPOSE    :                                                            *
 *                                                                          *
 *  RETURNS    :                                                            *
 *                                                                          *
 ****************************************************************************/
HWND CreateInfoCtrl(
LPSTR pszCenter,              // NULL is ok.
int x,
int y,
int cx,
int cy,
HWND hwndParent,
HANDLE hInst,
LPSTR pszUL,                // NULLs here are fine.
LPSTR pszUC,
LPSTR pszUR,
LPSTR pszLL,
LPSTR pszLC,
LPSTR pszLR,
WORD  style,
HMENU id,
DWORD dwUser)
{
    INFOCTRL_DATA *picd;
    HWND hwnd;

    if (!cCreated) {
        WNDCLASS wc;
        TEXTMETRIC metrics;
        HDC hdc;

        wc.style = CS_VREDRAW | CS_HREDRAW;
        wc.lpfnWndProc = InfoCtrlWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = ICCBWNDEXTRA;
        wc.hInstance = hInst;
        wc.hIcon = NULL;
        wc.hCursor = NULL;
        wc.hbrBackground = COLOR_WINDOW + 1;
        wc.lpszMenuName =  NULL;
        wc.lpszClassName = szClass;
    
        RegisterClass(&wc);
        
        hdc = GetDC(hwndParent);
        GetTextMetrics(hdc, &metrics);
        cyMargin = metrics.tmHeight;
        cxMargin = metrics.tmAveCharWidth * 2;
        ReleaseDC(hwndParent, hdc);
        hFocusBrush = CreateSolidBrush(RGB(0, 0, 255));
    }

    if (!(picd = (INFOCTRL_DATA *)LocalAlloc(LPTR, sizeof(INFOCTRL_DATA))))
        return(FALSE);

    if (pszCenter) {
        picd->pszCenter = (PSTR)(PSTR)LocalAlloc(LPTR, _fstrlen(pszCenter) + 1);
        _fstrcpy(picd->pszCenter, pszCenter);
    } else {
        picd->pszCenter = NULL;
    }
        
    if (pszUL) {
        picd->pszUL = (PSTR)(PSTR)LocalAlloc(LPTR, _fstrlen(pszUL) + 1);
        _fstrcpy(picd->pszUL, pszUL);
    } else {
        picd->pszUL = NULL;
    }
    if (pszUC) {
        picd->pszUC = (PSTR)LocalAlloc(LPTR, _fstrlen(pszUC) + 1);
        _fstrcpy(picd->pszUC, pszUC);
    } else {
        picd->pszUC = NULL;
    }
    if (pszUR) {
        picd->pszUR = (PSTR)LocalAlloc(LPTR, _fstrlen(pszUR) + 1);
        _fstrcpy(picd->pszUR, pszUR);
    } else {
        picd->pszUR = NULL;
    }
    if (pszLL) {
        picd->pszLL = (PSTR)LocalAlloc(LPTR, _fstrlen(pszLL) + 1);
        _fstrcpy(picd->pszLL, pszLL);
    } else {
        picd->pszLL = NULL;
    }
    if (pszLC) {
        picd->pszLC = (PSTR)LocalAlloc(LPTR, _fstrlen(pszLC) + 1);
        _fstrcpy(picd->pszLC, pszLC);
    } else {
        picd->pszLC = NULL;
    }
    if (pszLR) {
        picd->pszLR = (PSTR)LocalAlloc(LPTR, _fstrlen(pszLR) + 1);
        _fstrcpy(picd->pszLR, pszLR);
    } else {
        picd->pszLR = NULL;
    }
    
    picd->style = style;
    picd->hInst = hInst;

    if (hwnd = CreateWindow(szClass, szNULL,
            WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS,
            x, y, cx, cy, hwndParent, id, hInst, (LPSTR)picd)) {
        cCreated++;
        SetWindowLong(hwnd, GWL_LUSER, dwUser);
        BringWindowToTop(hwnd);
        ShowWindow(hwnd, SW_SHOW);
        return(hwnd);
    }
    return(FALSE);
}




/****************************************************************************
 *                                                                          *
 *  FUNCTION   :                                                            *
 *                                                                          *
 *  PURPOSE    :                                                            *
 *                                                                          *
 *  RETURNS    :                                                            *
 *                                                                          *
 ****************************************************************************/
VOID MyDrawText(
HDC hdc,
LPRECT lprc,
PSTR psz,
WORD wFormat)
{
    RECT rc;
    WORD cx;

    if (psz == NULL || !*psz)
        return; // notin to draw dude.
        
    SetRect(&rc, 0, 0, 1, 0);
    DrawText(hdc, psz, -1, &rc, DT_CALCRECT | DT_NOCLIP | DT_SINGLELINE);
    cx = min(rc.right - rc.left, lprc->right - lprc->left);
    CopyRect(&rc, lprc);
    switch (wFormat & (DT_LEFT | DT_CENTER | DT_RIGHT)) {
    case DT_LEFT:
        rc.right = rc.left + cx;
        break;

    case DT_CENTER:
        cx = (rc.right - rc.left - cx) / 2;
        rc.right -= cx;
        rc.left += cx;
        break;

    case DT_RIGHT:
        rc.left = rc.right - cx;
        break;
    }
    DrawText(hdc, psz, -1, &rc, wFormat | DT_VCENTER);
}




/****************************************************************************
 *                                                                          *
 *  FUNCTION   :                                                            *
 *                                                                          *
 *  PURPOSE    :                                                            *
 *                                                                          *
 *  RETURNS    :                                                            *
 *                                                                          *
 ****************************************************************************/
long FAR PASCAL InfoCtrlWndProc(
HWND hwnd,
UINT msg,
WPARAM wParam,
LPARAM lParam)
{
    INFOCTRL_DATA *picd;
    int i;
    RECT rc;
    HDC hdc;
    
    switch (msg) {
    case WM_CREATE:
        SetWindowWord(hwnd, GWW_INFODATA,
                (WORD)(DWORD)(((LPCREATESTRUCT)lParam)->lpCreateParams));
        break;
        
    case WM_SIZE:
        if ((int)LOWORD(lParam) < 2 * cxMargin || (int)HIWORD(lParam) < 2 * cyMargin) {
            MoveWindow(hwnd, 0, 0, max((int)LOWORD(lParam), 2 * cxMargin),
                max((int)HIWORD(lParam), 2 * cyMargin), TRUE);
        } else {
            picd = (INFOCTRL_DATA *)GetWindowWord(hwnd, GWW_INFODATA);
            SetRect(&picd->rcFocusUL, 0, 0, cxMargin, cyMargin);
            SetRect(&picd->rcFocusUR, (int)LOWORD(lParam) - cxMargin, 0, (int)LOWORD(lParam),
                    cyMargin);
            SetRect(&picd->rcFocusLL, 0, (int)HIWORD(lParam) - cyMargin, cxMargin,
                    (int)HIWORD(lParam));
            SetRect(&picd->rcFocusLR, picd->rcFocusUR.left, picd->rcFocusLL.top,
                    picd->rcFocusUR.right, picd->rcFocusLL.bottom);
        }
        break;


    case WM_DESTROY:
        {
            PSTR *ppsz;
            
            SendMessage(GetParent(hwnd), ICN_BYEBYE, hwnd,
                    GetWindowLong(hwnd, GWL_LUSER));
            picd = (INFOCTRL_DATA *)GetWindowWord(hwnd, GWW_INFODATA);
            ppsz = &picd->pszUL;
            for (i = 0; i < 5; i++, ppsz++) {
                if (*ppsz) {
                    LocalUnlock((HANDLE)*ppsz);
                    *ppsz = (PSTR)LocalFree((HANDLE)*ppsz);
                }
            }
            LocalUnlock((HANDLE)picd);
            SetWindowWord(hwnd, GWW_INFODATA, LocalFree((HANDLE)picd));
        }
        break;
            
    case WM_SETFOCUS:
    case WM_KILLFOCUS:
        picd = (INFOCTRL_DATA *)GetWindowWord(hwnd, GWW_INFODATA);
        if (picd->style & ICSTY_SHOWFOCUS) {
            if (msg == WM_SETFOCUS) 
                picd->style |= ICSTY_HASFOCUS;
            else
                picd->style &= ~ICSTY_HASFOCUS;
            BringWindowToTop(hwnd);
            // notify parent
            SendMessage(GetParent(hwnd), ICN_HASFOCUS,
                    msg == WM_SETFOCUS, MAKELONG(picd, hwnd));
        } else 
            picd->style &= ~ICSTY_HASFOCUS;
        hdc = GetDC(hwnd);
        DrawFocus(hdc, hwnd, picd->style);
        ReleaseDC(hwnd, hdc);
        goto DoDWP;
        break;

    case WM_MOUSEMOVE:
        {
            LPCSTR cursor;

            picd = (INFOCTRL_DATA *)GetWindowWord(hwnd, GWW_INFODATA);
            if (picd->style & ICSTY_SHOWFOCUS) {
                
                if ((int)HIWORD(lParam) < cyMargin) {
                    if ((int)LOWORD(lParam) < cxMargin) {
                        cursor = IDC_SIZENWSE;
                    } else if ((int)LOWORD(lParam) > picd->rcFocusUR.left) {
                        cursor = IDC_SIZENESW;
                    } else {
                        cursor = IDC_SIZENS;
                    }
                } else if ((int)HIWORD(lParam) > picd->rcFocusLL.top) {
                    if ((int)LOWORD(lParam) < cxMargin) {
                        cursor = IDC_SIZENESW;
                    } else if ((int)LOWORD(lParam) > picd->rcFocusUR.left) {
                        cursor = IDC_SIZENWSE;
                    } else {
                        cursor = IDC_SIZENS;
                    }
                } else {
                    if ((int)LOWORD(lParam) < cxMargin) {
                        cursor = IDC_SIZEWE;
                    } else if ((int)LOWORD(lParam) > picd->rcFocusUR.left) {
                        cursor = IDC_SIZEWE;
                    } else {
                        cursor = IDC_CROSS;
                    }
                }
            } else {
                cursor = IDC_ARROW;
            }
            SetCursor(LoadCursor(NULL, cursor));
        }
        break;
        
    case WM_LBUTTONDOWN:
        picd = (INFOCTRL_DATA *)GetWindowWord(hwnd, GWW_INFODATA);
        if (picd->style & ICSTY_SHOWFOCUS) {
            WORD fs = 0;

            if (!(picd->style & ICSTY_HASFOCUS)) {
                SetFocus(hwnd);
            }
            
            if ((int)HIWORD(lParam) < cyMargin) {
                fs = TF_TOP;
            } else if ((int)HIWORD(lParam) > picd->rcFocusLL.top) {
                fs = TF_BOTTOM;
            }
            if ((int)LOWORD(lParam) < cxMargin) {
                fs |= TF_LEFT;
            } else if ((int)LOWORD(lParam) > picd->rcFocusUR.left) {
                fs |= TF_RIGHT;
            } else if (fs == 0) {
                fs = TF_MOVE;
            }
            
            GetClientRect(hwnd, &rc);
            ClientToScreen(hwnd, (LPPOINT)&rc.left);
            ClientToScreen(hwnd, (LPPOINT)&rc.right);
            ScreenToClient(GetParent(hwnd), (LPPOINT)&rc.left);
            ScreenToClient(GetParent(hwnd), (LPPOINT)&rc.right);
            if (TrackRect(picd->hInst, GetParent(hwnd),
                    rc.left, rc.top, rc.right, rc.bottom,
                    2 * cxMargin, 2 * cyMargin,
                    fs | TF_ALLINBOUNDARY, &rc)) {
                
                MoveWindow(hwnd, rc.left, rc.top, rc.right - rc.left,
                        rc.bottom - rc.top, TRUE);
            }
        }
        break;

    case ICM_SETSTRING:
        {
            PSTR *ppsz;
            
            picd = (INFOCTRL_DATA *)GetWindowWord(hwnd, GWW_INFODATA);
            ppsz = (PSTR *)&picd->pszUL + wParam;

            if (lParam == NULL)
                lParam = (DWORD)(LPSTR)szNULL;
                
            if (!_fstrcmp(*ppsz, (LPSTR)lParam)) 
                return 0;
                
            if (*ppsz) {
                LocalUnlock((HANDLE)*ppsz);
                *ppsz = (PSTR)LocalFree((HANDLE)*ppsz);
            }
            if (lParam) {
                *ppsz = (PSTR)LocalAlloc(LPTR, _fstrlen((LPSTR)lParam) + 1);
                _fstrcpy((LPSTR)*ppsz, (LPSTR)lParam);
            }
            GetClientRect(hwnd, &rc);
            switch (wParam) {
            case ICSID_UL:
            case ICSID_UC:
            case ICSID_UR:
                rc.bottom = cyMargin;
                break;
                
            case ICSID_LL:
            case ICSID_LC:
            case ICSID_LR:
                rc.top = rc.bottom - cyMargin;
                break;
                
            case ICSID_CENTER:
                InflateRect(&rc, -cxMargin, -cyMargin);
                break;
            }
            InvalidateRect(hwnd, &rc, TRUE);
            UpdateWindow(hwnd);    
        }        
        break;
                
    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HANDLE brush;

            picd = (INFOCTRL_DATA *)GetWindowWord(hwnd, GWW_INFODATA);
            BeginPaint(hwnd, &ps);
            // erasure should have already been done for us.
            GetClientRect(hwnd, &rc);
            brush = GetStockObject(BLACK_BRUSH);
            InflateRect(&rc, -cxMargin / 2, -cyMargin / 2);
            FrameRect(ps.hdc, &rc, brush);
            InflateRect(&rc, cxMargin / 2, cyMargin / 2);
            if (*picd->pszUL || *picd->pszUC || *picd->pszUR) {
                SetRect(&rc, picd->rcFocusUL.right, 0, picd->rcFocusUR.left,
                        cyMargin);
                MyDrawText(ps.hdc, &rc, picd->pszUR, DT_RIGHT);
                MyDrawText(ps.hdc, &rc, picd->pszUL, DT_LEFT);
                MyDrawText(ps.hdc, &rc, picd->pszUC, DT_CENTER);
            }
            if (*picd->pszLL || *picd->pszLC || *picd->pszLR) {
                SetRect(&rc, picd->rcFocusLL.right, picd->rcFocusLL.top,
                        picd->rcFocusLR.left, picd->rcFocusLR.bottom);
                MyDrawText(ps.hdc, &rc, picd->pszLR, DT_RIGHT);
                MyDrawText(ps.hdc, &rc, picd->pszLL, DT_LEFT);
                MyDrawText(ps.hdc, &rc, picd->pszLC, DT_CENTER);
            }
            
            GetClientRect(hwnd, &rc);
            InflateRect(&rc, -cxMargin, -cyMargin);
            if (picd->style & ICSTY_OWNERDRAW) {
                OWNERDRAWPS odps;
                
                if (IntersectRect(&odps.rcPaint, &rc, &ps.rcPaint)) {
                    if (IntersectClipRect(ps.hdc, rc.left, rc.top, rc.right,
                            rc.bottom) != NULLREGION) {
                        odps.rcBound = rc;
                        odps.hdc = ps.hdc;
                        odps.dwUser = GetWindowLong(hwnd, GWL_LUSER);
                        SendMessage(GetParent(hwnd), ICN_OWNERDRAW,
                                GetWindowWord(hwnd, GWW_ID), (DWORD)(LPSTR)&odps);
                    }
                }
            } else {
                MyDrawText(ps.hdc, &rc, picd->pszCenter, DT_LEFT | DT_WORDBREAK | DT_EXPANDTABS);
            }
            DrawFocus(ps.hdc, hwnd, picd->style);
            EndPaint(hwnd, &ps);
        }
        break;

DoDWP:        
    default:
        return (DefWindowProc(hwnd, msg, wParam, lParam));
    }
    return (NULL);
}


/****************************************************************************
 *                                                                          *
 *  FUNCTION   :                                                            *
 *                                                                          *
 *  PURPOSE    :                                                            *
 *                                                                          *
 *  RETURNS    :                                                            *
 *                                                                          *
 ****************************************************************************/
void DrawFocus(
HDC hdc,
HWND hwnd,
WORD style)
{
    RECT rc;

    GetClientRect(hwnd, &rc);
    FrameRect(hdc, &rc, style & ICSTY_HASFOCUS ?
            hFocusBrush : GetStockObject(GRAY_BRUSH));
}




/****************************************************************************
 *                                                                          *
 *  FUNCTION   :                                                            *
 *                                                                          *
 *  PURPOSE    :                                                            *
 *                                                                          *
 *  RETURNS    :                                                            *
 *                                                                          *
 ****************************************************************************/
int CountWindows(
register HWND hwndParent)
{
  int cWindows = 0;
  register HWND hwnd;

  for (hwnd=GetWindow(hwndParent, GW_CHILD);
        hwnd;
        hwnd= GetWindow(hwnd, GW_HWNDNEXT)) {
      cWindows++;
  }
  return(cWindows);
}



/****************************************************************************
 *                                                                          *
 *  FUNCTION   :                                                            *
 *                                                                          *
 *  PURPOSE    :                                                            *
 *                                                                          *
 *  RETURNS    :                                                            *
 *                                                                          *
 ****************************************************************************/
void GetCascadeWindowPos(
HWND hwndParent,
int  iWindow,
LPRECT lprc)
{
  RECT      rc;
  int       cStack;
  register int dxClient, dyClient;

  /* Compute the width and breadth of the situation. */
  GetClientRect(hwndParent, (LPRECT)&rc);
  dxClient = rc.right - rc.left;
  dyClient = rc.bottom - rc.top;

  /* How many windows per stack? */
  cStack = dyClient / (3 * cyMargin);

  lprc->right = dxClient - (cStack * cxMargin);
  lprc->bottom = dyClient - (cStack * cyMargin);

  cStack++;             /* HACK!: Mod by cStack+1 */

  lprc->left = (iWindow % cStack) * cxMargin;
  lprc->top = (iWindow % cStack) * cyMargin;
}




/****************************************************************************
 *                                                                          *
 *  FUNCTION   :                                                            *
 *                                                                          *
 *  PURPOSE    :                                                            *
 *                                                                          *
 *  RETURNS    :                                                            *
 *                                                                          *
 ****************************************************************************/
void CascadeChildWindows(
register HWND hwndParent)
{
  int       i;
  int       cWindows;
  RECT      rc;
  WORD      wFlags;
  register HWND hwndMove;
  HANDLE    hDefer;

  cWindows = CountWindows(hwndParent);

  if (!cWindows)
      return;

  /* Get the last child of hwndParent. */
  hwndMove = GetWindow(hwndParent, GW_CHILD);

  /* Arouse the terrible beast... */
  hDefer = BeginDeferWindowPos(cWindows);

  /* Position each window. */
  for (i=0; i < cWindows; i++) {
      GetCascadeWindowPos(hwndParent, i, (LPRECT)&rc);

      wFlags = SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOCOPYBITS;

      /* Size the window. */
      hDefer = DeferWindowPos(hDefer,
                 hwndMove, NULL,
                 rc.left, rc.top,
                 rc.right, rc.bottom,
                 wFlags);

      hwndMove = GetWindow(hwndMove, GW_HWNDNEXT);
  }

  /* Calm the brute. */
  EndDeferWindowPos(hDefer);
}


/****************************************************************************
 *                                                                          *
 *  FUNCTION   :                                                            *
 *                                                                          *
 *  PURPOSE    :                                                            *
 *                                                                          *
 *  RETURNS    :                                                            *
 *                                                                          *
 ****************************************************************************/
void TileChildWindows(
register HWND hwndParent)
{
  int       i;
  int       dx;
  int       dy;
  int       xRes;
  int       yRes;
  int       iCol;
  int       iRow;
  int       cCols;
  int       cRows;
  int       cExtra;
  int       cWindows;
  register HWND hwndMove;
  RECT      rcClient;
  HANDLE    hDefer;
 