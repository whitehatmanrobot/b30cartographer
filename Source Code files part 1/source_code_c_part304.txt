O_PENDING)
        {
        COMMON_AddressManager(pAddress);
        }

    return;
}


RPC_STATUS
NMP_NewConnection(
    IN PADDRESS Address,
    OUT PCONNECTION *ppConnection
    )
/*++

Routine Description:

    Called when an ConnectNamedPipe completes on the main recv any thread.

    Can't fail after it calls I_RpcTransServerNewConnection().

Arguments:

    pAddress - The address used as context in a previous AcceptEx.
    ppConnection - A place to store the new pConnection.  Used
        when a connection been created and then a failure occurs.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_RESOURCES
    RPC_S_OUT_OF_MEMORY

--*/
{
    RPC_STATUS status;

    NMP_ADDRESS *pAddress = (NMP_ADDRESS *)Address;
    HANDLE hClient = pAddress->hConnectPipe;
    NMP_CONNECTION *pConnection;

    // First, submit an new instance for the next client

    pAddress->hConnectPipe = 0;
    NMP_SubmitConnect(pAddress);

    // Allocate a new connection object

    pConnection = (PNMP_CONNECTION)I_RpcTransServerNewConnection(pAddress);

    *ppConnection = pConnection;

    if (!pConnection)
        {
        CloseHandle(hClient);
        return(RPC_S_OUT_OF_MEMORY);
        }

    // Got a good connection, initialize it..
    // start with the vtbl
    pConnection = new (pConnection) NMP_CONNECTION;
    pConnection->type = SERVER | CONNECTION;
    pConnection->id = NMP;
    pConnection->Conn.Handle = hClient;
    pConnection->fAborted = 0;
    pConnection->pReadBuffer = 0;
    pConnection->maxReadBuffer = 0;
    pConnection->iLastRead = 0;
    pConnection->iPostSize = gPostSize;
    memset(&pConnection->Read.ol, 0, sizeof(pConnection->Read.ol));
    pConnection->Read.pAsyncObject = pConnection;
    pConnection->InitIoCounter();
    pConnection->pAddress = pAddress;

    return(RPC_S_OK);
}

RPC_CHAR *
ULongToHexString (
    IN RPC_CHAR * String,
    IN unsigned long Number
    );

#ifdef TRANSPORT_DLL

RPC_CHAR *
ULongToHexString (
    IN RPC_CHAR * String,
    IN unsigned long Number
    )
/*++

Routine Description:

    We convert an unsigned long into hex representation in the specified
    string.  The result is always eight characters long; zero padding is
    done if necessary.

Arguments:

    String - Supplies a buffer to put the hex representation into.

    Number - Supplies the unsigned long to convert to hex.

Return Value:

    A pointer to the end of the hex string is returned.

--*/
{
    *String++ = HexDigits[(Number >> 28) & 0x0F];
    *String++ = HexDigits[(Number >> 24) & 0x0F];
    *String++ = HexDigits[(Number >> 20) & 0x0F];
    *String++ = HexDigits[(Number >> 16) & 0x0F];
    *String++ = HexDigits[(Number >> 12) & 0x0F];
    *String++ = HexDigits[(Number >> 8) & 0x0F];
    *String++ = HexDigits[(Number >> 4) & 0x0F];
    *String++ = HexDigits[Number & 0x0F];
    return(String);
}
#endif


#define NMP_EP_TRAILER_LENGTH 8

RPC_STATUS
NMP_ServerListen(
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN PWSTR NetworkAddress,
    IN OUT PWSTR *pEndpoint,
    IN UINT PendingQueueSize,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG EndpointFlags,
    IN ULONG NICFlags
    )
/*++

Routine Description:

    This routine allocates a new pipe to receive new client connections.
    If successful a call to NMP_CompleteListen() will actually allow
    new connection callbacks to the RPC runtime to occur.  Setup
    before the call to NMP_CompleteListen() can be stopped after this
    function call with a call to NMP_ServerAbortListen().

Arguments:

    pAddress - A pointer to the loadable transport interface address.
    pEndpoint - Optionally, the endpoint (pipe) to listen on.  Set
        to listened pipe for dynamic endpoints.
    PendingQueueSize - Meaningless for named pipes.
    EndpointFlags - Meaningless for named pipes.
    NICFlags - Meaningless for named pipes.
    SecurityDescriptor - The SD to associate with this address.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_INVALID_SECURITY_DESC

--*/
{
    BOOL b;
    INT i;
    RPC_STATUS status;
    PWSTR LocalPipeEndpoint;
    PNMP_ADDRESS pAddress = (PNMP_ADDRESS)ThisAddress;
    BOOL fEndpointCreated = FALSE;

    pAddress->type = ADDRESS;
    pAddress->id = NMP;
    pAddress->NewConnection = NMP_NewConnection;
    pAddress->SubmitListen = NMP_SubmitConnect;
    pAddress->InAddressList = NotInList;
    pAddress->pNext = 0;
    pAddress->hConnectPipe = 0;
    memset(&pAddress->Listen, 0, sizeof(BASE_OVERLAPPED));
    pAddress->Listen.pAsyncObject = pAddress;
    pAddress->pAddressVector = 0;
    pAddress->LocalEndpoint = 0;
    pAddress->Endpoint = 0;
    pAddress->pNextAddress = 0;
    pAddress->pFirstAddress = pAddress;
    pAddress->sparePipes.Init();


    // Determine the network address we'll try to listen on

    if (*pEndpoint)
        {
        // User specified an endpoint to use.

        if (RpcpStringNCompare(*pEndpoint, RPC_CONST_STRING("\\pipe\\"), 6) != 0)
            return(RPC_S_INVALID_ENDPOINT_FORMAT);

        i = RpcpStringLength(*pEndpoint) + 1 + 3; // NULL, \\, \\, .

        LocalPipeEndpoint = new RPC_CHAR[i];

        if (NULL == LocalPipeEndpoint)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }

        LocalPipeEndpoint[0] = L'\\';
        LocalPipeEndpoint[1] = L'\\';
        LocalPipeEndpoint[2] = L'.';
        RpcpStringCopy(&LocalPipeEndpoint[3], *pEndpoint);
        }
    else
        {
        // Make up an endpoint to use.
        // Format: \\.\pipe\<eight byte random number (16 hex digits)>\0
        BYTE RandomBytes[NMP_EP_TRAILER_LENGTH];
        
        status = GenerateRandomNumber(&RandomBytes[0], 8);
        if (status != RPC_S_OK)
            {
            return status;
            }

        LocalPipeEndpoint = new RPC_CHAR[3 + 6 + 16 + 1];

        if (NULL == LocalPipeEndpoint)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }

        LONG counter;
        PWSTR pwstrT = LocalPipeEndpoint;

        *pwstrT++ = RPC_CONST_CHAR('\\');
        *pwstrT++ = RPC_CONST_CHAR('\\');
        *pwstrT++ = RPC_CONST_CHAR('.');
        *pwstrT++ = RPC_CONST_CHAR('\\');
        *pwstrT++ = RPC_CONST_CHAR('p');
        *pwstrT++ = RPC_CONST_CHAR('i');
        *pwstrT++ = RPC_CONST_CHAR('p');
        *pwstrT++ = RPC_CONST_CHAR('e');
        *pwstrT++ = RPC_CONST_CHAR('\\');
        
        for (i=0; i < NMP_EP_TRAILER_LENGTH; i++)
            {
            *pwstrT++ = HexDigits[(RandomBytes[i] >> 4) & 0x0F];
            *pwstrT++ = HexDigits[RandomBytes[i] & 0x0F];
            }
        *pwstrT = 0;

        *pEndpoint = DuplicateString(LocalPipeEndpoint + 3);
        if (!(*pEndpoint))
            {
            delete [] LocalPipeEndpoint;
            return RPC_S_OUT_OF_MEMORY;
            }

        fEndpointCreated = TRUE;
        }

    // Security setup

    status = NMP_SetSecurity(pAddress, SecurityDescriptor);

    if (status != RPC_S_OK)
        {
        delete [] LocalPipeEndpoint;
        if (fEndpointCreated)
            delete *pEndpoint;
        return(status);
        }

    // Network address setup

    NETWORK_ADDRESS_VECTOR *pVector;

    pVector =  new(  sizeof(RPC_CHAR *)
                   + (3 + gdwComputerNameLength) * sizeof(RPC_CHAR))
                   NETWORK_ADDRESS_VECTOR;

    if (NULL == pVector)
        {
        NMP_ServerAbortListen(pAddress);
        delete [] LocalPipeEndpoint;
        if (fEndpointCreated)
            delete *pEndpoint;
        return(RPC_S_OUT_OF_MEMORY);
        }

    pVector->Count = 1;
    pVector->NetworkAddresses[0] = (RPC_CHAR *)&pVector->NetworkAddresses[1];

    RpcpStringCopy(pVector->NetworkAddresses[0], RPC_CONST_STRING("\\\\"));
    RpcpStringCat(pVector->NetworkAddresses[0], gpstrComputerName);

    //
    // Setup address
    //

    pAddress->Endpoint = LocalPipeEndpoint + 3;
    pAddress->LocalEndpoint = LocalPipeEndpoint;
    pAddress->pAddressVector = pVector;

    // We need to create two pipe instances to start with.  This is necessary
    // to avoid a race where a client connects and quickly disconnects.
    // Before the server can submit the next connect another client fails with
    // RPC_S_SERVER_UNAVAILABLE.  The extra pipe instance forces the client to
    // retry and everything works.

    HANDLE hSpares[2];

    for (i = 0; i < 2; i++)
        {
        status = NMP_CreatePipeInstance(pAddress);
        ASSERT(status != RPC_P_FOUND_IN_CACHE);

        if (status != RPC_S_OK)
            {
            ASSERT(pAddress->hConnectPipe == 0);
            break;
            }

        hSpares[i] = pAddress->hConnectPipe;
        pAddress->hConnectPipe = 0;

        status = COMMON_PrepareNewHandle(hSpares[i]);

        if (status != RPC_S_OK)
            {
            break;
            }
        }

    if (status != RPC_S_OK)
        {
        NMP_ServerAbortListen(pAddress);
        if (fEndpointCreated)
            delete *pEndpoint;
        return(status);
        }

    // Move the pipe instances back into the address.

    pAddress->sparePipes.CheckinHandle(&hSpares[0]);
    // assert that it succeeded (i.e. did not zero out the handle)
    ASSERT(hSpares[0] == NULL);

    pAddress->sparePipes.CheckinHandle(&hSpares[1]);
    ASSERT(hSpares[1] == NULL);

    //
    // Done with phase one, now return to the runtime and wait.
    //

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
NMP_ConnectionImpersonateClient (
    IN RPC_TRANSPORT_CONNECTION SConnection
    )
// Impersonate the client at the other end of the connection.
{
    NMP_CONNECTION *p = (NMP_CONNECTION *)SConnection;
    BOOL b;

    p->StartingOtherIO();

    if (p->fAborted)
        {
        p->OtherIOFinished();
        return(RPC_S_NO_CONTEXT_AVAILABLE);
        }

    b = ImpersonateNamedPipeClient(p->Conn.Handle);

    p->OtherIOFinished();

    if (!b)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "ImpersonateNamedPipeClient (%p) failed %d\n",
                       p,
                       GetLastError() ));

        return(RPC_S_NO_CONTEXT_AVAILABLE);
        }
    return(RPC_S_OK);
}

RPC_STATUS
RPC_ENTRY
NMP_ConnectionRevertToSelf (
    RPC_TRANSPORT_CONNECTION SConnection
    )
/*++

Routine Description:

    We want to stop impersonating the client. This means we want
    the current thread's security context to revert the the
    default.

Arguments:

    SConnection - unused

Return Value:

    RPC_S_OK

    RPC_S_INTERNAL_ERROR - Not impersonating or something else went wrong.
                           (Debug systems only)
--*/
{
    BOOL b;

    UNUSED(SConnection);

    b = RevertToSelf();

#if DBG
    if (!b)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "RevertToSelf failed %d\n",
                       GetLastError()));

        ASSERT(b);
        return(RPC_S_INTERNAL_ERROR);
        }
#endif

    return(RPC_S_OK);
}

RPC_STATUS RPC_ENTRY
NMP_ConnectionQueryClientAddress(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT RPC_CHAR **pNetworkAddress
    )
/*++

Routine Description:

    Returns the address of the client.  Uses an extended in NT 5
    ioctl to reterive the client machine name from named pipes.

Arguments:

    ThisConnection - The server connection of interest.
    NetworkAddress - Will contain the string on success.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_RESOURCES
    RPC_S_OUT_OF_MEMORY

--*/

{
    NTSTATUS NtStatus;
    RPC_STATUS status;
    IO_STATUS_BLOCK IoStatus;
    NMP_CONNECTION *p = (NMP_CONNECTION *)ThisConnection;
    FILE_PIPE_CLIENT_PROCESS_BUFFER_EX ClientProcess;
    HANDLE hEvent = I_RpcTransGetThreadEvent();
    DWORD size;

    ClientProcess.ClientComputerNameLength = 0;

    ASSERT(hEvent);

    p->StartingOtherIO();

    if (p->fAborted)
        {
        p->OtherIOFinished();
        return(RPC_S_NO_CONTEXT_AVAILABLE);
        }

    NtStatus = NtFsControlFile(p->Conn.Handle,
                               hEvent,
                               0,
                               0,
                               &IoStatus,
                               FSCTL_PIPE_QUERY_CLIENT_PROCESS,
                               0,
                               0,
                               &ClientProcess,
                               sizeof(FILE_PIPE_CLIENT_PROCESS_BUFFER_EX));

    p->OtherIOFinished();

    if (NtStatus == STATUS_PENDING)
        {
        status = WaitForSingleObject(hEvent, INFINITE);
        ASSERT(status == WAIT_OBJECT_0);
        if (status != WAIT_OBJECT_0)
            {
            return(RPC_S_OUT_OF_RESOURCES);
            }
        }

    if (!NT_SUCCESS(NtStatus))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "QUERY_PIPE_PROCESS ioctl failed %x\n",
                       NtStatus));

        return(RPC_S_OUT_OF_RESOURCES);
        }

    if (ClientProcess.ClientComputerNameLength == 0)
        {
        // Must be local, no ID.  Just copy the local computer name into the
        // buffer and continue.

        size = gdwComputerNameLength;  // Includes null
        wcscpy(ClientProcess.ClientComputerBuffer, gpstrComputerName);
        }
    else
        {
        ASSERT(wcslen(ClientProcess.ClientComputerBuffer) < 16);

        // Convert from bytes to characters, add one for the null.

        size = ClientProcess.ClientComputerNameLength/2 + 1;
        }

    *pNetworkAddress = new WCHAR[size];
    if (!*pNetworkAddress)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    wcscpy(*pNetworkAddress, ClientProcess.ClientComputerBuffer);

    return(RPC_S_OK);
}

RPC_STATUS RPC_ENTRY
NMP_ConnectionQueryClientId (
    IN RPC_TRANSPORT_CONNECTION SConnection,
    OUT RPC_CLIENT_PROCESS_IDENTIFIER * ClientProcess
    )
/*++

Routine Description:

    We want to query the identifier of the client process at the other
    of this named pipe.  Two pipes from the same client process will always
    return the same identifier for their client process.  Likewise, two
    pipes from different client processes will never return the same
    identifier for their respective client process.

    This is one of the few things you can't do in win32.

Arguments:

    SConnection - Supplies the named pipe instance for which we want to
        obtain the client process identifier.

    ClientProcess - Returns the identifier for the client process at the
        other end of this named pipe instance.

Return Value:

    RPC_S_OK - This value will always be returned.

--*/
{
    NTSTATUS NtStatus;
    RPC_STATUS status;
    IO_STATUS_BLOCK IoStatus;
    NMP_CONNECTION *p = (NMP_CONNECTION *)SConnection;
    FILE_PIPE_CLIENT_PROCESS_BUFFER ClientProcessBuffer;
    HANDLE hEvent = I_RpcTransGetThreadEvent();
    BOOL fLocal;

    ClientProcess->ZeroOut();

    ASSERT(hEvent);

    p->StartingOtherIO();

    if (p->fAborted)
        {
        p->OtherIOFinished();
        return(RPC_S_NO_CONTEXT_AVAILABLE);
        }

    NtStatus = NtFsControlFile(p->Conn.Handle,
                               hEvent,
                               0,
                               0,
                               &IoStatus,
                               FSCTL_PIPE_QUERY_CLIENT_PROCESS,
                               0,
                               0,
                               &ClientProcessBuffer,
                               sizeof(FILE_PIPE_CLIENT_PROCESS_BUFFER));

    p->OtherIOFinished();

    if (NtStatus == STATUS_PENDING)
        {
        status = WaitForSingleObject(hEvent, INFINITE);
        ASSERT(status == WAIT_OBJECT_0);
        if (status != WAIT_OBJECT_0)
            {
            return(RPC_S_OUT_OF_RESOURCES);
            }
        }

    if (NT_SUCCESS(NtStatus))
        {
        if (ClientProcessBuffer.ClientSession)
            {
            ClientProcessBuffer.ClientSession = 0;
            fLocal = FALSE;
            }
        else
            fLocal = TRUE;

        ClientProcess->SetNMPClientIdentifier(&ClientProcessBuffer, fLocal);
        }

    return(RPC_S_OK);
}

NETWORK_ADDRESS_VECTOR *
NMP_GetNetworkAddressVector (
    IN RPC_TRANSPORT_ADDRESS Address
    )
{
    NMP_ADDRESS *p = (NMP_ADDRESS *)Address;
    return p->pAddressVector;
}


RPC_STATUS
RPC_ENTRY
NMP_Initialize (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN RPC_CHAR * NetworkAddress,
    IN RPC_CHAR * NetworkOptions,
    IN BOOL fAsync
    )
/*++

Routine Description:

    Initialize the connection. This function is guaranteed to be called
    in the thread that called GetBuffer.

Arguments:

    ThisConnection - A place to store the connection
*/
{
    PNMP_CONNECTION pConnection = (PNMP_CONNECTION)ThisConnection;

    // use explicit placement to initialize vtbl
    pConnection = new (pConnection) NMP_CONNECTION;

    pConnection->id = NMP;
    pConnection->Initialize();
    pConnection->pAddress = 0;

    return RPC_S_OK;
}



RPC_STATUS
RPC_ENTRY
NMP_Open(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN RPC_CHAR * ProtocolSequence,
    IN RPC_CHAR * NetworkAddress,
    IN RPC_CHAR * Endpoint,
    IN RPC_CHAR * NetworkOptions,
    IN UINT ConnTimeout,
    IN UINT SendBufferSize,
    IN UINT RecvBufferSize,
    IN void *ResolverHint,
    IN BOOL fHintInitialized,
    IN ULONG CallTimeout,
    IN ULONG AdditionalTransportCredentialsType, OPTIONAL
    IN void *AdditionalCredentials OPTIONAL
    )
/*++

Routine Description:

    Opens a connection to a server.

Arguments:

    ThisConnection - A place to store the connection
    ProtocolSeqeunce - "ncacn_np"
    NetworkAddress - The name of the server, with or without the '\\'
    NetworkOptions - Options from the string binding.  For security:

        security=
            [anonymous|identification|impersonation|delegation]
            [dynamic|static]
            [true|false]

        All three fields must be present.  To specify impersonation
        with dynamic tracking and effective only, use the following
        string for the network options.

        "security=impersonation dynamic true"

    ConnTimeout - See RpcMgmtSetComTimeout
            0 - Min
            5 - Default
            9 - Max
            10 - Infinite

    {Send,Recv}BufferSize - Ignored.

    CallTimeout - call timeout in milliseconds. Ignored for named pipes.

    AdditionalTransportCredentialsType - the type of additional credentials that we were
        given. Not used for named pipes.

    AdditionalCredentials - additional credentials that we were given. 
        Not used for named pipes.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_INVALID_NETWORK_OPTIONS
    RPC_S_SERVER_UNAVAILABLE
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_INVALID_NET_ADDR

--*/
{
    RPC_STATUS Status;
    PNMP_CONNECTION pConnection = (PNMP_CONNECTION)ThisConnection;
    BOOL f;
    HANDLE hPipe;
    DWORD SecurityQOSFlags = 0;
    NTSTATUS NtStatus;
    UINT AddressLen ;
    UINT EndpointLen;
    HANDLE ImpersonationToken = 0;
    DWORD StartTickCount;
    DWORD RetryCount;
    BOOL fLocalAddress = FALSE;

    if ((AdditionalTransportCredentialsType != 0) || (AdditionalCredentials != NULL))
        return RPC_S_CANNOT_SUPPORT;

    if (NetworkOptions && *NetworkOptions)
        {
        //
        // Enable transport level security.
        //
        // By default named pipes (CreateFile) uses security with impersonation,
        // dynamic tracking and effective only enabled.
        //
        // RPC level security sits on top of this and provides other features.
        //
        // Named pipes security is controlled via an options string in the string
        // binding.  The runtime exports an API to parse the string which is used
        // here to do most of the work.
        //
        SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

        Status = I_RpcParseSecurity(NetworkOptions,
                                    &SecurityQualityOfService);

        if ( Status != RPC_S_OK )
            {
            ASSERT( Status == RPC_S_INVALID_NETWORK_OPTIONS );
            goto Cleanup;
            }

        // Convert into SecurityQOS into CreateFile flags

        ASSERT(SECURITY_ANONYMOUS      == (SecurityAnonymous <<16));
        ASSERT(SECURITY_IDENTIFICATION == (SecurityIdentification <<16));
        ASSERT(SECURITY_IMPERSONATION  == (SecurityImpersonation <<16));
        ASSERT(SECURITY_DELEGATION     == (SecurityDelegation <<16));

        SecurityQOSFlags =   SECURITY_SQOS_PRESENT
                           | (SecurityQualityOfService.ImpersonationLevel << 16);

        SecurityQOSFlags |= (SecurityQualityOfService.ContextTrackingMode
                             != SECURITY_STATIC_TRACKING) ? SECURITY_CONTEXT_TRACKING : 0;

        SecurityQOSFlags |= (SecurityQualityOfService.EffectiveOnly)
                             ? SECURITY_EFFECTIVE_ONLY : 0;
        }

    ASSERT(NetworkAddress);

    if (NetworkAddress[0] == '\\')
        {
        if (   NetworkAddress[1] == '\\'
            && NetworkAddress[2] != '\0'
            && NetworkAddress[3] != '\\')
            {
            NetworkAddress += 2;
            }
        else
            {
            RpcpErrorAddRecord(EEInfoGCRuntime,
                RPC_S_INVALID_NET_ADDR, 
                EEInfoDLNMPOpen30, 
                NetworkAddress);

            Status = RPC_S_INVALID_NET_ADDR;
            goto Cleanup;
            }
        }

    if (   (NetworkAddress[0] == 0)
        || (RpcpStringCompare(NetworkAddress, gpstrComputerName) == 0) )
        {
        NetworkAddress = RPC_STRING_LITERAL(".");
        fLocalAddress = TRUE;
        }

    ASSERT(Endpoint);
    if (   Endpoint[0] != 0
        && RpcpStringNCompare(Endpoint, RPC_CONST_STRING("\\pipe\\"), 6) != 0)
        {
        Status = RPC_S_INVALID_ENDPOINT_FORMAT;
        goto Cleanup;
        }

    AddressLen = RpcpStringLength(NetworkAddress);
    EndpointLen = RpcpStringLength(Endpoint);

    RPC_CHAR *TransportAddress;
    TransportAddress = (RPC_CHAR *)alloca(   (2 + AddressLen + EndpointLen + 1)
                                           * sizeof(RPC_CHAR) );

    TransportAddress[0] = TransportAddress[1] = '\\';
    memcpy(TransportAddress + 2,
           NetworkAddress,
           AddressLen * sizeof(RPC_CHAR));

    memcpy(TransportAddress + 2 + AddressLen,
           Endpoint,
           (EndpointLen + 1) * sizeof(RPC_CHAR));

    ASSERT(   ((long)ConnTimeout >= RPC_C_BINDING_MIN_TIMEOUT)
           && (ConnTimeout <= RPC_C_BINDING_INFINITE_TIMEOUT));

    StartTickCount = GetTickCount();
    RetryCount = 0;
    do
        {
        hPipe = CreateFile((RPC_SCHAR *)TransportAddress,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            0,
                            OPEN_EXISTING,
                            FILE_FLAG_OVERLAPPED | SecurityQOSFlags,
                            0
                           );

        if (hPipe != INVALID_HANDLE_VALUE)
            {
            DWORD Mode = PIPE_READMODE_MESSAGE | PIPE_WAIT;

            f = SetNamedPipeHandleState(hPipe, &Mode, 0, 0);

            if (f)
                {
                Status = COMMON_PrepareNewHandle(hPipe);
                if (Status == RPC_S_OK)
                    {
                    break;
                    }
                else
                    {
                    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   RPCTRANS "COMMON_PrepareNewHandle: %d\n",
                                   GetLastError()));
                    }
                }
            else
                {
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "SetNamedPipeHandleState: %d\n",
                               GetLastError()));

                Status = GetLastError();
                }

            CloseHandle(hPipe);
            hPipe = INVALID_HANDLE_VALUE;

            }
        else
            {
            Status = GetLastError();
            }

        if (Status != ERROR_PIPE_BUSY)
            {
            RpcpErrorAddRecord(fLocalAddress ? EEInfoGCNPFS : EEInfoGCRDR,
                Status, 
                EEInfoDLNMPOpen10, 
                TransportAddress,
                SecurityQOSFlags);

            switch(Status)
                {
                case ERROR_INVALID_NAME:
                    Status = RPC_S_INVALID_ENDPOINT_FORMAT;
                    break;

                case ERROR_BAD_NET_NAME:
                case ERROR_INVALID_NETNAME:
                    Status = RPC_S_INVALID_NET_ADDR;
                    break;

                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_NOT_ENOUGH_QUOTA:
                case ERROR_COMMITMENT_LIMIT:
                case ERROR_TOO_MANY_OPEN_FILES:
                case ERROR_OUTOFMEMORY:
                    Status = RPC_S_OUT_OF_MEMORY;
                    break;

                case ERROR_NOT_ENOUGH_SERVER_MEMORY:
                    Status = RPC_S_SERVER_OUT_OF_MEMORY;
                    break;

                case ERROR_NO_SYSTEM_RESOURCES:
                case ERROR_WORKING_SET_QUOTA:
                case ERROR_TOO_MANY_SESS:
                    Status = RPC_S_OUT_OF_RESOURCES;
                    break;

                case ERROR_DOMAIN_TRUST_INCONSISTENT:
                case ERROR_ACCESS_DENIED:
                case ERROR_ACCOUNT_EXPIRED:
                case ERROR_ACCOUNT_RESTRICTION:
                case ERROR_ACCOUNT_LOCKED_OUT:
                case ERROR_ACCOUNT_DISABLED:
                case ERROR_NO_SUCH_USER:
                case ERROR_BAD_IMPERSONATION_LEVEL:
                case ERROR_BAD_LOGON_SESSION_STATE:
                case ERROR_INVALID_PASSWORD:
                case ERROR_INVALID_LOGON_HOURS:
                case ERROR_INVALID_WORKSTATION:
                case ERROR_INVALID_SERVER_STATE:
                case ERROR_INVALID_DOMAIN_STATE:
                case ERROR_INVALID_DOMAIN_ROLE:
                case ERROR_LOGON_FAILURE:
                case ERROR_LICENSE_QUOTA_EXCEEDED:
                case ERROR_LOGON_NOT_GRANTED:
                case ERROR_LOGON_TYPE_NOT_GRANTED:
                case ERROR_MUTUAL_AUTH_FAILED:
                case ERROR_NETWORK_ACCESS_DENIED:
                case ERROR_NO_SUCH_DOMAIN:
                case ERROR_NO_SUCH_LOGON_SESSION:
                case ERROR_NO_LOGON_SERVERS:
                case ERROR_NO_TRUST_SAM_ACCOUNT:
                case ERROR_PASSWORD_EXPIRED:
                case ERROR_PASSWORD_MUST_CHANGE:
                case ERROR_TRUSTED_DOMAIN_FAILURE:
                case ERROR_TRUSTED_RELATIONSHIP_FAILURE:
                case ERROR_WRONG_TARGET_NAME:
                case ERROR_WRONG_PASSWORD:
                case ERROR_TIME_SKEW:
                case ERROR_NO_TRUST_LSA_SECRET:
                case ERROR_LOGIN_WKSTA_RESTRICTION:
                case ERROR_SHUTDOWN_IN_PROGRESS:
                case ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT:
                case ERROR_DOWNGRADE_DETECTED:
                case ERROR_CONTEXT_EXPIRED:
                case SCARD_E_NO_SMARTCARD:
                case ERROR_SMARTCARD_SUBSYSTEM_FAILURE:
                case SCARD_E_COMM_DATA_LOST:
                case ERROR_AUTHENTICATION_FIREWALL_FAILED:
                    Status = RPC_S_ACCESS_DENIED;
                    break;

                //case ERROR_INTERNAL_ERROR:
                case ERROR_NOACCESS:
                // Really unexpected errors - fall into default on retail.
                    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   RPCTRANS "Unexpected error: %d\n",
                                   Status));
                    ASSERT(0);

                default:
                    VALIDATE(Status)
                        {
                        ERROR_REM_NOT_LIST,
                        ERROR_SHARING_PAUSED,
                        ERROR_NETNAME_DELETED,
                        ERROR_SEM_TIMEOUT,
                        ERROR_FILE_NOT_FOUND,
                        ERROR_PATH_NOT_FOUND,
                        ERROR_BAD_NETPATH,
                        ERROR_NETWORK_UNREACHABLE,
                        ERROR_UNEXP_NET_ERR,
                        ERROR_REQ_NOT_ACCEP,
                        ERROR_GEN_FAILURE,
                        ERROR_BAD_NET_RESP,
                        ERROR_PIPE_NOT_CONNECTED,
                        ERROR_NETLOGON_NOT_STARTED,
                        ERROR_DOMAIN_CONTROLLER_NOT_FOUND,
                        ERROR_CONNECTION_ABORTED,
                        ERROR_CONNECTION_INVALID,
                        ERROR_HOST_UNREACHABLE,
                        ERROR_CANT_ACCESS_DOMAIN_INFO,
                        ERROR_DUP_NAME,
                        ERROR_NO_SUCH_PACKAGE,
                        ERROR_INVALID_FUNCTION,
                        ERROR_BAD_DEV_TYPE,
                        ERROR_CONNECTION_REFUSED,
                        ERROR_BAD_COMMAND
                        } END_VALIDATE;
                    Status = RPC_S_SERVER_UNAVAILABLE;
                    break;
                }

            RpcpErrorAddRecord(EEInfoGCRuntime,
                Status, 
                EEInfoDLNMPOpen40);

            goto Cleanup;
            }

        ASSERT(hPipe == INVALID_HANDLE_VALUE);

        // No pipe instances available, wait for one to show up...

        WaitNamedPipe((RPC_SCHAR *)TransportAddress, 1000);

        // attempt the connect for at least 40 seconds and at least 20 times
        // note that since this is DWORD, even if the counter has wrapped
        // the difference will be accurate
        RetryCount ++;
        }
    while ((GetTickCount() - StartTickCount < 40000) || (RetryCount <= 20));

    if (hPipe == INVALID_HANDLE_VALUE)
        {
        Status = RPC_S_SERVER_TOO_BUSY;
        RpcpErrorAddRecord(fLocalAddress ? EEInfoGCNPFS : EEInfoGCRDR,
            Status, 
            EEInfoDLNMPOpen20,
            TransportAddress);
        // No instances available
        goto Cleanup;
        }

    // Pipe opened successfully

    pConnection->Conn.Handle = hPipe;
    pConnection->fAborted = 0;
    pConnection->pReadBuffer = 0;
    pConnection->maxReadBuffer = 0;
    pConnection->iPostSize = gPostSize;
    pConnection->iLastRead = 0;
    memset(&pConnection->Read.ol, 0, sizeof(pConnection->Read.ol));
    pConnection->Read.pAsyncObject = pConnection;
    pConnection->Read.thread       = 0;
    pConnection->Read.ol.Internal = 0;
    pConnection->InitIoCounter();
    pConnection->pAddress = 0;

    Status = RPC_S_OK;

Cleanup:


    return(Status);
}


RPC_STATUS
RPC_ENTRY
NMP_SyncSend(
    IN RPC_TRANSPORT_CONNECTION Connection,
    IN UINT BufferLength,
    IN BUFFER Buffer,
    IN BOOL fDisableShutdownCheck,
    IN BOOL fDisableCancelCheck,
    ULONG Timeout
    )
/*++

Routine Description:

    Sends a message on the connection.  This method must appear
    to be synchronous from the callers perspective.

Arguments:

    pConnection - The connection.
    Buffer - The data to send.
    BufferLength - The size of the buffer.
    fDisableShutdownCheck - N/A to named pipes.

Return Value:

    RPC_S_OK - Data sent
    RPC_P_SEND_FAILED - Connection will be aborted if this is returned.
    RPC_S_CALL_CANCELLED - The call was cancelled

--*/
{
    NMP_CONNECTION *p = (NMP_CONNECTION *)Connection;
    DWORD bytes;
    RPC_STATUS status;
    OVERLAPPED olWrite;
    HANDLE hEvent;
    BOOL fPendingReturned = FALSE;

    hEvent = I_RpcTransGetThreadEvent();

    ASSERT(hEvent);

    p->StartingWriteIO();

    if (p->fAborted)
        {
        p->WriteIOFinished();
        return(RPC_P_SEND_FAILED);
        }

    // Setting the low bit of the event indicates that the write
    // completion should NOT be sent to the i/o completion port.
    olWrite.Internal = 0;
    olWrite.InternalHigh = 0;
    olWrite.Offset = 0;
    olWrite.OffsetHigh = 0;
    olWrite.hEvent = (HANDLE) ((ULONG_PTR)hEvent | 0x1);

#ifdef _INTERNAL_RPC_BUILD_
    if (gpfnFilter)
        {
        (*gpfnFilter) (Buffer, BufferLength, 0);
        }
#endif

    status = p->NMP_CONNECTION::Send(p->Conn.Handle,
                            Buffer,
                            BufferLength,
                            &bytes,
                            &olWrite
                            );

    p->WriteIOFinished();

    if (status == RPC_S_OK)
        {
        ASSERT(bytes == BufferLength);
        return(RPC_S_OK);
        }

    if (status == ERROR_IO_PENDING)
        {
        fPendingReturned = TRUE;
        // if fDisableCancelCheck - not alertable. Else, alertable.
        status = UTIL_GetOverlappedResultEx(Connection,
                                            &olWrite,
                                            &bytes,
                                            (fDisableCancelCheck ? FALSE : TRUE),
                                            Timeout);

        if (status == RPC_S_OK)
            {
            ASSERT(bytes == BufferLength);
            return(RPC_S_OK);
            }
        }

    ASSERT(status != ERROR_SUCCESS);

    RpcpErrorAddRecord(EEInfoGCNMP,
        status, 
        EEInfoDLNMPSyncSend10,
        (ULONGLONG)Connection,
        (ULONGLONG)Buffer,
        (ULONG)BufferLength,
        (ULONG)fPendingReturned);

    VALIDATE(status)
        {
        ERROR_NETNAME_DELETED,
        ERROR_GRACEFUL_DISCONNECT,
        ERROR_BROKEN_PIPE,
        ERROR_PIPE_NOT_CONNECTED,
        ERROR_NO_DATA,
        ERROR_NO_SYSTEM_RESOURCES,
        ERROR_WORKING_SET_QUOTA,
        ERROR_SEM_TIMEOUT,
        ERROR_UNEXP_NET_ERR,
        ERROR_BAD_NET_RESP,
        ERROR_HOST_UNREACHABLE,
        RPC_S_CALL_CANCELLED,
        ERROR_CONNECTION_ABORTED,
        ERROR_NOT_ENOUGH_QUOTA,
        RPC_P_TIMEOUT,
        ERROR_LOGON_FAILURE,
        ERROR_TIME_SKEW,
        ERROR_NETWORK_UNREACHABLE,
        ERROR_NO_LOGON_SERVERS,
        ERROR_NO_SUCH_USER,
        ERROR_NOT_ENOUGH_SERVER_MEMORY,
        ERROR_INVALID_NETNAME,
        ERROR_BAD_COMMAND,
        ERROR_SMARTCARD_SUBSYSTEM_FAILURE
        } END_VALIDATE;

    p->NMP_CONNECTION::Abort();

    if ((status == RPC_S_CALL_CANCELLED) || (status == RPC_P_TIMEOUT))
        {
        // Wait for the write to finish.  Since we closed the pipe
        // this won't take very long.
        UTIL_WaitForSyncIO(&olWrite,
                           FALSE,
                           INFINITE);
        }
    else
        {
        status = RPC_P_SEND_FAILED;
        }

    return(status);
}

RPC_STATUS
RPC_ENTRY
NMP_SyncSendRecv(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN UINT InputBufferSize,
    IN BUFFER InputBuffer,
    OUT PUINT pOutputBufferSize,
    OUT BUFFER *pOutputBuffer
    )
/*++

Routine Description:

    Sends a request to the server and waits to receive the next PDU
    to arrive at the connection.

Arguments:

    ThisConnection - The connection to wait on.
    InputBufferSize - The size of the data to send to the server.
    InputBuffer - The data to send to the server
    pOutputBufferSize - On return it contains the size of the PDU received.
    pOutputBuffer - On return contains the PDU received.

Return Value:

    RPC_S_OK

    RPC_P_SEND_FAILED - Connection aborted, data did not reach the server.
    RPC_P_RECEIVE_FAILED - Connection aborted, data might have reached
        the server.

--*/
{
    PNMP_CONNECTION p = (PNMP_CONNECTION)ThisConnection;
    BOOL b;
    DWORD bytes;
    DWORD readbytes;
    RPC_STATUS status;
    HANDLE hEvent;

    ASSERT(p->pReadBuffer == 0);
    ASSERT(p->iLastRead == 0);

    p->pReadBuffer = TransConnectionAllocatePacket(p, p->iPostSize);
    if (!p->pReadBuffer)
        {
        p->NMP_CONNECTION::Abort();
        return(RPC_P_SEND_FAILED);
        }

    hEvent = I_RpcTransGetThreadEvent();

    ASSERT(hEvent);

    p->Read.ol.hEvent = (HANDLE) ((ULONG_PTR)hEvent | 0x1);

    p->maxReadBuffer = p->iPostSize;
    bytes = p->maxReadBuffer;

#ifdef _INTERNAL_RPC_BUILD_
    if (gpfnFilter)
        {
        (*gpfnFilter) (InputBuffer, InputBufferSize, 0);
        }
#endif

    b = TransactNamedPipe(p->Conn.Handle,
                          InputBuffer,
                          InputBufferSize,
                          p->pReadBuffer,
                          bytes,
                          &bytes,
                          &p->Read.ol
                          );


    if (!b)
        {
        status = GetLastError();
        if (status == ERROR_IO_PENDING)
            {
            status = UTIL_GetOverlappedResult(p,
                                              &p->Read.ol,
                                              &bytes);
            }
        else
            {
            ASSERT(status != RPC_S_OK);
            }
        }
    else
        {
        status = RPC_S_OK;
        }

    if (status == RPC_S_OK)
        {
        // Success - got the whole reply in the transact

        *pOutputBuffer = p->pReadBuffer;
        p->pReadBuffer = 0;
        *pOutputBufferSize = bytes;

        ASSERT(bytes == MessageLength((PCONN_RPC_HEADER)*pOutputBuffer));

        return(RPC_S_OK);
        }

    if (status != ERROR_MORE_DATA)
        {
        RpcpErrorAddRecord(EEInfoGCNMP,
            status, 
            EEInfoDLNMPSyncSendReceive10,
            (ULONGLONG)p,
            (ULONGLONG)InputBuffer,
            InputBufferSize);

        if (status == ERROR_BAD_PIPE)
            {
            status = RPC_P_SEND_FAILED;
            }
        else
            {
            // surprisingly enough, ERROR_PIPE_NOT_CONNECTED can be
            // returned if the server died midway through the
            // operation.
            VALIDATE(status)
                {
                ERROR_NETNAME_DELETED,
                ERROR_GRACEFUL_DISCONNECT,
                ERROR_BROKEN_PIPE,
                ERROR_PIPE_BUSY,
                ERROR_NO_DATA,
                ERROR_NO_SYSTEM_RESOURCES,
                ERROR_SEM_TIMEOUT,
                ERROR_UNEXP_NET_ERR,
                ERROR_BAD_NET_RESP,
                ERROR_CONNECTION_ABORTED,
                ERROR_NETWORK_UNREACHABLE,
                ERROR_HOST_UNREACHABLE,
                ERROR_BAD_NETPATH,
                ERROR_REM_NOT_LIST,
                ERROR_ACCESS_DENIED,
                ERROR_NOT_ENOUGH_QUOTA,
                ERROR_LOGON_FAILURE,
                ERROR_TIME_SKEW,
                ERROR_PIPE_NOT_CONNECTED,
                ERROR_WORKING_SET_QUOTA,
                ERROR_NOT_ENOUGH_SERVER_MEMORY,
                ERROR_INVALID_NETNAME,
                ERROR_BAD_COMMAND,
                ERROR_WORKING_SET_QUOTA
                } END_VALIDATE;

            status = RPC_P_RECEIVE_FAILED;
            }

        p->NMP_CONNECTION::Abort();
        return(status);
        }

    // More data to read.

    ASSERT(p->Read.ol.InternalHigh == p->maxReadBuffer);

    ASSERT(MessageLength((PCONN_RPC_HEADER)p->pReadBuffer) > p->maxReadBuffer);

    bytes = p->maxReadBuffer;

    status = p->ProcessRead(bytes, pOutputBuffer, pOutputBufferSize);

    if (status == RPC_P_PARTIAL_RECEIVE)
        {
        // More to arrive, submit a read for all of it.

        status = CO_SubmitSyncRead(p, pOutputBuffer, pOutputBufferSize);

        if (status == RPC_P_IO_PENDING)
            {
            status = UTIL_GetOverlappedResult(p, &p->Read.ol, &bytes);

            // Since we read all the expected data and np is message mode
            // this should either fail or give back all the data.

            ASSERT(status != ERROR_MORE_DATA);

            if (status == RPC_S_OK)
                {
                status = p->ProcessRead(bytes, pOutputBuffer, pOutputBufferSize);

                ASSERT(status != RPC_P_PARTIAL_RECEIVE);
                }
            }
        }

    if (status != RPC_S_OK)
        {
        RpcpErrorAddRecord(EEInfoGCNMP,
            status, 
            EEInfoDLNMPSyncSendReceive20,
            (ULONGLONG)p,
            (ULONGLONG)InputBuffer,
            InputBufferSize);

        p->NMP_CONNECTION::Abort();
        if (status != RPC_P_TIMEOUT)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime,
                RPC_P_RECEIVE_FAILED, 
                EEInfoDLNMPSyncSendReceive30,
                status);
            return(RPC_P_RECEIVE_FAILED);
            }
        else
            return (status);
        }

    ASSERT(*pOutputBufferSize == MessageLength((PCONN_RPC_HEADER)*pOutputBuffer));
    ASSERT(p->pReadBuffer == 0);

    return(RPC_S_OK);
}

RPC_STATUS
RPC_ENTRY
NMP_SyncSendRecv_Avrf(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN UINT InputBufferSize,
    IN BUFFER InputBuffer,
    OUT PUINT pOutputBufferSize,
    OUT BUFFER *pOutputBuffer
    )
/*++

Routine Description:

    Wrapper for NMP_SyncSendRecv implementing corruption injection
    under the RPC verifier.

    SyncSendRecv member of the transport interface may only be called
    by the cliet, hence we inject the corruption for a client receive.

Arguments:

Return Value:

--*/
{
    RPC_STATUS Status;

    Status = NMP_SyncSendRecv(
        ThisConnection,
        InputBufferSize,
        InputBuffer,
        pOutputBufferSize,
        pOutputBuffer);

    if (!Status)
        {
        if (gfRPCVerifierEnabled)
            {
            CorruptionInject(ClientReceive,
                             pOutputBufferSize,
                             (void **)pOutputBuffer);
            }
        }

    return Status;
}

RPC_STATUS RPC_ENTRY NMP_Abort(IN RPC_TRANSPORT_CONNECTION Connection)
{
    return ((NMP_CONNECTION *)Connection)->NMP_CONNECTION::Abort();
}


const RPC_CONNECTION_TRANSPORT
NMP_TransportInterface = {
    RPC_TRANSPORT_INTERFACE_VERSION,
    NMP_TOWER_ID,
    UNC_ADDRESS_ID,
    RPC_STRING_LITERAL("ncacn_np"),
    "\\pipe\\epmapper",
    COMMON_ProcessCalls,
    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,
    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    FALSE,
    NMP_GetNetworkAddressVector,
    sizeof(NMP_ADDRESS),
    sizeof(NMP_CONNECTION),
    sizeof(NMP_CONNECTION),
    sizeof(CO_SEND_CONTEXT),
    0,
    NMP_MAX_SEND,
    NMP_Initialize,
    0,
    NMP_Open,
    NMP_SyncSendRecv,
    CO_SyncRecv,
    NMP_Abort,
    NMP_Close,
    CO_Send,
    CO_Recv,
    NMP_SyncSend,
    0,  // turn on/off keep alives
    NMP_ServerListen,
    NMP_ServerAbortListen,
    COMMON_ServerCompleteListen,
    NMP_ConnectionQueryClientAddress,
    0, // query local address
    NMP_ConnectionQueryClientId,
    0,  // query client ip address
    NMP_ConnectionImpersonateClient,
    NMP_ConnectionRevertToSelf,
    0,  // FreeResolverHint
    0,  // CopyResolverHint
    0,  // CompareResolverHint
    0   // SetLastBufferToFree
    };

// When the RPC verifier is enabled and we are corrupting client receives,
// we will use a modified transport interface given below.  It will have the sync
// receive members overwritten.
RPC_CONNECTION_TRANSPORT *pNMP_TransportInterface_Avrf = NULL;

const RPC_CONNECTION_TRANSPORT *
NMP_TransportLoad (
    )
{
    // Overwrite the SyncSendRecv and SyncRecv members of the transport interfaces if the
    // RPC verifier is enabled.
    if (gfRpcVerifierCorruptionInjectClientReceives)
        {
        // Check if we have previously initialized the Avrf transport interface.
        if (pNMP_TransportInterface_Avrf == NULL)
            {
            // Allocate a transport interface structure to override the default.
            pNMP_TransportInterface_Avrf = new (RPC_CONNECTION_TRANSPORT);
            if (pNMP_TransportInterface_Avrf == NULL)
                {
                return NULL;
                }
            // Initialize the Avrf transport interface with the default values.
            RpcpMemoryCopy(pNMP_TransportInterface_Avrf,
                           &NMP_TransportInterface,
                           sizeof(RPC_CONNECTION_TRANSPORT));
            // Override the interface functions for sync receive.
            ASSERT(pNMP_TransportInterface_Avrf->SyncSendRecv == NMP_SyncSendRecv);
            pNMP_TransportInterface_Avrf->SyncSendRecv = NMP_SyncSendRecv_Avrf;
            ASSERT(pNMP_TransportInterface_Avrf->SyncRecv == CO_SyncRecv);
            pNMP_TransportInterface_Avrf->SyncRecv = CO_SyncRecv_Avrf;                
            }
        return(pNMP_TransportInterface_Avrf);
        }

    return(&NMP_TransportInterface);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\tower.cxx ===
/*++

    Copyright (C) Microsoft Corporation, 1996 - 1999

    Module Name:

        Tower.cxx

    Abstract:

        Common code from building and exploding towers.  Each
        protocol supported by the transport interface needs
        a section in this file.

    Author:

        Mario Goertzel    [MarioGo]

    Revision History:

        MarioGo     11/11/1996    Bits 'n pieces
        KamenM      05/02/2002    Major security and cleanup changes

--*/

#include <precomp.hxx>
#include <epmp.h>
#include <twrtypes.h>
#include <twrproto.h>

// Transport protocols defined in cotrans.hxx and dgtrans.hxx

RPC_STATUS
RPC_ENTRY
COMMON_TowerConstruct(
    IN PCHAR Protseq,
    IN PCHAR NetworkAddress,
    IN PCHAR Endpoint,
    OUT PUSHORT Floors,
    OUT PULONG ByteCount,
    OUT PUCHAR *Tower
    )
/*++

Routine Description:

    Constructs a OSF tower for the protocol, network address and endpoint.

Arguments:

    Protseq - The protocol for the tower.
    NetworkAddress - The network address to be encoded in the tower.
    Endpoint - The endpoint to be encoded in the tower.
    Floors - The number of twoer floors it encoded into the tower.
    ByteCount - The size of the "upper-transport-specific" tower that
        is encoded by this call.
    Tower - The encoded "upper tower" that is encoded by this call.
        This caller is responsible for freeing this memory.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_INVALID_RPC_PROTSEQ

--*/
{
    PFLOOR_234 Floor;
    ADDRINFO *AddrInfo;
    ADDRINFO Hint;

    INT index = MapProtseq(Protseq);

    if (index == 0)
        {
        return(RPC_S_INVALID_RPC_PROTSEQ);
        }

    RPC_TRANSPORT_INTERFACE pInfo = TransportTable[index].pInfo;

    ASSERT(pInfo);

    if (Endpoint == NULL || *Endpoint == '\0')
        {
        Endpoint = pInfo->WellKnownEndpoint;
        }

    // Currently all protocols have 5 floors.  If a new protocol
    // is added with < 5 floors watch out in tower explode.

    *Floors = 5;

    // Figure out the size of the tower

    size_t addr_size;
    size_t ept_size;
    size_t size;

    // Figure out the endpoint size
    switch (index)
        {
        // Protocols which use port numbers (ushorts) as endpoints
        case TCP:
#ifdef SPX_ON
        case SPX:
#endif
        case HTTP:
        case UDP:
#ifdef IPX_ON
        case IPX:
#endif
            ept_size = 2;
            break;

        // Protocols which use strings as endpoints
        case NMP:
#ifdef NETBIOS_ON
        case NBF:
        case NBT:
        case NBI:
#endif

#ifdef NCADG_MQ_ON
        case MSMQ:
#endif

#ifdef APPLETALK_ON
        case DSP:
#endif
            {
            ASSERT(Endpoint && *Endpoint);
            ept_size = strlen(Endpoint) + 1;
            break;
            }

        #if DBG
        default:
            ASSERT(0);
            return(RPC_S_INTERNAL_ERROR);
        #endif
        }

    // Figure out the address size
    switch(index)
        {
        // Protocols which use 4 bytes longs as the address size
        case TCP:
        case UDP:
        case HTTP:
            {
            addr_size = 4;
            break;
            }
#ifndef SPX_IPX_OFF
        // Protocols which use 10 byte (32+48 bit) address size
#ifdef SPX_ON
        case SPX:
#endif
#ifdef IPX_ON
        case IPX:
#endif
            {
            addr_size = 10;
            break;
            }
#endif

        // Protocols which use the string as the address
        case NMP:

#ifdef NETBIOS_ON
        case NBF:
        case NBT:
        case NBI:
#endif

#ifdef NCADG_MQ_ON
        case MSMQ:
#endif

#ifdef APPLETALK_ON
        case DSP:
#endif
            {
            if ((NetworkAddress == NULL) || (*NetworkAddress== '\0'))
                {
                addr_size = 2;
                }
            else
                {
                addr_size = strlen(NetworkAddress) + 1;
                }
            break;
            }

        #if DBG
        default:
            ASSERT(0);
            return(RPC_S_INTERNAL_ERROR);
        #endif
        }


    // Compute total size.
    // Note: FLOOR_234 already contains 2 bytes of data.

    size = addr_size + ept_size + 2*(sizeof(FLOOR_234) - 2);

    // Allocate tower
    *Tower = new UCHAR[size];
    if (!*Tower)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }
    *ByteCount = size;

    // Now fill-in the endpoint part of the tower

    Floor = (PFLOOR_234)*Tower;
    Floor->ProtocolIdByteCount = 1;
    Floor->FloorId = (UCHAR)pInfo->TransId;

    switch(index)
        {
        // Protocols which use big endian ushorts
        case TCP:
        case HTTP:
#ifdef SPX_ON
        case SPX:
#endif
        case UDP:
#ifdef IPX_ON
        case IPX:
#endif
            {
            Floor->AddressByteCount = 2;
            USHORT port = (USHORT) atoi(Endpoint);
            port = htons(port);
            memcpy((char PAPI *)&Floor->Data[0], &port, 2);
            break;
            }

        // Protocols which use ansi strings
        case NMP:

#ifdef NETBIOS_ON
        case NBT:
        case NBF:
        case NBI:
#endif

#ifdef NCADG_MQ_ON
        case MSMQ:
#endif

#ifdef APPLETALK_ON
        case DSP:
#endif
            {
            Floor->AddressByteCount = (unsigned short) ept_size;
            memcpy(&Floor->Data[0], Endpoint, ept_size);
            break;
            }

        #if DBG
        default:
            ASSERT(0);
        #endif
        }

    // Move to the next tower and fill-in the address part of the tower

    Floor = NEXTFLOOR(PFLOOR_234, Floor);
    Floor->ProtocolIdByteCount = 1;
    Floor->FloorId = (unsigned char) pInfo->TransAddrId;

    switch (index)
        {
        // IP protocols use 4 byte big endian IP addreses
        case TCP:
        case HTTP:
        case UDP:
            {
            int err;

            RpcpMemorySet(&Hint, 0, sizeof(Hint));
            Hint.ai_flags = AI_NUMERICHOST;

            err = getaddrinfo(NetworkAddress, 
                NULL, 
                &Hint,
                &AddrInfo);

            if (err)
                {
                // if it's not a dot address, keep it zero
                RpcpMemorySet(&Floor->Data[0], 0, 4);  
                }
            else
                {
                RpcpMemoryCopy(&Floor->Data[0], &(((SOCKADDR_IN *)AddrInfo->ai_addr)->sin_addr.s_addr), 4);
                freeaddrinfo(AddrInfo);
                }

            Floor->AddressByteCount = 4;
            break;
            }

#ifndef SPX_IPX_OFF
        // IPX protocols use little endian net (32 bit) + node (48 bit) addresses
#ifdef SPX_ON
        case SPX:
#endif
#ifdef IPX_ON
        case IPX:
#endif
            {
            Floor->AddressByteCount = 10;
            memset(&Floor->Data[0], 0, 10);  // Zero is fine..
            break;
            }
#endif

        // Protocols which use string names.
        case NMP:

#ifdef NETBIOS_ON
        case NBF:
        case NBT:
        case NBI:
#endif

#ifdef NCADG_MQ_ON
        case MSMQ:
#endif

#ifdef APPLETALK_ON
        case DSP:
#endif
            {
            if ((NetworkAddress) && (*NetworkAddress))
                {
                Floor->AddressByteCount = (unsigned short) addr_size;
                memcpy(&Floor->Data[0], NetworkAddress, addr_size);
                }
            else
                {
                Floor->AddressByteCount = 2;
                Floor->Data[0] = 0;
                }
            break;
            }

        #if DBG
        default:
            ASSERT(0);
        #endif
        }

    return(RPC_S_OK);
}

const INT HTTP_OLD_ADDRESS_ID = 0x20;

RPC_STATUS
FixupFloorForMac(
    IN BYTE *Floor,
    IN BYTE *UpperBound
    )
/*++

Routine Description:

    Mac clients have their LHS and RHS byte counts in big endian format.
    This routine fixes the bug counts.

Arguments:

    Floor - The floor to fix
    UpperBound - The first invalid byte after the end of the buffer.

Return Value:

    RPC_S_OK

    EP_S_CANT_PERFORM_OP - The floor provided is invalid.

Note:

    The function expects the LHSBytes value to be present.
    The caller should have verified that we can read this floor:
    &Floor->Data[0] < UpperBound 

--*/
{
    USHORT LHSBytes, RHSBytes;
    BYTE *RHSBytesPosition;

    // The caller must verify that we are given a full floor.

    // PFLOOR_234 is defined as unaligned - no need to worry about alignment
    LHSBytes = ((PFLOOR_234)Floor)->ProtocolIdByteCount;

    // Swap the LHSBytes,
    LHSBytes = RpcpByteSwapShort(LHSBytes);
    ((PFLOOR_234)Floor)->ProtocolIdByteCount = LHSBytes;

    // find the RHSBytes and swap them too
    RHSBytesPosition = Floor + 2 + LHSBytes;

    // Make sure we can read the field.
    if (RHSBytesPosition + 2 >= UpperBound)
        return EP_S_CANT_PERFORM_OP;

    RHSBytes = *(USHORT UNALIGNED *)RHSBytesPosition;
    RHSBytes = RpcpByteSwapShort(RHSBytes);
    *(USHORT UNALIGNED *)RHSBytesPosition = RHSBytes;

    return RPC_S_OK;
}

#define BadMacByteCount 0x0100

RPC_STATUS
COMMON_TowerExplode(
    IN BYTE *Tower,
    IN BYTE *UpperBound,
    IN ULONG RemainingFloors,
    OUT PCHAR *Protseq,
    OUT PCHAR *NetworkAddress,
    OUT PCHAR *Endpoint
    )
/*++

Routine Description:

    Decodes an OSF transport "upper tower" for the runtime.

Arguments:

    Tower - The encoded "upper tower" to decode
    UpperBound - the first invalid byte after the end of the buffer.
    RemainingFloors - the number of floors remaining
    Protseq - The protseq encoded in the Tower
        Does not need to be freed by the caller.
    NetworkAddress - The network address encoded in the Tower
        Must be freed by the caller.
    Endpoint - The endpoint encoded in the Tower.
        Must be freed by the caller.

Return Value:

    RPC_S_OK

    EP_S_CANT_PERFORM_OP - The tower provided is invalid.

    RPC_S_INVALID_RPC_PROTSEQ

    RPC_S_OUT_OF_MEMORY

--*/
{
    PFLOOR_234 Floor = (PFLOOR_234)Tower;
    BYTE *FloorAfterThat;
    RPC_STATUS Status = RPC_S_OK;
    INT Index;
    BOOL NextFloorVerified;
    ULONG EndpointLength;
    char *NewEndpoint;
    ULONG NetworkAddressLength;
    char *NewNetworkAddress;
    USHORT LHSBytes, RHSBytes;
    unsigned short TransportId;
    BOOL fBadMacClient = FALSE;

    if (RemainingFloors == 0)
        return EP_S_CANT_PERFORM_OP;

    // Verify that we can access the floor data.
    if (&Floor->Data[0] >= UpperBound)
        return EP_S_CANT_PERFORM_OP;

    PFLOOR_234 NextFloor = NEXTFLOOR(PFLOOR_234, Tower);

    // The pointer to the tower is actually a pointer to the 3rd floor.

    TransportId = Floor->FloorId;

    // Mac clients have their LHS and RHS byte counts in big endian format.
    // Detect such clients, and byte swap them.

    // PFLOOR_234 is defined as unaligned - no need to worry about alignment
    LHSBytes = Floor->ProtocolIdByteCount;
    if ((LHSBytes == BadMacByteCount) && (TransportId == TCP_TOWER_ID))
        {
        fBadMacClient = TRUE;

        if (FixupFloorForMac((BYTE*)Floor,
                UpperBound
                ) != RPC_S_OK)
            {
            return EP_S_CANT_PERFORM_OP;
            }
        }

    NextFloor = (PFLOOR_234)VerifyFloorLHSAndRHS (Tower, 
        UpperBound, 
        3   // FloorNum
        );

    if (NextFloor == NULL)
        return EP_S_CANT_PERFORM_OP;

    // Find the protocol based first on the ID from this floor,
    // and then the next floor.  We only dereference the next
    // floor if we match the ID on this floor.

    NextFloorVerified = FALSE;
    for (unsigned i = 1; i < cTransportTable; i++)
        {
        if (TransportTable[i].ProtocolTowerId == Floor->FloorId)
            {
            if (NextFloorVerified == FALSE)
                {
                if (RemainingFloors == 1)
                    return EP_S_CANT_PERFORM_OP;

                if ((BYTE *)NextFloor + sizeof(FLOOR_234) - 2 >= UpperBound)
                    return EP_S_CANT_PERFORM_OP;

                // Don't forget to byteswap NextFloor if it came from a Mac client.
                if (fBadMacClient)
                    {
                    if (FixupFloorForMac((BYTE *)NextFloor,
                            UpperBound
                            ) != RPC_S_OK)
                        {
                        return EP_S_CANT_PERFORM_OP;
                        }
                    }

                FloorAfterThat = VerifyFloorLHSAndRHS ((BYTE *)NextFloor, 
                    UpperBound, 
                    4   // FloorNum
                    );

                if (FloorAfterThat == NULL)
                    return EP_S_CANT_PERFORM_OP;

                NextFloorVerified = TRUE;
                }

            if (TransportTable[i].AddressTowerId == NextFloor->FloorId)
                break;

            // 
            // The & 0x0F is needed because the legacy server code incorrectly
            // cleared the high nibble before sending the address tower id
            //
            if ((TransportTable[i].AddressTowerId & 0x0F) == NextFloor->FloorId )
                break;

            // N.B. Old (Win9x/NT4) clients would send a AddressTowerId of 0x20
            // (HTTP_OLD_ADDRESS_ID). We need to match this as well.
            if ((Floor->FloorId == HTTP_TOWER_ID)
                && (NextFloor->FloorId == HTTP_OLD_ADDRESS_ID))
                break;

            }
        }

    if (i == cTransportTable)
        {
        return(RPC_S_INVALID_RPC_PROTSEQ);
        }

    // the only way to break early of the loop passed through the second floor
    // verification code
    ASSERT(NextFloorVerified);

    Index = i;

    RPC_TRANSPORT_INTERFACE pInfo = TransportTable[Index].pInfo;

    if (pInfo == NULL){
        ASSERT(pInfo);
        return EP_S_CANT_PERFORM_OP;
        }    

    //
    // Figure out the protseq
    //

    if (ARGUMENT_PRESENT(Protseq))
        {
        size_t len = RpcpStringLength(pInfo->ProtocolSequence);
        *Protseq = new char[len + 1];
        if (*Protseq)
            {
            RPC_CHAR *MySrc = (RPC_CHAR *) pInfo->ProtocolSequence;
            char *MyDest = *Protseq;

            while (*MyDest++ = (char) *MySrc++);
            }
        else
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        }

    //
    // Figure out the endpoint
    //

    if (ARGUMENT_PRESENT(Endpoint))
        {
        switch(Index)
            {
            // Protocols which use strings as the endpoint format.
            case NMP:

#ifdef NETBIOS_ON
            case NBT:
            case NBI:
            case NBF:
#endif

#ifdef NCADG_MQ_ON
            case MSMQ:
#endif

#ifdef APPLETALK_ON
            case DSP:
#endif
                {
                EndpointLength = Floor->AddressByteCount;
                Status = ExtractStringFromUntrustedPacket (UpperBound,
                    EndpointLength,
                    (char *)&Floor->Data[0],
                    Endpoint
                    );
                }
                break;

            // Protocols which use ushort's as the endpoint format.
            case TCP:
#ifdef SPX_ON
            case SPX:
#endif
            case HTTP:
            case UDP:
#ifdef IPX_ON
            case IPX:
#endif
                {
                if (Tower + sizeof(FLOOR_234) >= UpperBound)
                    {
                    Status = EP_S_CANT_PERFORM_OP;
                    break;
                    }

                USHORT PortNum = *(USHORT UNALIGNED *)(&Floor->Data[0]);

                PortNum = RpcpByteSwapShort(PortNum);  // Towers are big endian.

                *Endpoint = new CHAR[6]; // 65535'\0'
                if (*Endpoint)
                    {
                    RpcpItoa(PortNum, *Endpoint, 10);
                    Status = RPC_S_OK;
                    }
                else
                    Status = RPC_S_OUT_OF_MEMORY;
                }
                break;

            default:
                CORRUPTION_ASSERT(0);
                Status = RPC_S_INVALID_RPC_PROTSEQ;
            }

        if (Status != RPC_S_OK)
            {
            if (ARGUMENT_PRESENT(Protseq))
                {
                delete *Protseq;
                *Protseq = 0;
                }
            return(Status);
            }
        }

    //
    // Now the hard part, figure out the network address.
    //

    if (ARGUMENT_PRESENT(NetworkAddress))
        {
        Floor = NextFloor;
        Status = RPC_S_OUT_OF_MEMORY;

        switch(Index)
            {
            // Protocols which use strings as their network address
            case NMP:

#ifdef NETBIOS_ON
            case NBF:
            case NBT:
            case NBI:
#endif

#ifdef NCADG_MQ_ON
            case MSMQ:
#endif

#ifdef APPLETALK_ON
            case DSP:
#endif
                Status = ExtractStringFromUntrustedPacket (UpperBound,
                    Floor->AddressByteCount,
                    (char *)&Floor->Data[0],
                    NetworkAddress
                    );
                break;

            // Protocols using IP addresses
            case TCP:
            case HTTP:
            case UDP:
                {

                if (Floor->AddressByteCount != 4)
                    {
                    Status = RPC_S_INVALID_RPC_PROTSEQ;
                    break;
                    }

                // make sure we have all four bytes. The check
                // above does not ensure that
                if (&Floor->Data[3] >= UpperBound)
                    {
                    Status = RPC_S_INVALID_RPC_PROTSEQ;
                    break;
                    }

                struct in_addr in;
                in.S_un.S_un_b.s_b1 = Floor->Data[0];
                in.S_un.S_un_b.s_b2 = Floor->Data[1];
                in.S_un.S_un_b.s_b3 = Floor->Data[2];
                in.S_un.S_un_b.s_b4 = Floor->Data[3];

                PCHAR t = inet_ntoa(in);
                if (t)
                    {
                    *NetworkAddress = new CHAR[16+1];
                    if (*NetworkAddress)
                        {
                        strcpy(*NetworkAddress, t);
                        Status = RPC_S_OK;
                        }
                    }
                else
                    {
                    ASSERT(0);
                    Status = RPC_S_INVALID_RPC_PROTSEQ;
                    }

                }
                break;

#ifndef SPX_IPX_OFF
            // Protocols using IPX 80 bit addresses
#ifdef SPX_ON
            case SPX:
#endif
#ifdef IPX_ON
            case IPX:
#endif
                {
                if (Floor->AddressByteCount != 10)
                    {
                    Status = RPC_S_INVALID_RPC_PROTSEQ;
                    break;
                    }

                if (&Floor->Data[9] >= UpperBound)
                    {
                    Status = RPC_S_INVALID_RPC_PROTSEQ;
                    break;
                    }

                // Format: ~NNNNNNNNAAAAAAAAAAAA'\0'
                // Network number (32bits) and IEEE 802 address (48bits)

                *NetworkAddress = new CHAR[1 + 8 + 12 + 1];
                if (*NetworkAddress)
                    {
                    PCHAR p = *NetworkAddress;
                    PCHAR pInput = (PCHAR) &Floor->Data[0];
                    *p++ = '~';
                    for (int i = 0; i < 10; i++)
                        {
                        CHAR c = *pInput ++;
                        *p++ = (char) HexDigits[(c >> 4) & 0xF];
                        *p++ = (char) HexDigits[ c       & 0xF];
                        }
                    *p = '\0';
                    Status = RPC_S_OK;
                    }

                break;
                }
#endif
            }

        if (Status != RPC_S_OK)
            {
            if (ARGUMENT_PRESENT(Endpoint))
                {
                delete *Endpoint;
                *Endpoint = 0;
                }
            if (ARGUMENT_PRESENT(Protseq))
                {
                delete *Protseq;
                *Protseq = 0;
                }
            return(Status);
            }
        }

    ASSERT(Status == RPC_S_OK);
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\util.cxx ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

    Module Name:

        Util.cxx

    Abstract:

        Transport/protocol independent helper functions.

    Author:

        Mario Goertzel    [MarioGo]

    Revision History:

        MarioGo     2/21/1997    Bits 'n pieces

--*/

#include <precomp.hxx>

RPC_STATUS
EndpointToPortNumber(
    IN RPC_CHAR *endpoint,
    OUT USHORT &port)
/*++

Routine Description:

    Validates a unicode string which should contain a winsock (USHORT) port
    number and converts the string to an integer.

Arguments:

    endpoint - The port number as a unicode string
    port - If successful, the port number.

Return Value:

    RPC_S_OK
    RPC_S_INVALID_ENDPOINT_FORMAT

--*/
{
    RPC_CHAR *pT;

#ifdef UNICODE
    ULONG lport = wcstol(endpoint, &pT, 10);
#else
    ULONG lport = ANSI_strtol((const RPC_SCHAR *) endpoint, (RPC_SCHAR **) &pT, 10);
#endif

    if (lport == 0 || lport > 0xFFFF || *pT != 0)
        {
        return(RPC_S_INVALID_ENDPOINT_FORMAT);
        }

    port = (USHORT)lport;

    return(RPC_S_OK);
}


RPC_STATUS
EndpointToPortNumberA(
    IN char *endpoint,
    OUT USHORT &port)
/*++

Routine Description:

    Validates an ANSI string which should contain a winsock (USHORT) port
    number and converts the string to an integer.

Arguments:

    endpoint - The port number as an ANSI string
    port - If successful, the port number.

Return Value:

    RPC_S_OK
    RPC_S_INVALID_ENDPOINT_FORMAT

--*/
{
    char *pT;

    ULONG lport = ANSI_strtol(endpoint, &pT, 10);

    if (lport == 0 || lport > 0xFFFF || *pT != 0)
        {
        return(RPC_S_INVALID_ENDPOINT_FORMAT);
        }

    port = (USHORT)lport;

    return(RPC_S_OK);
}

void
PortNumberToEndpoint(
    IN USHORT port,
    OUT RPC_CHAR *pEndpoint
    )
{
    UNICODE_STRING UnicodeString;

    ASSERT(port);

    UnicodeString.Buffer = pEndpoint;
    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = 6 * sizeof(RPC_CHAR);

    NTSTATUS status = RtlIntegerToUnicodeString(port, 0, &UnicodeString);
    ASSERT(NT_SUCCESS(status));
}

void
PortNumberToEndpointA(
    IN USHORT port,
    OUT char *pEndpoint
    )
{
    NTSTATUS status = RtlIntegerToChar(port, 
        10,                 // Base
        6 * sizeof(char),   // OutputLength
        pEndpoint);

    ASSERT(NT_SUCCESS(status));
}

inline
UCHAR ConvertHexDigit(UCHAR digit)
/*++

Routine Description:

    Converts a character containing '0'-'9', 'a'-'f' or 'A'-'F' into the
    equivalent binary value: 0x0 - 0xF.

Arguments:

    digit - The character to convert.

Return Value:

    The value of digit or zero if the digit is not a hex digit.

--*/
{
    UCHAR r;

    r = digit - '0';
    if (r < 10)
        {
        return(r);
        }

    r = digit - 'a';
    if (r < 6)
        {
        return(r + 10);
        }

    r = digit - 'A';
    if (r < 6)
        {
        return(r + 10);
        }

    ASSERT(0);
    return 0;
}

UCHAR
HexDigitsToBinary(
    IN UCHAR high,
    IN UCHAR low
    )
/*++

Routine Description:

    Builds an 8-bit value from two hex digits.

--*/
{
    return( ( ConvertHexDigit(high) << 4 ) | ConvertHexDigit(low) );
}

DWORD
UTIL_WaitForSyncIO(
    LPOVERLAPPED lpOverlapped,
    IN BOOL fAlertable,
    IN DWORD dwTimeout
    )
/*++

Routine Description:

    The special part is that the same event (this's threads event)
    maybe used for multiple IOs at once. If another one of those
    IOs completes, it is ignored.  This only returns when the IO
    specified by lpOverlapped finishes or an alert/timeout happens.

Arguments:

    lpOverlapped - The status block associated with the IO in question.
    fAlertable - If TRUE, the wait is alertable
    dwTimeout - Milliseconds to wait for the IO.

Return Value:

    Same as WaitForSingleObjectEx()

--*/

{
    DWORD status;

    for (;;)
        {
        if (HasOverlappedIoCompleted(lpOverlapped))
            {
            break;
            }

        status = WaitForSingleObjectEx(lpOverlapped->hEvent, dwTimeout, fAlertable);
        if (status != WAIT_OBJECT_0)
            {
            ASSERT(   (status == WAIT_IO_COMPLETION && fAlertable)
                   || (status == WAIT_TIMEOUT && (dwTimeout != INFINITE)));
            return(status);
            }

        if (HasOverlappedIoCompleted(lpOverlapped))
            {
            break;
            }

        // Another Io completed, just ignore it for now.

        ResetEvent(lpOverlapped->hEvent);
        }

    return(WAIT_OBJECT_0);
}

DWORD
UTIL_WaitForSyncHTTP2IO(
    IN LPOVERLAPPED lpOverlapped,
    IN HANDLE hEvent,
    IN BOOL fAlertable,
    IN DWORD dwTimeout
    )
/*++

Routine Description:

    The special part is that the same event (this's threads event)
    maybe used for multiple IOs at once. If another one of those
    IOs completes, it is ignored.  This only returns when the IO
    specified by lpOverlapped finishes or an alert/timeout happens.

Arguments:

    lpOverlapped - The status block associated with the IO in question.

    hEvent - the event to wait on

    fAlertable - If TRUE, the wait is alertable

    dwTimeout - Milliseconds to wait for the IO.

Return Value:

    Same as WaitForSingleObjectEx()

--*/

{
    DWORD status;

    ASSERT(hEvent);

    for (;;)
        {
        if (lpOverlapped->OffsetHigh)
            {
            break;
            }

        status = WaitForSingleObjectEx(hEvent, dwTimeout, fAlertable);
        if (status != WAIT_OBJECT_0)
            {
            ASSERT(   (status == WAIT_IO_COMPLETION && fAlertable)
                   || (status == WAIT_TIMEOUT && (dwTimeout != INFINITE)));
            return(status);
            }

        if (lpOverlapped->OffsetHigh)
            {
            break;
            }

        // Another Io completed, just ignore it for now.

        ResetEvent(hEvent);
        }

    return(WAIT_OBJECT_0);
}

RPC_STATUS
UTIL_GetOverlappedResultEx(
    RPC_TRANSPORT_CONNECTION ThisConnection,
    LPOVERLAPPED lpOverlapped,
    LPDWORD lpNumberOfBytesTransferred,
    BOOL fAlertable,
    DWORD dwTimeout
    )
/*++

Routine Description:

    Similar to the Win32 API GetOverlappedResult.

    Works with thread event based IO.  (even with multiple IOs/thread-event)
    Allows cancels

Arguments:

    ThisConnection - RPC runtime connection associated with this IO.

    lpOverlapped - Overlapped structure of the IO in progress.
        Must contain a valid hEvent member.

    lpNumberOfBytesTransferred - see GetOverlappedResult

    fAlertable - If true, RPC cancels are enabled. This means the
        wait must be alertable and must follow a protocol to determine
        if a call has been cancelled.

    dwTimeout - Milliseconds to wait

Return Value:

    RPC_S_Ok
    RPC_P_TIMEOUT
    RPC_S_CALL_CANCELLED

--*/
{
    BASE_ASYNC_OBJECT *Connection = (BASE_ASYNC_OBJECT *) ThisConnection;
    ASSERT(lpOverlapped->hEvent);

    RPC_STATUS status;
    DWORD canceltimeout = 0;

    for(;;)
        {
        // Wait for the IO to complete
        status = UTIL_WaitForSyncIO(lpOverlapped, fAlertable, dwTimeout);

        if (status == WAIT_OBJECT_0)
            {
            break;
            }

        if (status == WAIT_TIMEOUT)
            {
            ASSERT(dwTimeout != INFINITE);

            if (canceltimeout)
                {
                return(RPC_S_CALL_CANCELLED);
                }

            return(RPC_P_TIMEOUT);
            }

        ASSERT(status == WAIT_IO_COMPLETION);

        if ((Connection->type & TYPE_MASK) == CLIENT)
            {
            //
            // The RPC call may have been cancelled, need to call
            // into the runtime to find out.
            //

            status = I_RpcTransIoCancelled(ThisConnection, &canceltimeout);
            switch (status)
                {
                case RPC_S_OK:
                    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   RPCTRANS "RPC cancelled (%p)\n",
                                   lpOverlapped));

                    if (canceltimeout == 0)
                        {
                        return (RPC_S_CALL_CANCELLED);
                        }

                    //
                    // Convert to milliseconds
                    //
                    canceltimeout *= 1000;

                    if (dwTimeout > canceltimeout)
                        {
                        dwTimeout = canceltimeout;
                        }
                    break;

                case RPC_S_NO_CALL_ACTIVE:
                    //
                    // ignore and continue
                    //
                    break;

                default:
                    return RPC_S_CALL_CANCELLED;
                }
            }

        // Either the call was cancelled and timeout has been updated or
        // the call wasn't cancelled and we need to wait again.
        }

    // IO has completed
    ASSERT(HasOverlappedIoCompleted(lpOverlapped));

    // IO successful
    *lpNumberOfBytesTransferred = ULONG(lpOverlapped->InternalHigh);

    if ( NT_SUCCESS(lpOverlapped->Internal) )
        {
        return(RPC_S_OK);
        }

    // IO failed
    return RtlNtStatusToDosError(ULONG(lpOverlapped->Internal));
}

RPC_STATUS
UTIL_GetOverlappedHTTP2ResultEx(
    RPC_TRANSPORT_CONNECTION ThisConnection,
    IN LPOVERLAPPED lpOverlapped,
    IN HANDLE hEvent,
    IN BOOL fAlertable,
    IN DWORD dwTimeout
    )
/*++

Routine Description:

    Similar to the Win32 API GetOverlappedResult.

    Works with thread event based IO.  (even with multiple IOs/thread-event)
    Allows cancels

Arguments:

    ThisConnection - RPC runtime connection associated with this IO.

    lpOverlapped - Overlapped structure of the IO in progress.
        Must contain a valid hEvent member.

    hEvent - event to wait on

    fAlertable - If true, RPC cancels are enabled. This means the
        wait must be alertable and must follow a protocol to determine
        if a call has been cancelled.

    dwTimeout - Milliseconds to wait

Return Value:

    RPC_S_Ok
    RPC_P_TIMEOUT
    RPC_S_CALL_CANCELLED

--*/
{
    BASE_ASYNC_OBJECT *Connection = (BASE_ASYNC_OBJECT *) ThisConnection;
    ASSERT(hEvent);

    RPC_STATUS status;
    DWORD canceltimeout = 0;

    for(;;)
        {
        // Wait for the IO to complete
        status = UTIL_WaitForSyncHTTP2IO(lpOverlapped, hEvent, fAlertable, dwTimeout);

        if (status == WAIT_OBJECT_0)
            {
            break;
            }

        if (status == WAIT_TIMEOUT)
            {
            ASSERT(dwTimeout != INFINITE);

            if (canceltimeout)
                {
                return(RPC_S_CALL_CANCELLED);
                }

            return(RPC_P_TIMEOUT);
            }

        ASSERT(status == WAIT_IO_COMPLETION);

        if ((Connection->type & TYPE_MASK) == CLIENT)
            {
            //
            // The RPC call may have been cancelled, need to call
            // into the runtime to find out.
            //

            status = I_RpcTransIoCancelled(ThisConnection, &canceltimeout);
            switch (status)
                {
                case RPC_S_OK:
                    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   RPCTRANS "RPC cancelled (%p)\n",
                                   lpOverlapped));

                    if (canceltimeout == 0)
                        {
                        return (RPC_S_CALL_CANCELLED);
                        }

                    //
                    // Convert to milliseconds
                    //
                    canceltimeout *= 1000;

                    if (dwTimeout > canceltimeout)
                        {
                        dwTimeout = canceltimeout;
                        }
                    break;

                case RPC_S_NO_CALL_ACTIVE:
                    //
                    // ignore and continue
                    //
                    break;

                default:
                    return RPC_S_CALL_CANCELLED;
                }
            }

        // Either the call was cancelled and timeout has been updated or
        // the call wasn't cancelled and we need to wait again.
        }

    // IO has completed
    ASSERT(lpOverlapped->OffsetHigh);

    if (lpOverlapped->Internal == RPC_S_OK)
        {
        return(RPC_S_OK);
        }

    if ((lpOverlapped->Internal == RPC_P_CONNECTION_SHUTDOWN)
     || (lpOverlapped->Internal == RPC_P_RECEIVE_FAILED)
     || (lpOverlapped->Internal == RPC_P_SEND_FAILED)
     || (lpOverlapped->Internal == RPC_P_CONNECTION_CLOSED)
     || (lpOverlapped->Internal == RPC_S_OUT_OF_MEMORY)
     || (lpOverlapped->Internal == RPC_S_SERVER_UNAVAILABLE)
     || (lpOverlapped->Internal == RPC_S_PROTOCOL_ERROR) )
        {
        return lpOverlapped->Internal;
        }
    else if (lpOverlapped->Internal == RPC_S_OUT_OF_THREADS)
        {
        return RPC_S_OUT_OF_MEMORY;
        }  
    else
        {
        // IO failed
        status = RtlNtStatusToDosError(ULONG(lpOverlapped->Internal));
        ASSERT(status != ERROR_MR_MID_NOT_FOUND);
        return status;
        }
}




char * _cdecl
RpcStrTok(
    IN char * string,
    IN const char * control,
    IN OUT char ** ppStrPrev
    )
/*++

Routine Description:

    Tokenize string with delimiter in control. Similar to C runtime function
    strtok() but no state information is maintained. The caller is expected
    to give the string from where to tokenize next.

    strtok considers the string to consist of a sequence of zero or more
    text tokens separated by spans of one or more control chars. The first
    call, with string specified, returns a pointer to the first char of the
    first token, and will write a null char into string immediately
    following the returned token. Subsequent calls with zero for the first
    argument (string) will work thru the string until no tokens remain. The
    control string may be different from call to call. when no tokens remain
    in string a NULL pointer is returned. Remember the control chars with a
    bit map, one bit per ascii char. The null char is always a control char.

Arguments:

    string - string to tokenize, or NULL to get next token

    control - string of characters to use as delimiters

    strPrev - string returned from the preceeding call to RpcStrTok().

Note:

    a. Works only for ANSI character strings.

    b. Cloned from SLM project vctools [crt\crtw32\string\strtok.c].

Return Value:

    pointer to first token in string, or if string was NULL, to next token

    NULL,  when no more tokens remain.

--*/
{
    char *str;
    const char *ctrl = control;

    unsigned char map[32];
    int count;

    ASSERT(ppStrPrev != NULL);

    char * nextoken = *ppStrPrev;

    /* Clear control map */
    for (count = 0; count < 32; count++)
        map[count] = 0;

    /* Set bits in delimiter table */
    do {
        map[*ctrl >> 3] |= (1 << (*ctrl & 7));
    } while (*ctrl++);

    /* Initialize str. If string is NULL, set str to the saved
     * pointer (i.e., continue breaking tokens out of the string
     * from the last strtok call) */
    if (string)
        str = string;
    else
        str = nextoken;

    /* Find beginning of token (skip over leading delimiters). Note that
     * there is no token iff this loop sets str to point to the terminal
     * null (*str == '\0') */
    while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
        str++;

    string = str;

    /* Find the end of the token. If it is not the end of the string,
     * put a null there. */
    for ( ; *str ; str++ )
        if ( map[*str >> 3] & (1 << (*str & 7)) ) {
            *str++ = '\0';
            break;
            }

    /* Update nextoken (or the corresponding field in the per-thread data
     * structure). This should update *ppStrPrev. */
    nextoken = str;

    /* Determine if a token has been found. */
    if ( string == str )
        return NULL;
    else
        return string;
}


#if defined(DBG) && defined(TRANSPORT_DLL)
BOOL ValidateError(
    IN unsigned int Status,
    IN unsigned int Count,
    IN const int ErrorList[])
/*++
Routine Description

    Tests that 'Status' is one of an expected set of error codes.
    Used on debug builds as part of the VALIDATE() macro.

Example:

        VALIDATE(EventStatus)
            {
            RPC_P_CONNECTION_CLOSED,
            RPC_P_RECEIVE_FAILED,
            RPC_P_CONNECTION_SHUTDOWN
            // more error codes here
            } END_VALIDATE;

     This function is called with the RpcStatus and expected errors codes
     as parameters.  If RpcStatus is not one of the expected error
     codes and it not zero a message will be printed to the debugger
     and the function will return false.  The VALIDATE macro ASSERT's the
     return value.

Arguments:

    Status - Status code in question.
    Count - number of variable length arguments

    ... - One or more expected status codes.  Terminated with 0 (RPC_S_OK).

Return Value:

    TRUE - Status code is in the list or the status is 0.

    FALSE - Status code is not in the list.

--*/
{
    unsigned i;

    for (i = 0; i < Count; i++)
        {
        if (ErrorList[i] == (int) Status)
            {
            return TRUE;
            }
        }

    PrintToDebugger("RPC Assertion: unexpected failure %lu (0lx%08x)\n",
                    (unsigned long)Status, (unsigned long)Status);

    return(FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1989


Revision History:

!ENDIF

#
# The TARGETNAME variable is defined by the developer.  It is the name of
# the target (component) that is being built by this makefile.  It
# should NOT include any path or file extension information.
#

TARGETNAME=rpctrans

#
# The TARGETPATH and TARGETTYPE variables are defined by the developer.
# The first specifies where the target is to be build.  The second specifies
# the type of target (either PROGRAM, DYNLINK or LIBRARY)
#

TARGETPATH=obj
TARGETTYPE=LIBRARY

#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#

INCLUDES=..;..\..\..\..\selbinding;..\..\..\mtrt;..\..\..\rtifs\$(O);..\..\..\charconv;$(BASE_INC_PATH);$(NET_INC_PATH)

#
# The SOURCES variable is defined by the developer.  It is a list of all the
# source files for this component.  Each source file should be on a separate
# line using the line continuation character.  This will minimize merge
# conflicts if two developers adding source files to the same component.
#

MSC_WARNING_LEVEL=/WX

PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_CXX=1

SOURCES= $(SOURCES)  \
    ..\afd.cxx      \
    ..\complete.cxx \
    ..\Cookie.cxx   \
    ..\loader.cxx   \
    ..\cotrans.cxx  \
    ..\dgtrans.cxx  \
    ..\HndlCach.cxx \
    ..\HTTP2.cxx    \
    ..\HttpRTS.cxx  \
    ..\muteximp.cxx \
    ..\nptrans.cxx  \
    ..\wsload.cxx   \
    ..\wstrans.cxx  \
    ..\tower.cxx    \
    ..\httptran.cxx \
    ..\httpreg.cxx  \
    ..\regexp.cxx   \
    ..\util.cxx     \
    ..\Protocol.cxx \
    ..\WHttpImp.cxx

i386_SOURCES= \
    ..\ipxname.cxx

C_DEFINES= $(C_DEFINES) -DWIN32RPC -D_RPCRT4_ -D_RPCTRANS_

UMTYPE=console



#
# Defining the NTTARGETFILES variable causes MAKEFILE.DEF to attempt to
# include .\makefile.inc immediately after it specifies the top
# level targets (all, clean and loc) and their dependencies.  MAKEFILE.DEF
# also expands the value of the NTTARGETFILES variable at the end of the
# list of dependencies for the all target.  Useful for specifying additional
# targets and dependencies that don't fit the general case covered by
# MAKEFILE.DEF
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\wsload.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    wsload.cxx

Abstract:

    Implements the wrapper used to avoid loading the winsock
    DLLs into more processes than necessary.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     3/21/1996    Bits 'n pieces

--*/

#include <precomp.hxx>
#include <wswrap.hxx>

struct WINSOCK_FUNCTION_TABLE WFT;

HMODULE hWinsock = 0;
HMODULE hWinsock2 = 0;

typedef int (PASCAL FAR *PWSASTARTUP)(WORD wVersionRequired, LPWSADATA lpWSAData);

typedef struct tagProcAddressData
{
    int nDllIndex;      // 0 is ws2_32.dll, 1 is mswsock.dll
    char *pProcName;
} ProcAddressData;

const ProcAddressData WinsockProcData[] = {
    { 0, "socket" },
    { 0, "bind" },
    { 0, "closesocket" },
    { 0, "getsockname" },
    { 0, "connect" },
    { 0, "listen" },
    { 0, "send" },
    { 0, "recv" },
    { 0, "sendto" },
    { 0, "recvfrom" },
    { 0, "setsockopt" },
    { 0, "getsockopt" },
    { 0, "inet_ntoa" },
    { 0, "gethostbyname" },
    { 1, "GetAddressByNameA" },
    { 0, "WSASocketW" },
    { 0, "WSARecv" },
    { 0, "WSARecvFrom" },
    { 0, "WSASend" },
    { 0, "WSASendTo" },
    { 0, "WSAProviderConfigChange" },
    { 0, "WSAEnumProtocolsW" },
    { 0, "WSAIoctl" },
    { 0, "getaddrinfo"},
    { 0, "freeaddrinfo"},
    { 0, "getnameinfo" },
    { 0, "WSAGetOverlappedResult" }
    };

LONG TriedUsingAfd = 0;

// Winsock's function IN6ADDR_SETANY uses the external constant in6addr_any.
// Since we do not statically link to obtain this constatnt, we need to define
// one ourselves.
const struct in6_addr in6addr_any = IN6ADDR_ANY_INIT;

void TryUsingAfdProc(void) {    

    // Figure out if we can call AFD directly for datagram.

    // This is a performance optimization - if any thing fails
    // or does match exactly to MSAFD the we'll just use the
    // ws2_32 exported functions.
    static const UUID aDefaultProviders[] = {
        { 0xe70f1aa0, 0xab8b, 0x11cf, 0x8c, 0xa3, 0x0, 0x80, 0x5f, 0x48, 0xa1, 0x92 }, // AFD UDP
        { 0x9d60a9e0, 0x337a, 0x11d0, 0xbd, 0x88, 0x0, 0x00, 0xc0, 0x82, 0xe6, 0x9a }, // RSVP UDP
        { 0x11058240, 0xbe47, 0x11cf, 0x95, 0xc8, 0x0, 0x80, 0x5f, 0x48, 0xa1, 0x92 }  // AFD IPX
        };


    INT aProtocols[] = { IPPROTO_UDP, NSPROTO_IPX, 0 };
    WSAPROTOCOL_INFO *info;
    DWORD dwSize;
    INT cProtocols;
    BOOL fUseAfd = TRUE;

    info = new WSAPROTOCOL_INFO[8];
    if (info == NULL)
        {
        cProtocols = 0;
        fUseAfd = FALSE;
        }
    else
        {
        dwSize = sizeof(WSAPROTOCOL_INFO) * 8;
        }

    if (fUseAfd)
        {
        cProtocols = WSAEnumProtocolsT(aProtocols,
                                      info,
                                      &dwSize);

        if (cProtocols <= 0)
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "Failed to enum protocols, using winsock. %d\n",
                           GetLastError()));

            cProtocols = 0;
            fUseAfd = FALSE;
            }

        for (int i = 0; i < cProtocols; i++)
            {
            BOOL fFoundIt = FALSE;

            for (int j = 0; j < sizeof(aDefaultProviders)/sizeof(UUID); j++)
                {
                if (memcmp(&aDefaultProviders[j], &info[i].ProviderId, sizeof(UUID)) == 0)
                    {
                    fFoundIt = TRUE;
                    }
                }

            if (!fFoundIt)
                {
                fUseAfd = FALSE;
                }
            }
        }

    if (fUseAfd)
        {
        WFT.pWSASendTo = AFD_SendTo;
        WFT.pWSARecvFrom = AFD_RecvFrom;
        }
    else
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "Non-default winsock providers loaded\n"));
        }

    if (info)
        delete [] info;
}


C_ASSERT((sizeof(WinsockProcData) / sizeof(ProcAddressData)) <= (sizeof(WINSOCK_FUNCTION_TABLE) / sizeof(FARPROC)));

BOOL RPC_WSAStartup(void)
{
    // Transport load can only be called by a single thread at a time.

    WSADATA data;
    PWSASTARTUP pStartup;
    FARPROC *ppProc;
    BOOL status;
    BOOL b;
    HMODULE ws2;
    HMODULE ws;
    HMODULE hDlls[2];

    if (hWinsock == 0)
        {
        ws = LoadLibrary(RPC_CONST_SSTRING("mswsock.dll"));

        ws2 = LoadLibrary(RPC_CONST_SSTRING("ws2_32.dll"));

        if (ws == 0 || ws2 == 0)
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "Unable to load windows sockets dlls, bad config? %d\n",
                           GetLastError()));

            return FALSE;
            }
        }
    else
        {
        // loading already performed - just return true
        ASSERT(hWinsock2);
        return TRUE;
        }

    status = FALSE;

    pStartup = (PWSASTARTUP)GetProcAddress(ws2, "WSAStartup");
    if (pStartup)
        {
        if ( (*pStartup)(2, &data) == NO_ERROR)
            {
            status = TRUE;
            }
        }

    if (!status)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "GetProcAddr or WSAStartup failed %d\n",
                       GetLastError()));

        b = FreeLibrary(ws);
        if (b)
            b = FreeLibrary(ws2);

        if (!b)
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "FreeLibrary failed %d\n",
                           GetLastError()));

            ASSERT(0);
            }
        return(FALSE);
        }

    ppProc = (FARPROC *)&WFT;
    hDlls[0] = ws2;
    hDlls[1] = ws;

    // WinsockProcData is smaller than WINSOCK_FUNCTION_TABLE. Make sure the loop
    // is driven by WinsockProcData
    for (int i = 0; i < sizeof(WinsockProcData) / sizeof(ProcAddressData); i++)
        {
        *ppProc = GetProcAddress(hDlls[WinsockProcData[i].nDllIndex], WinsockProcData[i].pProcName);
        if (*ppProc == 0)
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "Failed to load winsock procedure %s correctly\n",
                           WinsockProcData[i].pProcName));

            b = FreeLibrary(ws);
            if (b)
                b = FreeLibrary(ws2);

            if (!b)
                {
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "FreeLibrary failed %d\n",
                               GetLastError()));

                ASSERT(0);
                }
            return(FALSE);
            }
        ppProc ++;
        }

    hWinsock = ws;
    hWinsock2 = ws2;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\wstrans.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    wstrans.cxx

Abstract:

    Winsock connection transport interface.

Author:

    Mario Goertzel    [MarioGo]


Revision History:

    MarioGo     3/18/1996    Bits 'n pieces
    MarioGo     12/1997      Async and client parts
    KamenM      Aug 2/2000   IPv6 Support added - rewrote parts of it

--*/

#include <precomp.hxx>
#include <CharConv.hxx>

//
// Globals
//

BOOL fWinsockLoaded = FALSE;

const WS_TRANS_INFO WsTransportTable[] =
    // indexed by protocol ID
{

    {
    0
    },

    // TCP
    {
    AF_INET,
    SOCK_STREAM,
    IPPROTO_TCP,
    sizeof(SOCKADDR_IN),
    FALSE,
    TRUE,
    TRUE, TRUE, FALSE, FALSE
    },

#ifdef SPX_ON
    // SPX
    {
    AF_IPX,
    SOCK_STREAM,
    NSPROTO_SPXII,
    sizeof(SOCKADDR_IPX),
    FALSE,
    FALSE,
    FALSE, FALSE, FALSE, FALSE
    },
#else
    {
    0,
    0,
    0,
    0,
    0, 0, 0
    },

#endif

    // NMP - not winsock.
    {
    0,
    0,
    0,
    0,
    0, 0, 0
    },

#ifdef NETBIOS_ON
    // NBF
    {
    AF_NETBIOS,
    SOCK_SEQPACKET,
    -1, // Protocol is -1*(LANA),
    sizeof(SOCKADDR_NB),
    TRUE,
    FALSE,
    FALSE, FALSE, FALSE, FALSE
    },

    // NBT
    {
    AF_NETBIOS,
    0,
    -1, // Protocol is -1*(LANA)
    sizeof(SOCKADDR_NB),
    TRUE,
    FALSE,
    FALSE, FALSE, FALSE, FALSE
    },

    // NBI
    {
    AF_NETBIOS,
    SOCK_SEQPACKET,
    -1, // Protocol is -1*(LANA)
    sizeof(SOCKADDR_NB),
    TRUE,
    FALSE,
    FALSE, FALSE, FALSE, FALSE
    },
#else
    // NBF
    {
    0,
    0,
    0,
    0,
    0, 0, 0
    },

    // NBT
    {
    0,
    0,
    0,
    0,
    0, 0, 0
    },

    // NBI
    {
    0,
    0,
    0,
    0,
    0, 0, 0
    },
#endif

#ifdef APPLETALK_ON
    // DSP
    {
    AF_APPLETALK,
    SOCK_RDM,
    ATPROTO_ADSP,
    sizeof(SOCKADDR_AT),
    FALSE,
    FALSE,
    FALSE, FALSE, FALSE, FALSE
    },
#else
    // DSP
    {
    0,
    0,
    0,
    0,
    0, 0, 0
    },
#endif

    // SPP
    {
    0,
    0,
    0,
    0,
    0, 0, 0
    },

    // HTTP
    {
    AF_INET,
    SOCK_STREAM,
    IPPROTO_TCP,
    sizeof(SOCKADDR_IN),
    FALSE,
    TRUE,
    TRUE, TRUE, FALSE, FALSE
    },

    // UDP
    {
    AF_INET,
    SOCK_DGRAM,
    IPPROTO_UDP,
    sizeof(SOCKADDR_IN),
    FALSE,
    FALSE,
    FALSE, FALSE, FALSE, FALSE
    },

#ifdef IPX_ON
    // IPX
    {
    AF_IPX,
    SOCK_DGRAM,
    NSPROTO_IPX,
    sizeof(SOCKADDR_IPX),
    FALSE,
    FALSE,
    FALSE, FALSE, FALSE, FALSE
    },
#else
    // IPX
    {
    0,
    0,
    0,
    0,
    0,
    0,
    0, 0, 0, 0
    },
#endif

    // CDP (Cluster datagram protocol)
    {
    AF_CLUSTER,
    SOCK_DGRAM,
    CLUSPROTO_CDP,
    sizeof(SOCKADDR_CLUSTER),
    FALSE,
    FALSE,
    FALSE, FALSE, FALSE, FALSE
    },

    // MSMQ - not winsock.
    {
    0,
    0,
    0,
    0,
    0, 0, 0
    },

    // TCP over IPv6
    {
    AF_INET6,
    SOCK_STREAM,
    IPPROTO_TCP,
    sizeof(SOCKADDR_IN6),
    FALSE,
    TRUE,
    TRUE, TRUE, FALSE, FALSE
    },

    // HTTPv2
    {
    AF_INET,
    SOCK_STREAM,
    IPPROTO_TCP,
    sizeof(SOCKADDR_IN),
    FALSE,      // fNetbios
    FALSE,      // fCheckShutdowns
    TRUE,       // fSetNoDelay
    TRUE,       // fSetKeepAlive
    FALSE,      // fSetRecvBuffer
    FALSE       // fSetSendBuffer
    },

};

const DWORD cWsTransportTable = sizeof(WsTransportTable)/sizeof(WS_TRANS_INFO);

const DWORD cTcpTimeoutDefault = 120 * 60 * 1000; // Normal TCP/IP timeout, 120 minutes

const UUID WS_ADDRESS::ExtensionFunctionsUuids[] = {WSAID_ACCEPTEX, WSAID_GETACCEPTEXSOCKADDRS};
const int WS_ADDRESS::AcceptExFunctionId = 0;
const int WS_ADDRESS::GetAcceptExSockAddressFunctionId = 1;

#define FIRST_EXTENSION_FUNCTION_CODE  (WS_ADDRESS::AcceptExFunctionId)
#define LAST_EXTENSION_FUNCTION_CODE  (WS_ADDRESS::GetAcceptExSockAddressFunctionId)

inline BOOL IsNetbiosProtocol(PROTOCOL_ID id)
{
#ifdef NETBIOS_ON
    return ((id == NBT) || (id == NBF) || (id == NBI));
#else
    return FALSE;
#endif
}

void 
TCPResolverHint::GetResolverHint (
    OUT BOOL *fIPv4Hint,
    OUT WS_SOCKADDR *sa
    )
/*++

Routine Description:

    Retrieves the resolver hint from the runtime supplied hint
    (the this object).

Arguments:

    fIPv4Hint - on output true if the store hint was about IPv4
    sa - on output, the IP address is retrieved from the hint
        and stored in sa.

Return Value:

--*/
{
    SOCKADDR_IN6 *IPv6Address = (SOCKADDR_IN6 *)sa;

    *fIPv4Hint = fIPv4HintValid;
    if (fIPv4HintValid)
        {
        ((SOCKADDR_IN *)sa)->sin_addr.s_addr = u.IPv4Hint;
        }
    else
        {
        IPv6Address->sin6_flowinfo = 0;
        *((u_long *)(IPv6Address->sin6_addr.s6_addr)    ) = *((u_long *)(u.IPv6Hint.u.Word)    );
        *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 1) = *((u_long *)(u.IPv6Hint.u.Word) + 1);
        *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 2) = *((u_long *)(u.IPv6Hint.u.Word) + 2);
        *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 3) = *((u_long *)(u.IPv6Hint.u.Word) + 3);
        IPv6Address->sin6_scope_id = 0;
        }
}

void
TCPResolverHint::SetResolverHint (
    IN BOOL fIPv4Hint,
    IN WS_SOCKADDR *sa
    )
/*++

Routine Description:

    Sets the resolver hint in the runtime supplied hint
    (the this object).

Arguments:

    fIPv4Hint - true if the stored hint is about IPv4
    sa - the IP address is retrieved from sa
        and is stored in the hint.

Return Value:

--*/
{
    SOCKADDR_IN6 *IPv6Address = (SOCKADDR_IN6 *)sa;

    fIPv4HintValid = fIPv4Hint;
    if (fIPv4HintValid)
        {
        u.IPv4Hint = ((SOCKADDR_IN *)sa)->sin_addr.s_addr;
        }
    else
        {
        *((u_long *)(u.IPv6Hint.u.Word)    ) = *((u_long *)(IPv6Address->sin6_addr.s6_addr)    );
        *((u_long *)(u.IPv6Hint.u.Word) + 1) = *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 1);
        *((u_long *)(u.IPv6Hint.u.Word) + 2) = *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 2);
        *((u_long *)(u.IPv6Hint.u.Word) + 3) = *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 3);
        }
}

BOOL WS_ADDRESS::GetExtensionFunctionPointers(SOCKET sock)
{
    int i;

    for (i = FIRST_EXTENSION_FUNCTION_CODE; i <= LAST_EXTENSION_FUNCTION_CODE; i ++)
        {
        if (GetExtensionFunctionPointerForFunction(sock, i) == FALSE)
            return FALSE;
        }
    return TRUE;
}

BOOL WS_ADDRESS::GetExtensionFunctionPointerForFunction(SOCKET sock, int nFunctionCode)
{
    DWORD dwBytesReturned;
    int retval;

    ASSERT(nFunctionCode >= FIRST_EXTENSION_FUNCTION_CODE);
    ASSERT(nFunctionCode <= LAST_EXTENSION_FUNCTION_CODE);
    ASSERT(sizeof(ExtensionFunctionPointers)/sizeof(ExtensionFunctionPointers[0]) == (LAST_EXTENSION_FUNCTION_CODE - FIRST_EXTENSION_FUNCTION_CODE + 1));

    retval = WSAIoctl(sock, SIO_GET_EXTENSION_FUNCTION_POINTER, (void *) &ExtensionFunctionsUuids[nFunctionCode],
        sizeof(UUID), (void *) &ExtensionFunctionPointers[nFunctionCode], sizeof(void *), &dwBytesReturned,
        NULL, NULL);

    if (retval == SOCKET_ERROR)
        return FALSE;

    ASSERT(dwBytesReturned == sizeof(void *));
    return TRUE;
}


//
// General winsock interfaces
//

RPC_STATUS WS_CONNECTION::Abort(void)
/*++

Routine Description:

    Closes a connection, will be called only before WS_Close() and
    maybe called by several threads at once.  It must also handle
    the case where another thread is about to start IO on the connection.

Arguments:

    Connection - pointer to a server connection object to abort.

Return Value:

    RPC_S_OK

--*/

{
    if (InterlockedIncrement(&fAborted) != 1)
        {
        // Another thread beat us to it. Normal during
        // a call to WS_Close.
        return(RPC_S_OK);
        }

    I_RpcLogEvent(SU_TRANS_CONN, EV_ABORT, this, ULongToPtr(GetLastError()), 0, 1, 2);

    // Wait for any threads which are starting IO to do so.
    while(IsIoStarting())
        Sleep(1);

    RTL_SOFT_ASSERT(fAborted != 0 && IsIoStarting() == 0);

    if (type & SERVER)
        {
        ASSERT(pAddress != NULL);
        }

    if (Conn.Socket)
        {
        closesocket(Conn.Socket);
        Conn.Socket = 0;
        }

    return(RPC_S_OK);
}


VOID
WS_DeactivateAddress (
    IN WS_ADDRESS *pAddress
    )
/*++
Function Name:WS_DeactivateAddress

Parameters:

Note:

    Doesn't deal with multiple transport addresses/runtime address
    case in netbios or TCP/IP bound to a subset of NICs case. These
    cases currently don't PnP.

Description:

Returns:

--*/
{
    switch (pAddress->id)
        {
        case TCP:
        case TCP_IPv6:
        case HTTP:
#ifdef SPX_ON
        case SPX:
#endif
#ifdef APPLETALK_ON
        case DSP:
#endif
            break;

        default:
            //
            // Don't deactivate the other guys
            //
#ifdef NETBIOS_ON
            ASSERT((pAddress->id == NMP)
                    || (pAddress->id == NBF)
                    || (pAddress->id == NBT)
                    || (pAddress->id == NBI)
                    || (pAddress->id == CDP)
                    );
#else
            ASSERT((pAddress->id == NMP)
                    || (pAddress->id == CDP)
                    );
#endif
            return;
        }

    if (InterlockedIncrement(&pAddress->fAborted) != 1)
        {
        return;
        }

    if (pAddress->ListenSocket)
        {
        closesocket(pAddress->ListenSocket);
        pAddress->ListenSocket = 0;
        }

    if (pAddress->ConnectionSocket)
        {
        closesocket(pAddress->ConnectionSocket);
        pAddress->ConnectionSocket = 0;
        }
}

RPC_STATUS
WS_ServerListenCommon (
    IN WS_ADDRESS *pAddress,
    IN BOOL fResetAddressListEntries = TRUE, OPTIONAL
    IN BOOL fAddToProtocolList = TRUE OPTIONAL
    );

USHORT
WS_GetPortForTCPAddressOnAddressRestart (
    IN WS_ADDRESS *pAddress
    )
/*++
Function Name: WS_GetPortForTCPAddressOnAddressRestart

Parameters:
    pAddress - the address for which we need to get the port

Description:
    When an address is restarted and it happens to be a TCP
    address, we need to call this function to get the port to
    be used. This is necessary so that if we are in a dual
    transport configuration with an active address we can get
    the port from the other address in order to maintain
    consistency

Returns:
    the port number or 0 (means no known ports or not a dual 
    transport configuration)

--*/
{
    WS_ADDRESS *NextAddress;
    USHORT PortNumber = 0;

    ASSERT((pAddress->id == TCP) || (pAddress->id == TCP_IPv6));
    ASSERT(pAddress->fDynamicEndpoint);

    if (pAddress->pFirstAddress != NULL)
        {
        NextAddress = (WS_ADDRESS *)pAddress->pFirstAddress;
        }
    else
        NextAddress = pAddress;


    while (NextAddress != NULL)
        {
        ASSERT(NextAddress->fDynamicEndpoint);
        ASSERT((NextAddress->id == TCP) || (NextAddress->id == TCP_IPv6));
        if (!NextAddress->fAborted)
            {
            PortNumber = RpcpGetIpPort(&NextAddress->ListenAddr);
            ASSERT(PortNumber != 0);
            break;
            }
        NextAddress = (WS_ADDRESS *)NextAddress->pNextAddress;
        }

    return PortNumber;
}


RPC_STATUS
WS_ReactivateAddress (
    IN WS_ADDRESS *pAddress,
    IN BOOL fResetAddressListEntries OPTIONAL
    )
/*++
Function Name:WS_ReactivateAddress

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    WS_SOCKADDR *sockaddr = &(pAddress->ListenAddr);

    //
    // If the endpoint is dynamic, clear out the endpoint
    //
    switch (pAddress->id)
        {
        case TCP:
        case TCP_IPv6:
            if (pAddress->fDynamicEndpoint)
                {
                RpcpSetIpPort(sockaddr, WS_GetPortForTCPAddressOnAddressRestart(pAddress));
                }
            break;

        case HTTP:
            if (pAddress->fDynamicEndpoint)
                {
                RpcpSetIpPort(sockaddr, 0);
                }
            break;

#ifdef SPX_ON
        case SPX:
            if (pAddress->fDynamicEndpoint)
                {
                sockaddr->ipxaddr.sa_socket = 0;
                }
            break;
#endif

#ifdef APPLETALK_ON
        case DSP:
            // Don't need to null out the endpoint
            break;
#endif

        default:
            VALIDATE(pAddress->id)
                {
                NMP,
#ifdef NETBIOS_ON
                NBF,
                NBT,
                NBI,
#endif
                CDP
                } END_VALIDATE;
            //
            // Don't reactivate the other guys
            //
            return RPC_S_OK;
        }

    // Pass in fAddToProtocolList = FALSE since the object is already in the protocol list.
    Status = WS_ServerListenCommon (pAddress, fResetAddressListEntries, FALSE);
    if (Status == RPC_S_OK)
        {
        pAddress->fAborted = 0;
        pAddress->GetExtensionFunctionPointers(pAddress->ListenSocket);
        }
    else if (Status == RPC_P_ADDRESS_FAMILY_INVALID)
        {
        Status = RPC_S_PROTSEQ_NOT_SUPPORTED;
        }

    return Status;
}


RPC_STATUS
RPC_ENTRY
WS_Close(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN BOOL fDontFlush
    )
/*++

Routine Description:

    Called once when the connection object is to be really deleted.
    At this point there will be no async IO pending on the connection.

Arguments:

    ThisConnection - The connection object to close

Return Value:

    RPC_S_OK

--*/

{
    SOCKET s;
    WS_CONNECTION *p = (WS_CONNECTION *)ThisConnection;

    p->WS_CONNECTION::Abort();

    if (p->iLastRead)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "Closing connection %p with left over data (%d) %p \n",
                       p,
                       p->iLastRead,
                       p->pReadBuffer));
        }

    // Wait for the pending receive, if any, to actually complete.

    if ((p->type & TYPE_MASK) == CLIENT)
        {
        // these operations don't apply to all netbios flavors - they
        // apply to protocols which interop with OSF servers only
        // (because of the check for shutdown)
        if (!IsNetbiosProtocol(p->id))
            {
            PWS_CCONNECTION pcc = (PWS_CCONNECTION)ThisConnection;
            if (pcc->fReceivePending)
                {
                UTIL_WaitForSyncIO(&pcc->Read.ol,
                                   FALSE,
                                   INFINITE);

                }
            }
        }

    // Now free the read buffer

    TransConnectionFreePacket(ThisConnection, p->pReadBuffer);
    p->pReadBuffer = 0;

    TransportProtocol::RemoveObjectFromProtocolList((BASE_ASYNC_OBJECT *) ThisConnection);

    return(RPC_S_OK);
}


BOOL
WS_ProtectListeningSocket(
    IN SOCKET sock,
    IN BOOL newValue
    )
/*++

Routine Description:

    Sets the SO_EXCLUSIVEADDRUSE socket option on the sock parameter.  This
    prevents another process from using same port # and stealing our
    connections.

    Note: This option can only be set by administrators.  This routine has no
          affect when called by non-administrator.

Arguments:

    sock - The socket to protect
    newValue - TRUE if the socket is to be protected, FALSE if it is to be unprotected

Return Value:

    0 if it succeeds, 1 if it fails

--*/
{
    int fSocketExclusive = newValue;
    int rval;

    rval = setsockopt(sock,
                      SOL_SOCKET,
                      SO_EXCLUSIVEADDRUSE,
                      (const char *)&fSocketExclusive,
                      sizeof(fSocketExclusive));

    if (rval != 0)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       "Unable to protect listening socket %d\n",
                       GetLastError()));
        }

    return rval;
}


RPC_STATUS
WS_CheckForShutdowns(
    PWS_CCONNECTION p
    )
/*++

Routine Description:

    When a connection is idle OSF DCE 1.1+ machines will try to reduce
    resource usage by shutting down the connection.  This is the place
    in the DCE RPC protocol where the servers send data to the client
    asychronously to the client sending a request.
    When a server decides to shutdown a connection it send three
    PDUs of the rpc_shutdown type.  Then, if there are no open context
    handles on the connection, it will gracefully close the connection.
    Note: If there are context handles open on the connection then
    the connection is not acutally closed, but the shutdown PDUs are
    still sent.

Algorithm:

    allocate a buffer large enough for a shutdown PDU.

    loop (i = 1 to 4 step 1)
        submit an async receive on the connection.
        If the receive doesn't complete immediately, return.

        type = PDU->type.

        If type != shutdown, save the PDU in the connection and return.

        goto Loop:

    If we get here it means we got too many shutdown PDUs. ASSERT and
    close the connection.

Arguments:

    p - The connection to check for shutdowns on.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_P_RECEIVE_FAILED
    RPC_P_SEND_FAILED

--*/

{
    RPC_STATUS status;
    BUFFER buffer;
    UINT length;
    HANDLE hEvent;

    if (p->iLastRead == 0)
        {
        // The server may have sent us a shutdown packet while the client
        // was idle.  We'll submit a recv now and check the result without
        // waiting.
        //
        // OSF servers will send 3 shutdown packets and then close the
        // connection.  We try to submit four receives, this way if the
        // connection has already been closed we can fail here.

        // Allocate a packet
        p->pReadBuffer = TransConnectionAllocatePacket(p, p->iPostSize);

        if (NULL == p->pReadBuffer)
            {
            p->WS_CONNECTION::Abort();
            return(RPC_S_OUT_OF_MEMORY);
            }

        p->maxReadBuffer = p->iPostSize;
        }
    else
        {
        ASSERT(p->pReadBuffer);
        }

    InitReadEvent(p);

    for (int i = 0; i < 4; i++)
        {
        status = CO_SubmitSyncRead(p, &buffer, &length);

        if (status == RPC_S_OK)
            {
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "Shutdown check completed!\n"));

            PCONN_RPC_HEADER phdr = (PCONN_RPC_HEADER)buffer;

            switch (MessageType(phdr))
                {
                case rpc_shutdown:
                    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   RPCTRANS "Received a shutdown\n"));

                    p->fShutdownReceived = TRUE;

                    // Reset the buffers and try again.
                    if (p->pReadBuffer == 0)
                        {
                        // we don't know how big the buffer actually is. It may be
                        // gPostSize, but it also may be only length (if the
                        // previous receive was coalesced). Play it safe and choose
                        // what we know - length
                        p->pReadBuffer = buffer;
                        p->maxReadBuffer = length;
                        }
                    // else
                    // it is possible that by now all shutdowns
                    // are coalesced in memory - in this case
                    // pReadbuffer and maxReadBuffer are already
                    // set and there is nothing for us to do here -
                    // just loop around and get them
                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        RPC_P_SEND_FAILED, 
                        EEInfoDLWSCheckForShutdowns10,
                        i);
                    break;

                case rpc_fault:
                    // Io pending - don't free the buffer.
                    p->fReceivePending = TRUE;
                    if (p->pReadBuffer == 0)
                        {
                        // see comment in buffer resetting logic in rpc_shutdown 
                        // for explanation of this.
                        p->pReadBuffer = buffer;
                        p->maxReadBuffer = length;
                        }

                    if (((CONN_RPC_FAULT *) buffer)->status == NCA_STATUS_PROTO_ERROR)
                        {
                        //
                        // This can happen if the server is NT 4.0 and it received a cancel
                        // after a call completed.
                        //
                        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                                       DPFLTR_WARNING_LEVEL,
                                       RPCTRANS "Received an out of sequence packet: %p %p\n",
                                       p,
                                       phdr));

                        RpcpErrorAddRecord(EEInfoGCWinsock,
                            RPC_P_SEND_FAILED, 
                            EEInfoDLWSCheckForShutdowns20,
                            (ULONG)((CONN_RPC_FAULT *) buffer)->status,
                            (ULONG)i);
                        goto Cleanup;
                        }

                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        RPC_P_RECEIVE_COMPLETE, 
                        EEInfoDLWSCheckForShutdowns30,
                        (ULONG)((CONN_RPC_FAULT *) buffer)->status,
                        (ULONG)i);

                    return RPC_P_RECEIVE_COMPLETE;

                default:
                    // Got something else - this is probably a protocol error.
                    TransDbgPrint((DPFLTR_RPCPROXY_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   RPCTRANS "Received an out of sequence packet: %p %p\n",
                                   p,
                                   phdr));

                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        RPC_P_SEND_FAILED, 
                        EEInfoDLWSCheckForShutdowns40,
                        (ULONG)MessageType(phdr),
                        (ULONG)i);

                    CORRUPTION_ASSERT(0);
                    goto Cleanup;
                }
            }
        else
            {
            if (status == RPC_P_IO_PENDING)
                {
                // Io pending - don't free the buffer.
                p->fReceivePending = TRUE;
                return(RPC_S_OK);
                }

            RpcpErrorAddRecord(EEInfoGCWinsock,
                status, 
                EEInfoDLWSCheckForShutdowns50,
                i);
            return(status);
            }
        }

Cleanup:
    p->WS_CONNECTION::Abort();
    return(RPC_P_SEND_FAILED);
}


RPC_STATUS
RPC_ENTRY
WS_SyncSend(
    IN RPC_TRANSPORT_CONNECTION Connection,
    IN UINT BufferLength,
    IN BUFFER Buffer,
    IN BOOL fDisableShutdownCheck,
    IN BOOL fDisableCancelCheck,
    ULONG Timeout
    )
/*++

Routine Description:

    Sends a message on the connection.  This method must appear
    to be synchronous from the callers perspective.

    Note: This routine must check for OSF DCE shutdown PDUs
    on TCP/IP to avoid interop problems.

Arguments:

    Connection - The connection of send to.
    BufferLength - The size of the buffer.
    Buffer - The data to sent.
    fDisableShutdownCheck - Normally FALSE, when true this disables
        the transport check for async shutdown PDUs.  This is needed
        when sending the third leg.


Return Value:

    RPC_P_SEND_FAILED - Connection will be closed if this is returned.

    RPC_S_OK - Data sent

--*/

{
    DWORD bytes;
    RPC_STATUS status;

    PWS_CCONNECTION p = (PWS_CCONNECTION)Connection;
    ASSERT(!IsNetbiosProtocol(p->id));

    // Note: this can be called on SERVER connections, too.
    // All references to CLIENT-ONLY members must be guarded with
    // (p->type & CLIENT).

    //
    // OSF 1.1(+) server's send, asynchronously to the client sending a
    // request, shutdown PDUs on "idle" connections.  Here we check for
    // shutdown PDUs in order to allow the client to retry the call on
    // another connection if this one has closed.
    //

    if (   ((p->type & TYPE_MASK) == CLIENT)
        && (FALSE == p->fCallStarted)
        && WsTransportTable[p->id].fCheckShutdowns
        && (fDisableShutdownCheck == FALSE)
        && (GetTickCount() - p->dwLastCallTime) > MILLISECONDS_BEFORE_PEEK)
        {
        p->fShutdownReceived = FALSE;

        status = WS_CheckForShutdowns(p);

        if (status != RPC_S_OK)
            {
            VALIDATE(status)
                {
                RPC_P_RECEIVE_FAILED,
                RPC_P_CONNECTION_SHUTDOWN,
                RPC_P_SEND_FAILED,
                RPC_S_OUT_OF_MEMORY,
                RPC_P_RECEIVE_COMPLETE
                } END_VALIDATE;

            if (status == RPC_P_RECEIVE_COMPLETE)
                {
                return status;
                }

            RpcpErrorAddRecord(EEInfoGCWinsock,
                RPC_P_SEND_FAILED, 
                EEInfoDLWSSyncSend10);
            return(RPC_P_SEND_FAILED);
            }

        // There is no need to to this again until SyncRecv is called.
        p->fCallStarted = TRUE;
        }

    HANDLE hEvent = I_RpcTransGetThreadEvent();

    p->StartingWriteIO();

    if (p->fAborted)
        {
        p->WriteIOFinished();
        return(RPC_P_SEND_FAILED);
        }

    // Setting the low bit of the event indicates that the write
    // completion should NOT be sent to the i/o completion port.
    OVERLAPPED olWrite;
    olWrite.Internal = 0;
    olWrite.InternalHigh = 0;
    olWrite.Offset = 0;
    olWrite.OffsetHigh = 0;
    olWrite.hEvent = (HANDLE) ((ULONG_PTR)hEvent | 0x1);

#ifdef _INTERNAL_RPC_BUILD_
    if (gpfnFilter)
        {
        (*gpfnFilter) (Buffer, BufferLength, 0);
        }
#endif

    status = p->Send(p->Conn.Handle,
                            Buffer,
                            BufferLength,
                            &bytes,
                            &olWrite
                            );

    p->WriteIOFinished();

    if (status == RPC_S_OK)
        {
        ASSERT(bytes == BufferLength);
        return(RPC_S_OK);
        }

    if (status == ERROR_IO_PENDING)
        {
        // if fDisableCancelCheck, make the thread wait non-alertably,
        // otherwise, make it wait alertably.
        status = UTIL_GetOverlappedResultEx(Connection,
                                            &olWrite,
                                            &bytes,
                                            !fDisableCancelCheck,
                                            Timeout);

        if (status == RPC_S_OK)
            {
            ASSERT(bytes == BufferLength);

            return(RPC_S_OK);
            }
        }

    ASSERT(status != RPC_S_OK);

    RpcpErrorAddRecord(EEInfoGCWinsock,
        status, 
        EEInfoDLWSSyncSend20);

    p->WS_CONNECTION::Abort();

    if ((status == RPC_S_CALL_CANCELLED) || (status == RPC_P_TIMEOUT))
        {
        // Wait for the write to finish.  Since we closed the
        // connection this won't take very long.
        UTIL_WaitForSyncIO(&olWrite,
                           FALSE,
                           INFINITE);
        }
    else
        {
        RpcpErrorAddRecord(EEInfoGCRuntime,
            RPC_P_SEND_FAILED, 
            EEInfoDLWSSyncSend30);

        status = RPC_P_SEND_FAILED;
        }

    return(status);
}

VOID
WS_P_SetKeepAliveTimeout(
    IN SOCKET Socket,
    IN BOOL OnOff,
    IN UINT KATime,
    IN UINT KAInterval = 5000 OPTIONAL)
/*++

Arguments:

    Socket - The socket to set the keepalive timeout on
    OnOff - TRUE to turn if on. FALSE to turn it off
    KATime - The time between the last keep alive
        response and the next probe.
    KAInterval - The timeout in milliseconds for the
        subsequent keepalive packets.  The time between
        two consequitive keep alive probes if the first one
        did not receive a response.

--*/
{
    int r;
    tcp_keepalive tcpka;
    DWORD t;

    // make sure we indeed get TRUE of FALSE - we don't know how Winsock will
    // take it otherwise
    ASSERT((OnOff == TRUE) || (OnOff == FALSE));

    tcpka.onoff             = OnOff;
    tcpka.keepalivetime     = KATime; // Milliseconds, time to send first KA
    tcpka.keepaliveinterval = KAInterval;    // Milliseconds, this is the TCP/IP default.

    r = WSAIoctl(Socket,
                 SIO_KEEPALIVE_VALS,
                 (PVOID)&tcpka,
                 sizeof(tcpka),
                 (PVOID)&tcpka,
                 sizeof(tcpka),
                 &t,
                 0,
                 0);

    if (r != 0)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "setsockopt KEEPALIVE_VALS failed %d\n",
                       GetLastError()));
        }
}

RPC_STATUS
RPC_ENTRY 
WS_TurnOnOffKeepAlives (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN BOOL TurnOn,
    IN BOOL bProtectIO,
    IN KEEPALIVE_TIMEOUT_UNITS Units,
    IN OUT KEEPALIVE_TIMEOUT KATime,
    IN ULONG KAInterval OPTIONAL
    )
/*++

Routine Description:

    Turns on keep alives for Winsock transports supporting keepalives.

Arguments:

    ThisConnection - The connection to turn keep alives on on.
    TurnOn - if non-zero, keep alives are turned on. If zero, keep alives
        are turned off.
    KATime - how much to wait before sending first keep alive.  The time between the last keep alive
        response and the next probe.
    KAInterval - the time between two consequitive keep alive probes if the first one did not
        receive a response.  5000 milliseconds is the default.

Return Value:

    RPC_S_OK or RPC_S_* / Win32 errors on failure

Note:

    If we use it on the server, we must protect
        the handle by calling StartingOtherIO

--*/
{
    PWS_CCONNECTION p = (PWS_CCONNECTION)ThisConnection;
    const WS_TRANS_INFO *pInfo = &WsTransportTable[p->id];
    RPC_STATUS RpcStatus = RPC_S_OK;

    // convert the timeout from runtime scale to transport scale
    if (Units == tuRuntime)
        {
        ASSERT(KATime.RuntimeUnits != RPC_C_BINDING_INFINITE_TIMEOUT);
        KATime.Milliseconds = ConvertRuntimeTimeoutToWSTimeout(KATime.RuntimeUnits);
        }

    // When the server is turning on keepalives it must protect
    // the operation by calling StartingOtherIO
    if (bProtectIO)
        {
        p->StartingOtherIO();
        }

    //
    // It is possible that this code is executed before TCP_Open and WS_Open
    // have been called or that unrecoverable failure has been hit.
    // In this case p->id will be invalid or fAborted will be set.
    //
    if (p->id == INVALID_PROTOCOL_ID || p->fAborted)
        {
        RpcStatus = RPC_P_CONNECTION_CLOSED;
        goto Cleanup;
        }

    ASSERT(pInfo->fSetKeepAlive);

    WS_P_SetKeepAliveTimeout(
        p->Conn.Socket, 
        TurnOn ? TRUE : FALSE, 
        KATime.Milliseconds,
        KAInterval);

Cleanup:
    if (bProtectIO)
        {
        p->OtherIOFinished();
        }
    return RpcStatus;
}


RPC_STATUS
RPC_ENTRY
WS_SyncRecv(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT BUFFER *pBuffer,
    OUT PUINT pBufferLength,
    IN DWORD dwTimeout
    )
/*++

Routine Description:

    Receive the next PDU to arrive at the connection.

Arguments:

    ThisConnection - The connection to wait on.
    fCancelable - If TRUE, the wait will also include the threads cancel
        event and will timeout after the cancel event is signaled.
    pBuffer - If successful, points to a buffer containing the next PDU.
    BufferSize -  If successful, contains the length of the message.

Return Value:

    RPC_S_OK
    RPC_P_RECEIVE_FAILED - Connection aborted.
    RPC_P_CONNECTION_SHUTDOWN - Graceful disconnect from server, connection aborted.
    RPC_S_CALL_CANCELLED - Timeout after cancel event, connection aborted.

Note:

    Used only on the client. If we use it on the server, we must protect
        the handle with StartingOtherIO.

--*/
{
    RPC_STATUS status;
    DWORD bytes;
    HANDLE hEvent;
    BOOL fReceivePending;
    BOOL fSetKeepAliveVals = FALSE;
    PWS_CCONNECTION p = (PWS_CCONNECTION)ThisConnection;
    DWORD dwActualTimeout;
    BOOL fWaitOnConnectionTimeout;

    ASSERT((p->type & TYPE_MASK) == CLIENT);
    ASSERT(!IsNetbiosProtocol(p->id));

    // There maybe a receive already pending from the shutdown check
    // in WS_SyncSend.  If so, we want to skip the first submit.

    fReceivePending = p->fReceivePending;
    p->fReceivePending = FALSE;
    p->fCallStarted = FALSE;

    // if there's a per operation timeout, use the lesser of the operation
    // and connection timeout
    if (dwTimeout != INFINITE)
        {
        if (dwTimeout <= p->Timeout)
            {
            dwActualTimeout = dwTimeout;
            fWaitOnConnectionTimeout = FALSE;
            }
        else
            {
            dwActualTimeout = p->Timeout;
            fWaitOnConnectionTimeout = TRUE;
            }
        }
    else
        {
        // wait on the connection timeout
        dwActualTimeout = p->Timeout;
        fWaitOnConnectionTimeout = TRUE;
        }

    ASSERT(   (fReceivePending == FALSE)
           || (p->Read.ol.hEvent == (HANDLE) ((ULONG_PTR)I_RpcTransGetThreadEvent() | 0x1)) );

    //
    // Keep looping until we have a complete message.
    //
    // Note that SubmitSyncRecv may complete with a whole message read.
    //
    do
        {

        if (!fReceivePending)
            {
            // Allocate a receive buffer if needed.

            if (p->pReadBuffer == NULL)
                {
                ASSERT(p->iLastRead == 0);

                p->pReadBuffer = TransConnectionAllocatePacket(p,
                                                               p->iPostSize);
                if (p->pReadBuffer == NULL)
                    {
                    p->WS_CONNECTION::Abort();
                    return(RPC_P_RECEIVE_FAILED);
                    }

                p->maxReadBuffer = p->iPostSize;
                }

            InitReadEvent(p);

            status = CO_SubmitSyncRead(p, pBuffer, pBufferLength);

            if (status != RPC_P_IO_PENDING)
                {
                break;
                }
            }
        else
            {
            fReceivePending = FALSE;
            }

        do
            {

            //
            // Wait for the pending receive on the connection to complete
            //
            status = UTIL_GetOverlappedResultEx(ThisConnection,
                                                &p->Read.ol,
                                                &bytes,
                                                TRUE, // Alertable
                                                dwActualTimeout);


            if (   status != RPC_S_OK
                || bytes == 0 )
                {

                // if we timed out ...
                if (status == RPC_P_TIMEOUT)
                    {
                    ASSERT(dwActualTimeout != INFINITE);

                    // if we waited on the per connection timeout ...
                    if (fWaitOnConnectionTimeout)
                        {
                        ASSERT(p->Timeout != INFINITE);
                        if (dwTimeout == INFINITE)
                            {
                            // enable keep alives and wait forever
                            dwActualTimeout = INFINITE;
                            }
                        else
                            {
                            ASSERT(p->Timeout < dwTimeout);

                            // enable keep alives and wait the difference
                            dwActualTimeout = dwTimeout - p->Timeout;
                            fWaitOnConnectionTimeout = FALSE;
                            }
                        // Enable aggressive keepalives on the socket if transport
                        // supports it
                        if (WsTransportTable[p->id].fSetKeepAlive)
                            {
                            WS_P_SetKeepAliveTimeout(p->Conn.Socket, 
                                TRUE,       // OnOff
                                p->Timeout);
                            fSetKeepAliveVals = TRUE;
                            }
                        continue;
                        }
                    // else we have chosen the per operation timeout and
                    // have timed out on that - time to bail out
                    }

                // Normal error path

                RpcpErrorAddRecord(EEInfoGCWinsock,
                    status, 
                    EEInfoDLWSSyncRecv10,
                    (status == RPC_S_OK ? bytes : 0));

                p->WS_CONNECTION::Abort();

                if ((status == RPC_S_CALL_CANCELLED) || (status == RPC_P_TIMEOUT))
                    {
                    UTIL_WaitForSyncIO(&p->Read.ol,
                                       FALSE,
                                       INFINITE);
                    if ((status == RPC_P_TIMEOUT) && fWaitOnConnectionTimeout)
                        {
                        status = RPC_P_RECEIVE_FAILED;
                        RpcpErrorAddRecord(EEInfoGCWinsock,
                            status, 
                            EEInfoDLWSSyncRecv20);
                        }
                    }
                else
                    {
                    status = RPC_P_RECEIVE_FAILED;
                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        status, 
                        EEInfoDLWSSyncRecv30);
                    }

                return(status);
                }
            }
        while (status == RPC_P_TIMEOUT);

        status = p->ProcessRead(bytes, pBuffer, pBufferLength);

        }
    while (status == RPC_P_PARTIAL_RECEIVE);

    p->dwLastCallTime = GetTickCount();

    if (fSetKeepAliveVals)
        {
        // Call complete okay, clear keep alives
        WS_P_SetKeepAliveTimeout(p->Conn.Socket, 
            FALSE,      // OnOff
            0);
        }

    return(status);
}


RPC_STATUS
RPC_ENTRY
WS_SyncRecv_Avrf(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT BUFFER *pBuffer,
    OUT PUINT pBufferLength,
    IN DWORD dwTimeout
    )
/*++

Routine Description:

    Wrapper for WS_SyncRecv implementing corruption injection
    under the RPC verifier.

    SyncRecv member of the transport interface may only be called
    by the cliet, hence we inject the corruption for a client receive.

Arguments:

Return Value:

--*/
{
    RPC_STATUS Status;

    Status = WS_SyncRecv(
        ThisConnection,
        pBuffer,
        pBufferLength,
        dwTimeout);

    if (!Status)
        {
        if (gfRPCVerifierEnabled)
            {
            CorruptionInject(ClientReceive,
                             pBufferLength,
                             (void **)pBuffer);
            }
        }

    return Status;
}


void
RPC_ENTRY
WS_ServerAbortListen(
    IN RPC_TRANSPORT_ADDRESS Address
    )
/*++

Routine Description:

    This routine will be called if an error occurs in setting up the
    address between the time that SetupWithEndpoint or SetupUnknownEndpoint
    successfully completed and before the next call into this loadable
    transport module.  We need to do any cleanup from Setup*.

Arguments:

    pAddress - The address which is being aborted.

Return Value:

    None

--*/
{
    PWS_ADDRESS pList = (PWS_ADDRESS)Address;
    PWS_ADDRESS pLast = 0;
    INT i, retval;

    delete pList->pAddressVector;
    delete pList->Endpoint;

    TransportProtocol::RemoveObjectFromProtocolList(pList);

    while(pList)
        {
        if (pList->ListenSocket)
            {
            closesocket(pList->ListenSocket);
            }

        if (pList->ConnectionSocket)
            {
            closesocket(pList->ConnectionSocket);
            }


        pLast = pList;
        pList = (PWS_ADDRESS) pList->pNextAddress;

        if (pLast != (PWS_ADDRESS)Address)
            {
            TransportProtocol::RemoveObjectFromProtocolList(pLast);
            delete pLast;
            }
        }

    return;
}


VOID
WS_SubmitAccept(
    BASE_ADDRESS *Address
    )
/*++

Routine Description:

    Used to submit an accept on a listen socket. Called once when the
    listen socket is created and again after each client connects.

    The listen socket must already be added to the completion port.

Arguments:

    Address - The address to accept on.
            ->ConnectionSocket - socket to accept on, or zero in
                which case a new socket is allocated and put here.

Return Value:

    None

--*/
{
    PWS_ADDRESS pAddress = (PWS_ADDRESS)Address;
    const WS_TRANS_INFO *pInfo = &WsTransportTable[pAddress->id];
    SOCKET sAccept;
    RPC_STATUS status;

#ifdef MAJOR_TRANS_DEBUG
    DbgPrint("WS_SubmitAccept: Address=0x%x ListenAddr=%x\n", pAddress, (DWORD)pAddress->ListenAddr.inetaddr.sin_addr.S_un.S_addr);
#endif

    if (pAddress->ConnectionSocket != 0)
        {
        closesocket(pAddress->ConnectionSocket);
        pAddress->ConnectionSocket = 0;
        }

    pAddress->ConnectionSocket =
        WSASocketT(pInfo->AddressFamily,
                   pInfo->SocketType,
                   pInfo->Protocol * GetProtocolMultiplier(pAddress),
                   0,
                   0,
                   WSA_FLAG_OVERLAPPED);

#ifdef MAJOR_TRANS_DEBUG
    DbgPrint("WS_SubmitAccept: WSASocketT: pAddress->ConnectionSocket=%x\n", pAddress->ConnectionSocket);
#endif

    if (pAddress->ConnectionSocket == SOCKET_ERROR)
        {
        pAddress->ConnectionSocket = 0;
        COMMON_AddressManager(Address);
        return;
        }

    //
    // make the handle non-inheritable so it goes away when we close it.
    // join the socket to the completion port
    //
    if (FALSE    == SetHandleInformation(   (HANDLE) pAddress->ConnectionSocket, HANDLE_FLAG_INHERIT, 0) ||
        RPC_S_OK != COMMON_PrepareNewHandle((HANDLE) pAddress->ConnectionSocket))
        {
        closesocket(pAddress->ConnectionSocket);
        pAddress->ConnectionSocket = 0;
        COMMON_AddressManager(Address);
        return;
        }

    ASSERT(pAddress->ConnectionSocket != INVALID_SOCKET);

    DWORD bytes = 0;

    BOOL b = pAddress->pAcceptExFunction(pAddress->ListenSocket,
                      pAddress->ConnectionSocket,
                      &pAddress->AcceptBuffer,
                      0,
                      0,
                      sizeof(WS_SOCKADDR) + 16,
                      &bytes,
                      &pAddress->Listen.ol
                      );

#ifdef MAJOR_TRANS_DEBUG
    DbgPrint("WS_SubmitAccept: pAddress->pAcceptExFunction: b=%x GetLastError()=%x\n", b, GetLastError());
#endif

    if (!b && (GetLastError() != ERROR_IO_PENDING))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       "AcceptEx failed %p, %d %d\n",
                       pAddress,
                       pAddress->ConnectionSocket,
                       GetLastError()));

        closesocket(pAddress->ConnectionSocket);
        pAddress->ConnectionSocket = 0;
        COMMON_AddressManager(Address);
        }

    return;
}


void
WS_SetSockOptForConnection (
    IN const WS_TRANS_INFO *pInfo,
    IN SOCKET sock
    )
/*++

Routine Description:

    Sets the socket options for the given socket for a server
    side connection socket.

Arguments:

    pInfo - the transport information for the Winsock transport
    sock - the socket on which to set options

Return Value:

    None. Setting the options is a best effort. Failures are ignored.

--*/
{
    int retval = 0;

    if (pInfo->fSetNoDelay)
        {
        INT NoDelay = TRUE;
        retval = setsockopt(sock,
                            pInfo->Protocol,
                            TCP_NODELAY,
                            (PCHAR)&NoDelay, sizeof(NoDelay)
                            );
        }

    if (   pInfo->fSetKeepAlive
        && retval == 0)
        {
        INT KeepAlive = TRUE;
        retval = setsockopt(sock,
                            pInfo->Protocol,
                            SO_KEEPALIVE,
                            (PCHAR)&KeepAlive, sizeof(KeepAlive)
                            );
        }

    if (retval != 0)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "setsockopt failed %d, %d\n",
                       retval,
                       GetLastError()));
        }

}


RPC_STATUS
WS_NewConnection(
    IN PADDRESS Address,
    OUT PCONNECTION *ppConnection
    )
/*++

Routine Description:

    Called when an AcceptEx completes on an I/O completion thread.

Arguments:

    Address - The address used as context in a previous AcceptEx.
    ppConnection - A place to store the new pConnection.  Used
        when a connection been created and then a failure occurs.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_RESOURCES
    RPC_S_OUT_OF_MEMORY

--*/
{
    RPC_STATUS status;
    BOOL b;
    WS_ADDRESS *pAddress = (WS_ADDRESS *)Address;
    const WS_TRANS_INFO *pInfo = &WsTransportTable[pAddress->id];
    WS_CONNECTION *pConnection;
    UINT fReceiveDirect;
    SOCKET sock = pAddress->ConnectionSocket;
    int retval = 0;
    WS_SOCKADDR *saAddrs;
    WS_SOCKADDR saClient;
    INT adwAddrLen;
    BOOL fSANConnection;
    int LocalAddressLength = 0;
    PSOCKADDR DummyAddr = NULL;

    ASSERT(sock);

    pAddress->ConnectionSocket = 0;

    // First, parse the client address out of the accept
    // since the next accept will reuse the same buffer.

    pAddress->pGetAcceptExSockaddressFunction(&pAddress->AcceptBuffer,
                         0,
                         0,
                         sizeof(WS_SOCKADDR) + 16,
                         &DummyAddr,
                         &LocalAddressLength,
                         (struct sockaddr **)&saAddrs,
                         &adwAddrLen);

    ASSERT(adwAddrLen <= sizeof(WS_SOCKADDR));

    // Save the client address before submitting the next accept.
    saClient = *saAddrs;

    // Submit the next accept.
    WS_SubmitAccept(pAddress);

    // Now, try process the new connection..
    WS_SetSockOptForConnection(pInfo, sock);

    /*
    fSANConnection = IsUserModeSocket(sock, &status);
    if (status != RPC_S_OK)
        {
        closesocket(sock);
        return status;
        }
        */
    fSANConnection = TRUE;

    //
    // Notes:
    //
    // a. For security reasons, we require the RPC HTTP Servers to send back
    //    an identification message.
    //
    // b. This should "really" be done in WS_SubmitAccept(). This is done here
    //    for convenience. This is OK if HttpSendIdentifyRespomse() rarely
    //    fails.
    //
    if ((pAddress->id == HTTP) &&
        (status = HttpSendIdentifyResponse(sock)))
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       "HttpSendIdentifyResponse failed %p, %d - %d\n",
                       pAddress,
                       sock,
                       status
                       ));
        closesocket(sock);
        return(RPC_S_OUT_OF_RESOURCES);
        }

    BASE_ADDRESS *pRealAddress = pAddress->pFirstAddress;

    pConnection = (WS_CONNECTION *)
                  I_RpcTransServerNewConnection(pRealAddress);

    *ppConnection = pConnection;

    if (!pConnection)
        {
        // Abort the connection.

        INT DontLinger = TRUE;
        // REVIEW: check a protocol flag to do this?
        retval = setsockopt(sock, SOL_SOCKET, SO_DONTLINGER,
                            (PCHAR)&DontLinger, sizeof(DontLinger));
        // setsockopt can fail with something like WSAENOBUFS in low
        // memory conditions.  We can't handle this in any special way.
        closesocket(sock);
        return(RPC_S_OUT_OF_MEMORY);
        }

    // Got a good connection, initialize it..

    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // This function cannot fail after this point.  There is no
    // way to notify the runtime that the connection has been closed.
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#ifdef NETBIOS_ON
    if ((pAddress->id == NBF)
        || (pAddress->id == NBT)
        || (pAddress->id == NBI))
        {
        if (fSANConnection)
            pConnection = new (pConnection) NB_SAN_CONNECTION;
        else
            pConnection = new (pConnection) NB_CONNECTION;
        }
    else 
#endif
    if (pAddress->id == HTTP)
        {
        pConnection = new (pConnection) WS_HTTP2_INITIAL_CONNECTION;
        }
    else
        {
        if (fSANConnection)
            pConnection = new (pConnection) WS_SAN_CONNECTION;
        else
            pConnection = new (pConnection) WS_CONNECTION;
        }

    pConnection->type = SERVER | CONNECTION;
    pConnection->id = pAddress->id;
    pConnection->Conn.Socket = sock;
    pConnection->fAborted = 0;
    pConnection->pReadBuffer = 0;
    pConnection->maxReadBuffer = 0;
    pConnection->iLastRead = 0;
    pConnection->iPostSize = gPostSize;
    pConnection->saClientAddress = saClient;
    RpcpMemorySet(&pConnection->Read.ol, 0, sizeof(pConnection->Read.ol));
    pConnection->Read.pAsyncObject = pConnection;
    pConnection->InitIoCounter();
    pConnection->pAddress = pAddress;

    TransportProtocol::AddObjectToProtocolList((BASE_ASYNC_OBJECT *) *ppConnection);

    return(RPC_S_OK);
}


BOOL
IsUserModeSocket(
    IN SOCKET s,
    OUT RPC_STATUS *pStatus)
/*++

Routine Description:

    Given a socket, it tells whether this is a true kernel socket or not. This test is based per VadimE's input
    that:
        "Just call getsockopt (SOL_SOCKET, SO_PROTOCOL_INFOW) and check XP1_IFS_HANDLES in
        dwServiceFlags1 of WSAPROTOCOL_INFOW. If flag is not set, the handle is not "TRUE"
        IFS handle and file system calls on them carry performance penalty.

        Make sure you call after connection is established or information returned may be
        inaccurate."

Arguments:

    s - The socket to be tested
    pStatus - RPC_S_OK if everything is fine. RPC_S_OUT_OF_MEMORY if the test could not be performed. Note
        that in the latter case the return value is undefined and should be disregarded.

Return Value:

    TRUE - the socket is a true kernel socket
    FALSE  - the socket is not a kernel socket

--*/
{
    WSAPROTOCOL_INFO protocolInfo;
    int paramSize = sizeof(protocolInfo);
    int retval;

    // check whether this is a kernel connection. We do this by checking whether this socket is a true
    // IFS_HANDLE. If yes, then this is not a kernel socket. If not, then it is a kernel socket
    retval = getsockopt(s, SOL_SOCKET, SO_PROTOCOL_INFOW, (char *) &protocolInfo, &paramSize);
    if (retval == SOCKET_ERROR)
        {
        *pStatus = RPC_S_OUT_OF_MEMORY;
        return FALSE;
        }

    *pStatus = RPC_S_OK;

    if (protocolInfo.dwServiceFlags1 & XP1_IFS_HANDLES)
        return FALSE;
    else
        return TRUE;
}


RPC_STATUS
WS_ServerListenCommon (
    IN WS_ADDRESS *pAddress,
    IN BOOL fResetAddressListEntries, OPTIONAL
    IN BOOL fAddToProtocolList OPTIONAL
    )
/*++

Routine Description:

    This routine does common server address setup.

Arguments:

    pAddress - A pointer to the loadable transport interface address.
        Will contain the newly allocated listen socket when finished.

    pListenAddr - Initalized socket address to bind to. On output
        it will contain results of the bind.

    PendingQueueSize - Value specified in use protseq, used
        to set the pending queue size for listens.

ReturnValue:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S__CANT_CREATE_ENDPOINT

--*/
{
    SOCKET               sock;
    int                  retval, length;
    RPC_STATUS           status;
    const WS_TRANS_INFO *pInfo = &WsTransportTable[pAddress->id];
    WS_SOCKADDR *pListenAddr = &(pAddress->ListenAddr);
    DWORD EndpointFlags = pAddress->EndpointFlags;
    BOOL fRetVal;
    int i;
    DWORD LastError;

    pAddress->type = ADDRESS;
    pAddress->InAddressList = NotInList;
    pAddress->fAborted = 0;
    pAddress->pNext = 0;
    pAddress->ListenSocket = 0;
    pAddress->ConnectionSocket = 0;

    // We may be called on an address that is enlinked in a list
    // and does not want these entries reset.
    if (fResetAddressListEntries)
        {
        pAddress->pNextAddress = 0;
        pAddress->pFirstAddress = pAddress;
        }

    memset(&pAddress->Listen, 0, sizeof(BASE_OVERLAPPED));
    pAddress->Listen.pAsyncObject = pAddress;
    for (i = FIRST_EXTENSION_FUNCTION_CODE; i < LAST_EXTENSION_FUNCTION_CODE; i ++)
        {
        pAddress->ExtensionFunctionPointers[i] = NULL;
        }

    if (fAddToProtocolList)
        {
        RpcpInitializeListHead(&pAddress->ObjectList);
        }

    // First order of business: get a valid socket
    //
    sock = WSASocketT(pInfo->AddressFamily,
                      pInfo->SocketType,
                      pInfo->Protocol,
                      0,
                      0,
                      WSA_FLAG_OVERLAPPED);

    if (sock == INVALID_SOCKET)
        {
        LastError = GetLastError();

        RpcpErrorAddRecord(EEInfoGCWinsock,
            LastError, 
            EEInfoDLWSServerListenCommon10,
            pInfo->AddressFamily,
            pInfo->SocketType,
            pInfo->Protocol);

        switch(LastError)
            {
            case WSAENETDOWN:
            case WSAEINVAL:
            case WSAEPROTOTYPE:
            case WSAENOPROTOOPT:
            case WSAEPROTONOSUPPORT:
            case WSAESOCKTNOSUPPORT:
            case WSAEPFNOSUPPORT:
            case WSAEADDRNOTAVAIL:
                status = RPC_S_PROTSEQ_NOT_SUPPORTED;
                break;

            case WSAEAFNOSUPPORT:
                status = RPC_P_ADDRESS_FAMILY_INVALID;
                break;

            case WSAENOBUFS:
            case WSAEMFILE:
            case WSA_NOT_ENOUGH_MEMORY:
                status = RPC_S_OUT_OF_MEMORY;
                break;

            default:
                ASSERT(0);

                // !break

            case WSAEPROVIDERFAILEDINIT:
                status = RPC_S_OUT_OF_RESOURCES;
                break;
            }

        RpcpErrorAddRecord(EEInfoGCRuntime,
            status, 
            EEInfoDLWSServerListenCommon30);

        return(status);
        }

    //
    // Make the handle non-inheritable so it goes away when we close it.
    //
    if (FALSE == SetHandleInformation( (HANDLE) sock, HANDLE_FLAG_INHERIT, 0))
        {
        closesocket(sock);
        return RPC_S_OUT_OF_RESOURCES;
        }

    fRetVal = pAddress->GetExtensionFunctionPointers(sock);

    if (!fRetVal)
        {
        switch (GetLastError())
            {
            case WSAEFAULT:
            case WSAEINVAL:
                status = RPC_S_INTERNAL_ERROR;
                break;

            case WSAEOPNOTSUPP:
                status = RPC_S_PROTSEQ_NOT_SUPPORTED;
                break;

            default:
                status = RPC_S_OUT_OF_RESOURCES;
            }
        closesocket(sock);
        return(status);
        }

    //
    // Try to bind to the given port number...
    //

    pListenAddr->generic.sa_family = pInfo->AddressFamily;

    // N.B. - we should think how the port allocation will look for TCP/IPv6
    status = WS_Bind(sock, pListenAddr, (pAddress->id == TCP) || (pAddress->id == HTTP), EndpointFlags);

    if (status != RPC_S_OK)
        {
        closesocket(sock);
        return(status);
        }

    if(listen(sock, pAddress->QueueSize) == SOCKET_ERROR)
        {
        RpcpErrorAddRecord(EEInfoGCWinsock,
            RPC_S_OUT_OF_RESOURCES,
            EEInfoDLWSServerListenCommon20,
            GetLastError(),
            (ULONGLONG)sock,
            (ULONG)pAddress->QueueSize);
        closesocket(sock);
        return(RPC_S_OUT_OF_RESOURCES);
        }

    status = COMMON_PrepareNewHandle((HANDLE)sock);
    if (status != RPC_S_OK)
        {
        closesocket(sock);
        return(status);
        }

    pAddress->ListenSocket = sock;

    if (fAddToProtocolList)
        {
        TransportProtocol::AddObjectToProtocolList((BASE_ASYNC_OBJECT *) pAddress);
        }

    TransportProtocol::FunctionalProtocolDetected(pAddress->id);

    return(RPC_S_OK);
}

NETWORK_ADDRESS_VECTOR *
WS_GetNetworkAddressVector (
    IN RPC_TRANSPORT_ADDRESS ThisAddress
    )
{
    PWS_ADDRESS pAddress = (PWS_ADDRESS)ThisAddress;
    ASSERT(pAddress->pAddressVector);
#ifdef MAJOR_TRANS_DEBUG
    DbgPrint("WS_GetNetworkAddressVector: pAddress=0x%x pAddressVector=0x%x\n", pAddress, pAddress->pAddressVector);
#endif
    return pAddress->pAddressVector;
}


RPC_STATUS
WS_Initialize_Internal (
    IN PWS_CCONNECTION pConnection
    )
{
    pConnection->Initialize();

    pConnection->fCallStarted      = FALSE;
    pConnection->fShutdownReceived = FALSE;
    pConnection->fReceivePending   = FALSE;
    pConnection->dwLastCallTime    = GetTickCount();
    pConnection->pAddress = NULL;
    RpcpInitializeListHead(&pConnection->ObjectList);

    return RPC_S_OK;
}


RPC_STATUS
WS_Initialize (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN RPC_CHAR *NetworkAddress,
    IN RPC_CHAR *NetworkOptions,
    IN BOOL fAsync
    )
{
    PWS_CCONNECTION p = (PWS_CCONNECTION) ThisConnection;

    p->id = INVALID_PROTOCOL_ID;
    return WS_Initialize_Internal(p);
}

const UUID ConnectExExtensionFunctionUuid = WSAID_CONNECTEX;


RPC_STATUS
WS_Open(
    IN PWS_CCONNECTION p,
    IN WS_SOCKADDR *psa,
    IN UINT ConnTimeout,
    IN UINT SendBufferSize,
    IN UINT RecvBufferSize,
    IN ULONG CallTimeout,
    IN BOOL fHTTP2Open
    )
/*++

Routine Description:

    Common part of opening a winsock connection to a server.

Arguments:

    p - The partially initialized client connection object. If fHTTP2,
        this is a connection object, not client connection object.
    psa - sockaddr with protocol specific part already containing
        this address and port of the server.
    ConnTimeout - Valid for TCP/IP, see SyncRecv error handling.
    {Send,Recv}BufferSize - Used to set the transport buffer
        sizes on some protocols. Currently ignored.
    CallTimeout - call timeout in milliseconds
    fHTTP2Open - the open is an HTTP2 open

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_RESOURCES
    RPC_S_OUT_OF_MEMORY

    RPC_S_SERVER_UNAVAILABLE - failed
    ERROR_RETRY - failed, but another address might work.

--*/
{
    // Initialize common part of the connection object

    const WS_TRANS_INFO *pInfo = &WsTransportTable[p->id];
    SOCKET sock;
    RPC_STATUS           status;
    BOOL fSANConnection;
    DWORD LastError;
    RPC_CLIENT_PROCESS_IDENTIFIER ServerAddress;
    HANDLE hEvent;
    OVERLAPPED ol;
    DWORD dwBytesReturned;
    LPFN_CONNECTEX ConnectEx;
    union
        {
        SOCKADDR_IN sockaddr;
        SOCKADDR_IN6 sockaddr6;
        };
    int NameLen;

    DWORD Transfer;
    DWORD Flags;

    // Set if we had already called GetLastErrorand added EEInfo.
    // Adding EEInfo may overwrite the LastError and getting it second
    // time will return 0 and cause an assert.
    BOOL fGetLastErrorCalled = FALSE;

    if (!fHTTP2Open)
        {
        WS_Initialize_Internal(p);
        }

    //
    // Open a socket
    //

    sock = WSASocketT(pInfo->AddressFamily,
                      pInfo->SocketType,
                      pInfo->Protocol,
                      0,
                      0,
                      WSA_FLAG_OVERLAPPED);

    if (sock == INVALID_SOCKET)
        {
        LastError = GetLastError();

        RpcpErrorAddRecord(EEInfoGCWinsock,
            LastError, 
            EEInfoDLWSOpen10,
            pInfo->AddressFamily,
            pInfo->SocketType,
            pInfo->Protocol);

        switch(LastError)
            {
            case WSAEAFNOSUPPORT:
            case WSAEPROTONOSUPPORT:
            case WSAEPROTOTYPE:
            case WSAENETDOWN:
            case WSAESOCKTNOSUPPORT:
            case WSAEINVAL:     // when registry is not yet setup.
                status = RPC_S_PROTSEQ_NOT_SUPPORTED;
                break;

            case ERROR_NOT_ENOUGH_QUOTA:
            case WSAENOBUFS:
            case WSAEMFILE:
            case WSA_NOT_ENOUGH_MEMORY:
            // This failure is possible in low memory conditions
            // or due to fault injection during registry read or
            // notification creation.
            case WSASYSCALLFAILURE:
                status = RPC_S_OUT_OF_MEMORY;
                break;

            case ERROR_ACCESS_DENIED:
                status = RPC_S_ACCESS_DENIED;
                break;

            default:
                ASSERT(0);
                // no break - fall through

            case WSAEPROVIDERFAILEDINIT:
                status = RPC_S_OUT_OF_RESOURCES;
                break;
            }

        RpcpErrorAddRecord(EEInfoGCRuntime,
            status, 
            EEInfoDLWSOpen30);

        return (status);
        }

    //
    // make the handle non-inheritable so it goes away when we close it.
    //
    if (FALSE == SetHandleInformation( (HANDLE) sock, HANDLE_FLAG_INHERIT, 0))
        {
        closesocket(sock);
        return RPC_S_OUT_OF_RESOURCES;
        }

    p->Conn.Socket = sock;

    //
    // Set socket options
    //
    // REVIEW: Set loopback socket option? Ask winsock folks.

    DWORD option;
    int retval = 0;

    if (pInfo->fSetNoDelay)
        {
        option = TRUE;
        retval = setsockopt( sock, pInfo->Protocol, TCP_NODELAY,
                             (PCHAR)&option, sizeof(option) );
        }

    if (pInfo->fSetKeepAlive && retval == 0)
        {
        option = TRUE;
        retval = setsockopt( sock, pInfo->Protocol, SO_KEEPALIVE,
                             (PCHAR)&option, sizeof(option) );
        }

    if (   pInfo->fSetSendBuffer
        && SendBufferSize
        && retval == 0)
        {
        ASSERT(SendBufferSize <= 0xFFFF);
        retval = setsockopt( sock, SOL_SOCKET, SO_SNDBUF,
                             (PCHAR)&SendBufferSize, sizeof(UINT) );
        }

    if (   pInfo->fSetRecvBuffer
        && RecvBufferSize
        && retval == 0 )
        {
        ASSERT(RecvBufferSize <= 0xFFFF);
        retval = setsockopt( sock, SOL_SOCKET, SO_RCVBUF,
                             (PCHAR)&RecvBufferSize, sizeof(UINT) );
        }


    if (retval)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "setsockopt failed %d\n",
                       GetLastError()));

        p->WS_CONNECTION::Abort();

        return(RPC_S_OUT_OF_RESOURCES);
        }

    if (!fHTTP2Open)
        {
        //
        // Set timeout
        //

        if (   WsTransportTable[p->id].fSetKeepAlive
            && ConnTimeout != RPC_C_BINDING_INFINITE_TIMEOUT)
            {
            ASSERT(   ((long)ConnTimeout >= RPC_C_BINDING_MIN_TIMEOUT)
                   && (ConnTimeout <= RPC_C_BINDING_MAX_TIMEOUT));

            // convert the timeout from runtime scale to transport scale
            p->Timeout = ConvertRuntimeTimeoutToWSTimeout(ConnTimeout);
            }
        else
            {
            p->Timeout = INFINITE;
            }
        }

    //
    // HTTP specific connect() done in HTTP_Open().
    //
    if (p->id == HTTP)
        {
        //
        // For HTTP, add the new socket to the io completion port
        // now. For TCP, we'll add it later.
        //
        status = COMMON_PrepareNewHandle((HANDLE)sock);
        if (status != RPC_S_OK)
            {
            closesocket(sock);
            return status;
            }

        return (RPC_S_OK);
        }


    //
    // Connect the socket to the server
    //

    psa->generic.sa_family = pInfo->AddressFamily;

    if ((CallTimeout == INFINITE) || (CallTimeout == 0) 
#ifdef SPX_ON
        || (p->id == SPX)
#endif
        )
        {
        retval = connect(sock, &psa->generic, pInfo->SockAddrSize);
        }
    else
        {
        // we have a specified call timeout. Use ConnectEx instead

        // first, bind the socket. Unlike connect, ConnectEx doesn't
        // accept unbound sockets
        if (p->id != TCP_IPv6)
            {
            sockaddr.sin_addr.S_un.S_addr = INADDR_ANY;
            sockaddr.sin_family = AF_INET;
            sockaddr.sin_port = 0;
            NameLen = sizeof(sockaddr);
            }
        else
            {
            IN6ADDR_SETANY(&sockaddr6);
            sockaddr6.sin6_scope_id = 0;
            NameLen = sizeof(sockaddr6);
            }

        retval = bind(sock,
            (SOCKADDR *)&sockaddr,
            NameLen);

        if (retval == SOCKET_ERROR)
            {
            status = GetLastError();
            RpcpErrorAddRecord(EEInfoGCWinsock,
                status,
                EEInfoDLWSOpen60);

            fGetLastErrorCalled = TRUE;

            goto Handle_WS_OpenError;
            }

        // second retrieve address of ConnectEx
        retval = WSAIoctl(sock, 
            SIO_GET_EXTENSION_FUNCTION_POINTER, 
            (void *) &ConnectExExtensionFunctionUuid,
            sizeof(UUID), 
            (void *) &ConnectEx,
            sizeof(void *), 
            &dwBytesReturned,
            NULL,   // lpOverlapped
            NULL    // lpCompletionRoutine
            );

        if (retval == SOCKET_ERROR)
            {
            // ConnectEx is not available.  We need to default to using connect.
            retval = connect(sock, &psa->generic, pInfo->SockAddrSize);
            }
        else
            {
            // Use ConnectEx.

            ASSERT(dwBytesReturned == sizeof(void *));

            hEvent = I_RpcTransGetThreadEvent();
            ASSERT(hEvent);

            ol.Internal = 0;
            ol.InternalHigh = 0;
            ol.Offset = 0;
            ol.OffsetHigh = 0;
            // There may be a window between winsock's raising the event to signal IO completion
            // and checking if there is a completion port associated with the socket.  We
            // need to make sure that the IO completion packet will not be posted to a port if
            // we associate it with the socket after the event is raised but before the packet is posted.
            ol.hEvent = (HANDLE) ((ULONG_PTR)hEvent | 0x1);

            retval = ConnectEx(sock, 
                &psa->generic, 
                pInfo->SockAddrSize,
                NULL,   // lpSendBuffer
                0,      // dwSendDataLength
                NULL,   // lpdwBytesSent
                &ol);

            // N.B. ConnectEx returns the opposite of connect - TRUE for
            // success and FALSE for failure. Since the error handling is
            // common, we must make the return value consistent. We do this
            // by reverting the return value for ConnectEx
            retval = !retval;

            if (retval != 0)
                {
                LastError = GetLastError();
                if ((LastError != ERROR_IO_PENDING) && (LastError != WSA_IO_PENDING))
                    {
                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        LastError, 
                        EEInfoDLWSOpen80);

                    status = LastError;
                    fGetLastErrorCalled = TRUE;

                    goto Handle_WS_OpenError;                    
                    }

                // wait for the result or for timeout
                LastError = WaitForSingleObject(hEvent, CallTimeout);
                if (LastError == WAIT_TIMEOUT)
                    {
                    // we have hit a timeout. Kill the socket and bail out
                    status = RPC_S_CALL_CANCELLED;
                    RpcpErrorAddRecord(EEInfoGCRuntime,
                        status, 
                        EEInfoDLWSOpen50,
                        CallTimeout);

                    p->WS_CONNECTION::Abort();

                    // wait for our IO to complete. Should be quick after
                    // we closed the socket
                    LastError = WaitForSingleObject(hEvent, INFINITE);
                    ASSERT(LastError == WAIT_OBJECT_0);
                    ASSERT(HasOverlappedIoCompleted(&ol));

                    return status;
                    }
                else
                    {
                    ASSERT(LastError == WAIT_OBJECT_0);
                    ASSERT(HasOverlappedIoCompleted(&ol));

                    // Retrieve the overlapped result.  No need to wait since the IO has
                    // already completed.
                    if (!WSAGetOverlappedResult(sock, &ol, &Transfer, FALSE, &Flags))
                        {
                        // set retval to the WSA error code.
                        retval = WSAGetLastError();

                        RpcpErrorAddRecord(EEInfoGCWinsock,
                            retval, 
                            EEInfoDLWSOpen90);

                        status = retval;
                        fGetLastErrorCalled = TRUE;
                        }
                    else
                        {
                        retval = setsockopt(sock,
                            SOL_SOCKET,
                            SO_UPDATE_CONNECT_CONTEXT,
                            NULL,
                            0
                            );
                        }
                    }
                }
            else
                {
                retval = setsockopt(sock,
                    SOL_SOCKET,
                    SO_UPDATE_CONNECT_CONTEXT,
                    NULL,
                    0
                    );
                }
            }
        }

    if (retval == 0)
        {
        //
        // After we're done with connect/ConnectEx, add the socket
        // to the completion port.
        //
        status = COMMON_PrepareNewHandle((HANDLE)sock);
        if (status != RPC_S_OK)
            {
            goto Handle_WS_OpenError;
            }

        fSANConnection = IsUserModeSocket(sock, &status);
        if (status == RPC_S_OK)
            {
            if (fSANConnection && !fHTTP2Open)
                {
                // reinitialize vtbl
                p = new (p) WS_SAN_CLIENT_CONNECTION;
                }
            TransportProtocol::AddObjectToProtocolList((BASE_ASYNC_OBJECT *) p);
            return(RPC_S_OK);
            }
        }

Handle_WS_OpenError:

    if (!fGetLastErrorCalled)
        {
        status = GetLastError();
        }

    ServerAddress.ZeroOut();
    if (p->id == TCP)
        {
        ServerAddress.SetIPv4ClientIdentifier(psa->inetaddr.sin_addr.S_un.S_addr, FALSE);
        }
    else if (p->id == TCP_IPv6)
        {
        ServerAddress.SetIPv6ClientIdentifier(&psa->ipaddr, sizeof(psa->ipaddr), FALSE);
        }

    RpcpErrorAddRecord(EEInfoGCWinsock,
        status, 
        EEInfoDLWSOpen20,
        (ULONG)ntohs(RpcpGetIpPort(psa)),
        ServerAddress.GetDebugULongLong1(),
        ServerAddress.GetDebugULongLong2());

    switch(status)
        {
        case WSAENETUNREACH:
        case STATUS_BAD_NETWORK_PATH:
        case STATUS_NETWORK_UNREACHABLE:
        case STATUS_PROTOCOL_UNREACHABLE:
        case WSAEHOSTUNREACH:
        case STATUS_HOST_UNREACHABLE:
        case WSAETIMEDOUT:
        case STATUS_LINK_TIMEOUT:
        case STATUS_IO_TIMEOUT:
        case STATUS_TIMEOUT:
        case WSAEADDRNOTAVAIL:
        case STATUS_INVALID_ADDRESS:
        case STATUS_INVALID_ADDRESS_COMPONENT:
            status = ERROR_RETRY;
            break;

        case WSAENOBUFS:
        case STATUS_INSUFFICIENT_RESOURCES:
        case STATUS_PAGEFILE_QUOTA:
        case STATUS_COMMITMENT_LIMIT:
        case STATUS_WORKING_SET_QUOTA:
        case STATUS_NO_MEMORY:
        case STATUS_QUOTA_EXCEEDED:
        case STATUS_TOO_MANY_PAGING_FILES:
        case STATUS_REMOTE_RESOURCES:
        case ERROR_NOT_ENOUGH_MEMORY:
            status = RPC_S_OUT_OF_MEMORY;
            break;

        case WSAECONNREFUSED:
        case STATUS_REMOTE_NOT_LISTENING:
        case STATUS_CONNECTION_REFUSED:
            // for conn refused, we have different logic for IPv4 and IPv6
            // since IPv6 is installed optionally at the time of this writing
            // and is not PnP compliant in the way we need, it will not be
            // picked up by the server by default. Yet the DNS entries will
            // be updated. So if we have an IPv6 address, the server may
            // not have picke dup IPv6 and we need to retry for IPv6 only.
            if (p->id == TCP_IPv6)
                {
                status = ERROR_RETRY;
                }
            else
                {
                status = RPC_S_SERVER_UNAVAILABLE;
                }
            break;

        default:
            VALIDATE(status)
                {
                WSAENETDOWN,
                STATUS_INVALID_NETWORK_RESPONSE,
                STATUS_NETWORK_BUSY,
                STATUS_NO_SUCH_DEVICE,
                STATUS_NO_SUCH_FILE,
                STATUS_OBJECT_PATH_NOT_FOUND,
                STATUS_OBJECT_NAME_NOT_FOUND,
                STATUS_UNEXPECTED_NETWORK_ERROR,
                WSAECONNABORTED,
                STATUS_LOCAL_DISCONNECT,
                STATUS_TRANSACTION_ABORTED,
                STATUS_CONNECTION_ABORTED,
                WSAEADDRINUSE,
                ERROR_CONNECTION_REFUSED,
                WSAECONNRESET
                } END_VALIDATE;

            status = RPC_S_SERVER_UNAVAILABLE;
            break;
        }

    RpcpErrorAddRecord(EEInfoGCWinsock,
        status, 
        EEInfoDLWSOpen40);

    p->WS_CONNECTION::Abort();

    return(status);
}


/////////////////////////////////////////////////////////////////////
//
// TCP/IP specific stuff
//

RPC_STATUS
IP_ADDRESS_RESOLVER::NextAddress(
    OUT SOCKADDR_STORAGE *pAddress
    )
/*++

Routine Description:

    Returns the next IP address associated with the Name
    parameter to the constructor.

    During the first call if check for loopback and for dotted numeric IP
    address formats.  If these fail then it begins a complex lookup
    (WSALookupServiceBegin) and returns the first available address.

    During successive calls in which a complex lookup was started
    it returns sucessive addressed returned by WSALookupServiceNext().

Arguments:

    pAddress - If successful, the pAddress->sin_addr.s_addr member is set
        to an IP address to try. For all cosClients, if IPvToUse is ipvtuIPAny,
        pAddress->sin_family is set to the actual address family for the
        returned address. This allows client to find out what address was
        returned to them.

Return Value:

    RPC_S_OK - pAddress contains a new IP address

    RPC_S_SERVER_UNAVAILABLE - Unable to find any more addresses
    RPC_S_OUT_OF_MEMORY

--*/
{
    int err;
    RPC_STATUS status;
    SOCKADDR_IN6 *IPv6Address = (SOCKADDR_IN6 *)pAddress;
    SOCKADDR_STORAGE addr;
    int ai_flags;
    int i;
    USES_CONVERSION;
    CStackAnsi AnsiName;
    BOOL fValidIPv4;
    BOOL fValidIPv6;
    ADDRINFO *ThisAddrInfo;

    if (!AddrInfo)
        {
        if (!Name)
            {
            if (cos == cosServer)
                {
                if (IPvToUse == ipvtuIPv6)
                    {
                    IPv6Address->sin6_flowinfo = 0;
                    *((u_long *)(IPv6Address->sin6_addr.s6_addr)    ) = 0;
                    *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 1) = 0;
                    *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 2) = 0;
                    *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 3) = 0;
                    IPv6Address->sin6_scope_id = 0;
                    }
                else
                    {
                    ASSERT(IPvToUse == ipvtuIPv4);
                    ((SOCKADDR_IN *)pAddress)->sin_addr.s_addr = INADDR_ANY;
                    }
                }
            else
                {
                if (LoopbacksReturned > 2)
                    {
                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        RPC_S_SERVER_UNAVAILABLE, 
                        EEInfoDLNextAddress40);
                    return RPC_S_SERVER_UNAVAILABLE;
                    }

                if ((IPvToUse == ipvtuIPv6)
                    || ((IPvToUse == ipvtuIPAny) 
                         && 
                         (LoopbacksReturned == 1)
                       )
                   )
                    {
                    IPv6Address->sin6_family = AF_INET6;
                    IPv6Address->sin6_flowinfo = 0;
                    *((u_long *)(IPv6Address->sin6_addr.s6_addr)    ) = 0;
                    *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 1) = 0;
                    *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 2) = 0;
                    *((u_long *)(IPv6Address->sin6_addr.s6_addr) + 3) = 1;
                    IPv6Address->sin6_scope_id = 0;
                    }
                else if ((IPvToUse == ipvtuIPv4)
                         || ((IPvToUse == ipvtuIPAny) 
                             && 
                             (LoopbacksReturned == 0)
                           )
                        )
                    {
                    // Loopback - assign result of htonl(INADDR_LOOPBACK)
                    // Little-endian dependence.
                    ((SOCKADDR_IN *)pAddress)->sin_addr.s_addr = 0x0100007F;
                    ((SOCKADDR_IN *)pAddress)->sin_family = AF_INET;
                    }
                else
                    {
                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        RPC_S_SERVER_UNAVAILABLE, 
                        EEInfoDLNextAddress40);
                    return RPC_S_SERVER_UNAVAILABLE;
                    }

                LoopbacksReturned ++;
                }

            return RPC_S_OK;
            }

        if (cos == cosServer)
            ai_flags = AI_PASSIVE;
        else
            ai_flags = 0;

        switch (IPvToUse)
            {
            case ipvtuIPAny:
                // make a hint for any protocol
                Hint.ai_flags = ai_flags | AI_NUMERICHOST;
                Hint.ai_family = PF_UNSPEC;
                break;

            case ipvtuIPv4:
                // make a hint for any v4 protocol
                Hint.ai_flags = ai_flags | AI_NUMERICHOST;
                Hint.ai_family = AF_INET;
                break;

            case ipvtuIPv6:
                // make a hint for TCPv6
                Hint.ai_flags = ai_flags | AI_NUMERICHOST;
                Hint.ai_family = AF_INET6;
                break;

            default:
                ASSERT((IPvToUse == ipvtuIPAny)
                    || (IPvToUse == ipvtuIPv4)
                    || (IPvToUse == ipvtuIPv6));
            }

        ATTEMPT_STACK_W2A(AnsiName, Name);

        err = getaddrinfo(AnsiName, 
            NULL, 
            &Hint,
            &AddrInfo);

        if (err)
            {
            ASSERT((err != EAI_BADFLAGS)
                && (err != EAI_SOCKTYPE));

            // take down the numeric hosts flag - we'll try
            // to resolve it as a DNS name
            Hint.ai_flags &= ~AI_NUMERICHOST;

            err = getaddrinfo(AnsiName,
                NULL,
                &Hint,
                &AddrInfo);

            if (err)
                {
                RpcpErrorAddRecord(EEInfoGCWinsock,
                    err, 
                    EEInfoDLNextAddress10,
                    Name);
                if (err == EAI_MEMORY)
                    {
                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        RPC_S_OUT_OF_MEMORY, 
                        EEInfoDLNextAddress20);
                    return RPC_S_OUT_OF_MEMORY;
                    }
                else
                    {
                    VALIDATE(err)
                        {
                        EAI_AGAIN,
                        EAI_FAMILY,
                        EAI_FAIL,
                        EAI_NODATA,
                        EAI_NONAME,
                        EAI_SERVICE
                        } END_VALIDATE;
                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        RPC_S_SERVER_UNAVAILABLE, 
                        EEInfoDLNextAddress30);
                    return RPC_S_SERVER_UNAVAILABLE;
                    }
                }

            }

        // successfully resolved this address
        // just stick it in and we'll let the code below handle it
        CurrentAddrInfo = AddrInfo;
        }

    ASSERT(AddrInfo != NULL);

    // get the next value from the cache
    while (CurrentAddrInfo)
        {
        ThisAddrInfo = CurrentAddrInfo;
        CurrentAddrInfo = CurrentAddrInfo->ai_next;

        fValidIPv4 = FALSE;
        fValidIPv6 = FALSE;

        if (ThisAddrInfo->ai_family == AF_INET)
            {
            fValidIPv4 = TRUE;
            }

        if (ThisAddrInfo->ai_family == AF_INET6)
            {
            fValidIPv6 = TRUE;
            }

        if ((IPvToUse == ipvtuIPv4) && !fValidIPv4)
            continue;

        if ((IPvToUse == ipvtuIPv6) && !fValidIPv6)
            continue;

        if ((IPvToUse == ipvtuIPAny) && !fValidIPv4 && !fValidIPv6)
            continue;

        if (ThisAddrInfo->ai_family == AF_INET)
            {
            ASSERT((IPvToUse == ipvtuIPv4)
                || (IPvToUse == ipvtuIPAny));
            RpcpCopyIPv4Address((SOCKADDR_IN *)ThisAddrInfo->ai_addr, (SOCKADDR_IN *)pAddress);
            ((SOCKADDR_IN *)pAddress)->sin_family = AF_INET;
            }
        else
            {
            ASSERT((IPvToUse == ipvtuIPv6)
                || (IPvToUse == ipvtuIPAny));
            RpcpCopyIPv6Address((SOCKADDR_IN6 *)ThisAddrInfo->ai_addr, IPv6Address);
            IPv6Address->sin6_family = AF_INET6;
            IPv6Address->sin6_scope_id = ((SOCKADDR_IN6 *)ThisAddrInfo->ai_addr)->sin6_scope_id;
            IPv6Address->sin6_flowinfo = 0;
            }

        return RPC_S_OK;
        }

    RpcpErrorAddRecord(EEInfoGCWinsock,
        RPC_S_SERVER_UNAVAILABLE, 
        EEInfoDLNextAddress40);

    return RPC_S_SERVER_UNAVAILABLE;
}

IP_ADDRESS_RESOLVER::~IP_ADDRESS_RESOLVER()
{
    if (AddrInfo)
        freeaddrinfo(AddrInfo);
}

RPC_STATUS
IP_BuildAddressVector(
    OUT NETWORK_ADDRESS_VECTOR **ppAddressVector,
    IN ULONG NICFlags,
    IN RPC_CHAR *NetworkAddress OPTIONAL,
    IN WS_ADDRESS *Address OPTIONAL
    )
/*++

Routine Description:

    Builds a vector of IP addresses supported by this machine.

Arguments:

    ppAddressVector - A place to store the vector.  If a non-NULL
        pointer is passed in, the memory will be freed before returning
        a new vector.  Queries should always specify *ppAddressVector == NULL.
    NICFlags - the flags as specified in the RPC_POLICY of the
        RpcServerUse*Protseq* APIs
    NetworkAddess - the network address we were asked to listen
        on. May be NULL.
    Address - in the case of firewall, the addresses we chose to
        listen on.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES

--*/
{
    //
    // Figure out all of our IP addresses
    //
    NETWORK_ADDRESS_VECTOR *pVector;
    unsigned i, iActive;
    RPC_CHAR *NextAddress;
    int NumberOfAddresses;
    WS_ADDRESS *CurrentAddress;

    // If we were called with an old address vector, delete it.
    if (*ppAddressVector)
        {
        delete (*ppAddressVector);
        }

    if ((pFirewallTable == 0 || NICFlags == RPC_C_BIND_TO_ALL_NICS) && !NetworkAddress)
        {
        ULONG Ignored;

        // Get Dns hostname
        pVector = (NETWORK_ADDRESS_VECTOR *)AllocateAndGetComputerName(cnaNew,
            ComputerNameDnsHostname,
            FIELD_OFFSET(NETWORK_ADDRESS_VECTOR, NetworkAddresses[1]),
            FIELD_OFFSET(NETWORK_ADDRESS_VECTOR, NetworkAddresses[1]),
            &Ignored);
        if (pVector == NULL)
            {
            RpcpErrorAddRecord(EEInfoGCWinsock,
                RPC_S_OUT_OF_MEMORY, 
                EEInfoDLIPBuildAddressVector10,
                GetLastError());
            return RPC_S_OUT_OF_MEMORY;
            }

        pVector->Count = 1;
        pVector->NetworkAddresses[0] = (RPC_CHAR*)&pVector->NetworkAddresses[1];
        }
    else if (NetworkAddress)
        {
        // the length of the network address including the terminating NULL
        // (in characters)
        int NetworkAddressLength;
#if DBG
            {
            // if we have a network address, it must be in IP address notation
            // make an ASSERT to verify that nobody ever passes an dns name here
            ADDRINFO Hint;
            ADDRINFO *AddrInfo;
            USES_CONVERSION;
            CStackAnsi AnsiName;
            int err;

            RpcpMemorySet(&Hint, 0, sizeof(Hint));
            Hint.ai_flags = AI_NUMERICHOST;
            ATTEMPT_STACK_W2A(AnsiName, NetworkAddress);

            err = getaddrinfo(AnsiName,
                NULL,
                &Hint,
                &AddrInfo);

            // this is a numeric address. It should never fail
            ASSERT (!err);
            }
#endif

        NetworkAddressLength = RpcpStringLength(NetworkAddress) + 1;

        pVector = (NETWORK_ADDRESS_VECTOR *)
              I_RpcAllocate(  sizeof(NETWORK_ADDRESS_VECTOR)
                            + sizeof(RPC_CHAR *)
                            + (sizeof(RPC_CHAR) * NetworkAddressLength));
        if (pVector == NULL)
            {
            return (RPC_S_OUT_OF_MEMORY);
            }

        pVector->Count = 1;

        NextAddress = (RPC_CHAR *)&pVector->NetworkAddresses[1];

        pVector->NetworkAddresses[0] = NextAddress;

        RpcpMemoryCopy(NextAddress, NetworkAddress, NetworkAddressLength * 2);
        }
    else
        {
        NumberOfAddresses = 0;
        CurrentAddress = Address;
        while (CurrentAddress != NULL)
            {
            NumberOfAddresses ++;
            CurrentAddress = (WS_ADDRESS *)CurrentAddress->pNextAddress;
            }

        pVector = (NETWORK_ADDRESS_VECTOR *)
              I_RpcAllocate(  sizeof(NETWORK_ADDRESS_VECTOR)
                            + (sizeof(RPC_CHAR *)
                            + max(IPv6_MAXIMUM_RAW_NAME, IP_MAXIMUM_RAW_NAME) * sizeof(RPC_CHAR))
                              * ((WS_ADDRESS *)Address->pFirstAddress)->NumActiveAddresses);
        if (pVector == NULL)
            {
            return (RPC_S_OUT_OF_MEMORY);
            }

        // Only populate the vector with addresses that have been initialized.
        // It is possible that the list contains some address object that have
        // not yet had their DHCP address assigned - they should be skipped.
        pVector->Count = ((WS_ADDRESS *)Address->pFirstAddress)->NumActiveAddresses;

        NextAddress = (RPC_CHAR*)&pVector->NetworkAddresses[NumberOfAddresses];
        IN_ADDR addr;
        SOCKADDR_IN6 *Ipv6Address;
        unsigned j;

        CurrentAddress = Address;
        
        iActive = 0;
        for (i = 0; i < NumberOfAddresses; i++)
            {
            if (CurrentAddress->fAddressInitialized)
                {
                pVector->NetworkAddresses[iActive] = NextAddress;
                iActive++;

                if (CurrentAddress->id != TCP_IPv6)
                    {
                    addr.s_addr = ((SOCKADDR_IN *)(&CurrentAddress->ListenAddr.inetaddr))->sin_addr.s_addr;

                    swprintf((RPC_SCHAR *)NextAddress, RPC_CONST_SSTRING("%d.%d.%d.%d"),
                             addr.s_net, addr.s_host, addr.s_lh, addr.s_impno);
                    }
                else
                    {
                    Ipv6Address = (SOCKADDR_IN6 *)(&CurrentAddress->ListenAddr.inetaddr);
                

                    swprintf((RPC_SCHAR *)NextAddress, RPC_CONST_SSTRING("%X:%X:%X:%X:%X:%X:%X:%X"),
                             Ipv6Address->sin6_addr.u.Word[0],
                             Ipv6Address->sin6_addr.u.Word[1],
                             Ipv6Address->sin6_addr.u.Word[2],
                             Ipv6Address->sin6_addr.u.Word[3],
                             Ipv6Address->sin6_addr.u.Word[4],
                             Ipv6Address->sin6_addr.u.Word[5],
                             Ipv6Address->sin6_addr.u.Word[6],
                             Ipv6Address->sin6_addr.u.Word[7]
                             );
                    }

                NextAddress += max(IPv6_MAXIMUM_RAW_NAME, IP_MAXIMUM_RAW_NAME);
                }

            CurrentAddress = (WS_ADDRESS *)CurrentAddress->pNextAddress;
            }
        }


    *ppAddressVector = pVector;

    return(RPC_S_OK);
}


RPC_STATUS
WS_Bind(
    IN SOCKET sock,
    IN OUT WS_SOCKADDR *pListenAddr,
    IN BOOL IpProtocol,
    IN DWORD EndpointFlags
    )
/*++

Routine Description:

    Binds the socket to a port.  Takes into account the endpoint flags
    and the value of the port in the WS_SOCKADDR.  There is IP specific
    code for firewalls which is keyed off of the EndpointFlags.

Arguments:

    sock - The socket to bind
    pListenAddr - On input the sin_port member is checked. For fixed endpoints
        this is set and is the only address bound to.  On output it contains
        the info on the fully bound socket.
    IpProtocol - Whether this is an IP protocol.  TRUE for TCP/IP and HTTP.
    EndpointFlags - see RpcTrans.hxx.  If non-zero and we're allocating a
        dynamic port then we must call the runtime.

Return Value:

    RPC_S_OK

    RPC_S_DUPLICATE_ENDPOINT : when a fixed endpoint is already in use.
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT

--*/
{
    RPC_STATUS status;
    int Retries = 0;
    BOOL fFirewallPorts = FALSE;
    BOOL fSetSockOptFailed;
    DWORD LastError;
    USHORT Port;

    if (IpProtocol && (RpcpGetIpPort(pListenAddr) == 0))
        {
        Retries = 8;
        }

    // Protect the socket to prevent another server from using our port.
    if (WS_ProtectListeningSocket(sock, TRUE) != 0)
        {
        return RPC_S_CANT_CREATE_ENDPOINT;
        }

    do
        {
        if (Retries)
            {
            status = I_RpcServerAllocateIpPort(EndpointFlags, &Port);

            if (status != RPC_S_OK)
                {
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    status, 
                    EEInfoDLWSBind10,
                    EndpointFlags);
                break;
                }

            RpcpSetIpPort(pListenAddr, Port);

            // Check if any firewall ports are defined. If they are remember
            // that so we can map the error correctly.

            if (!fFirewallPorts && (RpcpGetIpPort(pListenAddr) == 0))
                {
                Retries = 0;
                }
            else
                {
                Retries--;
                fFirewallPorts = TRUE;
                }

            RpcpSetIpPort(pListenAddr, htons(RpcpGetIpPort(pListenAddr)));
            }
        else
            {
            status = RPC_S_OK;
            }

WS_Bind_Rebind:
        if ( bind(sock,
                  &pListenAddr->generic,
                  sizeof(WS_SOCKADDR)) )
            {

            LastError = GetLastError();
            switch(LastError)
                {
                case WSAEACCES:
                    // This error can only be returned when a bind is done for a socket
                    // with SO_REUSEADDR following a bind with SO_EXCLUSIVEADDRUSE.  Since
                    // we never bind with SO_REUSEADDR we should not see this error unless
                    // the port is being allocated dynamically and happens to use
                    // an already listening port.
                    ASSERT(Retries > 0);
                    status = RPC_S_DUPLICATE_ENDPOINT;
                    break;

                case WSAEADDRINUSE:
                    {
                    status = RPC_S_DUPLICATE_ENDPOINT;
                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        status, 
                        EEInfoDLWSBind45,
                        (ULONG)ntohs(RpcpGetIpPort(pListenAddr)));
                    break;
                    }

                case WSAENOBUFS:
                    {
                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        LastError, 
                        EEInfoDLWSBind40);
                    status = RPC_S_OUT_OF_MEMORY;
                    break;
                    }

                default:
                    {
                    RpcpErrorAddRecord(EEInfoGCWinsock,
                        LastError, 
                        EEInfoDLWSBind50);
                    status = RPC_S_CANT_CREATE_ENDPOINT;
                    break;
                    }
                }
            }
        }
    while ( (status == RPC_S_DUPLICATE_ENDPOINT) && Retries);

    if (status != RPC_S_OK)
        {
        if (fFirewallPorts && status == RPC_S_DUPLICATE_ENDPOINT)
            {
            status = RPC_S_OUT_OF_RESOURCES;
            }

        RpcpErrorAddRecord(EEInfoGCWinsock,
            status, 
            EEInfoDLWSBind30);
        return(status);
        }

    int length = sizeof(WS_SOCKADDR);
    if (getsockname(sock, &pListenAddr->generic, &length))
        {
        return(RPC_S_OUT_OF_RESOURCES);
        }

    return(RPC_S_OK);
}

RPC_STATUS
CDP_BuildAddressVector(
    OUT NETWORK_ADDRESS_VECTOR **ppAddressVector
    )
/*++

Routine Description:

    Look up the Cluster node number of this node and build
    the appropriate vector

Arguments:

    ppAddressVector - A place to store the vector.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES

--*/
{
    HKEY ParamsKey;
    NETWORK_ADDRESS_VECTOR * pVector;
    const RPC_CHAR *ClussvcParams =
                RPC_CONST_STRING("System\\CurrentControlSet\\Services\\ClusSvc\\Parameters");
    RPC_CHAR *ClusRegNodeId = RPC_STRING_LITERAL("NodeId");
    DWORD KeyType;
    RPC_CHAR NodeIdString[ CDP_MAXIMUM_RAW_NAME ];
    DWORD StringLength = CDP_MAXIMUM_RAW_NAME * sizeof( RPC_CHAR );
    DWORD status;

    //
    // open the Clussvc parameters key and extrace the NodeId
    //

    status = RegOpenKey( HKEY_LOCAL_MACHINE,
                         (const RPC_SCHAR *)ClussvcParams,
                         &ParamsKey );

    if ( status != ERROR_SUCCESS )
        {
        return RPC_S_INVALID_NET_ADDR;
        }

    status = RegQueryValueEx(ParamsKey,
                             (const RPC_SCHAR *)ClusRegNodeId,
                             NULL,
                             &KeyType,
                             (LPBYTE)NodeIdString,
                             &StringLength);

    RegCloseKey( ParamsKey );

    if ( status != ERROR_SUCCESS ||
         KeyType != REG_SZ ||
                (( StringLength / sizeof( RPC_CHAR )) > CDP_MAXIMUM_RAW_NAME ))
        {
        return RPC_S_INVALID_NET_ADDR;
        }

    pVector = (NETWORK_ADDRESS_VECTOR *)
        I_RpcAllocate( sizeof(NETWORK_ADDRESS_VECTOR ) +
                       sizeof(RPC_CHAR *) +
                       StringLength );

    if (pVector == NULL)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    pVector->Count = 1;
    pVector->NetworkAddresses[0] = (RPC_CHAR *)&pVector->NetworkAddresses[1];

    RpcpStringCopy( pVector->NetworkAddresses[0], NodeIdString );

    *ppAddressVector = pVector;

    return RPC_S_OK;
}

typedef struct tagIPVersionSettings
{
    IPVersionToUse IPVersion;
    BOOL fUseIPv6;
} IPVersionSettings;

const static IPVersionSettings ListenIPVersionSettings[2] = {{ipvtuIPv4, FALSE}, {ipvtuIPv6, TRUE}};

typedef enum tagIPVersionSettingsIndexes
{
    ipvsiIPv4SettingsIndex = 0,
    ipvsiIPv6SettingsIndex
} IPVersionSettingsIndexes;

typedef struct tagListenAddressListElement
{
    INT ProtocolId;
    IPVersionSettingsIndexes IPVersionSettingsIndex;
    BOOL fSuccessfullyInitialized;
    RPC_STATUS ErrorCode;
    union
        {
        SOCKADDR_IN6 inet6Addr;
        SOCKADDR_IN inetAddr;
        } u;
} ListenAddressListElement;

typedef struct tagTCPServerListenParams
{
    INT ProtocolId;
    IPVersionSettingsIndexes IPVersionSettingsIndex;
} TCPServerListenParams;

const static TCPServerListenParams HTTPListenParams[1] = {HTTP, ipvsiIPv4SettingsIndex};
const static TCPServerListenParams TCPListenParams[2] = 
    {{TCP, ipvsiIPv4SettingsIndex}, 
    {TCP_IPv6, ipvsiIPv6SettingsIndex}};
const int MAX_TCP_SERVER_LISTEN_LOOP_ITERATIONS = 2;

RPC_STATUS
TCP_ServerListenEx(
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN RPC_CHAR *NetworkAddress,
    IN OUT RPC_CHAR * *pEndpoint,
    IN UINT PendingQueueSize,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG EndpointFlags,
    IN ULONG NICFlags,
    IN BOOL fHttp
    )
/*++

Routine Description:

    This routine allocates a port to receive new client connections.
    If successful a call to COMMON_ServerCompleteListen() will actually allow
    new connection callbacks to the RPC runtime to occur. If the runtime
    is unable to complete then it must abort the address by calling
    WS_ServerAbortListen().

Arguments:

    ThisAddress - A pointer to the loadable transport interface address.
    NetworkAddress - the address to listen on. This can be specified for
        IP only, and it *cannot* be a DNS name. If it is, this function
        will work incorrectly for multihomed/multi IP machines.
    pEndpoint - Optionally, the endpoint (port) to listen on. Set to
         to listened port for dynamically allocated endpoints.
    PendingQueueSize - Count to call listen() with.
    EndpointFlags - Flags that control dynamic port allocation
    NICFlags - Flags that control network (IP) address binding
    SecurityDescriptor - Meaningless for TCP

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_DUPLICATE_ENDPOINT

--*/
{
    PWS_ADDRESS pAddress = (PWS_ADDRESS)ThisAddress;
    RPC_STATUS status;
    WS_SOCKADDR *sockaddr = &(pAddress->ListenAddr);
    unsigned i;
    PWS_ADDRESS pList, pOld;
    int NeededAddressListSize;
    ListenAddressListElement *ListenAddressList;
    ListenAddressListElement *CurrentListElement;
    int AddressListSize;
    SOCKADDR_IN IPv4Address;
    SOCKADDR_IN6 *IPv6Address;
    int LoopIterations;
    TCPServerListenParams *ParamsToUse;
    IPVersionSettingsIndexes IPVersionSettingsIndex;
    BOOL fAtLeastOneAddressInitialized;
    USHORT PortNumber;      // in network byte order!
    BOOL fPortNumberInitialized;
    BOOL fDynamicEndpoint;
    BOOL fFatalErrorEncountered;
    RPC_STATUS FatalErrorCode;
    WS_ADDRESS *LastSuccessfullyInitializedAddress;
    WS_ADDRESS *NextAddress;
    BOOL fDualTransportConfiguration = FALSE;
    BOOL fLoopbackAddressProcessed;
    FIREWALL_INFO *pCopyOfFirewallTable = NULL;

    RequestGlobalMutex();
    // Get a copy of pFirewallTable while in the critical section
    // to protect against a race with the PnP table update.
    // We should only access the local copy and remember to delete it.
    pCopyOfFirewallTable = GetFirewallTableCopy();

    if (pFirewallTable != NULL &&
        pCopyOfFirewallTable == NULL)
        {
        ClearGlobalMutex();
        return RPC_S_OUT_OF_MEMORY;
        }
    ClearGlobalMutex();

    // sizing pass - allocate sufficient memory
    if (pCopyOfFirewallTable == 0 || NICFlags == RPC_C_BIND_TO_ALL_NICS)
        {
        if (fHttp)
            AddressListSize = 1;
        else
            {
            AddressListSize = 2;
            fDualTransportConfiguration = TRUE;
            }
        }
    else
        {
        AddressListSize = pCopyOfFirewallTable->NumAddresses + 1;
        }

    NeededAddressListSize = AddressListSize * sizeof(ListenAddressListElement);

    ListenAddressList = new ListenAddressListElement[NeededAddressListSize];
    if (ListenAddressList == NULL)
        {
        delete pCopyOfFirewallTable;
        return RPC_S_OUT_OF_MEMORY;
        }

    fAtLeastOneAddressInitialized = FALSE;
    RpcpMemorySet(ListenAddressList, 
        0,
        NeededAddressListSize);

    // processing pass. Set all the required addresses in the array
    if (pCopyOfFirewallTable == 0 || NICFlags == RPC_C_BIND_TO_ALL_NICS)
        {
        if (fHttp)
            {
            ASSERT(AddressListSize == 1);
            ParamsToUse = (TCPServerListenParams *)HTTPListenParams;
            LoopIterations = 1;
            }
        else
            {
            ParamsToUse = (TCPServerListenParams *)TCPListenParams;
            LoopIterations = 2;
            }

        for (i = 0; i < LoopIterations; i ++)
            {
            CurrentListElement = &ListenAddressList[i];
            CurrentListElement->ProtocolId = ParamsToUse[i].ProtocolId;
            IPVersionSettingsIndex = ParamsToUse[i].IPVersionSettingsIndex;
            CurrentListElement->IPVersionSettingsIndex = IPVersionSettingsIndex;

            IP_ADDRESS_RESOLVER resolver(NetworkAddress, 
                cosServer,
                ListenIPVersionSettings[IPVersionSettingsIndex].IPVersion       // IP version to use
                );

            // resolve the address. Since this cannot be a DNS name, we will resolve
            // to one address at most. We choose the ipv6 address, because it has space
            // for both. The actual parameter that determines the type of name resolution
            // to be done is IP version to use passed to the constructor
            status = resolver.NextAddress((SOCKADDR_STORAGE *)&CurrentListElement->u.inet6Addr);
            if (status == RPC_S_OK)
                {
                fAtLeastOneAddressInitialized = TRUE;
                CurrentListElement->fSuccessfullyInitialized = TRUE;
                }
            }
        }
    else
        {
        fAtLeastOneAddressInitialized = TRUE;
        fLoopbackAddressProcessed = FALSE;

        for (i = 0; i < AddressListSize; i++)
            {
            CurrentListElement = &ListenAddressList[i];

            if (fHttp)
                {
                CurrentListElement->ProtocolId = HTTP;
                }
            else 
                {
                CurrentListElement->ProtocolId = TCP;                
                }

            CurrentListElement->IPVersionSettingsIndex = ipvsiIPv4SettingsIndex;
            CurrentListElement->fSuccessfullyInitialized = TRUE;

            if (i == pCopyOfFirewallTable->NumAddresses)
                {
                CurrentListElement->u.inetAddr.sin_addr.s_addr = 0x0100007F;
                }
            else
                {
                if (pCopyOfFirewallTable->Entries[i].Address == 0x0100007F)
                    fLoopbackAddressProcessed = TRUE;
                CurrentListElement->u.inetAddr.sin_addr.s_addr = pCopyOfFirewallTable->Entries[i].Address;
                }
            }

        // if the loopback address was in the firewall configuration, 'forget' about
        // the last entry we added for the loopback address. Otherwise, we'll have
        // it twice in the list, and this will cause errors
        if (fLoopbackAddressProcessed)
            {
            AddressListSize --;
            // since we added one, and fLoopbackAddressProcessed is set only if
            // we find something in the list, then AddressListSize must still be
            // greater than 0.
            ASSERT(AddressListSize > 0);
            }
        }

    if (fAtLeastOneAddressInitialized)
        {
        fAtLeastOneAddressInitialized = FALSE;
        }
    else
        {
        // the only place where we can fail so far is name resolution. If this
        // fails, return the status
        delete [] ListenAddressList;
        delete pCopyOfFirewallTable;
        return status;
        }

    // Figure out what port to bind to.

    if (*pEndpoint)
        {
        status = EndpointToPortNumber(*pEndpoint, PortNumber);
        if (status != RPC_S_OK)
            {
            delete [] ListenAddressList;
            delete pCopyOfFirewallTable;
            return(status);
            }

        PortNumber = htons(PortNumber);
        fDynamicEndpoint = 0;
        fPortNumberInitialized = TRUE;
        }
    else
        {
        PortNumber = 0;
        fDynamicEndpoint = TRUE;
        fPortNumberInitialized = FALSE;
        }

    // zoom in through the array address, and listen on all successfully initialized
    // protocols
    pList = pAddress;

    pAddress->NumActiveAddresses = 0;

    fFatalErrorEncountered = FALSE;

    for (i = 0; i < AddressListSize; i ++)
        {
        CurrentListElement = &ListenAddressList[i];
        if (!CurrentListElement->fSuccessfullyInitialized)
            continue;

        if (pList == 0)
            {
            pList = new WS_ADDRESS;
            if (pList == 0)
                {
                fFatalErrorEncountered = TRUE;

                FatalErrorCode = RPC_S_OUT_OF_MEMORY;
                break;
                }

            pOld->pNextAddress = pList;
            }

        sockaddr = &(pList->ListenAddr);

        RpcpMemorySet(sockaddr, 0, sizeof(*sockaddr));

        // the port we have set is already in network byte order - 
        // no need to change it
        RpcpSetIpPort(sockaddr, PortNumber);

        pList->fDynamicEndpoint = fDynamicEndpoint;

        if (ListenIPVersionSettings[CurrentListElement->IPVersionSettingsIndex].fUseIPv6)
            {
            ((SOCKADDR_IN6 *)sockaddr)->sin6_flowinfo = 0;
            RpcpCopyIPv6Address(&CurrentListElement->u.inet6Addr, (SOCKADDR_IN6 *)sockaddr);
            }
        else
            {
            RpcpCopyIPv4Address(&CurrentListElement->u.inetAddr, (SOCKADDR_IN *)sockaddr);
            }

        pList->id = CurrentListElement->ProtocolId;
        pList->NewConnection = WS_NewConnection;
        pList->SubmitListen = WS_SubmitAccept;
        SetProtocolMultiplier(pList, 1);
        pList->pAddressVector = 0;
        pList->Endpoint = 0;
        pList->QueueSize = PendingQueueSize;
        pList->EndpointFlags = EndpointFlags;
        pList->fAddressInitialized = TRUE;

        pList->pFirstAddress = pAddress;
        pList->pNextAddress = NULL;

        sockaddr->generic.sa_family = WsTransportTable[CurrentListElement->ProtocolId].AddressFamily;

        // If we are running with the firewall address table
        // and the address has not yet been initialized or enabled, delay listening on it.
        if (pCopyOfFirewallTable != NULL &&
            (pCopyOfFirewallTable->Entries[i].fInitialized == FALSE
             || pCopyOfFirewallTable->Entries[i].fEnabled == FALSE
            )
           )
            {
            ASSERT(pCopyOfFirewallTable->NumAddresses > i);

            pList->InAddressList = Inactive;

            // We need to register the address to receive
            // PnP notifications.  This is necessary to allow
            // the initialization and activation of the address later on
            // when the corresponding interface has been initialized.
            TransportProtocol::AddObjectToProtocolList(pList);

            pList->type = ADDRESS;

            // Record that the address has not yet been initialized and
            // keep track of the interface index so that we can later use
            // the pFirewallTable to initialize this address.
            pList->fAddressInitialized = FALSE;
            }
        // Either selective bindings are not used, or the address has been initialized.
        else
            {
            // we must know whether we got WSAEAFNOSUPPORT when we opened the socket
            // if yes, we must record this in CurrentElement, and we must not blow
            // the address. If we got something else, we should abort even in dual
            // transport config. The addresses on the firewall are a separate thing -
            // we ignore the ones we can't listen on.

            pAddress->NumActiveAddresses++;

            // Actually listen.
            // Pass in fResetAddressListEntries = FALSE since the address list
            // fields have already been initialized.
            status = WS_ServerListenCommon(pList, FALSE);

            if (status != RPC_S_OK)
                {
                if ((status == RPC_S_DUPLICATE_ENDPOINT) 
                    || (fDualTransportConfiguration && (status != RPC_P_ADDRESS_FAMILY_INVALID)))
                    {
                    // if either somebody else is listening on our port for this address,
                    // or this is a dual transport configuratuon, and we fail to listen
                    // on one of the transports for reasons other that it not being
                    // installed, bail out
                    fFatalErrorEncountered = TRUE;
                    FatalErrorCode = status;
                    break;
                    }
                else if (fDualTransportConfiguration && (status == RPC_P_ADDRESS_FAMILY_INVALID))
                    {
                    pList->InAddressList = Inactive;

                    // we still need to register the address with PnP
                    // make sure it's not already there
                    ASSERT(RpcpIsListEmpty(&pList->ObjectList));
                    TransportProtocol::AddObjectToProtocolList(pList);
                    }

                CurrentListElement->ErrorCode = status;

                CurrentListElement->fSuccessfullyInitialized = FALSE;
                }
            else
                {
                if (!fPortNumberInitialized)
                    {
                    PortNumber = RpcpGetIpPort(&(pList->ListenAddr));
                    fPortNumberInitialized = TRUE;
                    }
                fAtLeastOneAddressInitialized = TRUE;
                }
            }

        pOld = pList;
        pList = 0;
        }

    // If at least one address has initialized then that address should have picked
    // the dynamic endpoint to listen on:
    // fAtLeastOneAddressInitialized -> fPortNumberInitialized
    ASSERT(!fAtLeastOneAddressInitialized || fPortNumberInitialized);

    // compact the list by removing addresses we couldn't successfully listen on
    pList = pAddress;
    for (i = 0; i < AddressListSize; i ++)
        {
        // we may have an early break if a memory allocation failed
        if (pList == NULL)
            break;

        // if this address has not initialized successfully, and this is not
        // the first address, and either none of the elements initialized
        // successfully or this is not a dual transport configuration with
        // error RPC_P_ADDRESS_FAMILY_INVALID and this is not a
        // delay-initialized address under dynamic binding that has not yet been
        // assigned an IP address, delete the element.
        if (!ListenAddressList[i].fSuccessfullyInitialized && (i > 0)
            && 
            (!fAtLeastOneAddressInitialized 
                || (!fDualTransportConfiguration 
                    || (ListenAddressList[i].ErrorCode != RPC_P_ADDRESS_FAMILY_INVALID)
                   )
            )
            &&
            !(pCopyOfFirewallTable != NULL && pCopyOfFirewallTable->Entries[i].fInitialized == FALSE)
           )
            {
            ASSERT(pOld != pList);
            pOld->pNextAddress = pList->pNextAddress;
            NextAddress = (WS_ADDRESS *)pList->pNextAddress;
            TransportProtocol::RemoveObjectFromProtocolList(pList);
            delete pList;
            }
        else
            {
            pOld = pList;
            NextAddress = (WS_ADDRESS *)pList->pNextAddress;
            }

        pList = NextAddress;
        }

    if (!fAtLeastOneAddressInitialized)
        {
        TransportProtocol::RemoveObjectFromProtocolList(pAddress);
        delete [] ListenAddressList;
        delete pCopyOfFirewallTable;
        if (status == RPC_P_ADDRESS_FAMILY_INVALID)
            status = RPC_S_PROTSEQ_NOT_SUPPORTED;
        return status;
        }

    // the attempt to listen on dual protocol configurations may have left EEInfo
    // record in the TEB. If we're here, we have succeeded, and we can delete them
    RpcpPurgeEEInfo();

    if (!ListenAddressList[0].fSuccessfullyInitialized)
        {
        // here, pOld must be the last successfully initialized element
        // or the last element we haven't given up on (i.e. potentially
        // active through PnP)
        // It cannot be the first element, or we would have bailed out
        // by now. We cannot have only one element either
        ASSERT(pOld->pNextAddress == NULL);
        ASSERT(pAddress->pNextAddress != NULL);

        // here at least one has succeeded and all non-first failed
        // elements are deleted, though a fatal error may have been
        // encountered. We need to deal with the first element
        // because we don't want to expose elements with failed
        // initialization outside this routine.
        // 
        // We will leave the first element alone if it is a delay-initialized address
        // that has not yet been assigned a transport address.
        if (!(fDualTransportConfiguration && (ListenAddressList[0].ErrorCode == RPC_P_ADDRESS_FAMILY_INVALID))
            &&
            !(pCopyOfFirewallTable != NULL && pCopyOfFirewallTable->Entries[0].fInitialized == FALSE))
            {
            // remove the element we will copy to the first element
            TransportProtocol::RemoveObjectFromProtocolList(pOld);

            NextAddress = (WS_ADDRESS *)pAddress->pNextAddress;
            RpcpMemoryCopy(pAddress, pOld, sizeof(WS_ADDRESS));
            pAddress->pNextAddress = NextAddress;

            // find the element we just copied over the first, and free it
            LastSuccessfullyInitializedAddress = pOld;
            pList = pAddress;
            while (pList->pNextAddress != LastSuccessfullyInitializedAddress)
                {
                pList = (WS_ADDRESS *)pList->pNextAddress;
                }

            delete pList->pNextAddress;
            pList->pNextAddress = NULL;

            // add the first element back on the list.
            TransportProtocol::AddObjectToProtocolList(pAddress);
            }
        }

    delete [] ListenAddressList;
    delete pCopyOfFirewallTable;

    // by now all elements in the list have listened successfully
    // or are in transport PnP state. However
    // if we encountered a fatal error, we need to abort any way
    if (fFatalErrorEncountered)
        {
        WS_ServerAbortListen(pAddress);

        // fatal error - bail out
        return FatalErrorCode;
        }

    // Listened okay

    // Figure out our network addresses
    ASSERT(pAddress->pAddressVector == NULL);
    status = IP_BuildAddressVector(
                                   &pAddress->pAddressVector,
                                   NICFlags,
                                   NetworkAddress,
                                   pAddress);

    if (status != RPC_S_OK)
        {
        WS_ServerAbortListen(pAddress);
        return(status);
        }

    // Return the dynamic port, if needed.

    if (!*pEndpoint)
        {
        *pEndpoint = new RPC_CHAR[6]; // 65535 max
        if (!*pEndpoint)
            {
            WS_ServerAbortListen(ThisAddress);
            return(RPC_S_OUT_OF_MEMORY);
            }

        PortNumber = ntohs(PortNumber);

        PortNumberToEndpoint(PortNumber, *pEndpoint);
        }

    // Save away the endpoint in the address, if needed, here.
    // (PnP?)

    return(status);
}




RPC_STATUS
TCP_ServerListen(
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN RPC_CHAR *NetworkAddress,
    IN OUT RPC_CHAR * *pEndpoint,
    IN UINT PendingQueueSize,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG EndpointFlags,
    IN ULONG NICFlags
    )
{

    return (TCP_ServerListenEx(
                ThisAddress,
                NetworkAddress,
                pEndpoint,
                PendingQueueSize,
                SecurityDescriptor,
                EndpointFlags,
                NICFlags,
                FALSE // Not HTTP
                ));
}

RPC_STATUS
WS_ConvertClientAddress (
    IN const SOCKADDR *ClientAddress,
    IN ULONG ClientAddressType,
    OUT RPC_CHAR **pNetworkAddress
    )
/*++

Routine Description:

    Converts a given IP address to a RPC network address

Arguments:

    ClientAddress - the client IP address. Can be SOCKADDR_IN6
        for IPv6.

    ClientAddressType - TCP or TCP_IPv6

    NetworkAddress - Will contain string on success.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    USES_CONVERSION;
    CNlUnicode nlUnicode;
    int Result;
    int SocketLength;
    int HostLength;
    char *HostName;
    char *ScopeIdSeparator;

    ASSERT((ClientAddressType == TCP) || (ClientAddressType == TCP_IPv6));

    if (ClientAddressType == TCP)
        SocketLength = sizeof(SOCKADDR_IN);
    else
        SocketLength = sizeof(SOCKADDR_IN6);

    // allocate space for the numeric name plus the terminating NULL
    HostLength = max(IP_MAXIMUM_RAW_NAME, IPv6_MAXIMUM_RAW_NAME) + 1;
    HostName = (char *)alloca(HostLength);

    Result = getnameinfo(ClientAddress,
        SocketLength,
        HostName,
        HostLength,
        NULL,
        0,
        NI_NUMERICHOST);

    ASSERT(Result == 0);

    ScopeIdSeparator = strchr(HostName, '%');
    if (ScopeIdSeparator)
        {
        // if there is a scope separator, whack everything after
        // the scope separator (i.e. we don't care about the scope).
        *ScopeIdSeparator = 0;
        }

    ATTEMPT_NL_A2W(nlUnicode, HostName);

    *pNetworkAddress = (WCHAR *)nlUnicode;
    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
TCP_QueryClientAddress (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT RPC_CHAR **pNetworkAddress
    )
/*++

Routine Description:

    Returns the IP address of the client on a connection as a string.
    The clients address is saved when the client connects, so all
    we need to do is format the address.

Arguments:

    ThisConnection - The server connection of interest.
    NetworkAddress - Will contain string on success.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    PWS_CONNECTION p = (PWS_CONNECTION)ThisConnection;

    return WS_ConvertClientAddress((const SOCKADDR *)&p->saClientAddress.ipaddr,
        p->id,
        pNetworkAddress
        );
}


RPC_STATUS
RPC_ENTRY
TCP_QueryLocalAddress (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    )
/*++

Routine Description:

    Returns the local IP address of a connection.

Arguments:

    ThisConnection - The server connection of interest.

    Buffer - The buffer that will receive the output address

    BufferSize - the size of the supplied Buffer on input. On output the
        number of bytes written to the buffer. If the buffer is too small
        to receive all the output data, ERROR_MORE_DATA is returned,
        nothing is written to the buffer, and BufferSize is set to
        the size of the buffer needed to return all the data.

    AddressFormat - a constant indicating the format of the returned address.
        Currently supported are RPC_P_ADDR_FORMAT_TCP_IPV4 and
        RPC_P_ADDR_FORMAT_TCP_IPV6. Undefined on failure.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    PWS_CONNECTION p = (PWS_CONNECTION)ThisConnection;
    int MinimumBufferLength;
    int Result;
    const WS_TRANS_INFO *pInfo = &WsTransportTable[p->id];

    ASSERT(p->type & SERVER);

    if ((p->id == TCP) || (p->id == HTTP))
        {
        MinimumBufferLength = sizeof(SOCKADDR_IN);
        *AddressFormat = RPC_P_ADDR_FORMAT_TCP_IPV4;
        }
    else
        {
        ASSERT(p->id == TCP_IPv6);
        MinimumBufferLength = sizeof(SOCKADDR_STORAGE);
        *AddressFormat = RPC_P_ADDR_FORMAT_TCP_IPV6;
        }

    if (*BufferSize < MinimumBufferLength)
        {
        *BufferSize = MinimumBufferLength;
        return ERROR_MORE_DATA;
        }

    ASSERT(p->pAddress);

    p->StartingOtherIO();

    if (p->fAborted)
        {
        p->OtherIOFinished();
        return(RPC_S_NO_CONTEXT_AVAILABLE);
        }

    Result = setsockopt(p->Conn.Socket,
        SOL_SOCKET,
        SO_UPDATE_ACCEPT_CONTEXT,
        (char *)&p->pAddress->ListenSocket,
        sizeof(p->pAddress->ListenSocket) );

    if (Result != SOCKET_ERROR)
        {
        Result = getsockname(p->Conn.Socket,
            (sockaddr *)Buffer, 
            (int *) BufferSize);

        // SO_UPDATE_ACCEPT_CONTEXT has the nasty habit of deleting
        // all of our socker options. Restore them
        WS_SetSockOptForConnection(pInfo, p->Conn.Socket);

        p->OtherIOFinished();

        if (Result == SOCKET_ERROR)
            {
            RpcpErrorAddRecord(EEInfoGCWinsock,
                RPC_S_OUT_OF_MEMORY,
                EEInfoDLTCP_QueryLocalAddress10,
                (ULONGLONG) p->Conn.Socket,
                GetLastError());
            return RPC_S_OUT_OF_MEMORY;
            }
        }
    else
        {
        p->OtherIOFinished();

        RpcpErrorAddRecord(EEInfoGCWinsock,
            RPC_S_OUT_OF_MEMORY,
            EEInfoDLTCP_QueryLocalAddress20,
            (ULONGLONG) p->Conn.Socket,
            GetLastError());
        return RPC_S_OUT_OF_MEMORY;
        }

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
TCP_QueryClientId(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT RPC_CLIENT_PROCESS_IDENTIFIER *ClientProcess
    )
/*++

Routine Description:

    For secure protocols (which TCP/IP is not) this is suppose to
    give an ID which will be shared by all clients from the same
    process.  This prevents one user from grabbing another users
    association group and using their context handles.

    Since TCP/IP is not secure we return the IP address of the
    client machine.  This limits the attacks to other processes
    running on the client machine which is better than nothing.

Arguments:

    ThisConnection - Server connection in question.
    ClientProcess - Transport identification of the "client".

Return Value:

    RPC_S_OUT

--*/
{
    PWS_CONNECTION p = (PWS_CONNECTION)ThisConnection;

    ASSERT(p->type & SERVER);

    // Currently, we don't have an efficient way of determining which clients
    // are local, and which remote. Since some clients grant more permissions
    // to local clients, we want to be on the safe side, and return all TCP
    // clients as remote.
    ClientProcess->ZeroOut();
    if (p->id != TCP_IPv6)
        {
        ClientProcess->SetIPv4ClientIdentifier(p->saClientAddress.inetaddr.sin_addr.s_addr,
            FALSE   // fLocal
            );
        }
    else
        {
        ClientProcess->SetIPv6ClientIdentifier(&p->saClientAddress.ipaddr, 
            sizeof(p->saClientAddress.ipaddr),
            FALSE   // fLocal
            );
        }

    return(RPC_S_OK);
}

RPC_STATUS
RPC_ENTRY
TCP_QueryClientIpAddress (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN OUT RPC_CLIENT_IP_ADDRESS *ClientIpAddress
    )
/*++

Routine Description:

    Returns the IP address of the client on a connection as a SOCKADDR.
    The clients address is saved when the client connects, so all
    we need to do is copy it.

Arguments:

    ThisConnection - The server connection of interest.

    ClientIpAddress - the buffer to store the address to.

Return Value:

    RPC_S_OK or other RPC_S_* errors for error

--*/
{
    ULONG BufferLength;
    PWS_CONNECTION p = (PWS_CONNECTION)ThisConnection;

    if (p->id != TCP_IPv6)
        {
        BufferLength = sizeof(SOCKADDR_IN);
        }
    else
        {
        BufferLength = sizeof(SOCKADDR_IN6);
        }

    ASSERT(BufferLength <= sizeof(ClientIpAddress->Data));

    ClientIpAddress->DataSize = BufferLength;
    // we know both IPv4 and IPv6 start at the same offset. Just copy the respective
    // size starting at the offset.
    RpcpMemoryCopy (ClientIpAddress->Data, &p->saClientAddress.ipaddr, BufferLength);

    return RPC_S_OK;
}

RPC_STATUS
TCPOrHTTP_Open(
    IN WS_CONNECTION *Connection,
    IN RPC_CHAR * NetworkAddress,
    IN USHORT Endpoint,
    IN UINT ConnTimeout,
    IN UINT SendBufferSize,
    IN UINT RecvBufferSize,
    IN OUT TCPResolverHint *Hint,
    IN BOOL  fHintInitialized,
    IN ULONG CallTimeout,
    IN BOOL fHTTP2Open,
    IN I_RpcProxyIsValidMachineFn IsValidMachineFn OPTIONAL
    )
/*++

Routine Description:

    Opens a connection to a server.

Arguments:

    ThisConnection - A place to store the connection
    NetworkAddress - The name of the server, either a dot address or DNS name
    Endpoint - the port number in host byte order representation
    ConnTimeout - See RpcMgmtSetComTimeout
            0 - Min
            5 - Default
            9 - Max
            10 - Infinite
    SendBufferSize -
    RecvBufferSize - (Both optional) Specifies the size of the send/recv
        transport buffers.
    ResolverHint - Resolver hint
    fHintInitialized - If TRUE, the ResolveHint contains the IP address
        of the server. If FALSE, do standard name resolution.
    CallTimeout - the call timeout in milliseconds
    fHTTP2Open - non-zero if this is an HTTP2 Open
    IsValidMachineFn - a callback function that is used to validate machine/port
        for access from this process. Used by HTTP only.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_SERVER_UNAVAILABLE
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_INVALID_NET_ADDR

--*/
{
    RPC_STATUS status;
    RPC_STATUS status2;
    WS_SOCKADDR sa;
    PVOID rnrContext;
    BOOL fIPv4Hint;
    USES_CONVERSION;
    CStackAnsi AnsiName;
    BOOL NetworkAddressConverted;
    char *DotName;
    char *DotNamePtr;
    char DotNameBuffer[max(IP_MAXIMUM_RAW_NAME, IPv6_MAXIMUM_RAW_NAME) + 1]; 

    ASSERT(NetworkAddress);

    // All this function needs to is initialize transport specific
    // parts of the connection and sockaddr.  This includes resolving
    // the network address into a `raw' address.

    RpcpSetIpPort(&sa, htons(Endpoint));

    if (fHTTP2Open)
        {
        Connection->id = HTTPv2;
        NetworkAddressConverted = FALSE;
        }
    else
        Connection->id = TCP;

    // Two cases, previously saved address or first open

    if (fHintInitialized)
        {
        Hint->GetResolverHint(&fIPv4Hint, &sa);

        if (!fIPv4Hint)
            Connection->id = TCP_IPv6;

        ASSERT(IsValidMachineFn == FALSE);

        status = WS_Open((PWS_CCONNECTION)Connection, 
            &sa, 
            ConnTimeout, 
            SendBufferSize, 
            RecvBufferSize, 
            CallTimeout,
            fHTTP2Open
            );
        if (status == ERROR_RETRY)
            {
            status = RPC_S_SERVER_UNAVAILABLE;
            }

        return(status);
        }

    // Prepare to resolve the network address

    IP_ADDRESS_RESOLVER resolver(NetworkAddress, 
        cosClient,
        ipvtuIPAny       // IP version to use
        );

    // Loop until success, fatal failure or we run out of addresses.

    do
        {
        status = resolver.NextAddress(&sa.ipaddr);

        // check the list of valid machines first. If this is not a valid
        // machine, we don't want to return out information on whether the name
        // resolves or not
        if (IsValidMachineFn)
            {
            ASSERT(fHTTP2Open != FALSE);
            if (NetworkAddressConverted == FALSE)
                {
                ATTEMPT_STACK_W2A(AnsiName, NetworkAddress);
                NetworkAddressConverted = TRUE;
                }

            if (status == RPC_S_OK)
                {
                DotName = inet_ntoa(sa.inetaddr.sin_addr);
                strcpy(DotNameBuffer, DotName);
                DotNamePtr = DotNameBuffer;
                }
            else
                {
                DotNamePtr = NULL;
                }

            status2 = IsValidMachineFn(AnsiName,
                DotNamePtr,
                Endpoint
                );

            if (status2 != RPC_S_OK)
                {
                // if we're out of names, no point in continuing
                if (status != RPC_S_OK)
                    {
                    // move the status from the allowed check to the return value
                    status = status2;
                    break;
                    }

                // if the server is resolved, but not allowed for access, continue with next
                status = ERROR_RETRY;
                continue;
                }
            else if (status != RPC_S_OK)
                {
                // the server is allowed, but can't be resolved - break where we will return an error
                break;
                }
            }

        if (status != RPC_S_OK)
            {
            break;
            }

        if (sa.ipaddr.ss_family == AF_INET6)
            Connection->id = TCP_IPv6;
        else if (Connection->id == TCP_IPv6)
            {
            // if we were at IPv6 and we didn't select IPv6 this time, it must
            // be IPv4
            ASSERT(sa.ipaddr.ss_family == AF_INET);
            Connection->id = TCP;
            }

        // Call common open function
        status = WS_Open((PWS_CCONNECTION)Connection, 
            &sa, 
            ConnTimeout, 
            SendBufferSize, 
            RecvBufferSize, 
            CallTimeout,
            fHTTP2Open
            );
        }
    while (status == ERROR_RETRY);

    if (status == RPC_S_OK)
        {
        Hint->SetResolverHint((Connection->id == TCP) || (Connection->id == HTTPv2), &sa);
        }

    return(status);
}




RPC_STATUS
RPC_ENTRY
TCP_Open(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN RPC_CHAR * ProtocolSequence,
    IN RPC_CHAR * NetworkAddress,
    IN RPC_CHAR * Endpoint,
    IN RPC_CHAR * NetworkOptions,
    IN UINT ConnTimeout,
    IN UINT SendBufferSize,
    IN UINT RecvBufferSize,
    IN OUT PVOID ResolverHint,
    IN BOOL  fHintInitialized,
    IN ULONG CallTimeout,
    IN ULONG AdditionalTransportCredentialsType, OPTIONAL
    IN void *AdditionalCredentials OPTIONAL
    )
/*++

Routine Description:

    Opens a connection to a server.

Arguments:

    ThisConnection - A place to store the connection
    ProtocolSeqeunce - "ncacn_ip_tcp". Ignored in this function
    NetworkAddress - The name of the server, either a dot address or DNS name
    NetworkOptions - Ignored
    ConnTimeout - See RpcMgmtSetComTimeout
            0 - Min
            5 - Default
            9 - Max
            10 - Infinite
    SendBufferSize -
    RecvBufferSize - (Both optional) Specifies the size of the send/recv
        transport buffers.
    ResolverHint - IP address of server, if valid.
    fHintInitialized - If TRUE, the ResolveHint contains the IP address
        of the server. If FALSE, do standard name resolution.
    CallTimeout - the call timeout in milliseconds

    AdditionalTransportCredentialsType - the type of additional credentials that we were
        given. Not used for TCP.

    AdditionalCredentials - additional credentials that we were given. 
        Not used for TCP.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_SERVER_UNAVAILABLE
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_INVALID_NET_ADDR

--*/
{
    RPC_STATUS status;
    PWS_CCONNECTION p = (PWS_CCONNECTION)ThisConnection;
    USHORT port;

    ASSERT(NetworkAddress);

    if ((AdditionalTransportCredentialsType != 0) || (AdditionalCredentials != NULL))
        return RPC_S_CANNOT_SUPPORT;

    // use explicit placement to initialize the vtable. We need this to
    // be able to use the virtual functions
    p = new (p) WS_CLIENT_CONNECTION;

    // All this function needs to is initialize transport specific
    // parts of the connection and sockaddr.  This includes resolving
    // the network address into a `raw' address.

    // Figure out the destination port
    status = EndpointToPortNumber(Endpoint, port);
    if (status != RPC_S_OK)
        {
        return(status);
        }

    return TCPOrHTTP_Open (p,
        NetworkAddress,
        port,
        ConnTimeout,
        SendBufferSize,
        RecvBufferSize,
        (TCPResolverHint *)ResolverHint,
        fHintInitialized,
        CallTimeout,
        FALSE,   // fHTTP2Open
        NULL     // IsValidMachineFn
        );
}

#ifdef SPX_ON
/////////////////////////////////////////////////////////////////////
//
// SPX specific functions
//

RPC_STATUS
SPX_ServerListen(
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN RPC_CHAR *NetworkAddress,
    IN OUT RPC_CHAR * *pEndpoint,
    IN UINT PendingQueueSize,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG EndpointFlags,
    IN ULONG NICFlags
    )
/*++

Routine Description:

    This routine allocates a new pipe to receive new client connections.
    If successful a call to COMMON_ServerCompleteListen() will actually allow
    new connection callbacks to the RPC runtime to occur. If the runtime
    is unable to complete then it must abort the address by calling
    WS_ServerAbortListen().

Arguments:

    pAddress - A pointer to the loadable transport interface address.
    pEndpoint - Optionally, the endpoint (port) to listen on. Set to
         to listened port for dynamically allocated endpoints.
    PendingQueueSize - Count to call listen() with.
    EndpointFlags - Meaningless for SPX
    NICFlags - Meaningless for SPX
    SecurityDescriptor - Meaningless for SPX

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_DUPLICATE_ENDPOINT

--*/
{
    PWS_ADDRESS pAddress = (PWS_ADDRESS)ThisAddress;
    RPC_STATUS status;
    WS_SOCKADDR *sockaddr = &(pAddress->ListenAddr);
    INT i;
    USHORT port;

    pAddress->id = SPX;
    pAddress->NewConnection = WS_NewConnection;
    pAddress->SubmitListen = WS_SubmitAccept;
    SetProtocolMultiplier(pAddress, 1);
    pAddress->pAddressVector = 0;
    pAddress->Endpoint = 0;
    pAddress->QueueSize = PendingQueueSize;
    pAddress->EndpointFlags = EndpointFlags;

    sockaddr->generic.sa_family = WsTransportTable[SPX].AddressFamily;

    // Figure out what port to bind to.

    if (*pEndpoint)
        {
        status = EndpointToPortNumber(*pEndpoint, port);
        if (status != RPC_S_OK)
            {
            return(status);
            }

        sockaddr->ipxaddr.sa_socket = htons(port);
        pAddress->fDynamicEndpoint = 0;
        }
    else
        {
        pAddress->fDynamicEndpoint = 1;
        sockaddr->ipxaddr.sa_socket = 0;
        }

    // No need to bind to a specific address for SPX
    memset(sockaddr->ipxaddr.sa_netnum,  0, sizeof(sockaddr->ipxaddr.sa_netnum) );
    memset(sockaddr->ipxaddr.sa_nodenum, 0, sizeof(sockaddr->ipxaddr.sa_nodenum));

    // Actually listen

    status = WS_ServerListenCommon(pAddress);


    if (status == RPC_S_OK)
        {
        // Listened okay, update local IPX address.
        //
        // Since there is only one addess no lock is required.
        //
        memcpy(IpxAddr.sa_netnum, sockaddr->ipxaddr.sa_netnum, 4);
        memcpy(IpxAddr.sa_nodenum, sockaddr->ipxaddr.sa_nodenum, 6);
        fIpxAddrValid = TRUE;

        // Figure out our network addresses
        status = IPX_BuildAddressVector(&pAddress->pAddressVector);

        if (status != RPC_S_OK)
            {
            WS_ServerAbortListen(pAddress);
            return(status);
            }

        // Return the dynamic port, if needed.

        if (!*pEndpoint)
            {
            *pEndpoint = new RPC_CHAR[6]; // 65535 max
            if (!*pEndpoint)
                {
                WS_ServerAbortListen(ThisAddress);
                return(RPC_S_OUT_OF_MEMORY);
                }

            port = ntohs(sockaddr->ipxaddr.sa_socket);

            PortNumberToEndpoint(port, *pEndpoint);
            }

        TransportProtocol::FunctionalProtocolDetected(pAddress->id);

        // Save away the endpoint in the address, if needed, here.
        // (PnP?)

        }
    else if (status == RPC_P_ADDRESS_FAMILY_INVALID)
        {
        status = RPC_S_PROTSEQ_NOT_SUPPORTED;
        }

    return(status);
}


RPC_STATUS
RPC_ENTRY
SPX_QueryClientAddress(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT RPC_CHAR ** pNetworkAddress
    )
/*++

Routine Description:

    Returns the raw IPX of the client to a connection as a string.  The
    clients address is saved when the client connects, so all we need to do is
    format the address.

Arguments:

    ThisConnection - The connection of interest.
    pNetworkAddress - Will contain string on success.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY

--*/
{
    WS_CONNECTION *p= (WS_CONNECTION *)ThisConnection;
    ASSERT(p->type & SERVER);

    RPC_CHAR *Address = new RPC_CHAR[IPX_MAXIMUM_RAW_NAME];

    if (!Address)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    IPX_AddressToName(&p->saClientAddress.ipxaddr, Address);

    *pNetworkAddress = Address;

    return(RPC_S_OK);
}

RPC_STATUS
RPC_ENTRY
SPX_QueryClientId(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT RPC_CLIENT_PROCESS_IDENTIFIER *ClientProcess
    )
/*++

Routine Description:

    For secure protocols (which SPX is not) this is suppose to give an ID
    which will be shared by all connections from the same process or security
    identity.  This prevents one user from grabbing another users association
    group and using their context handles.

    Since SPX is not secure we return the IPX node number of the client.
    This limits the attacks to other processes running on the client machine
    which is better than nothing.

Arguments:

    ThisConnection - Server connection in question.
    ClientProcess - Transport identification of the "client".

Return Value:

    RPC_S_OUT

--*/
{
    PWS_CONNECTION p = (PWS_CONNECTION)ThisConnection;

    ASSERT(p->type & SERVER);

    // The runtime assumes that any connections with a ClientProcess->FirstPart is 
    // zero means the client is local.
    // Currently, we don't have an efficient way of determining which clients
    // are local, and which remote. Since some clients grant more permissions
    // to local clients, we want to be on the safe side, and return all SPX
    // clients as remote.

    ClientProcess->ZeroOut();
    ClientProcess->SetIPXClientIdentifier(p->saClientAddress.ipxaddr.sa_nodenum,
        sizeof(p->saClientAddress.ipxaddr.sa_nodenum), FALSE);

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
SPX_Open(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN RPC_CHAR * ProtocolSequence,
    IN RPC_CHAR * NetworkAddress,
    IN RPC_CHAR * Endpoint,
    IN RPC_CHAR * NetworkOptions,
    IN UINT ConnTimeout,
    IN UINT SendBufferSize,
    IN UINT RecvBufferSize,
    IN void *ResolverHint,
    IN BOOL fHintInitialized,
    IN ULONG CallTimeout,
    IN ULONG AdditionalTransportCredentialsType, OPTIONAL
    IN void *AdditionalCredentials OPTIONAL
    )
/*++

Routine Description:

    Opens a connection to a server.

Arguments:

    ThisConnection - A place to store the connection
    ProtocolSeqeunce - "ncacn_spx"
    NetworkAddress - The name of the server, either a raw address or pretty name
    NetworkOptions - Ignored
    ConnTimeout - See RpcMgmtSetComTimeout
            0 - Min
            5 - Default
            9 - Max
            10 - Infinite
    SendBufferSize -
    RecvBufferSize - (Both optional) Specifies the size of the send/recv
        transport buffers.
    CallTimeout - call timeout in milliseconds

    AdditionalTransportCredentialsType - the type of additional credentials that we were
        given. Not used for SPX.

    AdditionalCredentials - additional credentials that we were given. 
        Not used for SPX.

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_SERVER_UNAVAILABLE
    RPC_S_INVALID_ENDPOINT_FORMAT
    RPC_S_INVALID_NET_ADDR

--*/
{
    RPC_STATUS status;
    PWS_CCONNECTION p = (PWS_CCONNECTION)ThisConnection;
    SOCKET sock;
    WS_SOCKADDR sa;
    CHAR AnsiPort[IPX_MAXIMUM_ENDPOINT];
    PCHAR AnsiNetworkAddress;
    BOOL fUseCache = TRUE;
    BOOL fFoundInCache = FALSE;

    if ((AdditionalTransportCredentialsType != 0) || (AdditionalCredentials != NULL))
        return RPC_S_CANNOT_SUPPORT;

    // use explicit placement to initialize the vtable. We need this to
    // be able to use the virtual functions
    p = new (p) WS_CLIENT_CONNECTION;

    // All this function needs to is initialize transport specific
    // parts of the connection and sockaddr.  This includes resolving
    // the network address into a `raw' address.

    p->id = SPX;

    // Figure out the destination port
    USHORT port;
    status = EndpointToPortNumber(Endpoint, port);
    if (status != RPC_S_OK)
        {
        return(status);
        }

    for (;;)
        {
        // Resolve network address

        sa.ipxaddr.sa_family = AF_IPX;
        sa.ipxaddr.sa_socket = 0;

        status = IPX_NameToAddress(NetworkAddress, fUseCache, &sa.ipxaddr);

        if (status == RPC_P_FOUND_IN_CACHE)
            {
            ASSERT(fUseCache);
            fFoundInCache = TRUE;
            status = RPC_S_OK;
            }

        if (status != RPC_S_OK)
            {
            if (status == RPC_P_MATCHED_CACHE)
                {
                status = RPC_S_SERVER_UNAVAILABLE;
                }
            return(status);
            }

        sa.ipxaddr.sa_socket = htons(port);

        // Call common open function

        status = WS_Open(p, 
            &sa, 
            ConnTimeout, 
            SendBufferSize, 
            RecvBufferSize, 
            CallTimeout,
            FALSE       // fHTTP2Open
            );

        if (status == ERROR_RETRY)
            {
            status = RPC_S_SERVER_UNAVAILABLE;
            }

        if (   status == RPC_S_SERVER_UNAVAILABLE
            && fFoundInCache
            && fUseCache )
            {
            fUseCache = FALSE;
            continue;
            }

        break;
        }

    return(status);
}
#endif

#ifdef APPLETALK_ON

/////////////////////////////////////////////////////////////////////
//
// Appletalk data stream protocol (DSP) specific functions
//

RPC_STATUS DSP_GetAppleTalkName(
    OUT CHAR *Buffer
    )
/*++

Routine Description:

    Returns the server's name for appletalk workstations.  This value
    defaults to GetComputerName() but can be changed.  Mail from JameelH:

    By default it is the netbios name of the server. It can be overwritten.
    The new name is at:
    HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\MacFile\Parameters\ServerName.

    By default this value is not present.

Arguments:

    Buffer - Supplies a buffer (at least 33 bytes) for the name.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_RESOURCES - Unable to get the name for some reasons.
--*/
{
    RPC_STATUS Status;
    HKEY hKey;
    DWORD Size = 33;
    DWORD Type;

    Status =
    RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
                RPC_CONST_SSTRING("System\\CurrentControlSet\\Services\\MacFile\\Parameters"),
        0,
        KEY_READ,
        &hKey);

    if (   Status != ERROR_SUCCESS
        && Status != ERROR_FILE_NOT_FOUND )
        {
        ASSERT(0);
        return(RPC_S_OUT_OF_RESOURCES);
        }

    if (Status == ERROR_SUCCESS)
        {

        Status =
        RegQueryValueExA(
            hKey,
            "ServerName",
            0,
            &Type,
            (PBYTE)Buffer,
            &Size);
        }

    (void) RegCloseKey(hKey);
        
    if (   Status != ERROR_SUCCESS
        && Status != ERROR_FILE_NOT_FOUND )
        {
        ASSERT(0);
        return(RPC_S_OUT_OF_RESOURCES);
        }

    if (Status == ERROR_SUCCESS)
        {
        // Found a name in the registry.

        ASSERT(   Type == REG_SZ
               && Size <= 32
               && strlen(Buffer) == (Size + 1));

        return(RPC_S_OK);
        }

    // Not in the registry, must be using the computer name.

    Size = 33;

    if ( GetComputerNameA(
            Buffer,
            &Size ) == FALSE )
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       "GetComputerNameA failed! %d\n",
                       GetLastError()));

        ASSERT(0);
        return(RPC_S_OUT_OF_RESOURCES);
        }

    return(RPC_S_OK);
}


const PCHAR DSP_OBJECTTYPE_PREFIX = "DceDspRpc ";

RPC_STATUS
DSP_ServerListen(
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN RPC_CHAR *NetworkAddress,
    IN OUT RPC_CHAR * *pEndpoint,
    IN UINT PendingQueueSize,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG EndpointFlags,
    IN ULONG NICFlags
    )
/*++

Routine Description:

    This routine allocates a port to receive new client connections.
    If successful a call to COMMON_ServerCompleteListen() will actually allow
    new connection callbacks to the RPC runtime to occur. If the runtime
    is unable to complete then it must abort the address by calling
    WS_ServerAbortListen().

Arguments:

    pAddress - A pointer to the loadable transport interface address.
    pEndpoint - Optionally, the endpoint (port) to listen on. Set to
         to listened port for dynamically allocated endpoints.
    PendingQueueSize - Count to call listen() with.
    EndpointFlags - Meaningless for DSP
    NICFlags - Meaningless for DSP
    SecurityDescriptor - Meaningless for DSP

Return Value:

    RPC_S_OK

    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES
    RPC_S_CANT_CREATE_ENDPOINT
    RPC_S_DUPLICATE_ENDPOINT

--*/
{
    PWS_ADDRESS pAddress = (PWS_ADDRESS)ThisAddress;
    RPC_STATUS status;
    WS_SOCKADDR *sockaddr = &(pAddress->ListenAddr);
    USHORT port;
    CHAR AnsiEndpoint[NBP_MAXIMUM_ENDPOINT];

    pAddress->id = DSP;
    pAddress->NewConnection = WS_NewConnection;
    pAddress->SubmitListen = WS_SubmitAccept;
    SetProtocolMultiplier(pAddress, 1);
    pAddress->pAddressVector = 0;
    pAddress->Endpoint = 0;
    pAddress->QueueSize = PendingQueueSize;
    pAddress->EndpointFlags = EndpointFlags;

    //
    // For DSP the endpoint is a character string.  It is not actually used
    // to allocate the socket.  We let DSP allocate a port and then register
    // the port along with our address and endpoint with NBP.
    //

    if (*pEndpoint)
        {
        // Runtime gave us an endpoint, convert it to ansi
        int nLength;
                *AnsiEndpoint = 0;
        nLength = RpcpStringLength(*pEndpoint);
        if ((nLength <= 0) || (nLength > 22))
            {
            return(RPC_S_INVALID_ENDPOINT_FORMAT);
            }
        PlatformToAnsi(*pEndpoint, AnsiEndpoint);
        pAddress->fDynamicEndpoint = 0;
        }
    else
        {
        static LONG EndpointCount = 0;
        //
        // Create a dynamic endpoint using Use process ID + 16-bit counter.
        //
        *pEndpoint = new RPC_CHAR[7 + 8 + 4 + 1 + 1];
        if (!*pEndpoint)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        CHAR buffer[9];

        strcpy(AnsiEndpoint, "DynEpt ");
        _ltoa(GetCurrentProcessId(), buffer, 16);
        lstrcatA(AnsiEndpoint, buffer);
        buffer[0] = '.';
        LONG t = InterlockedIncrement(&EndpointCount);
        _ltoa( t & 0xFFFF, buffer + 1, 16);
        lstrcatA(AnsiEndpoint, buffer);

        SimpleAnsiToPlatform(AnsiEndpoint, *pEndpoint);
        pAddress->fDynamicEndpoint = 1;
        }

    ASSERT(strlen(AnsiEndpoint) > 0 && strlen(AnsiEndpoint) < NBP_MAXIMUM_ENDPOINT);

    memset(&sockaddr->ataddr, 0, sizeof(WS_SOCKADDR));
    sockaddr->generic.sa_family = WsTransportTable[DSP].AddressFamily;

    // For DSP we always bind to a transport choosen port.  The endpoint
    // only exists in the NBP router as a mapping to our address and port.

    // Create listen socket

    status = WS_ServerListenCommon(pAddress);


    if (status != RPC_S_OK)
        {
        if (status == RPC_P_ADDRESS_FAMILY_INVALID)
            status = RPC_S_PROTSEQ_NOT_SUPPORTED;
        return(status);
        }

    // Now, try to register our name and zone.
    //
    // The final format of the name to register is:
    // <ComputerName>@<Zone>@DceDspRpc <Endpoint>
    //
    // The <ComputerName>@<Zone> string is treated as this machines
    // name as far as the runtime cares.  The <Endpoint> is used as
    // the endpoint.
    //

    CHAR ComputerName[NBP_MAXIMUM_NAME];

    status = DSP_GetAppleTalkName(ComputerName);

    if (status != RPC_S_OK)
        {
        WS_ServerAbortListen(ThisAddress);
        return(status);
        }

// The following code segment is commented out to be consistent with
// what we did in NT4. In NT4, we had a bug where if the AppleTalk name
// registered is just the computer name without the zone name appended.
// In NT5, we achieve the same by commenting out this code which appends
// the zone name.
//

/*
    INT cZone;

    PSZ pszT = ComputerName;
    while(*pszT)
        pszT++;
    *pszT++ = '@';
    cZone = 33;

    // So far we have ComputerName@ and a pointer to just after the @.

    if (getsockopt(pAddress->ListenSocket,
                   SOL_APPLETALK,
                   SO_LOOKUP_MYZONE,
                   pszT,
                   &cZone) != 0)
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "Failed to lookup zone: %d\n",
                       GetLastError()));

        // Don't fail, this could be a small network, just register '*' for
        // the broadcast/local zone.
        *pszT++ = '*';
        *pszT++ = '0';
        }
*/

    //
    // We need to register our computer name and endpoint next.
    //

    WSH_REGISTER_NAME   AtalkNameToRegister;
    int                 length;

    ASSERT(MAX_COMPUTERNAME_LENGTH < MAX_ENTITY + 1);

    length = strlen(AnsiEndpoint);
    memcpy(AtalkNameToRegister.TypeName, DSP_OBJECTTYPE_PREFIX, 10);
    memcpy(AtalkNameToRegister.TypeName + 10, AnsiEndpoint, length);
    AtalkNameToRegister.TypeNameLen = length + 10;

    length = strlen(ComputerName);
    memcpy(AtalkNameToRegister.ObjectName, ComputerName, length);
    AtalkNameToRegister.ObjectNameLen = (char) length;

    AtalkNameToRegister.ZoneName[0] = '*';
    AtalkNameToRegister.ZoneNameLen = 1;

    // Could do a lookup and connect to see if our name is already registered..

    if (setsockopt(
              pAddress->ListenSocket,
              SOL_APPLETALK,
              SO_REGISTER_NAME,
              (char *)&AtalkNameToRegister,
              sizeof(AtalkNameToRegister)
              ) != 0 )
        {
        TransDbgPrint((DPFLTR_RPCPROXY_ID,
                       DPFLTR_WARNING_LEVEL,
                       RPCTRANS "Failed to register name: %d\n",
                       GetLastError()));

        WS_ServerAbortListen(ThisAddress);
        return(RPC_S_CANT_CREATE_ENDPOINT);
        }

    // All done, build out parameters

    ASSERT(length == (int) strlen(ComputerName));

    NETWORK_ADDRESS_VECTOR *pVector;

    pVector =  new(  sizeof(RPC_CHAR *)
                   + (length + 2) * sizeof(RPC_CHAR))
                   NETWORK_ADDRESS_VECTOR;

    if (NULL == pVector)
        {
        WS_ServerAbortListen(ThisAddress);
        return(RPC_S_OUT_OF_MEMORY);
        }

    pVector->Count = 1;
    pVector->NetworkAddresses[0] = (RPC_CHAR*)&pVector->NetworkAddresses[1];

        AnsiToPlatform(ComputerName, pVector->NetworkAddresses[0]);

    pAddress->pAddressVector = pVector;

    return(RPC_S_OK);
}


RPC_STATUS
RPC_ENTRY
DSP_Open(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN RPC_CHAR * ProtocolSequence,
    IN RPC_CHAR * NetworkAddress,
    IN RPC_CHAR * Endpoint,
    IN RPC_CHAR * NetworkOptions,
    IN UINT ConnTimeout,
    IN UINT SendBufferSize,
    IN UINT RecvBufferSize,
    IN void *ResolverHint,
    IN BOOL fHintInitialized,
    IN ULONG CallTimeout,
    IN ULONG AdditionalTransportCredentialsType, OPTIONAL
    IN void *AdditionalCredentials OPTIONAL
    )
/*++

Routine Description:

    Not supported on Windows NT.

--*/
{
    return(RPC_S_PROTSEQ_NOT_SUPPORTED);
}
#endif


RPC_STATUS RPC_ENTRY WS_Abort(IN RPC_TRANSPORT_CONNECTION Connection)
{
    return ((WS_CONNECTION *)Connection)->WS_CONNECTION::Abort();
}

/////////////////////////////////////////////////////////////////////
//
// Transport information definitions
//

const RPC_CONNECTION_TRANSPORT
TCP_TransportInterface =
    {
    RPC_TRANSPORT_INTERFACE_VERSION,
    TCP_TOWER_ID,
    IP_ADDRESS_ID,
    RPC_STRING_LITERAL("ncacn_ip_tcp"),
    "135",
    COMMON_ProcessCalls,

    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,

    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    FALSE,
    WS_GetNetworkAddressVector,
    sizeof(WS_ADDRESS),
    max(sizeof(WS_CLIENT_CONNECTION), sizeof(WS_SAN_CLIENT_CONNECTION)),
    max(sizeof(WS_CONNECTION), sizeof(WS_SAN_CONNECTION)),
    sizeof(CO_SEND_CONTEXT),
    sizeof(TCPResolverHint),
    TCP_MAX_SEND,
    WS_Initialize,
    0,
    TCP_Open,
    0, // No SendRecv on winsock
    WS_SyncRecv,
    WS_Abort,
    WS_Close,
    CO_Send,
    CO_Recv,
    WS_SyncSend,
    WS_TurnOnOffKeepAlives,
    TCP_ServerListen,
    WS_ServerAbortListen,
    COMMON_ServerCompleteListen,
    TCP_QueryClientAddress,
    TCP_QueryLocalAddress,
    TCP_QueryClientId,
    TCP_QueryClientIpAddress,
    0,  // Impersonate
    0,  // Revert
    0,  // FreeResolverHint
    0,  // CopyResolverHint
    0,  // CompareResolverHint
    0   // SetLastBufferToFree
    };

// When the RPC verifier is enabled and we are corrupting client receives,
// we will use a modified transport interface given below.  It will have the sync
// receive members overwritten.
RPC_CONNECTION_TRANSPORT *pTCP_TransportInterface_Avrf = NULL;

#ifdef SPX_ON
const RPC_CONNECTION_TRANSPORT
SPX_TransportInterface =
    {
    RPC_TRANSPORT_INTERFACE_VERSION,
    SPX_TOWER_ID,
    IPX_ADDRESS_ID,
    RPC_STRING_LITERAL("ncacn_spx"),
    "34280",
    COMMON_ProcessCalls,

    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,

    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    FALSE,
    WS_GetNetworkAddressVector,
    sizeof(WS_ADDRESS),
    max(sizeof(WS_CLIENT_CONNECTION), sizeof(WS_SAN_CLIENT_CONNECTION)),
    max(sizeof(WS_CONNECTION), sizeof(WS_SAN_CONNECTION)),
    sizeof(CO_SEND_CONTEXT),
    0,
    SPX_MAX_SEND,
    WS_Initialize,
    0,
    SPX_Open,
    0, // No SendRecv on winsock
    WS_SyncRecv,
    WS_Abort,
    WS_Close,
    CO_Send,
    CO_Recv,
    WS_SyncSend,
    0,  // turn on/off keep alives
    SPX_ServerListen,
    WS_ServerAbortListen,
    COMMON_ServerCompleteListen,
    SPX_QueryClientAddress,
    0, // query local address
    SPX_QueryClientId,
    0,  // query client ip address
    0,  // Impersonate
    0,  // Revert
    0,  // FreeResolverHint
    0,  // CopyResolverHint
    0,  // CompareResolverHint
    0   // SetLastBufferToFree
    };
#endif

#ifdef APPLETALK_ON
const RPC_CONNECTION_TRANSPORT
DSP_TransportInterface =
    {
    RPC_TRANSPORT_INTERFACE_VERSION,
    DSP_TOWER_ID,
    NBP_ADDRESS_ID,
    RPC_STRING_LITERAL("ncacn_at_dsp"),
    "Endpoint Mapper",
    COMMON_ProcessCalls,
    COMMON_StartPnpNotifications,
    COMMON_ListenForPNPNotifications,
    COMMON_TowerConstruct,
    COMMON_TowerExplode,
    COMMON_PostRuntimeEvent,
    FALSE,
    WS_GetNetworkAddressVector,
    sizeof(WS_ADDRESS),
    sizeof(WS_CLIENT_CONNECTION),
    sizeof(WS_CONNECTION),
    sizeof(CO_SEND_CONTEXT),
    0,
    DSP_MAX_SEND,
    WS_Initialize,
    0,
    DSP_Open,  // Not really supported.
    0, // No SendRecv on winsock
    WS_SyncRecv,
    WS_Abort,
    WS_Close,
    CO_Send,
    CO_Recv,
    WS_SyncSend,
    0,  // turn on/off keep alives
    DSP_ServerListen,
    WS_ServerAbortListen,
    COMMON_ServerCompleteListen,
    0,  // DSP_QueryClientAddress,
    0,  // DSP_QueryClientId,
    0,  // query client ip address
    0,  // Impersonate
    0,  // Revert
    0,  // FreeResolverHint
    0,  // CopyResolverHint
    0,  // CompareResolverHint
    0   // SetLastBufferToFree
    };
#endif

const RPC_CONNECTION_TRANSPORT *
WS_TransportLoad (
    IN PROTOCOL_ID index
    )
{
    RPC_STATUS status;

    if (fWinsockLoaded == FALSE)
        {
        if (RPC_WSAStartup() == FALSE)
            {
            return 0;
            }
        fWinsockLoaded = TRUE;
        }

    switch(index)
        {
        case TCP:
            AddressChangeFn = I_RpcServerInqAddressChangeFn();

            if (AddressChangeFn)
                {
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "TCP address change function has been loaded"));
                }

            if (DoFirewallInit())
                {
                // Overwrite the SyncSendRecv and SyncRecv members of the transport interfaces if the
                // RPC verifier is enabled.
                if (gfRpcVerifierCorruptionInjectClientReceives)
                    {
                    // Check if we have previously initialized the Avrf transport interface.
                    if (pTCP_TransportInterface_Avrf == NULL)
                        {
                        // Allocate a transport interface structure to override the default.
                        pTCP_TransportInterface_Avrf = new (RPC_CONNECTION_TRANSPORT);
                        if (pTCP_TransportInterface_Avrf == NULL)
                            {
                            return NULL;
                            }
                        // Initialize the Avrf transport interface with the default values.
                        RpcpMemoryCopy(pTCP_TransportInterface_Avrf,
                                       &TCP_TransportInterface,
                                       sizeof(RPC_CONNECTION_TRANSPORT));
                        // Override the interface function for sync receive.
                        ASSERT(pTCP_TransportInterface_Avrf->SyncRecv == WS_SyncRecv);
                        pTCP_TransportInterface_Avrf->SyncRecv = WS_SyncRecv_Avrf;
                        }
                    return(pTCP_TransportInterface_Avrf);
                    }

                return(&TCP_TransportInterface);
                }
            break;

#ifdef SPX_ON
        case SPX:
            AddressChangeFn = I_RpcServerInqAddressChangeFn();

            if (AddressChangeFn)
                {
                TransDbgPrint((DPFLTR_RPCPROXY_ID,
                               DPFLTR_WARNING_LEVEL,
                               RPCTRANS "SPX address change function has been loaded"));
                }

            if (InitializeIpxNameCache() != RPC_S_OK)
                {
                return(0);
                }
            return(&SPX_TransportInterface);
#endif

#ifdef APPLETALK_ON
        case DSP:
            return(&DSP_TransportInterface);
#endif

        case HTTP:
    	    if (DoFirewallInit())
                {
                return(&HTTP_TransportInterface);
    	        }
	        break;

        default:
            TransDbgPrint((DPFLTR_RPCPROXY_ID,
                           DPFLTR_WARNING_LEVEL,
                           RPCTRANS "WS_TransportLoad called with index: %d\n",
                           index));

            ASSERT(0);
        }

    return(0);
}

RPC_STATUS SAN_CONNECTION::SANReceive(HANDLE hFile, LPVOID lpBuffer,
                                  DWORD nNumberOfBytesToRead,
                                  LPDWORD lpNumberOfBytesRead,
                                  LPOVERLAPPED lpOverlapped)
{
    WSABUF wsaBuf;
    int nResult;

    wsaBuf.len = nNumberOfBytesToRead;
    wsaBuf.buf = (char *)lpBuffer;
    m_dwFlags = 0;

    nResult = WSARecv((SOCKET)hFile, &wsaBuf, 1, lpNumberOfBytesRead, &m_dwFlags,
            lpOverlapped, NULL);
    if (nResult == SOCKET_ERROR)
        return WSAGetLastError();
    else
        return RPC_S_OK;
}

RPC_STATUS SAN_CONNECTION::SANSend(HANDLE hFile, LPCVOID lpBuffer,
                               DWORD nNumberOfBytesToWrite,
                               LPDWORD lpNumberOfBytesWritten,
                               LPOVERLAPPED lpOverlapped)
{
    WSABUF wsaBuf;
    int nResult;
    wsaBuf.len = nNumberOfBytesToWrite;
    wsaBuf.buf = (char *)lpBuffer;

    nResult = WSASend((SOCKET)hFile, &wsaBuf, 1, lpNumberOfBytesWritten, 0,
        lpOverlapped, NULL);

    if (nResult == SOCKET_ERROR)
        return WSAGetLastError();
    else
        return RPC_S_OK;
}

RPC_STATUS WS_CONNECTION::Receive(HANDLE hFile, LPVOID lpBuffer,
                                  DWORD nNumberOfBytesToRead,
                                  LPDWORD lpNumberOfBytesRead,
                                  LPOVERLAPPED lpOverlapped)
{
    return UTIL_ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
}

RPC_STATUS WS_CONNECTION::Send(HANDLE hFile, LPCVOID lpBuffer,
                               DWORD nNumberOfBytesToWrite,
                               LPDWORD lpNumberOfBytesWritten,
                               LPOVERLAPPED lpOverlapped)
{
    return UTIL_WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
}

void
RPC_CLIENT_PROCESS_IDENTIFIER::SetIPv6ClientIdentifier (
    IN void *Buffer,
    IN size_t BufferSize,
    IN BOOL fLocal)
/*++

Routine Description:

    IPv6 servers can use this to store their IP address in
    the client identifier.

Arguments:

    Buffer - the buffer with the client identifier
    BufferSize - the size of the data in buffer
    fLocal - TRUE if the client is guaranteed to be Local. False otherwise.

Return Value:


--*/
{
    SOCKADDR_IN6 *IPv6Address;
    ASSERT(BufferSize >= sizeof(SOCKADDR_IN6));

    this->fLocal = fLocal;
    RpcpMemoryCopy(u.ULongClientId, Buffer, sizeof(SOCKADDR_IN6));
    IPv6Address = (SOCKADDR_IN6 *)u.ULongClientId;
    IPv6Address->sin6_port = 0;
    IPv6Address->sin6_flowinfo = 0;
    IPv6Address->sin6_scope_id = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\rpcproxy\ecblist.c ===
//--------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  ecblist.c
//
//  Simple hash table support for keeping a list of active ECBs.
//
//  History:
//
//    Edward Reus   12-08-97   Initial Version.
//    Edward Reus   03-01-2000 Convert to hash table.
//--------------------------------------------------------------------

#include <sysinc.h>
#include <rpc.h>
#include <winsock2.h>
#include <httpfilt.h>

#include <httpext.h>
#include "ecblist.h"
#include "filter.h"

//--------------------------------------------------------------------
// InitializeECBList()
//
// Create an empty ECB list. If the list is successfully created,
// the return a pointer to it, else return NULL.
//
// This will fail (return FALSE) if either the memory allocation
// for the list failed, or if the initialization of a critical
// section for the list failed.
//--------------------------------------------------------------------
ACTIVE_ECB_LIST *InitializeECBList()
    {
    int    i;
    DWORD  dwStatus;
    DWORD  dwSpinCount = 0x80000008;  // Preallocate event, spincount is 4096.
    ACTIVE_ECB_LIST *pECBList;
 
    pECBList = MemAllocate(sizeof(ACTIVE_ECB_LIST));
    if (!pECBList)
       {
       return NULL;
       }

    memset(pECBList,0,sizeof(ACTIVE_ECB_LIST));
 
    dwStatus = RtlInitializeCriticalSectionAndSpinCount(&pECBList->cs,dwSpinCount);
    if (dwStatus != 0)
       {
       MemFree(pECBList);
       return NULL;
       }

    for (i=0; i<HASH_SIZE; i++)
       {
       InitializeListHead( &(pECBList->HashTable[i]) );
       }
 
    return pECBList;
    }

//--------------------------------------------------------------------
// EmptyECBList()
//
// Return true iff the ECB list holds at least one active ECB.
//--------------------------------------------------------------------
BOOL EmptyECBList( IN ACTIVE_ECB_LIST *pECBList )
    {
    ASSERT(pECBList);

    return (pECBList->dwNumEntries > 0);
    }

//--------------------------------------------------------------------
// InternalLookup()
//
// Do a non-protected lookup for the specified ECB. If its found, then
// return a pointer to its ECB_ENTRY, else return NULL.
//--------------------------------------------------------------------
ECB_ENTRY *InternalLookup( IN ACTIVE_ECB_LIST *pECBList,
                           IN EXTENSION_CONTROL_BLOCK *pECB )
    {
    DWORD       dwHash;
    LIST_ENTRY *pHead;
    LIST_ENTRY *pListEntry;
    ECB_ENTRY  *pECBEntry;

    dwHash = ECB_HASH(pECB);

    pHead = &(pECBList->HashTable[dwHash]);
    pListEntry = pHead->Flink;

    while (pListEntry != pHead)
        {
        pECBEntry = CONTAINING_RECORD(pListEntry,ECB_ENTRY,ListEntry);
        if (pECB == pECBEntry->pECB)
            {
            return pECBEntry;
            }

        pListEntry = pListEntry->Flink;
        }

    return NULL;
    }

//--------------------------------------------------------------------
// LookupInECBList()
//
// Look for the specified extension control block (pECB) on the
// list of active ECBs. If its found, then return a pointer to it.
// If its not found then return NULL.
//--------------------------------------------------------------------
EXTENSION_CONTROL_BLOCK *LookupInECBList(
                                 IN ACTIVE_ECB_LIST *pECBList,
                                 IN EXTENSION_CONTROL_BLOCK *pECB )
    {
    DWORD       dwStatus;
    ECB_ENTRY  *pECBEntry;
    EXTENSION_CONTROL_BLOCK *pRet = NULL;

    ASSERT(pECBList);
    ASSERT(pECB);

    if (pECBList->dwNumEntries == 0)
        {
        return NULL;
        }

    dwStatus = RtlEnterCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);

    pECBEntry = InternalLookup(pECBList,pECB);
    if (pECBEntry)
        {
        pRet = pECB;
        }
 
    dwStatus = RtlLeaveCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);
 
    return pRet;
    }

//--------------------------------------------------------------------
// AddToECBList()
//
// Add the specified extension control block (pECB) to the list
// of active ECBs. If the ECB is already in the list of active ECBs
// then return success (already added).
//
// Return TRUE on success, FALSE on failure.
//--------------------------------------------------------------------
BOOL   AddToECBList( IN ACTIVE_ECB_LIST *pECBList,
                     IN EXTENSION_CONTROL_BLOCK *pECB )
    {
    DWORD      dwStatus;
    DWORD      dwHash;
    ECB_ENTRY *pECBEntry;

    ASSERT(pECBList);
    ASSERT(pECB);

    dwStatus = RtlEnterCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);
 
    //
    // Check to see if the ECB is alreay on the list...
    //
    pECBEntry = InternalLookup(pECBList,pECB);
    if (pECBEntry)
       {
       #ifdef DBG_ERROR
       DbgPrint("RpcProxy: AddToECBList(): pECB (0x%p) already in list\n",pECB);
       #endif
       dwStatus = RtlLeaveCriticalSection(&pECBList->cs);
       ASSERT(dwStatus == 0);
       return TRUE;
       }
 
    //
    // Make up a new ECB entry:
    //
    pECBEntry = MemAllocate(sizeof(ECB_ENTRY));
    if (!pECBEntry)
       {
       dwStatus = RtlLeaveCriticalSection(&pECBList->cs);
       ASSERT(dwStatus == 0);

       return FALSE;
       }
 
    pECBEntry->lRefCount = 1;   // Take the first reference...
    pECBEntry->dwTickCount = 0; // Set when connection is closed.
    pECBEntry->pECB = pECB;     // Cache the Extension Control Block.

    dwHash = ECB_HASH(pECB);
 
    InsertHeadList( &(pECBList->HashTable[dwHash]),
                    &(pECBEntry->ListEntry) );

    pECBList->dwNumEntries++;

    dwStatus = RtlLeaveCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);
 
    return TRUE;
    }

//--------------------------------------------------------------------
//  IncrementECBRefCount()
//
//  Find the specified ECB in the list and increment its refcount.
//  Return TRUE if its found, FALSE if it isn't on the list.
//
//  Note: That the RefCount shouldn't go over 2 (or less than 0).
//--------------------------------------------------------------------
BOOL IncrementECBRefCount( IN ACTIVE_ECB_LIST *pECBList,
                           IN EXTENSION_CONTROL_BLOCK *pECB )
    {
    DWORD      dwStatus;
    DWORD      dwHash;
    ECB_ENTRY *pECBEntry;

    ASSERT(pECBList);
    ASSERT(pECB);

    dwStatus = RtlEnterCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);

    //
    // Look for the ECB:
    //
    pECBEntry = InternalLookup(pECBList,pECB);
    if (pECBEntry)
        {
        pECBEntry->lRefCount++;
        }

    dwStatus = RtlLeaveCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);
    return (pECBEntry != NULL);
    }

//--------------------------------------------------------------------
//  DecrementECBRefCount()
//
//  Look for the specified ECB in the list and if found, decrement its
//  refcount. If the RefCount falls to zero, then remove it from the 
//  list and return it. If the refcount is greater than zero (or the
//  ECB wasn't on the lsit) then return NULL.
//--------------------------------------------------------------------
EXTENSION_CONTROL_BLOCK *DecrementECBRefCount(
                            IN ACTIVE_ECB_LIST *pECBList,
                            IN EXTENSION_CONTROL_BLOCK *pECB )
    {
    DWORD      dwStatus;
    ECB_ENTRY *pECBEntry;
    EXTENSION_CONTROL_BLOCK *pRet = NULL;

    ASSERT(pECBList);
    ASSERT(pECB);

    dwStatus = RtlEnterCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);

    //
    // Look for the ECB:
    //
    pECBEntry = InternalLookup(pECBList,pECB);
    if (pECBEntry)
        {
        pECBEntry->lRefCount--;
        ASSERT(pECBEntry->lRefCount >= 0);

        if (pECBEntry->lRefCount <= 0)
            {
            RemoveEntryList( &(pECBEntry->ListEntry) );
            pRet = pECBEntry->pECB;
            MemFree(pECBEntry);
            pECBList->dwNumEntries--;
            }
        }

    dwStatus = RtlLeaveCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);
    return pRet;
    }

//--------------------------------------------------------------------
// LookupRemoveFromECBList()
//
// Look for the specified extension control block (pECB) on the
// list of active ECBs. If its found, then remove it from the active
// list and return a pointer to it. If its not found then return
// NULL.
//--------------------------------------------------------------------
EXTENSION_CONTROL_BLOCK *LookupRemoveFromECBList(
                             IN ACTIVE_ECB_LIST *pECBList,
                             IN EXTENSION_CONTROL_BLOCK *pECB )
    {
    DWORD      dwStatus;
    ECB_ENTRY *pECBEntry;
    EXTENSION_CONTROL_BLOCK *pRet = NULL;

    ASSERT(pECBList);
    ASSERT(pECB);

    dwStatus = RtlEnterCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);

    //
    // Look for the ECB:
    //
    pECBEntry = InternalLookup(pECBList,pECB);
    if (pECBEntry)
        {
        RemoveEntryList( &(pECBEntry->ListEntry) );
        MemFree(pECBEntry);
        pECBList->dwNumEntries--;
        pRet = pECB;
        }

    dwStatus = RtlLeaveCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);
    return pRet;
    }

#ifdef DBG
//--------------------------------------------------------------------
// CountBucket()
//
// Helper used by CheckECBHashBalance() to count the number of entries
// in a hast table bucket.
//--------------------------------------------------------------------
int CountBucket( IN LIST_ENTRY *pBucket )
    {
    int iCount = 0;
    LIST_ENTRY *p = pBucket->Flink;

    while (p != pBucket)
        {
        iCount++;
        p = p->Flink;
        }
    return iCount;
    }
//--------------------------------------------------------------------
// CheckECBHashBalance()
//
// DBG code to walk through the hash table and inspect the hash buckets
// for collisions. A will balanced hash table will have a nice uniform 
// distribution of entries spread throughout the hash buckets in the
// hash table.
//--------------------------------------------------------------------
void CheckECBHashBalance( IN ACTIVE_ECB_LIST *pECBList )
    {
    #define ICOUNTS                    7
    #define ILAST                     (ICOUNTS-1)
    #define TOO_MANY_COLLISIONS_POINT  3
    int  i;
    int  iCount;
    int  iHashCounts[ICOUNTS];
    BOOL fAssert = FALSE;

    memset(iHashCounts,0,sizeof(iHashCounts));

    for (i=0; i<HASH_SIZE; i++)
        {
        iCount = CountBucket( &(pECBList->HashTable[i]) );
        if (iCount < ILAST)
            {
            iHashCounts[iCount]++;
            }
        else
            {
            iHashCounts[ILAST]++;
            }
        }

    DbgPrint("CheckECBHashBalance():\n");
    for (i=0; i<ICOUNTS; i++)
        {
        DbgPrint("  Buckets with %d entries: %d\n",i,iHashCounts[i]);
        if ((i>=TOO_MANY_COLLISIONS_POINT)&&(iHashCounts[i] > 0))
            {
            fAssert = TRUE;
            }
        }

    ASSERT(fAssert == FALSE);
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\rpcproxy\ecblist.h ===
//--------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  ecblist.h
//
//  Simple rountines to keep a list of the active ISAPI ECBs.
//--------------------------------------------------------------------

#ifndef _ECBLIST_H
#define _ECBLIST_H

//--------------------------------------------------------------------
//  ACTIVE_ECB_LIST is the list (hashed) of currently active
//  Extension Control Blocks. There is one ECB_ENTRY for each
//  currently active ECB the RpcProxy.dll is managing.
//--------------------------------------------------------------------

//  HASH_SIZE should be a prime number.
#define   HASH_SIZE  991
#define   ECB_HASH(pointer)  (((UINT_PTR)pointer)%HASH_SIZE)

typedef struct _ECB_ENTRY
   {
     LIST_ENTRY   ListEntry;    // Linked list of hash collisions.
     LONG         lRefCount;    // Refcount for ECBs.
     DWORD        dwTickCount;  // For ECB age
     EXTENSION_CONTROL_BLOCK *pECB;
   } ECB_ENTRY;


typedef struct _ACTIVE_ECB_LIST
   {
   RTL_CRITICAL_SECTION  cs;
   DWORD                 dwNumEntries;
   LIST_ENTRY            HashTable[HASH_SIZE]; // List heads for the hash.
   } ACTIVE_ECB_LIST;

//--------------------------------------------------------------------
//
//--------------------------------------------------------------------

extern ACTIVE_ECB_LIST *InitializeECBList();

extern BOOL   EmptyECBList( IN ACTIVE_ECB_LIST *pECBList );

extern BOOL   AddToECBList( IN ACTIVE_ECB_LIST *pECBList,
                            IN EXTENSION_CONTROL_BLOCK *pECB );

extern BOOL   IncrementECBRefCount( IN ACTIVE_ECB_LIST *pECBList,
                                    IN EXTENSION_CONTROL_BLOCK *pECB );

extern EXTENSION_CONTROL_BLOCK *DecrementECBRefCount(
                                    IN ACTIVE_ECB_LIST *pECBList,
                                    IN EXTENSION_CONTROL_BLOCK *pECB );

extern EXTENSION_CONTROL_BLOCK *LookupInECBList(
                                    IN ACTIVE_ECB_LIST *pECBList,
                                    IN EXTENSION_CONTROL_BLOCK *pECB );

extern EXTENSION_CONTROL_BLOCK *LookupRemoveFromECBList(
                                    IN ACTIVE_ECB_LIST *pECBList,
                                    IN EXTENSION_CONTROL_BLOCK *pECB );

#ifdef DBG
extern void   CheckECBHashBalance( IN ACTIVE_ECB_LIST *pECBList );
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\rpcproxy\filter.c ===
//-----------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  filter.c
//
//  IIS Filter is the front end of the RpcProxy for HTTP over RPC.
//
//
//  History:
//
//    Edward Reus   00-00-97   Initial Version.
//-----------------------------------------------------------------

#define  FD_SETSIZE   1

#include <sysinc.h>
#include <mbstring.h>
#include <rpc.h>
#include <rpcdce.h>
#include <winsock2.h>
#include <httpfilt.h>
#include <httpext.h>
#include <ecblist.h>
#include <filter.h>
#include <olist.h>
#include <registry.h>

//-----------------------------------------------------------------
//  Globals:
//-----------------------------------------------------------------

#ifdef DBG_COUNTS
int g_iSocketCount = 0;
int g_iSessionCount = 0;
#endif

SERVER_INFO *g_pServerInfo = NULL;

BOOL g_fIsIIS6 = TRUE;

BOOL fIsIISInCompatibilityMode = FALSE;
ULONG IISConnectionTimeout = 0;

#define      MAX_NUM_LEN       20

//-----------------------------------------------------------------
// GetFilterVersion()
//
//-----------------------------------------------------------------
BOOL WINAPI GetFilterVersion( HTTP_FILTER_VERSION *pVer )
{
    BOOL Result;

   // Fillout filter information:
   pVer->dwServerFilterVersion = HTTP_FILTER_REVISION;
   pVer->dwFilterVersion = HTTP_FILTER_REVISION;

   lstrcpy(pVer->lpszFilterDesc,FILTER_DESCRIPTION);

   Result = InitializeGlobalDataStructures(
       TRUE     // IsFromFilter
       );

   if (Result)
       {
       if (fIsIISInCompatibilityMode)
           {
           pVer->dwFlags = SF_NOTIFY_ORDER_LOW
                         | SF_NOTIFY_READ_RAW_DATA
                         | SF_NOTIFY_END_OF_NET_SESSION
                         | SF_NOTIFY_PREPROC_HEADERS;
           }
       else
           {
           // in compatibility mode we're not interested in
           // any notifications
           pVer->dwFlags = 0;
           }
       }

   return Result;
}

BOOL InitializeGlobalDataStructures (
    IN BOOL IsFromFilter
    )
{
    BOOL Result;
    WSADATA  wsaData;
    DWORD    dwStatus;
    DWORD    dwSize;
    RPC_STATUS RpcStatus;

    Result = UpdateIsIISInCompatibilityMode();

    if (Result == FALSE)
        return Result;

    if (IsFromFilter)
        {
        // we don't want to continue with initialization if we are
        // not in compatibility mode. In new mode we only need
        // the ISAPI extension, and it will initialize what it needs
        if (fIsIISInCompatibilityMode == FALSE)
            return TRUE;
        }

    RpcStatus = GetIISConnectionTimeout(&IISConnectionTimeout);
    if (RpcStatus != RPC_S_OK)
        return FALSE;

   // Initialize Winsock:
   if (WSAStartup(WSA_VERSION,&wsaData) == SOCKET_ERROR)
      {
      #ifdef DBG_ERROR
      DbgPrint("GetFilterVersion(): WSAStartup() failed: Error: %d\n",WSAGetLastError());
      #endif
      return FALSE;
      }

   //
   // Initialize a save list of SERVER_OVERLAPPED structures
   // that is used to pass connection data between the filter
   // and ISAPI:
   //
   if (!InitializeOverlappedList())
      {
      // If this guy failed, then a critical section failed to
      // initialize, should be very very rare...
      return FALSE;
      }

   //
   // Create the server info data structure and create events
   // used to register and unregister the socket events:
   //
   g_pServerInfo = (SERVER_INFO*)MemAllocate(sizeof(SERVER_INFO));
   if (!g_pServerInfo)
      {
      // Out of memory...
      FreeServerInfo(&g_pServerInfo);
      return FALSE;
      }

   memset(g_pServerInfo,0,sizeof(SERVER_INFO));

   g_pServerInfo->pszLocalMachineName = (char*)MemAllocate(1+MAX_COMPUTERNAME_LENGTH);
   if (!g_pServerInfo->pszLocalMachineName)
      {
      FreeServerInfo(&g_pServerInfo);
      return FALSE;
      }

   dwSize = 1+MAX_COMPUTERNAME_LENGTH;
   if (  (!GetComputerName(g_pServerInfo->pszLocalMachineName,&dwSize))
      || (!HttpProxyCheckRegistry())
      || (dwStatus = RtlInitializeCriticalSection(&g_pServerInfo->cs))
      || (dwStatus = RtlInitializeCriticalSection(&g_pServerInfo->csFreeOverlapped)) )
      {
      FreeServerInfo(&g_pServerInfo);
      return FALSE;
      }

   dwSize = 1+MAX_COMPUTERNAME_LENGTH;
   if (!(g_pServerInfo->hIoCP = CreateIoCompletionPort(INVALID_HANDLE_VALUE,NULL,0,0)) )
      {
      FreeServerInfo(&g_pServerInfo);
      return FALSE;
      }

   //
   // Initialize a list of the active and inactive ECBs
   //
   g_pServerInfo->pActiveECBList = InitializeECBList();
   if (!g_pServerInfo->pActiveECBList)
      {
      FreeServerInfo(&g_pServerInfo);
      return FALSE;
      }

    return TRUE;
}


//-----------------------------------------------------------------
// HttpFilterProc()
//
//-----------------------------------------------------------------
DWORD WINAPI HttpFilterProc( HTTP_FILTER_CONTEXT *pFC,
                             DWORD  dwNotificationType,
                             VOID  *pvNotification     )
{
   DWORD  dwFilterStatus = SF_STATUS_REQ_NEXT_NOTIFICATION;
   DWORD  dwStatus = 0;
   DWORD  dwSize;
   unsigned char      szPort[HTTP_PORT_STR_SIZE];
   SERVER_CONNECTION *pConn;
   SERVER_OVERLAPPED *pOverlapped;

   switch (dwNotificationType)
      {
      case SF_NOTIFY_READ_RAW_DATA:
         if (pFC->pFilterContext)
            {
            // Existing connection if we have already set up the filter context.
            pConn = pFC->pFilterContext;
            #if FALSE
            if (pConn->Socket == INVALID_SOCKET)
               {
               dwFilterStatus = SF_STATUS_REQ_FINISHED;
               }
            else
               {
               dwFilterStatus = SF_STATUS_REQ_NEXT_NOTIFICATION;
               }
            #else

            if ( g_fIsIIS6 )
            {
               //
               // We'll need to chunk the entity ourselves
               //

               if ( !ChunkEntity(pConn,(HTTP_FILTER_RAW_DATA*)pvNotification))
               {
                  dwFilterStatus = SF_STATUS_REQ_FINISHED;
               }
               else
               {
                  dwFilterStatus = SF_STATUS_REQ_NEXT_NOTIFICATION;
               }
            }
            else
            {
               dwFilterStatus = SF_STATUS_REQ_NEXT_NOTIFICATION;
            }
            #endif
            }
         else if ( (g_pServerInfo->dwEnabled)
                   && (pConn = IsNewConnect(pFC,(HTTP_FILTER_RAW_DATA*)pvNotification,&dwStatus)) )
            {
            // Establish a new connection between client and server.

            // For overlapped server reads:
            pOverlapped = AllocOverlapped();
            if (!pOverlapped)
               {
               #ifdef DBG_ERROR
               DbgPrint("HttpFilterProc(): AllocOverlapped() failed: %d\n",dwStatus);
               #endif
               // dwStatus = HttpReplyToClient(pFC,STATUS_CONNECTION_FAILED_STR);
               SetLastError(STATUS_CONNECTION_FAILED);
               dwFilterStatus = SF_STATUS_REQ_FINISHED;
               break;
               }

            // AddRef the SERVER_CONNECTION pConn since it is in
            // several data structures.
            pOverlapped->pConn = pConn;
            pOverlapped->fIsServerSide = TRUE;
            AddRefConnection(pConn);

            // Do machine name resolution:
            if (  (!ResolveMachineName(pConn,&dwStatus))
               || (!HttpProxyIsValidMachine(g_pServerInfo,pConn->pszMachine,pConn->pszDotMachine,pConn->dwPortNumber))
               || (!ConnectToServer(pFC,&dwStatus))
               || (!ConvertVerbToPost(pFC,(HTTP_FILTER_RAW_DATA*)pvNotification,pOverlapped))
               || (!SetupIoCompletionPort(pFC,g_pServerInfo,&dwStatus)) )
               {
               // dwStatus = HttpReplyToClient(pFC,STATUS_CONNECTION_FAILED_STR);
               FreeOverlapped(pOverlapped);
               FreeServerConnection(pConn);
               pFC->pFilterContext = NULL;

               // Was SF_STATUS_REQ_FINISHED... Now use SF_STATU_REQ_ERROR to have IIS return
               // the error status...
               SetLastError(STATUS_CONNECTION_FAILED);
               dwFilterStatus = SF_STATUS_REQ_ERROR;
               break;
               }

            // Reply Ok to client:
            // dwStatus = HttpReplyToClient(pFC,STATUS_CONNECTION_OK_STR);

            #ifdef DBG_ERROR
            if (dwStatus)
               {
               DbgPrint("HttpFilterProc(): ReplyToClient() failed: %d\n",dwStatus);
               }
            #endif
            dwFilterStatus = SF_STATUS_REQ_NEXT_NOTIFICATION;
            }
         else
            {
            // Data isn't for me, pass it on:
            dwFilterStatus = SF_STATUS_REQ_NEXT_NOTIFICATION;
            }
         break;

      case SF_NOTIFY_END_OF_NET_SESSION:
         if (pFC->pFilterContext)
            {
            // Connection with client was closed, so close
            // the connection with the server:
            dwStatus = EndOfSession(g_pServerInfo,pFC);

            dwFilterStatus = SF_STATUS_REQ_FINISHED;
            }
         else
            {
            // Not our problem, so do nothing...
            dwFilterStatus = SF_STATUS_REQ_NEXT_NOTIFICATION;
            }
         break;

      case SF_NOTIFY_PREPROC_HEADERS:
         // We don't want anyone to directly access the RPC ISAPI, so
         // we'll look for a direct access attempt here:
         if (IsDirectAccessAttempt(pFC,pvNotification))
            {
            dwFilterStatus = SF_STATUS_REQ_FINISHED;
            }
         else
            {
            dwFilterStatus = SF_STATUS_REQ_NEXT_NOTIFICATION;
            }
         break;

      default:
         #ifdef DBG_ERROR
            DbgPrint("HttpFilterProc(): Unexpected notification: %d\n",
                     dwNotificationType );
         #endif
         dwFilterStatus = SF_STATUS_REQ_NEXT_NOTIFICATION;
         break;
      }

   return dwFilterStatus;
}

//-----------------------------------------------------------------------------
//  FreeIpAddressList()
//
//-----------------------------------------------------------------------------
void FreeIpAddressList( char **ppszDotMachineList )
    {
    char **ppsz = ppszDotMachineList;

    if (ppsz)
       {
       while (*ppsz)
          {
          MemFree(*ppsz);
          ppsz++;
          }

       MemFree(ppszDotMachineList);
       }
    }

//-----------------------------------------------------------------------------
//  FreeServerInfo()
//
//-----------------------------------------------------------------------------
void FreeServerInfo( SERVER_INFO **ppServerInfo )
   {
   char       **ppszDot;
   DWORD        dwStatus;
   SERVER_INFO *pServerInfo = *ppServerInfo;

   if (pServerInfo)
      {
      // The name of this machine (local name):
      if (pServerInfo->pszLocalMachineName)
         {
         MemFree(pServerInfo->pszLocalMachineName);
         }

      // The list if the valid ports (read from the registry):
      if (pServerInfo->pValidPorts)
         {
         HttpFreeValidPortList(pServerInfo->pValidPorts);
         }

      dwStatus = RtlDeleteCriticalSection(&g_pServerInfo->cs);

      dwStatus = RtlDeleteCriticalSection(&g_pServerInfo->csFreeOverlapped);

      if (pServerInfo->hIoCP)
         {
         CloseHandle(pServerInfo->hIoCP);
         }

      MemFree(pServerInfo);
      }

   UninitializeOverlappedList();

   *ppServerInfo = NULL;
   }

//-----------------------------------------------------------------------------
//  DwToHexAnsi()
//
//  Convert a DWORD number to an ANSI HEX string.
//-----------------------------------------------------------------------------
DWORD DwToHexAnsi( IN     DWORD dwVal, 
                   IN OUT char *pszNumBuff,
                   IN     DWORD dwLen        )
{
   NTSTATUS NtStatus = RtlIntegerToChar(dwVal,16,dwLen,pszNumBuff);

   if (!NT_SUCCESS(NtStatus))
       {
       pszNumBuff[0] = '0';
       pszNumBuff[1] = 0;
       dwLen = 1;
       }
   else
       {
       dwLen = strlen(pszNumBuff);
       }

   return dwLen;
}

//-----------------------------------------------------------------------------
//  AnsiHexToDWORD()
//
//  Convert the string HEX number in pszNum into a DWORD and return it in
//  *pdwNum. If the conversion fails, then return NULL, else advance the
//  string pointer past the number and return it (pszNum).
//-----------------------------------------------------------------------------
unsigned char *AnsiHexToDWORD( unsigned char *pszNum,
                               DWORD         *pdwNum,
                               DWORD         *pdwStatus )
{
   DWORD dwNum = 0;
   DWORD dwDigitCount = 0;
   NTSTATUS NtStatus;

   *pdwNum = *pdwStatus = 0;

   // Skip over any leading spaces:
   while (*pszNum == CHAR_SPACE)
      {
      pszNum++;
      }

   NtStatus = RtlCharToInteger( pszNum, 16, &dwNum );

   if (!NT_SUCCESS(NtStatus))
       {
       *pdwStatus = ERROR_INVALID_DATA;
       return NULL;
       }

   *pdwNum = dwNum;

   return pszNum;
}

//-----------------------------------------------------------------
//  AllocOverlapped()
//
//-----------------------------------------------------------------
SERVER_OVERLAPPED *AllocOverlapped()
{
   DWORD  dwStatus;
   SERVER_OVERLAPPED *pOverlapped;

   dwStatus = RtlEnterCriticalSection(&g_pServerInfo->csFreeOverlapped);
   if (dwStatus)
      {
      #ifdef DBG_ERROR
      DbgPrint("AllocOverlapped(): RtlEnterCriticalSection() failed: %d\n",
               dwStatus);
      #endif
      return NULL;
      }

   if (g_pServerInfo->pFreeOverlapped)
      {
      pOverlapped = g_pServerInfo->pFreeOverlapped;

      g_pServerInfo->pFreeOverlapped = pOverlapped->pNext;

      if (!g_pServerInfo->pFreeOverlapped)
         {
         g_pServerInfo->pLastOverlapped = NULL;
         ASSERT(g_pServerInfo->dwFreeOverlapped == 1); // Hasn't been decremented yet...
         }

      g_pServerInfo->dwFreeOverlapped--;

      dwStatus = RtlLeaveCriticalSection(&g_pServerInfo->csFreeOverlapped);
      ASSERT(dwStatus == 0);

      pOverlapped->Internal = 0;
      pOverlapped->InternalHigh = 0;
      pOverlapped->Offset = 0;
      pOverlapped->OffsetHigh = 0;
      pOverlapped->hEvent = 0;
      pOverlapped->pNext = NULL;
      pOverlapped->pECB = NULL;
      pOverlapped->pConn = NULL;
      }
   else
      {
      dwStatus = RtlLeaveCriticalSection(&g_pServerInfo->csFreeOverlapped);
      ASSERT(dwStatus == 0);

      pOverlapped = (SERVER_OVERLAPPED*)MemAllocate(sizeof(SERVER_OVERLAPPED));
      if (pOverlapped)
         {
         memset(pOverlapped,0,sizeof(SERVER_OVERLAPPED));
         }
      else
         {
         // Memory allocation failed:
         #ifdef DBG_ERROR
         DbgPrint("AllocOverlapped(): Allocation of SERVER_OVERLAPPED failed.\n");
         #endif
         }
      }

   #ifdef TRACE_MALLOC
   DbgPrint("AllocOverlapped(): pOverlapped: 0x%x\n",pOverlapped);
   #endif

   return pOverlapped;
}

//-----------------------------------------------------------------
//  FreeOverlapped()
//
//-----------------------------------------------------------------
SERVER_OVERLAPPED *FreeOverlapped( SERVER_OVERLAPPED *pOverlapped )
{
   int                      iRet;
   DWORD                    dwStatus;
   EXTENSION_CONTROL_BLOCK *pECB;
   SERVER_CONNECTION       *pConn = pOverlapped->pConn;
   SOCKET                   Socket;


   #ifdef TRACE_MALLOC
   DbgPrint("FreeOverlapped(): pOverlapped: 0x%x pConn: 0x%x\n",
            pOverlapped, pConn );
   #endif

   if (pConn)
      {
      pOverlapped->pConn = NULL;
      FreeServerConnection(pConn);
      }

   if (pECB=pOverlapped->pECB)
      {
      pOverlapped->pECB = NULL;
      CloseClientConnection( pECB );
      }


   dwStatus = RtlEnterCriticalSection(&g_pServerInfo->csFreeOverlapped);
   ASSERT(dwStatus == 0);

   if (g_pServerInfo->dwFreeOverlapped < MAX_FREE_OVERLAPPED)
      {
      if (!g_pServerInfo->pFreeOverlapped)
         {
         g_pServerInfo->pFreeOverlapped = pOverlapped;
         g_pServerInfo->pLastOverlapped = pOverlapped;
         }
      else
         {
         pOverlapped->pNext = NULL;
         g_pServerInfo->pLastOverlapped->pNext = pOverlapped;
         g_pServerInfo->pLastOverlapped = pOverlapped;
         }

      g_pServerInfo->dwFreeOverlapped++;
      dwStatus = RtlLeaveCriticalSection(&g_pServerInfo->csFreeOverlapped);
      ASSERT(dwStatus == 0);
      }
   else
      {
      // Already have a cache of available SERVER_OVERLAPPED, so we
      // can get rid of this one.

      dwStatus = RtlLeaveCriticalSection(&g_pServerInfo->csFreeOverlapped);
      ASSERT(dwStatus == 0);

      MemFree(pOverlapped);
      }

   return NULL;
}

//-----------------------------------------------------------------
//  SetupIoCompletionPort()
//
//  Associate the new socket with our IO completion port so that
//  we can post asynchronous reads to it. Return TRUE on success,
//  FALSE on failure.
//-----------------------------------------------------------------
BOOL SetupIoCompletionPort( HTTP_FILTER_CONTEXT *pFC,
                            SERVER_INFO         *pServerInfo,
                            DWORD               *pdwStatus )
{
   DWORD              dwStatus;
   HANDLE             hIoCP;
   SERVER_CONNECTION *pConn = (SERVER_CONNECTION*)(pFC->pFilterContext);

   if (pConn)
      {
      dwStatus = RtlEnterCriticalSection(&pServerInfo->cs);

      pConn->dwKey = pConn->Socket;

      hIoCP = CreateIoCompletionPort( (HANDLE)pConn->Socket,
                                      pServerInfo->hIoCP,
                                      pConn->dwKey,
                                      0 );
      if (!hIoCP)
         {
         dwStatus = RtlLeaveCriticalSection(&pServerInfo->cs);
         // Very, very bad!
         *pdwStatus = GetLastError();
         #ifdef DBG_ERROR
         DbgPrint("SetupIoCompletionPort(): CreateIoCompletionPort() failed %d\n",*pdwStatus);
         #endif
         return FALSE;
         }

      pServerInfo->hIoCP = hIoCP;
      dwStatus = RtlLeaveCriticalSection(&pServerInfo->cs);
      }
   else
      {
      #ifdef DBG_ERROR
      DbgPrint("SetupIoCompletionPort(): Bad State: pConn is NULL.\n");
      #endif
      return FALSE;
      }

   return TRUE;
}

//-----------------------------------------------------------------
//  ConvertVerbToPost()
//
//  Our incomming request was an RPC_CONNECT, we need to rewrite
//  the input buffer to an appropriate POST request to be captured
//  by the RpcIsapi extension.
//-----------------------------------------------------------------
BOOL ConvertVerbToPost( HTTP_FILTER_CONTEXT  *pFC,
                        HTTP_FILTER_RAW_DATA *pRawData,
                        SERVER_OVERLAPPED    *pOverlapped  )
{
   int    len;
   char   szBuffer[256];
   char   szNumBuffer[MAX_NUM_LEN];
   DWORD  dwIndex;
   char   szChunkedRequest[512];
   char   szIpAddress[ 64 ];
   DWORD  cbIpAddress;
   BOOL   fRet;

   if ( g_fIsIIS6 )
   {
      lstrcpy(szBuffer,RPC_CONNECT);
   }
   else
   {
      lstrcpy(szBuffer,POST_STR);
   }
   lstrcat(szBuffer," ");
   lstrcat(szBuffer,URL_PREFIX_STR);
   lstrcat(szBuffer,URL_START_PARAMS_STR);

   dwIndex = SaveOverlapped(pOverlapped);

   DwToHexAnsi( dwIndex, szNumBuffer, MAX_NUM_LEN );
   lstrcat(szBuffer,szNumBuffer);

   if ( g_fIsIIS6 )
   {
      //
      // Make the request chunked for IIS 6.0 since HTTP.SYS doesn't support
      // reads on a 0 byte POST
      //

      lstrcat(szBuffer, URL_SUFFIX_STR_60);

      cbIpAddress = sizeof( szIpAddress );

      fRet = pFC->GetServerVariable( pFC,
                                     "LOCAL_ADDR",
                                     szIpAddress,
                                     &cbIpAddress );
      if ( !fRet )
      {
         return FALSE;
      }

      lstrcat(szBuffer, szIpAddress);
      lstrcat(szBuffer, URL_SUFFIX_STR_60_TERM);
   }
   else
   {
      lstrcat(szBuffer,URL_SUFFIX_STR);
   }

   len = lstrlen(szBuffer);
   if ( (DWORD)len > pRawData->cbInBuffer)
      {
      #ifdef DBG_ERROR
      DbgPrint("ConvertVerbToPost(): Error: Buffer too small (%d < %d)\n",len,pRawData->cbInBuffer);
      #endif
      return FALSE;
      }
   else
      {
      lstrcpy(pRawData->pvInData,szBuffer);
      pRawData->cbInData = len;
      }

   return TRUE;
}

//-----------------------------------------------------------------
//  GetIndex()
//
//-----------------------------------------------------------------
BOOL GetIndex( unsigned char *pszUrl,
               DWORD         *pdwIndex )
    {
    DWORD    dwStatus;
    unsigned char *psz;

    *pdwIndex = 0;

    if (psz=_mbsstr(pszUrl,URL_START_PARAMS_STR))
        {
        if (!*psz)
            {
            return FALSE;    // Unexpected end of string...
            }

        psz = _mbsinc(psz);
        if (*psz)
            {
            psz = AnsiHexToDWORD(psz,pdwIndex,&dwStatus);
            if (psz)
                {
                return TRUE;
                }
            }
        }

    return FALSE;
    }

//-----------------------------------------------------------------
//  IsDirectAccessAttempt()
//
//  We don't want anybody on the outside to directly access the
//  RpcProxy ISAPI. Is is only called directly by the RPC Proxy
//  filter. So, we need to look for URLs of the form:   
//
//          /rpc/rpcproxy.dll ...
//
//  If a match is found, return TRUE, else return FALSE.
//
//-----------------------------------------------------------------
BOOL IsDirectAccessAttempt( HTTP_FILTER_CONTEXT *pFC,
                            void     *pvNotification )
{
   BOOL   fIsDirect = FALSE;
   DWORD  dwSize;
   DWORD  dwIndex;
   unsigned char  Buffer[MAX_URL_BUFFER];
   HTTP_FILTER_PREPROC_HEADERS *pPreprocHeaders;

   pPreprocHeaders = (HTTP_FILTER_PREPROC_HEADERS*)pvNotification;

   ASSERT(pPreprocHeaders);

   dwSize = MAX_URL_BUFFER;
   if (pPreprocHeaders->GetHeader(pFC,"url",Buffer,&dwSize))
       {
       #ifdef DBG_ACCESS
       DbgPrint("RpcProxy Filter: Url: %s\n",Buffer);
       #endif
       if (!_mbsnbicmp(Buffer,URL_PREFIX_STR,sizeof(URL_PREFIX_STR)-1))
           {
           if (GetIndex(Buffer,&dwIndex) && IsValidOverlappedIndex(dwIndex))
               {
               fIsDirect = FALSE;
               }
           else
               {
               fIsDirect = TRUE;
               }
           }
       }

   #ifdef DBG_ACCESS
   dwSize = MAX_URL_BUFFER;
   if (pPreprocHeaders->GetHeader(pFC,"method",Buffer,&dwSize))
       {
       DbgPrint("RpcProxy Filter: Method: %s\n",Buffer);
       }

   dwSize = MAX_URL_BUFFER;
   if (pPreprocHeaders->GetHeader(pFC,"version",Buffer,&dwSize))
       {
       DbgPrint("RpcProxy Filter: Version: %s\n",Buffer);
       }

   if (fIsDirect)
       {
       DbgPrint("RpcProxy Filter: Direct access attempt.\n");
       }
   #endif

   return fIsDirect;
}

//-----------------------------------------------------------------
//  IsNewConnect()
//
//  See if this is an RPC_CONNECT verb. If so, then establish
//  the connection with the server. The structure of the connect
//  is:
//
//  RPC_CONNECT <Host>:<Port> HTTP/1.0
//
//  Return TRUE iff this is an RPC_CONNECT, else return FALSE.
//
//-----------------------------------------------------------------
SERVER_CONNECTION *IsNewConnect( HTTP_FILTER_CONTEXT  *pFC,
                                 HTTP_FILTER_RAW_DATA *pRawData,
                                 DWORD                *pdwStatus )
{
   int    i;
   char  *pszData = (char*)(pRawData->pvInData);
   char  *pszRpcConnect = RPC_CONNECT;
   SERVER_CONNECTION *pConn;

   *pdwStatus = 0;

   // First see if the verb is for us:
   if (pRawData->cbInData < RPC_CONNECT_LEN)
      {
      return NULL;
      }

   for (i=0; i<RPC_CONNECT_LEN; i++)
      {
      if ( *(pszData++) != *(pszRpcConnect++) )
         {
         return NULL;
         }
      }

   // We have a connect request:
   pConn = AllocConnection();
   if (!pConn)
      {
      return NULL;
      }

   // Skip over any white space to the machine name:
   if (!SkipWhiteSpace(&pszData,pdwStatus))
      {
      FreeServerConnection(pConn);
      return NULL;
      }

   // Extract out the machine name:
   // Note: Command should end with "HTTP/1.0\n":
   if (!ParseMachineNameAndPort(&pszData,pConn,pdwStatus))
      {
      FreeServerConnection(pConn);
      return NULL;
      }


   pFC->pFilterContext = (void*)pConn;

   return pConn;
}

//-----------------------------------------------------------------
//  ChunkEntity()
//
//  For IIS 6.0, chunk encode the entity to ensure that HTTP.SYS allows
//  the ISAPI extension part of this application to work
//
//  Returns FALSE if we cannot do the chunking
//
//-----------------------------------------------------------------
BOOL ChunkEntity( SERVER_CONNECTION * pConn,
                  HTTP_FILTER_RAW_DATA *pRawData )
{
   DWORD            cbRequired;
   CHAR             achChunkPrefix[ CHUNK_PREFIX_SIZE + 1 ];
   DWORD            cchChunkPrefix;
   
   ASSERT( pConn != NULL );
   ASSERT( pRawData != NULL );

   //
   // We should only do the chunk hack for IIS 6
   //
   
   ASSERT( g_fIsIIS6 );

   //
   // Calculate how much buffer we need to add chunk prefix
   //

   wsprintf( achChunkPrefix,
             CHUNK_PREFIX,
             pRawData->cbInData );

   cchChunkPrefix = strlen( achChunkPrefix );

   cbRequired = pRawData->cbInData + cchChunkPrefix + CHUNK_SUFFIX_SIZE;

   //
   // If the buffer provided by IIS is large enough, then we don't need
   // to allocate our own
   //

   if ( cbRequired <= pRawData->cbInBuffer )
   {
      //
      // Shift the buffer over
      //

      memmove( (PBYTE) pRawData->pvInData + cchChunkPrefix,
               pRawData->pvInData,
               pRawData->cbInData );

      //
      // Prepend chunked prefix
      //
      
      memcpy( (PBYTE) pRawData->pvInData,
              achChunkPrefix,
              cchChunkPrefix );

      //
      // Append chunked suffix
      //

      memcpy( (PBYTE) pRawData->pvInData + cchChunkPrefix + pRawData->cbInData,
              CHUNK_SUFFIX,
              CHUNK_SUFFIX_SIZE );

      //
      // Update length
      //

      pRawData->cbInData = cbRequired;
   }
   else
   {
      //
      // We will have to allocate a new buffer
      //

      if ( pConn->cbIIS6ChunkBuffer < cbRequired )
      {
         //
         // We already have a buffer big enough
         //

         if ( pConn->pbIIS6ChunkBuffer != NULL )
         {
            MemFree( pConn->pbIIS6ChunkBuffer );
            pConn->pbIIS6ChunkBuffer = NULL;
         }

         pConn->pbIIS6ChunkBuffer = MemAllocate( cbRequired );
         if ( pConn->pbIIS6ChunkBuffer == NULL )
         {
            return FALSE;
         }

         pConn->cbIIS6ChunkBuffer = cbRequired;
      }
      
      //
      // Now copy stuff to new buffer
      //

      memcpy( pConn->pbIIS6ChunkBuffer,
              achChunkPrefix,
              cchChunkPrefix );

      memcpy( pConn->pbIIS6ChunkBuffer + cchChunkPrefix,
              pRawData->pvInData,
              pRawData->cbInData );

      memcpy( pConn->pbIIS6ChunkBuffer + cchChunkPrefix + pRawData->cbInData,
              CHUNK_SUFFIX,
              CHUNK_SUFFIX_SIZE );

      //
      // Update raw data structure to point to our buffer
      //

      pRawData->pvInData = pConn->pbIIS6ChunkBuffer;
      pRawData->cbInData = cbRequired;
      pRawData->cbInBuffer = cbRequired;
   }

   return TRUE;
}

//-----------------------------------------------------------------
//  SkipWhiteSpace()
//
//-----------------------------------------------------------------
BOOL SkipWhiteSpace( char **ppszData,
                     DWORD *pdwStatus )
{
   char  *psz = *ppszData;

   *pdwStatus = 0;

   while ( (*psz == CHAR_SPACE) || (*psz == CHAR_TAB) )
      {
      psz++;
      }

   *ppszData = psz;

   return TRUE;
}

//-----------------------------------------------------------------
//  ParseMachineNameAndPort()
//
//  The machine name and port should look like:  <machine>:<port>
//-----------------------------------------------------------------
BOOL ParseMachineNameAndPort( char              **ppszData,
                              SERVER_CONNECTION  *pConn,
                              DWORD              *pdwStatus )
{
   int    len = 0;
   char  *psz = *ppszData;
   char  *pszMachine;

   *pdwStatus = RPC_S_OK;

   // Get the machine name length:
   while ( (*psz != CHAR_COLON) && (*psz != CHAR_NL) && (*psz != CHAR_LF) )
      {
      len++; psz++;
      }

   if (*psz != CHAR_COLON)
      {
      *pdwStatus = RPC_S_INVALID_ENDPOINT_FORMAT;
      return FALSE;
      }

   if (len > MAX_MACHINE_NAME_LEN)
      {
      *pdwStatus = RPC_S_STRING_TOO_LONG;
      return FALSE;
      }

   // Make a buffer to hold the machine name:
   pConn->pszMachine = pszMachine = (char*)MemAllocate(1+len);
   if (!pConn->pszMachine)
      {
      *pdwStatus = RPC_S_OUT_OF_MEMORY;
      return FALSE;
      }

   // Copy over the machine name:
   psz = *ppszData;
   while (*psz != CHAR_COLON)
      {
      *(pszMachine++) = *(psz++);
      // pszMachine++;
      // psz++;
      }

   *pszMachine = 0;

   // Ok get the port number:
   psz++;
   psz = AnsiToPortNumber(psz,&pConn->dwPortNumber);
   if (!psz)
      {
      pConn->pszMachine = MemFree(pConn->pszMachine);
      *pdwStatus = RPC_S_INVALID_ENDPOINT_FORMAT;
      return FALSE;
      }

   *ppszData = psz;
   return TRUE;
}

//-----------------------------------------------------------------
//  AnsiToPortNumber()
//
//-----------------------------------------------------------------
char *AnsiToPortNumber( char  *pszPort,
                        DWORD *pdwPort  )
{
   *pdwPort = 0;

   while ( (*pszPort >= CHAR_0) && (*pszPort <= CHAR_9) )
      {
      *pdwPort = 10*(*pdwPort) + (*(pszPort++) - CHAR_0);

      // I want to limit the port number to 65535:
      if (*pdwPort > 65535)
         {
         *pdwPort = 0;
         return NULL;
         }
      }

   return pszPort;
}

//-----------------------------------------------------------------
//  ResolveMachineName()
//
//  Resolve the machine name, address and port number. The machine
//  name may come in as either a friendly name or as an IP address.
//-----------------------------------------------------------------
BOOL ResolveMachineName( SERVER_CONNECTION *pConn,
                         DWORD             *pdwStatus )
{
   unsigned long     ulHostAddr;
   struct   hostent *pHostEnt;
   char             *pszDot;
   struct   in_addr  MachineInAddr;

   *pdwStatus = 0;
   memset( &(pConn->Server), 0, sizeof(pConn->Server) );

   // Resolve the machine name, which may be either an address in IP dot
   // notation or a host name string:
   if (!pConn->pszMachine)
      {
      // local machine:
      ulHostAddr = INADDR_LOOPBACK;
      pHostEnt = gethostbyaddr( (char*)&ulHostAddr, sizeof(struct in_addr), AF_INET);
      if (pHostEnt)
         {
         pConn->pszMachine = (char*)MemAllocate(1+lstrlen(pHostEnt->h_name));
         if (!pConn->pszMachine)
            {
            *pdwStatus = RPC_S_OUT_OF_MEMORY;
            #ifdef DBG_ERROR
            DbgPrint("ResolveMachineName(): Out of memory.\n");
            #endif
            return FALSE;
            }

         lstrcpy(pConn->pszMachine,pHostEnt->h_name);
         }

      memcpy(&MachineInAddr,&ulHostAddr,sizeof(struct in_addr));
      pszDot = inet_ntoa(MachineInAddr);
      if (pszDot)
         {
         pConn->pszDotMachine = (char*)MemAllocate(1+lstrlen(pszDot));
         if (!pConn->pszDotMachine)
            {
            *pdwStatus = RPC_S_OUT_OF_MEMORY;
            #ifdef DBG_ERROR
            DbgPrint("ResolveMachineName(): Out of memory.\n");
            #endif
            return FALSE;
            }

         lstrcpy(pConn->pszDotMachine,pszDot);
         }

      ulHostAddr = htonl(INADDR_LOOPBACK);
      memcpy( &(pConn->Server.sin_addr), (unsigned char *)&ulHostAddr, sizeof(ulHostAddr) );
      pConn->Server.sin_family = AF_INET;
      }
   else
      {
      // First, assume an address in numeric dot notation (xxx.xxx.xxx.xxx):
      ulHostAddr = inet_addr(pConn->pszMachine);
      if (ulHostAddr == INADDR_NONE)
         {
         // Not a numeric address, try a network name:
         pHostEnt = gethostbyname(pConn->pszMachine);
         if (!pHostEnt)
            {
            *pdwStatus = WSAGetLastError();
            #ifdef DBG_ERROR
            DbgPrint("ResolveMachineName(): gethostbyname() failed: %d\n",
                     *pdwStatus);
            #endif
            return FALSE;
            }

         memcpy(&MachineInAddr,pHostEnt->h_addr,pHostEnt->h_length);
         pszDot = inet_ntoa(MachineInAddr);
         if (pszDot)
            {
            pConn->pszDotMachine = (char*)MemAllocate(1+lstrlen(pszDot));
            if (!pConn->pszDotMachine)
               {
               *pdwStatus = RPC_S_OUT_OF_MEMORY;
               #ifdef DBG_ERROR
               DbgPrint("ResolveMachineName(): Out of memory.\n");
               #endif
               return FALSE;
               }

            lstrcpy(pConn->pszDotMachine,pszDot);
            }
         }
      else
         {
         // Ok, machine name was an IP address.
         pHostEnt = gethostbyaddr( (char*)&ulHostAddr, sizeof(ulHostAddr), AF_INET );
         if (!pHostEnt)
            {
            *pdwStatus = WSAGetLastError();
            #ifdef DBG_ERROR
            DbgPrint("ResolveMachineName(): gethostbyaddr() failed: %d\n",*pdwStatus);
            #endif
            return FALSE;
            }

         pConn->pszDotMachine = pConn->pszMachine;
         pConn->pszMachine = (char*)MemAllocate(1+lstrlen(pHostEnt->h_name));
         if (!pConn->pszMachine)
            {
            #ifdef DBG_ERROR
            DbgPrint("ResolveMachineName(): Out of memory.\n");
            #endif
            return FALSE;
            }

         lstrcpy(pConn->pszMachine,pHostEnt->h_name);
         }
      memcpy( &(pConn->Server.sin_addr), pHostEnt->h_addr, pHostEnt->h_length );
      pConn->Server.sin_family = pHostEnt->h_addrtype;
      }

   //
   // Now, do the port number (Note: htons() doesn't fail):
   //
   pConn->Server.sin_port = htons( (unsigned short)(pConn->dwPortNumber) );

   return TRUE;
}

//-----------------------------------------------------------------
//  CheckRpcServer()
//
//  When we've just connected to an HTTP/RPC server, it must send
//  us and ID string, so that we know that the socket is in fact
//  an RPC server listening on ncacn_http. If we get correct string
//  then return TRUE.
//
//  If we don't get the correct response back in HTTP_SERVER_TIMEOUT
//  seconds then fail (return FALSE).
//-----------------------------------------------------------------
BOOL CheckRpcServer( SERVER_CONNECTION *pConn,
                     DWORD             *pdwStatus )
{
   int    iBytes;
   int    iRet;
   int    iBytesLeft = sizeof(HTTP_SERVER_ID_STR) - 1;
   char   Buff[sizeof(HTTP_SERVER_ID_STR)];
   char  *pBuff;
   fd_set rfds;
   struct timeval Timeout;

   FD_ZERO(&rfds);
   FD_SET(pConn->Socket,&rfds);

   *pdwStatus = 0;
   pBuff = Buff;
   Timeout.tv_sec = HTTP_SERVER_ID_TIMEOUT;
   Timeout.tv_usec = 0;

   while (TRUE)
      {
      iRet = select(0,&rfds,NULL,NULL,&Timeout);

      if (iRet == 0)
         {
         // Timeout
         return FALSE;
         }
      else if (iRet == SOCKET_ERROR)
         {
         // Socket (select) error
         *pdwStatus = WSAGetLastError();
         return FALSE;
         }

      iBytes = recv( pConn->Socket, pBuff, iBytesLeft, 0 );

      if (iBytes == 0)
         {
         // Socket was closed by the server
         }
      else if (iBytes == SOCKET_ERROR)
         {
         *pdwStatus = WSAGetLastError();
         return FALSE;
         }

      pBuff += iBytes;
      iBytesLeft -= iBytes;

      if (iBytesLeft == 0)
         {
         *pBuff = 0;
         break;
         }

      ASSERT(iBytes > 0);

      }

   // Got an ID string, check to make sure its correct:
   if (RpcpStringCompareIntA(Buff,HTTP_SERVER_ID_STR))
      {
      return FALSE;
      }

   return TRUE;
}

//-----------------------------------------------------------------
//  ConnectToServer()
//
//-----------------------------------------------------------------
BOOL ConnectToServer( HTTP_FILTER_CONTEXT *pFC,
                      DWORD               *pdwStatus )
{
   int                iRet;
   int                iCount;
   int                iSocketStatus;
   int                iSocketType = SOCK_STREAM;
   int                iNagleOff = TRUE;
   int                iKeepAliveOn = TRUE;
   struct hostent    *pHostEnt;
   SERVER_CONNECTION *pConn = (SERVER_CONNECTION*)(pFC->pFilterContext);
   unsigned short     usHttpPort = DEF_HTTP_PORT;
   SOCKET             Socket;

   *pdwStatus = 0;

   //
   // Create the socket:
   //
   #ifdef DBG_ERROR
   if (pConn->Socket != INVALID_SOCKET)
      {
      DbgPrint("ConnectToServer(): socket() on existing socket.\n");
      }
   #endif

   pConn->Socket = socket(AF_INET,iSocketType,0);
   if (pConn->Socket == INVALID_SOCKET)
      {
      *pdwStatus = WSAGetLastError();
      #ifdef DBG_ERROR
      DbgPrint("ConnectToServer(): socket() failed: %d\n",*pdwStatus);
      #endif
      return FALSE;
      }

   #ifdef DBG_COUNTS
   iCount = InterlockedIncrement(&g_iSocketCount);
   DbgPrint("socket(%d): Count: %d -> %d\n",pConn->Socket,iCount-1,iCount);
   #endif

   //
   // Connect to the RPC server:
   //
   iSocketStatus = connect( pConn->Socket,
                            (struct sockaddr*)&(pConn->Server),
                            sizeof(pConn->Server) );
   if (iSocketStatus == SOCKET_ERROR)
      {
      *pdwStatus = WSAGetLastError();
      iRet = closesocket(pConn->Socket);
      pConn->Socket = INVALID_SOCKET;
      return FALSE;
      }

   //
   // Turn off Nagle Algorithm, turn keep-alive on:
   //
   setsockopt(pConn->Socket,IPPROTO_TCP,TCP_NODELAY,(char*)&iNagleOff,sizeof(iNagleOff));

   setsockopt(pConn->Socket,IPPROTO_TCP,SO_KEEPALIVE,(char*)&iKeepAliveOn,sizeof(iKeepAliveOn));

   //
   // Make sure the socket that we've connected to is for HTTP/RPC. If so,
   // then it will return an Ident string as soon as it does the accept().
   //
   if (  (!CheckRpcServer(pConn,pdwStatus))
      && ( (Socket=pConn->Socket) != INVALID_SOCKET) )
      {
      iRet = closesocket(pConn->Socket);
      pConn->Socket = INVALID_SOCKET;
      #ifdef DBG_COUNTS
      if (iRet == SOCKET_ERROR)
         {
         DbgPrint("[2] closesocket(%d) failed: %d\n",Socket,WSAGetLastError());
         }
      else
         {
         int iCount = InterlockedDecrement(&g_iSocketCount);
         DbgPrint("[2] closesocket(%d): Count: %d -> %d\n",Socket,1+iCount,iCount);
         }
      #endif
      return FALSE;
      }

   return TRUE;
}


//-----------------------------------------------------------------
//  AllocConnection()
//
//-----------------------------------------------------------------
SERVER_CONNECTION *AllocConnection()
{
   SERVER_CONNECTION  *pConn;

   pConn = (SERVER_CONNECTION*)MemAllocate(sizeof(SERVER_CONNECTION));
   if (!pConn)
      {
      #ifdef DBG_ERROR
      DbgPrint("AllocConnection(): Allocate failed.\n");
      #endif
      return NULL;
      }

   memset(pConn,0,sizeof(SERVER_CONNECTION));
   pConn->iRefCount = 1;
   pConn->Socket = INVALID_SOCKET;

   #ifdef TRACE_MALLOC
   DbgPrint("AllocConnection(): pConn: 0x%x Socket: %d\n",pConn,pConn->Socket);
   #endif

   return pConn;
}

//-----------------------------------------------------------------
//  AddRefConnection()
//
//-----------------------------------------------------------------
void AddRefConnection( SERVER_CONNECTION *pConn )
{
   ASSERT(pConn);
   ASSERT(pConn->iRefCount > 0);

   InterlockedIncrement(&pConn->iRefCount);

   #ifdef TRACE_MALLOC
   DbgPrint("AddRefConnection(): pConn: 0x%x Socket: %d iRefCount: %d\n",
            pConn, pConn->Socket, pConn->iRefCount);
   #endif
}

//-----------------------------------------------------------------
//  ShutdownConnection()
//
//-----------------------------------------------------------------
void ShutdownConnection( SERVER_CONNECTION *pConn,
                         int                how    )
{
   SOCKET  Socket;
   int     iRet;

   if (pConn)
      {
      Socket = pConn->Socket;
      if (Socket != INVALID_SOCKET)
         {
         iRet = shutdown(Socket,how);

         #ifdef DBG_ERROR
         if (iRet == SOCKET_ERROR)
            {
            DbgPrint("shutdown(%d) failed: %d\n",
                     Socket, WSAGetLastError() );
            }
         #endif
         }
      }
}

//-----------------------------------------------------------------
//  CloseServerConnection()
//
//-----------------------------------------------------------------
void CloseServerConnection( SERVER_CONNECTION *pConn )
{
   SOCKET  Socket;
   int     iRet;

   if (pConn)
      {
      Socket = (UINT_PTR)InterlockedExchangePointer((PVOID *)&pConn->Socket,(PVOID)INVALID_SOCKET);
      if (Socket != INVALID_SOCKET)
         {
         iRet = closesocket(Socket);

         #ifdef DBG_ERROR
         if (iRet == SOCKET_ERROR)
            {
            DbgPrint("closesocket(%d) failed: %d\n",
                     Socket, WSAGetLastError() );
            }
         #ifdef DBG_COUNTS
         else
            {
            int iCount = InterlockedDecrement(&g_iSocketCount);
            DbgPrint("closesocket(%d): Count: %d -> %d\n",
                     Socket, 1+iCount, iCount );
            }
         #endif
         #endif
         }
      }
}

//-----------------------------------------------------------------
//  FreeServerConnection()
//
//  SERVER_CONNECTIONs are reference counted so, that there may
//  be several references to one. FreeServerConnection() will continue
//  to return a pointer to the connection as long as the reference
//  count is >0. When  the reference count drops to zero, the
//  connection is actually free'd, and FreeServerConnection() will then
//  return NULL.
//-----------------------------------------------------------------
SERVER_CONNECTION *FreeServerConnection( SERVER_CONNECTION *pConn )
{
   SOCKET  Socket;
   int     iRet;
   int     iRefCount = InterlockedDecrement(&pConn->iRefCount);

   ASSERT(iRefCount >= 0);

   #ifdef TRACE_MALLOC
   DbgPrint("FreeServerConnection(): pConn: 0x%x Socket: %d iRefCount: %d\n",
            pConn, pConn->Socket, pConn->iRefCount);
   #endif

   if (iRefCount > 0)
      {
      // Still one or more outstanding references to this SERVER_CONNECTION.
      ShutdownConnection(pConn,SD_RECEIVE);
      return pConn;
      }

   if (pConn)
      {
      CloseServerConnection(pConn);

      if (pConn->pszMachine)
          {
          pConn->pszMachine = MemFree(pConn->pszMachine);
          }

      if (pConn->pszDotMachine)
          {
          pConn->pszDotMachine = MemFree(pConn->pszDotMachine);
          }

      MemFree(pConn);
      }
   else
      {
      #ifdef DBG_ERROR
      DbgPrint("FreeServerConnection(): called with NULL pointer (filter.c).\n");
      #endif
      }

   return NULL;
}

//-----------------------------------------------------------------
//  SendToServer()
//
//-----------------------------------------------------------------
DWORD SendToServer( SERVER_CONNECTION  *pConn,
                    char               *pBuffer,
                    DWORD               dwBytes )
{
   int    iRet;
   char  *pCurrent = pBuffer;
   DWORD  dwStatus = ERROR_SUCCESS;
   DWORD  dwBytesToSend = dwBytes;
   DWORD  dwBytesWritten = 0;
   SERVER_OVERLAPPED *pOverlapped;
   fd_set wfds;
   struct timeval Timeout;

   #ifdef DBG_ERROR
   if (pConn->Socket == INVALID_SOCKET)
      {
      DbgPrint("SendToServer(%d): Invalid Socket.\n",pConn->Socket);
      }
   #endif

   FD_ZERO(&wfds);
   FD_SET(pConn->Socket,&wfds);

   Timeout.tv_sec = HTTP_SERVER_ID_TIMEOUT;
   Timeout.tv_usec = 0;

   while (dwBytes > dwBytesWritten)
       {
       iRet = select(0,NULL,&wfds,NULL,&Timeout);
       if (iRet == 0)
           {
           // Timeout...
           continue;
           }
       else if (iRet == SOCKET_ERROR)
           {
           dwStatus = WSAGetLastError();
           #ifdef DBG_ERROR
           DbgPrint("SendToServer(%d): Failed: %d\n",pConn->Socket,dwStatus);
           #endif
           break;
           }

       iRet = send(pConn->Socket,pBuffer,dwBytesToSend,0);
       if (iRet == SOCKET_ERROR)
           {
           dwStatus = WSAGetLastError();
           #ifdef DBG_ERROR
           DbgPrint("SendToServer(%d): Failed: %d\n",pConn->Socket,dwStatus);
           #endif
           break;
           }

       dwBytesWritten += iRet;
       pCurrent += iRet;
       }

   return dwStatus;
}

//-----------------------------------------------------------------
//  HttpReplyToClient()
//
//-----------------------------------------------------------------
DWORD HttpReplyToClient( HTTP_FILTER_CONTEXT  *pFC,
                         char                 *pszConnectionStatus )
{
   DWORD  dwStatus = 0;
   DWORD  dwReserved = 0;
   DWORD  len = lstrlen(pszConnectionStatus);


   if (!pFC->WriteClient(pFC,pszConnectionStatus,&len,dwReserved) )
      {
      dwStatus = GetLastError();
      #ifdef DBG_ERROR
      DbgPrint("HttpReplyToClient(): WriteClient() failed: %d\n",dwStatus);
      #endif
      }

   return dwStatus;
}

//-----------------------------------------------------------------
//  CloseClientConnection()
//
//  Tells the IIS to close the client connection. Any pending
//  asynchronous IOs (reads) will be terminated with the error
//  ERROR_NETNAME_DELETED (64).
//
//-----------------------------------------------------------------
void CloseClientConnection( EXTENSION_CONTROL_BLOCK *pECB )
   {
   if (pECB)
      {
      // pECB->dwHttpStatusCode = STATUS_SERVER_ERROR;

      if (!pECB->ServerSupportFunction( pECB->ConnID,
                                        HSE_REQ_CLOSE_CONNECTION,
                                        NULL, NULL, NULL))
         {
         #ifdef DBG_ERROR
         DbgPrint("CloseClientConnection(): HSE_REQ_CLOSE_CONNECTION failed: %d\n", GetLastError());
         #endif
         }

      #ifdef DBG_ERROR
      DbgPrint("CloseClientConnection(): HSE_REQ_CLOSE_CONNECTION\n");
      #endif
      }
   }

//-----------------------------------------------------------------
//  EndOfSession()
//
//  Sends a message to the server forwarding thread to tell it to
//  close down the connection to the RPC server represented by
//  pConn.
//
//-----------------------------------------------------------------
DWORD EndOfSession( SERVER_INFO         *pServerInfo,
                    HTTP_FILTER_CONTEXT *pFC          )
{
   int    iRet;
   DWORD  dwStatus = 0;
   SOCKET Socket;
   SERVER_CONNECTION *pConn = (SERVER_CONNECTION*)(pFC->pFilterContext);

   // Socket = pConn->Socket;

   #ifdef DBG_ERROR
   DbgPrint("EndOfSession(): Socket: %d\n",pConn->Socket);
   #endif

   // CloseServerConnection(pConn);

   FreeServerConnection(pConn);

   return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\rpcproxy\httpreg.c ===
//---------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  httpreg.c
//
//    HTTP/RPC Proxy Registry Functions.
//
//  Author:
//    06-16-97  Edward Reus    Initial version.
//
//---------------------------------------------------------------------------

#include <sysinc.h>
#include <rpc.h>
#include <rpcdce.h>
#include <winsock2.h>
#include <httpfilt.h>
#include <httpext.h>
#include <mbstring.h>
#include <ecblist.h>
#include <filter.h>
#include <regexp.h>
#include <registry.h>
#include <resource.h>
#include <PEventLog.h>


//-------------------------------------------------------------------------
//  AtoUS()
//
//  Convert a numeric string to an unsigned short. If the conversion
//  fails return FALSE.
//-------------------------------------------------------------------------
static BOOL AtoUS( char *pszValue, unsigned short *pusValue )
{
   int  iValue;
   size_t  iLen = strlen(pszValue);

   *pusValue = 0;

   if ((iLen == 0) || (iLen > 5) || (iLen != strspn(pszValue,"0123456789")))
      {
      return FALSE;
      }

   iValue = atoi(pszValue);

   if ((iValue < 0) || (iValue > 65535))
      {
      return FALSE;
      }

   *pusValue = (unsigned short) iValue;

   return TRUE;
}

char *
SkipLeadingSpaces (
    IN const char *CurrentPosition
    )
/*++

Routine Description:

    Skips all spaces (0x20) starting from the current position.

Arguments:

    CurrentPosition - the beginning of the string

Return Value:

    The first non-space character in the string

--*/
{
    while (*CurrentPosition == ' ')
        CurrentPosition ++;

    return (char *)CurrentPosition;
}

void
RemoveTrailingSpaces (
    IN char *CurrentPosition,
    IN char *BeginningOfString
    )
/*++

Routine Description:

    Removes all trailing spaces at the end of the string
    by converting them to 0.

Arguments:

    CurrentPosition - the current position in the string -
        usually one before the null terminator.

    BeginningOfString - the beginning of the string - we should
        not move beyond this.

Return Value:

--*/
{
    ASSERT(CurrentPosition >= BeginningOfString);

    // whack all trailing spaces
    while (*CurrentPosition == ' ' && CurrentPosition > BeginningOfString)
        {
        *CurrentPosition = '\0';
        -- CurrentPosition;
        }
}

void 
LogEventValidPortsFailure (
    IN char *ValidPorts
    )
/*++

Routine Description:

    Logs a message to the event log reporting that the 
    ValidPorts regkey cannot be parsed.

Arguments:

    ValidPorts - parses the valid ports string as read from the registry.

Return Value:

--*/
{
    HANDLE hEventSource;
    char *Strings[] = { ValidPorts };
 
    hEventSource = RegisterEventSourceW (NULL,  // uses local computer 
             EVENT_LOG_SOURCE_NAME);    // source name 

    if (hEventSource == NULL)
        {
#if DBG
        DbgPrint("Rpc Proxy - RegisterEventSourceW failed: %X. Can't log event ValidPorts failure event. \n", 
            GetLastError());
#endif  // DBG
        return;        
        }

    if (!ReportEventA(hEventSource,
            EVENTLOG_ERROR_TYPE,  // event type 
            RPCPROXY_EVENTLOG_STARTUP_CATEGORY,                    // category
            RPCPROXY_EVENTLOG_VALID_PORTS_ERR,        // event identifier 
            NULL,                 // user security identifier 
            1,                    // # of substitution strings
            0,                    // no data 
            Strings,              // pointer to string array 
            NULL))                // pointer to data 
        {
#if DBG
        DbgPrint("Rpc Proxy - ReportEventW failed: %X. Can't log event ValidPorts failure. \n", GetLastError());
#endif  // DBG
        // fall through on error
        }
 
    DeregisterEventSource(hEventSource); 
} 

void 
LogEventStartupSuccess (
    IN char *IISMode
    )
/*++

Routine Description:

    Logs a message to the event log reporting that the 
    RPC proxy started successfully.

Arguments:

    IISMode - the mode that we start in. Must be the string "5"
    for 5.0 mode and the string "6" for 6.0 mode.

Return Value:

--*/
{
    HANDLE hEventSource;
    char *Strings[] = { IISMode };
 
    hEventSource = RegisterEventSourceW (NULL,  // uses local computer 
             EVENT_LOG_SOURCE_NAME);    // source name 

    if (hEventSource == NULL)
        {
#if DBG
        DbgPrint("Rpc Proxy - RegisterEventSourceW failed: %X. Can't log event StartupSuccess event. \n", 
            GetLastError());
#endif  // DBG
        return;        
        }

    if (!ReportEventA(hEventSource,
            EVENTLOG_INFORMATION_TYPE,  // event type 
            RPCPROXY_EVENTLOG_STARTUP_CATEGORY,                    // category
            RPCPROXY_EVENTLOG_SUCCESS_LOAD,        // event identifier 
            NULL,                 // user security identifier 
            1,                    // # of substitution strings
            0,                    // no data 
            Strings,              // pointer to string array 
            NULL))                // pointer to data 
        {
#if DBG
        DbgPrint("Rpc Proxy - ReportEventW failed: %X. Can't log event Startup Success. \n", GetLastError());
#endif  // DBG
        // fall through on error
        }
 
    DeregisterEventSource(hEventSource); 
} 

//-------------------------------------------------------------------------
//  HttpParseServerPort()
//
//  Parse strings of the form:  <svr>:<port>[-<port>]
//
//  Return TRUE iff we have a valid specification of a server/port range.
//
//  N.B.: pszServerPortRange gets modified on output
//-------------------------------------------------------------------------
static BOOL HttpParseServerPort( IN  char        *pszServerPortRange,
                                 OUT VALID_PORT  *pValidPort )
{
   char *psz;
   char *pszColon;
   char *pszDash;
   char *pszCurrent;

   pszServerPortRange = SkipLeadingSpaces (pszServerPortRange);

   if (pszColon=_mbschr(pszServerPortRange,':'))
      {
      if (pszColon == pszServerPortRange)
         {
         return FALSE;
         }

      *pszColon = 0;
      psz = pszColon;
      psz++;
      pValidPort->pszMachine = (char*)MemAllocate(1+lstrlen(pszServerPortRange));
      if (!pValidPort->pszMachine)
         {
         return FALSE;
         }

      lstrcpy(pValidPort->pszMachine,pszServerPortRange);

      // truncate trailing spaces in the name
      // position on the last character before the terminating NULL
      pszCurrent = pValidPort->pszMachine + _mbstrlen(pValidPort->pszMachine) - 1;

      // we checked above that the machine name is not empty
      ASSERT(pszCurrent > pValidPort->pszMachine);

      RemoveTrailingSpaces (pszCurrent, pValidPort->pszMachine);

      if (*psz)
         {
         // skip leading spaces
         psz = SkipLeadingSpaces (psz);

         if (pszDash=_mbschr(psz,'-'))
            {
            *pszDash = 0;
            RemoveTrailingSpaces (pszDash - 1, psz);
            if (!AtoUS(psz,&pValidPort->usPort1))
               {
               pValidPort->pszMachine = MemFree(pValidPort->pszMachine);
               return FALSE;
               }

            psz = SkipLeadingSpaces (pszDash + 1);

            if (!AtoUS(psz,&pValidPort->usPort2))
               {
               pValidPort->pszMachine = MemFree(pValidPort->pszMachine);
               return FALSE;
               }
            }
         else
            {
            psz = SkipLeadingSpaces (psz);

            if (!AtoUS(psz,&pValidPort->usPort1))
               {
               pValidPort->pszMachine = MemFree(pValidPort->pszMachine);
               return FALSE;
               }

            pValidPort->usPort2 = pValidPort->usPort1;
            }
         }
      else
         {
         pValidPort->pszMachine = MemFree(pValidPort->pszMachine);
         return FALSE;
         }
      }
   else
      {
      return FALSE;
      }

   return TRUE;
}

//-------------------------------------------------------------------------
//  HttpFreeValidPortList()
//
//-------------------------------------------------------------------------
void HttpFreeValidPortList( IN VALID_PORT *pValidPorts )
{
   VALID_PORT *pCurrent = pValidPorts;

   if (pValidPorts)
      {
      while (pCurrent->pszMachine)
         {
         MemFree(pCurrent->pszMachine);

         if (pCurrent->ppszDotMachineList)
            {
            FreeIpAddressList(pCurrent->ppszDotMachineList);
            }

         pCurrent++;
         }

      MemFree(pValidPorts);
      }
}

//-------------------------------------------------------------------------
//  HttpParseValidPortsList()
//
//  Given a semicolon separated list of valid machine name/port ranges
//  string, part it and return an array of ValidPort structures. The last
//  entry has a NULL pszMachine field.
//-------------------------------------------------------------------------
VALID_PORT *HttpParseValidPortsList( IN char *pszValidPorts )
{
   int    i;
   int    iLen;
   int    count = 1;
   DWORD  dwSize = 1+lstrlen(pszValidPorts);
   char  *pszList;
   char  *pszFirst;
   char  *psz;
   VALID_PORT *pValidPorts = NULL;

   if (!dwSize)
      {
      return NULL;
      }

   // Make a local copy of the machine/ports list to work with:
   pszList = MemAllocate(dwSize);

   if (!pszList)
      {
      // Out of memory.
      return NULL;
      }

   lstrcpy(pszList,pszValidPorts);

   // See how many separate machine/port range patterns ther are in
   // the list:
   //
   // NOTE: That count may be too high, if either the list contains
   //       double semicolons or the list ends with a semicolon. If
   //       either/both of these happen that's Ok, our array will be
   //       just a little too long.
   psz = pszList;
   while (psz=_mbsstr(psz,";"))
      {
      count++;
      psz++;
      }

   pValidPorts = (VALID_PORT*)MemAllocate( (1+count)*sizeof(VALID_PORT) );
   if (!pValidPorts)
      {
      // Out of memory.
      MemFree(pszList);
      return NULL;
      }

   memset(pValidPorts,0,(1+count)*sizeof(VALID_PORT));

   i = 0;

   psz = pszList;

   while (i<count)
      {
      if (!*psz)
         {
         // End of list. This happens when the list contained empty
         // patterns.
         break;
         }

      pszFirst = psz;
      psz = _mbsstr(pszFirst,";");
      if (psz)
         {
         *psz = 0;   // Nul where the semicolon was...

         if ( (iLen=lstrlen(pszFirst)) == 0)
            {
            // Zero length pattern.
            ++psz;
            continue;
            }

         if (!HttpParseServerPort(pszFirst,&(pValidPorts[i++])))
            {
            MemFree(pszList);
            HttpFreeValidPortList(pValidPorts);
            return NULL;
            }
         }
      else
         {
         // Last one.
         if (!HttpParseServerPort(pszFirst,&(pValidPorts[i++])))
            {
            MemFree(pszList);
            HttpFreeValidPortList(pValidPorts);
            return NULL;
            }
         }

      ++psz;
      }

   MemFree(pszList);
   return pValidPorts;
}

BOOL InvalidPortsRangeEventLogged = FALSE;

//-------------------------------------------------------------------------
//  HttpProxyRefreshValidPorts()
//
//  Check the registry to see if HTTP/RPC is enabled and if so, return a
//  list (array) of machines that the RPC Proxy is allowed to reach (may
//  be NULL. The returned list specifies specifically what machines may 
//  be reached by the proxy.
//
//  The following registry entries are found in:
//
//    \HKEY_LOCAL_MACHINE
//        \Software
//        \Microsoft
//        \Rpc
//        \RpcProxy
//
//  Enabled : REG_DWORD
//
//    TRUE iff the RPC proxy is enabled.
//
//  ValidPorts : REG_SZ
//
//    Semicolon separated list of machine/port ranges used to specify
//    what machine are reachable from the RPC proxy. For example:
//
//    foxtrot:1-4000;Data*:200-4000
//
//    Will allow access to the machine foxtrot (port ranges 1 to 4000) and
//    to all machines whose name begins with Data (port ranges 200-4000).
//
//-------------------------------------------------------------------------
VALID_PORT *HttpProxyRefreshValidPorts(IN HKEY hKey OPTIONAL)
{
    long   lStatus;
    BOOL KeyOpenedLocally;
    DWORD  dwType;
    DWORD  dwSize;
    VALID_PORT *ValidPorts = NULL;
    char *pszValidPorts = NULL;

    KeyOpenedLocally = FALSE;

    if (hKey == NULL)
        {
        lStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_PROXY_PATH_STR, 0, KEY_READ, &hKey);
        if (lStatus != ERROR_SUCCESS)
            {
            goto CleanupAndExit;
            }
        KeyOpenedLocally = TRUE;
        }

    dwSize = 0;
    lStatus = RegQueryValueEx(hKey, REG_PROXY_VALID_PORTS_STR, 0, &dwType, (LPBYTE)NULL, &dwSize);
    if ( (lStatus != ERROR_SUCCESS) || (dwSize == 0) )
        {
        goto CleanupAndExit;
        }

    // dwSize is now how big the valid ports string is (including the trailing nul).
    pszValidPorts = (char *) MemAllocate(dwSize);
    if (pszValidPorts == NULL)
        goto CleanupAndExit;

    lStatus = RegQueryValueEx(hKey, REG_PROXY_VALID_PORTS_STR, 0, &dwType, (LPBYTE)pszValidPorts, &dwSize);
    if (lStatus != ERROR_SUCCESS)
        {
        goto CleanupAndExit;
        }

    ValidPorts = HttpParseValidPortsList(pszValidPorts);

    // fall through to the cleanup and exit code

CleanupAndExit:
    if (KeyOpenedLocally)
        RegCloseKey(hKey);

    // if we failed to load/parse the valid ports list, log an event
    if (ValidPorts == NULL)
        {
        // log the event only the first time
        if (InvalidPortsRangeEventLogged == FALSE)
            {
            LogEventValidPortsFailure (pszValidPorts);
            // remember we have logged the event.
            InvalidPortsRangeEventLogged = TRUE;
            }
        }
    else
        {
        // we parsed the ports successfully.
        InvalidPortsRangeEventLogged = FALSE;
        }

    if (pszValidPorts)
        MemFree(pszValidPorts);

    return ValidPorts;
}

BOOL HttpProxyCheckRegistry(void)
{
   int    i;
   long   lStatus;
   DWORD  dwType;
   DWORD  dwSize;
   HKEY   hKey;
   char  *pszValidPorts;
   struct hostent UNALIGNED *pHostEnt;
   struct in_addr   ServerInAddr;
   HMODULE RedirectorDll;
   RPC_CHAR *RedirectorDllName;
   RPC_CHAR RedirectorDllNameBuffer[40];

   lStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,REG_PROXY_PATH_STR,0,KEY_READ,&hKey);
   if (lStatus != ERROR_SUCCESS)
      {
      return TRUE;
      }

   dwSize = sizeof(g_pServerInfo->dwEnabled);
   lStatus = RegQueryValueEx(hKey,REG_PROXY_ENABLE_STR,0,&dwType,(LPBYTE)&g_pServerInfo->dwEnabled,&dwSize);
   if (lStatus != ERROR_SUCCESS)
      {
      RegCloseKey(hKey);
      return TRUE;
      }

   if (!g_pServerInfo->dwEnabled)
      {
      // RPC Proxy is disabled, no need to go on.
      RegCloseKey(hKey);
      return TRUE;
      }

   dwSize = sizeof(g_pServerInfo->dwEnabled);
   lStatus = RegQueryValueEx(hKey,REG_PROXY_ALLOW_ANONYMOUS,0,&dwType,(LPBYTE)&g_pServerInfo->AllowAnonymous,&dwSize);
   if ((lStatus == ERROR_SUCCESS) && (dwType != REG_DWORD))
      {
      // if the type is wrong, bail out
      RegCloseKey(hKey);
      return FALSE;
      }

   dwSize = sizeof(RedirectorDllNameBuffer);
   lStatus = RegQueryValueExW(hKey, REG_PROXY_REDIRECTOR_DLL, 0, &dwType, (LPBYTE)RedirectorDllNameBuffer, &dwSize);
   if (
       (
        (lStatus == ERROR_SUCCESS) 
        ||
        (lStatus == ERROR_MORE_DATA) 
       )
       && (dwType != REG_SZ)
      )
      {
      // if the type is wrong, bail out
      RegCloseKey(hKey);
      return FALSE;
      }

   if (lStatus == ERROR_MORE_DATA)
       {
       RedirectorDllName = MemAllocate(dwSize);
       if (RedirectorDllName == NULL)
           {
           RegCloseKey(hKey);
           return FALSE;
           }

       lStatus = RegQueryValueExW(hKey, REG_PROXY_REDIRECTOR_DLL, 0, &dwType, (LPBYTE)RedirectorDllName, &dwSize);
       }
    else
        RedirectorDllName = RedirectorDllNameBuffer;

    if (lStatus == ERROR_SUCCESS)
        {
        // a redirector DLL was configured
        // Load it.
        RedirectorDll = LoadLibraryW(RedirectorDllName);
        if (RedirectorDll == NULL)
            {
            RegCloseKey(hKey);
            return FALSE;
            }

        g_pServerInfo->RpcNewHttpProxyChannel 
            = (RPC_NEW_HTTP_PROXY_CHANNEL)GetProcAddress(RedirectorDll, "RpcNewHttpProxyChannel");
        g_pServerInfo->RpcHttpProxyFreeString 
            = (RPC_HTTP_PROXY_FREE_STRING)GetProcAddress(RedirectorDll, "RpcHttpProxyFreeString");

        if ((g_pServerInfo->RpcNewHttpProxyChannel == NULL)
            || (g_pServerInfo->RpcHttpProxyFreeString == NULL))
            {
            g_pServerInfo->RpcNewHttpProxyChannel = NULL;
            g_pServerInfo->RpcHttpProxyFreeString = NULL;
            FreeLibrary(RedirectorDll);
            RegCloseKey(hKey);
            return FALSE;
            }
        }

    // this is called as part of the ISAPI initialization - no need
    // to claim the right to refresh ports - we're single threaded
    // by definition.
    g_pServerInfo->RefreshingValidPorts = FALSE;
    g_pServerInfo->pValidPorts = HttpProxyRefreshValidPorts(hKey);

    RegCloseKey(hKey);

    if (g_pServerInfo->pValidPorts)
        return TRUE;
    else
        return FALSE;
}

//-------------------------------------------------------------------------
//  HttpConvertToDotAddress()
//
//  Convert the specified machine name to IP dot notation if possible.
//-------------------------------------------------------------------------
char *HttpConvertToDotAddress( char *pszMachineName )
{
   struct   hostent UNALIGNED *pHostEnt;
   struct     in_addr  MachineInAddr;
   char      *pszDot = NULL;
   char      *pszDotMachine = NULL;

   pHostEnt = gethostbyname(pszMachineName);
   if (pHostEnt)
      {
      memcpy(&MachineInAddr,pHostEnt->h_addr,pHostEnt->h_length);
      pszDot = inet_ntoa(MachineInAddr);
      }

   if (pszDot)
      {
      pszDotMachine = (char*)MemAllocate(1+lstrlen(pszDot));
      if (pszDotMachine)
         {
         lstrcpy(pszDotMachine,pszDot);
         }
      }

   return pszDotMachine;
}

//-------------------------------------------------------------------------
//  HttpNameToDotAddressList()
//
//  Convert the specified machine name to IP dot notation if possible. 
//  Return a list (null terminated) of the IP dot addresses in ascii.
//
//  If the function fails, then retrun NULL. It can fail if gethostbyname()
//  fails, or memory allocation fails.
//-------------------------------------------------------------------------
char **HttpNameToDotAddressList( IN char *pszMachineName )
{
   int        i;
   int        iCount = 0;
   struct   hostent UNALIGNED *pHostEnt;
   struct     in_addr  MachineInAddr;
   char     **ppszDotList = NULL;
   char      *pszDot = NULL;
   char      *pszDotMachine = NULL;

   pHostEnt = gethostbyname(pszMachineName);
   if (pHostEnt)
      {
      // Count how many addresses we have:
      while (pHostEnt->h_addr_list[iCount])
          {
          iCount++;
          }

      // Make sure we have at lease one address:
      if (iCount > 0)
          {
          ppszDotList = (char**)MemAllocate( sizeof(char*)*(1+iCount) );
          }

      // Build an array of strings, holding the addresses (ascii DOT
      // notation:
      if (ppszDotList)
          {
          for (i=0; i<iCount; i++)
               {
               memcpy(&MachineInAddr,
                      pHostEnt->h_addr_list[i],
                      pHostEnt->h_length);

               pszDot = inet_ntoa(MachineInAddr);

               if (pszDot)
                   {
                   ppszDotList[i] = (char*)MemAllocate(1+lstrlen(pszDot));
                   if (ppszDotList[i])
                       {
                       strcpy(ppszDotList[i],pszDot);
                       }
                   else
                       {
                       // memory allocate failed:
                       break;
                       }
                   }
              }

          ppszDotList[i] = NULL;   // Null terminated list.
          }
      }

   return ppszDotList;
}

//-------------------------------------------------------------------------
//  CheckCacheTimestamp()
//
//  Return true if the current time stamp is aged out.
//-------------------------------------------------------------------------
BOOL CheckCacheTimestamp( DWORD  dwCurrentTickCount,
                                    DWORD  dwCacheTimestamp )

   {
   if (  (dwCurrentTickCount < dwCacheTimestamp)
      || ((dwCurrentTickCount - dwCacheTimestamp) > VALID_PORTS_CACHE_LIFE) )
      {
      return TRUE;
      }

   return FALSE;
   }

//-------------------------------------------------------------------------
//  CheckPort()
//
//-------------------------------------------------------------------------
static BOOL CheckPort( DWORD             dwPortNumber,
                       VALID_PORT        *pValidPort )
{
   return ( (dwPortNumber >= pValidPort->usPort1)
            && (dwPortNumber <= pValidPort->usPort2) );
}

//-------------------------------------------------------------------------
//  HttpProxyIsValidMachine()
//
//-------------------------------------------------------------------------
BOOL HttpProxyIsValidMachine( SERVER_INFO *pServerInfo,
                     char *pszMachine,
                     char *pszDotMachine,
                     DWORD dwPortNumber )
{
   int         i;
   char      **ppszDot;
   DWORD       dwTicks;
   DWORD       dwSize;
   DWORD       dwStatus;
   VALID_PORT *pValidPorts;


   // Check the machine name against those that were allowed
   // in the registry:
   dwStatus = RtlEnterCriticalSection(&pServerInfo->cs);

   dwTicks = GetTickCount();
   if (CheckCacheTimestamp(dwTicks, pServerInfo->dwCacheTimestamp)
       && pServerInfo->RefreshingValidPorts == FALSE)
       {
       // claim the right to refresh the ports
       pServerInfo->RefreshingValidPorts = TRUE;
       RtlLeaveCriticalSection(&pServerInfo->cs);

       // refresh them outside the critical section
       pValidPorts = HttpProxyRefreshValidPorts (
           NULL     // hKey
           );

       // get back into the critical section
       RtlEnterCriticalSection(&pServerInfo->cs);

       pServerInfo->RefreshingValidPorts = FALSE;

       if (pValidPorts)
           {
           // if success, refresh the tick count
           pServerInfo->dwCacheTimestamp = dwTicks;
           }

       if (pServerInfo->pValidPorts)
           MemFree (pServerInfo->pValidPorts);

       pServerInfo->pValidPorts = pValidPorts;
       }

   pValidPorts = pServerInfo->pValidPorts;

   if (pValidPorts)
      {
      while (pValidPorts->pszMachine)
         {
         // See if we have a name match:
         if ( (MatchREi(pszMachine,pValidPorts->pszMachine))
              && (CheckPort(dwPortNumber,pValidPorts)) )
            {
            dwStatus = RtlLeaveCriticalSection(&pServerInfo->cs);
            return TRUE;
            }

         // The "valid entry" in the registry might be an address
         // wildcard, check it:
         if (  (pszDotMachine)
            && (MatchREi(pszDotMachine,pValidPorts->pszMachine))
            && (CheckPort(dwPortNumber,pValidPorts)) )
            {
            dwStatus = RtlLeaveCriticalSection(&pServerInfo->cs);
            return TRUE;
            }

         // Try a match using internet dot address:
         if (  (pValidPorts->ppszDotMachineList)
            && (pszDotMachine)
            && (CheckPort(dwPortNumber,pValidPorts)) )
            {
            // Note that the machine may have more than one address
            // associated with it:
            //
            ppszDot = pValidPorts->ppszDotMachineList;

            while (*ppszDot)
               {
               if (!_mbsicmp(pszDotMachine,*ppszDot))
                   {
                   dwStatus = RtlLeaveCriticalSection(&pServerInfo->cs);
                   return TRUE;
                   }
               else
                   {
                   ppszDot++;
                   }
               }
            }

         pValidPorts++;
         }
      }

   dwStatus = RtlLeaveCriticalSection(&pServerInfo->cs);

   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\rpcproxy\httpreg.h ===
//---------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  httpreg.h
//
//    HTTP/RPC protocol specific constants and types.
//
//  Author:
//    04-23-97  Edward Reus    Initial version.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//  Constants:
//---------------------------------------------------------------------------

#define  REG_PROXY_PATH_STR         "Software\\Microsoft\\Rpc\\RpcProxy"
#define  REG_PROXY_ENABLE_STR       "Enabled"
#define  REG_PROXY_VALID_PORTS_STR  "ValidPorts"

//---------------------------------------------------------------------------
//  Types:
//---------------------------------------------------------------------------

typedef struct _ValidPort
{
   char          *pszMachine;
   unsigned short usPort1;
   unsigned short usPort2;
}  ValidPort;


//---------------------------------------------------------------------------
//  Functions:
//---------------------------------------------------------------------------

extern BOOL HttpProxyCheckRegistry( OUT DWORD *pdwEnabled,
                                    OUT ValidPorts **ppValidPorts );

extern void HttpFreeValidPortList( IN ValidPort *pValidPorts );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\rpcproxy\filter.h ===
//--------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  filter.h
//
//--------------------------------------------------------------------


// Flag to track counts of open sockets and IIS sessions:
#ifdef DBG
// #define DBG_ERROR
// #define DBG_ECBREF
// #define  DBG_ACCESS
// #define  DBG_COUNTS
// #define  TRACE_MALLOC
#endif

#define  STATUS_CONNECTION_OK           200
#define  STATUS_SERVER_ERROR            500
#define  STATUS_CONNECTION_FAILED       502
#define  STATUS_MUST_BE_POST            503
#define  STATUS_POST_BAD_FORMAT         504

#define  STATUS_CONNECTION_OK_STR       "HTTP/1.0 200 Connection established\n"
#define  STATUS_CONNECTION_FAILED_STR   "HTTP/1.0 502 Connection to RPC server failed\n"
#define  STATUS_MUST_BE_POST_STR        "HTTP/1.0 503 Must use POST\n"
#define  STATUS_POST_BAD_FORMAT_STR     "HTTP/1.0 504 POST bad format\n"
#define  STATUS_PROXY_DISABLED          "HTTP/1.0 503 RPC Proxy disabled\n"

#define  FILTER_DESCRIPTION             "HTTP/RPC Proxy Filter"
#define  FILTER_DESCRIPTION_W           (L"HTTP/RPC Proxy Filter")
#define  EXTENSION_DESCRIPTION          "HTTP/RPC Proxy Extension"

// NOTE: RPC_CONNECT_LEN must be the length of RPC_CONNECT.
#define  RPC_CONNECT                  "RPC_CONNECT"
#define  RPC_CONNECT_LEN                  11

#define  CHAR_SPACE                      ' '
#define  CHAR_TAB                       '\t'
#define  CHAR_COLON                      ':'
#define  CHAR_AMPERSAND                  '&'
#define  CHAR_NL                        '\n'
#define  CHAR_LF                        '\r'
#define  CHAR_0                          '0'
#define  CHAR_9                          '9'
#define  CHAR_A                          'A'
#define  CHAR_F                          'F'

#define  HTTP_SERVER_ID_STR           "ncacn_http/1.0"
#define  HTTP_SERVER_ID_TIMEOUT          30

#define  POST_STR                     "POST"
#define  URL_PREFIX_STR               "/rpc/RpcProxy.dll"
#define  URL_START_PARAMS_STR            "?"
#define  URL_PARAM_SEPARATOR_STR         "&"
// #define  URL_SUFFIX_STR               " HTTP/1.0\r\nUser-Agent: RPC\r\nContent-Length: 0\r\nConnection: Keep-Alive\r\nPragma: No-Cache\r\n\r\n"
// #define  URL_SUFFIX_STR               " HTTP/1.1\r\nAccept: */*\r\nAccept-Language: en-us\r\nUser-Agent: RPC\r\nContent-Length: 0\r\nHost: edwardr2\r\nConnection: Close\r\nPragma: No-Cache\r\n\r\n"
#define  URL_SUFFIX_STR                  " HTTP/1.0\r\nUser-Agent: RPC\r\nContent-Length: 0\r\nConnection: Close\r\nPragma: No-Cache\r\n\r\n"

//
// Some stuff to chunk IIS 6 entity 
//
#define  URL_SUFFIX_STR_60               " HTTP/1.1\r\nUser-Agent: RPC\r\nTransfer-Encoding: chunked\r\nConnection: Close\r\nPragma: No-Cache\r\nHost: "
#define  URL_SUFFIX_STR_60_TERM          "\r\n\r\n"
#define  CHUNK_PREFIX_SIZE               (sizeof( "XXXXXXXX\r\n" ) - 1)
#define  CHUNK_PREFIX                    "%x\r\n"
#define  CHUNK_SUFFIX                    "\r\n"
#define  CHUNK_SUFFIX_SIZE               (sizeof( "\r\n" ) - 1)

#define  WSA_VERSION                  0x0101
#define  DEF_HTTP_PORT                    80

#define  VALID_PORTS_CACHE_LIFE    5*60*1000

#define  TIMEOUT_MSEC                  30000
#define  READ_BUFFER_SIZE               8192
#define  HTTP_PORT_STR_SIZE               20

#define  MAX_URL_BUFFER                  256
#define  MAX_MACHINE_NAME_LEN            255
#define  MAX_HTTP_CLIENTS                256
#define  MAX_FREE_OVERLAPPED              64

#define  REG_PROXY_PATH_STR           "Software\\Microsoft\\Rpc\\RpcProxy"
#define  REG_PROXY_ENABLE_STR         "Enabled"
#define  REG_PROXY_VALID_PORTS_STR    "ValidPorts"
#define  REG_PROXY_ALLOW_ANONYMOUS    "AllowAnonymous"
#define  REG_PROXY_REDIRECTOR_DLL     (L"RedirectorDll")

#ifndef  HSE_REQ_ASYNC_READ_CLIENT

    // These are new constructs and types defined by K2. Newer
    // versions of httpext.h will already define these.

    #define  HSE_REQ_ASYNC_READ_CLIENT       (10 + HSE_REQ_END_RESERVED)
    #define  HSE_REQ_ABORTIVE_CLOSE          (14 + HSE_REQ_END_RESERVED)
    #define  HSE_REQ_SEND_RESPONSE_HEADER_EX (16 + HSE_REQ_END_RESERVED)

    typedef struct _HSE_SEND_HEADER_EX_INFO
        {
        //
        // HTTP status code and header
        //
        LPCSTR  pszStatus;  // HTTP status code  eg: "200 OK"
        LPCSTR  pszHeader;  // HTTP header

        DWORD   cchStatus;  // number of characters in status code
        DWORD   cchHeader;  // number of characters in header

        BOOL    fKeepConn;  // keep client connection alive?
        } HSE_SEND_HEADER_EX_INFO;

#endif

#ifndef HSE_REQ_CLOSE_CONNECTION

    // New SSF() command to close an async connection and cancel
    // any outstanding IOs (reads) on it.

    #define HSE_REQ_CLOSE_CONNECTION         (17 + HSE_REQ_END_RESERVED)

#endif

//--------------------------------------------------------------------
//--------------------------------------------------------------------

#define HEX_DIGIT_VALUE(chex)                                   \
                  (  (((chex) >= CHAR_0) && ((chex) <= CHAR_9)) \
                     ? ((chex) - CHAR_0)                        \
                     : ((chex) - CHAR_A + 10) )

//--------------------------------------------------------------------
//--------------------------------------------------------------------

#ifdef DBG_COUNTS
extern int g_iSocketCount;
extern int g_iSessionCount;
#endif

//--------------------------------------------------------------------
//  Types:
//--------------------------------------------------------------------

typedef struct _VALID_PORT
{
   char          *pszMachine;         // A valid machine to access.
   char         **ppszDotMachineList; // Its name in IP dot notation.
   unsigned short usPort1;
   unsigned short usPort2;
}  VALID_PORT;


typedef struct _SERVER_CONNECTION
{
   int             iRefCount;
   DWORD           dwPortNumber;
   char           *pszMachine;        // RPC server friendly name.
   char           *pszDotMachine;
   DWORD           MachineAddrLen;
   struct in_addr  MachineAddr;
   ULONG_PTR       dwKey;
   struct          sockaddr_in Server;
   SOCKET          Socket;
   DWORD           cbIIS6ChunkBuffer;
   BYTE *          pbIIS6ChunkBuffer;
} SERVER_CONNECTION;


typedef struct _SERVER_OVERLAPPED
{
   DWORD  Internal;
   DWORD  InternalHigh;
   DWORD  Offset;
   DWORD  OffsetHigh;
   HANDLE hEvent;
   struct _SERVER_OVERLAPPED *pNext;
   EXTENSION_CONTROL_BLOCK   *pECB;   // Connection to client.
   SERVER_CONNECTION         *pConn;  // Connection to the RPC server.
   DWORD  dwBytes;                    // #bytes to Read/Write.
   DWORD  dwFlags;                    // Async flags.
   BOOL   fFirstRead;
   BOOL   fIsServerSide;              // TRUE iff server side connection.

   DWORD  dwIndex;                    // Filter/ISAPI transition index.
   LIST_ENTRY     ListEntry;          // Filter/ISAPI transition list.

   unsigned char  arBuffer[READ_BUFFER_SIZE]; // Read/Write Buffer.
} SERVER_OVERLAPPED;


typedef struct _SERVER_INFO
{
   RTL_CRITICAL_SECTION   cs;
   HANDLE                 hIoCP;

   DWORD                  dwEnabled;
   BOOL                   AllowAnonymous;
   RPC_NEW_HTTP_PROXY_CHANNEL   RpcNewHttpProxyChannel;
   RPC_HTTP_PROXY_FREE_STRING   RpcHttpProxyFreeString;
   DWORD                  dwCacheTimestamp;  // Timestamp, used to 
                                         // age out validports cache

   char                  *pszLocalMachineName;
   VALID_PORT            *pValidPorts;

   BOOL                  RefreshingValidPorts;

   RTL_CRITICAL_SECTION   csFreeOverlapped;
   DWORD                  dwFreeOverlapped;
   SERVER_OVERLAPPED     *pFreeOverlapped;
   SERVER_OVERLAPPED     *pLastOverlapped;

   ACTIVE_ECB_LIST       *pActiveECBList;

} SERVER_INFO;

//--------------------------------------------------------------------
//  Functions:
//--------------------------------------------------------------------


extern DWORD WINAPI ServerThreadProc( void *pArg );

extern BOOL  IsDirectAccessAttempt( HTTP_FILTER_CONTEXT  *pFC,
                                    void      *pvNotification );

extern SERVER_CONNECTION *IsNewConnect( HTTP_FILTER_CONTEXT  *pFC,
                                        HTTP_FILTER_RAW_DATA *pRawData,
                                        DWORD                *pdwStatus );

extern BOOL  ChunkEntity( SERVER_CONNECTION    *pConn,
                          HTTP_FILTER_RAW_DATA *pRawData );

extern BOOL  ResolveMachineName( SERVER_CONNECTION *pConn,
                                 DWORD             *pdwStatus );

extern BOOL  ConnectToServer( HTTP_FILTER_CONTEXT *pFC,
                              DWORD               *pdwStatus);

extern BOOL  ConvertVerbToPost( HTTP_FILTER_CONTEXT  *pFC,
                                HTTP_FILTER_RAW_DATA *pRawData,
                                SERVER_OVERLAPPED    *pOverlapped );

extern BOOL  SetupIoCompletionPort( HTTP_FILTER_CONTEXT *pFC,
                                    SERVER_INFO         *pServerInfo,
                                    DWORD               *pdwStatus );

extern DWORD SendToServer( SERVER_CONNECTION *pConn,
                           char              *pBuffer,
                           DWORD              dwBytes );

extern DWORD HttpReplyToClient( HTTP_FILTER_CONTEXT  *pFC,
                                char       *pszHttpStatus );

extern SERVER_OVERLAPPED *AllocOverlapped();

extern SERVER_OVERLAPPED *FreeOverlapped( SERVER_OVERLAPPED *pOverlapped );

extern SERVER_CONNECTION *AllocConnection();

extern void               AddRefConnection( SERVER_CONNECTION *pConn );

extern void               CloseServerConnection( SERVER_CONNECTION *pConn );

extern SERVER_CONNECTION *FreeServerConnection( SERVER_CONNECTION *pConn );

extern void               ShutdownConnection( SERVER_CONNECTION *pConn,
                                              int    how );

extern void               CloseClientConnection(
                                         EXTENSION_CONTROL_BLOCK *pECB );

extern DWORD EndOfSession( SERVER_INFO         *pServerInfo,
                           HTTP_FILTER_CONTEXT *pFC );



extern BOOL  SkipWhiteSpace( char **ppszData,
                             DWORD *pdwStatus );

extern BOOL  ParseMachineNameAndPort( char              **ppszData,
                                      SERVER_CONNECTION  *pConn,
                                      DWORD              *pdwStatus );

extern char *AnsiToPortNumber( char  *pszPort,
                               DWORD *pdwPort  );

extern unsigned char *AnsiHexToDWORD( unsigned char *pszNum,
                                      DWORD         *pdwNum,
                                      DWORD         *pdwStatus );

extern char *HttpConvertToDotAddress( char *pszMachine );

extern BOOL HttpProxyCheckRegistry(void);

extern BOOL HttpProxyIsValidMachine( SERVER_INFO *pServerInfo,
                     char *pszMachine,
                     char *pszDotMachine,
                     DWORD dwPortNumber );

extern void FreeIpAddressList( char **ppszDotMachineList );

extern void HttpFreeValidPortList( VALID_PORT *pValidPorts );

extern BOOL  MemInitialize( DWORD *pdwStatus );

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

void *MemAllocate( DWORD dwSize );

void *MemFree( VOID *pMem );

BOOL InitializeGlobalDataStructures (
    IN BOOL IsFromFilter
    );

extern BOOL fIsIISInCompatibilityMode;
extern ULONG IISConnectionTimeout;

extern void  FreeServerInfo( SERVER_INFO **ppServerInfo );

extern SERVER_INFO *g_pServerInfo;

#ifdef __cplusplus
};
#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\rpcproxy\olist.c ===
//---------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  olist.c
//
//    Maintain list of SERVER_OVERLAPPED structures, used in passing 
//    the overlapped structure pointers between the RpcProxy filter
//    and its ISAPI. This happens on initial connection.
//
//  Author:
//    05-04-98  Edward Reus    Initial version.
//
//---------------------------------------------------------------------------

#define  FD_SETSIZE   1

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <sysinc.h>
#include <mbstring.h>
#include <rpc.h>
#include <rpcdce.h>
#include <winsock2.h>
#include <httpfilt.h>
#include <httpext.h>
#include "ecblist.h"
#include "filter.h"
#include "olist.h"


static RTL_CRITICAL_SECTION  g_cs;
static LIST_ENTRY            g_OverlappedList;
static DWORD                 g_dwIndex = 0;

//-------------------------------------------------------------------------
//  InitializeOverlappedList()
//
//-------------------------------------------------------------------------
BOOL InitializeOverlappedList()
    {
    DWORD  dwStatus;

    dwStatus = RtlInitializeCriticalSection(&g_cs);
    if (dwStatus != 0)
        {
        return FALSE;
        }

    InitializeListHead(&g_OverlappedList);

    g_dwIndex = 1;

    return TRUE;
    }

void 
UninitializeOverlappedList (
    void
    )
{
    if (g_dwIndex)
        RtlDeleteCriticalSection(&g_cs);
}

//-------------------------------------------------------------------------
//  SaveOverlapped()
//
//-------------------------------------------------------------------------
DWORD SaveOverlapped( SERVER_OVERLAPPED *pOverlapped )
    {
    DWORD  dwStatus;
    DWORD  dwIndex;

    dwStatus = RtlEnterCriticalSection(&g_cs);

    InsertTailList(&g_OverlappedList,&(pOverlapped->ListEntry));

    dwIndex = g_dwIndex++;
    pOverlapped->dwIndex = dwIndex;

    // Reset the index allocation so we'll never run out of 
    // index values...
    if (g_dwIndex >= 0x7fffffff)
        {
        // 0x7fffffff is a LOT of connections...
        g_dwIndex = 1;
        }

    dwStatus = RtlLeaveCriticalSection(&g_cs);

    return dwIndex;
    }

//-------------------------------------------------------------------------
// GetOverlapped()
//
//-------------------------------------------------------------------------
SERVER_OVERLAPPED *GetOverlapped( DWORD dwIndex )
    {
    DWORD              dwStatus;
    LIST_ENTRY        *pEntry;
    SERVER_OVERLAPPED *pOverlapped = NULL;

    dwStatus = RtlEnterCriticalSection(&g_cs);

    pEntry = g_OverlappedList.Flink;

    while (pEntry != &g_OverlappedList)
        {
        pOverlapped = CONTAINING_RECORD(pEntry,
                                        SERVER_OVERLAPPED,
                                        ListEntry );
        if (pOverlapped->dwIndex == dwIndex)
            {
            RemoveEntryList(pEntry);
            dwStatus = RtlLeaveCriticalSection(&g_cs);
            return pOverlapped;
            }

        pEntry = pEntry->Flink;
        }

    dwStatus = RtlLeaveCriticalSection(&g_cs);

    return NULL;
    }

//-------------------------------------------------------------------------
//  IsValidOverlappedIndex()
//
//  Return TRUE iff the specified index refers to a valid 
//  SERVER_OVERLAPPED in the list.
//-------------------------------------------------------------------------
BOOL IsValidOverlappedIndex( DWORD dwIndex )
    {
    DWORD              dwStatus;
    LIST_ENTRY        *pEntry;
    SERVER_OVERLAPPED *pOverlapped = NULL;

    dwStatus = RtlEnterCriticalSection(&g_cs);

    pEntry = g_OverlappedList.Flink;

    while (pEntry != &g_OverlappedList)
        {
        pOverlapped = CONTAINING_RECORD(pEntry,
                                        SERVER_OVERLAPPED,
                                        ListEntry );
        if (pOverlapped->dwIndex == dwIndex)
            {
            dwStatus = RtlLeaveCriticalSection(&g_cs);
            return TRUE;
            }

        pEntry = pEntry->Flink;
        }

    dwStatus = RtlLeaveCriticalSection(&g_cs);

    return FALSE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\rpcproxy\memory.c ===
//-----------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  memory.c
//
//  The RPC Proxy uses its own heap.
//
//
//  History:
//
//    Edward Reus   06-23-97   Initial Version.
//-----------------------------------------------------------------

#include <sysinc.h>
#include <rpc.h>
#include <rpcdce.h>
#include <winsock2.h>
#include <httpfilt.h>
#include <httpext.h>
#include "ecblist.h"
#include "filter.h"

//-----------------------------------------------------------------
//  Globals:
//-----------------------------------------------------------------

HANDLE g_hHeap = NULL;

//-----------------------------------------------------------------
//  MemInitialize()
//
//  Creates a heap to be used by MemAllocate() and MemFree().
//
//  Note: You don't need to call this function, it will be called
//  automatically by MemAllocate().
//-----------------------------------------------------------------
BOOL MemInitialize( DWORD *pdwStatus )
{
   SYSTEM_INFO SystemInfo;

   *pdwStatus = 0;

   if (!g_hHeap)
      {
      GetSystemInfo(&SystemInfo);

      g_hHeap = HeapCreate(0L,SystemInfo.dwPageSize,0L);
      if (!g_hHeap)
         {
         *pdwStatus = GetLastError();
         #ifdef DBG_ERROR
         DbgPrint("MemInitialize(): HeapCreate() failed: %d\n",*pdwStatus);
         #endif
         return FALSE;
         }
      }

   return TRUE;
}

//-----------------------------------------------------------------
//  MemAllocate()
//
//  Allocate a chunk of memory of dwSize bytes.
//-----------------------------------------------------------------
void *MemAllocate( DWORD dwSize )
{
   DWORD  dwStatus;
   void  *pMem;

   if (!g_hHeap)
      {
      if (!MemInitialize(&dwStatus))
         {
         return NULL;
         }
      }

   pMem = HeapAlloc(g_hHeap,0L,dwSize);

   return pMem;
}

//-----------------------------------------------------------------
//  MemFree()
//
//  Free memory allocated by MemAllocate().
//-----------------------------------------------------------------
void *MemFree( void *pMem )
{
   if (g_hHeap)
      {
      #ifdef DBG_ERROR
      if (!HeapFree(g_hHeap,0L,pMem))
         {
         DbgPrint("MemFree(): HeapFree() failed: %d\n",GetLastError());
         }
      #else
      HeapFree(g_hHeap,0L,pMem);
      #endif
      }
   #ifdef DBG_ERROR
   else
      {
      DbgPrint("MemFree(): Called on uninitialized Heap.\n");
      }
   #endif

   return NULL;
}

//-----------------------------------------------------------------
//  MemTerminate()
//
//-----------------------------------------------------------------
void MemTerminage()
{
   if (g_hHeap)
      {
      #ifdef DBG_ERROR
      if (!HeapDestroy(g_hHeap))
         {
         DbgPrint("MemTerminate(): HeapDestroy() failed: %d\n",GetLastError());
         }
      #else
      HeapDestroy(g_hHeap);
      #endif
      }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\common\whttpimp.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    WHttpImp.cxx

Abstract:

    HTTP2 WinHttp import functionality.

Author:

    KamenM      10-30-01    Created

Revision History:

--*/

#include <precomp.hxx>
#include <Http2Log.hxx>
#include <WHttpImp.hxx>

RpcWinHttpImportTableType RpcWinHttpImportTable = {NULL};

HMODULE WinHttpLibrary = NULL;

const char *RpcWinHttpImportTableFunctionNames[] = {
    "WinHttpOpen",
    "WinHttpSetStatusCallback",
    "WinHttpSetOption",
    "WinHttpConnect",
    "WinHttpOpenRequest",
    "WinHttpQueryOption",
    "WinHttpSendRequest",
    "WinHttpWriteData",
    "WinHttpReceiveResponse",
    "WinHttpReadData",
    "WinHttpCloseHandle",
    "WinHttpQueryHeaders",
    "WinHttpQueryDataAvailable",
    "WinHttpQueryAuthSchemes",
    "WinHttpSetCredentials",
    "WinHttpAddRequestHeaders"
    };

RPC_STATUS InitRpcWinHttpImportTable (
    void
    )
/*++

Routine Description:

    Initializes the Rpc WinHttp import table. Must
    be called before any WinHttp function.
    The function must be idempotent.

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* for error.

--*/
{
    RPC_STATUS RpcStatus;
    int i;
    int FunctionsCount;
    FARPROC *CurrentFunction;
    HMODULE LocalWinHttpLibrary;

    GlobalMutexRequest();

    if (WinHttpLibrary == NULL)
        {
        WinHttpLibrary = LoadLibrary(L"WinHttp.dll");
        if (WinHttpLibrary == NULL)
            {
            RpcStatus = GetLastError();
            GlobalMutexClear();
            if (RpcStatus == ERROR_FILE_NOT_FOUND)
                RpcStatus = RPC_S_CANNOT_SUPPORT;
            else
                RpcStatus = RPC_S_OUT_OF_MEMORY;

            return RpcStatus;
            }
        }

    FunctionsCount = sizeof(RpcWinHttpImportTableFunctionNames) 
        / sizeof(RpcWinHttpImportTableFunctionNames[0]);

    CurrentFunction = (FARPROC *) &RpcWinHttpImportTable;

    for (i = 0; i < FunctionsCount; i ++)
        {
        *CurrentFunction = GetProcAddress(WinHttpLibrary, 
            RpcWinHttpImportTableFunctionNames[i]
            );

        if (*CurrentFunction == NULL)
            {
            LocalWinHttpLibrary = WinHttpLibrary;
            WinHttpLibrary = NULL;
            GlobalMutexClear();
            FreeLibrary(LocalWinHttpLibrary);
            return RPC_S_CANNOT_SUPPORT;
            }

        CurrentFunction ++;
        }

    GlobalMutexClear();
    return RPC_S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\rpcproxy\regexp.h ===
//---------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  regexp.h
//
//    Simple, fast regular expression matching.
//
//  Author:
//    06-02-97  Edward Reus    Initial version.
//
//---------------------------------------------------------------------------

#ifndef REG_EXP_H
#define REG_EXP_H

extern BOOL MatchREi( unsigned char *pszString,
                      unsigned char *pszPattern );


#if FALSE
... not currently used ...
extern BOOL MatchRE( unsigned char *pszString,
                     unsigned char *pszPattern );

extern BOOL MatchREList( unsigned char  *pszString,
                         unsigned char **ppszREList  );

extern BOOL MatchExactList( unsigned char  *pszString,
                            unsigned char **ppszREList );
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\rpcproxy\olist.h ===
//--------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  olist.h
//
//    Maintain list of SERVER_OVERLAPPED structures, used in passing
//    the overlapped structure pointers between the RpcProxy filter
//    and its ISAPI. This happens on initial connection.
//
//  Author:
//    05-04-98  Edward Reus    Initial version.
//
//--------------------------------------------------------------------


#ifndef OLIST_H
#define OLIST_H

extern BOOL InitializeOverlappedList();

extern void UninitializeOverlappedList(void);

extern DWORD SaveOverlapped( SERVER_OVERLAPPED *pOverlapped );

extern BOOL  IsValidOverlappedIndex( DWORD dwIndex );

extern SERVER_OVERLAPPED *GetOverlapped( DWORD dwIndex );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\rpcproxy\resource.h ===
#define IDS_EXTENSION_NAME              1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\rpcproxy\regexp.c ===
//---------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  regexp.c
//
//    Simple regular expression matching.
//
//  Author:
//    06-02-97  Edward Reus    Initial version.
//
//---------------------------------------------------------------------------

#include <sysinc.h>
#include <mbstring.h>
#include "regexp.h"

//-------------------------------------------------------------------------
//  MatchREi()
//
//  Match the test string (pszString) against the specifed pattern. If they
//  match return TRUE, else return FALSE. This version works with ANSI
//  characters and is case independent.
//
//  In this function patterns are made up from "literal" characters plus
//  some control characters, "*", "?". Asterix (*) is a place
//  holder for "zero or more" of any character. Question Mark (?) is a place
//  holder for "any single character". The square brackets ([]) contain a
//  list of matching characters, in this case "-" is used to denote a range
//  of characters (i.e. [A-Z] matches any alpha character), but I didn't 
//  pub brackets in this one yet...
//
//-------------------------------------------------------------------------
BOOL MatchREi( unsigned char *pszString,
               unsigned char *pszPattern )
{
    unsigned char *pchRangeLow;

    while (TRUE)
       {
       // Walk throuh the pattern, matching it against the string.
       switch (*pszPattern)
          {
          case '*':
             // Match zero or more characters.
             pszPattern = _mbsinc(pszPattern);
             while (*pszString)
                {
                if (MatchREi(pszString,pszPattern))
                   {
                   return TRUE;
                   }
                pszString = _mbsinc(pszString);
                }
                return MatchREi(pszString,pszPattern);

          case '?':
             // Match any single character.
             if (*pszString == 0)
                {
                // Not at end of string, so no match.
                return FALSE;
                }
             pszString = _mbsinc(pszString);
             break;

          #if FALSE
          case '[':
             // Match a set of characters.
             if (*pszString == 0)
                {
                // Syntax error, no matching close bracket "]".
                return FALSE;
                }

             pchRangeLow = 0;
             while (*pszPattern)
                {
                if (*pszPattern == ']')
                   {
                   // End of char set, no match found.
                   return FALSE;
                   }

                if (*pszPattern == '-')
                   {
                   // check a range of chars?
                   pszPattern = _mbsinc(pszPattern);

                   // get high limit of range:
                   if ((*pszPattern == 0)||(*pszPattern == ']'))
                      {
                      // Syntax error.
                      return FALSE;
                      }

                   if ( (_mbsnicoll(pszString,pchRangeLow,1) >= 0)
                      &&(_mbsnicoll(pszString,pszPattern,1) <= 0))
                      {
                      // In range, go to next character.
                      break;
                      }
                   }

                pchRangeLow = pchPattern;

                // See if character matches this pattern element.
                if (_mbsnicoll(pszString,pszPattern,1) == 0)
                   {
                   // Character match, go on.
                   break;
                   }

                pszPattern = _mbsinc(pszPattern);
                }

             // Have a match in the character set, skip to the end of the set.
             while ((*pszPattern != 0)&&(*pszPattern != ']'))
                {
                pszPattern = _mbsinc(pszPattern);
                }

             break;
             #endif

          case 0:
             // End of pattern, return TRUE if at end of string.
             return ((*pszString)? FALSE : TRUE);

          default:
             // Check for exact character match.
             if (_mbsnicoll(pszString,pszPattern,1))
                {
                // No match.
                return FALSE;
                }
             pszString = _mbsinc(pszString);
             break;
          }

          pszPattern = _mbsinc(pszPattern);
       }

    // Can never exit from here.
}

#if FALSE
    ... not currently used ...
//-------------------------------------------------------------------------
//  MatchRE()
//
//  Match the test string (pszString) against the specifed pattern. If they
//  match return TRUE, else return FALSE.
//
//  In this function patterns are made up from "literal" characters plus
//  some control characters, "*", "?", "[" and "]". Asterix (*) is a place
//  holder for "zero or more" of any character. Question Mark (?) is a place
//  holder for "any single character". The square brackets ([]) contain a
//  list of matching characters, in this case "-" is used to denote a range
//  of characters (i.e. [a-zA-Z] matches any alpha character).
//
//  Note: Currently there is no support for "or" (|) operator.
//
//  Note: Ranges are simple, there is no support for dash at the begining
//        of a range to denote the dash itself.
//-------------------------------------------------------------------------
BOOL MatchRE( unsigned char *pszString,
              unsigned char *pszPattern )
{
    unsigned char ch;
    unsigned char chPattern;
    unsigned char chRangeLow;

    while (TRUE)
       {
       // Walk throuh the pattern, matching it against the string.
       switch (chPattern = *pszPattern++)
          {
          case '*':
             // Match zero or more characters.
             while (*pszString)
                {
                if (MatchRE(pszString++,pszPattern))
                   {
                   return TRUE;
                   }
                }
                return MatchRE(pszString,pszPattern);

          case '?':
             // Match any single character.
             if (*pszString++ == 0)
                {
                // Not at end of string, so no match.
                return FALSE;
                }
             break;

          case '[':
             // Match a set of characters.
             if ( (ch = *pszString++) == 0)
                {
                // Syntax error, no matching close bracket "]".
                return FALSE;
                }

             // ch = toupper(ch);
             chRangeLow = 0;
             while (chPattern = *pszPattern++)
                {
                if (chPattern == ']')
                   {
                   // End of char set, no match found.
                   return FALSE;
                   }

                if (chPattern == '-')
                   {
                   // check a range of chars?
                   chPattern = *pszPattern;           // get high limit of range
                   if ((chPattern == 0)||(chPattern == ']'))
                      {
                      // Syntax error.
                      return FALSE;
                      }

                   if ((ch >= chRangeLow)&&(ch <= chPattern))
                      {
                      // In range, go to next character.
                      break;
                      }
                   }

                chRangeLow = chPattern;
                // See if character matches this pattern element.
                if (ch == chPattern)
                   {
                   // Character match, go on.
                   break;
                   }
                }

             // Have a match in the character set, skip to the end of the set.
             while ((chPattern)&&(chPattern != ']'))
                {
                chPattern = *pszPattern++;
                }

             break;

          case 0:
             // End of pattern, return TRUE if at end of string.
             return ((*pszString)? FALSE : TRUE);

          default:
             ch = *pszString++;
             // Check for exact character match.
             // Note: CASE doesn't matter...
             if (tolower(ch) != tolower(chPattern))
                {
                // No match.
                return FALSE;
                }
             break;
          }
       }

    // Can never exit from here.
}

//-------------------------------------------------------------------------
//  MatchREList()
//
//  Match a string against a list (array) of RE pattens, return TRUE iff
//  the string matches one of the RE patterns. The list of patterns is a
//  NULL terminated array of pointers to RE pattern strings.
//-------------------------------------------------------------------------
BOOL MatchREList( unsigned char  *pszString,
                  unsigned char **ppszREList  )
{
   unsigned char *pszPattern;

   if (ppszREList)
      {
      pszPattern = *ppszREList;
      while (pszPattern)
         {
         if (MatchRE(pszString,pszPattern))
            {
            return TRUE;
            }

         pszPattern = *(++ppszREList);
         }
      }

   return FALSE;
}

//-------------------------------------------------------------------------
//  MatchExactList()
//
//-------------------------------------------------------------------------
BOOL MatchExactList( unsigned char  *pszString,
                     unsigned char **ppszREList )
{
   unsigned char *pszPattern;

   if (ppszREList)
      {
      pszPattern = *ppszREList;
      while (pszPattern)
         {
         if (!_mbsicmp(pszString,pszPattern))
            {
            return TRUE;
            }

         pszPattern = *(++ppszREList);
         }
      }

   return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\rpcproxy\registry.cpp ===
//---------------------------------------------------------------------
//  Copyright (C)1998 Microsoft Corporation, All Rights Reserved.
//
//  registry.cpp
//
//---------------------------------------------------------------------

#define UNICODE
#define INITGUID

#include <sysinc.h>
#include <malloc.h>
#include <winsock2.h>
#include <olectl.h>   // for: SELFREG_E_CLASS
#include <iadmw.h>    // COM Interface header 
#include <iiscnfg.h>  // MD_ & IIS_MD_ #defines
#include <httpfilt.h>
#include <httpext.h>
#include <ecblist.h>
#include <registry.h>
#include <filter.h>
#include <iwamreg.h>
#include <align.h>
#include <util.hxx>
#include <osfpcket.hxx>
#include <iads.h>
#include <adshlp.h>
#include <resource.h>
#include <iiisext.h>
#include <iisext_i.c>

// uncomment to debug setup problems

/*
#ifndef DBG_REG
#define DBG_REG 1
#endif  // DBG_REG

#define DBG_ERROR 1

*/

// this defines control whether we will compile for the IIS security
// console or for the lockdown list.
#define IIS_SEC_CONSOLE     1
//#define IIS_LOCKDOWN_LIST

//----------------------------------------------------------------
//  Globals:
//----------------------------------------------------------------

const rpcconn_tunnel_settings EchoRTS =
    {
        {
        OSF_RPC_V20_VERS,
        OSF_RPC_V20_VERS_MINOR,
        rpc_rts,
        PFC_FIRST_FRAG | PFC_LAST_FRAG,
            {
            NDR_LOCAL_CHAR_DREP | NDR_LOCAL_INT_DREP,
            NDR_LOCAL_FP_DREP,
            0,
            0
            },
        FIELD_OFFSET(rpcconn_tunnel_settings, Cmd) + ConstPadN(FIELD_OFFSET(rpcconn_tunnel_settings, Cmd), 4),
        0,
        0
        },
    RTS_FLAG_ECHO,
    0
    };

const BYTE *GetEchoRTS (
    OUT ULONG *EchoRTSSize
    )
{
    *EchoRTSSize = FIELD_OFFSET(rpcconn_tunnel_settings, Cmd)
        + ConstPadN(FIELD_OFFSET(rpcconn_tunnel_settings, Cmd), 4);

    return (const BYTE *)&EchoRTS;
}

HMODULE g_hInst = NULL;

//----------------------------------------------------------------
//  AnsiToUnicode()
//
//  Convert an ANSI string to a UNICODE string.
//----------------------------------------------------------------
DWORD AnsiToUnicode( IN  UCHAR *pszString,
                     IN  ULONG  ulStringLen,
                     OUT WCHAR *pwsString    )
{
    if (!pszString)
       {
       if (!pwsString)
          {
          return NO_ERROR;
          }
       else
          {
          pwsString[0] = 0;
          return NO_ERROR;
          }
       }

    if (!MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                              (char*)pszString, 1+ulStringLen,
                              pwsString, 1+ulStringLen ))
       {
       return ERROR_NO_UNICODE_TRANSLATION;
       }

    return NO_ERROR;
}

//---------------------------------------------------------------------
//  RegSetKeyAndValueIfDontExist()
//
//  Private helper function for SetupRegistry() that checks if a key exists,
//  and if not, creates a key, sets a value, then closes the key. If key
//  exists, it is not touched.
//
//  Parameters:
//    pwsKey       WCHAR* The name of the key
//    pwsSubkey    WCHAR* The name of a subkey
//    pwsValueName WCHAR* The value name.
//    pwsValue     WCHAR* The data value to store
//    dwType       The type for the new registry value.
//    dwDataSize   The size for non-REG_SZ registry entry types.
//
//  Return:
//    BOOL         TRUE if successful, FALSE otherwise.
//---------------------------------------------------------------------
BOOL RegSetKeyAndValueIfDontExist( const WCHAR *pwsKey,
                        const WCHAR *pwsSubKey,
                        const WCHAR *pwsValueName,
                        const WCHAR *pwsValue,
                        const DWORD  dwType = REG_SZ,
                              DWORD  dwDataSize = 0 )
    {
    HKEY   hKey;
    DWORD  dwSize = 0;
    WCHAR  *pwsCompleteKey;
    DWORD dwTypeFound;
    long Error;

    if (pwsKey)
        dwSize = wcslen(pwsKey);

    if (pwsSubKey)
        dwSize += wcslen(pwsSubKey);

    dwSize = (1+1+dwSize)*sizeof(WCHAR);  // Extra +1 for the backslash...

    pwsCompleteKey = (WCHAR*)_alloca(dwSize);

    wcscpy(pwsCompleteKey,pwsKey);

    if (NULL!=pwsSubKey)
        {
        wcscat(pwsCompleteKey, TEXT("\\"));
        wcscat(pwsCompleteKey, pwsSubKey);
        }

    if ((Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                  pwsCompleteKey,
                                  0,
                                  KEY_WRITE | KEY_QUERY_VALUE,
                                  &hKey) ) == ERROR_SUCCESS )
        {
        if (( Error = RegQueryValueEx(
                        hKey,
                        pwsValueName,
                        0,
                        &dwTypeFound,
                        NULL,
                        NULL
                        ) ) == ERROR_SUCCESS )
            {
            RegCloseKey(hKey);
            return TRUE;
            }

        // the key exists, but the value does not. Fall through to
        // create it
        }
    else 
        {
        if (ERROR_SUCCESS != RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                                       pwsCompleteKey,
                                       0,
                                       NULL,
                                       REG_OPTION_NON_VOLATILE,
                                       KEY_WRITE, NULL, &hKey, NULL))
            {
            return FALSE;
            }
        }

    if (pwsValue)
        {
        if ((dwType == REG_SZ)||(dwType == REG_EXPAND_SZ))
          dwDataSize = (1+wcslen(pwsValue))*sizeof(WCHAR);

        RegSetValueEx( hKey,
                       pwsValueName, 0, dwType, (BYTE *)pwsValue, dwDataSize );
        }
    else
        {
        RegSetValueEx( hKey,
                       pwsValueName, 0, dwType, (BYTE *)pwsValue, 0 );
        }

    RegCloseKey(hKey);
    return TRUE;
    }

const WCHAR * const EVENT_LOG_SOURCE_NAME = L"RPC Proxy";
const WCHAR * const EVENT_LOG_KEY_NAME = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\RPC Proxy";
const ULONG EVENT_LOG_CATEGORY_COUNT = 1;

HRESULT
RegisterEventLog()
{

    HKEY EventLogKey = NULL;
    DWORD Disposition;

    LONG Result =
        RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,                         // handle to open key
            EVENT_LOG_KEY_NAME,                         // subkey name
            0,                                          // reserved
            NULL,                                       // class string
            0,                                          // special options
            KEY_ALL_ACCESS,                             // desired security access
            NULL,                                       // inheritance
            &EventLogKey,                               // key handle 
            &Disposition                                // disposition value buffer
            );

    if ( Result )
        {
#if DBG
        DbgPrint("RPCProxy: Can't create Eventlog key: %X\n", GetLastError());
#endif  // DBG
        return HRESULT_FROM_WIN32( Result );
        }

    DWORD Value = EVENT_LOG_CATEGORY_COUNT;

    Result =
        RegSetValueEx(
            EventLogKey,            // handle to key
            L"CategoryCount",       // value name
            0,                      // reserved
            REG_DWORD,              // value type
            (BYTE*)&Value,          // value data
            sizeof(Value)           // size of value data
            );

    if ( Result )
        {
#if DBG
        DbgPrint("RPCProxy: Can't set CategoryCount value: %X\n", GetLastError());
#endif  // DBG
        goto error;
        }

    const WCHAR MessageFileName[] = L"%SystemRoot%\\system32\\rpcproxy\\rpcproxy.dll";
    const DWORD MessageFileNameSize = sizeof( MessageFileName );

    Result =
        RegSetValueEx(
            EventLogKey,                    // handle to key
            L"CategoryMessageFile",         // value name
            0,                              // reserved
            REG_EXPAND_SZ,                  // value type
            (const BYTE*)MessageFileName,   // value data
            MessageFileNameSize             // size of value data
            );

    if ( Result )
        {
#if DBG
        DbgPrint("RPCProxy: Can't set CategoryMessageFile value: %X\n", GetLastError());
#endif  // DBG
        goto error;
        }

    Result =
        RegSetValueEx(
            EventLogKey,                    // handle to key
            L"EventMessageFile",            // value name
            0,                              // reserved
            REG_EXPAND_SZ,                  // value type
            (const BYTE*)MessageFileName,   // value data
            MessageFileNameSize             // size of value data
            );

    if ( Result )
        {
#if DBG
        DbgPrint("RPCProxy: Can't set EventMessageFile value: %X\n", GetLastError());
#endif  // DBG
        goto error;
        }

    Value = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;
    Result =
        RegSetValueEx(
            EventLogKey,            // handle to key
            L"TypesSupported",      // value name
            0,                      // reserved
            REG_DWORD,              // value type
            (BYTE*)&Value,          // value data
            sizeof(Value)           // size of value data
            );

    if ( Result )
        {
#if DBG
        DbgPrint("RPCProxy: Can't set TypesSupported value: %X\n", GetLastError());
#endif  // DBG
        goto error;
        }

    RegCloseKey( EventLogKey );
    EventLogKey = NULL;
    return S_OK;

error:

    if ( EventLogKey )
        {
        RegCloseKey( EventLogKey );
        EventLogKey = NULL;
        }

    if ( REG_CREATED_NEW_KEY == Disposition )
        {
        RegDeleteKey( 
            HKEY_LOCAL_MACHINE,
            EVENT_LOG_KEY_NAME );
        }

    return HRESULT_FROM_WIN32( Result );

}

HRESULT
UnRegisterEventLog()
{

    RegDeleteKey( 
        HKEY_LOCAL_MACHINE,
        EVENT_LOG_KEY_NAME );

    return S_OK;
}

HRESULT
RPCProxyGetStartupInfo( 
    LPSTARTUPINFOA lpStartupInfo )
{

    __try
    {
        GetStartupInfoA( lpStartupInfo );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        return E_OUTOFMEMORY;
    }
    
    return S_OK;

}

BOOL
RegisterOutOfProc(void)
{

    //
    // Runs a child process
    //

    STARTUPINFOA StartupInfo;

    HRESULT Hr = RPCProxyGetStartupInfo( &StartupInfo );

    if ( FAILED( Hr ) )
        {
        SetLastError( Hr );
        return FALSE;
        }

    PROCESS_INFORMATION ProcessInfo;
    CHAR    sApplicationPath[MAX_PATH];
    CHAR   *pApplicationName = NULL;
    CHAR    sCmdLine[MAX_PATH];
    DWORD   dwLen = MAX_PATH;
    DWORD   dwCount;

    dwCount = SearchPathA(NULL,               // Search Path, NULL is PATH
                         "regsvr32.exe",      // Application
                         NULL,                // Extension (already specified)
                         dwLen,               // Length (char's) of sApplicationPath
                         sApplicationPath,    // Path + Name for application
                         &pApplicationName ); // File part of sApplicationPath

    if (dwCount == 0)
        {
        return FALSE;
        }

    if (dwCount > dwLen)
        {
        SetLastError( ERROR_BUFFER_OVERFLOW );
        return FALSE;
        }

    strcpy(sCmdLine, "regsvr32 /s rpcproxy.dll");

    BOOL RetVal = CreateProcessA(
            sApplicationPath,                          // name of executable module
            sCmdLine,                                  // command line string
            NULL,                                      // SD
            NULL,                                      // SD
            FALSE,                                     // handle inheritance option
            CREATE_NO_WINDOW,                          // creation flags
            NULL,                                      // new environment block
            NULL,                                      // current directory name
            &StartupInfo,                              // startup information
            &ProcessInfo                               // process information
        );

    if ( !RetVal )
        return FALSE;

    WaitForSingleObject( ProcessInfo.hProcess, INFINITE );

    DWORD Status;
    GetExitCodeProcess( ProcessInfo.hProcess, &Status );

    CloseHandle( ProcessInfo.hProcess );
    CloseHandle( ProcessInfo.hThread );

    if ( ERROR_SUCCESS == Status )
        return TRUE;

    SetLastError( Status );
    return FALSE;
}

//---------------------------------------------------------------------
//  SetupRegistry()
//
//  Add RPC proxy specific registry entries to contol its operation.
//
//  \HKEY_LOCAL_MACHINE
//     \Software
//         \Microsoft
//             \Rpc
//                 \RpcProxy
//                     \Enabled:REG_DWORD:0x00000001
//                     \ValidPorts:REG_SZ:<hostname>:1-5000
//
//---------------------------------------------------------------------
HRESULT SetupRegistry()
{
    DWORD  dwEnabled = 0x01;
    DWORD  dwSize;
    DWORD  dwStatus;
    WCHAR *pwsValidPorts = 0;
    char   szHostName[MAX_TCPIP_HOST_NAME];
    HRESULT hr;

    // Note that gethostname() is an ANSI (non-unicode) function:
    if (SOCKET_ERROR == gethostname(szHostName,sizeof(szHostName)))
        {
        dwStatus = WSAGetLastError();
        return SELFREG_E_CLASS;
        }

    dwSize = 1 + _mbstrlen(szHostName);
    pwsValidPorts = (WCHAR*)MemAllocate( sizeof(WCHAR)
                                         * (dwSize + wcslen(REG_PORT_RANGE)) );
    if (!pwsValidPorts)
        {
        return E_OUTOFMEMORY;
        }

    dwStatus = AnsiToUnicode((unsigned char*)szHostName,dwSize,pwsValidPorts);
    if (dwStatus != NO_ERROR)
        {
        MemFree(pwsValidPorts);
        return SELFREG_E_CLASS;
        }

    wcscat(pwsValidPorts,REG_PORT_RANGE);

    if (  !RegSetKeyAndValueIfDontExist( REG_RPC_PATH,
                              REG_RPCPROXY,
                              REG_ENABLED,
                              (unsigned short *)&dwEnabled,
                              REG_DWORD,
                              sizeof(DWORD))

       || !RegSetKeyAndValueIfDontExist( REG_RPC_PATH,
                              REG_RPCPROXY,
                              REG_VALID_PORTS,
                              pwsValidPorts,
                              REG_SZ) )
        {
        MemFree(pwsValidPorts);
        return SELFREG_E_CLASS;
        }

    MemFree(pwsValidPorts);

    hr = RegisterEventLog ();

    return hr;
}

//---------------------------------------------------------------------
//  CleanupRegistry()
//
//  Delete the RpcProxy specific registry entries.
//---------------------------------------------------------------------
HRESULT CleanupRegistry()
{
    HRESULT  hr;
    LONG     lStatus;
    DWORD    dwLength = sizeof(WCHAR) + sizeof(REG_RPC_PATH)
                                      + sizeof(REG_RPCPROXY);
    WCHAR   *pwsSubKey;

    pwsSubKey = (WCHAR*)_alloca(sizeof(WCHAR)*dwLength);

    wcscpy(pwsSubKey,REG_RPC_PATH);
    wcscat(pwsSubKey,TEXT("\\"));
    wcscat(pwsSubKey,REG_RPCPROXY);

    lStatus = RegDeleteKey( HKEY_LOCAL_MACHINE,
                            pwsSubKey );

    (void) UnRegisterEventLog ();

    return S_OK;
}

//---------------------------------------------------------------------
//  GetMetaBaseString()
//
//  Retrieve a string value from the metabase.
//---------------------------------------------------------------------
HRESULT GetMetaBaseString( IN  IMSAdminBase    *pIMeta,
                           IN  METADATA_HANDLE  hMetaBase,
                           IN  WCHAR           *pwsKeyPath,
                           IN  DWORD            dwIdent,
                           OUT WCHAR           *pwsBuffer,
                           IN OUT DWORD        *pdwBufferSize )
    {
    HRESULT  hr;
    DWORD    dwSize;
    METADATA_RECORD *pmbRecord;

    dwSize = sizeof(METADATA_RECORD);

    pmbRecord = (METADATA_RECORD*)MemAllocate(dwSize);
    if (!pmbRecord)
        {
        return ERROR_OUTOFMEMORY;
        }

    memset(pmbRecord,0,dwSize);

    pmbRecord->dwMDIdentifier = dwIdent;
    pmbRecord->dwMDAttributes = 0;  // METADATA_INHERIT;
    pmbRecord->dwMDUserType = IIS_MD_UT_SERVER;
    pmbRecord->dwMDDataType = STRING_METADATA;
    pmbRecord->dwMDDataLen = *pdwBufferSize;
    pmbRecord->pbMDData = (BYTE*)pwsBuffer;

    hr = pIMeta->GetData( hMetaBase,
                          pwsKeyPath,
                          pmbRecord,
                          &dwSize );
    #ifdef DBG_REG
    if (FAILED(hr))
        {
        DbgPrint("pIMeta->GetData(): Failed: 0x%x\n",hr);
        }
    #endif

    MemFree(pmbRecord);

    return hr;
    }

//---------------------------------------------------------------------
//  SetMetaBaseString()
//
//  Store a string value into the metabase.
//---------------------------------------------------------------------
HRESULT SetMetaBaseString( IMSAdminBase    *pIMeta,
                           METADATA_HANDLE  hMetaBase,
                           WCHAR           *pwsKeyPath,
                           DWORD            dwIdent,
                           WCHAR           *pwsBuffer,
                           DWORD            dwAttributes,
                           DWORD            dwUserType )
    {
    HRESULT  hr;
    METADATA_RECORD MbRecord;

    memset(&MbRecord,0,sizeof(MbRecord));

    MbRecord.dwMDIdentifier = dwIdent;
    MbRecord.dwMDAttributes = dwAttributes;
    MbRecord.dwMDUserType = dwUserType;
    MbRecord.dwMDDataType = STRING_METADATA;
    MbRecord.dwMDDataLen = sizeof(WCHAR) * (1 + wcslen(pwsBuffer));
    MbRecord.pbMDData = (BYTE*)pwsBuffer;

    hr = pIMeta->SetData( hMetaBase,
                          pwsKeyPath,
                          &MbRecord );

    return hr;
    }

#if IIS_LOCKDOWN_LIST
HRESULT
AddDllToIISList(
    SAFEARRAY* Array )
{

    //
    // Add the ISAPI to the IIS list.   
    //

    HRESULT Hr;
    WCHAR ExtensionPath[ MAX_PATH ];

    DWORD dwRet = 
        GetModuleFileNameW(
            g_hInst,
            ExtensionPath,
            MAX_PATH );

    if ( !dwRet )
        return HRESULT_FROM_WIN32( GetLastError() );

    // Search for the DLL.  If its already in the list, do nothing

    Hr = SafeArrayLock( Array );
    if ( FAILED( Hr ) )
        return Hr;

    for ( unsigned int i = Array->rgsabound[0].lLbound; 
         i < Array->rgsabound[0].lLbound + Array->rgsabound[0].cElements; i++ )
        {

        VARIANT & IElem = ((VARIANT*)Array->pvData)[i];

        if ( _wcsicmp( (WCHAR*)IElem.bstrVal, ExtensionPath ) == 0 )
            {
            SafeArrayUnlock( Array );
            return S_OK;
            }

        }

    // Need to add the DLL

    SAFEARRAYBOUND SafeBounds;
    SafeBounds.lLbound      = Array->rgsabound[0].lLbound;
    SafeBounds.cElements    = Array->rgsabound[0].cElements+1;

    SafeArrayUnlock( Array );

    Hr = SafeArrayRedim( Array, &SafeBounds );
    if ( FAILED( Hr ) )
        return Hr;

    VARIANT bstrvar;
    VariantInit( &bstrvar );
    bstrvar.vt = VT_BSTR;
    bstrvar.bstrVal = SysAllocString( ExtensionPath );
    long Index = SafeBounds.lLbound + SafeBounds.cElements - 1;

    Hr = SafeArrayPutElement( Array, &Index, (void*)&bstrvar );
    
    VariantClear( &bstrvar );
    if ( FAILED( Hr ) )
        return Hr;

    return S_OK;
    
}

HRESULT
RemoveDllFromIISList(
    SAFEARRAY *Array )
{

    // Remove the DLL from the IIS list

    HRESULT Hr;
    WCHAR ExtensionPath[ MAX_PATH ];

    DWORD dwRet = 
        GetModuleFileNameW(
            g_hInst,
            ExtensionPath,
            MAX_PATH );

    if ( !dwRet )
        return HRESULT_FROM_WIN32( GetLastError() );

    Hr = SafeArrayLock( Array );
    if ( FAILED( Hr ) )
        return Hr;

    ULONG  NewSize = 0;
    SIZE_T j = Array->rgsabound[0].lLbound;
    SIZE_T k = Array->rgsabound[0].lLbound + Array->rgsabound[0].cElements;
    
    while( j < k )
        {

        VARIANT & JElem = ((VARIANT*)Array->pvData)[j];

        // This element is fine, keep it
        if ( 0 != _wcsicmp( (WCHAR*)JElem.bstrVal, ExtensionPath ) )
            {
            NewSize++;
            j++;
            }

        else
            {

            // find a suitable element to replace the bad element with
            while( j < --k )
                {
                VARIANT & KElem = ((VARIANT*)Array->pvData)[k];
                if ( 0 != _wcsicmp( (WCHAR*)KElem.bstrVal,  ExtensionPath ) )
                    {
                    // found element. move it
                    VARIANT temp = JElem;
                    JElem = KElem;
                    KElem = temp;
                    break;
                    }
                }
            }
        }

    SAFEARRAYBOUND ArrayBounds;
    ArrayBounds = Array->rgsabound[0];
    ArrayBounds.cElements = NewSize;

    SafeArrayUnlock( Array );

    Hr = SafeArrayRedim( Array, &ArrayBounds );

    if ( FAILED( Hr ) )
        return Hr;

    return S_OK;
}

#endif // #if #if IIS_LOCKDOWN_LIST

#if IIS_SEC_CONSOLE

HRESULT
EnableRpcProxyExtension (
    void
    )
/*++

Routine Description:

    Enables the rpc proxy extension in the list of IIS ISAPI extensions.

Arguments:


Return Value:

    Standard HRESULT

--*/
{
    HRESULT hr;
    WCHAR* wszRootWeb6 = L"IIS://LOCALHOST/W3SVC";
    IISWebService * pWeb = NULL;
    VARIANT var1,var2;
    BSTR ExtensionPath = NULL;
    BSTR ExtensionGroup = NULL;
    BSTR ExtensionDescription = NULL;
    WCHAR FilterPath[ MAX_PATH + 1 ];
    WCHAR ExtensionNameBuffer[ MAX_PATH ];
    DWORD dwRet;

    hr = ADsGetObject(wszRootWeb6, IID_IISWebService, (void**)&pWeb);

    if (SUCCEEDED(hr) && NULL != pWeb)
        {
        VariantInit(&var1);
        VariantInit(&var2);

        var1.vt = VT_BOOL;
        var1.boolVal = VARIANT_TRUE;

        var2.vt = VT_BOOL;
        var2.boolVal = VARIANT_TRUE;

        dwRet = GetModuleFileNameW(
                g_hInst,
                FilterPath,
                MAX_PATH );

        if ( (dwRet > 0) && (dwRet != MAX_PATH))
            {
            FilterPath[MAX_PATH] = '\0';
            ASSERT(GetLastError() == NO_ERROR);
            }
        else
            {
            ASSERT(GetLastError() != NO_ERROR);
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto CleanupAndExit;
            }

        if (! LoadStringW(g_hInst,              // handle to resource module
                          IDS_EXTENSION_NAME,   // resource identifier
                          ExtensionNameBuffer,        // resource buffer
                          MAX_PATH ) )          // size of buffer
            {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto CleanupAndExit;
            }

        ExtensionPath = SysAllocString(FilterPath);
        if (ExtensionPath == NULL)
            {
            hr = E_OUTOFMEMORY;
            goto CleanupAndExit;
            }

        ExtensionGroup = SysAllocString(L"RPCProxy");
        if (ExtensionGroup == NULL)
            {
            hr = E_OUTOFMEMORY;
            goto CleanupAndExit;
            }

        ExtensionDescription = SysAllocString(ExtensionNameBuffer);
        if (ExtensionDescription == NULL)
            {
            hr = E_OUTOFMEMORY;
            goto CleanupAndExit;
            }

        // During an upgrade the extension will already exist, so the API will fail. 
        hr = pWeb->AddExtensionFile(ExtensionPath, var1, ExtensionGroup, var2, ExtensionDescription);

        if (SUCCEEDED(hr))
            {
            hr = pWeb->AddDependency(ExtensionPath, ExtensionGroup);
            if (SUCCEEDED(hr))
                {
                hr = S_OK;
                }
            }
        else
            {
            if (HRESULT_CODE(hr) == ERROR_DUP_NAME)
                {
                hr = S_OK;
                }
            else
                {
                #ifdef DBG_ERROR
                DbgPrint("pWeb->AddExtensionFile failed: %X\r\n", hr);
                #endif
                // fall through with hr
                }
            }

        VariantClear(&var1);
        VariantClear(&var2);
        pWeb->Release();
        }
    else
        {
        #ifdef DBG_ERROR
        DbgPrint("FAIL:no object: %X\r\n", hr);
        #endif
        // fall through with hr
        }

CleanupAndExit:
    if (ExtensionPath != NULL)
        SysFreeString(ExtensionPath);

    if (ExtensionGroup != NULL)
        SysFreeString(ExtensionGroup);

    if (ExtensionDescription != NULL)
        SysFreeString(ExtensionDescription);

    return hr;
}

HRESULT
DisableRpcProxyExtension (
    void
    )
/*++

Routine Description:

    Disables the rpc proxy extension in the list of IIS ISAPI extensions.

Arguments:


Return Value:

    Standard HRESULT

--*/
{
    BSTR ExtensionPath = NULL;
    HRESULT hr;
    WCHAR* wszRootWeb6 = L"IIS://LOCALHOST/W3SVC";
    IISWebService * pWeb = NULL;
    DWORD dwRet;
    WCHAR FilterPath[ MAX_PATH + 1 ];

    hr = ADsGetObject(wszRootWeb6, IID_IISWebService, (void**)&pWeb);

    if (SUCCEEDED(hr) && NULL != pWeb)
        {
        dwRet = GetModuleFileNameW(
                g_hInst,
                FilterPath,
                MAX_PATH );

        if ( (dwRet > 0) && (dwRet != MAX_PATH))
            {
            FilterPath[MAX_PATH] = '\0';
            ASSERT(GetLastError() == NO_ERROR);
            }
        else
            {
            ASSERT(GetLastError() != NO_ERROR);
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto CleanupAndExit;
            }

        ExtensionPath = SysAllocString(FilterPath);
        if (ExtensionPath == NULL)
            {
            hr = E_OUTOFMEMORY;
            goto CleanupAndExit;
            }

        // Call DeleteExtensionFileRecord for each of the DLLs you are removing 
        // from the system.  This removes entries from WSERL.
        hr = pWeb->DeleteExtensionFileRecord(ExtensionPath);

        if (SUCCEEDED(hr))
            {
            // Call RemoveApplication (pYourAppName) - this removes your entry from 
            // ApplicationDependencies
            hr = pWeb->RemoveApplication(ExtensionPath);
            // fall through with the hr
            }
        else
            {
            #ifdef DBG_ERROR
            DbgPrint("pWeb->DeleteExtensionFileRecord failed: %X\r\n", hr);
            #endif
            // fall through with the hr
            }
        }
    else
        {
        // fall through with the hr
        }

CleanupAndExit:
    if (ExtensionPath != NULL)
        SysFreeString(ExtensionPath);

    return hr;
}

#endif  // #if IIS_SEC_CONSOLE

#if IIS_LOCKDOWN_LIST
HRESULT
ModifyLockdownList( bool Add )
{

    // Toplevel function to modify the IIS lockdown list.
    // If Add is 1, then the ISAPI is added.  If Add is 0, then the ISAPI is removed.

    HRESULT Hr;
    IADs *Service       = NULL;
    SAFEARRAY* Array    = NULL;
    bool ArrayLocked    = false;

    VARIANT var;
    VariantInit( &var );

    Hr = ADsGetObject( BSTR( L"IIS://LocalHost/W3SVC" ), __uuidof( IADs ), (void**)&Service );
    if ( FAILED( Hr ) )
        return Hr;

    Hr = Service->Get( BSTR( L"IsapiRestrictionList" ), &var );
    if ( FAILED(Hr) )
        {
        // This property doesn't exist on IIS5 or IIS5.1 don't install it
        Hr = S_OK;
        goto cleanup;
        }

    Array = var.parray;

    Hr = SafeArrayLock( Array );
    if ( FAILED( Hr ) )
        goto cleanup;
    
    ArrayLocked = true;

    if ( !Array->rgsabound[0].cElements )
        {
        // The array has no elements which means no restrictions.
        Hr = S_OK;
        goto cleanup;
        }

    VARIANT & FirstElem = ((VARIANT*)Array->pvData)[ Array->rgsabound[0].lLbound ];
    if ( _wcsicmp(L"0", (WCHAR*)FirstElem.bstrVal ) == 0 )
        {

        // 
        // According to the IIS6 spec, a 0 means that all ISAPIs are denied except
        // those that are explicitly listed.  
        // 
        // If installing:   add to the list. 
        // If uninstalling: remove from the list
        //

        SafeArrayUnlock( Array );
        ArrayLocked = false;

        if ( Add )
            Hr = AddDllToIISList( Array );
        else
            Hr = RemoveDllFromIISList( Array );

        if ( FAILED( Hr ) )
            goto cleanup;

        }
    else if ( _wcsicmp( L"1", (WCHAR*)FirstElem.bstrVal ) == 0 )
        {

        //
        // According to the IIS6 spec, a 1 means that all ISAPIs are allowed except
        // those that are explicitly denied. 
        //
        // If installing:   remove from the list
        // If uninstalling: Do nothing
        //

        SafeArrayUnlock( Array );
        ArrayLocked = false;

        if ( Add )
            {
            Hr = RemoveDllFromIISList( Array );

            if ( FAILED( Hr ) )
                goto cleanup;
            }

        }
    else
        {
        Hr = E_FAIL;
        goto cleanup;
        }

    Hr = Service->Put( BSTR( L"IsapiRestrictionList" ), var );
    if ( FAILED( Hr ) )
        goto cleanup;

    Hr = Service->SetInfo();
    if ( FAILED( Hr ) )
        goto cleanup;

    Hr = S_OK;
    
cleanup:

    if ( Array && ArrayLocked )
        SafeArrayUnlock( Array );

    if ( Service )
        Service->Release();
    
    VariantClear( &var );

    return Hr;

}

HRESULT
AddToLockdownListDisplayPutString( 
    SAFEARRAY *Array,
    unsigned long Position,
    const WCHAR *String )
{

    HRESULT Hr;
    VARIANT Var;

    VariantInit( &Var );
    Var.vt          =   VT_BSTR;
    Var.bstrVal     =   SysAllocString( String );

    if ( !Var.bstrVal )
        return E_OUTOFMEMORY;

    long Index = (unsigned long)Position;
    Hr = SafeArrayPutElement( Array, &Index, (void*)&Var );

    VariantClear( &Var );
    return Hr;

}

HRESULT
AddToLockdownListDisplay( SAFEARRAY *Array )
{

    HRESULT Hr;
    WCHAR FilterPath[ MAX_PATH ];

    DWORD dwRet = 
        GetModuleFileNameW(
            g_hInst,
            FilterPath,
            MAX_PATH );

    if ( !dwRet )
        return HRESULT_FROM_WIN32( GetLastError() );

    WCHAR ExtensionName[ MAX_PATH ];
    if (! LoadStringW(g_hInst,              // handle to resource module
                      IDS_EXTENSION_NAME,   // resource identifier
                      ExtensionName,        // resource buffer
                      MAX_PATH ) )          // size of buffer
        return HRESULT_FROM_WIN32( GetLastError() );


    //
    //  Check to see if the ISAPI is already in the list.  If it is, don't modify 
    //  list.
    //

    Hr = SafeArrayLock( Array );

    if ( FAILED( Hr ) )
        return Hr;

    for( unsigned long i = Array->rgsabound[0].lLbound;
         i < Array->rgsabound[0].lLbound + Array->rgsabound[0].cElements;
         i++ )
        {

        VARIANT & CurrentElement = ((VARIANT*)Array->pvData)[ i ];
        BSTR BSTRString = CurrentElement.bstrVal;

        if ( _wcsicmp( (WCHAR*)BSTRString, FilterPath ) == 0 )
            {
            // ISAPI is already in the list, don't do anything
            SafeArrayUnlock( Array );
            return S_OK;
            }

        }

     
    SAFEARRAYBOUND SafeArrayBound = Array->rgsabound[0];
    unsigned long OldSize = SafeArrayBound.cElements;
    SafeArrayBound.cElements += 3;
    SafeArrayUnlock( Array );

    Hr = SafeArrayRedim( Array, &SafeArrayBound );
    if ( FAILED( Hr ) )
        return Hr;

    Hr = AddToLockdownListDisplayPutString( Array, OldSize, L"1" );
    if ( FAILED( Hr ) )
        return Hr;

    Hr = AddToLockdownListDisplayPutString( Array, OldSize + 1, FilterPath );
    if ( FAILED( Hr ) )
        return Hr;

    Hr = AddToLockdownListDisplayPutString( Array, OldSize + 2, ExtensionName );
    if ( FAILED( Hr ) )
        return Hr;

    return S_OK;
}

HRESULT
SafeArrayRemoveSlice(
    SAFEARRAY *Array,
    unsigned long lBound,
    unsigned long uBound )
{

    // Remove a slice of an array.

    SIZE_T ElementsToRemove = uBound - lBound + 1;
    
    HRESULT Hr = SafeArrayLock( Array );

    if ( FAILED( Hr ) )
        return Hr;

    if ( uBound + 1 < Array->rgsabound[0].cElements )
        {
        // At least one element exists above this element

        // Step 1, move slice to temp storage

        VARIANT *Temp = (VARIANT*)_alloca( sizeof(VARIANT) * ElementsToRemove );
        memcpy( Temp, &((VARIANT*)Array->pvData)[ lBound ], sizeof(VARIANT)*ElementsToRemove );

		// Step 2, collapse hole left by slice
        memmove( &((VARIANT*)Array->pvData)[ lBound ],
                 &((VARIANT*)Array->pvData)[ uBound + 1 ],
                 sizeof(VARIANT) * ( Array->rgsabound[0].cElements - ( uBound + 1 ) ) );

		// Step 3, move slice to end of array
		memcpy( &((VARIANT*)Array->pvData)[ Array->rgsabound[0].cElements - ElementsToRemove ],
			    Temp,
				sizeof(VARIANT)*ElementsToRemove );

        }

    SAFEARRAYBOUND SafeArrayBound = Array->rgsabound[0];
    SafeArrayBound.cElements -= (ULONG)ElementsToRemove;

    SafeArrayUnlock( Array );

    return SafeArrayRedim( Array, &SafeArrayBound );

}

HRESULT
RemoveFromLockdownListDisplay(
    SAFEARRAY *Array )
{

    HRESULT Hr;
    WCHAR FilterPath[ MAX_PATH ];

    DWORD dwRet = 
        GetModuleFileNameW(
            g_hInst,
            FilterPath,
            MAX_PATH );

    if ( !dwRet )
        return HRESULT_FROM_WIN32( GetLastError() );

    Hr = SafeArrayLock( Array );

    if ( FAILED( Hr ) )
        return Hr;

    for( unsigned int i = Array->rgsabound[0].lLbound;
         i < Array->rgsabound[0].lLbound + Array->rgsabound[0].cElements;
         i++ )
        {

        VARIANT & CurrentElement = ((VARIANT*)Array->pvData)[ i ];
        BSTR BSTRString = CurrentElement.bstrVal;

        if ( _wcsicmp( (WCHAR*)BSTRString, FilterPath ) == 0 )
            {
            // ISAPI is in the list, remove it

            Hr = SafeArrayUnlock( Array );
            
            if ( FAILED( Hr ) )
                return Hr;

            Hr = SafeArrayRemoveSlice( 
                Array,
                (i == 0) ? 0 : i - 1,
                min( i + 1, Array->rgsabound[0].cElements - 1 ) );

            return Hr;

            }

        }

    // ISAPI wasn't found. Nothing to do.

    SafeArrayUnlock( Array );
    return S_OK;

}

HRESULT
ModifyLockdownListDisplay( bool Add )
{
 
    HRESULT Hr;
    SAFEARRAY* Array    = NULL;
    IADs *Service       = NULL;

    VARIANT var;
    VariantInit( &var );

    Hr = ADsGetObject( BSTR( L"IIS://LocalHost/W3SVC" ), __uuidof( IADs ), (void**)&Service );
    if ( FAILED( Hr ) )
        {
    #ifdef DBG_REG
        DbgPrint("RpcProxy: ADsGetObject(): Failed: 0x%x (%d)\n",
                Hr, Hr );
    #endif
        return Hr;
        }

    Hr = Service->Get( BSTR( L"RestrictionListCustomDesc" ), &var );
    if ( FAILED(Hr) )
        {
    #ifdef DBG_REG
        DbgPrint("RpcProxy: Service->Get(): Failed: 0x%x (%d)\n",
                Hr, Hr );
    #endif
        // This property doesn't exist on IIS5 or IIS5.1 don't install or uninstall it
        Hr = S_OK;
        goto cleanup;
        }

    Array = var.parray;

    if ( Add )
        Hr = AddToLockdownListDisplay( Array );
    else 
        Hr = RemoveFromLockdownListDisplay( Array );

    if ( FAILED( Hr ) )
        {
    #ifdef DBG_REG
        DbgPrint("RpcProxy: AddToLockdownListDisplay/RemoveFromLockdownListDisplay(): Failed: 0x%x (%d)\n",
                Hr, Hr );
    #endif
        goto cleanup;
        }

    Hr = Service->Put( BSTR( L"RestrictionListCustomDesc" ), var );
    if ( FAILED( Hr ) )
        {
    #ifdef DBG_REG
        DbgPrint("RpcProxy: Service->Put(): Failed: 0x%x (%d)\n",
                Hr, Hr );
    #endif
        goto cleanup;
        }

    Hr = Service->SetInfo();
    if ( FAILED( Hr ) )
        {
    #ifdef DBG_REG
        DbgPrint("RpcProxy: Service->SetInfo(): Failed: 0x%x (%d)\n",
                Hr, Hr );
    #endif
        goto cleanup;
        }

cleanup:
    VariantClear( &var );
    if ( Service )
        Service->Release();

    return Hr;
}

#endif // #if IIS_LOCKDOWN_LIST

//---------------------------------------------------------------------
//  GetMetaBaseDword()
//
//  Get a DWORD value from the metabase.
//---------------------------------------------------------------------
HRESULT GetMetaBaseDword( IMSAdminBase    *pIMeta,
                          METADATA_HANDLE  hMetaBase,
                          WCHAR           *pwsKeyPath,
                          DWORD            dwIdent,
                          DWORD           *pdwValue )
    {
    HRESULT  hr;
    DWORD    dwSize;
    METADATA_RECORD MbRecord;

    memset(&MbRecord,0,sizeof(MbRecord));
    *pdwValue = 0;

    MbRecord.dwMDIdentifier = dwIdent;
    MbRecord.dwMDAttributes = 0;
    MbRecord.dwMDUserType = IIS_MD_UT_SERVER;
    MbRecord.dwMDDataType = DWORD_METADATA;
    MbRecord.dwMDDataLen = sizeof(DWORD);
    MbRecord.pbMDData = (unsigned char *)pdwValue;

    hr = pIMeta->GetData( hMetaBase,
                          pwsKeyPath,
                          &MbRecord,
                          &dwSize );

    return hr;
    }

//---------------------------------------------------------------------
//  SetMetaBaseDword()
//
//  Store a DWORD value into the metabase.
//---------------------------------------------------------------------
HRESULT SetMetaBaseDword( IMSAdminBase    *pIMeta,
                          METADATA_HANDLE  hMetaBase,
                          WCHAR           *pwsKeyPath,
                          DWORD            dwIdent,
                          DWORD            dwValue,
                          DWORD            dwAttributes,
                          DWORD            dwUserType )
    {
    HRESULT  hr;
    DWORD    dwSize;
    METADATA_RECORD MbRecord;

    memset(&MbRecord,0,sizeof(MbRecord));

    MbRecord.dwMDIdentifier = dwIdent;
    MbRecord.dwMDAttributes = dwAttributes;
    MbRecord.dwMDUserType = dwUserType;
    MbRecord.dwMDDataType = DWORD_METADATA;
    MbRecord.dwMDDataLen = sizeof(DWORD);
    MbRecord.pbMDData = (unsigned char *)&dwValue;

    hr = pIMeta->SetData( hMetaBase,
                          pwsKeyPath,
                          &MbRecord );

    return hr;
    }

RPC_STATUS 
GetIISConnectionTimeout (
    OUT ULONG *ConnectionTimeout
    )
/*++

Routine Description:

    Retrieve the connection timeout for IIS:
        W3Svc/1/ROOT/Rpc/ConnectionTimeout

Arguments:

    ConnectionTimeout - the connection timeout in seconds. Undefined
        on failure

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    HRESULT hr = 0;
    DWORD   dwValue = 0;
    DWORD   dwSize = 0;
    IMSAdminBase   *pIMeta = NULL;
    BOOL CoInitSucceeded = FALSE;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr))
        {
        #ifdef DBG_ERROR
        DbgPrint("GetIISConnectionTimeout: CoInitializeEx failed: Error: %X\n", hr);
        #endif
        goto MapErrorAndExit;
        }
    CoInitSucceeded = TRUE;
        
    hr = CoCreateInstance( CLSID_MSAdminBase, 
                           NULL, 
                           CLSCTX_ALL,
                           IID_IMSAdminBase, 
                           (void **)&pIMeta );  
    if (FAILED(hr))
        {
        #ifdef DBG_REG
        DbgPrint("CoCreateInstance(): Failed: 0x%x\n",hr);
        #endif
        goto MapErrorAndExit;
        }

    //
    // Get: /W3Svc/1/ROOT/rpc/ConnectionTimeout
    //
    hr = GetMetaBaseDword( pIMeta,
                           METADATA_MASTER_ROOT_HANDLE,
                           TEXT("/lm/w3svc/1/ROOT/Rpc"),
                           MD_CONNECTION_TIMEOUT,
                           ConnectionTimeout);

    if (FAILED(hr))
        {
        #ifdef DBG_REG
        DbgPrint("GetMetaBaseDword: Failed: 0x%x\n",hr);
        #endif
        // couldn't read at the site level - try the root

        //
        // Get: /W3Svc/ConnectionTimeout
        //
        hr = GetMetaBaseDword( pIMeta,
                               METADATA_MASTER_ROOT_HANDLE,
                               TEXT("/lm/w3svc"),
                               MD_CONNECTION_TIMEOUT,
                               ConnectionTimeout);
        if (FAILED(hr))
            {
            #ifdef DBG_REG
            DbgPrint("GetMetaBaseDword: Failed: 0x%x\n",hr);
            #endif
            }
        }

MapErrorAndExit:
    if (pIMeta != NULL)
        pIMeta->Release();

    if (CoInitSucceeded)
        CoUninitialize();

    if (FAILED(hr))
        return RPC_S_OUT_OF_MEMORY;
    else
        return RPC_S_OK;
}

//---------------------------------------------------------------------
// SetupMetaBase()
//
// Setup entries in the metabase for both the filter and ISAPI parts
// of the RPC proxy. Note that these entries used to be in the registry.
//
// W3Svc/Filters/FilterLoadOrder            "...,RpcProxy"
// W3Svc/Filters/RpcProxy/FilterImagePath   "%SystemRoot%\System32\RpcProxy"
// W3Svc/Filters/RpcProxy/KeyType           "IIsFilter"
// W3Svc/Filters/RpcProxy/FilterDescription "Microsoft RPC Proxy Filter, v1.0"
//
// W3Svc/1/ROOT/Rpc/KeyType                 "IIsWebVirtualDir"
// W3Svc/1/ROOT/Rpc/VrPath                  "%SystemRoot%\System32\RpcProxy"
// W3Svc/1/ROOT/Rpc/AccessPerm              0x205
// W3Svc/1/ROOT/Rpc/Win32Error              0x0
// W3Svc/1/ROOT/Rpc/DirectoryBrowsing       0x4000001E
// W3Svc/1/ROOT/Rpc/AppIsolated             0x0
// W3Svc/1/ROOT/Rpc/AppRoot                 "/LM/W3SVC/1/Root/rpc"
// W3Svc/1/ROOT/Rpc/AppWamClsid             "{BF285648-0C5C-11D2-A476-0000F8080B50}"
// W3Svc/1/ROOT/Rpc/AppFriendlyName         "rpc"
//
//---------------------------------------------------------------------
HRESULT SetupMetaBase()
    {
    HRESULT hr = 0;
    DWORD   dwValue = 0;
    DWORD   dwSize = 0;
    DWORD   dwBufferSize = sizeof(WCHAR) * ORIGINAL_BUFFER_SIZE;
    WCHAR  *pwsBuffer = (WCHAR*)MemAllocate(dwBufferSize);
    WCHAR  *pwsSystemRoot = _wgetenv(SYSTEM_ROOT);
    WCHAR   wsPath[METADATA_MAX_NAME_LEN];

    IMSAdminBase   *pIMeta;
    METADATA_HANDLE hMetaBase;

    //
    // Name of this DLL (and where it is):
    //
    // WCHAR   wszModule[256];
    //
    // if (!GetModuleFileName( g_hInst, wszModule,
    //                         sizeof(wszModule)/sizeof(WCHAR)))
    //    {
    //    return SELFREG_E_CLASS;
    //    }

    if (!pwsBuffer)
        {
        return E_OUTOFMEMORY;
        }

    hr = CoCreateInstance( CLSID_MSAdminBase, 
                           NULL, 
                           CLSCTX_ALL,
                           IID_IMSAdminBase, 
                           (void **)&pIMeta );  
    if (FAILED(hr))
        {
        #ifdef DBG_REG
        DbgPrint("CoCreateInstance(): Failed: 0x%x\n",hr);
        #endif
        MemFree(pwsBuffer);
        return hr;
        }

    // Get a handle to the Web service:
    hr = pIMeta->OpenKey( METADATA_MASTER_ROOT_HANDLE, 
                          LOCAL_MACHINE_W3SVC,
                          (METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE),
                          20, 
                          &hMetaBase );

    if (FAILED(hr))
        {
        #ifdef DBG_REG
        DbgPrint("pIMeta->OpenKey(): Failed: 0x%x\n",hr);
        #endif
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }


    //
    // IIS Filter: FilterLoadOrder
    //
    dwSize = dwBufferSize;
    hr = GetMetaBaseString( pIMeta,
                            hMetaBase,
                            MD_KEY_FILTERS,       // See iiscnfg.h
                            MD_FILTER_LOAD_ORDER, // See iiscnfg.h
                            pwsBuffer,
                            &dwSize );
    if (FAILED(hr) && (hr != MD_ERROR_DATA_NOT_FOUND))
        {
        #ifdef DBG_REG
        DbgPrint("GetMetaBaseString(): Failed: 0x%x\n",hr);
        #endif
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

    if (hr == MD_ERROR_DATA_NOT_FOUND)
        pwsBuffer[0] = '\0';

    // Check whether too much of the buffer has been used up.
    pwsBuffer[ORIGINAL_BUFFER_SIZE-1] = '\0';
    if (wcslen(pwsBuffer) > MAX_USED_BUFFER_SIZE)
        {
        ASSERT(0);
        MemFree(pwsBuffer);
        pIMeta->Release();
        return E_UNEXPECTED;
        }

    if (!wcsstr(pwsBuffer,RPCPROXY))
        {
        // RpcProxy is not in FilterLoadOrder, so add it (if there were
        // previous elements).
        if (hr != MD_ERROR_DATA_NOT_FOUND)
            {
            wcscat(pwsBuffer,TEXT(","));
            }

        wcscat(pwsBuffer,RPCPROXY);
        hr = SetMetaBaseString( pIMeta,
                             hMetaBase,
                             MD_KEY_FILTERS,
                             MD_FILTER_LOAD_ORDER,
                             pwsBuffer,
                             0,
                             IIS_MD_UT_SERVER );
        }

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

    //
    // IIS Filter: RpcProxy/FilterImagePath
    //
    hr = pIMeta->AddKey( hMetaBase, MD_KEY_FILTERS_RPCPROXY );
    if ( (FAILED(hr)) && (hr != 0x800700b7))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }


    wcscpy(pwsBuffer,pwsSystemRoot);
    wcscat(pwsBuffer,RPCPROXY_PATH);
    wcscat(pwsBuffer,TEXT("\\"));
    wcscat(pwsBuffer,RPCPROXY_DLL);
    hr = SetMetaBaseString( pIMeta,
                            hMetaBase,
                            MD_KEY_FILTERS_RPCPROXY,
                            MD_FILTER_IMAGE_PATH,
                            pwsBuffer,
                            0,
                            IIS_MD_UT_SERVER );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

    //
    // IIS Filter: Filters/RpcProxy/KeyType
    //

    wcscpy(pwsBuffer,IISFILTER);
    hr = SetMetaBaseString( pIMeta,
                            hMetaBase,
                            MD_KEY_FILTERS_RPCPROXY,
                            MD_KEY_TYPE,
                            pwsBuffer,
                            0,
                            IIS_MD_UT_SERVER );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }


    wcscpy(pwsBuffer, FILTER_DESCRIPTION_W);
    hr = SetMetaBaseString( pIMeta,
                            hMetaBase,
                            MD_KEY_FILTERS_RPCPROXY,
                            MD_FILTER_DESCRIPTION,
                            pwsBuffer,
                            0,
                            IIS_MD_UT_SERVER );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

    // We do not write the events we subscribe for to the metabase. We have
    // already advertised our presence and in IIS 5 mode IIS will load us,
    // ask for the events, and write them for us in the metabase

    //
    // Set: /W3Svc/1/ROOT/rpc/AccessPerm 
    //
    dwValue = ACCESS_PERM_FLAGS;
    hr = SetMetaBaseDword( pIMeta,
                           hMetaBase,
                           MD_KEY_ROOT_RPC,
                           MD_ACCESS_PERM,
                           dwValue,
                           METADATA_INHERIT,
                           IIS_MD_UT_FILE );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

    //
    // Disable entity body preload for this ISAPI
    //

    dwValue = 0;
    
    hr = SetMetaBaseDword( pIMeta,
                           hMetaBase,
                           MD_KEY_ROOT_RPC,
                           MD_UPLOAD_READAHEAD_SIZE,
                           dwValue,
                           METADATA_INHERIT,
                           IIS_MD_UT_FILE );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

    //
    // Set: /W3Svc/1/ROOT/rpc/Win32Error
    //
    dwValue = 0;
    hr = SetMetaBaseDword( pIMeta,
                           hMetaBase,
                           MD_KEY_ROOT_RPC,
                           MD_WIN32_ERROR,
                           dwValue,
                           METADATA_INHERIT,
                           IIS_MD_UT_SERVER );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }


    //
    // Set: /W3Svc/1/ROOT/rpc/DirectroyBrowsing
    //
    dwValue = DIRECTORY_BROWSING_FLAGS;
    hr = SetMetaBaseDword( pIMeta,
                           hMetaBase,
                           MD_KEY_ROOT_RPC,
                           MD_DIRECTORY_BROWSING,
                           dwValue,
                           METADATA_INHERIT,
                           IIS_MD_UT_FILE );

    if (FAILED(hr))
        {
        pIMeta->Release();
        CoUninitialize();
        return hr;
        }

    //
    // Set: /W3Svc/1/ROOT/rpc/KeyType
    //
    wcscpy(pwsBuffer,IIS_WEB_VIRTUAL_DIR);
    hr = SetMetaBaseString( pIMeta,
                            hMetaBase,
                            MD_KEY_ROOT_RPC,
                            MD_KEY_TYPE,
                            pwsBuffer,
                            0,
                            IIS_MD_UT_SERVER );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

    //
    // Set: /W3Svc/1/ROOT/rpc/VrPath
    //
    wcscpy(pwsBuffer,pwsSystemRoot);
    wcscat(pwsBuffer,RPCPROXY_PATH);
    hr = SetMetaBaseString( pIMeta,
                            hMetaBase,
                            MD_KEY_ROOT_RPC,
                            MD_VR_PATH,
                            pwsBuffer,
                            METADATA_INHERIT,
                            IIS_MD_UT_FILE );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

#if FALSE

    //
    // Set: /W3Svc/1/ROOT/rpc/AppIsolated
    //
    dwValue = 0;
    hr = SetMetaBaseDword( pIMeta,
                           hMetaBase,
                           MD_KEY_ROOT_RPC,
                           MD_APP_ISOLATED,
                           dwValue,
                           METADATA_INHERIT,
                           IIS_MD_UT_WAM );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

    //
    // Set: /W3Svc/1/ROOT/rpc/AppRoot
    //
    wcscpy(pwsBuffer,APP_ROOT_PATH);
    hr = SetMetaBaseString( pIMeta,
                            hMetaBase,
                            MD_KEY_ROOT_RPC,
                            MD_APP_ROOT,
                            pwsBuffer,
                            METADATA_INHERIT,
                            IIS_MD_UT_FILE );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

    //
    // Set: /W3Svc/1/ROOT/rpc/AppWamClsid
    //
    wcscpy(pwsBuffer,APP_WAM_CLSID);
    hr = SetMetaBaseString( pIMeta,
                            hMetaBase,
                            MD_KEY_ROOT_RPC,
                            MD_APP_WAM_CLSID,
                            pwsBuffer,
                            METADATA_INHERIT,
                            IIS_MD_UT_WAM );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

    //
    // Set: /W3Svc/1/ROOT/rpc/AppFriendlyName
    //
    wcscpy(pwsBuffer,APP_FRIENDLY_NAME);
    hr = SetMetaBaseString( pIMeta,
                            hMetaBase,
                            MD_KEY_ROOT_RPC,
                            MD_APP_FRIENDLY_NAME,
                            pwsBuffer,
                            METADATA_INHERIT,
                            IIS_MD_UT_WAM );

    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

#endif

    //
    // Release the handle and buffer:
    //
    MemFree(pwsBuffer);

    pIMeta->CloseKey(hMetaBase);

    pIMeta->Release();

    CoUninitialize();

    return 0;
    }

//---------------------------------------------------------------------
//  CleanupMetaBase()
//
//---------------------------------------------------------------------
HRESULT CleanupMetaBase()
    {
    HRESULT hr = 0;
    DWORD   dwSize = 0;
    WCHAR  *pwsRpcProxy;
    WCHAR  *pws;
    DWORD   dwBufferSize = sizeof(WCHAR) * ORIGINAL_BUFFER_SIZE;
    WCHAR  *pwsBuffer = (WCHAR*)MemAllocate(dwBufferSize);

    // CComPtr <IMSAdminBase> pIMeta;
    IMSAdminBase   *pIMeta;
    METADATA_HANDLE hMetaBase;

    if (!pwsBuffer)
        {
        return ERROR_OUTOFMEMORY;
        }

    hr = CoCreateInstance( CLSID_MSAdminBase,
                           NULL,
                           CLSCTX_ALL,
                           IID_IMSAdminBase,
                           (void **)&pIMeta );
    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        return hr;
        }

    //
    // Get a handle to the Web service:
    //
    hr = pIMeta->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                          TEXT("/LM/W3SVC"),
                          (METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE),
                          20,
                          &hMetaBase );
    if (FAILED(hr))
        {
        MemFree(pwsBuffer);
        pIMeta->Release();
        return hr;
        }

    //
    // Remove the RpcProxy reference from the FilterLoadOrder value:
    //
    dwSize = dwBufferSize;
    hr = GetMetaBaseString( pIMeta,
                            hMetaBase,
                            MD_KEY_FILTERS,
                            MD_FILTER_LOAD_ORDER,
                            pwsBuffer,
                            &dwSize );
    if (!FAILED(hr))
        {
        // Check whether too much of the buffer has been used up.
        pwsBuffer[ORIGINAL_BUFFER_SIZE-1] = '\0';
        if (wcslen(pwsBuffer) > MAX_USED_BUFFER_SIZE)
            {
            ASSERT(0);
            MemFree(pwsBuffer);
            pIMeta->Release();
            return E_UNEXPECTED;
            }

        if (pwsRpcProxy=wcsstr(pwsBuffer,RPCPROXY))
            {
            // "RpcProxy" is in FilterLoadOrder, so remove it:

            // Check to see if RpcProxy is at the start of the list:
            if (pwsRpcProxy != pwsBuffer)
                {
                pwsRpcProxy--;  // Want to remove the comma before...
                dwSize = sizeof(RPCPROXY);
                }
            else
                {
                dwSize = sizeof(RPCPROXY) - 1;
                }

            pws = pwsRpcProxy + dwSize;
            memcpy(pwsRpcProxy,pws,sizeof(WCHAR)*(1+wcslen(pws)));
            hr = SetMetaBaseString( pIMeta,
                                    hMetaBase,
                                    MD_KEY_FILTERS,
                                    MD_FILTER_LOAD_ORDER,
                                    pwsBuffer,
                                    0,
                                    IIS_MD_UT_SERVER );
            }
        }


    //
    // Delete: /W3Svc/Filters/RpcProxy
    //
    hr = pIMeta->DeleteKey( hMetaBase,
                            MD_KEY_FILTERS_RPCPROXY );

    //
    // Delete: /W3Svc/1/ROOT/Rpc
    //
    hr = pIMeta->DeleteKey( hMetaBase,
                            MD_KEY_FILTERS_RPCPROXY );

    //
    // Release the handle and buffer:
    //
    MemFree(pwsBuffer);

    pIMeta->CloseKey(hMetaBase);

    pIMeta->Release();

    return S_OK;
    }

const WCHAR InetInfoName[] = L"inetinfo.exe";
const ULONG InetInfoNameLength = sizeof(InetInfoName) / sizeof(WCHAR) - 1;  // in characters without terminating NULL

BOOL
UpdateIsIISInCompatibilityMode (
    void
    )
/*++

Routine Description:

    Reads the compatibility mode state. It used to read it from the metabase,
    but after repeated problems in compatibility mode, WadeH suggested a simpler approach -
    check whether we run in inetinfo. If yet, we're in compatibility mode.

Arguments:

Return Value:
    non-zero if the variable is correctly updated. 0 otherwise

--*/
{
    WCHAR ExtensionPath[ MAX_PATH + 1 ];
    ULONG ModuleFileNameLength;     // in characters without terminating NULL

    DWORD dwRet = GetModuleFileNameW(
            GetModuleHandle(NULL),
            ExtensionPath,
            MAX_PATH );

    if ( (dwRet > 0) && (dwRet != MAX_PATH))
        {
        ExtensionPath[MAX_PATH] = '\0';
        ASSERT(GetLastError() == NO_ERROR);
        }
    else
        {
        ASSERT(GetLastError() != NO_ERROR);
        return FALSE;
        }

    ModuleFileNameLength = wcslen(ExtensionPath);
    if (ModuleFileNameLength < InetInfoNameLength)
        {
        fIsIISInCompatibilityMode = FALSE;
        }

    if (_wcsicmp(ExtensionPath + ModuleFileNameLength - InetInfoNameLength, InetInfoName) == 0)
        {
        fIsIISInCompatibilityMode = TRUE;
        }
    else
        {
        fIsIISInCompatibilityMode = FALSE;
        }

    return TRUE;
}

//---------------------------------------------------------------------
// DllRegisterServer()
//
// Setup the Registry and MetaBase for the RPC proxy.
//---------------------------------------------------------------------

const char ChildProcessVar[] = "__RPCPROXY_CHILD_PROCESS";
const char ChildProcessVarValue[] = "__FROM_SETUP";


HRESULT DllRegisterServer()
    {
    HRESULT  hr;
    WORD     wVersion = MAKEWORD(1,1);
    WSADATA  wsaData;
    char EnvironmentVarBuffer[MAX_PATH];
    DWORD Temp;
    BOOL Result;
    DWORD LastError;

    #ifdef DBG_REG
    DbgPrint("RpcProxy: DllRegisterServer(): Start\n");
    #endif

    // check if we are have already been called from the RPCProxy DllRegister routine
    Temp = GetEnvironmentVariableA(ChildProcessVar, EnvironmentVarBuffer, MAX_PATH);

    #ifdef DBG_REG
    DbgPrint("RpcProxy: Result of looking for environment variable - %d\n", Temp);
    #endif

    // GetEnvironmentVariable does not count the terminating NULL.
    if (Temp < sizeof(ChildProcessVarValue) - 1)
        {
        #ifdef DBG_REG
        DbgPrint("RpcProxy: Not a child process - spawning one\n");
        #endif

        // we didn't find the variable. Add it and spawn ourselves to register out of proc
        Result = SetEnvironmentVariableA (ChildProcessVar, ChildProcessVarValue);
        if (Result == FALSE)
            return E_OUTOFMEMORY;

        Result = RegisterOutOfProc();
        if (Result == FALSE)
            {
            // capture the last error before we call SetEnvironmentVariable
            LastError = GetLastError();
            }

        // before processing the result, remove the environment variable. If this fails, there
        // isn't much we can do. Fortunately, failure to delete is completely benign
        (void) SetEnvironmentVariableA (ChildProcessVar, NULL);

        if (Result == FALSE)
            {
            return HRESULT_FROM_WIN32(LastError);
            }

        return S_OK;
        }

    if (WSAStartup(wVersion,&wsaData))
        {
        return SELFREG_E_CLASS;
        }

    hr = CoInitializeEx(0,COINIT_MULTITHREADED);
    if (FAILED(hr))
        {
        hr = CoInitializeEx(0,COINIT_APARTMENTTHREADED);
        if (FAILED(hr))
            {
            #ifdef DBG_REG
            DbgPrint("RpcProxy: CoInitialize(): Failed: 0x%x\n", hr );
            #endif
            return hr;
            }
        }

    hr = SetupRegistry();
    if (FAILED(hr))
        {
        #ifdef DBG_REG
        DbgPrint("RpcProxy: SetupRegistry(): Failed: 0x%x (%d)\n",
                 hr, hr );
        #endif
        goto CleanupAndExit;
        }

    hr = SetupMetaBase();
    if (FAILED(hr))
        {
        #ifdef DBG_REG
        DbgPrint("RpcProxy: SetupMetaBase(): Failed: 0x%x (%d)\n",
                hr, hr );
        #endif
        goto CleanupAndExit;
        }

#if IIS_LOCKDOWN_LIST
    hr = ModifyLockdownList( true );
#endif // #if IIS_LOCKDOWN_LIST

#if IIS_SEC_CONSOLE
    hr = EnableRpcProxyExtension();
#endif // #if IIS_SEC_CONSOLE

    if ( FAILED( hr ) )
        {
        #ifdef DBG_REG
        DbgPrint("RpcProxy: ModifyLockdownList(): Failed: 0x%x (%d)\n",
                hr, hr );
        #endif
        goto CleanupAndExit;
        }

#if IIS_LOCKDOWN_LIST
    hr = ModifyLockdownListDisplay( true );
    #ifdef DBG_REG
    if ( FAILED( hr ) )
        {
        DbgPrint("RpcProxy: ModifyLockdownListDisplay(): Failed: 0x%x (%d)\n",
                hr, hr );
        }
    #endif
#endif  // #if IIS_LOCKDOWN_LIST

CleanupAndExit:
    CoUninitialize();

    #ifdef DBG_REG
    DbgPrint("RpcProxy: DllRegisterServer(): End: hr: 0x%x\n",hr);
    #endif

    return hr;
    }

//---------------------------------------------------------------------
// DllUnregisterServer()
//
// Uninstall Registry and MetaBase values used by the RPC proxy.
//
// Modified to mostly return S_Ok, even if a problem occurs. This is 
// done so that the uninstall will complete even if there is a problem
// in the un-register.
//---------------------------------------------------------------------
HRESULT DllUnregisterServer()
    {
    HRESULT  hr;
    WORD     wVersion = MAKEWORD(1,1);
    WSADATA  wsaData;

    #ifdef DBG_REG
    DbgPrint("RpcProxy: DllUnregisterServer(): Start\n");
    #endif

    if (WSAStartup(wVersion,&wsaData))
        {
        return SELFREG_E_CLASS;
        }

    hr = CoInitializeEx(0,COINIT_MULTITHREADED);
    if (FAILED(hr))
        {
        hr = CoInitializeEx(0,COINIT_APARTMENTTHREADED);
        if (FAILED(hr))
            {
            #ifdef DBG_REG
            DbgPrint("RpcProxy: CoInitializeEx() Failed: 0x%x\n",hr);
            #endif
            return S_OK;
            }
        }
#if IIS_SEC_CONSOLE
    hr = DisableRpcProxyExtension();
#endif // #if IIS_SEC_CONSOLE

#if IIS_LOCKDOWN_LIST
    hr = ModifyLockdownList( false );
#endif // #if IIS_LOCKDOWN_LIST

    if (FAILED(hr))
        {
        #ifdef DBG_REG
        DbgPrint("RpcProxy: ModifyLockdownList() Failed: 0x%x (%d)\n",hr,hr);
        #endif
        return S_OK;
        }

#if IIS_LOCKDOWN_LIST
    hr = ModifyLockdownListDisplay( false );

    if (FAILED(hr))
        {
        #ifdef DBG_REG
        DbgPrint("RpcProxy: ModifyLockdownListDisplay() Failed: 0x%x (%d)\n",hr,hr);
        #endif
        return S_OK;
        }
#endif  // #if IIS_LOCKDOWN_LIST

    hr = CleanupRegistry();
    if (FAILED(hr))
        {
        #ifdef DBG_REG
        DbgPrint("RpcProxy: CleanupRegistry() Failed: 0x%x (%d)\n",hr,hr);
        #endif
        return S_OK;
        }

    hr = CleanupMetaBase();

    #ifdef DBG_REG
    if (FAILED(hr))
        {
        DbgPrint("RpcProxy: CleanupMetaBase() Failed: 0x%x (%d)\n",hr,hr);
        }
    #endif

    CoUninitialize();

    #ifdef DBG_REG
    DbgPrint("RpcProxy: DllUnregisterServer(): Start\n");
    #endif

    return S_OK;
    }

//--------------------------------------------------------------------
// DllMain()
//
//--------------------------------------------------------------------
BOOL WINAPI DllMain( HINSTANCE hInst,
                     ULONG     ulReason,
                     LPVOID    pvReserved )
{
    BOOL fInitialized = TRUE;

    switch (ulReason)
        {
        case DLL_PROCESS_ATTACH:
            if (!DisableThreadLibraryCalls(hInst))
                {
                fInitialized = FALSE;
                }
            else
                {
                g_hInst = hInst;
                }
            break;

        case DLL_PROCESS_DETACH:
            FreeServerInfo(&g_pServerInfo);
            break;

        case DLL_THREAD_ATTACH:
            // Not used. Disabled.
            break;

        case DLL_THREAD_DETACH:
            // Not used. Disabled.
            break;
        }

    return fInitialized;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\rpcproxy\registry.h ===
//--------------------------------------------------------------------
// Copyright (C)1998 Microsoft Corporation, All Rights Reserved
//
// registry.h
//
// Constants for registration of the ncacn_http RpcProxy with
// the registry and IIS MetaBase.
//
//
//--------------------------------------------------------------------


#ifndef _MBASE_H_
#define _MBASE_H_

//--------------------------------------------------------------------
//  Registry constants:
//--------------------------------------------------------------------

#ifdef DBG
#define DBG_REG
#endif

#define MAX_TCPIP_HOST_NAME       512

#define REG_RPC_PATH             TEXT("Software\\Microsoft\\Rpc")
#define REG_RPCPROXY             TEXT("RpcProxy")
#define REG_ENABLED              TEXT("Enabled")
#define REG_VALID_PORTS          TEXT("ValidPorts")
#define REG_PORT_RANGE           TEXT(":100-5000")

//--------------------------------------------------------------------
//  MetaBase constants:
//--------------------------------------------------------------------
#define ORIGINAL_BUFFER_SIZE     512
#define MAX_USED_BUFFER_SIZE     400

#define SYSTEM_ROOT              TEXT("SystemRoot")
#define RPCPROXY_PATH            TEXT("\\System32\\RpcProxy")

#define RPCPROXY                 TEXT("RpcProxy")
#define RPCPROXY_DLL             TEXT("RpcProxy.dll")

#define LOCAL_MACHINE_W3SVC      TEXT("/LM/W3SVC")
#define APP_ROOT_PATH            TEXT("/LM/W3SVC/1/Root/rpc")
#define APP_FRIENDLY_NAME        TEXT("rpc")
#define APP_WAM_CLSID            TEXT("{BF285648-0C5C-11D2-A476-0000F8080B50}")

#define IISFILTER                TEXT("IIsFilter")

#define IIS_WEB_VIRTUAL_DIR      TEXT("IIsWebVirtualDir")

#define MD_KEY_FILTERS           TEXT("Filters")
#define MD_KEY_FILTERS_RPCPROXY  TEXT("Filters/RpcProxy")
#define MD_KEY_ROOT_RPC          TEXT("1/ROOT/Rpc")

#define ACCESS_PERM_FLAGS        MD_ACCESS_EXECUTE
#define DIRECTORY_BROWSING_FLAGS 0x4000001E

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

BOOL
UpdateIsIISInCompatibilityMode (
    void
    );

RPC_STATUS 
GetIISConnectionTimeout(
    OUT ULONG *ConnectionTimeout
    );

const BYTE *GetEchoRTS (
    OUT ULONG *EchoRTSSize
    );

void 
LogEventStartupSuccess (
    IN char *IISMode
    );

extern const WCHAR * const EVENT_LOG_SOURCE_NAME;
extern const WCHAR * const EVENT_LOG_KEY_NAME;
extern const ULONG EVENT_LOG_CATEGORY_COUNT;

#ifdef __cplusplus
};
#endif  // __cplusplus

#endif //_MBASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\rpcproxy\server.h ===
//--------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  server.h
//
//--------------------------------------------------------------------

//--------------------------------------------------------------------
//  Constants:
//--------------------------------------------------------------------

#ifndef CHAR_0
#define CHAR_0       '0'
#define CHAR_9       '9'
#endif

#ifndef CHAR_A
#define CHAR_A       'A'
#define CHAR_F       'F'
#endif

//--------------------------------------------------------------------
//  Functions:
//--------------------------------------------------------------------

extern DWORD CleanupECB( EXTENSION_CONTROL_BLOCK *pECB );

extern DWORD WINAPI ReceiveThreadProc( void *pvServerInfo );

extern BOOL  CheckStartReceiveThread( SERVER_INFO *pServerInfo,
                                      DWORD       *pdwStatus  );

extern BOOL  SubmitNewRead( SERVER_INFO       *pServerInfo,
                            SERVER_OVERLAPPED *pOverlapped,
                            DWORD             *pdwStatus   );

extern BOOL  StartAsyncClientRead( EXTENSION_CONTROL_BLOCK *pECB,
                                   SERVER_CONNECTION       *pConn,
                                   DWORD                   *pdwStatus );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\rpcproxy\rpcisapi.c ===
//-----------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  rpcisapi.cxx
//
//  IIS ISAPI extension part of the RPC proxy over HTTP.
//
//  Exports:
//
//    BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO *pVer )
//
//      Returns the version of the spec that this server was built with.
//
//    BOOL WINAPI HttpExtensionProc(   EXTENSION_CONTROL_BLOCK *pECB )
//
//      This function does all of the work.
//
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//  Includes:
//-----------------------------------------------------------------------------

#include <sysinc.h>
#include <winsock2.h>
#include <rpc.h>
#include <rpcdcep.h>
#include <rpcerrp.h>
#include <httpfilt.h>
#include <httpext.h>
#include <mbstring.h>
#include <ecblist.h>
#include <filter.h>
#include <olist.h>
#include <server.h>
#include <RpcIsapi.h>
#include <registry.h>
#include <StrSafe.h>


//-----------------------------------------------------------------------------
//  Globals:
//-----------------------------------------------------------------------------

extern SERVER_INFO *g_pServerInfo;
extern BOOL g_fIsIIS6;

//-----------------------------------------------------------------------------
//  GetExtensionVersion()
//
//-----------------------------------------------------------------------------
BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO *pVer )
{
    HRESULT hr;

    pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

    ASSERT( sizeof(EXTENSION_DESCRIPTION) <= HSE_MAX_EXT_DLL_NAME_LEN );

    hr = StringCchCopyNA (pVer->lpszExtensionDesc, 
        sizeof(pVer->lpszExtensionDesc), 
        EXTENSION_DESCRIPTION,
        sizeof(EXTENSION_DESCRIPTION)
        );

    // this cannot fail as the strings are constant
    ASSERT(SUCCEEDED(hr));

    // if the filter data structures are not initialized yet, initialize them
    if (g_pServerInfo == NULL)
        {
        if (InitializeGlobalDataStructures(FALSE /* IsFromFilter */) == FALSE)
            {
            return FALSE;
            }
        }

    LogEventStartupSuccess (fIsIISInCompatibilityMode ? "5" : "6");

    return TRUE;
}

//-----------------------------------------------------------------------------
//  ReplyToClient()
//
//-----------------------------------------------------------------------------
BOOL ReplyToClient( EXTENSION_CONTROL_BLOCK *pECB,
                    const char              *pBuffer,
                    DWORD                   *pdwSize,
                    DWORD                   *pdwStatus )
{
   DWORD  dwFlags = (HSE_IO_SYNC | HSE_IO_NODELAY);

   if (!pECB->WriteClient(pECB->ConnID, (char *)pBuffer, pdwSize, dwFlags))
      {
      *pdwStatus = GetLastError();
      #ifdef DBG_ERROR
      DbgPrint("ReplyToClient(): failed: %d\n",*pdwStatus);
      #endif
      return FALSE;
      }

   *pdwStatus = HSE_STATUS_SUCCESS;
   return TRUE;
}

DWORD 
ReplyToClientWithStatus (
    IN EXTENSION_CONTROL_BLOCK *pECB,
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    Sends a reply to the client with the given error code as error.

Arguments:

    pECB - extension control block
    RpcStatus - error code to be returned to client

Return Value:

    Return value appropriate for return to IIS (i.e. HSE_STATUS_*)

--*/
{
    // size is the error string + 20 space for the error code
    char Buffer[sizeof(ServerErrorString) + 20];
    ULONG Size;
    ULONG Status;
    BOOL Result;
    HRESULT hr;

    hr = StringCbPrintfA (Buffer,
        sizeof(Buffer),
        ServerErrorString,
        RpcStatus
        );

    // this should never fail as the strings are constant
    ASSERT(SUCCEEDED(hr));

    Size = strlen(Buffer);
    Result = ReplyToClient (
        pECB,
        Buffer,
        &Size,
        &Status
        );

    return Status;
}

//-----------------------------------------------------------------------------
//  ParseQueryString()
//
//  The query string is in the format:
//
//    <Index_of_pOverlapped>
//
//  Where the index is in ASCII Hex. The index is read and converted back
//  to a DWORD then used to locate the SERVER_OVERLAPPED. If its found,
//  return TRUE, else return FALSE.
//
//  NOTE: "&" is the parameter separator if multiple parameters are passed.
//-----------------------------------------------------------------------------
BOOL ParseQueryString( unsigned char      *pszQuery,
                       SERVER_OVERLAPPED **ppOverlapped,
                       DWORD              *pdwStatus  )
{
   DWORD  dwIndex = 0;

   pszQuery = AnsiHexToDWORD(pszQuery,&dwIndex,pdwStatus);
   if (!pszQuery)
      {
      return FALSE;
      }

   *ppOverlapped = GetOverlapped(dwIndex);
   if (*ppOverlapped == NULL)
      {
      return FALSE;
      }

   return TRUE;
}

BOOL
ParseHTTP2QueryString (
    IN char *Query,
    IN OUT USHORT *ServerAddressBuffer,
    IN ULONG ServerAddressBufferLength,
    IN OUT USHORT *ServerPortBuffer,
    IN ULONG ServerPortBufferLength
    )
/*++

Routine Description:

    Parses an HTTP2 format query string into a server address and
    server port.

Arguments:

    Query - the raw query string as received by the extension
    ServerAddressBuffer - the buffer where the server address will be
        stored. Undefined upon failure. Upon success it will be 0 terminated.
    ServerAddressBufferLengh - the length of ServerAddressBuffer in unicode chars.
    ServerPortBuffer - the buffer where the server port will be
        stored. Undefined upon failure. Upon success it will be 0 terminated.
    ServerPortBufferLengh - the length of ServerAddressBuffer in unicode chars.

Return Value:

    non-zero for success and 0 for failure.

--*/
{
    char *ColonPosition;
    int CharactersConverted;

    ColonPosition = _mbschr(Query, ServerAddressAndPortSeparator);

    if (ColonPosition == NULL)
        return FALSE;

    CharactersConverted = MultiByteToWideChar (
        CP_ACP,
        MB_ERR_INVALID_CHARS,
        Query,
        ColonPosition - Query,
        ServerAddressBuffer,
        ServerAddressBufferLength
        );

    // did we convert successfully?
    if (CharactersConverted == 0)
        return FALSE;

    // do we have space for the terminating null?
    if (CharactersConverted + 1 > ServerAddressBufferLength)
        return FALSE;

    // null terminate the server address string. Since we gave the length
    // explicitly to MultiByteToWideChar it will not add null for us
    ServerAddressBuffer[CharactersConverted] = 0;

    CharactersConverted = MultiByteToWideChar (
        CP_ACP,
        MB_ERR_INVALID_CHARS,
        ColonPosition + 1,
        -1,     // have MultiByteToWideChar calculate the length
        ServerPortBuffer,
        ServerPortBufferLength
        );

    // did we convert successfully?
    if (CharactersConverted == 0)
        return FALSE;

    // since we had MultiByteToWideChar calculate the string length,
    // it has null terminated the resulting string. We're all done.
    return TRUE;
}

BOOL
GetRemoteUserString (
    IN EXTENSION_CONTROL_BLOCK *pECB,
    OUT char **FinalRemoteUser
    )
/*++

Routine Description:

    Gets the remote user name from IIS. If anonymous, an empty
    string will be returned.

Arguments:

    pECB - the extension control block given to us by IIS.
    FinalRemoteUser - on output a pointer to the remote user name allocated by this
        routine. Muts be freed by caller using MemFree. Undefined on failure.

Return Value:

    non-zero for success or 0 for failure/

--*/
{
    ULONG ActualServerVariableLength;
    char *TempRemoteUser;
    BOOL Result;

    ActualServerVariableLength = 0;
    TempRemoteUser = NULL;
    Result = pECB->GetServerVariable(pECB->ConnID,
        "REMOTE_USER",
        TempRemoteUser,
        &ActualServerVariableLength
        );
    ASSERT(Result == FALSE);
    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
        return FALSE;
        }

    TempRemoteUser = (char *)MemAllocate(ActualServerVariableLength + 1);
    if (TempRemoteUser == NULL)
        {
        return FALSE;
        }

    Result = pECB->GetServerVariable(pECB->ConnID,
        "REMOTE_USER",
        TempRemoteUser,
        &ActualServerVariableLength
        );

    if (Result == FALSE)
        {
        MemFree(TempRemoteUser);
        return FALSE;
        }

    *FinalRemoteUser = TempRemoteUser;
    return TRUE;
}

RPC_STATUS
RPC_ENTRY I_RpcProxyIsValidMachine (
    IN char *pszMachine,
    IN char *pszDotMachine,
    IN ULONG dwPortNumber        
    )
{
    BOOL Result;

    Result = HttpProxyIsValidMachine(g_pServerInfo,
        pszMachine,
        pszDotMachine,
        dwPortNumber
        );

    if (Result)
        return RPC_S_OK;
    else
        return RPC_S_ACCESS_DENIED;
}

RPC_STATUS
RPC_ENTRY I_RpcProxyGetClientAddress (
    IN void *Context,
    OUT char *Buffer,
    OUT ULONG *BufferLength
    )
{
    BOOL Result;
    EXTENSION_CONTROL_BLOCK *pECB = (EXTENSION_CONTROL_BLOCK *) Context;

    Result = pECB->GetServerVariable(pECB->ConnID,
        "REMOTE_ADDR",
        Buffer,
        BufferLength
        );

    if (Result)
        return RPC_S_OK;
    else
        return GetLastError();
}

RPC_STATUS
RPC_ENTRY I_RpcProxyGetConnectionTimeout (
    OUT ULONG *ConnectionTimeout
    )
{
    *ConnectionTimeout = IISConnectionTimeout;
    return RPC_S_OK;
}

const I_RpcProxyCallbackInterface ProxyCallbackInterface = 
    {
    I_RpcProxyIsValidMachine,
    I_RpcProxyGetClientAddress,
    I_RpcProxyGetConnectionTimeout
    };


// uncomment this to see why connections are being rejected
// by AllowAnonymous
// #define DEBUG_ALLOW_ANONYMOUS

//-----------------------------------------------------------------------------
//  HttpExtensionProc()
//
//-----------------------------------------------------------------------------
DWORD WINAPI HttpExtensionProc( EXTENSION_CONTROL_BLOCK *pECB )
{
    DWORD   dwStatus;
    DWORD   dwFlags;
    DWORD   dwSize;
    SERVER_INFO       *pServerInfo = g_pServerInfo;
    SERVER_OVERLAPPED *pOverlapped = NULL;
    HSE_SEND_HEADER_EX_INFO  HeaderEx;
    CHAR    *pLegacyVerb;
    RPC_STATUS RpcStatus;
    ULONG VerbLength;
    USHORT ServerAddress[MaxServerAddressLength];
    USHORT ServerPort[MaxServerPortLength];
    BOOL Result;
    ULONG ProxyType;
    BOOL ConnectionEstablishmentRequest;
    char EchoResponse[sizeof(EchoResponseHeader2) + 2];  // 2 is for 
            // the size of the Echo RTS which goes instead of ContentLength
    int BytesWritten;
    ULONG BufferSize;
    const BYTE *EchoRTS;
    char ServerVariable[20];
    ULONG ActualServerVariableLength;
    ULONG NumContentLength;
    BOOL AnonymousConnection;
    char *RemoteUser = NULL;
    RPC_CHAR *ActualServerName;
    DWORD ExtensionProcResult;
    DWORD HttpStatusCode;
    char *DestinationEnd;
    HRESULT hr;

    if (g_pServerInfo->dwEnabled == FALSE)
        {
        dwSize = sizeof(STATUS_PROXY_DISABLED) - 1;  // don't want to count trailing 0.

        ReplyToClient(pECB,STATUS_PROXY_DISABLED, &dwSize, &dwStatus);
        HttpStatusCode = STATUS_SERVER_ERROR;
        ExtensionProcResult = HSE_STATUS_ERROR;
        goto AbortAndExit;
        }

    if (g_pServerInfo->AllowAnonymous == FALSE)
        {
        // if we are not allowing anonymous connections, check that a secure
        // channel and authentication are used

        // assume anonymous for now
        AnonymousConnection = TRUE;

        ActualServerVariableLength = sizeof(ServerVariable);

        Result = pECB->GetServerVariable(pECB->ConnID,
            "HTTPS",
            ServerVariable,
            &ActualServerVariableLength
            );

        if (!Result)
            {
            HttpStatusCode = STATUS_SERVER_ERROR;
            ExtensionProcResult = HSE_STATUS_ERROR;
            goto AbortAndExit;
            }

        if (RpcpStringCompareIntA(ServerVariable, "on") == 0)
            {
            Result = GetRemoteUserString (pECB,
                &RemoteUser
                );
            if (!Result)
                {
#ifdef DEBUG_ALLOW_ANONYMOUS
                DbgPrint("Connection rejected getting the remote user failed\n");
#endif  // #ifdef DEBUG_ALLOW_ANONYMOUS
                HttpStatusCode = STATUS_SERVER_ERROR;
                ExtensionProcResult = HSE_STATUS_ERROR;
                goto AbortAndExit;
                }

            // if non-empty string, it is authenticated
            if (RemoteUser[0] != 0)
                {
                AnonymousConnection = FALSE;
#ifdef DEBUG_ALLOW_ANONYMOUS
                DbgPrint("Connection rejected because user could not be retrieved\n");
#endif  // #ifdef DEBUG_ALLOW_ANONYMOUS
                }
            else
                {
#ifdef DEBUG_ALLOW_ANONYMOUS
                DbgPrint("Connection accepted for user %s\n", RemoteUser);
#endif  // #ifdef DEBUG_ALLOW_ANONYMOUS
                }
            }
        else
            {
#ifdef DEBUG_ALLOW_ANONYMOUS
            DbgPrint("Connection rejected because it is not SSL\n");
#endif  // #ifdef DEBUG_ALLOW_ANONYMOUS
            }

        // if empty string, it is not authenticated
        if (AnonymousConnection)
            {
            dwSize = sizeof(AnonymousAccessNotAllowedString) - 1;  // don't want to count trailing 0.

            ReplyToClient(pECB, AnonymousAccessNotAllowedString, &dwSize, &dwStatus);
            HttpStatusCode = STATUS_SERVER_ERROR;
            ExtensionProcResult = dwStatus;
            goto AbortAndExit;
            }
        }

   pECB->dwHttpStatusCode = STATUS_CONNECTION_OK;

   if (g_fIsIIS6)
   {
      pLegacyVerb = RPC_CONNECT;
   }
   else
   {
      pLegacyVerb = POST_STR;
   }

    VerbLength = strlen(pECB->lpszMethod);
    ConnectionEstablishmentRequest = FALSE;

    // get the verb and depending on that we will determine our course of
    // action
    if ((VerbLength == InChannelEstablishmentMethodLength) 
        && (lstrcmpi(pECB->lpszMethod, InChannelEstablishmentMethod) == 0))
        {
        ConnectionEstablishmentRequest = TRUE;
        ProxyType = RPC_PROXY_CONNECTION_TYPE_IN_PROXY;
        }
    else if ((VerbLength == OutChannelEstablishmentMethodLength) 
        && (lstrcmpi(pECB->lpszMethod, OutChannelEstablishmentMethod) == 0))
        {
        ConnectionEstablishmentRequest = TRUE;
        ProxyType = RPC_PROXY_CONNECTION_TYPE_OUT_PROXY;
        }

    if (ConnectionEstablishmentRequest)
        {
        // check if this is echo request or a true connection
        // establishment
        ActualServerVariableLength = sizeof(ServerVariable);

        Result = pECB->GetServerVariable(pECB->ConnID,
            "CONTENT_LENGTH",
            ServerVariable,
            &ActualServerVariableLength
            );

        if (!Result)
            {
            HttpStatusCode = STATUS_SERVER_ERROR;
            ExtensionProcResult = HSE_STATUS_ERROR;
            goto AbortAndExit;
            }

        NumContentLength = atol(ServerVariable);
        if (NumContentLength <= MaxEchoRequestSize)
            {
            // too small for a channel. Must be an echo
            EchoRTS = GetEchoRTS(&BufferSize);

            // Echo back the RTS packet + headers
            hr = StringCbPrintfExA(EchoResponse,
                sizeof(EchoResponse),
                &DestinationEnd,   // ppszDestEnd
                NULL,   // pcbRemaining
                0,      // Flags
                EchoResponseHeader2,
                BufferSize
                );

            if (FAILED(hr))
                {
                HttpStatusCode = STATUS_SERVER_ERROR;
                ExtensionProcResult = HSE_STATUS_ERROR;
                goto AbortAndExit;
                }

            // calculate the number of bytes written as the
            // distance from the end of the written buffer to the 
            // beginning
            BytesWritten = DestinationEnd - EchoResponse;

            // send back headers
            dwSize = sizeof(HeaderEx);
            dwFlags = 0;
            memset(&HeaderEx, 0, dwSize);
            HeaderEx.fKeepConn = TRUE;
            HeaderEx.pszStatus = EchoResponseHeader1;
            HeaderEx.cchStatus = sizeof(EchoResponseHeader1);
            HeaderEx.pszHeader = EchoResponse;
            HeaderEx.cchHeader = BytesWritten;
            Result = pECB->ServerSupportFunction(pECB->ConnID,
                                            HSE_REQ_SEND_RESPONSE_HEADER_EX,
                                            &HeaderEx,
                                            &dwSize,
                                            &dwFlags);
            if (!Result)
                {
                HttpStatusCode = STATUS_SERVER_ERROR;
                ExtensionProcResult = HSE_STATUS_ERROR;
                goto AbortAndExit;
                }

            // send back Echo RTS
            dwSize = BufferSize;
            dwFlags = 0;
            Result = pECB->WriteClient(pECB->ConnID, (char *)EchoRTS, &dwSize, dwFlags);
            if (!Result)
                {
                HttpStatusCode = STATUS_SERVER_ERROR;
                ExtensionProcResult = HSE_STATUS_ERROR;
                goto AbortAndExit;
                }

            return HSE_STATUS_SUCCESS;
            }
        else
            {
            // a channel
            Result = ParseHTTP2QueryString (
                pECB->lpszQueryString,
                ServerAddress,
                sizeof(ServerAddress) / sizeof(ServerAddress[0]),
                ServerPort,
                sizeof(ServerPort) / sizeof(ServerPort[0])
                );

            if (Result == FALSE)
                {
                dwSize = sizeof(CannotParseQueryString) - 1;  // don't want to count trailing 0.

                ReplyToClient(pECB, CannotParseQueryString, &dwSize, &dwStatus);
                HttpStatusCode = STATUS_SERVER_ERROR;
                ExtensionProcResult = dwStatus;
                goto AbortAndExit;
                }

            if (g_pServerInfo->RpcNewHttpProxyChannel)
                {
                // get the remote user (if not available yet) and call 
                // the redirector dll
                if (RemoteUser == NULL)
                    {
                    Result = GetRemoteUserString (pECB,
                        &RemoteUser
                        );
                    if (Result == FALSE)
                        {
                        HttpStatusCode = STATUS_SERVER_ERROR;
                        ExtensionProcResult = HSE_STATUS_ERROR;
                        goto AbortAndExit;
                        }
                    }

                ASSERT(g_pServerInfo->RpcHttpProxyFreeString);

                RpcStatus = g_pServerInfo->RpcNewHttpProxyChannel (
                    ServerAddress,
                    ServerPort,
                    RemoteUser,
                    &ActualServerName
                    );

                if (RpcStatus != RPC_S_OK)
                    {
                    HttpStatusCode = STATUS_SERVER_ERROR;
                    ExtensionProcResult = HSE_STATUS_ERROR;
                    goto AbortAndExit;
                    }
                }
            else
                ActualServerName = ServerAddress;

            RpcStatus = I_RpcProxyNewConnection (
                ProxyType,
                ActualServerName,
                ServerPort,
                pECB,
                (I_RpcProxyCallbackInterface *)&ProxyCallbackInterface
                );

            if (g_pServerInfo->RpcNewHttpProxyChannel
                && (ActualServerName != ServerAddress))
                {
                // get the remote user and call the redirector dll
                ASSERT(g_pServerInfo->RpcHttpProxyFreeString);
                g_pServerInfo->RpcHttpProxyFreeString(ActualServerName);
                }

            if (RpcStatus != RPC_S_OK)
                {
                ReplyToClientWithStatus(pECB, RpcStatus);
                HttpStatusCode = STATUS_CONNECTION_OK;
                ExtensionProcResult = HSE_STATUS_SUCCESS;
                goto AbortAndExit;
                }

#if DBG
            DbgPrint("RPCPROXY: %d: Connection type %d to %S:%S\n", GetCurrentProcessId(),
                ProxyType, ServerAddress, ServerPort);
#endif
            HttpStatusCode = STATUS_CONNECTION_OK;
            ExtensionProcResult = HSE_STATUS_PENDING;
            goto AbortAndExit;
            }
        }

   //
   // The RPC request must be a post (or RPC_CONNECT for 6.0):
   //
   if (_mbsicmp(pECB->lpszMethod,pLegacyVerb))
      {
      dwSize = sizeof(STATUS_MUST_BE_POST_STR) - 1; // don't want to count trailing 0.

      ReplyToClient(pECB,STATUS_MUST_BE_POST_STR,&dwSize,&dwStatus);
      HttpStatusCode = STATUS_CONNECTION_OK;
      ExtensionProcResult = HSE_STATUS_SUCCESS;
      goto AbortAndExit;
      }

   //
   // Make sure there is no data from the initial BIND in the ECB data buffer:
   //
   // ASSERT(pECB->cbTotalBytes == 0);

   //
   // Get the connect parameters:
   //
   if (!ParseQueryString(pECB->lpszQueryString,&pOverlapped,&dwStatus))
      {
      dwSize = sizeof(STATUS_POST_BAD_FORMAT_STR) - 1;  // don't want to count trailing 0.

      ReplyToClient(pECB,STATUS_POST_BAD_FORMAT_STR,&dwSize,&dwStatus);
      HttpStatusCode = STATUS_CONNECTION_OK;
      ExtensionProcResult = HSE_STATUS_SUCCESS;
      goto AbortAndExit;
      }

   pOverlapped->pECB = pECB;

   //
   // Add the new ECB to the Active ECB List:
   //
   if (!AddToECBList(g_pServerInfo->pActiveECBList,pECB))
      {
      #ifdef DBG_ERROR
      DbgPrint("HttpExtensionProc(): AddToECBList() failed\n");
      #endif
      FreeOverlapped(pOverlapped);
      HttpStatusCode = STATUS_SERVER_ERROR;
      ExtensionProcResult = HSE_STATUS_ERROR;
      goto AbortAndExit;
      }

   //
   // Submit the first client async read:
   //
   if (!StartAsyncClientRead(pECB,pOverlapped->pConn,&dwStatus))
      {
      #ifdef DBG_ERROR
      DbgPrint("HttpExtensionProc(): StartAsyncClientRead() failed %d\n",dwStatus);
      #endif
      FreeOverlapped(pOverlapped);
      CleanupECB(pECB);
      HttpStatusCode = STATUS_SERVER_ERROR;
      ExtensionProcResult = HSE_STATUS_ERROR;
      goto AbortAndExit;
      }

   //
   // Post the first server read on the new socket:
   //
   IncrementECBRefCount(pServerInfo->pActiveECBList,pECB);

   if (!SubmitNewRead(pServerInfo,pOverlapped,&dwStatus))
      {
      #ifdef DBG_ERROR
      DbgPrint("HttpExtensionProc(): SubmitNewRead() failed %d\n",dwStatus);
      #endif
      FreeOverlapped(pOverlapped);
      CleanupECB(pECB);
      HttpStatusCode = STATUS_SERVER_ERROR;
      ExtensionProcResult = HSE_STATUS_ERROR;
      goto AbortAndExit;
      }

   //
   // Make sure the server receive thread is up and running:
   //
   if (!CheckStartReceiveThread(g_pServerInfo,&dwStatus))
      {
      #ifdef DBG_ERROR
      DbgPrint("HttpExtensionProc(): CheckStartReceiveThread() failed %d\n",dwStatus);
      #endif
      FreeOverlapped(pOverlapped);
      CleanupECB(pECB);
      HttpStatusCode = STATUS_SERVER_ERROR;
      ExtensionProcResult = HSE_STATUS_ERROR;
      goto AbortAndExit;
      }

   //
   // Send back connection Ok to client, and also set fKeepConn to FALSE.
   //
   dwSize = sizeof(HeaderEx);
   dwFlags = 0;
   memset(&HeaderEx,0,dwSize);
   HeaderEx.fKeepConn = FALSE;
   if (!pECB->ServerSupportFunction(pECB->ConnID,
                                    HSE_REQ_SEND_RESPONSE_HEADER_EX,
                                    &HeaderEx,
                                    &dwSize,
                                    &dwFlags))
      {
      #ifdef DBG_ERROR
      DbgPrint("HttpExtensionProc(): SSF(HSE_REQ_SEND_RESPONSE_HEADER_EX) failed %d\n",dwStatus);
      #endif
      FreeOverlapped(pOverlapped);
      CleanupECB(pECB);
      HttpStatusCode = STATUS_SERVER_ERROR;
      ExtensionProcResult = HSE_STATUS_ERROR;
      goto AbortAndExit;
      }

   HttpStatusCode = STATUS_SERVER_ERROR;
   ExtensionProcResult = HSE_STATUS_PENDING;
   // fall through

AbortAndExit:
    if (RemoteUser)
        MemFree(RemoteUser);

    pECB->dwHttpStatusCode = HttpStatusCode;

    return ExtensionProcResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\rpcproxy\rpcisapi.h ===
/*++

    Copyright (C) Microsoft Corporation, 2001

    Module Name:

        RpcIsapi.h

    Abstract:

        Definitions for the Rpc Proxy ISAPI extension

    Author:

        Kamen Moutafov    [KamenM]

    Revision History:

        KamenM      09/04/2001   Creation

--*/

#if _MSC_VER >= 1200
#pragma once
#endif

#ifndef __RPCISAPI_H_
#define __RPCISAPI_H_

const char *InChannelEstablishmentMethod = "RPC_IN_DATA";
const int InChannelEstablishmentMethodLength = 11;

const char *OutChannelEstablishmentMethod = "RPC_OUT_DATA";
const int OutChannelEstablishmentMethodLength = 12;

const char *RpcEchoDataMethod = "RPC_ECHO_DATA";
const int RpcEchoDataMethodLength = 13;

#define MaxServerAddressLength      1024
#define MaxServerPortLength            6      // length of 65536 + 1 for terminating NULL

const int ServerAddressAndPortSeparator = ':';

const char CannotParseQueryString[] = "HTTP/1.0 504 Invalid query string\r\n";
const char ServerErrorString[] = "HTTP/1.0 503 RPC Error: %d\r\n";
const char AnonymousAccessNotAllowedString[] = "HTTP/1.0 401 Anonymous requests or requests on unsecure channel are not allowed\r\n";

#define MaxEchoRequestSize          0x10

const char EchoResponseHeader1[] = "HTTP/1.1 200 Success";
const char EchoResponseHeader2[] = "Content-Type: application/rpc\r\nContent-Length:%d\r\nConnection: Keep-Alive\r\n\r\n";

#endif  // __RPCISAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\rpcproxy\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood  (stevewo) 12-Apr-1989
    Edward Reus (edwardr) 14-Jun-1997  Version for RpcProxy.Dll


Revision History:

!ENDIF

#
# The TARGETNAME variable is defined by the developer.  It is the name of
# the target (component) that is being built by this makefile.  It
# should NOT include any path or file extension information.
#

TARGETNAME=RpcProxy

#
# The TARGETPATH and TARGETTYPE varialbes are defined by the developer.
# The first specifies where the target is to be build.  The second specifies
# the type of target (either PROGRAM, DYNLINK or LIBRARY)
#

TARGETPATH=obj
TARGETTYPE=DYNLINK
PASS1_PUBLISH={$(O)\$(TARGETNAME).lib=$(SDK_LIB_PATH)\$(TARGETNAME).lib}

TARGETLIBS= $(SDK_LIB_PATH)\rpcrt4.lib               \
            $(SDK_LIB_PATH)\ole32.lib    \
            $(SDK_LIB_PATH)\kernel32.lib \
            $(SDK_LIB_PATH)\wsock32.lib  \
            $(SDK_LIB_PATH)\user32.lib   \
            $(SDK_LIB_PATH)\advapi32.lib \
            $(SDK_LIB_PATH)\msvcrt.lib   \
            $(SDK_LIB_PATH)\oleaut32.lib \
            $(SDK_LIB_PATH)\ActiveDS.lib

#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#

INCLUDES=..;..\..\..\mtrt
MSC_WARNING_LEVEL=/WX

#
# The SOURCES variable is defined by the developer.  It is a list of all the
# source files for this component.  Each source file should be on a separate
# line using the line continuation character.  This will minimize merge
# conflicts if two developers adding source files to the same component.
#

SOURCES= ..\PEventLog.mc \
         ..\filter.c     \
         ..\RpcIsapi.c   \
         ..\server.c     \
         ..\httpreg.c    \
         ..\regexp.c     \
         ..\memory.c     \
         ..\ecblist.c    \
         ..\olist.c      \
         ..\registry.cpp \
         ..\RpcProxy.rc

!ifdef DOSWIN32RPC
RPCENV=-DDOSWIN32RPC -DWIN32RPC
!else
RPCENV=-DNTENV -DWIN32RPC -DNTWIN32RPC
!endif

C_DEFINES=$(RPCENV)
USE_MSVCRT=1
BUFFER_OVERFLOW_CHECKS=1
DLLENTRY=DllMain

UMTYPE=console
UMRES=obj\*\RpcProxy.res
#NTPROFILEINPUT=yes

#
# Defining the NTTARGETFILES variable causes MAKEFILE.DEF to attempt to
# include .\makefile.inc immediately after it specifies the top
# level targets (all, clean and loc) and their dependencies.  MAKEFILE.DEF
# also expands the value of the NTTARGETFILES variable at the end of the
# list of dependencies for the all target.  Useful for specifying additional
# targets and dependencies that don't fit the general case covered by
# MAKEFILE.DEF
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\unpickle\unpickle.cxx ===
//*****************************************************************************
//
// Name:        unpickle.cxx
//
// Description: Library which exports UnpickleEEInfo
//
// History:
//  09/05/01  mauricf  Created.
//
//*****************************************************************************

//*****************************************************************************
//
// Copyright (c) 2001 by Microsoft Corp.  All rights reserved.
//
//*****************************************************************************

#include <precomp.hxx>
#include "eeinfo.hxx"

RPC_STATUS
UnpickleEEInfo (
    IN OUT unsigned char *Buffer,
    IN size_t BufferSize,
    OUT ExtendedErrorInfo **NewEEInfo
    )
/*++

Routine Description:

    This routine does the actual pickling in a user supplied buffer.
    The buffer must have been allocated large enough to hold all
    pickled data. Some of the other functions should have been
    used to get the size of the pickled data and the buffer
    should have been allocated appropriately

Arguments:
    Buffer - the actual Buffer to pickle into
    BufferSize - the size of the Buffer.

Return Value:
    RPC_S_OK if the pickling was successful.
    other RPC_S_* codes if it failed.

--*/
{
    ExtendedErrorInfo *EEInfo;
    handle_t PickleHandle;
    RPC_STATUS RpcStatus;
    ExtendedErrorInfoPtr *EEInfoPtr;

    RpcStatus = MesDecodeBufferHandleCreate((char *)Buffer, BufferSize, &PickleHandle);
    if (RpcStatus != RPC_S_OK)
        {
        return RpcStatus;
        }

    EEInfoPtr = &EEInfo;
    EEInfo = NULL;
    RpcTryExcept
        {
        ExtendedErrorInfoPtr_Decode(PickleHandle, EEInfoPtr);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        RpcStatus = RpcExceptionCode();
        }
    RpcEndExcept

    MesHandleFree(PickleHandle);

    if (RpcStatus == RPC_S_OK)
        *NewEEInfo = EEInfo;

    return RpcStatus;
}

inline void
FreeEEInfoRecordShallow (
    IN ExtendedErrorInfo *InfoToFree
    )
/*++

Routine Description:

    Frees only the eeinfo record - not any of
    the pointers contained in it.

Arguments:
    InfoToFree - the eeinfo record

Return Value:

    void

--*/
{
    MIDL_user_free(InfoToFree);
}

void
FreeEEInfoPrivateParam (
    IN ExtendedErrorParam *Param
    )
{
    if ((Param->Type == eeptiAnsiString)
        || (Param->Type == eeptiUnicodeString))
        {
        // AnsiString & UnicodeString occupy the same
        // memory location - ok to free any of them
        MIDL_user_free(Param->AnsiString.pString);
        }
    else if (Param->Type == eeptiBinary)
        {
        MIDL_user_free(Param->Blob.pBlob);
        }
}

void
FreeEEInfoPublicParam (
    IN OUT RPC_EE_INFO_PARAM *Param,
    IN BOOL CopyStrings
    )
/*++

Routine Description:

    If the type of parameter is string (ansi or unicode)
        and CopyStrings, free the string

Arguments:
    Param - the parameter to free
    CopyStrings - the value of the CopyStrings parameter
        when RpcErrorGetNextRecord was called. If non-zero
        the string will be freed. Otherwise, the function
        is a no-op

Return Value:

    void

--*/
{
    if ((Param->ParameterType == eeptAnsiString)
        || (Param->ParameterType == eeptUnicodeString))
        {
        if (CopyStrings)
            {
            RtlFreeHeap(RtlProcessHeap(), 0, Param->u.AnsiString);
            }
        }
    else if (Param->ParameterType == eeptBinary)
        {
        if (CopyStrings)
            {
            RtlFreeHeap(RtlProcessHeap(), 0, Param->u.BVal.Buffer);
            }
        }
}

void
FreeEEInfoRecord (
    IN ExtendedErrorInfo *EEInfo
    )
/*++

Routine Description:

    Frees a single ExtendedErrorInfo record and
    all strings within it.

Arguments:
    EEInfo - record to free

Return Value:

    void

--*/
{
    int i;
    THREAD *Thread;

    for (i = 0; i < EEInfo->nLen; i ++)
        {
        FreeEEInfoPrivateParam(&EEInfo->Params[i]);
        }

    if (EEInfo->ComputerName.Type == eecnpPresent)
        {
        MIDL_user_free(EEInfo->ComputerName.Name.pString);
        }

    Thread = RpcpGetThreadPointer();

    if (Thread)
        {
        Thread->SetCachedEEInfoBlock(EEInfo, EEInfo->nLen);
        }
    else
        {
        FreeEEInfoRecordShallow(EEInfo);
        }
}

void
FreeEEInfoChain (
    IN ExtendedErrorInfo *EEInfo
    )
/*++

Routine Description:

    Frees a chain of ExtendedErrorInfo records and
        all strings within them.

Arguments:
    EEInfo - head of list to free

Return Value:

    void

--*/
{
    ExtendedErrorInfo *CurrentInfo, *NextInfo;

    CurrentInfo = EEInfo;
    while (CurrentInfo != NULL)
        {
        // get the next link while we can
        NextInfo = CurrentInfo->Next;
        FreeEEInfoRecord(CurrentInfo);
        CurrentInfo = NextInfo;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\trans\rpcproxy\server.c ===
//-----------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  server.c
//
//  Thread code to manage communication between RPC client and
//  server for the HTTP RPC proxy.
//
//  History:
//
//    Edward Reus  00-00-97   Initial version.
//-----------------------------------------------------------------

#include <sysinc.h>
#include <rpc.h>
#include <rpcdce.h>
#include <winsock2.h>
#include <httpfilt.h>
#include <httpext.h>
#include "ecblist.h"
#include "filter.h"
#include "server.h"

//-----------------------------------------------------------------
//  Globals:
//-----------------------------------------------------------------

HANDLE  g_hServerThread = 0;
DWORD   g_dwThreadId = 0;

extern  SERVER_INFO *g_pServerInfo;

//-----------------------------------------------------------------
// CleanupECB()
//
// When the client or server side connection is closed, they call
// this function to handle cleanup of the ECB. The active ECBs are
// reference counted, since its used by both the server and client
// side threads. When the count goes to zero, the ECB can be
// destroyed by the IIS (HSE_REQ_DONE_WITH_SESSION).
//
//-----------------------------------------------------------------
DWORD CleanupECB( EXTENSION_CONTROL_BLOCK *pECB )
    {
    DWORD dwStatus = 0;

    if (DecrementECBRefCount(g_pServerInfo->pActiveECBList,pECB))
        {
        //
        // The ECB reference count has reached zero, we can get
        // rid of it:
        //
        #ifdef DBG_ECBREF
        DbgPrint("CleanupECB(): Destroy ECB: 0x%x\n",pECB);
        #endif

        if (!pECB->ServerSupportFunction( pECB->ConnID,
                                          HSE_REQ_DONE_WITH_SESSION,
                                          NULL, NULL, NULL))
            {
            dwStatus = GetLastError();
            #ifdef DBG_ERROR
            DbgPrint("CleanupECB(): HSE_REQ_DONE_WITH_SESSION failed: %d\n",dwStatus);
            #endif
            }
        }

    return dwStatus;
    }

#ifdef DBG
//-----------------------------------------------------------------
//  CheckForOldECBs()
//
//-----------------------------------------------------------------
void CheckForOldECBs()
    {
    int    i;
    DWORD  dwStatus;
    DWORD  dwAgeMsec;
    DWORD  dwTickCount = GetTickCount();
    ACTIVE_ECB_LIST   *pECBList = g_pServerInfo->pActiveECBList;
    ECB_ENTRY         *pECBEntry;
    LIST_ENTRY        *pEntry;
    LIST_ENTRY        *pHead = NULL;
    LIST_ENTRY        *pOldEntries = NULL;
    EXTENSION_CONTROL_BLOCK *pECB;

    //
    // Check for ECBs that are inactive (one side of connection
    // closed) for more that 10 minutes.
    //
    #define OLD_AGE_LIMIT 1000*60*10

    dwStatus = RtlEnterCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);

    for (i=0; i<HASH_SIZE; i++)
        {
        pHead = &(pECBList->HashTable[i]);

        pEntry = pHead->Flink;

        while (pEntry != pHead)
            {
            pECBEntry = CONTAINING_RECORD(pEntry,ECB_ENTRY,ListEntry);

            if (pECBEntry->dwTickCount)
                {
                // Ok, this is one where one of the server/client side
                // has closed the connection:
                //
                // dwAgeMsec is the age of the current ECB is msec.
                //
                if (pECBEntry->dwTickCount > dwTickCount)
                    {
                    // Rollover case (every ~49 days):
                    dwAgeMsec = (0xFFFFFFFF - pECBEntry->dwTickCount) + dwTickCount;
                    }
                else
                    {
                    dwAgeMsec = dwTickCount - pECBEntry->dwTickCount;
                    }

                // ASSERT( dwAgeMsec <= OLD_AGE_LIMIT);

                if (dwAgeMsec > OLD_AGE_LIMIT)
                    {
                    RemoveEntryList(pEntry);
                    pEntry->Blink = pOldEntries;
                    pOldEntries = pEntry;
                    }
                }

            pEntry = pEntry->Flink;
            }
        }

    dwStatus = RtlLeaveCriticalSection(&pECBList->cs);
    ASSERT(dwStatus == 0);

    while (pOldEntries)
        {
        pECBEntry = CONTAINING_RECORD(pOldEntries,ECB_ENTRY,ListEntry);
        pECB = pECBEntry->pECB;
        pOldEntries = pOldEntries->Blink;

        MemFree(pECBEntry);

        #ifdef DBG_ECBREF
        DbgPrint("CheckForOldECBs(): Age out pECB: 0x%x\n",pECB);
        #endif

        if (!pECB->ServerSupportFunction( pECB->ConnID,
                                          HSE_REQ_DONE_WITH_SESSION,
                                          NULL, NULL, NULL))
            {
            #ifdef DBG_ERROR
            DbgPrint("CheckForOldECBs(): HSE_REQ_DONE_WITH_SESSION failed: %d\n", GetLastError());
            #endif
            }
        }
    }
#endif

//-----------------------------------------------------------------
//  SendToClient()
//
//  Forward data received from the server back to the client.
//-----------------------------------------------------------------
BOOL SendToClient( SERVER_INFO       *pServerInfo,
                   SERVER_OVERLAPPED *pOverlapped,
                   DWORD              dwReceiveSize,
                   DWORD             *pdwStatus     )
{
   DWORD  dwSize;
   DWORD  dwFlags = (HSE_IO_SYNC | HSE_IO_NODELAY);
   UCHAR *pBuffer = pOverlapped->arBuffer;
   EXTENSION_CONTROL_BLOCK *pECB = pOverlapped->pECB;

   *pdwStatus = 0;

   //
   // Forward the data to the client:
   //
   dwSize = dwReceiveSize;
   while (dwReceiveSize)
      {
      if (!pECB->WriteClient(pECB->ConnID,pBuffer,&dwSize,dwFlags))
         {
         *pdwStatus = GetLastError();
         #ifdef DBG_ERROR
         DbgPrint("SendToClient(): WriteClient() failed: %d\n",*pdwStatus);
         #endif
         return FALSE;
         }

      dwReceiveSize -= dwSize;

      if (dwReceiveSize)
         {
         pBuffer += dwSize;
         }
      }

   return TRUE;
}

//-----------------------------------------------------------------
//  SubmitNewRead()
//
//  Submit a read request on the socket connected to the
//  RPC server process.
//-----------------------------------------------------------------
BOOL SubmitNewRead( SERVER_INFO       *pServerInfo,
                    SERVER_OVERLAPPED *pOverlapped,
                    DWORD             *pdwStatus    )
{
   DWORD  dwBytesRead = 0;
   SERVER_CONNECTION  *pConn = pOverlapped->pConn;


   *pdwStatus = 0;

   pOverlapped->Internal = 0;
   pOverlapped->InternalHigh = 0;
   pOverlapped->Offset = 0;
   pOverlapped->OffsetHigh = 0;
   pOverlapped->hEvent = 0;

   SetLastError(ERROR_SUCCESS);

   if (!ReadFile( (HANDLE)pConn->Socket,
                  pOverlapped->arBuffer,
                  READ_BUFFER_SIZE,
                  &dwBytesRead,
                  (OVERLAPPED*)pOverlapped ) )
      {
      *pdwStatus = GetLastError();
      if ( (*pdwStatus != ERROR_IO_PENDING) && (*pdwStatus != ERROR_SUCCESS) )
         {
         #ifdef DBG_ERROR
         DbgPrint("SubmitNewRead(): ReadFile() Socket: %d  failed: %d\n",pConn->Socket,*pdwStatus);
         #endif
         return FALSE;
         }
      }

   return TRUE;
}

//-----------------------------------------------------------------
//  ForwardAndSubmitNewRead()
//
//  Forward data to the client, the submit a new read on the
//  server.
//-----------------------------------------------------------------
BOOL ForwardAndSubmitNewRead( SERVER_INFO       *pServerInfo,
                              SERVER_OVERLAPPED *pOverlapped,
                              DWORD              dwReceiveSize,
                              DWORD             *pdwStatus     )
{
   DWORD  dwBytesRead = 0;
   SERVER_CONNECTION  *pConn = pOverlapped->pConn;

   *pdwStatus = 0;

   //
   // Forward the data to the client:
   //
   if (!SendToClient(pServerInfo,pOverlapped,dwReceiveSize,pdwStatus))
      {
      return FALSE;
      }

   //
   // Submit another read on the socket:
   //
   if (!SubmitNewRead(pServerInfo,pOverlapped,pdwStatus))
      {
      return FALSE;
      }

   return TRUE;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif
//-----------------------------------------------------------------
//  ServerReceiveThreadProc()
//
//  This is the receive thread for the server. It monitors the
//  all the sockets to RPC servers that are currently connected
//  to the RPC proxy. When it gets incomming data from an RPC
//  server socket, it forwards the data to the client, then
//  submits a new read on the socket that data came in on.
//
//  Once its started, it never stops...
//-----------------------------------------------------------------
DWORD WINAPI ServerReceiveThreadProc( void *pvServerInfo )
{
   int    iRet;
   BOOL   fWaitAll = FALSE;
   DWORD  dwStatus;
   DWORD  dwTimeout = TIMEOUT_MSEC;
   DWORD  dwWhichEvent;
   ULONG_PTR dwKey;
   DWORD  dwNumBytes;
   SERVER_OVERLAPPED *pOverlapped;
   SERVER_INFO       *pServerInfo = (SERVER_INFO*)pvServerInfo;
   EXTENSION_CONTROL_BLOCK *pECB;
   DWORD  dwTemp;
   DWORD  dwSize;
   DWORD  dwFlags;


   while (TRUE)
      {
      SetLastError(0);
      dwKey = 0;
      dwNumBytes = 0;
      pOverlapped = NULL;
      if (!GetQueuedCompletionStatus(pServerInfo->hIoCP,&dwNumBytes,&dwKey,(OVERLAPPED**)&pOverlapped,dwTimeout))
         {
         dwStatus = GetLastError();
         if (dwStatus == WAIT_TIMEOUT)
            {
            // Our reads are still posted, go around again:
            #ifdef DBG
            CheckForOldECBs();
            #endif
            continue;
            }
         else if (dwStatus == ERROR_OPERATION_ABORTED)
            {
            // The posted read on the server was aborted (why?). Try
            // to resubmit the read...
            if ( (pOverlapped)
               && (!SubmitNewRead(pServerInfo,pOverlapped,&dwStatus)) )
               {
               pECB = pOverlapped->pECB;
               CloseServerConnection(pOverlapped->pConn);
               FreeOverlapped(pOverlapped);
               CleanupECB(pECB);
               #ifdef DBG_ERROR
               DbgPrint("ServerReceiveThreadProc(): Aborted re-submit failed: %d\n",dwStatus);
               #endif
               }
            continue;
            }
         else if (dwStatus == ERROR_NETNAME_DELETED)
            {
            // The server connection has been closed:
            if (pOverlapped)
               {
               pECB = pOverlapped->pECB;
               CloseServerConnection(pOverlapped->pConn);
               FreeOverlapped(pOverlapped);
               CleanupECB(pECB);

               #ifdef DBG_ERROR
               DbgPrint("ServerReceiveThreadProc(): Socket(%d): ERROR_NETNAME_DELETED\n",dwKey,dwStatus);
               #endif
               }
            continue;
            }
         else
            {
            #ifdef DBG_ERROR
            DbgPrint("ServerReceiveThreadProc(): GetQueuedCompletionStatus() failed: %d\n",dwStatus);
            #endif
            if (pOverlapped)
               {
               pECB = pOverlapped->pECB;
               CloseServerConnection(pOverlapped->pConn);
               FreeOverlapped(pOverlapped);
               CleanupECB(pECB);
               }
            continue;
            }
         }

      // Check for incomming data from a server:
      if (pOverlapped)
          {
          pECB = pOverlapped->pECB;

          if (dwNumBytes)
              {
              //
              // data from server arrived...
              //
              if (!ForwardAndSubmitNewRead(pServerInfo,pOverlapped,dwNumBytes,&dwStatus))
                 {
                 CloseServerConnection(pOverlapped->pConn);
                 FreeOverlapped(pOverlapped);
                 CleanupECB(pECB);
                 #ifdef DBG_ERROR
                 DbgPrint("ServerReceiveThreadProc(): ForwardAndSubmitNewRead(): failed: %d\n",dwStatus);
                 #endif
                 }
              }
          else
              {
              // Receive, but zero bytes, so connection was gracefully closed...
              CloseServerConnection(pOverlapped->pConn);
              FreeOverlapped(pOverlapped);
              CleanupECB(pECB);
              }
          }
      else
          {
          // The filter called EndOfSession() and posted this message to
          // us to close up... dwKey is the socket in question:

          #ifdef DBG_ERROR
          DbgPrint("ServerReceiveProc(): EndOfSession(): pOverlapped == NULL\n");
          #endif

          iRet = closesocket( (SOCKET)dwKey );

          #ifdef DBG_COUNTS
          if (iRet == SOCKET_ERROR)
              {
              DbgPrint("[6] closesocket(%d) failed: %d\n",dwKey,WSAGetLastError());
              }
          else
              {
              int iCount = InterlockedDecrement(&g_iSocketCount);
              DbgPrint("[6] closesocket(%d): Count: %d -> %d\n",
                       dwKey, 1+iCount, iCount );
              }
          #endif
          }
      }

   return 0;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

//-----------------------------------------------------------------
//  CheckStartReceiveThread()
//
//  Check to see of the server side receive thread is running, if
//  it isn't started yet, then start it.
//-----------------------------------------------------------------
BOOL CheckStartReceiveThread( SERVER_INFO *pServerInfo,
                              DWORD       *pdwStatus )
{
   *pdwStatus = 0;

   if (!g_hServerThread)
      {
      g_hServerThread = CreateThread( NULL,
                                      0,
                                      ServerReceiveThreadProc,
                                      (void*)pServerInfo,
                                      0,
                                      &g_dwThreadId );

      if (!g_hServerThread)
         {
         *pdwStatus = GetLastError();
         #ifdef DBG_ERROR
         DbgPrint("CheckStartServerThread(): CreateThread() failed: 0x%x\n",pdwStatus);
         #endif
         return FALSE;
         }
      }

   return TRUE;
}

//-----------------------------------------------------------------
//  AsyncClientReadComplete()
//
//  This function is called when data (a call) comes in from an
//  RPC client. It then forwards the data to the RPC server via
//  the function SendToServer().
//-----------------------------------------------------------------
void WINAPI AsyncClientReadComplete( IN EXTENSION_CONTROL_BLOCK *pECB,
                                     IN void     *pvOverlapped,
                                     IN DWORD     dwBytes,
                                     IN DWORD     dwStatus )
{
   int       iRet;
   DWORD     dwSize;
   DWORD     dwFlags;
   DWORD     dwLocalStatus;
   SERVER_CONNECTION       *pConn;
   SERVER_OVERLAPPED       *pOverlapped = (SERVER_OVERLAPPED*)pvOverlapped;
   SOCKET    Socket;

   ASSERT(pECB == pOverlapped->pECB);

   pConn = pOverlapped->pConn;

   if (dwStatus == ERROR_SUCCESS)
      {
      if (dwBytes)
         {
         if (pOverlapped->fFirstRead)
            {
            pOverlapped->fFirstRead = FALSE;
            if ( (dwBytes < 72) && (pECB->lpbData) )
               {
               #ifdef DBG_ERROR
               DbgPrint("AsyncClientReadComplete(): Bind missing bytes: %d\n",72-dwBytes);
               #endif
               dwStatus = SendToServer(pOverlapped->pConn,pECB->lpbData,72-dwBytes);
               }
            }

         // Got data from the client, forward it to the server:
         dwStatus = SendToServer(pOverlapped->pConn,pOverlapped->arBuffer,dwBytes);

         // Submit a new async read on the client:
         if (dwStatus == ERROR_SUCCESS)
            {
            dwSize = sizeof(pOverlapped->arBuffer);
            dwFlags = HSE_IO_ASYNC;
            if (!pECB->ServerSupportFunction(pECB->ConnID,
                                             HSE_REQ_ASYNC_READ_CLIENT,
                                             pOverlapped->arBuffer,
                                             &dwSize,
                                             &dwFlags))
               {
               dwStatus = GetLastError();
               }
            }
         }
      }

   if ((dwBytes == 0) || (dwStatus != ERROR_SUCCESS))
      {
      //
      // Connection to client was closed (dwBytes == 0) or error. So
      // shutdown socket to server:
      //
      if (pOverlapped)
         {
         CloseServerConnection(pOverlapped->pConn);
         pOverlapped->pECB = NULL;
         FreeOverlapped(pOverlapped);
         CleanupECB(pECB);
         }

      #ifdef DBG_ERROR
      if ((dwStatus != ERROR_SUCCESS) && (dwStatus != ERROR_NETNAME_DELETED))
         {
         DbgPrint("AsyncClientReadComplete(): Erorr: %d  Close server socket: %d\n",dwStatus,pConn->Socket);
         }
      #endif
      }
}

//-----------------------------------------------------------------
//  StartAsyncClientRead()
//
//  Called by the RpcIsapi half of the code to start an async read
//  on the client connection.
//-----------------------------------------------------------------
BOOL StartAsyncClientRead( EXTENSION_CONTROL_BLOCK *pECB,
                           SERVER_CONNECTION       *pConn,
                           DWORD                   *pdwStatus )
{
   SERVER_OVERLAPPED       *pOverlapped;

   pOverlapped = AllocOverlapped();
   if (!pOverlapped)
       {
       *pdwStatus = RPC_S_OUT_OF_MEMORY;
       return FALSE;
       }

   *pdwStatus = 0;

   pOverlapped->pECB = pECB;

   // The SERVER_CONNECTION (pConn) is in two separate SERVER_OVERLAPPED
   // structures, one for client async reads and one for server async
   // reads, as well as in the filter context. So it is reference counted.
   pOverlapped->pConn = pConn;
   AddRefConnection(pConn);

   pOverlapped->fFirstRead = TRUE;

   if (!pECB->ServerSupportFunction(pECB->ConnID,
                                    HSE_REQ_IO_COMPLETION,
                                    AsyncClientReadComplete,
                                    NULL,
                                    (void*)pOverlapped))
      {
      *pdwStatus = GetLastError();
      FreeOverlapped(pOverlapped);
      #ifdef DBG_ERROR
      DbgPrint("StartAsyncClientRead(): HSE_REQ_IO_COMPLETION Failed: %d\n",*pdwStatus);
      #endif
      return FALSE;
      }

   pOverlapped->dwBytes = sizeof(pOverlapped->arBuffer);
   pOverlapped->dwFlags = HSE_IO_ASYNC;
   if (!pECB->ServerSupportFunction(pECB->ConnID,
                                    HSE_REQ_ASYNC_READ_CLIENT,
                                    pOverlapped->arBuffer,
                                    &pOverlapped->dwBytes,
                                    &pOverlapped->dwFlags))
      {
      *pdwStatus = GetLastError();
      FreeOverlapped(pOverlapped);
      #ifdef DBG_ERROR
      DbgPrint("StartAsyncClientRead(): HSE_REQ_ASYNC_READ_CLIENT Failed: %d\n",*pdwStatus);
      #endif
      return FALSE;
      }

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\erec\ebase.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

#ifndef __EBASE_H__
#define __EBASE_H__

typedef struct _sgoto
	{
	short	Goto;
	short	Token;
	} SGOTO;

typedef struct _sgotovector
	{

	short		State;
	SGOTO	*	pSGoto;
	short		Count;

	} SGOTOVECTOR;

typedef struct _tokvsstatevector
	{
	short		Token;
	short	*	pTokenVsState;
	short		Count;
	} TOKVSSTATEVECTOR;

#endif//__EBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\selbinding\selbinding.cxx ===
/*++

  Copyright (C) Microsoft Corporation, 2002

Module Name:

    selbinding.hxx

Abstract:

    Manipulation of the selective binding registry settings.

Revision History:
  MauricF      03-20-02    Consolodate access to selective binding settings across
                           rpccfg/rpcnsh/rpctrans.lib

--*/
#include <sysinc.h>
#include <selbinding.hxx>


DWORD
GetSelectiveBindingVersion(
    IN  DWORD   dwSize,
    IN  LPVOID lpBuffer,
    OUT SB_VER  *pVer
    )
/*++
 
Routine Description:

    Determines the version of the selective binding settings in this buffer.
    the appropriate 
Arguments:

    dwSize - Size of the buffer

    lpBuffer - The buffer containing the settings 

    pVer - Pointer to the version we fill in

Return Value:

    ERROR_OUTOFMEMORY

    ERROR_SUCCESS - if the buffer is corrupt -> *pVer==SB_VER_UNKNOWN, if its default settings *pVer==SB_VER_DEFAULT
--*/

{   
    SUBNET_REG_ENTRY *pRegEntry;

    ASSERT(pVer != NULL);

    //Initialize the out params
    *pVer = SB_VER_UNKNOWN;

    //If NULL, then we treat it as default settings
    if ((dwSize == 0) || (lpBuffer == NULL))
        {
        *pVer = SB_VER_DEFAULT;
        return ERROR_SUCCESS;
        }

    //If its not large enough to hold the flag, then
    //it isn't new format, could be the old format
    if (dwSize < sizeof(DWORD))
        {
        *pVer = SB_VER_INDICES;
        return ERROR_SUCCESS;
        }
    
    //We can now cast the buffer as the structure, but don't
    //access anything but the flag just yet
    pRegEntry = (SUBNET_REG_ENTRY*) lpBuffer;

    //If it doesn't contain our flag at the begining, its
    //not new format, could be a differnet format though
    if (((ULONG)'4vPI') != pRegEntry->dwFlag)
        {
        *pVer = SB_VER_INDICES;
        return ERROR_SUCCESS;
        }

    //At this point it is either new format or unknown, it is not old format

    //If its not large enough to hold the header, its unknown
    if (dwSize < sizeof(SUBNET_REG_ENTRY))
        {
        return ERROR_SUCCESS;
        }

    //Now we can access the rest of thee header

    //If the size is not consistent with the number of subnets
    //it claims to be holding then it is unknown
    if (dwSize != (sizeof(SUBNET_REG_ENTRY) + sizeof(DWORD) * pRegEntry->dwCount))
        {
        return ERROR_SUCCESS;
        }

    //If it is holding zero subnets, its unknown (this is not valid for SB_VER_SUBNETS)
	if (pRegEntry->dwCount == 0)
		{
		return ERROR_SUCCESS;
		}

    //Make sure the admit flag is either zero or one
    if ((pRegEntry->dwAdmit != 0) && (pRegEntry->dwAdmit != 1))
        {
        return ERROR_SUCCESS;
        }

    //Looks legit
    *pVer = SB_VER_SUBNETS;
    return ERROR_SUCCESS;
}

DWORD
GetSelectiveBindingBuffer(
    OUT LPDWORD lpSize,
    OUT LPVOID *lppBuffer
    )
/*++
 
Routine Description:

    Retrieves the buffer from the registry and allocates space for you.
Arguments:

    lpSize - This is filled in with the size of the buffer.

    lppBuffer - This will point to a buffer containing the registry entry, can't be NULL

Return Value:

    ERROR_OUTOFMEMORY

    ERROR_ACCESS_DENIED - The user did not have access to the registry key.

    ERROR_SUCCESS - lppBuffer will point to a buffer containing the registry key or NULL if the
                    key could not be found or is of zero size.

  --*/

{
    HKEY hKey;
    DWORD dwStatus;
    DWORD dwDummy;
    
    ASSERT((lpSize != NULL) && (lppBuffer != NULL));

    //Init the out params
    *lppBuffer = NULL;
    *lpSize = 0;

    // Open the handle to our registry entry
    dwStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RPC_SELECTIVE_BINDING_KEY_PATH,
                             0, KEY_READ, &hKey
                             );
    if (dwStatus != ERROR_SUCCESS)
        {
        ASSERT((dwStatus == ERROR_FILE_NOT_FOUND) ||
               (dwStatus == ERROR_ACCESS_DENIED)  ||
               (dwStatus == ERROR_OUTOFMEMORY) ||
               (dwStatus == ERROR_NOT_ENOUGH_MEMORY));

        if (dwStatus == ERROR_FILE_NOT_FOUND)
            {
            //Default settings
            return ERROR_SUCCESS;
            }
        return dwStatus;
        }
    
    // Query for the size of the buffer

    dwStatus = RegQueryValueEx(hKey, RPC_SELECTIVE_BINDING_VALUE,
                                0, &dwDummy, NULL, lpSize);

    if (dwStatus != ERROR_SUCCESS)
        {
        ASSERT(dwStatus == ERROR_OUTOFMEMORY);
        RegCloseKey(hKey);
        return dwStatus;
        }

    // If the size is zero, we will map this to default settings
    if (*lpSize == 0)
        {
        RegCloseKey(hKey);
        return ERROR_SUCCESS;
        }
    
    // Allocate the buffer
    *lppBuffer = new char[*lpSize];
    if (*lppBuffer == NULL)
        {
        RegCloseKey(hKey);
        return ERROR_OUTOFMEMORY;
        }

    // Get the buffer for real this time
    dwStatus = RegQueryValueEx(hKey, RPC_SELECTIVE_BINDING_VALUE,
                                0, &dwDummy, (LPBYTE)*lppBuffer, lpSize);

    if (dwStatus != ERROR_SUCCESS)
        {
        ASSERT(dwStatus == ERROR_OUTOFMEMORY);
        delete [] *lppBuffer;
        }

    RegCloseKey(hKey);
    return dwStatus;

}

DWORD
GetSelectiveBindingSettings(
    OUT SB_VER  *pVer,
    OUT LPDWORD lpSize,
    OUT LPVOID *lppSettings
    )
/*++
 
Routine Description:

    Retrieves the version and version specific setting information. *lppSettings will point to the settings
    if *pVer == SB_VER_INDICES or SB_VER_SUBNETS, other wise *lppSettings will be NULL
    
Arguments:
 

Return Value:

    ERROR_SUCCESS
    ERROR_ACCESS_DENIED
    ERROR_OUTOFMEMORY
--*/
{
    DWORD   dwStatus = ERROR_SUCCESS;
    LPVOID lpBuffer = NULL;
    DWORD   dwSize = 0;

    ASSERT((pVer != NULL) && (lpSize != NULL) && (lppSettings != NULL));

    *lppSettings = NULL;

    // Get the selective binding buffer
    dwStatus = GetSelectiveBindingBuffer(&dwSize, &lpBuffer);
    if (dwStatus != ERROR_SUCCESS)
        {
        ASSERT((dwStatus == ERROR_ACCESS_DENIED) ||
               (dwStatus == ERROR_OUTOFMEMORY));        
        return dwStatus;
        }

    // Get the selective binding version

    dwStatus = GetSelectiveBindingVersion(dwSize, lpBuffer, pVer);
    if (dwStatus != ERROR_SUCCESS)
        {
        ASSERT(0);
        delete [] lpBuffer;
        return dwStatus;
        }


    // Depending on the version, fill in the appropriate structure
    switch (*pVer)
        {
        case SB_VER_INDICES:
        dwStatus = GetSelectiveBindingIndices(dwSize, lpBuffer, lpSize, (VER_INDICES_SETTINGS**) lppSettings);
        break;

        case SB_VER_SUBNETS:
        dwStatus = GetSelectiveBindingSubnets(dwSize, lpBuffer, lpSize, (VER_SUBNETS_SETTINGS**) lppSettings);
        break;

        case SB_VER_UNKNOWN:
        case SB_VER_DEFAULT:
        break;

        default:
        ASSERT(0);
        }

    ASSERT((dwStatus == ERROR_SUCCESS)      ||
           (dwStatus == ERROR_OUTOFMEMORY));

    return dwStatus;
}

DWORD
GetSelectiveBindingSubnets(
    IN  DWORD   dwSize,
    IN  LPVOID lpBuffer,
    OUT LPDWORD lpSize,
    OUT VER_SUBNETS_SETTINGS **lppSettings
    )
/*++
 
Routine Description:

    Allocates and fills in a settings structure based off an SB_VER_SUBNETS buffer.
    
Arguments:
 
    IN dwSize - size of the SB_VER_SUBNETS buffer
    IN lpBuffer - pointer to the SB_VER_SUBNETS buffer
    OUT lppSettings - filled in with a pointer to te subnet settings

Return Value:

    ERROR_SUCCESS
    ERROR_OUTOFMEMORY

--*/

{
    SUBNET_REG_ENTRY *pEntry;

    ASSERT((lpBuffer != NULL) &&
           (lppSettings != NULL));

    // Cast the buffer as a SUBNET_REG_ENTRY
    pEntry = (SUBNET_REG_ENTRY*)lpBuffer;

    // Calculate the size to allocate for VER_SUBNETS_SETTINGS
    *lpSize = sizeof(VER_SUBNETS_SETTINGS) + pEntry->dwCount*sizeof(DWORD);

    *lppSettings = (VER_SUBNETS_SETTINGS*) new char [*lpSize];
    if (*lppSettings == NULL)
        return ERROR_OUTOFMEMORY;

    // Copy in the relevent fields
    (*lppSettings)->bAdmit = (BOOL)pEntry->dwAdmit;
    (*lppSettings)->dwCount = pEntry->dwCount;
    memcpy((*lppSettings)->dwSubnets, pEntry->dwSubnets, pEntry->dwCount*sizeof(DWORD));

    return ERROR_SUCCESS;
}

DWORD
GetSelectiveBindingIndices(
    IN  DWORD   dwSize,
    IN  LPVOID lpBuffer,
    OUT LPDWORD lpSize,
    OUT VER_INDICES_SETTINGS **lppSettings
    )
/*++
 
Routine Description:

    Allocates and fills in a settings structure based off an SB_VER_INDICES buffer.
    
Arguments:
 
    IN dwSize - size of the SB_VER_INDICES buffer
    IN lpBuffer - pointer to the SB_VER_INDICES buffer
    OUT lppSettings - filled in with a pointer to the indices settings

Return Value:

    ERROR_SUCCESS
    ERROR_OUTOFMEMORY

--*/

{

    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwCount=0;
    LPVOID lpTmp = NULL;
    DWORD dwIndex;
    DWORD idx;

    ASSERT((lpBuffer != NULL) &&
           (lppSettings != NULL));

    // Count how many indices there are 
    lpTmp = lpBuffer;
    while (NextIndex((char**)&lpTmp) != -1) dwCount++;

    // Calculate the size to allocate for VER_INDICES_SETTINGS
    *lpSize = sizeof(VER_INDICES_SETTINGS) + dwCount*sizeof(DWORD);
    
    *lppSettings = (VER_INDICES_SETTINGS*) new char [*lpSize];
    if (*lppSettings == NULL)
        return ERROR_OUTOFMEMORY;

    // Step through and get each index
    lpTmp = lpBuffer;
    idx = 0;
    (*lppSettings)->dwCount = dwCount;
    for (idx = 0; idx <dwCount; idx++)
        (*lppSettings)->dwIndices[idx] = NextIndex((char**)&lpTmp);
        
    return ERROR_SUCCESS;
}


DWORD
DeleteSelectiveBinding()
/*++
 
Routine Description:

    Deletes the linkage key, this indicates we should use the default settings for selective binding
    (listen on all interfaces).
    
Arguments:
 

Return Value:

    ERROR_SUCCESS
    ERROR_ACCESS_DENIED

--*/

{
    HKEY hKey;
    DWORD dwStatus;

    // Attempt to open the key
    dwStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RPC_SETTINGS_PATH,
                                0, KEY_ALL_ACCESS, &hKey
                                );

    if (dwStatus != ERROR_SUCCESS)
        {
        ASSERT((dwStatus == ERROR_ACCESS_DENIED) ||
               (dwStatus == ERROR_FILE_NOT_FOUND));
		return dwStatus;
        }

    // Delete the selective binding key
    dwStatus = RegDeleteKey(hKey, RPC_SELECTIVE_BINDING_KEY);
    ASSERT((dwStatus == ERROR_SUCCESS) ||
           (dwStatus == ERROR_FILE_NOT_FOUND));

    RegCloseKey(hKey);
    return ERROR_SUCCESS;
   
}


DWORD
SetSelectiveBindingSubnets(
    IN DWORD   dwCount,
    IN LPDWORD lpSubnetTable,
    IN BOOL    bAdmit
    )
/*++
 
Routine Description:

    This converts the inputs into a buffer which we write to the registry using SetSelectiveBindingBuffer.
    
Arguments:

    bAdmit  - True for Admit (Add) list False for Deny (Delete) list.

    dwCount - The number of subnets we are setting.  It is illegal to set zero subnets.

    lpSubnetTable - This is the array of subnets we wish to create an Admit or Deny list from.
 

Return Value:

    ERROR_ACCESS_DENIED
    ERROR_OUTOFMEMORY
    ERROR_SUCCESS

--*/
{
    SUBNET_REG_ENTRY *pRegEntry;
    DWORD dwSize;
    DWORD dwStatus;

    ASSERT((dwCount !=0) &&
           (lpSubnetTable != NULL));

    //Calculate the size of the buffer
    dwSize = sizeof(SUBNET_REG_ENTRY) + dwCount*sizeof(DWORD);
    pRegEntry = (SUBNET_REG_ENTRY*) new char[dwSize];   
    if (pRegEntry == NULL)
        return ERROR_OUTOFMEMORY;

    //Fill in the structure
    pRegEntry->dwFlag = ((ULONG)'4vPI');
    pRegEntry->dwCount = dwCount;
    pRegEntry->dwAdmit = (bAdmit ? ((DWORD)0x01) : ((DWORD)0x00));
    memcpy(pRegEntry->dwSubnets, lpSubnetTable, dwCount*sizeof(DWORD));

    //Write this to the registry
    dwStatus = SetSelectiveBindingBuffer(dwSize, (LPVOID)pRegEntry);
		
    delete [] pRegEntry;
    pRegEntry = NULL;
    return dwStatus;
}


DWORD
SetSelectiveBindingBuffer(
    IN DWORD dwSize,
    IN LPVOID lpBuffer
    )
/*++
 
Routine Description:

    Writes the buffer to the selective binding key in the registry
Arguments:

    dwSize - This is the size of the buffer.

    lpBuffer - This is the buffer we write to the registry.

Return Value:

	ERROR_ACCESS_DENIED - The user did not have permission to write to this key
    ERROR_SUCCESS

--*/
{
    HKEY hKey;
    DWORD dwStatus;
    DWORD dwDummy;

    ASSERT((dwSize != 0) &&
           (lpBuffer != NULL));

    // Attempt to create the key, this will succeed even if the key already exists
    dwStatus = RegCreateKeyEx(HKEY_LOCAL_MACHINE, RPC_SELECTIVE_BINDING_KEY_PATH,
                                0, "", REG_OPTION_NON_VOLATILE,
                                KEY_WRITE, NULL, &hKey, &dwDummy
                                );
    if (dwStatus != ERROR_SUCCESS)
        {
        ASSERT(dwStatus == ERROR_ACCESS_DENIED);
		return dwStatus;
        }

    // Write the value
    dwStatus = RegSetValueEx(hKey, "Bind",
                              0, REG_BINARY, (LPBYTE)lpBuffer,
                              dwSize
                              );

    ASSERT(dwStatus == ERROR_SUCCESS);

    RegCloseKey(hKey);
    return dwStatus;
}

DWORD
NextIndex(
    IN OUT char **Ptr
    )
/*++
 
Routine Description:

    Retrieves the next index from the buffer, and moves the pointer to the start of the
    following index.

Arguments:

    Ptr - A pointer to the old registry format for storing indices.  Each index is stored
          as a string, (must be ASCII when its passed to this function).  The Ptr gets
          updated to point to the following index.

Return Value:
    
    The index retrieved or -1 if the end of the buffer has been reached.
--*/
{
    char *Index = (char *)*Ptr ;
    if (*Index == 0)
        {
        return -1;
        }

    while (*(char *)*Ptr) ((char *)*Ptr)++ ;
    ((char *)*Ptr)++ ;

    return (DWORD) atol(Index) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\erec\ebase.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989-2000 Microsoft Corporation

 Module Name:

    ebase.c

 Abstract:

    This file generates the error recovery data base.

 Notes:

    1.  Inputs to this module are the extable.* files generated by yacc in
        response to the s switch.
    2.  Take the state vs token index file ( extable.h3 ), and generate the
        state vs token table using the token index to token value
        translations provided by extable.h1
    3.  Take the state vs expected RHS file ( extable.h2 ) and generate a
        data base of expected RHS in every state.

 Author:

    vibhasc 11-15-91

 ----------------------------------------------------------------------------*/

/*****************************************************************************
 local defines and includes
 *****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <malloc.h>
#include <string.h>

#include "ebase.h"

#define STATE_VS_TOKEN_INDEX_FILE   "extable.h3"
#define TOKEN_TRANSLATION_FILE      "extable.h1"
#define STATE_VS_EXPECTED_FILE      "extable.h2"
#define ISVALIDTOKEN( i ) (TRUE)
#define MAX_TRANSLATION_LINE_SIZE (512)

#define TRUE 1
#define FALSE 0
                                   /* from winerror.h */
#define ERROR_INVALID_DATA  13

#define CHECK_FSCAN_STATUS( fscanfcall ) \
    if ( EOF == (fscanfcall) ) \
        { \
            fprintf( stderr, \
                     "\nmidleb : error MIDLEB%d : unexpected end of input stream", \
                     ERROR_INVALID_DATA ); \
            exit( ERROR_INVALID_DATA ); \
        }

typedef unsigned int BOOL;

typedef enum _status
    {

    STATUS_OK   = 0,
    OUT_OF_MEMORY,
    CANT_OPEN_INPUT_FILE,
    CANT_OPEN_OUTPUT_FILE,
    WRONG_ARGUMENT_COUNT

    } STATUS_T;

typedef struct _xlat
    {
    char    *   pIncoming;
    char    *   pTranslated;
    struct _xlat *pNext;
    } XLAT;

typedef struct _DBENTRY
    {
    short   State;
    char *  pTranslated;
    } DBENTRY;

/*****************************************************************************
 global data 
 *****************************************************************************/

FILE                    *   hStateVsTokenIndexFile;
FILE                    *   hStateVsExpectedFile;
FILE                    *   hOutput;
FILE                    *   hXlatFile;
FILE                    *   hTokXlatHdl;
SGOTO                   **  pSGoto;
short                   *   pSGotoCount;
short                   **  pTokVsState;
short                   *   pTokVsStateIndex;
short                       ValidStates;
short                       ValidTokens;
char                    *   pPrefix;
XLAT                    *   pXlat = 0, 
                        *   pXlatCur = 0;
DBENTRY                 *   pDataBase;
short                       NTOKENS;
short                       ACCEPTCODE;
short                   *   TokVal;
short                   *   TokCount;
short                       NSTATES;
short                       MAXTOKVSSTATE;
short                       MAXSTATEVSTOK;
short                       MAXTOKENVALUE;
short                       MAXSTATEVSEXPECTED;

/*****************************************************************************
 external procedures
 *****************************************************************************/

STATUS_T                    Init( char *, char * );
STATUS_T                    Generate( FILE * );
STATUS_T                    OpenFileForReadProcessing( FILE **, char * );
void                        Dump( void );
BOOL                        SearchForStateInTokenVsState( short, short );
void                        TranslateExpectedConstructs( void );
char                    *   Translate( char * );


void
main(
    int argc,
    char *argv[] )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:
    
    the main routine.

 Arguments:

    Standard

 Return Value:
    
    Exit Status

 Notes:

    Usage : ebase <OutputFilename> <Xlatefile> <prefix> 

    Xlatefile is the file where production names to message translation
    is specified.

    prefix is idl or acf. The expected string array is created with a
    standard name prefixed with the user specified prefix.
----------------------------------------------------------------------------*/
{

    STATUS_T    Status;

    fprintf( stderr, "Error Recovery Data Base Generator\n" );


    if( argc == 4 )
        {

        pPrefix = argv[ 3 ];

        if( (Status = Init( argv[ 1 ], argv[ 2 ] )) == STATUS_OK )
            {
            Status  =   Generate( hStateVsTokenIndexFile );
            }

        Dump();

        TranslateExpectedConstructs();

        }
    else
        {

        fprintf( stderr, "Wrong argument count\n" );
        fprintf( stderr, "Usage : midleb <output file or - > <translation-file-name> <prefix>\n");
        Status = WRONG_ARGUMENT_COUNT;

        }

    exit( Status );

}


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    Initialize

 Arguments:

    OutputName   : output file name
    XlatFilename : the production/token name to error message translation.

 Return Value:

    STATUS_T    -   OUT_OF_MEMORY or
                -   CANT_OPEN_INPUT_FILE or
                -   STATUS_OK

 Notes:

    Sets up the file handles for all the files that need to be read from

----------------------------------------------------------------------------*/
STATUS_T
Init(
    char * OutputFileName,
    char * XlatFileName )
{
    STATUS_T    Status;
    int         i;

    Status  = OpenFileForReadProcessing(
                                &hStateVsTokenIndexFile,
                                STATE_VS_TOKEN_INDEX_FILE );

    if( Status == STATUS_OK )
        {
        Status  = OpenFileForReadProcessing(
                                    &hStateVsExpectedFile,
                                    STATE_VS_EXPECTED_FILE );

        if( Status == STATUS_OK )
            {
            Status = OpenFileForReadProcessing(
                                    &hTokXlatHdl,
                                    TOKEN_TRANSLATION_FILE );
            if( Status == STATUS_OK )
                {
                Status = OpenFileForReadProcessing( &hXlatFile, XlatFileName );
    
                if( Status == STATUS_OK )
                    {
                    if( strcmp( OutputFileName, "-" ) == 0 )
                        hOutput = stdout;
                    else if( (hOutput = fopen( OutputFileName , "w" )) == (FILE *)0 )
                        {
                        Status = CANT_OPEN_OUTPUT_FILE;
                        };
                    }
                }
            }
        }

    if( Status != STATUS_OK )
        return Status;

    /** read in the required numbers from the TOKEN_TRANSLATION_FILE **/

    CHECK_FSCAN_STATUS( 
        fscanf( hTokXlatHdl, "%hd %hd\n", &NTOKENS, &ACCEPTCODE ) );

    /** read in the token translation table **/

    TokVal = (short *)calloc( 1, NTOKENS * sizeof( short ) );
    TokCount = (short *)calloc( 1, NTOKENS * sizeof( short ) );
        
        if (!TokVal || !TokCount )
            {
            fprintf( stderr, "Out of memory.\n");
            exit(OUT_OF_MEMORY);           
            } 

    for( i = 0;
         i < NTOKENS;
         i++ )
        {
        CHECK_FSCAN_STATUS( 
            fscanf( hTokXlatHdl, "%hd", &TokVal[ i ]) );
        }

    CHECK_FSCAN_STATUS( 
        fscanf( hTokXlatHdl, "\n" ) );

    for( i = 0;
         i < NTOKENS;
         i++ )
        {
        CHECK_FSCAN_STATUS( 
            fscanf( hTokXlatHdl, "%hd", &TokCount[ i ]) );
        }

    CHECK_FSCAN_STATUS( 
        fscanf( hTokXlatHdl, "\n" ) );

    CHECK_FSCAN_STATUS( 
        fscanf( hTokXlatHdl, 
                "%hd %hd %hd %hd %hd\n", 
                &NSTATES, 
                &MAXTOKVSSTATE, 
                &MAXSTATEVSTOK, 
                &MAXTOKENVALUE, 
                &MAXSTATEVSEXPECTED ) ); 

    /** allocate memory now **/

    pSGoto  = (SGOTO **) calloc( 1,NSTATES * sizeof( SGOTO * ) );

    pSGotoCount = (short *)calloc(1, NSTATES * sizeof( short ) );

    pTokVsState = (short **)calloc( 1,(MAXTOKENVALUE+1) * sizeof( short * ) );

    pTokVsStateIndex = (short *)calloc(1, (MAXTOKENVALUE+1) * sizeof( short ) );

    pDataBase = ( DBENTRY * )calloc( 1, MAXSTATEVSEXPECTED * sizeof( DBENTRY ) );


        if( !pSGoto || !pSGotoCount || !pTokVsState || !pTokVsStateIndex || !pDataBase )
            {
            fprintf( stderr, "Out of memory.\n");
            exit(OUT_OF_MEMORY);
            }

    return Status;
}


STATUS_T
Generate(
    FILE    *   hSVsTIndexFile )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:
    
    Generate the state vs token table, given the state vs token index table
    in extable.h3 and token vs token index translation of extable.h1.

 Arguments:

    hStateVsTokenIndexFile  -   handle to the file which has the state vs
                                token index info.

 Return Value:

    None.

 Notes:

    The state vs token index file has the goto info for every valid token,
    For every state, this file contains the goto ( or none ) for every valid
    token ( represented by the token index ). Thus for each state, we lookup 
    to see if the state has a goto for a given token index. If it does, then 
    we translate the token index into a token value, and mark the goto for the
    state for that token in the state vs token table. 

    In the end we will have a very sparse array, which contains all the states
    and the gotos for the state for each token ( or the absence of any goto ).

    We will use this table to generate two tables:

        1. The set of all states which have a goto on a token
        2. The set of all tokens valid for any state.

    The exception to this rule is the accept action which is treated like
    an absence of goto.
----------------------------------------------------------------------------*/
    {
    
    short    iState,i,j,Temp,SGotoCount;
    SGOTO   *p;

    /** fixup pointers to token vs state pointer array **/

    for( i = 0;
         i < NTOKENS;
         i++ )
        {

        if( TokCount[ i ] )
            {
            j = TokVal[ i ];

            if( ISVALIDTOKEN( j ) )
                            {
                pTokVsState[ j ] = calloc( 1, TokCount[ i ] * sizeof( short ) );
                            
                            if (!pTokVsState[ j ])
                                {
                                fprintf( stderr, "Out of memory.\n" );
                                exit( OUT_OF_MEMORY );
                                }
                            }
            }

        }

    for( iState = 0;
         iState < NSTATES;
         ++iState )
        {

        /** ignore the state number */

        CHECK_FSCAN_STATUS( 
            fscanf( hSVsTIndexFile,
                    "%hd %c",
                    &Temp,
                    &Temp ) );

        /** get the count of number of state goto entries **/

        CHECK_FSCAN_STATUS( 
            fscanf( hSVsTIndexFile,
                    "%hd %c",
                    &SGotoCount,
                    &Temp ) );

        /** now read in the goto vs token pairs **/


        if( SGotoCount )
            {

            p = pSGoto[ iState ] = calloc( 1, SGotoCount * sizeof( SGOTO ) );

                        if (!p) 
                            {
                            fprintf( stderr, "Out of memory.\n" );
                            exit( OUT_OF_MEMORY );
                            }

            for( j = 0;
                j < SGotoCount;
                ++j )
                {

                CHECK_FSCAN_STATUS( 
                    fscanf( hSVsTIndexFile,
                            "%hd%c %hd",
                            &p->Goto,
                            &Temp,
                            &p->Token ) );

                Temp = TokVal[ p->Token ];

                if( ISVALIDTOKEN( Temp ) )
                    {
                    if( !SearchForStateInTokenVsState( Temp, p->Goto ) )
                        {
                        i = pTokVsStateIndex[ Temp ];
                        pTokVsStateIndex[ Temp ]++;

                        *(pTokVsState[Temp] +  i )  = p->Goto;
                        }
                    p++;
                    pSGotoCount[ iState ]++;

                    }
                }

            }


        }
    return STATUS_OK;
    }

STATUS_T
OpenFileForReadProcessing(
    FILE    **  pHandle,
    char    *   pName )
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Routine Description:

    This process opens a file for read processing, reports an error if
    the file could not be opened.

 Arguments:

    pHandle     -   pointer to a file handle deposition area.
    pName       -   pointer to a file name, null terminated.

 Return Value:

    STATUS_T    -   STATUS_OK if all is well.
                -   CANT_OPEN_INPUT_FILE otherwise.
 Notes:

----------------------------------------------------------------------------*/
{
    FILE    *hF;

    if( ( hF = fopen( pName, "r" ) ) == (FILE *)NULL )
        {
        fprintf( stderr, "Cannot open input file : %s\n", pName );
        return CANT_OPEN_INPUT_FILE;
        }
    *pHandle = hF;
    return STATUS_OK;
}


void
Dump( void )
    {
    SGOTO   *   p;
    short       iTemp, i,j;

    /** dump the state goto table **/

    for( iTemp = 0, ValidStates = 0;
         iTemp < NSTATES;
         ++iTemp )
        {

        p = pSGoto[ iTemp ];

        if( j = pSGotoCount[ iTemp ] )
            {
            fprintf( hOutput, "\n SGOTO _sG%s%.4hd [ %d ] = {  ", pPrefix, iTemp, j );

            for( i = 0;
                i < j;
                i++ )
                {

                fprintf(  hOutput
                        , " {%hd, %hd} %c"
                        , p[ i ].Goto
                        , TokVal[ p[ i ].Token]
                        , ( (i+1 == j) ? ' ' : ',' ));
    
                }

            fprintf( hOutput, "};" );

            ValidStates++;
            }
        }


    /** now dump the array of pointers to this **/

    fprintf( hOutput, "\n\n#define VALIDSTATES_%s %d\n", pPrefix, ValidStates );

    fprintf( hOutput, "\n\nSGOTOVECTOR  SGoto%s[ VALIDSTATES_%s ] = {\n",pPrefix, pPrefix);

    for( i = 0;
         i < NSTATES;
         ++i )
        {
        if( pSGotoCount[ i ] )
            {
            fprintf( hOutput, "\n{ %d, _sG%s%.4hd, %d }"
                    , i
                    ,pPrefix
                    , i
                    , pSGotoCount[ i ] );
            fprintf( hOutput,"%c", ((i + 1 == NSTATES) ? ' ' : ',' ));
            }

        }

    fprintf( hOutput, "\n};\n\n" );

    /** count the valid token entries. i.e tokens for which states exist **/

fprintf(hOutput, "#if 0\n");

    for( ValidTokens = 0, i = 0;
         i < MAXTOKENVALUE;
         ++i )
         {

         if( pTokVsStateIndex[ i ] )
            ValidTokens++;
         }

    /** dump the token vs state table **/

    for( iTemp = 0;
         iTemp < NTOKENS;
         ++iTemp )
         {


         if( j = pTokVsStateIndex[ TokVal[ iTemp ] ] )
            {

            fprintf( hOutput, "short _tS%s%.4d[ %d ] = {", pPrefix, TokVal[ iTemp ], j );

            for( i = 0;
                 i < j;
                 ++i )
                {

                fprintf( hOutput, " %d %c", *(pTokVsState[ TokVal[ iTemp ] ]+i),
                         (( i + 1 == j ) ? ' ' : ',' ));

                }

            fprintf( hOutput, "};\n" );

            }
         }

    /** dump the vectors to the token vs state table **/

    fprintf(hOutput, "\n#define VALIDTOKENS %d\n", ValidTokens );
    fprintf( hOutput, "\nTOKVSSTATEVECTOR TokVsState%s[ VALIDTOKENS ] = { \n",pPrefix);

    for( i = 0;
         i < MAXTOKENVALUE+1;
         ++i )
        {

        if( j = pTokVsStateIndex[ i ])
            {
            fprintf( hOutput, "\n{ %d, _tS%s%.4d, %d }",i, pPrefix, i, j );
            fprintf(hOutput, "%c", (i + 1 == NTOKENS) ? ' ' : ',' );
            }


        }

    fprintf( hOutput, "\n\n};\n" );
    fprintf( hOutput, "\n" );

fprintf(hOutput, "#endif\n");

    }


BOOL
SearchForStateInTokenVsState(
    short TokenValue,
    short Goto )
    {
    int i,j;

    for( i = 0, j = pTokVsStateIndex[ TokenValue ];
         i < j;
         ++i )
        {
        if( *(pTokVsState[ TokenValue ] + i) == Goto )
            return TRUE;
        }
    return FALSE;
    }

void
TranslateExpectedConstructs( void )
    {
    int i,State,Count,Temp;
    char Buffer[ MAX_TRANSLATION_LINE_SIZE ];
    char Buffer1[ MAX_TRANSLATION_LINE_SIZE ];
    DBENTRY *p;
    XLAT    *pX;

    /**
        firstly, read in the translation data base, which shows the
        expected token name vs the actual error string the compiler wants to
        output.
     **/

    for(;;)
        {
        i = fscanf( hXlatFile,
                    "%[^ \t]%1s%[^\n]\n",
                    Buffer,
                    &Temp,
                    Buffer1 );

        if( i == EOF || i == 0 )
            break;

        if( ( Buffer[0] != '$' ) && ( Buffer[1] != '$' ) )
            {
            pX = calloc( 1 , sizeof( XLAT ) );

                        if (!pX )
                            {
                            fprintf( stderr, "Out of memory!" );
                            exit(OUT_OF_MEMORY );
                            }

            pX->pIncoming = malloc( strlen( Buffer ) + 1 );
                     
                        if (!pX->pIncoming )
                            {
                            fprintf( stderr, "Out of memory!" );
                            exit(OUT_OF_MEMORY );
                            }
                        
            strcpy( pX->pIncoming, Buffer );

            pX->pTranslated = malloc( strlen( Buffer1 ) + 1 );

                        if (!pX->pTranslated)
                           {
                           fprintf( stderr, "Out of memory!" );
                           exit(OUT_OF_MEMORY );
                           }

            strcpy( pX->pTranslated, Buffer1 );

            if( pXlatCur == 0 )
                {
                pXlatCur = pXlat = pX;
                }
            else
                {
                pXlatCur->pNext = pX;
                pXlatCur = pX;
                }
            }
        }
         

    /**
        Then read the STATE_VS_EXPECTED_FILE, and read in the expected
        tokens/productions for each entry, as translated by looking up the
        data base.
     **/

    p = pDataBase;

    while( p < (pDataBase + MAXSTATEVSEXPECTED) )
        {

        CHECK_FSCAN_STATUS( 
            fscanf( hStateVsExpectedFile, "%d %c %d %c",
                    &State,
                    &Temp,
                    &Count,
                    &Temp,
                    Buffer ) );



        if( Count )
            {
            CHECK_FSCAN_STATUS( 
                fscanf( hStateVsExpectedFile, " %[^\n]\n", Buffer ) );
            p->State = (short) State;
            p->pTranslated = Translate( Buffer );
            p++;
            }
        else
            CHECK_FSCAN_STATUS( 
                fscanf( hStateVsExpectedFile, "\n" ) );

        }
    /**
        emit the state vs expected array with the proper prefix
     **/

    fprintf( hOutput, "\n#ifndef _DBENTRY_DEFINED\n" );
    fprintf( hOutput, "\n#define _DBENTRY_DEFINED\n" );
    fprintf( hOutput, "\ntypedef struct _DBENTRY {" );
    fprintf( hOutput, "\n\t short State;");
    fprintf( hOutput, "\n\t char * pTranslated;");
    fprintf( hOutput, "\n} DBENTRY;\n");
    fprintf( hOutput, "\n#endif\n" );

    fprintf( hOutput, "\n#define MAXSTATEVSEXPECTED_SIZE_%s %d\n", pPrefix, MAXSTATEVSEXPECTED );
    fprintf( hOutput, "\n DBENTRY %s_SyntaxErrorDB[ MAXSTATEVSEXPECTED_SIZE_%s ] = {\n", pPrefix, pPrefix);

    for( p = pDataBase;
         p < (pDataBase + MAXSTATEVSEXPECTED);
         p++ )
        {
        fprintf( hOutput, "{ %d , \"%s\"},\n" , p->State, p->pTranslated );
        }

    fprintf( hOutput, "\n};\n" );

    }

char *
Translate(
    char *pIncoming )
    {
    char *p;

    pXlatCur = pXlat;

    while( pXlatCur )
        {
        if( strcmp( pXlatCur->pIncoming, pIncoming ) == 0 )
            return pXlatCur->pTranslated;
        pXlatCur = pXlatCur->pNext;
        }

    p = malloc( strlen( pIncoming ) + 1 );
 
        if (!p )
            {
            fprintf( stderr, "Out of memory.\n" );
            exit( OUT_OF_MEMORY );
            }

    strcpy( p, pIncoming );

    return p;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\pg\gram.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

# define ID 257
# define NUMBER 258
# define TOKEN_CASE 259
# define TOKEN_CHAR 260
# define TOKEN_END 261
# define TOKEN_END_CASE 262
# define TOKEN_MYACT 263
# define TOKEN_START 264
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\pg\flexskel.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* macro definitions for compressed-table C/FTL programs generated by flex */

#include "flexcom.h"

/* reinitializes everything except the current start condition.  The last
 * input character is set to a newline so an initial beginning-of-line
 * rule will match
 */
#define YY_INIT \
	{ \
	yyleng = yy_c_buf_p = yy_e_buf_p = 0; \
	yy_hold_char = yy_ch_buf[yy_c_buf_p] = '\n'; \
	yytext = &yy_ch_buf[yy_c_buf_p]; \
	yy_saw_eof = 0; \
	}

/* returns the length of the matched text */
#define YY_LENG (yy_c_buf_p - yy_b_buf_p + 1)

/* done before the next pattern has been matched action */
#define YY_DO_BEFORE_SCAN \
	yytext[yyleng] = yy_hold_char;

/* done after the current pattern has been matched and before the corresponding action */
#define YY_DO_BEFORE_ACTION \
	yytext = &yy_ch_buf[yy_b_buf_p]; \
	yyleng = YY_LENG; \
	yy_hold_char = yytext[yyleng]; \
	yytext[yyleng] = '\0';

/* find the next rule matched */
#ifdef FLEX_REJECT_ENABLED
#define REJECT \
        { \
	YY_DO_BEFORE_SCAN; /* undo effects of setting up yytext */ \
	yy_c_buf_p = yy_full_match; /* restore possibly backed-over text */ \
        ++yy_lp; \
        goto find_rule; \
        }
#else
#define REJECT YY_FATAL_ERROR( "REJECT used and scanner was not generated using -r" )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\pg\flexcom.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* common macro definitions for C/FTL programs generated by flex */


/* returned upon end-of-file */
#define YY_END_TOK 0

/* action number for an "end-of-file was seen and yywrap indicated that we
 * should continue processing"
 */
#define YY_NEW_FILE -1

/* action number for "the default action should be done" */
#define YY_DO_DEFAULT -2

#ifndef BUFSIZ
#include <stdio.h>
#endif

#define YY_BUF_SIZE (BUFSIZ * 2) /* size of input buffer */

/* number of characters one rule can match.  One less than YY_BUF_SIZE to make
 * sure we never access beyond the end of an array
 */
#define YY_BUF_MAX (YY_BUF_SIZE - 1)

/* we will never use more than the first YY_BUF_LIM + YY_MAX_LINE positions
 * of the input buffer
 */
#ifndef YY_MAX_LINE
#define YY_MAX_LINE BUFSIZ
#endif

#define YY_BUF_LIM (YY_BUF_MAX - YY_MAX_LINE)

/* copy whatever the last rule matched to the standard output */

#define ECHO fputs( yytext, yyout )

/* gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#if 1
#define YY_INPUT(buf,result,max_size) \
	{	\
	result = fread( buf, 1, max_size, yyin );	\
	if( ferror( yyin ) )	\
	    YY_FATAL_ERROR( "fread() in flex scanner failed" );	\
	}
#else // 0
#define YY_INPUT(buf,result,max_size) \
	if ( (result = read( fileno(yyin), buf, max_size )) < 0 ) \
	    YY_FATAL_ERROR( "read() in flex scanner failed" );
#endif // 0

#define YY_NULL 0

/* macro used to output a character */
#define YY_OUTPUT(c) putc( c, yyout );

/* report a fatal error */
#define YY_FATAL_ERROR(msg) \
	{ \
	fputs( msg, stderr ); \
	putc( '\n', stderr ); \
	exit( 1 ); \
	}

/* returns the first character of the matched text */
#define YY_FIRST_CHAR yy_ch_buf[yy_b_buf_p]

/* default yywrap function - always treat EOF as an EOF */
#define yywrap() 1

/* enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way that old Unix-lex does it
 */
#define BEGIN yy_start = 1 +

/* callable from YY_INPUT to set things up so that '%' will match.  Proper
 * usage is "YY_SET_BOL(array,pos)"
 */
#define YY_SET_BOL(array,pos) array[pos - 1] = '\n';

/* default declaration of generated scanner - a define so the user can
 * easily add parameters
 */
#define YY_DECL int yylex()

/* return all but the first 'n' matched characters back to the input stream */
#define yyless(n) \
	{ \
	YY_DO_BEFORE_SCAN; /* undo effects of setting up yytext */ \
	yy_c_buf_p = yy_b_buf_p + n - 1; \
	YY_DO_BEFORE_ACTION; /* set up yytext again */ \
	}

/* code executed at the end of each rule */
#define YY_BREAK break;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\pg\gram.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/*
 * Created by CSD YACC (IBM PC) from "gram.y" */


/****************************************************************************
 ***		local defines
 ***************************************************************************/

#define pascal 
#define FARDATA
#define NEARDATA
#define FARCODE
#define NEARCODE
#define NEARSWAP

#define PASCAL pascal
#define CDECL
#define VOID void
#define CONST const
#define GLOBAL

#define YYSTYPE         lextype_t
#define YYNEAR          NEARCODE
#define YYPASCAL        PASCAL
#define YYPRINT         printf
#define YYSTATIC        static
#define YYLEX           yylex
#define YYPARSER        yyparse

#define MAXARRAY				1000
#define CASE_BUFFER_SIZE		10000

#define CASE_FN_FORMAT			("\nvoid\n%s_case_fn_%.4d()")
#define DISPATCH_ENTRY_FORMAT	("\n\t,%s_case_fn_%.4d")
#define DISPATCH_FIRST_ENTRY	("\n\t %s_case_fn_%.4d")

/****************************************************************************
 ***		include files
 ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>
#include "lex.h"

/****************************************************************************
 ***		externals 
 ***************************************************************************/

extern	int			Incase;
extern	int			ActionSensed;
extern	int			yylex();
extern	int			yyparse();
extern	char	*	name_prefix;

/****************************************************************************
 ***		local procs 
 ***************************************************************************/

void				Init( void );
void				EmitCaseTableArray( void );
void				EmitDefaultCase( void );
void				EmitCaseBody( int );
void				RegisterCase( int );
void				BufferIt( char * pStr, int iLen );
void				ResetBuffer();
void				FlushBuffer();

/****************************************************************************
 ***		local data 
 ***************************************************************************/

unsigned	long	SavedIDCount	= 0;
unsigned	long	IDCount			= 0;
unsigned	char	CaseTable[ MAXARRAY ] = { 0 };
int					CaseNumber		= 0;
int					MaxCaseNumber	= 0;
char		*		pBufStart;
char		*		pBufCur;
char		*		pBufEnd;

# define ID 257
# define NUMBER 258
# define TOKEN_CASE 259
# define TOKEN_CHAR 260
# define TOKEN_END 261
# define TOKEN_END_CASE 262
# define TOKEN_MYACT 263
# define TOKEN_START 264
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
YYSTYPE yylval, yyval;
#ifndef YYFARDATA
#define	YYFARDATA	/*nothing*/
#endif
#if ! defined YYSTATIC
#define	YYSTATIC	/*nothing*/
#endif
#ifndef YYOPTTIME
#define	YYOPTTIME	0
#endif
#ifndef YYR_T
#define	YYR_T	int
#endif
typedef	YYR_T	yyr_t;
#ifndef YYEXIND_T
#define	YYEXIND_T	unsigned int
#endif
typedef	YYEXIND_T	yyexind_t;
#ifndef	YYACT
#define	YYACT	yyact
#endif
#ifndef	YYPACT
#define	YYPACT	yypact
#endif
#ifndef	YYPGO
#define	YYPGO	yypgo
#endif
#ifndef	YYR1
#define	YYR1	yyr1
#endif
#ifndef	YYR2
#define	YYR2	yyr2
#endif
#ifndef	YYCHK
#define	YYCHK	yychk
#endif
#ifndef	YYDEF
#define	YYDEF	yydef
#endif
#ifndef	YYLOCAL
#define	YYLOCAL
#endif
# define YYERRCODE 256



/*****************************************************************************
 *	utility functions
 *****************************************************************************/
YYSTATIC VOID FARCODE PASCAL 
yyerror(char *szError)
	{
		extern int Line;
		extern char LocalBuffer[];

		fprintf(stderr, "%s at Line %d near %s\n", szError, Line, LocalBuffer);
	}
void
Init()
	{
	pBufStart = pBufCur = malloc( CASE_BUFFER_SIZE );
	if( !pBufStart )
		{
		fprintf(stderr,"Out Of Memory\n");
		exit(1);
		}
	pBufEnd = pBufStart + CASE_BUFFER_SIZE;
	}

void
BufferIt( 
	char	*	pStr,
	int			iLen )
	{
	if( pBufCur + iLen > pBufEnd )
		{
		printf("ALERT iLen = %d\n", iLen );
//		assert( (pBufCur + iLen) <= pBufEnd );
		exit(1);
		}
	strncpy( pBufCur , pStr, iLen );
	pBufCur += iLen;
	*pBufCur = '\0';
	}

void
ResetBuffer()
	{
	pBufCur = pBufStart;
	*pBufCur= '\0';
	}

void
FlushBuffer()
	{
	fprintf(stdout, "%s", pBufStart);
	ResetBuffer();
	}

void
EmitCaseBody( 
	int		CaseNumber )
	{
	fprintf( stdout, CASE_FN_FORMAT, name_prefix, CaseNumber );
	FlushBuffer();
	fprintf( stdout, "}\n" );
	}

void
EmitCaseTableArray()
	{
	int		i, iTemp;

	fprintf( stdout, "const pfn\t %s_case_fn_array[] = \n\t{", name_prefix );
	fprintf( stdout,DISPATCH_FIRST_ENTRY,name_prefix, 0 );

	for( i = 1 ; i <= MaxCaseNumber ; ++i )
		{
		iTemp = CaseTable[ i ] ? i : 0;
		fprintf(stdout,DISPATCH_ENTRY_FORMAT,name_prefix, iTemp );
		}

	fprintf( stdout, "\n\t};\n" );
	fprintf( stdout, "\nstatic void\nyy_vc_init()\n{ \n\tpcase_fn_array = (pfn *) %s_case_fn_array;\n\tyym_vc_max = %d;\n}\n" , name_prefix, MaxCaseNumber);
	}

void
EmitDefaultCase()
	{
	fprintf(stdout, "void\n%s_case_fn_%.4d() {\n\t}\n\n", name_prefix, 0 );
	}
void
RegisterCase(
	int		iCase )
	{
	CaseTable[ iCase ] = 1;
	}
YYSTATIC short yyexca[] ={
#if !(YYOPTTIME)
-1, 1,
#endif
	0, -1,
	-2, 0,
	};
# define YYNPROD 16
#if YYOPTTIME
YYSTATIC yyexind_t yyexcaind[] = {
0,
0,
	};
#endif
# define YYLAST 39
YYSTATIC short YYFARDATA YYACT[]={

   8,  13,  28,   6,   7,  16,   5,  25,  23,  21,
  24,   2,  20,   4,   3,  26,  19,   9,  15,  12,
  10,   1,  11,   0,  14,   0,   0,  17,  18,   0,
   0,   0,  22,   0,   0,   0,   0,   0,  27 };
YYSTATIC short YYFARDATA YYPACT[]={

-254,-1000,-264,-254,-1000,-1000,-1000,-1000,-1000,-1000,
-254,-262,-254,-1000,-256,-254,-254,-250,-1000,-250,
-1000,-252,-1000,-248,-253,-1000,-254,-260,-1000 };
YYSTATIC short YYFARDATA YYPGO[]={

   0,  21,  11,  20,  19,  18,  16,  12,  15,  14,
  13 };
YYSTATIC yyr_t YYFARDATA YYR1[]={

   0,   3,   1,   5,   4,   6,   6,   8,   7,   2,
   2,   9,   9,  10,  10,  10 };
YYSTATIC yyr_t YYFARDATA YYR2[]={

   0,   0,   8,   0,   4,   2,   1,   0,   7,   1,
   0,   2,   1,   1,   1,   1 };
YYSTATIC short YYFARDATA YYCHK[]={

-1000,  -1,  -2,  -9, -10, 260, 257, 258, 264, -10,
  -3,  -2,  -4, 263,  -2,  -5, 261,  -2,  -2,  -6,
  -7, 259,  -7, 260, 258, 260,  -8,  -2, 262 };
YYSTATIC short YYFARDATA YYDEF[]={

  10,  -2,   0,   9,  12,  13,  14,  15,   1,  11,
  10,   0,  10,   3,   0,  10,  10,   0,   2,   4,
   6,   0,   5,   0,   0,   7,  10,   0,   8 };
#ifdef YYRECOVER
YYSTATIC short yyrecover[] = {
-1000	};
#endif
/* SCCSWHAT( "@(#)yypars.c	2.4 88/05/09 15:22:59	" ) */
static char *SCCSID = "@(#)yypars.c:1.3";
# define YYFLAG -1000
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)

#ifdef YYDEBUG				/* RRR - 10/9/85 */
#define yyprintf(a, b, c, d, e) printf(a, b, c, d, e)
#else
#define yyprintf(a, b, c, d)
#endif

#ifndef YYPRINT
#define	YYPRINT	printf
#endif

#if ! defined YYSTATIC
#define YYSTATIC
#endif

/*	parser for yacc output	*/

#ifdef YYDEBUG
YYSTATIC int yydebug = 0; /* 1 for debugging */
#endif
YYSTATIC YYSTYPE yyv[YYMAXDEPTH];	/* where the values are stored */
YYSTATIC short	yys[YYMAXDEPTH];	/* the parse stack */
YYSTATIC int yychar = -1;			/* current input token number */
YYSTATIC int yynerrs = 0;			/* number of errors */
YYSTATIC short yyerrflag = 0;		/* error recovery flag */
short yyexpected;

#ifdef YYRECOVER
/*
**  yyscpy : copy f onto t and return a ptr to the null terminator at the
**  end of t.
*/
YYSTATIC	char	*yyscpy(t,f)
	register	char	*t, *f;
	{
	while(*t = *f++)
		t++;
	return(t);	/*  ptr to the null char  */
	}
#endif

#ifndef YYNEAR
#define YYNEAR
#endif
#ifndef YYPASCAL
#define YYPASCAL
#endif
#ifndef YYLOCAL
#define YYLOCAL
#endif
#if ! defined YYPARSER
#define YYPARSER yyparse
#endif
#if ! defined YYLEX
#define YYLEX yylex
#endif
#ifdef VC_ERRORS
static short yysavestate = 0;
#endif

YYLOCAL YYNEAR YYPASCAL YYPARSER()
{
	register	short	yyn;
	short		yystate, *yyps;
	YYSTYPE		*yypv;
	short		yyj, yym;

#ifdef YYDEBUG
	yydebug = 1;
#endif // YYDEBUG

	yystate = 0;
	yychar = -1;
	yynerrs = 0;
	yyerrflag = 0;
	yyps= &yys[-1];
	yypv= &yyv[-1];

 yystack:    /* put a state and value onto the stack */

#ifdef YYDEBUG
	yyprintf( "[yydebug] state %d, char %d = %c\n", yystate, yychar,yychar, 0 );
#else // YYDEBUG
	yyprintf( "[yydebug] state %d, char %d\n", yystate, yychar, 0 );
#endif // YYDEBUG
	if( ++yyps > &yys[YYMAXDEPTH] ) {
#ifdef VC_ERRORS
		yyerror( "yacc stack overflow", -1 );
#else //  VC_ERRORS
		yyerror( "yacc stack overflow");
#endif //  VC_ERRORS
		return(1);
	}
	*yyps = yystate;
	++yypv;

#ifdef UNION
	yyunion(yypv, &yyval);
#else
	*yypv = yyval;
#endif

yynewstate:

#ifdef VC_ERRORS
	yysavestate = yystate;
#endif

	yyn = yypact[yystate];

yyexpected = -yyn;

	if( yyn <= YYFLAG ) {	/*  simple state, no lookahead  */
		goto yydefault;
	}
	if( yychar < 0 ) {	/*  need a lookahead */
		yychar = YYLEX();
	}
	if( ((yyn += (short) yychar) < 0) || (yyn >= YYLAST) ) {
		goto yydefault;
	}
	if( yychk[ yyn = yyact[ yyn ] ] == yychar ) {		/* valid shift */
		yychar = -1;
#ifdef UNION
		yyunion(&yyval, &yylval);
#else
		yyval = yylval;
#endif
		yystate = yyn;
		if( yyerrflag > 0 ) {
			--yyerrflag;
		}
		goto yystack;
	}

 yydefault:
	/* default state action */

	if( (yyn = yydef[yystate]) == -2 ) {
		register	short	*yyxi;

		if( yychar < 0 ) {
			yychar = YYLEX();
		}
/*
**  search exception table, we find a -1 followed by the current state.
**  if we find one, we'll look through terminal,state pairs. if we find
**  a terminal which matches the current one, we have a match.
**  the exception table is when we have a reduce on a terminal.
*/

#if YYOPTTIME
		yyxi = yyexca + yyexcaind[yystate];
		while(( *yyxi != yychar ) && ( *yyxi >= 0 )){
			yyxi += 2;
		}
#else
		for(yyxi = yyexca;
			(*yyxi != (-1)) || (yyxi[1] != yystate);
			yyxi += 2
		) {
			; /* VOID */
			}

		while( *(yyxi += 2) >= 0 ){
			if( *yyxi == yychar ) {
				break;
				}
		}
#endif
		if( (yyn = yyxi[1]) < 0 ) {
			return(0);   /* accept */
			}
		}

	if( yyn == 0 ){ /* error */
		/* error ... attempt to resume parsing */

		switch( yyerrflag ){

		case 0:		/* brand new error */
#ifdef YYRECOVER
			{
			register	int		i,j;

			for(i = 0;
				(yyrecover[i] != -1000) && (yystate > yyrecover[i]);
				i += 3
			) {
				;
			}
			if(yystate == yyrecover[i]) {
#ifdef YYDEBUG
				yyprintf("recovered, from state %d to state %d on token %d\n",
						yystate,yyrecover[i+2],yyrecover[i+1], 0
						);
#else // YYDEBUG
				yyprintf("recovered, from state %d to state %d on token %d\n",
						yystate,yyrecover[i+2],yyrecover[i+1]
						);
#endif // YYDEBUG
				j = yyrecover[i + 1];
				if(j < 0) {
				/*
				**  here we have one of the injection set, so we're not quite
				**  sure that the next valid thing will be a shift. so we'll
				**  count it as an error and continue.
				**  actually we're not absolutely sure that the next token
				**  we were supposed to get is the one when j > 0. for example,
				**  for(+) {;} error recovery with yyerrflag always set, stops
				**  after inserting one ; before the +. at the point of the +,
				**  we're pretty sure the guy wants a 'for' loop. without
				**  setting the flag, when we're almost absolutely sure, we'll
				**  give him one, since the only thing we can shift on this
				**  error is after finding an expression followed by a +
				*/
					yyerrflag++;
					j = -j;
					}
				if(yyerrflag <= 1) {	/*  only on first insertion  */
					yyrecerr(yychar,j);	/*  what was, what should be first */
				}
				yyval = yyeval(j);
				yystate = yyrecover[i + 2];
				goto yystack;
				}
			}
#endif

#ifdef VC_ERRORS
		yyerror("syntax error", yysavestate);
#else
		yyerror("syntax error");
#endif

		// yyerrlab:
			++yynerrs;

		case 1:
		case 2: /* incompletely recovered error ... try again */

			yyerrflag = 3;

			/* find a state where "error" is a legal shift action */

			while ( yyps >= yys ) {
			   yyn = yypact[*yyps] + YYERRCODE;
			   if( yyn>= 0 && yyn < YYLAST && yychk[yyact[yyn]] == YYERRCODE ){
			      yystate = yyact[yyn];  /* simulate a shift of "error" */
			      goto yystack;
			      }
			   yyn = yypact[*yyps];

			   /* the current yyps has no shift onn "error", pop stack */

#ifdef YYDEBUG
yyprintf( "error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1], 0, 0 );
#else // YYDEBUG
yyprintf( "error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1], 0  );
#endif // YYDEBUG
			   --yyps;
			   --yypv;
			   }

			/* there is no state on the stack with an error shift ... abort */

	yyabort:
			return(1);


		case 3:  /* no shift yet; clobber input char */

#ifdef YYDEBUG
			yyprintf( "error recovery discards char %d\n", yychar, 0, 0, 0 );
#else // YYDEBUG
			yyprintf( "error recovery discards char %d\n", yychar, 0, 0 );
#endif // YYDEBUG
			if( yychar == 0 ) goto yyabort; /* don't discard EOF, quit */
			yychar = -1;
			goto yynewstate;   /* try again in the same state */
			}
		}

	/* reduction by production yyn */
// yyreduce:
		{
		register	YYSTYPE	*yypvt;
#ifdef YYDEBUG
		yyprintf("[yydebug] reduce %d\n",yyn, 0, 0, 0);
#else // YYDEBUG
		yyprintf("[yydebug] reduce %d\n",yyn, 0, 0);
#endif // YYDEBUG
		yypvt = yypv;
		yyps -= yyr2[yyn];
		yypv -= yyr2[yyn];
#ifdef UNION
		yyunion(&yyval, &yypv[1]);
#else
		yyval = yypv[1];
#endif
		yym = yyn;
		yyn = (short) yyr1[yyn];	/* consult goto table to find next state */
		yyj = yypgo[yyn] + *yyps + 1;
		if( (yyj >= YYLAST) || (yychk[ yystate = yyact[yyj] ] != -yyn) ) {
			yystate = yyact[yypgo[yyn]];
			}
		switch(yym){
			
case 1:
{
		Init();
		} break;
case 2:
{
		EmitDefaultCase();
		EmitCaseTableArray();
		} break;
case 3:
{
		ActionSensed++;
		ResetBuffer();
		} break;
case 4:
{
		} break;
case 5:
{
		} break;
case 6:
{
		} break;
case 7:
{
		Incase = 1;

		CaseNumber		= yypvt[-1].yynumber;
		if(yypvt[-1].yynumber >= MAXARRAY)
			{
			fprintf(stderr, "Case Limit Reached : Contact Dov/Vibhas\n");
			return 1;
			}

		SavedIDCount	= IDCount;
		} break;
case 8:
{
		if(SavedIDCount != IDCount)
			{
			RegisterCase( CaseNumber );
			EmitCaseBody( CaseNumber );
			}

		ResetBuffer();

		if(CaseNumber > MaxCaseNumber)
			MaxCaseNumber = CaseNumber;
		Incase = 0;
		} break;
case 9:
{
		} break;
case 10:
{
		} break;
case 11:
{
		} break;
case 12:
{
		} break;
case 13:
{
		if(!ActionSensed)
			fprintf(stdout, "%c", yypvt[-0].yycharval);
		else
			BufferIt( &yypvt[-0].yycharval, 1);
		} break;
case 14:
{
		IDCount++;
		if(!ActionSensed)
			fprintf(stdout, "%s", yypvt[-0].yystring);
		else
			BufferIt( yypvt[-0].yystring, strlen(yypvt[-0].yystring) );
		} break;
case 15:
{
		if(!ActionSensed)
			fprintf(stdout, "%d", yypvt[-0].yynumber);
		else
			{
			char	buffer[20];
			sprintf(buffer,"%d", yypvt[-0].yynumber );
			BufferIt( buffer, strlen(buffer) );
			}
		} break;/* End of actions */
			}
		}
		goto yystack;  /* stack new state and value */
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\pg\lex.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

union   s_lextype   {
	char	*	yystring;
	int			yynumber;
	char		yycharval;
};

typedef union s_lextype lextype_t;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\pg\lexyy.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#define YY_DEFAULT_ACTION ECHO;
#define FLEX_USE_ECS
#define FLEX_USE_MECS
/* A lexical scanner generated by flex */

#include "flexskel.h"

#define INITIAL 0
/***
 *** lexer for preprocessing the parser driver generated by yacc, in
 *** order to convert the big switch statement into individual semantic
 *** functions
 ***/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include "lex.h"
#include "gram.h"

#define VC_PRINTF( x ) /** printf(x) **/

void		LexInstall_ID( void );
void		LexInstall_Number( void );
int			IsToken( void );
lextype_t	yylval;
int			Line = 0;
int			Incase = 0;
int			ActionSensed = 0;
char		LocalBuffer[ 100 ];

#define YY_JAM 40
#define YY_JAM_BASE 65
#define YY_TEMPLATE 41
static char l[41] =
    {   0,
       -2,   -2,    6,    5,    4,    1,    6,    4,    1,    0,
        0,    0,    0,    0,    0,    0,    0,    2,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    3,    0
    } ;

static char e[128] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    4,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    5,    1,    1,    1,    1,    6,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    1,    8,    1,
        1,    1,    1,    1,    9,    9,    9,    9,   10,    9,
        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        1,    1,    1,    1,    9,    1,   11,   12,   13,   14,

       15,   16,    9,    9,   17,    9,   18,    9,    9,   19,
       20,    9,    9,   21,   22,   23,    9,    9,    9,    9,
        9,    9,    1,    1,   24,    1,    1
    } ;

static char m[25] =
    {   0,
        1,    1,    1,    1,    1,    1,    2,    1,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    1
    } ;

static short int b[43] =
    {   0,
        0,   24,   65,   65,   58,    0,   60,   56,    0,   50,
       40,   45,   48,   40,   49,   47,    7,   65,   51,    8,
       12,   33,   33,   42,   25,   28,   39,   31,   28,   17,
       22,   18,   18,   12,   15,   31,   17,   18,   65,   65,
       53,   13
    } ;

static short int d[43] =
    {   0,
       41,   41,   40,   40,   40,   42,   40,   40,   42,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   40,-32767,
       40,   40
    } ;

static short int n[90] =
    {   0,
        3,    3,    4,    3,    3,    3,    5,    3,   17,   21,
       17,   21,   19,   21,    9,   21,   36,   22,   36,   37,
       39,   22,   38,    7,    3,    3,    4,    3,    3,    3,
        5,    3,   36,   35,   36,   37,   34,   33,   32,   31,
       30,   29,   28,   27,   26,   25,   24,    7,   17,   18,
       17,   23,   19,    6,    6,   20,   16,   15,   14,   13,
       12,   11,    8,   10,    8,   40,   40,   40,   40,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   40
    } ;

static short int c[90] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,   17,   20,
       17,   20,   17,   21,   42,   21,   35,   20,   35,   35,
       38,   21,   37,    1,    2,    2,    2,    2,    2,    2,
        2,    2,   36,   34,   36,   36,   33,   32,   31,   30,
       29,   28,   27,   26,   25,   24,   23,    2,   16,   16,
       16,   22,   16,   41,   41,   19,   15,   14,   13,   12,
       11,   10,    8,    7,    5,   40,   40,   40,   40,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   40
    } ;


/* these declarations have to come after the section 1 code or lint gets
 * confused about whether the variables are used
 */
FILE *yyin, *yyout;

/* these variables are all declared out here so that section 3 code can
 * manipulate them
 */
static int yy_start, yy_b_buf_p, yy_c_buf_p, yy_e_buf_p;
static int yy_saw_eof, yy_init = 1;

/* yy_ch_buf has to be 1 character longer than YY_BUF_SIZE, since when
 * setting up yytext we can try to put a '\0' just past the end of the
 * matched text
 */
static char yy_ch_buf[YY_BUF_SIZE + 1];
static int yy_st_buf[YY_BUF_SIZE];
static char yy_hold_char;
char *yytext;
static int yyleng;

YY_DECL
    {
    int yy_n_chars, yy_lp, yy_iii, yy_buf_pos, yy_act;
#ifdef FLEX_REJECT_ENABLED
    int yy_full_match;
#endif




    if ( yy_init )
	{
VC_PRINTF( "Init\n");
	YY_INIT;
	yy_start = 1;
	yy_init = 0;
	}

    goto get_next_token;

do_action:

VC_PRINTF( "do_action\n");

#ifdef FLEX_REJECT_ENABLED
    /* remember matched text in case we back up due to trailing context */
    yy_full_match = yy_c_buf_p;
#endif

    for ( ; ; )
	{
	YY_DO_BEFORE_ACTION

VC_PRINTF( "For loop \n");

#ifdef FLEX_DEBUG
	fprintf( stderr, "--accepting rule #%d\n", yy_act );
#endif
	switch ( yy_act )
	    {
case 1:
{
							int	Token;

				VC_PRINTF(" Case 1\n");

							if( Token = IsToken() )
								{
								return Token;
								}
							else
								LexInstall_ID();
							return ID;
							}
	break;
case 2:
{
				VC_PRINTF(" Case 2\n");
							Line++;
							return TOKEN_END_CASE;
							}
	break;
case 3:
{
				VC_PRINTF(" Case 3\n");
							Line++;
							return TOKEN_END_CASE;
							}
	break;
case 4:
{
				VC_PRINTF(" Case 4\n");
							LexInstall_Number();
							return NUMBER;
							}
	break;
case 5:
{
				VC_PRINTF(" Case 5\n");
							Line++;
							yylval.yycharval = '\n';
							return TOKEN_CHAR;
							}
	break;
case 6:
{
				VC_PRINTF(" Case 6\n");
							yylval.yycharval = yytext[0];
							return TOKEN_CHAR;
							}
	break;
case 7:
YY_DEFAULT_ACTION;
	YY_BREAK

case YY_NEW_FILE:
break; /* begin reading from new file */

case YY_END_TOK:
return ( YY_END_TOK );

default:
YY_FATAL_ERROR( "fatal flex scanner internal error" );
	    }

get_next_token:
	{
	register int yy_curst;
	register char yy_sym;

VC_PRINTF( "Get_next_token 1\n");

	YY_DO_BEFORE_SCAN

	/* set up to begin running DFA */

	yy_curst = yy_start;

	if ( yy_ch_buf[yy_c_buf_p] == '\n' )
	    ++yy_curst;

	/* yy_b_buf_p points to the position in yy_ch_buf
	 * of the start of the current run.
	 */

	yy_b_buf_p = yy_c_buf_p + 1;

VC_PRINTF( "Get_next_token 2\n");

	do /* until the machine jams */
	    {
	    if ( yy_c_buf_p == yy_e_buf_p )
		{ /* need more input */
		if ( yy_e_buf_p >= YY_BUF_LIM )
		    { /* not enough room to do another read */
		    /* see if we can make some room for more chars */

VC_PRINTF( "Get_next_token 4\n");
		    yy_n_chars = yy_e_buf_p - yy_b_buf_p;

		    if ( yy_n_chars >= 0 )
			/* shift down buffer to make room */
			for ( yy_iii = 0; yy_iii <= yy_n_chars; ++yy_iii )
			    {
VC_PRINTF( "Get_next_token 5\n");
			    yy_buf_pos = yy_b_buf_p + yy_iii;
			    yy_ch_buf[yy_iii] = yy_ch_buf[yy_buf_pos];
			    yy_st_buf[yy_iii] = yy_st_buf[yy_buf_pos];
			    }

		    yy_b_buf_p = 0;
		    yy_e_buf_p = yy_n_chars;

		    if ( yy_e_buf_p >= YY_BUF_LIM )
			YY_FATAL_ERROR( "flex input buffer overflowed" );

		    yy_c_buf_p = yy_e_buf_p;
		    }

		else if ( yy_saw_eof )
		    {
VC_PRINTF( "Get_next_token 6\n");
saweof:		    if ( yy_b_buf_p > yy_e_buf_p )
			{
			if ( yywrap() )
			    {
			    yy_act = YY_END_TOK;
			    goto do_action;
			    }
			
			else
			    {
			    YY_INIT;
			    yy_act = YY_NEW_FILE;
			    goto do_action;
			    }
			}

		    else /* do a jam to eat up more input */
			{
#ifndef FLEX_INTERACTIVE_SCANNER
			/* we're going to decrement yy_c_buf_p upon doing
			 * the jam.  In this case, that's wrong, since
			 * it points to the last non-jam character.  So
			 * we increment it now to counter the decrement.
			 */
			++yy_c_buf_p;
#endif
VC_PRINTF( "Get_next_token 7\n");
			break;
			}
		    }

VC_PRINTF( "Get_next_token 8\n");
		YY_INPUT( (yy_ch_buf + yy_c_buf_p + 1), yy_n_chars,
			  YY_MAX_LINE );

		if ( yy_n_chars == YY_NULL )
		    {
VC_PRINTF( "Get_next_token 9\n");
		    if ( yy_saw_eof )
	YY_FATAL_ERROR( "flex scanner saw EOF twice - shouldn't happen" );
		    yy_saw_eof = 1;
		    goto saweof;
		    }

		yy_e_buf_p += yy_n_chars;
		}

	    ++yy_c_buf_p;

#ifdef FLEX_USE_ECS
	    yy_sym = e[yy_ch_buf[yy_c_buf_p]];
#else
	    yy_sym = yy_ch_buf[yy_c_buf_p];
#endif

VC_PRINTF( "Get_next_token 10\n");

#ifdef FLEX_FULL_TABLE
	    yy_curst = n[yy_curst][yy_sym];

#else /* get next state from compressed table */

	    while ( c[b[yy_curst] + yy_sym] != yy_curst )
		{
		yy_curst = d[yy_curst];

#ifdef FLEX_USE_MECS
		/* we've arrange it so that templates are never chained
		 * to one another.  This means we can afford make a
		 * very simple test to see if we need to convert to
		 * yy_sym's meta-equivalence class without worrying
		 * about erroneously looking up the meta-equivalence
		 * class twice
		 */

		if ( yy_curst >= YY_TEMPLATE )
		    yy_sym = m[yy_sym];
#endif
		}

	    yy_curst = n[b[yy_curst] + yy_sym];

#endif

VC_PRINTF( "Get_next_token 11\n");
	    yy_st_buf[yy_c_buf_p] = yy_curst;

	    }
#ifdef FLEX_INTERACTIVE_SCANNER
	while ( b[yy_curst] != YY_JAM_BASE );
#else
	while ( yy_curst != YY_JAM );
	--yy_c_buf_p; /* put back character we jammed on */

#endif

	if ( yy_c_buf_p >= yy_b_buf_p )
	    { /* we matched some text */
	    yy_curst = yy_st_buf[yy_c_buf_p];
	    yy_lp = l[yy_curst];

#ifdef FLEX_REJECT_ENABLED
find_rule: /* we branch to this label when doing a REJECT */
#endif

	    for ( ; ; ) /* until we find what rule we matched */
		{
#ifdef FLEX_REJECT_ENABLED
		if ( yy_lp && yy_lp < l[yy_curst + 1] )
		    {
		    yy_act = a[yy_lp];
		    goto do_action; /* "continue 2" */
		    }
#else
		if ( yy_lp )
		    {
		    yy_act = yy_lp;
		    goto do_action; /* "continue 2" */
		    }
#endif

		if ( --yy_c_buf_p < yy_b_buf_p )
		    break;

		yy_curst = yy_st_buf[yy_c_buf_p];
		yy_lp = l[yy_curst];
		}
	    }

	YY_FATAL_ERROR( "no match in flex scanner - possible NULL in input" );
	}
	}

    /*NOTREACHED*/
    }



/****************************************************************************
 *	utility routines
 ****************************************************************************/
/**************************************************************************
 *** install parser value stack
 **************************************************************************/

void
LexInstall_ID()
	{
	strncpy( LocalBuffer, yytext, yyleng );
	LocalBuffer[ yyleng ] = '\0';
	yylval.yystring = LocalBuffer;
	}
void
LexInstall_Number()
	{
	yylval.yynumber = atoi(yytext);
	}
/**************************************************************************
 *** token search
 **************************************************************************/
int
IsToken()
	{
static char *pTokens[] =
	{
	 "case"
	,"___a_r_u_myact"
	,"___a_r_u_start"
	,"___a_r_u_end"
	};
static int	Tokens[] =
	{
	 TOKEN_CASE
	,TOKEN_MYACT
	,TOKEN_START
	,TOKEN_END
	};

	int i = 0;
	int Token;

	while( i < sizeof(pTokens) / sizeof(char *) )
		{
		if(strcmp( pTokens[i] , yytext ) == 0 )
			{
			Token = Tokens[i];
			if(Token == TOKEN_CASE)
				{
				if(!ActionSensed || Incase)
					return 0;
				}
			return Token;
			}
		++i;
		}
	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\dtxtrn.h ===
/*
 * DTXTRN.H  -- Original extern file for UNIX YACC.
 *
 * Modified to call in "decus" or "vax11c" .H files to set up
 * parameters as appropriate.
 *
 * Copyright (c) 1993-1999 Microsoft Corporation
 */

#ifndef __DTXTRN_H__
#define __DTXTRN_H__

#include <stdio.h>
#include "system.h"

#include "fprot.h"

/*  MANIFEST CONSTANT DEFINITIONS */

/* base of nonterminal internal numbers */
#define NTBASE 010000

/* internal codes for error and accept actions */

#define ERRCODE  8190
#define ACCEPTCODE 8191

/* sizes and limits */

#ifdef HUGETAB              /* defined for a 32 bit machine */
#pragma message ("using HUGETAB")
#define ACTSIZE 12000
#define MEMSIZE 12000
#define NSTATES 1000        /* original value 750 */
#define NTERMS 512          /* original value 127 */
#define NPROD 600
#define NNONTERM 300
#define TEMPSIZE 1200
#define CNAMSZ 10000         /* original value 6000 then 8000*/
#define LSETSIZE 600
#define WSETSIZE 350
#endif

#ifdef MEDTAB           /* defined for a 16 bit machine */
#pragma message ("using MEDTAB")
    #if 0
        #define ACTSIZE 4000
        #define MEMSIZE 5200
        #define NSTATES 600
        #define NTERMS 127
        #define NPROD 400
        #define NNONTERM 200
        #define TEMPSIZE 800
        #define CNAMSZ 4000
        #define LSETSIZE 450
        #define WSETSIZE 250
    #else  // 0
        #define ACTSIZE 12000
        #define MEMSIZE 12000
        #define NSTATES 750
        #define NTERMS 512
        #define NPROD 600
        #define NNONTERM 300
        #define TEMPSIZE 1200
        #define CNAMSZ 5000
        #define LSETSIZE 600
        #define WSETSIZE 350
    #endif // 0
#endif

#ifdef SMALLTAB
#pragma message ("using SMALLTAB")
#define ACTSIZE 1000
#define MEMSIZE 1500
#define NSTATES 450
#define NTERMS 127
#define NPROD 200
#define NNONTERM 100
#define TEMPSIZE 600
#define CNAMSZ 1000
#define LSETSIZE 200
#define WSETSIZE 125
#endif

#define NAMESIZE 50
#define NTYPES 63

#ifdef WORD32
#define TBITSET ((32+NTERMS)/32)

/* bit packing macros (may be machine dependent) */
#define BIT(a,i) ((a)[(i)>>5] & (1<<((i)&037)))
#define SETBIT(a,i) ((a)[(i)>>5] |= (1<<((i)&037)))

/* number of words needed to hold n+1 bits */
#define NWORDS(n) (((n)+32)/32)

#else

#define TBITSET ((16+NTERMS)/16)

/* bit packing macros (may be machine dependent) */
#define BIT(a,i) ((a)[(i)>>4] & (1<<((i)&017)))
#define SETBIT(a,i) ((a)[(i)>>4] |= (1<<((i)&017)))

/* number of words needed to hold n+1 bits */
#define NWORDS(n) (((n)+16)/16)
#endif

/* relationships which must hold:
        TBITSET ints must hold NTERMS+1 bits...
        WSETSIZE >= NNONTERM
        LSETSIZE >= NNONTERM
        TEMPSIZE >= NTERMS + NNONTERMs + 1
        TEMPSIZE >= NSTATES
        */

/* associativities */

#define NOASC 0  /* no assoc. */
#define LASC 1  /* left assoc. */
#define RASC 2  /* right assoc. */
#define BASC 3  /* binary assoc. */

/* flags for state generation */

#define DONE 0
#define MUSTDO 1
#define MUSTLOOKAHEAD 2

/* flags for a rule having an action, and being reduced */

#define ACTFLAG 04
#define REDFLAG 010

/* output parser flags */
#define YYFLAG1 (-1000)

/* macros for getting associativity and precedence levels */

#define ASSOC(i) ((i)&03)
#define PLEVEL(i) (((i)>>4)&077)
#define TYPE(i)  ((i>>10)&077)

/* macros for setting associativity and precedence levels */

#define SETASC(i,j) i|=j
#define SETPLEV(i,j) i |= (j<<4)
#define SETTYPE(i,j) i |= (j<<10)

/* looping macros */

#define TLOOP(i) for(i=1;i<=ntokens;++i)
#define NTLOOP(i) for(i=0;i<=nnonter;++i)
#define PLOOP(s,i) for(i=s;i<nprod;++i)
#define SLOOP(i) for(i=0;i<nstate;++i)
#define WSBUMP(x) ++x
#define WSLOOP(s,j) for(j=s;j<cwp;++j)
#define ITMLOOP(i,p,q) q=pstate[i+1];for(p=pstate[i];p<q;++p)
#define SETLOOP(i) for(i=0;i<tbitset;++i)

/* I/O descriptors */

#ifndef y2imp
extern FILE * finput;           /* input file */
extern FILE * faction;          /* file for saving actions */
extern FILE *fdefine;           /* file for #defines */
extern FILE * ftable;           /* y.tab.c file */
extern FILE * ftemp;            /* tempfile to pass 2 */
extern FILE * foutput;          /* y.output file */
#endif

/* structure declarations */

struct looksets
   {
   SSIZE_T lset[TBITSET];
   };

struct item
   {
   SSIZE_T *pitem;
   struct looksets *look;
   };

struct toksymb
   {
   char *name;
   SSIZE_T value;
   };

struct ntsymb
   {
   char *name;
   SSIZE_T tvalue;
   };

struct wset
   {
   SSIZE_T *pitem;
   int flag;
   struct looksets ws;
   };

#ifndef y2imp
/* token information */extern int ntokens ;    /* number of tokens */
extern struct toksymb tokset[];
extern int toklev[];    /* vector with the precedence of the terminals */
#endif

/* nonterminal information */

#ifndef y2imp
extern int nnonter ;    /* the number of nonterminals */
extern struct ntsymb nontrst[];
#endif

/* grammar rule information */
#ifndef y2imp
extern int nprod ;      /* number of productions */
extern SSIZE_T *prdptr[];   /* pointers to descriptions of productions */
extern SSIZE_T levprd[] ;   /* contains production levels to break conflicts */
#endif

/* state information */

#ifndef y1imp
extern int nstate ;             /* number of states */
extern struct item *pstate[];   /* pointers to the descriptions of the states */
extern SSIZE_T tystate[];   /* contains type information about the states */
#ifndef y3imp
extern SSIZE_T defact[];    /* the default action of the state */
#endif
extern int tstates[];   /* the states deriving each token */
extern int ntstates[];  /* the states deriving each nonterminal */
extern int mstates[];   /* the continuation of the chains begun in tstates and ntstates */
#endif

/* lookahead set information */

#ifndef y1imp
extern struct looksets lkst[];
extern int nolook;  /* flag to turn off lookahead computations */
#endif

/* working set information */

#ifndef y1imp
extern struct wset wsets[];
extern struct wset *cwp;
#endif

/* storage for productions */
#ifndef y2imp
extern SSIZE_T mem0[];
extern SSIZE_T *mem;
#endif

/* storage for action table */

#ifndef y1imp
extern SSIZE_T amem[];  /* action table storage */
extern SSIZE_T *memp ;              /* next free action table position */
extern SSIZE_T indgo[];             /* index to the stored goto table */

/* temporary vector, indexable by states, terms, or ntokens */

extern SSIZE_T temp1[];
extern int lineno; /* current line number */

/* statistics collection variables */

extern int zzgoent ;
extern int zzgobest ;
extern int zzacent ;
extern int zzexcp ;
extern int zzclose ;
extern int zzrrconf ;
extern int zzsrconf ;
extern char *pszPrefix;
#endif

/* define functions with strange types... */extern char *cstash();
extern struct looksets *flset();
extern char *symnam();
extern char *writem();

/* default settings for a number of macros */

#define ISIZE 400       /* Specific for static in cpres() */

/* name of yacc tempfiles */

#ifndef TEMPNAME
#define TEMPNAME "yacc.tmp"
#endif

#ifndef ACTNAME
#define ACTNAME "yacc.act"
#endif

/* output file name */

#ifndef OFILE
#define OFILE "ytab.c"
#endif

/* user output file name */

#ifndef FILEU
#define FILEU "y.out"
#endif

/* output file for #defines */

#ifndef FILED
#define FILED "ytab.h"
#endif

/* Size of complete filespec */
#ifndef FNAMESIZE
#define FNAMESIZE 32
#endif

/* command to clobber tempfiles after use */

#ifndef ZAPFILE
#define ZAPFILE(x) MIDL_UNLINK(x)
#endif

#endif /* __DTXTRN_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\util.c ===
/***************************** Module Header ****************************\
* Copyright (c) 1990-1999 Microsoft Corporation
*
* Module Name: util.c
*
* Extended functions for opening files on environment paths.
*
* Created: 01-May-90
*
* History:
*   01-May-90 created by SMeans
*
\************************************************************************/

#include <stdio.h>
#include <string.h>

FILE *pfopen(const char *path, char *search, const char *type)
{
    char szTmp[256];
    char *pszEnd;
    char c;
    FILE *fp;

    if (!(pszEnd = search)) {
        return fopen(path, type);
    }

    c = *search;

    while (c) {
        while (*pszEnd && *pszEnd != ';') {
            pszEnd++;
        }

        c = *pszEnd;
        *pszEnd = '\0';
        strcpy(szTmp, search);
        *pszEnd = c;

        if (szTmp[strlen(szTmp) - 1] != '\\') {
            strcat(szTmp, "\\");
        }

        strcat(szTmp, path);

        if (fp = fopen(szTmp, type)) {
            return fp;
        }

        search = ++pszEnd;
    }

    return (FILE *)NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\pg\main.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

extern int yyparse();
extern FILE *yyin, *yyout;
char *	name_prefix;

void
main(
	int		argc,
	char	*argv[] )
	{

	int ExitCode;
	char * cur;

    yyin = stdin;
    yyout = stdout;
	fprintf(stderr, "Grammar (.cxx) munge utility\n");

	if( argc < 2 )
		{
		printf("Usage : pg <filename>\n");
		exit(1);
		}
	else
		{
		if( (yyin = fopen( argv[1], "rt" )) == (FILE *)NULL )
			{
			printf("Error opening file %s\n",  argv[1] );
			exit(1);
			}
		}

	name_prefix = _strdup( argv[1] );

    if ( NULL == name_prefix )
        {
        fprintf( stderr, "Out of memory" );
        exit(1);
        }

	name_prefix = _strlwr( name_prefix );
	for ( cur = name_prefix; islower( *cur ); cur++ );

	*cur = '\0';
	


	ExitCode	= yyparse();

	fprintf(stderr, "Exit Code (%d) \n", ExitCode );

	exit( ExitCode );

	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\fprot.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

#ifndef FPROT_INCLUDED
#define FPROT_INCLUDED
#include <basetsd.h>
extern  void error(char *s, ...);
extern  struct looksets *flset(struct looksets *p);
extern  void main(int argc,char * *argv);
extern  int unix_getc(struct _iobuf *iop);
extern  void yungetc(SSIZE_T, FILE * );
extern  void prlook(struct looksets *p);
extern  void putitem(SSIZE_T *ptr,struct looksets *lptr);
extern  char *symnam(SSIZE_T i);
extern  int state(SSIZE_T c);
extern  int setunion(SSIZE_T *a,SSIZE_T *b);
extern  char *writem(SSIZE_T *pp);
extern  int defin(int t,char *s);
extern  void defout(void );
extern  SSIZE_T fdtype(SSIZE_T t);
extern  SSIZE_T gettok(void );
extern  void go2gen(int c);
extern  void go2out(void );
extern  void hideprod(void );
extern  void wrstate(int i);
extern  void aoutput(void );
extern  void gin(SSIZE_T i);
extern  int gtnm(void );
extern  int nxti(void );
extern  void stin(SSIZE_T i);
extern  void arout(char *s,SSIZE_T *v,SSIZE_T n);
extern  void writeline(FILE *fh);
extern	void aryfil( SSIZE_T *v, SSIZE_T n, SSIZE_T c );
extern	void cpfir( void );
extern	void cpres( void );
extern	void cempty( void );
extern	void callopt( void );
extern	void SSwitchExit( void );
extern	void summary( void );
extern	void cpyunion( void );
extern	void ydfout( void );
extern	void setup( int i, char *argv[] );
extern	int chfind( int, char * );
extern	void cpycode( void );
extern	void cpyact( SSIZE_T );
extern	void finact( void );
extern	void yyparse( void );
extern	void usage( void );
extern	void yg2out( void );
extern	void warray( char *, SSIZE_T *, int );
extern	void osummary( void );
extern	void others( void );
extern	void closure( int );
extern	int apack( SSIZE_T *, int );
extern	void stagen( void );
extern	void SSwitchInit( void );
extern	void EmitStateVsExpectedConstruct( int, SSIZE_T * );
extern	int CountStateVsExpectedConstruct( int, SSIZE_T * );
extern	void EmitStateGotoTable( int );
extern	void wdef( char *, int );
extern void wract( int );
extern void precftn( SSIZE_T, int, int );
extern void output( void );
extern int skipcom( void );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\system.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

/*                             *********************
 *                             *  S Y S T E M . H  *
 *                             *********************
 *
 * This file replaces the original "files." header file. It defines, for
 * the IBM PC/XT version, the target parser function source file, overriding
 * file name string defines, and other system-specific definitions and
 * parameters.
 *
 * Bob Denny    06-Dec-80
 *
 * Edits:
 *              18-Dec-80  ZAPFILE no longer used in Decus Yacc.
 *                         Parser file renamed yypars.c
 *
 *              28-Aug-81  Temp files for RSX have specific version
 *                         numbers of 1 to avoid multi-versions. Rename
 *                         parser info file ".i".
 *
 *              12-Apr-83  Add FNAMESIZE & EX_xxx parameters.
 *
 *Scott Guthery 23-Dec-83  Adapt for the IBM PC/XT & DeSmet C compiler.
 *
 */

/* Define WORD32 if target machine is a 32 bitter */

# ifdef M_I386
# define WORD32
# define HUGETAB YES
# else
# define MEDTAB YES
#endif

/*
 * Name of INCLUDE environment string
 */
#define INCLUDE "INCLUDE"
#define LIBENV "LIB"

/*
 * Target parser source file
 */
# define PARSER "yypars.c"

/*
/*
 * Filespec definitions
 */
# define ACTNAME "yacc2.tmp"
# define TEMPNAME "yacc1.tmp"
# define FNAMESIZE 24

/*
 * Exit status values
 */
#define EX_SUC 0
#define EX_WAR 1
#define EX_ERR 2
#define EX_SEV 4

#define MIDL_UNLINK  _unlink
#define MIDL_STRDUP  _strdup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\y1imp.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* Impure data used by modules originally in Y1.C. External declarations in Y1.H */

#define y1imp yes
#include "dtxtrn.h"

/* lookahead computations */

int tbitset;  /* size of lookahead sets */
struct looksets lkst [ LSETSIZE ];
int nlset = 0; /* next lookahead set index */
int nolook = 0; /* flag to suppress lookahead computations */
struct looksets clset;  /* temporary storage for lookahead computations */

/* working set computations */

struct wset wsets[ WSETSIZE ];
struct wset *cwp;

/* state information */

int nstate = 0;         /* number of states */
struct item *pstate[NSTATES+2]; /* pointers to the descriptions of the states */
SSIZE_T tystate[NSTATES];   /* contains type information about the states */
SSIZE_T indgo[NSTATES];             /* index to the stored goto table */
int tstates[ NTERMS ]; /* states generated by terminal gotos */
int ntstates[ NNONTERM ]; /* states generated by nonterminal gotos */
int mstates[ NSTATES ]; /* chain of overflows of term/nonterm generation lists  */

/* storage for the actions in the parser */

SSIZE_T amem[ACTSIZE];      /* action table storage */
SSIZE_T *memp = amem;       /* next free action table position */

/* other storage areas */

SSIZE_T temp1[TEMPSIZE]; /* temporary storage, indexed by terms + ntokens or states */
int lineno= 1; /* current input line number */
int fatfl = 1;          /* if on, error is fatal */
int nerrors = 0;        /* number of errors */

/* storage for information about the nonterminals */

SSIZE_T **pres[NNONTERM+2];  /* vector of pointers to productions yielding each nonterminal */
struct looksets *pfirst[NNONTERM+2];  /* vector of pointers to first sets for each nonterminal */
SSIZE_T pempty[NNONTERM+1];  /* vector of nonterminals nontrivially deriving e */

/* accumulators for statistics information */

struct wset *zzcwp = wsets;
int zzgoent = 0;
int zzgobest = 0;
int zzacent = 0;
int zzexcp = 0;
int zzclose = 0;
int zzsrconf = 0;
SSIZE_T * zzmemsz = mem0;
int zzrrconf = 0;

/* data pulled from internal static to here */
/* declared external only in user module    */

SSIZE_T *pyield[NPROD];             /* from ycpres */
char sarr[ISIZE];               /* from ywritm */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\y1.h ===
/********************************************************************************/
/* Copyright (c) 1993-1999 Microsoft Corporation                                */ 
/*                              *************                                   */
/*                              *  Y 1 . H  *                                   */
/*                              *************                                   */
/*                                                                              */
/*  This file contains the external declarations needed to hook Yacc modules    */
/* which were originally in Y1.C to their impure data in Y1IMP.1C. Also does    */
/* the include of the original data/external file DTXTRN.H.                     */
/*                                                                              */
/********************************************************************************/

#include "dtxtrn.h"

/* lookahead computations */

extern int tbitset;  /* size of lookahead sets */
extern int nlset; /* next lookahead set index */
extern struct looksets clset;  /* temporary storage for lookahead computations */

/* other storage areas */

extern int fatfl;               /* if on, error is fatal */
extern int nerrors;             /* number of errors */

/* storage for information about the nonterminals */

extern SSIZE_T **pres[ ];           /* vector of pointers to productions yielding each nonterminal */
extern struct looksets *pfirst[ ]; /* vector of pointers to first sets for each nonterminal */
extern SSIZE_T pempty[ ];           /* vector of nonterminals nontrivially deriving e */

/* accumulators for statistics information */

extern struct wset *zzcwp;
extern SSIZE_T * zzmemsz;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\y2.h ===
/********************************************************************************/
/* Copyright (c) 1993-1999 Microsoft Corporation                                */
/*                              *************                                   */
/*                              *  Y 2 . H  *                                   */
/*                              *************                                   */
/*                                                                              */
/*  This file contains the external declarations needed to hook Yacc modules    */
/* which were originally in Y2.C to their impure data in Y2IMP.2C. Also does    */
/* the include of the original data/external file DTXTRN.H.                     */
/*                                                                              */
/********************************************************************************/

# include "dtxtrn.h" 

# define IDENTIFIER 257
# define MARK 258
# define TERM 259
# define LEFT 260
# define RIGHT 261
# define BINARY 262
# define PREC 263
# define LCURLY 264
# define C_IDENTIFIER 265  /* name followed by colon */
# define NUMBER 266
# define START 267
# define TYPEDEF 268
# define TYPENAME 269
# define UNION 270
# define ENDFILE 0

/* communication variables between various I/O routines */

extern char *infile;            /* input file name */
extern SSIZE_T numbval;             /* value of an input number */
extern char tokname[ ];         /* input token name */

/* storage of names */

extern char cnames[ ];          /* place where token and nonterminal names are stored */
extern int cnamsz;              /* size of cnames */
extern char * cnamp;            /* place where next name is to be put in */
extern int ndefout;             /* number of defined symbols output */

/* storage of types */
extern int ntypes;              /* number of types defined */
extern char * typeset[ ];       /* pointers to type tags */

/* symbol tables for tokens and nonterminals */

extern int start;               /* start symbol */

/* assigned token type values */
extern int extval;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\y3imp.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* Impure data from modules split from y3.c */
#define y3imp YES

#include "dtxtrn.h"

int lastred;            /* the number of the last reduction of a state */

SSIZE_T defact[NSTATES];    /* the default actions of states */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\y2imp.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* Impure data needed by routines pulled from Y2.C */

#define y2imp YES
#include "dtxtrn.h"

/* communication variables between various I/O routines */

char *infile;   /* input file name */
SSIZE_T numbval;    /* value of an input number */
char tokname[NAMESIZE]; /* input token name */

/* storage of names */

char cnames[CNAMSZ];    /* place where token and nonterminal names are stored */
int cnamsz = CNAMSZ;    /* size of cnames */
char * cnamp = cnames;  /* place where next name is to be put in */
int ndefout = 3;  /* number of defined symbols output */

/* storage of types */
int ntypes;     /* number of types defined */
char * typeset[NTYPES]; /* pointers to type tags */

/* symbol tables for tokens and nonterminals */

int ntokens = 0;
struct toksymb tokset[NTERMS];
int toklev[NTERMS];
int nnonter = -1;
struct ntsymb nontrst[NNONTERM];
int start;      /* start symbol */

/* assigned token type values */
int extval = 0;

/* input and output file descriptors */

FILE * finput = NULL;          /* yacc input file */
FILE * faction = NULL;         /* file for saving actions */
FILE * fdefine = NULL;         /* file for # defines */
FILE * ftable = NULL;          /* y.tab.c file */
FILE * ftemp = NULL;    /* tempfile to pass 2 */
FILE * foutput = NULL;         /* y.output file */

/* storage for grammar rules */

SSIZE_T mem0[MEMSIZE] ; /* production storage */
SSIZE_T *mem = mem0;
int nprod= 1;   /* number of productions */
SSIZE_T *prdptr[NPROD];     /* pointers to descriptions of productions */
SSIZE_T levprd[NPROD] ;     /* precedence levels for the productions */

/* Statics pulled from modules */

int peekline;           /* from gettok() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\y4imp.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* Impure data from y4.c modules */

# include "dtxtrn.h"

# define a amem
# define pa indgo
# define yypact temp1
# define greed tystate

# define NOMORE -1000

SSIZE_T * ggreed = lkst[0].lset;
SSIZE_T * pgo = wsets[0].ws.lset;
SSIZE_T *yypgo = &nontrst[0].tvalue;

SSIZE_T maxspr = 0;  /* maximum spread of any entry */
SSIZE_T maxoff = 0;  /* maximum offset into a array */
SSIZE_T *pmem = mem0;
SSIZE_T *maxa;
int nxdb = 0;
int adb = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\y4.h ===
/********************************************************************************/
/* Copyright (c) 1993-1999 Microsoft Corporation                                */
/*                              *************                                   */
/*                              *  Y 4 . H  *                                   */
/*                              *************                                   */
/*                                                                              */
/*  This file contains the external declarations needed to hook Yacc modules    */
/* which were originally in Y4.C to their impure data in Y4IMP.4C. Also does    */
/* the include of the original data/external file DTXTRN.H.                     */
/*                                                                              */
/********************************************************************************/

# include "dtxtrn.h"

# define a amem
# define pa indgo
# define yypact temp1
# define greed tystate

# define NOMORE -1000

extern SSIZE_T * ggreed;
extern SSIZE_T * pgo;
extern SSIZE_T *yypgo;

extern SSIZE_T maxspr;              /* maximum spread of any entry */
extern SSIZE_T maxoff;              /* maximum offset into a array */
extern SSIZE_T *pmem;
extern SSIZE_T *maxa;
extern int nxdb;
extern int adb;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\y3.h ===
/********************************************************************************/
/* Copyright (c) 1993-1999 Microsoft Corporation                                */
/*                              *************                                   */
/*                              *  Y 3 . H  *                                   */
/*                              *************                                   */
/*                                                                              */
/*  This file contains the external declarations needed to hook Yacc modules    */
/* which were originally in Y3.C to their impure data in Y3IMP.3C. Also does    */
/* the include of the original data/external file DTXTRN.H.                     */
/*                                                                              */
/********************************************************************************/

# include "dtxtrn.h"

extern SSIZE_T lastred;             /* the number of the last reduction of a state */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yacc.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include <stdlib.h>
#include "y1.h"

/*
 * 12-Apr-83 (RBD) Add symbolic exit status
 * Added s - switch. Please refer to ywstat.c for details on sswitch
 */

extern FILE * finput;
extern FILE * faction;
extern FILE * fdefine;
extern FILE * ftable;
extern FILE * ftemp;
extern FILE * foutput;
extern FILE *tokxlathdl;    /* token xlation file,token index vs value*/
extern FILE *stgotohdl;     /* state goto table file handle */
extern FILE *stexhdl;	    /* state vs expected construct handle */

void
main(argc,argv) int argc;
char *argv[];

   {

   tokxlathdl = stdout;/* token xlation file,token index vs value*/
   stgotohdl = stdout; /* state goto table file handle */
   stexhdl = stdout;	 /* state vs expected construct handle */

   puts("Setup...");
   setup(argc,argv); /* initialize and read productions */
   puts("cpres ...");
   tbitset = NWORDS(ntokens);
   cpres(); /* make table of which productions yield a given nonterminal */
   puts("cempty ...");
   cempty(); /* make a table of which nonterminals can match the empty string */
   puts("cpfir ...");
   cpfir(); /* make a table of firsts of nonterminals */
   puts("stagen ...");
   stagen(); /* generate the states */
   puts("output ...");
   output();  /* write the states and the tables */
   puts("go2out ...");
   go2out();
   puts("hideprod ...");
   hideprod();
   puts("summary ...");
   summary();
   puts("callopt ...");
   callopt();
   puts("others ...");
   others();
   puts("DONE !!!");

   SSwitchExit();

   exit(EX_SUC);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yaoput.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y4.h"

void
aoutput( void )
   {
   /* this version is for C */
   /* write out the optimized parser */

   fprintf( ftable, "# define YYLAST %d\n", maxa-a+1 );

   arout( "yyact", a, (maxa-a)+1 );
   arout( "yypact", pa, nstate );
   arout( "yypgo", pgo, nnonter+1 );

   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yapack.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y3.h"

/*
 * yapack.3c
 *
 * Modified to make debug code conditionally compile.
 * 28-Aug-81
 * Bob Denny
 */
int
apack(SSIZE_T *p, int n )
   {
   /* pack state i from temp1 into amem */
   int off;
   SSIZE_T *pp, *qq, *rr;
   SSIZE_T *q, *r;

   /* we don't need to worry about checking because we
                   we will only look entries known to be there... */

   /* eliminate leading and trailing 0's */

   q = p+n;
   for( pp=p,off=0 ; *pp==0 && pp<=q; ++pp,--off ) /* VOID */ ;
   if( pp > q ) return(0);  /* no actions */
   p = pp;

   /* now, find a place for the elements from p to q, inclusive */

   r = &amem[ACTSIZE-1];
   for( rr=amem; rr<=r; ++rr,++off )
      {
      /* try rr */
      for( qq=rr,pp=p ; pp<=q ; ++pp,++qq)
         {
         if( *pp != 0 )
            {
            if( *pp != *qq && *qq != 0 ) goto nextk;
            }
         }

      /* we have found an acceptable k */

#ifdef debug
      if(foutput!=NULL) fprintf(foutput,"off = %d, k = %d\n",off,rr-amem);
#endif
      for( qq=rr,pp=p; pp<=q; ++pp,++qq )
         {
         if( *pp )
            {
            if( qq > r ) error( "action table overflow" );
            if( qq>memp ) memp = qq;
            *qq = *pp;
            }
         }
#ifdef debug
      if( foutput!=NULL )
         {
         for( pp=amem; pp<= memp; pp+=10 )
            {
            fprintf( foutput, "\t");
            for( qq=pp; qq<=pp+9; ++qq ) fprintf( foutput, "%d ", *qq );
            fprintf( foutput, "\n");
            }
         }
#endif
      return( off );

nextk: 
      ;
      }
   error("no space in action table" );
   return off; /* NOTREACHED */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ychfnd.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y2.h"
#include <string.h>

int
chfind( int t, register char *s )

   {
   int i;

   if (s[0]==' ')t=0;
   TLOOP(i)
      {
      if(!strcmp(s,tokset[i].name))
         {
         return( i );
         }
      }
   NTLOOP(i)
      {
      if(!strcmp(s,nontrst[i].name)) 
         {
         return( i+NTBASE );
         }
      }
   /* cannot find name */
   if( t>1 )
      error( "%s should have been defined earlier", s );
   return( defin( t, s ) );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yaryfl.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"
void
aryfil( v, n, c ) 
SSIZE_T *v,n,c; 
   {
   /* set elements 0 through n-1 to c */
   register SSIZE_T i;
   for( i=0; i<n; ++i ) v[i] = c;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yarout.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y4.h"

void
arout( char *s, SSIZE_T *v, SSIZE_T n )

   {

   SSIZE_T i;

   fprintf( ftable, "short %s%s[]={\n", pszPrefix ? pszPrefix : "", s );
   for( i=0; i<n; )
      {
      if( i%10 == 0 ) fprintf( ftable, "\n" );
      fprintf( ftable, "%4d", v[i] );
      if( ++i == n ) fprintf( ftable, " };\n" );
      else fprintf( ftable, "," );
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yclopt.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* Edits:
 *      06-Dec-80 Broken out of y4.c, impure data in y4imp.c.
 *      18-Dec-80 ZAPFILE not used for decus compiler, fmkdl() used.
 */

#include "y4.h"
void
callopt( void )
   {

   SSIZE_T i, j, k, *p, *q;

   /* read the arrays from tempfile and set parameters */

   
   if( (finput=fopen(TEMPNAME,"r")) == NULL ) error( "optimizer cannot open tempfile" );
   pgo[0] = 0;
   yypact[0] = 0;
   nstate = 0;
   nnonter = 0;
   for(;;)
      {
      switch( gtnm() )
         {

      case '\n':
         yypact[++nstate] = (--pmem) - mem0;

      case ',':
         continue;

      case '$':
         break;

      default:
         error( "bad tempfile" );
         }
      break;
      }

   yypact[nstate] = yypgo[0] = (--pmem) - mem0;

   for(;;)
      {
      switch( gtnm() )
         {

      case '\n':
         yypgo[++nnonter]= pmem-mem0;
      case '\r':
      case ',' :
         continue;

      case -1: /* EOF */
         break;

      default:
         error( "bad tempfile" );
         }
      break;
      }

   yypgo[nnonter--] = (--pmem) - mem0;

   for( i=0; i<nstate; ++i )
      {

      k = 32000;
      j = 0;
      q = mem0 + yypact[i+1];
      for( p = mem0 + yypact[i]; p<q ; p += 2 )
         {
         if( *p > j ) j = *p;
         if( *p < k ) k = *p;
         }
      if( k <= j )
         {
         /* nontrivial situation */
         /* temporarily, kill this for compatibility
                                j -= k;  j is now the range */
         if( k > maxoff ) maxoff = k;
         }
      greed[i] = (yypact[i+1]-yypact[i]) + 2*j;
      if( j > maxspr ) maxspr = j;
      }

   /* initialize ggreed table */

   for( i=1; i<=nnonter; ++i )
      {
      ggreed[i] = 1;
      j = 0;
      /* minimum entry index is always 0 */
      q = mem0 + yypgo[i+1] -1;
      for( p = mem0+yypgo[i]; p<q ; p += 2 ) 
         {
         ggreed[i] += 2;
         if( *p > j ) j = *p;
         }
      ggreed[i] = ggreed[i] + 2*j;
      if( j > maxoff ) maxoff = j;
      }

   /* now, prepare to put the shift actions into the a array */

   for( i=0; i<ACTSIZE; ++i ) a[i] = 0;
   maxa = a;

   for( i=0; i<nstate; ++i ) 
      {
      if( greed[i]==0 && adb>1 ) fprintf( ftable, "State %d: null\n", i );
      pa[i] = YYFLAG1;
      }

   while( (i = nxti()) != NOMORE ) 
      {
      if( i >= 0 ) stin(i);
      else gin(-i);

      }

   if( adb>2 )

      {
      /* print a array */
      for( p=a; p <= maxa; p += 10)
         {
         fprintf( ftable, "%4d  ", p-a );
         for( i=0; i<10; ++i ) fprintf( ftable, "%4d  ", p[i] );
         fprintf( ftable, "\n" );
         }
      }
   /* write out the output appropriate to the language */

   aoutput();

   osummary();

   fclose(finput);
   ZAPFILE(TEMPNAME);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ychcpy.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

char *chcopy( p, q )  char *p, *q; 
   {
   /* copies string q into p, returning next free char ptr */
   while( *p = *q++ ) ++p;
   return( p );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ycemty.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include <stdlib.h>
#include "y1.h"

/*
 * 12-Apr-83 (RBD) Add symbolic exit status
 */
void
cempty( void )
   {
   /* mark nonterminals which derive the empty string */
   /* also, look for nonterminals which don't derive any token strings */

# define EMPTY 1
# define WHOKNOWS 0
# define OK 1

   SSIZE_T i, *p;

   /* first, use the array pempty to detect productions that can never be reduced */
   /* set pempty to WHONOWS */
   aryfil( pempty, nnonter+1, WHOKNOWS );

   /* now, look at productions, marking nonterminals which derive something */

more:
   PLOOP(0,i)
      {
      if( pempty[ *prdptr[i] - NTBASE ] ) continue;
      for( p=prdptr[i]+1; *p>=0; ++p )
         {
         if( *p>=NTBASE && pempty[ *p-NTBASE ] == WHOKNOWS ) break;
         }
      if( *p < 0 )
         {
         /* production can be derived */
         pempty[ *prdptr[i]-NTBASE ] = OK;
         goto more;
         }
      }

   /* now, look at the nonterminals, to see if they are all OK */

   NTLOOP(i)
      {
      /* the added production rises or falls as the start symbol ... */
      if( i == 0 ) continue;
      if( pempty[ i ] != OK )
         {
         fatfl = 0;
         error( "nonterminal %s never derives any token string", nontrst[i].name );
         fatfl = 1;
         }
      }

   if( nerrors )
      {
      summary();
      exit(EX_ERR);
      }

   /* now, compute the pempty array, to see which nonterminals derive the empty string */

   /* set pempty to WHOKNOWS */

   aryfil( pempty, nnonter+1, WHOKNOWS );

   /* loop as long as we keep finding empty nonterminals */

again:
   PLOOP(1,i)
      {
      if( pempty[ *prdptr[i]-NTBASE ]==WHOKNOWS )
         {
         /* not known to be empty */
         for( p=prdptr[i]+1; *p>=NTBASE && pempty[*p-NTBASE]==EMPTY ; ++p ) ;
         if( *p < 0 )
            {
            /* we have a nontrivially empty nonterminal */
            pempty[*prdptr[i]-NTBASE] = EMPTY;
            goto again; /* got one ... try for another */
            }
         }
      }

   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yclsur.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

/*
 * yclsur.1c
 *
 * Modified to make debug code conditionally compile.
 * 28-Aug-81
 * Bob Denny
 */

void 
closure( int i)

   {
   /* generate the closure of state i */

   int work, k;
   SSIZE_T ch, c;
   register struct wset *u, *v;
   SSIZE_T *pi;
   SSIZE_T **s, **t;
   struct item *q;
   register struct item *p;

   ++zzclose;

   /* first, copy kernel of state i to wsets */

   cwp = wsets;
   ITMLOOP(i,p,q)

      {
      cwp->pitem = p->pitem;
      cwp->flag = 1;    /* this item must get closed */
      SETLOOP(k) cwp->ws.lset[k] = p->look->lset[k];
      WSBUMP(cwp);
      }

   /* now, go through the loop, closing each item */

   work = 1;
   while( work )

      {
      work = 0;
      WSLOOP(wsets,u)

         {

         if( u->flag == 0 ) continue;
         c = *(u->pitem);  /* dot is before c */

         if( c < NTBASE )

            {
            u->flag = 0;
            continue;  /* only interesting case is where . is before nonterminal */
            }

         /* compute the lookahead */
         aryfil( clset.lset, tbitset, 0 );

         /* find items involving c */

         WSLOOP(u,v)

            {
            if( v->flag == 1 && *(pi=v->pitem) == c )

               {
               v->flag = 0;
               if( nolook ) continue;
               while( (ch= *++pi)>0 )

                  {
                  if( ch < NTBASE )

                     {
                     /* terminal symbol */
                     SETBIT( clset.lset, ch );
                     break;
                     }
                  /* nonterminal symbol */
                  setunion( clset.lset, pfirst[ch-NTBASE]->lset );
                  if( !pempty[ch-NTBASE] ) break;
                  }
               if( ch<=0 ) setunion( clset.lset, v->ws.lset );
               }
            }

         /*  now loop over productions derived from c */

         c -= NTBASE; /* c is now nonterminal number */

         t = pres[c+1];
         for( s=pres[c]; s<t; ++s )

            {
            /* put these items into the closure */
            WSLOOP(wsets,v)

               {
               /* is the item there */
               if( v->pitem == *s )

                  {
                  /* yes, it is there */
                  if( nolook ) goto nexts;
                  if( setunion( v->ws.lset, clset.lset ) ) v->flag = work = 1;
                  goto nexts;
                  }
               }

            /*  not there; make a new entry */
            if( cwp-wsets+1 >= WSETSIZE ) error( "working set overflow" );
            cwp->pitem = *s;
            cwp->flag = 1;
            if( !nolook )

               {
               work = 1;
               SETLOOP(k) cwp->ws.lset[k] = clset.lset[k];
               }
            WSBUMP(cwp);
nexts: 
            ;
            }

         }
      }

   /* have computed closure; flags are reset; return */

   if( cwp > zzcwp ) zzcwp = cwp;

#ifdef debug
   if( foutput!=NULL )

      {
      fprintf( foutput, "\nState %d, nolook = %d\n", i, nolook );
      WSLOOP(wsets,u)

         {
         if( u->flag ) fprintf( foutput, "flag set!\n");
         u->flag = 0;
         fprintf( foutput, "\t%s", writem(u->pitem));
         prlook( &u->ws );
         fprintf( foutput,  "\n" );
         }
      }
#endif
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ycpfir.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

/*
 * ycpfir.1c
 *
 * Modified to make debug code conditionally compile.
 * 28-Aug-81
 * Bob Denny
 */

void
cpfir( void ) 

   {
   /* compute an array with the first of nonterminals */
   SSIZE_T *p, **s, i, **t, ch, changes;

   zzcwp = &wsets[nnonter];
   NTLOOP(i)

      {
      aryfil( wsets[i].ws.lset, tbitset, 0 );
      t = pres[i+1];
      for( s=pres[i]; s<t; ++s )

         {
         /* initially fill the sets */
         for( p = *s; (ch = *p) > 0 ; ++p ) 

            {
            if( ch < NTBASE ) 

               {
               SETBIT( wsets[i].ws.lset, ch );
               break;
               }
            else if( !pempty[ch-NTBASE] ) break;
            }
         }
      }

   /* now, reflect transitivity */

   changes = 1;
   while( changes )

      {
      changes = 0;
      NTLOOP(i)

         {
         t = pres[i+1];
         for( s=pres[i]; s<t; ++s )

            {
            for( p = *s; ( ch = (*p-NTBASE) ) >= 0; ++p ) 

               {
               changes |= setunion( wsets[i].ws.lset, wsets[ch].ws.lset );
               if( !pempty[ch] ) break;
               }
            }

         }
      }

   NTLOOP(i) pfirst[i] = flset( &wsets[i].ws );
#ifdef debug
   if( (foutput!=NULL) )

      {
      NTLOOP(i) 

         {
         fprintf( foutput,  "\n%s: ", nontrst[i].name );
         prlook( pfirst[i] );
         fprintf( foutput,  " %d\n", pempty[i] );
         }
      }
#endif
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ycpact.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include <stdio.h>
#include <ctype.h>
#include "y2.h"

void
cpyact( SSIZE_T offset)
   {
   /* copy C action to the next ; or closing } */
   int brac, c, match, s;
   SSIZE_T j, tok;

   writeline(faction);

   brac = 0;

loop:
   c = unix_getc(finput);
swt:
   switch( c )
      {

   case ';':
      if( brac == 0 )
         {
         putc( c , faction );
         return;
         }
      goto lcopy;

   case '{':
      brac++;
      goto lcopy;

   case '$':
      s = 1;
      tok = -1;
      c = unix_getc(finput);
      if( c == '<' )
         {
         /* type description */
         yungetc( c, finput );
         if( gettok() != TYPENAME ) error( "bad syntax on $<ident> clause" );
         tok = numbval;
         c = unix_getc(finput);
         }
      if( c == '$' )
         {
         fprintf( faction, "yyval");
         if( ntypes )
            {
            /* put out the proper tag... */
            if( tok < 0 ) tok = fdtype( *prdptr[nprod] );
            fprintf( faction, ".%s", typeset[tok] );
            }
         goto loop;
         }
      if( c == '-' )
         {
         s = -s;
         c = unix_getc(finput);
         }
      if( isdigit(c) )
         {
         j=0;
         while( isdigit(c) )
            {

            j= j*10+c-'0';
            c = unix_getc(finput);
            }

         j = j*s - offset;
         if( j > 0 )
            {
            error( "Illegal use of $%d", j+offset );
            }

         fprintf( faction, "yypvt[-%d]", -j );
         if( ntypes )
            {
            /* put out the proper tag */
            if( j+offset <= 0 && tok < 0 ) error( "must specify type of $%d", j+offset );
            if( tok < 0 ) tok = fdtype( prdptr[nprod][j+offset] );
            fprintf( faction, ".%s", typeset[tok] );
            }
         goto swt;
         }
      putc( '$' , faction );
      if( s<0 ) putc('-', faction );
      goto swt;

   case '}':
      if( --brac ) goto lcopy;
      putc( c, faction );
      return;


   case '/':    /* look for comments */
      putc( c , faction );
      c = unix_getc(finput);
      if( c != '*' ) goto swt;

      /* it really is a comment */

      putc( c , faction );
      c = unix_getc(finput);
      while( c != EOF )
         {
         while( c=='*' )
            {
            putc( c , faction );
            if( (c=unix_getc(finput)) == '/' ) goto lcopy;
            }
         putc( c , faction );
         if( c == '\n' )++lineno;
         c = unix_getc(finput);
         }
      error( "EOF inside comment" );

   case '\'':   /* character constant */
      match = '\'';
      goto string;

   case '"':    /* character string */
      match = '"';

string:

      putc( c , faction );

      while( c=unix_getc(finput) )
         {

         if( c=='\\' )
            {
            putc( c , faction );
            c=unix_getc(finput);
            if( c == '\n' ) ++lineno;
            }
         else if( c==match ) goto lcopy;
         else if( c=='\n' ) error( "newline in string or char. const." );
         putc( c , faction );
         }
      error( "EOF in string or character constant" );

   case -1: /* EOF */
      error("action does not terminate" );

   case '\n':   
      ++lineno;
      goto lcopy;

      }

lcopy:
   putc( c , faction );
   goto loop;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ycpres.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include <stdlib.h>
#include "y1.h"
/*
 * 12-Apr-83 (RBD) Add symbolic exit status
 */
extern SSIZE_T * pyield[NPROD];

void
cpres( void )
   {
   /* compute an array with the beginnings of  productions yielding given nonterminals
        The array pres points to these lists */
   /* the array pyield has the lists: the total size is only NPROD+1 */
   SSIZE_T **pmem;
   register j, i;
   SSIZE_T c;

   pmem = pyield;

   NTLOOP(i)
      {
      c = i+NTBASE;
      pres[i] = pmem;
      fatfl = 0;  /* make undefined  symbols  nonfatal */
      PLOOP(0,j)
         {
         if (*prdptr[j] == c) *pmem++ =  prdptr[j]+1;
         }
      if(pres[i] == pmem)
         {
         error("nonterminal %s not defined!", nontrst[i].name);
         }
      }
   pres[i] = pmem;
   fatfl = 1;
   if( nerrors )
      {
      summary();
      exit(EX_ERR);
      }
   if( pmem != &pyield[nprod] ) error( "internal Yacc error: pyield %d", pmem-&pyield[nprod] );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ycpuni.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y2.h"

void
cpyunion( void )
   {
   /* copy the union declaration to the output, and the define file if present */

   int level, c;

   writeline(ftable);

   fprintf( ftable, "\n#define UNION 1\n");
   fprintf( ftable, "typedef union " );
   if( fdefine ) fprintf( fdefine, "\ntypedef union " );

   level = 0;
   for(;;)
      {
      if( (c=unix_getc(finput)) < 0 ) error( "EOF encountered while processing %%union" );
      putc( c, ftable );
      if( fdefine ) putc( c, fdefine );

      switch( c )
         {

      case '\n':
         ++lineno;
         break;

      case '{':
         ++level;
         break;

      case '}':
         --level;
         if( level == 0 ) 
            {
            /* we are finished copying */
            fprintf( ftable, " YYSTYPE;\n" );
            if( fdefine ) fprintf( fdefine, " YYSTYPE;\nextern YYSTYPE yylval;\n" );
            return;
            }
         }
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ycstsh.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y2.h"
char *
cstash( s ) register char *s; 

   {
   char *temp;

   temp = cnamp;
   do 
      {
      if( cnamp >= &cnames[cnamsz] ) error("too many characters in id's and literals" );
      else *cnamp++ = *s;
      }
     while ( *s++ );
   return( temp );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ydefin.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y2.h"

int
defin( int t, register char *s )

   {
   /*   define s to be a terminal if t=0
        or a nonterminal if t=1         */

   register val;

   if (t) 
      {
      if( ++nnonter >= NNONTERM ) error("too many nonterminals, limit %d",NNONTERM);
      nontrst[nnonter].name = cstash(s);
      return( NTBASE + nnonter );
      }
   /* must be a token */
   if( ++ntokens >= NTERMS ) error("too many terminals, limit %d",NTERMS );
   tokset[ntokens].name = cstash(s);

   /* establish value for token */

   if( s[0]==' ' && s[2]=='\0' ) /* single character literal */
      val = s[1];
   else if ( s[0]==' ' && s[1]=='\\' ) 
      {
      /* escape sequence */
      if( s[3] == '\0' )
         {
         /* single character escape sequence */
         switch ( s[2] )
            {
            /* character which is escaped */
         case 'n': 
            val = '\n'; 
            break;
         case 'r': 
            val = '\r'; 
            break;
         case 'b': 
            val = '\b'; 
            break;
         case 't': 
            val = '\t'; 
            break;
         case 'f': 
            val = '\f'; 
            break;
         case '\'': 
            val = '\''; 
            break;
         case '"': 
            val = '"'; 
            break;
         case '\\': 
            val = '\\'; 
            break;
         default: 
            error( "invalid escape" );
            }
         }

      else if( s[2] <= '7' && s[2]>='0' )
         {
         /* \nnn sequence */
         if( s[3]<'0' || s[3] > '7' || s[4]<'0' ||
             s[4]>'7' || s[5] != '\0' ) error("illegal \\nnn construction" );
         val = 64*s[2] + 8*s[3] + s[4] - 73*'0';
         if( val == 0 ) error( "'\\000' is illegal" );
         }
      }
   else 
      {
      val = extval++;
      }
   tokset[ntokens].value = val;
   toklev[ntokens] = 0;
   return( ntokens );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ycpycd.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y2.h"

void
cpycode( void )
   {
   /* copies code between \{ and \} */

   int c;

   c = unix_getc(finput);
   if( c == '\n' ) 
      {
      c = unix_getc(finput);
      lineno++;
      }

   writeline(ftable);

   while( c>=0 )
      {
      if( c=='\\' )
         if( (c=unix_getc(finput)) == '}' ) return;
         else putc('\\', ftable );
      if( c=='%' )
         if( (c=unix_getc(finput)) == '}' ) return;
         else putc('%', ftable );
      putc( c , ftable );
      if( c == '\n' ) ++lineno;
      c = unix_getc(finput);
      }
   error("eof before %%}" );
   }

void writeline(FILE *fh) {
   char *psz = infile;

   fprintf( fh, "\n#line %d \"", lineno );
   psz = infile;
   while (*psz) {
      putc(*psz, fh);
      if (*psz == '\\') {
        putc('\\', fh);
      }
      psz++;
   }
   fprintf(fh, "\"\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yerror.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include <stdlib.h>
#include "y1.h"
#include <stdarg.h>

/*
 * 12-Apr-83 (RBD) Add symbolic exit status
 */

void
error(char *s, ...)

   {
   va_list arg_ptr;
   va_start(arg_ptr, s);
   /* write out error comment */

   ++nerrors;
   fprintf( stderr, "\n fatal error: ");
   vfprintf( stderr, s, arg_ptr);
   fprintf( stderr, ", line %d\n", lineno );
   va_end(arg_ptr);
   if( !fatfl ) return;
   summary();
   exit(EX_ERR);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yfdtyp.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y2.h"

SSIZE_T fdtype( SSIZE_T t )
   {
   /* determine the type of a symbol */
   SSIZE_T v;
   if( t >= NTBASE ) v = nontrst[t-NTBASE].tvalue;
   else v = TYPE( toklev[t] );
   if( v <= 0 ) error( "must specify type for %s", (t>=NTBASE)?nontrst[t-NTBASE].name:
   tokset[t].name );
   return( v );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ydfout.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y2.h"
#include <ctype.h>

void
defout( void )
   {
   /* write out the defines (at the end of the declaration section) */

   register int i, c;
   register char *cp;

   for( i=ndefout; i<=ntokens; ++i )
      {

      cp = tokset[i].name;
      if( *cp == ' ' ) ++cp;  /* literals */

      for( ; (c= *cp)!='\0'; ++cp )
         {

         if( islower(c) || isupper(c) || isdigit(c) || c=='_' );  /* VOID */
         else goto nodef;
         }

      fprintf( ftable, "# define %s %d\n", tokset[i].name, tokset[i].value );
      if( fdefine != NULL ) fprintf( fdefine, "# define %s %d\n", tokset[i].name, tokset[i].value );

nodef:  
      ;
      }

   ndefout = ntokens+1;

   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yfnact.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y2.h"

void
finact( void )
   {
   /* finish action routine */

   fclose(faction);

   fprintf( ftable, "# define YYERRCODE %d\n", tokset[2].value );

   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yg2gen.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y3.h"

/*
 * yg2gen.3c
 *
 * Modified to make debug code conditionally compile.
 * 28-Aug-81
 * Bob Denny
 */
void
go2gen(int c)

   {
   /* output the gotos for nonterminal c */

   int i, work;
   SSIZE_T cc;
   struct item *p, *q;


   /* first, find nonterminals with gotos on c */

   aryfil( temp1, nnonter+1, 0 );
   temp1[c] = 1;

   work = 1;
   while( work )

      {
      work = 0;
      PLOOP(0,i)

         {
         if( (cc=prdptr[i][1]-NTBASE) >= 0 )

            {
            /* cc is a nonterminal */
            if( temp1[cc] != 0 )

               {
               /* cc has a goto on c */
               cc = *prdptr[i]-NTBASE; /* thus, the left side of production i does too */
               if( temp1[cc] == 0 )

                  {
                  work = 1;
                  temp1[cc] = 1;
                  }
               }
            }
         }
      }

   /* now, we have temp1[c] = 1 if a goto on c in closure of cc */

#ifdef debug
   if( foutput!=NULL )

      {
      fprintf( foutput, "%s: gotos on ", nontrst[c].name );
      NTLOOP(i) if( temp1[i] ) fprintf( foutput, "%s ", nontrst[i].name);
      fprintf( foutput, "\n");

      }
#endif
   /* now, go through and put gotos into tystate */

   aryfil( tystate, nstate, 0 );
   SLOOP(i)

      {
      ITMLOOP(i,p,q)

         {
         if( (cc= *p->pitem) >= NTBASE )

            {
            if( temp1[cc -= NTBASE] )

               {
               /* goto on c is possible */
               tystate[i] = amem[indgo[i]+c];
               break;
               }
            }
         }
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ygin.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y4.h"

void
gin(SSIZE_T i)
   {

   SSIZE_T *p, *r, *s, *q1, *q2;

   /* enter gotos on nonterminal i into array a */

   ggreed[i] = 0;

   q2 = mem0+ yypgo[i+1] - 1;
   q1 = mem0 + yypgo[i];

   /* now, find a place for it */

   for( p=a; p < &a[ACTSIZE]; ++p )
      {
      if( *p ) continue;
      for( r=q1; r<q2; r+=2 )
         {
         s = p + *r +1;
         if( *s ) goto nextgp;
         if( s > maxa )
            {
            if( (maxa=s) > &a[ACTSIZE] ) error( "a array overflow" );
            }
         }
      /* we have found a spot */

      *p = *q2;
      if( p > maxa )
         {
         if( (maxa=p) > &a[ACTSIZE] ) error( "a array overflow" );
         }
      for( r=q1; r<q2; r+=2 )
         {
         s = p + *r + 1;
         *s = r[1];
         }

      pgo[i] = p-a;
      if( adb>1 ) fprintf( ftable, "Nonterminal %d, entry at %d\n" , i, pgo[i] );
      goto nextgi;

nextgp:  
      ;
      }

   error( "cannot place goto %d\n", i );

nextgi:  
   ;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yflset.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

struct looksets *flset( p )   struct looksets *p; 

   {
   /* decide if the lookahead set pointed to by p is known */
   /* return pointer to a perminent location for the set */

   register struct looksets *q;
   int j;
   SSIZE_T *u, *v, *w;

   for( q = &lkst[nlset]; q-- > lkst; )
      {
      u = p->lset;
      v = q->lset;
      w = & v[tbitset];
      while( v<w) if( *u++ != *v++ ) goto more;
      /* we have matched */
      return( q );
more: 
      ;
      }
   /* add a new one */
   q = &lkst[nlset++];
   if( nlset >= LSETSIZE )error("too many lookahead sets" );
   SETLOOP(j)
      {
      q->lset[j] = p->lset[j];
      }
   return( q );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ygtnm.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y4.h"
#include <ctype.h>

gtnm()
   {

   register s, val, c;

   /* read and convert an integer from the standard input */
   /* return the terminating character */
   /* blanks, tabs, and newlines are ignored */

   s = 1;
   val = 0;

   while( (c=unix_getc(finput)) != EOF )
      {
      if( isdigit(c) )
         {
         val = val * 10 + c - '0';
         }
      else if ( c == '-' ) s = -1;
	  else if ( c == '\r') continue;
      else break;
      }
   *pmem++ = s*val;
   if( pmem > &mem0[MEMSIZE] ) error( "out of space" );
   return( c );

   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yg2out.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y3.h"

void
go2out( void )
   {
   /* output the gotos for the nontermninals */
   int i, j, k, count, times;
   SSIZE_T best, cbest;

   fprintf( ftemp, "$\n" );  /* mark begining of gotos */

   for( i=1; i<=nnonter; ++i ) 
      {
      go2gen(i);

      /* find the best one to make default */

      best = -1;
      times = 0;

      for( j=0; j<=nstate; ++j )
         {
         /* is j the most frequent */
         if( tystate[j] == 0 ) continue;
         if( tystate[j] == best ) continue;

         /* is tystate[j] the most frequent */

         count = 0;
         cbest = tystate[j];

         for( k=j; k<=nstate; ++k ) if( tystate[k]==cbest ) ++count;

         if( count > times )
            {
            best = cbest;
            times = count;
            }
         }

      /* best is now the default entry */

      zzgobest += (times-1);
      for( j=0; j<=nstate; ++j )
         {
         if( tystate[j] != 0 && tystate[j]!=best )
            {
            fprintf( ftemp, "%d,%d,", j, tystate[j] );
            zzgoent += 1;
            }
         }

      /* now, the default */

      zzgoent += 1;
      fprintf( ftemp, "%d\n", best );

      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ynxti.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y4.h"

nxti()
   {
   /* finds the next i */
   register i, maxi;
   SSIZE_T max;

   max = 0;

   for( i=1; i<= nnonter; ++i ) if( ggreed[i] >= max )
      {
      max = ggreed[i];
      maxi = -i;
      }

   for( i=0; i<nstate; ++i ) if( greed[i] >= max )
      {
      max = greed[i];
      maxi = i;
      }

   if( nxdb ) fprintf( ftable, "nxti = %d, max = %d\n", maxi, max );
   if( max==0 ) return( NOMORE );
   else return( maxi );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yhdprd.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y3.h"

void
hideprod( void )
   {
   /* in order to free up the mem and amem arrays for the optimizer,
        /* and still be able to output yyr1, etc., after the sizes of
        /* the action array is known, we hide the nonterminals
        /* derived by productions in levprd.
        */

   register i, j;

   j = 0;
   levprd[0] = 0;
   PLOOP(1,i)
      {
      if( !(levprd[i] & REDFLAG) )
         {
         ++j;
         if( foutput != NULL )
            {
            fprintf( foutput, "Rule not reduced:   %s\n", writem( prdptr[i] ) );
            }
         }
      levprd[i] = *prdptr[i] - NTBASE;
      }
   if( j ) fprintf( stdout, "%d rules never reduced\n", j );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ygttok.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y2.h"
#include <ctype.h>
#include <string.h>

extern int peekline; /* number of '\n' seen in lookahead */

SSIZE_T
gettok() 
   {
   register i, base;
   register reserve;
   SSIZE_T match, c;

begin:
   reserve = 0;
   lineno += peekline;
   peekline = 0;
   c = unix_getc(finput);
   while( c==' ' || c=='\n' || c=='\t' || c=='\f' || c=='\r')
      {
      if( c == '\n' ) ++lineno;
      c=unix_getc(finput);
      }
   if( c == '/' )
      {
      /* skip comment */
      lineno += skipcom();
      goto begin;
      }

   switch(c)
      {

   case -1: /* EOF */
      return(ENDFILE);
   case '{':
      yungetc( c, finput );
      return( '=' );  /* action ... */
   case '<':  /* get, and look up, a type name (union member name) */
      i = 0;
      while( (c=unix_getc(finput)) != '>' && c>=0 && c!= '\n' )
         {
         tokname[i] = (char) c;
         if( ++i >= NAMESIZE ) --i;
         }
      if( c != '>' ) error( "unterminated < ... > clause" );
      tokname[i] = '\0';
      for( i=1; i<=ntypes; ++i )
         {
         if( !strcmp( typeset[i], tokname ) )
            {
            numbval = i;
            return( TYPENAME );
            }
         }
      typeset[numbval = ++ntypes] = cstash( tokname );
      return( TYPENAME );

   case '"':    
   case '\'':
      match = c;
      tokname[0] = ' ';
      i = 1;
      for(;;)
         {
         c = unix_getc(finput);

         if( c == '\n' || c == EOF )
            error("illegal or missing ' or \"" );
         if( c == '\\' )
            {
            c = unix_getc(finput);
            tokname[i] = '\\';
            if( ++i >= NAMESIZE ) --i;
            }
         else if( c == match ) break;
         tokname[i] = (char) c;
         if( ++i >= NAMESIZE ) --i;
         }
      break;

   case '%':
   case '\\':

      switch(c=unix_getc(finput)) 
         {

      case '0': 
         return(TERM);
      case '<': 
         return(LEFT);
      case '2': 
         return(BINARY);
      case '>': 
         return(RIGHT);
      case '%':
      case '\\':        
         return(MARK);
      case '=': 
         return(PREC);
      case '{': 
         return(LCURLY);
      default:  
         reserve = 1;
         }

   default:

      if( isdigit((int) c) )
         {
         /* number */
         numbval = c-'0' ;
         base = (c=='0') ? 8 : 10 ;
         for( c=unix_getc(finput); isdigit((int) c) ; c=getc(finput) )
            {
            numbval = numbval*base + c - '0';
            }
         yungetc( c, finput );
         return(NUMBER);
         }
      else if( islower((int) c) || isupper((int) c) || c=='_' || c=='.' || c=='$' )
         {
         i = 0;
         while( islower((int) c) || isupper((int) c) || isdigit((int) c) || c=='_' || c=='.' || c=='$' )
            {
            tokname[i] = (char) c;
            if( reserve && isupper((int) c) ) tokname[i] += 'a'-'A';
            if( ++i >= NAMESIZE ) --i;
            c = unix_getc(finput);

            }
         }
      else return(c);

      yungetc( c, finput );
      }

   tokname[i] = '\0';

   if( reserve )
      {
      /* find a reserved word */
      if( !strcmp(tokname,"term")) return( TERM );
      if( !strcmp(tokname,"token")) return( TERM );
      if( !strcmp(tokname,"left")) return( LEFT );
      if( !strcmp(tokname,"nonassoc")) return( BINARY );
      if( !strcmp(tokname,"binary")) return( BINARY );
      if( !strcmp(tokname,"right")) return( RIGHT );
      if( !strcmp(tokname,"prec")) return( PREC );
      if( !strcmp(tokname,"start")) return( START );
      if( !strcmp(tokname,"type")) return( TYPEDEF );
      if( !strcmp(tokname,"union")) return( UNION );
      error("invalid escape, or illegal reserved word: %s", tokname );
      }

   /* look ahead to distinguish IDENTIFIER from C_IDENTIFIER */

   c = unix_getc(finput);
   while( c==' ' || c=='\t'|| c=='\n' || c=='\f' || c== '/' ) 
      {
      if( c == '\n' ) ++peekline;
      else if( c == '/' )
         {
         /* look for comments */
         peekline += skipcom();
         }
      c = unix_getc(finput);
      }
   if( c == ':' ) return( C_IDENTIFIER );
   yungetc( c, finput );
   return( IDENTIFIER );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yosmry.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y4.h"

/*
 * Write summary.
 */

void
osummary( void )

   {
   SSIZE_T i, *p;
   
   if(foutput == NULL) return;

   i=0;
   for(p=maxa; p>=a; --p)

      {
      if(*p == 0) ++i;
      }
   fprintf(foutput,"Optimizer space used: input %d/%d, output %d/%d\n",
   pmem-mem0+1, MEMSIZE, maxa-a+1, ACTSIZE);
   fprintf(foutput, "%d table entries, %d zero\n", (maxa-a)+1, i);
   fprintf(foutput, "maximum spread: %d, maximum offset: %d\n",maxspr, maxoff);
   fclose(foutput);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yothrs.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* Edits:
 *      06-Dec-80 Original code broken out of y1.c.
 *      18-Dec-80 Add conditional code for Decus for tempfile deletion.
 */

#include "y1.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

FILE *pfopen(const char *path, char *search, const char *type);

void
others( void )
   {
   /* put out other arrays, copy the parsers */
   register c, i, j;
   char *psz;
   extern char *infile;

   finput = NULL;
   if ((psz = strrchr(infile, '\\')) || (psz = strrchr(infile, ':'))) {
      char tmp[FNAMESIZE];
      char c = *++psz;

      *psz = '\0';
      strcpy(tmp, infile);
      *psz = c;
      strcat(tmp, PARSER);
      finput = fopen(tmp, "r");
   }

   if ( !finput && !(finput = fopen(PARSER, "r"))) {
      if (!(finput = pfopen(PARSER, getenv(LIBENV), "r"))) {
         error( "cannot find parser %s", PARSER );
      }
   }

   warray( "yyr1", levprd, nprod );

   aryfil( temp1, nprod, 0 );
   PLOOP(1,i)temp1[i] = prdptr[i+1]-prdptr[i]-2;
   warray( "yyr2", temp1, nprod );

   aryfil( temp1, nstate, -1000 );
   TLOOP(i)
      {
      for( j=tstates[i]; j!=0; j=mstates[j] )
         {
         temp1[j] = tokset[i].value;
         }
      }
   NTLOOP(i)
      {
      for( j=ntstates[i]; j!=0; j=mstates[j] )
         {
         temp1[j] = -i;
         }
      }
   warray( "yychk", temp1, nstate );

   warray( "yydef", defact, nstate );

   /* copy parser text */

   while( (c=unix_getc(finput) ) != EOF )
      {
      if( c == '$' ) {
         switch (c=unix_getc(finput)) {
         case 'A':
            faction = fopen( ACTNAME, "r" );
            if( faction == NULL ) error( "cannot reopen action tempfile" );
            while( (c=unix_getc(faction) ) != EOF ) putc( c, ftable );
            fclose(faction);
            ZAPFILE(ACTNAME);
            c = unix_getc(finput);
            break;

         case 'T':
            if (pszPrefix) {
                fprintf(ftable, "%s", pszPrefix);
            }
            c = unix_getc(finput);
            break;

         default:
            putc( '$', ftable );
            break;
         }
      }

      putc( c, ftable );
   }

   fclose( ftable );
}

static char getbuf[30], *getbufptr = getbuf;

unix_getc(iop)
FILE *iop;
{
	if(getbufptr == getbuf)
		return(getc(iop));
	else
		return(*--getbufptr);
}

void
yungetc(c, iop)
SSIZE_T c;
FILE *iop; /* WARNING: iop ignored ... ungetc's are multiplexed!!! */
{
	*getbufptr++ = (char) c;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\youtpt.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y3.h"

void
output( void )
   {
   /* print the output for the states */

   int i, k;
   SSIZE_T c;
   register struct wset *u, *v;

   fprintf( ftable, "short %syyexca[] ={\n", pszPrefix ? pszPrefix : "" );

   SLOOP(i) 
      {
      /* output the stuff for state i */
      nolook = !(tystate[i]==MUSTLOOKAHEAD);
      closure(i);
      /* output actions */
      nolook = 1;
      aryfil( temp1, ntokens+nnonter+1, 0 );
      WSLOOP(wsets,u)
         {
         c = *( u->pitem );
         if( c>1 && c<NTBASE && temp1[c]==0 ) 
            {
            WSLOOP(u,v)
               {
               if( c == *(v->pitem) ) putitem( v->pitem+1, (struct looksets *)0 );
               }
            temp1[c] = state(c);
            }
         else if( c > NTBASE && temp1[ (c -= NTBASE) + ntokens ] == 0 )
            {
            temp1[ c+ntokens ] = amem[indgo[i]+c];
            }
         }

      if( i == 1 ) temp1[1] = ACCEPTCODE;

      /* now, we have the shifts; look at the reductions */

      lastred = 0;
      WSLOOP(wsets,u)
         {
         c = *( u->pitem );
         if( c<=0 )
            {
            /* reduction */
            lastred = -c;
            TLOOP(k)
               {
               if( BIT(u->ws.lset,k) )
                  {
                  if( temp1[k] == 0 ) temp1[k] = c;
                  else if( temp1[k]<0 )
                     {
                     /* reduce/reduce conflict */
                     if( foutput!=NULL )
                        fprintf( foutput,
                        "\n%d: reduce/reduce conflict (red'ns %d and %d ) on %s",
                        i, -temp1[k], lastred, symnam(k) );
                     if( -temp1[k] > lastred ) temp1[k] = -lastred;

                     ++zzrrconf;
                     }
                  else 
                     {
                     /* potential shift/reduce conflict */
                     precftn( lastred, k, i );
                     }
                  }
               }
            }
         }
      wract(i);
      }

   fprintf( ftable, "\t};\n" );

   wdef( "YYNPROD", nprod );

   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yprlok.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

void
prlook( struct looksets * p )

   {
   SSIZE_T j, *pp;
   pp = p->lset;
   if( pp == 0 ) fprintf( foutput, "\tNULL");
   else 
      {
      fprintf( foutput, " { " );
      TLOOP(j) 
         {
         if( BIT(pp,j) ) fprintf( foutput,  "%s ", symnam(j) );
         }
      fprintf( foutput,  "}" );
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yskpcm.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y2.h"

int
skipcom( void )
   {
   /* skip over comments */
   register c, i;  /* i is the number of lines skipped */
   i=0;                                                         /*01*/
   /* skipcom is called after reading a / */

   c = unix_getc(finput);
   if (c == '/') {
        while ((c = unix_getc(finput)) != '\n')
            ;
        return ++i;
   } else {
      if( c != '*' )
          error( "illegal comment" );
      c = unix_getc(finput);
      while( c != EOF )
         {
         if (c == '*') {
             if ((c = unix_getc(finput)) != '/') {
                 continue;
             } else {
                 return i;
             }
         }
         if (c == '\n') {
            i++;
         }
         c = unix_getc(finput);
         }
      error( "EOF inside comment" );
      return i; /* NOTREACHED */
   }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yprcft.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y3.h"

void
precftn(SSIZE_T r,int t,int s)
   {
   /* decide a shift/reduce conflict by precedence.*/
   /* r is a rule number, t a token number */
   /* the conflict is in state s */
   /* temp1[t] is changed to reflect the action */

   int lt, action;
   SSIZE_T lp;

   lp = levprd[r];
   lt = toklev[t];
   if( PLEVEL(lt) == 0 || PLEVEL(lp) == 0 ) 
      {
      /* conflict */
      if( foutput != NULL ) fprintf( foutput, "\n%d: shift/reduce conflict (shift %d, red'n %d) on %s",
      s, temp1[t], r, symnam(t) );
      ++zzsrconf;
      return;
      }
   if( PLEVEL(lt) == PLEVEL(lp) ) action = ASSOC(lt);
   else if( PLEVEL(lt) > PLEVEL(lp) ) action = RASC;  /* shift */
   else action = LASC;  /* reduce */

   switch( action )
      {

   case BASC:  /* error action */
      temp1[t] = ERRCODE;
      return;

   case LASC:  /* reduce */
      temp1[t] = -r;
      return;

      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ysetup.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include <stdlib.h>
#include "y2.h"
#include <string.h>
#include <ctype.h>
/*
 * YSETUP.C  -- Modified for use with DECUS LEX
 *              Variable "yylval" resides in yylex(), not in yypars();
 *              Therefore, is defined "extern" here.
 *
 *              Also, the command line processing for the Decus version
 *              has been changed.  A new switch has been added to allow
 *              specification of the "table" file name(s), and unused
 *              switch processing removed.
 *
 *                               NOTE
 *              This probably won't run on UNIX any more.
 *
 * Bob Denny 27-Aug-81
 * Bob Denny 22-Mar-82 (01) Added header line, changes for 'new' DECUS library
 * Bob Denny 12-Apr-83 (02) Make filename[] size per #define'd FNAMESIZE so
 *                          VAX filenames won't blow out.  Conditionalize
 *                          time handling for banner.  Make filespec buffer
 *                          static for safety, since global "infile" is
 *                          pointed to it.
 * Scott Guthery 15-May-83  (03) Fixed up option flag handling for RT-11
 *				 23-Dec-83  Adapted for IBM PC/XT & DeSmet C compiler
 */

static char filename[FNAMESIZE];

int i;
SSIZE_T lev, t, j, ty;
int c;
SSIZE_T tempty;
SSIZE_T *p;
int defsw, infsw, ssw = 0;
char actname[8];
char *cp;
char *pszPrefix = NULL;

void
setup(argc,argv)
int argc;
char *argv[];
   {
   char finsave[FNAMESIZE];

   defsw = infsw = 0;
   foutput = NULL;
   fdefine = NULL;

   argc--;
   argv++;
   while( argc && **argv == '-' )
      {
      while( *++(*argv) )
         {
         switch( toupper(**argv) )
            {
         case 'I':
            infsw++;
            continue;
         case 'H':
            defsw++;
            continue;

		 case 'S':
			ssw++;
			infsw++;
			continue;

         case 'T':
            if (!--argc) {
                fprintf(stderr, "-t requires an argument\n");
                usage();
            } else {
                argv++;
                if (pszPrefix) {
                    free(pszPrefix);
                }
		pszPrefix = MIDL_STRDUP(*argv);
                goto next_arg;  // I hate myself
            }
            break;

         default:
            fprintf(stderr, "Illegal option: %c\n", *argv[i]);
            usage();
            }
         }
next_arg:
      argc--;
      argv++;
      }

   if(!argc) {
      fprintf(stderr, "No input file specified\n");
      usage();               /* Catch no filename given */
   }

/*
 * Now open the input file with a default extension of ".Y",
 * then replace the period in argv[1] with a null, so argv[1]
 * can be used to form the table, defs and info filenames.
 */

   if (!(cp = strrchr(argv[i], '\\')) && !(cp = strrchr(argv[i], ':'))) {
       cp = argv[i];
   }

   cp = strrchr(cp, '.');

   if(!cp) {
      strcpy(filename, argv[i]); strcat(filename, ".Y");
   } else {
      strcpy(filename, argv[i]);
      *cp = '\0';
   }

   strcpy(finsave, filename);
   if((finput=fopen( filename, "r" )) == NULL )
      error( "cannot open input file \"%s\"", filename );

/*
 * Now open the .H and .I files if requested.
 */

   if(defsw)
      {
      strcpy(filename, argv[i]); strcat(filename, ".H");
      fdefine = fopen(filename, "w");
      if(fdefine == NULL) error("cannot open defs file\"%s\"", filename);
      }

   if(infsw)
      {
      strcpy(filename, argv[i]); strcat(filename, ".I");
      foutput = fopen(filename, "w");
      if(foutput == NULL) error("cannot open info file\"%s\"", filename);
      }
/*
 * Now the "table" output C file.
 */
   strcpy(filename, argv[i]); strcat(filename, ".C");
   ftable = fopen(filename, "w");
   if( ftable == NULL ) error( "cannot open table file \"%s\"", filename);

/*
 * Finally, the temp files.
 */
   ftemp = fopen( TEMPNAME, "w" );
   if( ftemp==NULL ) error( "cannot open temp file" );
   faction = fopen( ACTNAME, "w" );
   if( faction==NULL ) error( "cannot open action file" );


/*
 * Now put the full filename of the input file into
 * the "filename" buffer for cpyact(), and point the
 * global cell "infile" at it.
 */
   strcpy(filename, finsave);
   infile = filename;
/*
 * Put out a header line at the beginning of the 'table' file.
 */
fprintf(ftable, "/*\n * Created by CSD YACC (IBM PC) from \"%s\" */\n",
        infile);
/*
 * Complete  initialization.
 */
   cnamp = cnames;
   defin(0,"$end");
   extval = 0400;
   defin(0,"error");
   defin(1,"$accept");
   mem=mem0;
   lev = 0;
   ty = 0;
   i=0;

   yyparse();
   }
void
yyparse( void )
   {
   /* sorry -- no yacc parser here.....
                we must bootstrap somehow... */

   for( t=gettok();  t!=MARK && t!= ENDFILE; )
      {
      switch( t )
         {

      case ';':
         t = gettok();
         break;

      case START:
         if( (t=gettok()) != IDENTIFIER )
            {
            error( "bad %%start construction" );
            }
         start = chfind(1,tokname);
         t = gettok();
         continue;

      case TYPEDEF:
         if( (t=gettok()) != TYPENAME ) error( "bad syntax in %%type" );
         ty = numbval;
         for(;;)

            {
            t = gettok();
            switch( t )
               {

            case IDENTIFIER:
               if( (t=chfind( 1, tokname ) ) < NTBASE )
                  {
                  j = TYPE( toklev[t] );
                  if( j!= 0 && j != ty )
                     {
                     error( "type redeclaration of token %s",
                     tokset[t].name );
                     }
                  else SETTYPE( toklev[t],ty);
                  }
               else
                  {
                  j = nontrst[t-NTBASE].tvalue;
                  if( j != 0 && j != ty )
                     {
                     error( "type redeclaration of nonterminal %s",
                     nontrst[t-NTBASE].name );
                     }
                  else nontrst[t-NTBASE].tvalue = ty;
                  }
            case ',':
               continue;

            case ';':
               t = gettok();
               break;
            default:
               break;
               }
            break;
            }
         continue;

      case UNION:
         /* copy the union declaration to the output */
         cpyunion();
         t = gettok();
         continue;

      case LEFT:
      case BINARY:
      case RIGHT:
         ++i;
      case TERM:
         lev = t-TERM;  /* nonzero means new prec. and assoc. */
         ty = 0;

         /* get identifiers so defined */

         t = gettok();
         if( t == TYPENAME )
            {
            /* there is a type defined */
            ty = numbval;
            t = gettok();
            }

         for(;;)
            {
            switch( t )
               {

            case ',':
               t = gettok();
               continue;

            case ';':
               break;

            case IDENTIFIER:
               j = chfind(0,tokname);
               if( lev )
                  {
                  if( ASSOC(toklev[j]) ) error( "redeclaration of precedence of%s", tokname );
                  SETASC(toklev[j],lev);
                  SETPLEV(toklev[j],i);
                  }
               if( ty )
                  {
                  if( TYPE(toklev[j]) ) error( "redeclaration of type of %s", tokname );
                  SETTYPE(toklev[j],ty);
                  }
               if( (t=gettok()) == NUMBER )
                  {
                  tokset[j].value = numbval;
                  if( j < ndefout && j>2 )
                     {
                     error( "please define type number of %s earlier",
                     tokset[j].name );
                     }
                  t=gettok();
                  }
               continue;

               }

            break;
            }

         continue;

      case LCURLY:
         defout();
         cpycode();
         t = gettok();
         continue;

      default:
	     printf("Unrecognized character: %o\n", t);
         error( "syntax error" );

         }

      }

   if( t == ENDFILE )
      {
      error( "unexpected EOF before %%" );
      }

   /* t is MARK */

   defout();

   fprintf( ftable,"#define yyclearin yychar = -1\n" );
   fprintf( ftable,"#define yyerrok yyerrflag = 0\n" );
/*
   fprintf( ftable,"extern int yychar;\nextern short yyerrflag;\n" );
*/
   fprintf( ftable,"#ifndef YYMAXDEPTH\n#define YYMAXDEPTH 150\n#endif\n" );
   if(!ntypes)
      fprintf( ftable,  "#ifndef YYSTYPE\n#define YYSTYPE int\n#endif\n" );
#ifdef unix
   fprintf( ftable,  "YYSTYPE yylval, yyval;\n" );
#else
   fprintf( ftable, "extern YYSTYPE yylval;  /*CSD & DECUS LEX */\n");
   fprintf( ftable, "YYSTYPE yyval;          /*CSD & DECUS LEX */\n");
#endif
   prdptr[0]=mem;
   /* added production */
   *mem++ = NTBASE;
   *mem++ = start;  /* if start is 0, we will overwrite with the lhs of the firstrule */
   *mem++ = 1;
   *mem++ = 0;
   prdptr[1]=mem;
   while( (t=gettok()) == LCURLY ) cpycode();
   if( t != C_IDENTIFIER ) error( "bad syntax on first rule" );
   if( !start ) prdptr[0][1] = chfind(1,tokname);

   /* read rules */

   while( t!=MARK && t!=ENDFILE )
      {

      /* process a rule */

      if( t == '|' )
         {
         *mem++ = *prdptr[nprod-1];
         }
      else if( t == C_IDENTIFIER )
         {
         *mem = chfind(1,tokname);
         if( *mem < NTBASE ) error( "token illegal on LHS of grammar rule" );
         ++mem;
         }
      else error( "illegal rule: missing semicolon or | ?" );

      /* read rule body */
      t = gettok();
more_rule:
      while( t == IDENTIFIER )
         {
         *mem = chfind(1,tokname);
         if( *mem<NTBASE ) levprd[nprod] = toklev[*mem];
         ++mem;
         t = gettok();
         }
      if( t == PREC )

         {
         if( gettok()!=IDENTIFIER) error( "illegal %%prec syntax" );
         j = chfind(2,tokname);
         if( j>=NTBASE)error("nonterminal %s illegal after %%prec", nontrst[j-NTBASE].name);
         levprd[nprod]=toklev[j];
         t = gettok();
         }
      if( t == '=' )
         {
         levprd[nprod] |= ACTFLAG;
         fprintf( faction, "\ncase %d:", nprod );
         cpyact( mem-prdptr[nprod]-1 );
         fprintf( faction, " break;" );
         if( (t=gettok()) == IDENTIFIER )
            {
            /* action within rule... */
            sprintf( actname, "$$%d", nprod );
            j = chfind(1,actname);  /* make it a nonterminal */
            /* the current rule will become rule number nprod+1 */
            /* move the contents down, and make room for the null */
            for( p=mem; p>=prdptr[nprod]; --p ) p[2] = *p;
            mem += 2;
            /* enter null production for action */
            p = prdptr[nprod];
            *p++ = j;
            *p++ = -nprod;

            /* update the production information */
            levprd[nprod+1] = levprd[nprod] & ~ACTFLAG;
            levprd[nprod] = ACTFLAG;

            if( ++nprod >= NPROD ) error( "more than %d rules", NPROD );
            prdptr[nprod] = p;

            /* make the action appear in the original rule */
            *mem++ = j;

            /* get some more of the rule */

            goto more_rule;
            }

         }

      while( t == ';' ) t = gettok();

      *mem++ = -nprod;

      /* check that default action is reasonable */

      if( ntypes && !(levprd[nprod]&ACTFLAG) && nontrst[*prdptr[nprod]-NTBASE].tvalue )
         {
         /* no explicit action, LHS has value */
         /*01*/
         tempty = prdptr[nprod][1];
         if( tempty < 0 ) error( "must return a value, since LHS has a type" );
         else if( tempty >= NTBASE ) tempty = nontrst[tempty-NTBASE].tvalue;
         else tempty = TYPE( toklev[tempty] );
         if( tempty != nontrst[*prdptr[nprod]-NTBASE].tvalue )
            {
            error( "default action causes potential type clash" );
            }

         }
      if( ++nprod >= NPROD ) error( "more than %d rules", NPROD );
      prdptr[nprod] = mem;
      levprd[nprod]=0;
      }
   /* end of all rules */
   fprintf(faction, "/* End of actions */"); /* Properly terminate the last line */
   finact();
   if( t == MARK )
      {
      writeline(ftable);
      while( (c=unix_getc(finput)) != EOF ) putc( c, ftable );
      }
   fclose( finput );
   }

void
usage( void )

   {
   fprintf(stderr,"UNIX YACC (CSD Variant):\n");
   fprintf(stderr,"   yacc -hist tag infile\n\n");
   fprintf(stderr,"Switches:\n");
   fprintf(stderr,"   -h     Create definitions header file\n");
   fprintf(stderr,"   -i     Create parser description file\n");
   fprintf(stderr,"   -t tag Prepends tag to tables\n");
   fprintf(stderr,"   -s     Generates extended tables (MIDL specific) \n\n");
   fprintf(stderr,"Default input file extension is \".Y\"\n");
   fprintf(stderr,"Defs file same name, \".H\" extension.\n");
   fprintf(stderr,"Info file same name, \".I\" extension.\n");
   fprintf(stderr,"Extended Tables in file \"extable.[h1/h2/h3]\".\n");
   fprintf(stderr,"Specifying -s switch also enables the -i switch\n");
   exit(EX_ERR);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yptitm.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

/*
 * yptitm.1c
 *
 * Modified to make debug code conditionally compile.
 * 28-Aug-81
 * Bob Denny
 */

void
putitem( SSIZE_T * ptr, struct looksets * lptr )
   {
   register struct item *j;

#ifdef debug
   if( foutput!=NULL ) 

      {
      fprintf( foutput, "putitem(%s), state %d\n", writem(ptr), nstate );
      }
#endif
   j = pstate[nstate+1];
   j->pitem = ptr;
   if( !nolook ) j->look = flset( lptr );
   pstate[nstate+1] = ++j;
   if( (SSIZE_T *)j > zzmemsz )

      {
      zzmemsz = (SSIZE_T *)j;
      if( zzmemsz >=  &mem0[MEMSIZE] ) error( "out of state space" );
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ysmnam.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

char *symnam( SSIZE_T i)
   {
   /* return a pointer to the name of symbol i */
   char *cp;

   cp = (i>=NTBASE) ? nontrst[i-NTBASE].name : tokset[i].name ;
   if( *cp == ' ' ) ++cp;
   return( cp );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ystagn.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

/*
 * ystagn.1c
 *
 * Modified to make debug code conditionally compile.
 * 28-Aug-81
 * Bob Denny
 */
void
stagen( void )

   {
   /* generate the states */

   int i;
#ifdef debug
   int j;
#endif
   SSIZE_T c;
   register struct wset *p, *q;

   /* initialize */

   nstate = 0;
   /* THIS IS FUNNY from the standpoint of portability */
   /* it represents the magic moment when the mem0 array, which has
        /* been holding the productions, starts to hold item pointers, of a
        /* different type... */
   /* someday, alloc should be used to allocate all this stuff... for now, we
        /* accept that if pointers don't fit in integers, there is a problem... */

   pstate[0] = pstate[1] = (struct item *)mem;
   aryfil( clset.lset, tbitset, 0 );
   putitem( prdptr[0]+1, &clset );
   tystate[0] = MUSTDO;
   nstate = 1;
   pstate[2] = pstate[1];

   aryfil( amem, ACTSIZE, 0 );

   /* now, the main state generation loop */

more:
   SLOOP(i)

      {
      if( tystate[i] != MUSTDO ) continue;
      tystate[i] = DONE;
      aryfil( temp1, nnonter+1, 0 );
      /* take state i, close it, and do gotos */
      closure(i);
      WSLOOP(wsets,p)

         {
         /* generate goto's */
         if( p->flag ) continue;
         p->flag = 1;
         c = *(p->pitem);
         if( c <= 1 ) 

            {
            if( pstate[i+1]-pstate[i] <= p-wsets ) tystate[i] = MUSTLOOKAHEAD;
            continue;

            }
         /* do a goto on c */
         WSLOOP(p,q)

            {
            if( c == *(q->pitem) )

               {
               /* this item contributes to the goto */
               putitem( q->pitem + 1, &q->ws );
               q->flag = 1;
               }
            }
         if( c < NTBASE ) 

            {
            state(c);  /* register new state */
            }
         else 

            {
            temp1[c-NTBASE] = state(c);
            }
         }
#ifdef debug
      if( foutput!=NULL )

         {
         fprintf( foutput,  "%d: ", i );
         NTLOOP(j) 

            {
            if( temp1[j] ) fprintf( foutput,  "%s %d, ", nontrst[j].name, temp1[j] );
            }
         fprintf( foutput, "\n");
         }
#endif
      indgo[i] = apack( &temp1[1], nnonter-1 ) - 1;
      goto more; /* we have done one goto; do some more */
      }
   /* no more to do... stop */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ystin.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y4.h"

void
stin( SSIZE_T i)
   {
   SSIZE_T *r, *s, n, flag, j, *q1, *q2;

   greed[i] = 0;

   /* enter state i into the a array */

   q2 = mem0+yypact[i+1];
   q1 = mem0+yypact[i];
   /* find an acceptable place */

   for( n= -maxoff; n<ACTSIZE; ++n )
      {

      flag = 0;
      for( r = q1; r < q2; r += 2 )
         {
         if( (s = *r + n + a ) < a ) goto nextn;
         if( *s == 0 ) ++flag;
         else if( *s != r[1] ) goto nextn;
         }

      /* check that the position equals another only if the states are identical */

      for( j=0; j<nstate; ++j )
         {
         if( pa[j] == n ) 
            {
            if( flag ) goto nextn;  /* we have some disagreement */
            if( yypact[j+1] + yypact[i] == yypact[j] + yypact[i+1] )
               {
               /* states are equal */
               pa[i] = n;
               if( adb>1 ) fprintf( ftable, "State %d: entry at %d equals state %d\n",
               i, n, j );
               return;
               }
            goto nextn;  /* we have some disagreement */
            }
         }

      for( r = q1; r < q2; r += 2 )
         {
         if( (s = *r + n + a ) >= &a[ACTSIZE] ) error( "out of space in optimizer a array" );
         if( s > maxa ) maxa = s;
         if( *s != 0 && *s != r[1] ) error( "clobber of a array, pos'n %d, by %d", s-a, r[1] );
         *s = r[1];
         }
      pa[i] = n;
      if( adb>1 ) fprintf( ftable, "State %d: entry at %d\n", i, pa[i] );
      return;

nextn:  
      ;
      }

   error( "Error; failure to place state %d\n", i );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ystuni.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

setunion( a, b ) SSIZE_T *a, *b; 

   {
   /* set a to the union of a and b */
   /* return 1 if b is not a subset of a, 0 otherwise */
   register i, sub;
   SSIZE_T x;

   sub = 0;
   SETLOOP(i)
      {
      *a = (x = *a)|*b++;
      if( *a++ != x ) sub = 1;
      }
   return( sub );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ystate.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

int
state( SSIZE_T c)
   {
   /* sorts last state,and sees if it equals earlier ones. returns state number */
   SSIZE_T size1,size2;
   register i;
   SSIZE_T *s;                                                  /*01*/
   struct looksets *ss;                                         /*01*/
   int s__;                                                     /*01*/
   struct item *p1, *p2, *k, *l, *q1, *q2;
   p1 = pstate[nstate];
   p2 = pstate[nstate+1];
   if(p1==p2) return(0); /* null state */
   /* sort the items */
   for(k=p2-1;k>p1;k--) 
      {
      /* make k the biggest */
      for(l=k-1;l>=p1;--l)if( l->pitem > k->pitem )
         {
         s = k->pitem;
         k->pitem = l->pitem;
         l->pitem = s;
         ss = k->look;
         k->look = l->look;
         l->look = ss;
         }
      }
   size1 = p2 - p1; /* size of state */

   for( i= (c>=NTBASE)?ntstates[c-NTBASE]:tstates[c]; i != 0; i = mstates[i] ) 
      {
      /* get ith state */
      q1 = pstate[i];
      q2 = pstate[i+1];
      size2 = q2 - q1;
      if (size1 != size2) continue;
      k=p1;
      for(l=q1;l<q2;l++) 
         {
         if( l->pitem != k->pitem ) break;
         ++k;
         }
      if (l != q2) continue;
      /* found it */
      pstate[nstate+1] = pstate[nstate]; /* delete last state */
      /* fix up lookaheads */
      if( nolook ) return(i);
      for( l=q1,k=p1; l<q2; ++l,++k )
         {
         SETLOOP(s__) clset.lset[s__] = l->look->lset[s__];
         if( setunion( clset.lset, k->look->lset ) ) 
            {
            tystate[i] = MUSTDO;
            /* register the new set */
            l->look = flset( &clset );
            }
         }
      return (i);
      }
   /* state is new */

   if( nolook ) error( "yacc state/nolook error" );
   pstate[nstate+2] = p2;
   if(nstate+1 >= NSTATES) error("too many states" );
   if( c >= NTBASE )
      {
      mstates[ nstate ] = ntstates[ c-NTBASE ];
      ntstates[ c-NTBASE ] = nstate;
      }
   else 
      {
      mstates[ nstate ] = tstates[ c ];
      tstates[ c ] = nstate;
      }
   tystate[nstate]=MUSTDO;
   return(nstate++);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ywarry.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y3.h"

void
warray( char *s, SSIZE_T *v, int n )
   {

   register i;

   fprintf( ftable, "short %s%s[]={\n", pszPrefix ? pszPrefix : "", s );
   for( i=0; i<n; )
      {
      if( i%10 == 0 ) fprintf( ftable, "\n" );
      fprintf( ftable, "%4d", v[i] );
      if( ++i == n ) fprintf( ftable, " };\n" );
      else fprintf( ftable, "," );
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ywract.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y3.h"

void
wract( int i)
   {
   /* output state i */
   /* temp1 has the actions, lastred the default */
   int p, p0;
   SSIZE_T p1;
   int ntimes, count, j;
   SSIZE_T tred;
   int flag;

   /* find the best choice for lastred */

   lastred = 0;
   ntimes = 0;
   TLOOP(j)
      {
      if( temp1[j] >= 0 ) continue;
      if( temp1[j]+lastred == 0 ) continue;
      /* count the number of appearances of temp1[j] */
      count = 0;
      tred = -temp1[j];
      levprd[tred] |= REDFLAG;
      TLOOP(p)
         {
         if( temp1[p]+tred == 0 ) ++count;
         }
      if( count >ntimes )
         {
         lastred = tred;
         ntimes = count;
         }
      }

   /* for error recovery, arrange that, if there is a shift on the
        /* error recovery token, `error', that the default be the error action */
   if( temp1[1] > 0 ) lastred = 0;

   /* clear out entries in temp1 which equal lastred */
   TLOOP(p) if( temp1[p]+lastred == 0 )temp1[p]=0;

   wrstate(i);
   defact[i] = lastred;

   flag = 0;
   TLOOP(p0)
      {
      if( (p1=temp1[p0])!=0 ) 
         {
         if( p1 < 0 )
            {
            p1 = -p1;
            goto exc;
            }
         else if( p1 == ACCEPTCODE ) 
            {
            p1 = -1;
            goto exc;
            }
         else if( p1 == ERRCODE ) 
            {
            p1 = 0;
            goto exc;

exc:
            if( flag++ == 0 ) fprintf( ftable, "-1, %d,\n", i );
            fprintf( ftable, "\t%d, %d,\n", tokset[p0].value, p1 );
            ++zzexcp;
            }
         else 
            {
            fprintf( ftemp, "%d,%d,", tokset[p0].value, p1 );
            ++zzacent;
            }
         }
      }
   if( flag ) 
      {
      defact[i] = -2;
      fprintf( ftable, "\t-2, %d,\n", lastred );
      }
   fprintf( ftemp, "\n" );
   return;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ysumry.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

void
summary( void )
   {
   /* output the summary on the tty */

   if( foutput!=NULL )
      {
      fprintf( foutput, "\n%d/%d terminals, %d/%d nonterminals\n", ntokens, NTERMS,
      nnonter, NNONTERM );
      fprintf( foutput, "%d/%d grammar rules, %d/%d states\n", nprod, NPROD, nstate, NSTATES );
      fprintf( foutput, "%d shift/reduce, %d reduce/reduce conflicts reported\n", zzsrconf, zzrrconf );
      fprintf( foutput, "%d/%d working sets used\n", zzcwp-wsets,  WSETSIZE );
      fprintf( foutput, "memory: states,etc. %d/%d, parser %d/%d\n", zzmemsz-mem0, MEMSIZE,
      memp-amem, ACTSIZE );
      fprintf( foutput, "%d/%d distinct lookahead sets\n", nlset, LSETSIZE );
      fprintf( foutput, "%d extra closures\n", zzclose - 2*nstate );
      fprintf( foutput, "%d shift entries, %d exceptions\n", zzacent, zzexcp );
      fprintf( foutput, "%d goto entries\n", zzgoent );
      fprintf( foutput, "%d entries saved by goto default\n", zzgobest );
      }
   if( zzsrconf!=0 || zzrrconf!=0 )
      {
      fprintf( stdout,"\nconflicts: ");
      if( zzsrconf )fprintf( stdout, "%d shift/reduce" , zzsrconf );
      if( zzsrconf && zzrrconf )fprintf( stdout, ", " );
      if( zzrrconf )fprintf( stdout, "%d reduce/reduce" , zzrrconf );
      fprintf( stdout, "\n" );
      }

   if (ftemp) {
       fclose( ftemp );
   }

   if( fdefine != NULL ) fclose( fdefine );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ywritm.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

#include "y1.h"

char *chcopy(char *, char *);

extern char sarr[ISIZE];

char *writem(pp) SSIZE_T *pp; 

   {
   /* creates output string for item pointed to by pp */
   SSIZE_T i,*p;
   char *q;

   for( p=pp; *p>0 ; ++p ) ;
   p = prdptr[-*p];
   q = chcopy( sarr, nontrst[*p-NTBASE].name );
   q = chcopy( q, " : " );

   for(;;)
      {
      *q++ = ++p==pp ? '_' : ' ';
      *q = '\0';
      if((i = *p) <= 0) break;
      q = chcopy( q, symnam(i) );
      if( q> &sarr[ISIZE-30] ) error( "item too big" );
      }

   if( (i = *pp) < 0 )
      {
      /* an item calling for a reduction */
      q = chcopy( q, "    (" );
      sprintf( q, "%d)", -i );
      }

   return( sarr );
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yypars.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* SCCSWHAT( "@(#)yypars.c	2.4 88/05/09 15:22:59	" ) */
___a_r_u_start
static char *SCCSID = "@(#)yypars.c:1.3";
# define YYFLAG -1000
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)

#ifdef YYDEBUG				/* RRR - 10/9/85 */
#define yyprintf(a, b, c, d, e) printf(a, b, c, d, e)
#else
#define yyprintf(a, b, c, d)
#endif

#ifndef YYPRINT
#define	YYPRINT	printf
#endif

#if ! defined YYSTATIC
#define YYSTATIC
#endif

/*	parser for yacc output	*/

#ifdef YYDEBUG
YYSTATIC int yydebug = 0; /* 1 for debugging */
#endif
YYSTATIC YYSTYPE yyv[YYMAXDEPTH];	/* where the values are stored */
YYSTATIC short	yys[YYMAXDEPTH];	/* the parse stack */
YYSTATIC int yychar = -1;			/* current input token number */
YYSTATIC int yynerrs = 0;			/* number of errors */
YYSTATIC short yyerrflag = 0;		/* error recovery flag */

#ifdef YYRECOVER
/*
**  yyscpy : copy f onto t and return a ptr to the null terminator at the
**  end of t.
*/
YYSTATIC	char	*yyscpy(t,f)
	register	char	*t, *f;
	{
	while(*t = *f++)
		t++;
	return(t);	/*  ptr to the null char  */
	}
#endif

#ifndef YYNEAR
#define YYNEAR
#endif
#ifndef YYPASCAL
#define YYPASCAL
#endif
#ifndef YYLOCAL
#define YYLOCAL
#endif
#if ! defined YYPARSER
#define YYPARSER yyparse
#endif
#if ! defined YYLEX
#define YYLEX yylex
#endif

static	void	yy_vc_init();
typedef	void	(*pfn)();
static	pfn		*pcase_fn_array;
static	int		returnflag = 0;
static	YYSTYPE	*yypvt;
static	int		yym_vc_max = 0;
extern  short	GrammarAct;

extern short	yysavestate;

YYLOCAL YYNEAR YYPASCAL YYPARSER()
{
	register	short	yyn;
	short		yystate, *yyps, *yysave_yyps;
	YYSTYPE		*yypv,*yysave_yypv;
	YYSTYPE		yysave_yyval;
	short		yyj, yym;
	short		fHaveRecoveredChar	= 0;

	yy_vc_init();
#ifdef YYDEBUG
	yydebug = 1;
#endif /* YYDEBUG */

	yystate = 0;
	yychar = -1;
	yynerrs = 0;
	yyerrflag = 0;
	yyps= &yys[-1];
	yypv= &yyv[-1];

 yystack:    /* put a state and value onto the stack */

#ifdef YYDEBUG
	yyprintf( "[yydebug] state %d, char %d = %c\n", yystate, yychar,yychar, 0 );
#else /* YYDEBUG */
	yyprintf( "[yydebug] state %d, char %d\n", yystate, yychar, 0 );
#endif /* YYDEBUG */
	if( ++yyps > &yys[YYMAXDEPTH] ) {
/*		yyerror( "yacc stack overflow" ); */
		ParseError(C_STACK_OVERFLOW, (char *)NULL);
		return(1);
	}
	*yyps = yystate;
	++yypv;

#ifdef UNION
	yyunion(yypv, &yyval);
#else
	*yypv = yyval;
#endif

yynewstate:

	yysavestate	= yystate;
	yysave_yypv	= yypv;
	yysave_yyval= yyval;
	yysave_yyps	= yyps;

	yyn = yypact[yystate];

	if( yyn <= YYFLAG ) {	/*  simple state, no lookahead  */
		goto yydefault;
	}

	if( ! fHaveRecoveredChar )
		{
		if( yychar < 0 ) /*  need a lookahead */
			{
			yychar = YYLEX();
			}
		}

	fHaveRecoveredChar	= 0;

	if( ((yyn += yychar) < 0) || (yyn >= YYLAST) ) {
		goto yydefault;
	}

	if( yychk[ yyn = yyact[ yyn ] ] == yychar ) {		/* valid shift */
		yychar = -1;
#ifdef UNION
		yyunion(&yyval, &yylval);
#else
		yyval = yylval;
#endif
		yystate = yyn;
		if( yyerrflag > 0 ) {
			--yyerrflag;
		}
		goto yystack;
	}

 yydefault:
	/* default state action */

	if( (yyn = yydef[yystate]) == -2 ) {
		register	short	*yyxi;

		if( yychar < 0 ) {
			yychar = YYLEX();
		}
/*
**  search exception table, we find a -1 followed by the current state.
**  if we find one, we'll look through terminal,state pairs. if we find
**  a terminal which matches the current one, we have a match.
**  the exception table is when we have a reduce on a terminal.
*/

#if YYOPTTIME
		yyxi = yyexca + yyexcaind[yystate];
		while(( *yyxi != yychar ) && ( *yyxi >= 0 )){
			yyxi += 2;
		}
#else
		for(yyxi = yyexca;
			(*yyxi != (-1)) || (yyxi[1] != yystate);
			yyxi += 2
		) {
			; /* VOID */
			}

		while( *(yyxi += 2) >= 0 ){
			if( *yyxi == yychar ) {
				break;
				}
		}
#endif
		if( (yyn = yyxi[1]) < 0 ) {
			return(0);   /* accept */
			}
		}

	if( yyn == 0 ) /* error */
		{ 

		int yytempchar;


		if( ( yytempchar = GetExpectedChar( yysavestate ) ) != -1 )
			{
			char Buf[ 9 ];

			SyntaxError( BENIGN_SYNTAX_ERROR, yysavestate );

			fHaveRecoveredChar	= 1;
			yyunlex( yychar );
			yychar	= yytempchar;

			sprintf( Buf, " %c ", yytempchar );
			ParseError( ASSUMING_CHAR, Buf );

			yystate	= yysavestate;
			yypv	= yysave_yypv;
			yyval	= yysave_yyval;
			yyps	= yysave_yyps;

			goto yynewstate;

			}
		else
			{
			SyntaxError( SYNTAX_ERROR, yysavestate );
			return 1;
			}
		}

	/* reduction by production yyn */
/* yyreduce: */
		{
#ifdef YYDEBUG
		yyprintf("[yydebug] reduce %d\n",yyn, 0, 0, 0);
#else /* YYDEBUG */
		yyprintf("[yydebug] reduce %d\n",yyn, 0, 0);
#endif /* YYDEBUG */
		yypvt = yypv;
		yyps -= yyr2[yyn];
		yypv -= yyr2[yyn];
#ifdef UNION
		yyunion(&yyval, &yypv[1]);
#else
		yyval = yypv[1];
#endif
		yym = yyn;
		yyn = yyr1[yyn];		/* consult goto table to find next state */
		yyj = yypgo[yyn] + *yyps + 1;
		if( (yyj >= YYLAST) || (yychk[ yystate = yyact[yyj] ] != -yyn) ) {
			yystate = yyact[yypgo[yyn]];
			}
		returnflag = 0;
		GrammarAct = yym;
		(*(pcase_fn_array[ (yym <= yym_vc_max) ? yym : 0  ]))();
		if(returnflag != 0)
			return returnflag;
		}
		goto yystack;  /* stack new state and value */
	}
___a_r_u_myact
$A
___a_r_u_end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yyless.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

yyless(x)

   {
   extern char yytext[];
   register char *lastch, *ptr;
   extern int yyleng;
   extern int yyprevious;
   lastch = yytext+yyleng;
   if (x>=0 && x <= yyleng)
      ptr = x + yytext;
   else
      ptr = x;
   while (lastch > ptr)
      yyunput(*--lastch);
   *lastch = 0;
   if (ptr >yytext)
      yyprevious = *--lastch;
   yyleng = ptr-yytext;
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\uuidgen\uuidfmt.h ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    uuidfmt.h {v1.00}

Abstract:

    This module is used by uuidfmt.c and any other module which
    uses uuidfmt.c.
    It prototypes the entry into uuidfmt.c, I_UuidStringGenerate,
    and contains the set of flag codes used by I_UuidStringGenerate.

Author:

    Joev Dubach (t-joevd) 6/11/92

Revision History:

--*/

#ifndef __UUIDGEN_H__
#define __UUIDGEN_H__

//
// Defines (flags for I_UuidStringGenerate)
//

#define UUIDGEN_FORMAT_IDL 0
#define UUIDGEN_FORMAT_CSTRUCT 1
#define UUIDGEN_FORMAT_PLAIN 2

//
// Function prototypes
//

RPC_STATUS I_UuidStringGenerate(
    int Flag,
    int Sequential,
    int AllCaps,
    char PAPI * UuidFormattedString,
    char PAPI * InterfaceName
    );

#endif /* __UUIDGEN_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\template\yypars.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/* SCCSWHAT( "@(#)yypars.c	2.4 88/05/09 15:22:59	" ) */
___a_r_u_start
static char *SCCSID = "@(#)yypars.c:1.3";
# define YYFLAG -1000
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)

#ifdef YYDEBUG				/* RRR - 10/9/85 */
#define yyprintf(a, b, c, d, e) printf(a, b, c, d, e)
#else
#define yyprintf(a, b, c, d)
#endif

#ifndef YYPRINT
#define	YYPRINT	printf
#endif

#if ! defined YYSTATIC
#define YYSTATIC
#endif

/*	parser for yacc output	*/

#ifdef YYDEBUG
YYSTATIC int yydebug = 0; /* 1 for debugging */
#endif
YYSTATIC YYSTYPE yyv[YYMAXDEPTH];	/* where the values are stored */
YYSTATIC short	yys[YYMAXDEPTH];	/* the parse stack */
YYSTATIC int yychar = -1;			/* current input token number */
YYSTATIC int yynerrs = 0;			/* number of errors */
YYSTATIC short yyerrflag = 0;		/* error recovery flag */

#ifdef YYRECOVER
/*
**  yyscpy : copy f onto t and return a ptr to the null terminator at the
**  end of t.
*/
YYSTATIC	char	*yyscpy(t,f)
	register	char	*t, *f;
	{
	while(*t = *f++)
		t++;
	return(t);	/*  ptr to the null char  */
	}
#endif

#ifndef YYNEAR
#define YYNEAR
#endif
#ifndef YYPASCAL
#define YYPASCAL
#endif
#ifndef YYLOCAL
#define YYLOCAL
#endif
#if ! defined YYPARSER
#define YYPARSER yyparse
#endif
#if ! defined YYLEX
#define YYLEX yylex
#endif

static	void	yy_vc_init();
typedef	void	(*pfn)();
static	pfn		*pcase_fn_array;
static	int		returnflag = 0;
static	YYSTYPE	*yypvt;
static	int		yym_vc_max = 0;
extern  short	GrammarAct;

extern short	yysavestate;

#define MAX_RECOVERY_ATTEMPTS	(50)
#define MAX_RETRY_COUNT			(3)
static short RetryCount = 0;
static short MaxRecoveryAttempts = 0;
static short fJustDiscarded = 0;

YYLOCAL YYNEAR YYPASCAL YYPARSER()
{
	register	short	yyn;
	short		yystate, *yyps, *yysave_yyps;
	YYSTYPE		*yypv,*yysave_yypv;
	YYSTYPE		yysave_yyval;
	short		yyj, yym;
	short		fHaveRecoveredChar	= 0;

	yy_vc_init();
#ifdef YYDEBUG
	yydebug = 1;
#endif /* YYDEBUG */

	yystate = 0;
	yychar = -1;
	yynerrs = 0;
	yyerrflag = 0;
	yyps= &yys[-1];
	yypv= &yyv[-1];

 yystack:    /* put a state and value onto the stack */

	RetryCount = 0;

#ifdef YYDEBUG
	yyprintf( "[yydebug] state %d, char %d = %c\n", yystate, yychar,yychar, 0 );
#else /* YYDEBUG */
	yyprintf( "[yydebug] state %d, char %d\n", yystate, yychar, 0 );
#endif /* YYDEBUG */
	if( ++yyps > &yys[YYMAXDEPTH] ) {
/*		yyerror( "yacc stack overflow" ); */
		ParseError(C_STACK_OVERFLOW, (char *)NULL);
		return(1);
	}
	*yyps = yystate;
	++yypv;

#ifdef UNION
	yyunion(yypv, &yyval);
#else
	*yypv = yyval;
#endif

yynewstate:

	yysavestate	= yystate;
	yysave_yypv	= yypv;
	yysave_yyval= yyval;
	yysave_yyps	= yyps;

	yyn = yypact[yystate];

	if( yyn <= YYFLAG ) {	/*  simple state, no lookahead  */
		goto yydefault;
	}

	if( ! fHaveRecoveredChar )
		{
		if( yychar < 0 ) /*  need a lookahead */
			{
			yychar = YYLEX();
			}
		}

	fHaveRecoveredChar	= 0;

	if( ((yyn += yychar) < 0) || (yyn >= YYLAST) ) {
		goto yydefault;
	}

	if( yychk[ yyn = yyact[ yyn ] ] == yychar ) {		/* valid shift */
		yychar = -1;
#ifdef UNION
		yyunion(&yyval, &yylval);
#else
		yyval = yylval;
#endif
		yystate = yyn;
		if( yyerrflag > 0 ) {
			--yyerrflag;
		}
		goto yystack;
	}

 yydefault:
	/* default state action */

	if( (yyn = yydef[yystate]) == -2 ) {
		register	short	*yyxi;

		if( yychar < 0 ) {
			yychar = YYLEX();
		}
/*
**  search exception table, we find a -1 followed by the current state.
**  if we find one, we'll look through terminal,state pairs. if we find
**  a terminal which matches the current one, we have a match.
**  the exception table is when we have a reduce on a terminal.
*/

#if YYOPTTIME
		yyxi = yyexca + yyexcaind[yystate];
		while(( *yyxi != yychar ) && ( *yyxi >= 0 )){
			yyxi += 2;
		}
#else
		for(yyxi = yyexca;
			(*yyxi != (-1)) || (yyxi[1] != yystate);
			yyxi += 2
		) {
			; /* VOID */
			}

		while( *(yyxi += 2) >= 0 ){
			if( *yyxi == yychar ) {
				break;
				}
		}
#endif
		if( (yyn = yyxi[1]) < 0 ) {
			return(0);   /* accept */
			}
		}

	if( yyn == 0 ) /* error */
		{ 

		int yytempchar;


		if( (yychar != EOI ) &&
			 ( RetryCount < MAX_RETRY_COUNT ) &&
			 ( MaxRecoveryAttempts < MAX_RECOVERY_ATTEMPTS ) )
			{ 
			if( RetryCount == 0 )
				SyntaxError( BENIGN_SYNTAX_ERROR, yysavestate );

			if((( yytempchar = PossibleMissingToken( yysavestate, yychar ) ) != -1 ))
				{
				char Buf[ 50 ];


				fHaveRecoveredChar	= 1;
				yyunlex( yychar );
				yychar	= yytempchar;

				if( (yytempchar < 128 ) && isprint( yytempchar ) )
					{
					sprintf( Buf, " %c ", yytempchar );
					}
				else if( yytempchar == IDENTIFIER )
					{
					yylval.yy_pSymName = GenTempName();
					sprintf( Buf, " identifier %s", yylval.yy_pSymName );
					}
				else if( (yytempchar == NUMERICCONSTANT ) ||
						 (yytempchar == NUMERICLONGCONSTANT ) ||
						 (yytempchar == NUMERICULONGCONSTANT ) ||
						 (yytempchar == HEXCONSTANT ) ||
						 (yytempchar == HEXLONGCONSTANT ) ||
						 (yytempchar == HEXULONGCONSTANT ) )
					{
					sprintf( Buf, "a number" );
					yylval.yy_numeric.Val = 0;
					yylval.yy_numeric.pValStr = new char[2];
					strcpy( yylval.yy_numeric.pValStr, "0");
					}

				ParseError( ASSUMING_CHAR, Buf );
				RetryCount = 0;
				MaxRecoveryAttempts++;
				fJustDiscarded = 0;
				}
			else 
				{
				char buf[ 20 ];
				if( (yychar < 128 ) && isprint( yychar ) )
					{
					sprintf( buf, " %c ", yychar );
					}
				else
					{
					sprintf( buf, " the last token " );
					}

				ParseError( DISCARDING_CHAR, buf );
				yychar = -1;
				RetryCount++;
				MaxRecoveryAttempts++;
				fJustDiscarded = 1;
				}

			yystate	= yysavestate;
			yypv	= yysave_yypv;
			yyval	= yysave_yyval;
			yyps	= yysave_yyps;

			goto yynewstate;

			}
		else if( (yychar == EOI ) && (fJustDiscarded == 0 ) )
			{
			SyntaxError( UNEXPECTED_END_OF_FILE, yysavestate );
			return 1;
			}
		else
			{
			SyntaxError( SYNTAX_ERROR, yysavestate );
			return 1;
			}
		}

	/* reduction by production yyn */
/* yyreduce: */
		{
#ifdef YYDEBUG
		yyprintf("[yydebug] reduce %d\n",yyn, 0, 0, 0);
#else /* YYDEBUG */
		yyprintf("[yydebug] reduce %d\n",yyn, 0, 0);
#endif /* YYDEBUG */
		yypvt = yypv;
		yyps -= yyr2[yyn];
		yypv -= yyr2[yyn];
#ifdef UNION
		yyunion(&yyval, &yypv[1]);
#else
		yyval = yypv[1];
#endif
		yym = yyn;
		yyn = yyr1[yyn];		/* consult goto table to find next state */
		yyj = yypgo[yyn] + *yyps + 1;
		if( (yyj >= YYLAST) || (yychk[ yystate = yyact[yyj] ] != -yyn) ) {
			yystate = yyact[yypgo[yyn]];
			}
		returnflag = 0;
		GrammarAct = yym;
		(*(pcase_fn_array[ (yym <= yym_vc_max) ? yym : 0  ]))();
		if(returnflag != 0)
			return returnflag;
		}
		goto yystack;  /* stack new state and value */
	}
___a_r_u_myact
$A
___a_r_u_end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\ywstat.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 The s switch has been introduced to allow yacc to generate extended tables
 for MIDL error recovery and reporting scheme. The following are the routines
 which take part in s switch processing:

 . EmitStateVsExpectedConstruct
 . EmitStateGotoTable
 . SSwitchInit
 . SSwitchExit

 The global int variable ssw is 0 if s switch is not specified, non-zero
 otherwise. This is set in ysetup.c If the sswitch is specified, the i switch
 is automatically enabled.

 ----------------------------------------------------------------------------*/
#include <malloc.h>
#include <stdlib.h>
#include "y3.h"
#include "y4.h"

extern int ssw;

FILE *tokxlathdl;/* token xlation file,token index vs value*/
FILE *stgotohdl; /* state goto table file handle */
FILE *stexhdl;	 /* state vs expected construct handle */
short MaxStateVsTokenCount = 0;
short MaxTokenVsStateCount = 0;
short *pTokenVsStateCount;
SSIZE_T MaxTokenValue = 0;
short NStates = 0;
int StateVsExpectedCount = 0;

void
wrstate( int i)
   {
   /* writes state i */
   register j0;
   SSIZE_T j1;
   register struct item *pp, *qq;
   register struct wset *u;

   if( foutput == NULL ) return;

	SSwitchInit();

   fprintf( foutput, "\nstate %d\n",i);
   ITMLOOP(i,pp,qq)
	{
	fprintf( foutput, "\t%s\n", writem(pp->pitem));
	EmitStateVsExpectedConstruct( i,  pp->pitem );
	}

   if( tystate[i] == MUSTLOOKAHEAD )
      {
      /* print out empty productions in closure */
      WSLOOP( wsets+(pstate[i+1]-pstate[i]), u )
         {
         if( *(u->pitem) < 0 ) fprintf( foutput, "\t%s\n", writem(u->pitem) );
         }
      }

   /* check for state equal to another */

   TLOOP(j0)
	{
	if( (j1=temp1[j0]) != 0 )
      {
      fprintf( foutput, "\n\t%s  ", symnam(j0) );
      if( j1>0 )
         {
         /* shift, error, or accept */
         if( j1 == ACCEPTCODE ) fprintf( foutput,  "accept" );
         else if( j1 == ERRCODE ) fprintf( foutput, "error" );
         else fprintf( foutput,  "shift %d", j1 );
         }
      else fprintf( foutput, "reduce %d",-j1 );
      }
	}

	/* output any s switch information */

	EmitStateGotoTable( i );

   /* output the final production */

   if( lastred ) fprintf( foutput, "\n\t.  reduce %d\n\n", lastred );
   else fprintf( foutput, "\n\t.  error\n\n" );

   /* now, output nonterminal actions */

   j1 = ntokens;
   for( j0 = 1; j0 <= nnonter; ++j0 )
      {
      if( temp1[++j1] )
		fprintf( foutput, "\t%s  goto %d\n", symnam( j0+NTBASE), temp1[j1] );
      }

   }

void
wdef( char *s, int n )

   {
   /* output a definition of s to the value n */
   fprintf( ftable, "# define %s %d\n", s, n );
   }
void
EmitStateGotoTable(
	int		i )
	{

	register int j0;
	short count = 0;

#define TLOOP_0(i) for(i=0;i<=ntokens;++i)
	if( ssw )
		{

		NStates++;

		TLOOP_0( j0 )
			{
			if( (temp1[ j0 ] > 0 ) && (temp1[ j0 ] != ACCEPTCODE ) )
				count++;
			}

		if( count >= MaxStateVsTokenCount )
			MaxStateVsTokenCount = count;

		fprintf( stgotohdl, "%.4d : %.4d : ", i, count );

   		TLOOP_0( j0 )
			{
			if( (temp1[ j0 ] > 0 ) && (temp1[ j0 ] != ACCEPTCODE ) )
				{
				fprintf( stgotohdl, " %.4d, %.4d", temp1[ j0 ], j0 );
				pTokenVsStateCount[ j0 ] += 1;
				if( pTokenVsStateCount[ j0 ] >= MaxTokenVsStateCount )
					MaxTokenVsStateCount = pTokenVsStateCount[ j0 ];
				}
			}

		fprintf( stgotohdl, "\n");
		}

	}
void
EmitStateVsExpectedConstruct(
	int state,
	SSIZE_T *pp )
   {
   SSIZE_T i,*p;
//   char *q;
   int flag = 0;
   int Count;

   if( ssw )
	{
   	for( p=pp; *p>0 ; ++p ) ;

   	p = prdptr[-*p];

// 	fprintf( stexhdl, " %s", nontrst[ *p-NTBASE ].name );
 	fprintf( stexhdl, " %.4d : ", state );

	Count = CountStateVsExpectedConstruct( state, pp );

	StateVsExpectedCount += Count;

	fprintf( stexhdl, " %.4d : ",Count );
	
   	for(;;)
      	{
      	if( ++p==pp )
			{
			if( ( i = *p ) <= 0 )
				{
				fprintf( stexhdl, "\n" );
				return;
				}
			else
				fprintf( stexhdl, "%s\n", symnam(i) );
			}
		if( p >= pp ) return;
      	}
	}
}
int
CountStateVsExpectedConstruct(
	int state,
	SSIZE_T *pp )
   {
   SSIZE_T i,*p;
   int flag = 0;
   int Count = 0;

   if( ssw )
	{
   	for( p=pp; *p>0 ; ++p ) ;

   	p = prdptr[-*p];

   	for(;;)
      	{
      	if( ++p==pp )
			{
			if( ( i = *p ) <= 0 )
				{
				return Count;
				}
			else
				++Count;
			}
		if( p >= pp ) return Count;
      	}
	}

    return Count;   /* NOTREACHED */
}
void
SSwitchInit()
	{
static sswitch_inited = 0;
	int	i	= 0;

	if( ssw && ! sswitch_inited )
		{
		tokxlathdl	= fopen( "extable.h1" , "w" );

        if ( NULL == tokxlathdl ) {error("Unable to open tokxlathdl" );exit(0);}

		/* output the token index vs the token value table */

		fprintf( tokxlathdl, "%d %d\n", ntokens+1, ACCEPTCODE );

		while( i <= ntokens )
			{
			fprintf( tokxlathdl , "%d ",
				tokset[ i ].value);

			if( tokset[ i ].value >= MaxTokenValue )
				MaxTokenValue = tokset[ i ].value;

			++i;
			}

		fprintf(tokxlathdl, "\n");

		/* set up for the state vs expected construct */

		stexhdl	= fopen( "extable.h2", "w" );
               
                if ( NULL == stexhdl ) error("Unable to open extable.h2");

		/* set up for state goto table */

		stgotohdl = fopen( "extable.h3", "w");

                if ( NULL == stgotohdl ) error("Unable to open extable.h3");

		/* set up state vs token count array */

		pTokenVsStateCount = calloc( 1, (ntokens+1 ) * sizeof(short) );

                if ( NULL == pTokenVsStateCount ) error("Out of memory");

		sswitch_inited = 1;
		}
	}

void
SSwitchExit( void )
	{
	int i;

	if( ssw )
		{

		/** print the token index vs goto count **/

		for( i = 0; i <= ntokens ; ++i )
			{
			fprintf( tokxlathdl , "%d ", pTokenVsStateCount[ i ]);
			}

		fprintf( tokxlathdl, "\n");
		fprintf( tokxlathdl, "%d %d %d %d %d \n",
							 NStates,
							 MaxTokenVsStateCount,
							 MaxStateVsTokenCount,
							 MaxTokenValue,
							 StateVsExpectedCount );

		fclose( tokxlathdl );
		fclose( stexhdl );
		fclose( stgotohdl );
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\tools\yacc\yywrap.c ===
// Copyright (c) 1993-1999 Microsoft Corporation

yywrap()

   {
   return(1);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\uuidgen\uuidfmt.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    uuidfmt.c {v1.00}

Abstract:

This module contains I_UuidStringGenerate, which coalesces
the procedures UuidCreate and UuidToString to create a UUID
in one of the formats IDL, C struct, or plain.

Author:

    Joev Dubach (t-joevd) 6/11/92

Revision History:

--*/

//
// Defines
//

#define IDL_STR "[\nuuid(%s),\nversion(1.0)\n]\ninterface %s\n{\n\n}\n"

//
// Inclusions
//
// The order in which these includes are performed seems, after
// extensive testing and analysis, to be highly crucial to a
// successful NT build.

#include <sysinc.h>
#include <rpc.h>
#include <uuidfmt.h>
#include <stdio.h>
#include <stdlib.h>

//
// Function prototypes.
//

void GenUuidAsIDL (
    char PAPI * MyUuidString,
    char PAPI * UuidFormattedString,
    char PAPI * InterfaceName
    );

void GenUuidAsCStruct (
    char PAPI * MyUuidString,
    char PAPI * UuidFormattedString,
    char PAPI * InterfaceName
    );

void GenUuidPlain (
    char PAPI * MyUuidString,
    char PAPI * UuidFormattedString
    );

void __RPC_FAR * __RPC_API
MIDL_user_allocate(
    size_t size
    )
{
    return malloc(size);
}

void __RPC_API
MIDL_user_free(
    void __RPC_FAR * pvBuf
    )
{
    free(pvBuf);
}



/*

Routine Description:

    This routine creates a UUID in one of several string representations.

Arguments:

    Flag - UUIDGEN_FORMAT_IDL gives an IDL template;
           UUIDGEN_FORMAT_CSTRUCT gives a C Struct;
           UUIDGEN_FORMAT_PLAIN gives a plain UUID.

    UuidFormattedString - Must be preinitialized; will contain result.

    InterfaceName - Name of desired interface; used for IDL and C Structs.

Return Value:

    RPC_S_OK - We successfully converted the UUID into its string
        representation.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
        a string.

    RPC_S_UUID_NO_ADDRESS - We were unable to obtain the ethernet or
        token ring address for this machine.


*/

RPC_STATUS I_UuidStringGenerate(
    int Flag,
    int Sequential,
    int AllCaps,
    char PAPI * UuidFormattedString,
    char PAPI * InterfaceName
    )
{
    UUID MyUuid;                    // Storage for a retrieved UUID.
    char PAPI * MyUuidString;
    RPC_STATUS Result;
    int LocalOnly = 0;

    ASSERT(   (Flag == UUIDGEN_FORMAT_IDL)
           || (Flag == UUIDGEN_FORMAT_CSTRUCT)
           || (Flag == UUIDGEN_FORMAT_PLAIN));

    if (Sequential)
        {
        Result = UuidCreateSequential(&MyUuid);
        }
    else 
        {
        Result = UuidCreate(&MyUuid);
        }

    ASSERT(    (Result == RPC_S_UUID_NO_ADDRESS)
            || (Result == RPC_S_OK)
            || (Result == RPC_S_UUID_LOCAL_ONLY) );

    if (Result == RPC_S_UUID_LOCAL_ONLY)
        {
        Result = RPC_S_OK;
        LocalOnly = 1;
        }

    if (Result == RPC_S_OK)
        {
        Result = UuidToString(
            &MyUuid,
            &MyUuidString
            );

        ASSERT((Result == RPC_S_OK) || (Result == RPC_S_OUT_OF_MEMORY));
        if (Result == RPC_S_OK)
            {

            if (AllCaps) {
                char *p = MyUuidString;
                while (*p)
                    {
                    *p= (char)toupper(*p);
                    p++;
                    }
                }

            switch(Flag)
                {
                case UUIDGEN_FORMAT_IDL:
                    GenUuidAsIDL(
                        MyUuidString,
                        UuidFormattedString,
                        InterfaceName
                        );
                    break;
                case UUIDGEN_FORMAT_CSTRUCT:
                    GenUuidAsCStruct(
                        MyUuidString,
                        UuidFormattedString,
                        InterfaceName
                        );
                    break;

                case UUIDGEN_FORMAT_PLAIN:
                    GenUuidPlain(
                        MyUuidString,
                        UuidFormattedString
                        );
                } // end switch
            RpcStringFree(&MyUuidString);
            } // end if
        } // end if

    if (   (Result == RPC_S_OK)
        && (LocalOnly) )
        {
        return(RPC_S_UUID_LOCAL_ONLY);
        }

    return(Result);
} // end I_UuidStringGenerate

void GenUuidAsIDL (
    char PAPI * MyUuidString,
    char PAPI * UuidFormattedString,
    char PAPI * InterfaceName
    )
{
    sprintf(
        UuidFormattedString,
        IDL_STR,
        MyUuidString,
        InterfaceName
        );
}

void GenUuidAsCStruct (
    char PAPI * MyUuidString,
    char PAPI * UuidFormattedString,
    char PAPI * InterfaceName
    )
{
    int      i;
    char     temp[157] =
        "%s = { /* ........-....-....-....-............ */\n"
        "    0x........,\n"
        "    0x....,\n"
        "    0x....,\n"
        "    {0x.., 0x.., 0x.., 0x.., 0x.., 0x.., 0x.., 0x..}\n"
        "  };\n\0";

    for (i=0; i<36; i++) temp[10+i] = MyUuidString[i];
    for (i=0; i<8; i++) temp[56+i] = MyUuidString[i];
    for (i=0; i<4; i++) temp[72+i] = MyUuidString[9+i];
    for (i=0; i<4; i++) temp[84+i] = MyUuidString[14+i];
    for (i=0; i<2; i++) temp[97+i] = MyUuidString[19+i];
    for (i=0; i<2; i++) temp[103+i] = MyUuidString[21+i];
    for (i=0; i<2; i++) temp[109+i] = MyUuidString[24+i];
    for (i=0; i<2; i++) temp[115+i] = MyUuidString[26+i];
    for (i=0; i<2; i++) temp[121+i] = MyUuidString[28+i];
    for (i=0; i<2; i++) temp[127+i] = MyUuidString[30+i];
    for (i=0; i<2; i++) temp[133+i] = MyUuidString[32+i];
    for (i=0; i<2; i++) temp[139+i] = MyUuidString[34+i];
    sprintf(UuidFormattedString, temp, InterfaceName);
}

void GenUuidPlain (
    char PAPI * MyUuidString,
    char PAPI * UuidFormattedString
    )
{
    strcpy(UuidFormattedString, MyUuidString);
    strcat(UuidFormattedString, "\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\uuidgen\uuidgen.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    uuidgen.c {v1.00}

Abstract:

usage: uuidgen [-xisconvh?]
        x - Generate sequential (V1) UUIDs
        i - Output UUID in an IDL interface template
        s - Output UUID as an initialized C struct
        c - Output UUID in upper case
        o<filename> - redirect output to a file, specified immediately after o
        n<number> - Number of UUIDs to generate, specified immediately after n
        v - display version information about uuidgen
        h,? - Display command option summary

This command-line program simply uses the procedure I_UuidStringGenerate
to output one or more UUIDs in one of the formats normal, IDL, or C struct.
This code should build under nt to nt and nmake under os2 to dos.
Requires uuidfmt.c.

Author:

    Joev Dubach (t-joevd) 6/11/92

Revision History:

--*/

//
// Inclusions
//
// The order in which these includes are performed seems, after
// extensive testing and analysis, to be highly crucial to an
// NT build.

#include <sysinc.h>
#include <rpc.h>
#include <uuidfmt.h>
#include <stdio.h>
#include <stdlib.h>

#include <common.ver>

//
// Defines
//

#define IDL_BIT_FLAG 0x01
#define CSTRUCT_BIT_FLAG 0x02
#define SEQUENTIAL_UUIDS   0x04
#define UPPER_CASE_UUIDS   0x08
#define BAD_SWITCH_STR "Invalid Switch Usage: %s\n\n"
#define CANNOT_OPEN_STR "Cannot open output file: %s\n\n"
#define TOO_SMALL_STR "Argument to %s must be an integer greater than 0.\n\n"
#define VERSION_INFO_STR \
 "Microsoft UUID Generator v1.01 " \
 VER_LEGALCOPYRIGHT_STR \
 "\n\n"
#define BAD_ARGS_STR "The arguments i and s are mutually exclusive.\n\n"
#define NO_ADDRESS_STR \
 "Cannot find the RPC End Point Mapper (RPCSS.EXE); Unable to allocate UUIDs.\n\n"
#define OUT_OF_MEMORY_STR \
 "Unable to allocate enough memory to create string.\n\n"
#define LOCAL_ONLY_STR \
 "Warning: Unable to determine your network address.  The UUID generated is\n" \
 "unique on this computer only.  It should not be used on another computer.\n"

//
// Function prototypes.
//

#ifdef NTENV
int __cdecl
#else // NTENV
int
#endif // NTENV
main(
    int argc,
    char **argv
    );

void Usage(void);

void ErrorUsageAndExit(void);

void NoErrorUsageAndExit(void);

//
// Global variables
//

FILE * OutputFile = stdout;

#ifdef NTENV
int __cdecl
#else // NTENV
int
#endif // NTENV
main(
    int argc,
    char **argv
    )
{
    int  ConditionFlags = 0;       // Holds conditions IDL_BIT_FLAG and
                                       // CSTRUCT_BIT_FLAG.
    char MyUuidString[255];        // The UUID string returned by
                                       // I_UuidStringGenerate.
    int  NumberOfUuids = 1;        // How many to make.
    int  i;                        // Current arg#.
    int Flag;                      // UUID Format requested.
    RPC_STATUS Result;
    int FirstTime = 1;
    
    //
    // Parse the command line.
    //

    for (i=1;argc-i;i++)
        {

        //
        // Make sure arg is in proper format.
        //

        if ( (argv[i][0] != '/') && (argv[i][0] != '-') )
            {
            fprintf(stderr, BAD_SWITCH_STR, argv[i]);
            ErrorUsageAndExit();
            }

        //
        // Which arg is it?
        //

        switch (argv[i][1])
            {
            case 'c':
            case 'C':
                ConditionFlags |= UPPER_CASE_UUIDS;
                break;
            case 'I':
            case 'i':
                ConditionFlags |= IDL_BIT_FLAG;
                break;

            case 'S':
            case 's':
                ConditionFlags |= CSTRUCT_BIT_FLAG;
                break;

            case 'O':
            case 'o':
                OutputFile = fopen(argv[i]+2, "wt");
                if (OutputFile == NULL)
                    {
                    fprintf(stderr,CANNOT_OPEN_STR, argv[i]+2);
                    exit(1);
                    }
                break;

            case 'N':
            case 'n':
                NumberOfUuids = atoi(argv[i]+2);
                if (NumberOfUuids <= 0)
                    {
                    fprintf(stderr, TOO_SMALL_STR, argv[i-1]);
                    ErrorUsageAndExit();
                    }
                break;

            case 'x':
            case 'X':
                ConditionFlags |= SEQUENTIAL_UUIDS;
                break;

            case 'V':
            case 'v':
                fprintf(OutputFile, VERSION_INFO_STR);
                exit(0);

            case 'H':
            case 'h':
            case '?':
                NoErrorUsageAndExit();

            default:
                fprintf(stderr, BAD_SWITCH_STR, argv[i]);
                ErrorUsageAndExit();

            } // switch
        } // for

    //
    // Fulfill the user's request
    //

    if ((ConditionFlags & IDL_BIT_FLAG) && (ConditionFlags & CSTRUCT_BIT_FLAG))
        {
        fprintf(stderr,BAD_ARGS_STR);
        ErrorUsageAndExit();
        }

    if (ConditionFlags & IDL_BIT_FLAG)
        {
        Flag = UUIDGEN_FORMAT_IDL;
        }
    else if (ConditionFlags & CSTRUCT_BIT_FLAG)
        {
        Flag = UUIDGEN_FORMAT_CSTRUCT;
        }
    else
        {
        Flag = UUIDGEN_FORMAT_PLAIN;
        }

    for (;NumberOfUuids;NumberOfUuids--)
        {
        Result = I_UuidStringGenerate(
            Flag,
            (ConditionFlags & SEQUENTIAL_UUIDS) != 0,
            (ConditionFlags & UPPER_CASE_UUIDS) != 0,
            MyUuidString,
            "INTERFACENAME"
            );

        ASSERT((Result == RPC_S_OK)
               || (Result == RPC_S_UUID_LOCAL_ONLY)
               || (Result == RPC_S_OUT_OF_MEMORY)
               || (Result == RPC_S_UUID_NO_ADDRESS));

        switch(Result)
            {
            case RPC_S_OUT_OF_MEMORY:
                fprintf(stderr,OUT_OF_MEMORY_STR);
                exit(1);

            case RPC_S_UUID_NO_ADDRESS:
                fprintf(stderr,NO_ADDRESS_STR);
                exit(1);

            case RPC_S_UUID_LOCAL_ONLY:
                if (FirstTime)
                    {
                    fprintf(stderr,LOCAL_ONLY_STR);
                    FirstTime = 0;
                    }

                // Fall through to the valid case.

            case RPC_S_OK:
                fprintf(
                    OutputFile,
                    MyUuidString
                    );
            } // end switch
        } // end for

    return(0);
}

void Usage(void)
{
    fprintf(OutputFile, VERSION_INFO_STR
                        "usage: uuidgen [-xisconvh?]\n"
                        "\tx - Generate sequential (V1) UUIDs\n"
                        "\ti - Output UUID in an IDL interface template\n"
                        "\ts - Output UUID as an initialized C struct\n"
                        "\tc - Output UUID in upper case\n"
                        "\to<filename> - redirect output to a file, specified immediately after o\n"
                        "\tn<number> - Number of UUIDs to generate, specified immediately after n\n"
                        "\tv - display version information about uuidgen\n"
                        "\th,? - Display command option summary\n"
            );
}

void ErrorUsageAndExit(void)
{
    OutputFile = stderr;
    Usage();
    exit(1);
}

void NoErrorUsageAndExit(void)
{
    Usage();
    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpcutil\server.c ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    RpcServ.c

Abstract:

    This file contains commonly used server-side RPC functions,
    such as starting and stoping RPC servers.

Author:

    Dan Lafferty    danl    09-May-1991

Environment:

    User Mode - Win32

Revision History:

    09-May-1991     Danl
        Created

    03-July-1991    JimK
        Copied from a net-specific file.

    18-Feb-1992     Danl
        Added support for multiple endpoints & interfaces per server.

    10-Nov-1993     Danl
        Wait for RPC calls to complete before returning from
        RpcServerUnregisterIf.  Also, do a WaitServerListen after
        calling StopServerListen (when the last server shuts down).
        Now this is similar to RpcServer functions in netlib.

    29-Jun-1995     RichardW
        Read an alternative ACL from a key in the registry, if one exists.
        This ACL is used to protect the named pipe.

--*/

//
// INCLUDES
//

// These must be included first:
#include <nt.h>              // DbgPrint
#include <ntrtl.h>              // DbgPrint
#include <windef.h>             // win32 typedefs
#include <rpc.h>                // rpc prototypes
#include <ntrpcp.h>
#include <nturtl.h>             // needed for winbase.h
#include <winbase.h>            // LocalAlloc

// These may be included in any order:
#include <tstr.h>       // WCSSIZE

#define     NT_PIPE_PREFIX_W        L"\\PIPE\\"

//
// GLOBALS
//

    static CRITICAL_SECTION RpcpCriticalSection;
    static DWORD            RpcpNumInstances;



NTSTATUS
RpcpInitRpcServer(
    VOID
    )

/*++

Routine Description:

    This function initializes the critical section used to protect the
    global server handle and instance count.

Arguments:

    none

Return Value:

    none

--*/
{
    NTSTATUS Status;

    RpcpNumInstances = 0;

    Status = RtlInitializeCriticalSection(&RpcpCriticalSection);

    return Status;
}



NTSTATUS
RpcpAddInterface(
    IN  LPWSTR                  InterfaceName,
    IN  RPC_IF_HANDLE           InterfaceSpecification
    )

/*++

Routine Description:

    Starts an RPC Server, adds the address (or port/pipe), and adds the
    interface (dispatch table).

Arguments:

    InterfaceName - points to the name of the interface.

    InterfaceSpecification - Supplies the interface handle for the
        interface which we wish to add.

Return Value:

    NT_SUCCESS - Indicates the server was successfully started.

    STATUS_NO_MEMORY - An attempt to allocate memory has failed.

    Other - Status values that may be returned by:

                 RpcServerRegisterIf()
                 RpcServerUseProtseqEp()

    , or any RPC error codes, or any windows error codes that
    can be returned by LocalAlloc.

--*/
{
    RPC_STATUS          RpcStatus;
    LPWSTR              Endpoint = NULL;

    BOOL                Bool;
    NTSTATUS            Status;

    // We need to concatenate \pipe\ to the front of the interface name.

    Endpoint = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(NT_PIPE_PREFIX_W) + WCSSIZE(InterfaceName));
    if (Endpoint == 0) {
       return(STATUS_NO_MEMORY);
    }
    wcscpy(Endpoint, NT_PIPE_PREFIX_W );
    wcscat(Endpoint,InterfaceName);


    //
    // Ignore the second argument for now.
    // Use default security descriptor
    //

    RpcStatus = RpcServerUseProtseqEpW(L"ncacn_np", 10, Endpoint, NULL);

    // If RpcpStartRpcServer and then RpcpStopRpcServer have already
    // been called, the endpoint will have already been added but not
    // removed (because there is no way to do it).  If the endpoint is
    // already there, it is ok.

    if (   (RpcStatus != RPC_S_OK)
        && (RpcStatus != RPC_S_DUPLICATE_ENDPOINT)) {

#if DBG
        DbgPrint("RpcServerUseProtseqW failed! rpcstatus = %u\n",RpcStatus);
#endif
        goto CleanExit;
    }

    RpcStatus = RpcServerRegisterIf(InterfaceSpecification, 0, 0);

CleanExit:
    if ( Endpoint != NULL ) {
        LocalFree(Endpoint);
    }

    return( I_RpcMapWin32Status(RpcStatus) );
}


NTSTATUS
RpcpStartRpcServer(
    IN  LPWSTR              InterfaceName,
    IN  RPC_IF_HANDLE       InterfaceSpecification
    )

/*++

Routine Description:

    Starts an RPC Server, adds the address (or port/pipe), and adds the
    interface (dispatch table).

Arguments:

    InterfaceName - points to the name of the interface.

    InterfaceSpecification - Supplies the interface handle for the
        interface which we wish to add.

Return Value:

    NT_SUCCESS - Indicates the server was successfully started.

    STATUS_NO_MEMORY - An attempt to allocate memory has failed.

    Other - Status values that may be returned by:

                 RpcServerRegisterIf()
                 RpcServerUseProtseqEp()

    , or any RPC error codes, or any windows error codes that
    can be returned by LocalAlloc.

--*/
{
    RPC_STATUS          RpcStatus;

    EnterCriticalSection(&RpcpCriticalSection);

    RpcStatus = RpcpAddInterface( InterfaceName,
                                  InterfaceSpecification );

    if ( RpcStatus != RPC_S_OK ) {
        LeaveCriticalSection(&RpcpCriticalSection);
        return( I_RpcMapWin32Status(RpcStatus) );
    }

    RpcpNumInstances++;

    if (RpcpNumInstances == 1) {


       // The first argument specifies the minimum number of threads to
       // be created to handle calls; the second argument specifies the
       // maximum number of concurrent calls allowed.  The last argument
       // indicates not to wait.

       RpcStatus = RpcServerListen(1,12345, 1);
       if ( RpcStatus == RPC_S_ALREADY_LISTENING ) {
           RpcStatus = RPC_S_OK;
           }
    }

    LeaveCriticalSection(&RpcpCriticalSection);
    return( I_RpcMapWin32Status(RpcStatus) );
}


NTSTATUS
RpcpDeleteInterface(
    IN  RPC_IF_HANDLE      InterfaceSpecification
    )

/*++

Routine Description:

    Deletes the interface.  This is likely
    to be caused by an invalid handle.  If an attempt to add the same
    interface or address again, then an error will be generated at that
    time.

Arguments:

    InterfaceSpecification - A handle for the interface that is to be removed.

Return Value:

    NERR_Success, or any RPC error codes that can be returned from
    RpcServerUnregisterIf.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = RpcServerUnregisterIf(InterfaceSpecification, 0, 1);

    return( I_RpcMapWin32Status(RpcStatus) );
}


NTSTATUS
RpcpStopRpcServer(
    IN  RPC_IF_HANDLE      InterfaceSpecification
    )

/*++

Routine Description:

    Deletes the interface.  This is likely
    to be caused by an invalid handle.  If an attempt to add the same
    interface or address again, then an error will be generated at that
    time.

Arguments:

    InterfaceSpecification - A handle for the interface that is to be removed.

Return Value:

    NERR_Success, or any RPC error codes that can be returned from
    RpcServerUnregisterIf.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = RpcServerUnregisterIf(InterfaceSpecification, 0, 1);
    EnterCriticalSection(&RpcpCriticalSection);

    RpcpNumInstances--;

    if (RpcpNumInstances == 0)
    {
        //
        // Return value needs to be from RpcServerUnregisterIf() to maintain
        // semantics, so the return values from these are ignored.
        //

        (VOID)RpcMgmtStopServerListening(0);
        (VOID)RpcMgmtWaitServerListen();
    }

    LeaveCriticalSection(&RpcpCriticalSection);

    return (I_RpcMapWin32Status(RpcStatus));
}


NTSTATUS
RpcpStopRpcServerEx(
    IN  RPC_IF_HANDLE      InterfaceSpecification
    )

/*++

Routine Description:

    Deletes the interface and close all context handles associated with it.
    This can only be called on interfaces that use strict context handles
    (RPC will assert and return an error otherwise).

Arguments:

    InterfaceSpecification - A handle for the interface that is to be removed.

Return Value:

    NERR_Success, or any RPC error codes that can be returned from
        RpcServerUnregisterIfEx.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = RpcServerUnregisterIfEx(InterfaceSpecification, 0, 1);
    EnterCriticalSection(&RpcpCriticalSection);

    RpcpNumInstances--;

    if (RpcpNumInstances == 0)
    {
        //
        // Return value needs to be from RpcServerUnregisterIfEx() to
        // maintain semantics, so the return values from these are ignored.
        //

        (VOID)RpcMgmtStopServerListening(0);
        (VOID)RpcMgmtWaitServerListen();
    }

    LeaveCriticalSection(&RpcpCriticalSection);

    return (I_RpcMapWin32Status(RpcStatus));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpcutil\midluser.c ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    MidlUser.c

Abstract:

    This file contains common functions and utilities that the API
    DLLs can use in making remote calls.  This includes the
    MIDL_USER_ALLOCATE functions.

Author:

    Dan Lafferty    danl    06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created
    25-Apr-1991    JohnRo
        Split out MIDL user (allocate,free) into seperate source file, so
        linker doesn't get confused.
    03-July-1991   JimK
        Moved to a common directory so services available to more than just
        LM code.
    03-Dec-1991 JohnRo
        Added MIDL_user_reallocate and MIDL_user_size APIs.  (These are so we
        create the NetApiBufferAllocate, NetApiBufferReallocate, and
        NetApiBufferSize APIs.)
        Also check alignment of allocated data.

--*/

// These must be included first:
#include <nt.h>
#include <ntrtl.h>          // needed for nturtl.h
#include <nturtl.h>         // needed for windows.h
#include <windows.h>        // win32 typedefs
#include <rpc.h>            // rpc prototypes

// These may be included in any order:
#include <align.h>              // POINTER_IS_ALIGNED(), ALIGN_WORST.
#include <ntrpcp.h>            // MIDL_user_allocate(), MIDL_user_free().

#include <winbase.h>            // LocalAlloc


#define LOCAL_ALLOCATION_FLAGS  LMEM_ZEROINIT


PVOID
MIDL_user_allocate (
    IN size_t NumBytes
    )

/*++

Routine Description:

    Allocates storage for RPC transactions.  The RPC stubs will either call
    MIDL_user_allocate when it needs to un-marshall data into a buffer
    that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - The number of bytes to allocate.

Return Value:

    none

Note:


--*/

{
    LPVOID NewPointer;

    NewPointer = LocalAlloc(
            LOCAL_ALLOCATION_FLAGS,
            NumBytes);

    ASSERT( POINTER_IS_ALIGNED( NewPointer, ALIGN_WORST) );

    return (NewPointer);

} // MIDL_user_allocate



VOID
MIDL_user_free (
    IN void *MemPointer
    )

/*++

Routine Description:

    Frees storage used in RPC transactions.  The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - This points to the memory block that is to be released.

Return Value:

    none.

Note:


--*/
{
    ASSERT( POINTER_IS_ALIGNED( MemPointer, ALIGN_WORST) );
    (void) LocalFree(MemPointer);

} // MIDL_user_free

void *
MIDL_user_reallocate(
    IN void * OldPointer OPTIONAL,
    IN size_t NewByteCount
    )
{
    LPVOID NewPointer;  // may be NULL.

    ASSERT( POINTER_IS_ALIGNED( OldPointer, ALIGN_WORST) );


    // Special cases: something into nothing, or nothing into something.
    if (OldPointer == NULL) {

        NewPointer = LocalAlloc(
                LOCAL_ALLOCATION_FLAGS,
                NewByteCount);

    } else if (NewByteCount == 0) {

        (void) LocalFree( OldPointer );
        NewPointer = NULL;

    } else {  // must be realloc of something to something else.

        HANDLE hOldMem;
        HANDLE hNewMem;                     // handle for new (may = old handle)

        hOldMem = LocalHandle( (LPSTR) OldPointer);
        ASSERT(hOldMem != NULL);

        hNewMem = LocalReAlloc(
                hOldMem,                        // old handle
                NewByteCount,                   // new size in bytes
                LOCAL_ALLOCATION_FLAGS |        // flags
                    LMEM_MOVEABLE);             //  (motion okay)
        if (hNewMem == NULL) {
            // BUGBUG: call GetLastError, could be out of memory or error.
            return (NULL);
        }
        NewPointer = (LPVOID) hNewMem;

    } // must be realloc of something to something else

    ASSERT( POINTER_IS_ALIGNED( NewPointer, ALIGN_WORST) );

    return (NewPointer);

} // MIDL_user_reallocate


unsigned long
MIDL_user_size(
    IN void * Pointer
    )
{
    DWORD ByteCount;
    HANDLE hMemory;

    ASSERT( Pointer != NULL );
    ASSERT( POINTER_IS_ALIGNED( Pointer, ALIGN_WORST ) );

    hMemory = LocalHandle( (LPSTR) Pointer );
    ASSERT( hMemory != NULL );

    ByteCount = (DWORD)LocalSize( hMemory );

    ASSERT( ByteCount > 0 );

    return (ByteCount);

} // MIDL_user_size

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\pch.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       pch.cxx
//
//  Contents:   headers to be built into the precompiled header file
//
//              include headers that don't change often in here
//
//--------------------------------------------------------------------------

extern "C"
{
    #include <nt.h>                 //  NT definitions
    #include <ntrtl.h>              //  NT runtime library definitions
    #include <nturtl.h>
}

#include <fileno.hxx>           //  macros to be used with THIS_FILE_NUMBER

#include <netevent.h>
#include <windows.h>            //  Win32 type definitions
#include <windowsx.h>           //  GET_WM_COMMAND_ID
#include <winnetwk.h>

#include <stdio.h>
#include <string.h>

#include <lmcons.h>             //  LAN Manager common definitions
#include <lmerr.h>              //  LAN Manager network error definitions
#include <lmshare.h>
#include <lmsname.h>            //  LAN Manager service names
#include <lmapibuf.h>           //  NetApiBufferFree
#include <lmserver.h>           //  NetServerEnum
#include <lmaccess.h>           //  NetUserGetInfo

#ifndef UNICODE
#define NetpGetDomainName NetpGetDomainNameT
#endif
#include <netlib.h>             //  LAN Man utility routines
#undef NetpGetDomainName
#include <netlibnt.h>           //  NetpNtStatusToApiStatus
#include <netdebug.h>           //  NetpDbgPrint

#include <stdlib.h>
#include <tchar.h>
//#include <tstring.h>            //  Transitional string functions
//#include <icanon.h>             //  I_Net canonicalize functions
//#include <align.h>              //  ROUND_UP_COUNT macro

#include <svcs.h>

//#include <apperr.h>             //  APE_AT_ID_NOT_FOUND
extern "C"
{
    #include <rpcutil.h>            //  Prototypes for MIDL user functions
}

#include <tchar.h>
#include <dsgetdc.h>            // DsGetDcName

#include <cfiletim.hxx>
#include <winldap.h>
#include <new>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpcutil\client.c ===
/*++

Copyright (c) 1990-92  Microsoft Corporation

Module Name:

    client.c

Abstract:

    This file contains commonly used client-side RPC control functions.

Author:

    Dan Lafferty    danl    06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created
    26-Apr-1991 JohnRo
        Split out MIDL user (allocate,free) so linker doesn't get confused.
        Deleted tabs.
    03-July-1991    JimK
        Copied from LM specific file.
    27-Feb-1992 JohnRo
        Fixed heap trashing bug in RpcpBindRpc().

--*/

// These must be included first:
#include <nt.h>         // needed for NTSTATUS
#include <ntrtl.h>      // needed for nturtl.h
#include <nturtl.h>     // needed for windows.h
#include <windows.h>    // win32 typedefs
#include <rpc.h>        // rpc prototypes
#include <ntrpcp.h>

#include <stdlib.h>      // for wcscpy wcscat
#include <tstr.h>       // WCSSIZE


#define     NT_PIPE_PREFIX      TEXT("\\PIPE\\")
#define     NT_PIPE_PREFIX_W        L"\\PIPE\\"



NTSTATUS
RpcpBindRpc(
    IN  LPWSTR               ServerName,
    IN  LPWSTR               ServiceName,
    IN  LPWSTR               NetworkOptions,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    )

/*++

Routine Description:

    Binds to the RPC server if possible.

Arguments:

    ServerName - Name of server to bind with.

    ServiceName - Name of service to bind with.

    pBindingHandle - Location where binding handle is to be placed

Return Value:

    STATUS_SUCCESS - The binding has been successfully completed.

    STATUS_INVALID_COMPUTER_NAME - The ServerName syntax is invalid.

    STATUS_NO_MEMORY - There is not sufficient memory available to the
        caller to perform the binding.

--*/

{
    NTSTATUS Status;
    RPC_STATUS        RpcStatus;
    LPWSTR            StringBinding;
    LPWSTR            Endpoint;
    WCHAR             ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD             bufLen;
    LPWSTR AllocatedServerName = NULL;
    LPWSTR UncServerName = NULL;

    *pBindingHandle = NULL;

    if ( ServerName != NULL ) {
        DWORD ServerNameLength = wcslen(ServerName);

        //
        // Canonicalize the server name
        //

        if ( ServerName[0] == L'\0' ) {
            ServerName = NULL;
            UncServerName = NULL;

        } else if ( ServerName[0] == L'\\' && ServerName[1] == L'\\' ) {
            UncServerName = ServerName;
            ServerName += 2;
            ServerNameLength -= 2;

            if ( ServerNameLength == 0 ) {
                Status = STATUS_INVALID_COMPUTER_NAME;
                goto Cleanup;
            }

        } else {
            AllocatedServerName = LocalAlloc( 0, (ServerNameLength+2+1) * sizeof(WCHAR) );

            if ( AllocatedServerName == NULL ) {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            AllocatedServerName[0] = L'\\';
            AllocatedServerName[1] = L'\\';
            RtlCopyMemory( &AllocatedServerName[2],
                           ServerName,
                           (ServerNameLength+1) * sizeof(WCHAR) );

            UncServerName = AllocatedServerName;
        }


        //
        // If the passed in computer name is the netbios name of this machine,
        //  drop the computer name so we can avoid the overhead of the redir/server/authentication.
        //

        if ( ServerName != NULL && ServerNameLength <= MAX_COMPUTERNAME_LENGTH ) {

            bufLen = MAX_COMPUTERNAME_LENGTH + 1;
            if (GetComputerNameW( ComputerName, &bufLen )) {
                if ( ServerNameLength == bufLen &&
                     _wcsnicmp( ComputerName, ServerName, ServerNameLength) == 0 ) {
                    ServerName = NULL;
                    UncServerName = NULL;
                }
            }

        }

        //
        // If the passed in computer name is the DNS host name of this machine,
        //  drop the computer name so we can avoid the overhead of the redir/server/authentication.
        //

        if ( ServerName != NULL ) {
            LPWSTR DnsHostName;

            //
            // Further canonicalize the ServerName.
            //

            if ( ServerName[ServerNameLength-1] == L'.' ) {
                ServerNameLength -= 1;
            }

            DnsHostName = LocalAlloc( 0, (MAX_PATH+1) * sizeof(WCHAR));

            if ( DnsHostName == NULL) {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            bufLen = MAX_PATH + 1;
            if ( GetComputerNameExW(
                    ComputerNameDnsFullyQualified,
                    DnsHostName,
                    &bufLen ) ) {

                if ( ServerNameLength == bufLen &&
                     _wcsnicmp( DnsHostName, ServerName, ServerNameLength) == 0 ) {
                    ServerName = NULL;
                    UncServerName = NULL;
                }
            }

            LocalFree( DnsHostName );
        }


    }

    // We need to concatenate \pipe\ to the front of the service
    // name.

    Endpoint = (LPWSTR)LocalAlloc(
                    0,
                    sizeof(NT_PIPE_PREFIX_W) + WCSSIZE(ServiceName));
    if (Endpoint == 0) {
       Status = STATUS_NO_MEMORY;
       goto Cleanup;
    }
    wcscpy(Endpoint,NT_PIPE_PREFIX_W);
    wcscat(Endpoint,ServiceName);

    RpcStatus = RpcStringBindingComposeW(0, L"ncacn_np", UncServerName,
                    Endpoint, NetworkOptions, &StringBinding);
    LocalFree(Endpoint);

    if ( RpcStatus != RPC_S_OK ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }


    //
    // Get an actual binding handle.
    //

    RpcStatus = RpcBindingFromStringBindingW(StringBinding, pBindingHandle);
    RpcStringFreeW(&StringBinding);
    if ( RpcStatus != RPC_S_OK ) {
        *pBindingHandle = NULL;
        if ( RpcStatus == RPC_S_INVALID_ENDPOINT_FORMAT ||
             RpcStatus == RPC_S_INVALID_NET_ADDR ) {

            Status = STATUS_INVALID_COMPUTER_NAME;
        } else {
            Status = STATUS_NO_MEMORY;
        }
        goto Cleanup;
    }

    Status = STATUS_SUCCESS;

Cleanup:
    if ( AllocatedServerName != NULL ) {
        LocalFree( AllocatedServerName );
    }
    return Status;
}


NTSTATUS
RpcpUnbindRpc(
    IN RPC_BINDING_HANDLE  BindingHandle
    )

/*++

Routine Description:

    Unbinds from the RPC interface.
    If we decide to cache bindings, this routine will do something more
    interesting.

Arguments:

    BindingHandle - This points to the binding handle that is to be closed.


Return Value:


    STATUS_SUCCESS - the unbinding was successful.

--*/
{
    RPC_STATUS       RpcStatus;

    if (BindingHandle != NULL) {
        RpcStatus = RpcBindingFree(&BindingHandle);
//        ASSERT(RpcStatus == RPC_S_OK);
    }

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\common\common.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       common.cxx
//
//  Contents:   Code common to Tracking (Workstation) Service and
//              Tracking (Server) Service.
//
//  Classes:
//
//  Functions:
//
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:
//
//  Codework:
//
//--------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include "trklib.hxx"
#include "ntlsa.h"  // LsaGetUserName

#if MAX_COMPUTERNAME_LENGTH != 15
#error MAX_COMPUTERNAME_LENGTH assumed to be 15
#endif

//DWORD g_ftIndex;


const TCHAR s_HexGuidString[] = TEXT("%08X%04X%04X%02X%02X%02X%02X%02X%02X%02X%02X");
#define CCH_HEXGUID_STRING (8+4+4+2*8)

EXTERN_C const CLSID CLSID_TrackFile = {0x8790c947, 0xa30b, 0x11d0, {0x8c, 0xab, 0x00, 0xc0, 0x4f, 0xd9, 0x0f, 0x85} };



#if DBG
#define TRK_E_ERROR_MAP(tr,hr) { tr, hr, TEXT(#tr) }
#else
#define TRK_E_ERROR_MAP(tr,hr) { tr, hr }
#endif

// Map of TRK_E_ type error codes to HRESULTs, and in the debug build to strings.

const TrkEMap g_TrkEMap[] =
{
    TRK_E_ERROR_MAP(TRK_S_OUT_OF_SYNC,                            HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR) ),
    TRK_E_ERROR_MAP(TRK_E_CORRUPT_LOG,                            HRESULT_FROM_WIN32(ERROR_INTERNAL_DB_CORRUPTION) ),
    TRK_E_ERROR_MAP(TRK_E_TIMER_REGISTRY_CORRUPT,                 HRESULT_FROM_WIN32(ERROR_REGISTRY_CORRUPT) ),
    TRK_E_ERROR_MAP(TRK_E_REGISTRY_REFRESH_CORRUPT,               HRESULT_FROM_WIN32(ERROR_REGISTRY_CORRUPT) ),
    TRK_E_ERROR_MAP(TRK_E_CORRUPT_IDT,                            HRESULT_FROM_WIN32(ERROR_INTERNAL_DB_CORRUPTION) ),
    TRK_E_ERROR_MAP(TRK_E_DB_CONNECT_ERROR,                       HRESULT_FROM_WIN32(ERROR_INTERNAL_DB_CORRUPTION) ),
    TRK_E_ERROR_MAP(TRK_E_DN_TOO_LONG,                            CO_E_PATHTOOLONG ),
    TRK_E_ERROR_MAP(TRK_E_DOMAIN_COMPUTER_NAMES_TOO_LONG,         HRESULT_FROM_WIN32(ERROR_INVALID_COMPUTERNAME) ),
    TRK_E_ERROR_MAP(TRK_E_BAD_USERNAME_NO_SLASH,                  HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) ),
    TRK_E_ERROR_MAP(TRK_E_UNKNOWN_SID,                            HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) ),
    TRK_E_ERROR_MAP(TRK_E_IMPERSONATED_COMPUTERNAME_TOO_LONG,     HRESULT_FROM_WIN32(ERROR_INVALID_COMPUTERNAME) ),
    TRK_E_ERROR_MAP(TRK_E_UNKNOWN_SVR_MESSAGE_TYPE,               HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR) ),
    TRK_E_ERROR_MAP(TRK_E_FAIL_TEST,                              E_FAIL ),
    TRK_E_ERROR_MAP(TRK_E_DENIAL_OF_SERVICE_ATTACK,               HRESULT_FROM_WIN32(ERROR_RETRY) ),
    TRK_E_ERROR_MAP(TRK_E_SERVICE_NOT_RUNNING,                    HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) ),
    TRK_E_ERROR_MAP(TRK_E_TOO_MANY_UNSHORTENED_NOTIFICATIONS,     HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW) ),
    TRK_E_ERROR_MAP(TRK_E_CORRUPT_CLNTSYNC,                       HRESULT_FROM_WIN32(ERROR_INTERNAL_DB_CORRUPTION) ),
    TRK_E_ERROR_MAP(TRK_E_COMPUTER_NAME_TOO_LONG,                 HRESULT_FROM_WIN32(ERROR_INVALID_COMPUTERNAME) ),
    TRK_E_ERROR_MAP(TRK_E_SERVICE_STOPPING,                       HRESULT_FROM_WIN32(ERROR_NO_TRACKING_SERVICE) ),
    TRK_E_ERROR_MAP(TRK_E_BIRTHIDS_DONT_MATCH,                    HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) ),
    TRK_E_ERROR_MAP(TRK_E_CORRUPT_VOLTAB,                         HRESULT_FROM_WIN32(ERROR_INTERNAL_DB_CORRUPTION) ),
    TRK_E_ERROR_MAP(TRK_E_INTERNAL_ERROR,                         HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR) ),
    TRK_E_ERROR_MAP(TRK_E_PATH_TOO_LONG,                          CO_E_PATHTOOLONG ),
    TRK_E_ERROR_MAP(TRK_E_GET_MACHINE_NAME_FAIL,                  HRESULT_FROM_WIN32(ERROR_INVALID_COMPUTERNAME) ),
    TRK_E_ERROR_MAP(TRK_E_SET_VOLUME_STATE_FAIL,                  HRESULT_FROM_WIN32(ERROR_INTERNAL_DB_CORRUPTION) ),
    TRK_E_ERROR_MAP(TRK_E_VOLUME_ACCESS_DENIED,                   HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) ),
    TRK_E_ERROR_MAP(TRK_S_VOLUME_NOT_FOUND,                       HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) ),
    TRK_E_ERROR_MAP(TRK_S_VOLUME_NOT_OWNED,                       HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) ),
    TRK_E_ERROR_MAP(TRK_E_REFERRAL,                               HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR) ),
    TRK_E_ERROR_MAP(TRK_E_NOT_FOUND,                              HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ),
    TRK_E_ERROR_MAP(TRK_E_UNAVAILABLE,                            HRESULT_FROM_WIN32(ERROR_CONNECTION_UNAVAIL) ),
    TRK_E_ERROR_MAP(TRK_E_TIMEOUT,                                HRESULT_FROM_WIN32(ERROR_SERVICE_REQUEST_TIMEOUT) ),
    TRK_E_ERROR_MAP(TRK_E_VOLUME_QUOTA_EXCEEDED,                  HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_QUOTA) ),
    TRK_E_ERROR_MAP(TRK_S_NOTIFICATION_QUOTA_EXCEEDED,            HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_QUOTA) ),
    TRK_E_ERROR_MAP(TRK_E_SERVER_TOO_BUSY,                        HRESULT_FROM_WIN32(RPC_S_SERVER_TOO_BUSY) ),
    TRK_E_ERROR_MAP(TRK_E_INVALID_VOLUME_ID,                      HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR) ),
    TRK_E_ERROR_MAP(TRK_E_POTENTIAL_FILE_FOUND,                   HRESULT_FROM_WIN32(ERROR_POTENTIAL_FILE_FOUND) ),
    TRK_E_ERROR_MAP(TRK_E_NULL_COMPUTERNAME,                      HRESULT_FROM_WIN32(ERROR_INVALID_COMPUTERNAME) ),
    TRK_E_ERROR_MAP(TRK_E_NOT_FOUND_AND_LAST_VOLUME_NOT_FOUND,    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ),
    TRK_E_ERROR_MAP(TRK_E_NOT_FOUND_BUT_LAST_VOLUME_FOUND,        HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) )
};


//+----------------------------------------------------------------------------
//
//  Function:   GetErrorString
//
//  Synopsis:   Map an TRK_E_ error to a descriptive string.
//
//+----------------------------------------------------------------------------

#if DBG
const TCHAR * GetErrorString(HRESULT hr)
{
    ULONG iError;

    if( S_OK == hr )
        return( TEXT("S_OK") );

    for( iError = 0; iError < sizeof(g_TrkEMap)/sizeof(*g_TrkEMap); iError++ )
    {
        if( g_TrkEMap[iError].tr == hr )
            return( g_TrkEMap[iError].ptszDescription );
    }

    return( TEXT("Not a TRK_E_ error") );
}
#endif

//+----------------------------------------------------------------------------
//
//  Function:   MapTR2HR
//
//  Synopsis:   Map a TRK_E_ type error code to an HRESULT.  If the input is
//              already a non-trk HRESULT, the input will be returned unchanged.
//
//+----------------------------------------------------------------------------

HRESULT MapTR2HR( HRESULT tr )
{
    ULONG iError;
    HRESULT hr = tr;

    if( S_OK == hr )
        return( hr );

    // Convert TRK_E_ error codes into an HRESULT

    for( iError = 0; iError < sizeof(g_TrkEMap)/sizeof(*g_TrkEMap); iError++ )
    {
        if( g_TrkEMap[iError].tr == hr )
        {
            hr = g_TrkEMap[iError].hr;
            break;
        }
    }

    // If this HRESULT is actually an NTSTATUS, then convert it to a Win32
    // error, then back to an HRESULT.

    if( FACILITY_NT_BIT & hr )
    {
        if( STATUS_VOLUME_NOT_UPGRADED == hr )
            hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
        else
            hr = HRESULT_FROM_WIN32( RtlNtStatusToDosError(hr & ~FACILITY_NT_BIT) );
    }

    return( hr );
}




//+----------------------------------------------------------------------------
//
//  HexStringizeGuid
//
//  Optimized conversion from a GUID to a string.
//
//+----------------------------------------------------------------------------

inline void
HexStringizeByte( BYTE b, TCHAR* &rptsz )
{
    static const TCHAR _tszLookup[] = { TEXT("0123456789ABCDEF") };

    *rptsz++ = _tszLookup[ b >> 4 ];
    *rptsz++ = _tszLookup[ b & 0xF ];
}


void
HexStringizeGuid(const GUID &g, TCHAR * & rptsz)
{

    HexStringizeByte( HIGH_BYTE(HIGH_WORD(g.Data1)), rptsz );
    HexStringizeByte( LO_BYTE(HIGH_WORD(g.Data1)), rptsz );
    HexStringizeByte( HIGH_BYTE(LO_WORD(g.Data1)), rptsz );
    HexStringizeByte( LO_BYTE(LO_WORD(g.Data1)), rptsz );

    HexStringizeByte( HIGH_BYTE(g.Data2), rptsz );
    HexStringizeByte( LO_BYTE(g.Data2), rptsz );

    HexStringizeByte( HIGH_BYTE(g.Data3), rptsz );
    HexStringizeByte( LO_BYTE(g.Data3), rptsz );

    for( int i = 0; i < sizeof(g.Data4); i++ )
        HexStringizeByte( g.Data4[i], rptsz );

    *rptsz = TEXT('\0');

}


//+----------------------------------------------------------------------------
//
//  HexUnstringizeGuid
//
//  Convert a string to a GUID.  This is not used as often as HexStringizeGuid,
//  so it uses the CRT.
//
//+----------------------------------------------------------------------------

BOOL
HexUnstringizeGuid(const TCHAR * &ptsz, GUID * pg)
{
    DWORD Data1;
    DWORD Data2;
    DWORD Data3;
    DWORD Data40;
    DWORD Data41;
    DWORD Data42;
    DWORD Data43;
    DWORD Data44;
    DWORD Data45;
    DWORD Data46;
    DWORD Data47;

    if( 11 != _stscanf(  ptsz,
                         s_HexGuidString,
                         &Data1,
                         &Data2,
                         &Data3,
                         &Data40,
                         &Data41,
                         &Data42,
                         &Data43,
                         &Data44,
                         &Data45,
                         &Data46,
                         &Data47))
    {
        return( FALSE );
    }

    pg->Data1     = Data1;
    pg->Data2     = (WORD)Data2;
    pg->Data3     = (WORD)Data3;
    pg->Data4[0]  = (BYTE)Data40;
    pg->Data4[1]  = (BYTE)Data41;
    pg->Data4[2]  = (BYTE)Data42;
    pg->Data4[3]  = (BYTE)Data43;
    pg->Data4[4]  = (BYTE)Data44;
    pg->Data4[5]  = (BYTE)Data45;
    pg->Data4[6]  = (BYTE)Data46;
    pg->Data4[7]  = (BYTE)Data47;

    ptsz += CCH_HEXGUID_STRING;

    return( TRUE );
}

TCHAR *
wcstotcs(TCHAR *ptszBuf, const WCHAR *pwsz)
{
#ifdef UNICODE
    wcscpy(ptszBuf, pwsz);
#else
    wcstombs(ptszBuf, pwsz, (wcslen(pwsz)+1)*sizeof(WCHAR));
#endif
    return(ptszBuf);
}

CHAR *
tcstombs(CHAR *pszBuf, const TCHAR *ptsz)
{
#ifdef UNICODE
    wcstombs(pszBuf, ptsz, (_tcslen(ptsz)+1)*sizeof(CHAR));
#else
    strcpy(pszBuf, ptsz);
#endif
    return(pszBuf);
}

WCHAR *
tcstowcs(WCHAR *pwszBuf, const TCHAR *ptsz)
{
#ifdef UNICODE
    wcscpy(pwszBuf, ptsz);
#else
    mbstowcs(pwszBuf, ptsz, (_tcslen(ptsz)+1)*sizeof(WCHAR));
#endif
    return(pwszBuf);
}

TCHAR *
mbstotcs(TCHAR *ptszBuf, const CHAR *psz)
{
#ifdef UNICODE
    mbstowcs(ptszBuf, psz, (strlen(psz)+1)*sizeof(WCHAR));
#else
    _tcscpy(ptszBuf, psz);
#endif
    return(ptszBuf);
}




DWORD
TrkTimeUnits(const SYSTEMTIME &st)
{
    CFILETIME cft( st );

    // 2**32 * 100e-9 =  429.4967296 seconds
    //
    // 32bit int can last  1844674407371 seconds =  58494.24173551 years

    return( cft.HighDateTime() );
}

DWORD
TrkTimeUnits(const CFILETIME &cft)
{
    // 2**32 * 100e-9 =  429.4967296 seconds
    //
    // 32bit int can last  1844674407371 seconds =  58494.24173551 years

    return( cft.HighDateTime() );
}



#if DBG

void
CMachineId::AssertValid()
{
}

#endif // #if DBG


//+----------------------------------------------------------------------------
//
//  CMachineId::CMachineId( ptsz )
//
//  Instantiate a mcid from a computer name, e.g. "mymachine".
//
//+----------------------------------------------------------------------------

CMachineId::CMachineId(const TCHAR * ptszPath)
{
    HRESULT hr = E_FAIL;
    int nReturn;

    // Zero everything out first
    new(this) CMachineId;

    // Ensure that this isn't a real path, it should
    // have been pre-processed already.

    TrkAssert( _tcslen(ptszPath) < 2
               ||
               ( TEXT('\\') != ptszPath[0]
                 &&
                 TEXT(':') != ptszPath[1]
               )
             );

    // Ensure that it's not too long.
    if (_tcslen(ptszPath) > MAX_COMPUTERNAME_LENGTH )
        TrkRaiseException( TRK_E_COMPUTER_NAME_TOO_LONG );

#ifndef _UNICODE
#error Ansi build not supported.
#endif

    // Convert the Unicode machine name into Ansi, using
    // the OEM code page (the netbios/computer name is always
    // OEM code page, not the Windows Ansi code page).

    nReturn = WideCharToMultiByte( CP_OEMCP, 0,
                                   ptszPath, -1,
                                   _szMachine, sizeof(_szMachine),
                                   NULL, NULL );

    if( 0 == nReturn )
        TrkRaiseLastError();


    TrkLog(( TRKDBG_WARNING, TEXT("Machine name is: %hs (from %s)"),
             _szMachine, ptszPath ));

    Normalize();    // Guarantee a terminator
}


//+----------------------------------------------------------------------------
//
//  CMachineId::CMachineId( type )
//
//  Initialize an mcid.  The type indicates if the mcid should be for the
//  local computer, a DC (possibly doing a rediscovery), or invalid.
//
//+----------------------------------------------------------------------------

CMachineId::CMachineId(MCID_CREATE_TYPE type)
{
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH+1;
    CHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
    int nReturn;

    TrkAssert(type == MCID_LOCAL ||
              type == MCID_INVALID ||
              type == MCID_DOMAIN ||
              type == MCID_DOMAIN_REDISCOVERY ||
              type == MCID_PDC_REQUIRED);

    // Basic initialization
    new(this) CMachineId;

    if (type == MCID_INVALID)
        goto Exit;

    switch (type)
    {
    case MCID_LOCAL:
        {
            WCHAR wszComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];

            // Create an MCID of the local machine
            // We can't call GetComputerNameA, because it uses 
            // RtlUnicodeStringToAnsiString and consequently returns
            // a Windows/Ansi string, when it should be returning an
            // OEM string.

            if (!GetComputerNameW(wszComputerName, &dwSize))
                TrkRaiseException(HRESULT_FROM_WIN32(GetLastError()));

            nReturn = WideCharToMultiByte( CP_OEMCP, 0,
                                           wszComputerName, -1,
                                           szComputerName, sizeof(szComputerName),
                                           NULL, NULL );
            if( 0 == nReturn )
                TrkRaiseLastError();
        }

        break;

    case MCID_DOMAIN:
    case MCID_DOMAIN_REDISCOVERY:
    case MCID_PDC_REQUIRED:

        // Create an MCID for a DC

        DWORD dwErr;
        PDOMAIN_CONTROLLER_INFOW pdci;

        // DsGetDcName gets us the appropriate DC computer name
        // (of the form \\machine).  We call the W version
        // because the A version returns an Ansi string, 
        // rather than an OEM string.

        dwErr = DsGetDcNameW(NULL, NULL, NULL, NULL,
                        DS_RETURN_FLAT_NAME |
                         DS_BACKGROUND_ONLY |
                         DS_DIRECTORY_SERVICE_REQUIRED |
                         DS_WRITABLE_REQUIRED |
                         (type == MCID_DOMAIN_REDISCOVERY ?
                            DS_FORCE_REDISCOVERY : 0 ) |
                         (type == MCID_PDC_REQUIRED ?
                            DS_PDC_REQUIRED : 0 ),
                        &pdci);
        if (dwErr != NO_ERROR)
        {
            TrkRaiseWin32Error(dwErr);
        }

        // Validate the returned name.

        TrkAssert(pdci->DomainControllerName &&
                  pdci->DomainControllerName[0] == L'\\' &&
                  pdci->DomainControllerName[1] == L'\\');

        dwSize = wcslen(pdci->DomainControllerName + 2);
        if ( dwSize + 1 > sizeof(_szMachine))
        {
            NetApiBufferFree(pdci);
            TrkRaiseException(HRESULT_FROM_WIN32(ERROR_INVALID_NAME));
        }

        // Keep the returned name.

        nReturn = WideCharToMultiByte( CP_OEMCP, 0,
                                       &pdci->DomainControllerName[2], -1,
                                       _szMachine, sizeof(_szMachine),
                                       NULL, NULL );
        if( 0 == nReturn )
            TrkRaiseLastError();

        NetApiBufferFree(pdci);

        goto Exit;
    }   // switch

    if (dwSize + 1 <= sizeof(_szMachine))
    {
        strcpy(_szMachine, szComputerName);
        Normalize();
    }
    else
    {
        TrkRaiseException(HRESULT_FROM_WIN32(ERROR_INVALID_NAME));
    }

Exit:

    Normalize();    // Guarantee a terminator
    return;
}


#ifndef UNICODE
extern "C"
NET_API_STATUS
NetpGetDomainName (
    IN  LPWSTR   *ComputerNamePtr);
#endif

//+----------------------------------------------------------------------------
//
//  CMachineId::GetLocalAuthName
//
//  Returns the authentication name for use in secure RPC (to be used in
//  the RpcBindingSetAuthInfo on the server).  The name
//  is of the form DOMAIN\MACHINE$, where DOMAIN is the local domain
//  and MACHINE is the contents of this CMachineId
//
//+----------------------------------------------------------------------------

void
CMachineId::GetLocalAuthName(RPC_TCHAR * ptszAuthName, DWORD cchBuf) const
{
    RaiseIfInvalid();
    
    // To get domain name: if you link to netlib.lib, you can call NetpGetDomainName,
    // which does all the work for you. Or you could copy the code
    // from \nt\private\net\netlib\domname.c

    NET_API_STATUS Status;
    WCHAR * pwszDomain;
    DWORD dwErr;
    PDOMAIN_CONTROLLER_INFOA pdci = NULL;

    __try
    {
        // Get the domain name ...

        Status = NetpGetDomainName(&pwszDomain);
        if (Status != NO_ERROR)
        {
            pwszDomain = NULL;
            TrkRaiseWin32Error(Status);
        }

        // and validate it.

        if (cchBuf < wcslen(pwszDomain) + 1 + strlen(_szMachine) + 1 + 1)
        {
            TrkRaiseException(TRK_E_DOMAIN_COMPUTER_NAMES_TOO_LONG);
        }

        // Copy the domain name then the machine name into the return buffer.

        wcstotcs((TCHAR*)ptszAuthName, pwszDomain);
        _tcscat((TCHAR*)ptszAuthName, TEXT("\\"));
        mbstotcs(_tcschr((TCHAR*)ptszAuthName, 0), _szMachine);
        _tcscat((TCHAR*)ptszAuthName, TEXT("$"));

    }
    __finally
    {
        if (pwszDomain != NULL)
        {
            NetApiBufferFree(pwszDomain);
        }
    }
}

//+----------------------------------------------------------------------------
//
//  GetFileTimeNow
//
//  Get the current FILETIME (UTC).
//
//+----------------------------------------------------------------------------

FILETIME GetFileTimeNow()
{
    SYSTEMTIME st;
    FILETIME ft;

    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    return(ft);
}

//+----------------------------------------------------------------------------
//
//  CDomainRelativeObjId::Stringize
//
//  Stringize a droid.
//
//+----------------------------------------------------------------------------

TCHAR *
CDomainRelativeObjId::Stringize( TCHAR * ptszOutBuf, DWORD cchBuf ) const
{
    TCHAR *ptszBuf = ptszOutBuf;
    _volume.Stringize(ptszBuf);     /*in, out, c++ reference*/
    _object.Stringize(ptszBuf);     /*in, out, c++ reference*/

    TrkAssert(_tcslen(ptszOutBuf) + 1 < cchBuf);

    return(ptszOutBuf);
}



//+----------------------------------------------------------------------------
//
//  CTrkRegistryKey::Delete
//
//  Common code to delete a registry key, relative to _hkey.
//
//+----------------------------------------------------------------------------

LONG
CTrkRegistryKey::Delete( const TCHAR *ptszName )
{
    LONG lRet = 0;
    _cs.Enter();
    __try
    {
        // Open _hkey if it's not already.

        lRet = Open();

        // And delete the value

        if( ERROR_SUCCESS == lRet )
        {
            RegDeleteValue( _hkey, ptszName );
            Close();
        }
    }
    __finally
    {
        _cs.Leave();
    }

    return( lRet );
}


//+----------------------------------------------------------------------------
//
//  CTrkRegistryKey::SetDword
//
//  Set a REG_DWORD value under _hkey.
//
//+---------------------------------------------------------------------------0

LONG
CTrkRegistryKey::SetDword( const TCHAR *ptszName, DWORD dw )
{
    LONG lRet = 0;

    _cs.Enter();
    __try
    {
        // Open _hkey if it's not already

        lRet = Open();

        // And set the value

        if ( ERROR_SUCCESS == lRet )
        {
            lRet = RegSetValueEx(  _hkey,
                                   ptszName,
                                   0,
                                   REG_DWORD,
                                   reinterpret_cast<CONST BYTE *>(&dw),
                                   sizeof(dw) );
            if( ERROR_SUCCESS != lRet )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't set registry value for %s (%lu)"),
                         ptszName, lRet ));
                RegDeleteKey( _hkey, ptszName );
            }

            Close();
        }
    }
    __finally
    {
        _cs.Leave();
    }

    return( lRet );
}


//+----------------------------------------------------------------------------
//
//  CTrkRegistryKey::GetDword
//
//  Get a REG_DWORD value from _hkey.
//
//+---------------------------------------------------------------------------0

LONG
CTrkRegistryKey::GetDword( const TCHAR *ptszName, DWORD *pdwRead, DWORD dwDefault )
{
    LONG lRet;
    DWORD dwRead;
    DWORD cbData = sizeof(*pdwRead);
    DWORD dwType;

    *pdwRead = dwDefault;

    _cs.Enter();
    __try
    {
        // Open _hkey if it's not already.

        lRet = Open();
        if( ERROR_SUCCESS != lRet )
            __leave;


        // Get the DWORD

        lRet = RegQueryValueEx( _hkey, ptszName, 0, &dwType,
                                reinterpret_cast<BYTE*>(&dwRead), &cbData );

        if( ERROR_SUCCESS == lRet )
        {
            // Validate the type

            if( REG_DWORD != dwType || sizeof(dwRead) != cbData )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Wrong type/size (%d/%d) for registry value %s"),
                         dwType, cbData, ptszName ));
                RegDeleteKey( _hkey, ptszName );
            }
            else
            {
                *pdwRead = dwRead;
            }
        }
        else if( ERROR_FILE_NOT_FOUND == lRet
                 ||
                 ERROR_PATH_NOT_FOUND == lRet )
        {
            lRet = ERROR_SUCCESS;
        }
        else
        {
            TrkLog(( TRKDBG_ERROR,
                     TEXT("Couldn't read %s from registry (%lu)"), ptszName, lRet ));
            RegDeleteKey( _hkey, ptszName );
            __leave;
        }
    }
    __finally
    {
        Close();
        _cs.Leave();
    }


    return( lRet );
}


//+----------------------------------------------------------------------------
//
//  ThreadPoolCallbackFunction
//
//  This function is passed as the callback function to
//  RegisterWaitForSingleObjectEx.  The context is a PWorkItem pointer.
//
//  Arguments:
//      [pvWorkItem]
//          The Context parameter from RegisterWaitForSingleObjectEx.
//          Is a PWorkItem*
//      [fTimeout]
//          We always register INFINITE as the timeout, so this value
//          should always be FALSE.
//
//+----------------------------------------------------------------------------

VOID NTAPI
ThreadPoolCallbackFunction( PVOID pvWorkItem, BOOLEAN fTimeout )
{
    SThreadFromPoolState state;
    PWorkItem *pWorkItem = reinterpret_cast<PWorkItem*>(pvWorkItem);

    TrkLog(( TRKDBG_WORKMAN, TEXT("Enter ThreadPoolCallbackFunction for %s (%p/%p)"),
             pWorkItem->_tszWorkItemSig, pWorkItem, *reinterpret_cast<UINT_PTR*>(pWorkItem) ));

    TrkAssert( FALSE == fTimeout );

    // Make sure we never raise back into the thread pool.

    __try
    {
        // Update thread-count stats.  Note that this isn't
        // thread-safe, but for private statistics it's not worth
        // creating a critsec.

        InterlockedIncrement( reinterpret_cast<LONG*>(&g_cThreadPoolThreads) );
        if( g_cThreadPoolThreads > g_cThreadPoolMaxThreads )
            g_cThreadPoolMaxThreads = g_cThreadPoolThreads;

        // Set our necessary thread-specific settings
        state = InitializeThreadFromPool();

        // Process the signal
        pWorkItem->DoWork();
    }
    __except( BREAK_THEN_RETURN( EXCEPTION_EXECUTE_HANDLER ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Unexpected exception on thread pool callback (%08x)"),
                 GetExceptionCode() ));
    }

    TrkLog(( TRKDBG_WORKMAN, TEXT("Exit  ThreadPoolCallbackFunction for %s (%p)"),
             pWorkItem->_tszWorkItemSig, pWorkItem ));

    InterlockedDecrement( reinterpret_cast<LONG*>(&g_cThreadPoolThreads) );

    //IFDBG( TrkRtlCheckForOrphanedCriticalSections( GetCurrentThread() ));

    // Restore the original thread-specific settings
    UnInitializeThreadFromPool( state );
}

// The work item callback function (used for RtlQueueWorkItem)
// just calls to the function above.

VOID NTAPI
ThreadPoolWorkItemFunction( PVOID pvWorkItem )
{
    ThreadPoolCallbackFunction( pvWorkItem, FALSE );
}

//+----------------------------------------------------------------------------
//
//  RunningAsAdministratorHack
//
//  This routine is only used by test/debug hooks.  It checks to see if
//  the thread is running as an administrative user by seeing if we can
//  get write access to the service's parameters key in the registry.
//
//+----------------------------------------------------------------------------

BOOL
RunningAsAdministratorHack()
{
    LONG lResult = 0;
    HKEY hkey = NULL;
    BOOL fReturn = FALSE;

    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            s_tszKeyNameLinkTrack,
                            0,  // Options, reserved must be zero
                            KEY_ALL_ACCESS,
                            &hkey );
    if( ERROR_SUCCESS == lResult )
    {
        fReturn = TRUE;
        RegCloseKey( hkey );
    }

    return( fReturn );

}

//+----------------------------------------------------------------------------
//
//  EnablePrivilege
//
//  Enable the specified privielge in the current access token if
//  it is available.
//
//+----------------------------------------------------------------------------

BOOL
EnablePrivilege( const TCHAR *ptszPrivilegeName )
{
    BOOL fSuccess = FALSE;
    HANDLE hToken = INVALID_HANDLE_VALUE;
    LUID luid;
    TOKEN_PRIVILEGES token_privileges;

    // Get the process token.

    if( !OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &hToken))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed OpenProcessToken (%lu)"), GetLastError() ));
        goto Exit;
    }

    // Look up the name of this privilege.

    if( !LookupPrivilegeValue( (LPTSTR) NULL, ptszPrivilegeName, &luid ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed LookupPrivilegeValue (%lu)"), GetLastError() ));
        goto Exit;
    }

    // Enable the privilege.

    token_privileges.PrivilegeCount = 1;
    token_privileges.Privileges[0].Luid = luid;
    token_privileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges( hToken, FALSE, &token_privileges, sizeof(TOKEN_PRIVILEGES),
                           (PTOKEN_PRIVILEGES) NULL, (PDWORD) NULL);

    // The return value doesn't tell us anything useful.  We have to check GetLastError
    // for ERROR_SUCCESS or ERROR_NOT_ALL_ASSIGNED.

    if( ERROR_SUCCESS != GetLastError() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't adjust process token privileges (%lu)"), GetLastError() ));
        goto Exit;
    }

    fSuccess = TRUE;

Exit:

    if( INVALID_HANDLE_VALUE != hToken )
        CloseHandle( hToken );

    return( fSuccess );

}



#if DBG

CDebugString::CDebugString(const TRKSVR_MESSAGE_TYPE MsgType)
{
    switch(MsgType)
    {
    case old_SEARCH:
        _tcscpy( _tsz, TEXT("old_SEARCH") ); break;
    case SEARCH:
        _tcscpy( _tsz, TEXT("SEARCH") ); break;
    case MOVE_NOTIFICATION:
        _tcscpy( _tsz, TEXT("MOVE_NOTIFICATION") ); break;
    case REFRESH:
        _tcscpy( _tsz, TEXT("REFRESH") ); break;
    case SYNC_VOLUMES:
        _tcscpy( _tsz, TEXT("SYNC_VOLUMES") ); break;
    case DELETE_NOTIFY:
        _tcscpy( _tsz, TEXT("DELETE_NOTIFY") ); break;
    case STATISTICS:
        _tcscpy( _tsz, TEXT("STATISTICS") ); break;
    default:
        _tcscpy( _tsz, TEXT("UNKNOWN") ); break;
    }
}

#endif // #if DBG



#if DBG

CDebugString::CDebugString(LONG VolIndex, const PFILE_NOTIFY_INFORMATION pNotifyInfo )
{
    TCHAR *ptsz = _tsz;
    _tsz[0] = TEXT('\0');

    switch( pNotifyInfo->Action )
    {
    case FILE_ACTION_ADDED:
        _tcscat( _tsz, TEXT("Added ")); break;
    case FILE_ACTION_REMOVED:
        _tcscat( _tsz, TEXT("Removed ")); break;
    case FILE_ACTION_MODIFIED:
        _tcscat( _tsz, TEXT("Modified ")); break;
    case FILE_ACTION_RENAMED_OLD_NAME:
        _tcscat( _tsz, TEXT("Rename old name ")); break;
    case FILE_ACTION_RENAMED_NEW_NAME:
        _tcscat( _tsz, TEXT("Rename new name ")); break;
    case FILE_ACTION_ADDED_STREAM:
        _tcscat( _tsz, TEXT("Added stream ")); break;
    case FILE_ACTION_REMOVED_STREAM:
        _tcscat( _tsz, TEXT("Removed stream ")); break;
    case FILE_ACTION_MODIFIED_STREAM:
        _tcscat( _tsz, TEXT("Modified stream ")); break;
    case FILE_ACTION_REMOVED_BY_DELETE:
        _tcscat( _tsz, TEXT("Removed by delete ")); break;
    case FILE_ACTION_ID_NOT_TUNNELLED:
        _tcscat( _tsz, TEXT("OID not tunnelled ")); break;
    case FILE_ACTION_TUNNELLED_ID_COLLISION:
        _tcscat( _tsz, TEXT("OID tunnel collision ")); break;
    default:
        _stprintf( _tsz, TEXT("Unknown action (0x%x)"), pNotifyInfo->Action ); break;
    }

    ptsz = _tsz + _tcslen(_tsz);

    // The name length for an object ID is always 72
    if( pNotifyInfo->FileNameLength != 72 )
        _stprintf( ptsz, TEXT(" name length=%d"), pNotifyInfo->FileNameLength );
    else
    {
        // Stringize the path of this object ID
        CDomainRelativeObjId droidBirth;
        CObjId objid( FOI_OBJECTID, *(FILE_OBJECTID_INFORMATION*)pNotifyInfo->FileName );

        ptsz[0] = VolChar(VolIndex);
        ptsz[1] = TEXT(':');
        ptsz[2] = TEXT('\0');
        FindLocalPath( VolIndex, objid, &droidBirth, &ptsz[2] );
        ptsz += _tcslen(ptsz);
        ptsz += _stprintf( ptsz, TEXT(" - %c:"), VolChar(VolIndex) );
        _stprintf( ptsz, TEXT("%s"), CDebugString(objid)._tsz );
        ptsz += _tcslen(ptsz);
    }

}

#endif // #if DBG


//+----------------------------------------------------------------------------
//
//  CActiveThreadList::AddCurrent
//
//  Add the current thread to the list of threads maintained by this class.
//
//+----------------------------------------------------------------------------

HRESULT
CActiveThreadList::AddCurrent( )
{
    HRESULT hr = S_OK;
    HANDLE hThread = NULL;

    if( !_cs.IsInitialized() )
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Active thread list critsec not initialized!!!") ));
        return S_OK;
    }

    _cs.Enter();

    if( _cActiveThreads < _cMaxThreads )
    {
        // Add the thread ID at the end of the list.
        _prgdwThreadIDs[ _cActiveThreads++ ] = GetCurrentThreadId();
    }
    else
    {
        // Alloc a larger buffer for the list, then add the thread ID.

        hr = Grow();
        if( SUCCEEDED(hr) )
        {
            _prgdwThreadIDs[ _cActiveThreads++ ] = GetCurrentThreadId();
        }
    }

#if DBG
    if( SUCCEEDED(hr) )
        TrkLog(( TRKDBG_WORKMAN, TEXT("Added thread 0x%x to the active thread list (%d)"),
                 GetCurrentThreadId(), _cActiveThreads ));
#endif

    _cs.Leave();

    return( hr );
}


//+----------------------------------------------------------------------------
//
//  CActiveThreadList::RemoveCurrent
//
//  Remove the current thread ID from the list which is maintained by this
//  class.
//
//+----------------------------------------------------------------------------

HRESULT
CActiveThreadList::RemoveCurrent( )
{
    HRESULT hr = S_OK;
    BOOL fFound = FALSE;
    DWORD dwThreadID = GetCurrentThreadId();

    if( !_cs.IsInitialized() )
        return S_OK;

    _cs.Enter();

    // Search for the current thread's ID in the list.

    for( ULONG i = 0; i < _cActiveThreads; i++ )
    {
        if( _prgdwThreadIDs[ i ] == dwThreadID )
        {
            // We found this thread.  Remove it from the list by copying down
            // all the IDs behind it.

            memcpy( &_prgdwThreadIDs[i], &_prgdwThreadIDs[i+1],
                    (--_cActiveThreads - i) * sizeof(_prgdwThreadIDs[0]) );
            _prgdwThreadIDs[ _cActiveThreads ] = 0;

            TrkLog(( TRKDBG_WORKMAN, TEXT("Removed thread 0x%x from the active thread list (%d)"),
                     dwThreadID, _cActiveThreads ));

            fFound = TRUE;
            break;
        }
    }

    if( !fFound )
    {
        hr = E_FAIL;
        TrkLog(( TRKDBG_WORKMAN, TEXT("CActiveThreadList couldn't remove thread 0x%x, not found"),
                 dwThreadID ));
    }

    _cs.Leave();

    return( hr );
}


//+----------------------------------------------------------------------------
//
//  CActiveThreadList::CancelAllRpc
//
//  Call RpcCancelThread on each of the threads in the list.
//
//+----------------------------------------------------------------------------

void
CActiveThreadList::CancelAllRpc()
{
    if( !_cs.IsInitialized() )
        return;

    _cs.Enter();

    TrkLog(( TRKDBG_WKS|TRKDBG_SVR, TEXT("Canceling all out-going RPCs") ));

    // Loop through the list of threads.

    for( ULONG i = 0; i < _cActiveThreads; i++ )
    {
        TrkAssert( 0 != _prgdwThreadIDs[i] );

        // Get a thread handle for this thread ID.

        HANDLE hThread = OpenThread( THREAD_ALL_ACCESS, FALSE, _prgdwThreadIDs[i] );
        if( NULL == hThread )
        {
            // Nothing we can do about it.  Move on to the next thread.
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open thread 0x%x to cancel RPC (%lu)"),
                     _prgdwThreadIDs[i], GetLastError() ));
            continue;
        }

        // Cancel any out-going RPC on this thread.

        RPC_STATUS rpcstatus = RpcCancelThread( hThread );
        if( RPC_S_OK != rpcstatus )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcCancelThread on %p/0x%x (%lu)"),
                     hThread, _prgdwThreadIDs[i], rpcstatus ));
        }
        else
        {
            TrkLog(( TRKDBG_WORKMAN, TEXT("Canceled RPC on %p/0x%x"),
                     hThread, _prgdwThreadIDs[i] ));
        }

        // Close the thread handle and move on.

        CloseHandle( hThread );
    }

    _cs.Leave();
}



//+----------------------------------------------------------------------------
//
//  CActiveThreadList::Grow
//
//  Private member function to grow the buffer used to hold the thread IDs.
//
//+----------------------------------------------------------------------------


HRESULT
CActiveThreadList::Grow()
{
    // This is a private method, the critsec has already been entered.

    HRESULT hr = S_OK;
    DWORD *prgNew = NULL;
    ULONG cMaxThreads = _cMaxThreads + INCREMENT_ACTIVE_THREAD_LIST;

    prgNew = new DWORD[ cMaxThreads ];
    if( NULL == prgNew )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't grow active thread list") ));
        return( E_OUTOFMEMORY );
    }

    TrkLog(( TRKDBG_WORKMAN, TEXT("Growing active thread list from %d to %d"),
             _cMaxThreads, cMaxThreads ));

    memcpy( prgNew, _prgdwThreadIDs, _cMaxThreads*sizeof(_prgdwThreadIDs[0]) );
    _cMaxThreads = cMaxThreads;
    delete [] _prgdwThreadIDs;
    _prgdwThreadIDs = prgNew;

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\common\config.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation


//+============================================================================
//
//  config.cxx
//
//  Common configuration code for both services, in the form of the
//  CTrkConfiguration base class (inherited by CTrkWksConfiguration and
//  CTrkSvrConfiguration).
//
//+============================================================================


#include <pch.cxx>
#pragma hdrstop

#include "trklib.hxx"

CMultiTsz CTrkConfiguration::_mtszOperationLog;


//+----------------------------------------------------------------------------
//
//  CTrkConfiguration::Initialize
//
//  Open the main key (identified by the global s_tszKeyNameLinkTrack, 
//  which is defined appropriately in trkwks.dll and trksvr.dll).  Then
//  read global values that are applicable to both services:  debug flags,
//  operation log filename, and test flags.
//
//+----------------------------------------------------------------------------

void
CTrkConfiguration::Initialize()
{
    ULONG lResult;
    TCHAR tszConfigurationKey[ MAX_PATH ];

    _fInitialized = TRUE;
    _hkey = NULL;

    // Open the base key

    _tcscpy( tszConfigurationKey, s_tszKeyNameLinkTrack );
    _tcscat( tszConfigurationKey, TEXT("\\") );
    _tcscat( tszConfigurationKey, TEXT("Configuration") );

    lResult = RegOpenKey( HKEY_LOCAL_MACHINE,
                          tszConfigurationKey,
                          &_hkey );
    if( ERROR_SUCCESS != lResult
        &&
        ERROR_PATH_NOT_FOUND != lResult
        &&
        ERROR_FILE_NOT_FOUND != lResult )
    {
        // We'll just make do without any custom configuration, rather than
        // making this a fatal error.

        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open Configuration key (%lu)"), lResult ));
        return;
    }

    // Read values that are common to trkwks & trksvr.

    Read( TRK_DEBUG_FLAGS_NAME, &_dwDebugFlags, TRK_DEBUG_FLAGS_DEFAULT );

    // Copy these flags into the global debug flags (debug.cxx)
    IFDBG( g_grfDebugFlags = _dwDebugFlags; )

    Read( DEBUG_STORE_FLAGS_NAME, &_dwDebugStoreFlags, DEBUG_STORE_FLAGS_DEFAULT );
    Read( TRK_TEST_FLAGS_NAME, &_dwTestFlags, TRK_TEST_FLAGS_DEFAULT );
    Read( OPERATION_LOG_NAME_NAME, &_mtszOperationLog, OPERATION_LOG_NAME_DEFAULT );

}


//+----------------------------------------------------------------------------
//
//  CTrkConfiguration::UnInitialize
//
//  Close the main reg key.
//
//+----------------------------------------------------------------------------

VOID
CTrkConfiguration::UnInitialize()
{
    if( _fInitialized )
    {
        if( NULL != _hkey )
        {
            RegCloseKey( _hkey );
            _hkey = NULL;
        }

        _fInitialized = FALSE;
    }
}


//+----------------------------------------------------------------------------
//
//  CTrkConfiguration::Read( REG_DWORD )
//
//  Read a DWORD configuration parameter.  Return the defaulut value 
//  if not found.
//
//+----------------------------------------------------------------------------

VOID
CTrkConfiguration::Read( const TCHAR *ptszName, DWORD *pdwValue, DWORD dwDefault ) const
{
    *pdwValue = dwDefault;

    if( NULL != _hkey )
    {
        LONG lResult;
        DWORD dwType;
        DWORD dwValue;
        DWORD cbValue = sizeof(dwValue);

        lResult = RegQueryValueEx(  const_cast<HKEY>( _hkey ),
                                    ptszName,
                                    NULL,
                                    &dwType,
                                    (LPBYTE) &dwValue,
                                    &cbValue);
        if( ERROR_SUCCESS == lResult )
        {
            if( REG_DWORD == dwType )
            {
                *pdwValue = dwValue;
                TrkLog(( TRKDBG_MISC, TEXT("RegConfig: %s = 0x%x (%lu)"),
                         ptszName, dwValue, dwValue ));
            }
            else
                TrkLog(( TRKDBG_ERROR,
                          TEXT("Registry value is wrong type") ));

        }
        else if( ERROR_FILE_NOT_FOUND != lResult )
        {
            TrkLog(( TRKDBG_ERROR,
                     TEXT("Couldn't read %s from registry (%lu)"), ptszName, lResult ));
        }
    }

    return;

}



//+----------------------------------------------------------------------------
//
//  CTrkConfiguration::Read( REG_SZ )
//
//  Read a string configuration parameter.  Return the default value
//  if not found.
//
//+----------------------------------------------------------------------------

VOID
CTrkConfiguration::Read( const TCHAR *ptszName, ULONG *pcbValue, TCHAR *ptszValue, TCHAR *ptszDefault ) const
{
    ULONG cbIn = *pcbValue;
    LONG lResult = ERROR_PATH_NOT_FOUND;
    DWORD dwType;

    if( NULL != _hkey )
    {
        lResult = RegQueryValueEx(  const_cast<HKEY>( _hkey ),
                                    ptszName,
                                    NULL,
                                    &dwType,
                                    (LPBYTE) ptszValue,
                                    pcbValue );
    }

    if( ERROR_SUCCESS != lResult || REG_SZ != dwType )
    {
        *pcbValue = 0;
        memset( ptszValue, 0, cbIn );
        _tcscpy( ptszValue, ptszDefault );
    }
    else
    {
        TrkLog(( TRKDBG_MISC, TEXT("RegConfig: %s = %s"), ptszName, ptszValue ));
    }

    return;

}



//+----------------------------------------------------------------------------
//
//  CTrkConfiguration::Read( REG_MULTI_SZ )
//
//  Read a string array configuration parameter.  Return the default
//  value if not found.
//
//+----------------------------------------------------------------------------

VOID
CTrkConfiguration::Read( const TCHAR *ptszName, CMultiTsz *pmtszValue, TCHAR *ptszDefault ) const
{
    ULONG cbValue = pmtszValue->MaxSize();
    LONG lResult = ERROR_PATH_NOT_FOUND;
    DWORD dwType;

    // Read the value

    if( NULL != _hkey )
    {
        lResult = RegQueryValueEx(  const_cast<HKEY>( _hkey ),
                                    ptszName,
                                    NULL,
                                    &dwType,
                                    pmtszValue->GetBuffer(),
                                    &cbValue );
    }

    // Check the type

    if( ERROR_SUCCESS != lResult || (REG_SZ != dwType && REG_MULTI_SZ != dwType) )
    {
        // It didn't exist, or was the wrong type.  Return the default.

        *pmtszValue = ptszDefault;
#if DBG
        if( ERROR_FILE_NOT_FOUND != lResult && ERROR_PATH_NOT_FOUND != lResult )
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't read %s from registry (%lu)"), ptszName, lResult ));
#endif
    }
    else
    {
        // We found the value.  Dump the first three values to dbgout.

        #if DBG
        TCHAR tszValues[ sizeof(*pmtszValue) ];
        _tcscpy( tszValues, TEXT("") );

        for( int i = 0; i < 3; i++ )
        {
           if( i >= (int) pmtszValue->NumStrings() )
              break;

           _tcscat( tszValues, (*pmtszValue)[i] );
           _tcscat( tszValues, TEXT(" ") );
        }

        if( 3 < (int) pmtszValue->NumStrings() )
           _tcscat( tszValues, TEXT("...") );

        TrkLog(( TRKDBG_MISC, TEXT("RegConfig: %s = %s"),
                 ptszName, tszValues ));
        #endif // #if DBG
    }

    return;
}



//+----------------------------------------------------------------------------
//
//  CTrkConfiguration::Write( REG_DWORD )
//
//  Write a DWORD configuration parameter.
//
//+----------------------------------------------------------------------------

BOOL
CTrkConfiguration::Write( const TCHAR *ptszName, DWORD dwValue ) const
{
    if( NULL != _hkey )
    {
        LONG lResult;
        DWORD cbValue = sizeof(dwValue);

        lResult = RegSetValueEx(  const_cast<HKEY>( _hkey ),
                                  ptszName,
                                  NULL,
                                  REG_DWORD,
                                  (LPBYTE) &dwValue,
                                  cbValue);
        if( ERROR_SUCCESS != lResult )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't write %s to registry (%lu)"), ptszName, lResult ));
            return( FALSE );
        }
    }

    return( TRUE );

}



//+----------------------------------------------------------------------------
//
//  CTrkConfiguration::Write( REG_SZ )
//
//  Write a string configuration parameter.
//
//+----------------------------------------------------------------------------

BOOL
CTrkConfiguration::Write( const TCHAR *ptszName, const TCHAR *ptszValue ) const
{
    LONG lResult = ERROR_PATH_NOT_FOUND;

    if( NULL != _hkey )
    {
        lResult = RegSetValueEx(  const_cast<HKEY>( _hkey ),
                                  ptszName,
                                  NULL,
                                  REG_SZ,
                                  (LPBYTE) ptszValue,
                                  _tcslen(ptszValue) + 1 );
    }

    if( ERROR_SUCCESS != lResult )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't write %s to registry (%lu)"), ptszName, lResult ));
        return( FALSE );
    }

    return( TRUE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\common\debug.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       debug.cxx
//
//  Contents:   Debug support.
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------



#include "pch.cxx"
#pragma hdrstop

#include "trklib.hxx"
#include <stdio.h>      //  vsprintf

#if DBG == 1

//CFailPoint * CFailPoint::g_pList = NULL;

#define TRKSVC_LOG_FILE              TEXT("%SystemRoot%\\debug\\trksvcs.log")



CHAR                     TrkGlobalDebugBuffer[ 1024];     //  arbitrary
DWORD                    TrkGlobalDebug;

HANDLE                   g_LogFile = INVALID_HANDLE_VALUE;

// This critical section is used to serialize simultaneous dbgout calls.
CRITICAL_SECTION         g_csDebugOut;
LONG                     g_cCritSecInit = 0;

CHAR                     g_szDebugBuffer[ 1024];     //  arbitrary
TCHAR                    g_tszDebugBuffer[ 1024 ];
ULONG                    g_grfDebugFlags = 0;
ULONG                    g_grfLogFlags = 0;
CHAR                     g_szModuleName[ MAX_PATH ] = { "" };
LONG                     g_cInitializations = 0;


VOID TrkDebugDelete( VOID)
{
    // This isn't thread safe, so we won't ever delete it.
    // It just means there's a one-time leak in the chk build
    // when the service gets stopped.

    //if( 0 == InterlockedDecrement( &g_cCritSecInit ))
      //  DeleteCriticalSection( &g_csDebugOut);

    InterlockedDecrement(&g_cInitializations);

    if( INVALID_HANDLE_VALUE != g_LogFile )
    {
        CloseHandle( g_LogFile );
        g_LogFile = INVALID_HANDLE_VALUE;
    }

}


VOID TrkDebugCreate( ULONG grfLogFlags, CHAR *pszModuleName )
{
    TCHAR       Buffer[ MAX_PATH];
    DWORD       Length;

    if( 1 < InterlockedIncrement(&g_cInitializations) ) return;

    strncpy( g_szModuleName, pszModuleName, sizeof(g_szModuleName) );
    g_szModuleName[ sizeof(g_szModuleName) - 1 ] = TEXT('\0');

    if( 1 == InterlockedIncrement( &g_cCritSecInit ))
        InitializeCriticalSection( &g_csDebugOut );

    if( (TRK_DBG_FLAGS_WRITE_TO_FILE | TRK_DBG_FLAGS_APPEND_TO_FILE) & grfLogFlags )
    {
        //
        //  Length returned by ExpandEnvironmentalStrings includes terminating
        //  NULL byte.
        //

        Length = ExpandEnvironmentStrings( TRKSVC_LOG_FILE, Buffer, sizeof( Buffer));
        if ( Length == 0) {
            TrkLog(( TRKDBG_ERROR, TEXT("Error=%d"), GetLastError()));
            return;
        }
        if ( Length > sizeof( Buffer) ||  Length != _tcslen(Buffer) + 1) {
            Beep(2000,2000);
            TrkLog(( TRKDBG_ERROR, TEXT("Buffer=%x, Length = %d"), Buffer, Length));
            return;
        }

        g_LogFile = CreateFile( Buffer,
                                      GENERIC_WRITE,
                                      FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                                      NULL,
                                      (TRK_DBG_FLAGS_APPEND_TO_FILE & grfLogFlags)
                                        ? OPEN_ALWAYS
                                        : CREATE_ALWAYS,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL );

        if ( g_LogFile == INVALID_HANDLE_VALUE ) {
            TCHAR tsz[ 2 * MAX_PATH ];
            _stprintf( tsz, TEXT("Cannot open %s (%lu)\n"),
                      Buffer, GetLastError() );
            OutputDebugString( tsz );
            return;
        }

        if( TRK_DBG_FLAGS_APPEND_TO_FILE & grfLogFlags )
        {
            //
            // Position the log file at the end
            //
            (VOID) SetFilePointer( g_LogFile,
                                   0,
                                   NULL,
                                   FILE_END );
        }
        else
        {
            // 
            // Truncate the file
            //

            SetFilePointer( g_LogFile, 0, NULL, FILE_BEGIN );
            SetEndOfFile( g_LogFile );
        }

    }

    g_grfLogFlags = grfLogFlags;
    
}


VOID TrkLogRoutine(
    IN      DWORD       DebugFlag,
    IN      LPTSTR      Format,
    ...
    )
{
    LONG l = GetLastError();

    va_list Arguments;
    va_start( Arguments, Format );

    TrkLogErrorRoutineInternal( DebugFlag, NULL, Format, Arguments );

    SetLastError(l);
}

VOID TrkLogErrorRoutine(
    IN      DWORD       DebugFlag,
    IN      HRESULT     hr,
    IN      LPTSTR      Format,
    ...
    )
{
    CHAR szHR[8];
    va_list Arguments;

    va_start( Arguments, Format );
    sprintf( szHR, "%08X", hr );

    TrkLogErrorRoutineInternal( DebugFlag, szHR, Format, Arguments );
}


VOID TrkLogErrorRoutineInternal(
    IN      DWORD       DebugFlag,
    IN      LPSTR       pszHR,
    IN      LPTSTR      Format,
    IN      va_list     Arguments
    )

{
//    va_list     arglist;
    ULONG       length = 0;
    DWORD       BytesWritten;
    ULONG       iFormatStart = 0;

    // Skip if TrkDebugCreate hasn't been called yet.
    if( 0 == g_grfLogFlags )
        return;

    //
    // If we aren't debugging this type of message and it's not an
    // error, then we're done.
    //

    if( !( (g_grfDebugFlags | TRKDBG_ERROR ) & DebugFlag ) )
        return;

    //
    //  vsprintf isn't multithreaded + we don't want to intermingle output
    //  from different threads.  Therefore we can use just a single output
    //  debug buffer.
    //

    EnterCriticalSection( &g_csDebugOut );

    //
    // Prefix the line with any newlines
    //

    for( iFormatStart = 0; TEXT('\n') == Format[iFormatStart]; iFormatStart++ )
        g_szDebugBuffer[length++] = '\n';

    //
    // Put our name/time at the beginning of the line.
    //

    CFILETIME cftLocal(0);
    cftLocal.SetToLocal();

    SYSTEMTIME st = static_cast<SYSTEMTIME>( cftLocal );

    length += (ULONG) sprintf( &g_szDebugBuffer[length],
                               "[%s/%02d%02d%02d.%03d:%03x] ",
                               g_szModuleName,
                               st.wHour, st.wMinute, st.wSecond, st.wMilliseconds,
                               GetCurrentThreadId() );

    //
    // Put the information requested by the caller onto the line
    //

    _vstprintf( g_tszDebugBuffer, &Format[iFormatStart], Arguments );
    tcstombs( &g_szDebugBuffer[length], g_tszDebugBuffer );
    length = strlen( g_szDebugBuffer );

    if( NULL != pszHR )
        length += (ULONG) sprintf( &g_szDebugBuffer[length], "  %s", pszHR );

    length += (ULONG) sprintf( &g_szDebugBuffer[length], "\n" );

    TrkAssert(length <= sizeof(g_szDebugBuffer));



    if( TRK_DBG_FLAGS_WRITE_TO_DBG & g_grfLogFlags )
        (void) OutputDebugStringA( (PCH) g_szDebugBuffer);

    if( TRK_DBG_FLAGS_WRITE_TO_STDOUT & g_grfLogFlags )
        printf( (PCH) g_szDebugBuffer );

    if( (TRK_DBG_FLAGS_WRITE_TO_FILE | TRK_DBG_FLAGS_APPEND_TO_FILE) & g_grfLogFlags )
    {
        if ( INVALID_HANDLE_VALUE == g_LogFile
             ||
             !WriteFile( g_LogFile,
                         g_szDebugBuffer,
                         length,
                         &BytesWritten,
                         NULL ) )
        {
            (void) OutputDebugStringA( (PCH) g_szDebugBuffer);
        }

    }


    LeaveCriticalSection( &g_csDebugOut );

}

VOID TrkAssertFailed(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
/*++

    Have my own version of RtlAssert so debug versions of netlogon really assert on
    free builds.

--*/
{
    char Response[ 2 ];

    for ( ; ; ) {
        DbgPrint( "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
                  Message ? Message : "",
                  FailedAssertion,
                  FileName,
                  LineNumber
                );

        DbgPrompt( "Break, Ignore, terminate Process, Sleep 30 seconds, or terminate Thread (bipst)? ",
                   Response, sizeof( Response));
        switch ( toupper(Response[0])) {
        case 'B':
            DbgBreakPoint();
            break;
        case 'I':
            return;
            break;
        case 'P':
            NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
            break;
        case 'S':
            Sleep( 30000L);
            break;
        case 'T':
            NtTerminateThread( NtCurrentThread(), STATUS_UNSUCCESSFUL );
            break;
        }
    }

    DbgBreakPoint();
    NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
}



typedef void (*PFNWin4AssertEx)( char const *pszFile, int iLine, char const *pszMsg);

VOID TrkAssertFailedDlg(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{
    static HINSTANCE hinstOLE32 = NULL;
    static PFNWin4AssertEx pfnWin4AssertEx = NULL;

    if( NULL == hinstOLE32 )
    {
        hinstOLE32 = LoadLibraryEx( TEXT("ole32.dll"), NULL, 0 );
        if( NULL == hinstOLE32 )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't load ole32.dll for Win4AssertEx (%#08x)"),
                     GetLastError() ));
            return;
        }
    }

    if( NULL == pfnWin4AssertEx )
    {
        pfnWin4AssertEx = (PFNWin4AssertEx) GetProcAddress( hinstOLE32, "Win4AssertEx" );
        if( NULL == pfnWin4AssertEx )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get Win4AssertEx from ole32.dll (%#08x)"),
                     GetLastError() ));
            return;
        }
    }

    pfnWin4AssertEx( (char*) FileName, (int) LineNumber, (char*) FailedAssertion );

    return;

}



VOID TrkLogRuntimeList( IN PCHAR Comment)
{
    PLIST_ENTRY     pListEntry;

    TrkLog(( TRKDBG_ERROR, TEXT("%s\n"), Comment));
}



HANDLE hTestThread = NULL;

/*
DWORD WINAPI _TestWorkManagerThread(LPVOID pParam)
{
    __try
    {
        ((CWorkManager*) pParam)->WorkManagerThread();
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        TrkAssert(GetExceptionCode() != STATUS_ACCESS_VIOLATION);
    }
    return(0);
}


void
StartTestWorkerThread(CWorkManager * pwm)
{
    DWORD dwThreadId;
    hTestThread = CreateThread( NULL,
                          0,
                          _TestWorkManagerThread,
                          pwm,
                          0,
                          &dwThreadId );
    TrkAssert(hTestThread != NULL);

    // Hack:  make sure the work manager has a chance to init
    Sleep( 500 );

}


void
WaitTestThreadExit()
{
    if (hTestThread != NULL)
    {
        WaitForSingleObject(hTestThread, INFINITE);
        CloseHandle(hTestThread);
    }
}
*/

#endif // #if DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\common\fileops.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       fileops.cxx
//
//  Contents:   OBJID and file operations
//
//  Classes:
//
//  Functions:
//
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:
//
//  Codework:
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "trklib.hxx"
#include "mountmgr.h"



//+-------------------------------------------------------------------
//
//  Function:   ConvertToNtPath, public
//
//  Synopsis:   Convert the path in the buffer to an Nt style path, in the
//              other buffer.
//
//  Arguments:  [pwszVolumePath] -- In. Buffer containing Dos style path.
//              [pwszNtPath]  -- Out. Buffer for new path.
//              [cwcBuf]      -- In. Size of buffer in wide chars.
//
//  Returns:    Return value is length in characters (not including nul)
//              of converted path.  Zero if not completely converted.
//
//--------------------------------------------------------------------

unsigned
ConvertToNtPath(const TCHAR *ptszVolumePath, WCHAR *pwszNtPath, ULONG cwcBuf)
{
    unsigned i=12;  // for \DosDevices\   .
    WCHAR *pwszWrite = pwszNtPath;
    ULONG cwcLeft = cwcBuf;
    BOOL  fDone = FALSE;
    unsigned ret;

    if (ptszVolumePath[0] == TEXT('\\') && ptszVolumePath[1] == TEXT('\\'))
    {
        i+=3;
        ptszVolumePath++;

        // i = 15
        // ptszVolumePath -----\ .
        //                     |
        //                     v
        //                    \\billmo2\rootd
        //
    }

    if (cwcLeft > i)
    {
        memcpy(pwszWrite, L"\\DosDevices\\UNC", i*sizeof(WCHAR));

        pwszWrite += i;
        cwcLeft   -= i;

        while (cwcLeft)
        {
            *pwszWrite = (WCHAR) *ptszVolumePath;
            cwcLeft --;

            if (*ptszVolumePath == 0)
            {
                // we just copied a null
                fDone = TRUE;
                break;
            }
            else
            {
                ptszVolumePath++;
                pwszWrite++;
            }
        }
    }

    ret = (fDone ? (unsigned)(pwszWrite - pwszNtPath) : 0);

    return(ret);
}



//+----------------------------------------------------------------------------
//
//  IsLocalObjectVolume
//
//  Determine if the specified volume (specified as a mount manager volume
//  name) is capable of object IDs (i.e. NTFS5).  The tracking service
//  currently only supports fixed volumes, so this routine really only
//  returns true for fixed NTFS5 volumes.
//
//  The input is a "volume name", as opposed to a volume device name
//  (i.e. it has a trailing slash).  E.g.:
//
//       \\?\Volume{8baec120-078b-11d2-824b-000000000000}\ 
//
//  The proper way to implement this routine is to open the filesystem
//  on this device, query for its FS attributes, and check for the
//  supports-object-ids bit.  But the ugly side-effect of this is that
//  we end up opening every volume on the system during system bootup,
//  including the floppies.  So as a workaround, we look up the device
//  in the object directory first, and only bother to check for the
//  bit on "\Device\HarddiskVolume" type devices.
//
//+----------------------------------------------------------------------------

const TCHAR *s_tszHarddiskDevicePrefix = TEXT("\\Device\\HarddiskVolume");

BOOL
IsLocalObjectVolume( const TCHAR *ptszVolumeName )
{


    TCHAR tszTargetSymLink[ MAX_PATH ];
    TCHAR tszVolumeDeviceName[ MAX_PATH + 1 ];
    ULONG cchVolumeName;
    DWORD dwFsFlags = 0;

    // Validate the volume name prefix.
    //TrkAssert( !_tcsnicmp( TEXT("\\\\?\\"), ptszVolumeName, 4 ) );

    /*
    // For the QueryDosDevice call, we need to strip the "\\?\"
    // from the beginning of the name.

    cchVolumeName = _tcslen( &ptszVolumeName[4] );

    memcpy( tszVolumeDeviceName, &ptszVolumeName[4],
            cchVolumeName * sizeof(TCHAR) );

    // Also for the QueryDosDevice call, we nee to strip the
    // whack from the end of the name.

    TrkAssert( TEXT('\\') == tszVolumeDeviceName[cchVolumeName-1] );
    tszVolumeDeviceName[ cchVolumeName - 1 ] = TEXT('\0');


    // Query for this device's symlink.

    if( !QueryDosDevice( tszVolumeDeviceName,
                         tszTargetSymLink,
                         sizeof(tszTargetSymLink)/sizeof(TCHAR) ))
    {
        TrkLog(( TRKDBG_MISC,
                 TEXT("Couldn't query %s for symlink in obj dir (%lu)"),
                 tszVolumeDeviceName, GetLastError() ));
        return FALSE;
    }


    TrkLog(( TRKDBG_MISC,
             TEXT("Volume %s is %s"),
             ptszVolumeName, tszTargetSymLink ));

    // Is this a harddisk?  I.e., does the symlink have the \Device\HarddiskVolume
    // prefix?

    if( _tcsnicmp( tszTargetSymLink,
                   s_tszHarddiskDevicePrefix,
                   _tcslen(s_tszHarddiskDevicePrefix) ))
    {
        // No, assume therefore that it's not an object (NTFS5) volume.
        return FALSE;
    }
    

    // Otherwise, is it a fixed harddisk?
    else if( DRIVE_FIXED != GetDriveType(ptszVolumeName) )
        // No - we don't currently handle removeable media.
        return FALSE;
    */

    if( DRIVE_FIXED != GetDriveType(ptszVolumeName) )
        return FALSE;

    // Finally, check to see if it supports object IDs
    if( GetVolumeInformation(ptszVolumeName,
                             NULL,
                             0,
                             NULL,
                             NULL,
                             &dwFsFlags,
                             NULL,
                             0 )
         &&
         (dwFsFlags & FILE_SUPPORTS_OBJECT_IDS) )
    {
        // Yes, it's a fixed harddisk that supports OIDs
        return TRUE;
    }
    else
        // It's a fixed harddisk, but it doesn't supports
        // OIDs (it's probably FAT).
        return FALSE;
}


#if 0
BOOL
IsLocalObjectVolume( const TCHAR *ptszVolumeDeviceName )
{
    BOOL fObjectIdCapable = FALSE;
    TCHAR tszVol[4];
    TCHAR tszRootOfVolume[MAX_PATH+1];
    DWORD dw;
    DWORD dwFsFlags;
    UINT DriveType;

    _tcscpy( tszRootOfVolume, ptszVolumeDeviceName );
    _tcscat( tszRootOfVolume, TEXT("\\") );

    // Get the drive type

    DriveType = GetDriveType(tszRootOfVolume);

    // Return TRUE if the drive type is fixed, and if
    // the filesystem attribute bit is set that indicates
    // that object IDs are supported.

    return ( ( DRIVE_FIXED == DriveType
               /*|| DRIVE_REMOVABLE == DriveType*/
             )
             &&
             GetVolumeInformation(tszRootOfVolume,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &dwFsFlags,
                                 NULL,
                                 0 )
             &&
             (dwFsFlags & FILE_SUPPORTS_OBJECT_IDS) );
}
#endif

//+-------------------------------------------------------------------
//
//  Function:   MapLocalPathToUNC
//
//  Synopsis:   Convert a volume-relative path to a UNC path.
//              Since there could be multiple UNC paths which cover
//              this local path, that which provides greatest
//              coverage & access will be returns (e.g., "C:\"
//              covers more than "C:\Docs".
//
//  Arguments:  [tszLocalPath] (in)
//                  A local path, including the drive letter.
//              [ptszUNC] (out)
//                  An equivalent UNC path which provides the
//                  greatest access.
//              [cbMaxUnc] (in)
//                  The size of the buffer pointed to be ptszUNC.
//
//  Returns:    [HRESULT]
//
//  Exceptions: None
//
//--------------------------------------------------------------------


HRESULT
MapLocalPathToUNC( RPC_BINDING_HANDLE IDL_handle,
                   const TCHAR *ptszLocalPath,
                   TCHAR *ptszUNC, 
                   ULONG cbMaxUnc )
{
    //  -----
    //  Locals
    //  ------

    HRESULT hr = S_OK;  // Return value

    CShareEnumerator cShareEnum;

    ULONG ulBestMerit;
    TCHAR tszBestShare[ MAX_PATH + 1 ];
    TCHAR tszBestPath[ MAX_PATH + 1 ];
    ULONG cchBestPath = 0;
    ULONG cch;


    //  ----------
    //  Initialize
    //  ----------
    __try
    {
        // Open an enumeration of the disk shares on this machine.
        // If we early-exit due to an exception, it will clean itself up.
        // NOTE:  The ptszLocalPath is only provided until we can fix
        // GetAccessLevel so that it doesn't have to do opens.

        cShareEnum.Initialize( IDL_handle );

        ulBestMerit = cShareEnum.GetMinimumMerit() - 1;

        //  --------------------
        //  Enumerate the shares
        //  --------------------

        while( cShareEnum.Next() )
        {
            // If the name or path is too long, skip it now

            if( _tcslen(cShareEnum.GetShareName()) > MAX_PATH
                ||
                _tcslen(cShareEnum.GetSharePath()) > MAX_PATH )
            {
                continue;
            }

            // Does this share cover the local path?

            if( cShareEnum.CoversDrivePath( ptszLocalPath ))
            {
                // Is this a better share than anything we've seen so far?

                if( cShareEnum.GetMerit() > ulBestMerit )
                {
                    // We have a new best share.  We'll hang on to both
                    // the share and it's path.

                    _tcscpy( tszBestShare, cShareEnum.GetShareName() );
                    _tcscpy( tszBestPath, cShareEnum.GetSharePath() );

                    ulBestMerit = cShareEnum.GetMerit();
                    cchBestPath = cShareEnum.QueryCCHSharePath();
                }
            }   // if( cenumShares.QueryCCHSharePath() < cchBestPath )
        }   // while( cenumShares.Next() )


        // Did we find a share which encompasses the file?

        if( 0 == cchBestPath )
        {
            hr = HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND );
            goto Exit;
        }

        //  -------------------
        //  Create the UNC path
        //  -------------------

        // Leave room for a terminator
        cbMaxUnc--;

        // Get the machine name

        cch = _tcslen( cShareEnum.GetMachineName() );

        if( cch * sizeof(WCHAR) > cbMaxUnc )
            TrkRaiseWin32Error(ERROR_PATH_NOT_FOUND);
        _tcscpy( ptszUNC, cShareEnum.GetMachineName() );

        cbMaxUnc -= cch * sizeof(WCHAR);

        // Add the share name

        cch = _tcslen(tszBestShare) + 1;
        if( cch * sizeof(WCHAR) > cbMaxUnc )
            TrkRaiseWin32Error(ERROR_PATH_NOT_FOUND);
        _tcscat( ptszUNC, TEXT("\\") );
        _tcscat( ptszUNC, tszBestShare );
        cbMaxUnc -= cch * sizeof(WCHAR);

        // Add a whack if necessary before the path

        if ( ptszLocalPath[ cchBestPath ] != TEXT('\\') )
        {
            if( cbMaxUnc/sizeof(WCHAR) < 2 )
                TrkRaiseWin32Error(ERROR_PATH_NOT_FOUND);
            _tcscat( ptszUNC, TEXT("\\") );
            cbMaxUnc -= sizeof(WCHAR);
        }

        // Finally, add on the local path

        cch = _tcslen( &ptszLocalPath[cchBestPath] );
        if( cch * sizeof(WCHAR) > cbMaxUnc )
            TrkRaiseWin32Error(ERROR_PATH_NOT_FOUND);
        _tcscat( ptszUNC, &ptszLocalPath[ cchBestPath ] );

        hr = S_OK;
    }   // __try

    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }


    //  ----
    //  Exit
    //  ----

Exit:

    if( FAILED(hr) )
    {
        TrkLog(( TRKDBG_ERROR,
                 TEXT("MapLocalPathToUNC returned hr=%08x"), hr ));
    }

    return( hr );

}   // MapLocalPathToUNC



//+-------------------------------------------------------------------
//
//  Function:   OpenVolume, public
//
//  [ptszVolumeDeviceName] is a Win32 name for a volume in the NT
//  namespace, *without* the trailing whack.  E.g.
//
//      \\.\A:
//
//  if you append a whack on the end of this, it opens the root
//  of the volume, not the volume itself.
//
//--------------------------------------------------------------------

NTSTATUS
OpenVolume( const TCHAR *ptszVolumeDeviceName, HANDLE * phVolume )
{
    NTSTATUS            status;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;
    IO_STATUS_BLOCK Iosb;
    HANDLE hDirect = NULL;

    // First, open the file in direct mode (by only opening it for
    // file_read_attributes).  This will open the volume but not cause
    // any filesystem to be loaded.  This was done for the following scenario:
    // A volume gets dismounted and goes offline for some reason.  Trkwks
    // gets the dismount notification and closes its handles.  Something
    // attempt to open the volume, and IO loads the RAW filesystem (if no other
    // filesystem can be loaded, IO always loads the rawfs).  This causes a
    // mount notification.  Trkwks gets this mount notification and
    // tries to reopen its handles.  It can open the volume handle, but it's
    // just to the rawfs.  It tries to open the oid index, but IO returns an
    // invalid parameter error.  Trkwks then closes all of its handles again,
    // including the volume handle.  When all handles are closed on rawfs in this
    // way, it automatically dismounts (without sending a dismount notification).
    // The problem is, when trkwks opened the volume handle, it mounted the 
    // volume (rawfs) and caused a new mount notification, which it now receives
    // and tries to open its handles again.  In this way trkwks goes into an
    // infinite loop.
    //
    // The solution is to open the volume direct, and see if it's really mounted.
    // If not, don't try to open the volume.

    status = TrkCreateFile(
                ptszVolumeDeviceName,
                FILE_READ_ATTRIBUTES,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                &hDirect );

    if( !NT_SUCCESS(status) ) goto Exit;
    

    // Check for the current mount status.

    status = NtQueryVolumeInformationFile(
                hDirect,
                &Iosb,
                &DeviceInfo,
                sizeof(DeviceInfo),
                FileFsDeviceInformation );

    NtClose( hDirect );
    if( !NT_SUCCESS(status) ) goto Exit;

    if( !(FILE_DEVICE_IS_MOUNTED & DeviceInfo.Characteristics) )
    {
        // This volume isn't currently mounted, and we don't want to be
        // the ones to mount it.

        TrkLog(( TRKDBG_WARNING, TEXT("Attempted to open dismounted volume (%s)"),
                 ptszVolumeDeviceName ));
        status = STATUS_VOLUME_DISMOUNTED;
        goto Exit;
    }

    // The filesystem is already mounted, so it's OK for us to
    // open our handle.

    status = TrkCreateFile(
                ptszVolumeDeviceName,
                FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                phVolume );

Exit:

    TrkAssert(NT_SUCCESS(status) || *phVolume == NULL);
    return(status);
}




//+----------------------------------------------------------------------------
//
//  Function:   CheckVolumeWriteProtection
//
//  Check the filesystem attributes on a volume to see if it's write-
//  protected.
//
//+----------------------------------------------------------------------------

NTSTATUS
CheckVolumeWriteProtection( const TCHAR *ptszVolumeDeviceName,
                            BOOL *pfWriteProtected )
{
    NTSTATUS status;
    HANDLE hVolume = NULL;
    IO_STATUS_BLOCK Iosb;
    FILE_FS_ATTRIBUTE_INFORMATION FsAttrs;

    status = OpenVolume( ptszVolumeDeviceName, &hVolume );
    if( !NT_SUCCESS(status) )
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Couldn't open volume - 0x%08x (%s)"),
                 status, ptszVolumeDeviceName ));
        goto Exit;
    }

    status = NtQueryVolumeInformationFile(
                hVolume,
                &Iosb,
                &FsAttrs,
                sizeof(FsAttrs),
                FileFsAttributeInformation );
    if( !NT_SUCCESS(status) && STATUS_BUFFER_OVERFLOW != status)
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Couldn't query fs attrs - 0x%08x (%s)"),
                 status, ptszVolumeDeviceName ));
        goto Exit;
    }

    if( FILE_READ_ONLY_VOLUME & FsAttrs.FileSystemAttributes )
        *pfWriteProtected = TRUE;
    else
        *pfWriteProtected = FALSE;

    status = STATUS_SUCCESS;

Exit:

    if( NULL != hVolume )
        NtClose( hVolume );

    return status;

}


//+-------------------------------------------------------------------
//
//  Function:   MapVolumeDeviceNameToIndex
//
//  Map a volume device name, as defined by the mount manager, to a
//  zero-relative index, where 0 represents 'A:'.  A "volume device name"
//  is e.g.
//
//      \\?\Volume{96765fc3-9c72-11d1-b93d-000000000000}
//
//  a "volume name" is the volume device name post-pended with a
//  whack (it is in this form that the mount manager returns the name).
//
//+-------------------------------------------------------------------

/*
LONG
MapVolumeDeviceNameToIndex( TCHAR *ptszVolumeDeviceName )
{
    // BUGBUG:  Rewrite this to use IOCTL_MOUNTMGR_QUERY_POINTS

    TCHAR tszVolumeNameOfCaller[ CCH_MAX_VOLUME_NAME + 1 ];
    TCHAR tszVolumeNameForRoot[ CCH_MAX_VOLUME_NAME + 1 ];
    TCHAR tszRoot[] = TEXT("*:\\");

    // Convert the caller's volume name to a volume device name.

    _tcscpy( tszVolumeNameOfCaller, ptszVolumeDeviceName );
    _tcscat( tszVolumeNameOfCaller, TEXT("\\") );


    // Loop through all the possible drive letters, trying to find the
    // caller's volume name.

    for( LONG iVol = 0; iVol < NUM_VOLUMES; iVol++ )
    {
        tszRoot[0] = TEXT('A') + iVol;

        if( GetVolumeNameForVolumeMountPoint( tszRoot, tszVolumeNameForRoot, sizeof(tszVolumeNameForRoot) ))
        {
            // We have a real volume with a name.  See if it's the name we seek.
            if( 0 == _tcscmp( tszVolumeNameForRoot, tszVolumeNameOfCaller ))
                return( iVol );
        }

    }


    return( -1 );

}
*/

LONG
MapVolumeDeviceNameToIndex( TCHAR *ptszVolumeDeviceName )
{
    HANDLE                  hMountManager = INVALID_HANDLE_VALUE;
    BYTE                    MountPointBuffer[ sizeof(MOUNTMGR_MOUNT_POINT) + MAX_PATH ];
    PMOUNTMGR_MOUNT_POINT   pMountPoint = (PMOUNTMGR_MOUNT_POINT) MountPointBuffer;
    BYTE                    MountPointsBuffer[ MAX_PATH ];
    PMOUNTMGR_MOUNT_POINTS  pMountPoints = (PMOUNTMGR_MOUNT_POINTS) MountPointsBuffer;
    BOOL                    fQuerySuccessful = FALSE;
    ULONG                   cbMountPoints = 0;
    ULONG                   cbVolumeDeviceName;
    LONG                    iVol = -1;

    __try
    {
        // Open the mount manager.

        hMountManager = CreateFileW( MOUNTMGR_DOS_DEVICE_NAME, GENERIC_READ,
                                     FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                                     OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                                     INVALID_HANDLE_VALUE );
        if( INVALID_HANDLE_VALUE == hMountManager )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open MountManager") ));
            TrkRaiseLastError();
        }

        // Initialize the input (pMountPoint)

        pMountPoint = (PMOUNTMGR_MOUNT_POINT) MountPointBuffer;
        memset(pMountPoint, 0, sizeof(MountPointBuffer) );

        cbVolumeDeviceName = sizeof(TCHAR) * _tcslen(ptszVolumeDeviceName);

        // Load the name of the device for which we wish to query.  We convert
        // this from Win32 "\\?\" form to NT "\??\" form.

        pMountPoint->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
        pMountPoint->DeviceNameLength = cbVolumeDeviceName;

        _tcscpy( (TCHAR*)( MountPointBuffer + pMountPoint->DeviceNameOffset ),
                 TEXT("\\??") );
        _tcscat( (TCHAR*)( MountPointBuffer + pMountPoint->DeviceNameOffset ),
                 &ptszVolumeDeviceName[3] );


        // Query the mount manager for info on this device.

        ULONG cQueryAttempts = 0; // Guarantee no infinite loop.
        fQuerySuccessful = FALSE;
        cbMountPoints = sizeof(MountPointsBuffer);

        while( !fQuerySuccessful )
        {
            // Check for an infinite loop.
            if( cQueryAttempts > 100 )
            {
                TrkLog(( TRKDBG_ERROR,
                         TEXT("Failed IOCTL_MOUNTMGR_QUERY_POINTS (%lu, loop detect)"), GetLastError() ));
                TrkRaiseLastError();
            }

            // Query the mount manager

            fQuerySuccessful = DeviceIoControl( hMountManager,
                                                IOCTL_MOUNTMGR_QUERY_POINTS,
                                                pMountPoint,
                                                sizeof(MountPointBuffer),
                                                pMountPoints,
                                                cbMountPoints,
                                                &cbMountPoints,
                                                NULL);

            // Did it work?
            if( fQuerySuccessful )
                // Yes, we got the info.
                break;

            // Otherwise, do we need a bigger out-buf?

            else if( ERROR_MORE_DATA == GetLastError() )
            {
                // Yes, the size of the necessary out-buf is at
                // the beginning of the out-buf we provided.

                cbMountPoints = pMountPoints->Size;

                // The initial guess buffer is on the stack, not heap.

                if( (PMOUNTMGR_MOUNT_POINTS) MountPointsBuffer != pMountPoints )
                    delete [] pMountPoints;

                pMountPoints = (PMOUNTMGR_MOUNT_POINTS) new BYTE[ cbMountPoints ];
                if( NULL == pMountPoints )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Couldn't alloc pMountPoints") ));
                    TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );
                }
            }

            // Of it's not a more-data error, then there's nothing more we can do.
            else
                break;

        }   // while( !fQuerySuccessful )

        // Raise if the query failed.

        if( !fQuerySuccessful )
        {
            TrkLog(( TRKDBG_WARNING,
                     TEXT("Failed IOCTL_MOUNTMGR_QUERY_POINTS (%lu)"), GetLastError() ));
            TrkRaiseLastError();
        }
                        

        // Loop through the returned mount points.  There should be 2: one of
        // the form "\??\Volume{8baec120-078b-11d2-824b-000000000000}",
        // and one of the form "\DosDevices\C:" (for the C drive).

        static const WCHAR wszSymLinkPrefix[] = { L"\\DosDevices\\" };
        ULONG cchSymLinkPrefix = sizeof(wszSymLinkPrefix)/sizeof(WCHAR) - 1;

        for( int i = 0; i < pMountPoints->NumberOfMountPoints; ++i )
        {
            PMOUNTMGR_MOUNT_POINT pOutPoint = &pMountPoints->MountPoints[i];
            WCHAR wc;
            const WCHAR *pwszSymLinkName
                = (PWCHAR)( (BYTE*)pMountPoints + pOutPoint->SymbolicLinkNameOffset );

            if( pOutPoint->SymbolicLinkNameLength/sizeof(WCHAR) >= 14
                &&
                0 == wcsncmp( pwszSymLinkName, wszSymLinkPrefix, cchSymLinkPrefix )
                &&
                pOutPoint->UniqueIdLength )

            {
                wc = pwszSymLinkName[ cchSymLinkPrefix ];

                if( TEXT('a') <= wc && wc <= TEXT('z') )
                {
                    iVol = wc - TEXT('a');
                    break;
                }
                else if( TEXT('A') <= wc && wc <= TEXT('Z') )
                {
                    iVol = wc - TEXT('A');
                    break;
                }

            }
        }


    }
    __finally
    {
        if( INVALID_HANDLE_VALUE != hMountManager )
            CloseHandle( hMountManager );

        if( (PMOUNTMGR_MOUNT_POINTS) MountPointsBuffer != pMountPoints
            &&
            NULL != pMountPoints )
        {
            delete [] pMountPoints;
        }

    }

    return iVol;
}



//+----------------------------------------------------------------------------
//
//  IsSystemVolumeInformation
//
//  Is the given volume-relative path under the "System Volume Information"
//  directory?
//
//  Note:  This is hard-coded for now, but will be replaced by a forthcoming
//  Rtl export.
//
//+----------------------------------------------------------------------------

BOOL
IsSystemVolumeInformation( const TCHAR *ptszPath )
{
    return 0 == _wcsnicmp( s_tszSystemVolumeInformation,
                           ptszPath,
                           wcslen(s_tszSystemVolumeInformation)/sizeof(WCHAR) );
}




//+-------------------------------------------------------------------
//
//  OpenFileById
//
//  Given an NTFS5 object ID, open the file and returns its handle.
//
//--------------------------------------------------------------------

NTSTATUS
OpenFileById( const TCHAR  *ptszVolumeDeviceName,
              const CObjId  &oid,
              ACCESS_MASK   AccessMask,
              ULONG         ShareAccess,
              ULONG         AdditionalCreateOptions,
              HANDLE        *ph)
{

    NTSTATUS    status;


    // A buffer for the id-based path.  This path is the volume's
    // path followed by the 16 byte object ID

    TCHAR tszPath[ MAX_PATH + 1 ] = { TEXT('\0') }; // Init to prevent prefix error.

    // Parameters for NtCreateFile
    OBJECT_ATTRIBUTES   ObjectAttr;
    IO_STATUS_BLOCK     IoStatus;

    UNICODE_STRING      uPath;
    PVOID               pFreeBuffer = NULL;


    // Compose a buffer with a Win32-style name with a dummy value where
    // the object ID will go (use "12345678" for now).  It's Win32-style
    // in that we will pass it to RtlDosPathNameToNtPathName below.

    TrkAssert( NULL != ptszVolumeDeviceName );
    _tcscpy( tszPath, ptszVolumeDeviceName );
    _tcscat( tszPath, TEXT("\\") );
    _tcscat( tszPath, TEXT("12345678") );

    // Convert to the NT path to this volume

    if( !RtlDosPathNameToNtPathName_U( tszPath, &uPath, NULL, NULL ))
    {
        status = STATUS_OBJECT_NAME_INVALID;
        goto Exit;
    }
    pFreeBuffer = uPath.Buffer;

    // Put in the real object ID in place of the "12345678"

    TrkAssert( oid.Size() == 16 );
    oid.SerializeRaw( reinterpret_cast<BYTE*>(&uPath.Buffer[ (uPath.Length-oid.Size()) / sizeof(uPath.Buffer[0]) ]) );


    // And open the file

    InitializeObjectAttributes( &ObjectAttr,              // Structure
                                &uPath,                   // Name (identifier)
                                OBJ_CASE_INSENSITIVE,     // Attributes
                                0,                        // Root
                                0 );                      // Security


    status =   NtCreateFile( ph,
                             AccessMask,
                             &ObjectAttr, &IoStatus,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             ShareAccess,
                             FILE_OPEN,
                             FILE_OPEN_BY_FILE_ID | FILE_OPEN_NO_RECALL | FILE_SYNCHRONOUS_IO_NONALERT
                                | AdditionalCreateOptions,
                             NULL,
                             0 );
    if( !NT_SUCCESS(status) )
    {
        *ph = NULL;
        goto Exit;
    }


    //  ----
    //  Exit
    //  ----

Exit:

    if( !NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND )
    {
        TrkLog(( TRKDBG_MISC, TEXT("OpenFileById returned status=%08X"), status ));
    }

    if( NULL != pFreeBuffer )
        RtlFreeHeap( RtlProcessHeap(), 0, pFreeBuffer );

    return( status );

}   // OpenFileById



//+----------------------------------------------------------------------
//
//  Function:   SetVolId
//
//  Synopsis:   Set the volume ID on a local volume.
//
//  Returns:    NTSTATUS
//
//  Note:       Setting the volid (and changing a volume's lable) triggers
//              a GUID_IO_VOLUME_CHANGE PNP device event.
//
//+----------------------------------------------------------------------------

NTSTATUS
SetVolId( const TCHAR *ptszVolumeDeviceName, const CVolumeId &volid )
{
    NTSTATUS status = STATUS_SUCCESS;

    UNICODE_STRING  usPath;
    PVOID pFreeBuffer = NULL;

    HANDLE hVol = NULL;
    FILE_FS_OBJECTID_INFORMATION file_fs_objectid_information;

    OBJECT_ATTRIBUTES ObjectAttr;
    IO_STATUS_BLOCK IoStatus;

    EnableRestorePrivilege();

    // Generate the NT path name to this volume.  The VolumeDeviceName has
    // no trailing whack, so we'll be opening the volume, not the root dir of
    // the volume.

    if( !RtlDosPathNameToNtPathName_U( ptszVolumeDeviceName, &usPath, NULL, NULL ))
    {
        status = STATUS_OBJECT_NAME_INVALID;
        goto Exit;
    }
    pFreeBuffer = usPath.Buffer;

    // Fill in an ObjectAttributes for the NtCreateFile request

    InitializeObjectAttributes( &ObjectAttr,              // Structure
                                &usPath,                  // Name (identifier)
                                OBJ_CASE_INSENSITIVE,     // Attributes
                                0,                        // Root
                                0 );                      // Security

    // Open the volume.
    // You wouldn't think that FILE_SHARE_WRITE would be necessary, but
    // without it we encounter a STATUS_UNABLE_TO_DELETE_SECTION error.
    // Also, we must use NtOpenFile; if we use NtCreateFile(...,FILE_OPEN,...),
    // we get a STATUS_ACCESS_DENIED error on the NtSetVolumeInformationFile
    // call.

    status =   NtOpenFile( &hVol,
                           SYNCHRONIZE | FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                           &ObjectAttr, &IoStatus,
                           FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                           FILE_SYNCHRONOUS_IO_NONALERT
                           );


    if( !NT_SUCCESS(status) )
    {
        hVol = NULL;
        TrkLog(( TRKDBG_ERROR, TEXT("SetVolId couldn't open the volume %s (status=%08x)"),
                 ptszVolumeDeviceName, status ));
        goto Exit;
    }

    // Set the Volume ID

    file_fs_objectid_information = volid;

    status = NtSetVolumeInformationFile( hVol, &IoStatus,
                                         &file_fs_objectid_information,
                                         sizeof(file_fs_objectid_information),
                                         FileFsObjectIdInformation );
    if( !NT_SUCCESS(status) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("SetVolId couldn't set volume ID on volume %s (status=%08x)"),
                 ptszVolumeDeviceName, status ));
        goto Exit;
    }


    //  ----
    //  Exit
    //  ----

Exit:

    if( NULL != hVol )
        NtClose( hVol );

    if( NULL != pFreeBuffer )
        RtlFreeHeap( RtlProcessHeap(), 0, pFreeBuffer );

    return( status );
}





//+----------------------------------------------------------------------------
//
//  Function:   TrkCreateFile
//
//  Synopsis:   Creates a file using NtCreateFile.
//
//  Arguments:  [pwszCompleteDosPath] (in)
//                  The path to open, in 'dos' format as opposed to
//                  NT format (e.g. "\\m\s\f" rather than "\DosDevices\..."
//              [AccessMask] (in)
//                  Required access.  SYNCRHONIZE is requested automatically.
//              [Attributes] (in)
//              [ShareAccess] (in)
//              [CreationDisposition] (in)
//              [CreateOptions] (in)
//              [lpSecurityAttributes] (in)
//              [ph] (out)
//                  The resulting file handle. Always set to NULL when function
//                  is entered.
//
//  Returns:    NTSTATUS
//
//+----------------------------------------------------------------------------

NTSTATUS
TrkCreateFile( const WCHAR           *pwszCompleteDosPath,
               ACCESS_MASK            AccessMask,
               ULONG                  Attributes,
               ULONG                  ShareAccess,
               ULONG                  CreationDisposition,
               ULONG                  CreateOptions,
               LPSECURITY_ATTRIBUTES  lpSecurityAttributes,
               HANDLE                 *ph)
{

    NTSTATUS    status;

    // Parameters for NtCreateFile
    OBJECT_ATTRIBUTES   ObjectAttr;
    IO_STATUS_BLOCK     IoStatus;

    // E.g. "\??\D:\..."
    UNICODE_STRING      uPath;
    PVOID               pFreeBuffer = NULL;

    *ph = NULL;

    //  -------------
    //  Open the File
    //  -------------

    // Generate the NT path name

    if( !RtlDosPathNameToNtPathName_U( pwszCompleteDosPath, &uPath, NULL, NULL ))
    {
        status = STATUS_OBJECT_NAME_INVALID;
        goto Exit;
    }
    pFreeBuffer = uPath.Buffer;


    // Set up the ObjectAttributes

    InitializeObjectAttributes( &ObjectAttr,              // Structure
                                &uPath,                   // Name (identifier)
                                OBJ_CASE_INSENSITIVE,     // Attributes
                                0,                        // Root
                                0 );                      // Security


    if( NULL != lpSecurityAttributes )
    {
        ObjectAttr.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle )
        {
            ObjectAttr.Attributes |= OBJ_INHERIT;
        }
    }

    // Create/Open the file

    status =   NtCreateFile( ph,
                             AccessMask | SYNCHRONIZE,
                             &ObjectAttr, &IoStatus,
                             NULL,
                             Attributes,
                             ShareAccess,
                             CreationDisposition,
                             CreateOptions, // | FILE_SYNCHRONOUS_IO_NONALERT,
                             NULL,  // No EA buffer
                             0 );
    if( !NT_SUCCESS(status) )
    {
        *ph = NULL;
        goto Exit;
    }


    //  ----
    //  Exit
    //  ----

Exit:

    if( NULL != pFreeBuffer )
        RtlFreeHeap( RtlProcessHeap(), 0, pFreeBuffer );

    return( status );

}   // TrkCreateFile



//+----------------------------------------------------------------------------
//
//  Function:   FindLocalPath
//
//  Synopsis:   Given a volume index and a file ObjectId, return a volume-relative
//              path to the file, and return the file's Birth ID.  The returned
//              path does not have the drive letter prefix.
//
//  Inputs:     [ptszVolumeDeviceName] (in)
//                  The volume on which to search.
//              [objid] (in)
//                  The ObjectID to search for on this volume.
//              [pdroidBirth] (out)
//                  If the function is successful, returns the found file's
//                  birth ID.
//              [ptszLocalPath] (out)
//                  If the function is successful, returns the volume-relative
//                  path (includes the drive letter).
//
//  Returns:    [NTSTATUS]
//
//  Exceptions: None.
//
//+----------------------------------------------------------------------------


NTSTATUS
FindLocalPath( IN  const TCHAR *ptszVolumeDeviceName,
               IN  const CObjId &objid,
               OUT CDomainRelativeObjId *pdroidBirth,
               OUT TCHAR *ptszLocalPath )
{
    //  ------
    //  Locals
    //  ------

    NTSTATUS status;
    IO_STATUS_BLOCK Iosb;
    HANDLE hFile = NULL;


    // Open the file

    status = OpenFileById(  ptszVolumeDeviceName,
                            objid,
                            SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                            0,
                            &hFile);
    if( !NT_SUCCESS(status) )
    {
        hFile = NULL;
        goto Exit;
    }

    // Get the file's birth ID

    status = GetBirthId( hFile, pdroidBirth );
    if( !NT_SUCCESS(status) ) goto Exit;

    // Get the volume-relative path

    status = QueryVolRelativePath( hFile, ptszLocalPath );
    if( !NT_SUCCESS(status) ) goto Exit;

    // When ptszLocalPath is a root directory, no relative path
    // will be found. i.e. "d:" will remain "d:", instead of "d:\", which is
    // what we want. We have to put the '\' in here.

    if(TEXT('\0') == ptszLocalPath[0])
    {
        ptszLocalPath[0] = TEXT('\\');
        ptszLocalPath[1] = TEXT('\0');
    }

    //  ----
    //  Exit
    //  ----

Exit:

    if( NULL != hFile )
        NtClose( hFile );

    if( !NT_SUCCESS(status)
        &&
        STATUS_OBJECT_PATH_NOT_FOUND != status
        &&
        STATUS_OBJECT_NAME_NOT_FOUND != status
        &&
        STATUS_INVALID_PARAMETER != status  // Happens when the objid is really the volid
      )
    {
        TrkLog(( TRKDBG_MISC,
                 TEXT("FindLocalPath returned status=%08X"), status ));
    }

    return( status );
}



//+----------------------------------------------------------------------------
//
//  Function:   GetDroids
//
//  Synopsis:   Get the current and birth domain-relative object IDs from
//              a file.  If rgoEnum is RGO_GET_OBJECT_ID, then an object ID
//              will be generated if necessary.  If RGO_READ_OBJECT_ID is
//              specified, and the file doesn't already have an object ID,
//              then STATUS_OBJECT_NAME_NOT_FOUND will be returned.
//
//  Inputs:     [tszFile] (in)
//                  The file who's object ID is to be retrieved.
//              [pdroidCurrent] (out)
//                  The file's CDomainRelativeObjId.
//              [pdroidBirth] (out)
//                  The file's birth CDomainRelativeObjId
//              [rgoEnum] (in)
//                  RGO_READ_OBJECTID => Read the object IDs, return
//                      STATUS_OBJECT_NAME_NOT_FOUND if none exist.
//                  RGO_GET_OBJECTID => Get the object IDs, generating
//                      and setting if necessary.
//
//  Returns:    NTSTATUS, outputs zero on error
//
//  Exceptions: None
//
//+----------------------------------------------------------------------------

NTSTATUS
GetDroids( HANDLE hFile,
           CDomainRelativeObjId *pdroidCurrent,
           CDomainRelativeObjId *pdroidBirth,
           RGO_ENUM rgoEnum )
{
    NTSTATUS status = STATUS_SUCCESS;
                            // Filled by NtQueryInformationFile
    FILE_OBJECTID_BUFFER fobOID;
    IO_STATUS_BLOCK Iosb;

    CDomainRelativeObjId droidCurrent;
    CDomainRelativeObjId droidBirth;

    pdroidCurrent->Init();
    pdroidBirth->Init();

    //  -----------------
    //  Get the Object ID
    //  -----------------

    // Use the file handle to get the file's Object ID

    memset( &fobOID, 0, sizeof(fobOID) );

    status = NtFsControlFile(
                 hFile,
                 NULL,
                 NULL,
                 NULL,
                 &Iosb,
                 RGO_READ_OBJECTID == rgoEnum ? FSCTL_GET_OBJECT_ID : FSCTL_CREATE_OR_GET_OBJECT_ID,
                 NULL,
                 0,
                 &fobOID,               // Out buffer
                 sizeof(fobOID) );      // Out buffer size
    if( !NT_SUCCESS(status) )
        goto Exit;

    //  ---------------
    //  Load the Droids
    //  ---------------


    droidBirth.InitFromFOB( fobOID );
    droidBirth.GetVolumeId().Normalize();

    status = droidCurrent.InitFromFile( hFile, fobOID );
    if( !NT_SUCCESS(status) ) goto Exit;

    *pdroidCurrent = droidCurrent;
    *pdroidBirth = droidBirth;


    //  ----
    //  Exit
    //  ----

Exit:

    if( !NT_SUCCESS(status)
        &&
        STATUS_OBJECT_NAME_NOT_FOUND != status      // Ignore non-link source
        &&
        STATUS_INVALID_DEVICE_REQUEST != status     // Ignore e.g. FAT
        &&
        STATUS_VOLUME_NOT_UPGRADED != status        // Ignore NTFS4
        )
    {
        TrkLog(( TRKDBG_ERROR,
                 TEXT("GetDroids returned ntstatus=%08X"), status ));
    }

    return( status );
}


// Following is a wrapper that takes a filename, opens the file,
// and then calls the above GetDroids with the file handle.

NTSTATUS
GetDroids( const TCHAR *ptszFile,
           CDomainRelativeObjId *pdroidCurrent,
           CDomainRelativeObjId *pdroidBirth,
           RGO_ENUM rgoEnum )
{
    HANDLE hFile = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    __try
    {
        status = TrkCreateFile( ptszFile, SYNCHRONIZE | FILE_READ_ATTRIBUTES, FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                FILE_OPEN,
                                FILE_OPEN_NO_RECALL | FILE_SYNCHRONOUS_IO_NONALERT,
                                NULL, &hFile );
        if( !NT_SUCCESS(status ))
        {
            hFile = NULL;
            goto Exit;
        }

        status = GetDroids( hFile, pdroidCurrent, pdroidBirth, rgoEnum );
    }
    __finally
    {
        if( NULL != hFile )
            NtClose( hFile );
    }

Exit:

    return( status );

}



//+----------------------------------------------------------------------------
//
//  Function:   SetObjId
//
//  Synopsis:   Sets an Object ID (GUID) on a file.
//
//  Inputs:     [ptszFile] (in)
//                  The file to be indexed.
//              [objid] (in)
//                  The ID to put on the file.
//              [droidBirth] (in)
//                  The BirthId to put on the file.
//
//  Returns:    NTSTATUS
//
//  Exceptions: None
//
//+----------------------------------------------------------------------------

NTSTATUS
SetObjId( const HANDLE hFile,
          CObjId objid,
          const CDomainRelativeObjId &droidBirth )
{

    //  --------------
    //  Initialization
    //  --------------

    NTSTATUS status = STATUS_SUCCESS;

    FILE_OBJECTID_BUFFER fobOID;
    IO_STATUS_BLOCK IoStatus;

    // Initialize the request buffer

    memset( &fobOID, 0, sizeof(fobOID) );

    droidBirth.SerializeRaw( fobOID.ExtendedInfo );
    objid.SerializeRaw( fobOID.ObjectId );


    // Send the FSCTL

    status = NtFsControlFile(
                 hFile,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatus,
                 FSCTL_SET_OBJECT_ID,
                 &fobOID,
                 sizeof(fobOID),
                 NULL,  // Out buffer
                 0);    // Out buffer size
    if( !NT_SUCCESS(status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if( !NT_SUCCESS(status) )
    {
        TrkLog(( TRKDBG_ERROR,
                 TEXT("SetObjId returned ntstatus=%08X"), status ));
    }

    return( status );
}


NTSTATUS
SetObjId( const TCHAR *ptszFile,
          CObjId objid,
          const CDomainRelativeObjId &droidBirth )
{
    NTSTATUS status = STATUS_SUCCESS;
    HANDLE hFile = NULL;

    __try
    {
        // Setting the object ID requires restore privelege, but no
        // file access.

        EnableRestorePrivilege();

        status = TrkCreateFile( ptszFile, FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                                FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                FILE_OPEN,
                                FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_NO_RECALL | FILE_SYNCHRONOUS_IO_NONALERT,
                                NULL, &hFile );
        if( !NT_SUCCESS(status ))
        {
            hFile = NULL;
            goto Exit;
        }

        status = SetObjId( hFile, objid, droidBirth );
    }
    __finally
    {
        if( NULL != hFile )
            NtClose( hFile );
    }

Exit:

    return( status );
}




//+----------------------------------------------------------------------------
//
//  Function:   MakeObjIdReborn
//
//  Synopsis:   Resets the birth ID on a file to it's current location.
//
//  Inputs:     [hFile]
//                  The handle of the file to delete the object id of.
//
//  Returns:    NTSTATUS
//
//  Exceptions: None
//
//+----------------------------------------------------------------------------

NTSTATUS
MakeObjIdReborn(const TCHAR *ptszVolumeDeviceName, const CObjId &objid)
{

    //  --------------
    //  Initialization
    //  --------------

    NTSTATUS status = STATUS_SUCCESS;
    HANDLE hFile = NULL;
    IO_STATUS_BLOCK IoStatus;

    // Open the file

    EnableRestorePrivilege();

    status = OpenFileById(ptszVolumeDeviceName,
                        objid,
                        SYNCHRONIZE | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_OPEN_FOR_BACKUP_INTENT, // for FSCTL_DELETE_OBJECT_ID
                        &hFile);
    if( !NT_SUCCESS(status) )
    {
        hFile = NULL;
        TrkLog(( (STATUS_SHARING_VIOLATION == status || STATUS_ACCESS_DENIED == status)
                     ? TRKDBG_MISC : TRKDBG_ERROR,
                 TEXT("Couldn't make born again objid (%s) on %s, failed open (%08x)"),
                 (const TCHAR*)CDebugString(objid), ptszVolumeDeviceName, status ));
        goto Exit;
    }

    // Clear the file's birth ID

    status = MakeObjIdReborn( hFile );
    if( !NT_SUCCESS(status) && STATUS_OBJECT_NAME_NOT_FOUND != status )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't make born again Object ID (%s) on %s:, failed delete (%08x)"),
                 (const TCHAR*)CDebugString(objid), ptszVolumeDeviceName, status ));
        goto Exit;
    }

    //  ----
    //  Exit
    //  ----

Exit:

    if( NULL != hFile )
        NtClose( hFile );

    #if DBG
    if( !NT_SUCCESS(status)
        &&
        STATUS_SHARING_VIOLATION != status
        &&
        STATUS_ACCESS_DENIED != status )
    {
        TCHAR tszPath[ MAX_PATH + 1 ];
        NTSTATUS statusDebug;

        hFile = NULL;
        statusDebug = OpenFileById( ptszVolumeDeviceName, objid,
                                    SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    FILE_ATTRIBUTE_NORMAL,
                                    &hFile );
        if( !NT_SUCCESS(statusDebug) )
            hFile = NULL;

        if( NT_SUCCESS(statusDebug) )
            statusDebug = QueryVolRelativePath( hFile, tszPath );
        else
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't OpenFileById (%08x)"), statusDebug ));

        if( NT_SUCCESS(statusDebug) )
            TrkLog(( TRKDBG_ERROR, TEXT("Failed to make born again objid on %s:%s"),
                     ptszVolumeDeviceName, tszPath ));
        else
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't QueryVolRelativePath (%08x)"), statusDebug ));

        if( NULL != hFile )
            NtClose( hFile );

    }
    #endif

    return( status );
}



NTSTATUS
MakeObjIdReborn(HANDLE hFile )
{
    NTSTATUS status = STATUS_SUCCESS;

    status = SetBirthId( hFile, CDomainRelativeObjId( ));
    if( !NT_SUCCESS(status) ) goto Exit;

Exit:

    return( status );

}


//+----------------------------------------------------------------------------
//
//  SetBirthId
//
//  The the birth ID on a file.  The object ID isn't altered.
//
//+----------------------------------------------------------------------------

NTSTATUS
SetBirthId( HANDLE hFile,
            const CDomainRelativeObjId &droidBirth )
{

    //  --------------
    //  Initialization
    //  --------------

    NTSTATUS status = STATUS_SUCCESS;
    BOOL   fOpen = FALSE;
    CObjId objidNull;

    FILE_OBJECTID_BUFFER fobOID;
    UNICODE_STRING uPath;
    IO_STATUS_BLOCK IoStatus;

    // Initialize the request buffer

    memset( &fobOID, 0, sizeof(fobOID) );

    droidBirth.SerializeRaw( fobOID.ExtendedInfo );
    objidNull.SerializeRaw( fobOID.ObjectId );

    // Send the FSCTL

    status = NtFsControlFile(
                 hFile,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatus,
                 FSCTL_SET_OBJECT_ID_EXTENDED,
                 &fobOID.ExtendedInfo,
                 sizeof(fobOID.ExtendedInfo),
                 NULL,  // Out buffer
                 0);    // Out buffer size
    if( !NT_SUCCESS(status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if( !NT_SUCCESS(status) )
    {
        TrkLog(( TRKDBG_ERROR,
                 TEXT("SetBirthId returned ntstatus=%08X"), status ));
    }

    return( status );
}


// Set the birth ID given a path, rather than a handle.

NTSTATUS
SetBirthId( const TCHAR *ptszFile,
            const CDomainRelativeObjId &droidBirth )
{
    NTSTATUS status = STATUS_SUCCESS;
    HANDLE hFile = NULL;

    __try
    {
        EnableRestorePrivilege();

        status = TrkCreateFile( ptszFile, SYNCHRONIZE | FILE_WRITE_ATTRIBUTES,
                                FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                FILE_OPEN,
                                FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_NO_RECALL | FILE_SYNCHRONOUS_IO_NONALERT,
                                NULL, &hFile );
        if( !NT_SUCCESS(status ))
        {
            hFile = NULL;
            goto Exit;
        }

        status = SetBirthId( hFile, droidBirth );
    }
    __finally
    {
        if( NULL != hFile )
            NtClose( hFile );

    }

Exit:

    return( status );
}



//+----------------------------------------------------------------------------
//
//  Function:   GetBirthId
//
//  Synopsis:   Get the birth ID from a given file.
//
//  Parameters: [hFile] (in)
//                  The file to query.
//              [pdroidBirth] (out)
//                  The file's birth ID.
//
//  Returns:    [NTSTATUS]
//
//+----------------------------------------------------------------------------

NTSTATUS
GetBirthId( IN HANDLE hFile,
            OUT CDomainRelativeObjId *pdroidBirth )
{
    NTSTATUS status = STATUS_SUCCESS;
    FILE_OBJECTID_BUFFER fobOID;
    IO_STATUS_BLOCK IoStatus;

    TrkAssert( NULL != pdroidBirth );
    TrkAssert( INVALID_HANDLE_VALUE != hFile && NULL != hFile );

    status = NtFsControlFile(
                 hFile,
                 NULL, NULL, NULL,
                 &IoStatus,
                 FSCTL_GET_OBJECT_ID,
                 NULL, 0,
                 &fobOID,
                 sizeof(fobOID));

    if( !NT_SUCCESS(status) ) goto Exit;

    // Load the droid from the objid buffer.
    pdroidBirth->InitFromFOB( fobOID );

    // Clear the bit xvol-move bit, which is not considered part of the ID.
    pdroidBirth->GetVolumeId().Normalize();

Exit:

    return( status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\sources.inc ===
# Copyright (c) 1996-1999 Microsoft Corporation


INCLUDES=$(INCLUDES);\
    ..;\
    ..\common;\
    ..\trkwks;\
    ..\trksvr;\
    $(COM_INC_PATH); \
    $(NET_INC_PATH); \
    $(DS_INC_PATH); \
    $(BASE_INC_PATH); \
    ..\trkcom

UNICODE=1

#
# set TWK_OWN_PROCESS to 1 to build a Tracking (Workstation) Service that
# runs in its own process
#
# set TWK_OWN_PROCESS to 0 to build a Tracking (Workstation) Service that
# runs in services.exe as part of the server service
#

TRK_OWN_PROCESS=0

C_DEFINES=      -DINCL_32= \
                -DNT \
                -DRPC_NO_WINDOWS_H \
                -DSTRICT=1 \
                -DUNICODE \
                -D_UNICODE \
                -DTRK_OWN_PROCESS=$(TRK_OWN_PROCESS)\
                -DUSE_LDAP\
                -D_ATL_MIN_CRT\
                -D_USRDLL #** Added for ATL

USE_MSVCRT=1
UMENTRY=wmain

MSC_WARNING_LEVEL=/W3 /WX

# Keep netlib.lib ahead of netapi32.lib to avoid a linker warning
TARGETLIBS= $(TARGETLIBS)\
          ..\common\$(O)\common.lib\
          $(SDK_LIB_PATH)\ntdll.lib\
          $(SDK_LIB_PATH)\wldap32.lib\
          $(SDK_LIB_PATH)\rpcrt4.lib\
          $(SDK_LIB_PATH)\uuid.lib\
          $(SDK_LIB_PATH)\user32.lib\
          $(SDK_LIB_PATH)\kernel32.lib\
          $(SDK_LIB_PATH)\advapi32.lib\
          $(SDK_LIB_PATH)\netlib.lib\
          $(SDK_LIB_PATH)\netapi32.lib\
          $(SDK_LIB_PATH)\mpr.lib\

!if $(IA64)
# Emit LTCG codegen
LTCG_WKS=1
!endif
	  
!if 0
PRECOMPILED_CXX=1
PRECOMPILED_TARGET=..\pch\$(O)\pch.pch
PRECOMPILED_OPTION=/Yupch.cxx /Fp..\pch\$(O)\pch.pch
!endif

PRECOMPILED_INCLUDE=..\pch.cxx
PRECOMPILED_CXX=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\common\midlallc.c ===
// Copyright (c) 1996-1999 Microsoft Corporation


#include <rpc.h>
#include <windows.h>

#if DBG
#include <stdio.h>
#endif

void __RPC_USER MIDL_user_free( void __RPC_FAR *pv ) 
{ 
    LocalFree(pv); 
}


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t s) 
{
    // Sanity check -- we should never need to allocate anything huge.  If we are, it's likely
    // an attemped DoS attack.  From a code review, it looks like the largest allocation is
    // for TRKSVR_CALL_REFRESH, which totals to about 5K.  This rounds way up to 50K just
    // to be safe (the service only supports 20 simultaneous RPC clients at a time).
    
    if( 50 * 1024 <= s )
    {
        #if DBG
        {
            char sz[ 256 ];
            sprintf( sz, "trksvcs:  RPC DoS attempt (%d byte allocation)\n", s );
            OutputDebugStringA( sz );
        }
        #endif

        return NULL;
    }

    return (void __RPC_FAR *) LocalAlloc(LMEM_FIXED, s); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\common\objidenm.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       objidenm.cxx
//
//  Contents:   CObjId enumeration from a volume
//
//  Classes:    CObjIdEnumerator
//
//  History:    18-Nov-96  BillMo      Created.
//              09-Jun-97  WeiruC      Modified. Skip volume id entries in
//                                     NTFS object id table.
//
//  Notes:
//
//  Codework:
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop
#include "trklib.hxx"


//+----------------------------------------------------------------------------
//
//  CObjIdEnumerator::Initialize
//
//  Prepare to enumerate the object IDs on a volume.  This opens a handle
//  to the object ID index directory.
//
//+----------------------------------------------------------------------------

BOOL
CObjIdEnumerator::Initialize(const TCHAR *ptszVolumeDeviceName)
{
    TCHAR tszDirPath[MAX_PATH];

    _tcscpy( tszDirPath, ptszVolumeDeviceName);
    _tcscat( tszDirPath, TEXT("\\$Extend\\$ObjId:$O:$INDEX_ALLOCATION") );

    _hDir = CreateFile( tszDirPath,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
                        NULL );

    return( INVALID_HANDLE_VALUE != _hDir );
}


//+----------------------------------------------------------------------------
//
//  CObjIdEnumerator::UnInitialize
//
//  Close the handle to the object ID index directory.
//
//+----------------------------------------------------------------------------

void
CObjIdEnumerator::UnInitialize()
{
    if( INVALID_HANDLE_VALUE != _hDir )
        CloseHandle(_hDir);
    _hDir = INVALID_HANDLE_VALUE;
}


//+----------------------------------------------------------------------------
//
//  CObjIdEnumerator::Find
//
//  This private method is used by the public FindFirst and FindNext
//  methods.  This method queries the object ID index directory
//  for a set of entries and puts the result into _ObjIdInfo.  It then
//  takes the first real entry and puts it into the caller-provided parameters
//  (the object ID and birth ID).  To start enumerating from the top of the
//  index, fRestart is set by the caller.
//
//+----------------------------------------------------------------------------


BOOL
CObjIdEnumerator::Find( CObjId * pobjid, CDomainRelativeObjId * pdroidBirth, BOOL fRestart )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOL            fObjFound = FALSE;

    // Loop until we find a real entry.

    do
    {
        // Query the object ID index for a set of entries.

        Status = NtQueryDirectoryFile( _hDir,
                                       NULL,     //  Event
                                       NULL,     //  ApcRoutine
                                       NULL,     //  ApcContext
                                       &IoStatusBlock,
                                       _ObjIdInfo,
                                       sizeof(_ObjIdInfo),
                                       FileObjectIdInformation,
                                       FALSE,    //  ReturnSingleEntry
                                       NULL,     //  FileName
                                       fRestart != 0);  //  RestartScan
        if(NT_SUCCESS(Status) && IoStatusBlock.Information != 0)
        {
            fRestart = FALSE;

            // Update the count of entries and the cursor into the entries.

            _cbObjIdInfo = (ULONG)IoStatusBlock.Information;
            _pObjIdInfo = _ObjIdInfo;

            TrkAssert( _cbObjIdInfo % sizeof(*_pObjIdInfo) == 0 );
            TrkAssert( _cbObjIdInfo <= sizeof(_ObjIdInfo) );

            // In the NTFS's ObjectID table is a record which represents
            // not the file object id but the volume id. We skip this record.

            while( _pObjIdInfo < &_ObjIdInfo[_cbObjIdInfo / sizeof(_ObjIdInfo[0])]
                   &&
                   (_pObjIdInfo->FileReference & FILEREF_MASK) == FILEREF_VOL )
            {
                _pObjIdInfo++;
            }

            // If we haven't exhausted the objects in the buffer, take the next
            // one and return it to the caller.

            if(_pObjIdInfo < &_ObjIdInfo[_cbObjIdInfo / sizeof(_ObjIdInfo[0])])
            {
                UnloadFileObjectIdInfo( *_pObjIdInfo, pobjid, pdroidBirth );
                _pObjIdInfo ++;
                fObjFound = TRUE;
                break;
            }
        }
        else
        {
            break;
        }
    } while(TRUE);

    if(TRUE == fObjFound)
    {
        return(TRUE);
    }
    else
    {
        _cbObjIdInfo = 0;
        return(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\common\eventlog.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//-----------------------------------------------------------------------------
//
// File:        eventlog.cxx
//
// Contents:    Utilities to report events.
//
// Histories:   08/06/97 created by weiruc
//
//-----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "trklib.hxx"
#include "netevent.h"

#define MAX_STRINGS 100

const extern TCHAR*   g_ptszEventSource;



//------------------------------------------------------------------------------
//
// Function:        TrkReportRawEvent
//
// Synopsis:        Report an event using the event logging service.
//                  It's "raw" because an lpRawData parameter may be passed.
//
// Input:           [in]  dwEventId
//                      Event id as defined in eventmsg.h.
//                  [in]  wType
//                      Type of event. Choices are:
//                      EVENTLOG_ERROR_TYPE         Error event 
//                      EVENTLOG_WARNING_TYPE       Warning event 
//                      EVENTLOG_INFORMATION_TYPE   Information event 
//                      EVENTLOG_AUDIT_SUCCESS      Success Audit event 
//                      EVENTLOG_AUDIT_FAILURE      Failure Audit event 
//                  [in]  ...
//                        Any string the caller wants to log.
//
// Requirement:     Because this function does not copy the string parameters
//                  into internal buffers. So the input strings can not be
//                  modified when the function is being called.
//                  The last string parameter passed in MUST be NULL to
//                  mark the end of the argument list. Any arguments passed
//                  in after a NULL argument are going to be ignored.
//
//------------------------------------------------------------------------------

HRESULT TrkReportRawEvent(DWORD dwEventId,
                          WORD wType,
                          DWORD cbRawData,
                          const void *pvRawData,
                          va_list pargs )
{
    HANDLE  hEventLog = INVALID_HANDLE_VALUE;
    HRESULT hr = S_OK;
    const TCHAR*  rgtszStrings[MAX_STRINGS];
    WORD    wCounter = 0;

    // initialize the insertion string array
    memset(rgtszStrings, 0, sizeof(rgtszStrings));

    // build the insertion string array
    wCounter = 0;
    while(TRUE)
    {
        if(wCounter >= MAX_STRINGS)
        {
            break;
        }
        rgtszStrings[wCounter] = va_arg(pargs, const TCHAR*);
        if(NULL == rgtszStrings[wCounter])
        {
            break;
        }
        else
        {
            wCounter++;
        }
    }
    va_end(pargs);
    
    // open registry
    hEventLog = RegisterEventSource(NULL, g_ptszEventSource);
    if(NULL == hEventLog)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TrkLog((TRKDBG_ERROR, TEXT("Can't open registry (%s), hr = %08x"),
                g_ptszEventSource, hr));
        goto Exit;
    }

    // write event log
    if(!ReportEvent(hEventLog,
                    wType,
                    0,
                    dwEventId,
                    NULL,
                    wCounter,
                    cbRawData,
                    rgtszStrings,
                    const_cast<void*>(pvRawData) ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TrkLog((TRKDBG_ERROR, TEXT("ReportEvent failed. hr = %08x"), hr));
    }

    // close registry
    if(!DeregisterEventSource(hEventLog) && S_OK == hr)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TrkLog((TRKDBG_ERROR, TEXT("Can't close registry (%s), hr = %08x"),
                g_ptszEventSource, hr));
    }

Exit:

    return hr;
}



//+----------------------------------------------------------------------------
//
//  TrkReportInternalError
//
//  Report an event that should never happen.  The file number and line
//  number are put into the hidden data blob.
//
//+----------------------------------------------------------------------------

HRESULT TrkReportInternalError(DWORD dwFileNo,
                               DWORD dwLineNo,
                               HRESULT hrErrorNo,
                               const TCHAR* ptszData)
{
    HRESULT hr = S_OK;
    TCHAR   tszHr[9];
    struct
    {
        DWORD   dwFileNo;
        DWORD   dwLineNo;
        TCHAR   tszData[ MAX_PATH + 1 ];
    }   sRawData;
    DWORD   cbRawData = 0;

    sRawData.dwFileNo = dwFileNo;
    sRawData.dwLineNo = dwLineNo;

    cbRawData = sizeof(sRawData.dwFileNo) + sizeof(sRawData.dwLineNo);
    if( NULL != ptszData )
    {
        _tcsncpy( sRawData.tszData, ptszData, MAX_PATH );
        cbRawData += 2 * _tcslen( ptszData );
    }

    // build the insertion strings
    _stprintf(tszHr, TEXT("%08x"), hrErrorNo);

    // This is just a special case of TrkReportEvent.
    hr = TrkReportRawEventWrapper( EVENT_TRK_INTERNAL_ERROR,
                                   EVENTLOG_ERROR_TYPE,
                                   cbRawData,
                                   reinterpret_cast<void*>(&sRawData),
                                   tszHr, TRKREPORT_LAST_PARAM );

    

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\common\rpccfg.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  rpccfg.cxx
//  
//  Base class for CRpcServer and CRpcClientBinding, which provides
//  reg-based configuration support.
//
//=============================================================================


#include <pch.cxx>
#pragma hdrstop

#include "trklib.hxx"


BOOL CTrkRpcConfig::_fInitialized = FALSE;
CMultiTsz CTrkRpcConfig::_mtszCustomDcName;
CMultiTsz CTrkRpcConfig::_mtszCustomSecureDcName;

CTrkRpcConfig::CTrkRpcConfig()
{
    // This isn't thread-safe because it's not worth the expense;
    // if multiple threads load this data, they'll each load the
    // same data anyway.

    if( !_fInitialized )
    {
        CTrkConfiguration::Initialize( );

        Read( CUSTOM_DC_NAME_NAME, &_mtszCustomDcName, CUSTOM_DC_NAME_DEFAULT );
        Read( CUSTOM_SECURE_DC_NAME_NAME, &_mtszCustomSecureDcName, CUSTOM_SECURE_DC_NAME_DEFAULT );

        _fInitialized = TRUE;

        CTrkConfiguration::UnInitialize();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\common\oplog.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  oplog.cxx
//
//  Implementation for COperationsLog, which maintains a simple, circular
//  log of events.
//
//+============================================================================


#include "pch.cxx"
#pragma hdrstop

#ifndef NO_OPLOG

#include "trklib.hxx"

#define OPERATION_LOG_SIZE  ( (( (1024*1024) - sizeof(SHeader) )/sizeof(SRecord))*sizeof(SRecord) + sizeof(SHeader) )
#define OPERATION_LOG_RECORD_COUNT  ( (OPERATION_LOG_SIZE - sizeof(SHeader)) / sizeof(SRecord) )


//+----------------------------------------------------------------------------
//
//  COperationLog::InitializeLogFile
//
//  Initialize the operations log file.  This is called lazily so that we don't
//  impact service start (and don't get called unless the oplog is turned on).
//
//+----------------------------------------------------------------------------

HRESULT
COperationLog::InitializeLogFile(  )
{
    HRESULT hr = E_FAIL;
    ULONG cbFile = 0;

    _iRecord = 0;

    Lock();

    __try
    {
        BY_HANDLE_FILE_INFORMATION FileInfo;

        _fLogFileInitialized = TRUE;

        TrkLog(( TRKDBG_VOLUME, TEXT("Initializing operation log file (%s)"), _ptszOperationLog ));

        // Loop twice, if we find a problem the first time, we'll delete and
        // try again.

        for( int i = 0; i < 2; i++ )
        {
            if( INVALID_HANDLE_VALUE != _hFile )
                CloseHandle( _hFile );

            // Open/create the file on the first pass, create it on the second pass.

            _hFile = CreateFile( _ptszOperationLog, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_DELETE, NULL,
                                 0 == i ? OPEN_ALWAYS : CREATE_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL, INVALID_HANDLE_VALUE );
            if( INVALID_HANDLE_VALUE == _hFile )
            {
                TrkLog(( TRKDBG_WARNING, TEXT("Couldn't create/open status log file (%lu)"),
                         GetLastError() ));
                TrkRaiseLastError();
            }

            // On the first pass, check the file to see if it looks valid.
            // If not, continue the loop so that a new file can be created.

            if( 1 == i )
                cbFile = 0;
            else
            {
                // All we check is the size.  There's no support for trying
                // to migrate a file if we change the file size.

                if( !GetFileInformationByHandle( _hFile, &FileInfo ))
                {
                    TrkLog(( TRKDBG_WARNING, TEXT("Couldn't get status file info") ));
                    TrkRaiseLastError();
                }
                if( 0 != FileInfo.nFileSizeHigh )
                {
                    TrkLog(( TRKDBG_WARNING, TEXT("Operation file to big") ));
                    continue;
                }
                else if( 0 != FileInfo.nFileSizeLow
                         &&
                         OPERATION_LOG_SIZE != FileInfo.nFileSizeLow )
                {
                    TrkLog(( TRKDBG_WARNING, TEXT( "Operation log file wrong size") ));
                    continue;
                }
                cbFile = FileInfo.nFileSizeLow;
            }
        }

        // Create a mapping of the file.

        _hFileMapping = CreateFileMapping( _hFile, NULL, PAGE_READWRITE, 0, OPERATION_LOG_SIZE, NULL );
        if( INVALID_HANDLE_VALUE == _hFileMapping )
        {
            TrkLog(( TRKDBG_WARNING, TEXT("Couldn't create status log file mapping (%lu)"), GetLastError() ));
            TrkRaiseLastError();
        }

        // And map a view of the file.

        _pHeader = (SHeader*) MapViewOfFile( _hFileMapping, FILE_MAP_ALL_ACCESS, 0, 0, OPERATION_LOG_SIZE );
        if( NULL == _pHeader )
        {
            TrkLog(( TRKDBG_WARNING, TEXT("Couldn't map view of status log file (%lu)"),
                     GetLastError() ));
            TrkRaiseLastError();
        }

        // If we opened an existing file, validate the shutdown and version.
        // If anything looks wrong, or if this file is new, zero it out.

        if( 0 == cbFile
            ||
            0 == (_pHeader->grfFlags & PROPER_SHUTDOWN)
            ||
            OPERATION_LOG_VERSION != _pHeader->dwVersion )
        {
            TrkLog(( TRKDBG_WARNING, TEXT("Re-initializing operation log file") ));
            _iRecord = 0;
            memset( _pHeader, 0, OPERATION_LOG_SIZE );
            _pHeader->dwVersion = OPERATION_LOG_VERSION;
        }
        else
            _iRecord = _pHeader->iRecord;

        // Show that the file isn't properly shut down.

        _pHeader->grfFlags &= ~PROPER_SHUTDOWN;
        _prgRecords = (SRecord*) ( (BYTE*)_pHeader + sizeof(SHeader) );
        Flush();

        TrkLog(( TRKDBG_VOLUME, TEXT("Status log starts at index %d"), _iRecord ));
        hr = S_OK;

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = GetExceptionCode();
    }


    Unlock();
    return( hr );
}



//+----------------------------------------------------------------------------
//
//  COperationsLog::Flush
//
//  Flush the operations log to disk.
//
//+----------------------------------------------------------------------------

void
COperationLog::Flush()
{
    __try
    {
        if( !_fLogFileInitialized )
            __leave;

        _pHeader->iRecord = _iRecord;

        if( NULL != _pHeader && !FlushViewOfFile( _pHeader, OPERATION_LOG_SIZE ))
        {
            TrkLog(( TRKDBG_WARNING, TEXT("Couldn't flush operation log file view") ));
        }
        if( INVALID_HANDLE_VALUE != _hFile && !FlushFileBuffers( _hFile ))
        {
            TrkLog(( TRKDBG_WARNING, TEXT("Couldn't flush operation log file") ));
        }
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Ignoring exception in COpLog::Flush (0x%08x)"),
                 GetExceptionCode() ));
    }
}



//+----------------------------------------------------------------------------
//
//  COperationLog::InternalAdd
//
//  Add an entry to the operation log.
//
//+----------------------------------------------------------------------------

void
COperationLog::InternalAdd( DWORD dwOperation, HRESULT hr, const CMachineId &mcidSource,
                               DWORD dwExtra0, DWORD dwExtra1, DWORD dwExtra2, DWORD dwExtra3,
                               DWORD dwExtra4, DWORD dwExtra5, DWORD dwExtra6, DWORD dwExtra7 )
{
    ULONG iFile = 0;
    ULONG cbWritten = 0;

    Lock();
    __try
    {
        // Lazy initialization of the log file.

        if( !_fLogFileInitialized )
        {
            if( FAILED( InitializeLogFile() ))
                __leave;
        }

        // Ensure we have valid mappings.

        if( NULL == _pHeader || NULL == _prgRecords )
            __leave;

        // Add the data to the next record.

        _prgRecords[_iRecord].dwOperation = dwOperation;
        _prgRecords[_iRecord].ftOperation = CFILETIME();
        _prgRecords[_iRecord].mcidSource = mcidSource;
        _prgRecords[_iRecord].hr = hr;

        _prgRecords[_iRecord].rgdwExtra[0] = dwExtra0;
        _prgRecords[_iRecord].rgdwExtra[1] = dwExtra1;
        _prgRecords[_iRecord].rgdwExtra[2] = dwExtra2;
        _prgRecords[_iRecord].rgdwExtra[3] = dwExtra3;
        _prgRecords[_iRecord].rgdwExtra[4] = dwExtra4;
        _prgRecords[_iRecord].rgdwExtra[5] = dwExtra5;
        _prgRecords[_iRecord].rgdwExtra[6] = dwExtra6;
        _prgRecords[_iRecord].rgdwExtra[7] = dwExtra7;

        // Advance the seek pointer.

        _iRecord++;
        if( OPERATION_LOG_RECORD_COUNT == _iRecord )
        {
            _iRecord = 0;
            TrkLog(( TRKDBG_VOLUME, TEXT("Wrapping operation log") ));
        }
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Ignoring exception in COpLog::InternalAdd (0x%08x)"),
                 GetExceptionCode() ));
    }


    Unlock();
}


#endif // #ifndef NO_OPLOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\common\rpcsvr.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  rpcsvr.cxx
//
//  Implementation of CRpcServer, with the common code to support
//  trkwks & trksvr RPC servers.
//
//+============================================================================

#include <pch.cxx>
#pragma hdrstop

#include "trklib.hxx"

#define THIS_FILE_NUMBER    RPCSVR_CXX_FILE_NO

//+----------------------------------------------------------------------------
//
//  CRpcServer::Initialize
//
//  Initialize the CRpcServer base class.  Before calling this
//  method, a derivation should perform all of its necessary
//  RpcUseProtseq calls.
//
//  If a ptszProtSeqForEpRegistration is specified, find the
//  binding handle for that protocol and register this interface
//  just with that binding.
//
//+----------------------------------------------------------------------------

void
CRpcServer::Initialize(RPC_IF_HANDLE ifspec,
                       ULONG grfRpcServerRegisterInterfaceEx,
                       UINT cMaxCalls,
                       BOOL fSetAuthInfo,
                       const TCHAR *ptszProtSeqForEpRegistration )
{
    RPC_STATUS          rpcstatus;
    RPC_BINDING_VECTOR *pBindingVector = NULL;
    TCHAR              *ptszStringBinding = NULL;
    TCHAR              *ptszProtSeq = NULL;

    _ifspec = ifspec;
    _fEpRegister = NULL != ptszProtSeqForEpRegistration;

    __try
    {
        // If required, set authentication information

        if( RpcSecurityEnabled() && fSetAuthInfo )
        {

            RPC_TCHAR tszAuthName[MAX_COMPUTERNAME_LENGTH * 2 + 2 + 1]; // slash and $ and NUL
            CMachineId mcid(MCID_LOCAL);

            // Get the authentiation name, e.g. domain\machine$
            mcid.GetLocalAuthName(tszAuthName, sizeof(tszAuthName)/sizeof(tszAuthName[0]));

            // Set the auth info.  We set it to negotiate, but we'll always get Kerberos.
            rpcstatus = RpcServerRegisterAuthInfo(
                tszAuthName,
                RPC_C_AUTHN_GSS_NEGOTIATE,
                NULL,   // RPC_AUTH_KEY_RETRIEVAL_FN,
                NULL ); // Arg );

            if (rpcstatus)
            {
                TrkReportInternalError( THIS_FILE_NUMBER, __LINE__,
                                        HRESULT_FROM_WIN32(rpcstatus), tszAuthName );
                TrkRaiseWin32Error(rpcstatus);
            }
        }

        // If using dynamic enpoints, register in the endpoint mapper
        // for the first binding handle for the specified protocol sequence.

        if( _fEpRegister )
        {

            // Query for the currently active binding handles

            rpcstatus = RpcServerInqBindings(&pBindingVector);
            if (rpcstatus)
            {
                TrkLog((TRKDBG_ERROR, TEXT("RpcServerInqBindings %08x"), rpcstatus));
                TrkReportInternalError( THIS_FILE_NUMBER, __LINE__,
                                        HRESULT_FROM_WIN32(rpcstatus), TRKREPORT_LAST_PARAM );
                TrkRaiseWin32Error(rpcstatus);
            }

            // Loop through the binding handles, looking for the first one with
            // the required protocol sequence.

            for( ULONG i = 0; i < pBindingVector->Count; i++ )
            {
                // Stringize the binding handle.

                rpcstatus = RpcBindingToStringBinding( pBindingVector->BindingH[i],
                                                       &ptszStringBinding );
                if( RPC_S_OK != rpcstatus )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("RpcBindingToStringBinding %08x"), rpcstatus ));
                    TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, HRESULT_FROM_WIN32(rpcstatus), TRKREPORT_LAST_PARAM );
                    TrkRaiseWin32Error(rpcstatus);
                }

                // Parse the binding string for the protseq

                rpcstatus = RpcStringBindingParse( ptszStringBinding, NULL,
                                                   &ptszProtSeq,
                                                   NULL, NULL, NULL );
                if( RPC_S_OK != rpcstatus )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("RpcStringBindingParse %08x"), rpcstatus ));
                    TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, HRESULT_FROM_WIN32(rpcstatus), TRKREPORT_LAST_PARAM );
                    TrkRaiseWin32Error(rpcstatus);
                }

                // See if this protseq is that which we seek

                if( 0 == _tcscmp( ptszProtSeq, ptszProtSeqForEpRegistration ))
                {
                    // We have a match.  Register against this binding handle.

                    RPC_BINDING_VECTOR PartialBindingVector;
                    PartialBindingVector.Count = 1;
                    PartialBindingVector.BindingH[0] = pBindingVector->BindingH[i];

                    rpcstatus = RpcEpRegister(ifspec, &PartialBindingVector, NULL, NULL);
                    if( RPC_S_OK != rpcstatus )
                    {
                        TrkLog((TRKDBG_ERROR, TEXT("RpcEpRegister %08x"), rpcstatus));
                        TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, HRESULT_FROM_WIN32(rpcstatus), TRKREPORT_LAST_PARAM );
                        TrkRaiseWin32Error(rpcstatus);
                    }
                    else
                        TrkLog(( TRKDBG_MISC, TEXT("RpcEpRegister on %s"), ptszStringBinding ));
                    break;
                }

                RpcStringFree( &ptszStringBinding );
                ptszStringBinding = NULL;
                RpcStringFree( &ptszProtSeq );
                ptszProtSeq = NULL;
            }

            if( i == pBindingVector->Count )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't find protseq %s in binding vector"),
                        ptszProtSeqForEpRegistration ));
                TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, HRESULT_FROM_WIN32(rpcstatus), TRKREPORT_LAST_PARAM );
                TrkRaiseWin32Error( HRESULT_FROM_WIN32(RPC_S_NO_PROTSEQS_REGISTERED) );
            }

        }   // if( _fEpRegister )

        // Finally, register the server interface

        rpcstatus = RpcServerRegisterIfEx(ifspec, NULL, NULL,
                                          grfRpcServerRegisterInterfaceEx,
                                          cMaxCalls, NULL );
                                      
        if (rpcstatus != RPC_S_OK && rpcstatus != RPC_S_TYPE_ALREADY_REGISTERED)
        {
            TrkLog((TRKDBG_ERROR, TEXT("RpcServerRegisterIf %08x"), rpcstatus));
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__,
                                    HRESULT_FROM_WIN32(rpcstatus), TRKREPORT_LAST_PARAM );
            TrkRaiseWin32Error(rpcstatus);
        }
    }
    __finally
    {
        if( NULL != pBindingVector )
            RpcBindingVectorFree( &pBindingVector );
        if( NULL != ptszStringBinding )
            RpcStringFree( &ptszStringBinding );
        if( NULL != ptszProtSeq )
            RpcStringFree( &ptszProtSeq );
    }

}


//+----------------------------------------------------------------------------
//
//  CRpcServer::UnInitialize
//
//  Unregister the interface, and if necessary unregister the endpoints.
//
//+----------------------------------------------------------------------------

void
CRpcServer::UnInitialize()
{
    RPC_STATUS          rpcstatus;
    RPC_BINDING_VECTOR *pBindingVector = NULL;

    if (_ifspec == NULL)
        return;

    // If we registered with the endpoint mapper, unreg now.

    if( _fEpRegister )
    {
        // Ignore any errors; we should still unregister the interface
        // no matter what.

        rpcstatus = RpcServerInqBindings(&pBindingVector);
        if (rpcstatus)
        {
            TrkLog((TRKDBG_ERROR, TEXT("RpcServerInqBindings %08x"), rpcstatus));
        }
        else
        {
            rpcstatus = RpcEpUnregister(_ifspec, pBindingVector, NULL);
            RpcBindingVectorFree( &pBindingVector );
            if( RPC_S_OK != rpcstatus && EPT_S_NOT_REGISTERED != rpcstatus )
            {
                TrkLog((TRKDBG_ERROR, TEXT("RpcEpUnregister %08x"), rpcstatus));
            }
        }
    }
    
    // Unregister the interface

    rpcstatus = RpcServerUnregisterIf(_ifspec, NULL, 1 /* wait for calls */);
    if (rpcstatus != RPC_S_OK)
    {
        TrkLog((TRKDBG_ERROR, TEXT("RpcServerUnregisterIf %08x"), rpcstatus));
        //TrkRaiseWin32Error(rpcstatus);
    }

    CTrkRpcConfig::UnInitialize();

    _ifspec = NULL;
    _fEpRegister = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\common\rpccbind.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       RpcCBind.cxx
//
//  Contents:   CRpcClientBinding, which wraps a client-side RPC
//              binding handle.
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "trklib.hxx"


//+----------------------------------------------------------------------------
//
//  Method:     CRpcClientBinding::RcInitialize
//
//  Synopsis:   Create a binding handle to the caller-provided
//              machine/protocol/endpoint.  If requested, set security too.
//
//+----------------------------------------------------------------------------

void
CRpcClientBinding::RcInitialize(const CMachineId &mcid,
                                const TCHAR *ptszRpcProtocol, const TCHAR *ptszRpcEndPoint,
                                RC_AUTHENTICATE auth )
{
    RPC_STATUS  rpcstatus;
    RPC_TCHAR * ptszStringBinding;
    RPC_TCHAR   tszComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];

    TrkAssert(!_fBound);

    // Get the name of the computer to which we're binding.

    mcid.GetName(tszComputerName, sizeof(tszComputerName)/sizeof(tszComputerName[0]));

    // Create the binding string that encapsulates the target machine, protocol,
    // and endpoint.

    rpcstatus = RpcStringBindingCompose(NULL,
                                        const_cast<TCHAR*>(ptszRpcProtocol),
                                        tszComputerName,
                                        const_cast<TCHAR*>(ptszRpcEndPoint),
                                        NULL,
                                        &ptszStringBinding);

    if( rpcstatus )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcStringBindingCompose %lu"), rpcstatus ));
        TrkRaiseWin32Error( rpcstatus );
    }

    // Get a binding handle from the binding string.

    rpcstatus = RpcBindingFromStringBinding(ptszStringBinding, &_BindingHandle);
    RpcStringFree(&ptszStringBinding);

    if( rpcstatus )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcBindingFromStringBinding") ));
        TrkRaiseWin32Error( rpcstatus );
    }

    // If necessary, set security on the binding

    if( RpcSecurityEnabled() && NO_AUTHENTICATION != auth )
    {
        TrkAssert( PRIVACY_AUTHENTICATION == auth || INTEGRITY_AUTHENTICATION == auth );

        RPC_TCHAR tszAuthName[MAX_COMPUTERNAME_LENGTH * 2 + 2 + 1]; // slash and $ and NUL
        
        mcid.GetLocalAuthName(tszAuthName, sizeof(tszAuthName)/sizeof(tszAuthName[0]));

        rpcstatus = RpcBindingSetAuthInfo(_BindingHandle,
                       tszAuthName,
                       PRIVACY_AUTHENTICATION == auth
                          ? RPC_C_AUTHN_LEVEL_PKT_PRIVACY
                          : RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
                       RPC_C_AUTHN_GSS_NEGOTIATE,
                       NULL,    // AuthIdentity - current process/address space
                       0);      // AuthzSvc - ignored for RPC_C_AUTHN_DCE_PRIVATE

        if( rpcstatus )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcBindingSetAuthInfo %lu"), rpcstatus ));
            TrkRaiseWin32Error( rpcstatus );
        }
    }   // if( RpcSecurityEnabled() )

    _fBound = TRUE;
}


//+----------------------------------------------------------------------------
//
//  Method:     UnInitialize
//
//  Synopsis:   Free a binding.
//
//+----------------------------------------------------------------------------

void
CRpcClientBinding::UnInitialize()
{
    if (_fBound)
    {
        RpcBindingFree(&_BindingHandle);
        _fBound = FALSE;
    }

    CTrkRpcConfig::UnInitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\common\secure.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       secure.cxx
//
//              This file contains wrapper classes for the NT security
//              objects.
//
//  Contents:   Code common to Tracking (Workstation) Service and
//              Tracking (Server) Service.
//
//  Classes:    CACL, CSID, and CSecDescriptor
//
//  History:    28-Jan-98   MikeHill    Created
//
//  Notes:      
//
//--------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include "trklib.hxx"


//+-------------------------------------------------------------------
//
//  Function:   CACL::Initialize, public
//
//  Synopsis:   Initialize the ACL by allocating a buffer
//              and calling InitializeAcl on it.
//
//  Arguments:  None
//
//  Returns:    None
//
//--------------------------------------------------------------------

VOID
CACL::Initialize()
{
    _fInitialized = TRUE;

    _pacl = (PACL) new BYTE[ MIN_ACL_SIZE ];
    if( NULL == _pacl )
        TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );

    _cbacl = MIN_ACL_SIZE;

    if( !InitializeAcl( _pacl, _cbacl, ACL_REVISION ))
    {
        TrkLog((TRKDBG_ERROR, TEXT("Failed InitializeAcl")) );
        TrkRaiseLastError();
    }

    _fDirty = TRUE;

}



//+-------------------------------------------------------------------
//
//  Function:   CACL::UnInitialize, public
//
//  Synopsis:   Free the ACL.
//
//  Arguments:  None
//
//  Returns:    None
//
//--------------------------------------------------------------------

VOID
CACL::UnInitialize()
{
    if( _fInitialized )
    {
        if( NULL != _pacl )
        {
            delete [] _pacl;
        }

        _fInitialized = FALSE;
    }
}




//+-------------------------------------------------------------------
//
//  Function:   CACL::Initialize, public
//
//  Synopsis:   Initialize a SID with its authority
//              and sub-authority(ies).
//
//  Arguments:  [enumCSIDAuthority] (in)
//                  An enumeration which tells us which of the
//                  standard authorities to use.
//              [cSubAuthorities] (in)
//                  The number of sub-auths in this SID.
//              [dwSubAuthority?] (in)
//                  The Sub-Authorities.
//
//  Returns:    None
//
//--------------------------------------------------------------------

VOID
CSID::Initialize( enumCSIDAuthority enumcsidAuthority,
                  BYTE  cSubAuthorities ,
                  DWORD dwSubAuthority0 = 0,
                  DWORD dwSubAuthority1 = 0,
                  DWORD dwSubAuthority2 = 0,
                  DWORD dwSubAuthority3 = 0,
                  DWORD dwSubAuthority4 = 0,
                  DWORD dwSubAuthority5 = 0,
                  DWORD dwSubAuthority6 = 0,
                  DWORD dwSubAuthority7 = 0 )
{
    SID_IDENTIFIER_AUTHORITY rgsid_identifier_authority[] = { SECURITY_NT_AUTHORITY };

    TrkAssert(!_fInitialized);

    _fInitialized = TRUE;
    _psid = NULL;

    if( !AllocateAndInitializeSid( &rgsid_identifier_authority[ enumcsidAuthority ],
                               cSubAuthorities,
                               dwSubAuthority0,
                               dwSubAuthority1,
                               dwSubAuthority2,
                               dwSubAuthority3,
                               dwSubAuthority4,
                               dwSubAuthority5,
                               dwSubAuthority6,
                               dwSubAuthority7,
                               &_psid ))
    {

        TrkLog((TRKDBG_ERROR, TEXT("AllocateAndInitializeSid failed")));
        TrkRaiseLastError();
    }
            
}


//+-------------------------------------------------------------------
//
//  Function:   CSID::UnInitialize, public
//
//  Synopsis:   Free the SID.
//
//  Arguments:  None
//
//  Returns:    None
//
//--------------------------------------------------------------------

VOID
CSID::UnInitialize()
{
    if( _fInitialized )
    {
        if( NULL != _psid )
        {
            FreeSid( _psid );   // Alloc-ed with AllocAndInitializeSid()
        }

        _fInitialized = FALSE;
    }
}




//+-------------------------------------------------------------------
//
//  Function:   CSecDescriptor::_Allocate, public
//
//  Synopsis:   Allocate a Security Descriptor.
//
//  Arguments:  [cb]
//                  Size of buffer to allocate for SD.
//
//  Returns:    None
//
//--------------------------------------------------------------------

void
CSecDescriptor::_Allocate( ULONG cb )
{
    PSECURITY_DESCRIPTOR psd;

    psd = (PSECURITY_DESCRIPTOR) new BYTE[ cb ];
    
    if( NULL == psd )
        TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );

    if( NULL != _psd )
        delete [] _psd;

    _psd = psd;

}


//+-------------------------------------------------------------------
//
//  Function:   CSecDescriptor::Initialize, public
//
//  Synopsis:   Allocate a SD, and call a Security API to init it.
//
//  Arguments:  None
//
//  Returns:    None
//
//--------------------------------------------------------------------

VOID
CSecDescriptor::Initialize()
{

    _fInitialized = TRUE;

    _Allocate( SECURITY_DESCRIPTOR_MIN_LENGTH );

    if( !InitializeSecurityDescriptor( _psd,
                                       SECURITY_DESCRIPTOR_REVISION ))
    {
        TrkLog((TRKDBG_ERROR, TEXT("Failed InitializeSecurityDescriptor")));
        TrkRaiseLastError();
    }

    if( !SetSecurityDescriptorControl( _psd,
                                       SE_DACL_AUTO_INHERITED,
                                       SE_DACL_AUTO_INHERITED ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed InitializeSecurityDescriptor (SetSecurityDescriptorControl") ));
        TrkRaiseLastError();
    }
}


//+-------------------------------------------------------------------
//
//  Function:   CSecDescriptor::UnInitialize, public
//
//  Synopsis:   Free the SD buffer, and free its ACLs.
//
//  Arguments:  None
//
//  Returns:    None
//
//--------------------------------------------------------------------

VOID
CSecDescriptor::UnInitialize()
{
    if( _fInitialized )
    {
        if( NULL != _psd )
        {
            delete [] _psd;
        }

        _cDacl.UnInitialize();
        _cSacl.UnInitialize();

        _fInitialized = FALSE;
    }
}



//+-------------------------------------------------------------------
//
//  Function:   CSecDescriptor::AddAce, public
//
//  Synopsis:   Adds an ACE (access allowed or denied) to an
//              ACL in this SID.
//
//  Arguments:  [enumAclType] (in)
//                  Either ACL_DACL or ACL_SACL.
//              [enumAccessType] (in)
//                  Either AT_ACCESS_ALLOWED or AT_ACCESS_DENIED.
//              [access_mask] (in)
//                  The access bits to put in this ACE.
//              [psid] (in)
//                  The SID to put in this ACE.
//
//  Returns:    None
//
//--------------------------------------------------------------------

void
CSecDescriptor::AddAce( const enumAclType AclType, const enumAccessType AccessType,
                        const ACCESS_MASK access_mask, const PSID psid )
{
    BOOL fSuccess;

    // Get a pointer to the member CACL object.

    CACL  *pcacl = ACL_IS_DACL == AclType ? &_cDacl : &_cSacl;

    // Initialize the CACL if necessary.

    if( !pcacl->IsInitialized() )
        pcacl->Initialize();

    // Size the ACL appropriately

    //pcacl->SetSize( psid ); // Not currently implemented.

    // Add the ACE to the appropriate ACL.

    if( AT_ACCESS_ALLOWED == AccessType )
    {
        fSuccess = pcacl->AddAccessAllowed( access_mask, psid );
    }
    else
    {
        fSuccess = pcacl->AddAccessDenied( access_mask, psid );
    }

    if( !fSuccess )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't add an ACE to an ACL")));
        TrkRaiseLastError();
    }

    return;

}


//+-------------------------------------------------------------------
//
//  Function:   CSecDescriptor::_ReloadAcl, public
//
//  Synopsis:   Puts the member ACLs back into the member
//              Security Descriptor, if they are dirty.
//
//  Arguments:  [enumAclType] (in)
//                  Either ACL_DACL or ACL_SACL.
//
//  Returns:    None
//
//--------------------------------------------------------------------

VOID
CSecDescriptor::_ReloadAcl( enumAclType AclType )
{
    if( ACL_IS_DACL == AclType && _cDacl.IsDirty() )
    {
        if( !SetSecurityDescriptorDacl( _psd, TRUE, _cDacl, FALSE ))
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't put DACL into SD")));
            TrkRaiseLastError();
        }
        _cDacl.ClearDirty();
    }
    else if( ACL_IS_SACL == AclType && _cSacl.IsDirty() )
    {
        if( !SetSecurityDescriptorSacl( _psd, TRUE, _cSacl, FALSE ))
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't put SACL into SD")));
            TrkRaiseLastError();
        }
        _cSacl.ClearDirty();
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\common\sharenum.cxx ===
// Copyright (c) 1996-2002 Microsoft Corporation


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       sharenum.cxx
//
//  Contents:   The CShareEnumerator class implementation.
//
//  Classes:    CShareEnumerator
//
//  History:    28-Jan-98   MikeHill    Created
//
//  Notes:      
//
//--------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include "trklib.hxx"

//+-------------------------------------------------------------------
//
//  Function:   CShareEnumerator::Initialize
//
//  Synopsis:   Initializes this enumeration by calling
//              NetShareEnum.
//
//  Arguments:  [IDL_handle] (in)
//                  The RPC binding handle to the client on whom's
//                  behalf we're acting.
//
//              [ptszMachineName] (in)
//                  The machine on which shares are to be enumerated.
//                  If this value is NULL, the local machine is assumed.
//
//
//  Returns:    None.
//
//  Raises:     On error.
//
//--------------------------------------------------------------------


VOID
CShareEnumerator::Initialize( RPC_BINDING_HANDLE IDL_handle, const TCHAR *ptszMachineName )
{
    NET_API_STATUS netstatus;
    NETRESOURCE netresourceMachine;
    DWORD dwTotalEntries;

    TrkAssert( !_fInitialized );    
    
    // Start with a clean state
    
    _ClearCache();
    _iCurrentEntry = static_cast<ULONG>(-1);
    _fInitialized = TRUE;

    _IDL_handle = IDL_handle;

    // Keep the machine name, retrieving it if necessary.

    _tcscpy( _tszMachineName, TEXT("\\\\") );

    if( NULL != ptszMachineName )
        _tcscpy( &_tszMachineName[2], ptszMachineName );
    else
    {
        DWORD cbMachineName = sizeof(_tszMachineName) - 2;
        if( !GetComputerName( &_tszMachineName[2], &cbMachineName ))
            TrkRaiseLastError();
    }

    // Start the enumeration.  We'll simply get all the share information
    // at once, instead of using a resume handle and making repeated RPC
    // calls to the Server service.

    netstatus = NetShareEnum( (TCHAR*) ptszMachineName,     // Server (we must de-const it)
                              502,                          // Info level
                              (LPBYTE*) &_prgshare_info,     // Return buffer
                              MAX_PREFERRED_LENGTH,         // Get everything
                              &_cEntries,                   // Entries read
                              &dwTotalEntries,              // Total entries avail
                              NULL );                       // Resume handle

    if( STATUS_SUCCESS != netstatus )
        TrkRaiseWin32Error( HRESULT_FROM_WIN32(netstatus) );

    TrkAssert( _cEntries == dwTotalEntries );

    return;

}


//+-------------------------------------------------------------------
//
//  Function:   CShareEnumerator::UnInitialize
//
//  Synopsis:   Free any resources.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Raises:     No
//
//--------------------------------------------------------------------

VOID
CShareEnumerator::UnInitialize()
{
    if( _fInitialized )
    {
        if( NULL != _prgshare_info )
            NetApiBufferFree( _prgshare_info );

        InitLocals();
    }

    CTrkRpcConfig::UnInitialize();
}


//+-------------------------------------------------------------------
//
//  Function:   CShareEnumerator::_ClearCache
//
//  Synopsis:   Clear the data members of the CShareEnumerator
//              which are cached information about the current share.
//              (This is done in preparation to move on to the next
//              share in the enumeration.)
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Raises:     No
//
//--------------------------------------------------------------------

VOID
CShareEnumerator::_ClearCache()
{
    // Clear the cached information about the
    // current share.

    _cchSharePath = (ULONG) -1;
    _ulMerit = 0;
    _enumHiddenState = HS_UNKNOWN;

}


//+-------------------------------------------------------------------
//
//  Function:   CShareEnumerator::Next
//
//  Synopsis:   Moves the enumerator on to the next share in the
//              the enumeration.
//
//  Arguments:  None.
//
//  Returns:    TRUE if there was another element in the enumeration,
//              FALSE if there are no more shares to enumerate.
//
//  Raises:     No.
//
//--------------------------------------------------------------------

BOOL
CShareEnumerator::Next()
{
    TrkAssert( _fInitialized );

    if( _iCurrentEntry + 1 < _cEntries )
    {
        _ClearCache();
        _iCurrentEntry++;
        return( TRUE );
    }
    else
        return( FALSE );

}



//+-------------------------------------------------------------------
//
//  Function:   CShareEnumerator::CoversDrivePath
//
//  Synopsis:   Determines if the current share in the enumeration
//              "covers" a given drive path.  E.g., a share to
//              "c:\docs" covers the drive path "c:\docs\mydoc.doc".
//
//  Arguments:  [ptszDrivePath]
//                  The drive-based path to check for coverage.
//
//  Returns:    TRUE if the current share covers the given path,
//              FALSE otherwise.
//
//  Raises:     No
//
//--------------------------------------------------------------------

BOOL
CShareEnumerator::CoversDrivePath( const TCHAR *ptszDrivePath )
{
    TrkAssert( _fInitialized );
    TrkAssert( TEXT(':') == ptszDrivePath[1] );

    // Does the current share path cover the file?  It does if it compares
    // successfully with the local path, up to the entire length of the
    // share path.

    if( _IsValidShare()
        &&
        QueryCCHSharePath() <= _tcslen(ptszDrivePath)
        &&
        !_tcsnicmp( GetSharePath(), ptszDrivePath, QueryCCHSharePath() )
      )
        return TRUE;
    else
        return FALSE;
    
}


//+-------------------------------------------------------------------
//
//  Function:   CShareEnumerator::_IsHiddenShare
//
//  Synopsis:   Determines if the current share is "hidden"
//              (i.e., the share name ends in a '$').
//
//              The first time this method is called, the share
//              named is checked for hidden-ness.  The result is
//              cached for subsequent calls.
//
//  Arguments:  None.
//
//  Returns:    TRUE if the current share is hidden,
//              FALSE if it is visible.
//
//  Raises:     On error.
//
//--------------------------------------------------------------------

BOOL
CShareEnumerator::_IsHiddenShare()
{
    TrkAssert( _fInitialized );
    TrkAssert( _IsValidShare() );
    TrkAssert( NULL != GetShareName() );
    TrkAssert( TEXT('\0') != GetShareName()[0] );

    if( _enumHiddenState == HS_UNKNOWN )
    {
        _enumHiddenState = TEXT('$') == GetShareName()[ _tcslen(GetShareName()) - 1 ]
                           ? HS_HIDDEN
                           : HS_VISIBLE;
    }

    return( HS_HIDDEN == _enumHiddenState );
}


//+-------------------------------------------------------------------
//
//  Function:   CShareEnumerator::_IsAdminShare
//
//  Synopsis:   Determines if the current share is Admin share.
//              Admin shares are automatically created by the Server
//              service during initialization.  They're hard-coded
//              to be A$, B$, C$, etc., for each of the drives,
//              and ADMIN$ for the %windir% directory.
//
//  Arguments:  None.
//
//  Returns:    TRUE if the current share is an auto-generated admin share,
//              FALSE otherwise.
//
//--------------------------------------------------------------------

BOOL
CShareEnumerator::_IsAdminShare()
{
    TCHAR tcDriveLetter;
    TrkAssert( _fInitialized );
    TrkAssert( _IsValidShare() );
    TrkAssert( NULL != GetShareName() );
    TrkAssert( TEXT('\0') != GetShareName()[0] );

    tcDriveLetter = TrkCharUpper( GetShareName()[0] );

    // Check for the admin share characteristics.

    if( 2 == _tcslen(GetShareName())
        &&
        TEXT('$')  == GetShareName()[ 1 ]
        &&
        TEXT('A')  <= tcDriveLetter
        &&
        TEXT('Z')  >= tcDriveLetter
      )
    {
        return( TRUE ); // It's a drive share
    }
    else if( !_tcsicmp( TEXT("admin$"), GetShareName() ))
        return( TRUE ); // It's the %windir% share

    else
        return( FALSE );

}


//+----------------------------------------------------------------------------
//
//  Method:     _IsValidShare
//
//  Synopsis:   Returns True if the current share is valid.  A share
//              valid it if it is in the form "<drive letter>:\\".  E.g.
//              "IPC$" isn't a valid share.
//
//  Arguments:  None
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

inline BOOL
CShareEnumerator::_IsValidShare()
{
    TCHAR tcFirstChar;

    // There should be a path, and it should be at least 3 characters
    // (e.g. "D:\")

    if( NULL == GetSharePath() || 3 > QueryCCHSharePath() )
        return FALSE;

    tcFirstChar = TrkCharUpper( GetSharePath()[0] );

    // Make sure that the share path begins with "<Drive>:\\".

    if( TEXT('A') <= tcFirstChar && tcFirstChar <= TEXT('Z')
        &&
        TEXT(':') == GetSharePath()[1]
        &&
        TEXT('\\') == GetSharePath()[2]
        )
    {
        return( TRUE );
    }
    else
        return( FALSE );

}

//+-------------------------------------------------------------------
//
//  Function:   CShareEnumerator::GetMerit
//
//  Synopsis:   Returns the linear (ULONG) merit of the current path.
//              The greater this merit value, the more useful the share
//              is.  This is calculated on the first call to this method,
//              and cached for use in subsequent calls.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Raises:     On error.
//
//--------------------------------------------------------------------

ULONG
CShareEnumerator::GetMerit()
{
    TrkAssert( _fInitialized );

    // The merit of a share is the bitwise-OR of the share's
    // enumAccessLevel, its hidden-ness, and the length of
    // the covered path.
    //
    // Shorter paths are more mertious than longer paths
    // (because they cover more of the volume), so we subtract
    // the path length from the max-value; thus giving shorter
    // paths more weight.

    if( 0 == _ulMerit && _IsValidShare() )
    {
        _ulMerit = ( _GetAccessLevel() )
                   |
                   ( SPC_MAX_COVERAGE - QueryCCHSharePath() )
                   |
                   ( _IsHiddenShare() ? HS_HIDDEN : HS_VISIBLE );
    }

    TrkLog(( TRKDBG_MEND, TEXT("Score %d for %s (%s)"),
             _ulMerit,
             _prgshare_info[ _iCurrentEntry ].shi502_netname,
             _prgshare_info[ _iCurrentEntry ].shi502_path ));
    
    return( _ulMerit );
}


static void SDAllocHelper( BYTE **ppb, ULONG cbCurrent, ULONG cbRequired )
{
    if( cbRequired <= cbCurrent )
        return;

    *ppb = new BYTE[ cbRequired ];
    if( NULL == *ppb )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Failed alloc in SDAllocHelper")));
        TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );
    }

    return;
}

void
CShareEnumerator::_AbsoluteSDHelper( const PSECURITY_DESCRIPTOR pSDRelative,
                                     PSECURITY_DESCRIPTOR *ppSDAbs, ULONG *pcbSDAbs,
                                     PACL *ppDaclAbs,     ULONG *pcbDaclAbs,
                                     PACL *ppSaclAbs,     ULONG *pcbSaclAbs,
                                     PSID *ppSidOwnerAbs, ULONG *pcbSidOwnerAbs,
                                     PSID *ppSidGroupAbs, ULONG *pcbSidGroupAbs  )
{
    ULONG cbSDAbs = *pcbSDAbs;
    ULONG cbDaclAbs = *pcbDaclAbs;
    ULONG cbSaclAbs = *pcbSaclAbs;
    ULONG cbSidOwnerAbs = *pcbSidOwnerAbs;
    ULONG cbSidGroupAbs = *pcbSidGroupAbs;

    for( int i = 0; i < 2; i++ )
    {
        if( !MakeAbsoluteSD( pSDRelative,
			    *ppSDAbs, pcbSDAbs,
			    *ppDaclAbs, pcbDaclAbs,
			    *ppSaclAbs, pcbSaclAbs,
			    *ppSidOwnerAbs, pcbSidOwnerAbs,
			    *ppSidGroupAbs, pcbSidGroupAbs ))
	{
	    if( i > 0 || ERROR_INSUFFICIENT_BUFFER != GetLastError() )
	    {
		TrkLog((TRKDBG_ERROR, TEXT("Couldn't make absolute SD")));
		TrkRaiseLastError( );
	    }

            TrkLog(( TRKDBG_MEND, TEXT("Realloc _AbsoluteSDHelper") ));

            SDAllocHelper( (BYTE**) ppSDAbs, cbSDAbs, *pcbSDAbs );
            SDAllocHelper( (BYTE**) ppDaclAbs, cbDaclAbs, *pcbDaclAbs );
            SDAllocHelper( (BYTE**) ppSaclAbs, cbSaclAbs, *pcbSaclAbs );
            SDAllocHelper( (BYTE**) ppSidOwnerAbs, cbSidOwnerAbs, *pcbSidOwnerAbs );
            SDAllocHelper( (BYTE**) ppSidGroupAbs, cbSidGroupAbs, *pcbSidGroupAbs );
        }
    }

}





//+-------------------------------------------------------------------
//
//  Function:   CShareEnumerator::_GetAccessLevel
//
//  Synopsis:   Determines the "access level" of the current share.
//              The definition of an access level is provided by
//              the enumAccessLevels enumeration in PShareMerit.
//
//              Once calculated, this access level is not cached for
//              subsequent calls, because this method is only called
//              by GetMerit, which provides its own cacheing.
//
//              *** Note:  This is a temporary solution.  This should
//              be replaced with a solution that simply checks security
//              on the share, without actually attempting to open the
//              file.
//
//  Arguments:  None.
//
//  Returns:    An access level in the form of an enumAccessLevels.
//
//  Raises:     On error.
//
//--------------------------------------------------------------------

PShareMerit::enumAccessLevels
CShareEnumerator::_GetAccessLevel()
{

    enumAccessLevels AccessLevel = AL_NO_ACCESS;
    static const int StackBufferSizes = 256;

    TCHAR tszUNCPath[ MAX_PATH + 1 ];
    HANDLE hFile = INVALID_HANDLE_VALUE;
    int iAttempt;
    DWORD rgAccess[] = { GENERIC_READ | GENERIC_WRITE, // => AL_READWRITE_ACCESS
                         GENERIC_READ,                 // => AL_READ_ACCESS
                         GENERIC_WRITE };              // => AL_WRITE_ACCESS

    HANDLE hAccessToken;
    BOOL   fAccessToken = FALSE;

    RPC_STATUS rpc_status;
    DWORD dwStatus;
    DWORD cbActual;
    BOOL fImpersonating = FALSE;

    BYTE rgbTokenUser[StackBufferSizes];
    ULONG cbTokenUser = sizeof(rgbTokenUser);
    TOKEN_USER *pTokenUser = (TOKEN_USER*) rgbTokenUser;

    BYTE rgbTokenGroups[ 4 * StackBufferSizes ];
    ULONG cbTokenGroups = sizeof(rgbTokenGroups);
    TOKEN_GROUPS *pTokenGroups = (TOKEN_GROUPS*) rgbTokenGroups;

    BYTE rgbSDAbs[ StackBufferSizes ];
    ULONG cbSDAbs = sizeof(rgbSDAbs);
    PSECURITY_DESCRIPTOR pSDAbs = (PSECURITY_DESCRIPTOR) rgbSDAbs;

    BYTE rgbDaclAbs[ StackBufferSizes ];
    ULONG cbDaclAbs = sizeof(rgbDaclAbs);
    PACL pDaclAbs = (PACL) rgbDaclAbs;

    BYTE rgbSaclAbs[ StackBufferSizes ];
    ULONG cbSaclAbs = sizeof(rgbSaclAbs);
    PACL pSaclAbs = (PACL) rgbSaclAbs;

    BYTE rgbSidOwnerAbs[ StackBufferSizes ];
    ULONG cbSidOwnerAbs = sizeof(rgbSidOwnerAbs);
    PSID pSidOwnerAbs = (PSID) rgbSidOwnerAbs;

    BYTE rgbSidGroupAbs[ StackBufferSizes ];
    ULONG cbSidGroupAbs = sizeof(rgbSidGroupAbs);
    PSID pSidGroupAbs = (PSID) rgbSidGroupAbs;

    GENERIC_MAPPING Generic_Mapping = { FILE_GENERIC_READ, FILE_GENERIC_WRITE, FILE_GENERIC_EXECUTE, FILE_ALL_ACCESS };

    PRIVILEGE_SET rgPrivilegeSet[ 10 ];
    ULONG cbPrivilegeSet = sizeof(rgPrivilegeSet);
    PRIVILEGE_SET *pPrivilegeSet = rgPrivilegeSet;

    DWORD dwGrantedAccess;
    BOOL fAccessStatus;

    CSID     csidAdministrators;
    CSecDescriptor csdAdministrators;

    PSECURITY_DESCRIPTOR psdCheck = NULL;

    // If there is no security descriptor and this isn't an admin share,
    // it means that Everyone has 'full control'.

    if( NULL == _prgshare_info[ _iCurrentEntry ].shi502_security_descriptor && !_IsAdminShare() )
        return( AL_FULL_ACCESS );


    // Otherwise, we'll look at the share's DACL ...

    __try
    {
        // Impersonate the client
        TrkAssert( NULL != _IDL_handle );

        if( RpcSecurityEnabled() )
        {
            rpc_status = RpcImpersonateClient( _IDL_handle );
            if( S_OK != rpc_status )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't impersonate client")));
                TrkRaiseWin32Error( rpc_status );
            }
            fImpersonating = TRUE;
        }
        else
        {
            if( !ImpersonateSelf( SecurityImpersonation ) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't impersonate self")));
                TrkRaiseLastError( );
            }
            fImpersonating = TRUE;
        }

        // Get the client's access token

        if( !OpenThreadToken( GetCurrentThread(),
                              TOKEN_READ, //TOKEN_ALL_ACCESS,
                              TRUE, // Open as self
                              &hAccessToken ))
        {
            TrkLog((TRKDBG_ERROR, TEXT("Failed OpenThreadToken")));
            TrkRaiseLastError( );
        }
        fAccessToken = TRUE;

        // Get the client's owner SID

	for( int i = 0; i < 2; i++ )
	{
    	    if( !GetTokenInformation( hAccessToken,
                                      TokenUser,
                                      (LPVOID) pTokenUser,
                                      cbTokenUser,
                                      &cbActual ))
	    {
	        if( i > 0 || ERROR_INSUFFICIENT_BUFFER != GetLastError() )
	        {
		    TrkLog((TRKDBG_ERROR, TEXT("Failed GetTokenInformation (TokenUser)")));
		    TrkRaiseLastError( );
	        }

                TrkLog(( TRKDBG_MEND, TEXT("Realloc pTokenUser") ));
	        cbTokenUser = cbActual;
	        pTokenUser = (TOKEN_USER*) new BYTE[ cbTokenUser ];
	        if( NULL == pTokenUser )
		    TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );
	    }
	}

        // Get the client's group SID

	for( i = 0; i < 2; i++ )
	{
	    if( !GetTokenInformation( hAccessToken,
				      TokenGroups,
				      (LPVOID) pTokenGroups,
				      cbTokenGroups,
				      &cbActual ))
	    {
	        if( i > 0 || ERROR_INSUFFICIENT_BUFFER != GetLastError() )
	        {
		    TrkLog((TRKDBG_ERROR, TEXT("Failed GetTokenInformation (TokenGroups)")));
		    TrkRaiseLastError( );
	        }

                TrkLog(( TRKDBG_MEND, TEXT("Realloc pTokenGroups") ));
	        cbTokenGroups = cbActual;
	        pTokenGroups = (TOKEN_GROUPS*) new BYTE[ cbTokenGroups ];
	        if( NULL == pTokenGroups )
		    TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );
	    }
	}
    
        // Get a pointer to the security descriptor we want to check against.

        if( _IsAdminShare() )
        {
            // For admin shares, we don't get a security descriptor in _prgshare_info
            // from the NetShareEnum call.  But, we know what the ACLs on admin shares
            // should be, so we'll craft up an SD.

            csidAdministrators.Initialize( CSID::CSID_NT_AUTHORITY, SECURITY_BUILTIN_DOMAIN_RID,
                                           DOMAIN_ALIAS_RID_ADMINS );

            csdAdministrators.Initialize();
            csdAdministrators.AddAce( CSecDescriptor::ACL_IS_DACL, CSecDescriptor::AT_ACCESS_ALLOWED,
                                      FILE_ALL_ACCESS, csidAdministrators );

            psdCheck = csdAdministrators;

        }
        else
        {
            // Convert the share's Security Descriptor into absolute form.

            _AbsoluteSDHelper( _prgshare_info[ _iCurrentEntry ].shi502_security_descriptor,
                               &pSDAbs, &cbSDAbs,
                               &pDaclAbs, &cbDaclAbs,
                               &pSaclAbs, &cbSaclAbs,
                               &pSidOwnerAbs, &cbSidOwnerAbs,
                               &pSidGroupAbs, &cbSidGroupAbs );

            psdCheck = pSDAbs;
        }
        // The appropriate security descriptor is now in 'psdCheck'

        // Put the client's owner SID in the Security Descriptor.

        if( !SetSecurityDescriptorOwner( psdCheck,
                                         pTokenUser->User.Sid,
                                         FALSE ))
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't add user to SD")));
            TrkRaiseLastError( );
        }

        // Put the client's group SID in the Security Descriptor.
        // (Perf) Why?  I think it's because GetEffectiveRightsFromAcl wasn't working,
        // so we had to use AccessCheck.  But to use that call I think we had to pass
        // in an SD with an owner/group, and the one returned from shi502_security_descriptor
        // didn't have them.

        if( !SetSecurityDescriptorGroup( psdCheck,
                                         pTokenGroups->Groups->Sid,
                                         FALSE ))
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't add group to SD")));
            TrkRaiseLastError( );
        }

        // We have to stop impersonating in order to make the AccessCheck call.

        fImpersonating = FALSE;
        if( RpcSecurityEnabled() )
            RpcRevertToSelf();
        else
            RevertToSelf();

        // Check the access that this user has to this share.  If this returns
        // false, it means that NtAccessCheck returned an error.  If this returns
        // true, but fAccessStatus is false, it means that NtAccessCheck succeeded,
        // but it returned an error in its RealStatus parameter.  In either case,
        // we need to check GetLastError.

        for( i = 0; i < 2; i++ )
        {
            if( !AccessCheck( psdCheck,
                            hAccessToken, MAXIMUM_ALLOWED, &Generic_Mapping,
                            pPrivilegeSet, &cbPrivilegeSet, 
                            &dwGrantedAccess, &fAccessStatus )
                ||
                !fAccessStatus )
            {
                if( i > 0 || ERROR_INSUFFICIENT_BUFFER != GetLastError() )
                {
                    TrkLog((TRKDBG_ERROR, TEXT("Couldn't perform AccessCheck for %s (%08x)"),
                            GetShareName(), HRESULT_FROM_WIN32(GetLastError()) ));
                    TrkRaiseLastError( );
                }

                TrkLog(( TRKDBG_MEND, TEXT("Realloc pPrivilegeSet") ));
                pPrivilegeSet = (PRIVILEGE_SET*) new BYTE[ cbPrivilegeSet ];
                if( NULL == pPrivilegeSet )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Couldn't alloc pPrivilegeSet") ));
                    TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );
                }
            }
        }

        // Reduce this complete list of accesses to a synopsis

        if( AreAllAccessesGranted( dwGrantedAccess, FILE_ALL_ACCESS ))
            AccessLevel = AL_FULL_ACCESS;
        else if( AreAllAccessesGranted( dwGrantedAccess, FILE_GENERIC_READ | FILE_GENERIC_WRITE ))
            AccessLevel = AL_READ_WRITE_ACCESS;
        else if( AreAllAccessesGranted( dwGrantedAccess, FILE_GENERIC_READ ))
            AccessLevel = AL_READ_ACCESS;
        else if( AreAllAccessesGranted( dwGrantedAccess, FILE_GENERIC_WRITE ))
            AccessLevel = AL_WRITE_ACCESS;
        else
            AccessLevel = AL_NO_ACCESS;

    }
    __finally
    {

        csdAdministrators.UnInitialize();
        csidAdministrators.UnInitialize();

        if( fAccessToken )
            CloseHandle( hAccessToken );

        if( fImpersonating )
        {
            if( RpcSecurityEnabled() )
                RpcRevertToSelf();
            else
                RevertToSelf();
        }

        if( rgPrivilegeSet != pPrivilegeSet )
            delete[] pPrivilegeSet;

        if( rgbTokenUser != (BYTE*) pTokenUser )
            delete[] pTokenUser;
        if( rgbTokenGroups != (BYTE*) pTokenGroups )
            delete[] pTokenGroups;

        if( rgbSDAbs != (BYTE*) pSDAbs )
            delete[] pSDAbs;
        if( rgbDaclAbs != (BYTE*) pDaclAbs )
            delete[] pDaclAbs;
        if( rgbSaclAbs != (BYTE*) pSaclAbs )
            delete[] pSaclAbs;
        if( rgbSidOwnerAbs != (BYTE*) pSidOwnerAbs )
            delete[] pSidOwnerAbs;
        if( rgbSidGroupAbs != (BYTE*) pSidGroupAbs )
            delete[] pSidGroupAbs;

    }

    return( AccessLevel );

}

//+-------------------------------------------------------------------
//
//  Function:   CShareEnumerator::GenerateUNCPath
//
//  Synopsis:   Generate a UNC path to the give drive-based path
//              WRT to the current share.
//
//  Arguments:  [ptszUNCPath] (out)
//                  Filled with the generated UNC path.  This 
//                  is assumed to be at least MAX_PATH+1 characters.
//
//              [ptszDrivePath] (in)
//                  The drive-based path to the file.
//                  E.g. "c:\my documents\wordfile.doc".
//
//  Returns:    FALSE if the current share doesn't cover the
//              file, TRUE otherwise.
//
//  Raises:     On error.
//
//--------------------------------------------------------------------

BOOL
CShareEnumerator::GenerateUNCPath( TCHAR *ptszUNCPath, const TCHAR * ptszDrivePath )
{
    TrkAssert( _fInitialized );
    TrkAssert( TEXT(':') == ptszDrivePath[1] );

    // Ensure that this share covers the drive-based path.

    if( !CoversDrivePath( ptszDrivePath ))
        return( FALSE );

    // Start out the UNC name with the \\machine\share.

    _tcscpy( ptszUNCPath, _tszMachineName );
    _tcscat( ptszUNCPath, TEXT("\\") );
    _tcscat( ptszUNCPath, GetShareName() );
    _tcscat( ptszUNCPath, TEXT("\\") );

    // Finish the UNC name with the portion of the
    // volume path which is under the share path.

    _tcscat( ptszUNCPath, &ptszDrivePath[ QueryCCHSharePath() ] );

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\common\timer.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       timer.cxx
//
//  Contents:   Code for a timer.
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop
#include "trklib.hxx"

BOOL
LoadPersistentFileTime(
    const TCHAR * ptszStaticRegName,
    CFILETIME * pcft
    );

void
UpdatePersistentFileTime(
    const TCHAR * ptszStaticRegName,
    const CFILETIME & cft
    );

void
RemovePersistentFileTime(
    const TCHAR * ptszStaticRegName
    );



//+----------------------------------------------------------------------------
//
//  Method:     CNewTimer::Initiliaze
//
//  Synopsis:   Initialize the object and create the timer but don't set it
//              yet.
//
//  Inputs:     [pTimerCallback] (in)
//                  Who to call when the timer fires.
//              [pWorkManager] (in)
//                  The WorkManager with which the timer will be registered
//              [ptszName] (in, optional)
//                  If specified, the timer is persistent, and the name is
//                  used to store the timer information in the registry.
//                  If not specified the timer is not persistent.
//                  If data already exists in the registry for this name, it
//                  is used the next time the timer is set.
//              [ulTimerContext] (in)
//                  Passed to pTimerCallback->Timer.
//              [ulPeriodInSeconds] (in)
//                  The length of this timer when it's set.
//              [retrytype] (in)
//                  From the TimerRetryType enumeration.  Can 
//                  be no_retry, retry_randomly, or retry_with_backoff.
//              [ulLowerRetryTime] (in)
//                  Only valid when retrytype isn't no_retry.
//              [ulUpperRetryTime] (in)
//                  Only valid when retrytype isn't no_retry.
//              [ulMaxLifetime] (in)
//                  Only valid when retrytype isn't no_retry.
//
//  Returns:    Void
//
//+----------------------------------------------------------------------------

void
CNewTimer::Initialize( PTimerCallback *pTimerCallback,
                       const TCHAR *ptszName,
                       ULONG ulTimerContext,
                       ULONG ulPeriodInSeconds,
                       TimerRetryType retrytype,
                       ULONG ulLowerRetryTime,
                       ULONG ulUpperRetryTime,
                       ULONG ulMaxLifetime )
{
    NTSTATUS Status = STATUS_SUCCESS;
    CFILETIME cftLastTimeSet;


    TrkAssert( ulLowerRetryTime <= ulUpperRetryTime );
    TrkAssert( NO_RETRY == retrytype
               ||
               0 != ulLowerRetryTime
               &&
               0 != ulUpperRetryTime );
    TrkAssert( NO_RETRY != retrytype || 0 == ulMaxLifetime );

    // Initialize our critical section.  _fIntitializeCalled is used to 
    // indicate that this has been done.

    _cs.Initialize();
    _fInitializeCalled = TRUE;

    // Keep the parameters

    _pTimerCallback = pTimerCallback;
    _ptszName = ptszName;
    _ulTimerContext = ulTimerContext;
    _ulPeriodInSeconds = ulPeriodInSeconds;
    _RetryType = retrytype;
    _ulLowerRetryTime = ulLowerRetryTime;
    _ulUpperRetryTime = ulUpperRetryTime;
    _ulMaxLifetime = ulMaxLifetime;

#if DBG
    // Set the workitem signature for use in debug outputs.
    _stprintf( _tszWorkItemSig, TEXT("CTimer:%p"), this );
    if( NULL != ptszName )
    {
        _tcscat( _tszWorkItemSig, TEXT("/") );
        _tcscat( _tszWorkItemSig, ptszName );
    }
    TrkAssert( _tcslen(_tszWorkItemSig) < ELEMENTS(_tszWorkItemSig) );
#endif

    // Create the NT timer.

    Status = NtCreateTimer(
                &_hTimer,
                TIMER_ALL_ACCESS,
                NULL,
                SynchronizationTimer );  // this sort of timer becomes un-signalled
                                         // when a wait is satisfied
    if (!NT_SUCCESS(Status))
    {
        _hTimer = NULL;
        TrkRaiseNtStatus(Status);
    }

    // If this is a persistent timer, load the persisted state from the
    // registry.

    LoadFromRegistry();

    // Register a work item with the Win32 thread pool.

    _hRegisterWaitForSingleObjectEx
        = TrkRegisterWaitForSingleObjectEx( _hTimer, ThreadPoolCallbackFunction,
                                            static_cast<PWorkItem*>(this), INFINITE,
                                            WT_EXECUTELONGFUNCTION | WT_EXECUTEDEFAULT );

    if( NULL == _hRegisterWaitForSingleObjectEx )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RegisterWaitForSingleObjectEx in CNewTimer::Initialize (%lu) for %s)"),
                 GetLastError(),  GetTimerName() ));
        TrkRaiseLastError();
    }
    else
        TrkLog(( TRKDBG_TIMER, TEXT("Registered timer %s with thread pool (%p/%p)"),
                 GetTimerName(), this, *reinterpret_cast<UINT_PTR*>(this) ));

}   // CNewTimer::Initialize


//+----------------------------------------------------------------------------
//
//  Method:     CNewTimer::SetTimer
//
//  Synopsis:   Start the timer.  If _cftDue isn't already set, we'll use
//              _ulPeriodInSeconds (or _ulCurrentRetryTime) to set it.  If this
//              is a persistent timer, the registry is updated.
//
//+----------------------------------------------------------------------------

void
CNewTimer::SetTimer()
{
    NTSTATUS Status;
    CFILETIME cftNow, cftMax(0);

    TrkAssert(NULL != _hTimer);
    TrkAssert(sizeof(LARGE_INTEGER) == sizeof(_cftDue));


    // If we're already running and not in retry mode, then there's nothing
    // to be done.

    if( _fRunning && 0 == _ulCurrentRetryTime )
        return;

    // Has the due time already been determined?
    if( 0 == _cftDue )
    {
        // Are we in retry mode?
        if( 0 != _ulCurrentRetryTime )
        {
            _cftDue = cftNow;
            _cftDue.IncrementSeconds( _ulCurrentRetryTime );
        }
        else
        {
            _cftDue = cftNow;
            _cftDue.IncrementSeconds( _ulPeriodInSeconds );
            _cftSet = cftNow;
        }
    }

    // We already have a non-zero due time.  That doesn't mean that we're running,
    // though, it might be a persistent timer that's been initialized but not
    // started.

    else if( _fRunning )
    {
        TrkAssert( 0 != _ulCurrentRetryTime );

        // This timer was in retry mode but is now being started again.
        // Restart as if it was being started for the first time.

        _ulCurrentRetryTime = 0;
        _cftDue = _cftSet = cftNow;
        _cftDue.IncrementSeconds( _ulPeriodInSeconds );
    }

    if( 0 < _ulMaxLifetime )
    {
        cftMax = _cftSet;
        cftMax.IncrementSeconds( _ulMaxLifetime );

        if( cftNow > cftMax )
        {
            TrkLog(( TRKDBG_TIMER, TEXT("Stopping timer %s/%p due to liftime limit"),
                     (NULL == _ptszName) ? TEXT("") : _ptszName,
                     this ));
            Cancel();
            return;
        }

        else if( _cftDue > cftMax )
        {
            TrkLog(( TRKDBG_TIMER, TEXT("Shortening timer %s/%p due to lifetime limit"),
                     (NULL == _ptszName) ? TEXT("") : _ptszName,
                     this ));
            _cftDue = cftMax;
        }
    }

    SaveToRegistry();

    // Set the timer, but not if it's currently firing.  When the timer
    // fires, the DoWork method is called, but that method doesn't hold
    // the lock while it calls the Timer callback.  Thus, if 
    // _fTimerSignalInProgress is true, some other thread is currently
    // in the callback.  When it complets, it will set this timer.

    if( !_fTimerSignalInProgress )
    {
        Status = NtSetTimer ( _hTimer, //IN HANDLE TimerHandle,
                              (LARGE_INTEGER*) &_cftDue,      //IN PLARGE_INTEGER DueTime,
                              NULL,    //IN PTIMER_APC_ROUTINE TimerApcRoutine OPTIONAL,
                              NULL,    //IN PVOID TimerContext OPTIONAL,
                              FALSE,   //IN BOOLEAN ResumeTimer,
                              0,       //IN LONG Period OPTIONAL,
                              NULL );  //OUT PBOOLEAN PreviousState OPTIONAL
        TrkAssert(NT_SUCCESS(Status));
    }

    _fRunning = TRUE;

}   // CNewTimer::SetTimer



//+----------------------------------------------------------------------------
//
//  Method:     CNewTimer::Cancel
//
//  Synopsis:   Cancel the timer and remove its persistent state from the
//              registry (if it's a persistent timer).
//
//+----------------------------------------------------------------------------

void
CNewTimer::Cancel()
{
    NTSTATUS Status;

    TrkAssert( _fInitializeCalled );

    Lock();
    __try
    {
        Status = NtCancelTimer(_hTimer, NULL);
        TrkAssert(NT_SUCCESS(Status));

        _fRunning = FALSE;
        _ulCurrentRetryTime = 0;
        _cftDue = _cftSet = 0;

        RemoveFromRegistry();

    }
    __finally
    {
        Unlock();
    }

}



//+----------------------------------------------------------------------------
//
//  Method:     CNewTimer::DebugStringize
//
//  Synopsis:   Stringize the current state of the timer.
//
//+----------------------------------------------------------------------------

#if DBG
void
CNewTimer::DebugStringize( ULONG cch, TCHAR *ptsz ) const
{
    ULONG cchUsed = 0;
    TCHAR *ptszTimerState;

    TrkAssert( _fInitializeCalled );

    Lock();
    __try
    {
        if( _fRunning )
        {
            if( 0 != _ulCurrentRetryTime )
                ptszTimerState = TEXT("retrying");
            else
                ptszTimerState = TEXT("running");
        }
        else
            ptszTimerState = TEXT("stopped");

        cchUsed = _stprintf( ptsz, TEXT("Timer %s/%p is %s "), 
                                   NULL == _ptszName ? TEXT("") : _ptszName,
                                   this,  ptszTimerState );

        if( _fRunning )
        {
            LONGLONG llDelta;
            llDelta = static_cast<LONGLONG>(_cftDue - CFILETIME()) / (10*1000*1000);

            if( 0 <= llDelta && 120 >= llDelta )
                cchUsed += _stprintf( &ptsz[cchUsed], TEXT("(expires in %I64i seconds)"), llDelta );
            else
            {
                cchUsed += _stprintf( &ptsz[cchUsed], TEXT("(expires on ") );
                _cftDue.Stringize( cch-cchUsed, &ptsz[cchUsed] );
                cchUsed += _tcslen( &ptsz[cchUsed] );
                cchUsed += _stprintf( &ptsz[cchUsed], TEXT(" UTC)") );
            }
        }

        TrkAssert( cch >= cchUsed );
    }
    __finally
    {
        Unlock();
    }
}
#endif



//+----------------------------------------------------------------------------
//
//  Method:     CNewTimer::DoWork
//
//  Synopsis:   This method is called by the work manager when the NT timer
//              is signaled.  We call pTimerCallback->Timer so that the timer
//              event can be handled.  That Timer method returns a status
//              that tells us what we should do next.  The returned status
//              is a TimerContinuation, that can be Continue (causes
//              a recurring timer to be set again), Break (causes a recurring
//              timer to be stopped), or Retry.
//
//+----------------------------------------------------------------------------

void
CNewTimer::DoWork()
{
    TrkAssert( _fInitializeCalled );

    PTimerCallback::TimerContinuation continuation;

    Lock();
    {
        // We were obviously running recently, or we wouldn't have been called.
        // But if we're not running now, we must have been canceled after the 
        // timer object was signaled (waking the WaitForMultiple) but before
        // entry into this routine.

        if( !_fRunning )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Timer %s/%p stopped while firing"),
                     NULL == _ptszName ? TEXT("") : _ptszName,
                     this ));
            Unlock();
            return;
        }

        // For now, we're no longer running.  If someone calls Set* while we're in
        // the Timer callback below, this will be set true.
        _fRunning = FALSE;
        _cftDue = 0;


        // Show that the timer has fired and is being processed.  This is used
        // by SetTimer so that it knows that we're in a call to the Timer
        // callback.
        _fTimerSignalInProgress = TRUE;
    }
    TrkAssert( 1 == GetLockCount() );
    Unlock();

    // Call the timer handler.  On return, it tells us how we should
    // proceed.

    continuation = _pTimerCallback->Timer( _ulTimerContext );
    // continuation : {Break, Continue, Retry}

    Lock();
    __try   // __except
    {
        // We're no longer in the timer callback.
        _fTimerSignalInProgress = FALSE;

        // If, while we were in the Timer callback, another thread came along
        // and set the timer, then that takes priority over the
        // continuation that was just returned.  In such an case, _fRunning
        // will have been set to TRUE.

        if( _fRunning )
        {
            TrkAssert( 0 != _cftDue );
            TrkAssert( NULL != _hTimer );

            // Show that we're not in retry mode
            _ulCurrentRetryTime = 0;

            NTSTATUS Status;

            // _cftDue was set in the SetTimer call already

            Status = NtSetTimer ( _hTimer, //IN HANDLE TimerHandle,
                                  (LARGE_INTEGER*) &_cftDue,      //IN PLARGE_INTEGER DueTime,
                                  NULL,    //IN PTIMER_APC_ROUTINE TimerApcRoutine OPTIONAL,
                                  NULL,    //IN PVOID TimerContext OPTIONAL,
                                  FALSE,   //IN BOOLEAN ResumeTimer,
                                  0,       //IN LONG Period OPTIONAL,
                                  NULL );  //OUT PBOOLEAN PreviousState OPTIONAL
            TrkAssert(NT_SUCCESS(Status));
        }

        else if( PTimerCallback::BREAK_TIMER == continuation )
        {
            // Break out of this timer; stop it even if it's a recurring timer.
            Cancel();
        }

        else if( PTimerCallback::CONTINUE_TIMER == continuation )
        {
            // Continue with this timer; stop it if it's a single shot, set it again
            // if it's recurring.

            _ulCurrentRetryTime = 0;    // If we were retrying, we aren't any longer

            if( _fRecurring )
                SetTimer();
            else
                Cancel();
        }

        else    // RETRY_TIMER
        {
            TrkAssert( PTimerCallback::RETRY_TIMER == continuation );
            TrkAssert( _ulLowerRetryTime <= _ulUpperRetryTime );

            if( 0 == _ulUpperRetryTime || NO_RETRY == _RetryType )
            {
                TrkAssert( !TEXT("Attempted to retry a timer with no retry times set") );
                Cancel();
            }

            if( RETRY_WITH_BACKOFF == _RetryType )
            {
                if( 0 == _ulCurrentRetryTime )
                    _ulCurrentRetryTime = _ulLowerRetryTime;
                else if( (MAXULONG/2) < _ulCurrentRetryTime )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Questionable retry time") ));
                    TrkAssert( FALSE );
                    _ulCurrentRetryTime = MAXULONG;
                }
                else
                    _ulCurrentRetryTime *= 2;

                if( _ulCurrentRetryTime > _ulUpperRetryTime )
                    _ulCurrentRetryTime = _ulUpperRetryTime;

            }
            else // PTimerCallback::RETRY_RANDOMLY == _RetryType
            {
                CFILETIME cftNow;

                _ulCurrentRetryTime = _ulLowerRetryTime
                                      +
                                      ( QuasiRandomDword() % (_ulUpperRetryTime - _ulLowerRetryTime) );

            }

            TrkLog(( TRKDBG_TIMER, TEXT("Retrying timer %s/%p for %d seconds"),
                     (NULL == _ptszName) ? TEXT("") : _ptszName,
                     this,
                     _ulCurrentRetryTime ));

            // Set the timer with the just-calculated retry period
            SetTimer();

        }   // else if( CONTINUE_TIMER == continuation ) ... else
    }
    __except( BreakOnDebuggableException() )
    {
        // The exception may have been in the timer, but more likely
        // was in the PTimerCallback::Timer routine.  As a cure-all,
        // just reset the timer to an arbitrary value (we don't want
        // to re-use _ulPeriodInSeconds, because it may be zero).

        TrkLog(( TRKDBG_ERROR, TEXT("Unexpected timer exception") ));
        TrkAssert( FALSE );

        __try
        {
            _ulPeriodInSeconds = TRKDAY;
            Cancel();
            SetTimer();
        }
        __except( BreakOnDebuggableException() )
        {
        }
    }

    Unlock();

}   // CNewTimer::DoWork


//+----------------------------------------------------------------------------
//
//  Method:     CNewTimer::SaveToRegistry
//
//  Synopsis:   Save the timer's state to the registry, using _ptszName
//              as a value name.
//
//+----------------------------------------------------------------------------

void
CNewTimer::SaveToRegistry()
{
    LONG lErr = ERROR_SUCCESS;

    HKEY hk = NULL;

    // If this isn't a persistent timer, then there's nothing to do.
    if( NULL == _ptszName )
        return;

    Lock();
    __try
    {
        lErr = RegOpenKey( HKEY_LOCAL_MACHINE, s_tszKeyNameLinkTrack, &hk );

        PersistentState persist;

        persist.cftSet = _cftSet;
        persist.cftDue = _cftDue;
        persist.ulCurrentRetryTime = _ulCurrentRetryTime;

        if ( lErr == ERROR_SUCCESS )
        {

            lErr = RegSetValueEx(  hk,
                                   _ptszName,
                                   0,
                                   REG_BINARY,
                                   (CONST BYTE *)&persist,
                                   sizeof(persist) );
            RegCloseKey(hk);
        }
    }
    __finally
    {
        Unlock();
    }

    TrkAssert( lErr == ERROR_SUCCESS
               ||
               lErr == ERROR_NOT_ENOUGH_MEMORY
               ||
               lErr == ERROR_NO_SYSTEM_RESOURCES );
}


//+----------------------------------------------------------------------------
//
//  Method:     CNewTimer::LoadFromRegistry
//
//  Synopsis:   Load this timer's previously persisted state from the
//              registry.
//
//+----------------------------------------------------------------------------

void
CNewTimer::LoadFromRegistry()
{

    LONG l;
    HKEY hk = NULL;

    // If this isn't a persistent timer, then there's nothing to do.
    if( NULL == _ptszName )
        return;

    Lock();
    __try
    {
        // Open the main link-tracking key.

        l = RegCreateKey(HKEY_LOCAL_MACHINE, s_tszKeyNameLinkTrack, &hk);
        if (l != ERROR_SUCCESS)
        {
            hk = NULL;
        }
        else
        {
            // The main link-tracking key exists.  See if we can open this 
            // timer's value.

            PersistentState persist;
            DWORD cbData = sizeof(persist);
            DWORD dwType = 0;

            l = RegQueryValueEx( hk,
                             _ptszName,
                             NULL,
                             &dwType,
                             (BYTE *)&persist,
                             &cbData );

            if (l == ERROR_SUCCESS)
            {
                if (dwType == REG_BINARY
                    &&
                    cbData == sizeof(persist))
                {

                    // This timer has a persistent value in the registry.  Override
                    // the caller-provided timeout.
    
                    _cftDue = persist.cftDue;
                    _cftSet = persist.cftSet;
                    _ulCurrentRetryTime = persist.ulCurrentRetryTime;
                }
                else
                {
                    RegDeleteValue( hk, _ptszName );
                    l = ERROR_FILE_NOT_FOUND;
                }
            }   // if (l == ERROR_SUCCESS)
        }   // if (l != ERROR_SUCCESS) ... else
    }
    __finally
    {
        if( NULL != hk )
            RegCloseKey(hk);

        Unlock();
    }

    if (l != ERROR_SUCCESS && l != ERROR_FILE_NOT_FOUND)
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring error %08x in timer %s LoadFromRegistry"),
                 l, _ptszName ));
    }

    return;
}



//+----------------------------------------------------------------------------
//
//  Method:     CNewTimer::RemoveFromRegistry
//
//  Synopsis:   Remove this timer's persistent state from the registry.
//
//+----------------------------------------------------------------------------

void
CNewTimer::RemoveFromRegistry()
{
    LONG lErr = ERROR_SUCCESS;
    HKEY hk = NULL;

    if( NULL == _ptszName )
        return;

    Lock();
    __try
    {
        lErr = RegOpenKey( HKEY_LOCAL_MACHINE, s_tszKeyNameLinkTrack, &hk );

        if ( lErr == ERROR_SUCCESS )
        {
            lErr = RegDeleteValue(  hk, _ptszName );
            RegCloseKey(hk);

            if( ERROR_SUCCESS != lErr
                &&
                ERROR_PATH_NOT_FOUND != lErr
                &&
                ERROR_FILE_NOT_FOUND != lErr )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't delete timer's static reg name (\"%s\", %08x)"),
                        _ptszName, lErr ));
            }
        }
    }
    __finally
    {
        Unlock();
    }

}



//+----------------------------------------------------------------------------
//
//  CNewTimer::UnInitialize
//
//  Unregister the timer handle from the thread pool, cancel the timer,
//  and release it.
//
//+----------------------------------------------------------------------------

void
CNewTimer::UnInitialize()
{
    if( _fInitializeCalled )
    {
        TrkLog(( TRKDBG_TIMER, TEXT("Uninitializing timer %s/%p"), GetTimerName(), this ));

        // Take the timer out of the thread pool, which must be
        // done before closing the timer.

        if( NULL != _hRegisterWaitForSingleObjectEx )
        {
            if( !TrkUnregisterWait( _hRegisterWaitForSingleObjectEx ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Failed UnregisterWait for CNewTimer (%s/%p, %lu)"),
                         NULL == _ptszName ? TEXT("") : _ptszName, this,
                         GetLastError() ));
            }
            else
            {
                TrkLog(( TRKDBG_TIMER, TEXT("Unregistered wait for timer (%s/%p)"),
                         NULL == _ptszName ? TEXT("") : _ptszName, this ));
            }
            _hRegisterWaitForSingleObjectEx = NULL;
        }

        // Close the timer handle

        TrkVerify( NT_SUCCESS( NtCancelTimer(_hTimer, NULL) ));
        NtClose(_hTimer);

        // Delete the CNewTimer critical section.

        _cs.UnInitialize();

        _fInitializeCalled = FALSE;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\dltadmin\backup.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//--------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>
#include "trkwks.hxx"
#include "trksvr.hxx"
#include "dltadmin.hxx"

BOOL
DltAdminBackupRead( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    NTSTATUS status;
    HRESULT hr = S_OK;;
    HANDLE hSource = NULL;
    HANDLE hBackup = NULL;
    BYTE rgb[ 8 * 1024 ];
    ULONG cbRead, cbWritten;
    void *pvBackup = NULL;

    if( 1 <= cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption BackupRead\n"
                  "   Purpose: Run the BackupRead API on a file\n"
                  "   Usage:   -backupread <file to be read> <read data>\n"
                  "   E.g.:    -backupread file.tst file.tst.bak\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    if( 2 > cArgs )
    {
        printf( "Invalid parameters.  Use -? for usage info\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    // Open the source file

    hSource = CreateFile( rgptszArgs[0],
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          0,
                          NULL );
    if( INVALID_HANDLE_VALUE == hSource )
    {
        printf( "Failed to open file (%lu)\n", GetLastError() );
        return FALSE;
    }

    // Open the backup file
                          
    hBackup = CreateFile( rgptszArgs[1],
                          GENERIC_READ | GENERIC_WRITE,
                          0,
                          NULL,
                          CREATE_ALWAYS,
                          0,
                          NULL );
    if( INVALID_HANDLE_VALUE == hBackup )
    {
        printf( "Failed to open backup file (%lu)\n", GetLastError() );
        return FALSE;
    }
    

    while( TRUE )
    {
        if( !BackupRead( hSource,
                         rgb,
                         sizeof(rgb),
                         &cbRead,
                         FALSE,
                         FALSE, //TRUE,
                         &pvBackup ))
        {
            printf( "Failed BackupRead (%lu)\n", GetLastError() );
            return FALSE;
        }

        if( !WriteFile( hBackup, rgb, cbRead, &cbWritten, NULL ))
        {
            printf( "Failed WriteFile (%lu)\n", GetLastError() );
            return FALSE;
        }

        if( cbRead < sizeof(rgb) )
            break;
    }

    // Free resources
    BackupRead( hSource, rgb, sizeof(rgb), &cbRead, TRUE, TRUE, &pvBackup );

    CloseHandle( hSource );
    CloseHandle( hBackup );

    return TRUE;

}


BOOL
DltAdminBackupWrite( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    NTSTATUS status;
    HRESULT hr = S_OK;;
    HANDLE hRestore = NULL;
    HANDLE hBackup = NULL;
    BYTE rgb[ 8 * 1024 ];
    ULONG cbRead, cbWritten;
    void *pvBackup = NULL;

    if( 1 <= cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption BackupWrite\n"
                  "   Purpose: Run the BackupWrite API on a file\n"
                  "   Usage:   -backupread <backup file> <restored file>\n"
                  "   E.g.:    -backupread file.tst.bak file.tst\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    if( 2 > cArgs )
    {
        printf( "Invalid parameters.  Use -? for usage info\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    // Open the backup file

    hBackup = CreateFile( rgptszArgs[0],
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          0,
                          NULL );
    if( INVALID_HANDLE_VALUE == hBackup )
    {
        printf( "Failed to open backup file (%lu)\n", GetLastError() );
        return FALSE;
    }

    // Open the restore file
                          
    hRestore = CreateFile( rgptszArgs[1],
                           GENERIC_READ | GENERIC_WRITE | WRITE_DAC,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_FLAG_BACKUP_SEMANTICS,
                           NULL );
    if( INVALID_HANDLE_VALUE == hRestore )
    {
        printf( "Failed to open restore file (%lu)\n", GetLastError() );
        return FALSE;
    }
    

    while( TRUE )
    {
        if( !ReadFile( hBackup, rgb, sizeof(rgb), &cbRead, NULL ))
        {
            printf( "Failed ReadFile (%lu)\n", GetLastError() );
            return FALSE;
        }

        if( !BackupWrite( hRestore,
                          rgb,
                          cbRead,
                          &cbWritten,
                          FALSE,
                          FALSE, //TRUE,
                          &pvBackup ))
        {
            printf( "Failed BackupWrite (%lu)\n", GetLastError() );
            return FALSE;
        }

        if( cbRead < sizeof(rgb) )
            break;
    }

    // Free resources
    BackupWrite( hRestore, rgb, 0, &cbWritten, TRUE, TRUE, &pvBackup );

    CloseHandle( hRestore );
    CloseHandle( hBackup );

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\dltadmin\cleanvol.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>
#include "trkwks.hxx"
#include "dltadmin.hxx"


class CLogFileNotify : public PLogFileNotify
{
    void OnHandlesMustClose()
    {
        return;
    }
};


BOOL
EmptyLogFile( LONG iVol )
{
    LogInfo loginfo, loginfoNew;
    CLogFile logfile;
    BOOL fSuccess = FALSE;
    TCHAR tszFile[ MAX_PATH + 1 ];
    CTrkWksConfiguration wksconfig;
    CLogFileNotify logfilenotify;

    __try
    {
        wksconfig.Initialize();

        memset( &loginfo, 0, sizeof(loginfo) );
        memset( &loginfoNew, 0, sizeof(loginfoNew) );

        logfile.Initialize( static_cast<const TCHAR*>(CVolumeDeviceName(iVol)),
                            &wksconfig, &logfilenotify, VolChar(iVol) );
        logfile.ReadExtendedHeader( CLOG_LOGINFO_START, &loginfo, sizeof(loginfo) );

        loginfoNew.ilogStart = loginfoNew.ilogWrite = loginfoNew.ilogRead = 0;
        loginfoNew.ilogLast = loginfoNew.ilogEnd = loginfo.ilogEnd;

        loginfoNew.seqNext = 0;
        loginfoNew.seqLastRead = loginfoNew.seqNext - 1;

        logfile.WriteExtendedHeader( CLOG_LOGINFO_START, &loginfoNew, sizeof(loginfoNew) );
        logfile.SetShutdown( TRUE );

        logfile.InitializeLogEntries( 0, logfile.NumEntriesInFile() - 1 );

        _tprintf( TEXT("    Emptied log\n" ) );
        fSuccess = TRUE;
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        logfile.UnInitialize();
    }

    return( fSuccess );
}


BOOL
DeleteLogFile( LONG iVol )
{
    NTSTATUS status;
    BOOL fSuccess = FALSE;
    TCHAR tszFile[ MAX_PATH + 1 ];

    __try   // __except
    {
        status = SetVolId( iVol, CVolumeId() );
        if( !NT_SUCCESS(status) )
        {
            _tprintf( TEXT("    Couldn't delete vol ID (%08x)\n"), status );
            __leave;
        }

        _tcscpy( tszFile, static_cast<const TCHAR*>(CVolumeDeviceName(iVol)) );
        _tcscat( tszFile, s_tszLogFileName );

        for( int i = 0; i < 4; i ++ )
        {
            // Delete the file

            if(!DeleteFile( tszFile ))
            {
                LONG lLastError = GetLastError();
                if( ERROR_FILE_NOT_FOUND != lLastError
                    &&
                    ERROR_PATH_NOT_FOUND != lLastError )
                {
                    _tprintf(TEXT("    Couldn't delete %s (%08x)\n"), tszFile, GetLastError());
                }
            }
            else
                _tprintf( TEXT("    Deleted %s\n"), tszFile );

            if( 1 & i ) // 1, 3
            {
                CDirectoryName dirname;
                dirname.SetFromFileName( tszFile );

                if(!RemoveDirectory( dirname ))
                {
                    LONG lLastError = GetLastError();
                    if( ERROR_FILE_NOT_FOUND != lLastError )
                    {
                       _tprintf(TEXT("    Couldn't delete %s (%lu)\n"),
                                     static_cast<const TCHAR*>(dirname), lLastError);
                    }
                }
                else
                    _tprintf( TEXT("    Deleted %s\n"), static_cast<const TCHAR*>(dirname) );

                _tcscpy( tszFile, static_cast<const TCHAR*>(CVolumeDeviceName(iVol)) );
                _tcscat( tszFile, s_tszOldLogFileName );

            }
            else
                _tcscat( tszFile, TEXT(".bak") );

        }

        fSuccess = TRUE;
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        _tprintf( TEXT("Exception %08x in DeleteLogFileAndOids"), GetExceptionCode() );
    }

    return( fSuccess );

}

BOOL
DltAdminCleanVol( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    NTSTATUS status = 0;
    TCHAR* ptcTmp = NULL;
    LONG iVol, iVolChar = 0;
    BOOL fSuccess = TRUE;
    BOOL fEmptyLog = FALSE;

    *pcEaten = 0;

    if( 1 <= cArgs )
    {
        _tcsupr( rgptszArgs[0] );

        if( IsHelpArgument( rgptszArgs[0] ))
        {
            printf( "\nOption CleanVol\n"
                      "   Purpose:  Clean all the IDs (object and volume) a volume\n"
                      "   Usage:    -cleanvol [options] [drive letter]\n"
                      "   Options:  -e  Empty log rather than deleting it\n"
                      "   E.g.:     -cleanvol -r D:\n"
                      "             -cleanvol\n"
                      "   Note:     If no drive is specified, all drives will be cleaned\n" );
            *pcEaten = 1;
            return( TRUE );
        }

        if( TEXT('-') == rgptszArgs[0][0]
            ||
            TEXT('/') == rgptszArgs[0][0] )
        {
            (*pcEaten)++;
            switch( rgptszArgs[0][1] )
            {
            case 'E':
                fEmptyLog = TRUE;
                break;
            default:
                _tprintf( TEXT("Invalid option.  Use -cleanvol -? for help\n") );
                return( TRUE );
            }

            iVolChar = 1;
        }
        else
            iVolChar = 0;
    }


    if( iVolChar < cArgs )
    {
        (*pcEaten)++;
        _tcsupr( rgptszArgs[iVolChar] );
        iVol = *rgptszArgs[iVolChar] - TEXT('A');
    }
    else
        iVol = 0;

    EnablePrivilege( SE_RESTORE_NAME );

    while( iVol < 26 )
    {
        if( IsLocalObjectVolume( iVol ))
        {
            LONG lLastError = 0;

            printf( "Cleaning volume %c:\n", iVol+TEXT('A') );

            if( fEmptyLog )
                fSuccess = EmptyLogFile( iVol );
            else
                fSuccess = DeleteLogFile( iVol );

            __try // except
            {
                CObjId                  objid;
                CDomainRelativeObjId    droid;
                CObjIdEnumerator        oie;
                ULONG                   cObjId = 0;

                if(oie.Initialize(CVolumeDeviceName(iVol)) == TRUE)
                {
                    if(oie.FindFirst(&objid, &droid))
                    {
                        do
                        {
                            DelObjId( iVol, objid );
                            cObjId++;
                        } while(oie.FindNext(&objid, &droid));

                        printf( "    Deleted %d object ID%s\n",
                                cObjId,
                                1 == cObjId ? "" : "s" );
                    }
                }
            }
            __except( BreakOnDebuggableException() )
            {
            }

        }   // if( IsLocalObjectVolume( iVol ))

        if( 1 <= cArgs ) break;
        iVol++;

    }   // while( iVol < 26 )

    return( fSuccess );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\dltadmin\config.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>
#include "trkwks.hxx"
#include "dltadmin.hxx"



HRESULT
SendParameterValueToService( BOOL fTrkWks, DWORD dwParameter, DWORD dwValue )
{
    HRESULT hr = E_FAIL;
    RPC_STATUS  rpcstatus;
    RPC_TCHAR * ptszStringBinding;
    RPC_BINDING_HANDLE hBinding = NULL;
    BOOL fBound = FALSE;
    TRKSVR_MESSAGE_UNION Msg;

    if( !fTrkWks )
        return( HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED ));

    rpcstatus = RpcStringBindingCompose( NULL, TEXT("ncalrpc"), NULL, TEXT("trkwks"),
                                         NULL, &ptszStringBinding);

    if( rpcstatus )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcStringBindingCompose %lu"), rpcstatus ));
        hr = HRESULT_FROM_WIN32(rpcstatus);
        goto Exit;
    }

    rpcstatus = RpcBindingFromStringBinding( ptszStringBinding, &hBinding );
    RpcStringFree( &ptszStringBinding );

    if( rpcstatus )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcBindingFromStringBinding") ));
        hr = HRESULT_FROM_WIN32(rpcstatus);
        goto Exit;
    }
    fBound = TRUE;

    memset( &Msg, 0, sizeof(Msg) );
    Msg.MessageType = WKS_CONFIG;
    Msg.Priority = PRI_0;
    Msg.WksConfig.dwParameter = dwParameter;
    Msg.WksConfig.dwNewValue = dwValue;

    __try
    {
        hr = LnkCallSvrMessage( hBinding, &Msg);
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = HRESULT_FROM_WIN32( GetExceptionCode() );
    }

    if( FAILED(hr) )
    {
        _tprintf( TEXT("Failed call to service (%08x)\n"), hr );
        goto Exit;
    }


Exit:

    if( fBound )
        RpcBindingFree( &hBinding );

    return( hr );

}









BOOL
DltAdminConfig( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    BOOL fTrkWks = FALSE;
    LONG iArg = 0;
    BOOL fDynamic = FALSE;


    if( 1 <= cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        printf("\nOption  Config\n"
                " Purpose: Set tracking service configuration\n"
                " Usage:   -config <trkwks|trksvr> [options] [<parameter> <value>]\n"
                "          If the parm/value is ommitted, a list\n"
                "          of parameters is displayed\n"
                " Options: -d  Attempt to dynamically change the parameter\n"
                "              on the running service\n"
                " E.g.:    -config trkwks VolInitInitialDelay 0\n"
                "          -config trkwks\n"
                "          -config trkwks -d MoveNotifyTimeout 5\n" );
        return( TRUE );
    }

    if( !_tcsicmp( rgptszArgs[iArg], TEXT("trkwks") ))
        fTrkWks = TRUE;
    else if( !_tcsicmp( rgptszArgs[iArg], TEXT("trksvr") ))
        fTrkWks = FALSE;
    else
    {
        _tprintf( TEXT("Invalid service name (%s).  Use -? for help\n"), rgptszArgs[0] );
        return( FALSE );
    }
    iArg++;

    while( iArg < cArgs
           &&
           ( rgptszArgs[ iArg ][0] == TEXT('/')
             ||
             rgptszArgs[ iArg ][0] == TEXT('-') ) )
    {
        _tcsupr( rgptszArgs[ iArg ] );
        switch( rgptszArgs[ iArg ][ 1 ] )
        {
        case TEXT('D'):
            fDynamic = TRUE;
            break;
            
        default:
            _tprintf( TEXT("Unknown option (%s).  Use -? for help\n"), rgptszArgs[iArg] );
            return( FALSE );
        }

        iArg++;
        (*pcEaten)++;
    }

    if( iArg + 2 != cArgs
        &&
        iArg != cArgs )
    {
        printf( "Invalid parameters.  Use -? for help\n" );
        return( FALSE );
    }
    (*pcEaten) += 2;

    if( fTrkWks )
    {
        CTrkWksConfiguration configWks;
        configWks.Initialize( TRUE ); // => Persistable

        if( iArg == cArgs )
            printf( "Configurable parameters:\n\n" );

        for( int i = 0; i < configWks.GetParameterCount(); i++ )
        {
            if( iArg == cArgs )
            {
                _tprintf( TEXT("   %s\n"), configWks.GetParameterName( i ) );
            }

            else if( !_tcsicmp( configWks.GetParameterName(i), rgptszArgs[iArg] ))
            {
                DWORD dwValue;
                if( 1 == _stscanf( rgptszArgs[iArg+1], TEXT("0x%x"), &dwValue )
                    ||
                    1 == _stscanf( rgptszArgs[iArg+1], TEXT("%lu"), &dwValue) )
                {
                    if( fDynamic )
                    {
                        HRESULT hr = SendParameterValueToService( fTrkWks, i, dwValue );
                        if( FAILED(hr) )
                        {
                            _tprintf( TEXT("Couldn't set %s in service (%08x)"),
                                      rgptszArgs[iArg], hr );
                            return( FALSE );
                        }
                        else
                        {

                        }
                    }

                    HRESULT hr = configWks.PersistParameter( i, dwValue );
                    if( FAILED(hr) )
                    {
                        printf( "Couldn't write parameter to registry (%08x)", hr );
                        return( FALSE );
                    }
                    else
                    {
                        _tprintf( TEXT("Set %s to 0x%x\n"), configWks.GetParameterName(i), dwValue );
                    }
                }
                else
                {
                    _tprintf( TEXT("Couldn't interpret parameter value (%s)\n"), rgptszArgs[iArg+1] );
                    return( FALSE );
                }

                break;
            }
        }
    }



    return( TRUE );

}   // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\common\svcctrl.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       svcctrl.cxx
//
//  Contents:   Class for service control interface.
//
//  Classes:
//
//  Functions:
//
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:
//
//  Codework:
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "trklib.hxx"

#define THIS_FILE_NUMBER    SVCCTRL_CXX_FILE_NO


// This is static so that we can handle a PNP timing problem
// (see the comment in CSvcCtrlInterface::ServiceHandler).
BOOL CSvcCtrlInterface::_fStoppedOrStopping = TRUE;


//+----------------------------------------------------------------------------
//
//  CSvcCtrlInterface::Initialize
//
//  Register our service control handler with the control dispatcher, and set our state
//  to start-pending.
//
//+----------------------------------------------------------------------------

void
CSvcCtrlInterface::Initialize(const TCHAR *ptszServiceName, IServiceHandler *pServiceHandler)
{
    _fInitializeCalled = TRUE;
    _pServiceHandler = pServiceHandler;
    _fStoppedOrStopping = FALSE;
    _dwCheckPoint = 0;

    // Register with the control dispatcher.

    _ssh = RegisterServiceCtrlHandlerEx(ptszServiceName, ServiceHandler, this );
    if (_ssh == 0)
    {
        TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, HRESULT_FROM_WIN32(GetLastError()),
                                ptszServiceName );
        TrkRaiseLastError();
    }

    // Go to the start-pending state.

    SetServiceStatus(SERVICE_START_PENDING, 0, NO_ERROR);

}



//+----------------------------------------------------------------------------
//
//  CSvcCtrlInterface::ServiceHandler
//
//  This method is called by the control dispatcher.  If we get a stop
//  or shutdown request, automatically send a stop-pending before calling
//  the service's handler.  Interrogate is handled automatically in
//  this routine without bothering to call the service.
//
//+----------------------------------------------------------------------------

DWORD   // static
CSvcCtrlInterface::ServiceHandler(DWORD dwControl,
                                  DWORD dwEventType,
                                  PVOID EventData,
                                  PVOID pData)
{
    //  NOTE:   In services.exe, this method is called on the one and only ServiceHandler
    //          thread.  So while we execute, no other service in this process can
    //          receive notifications.  Thus it is important that we do nothing
    //          blocking or time-consuming here.

    DWORD       dwRet = NO_ERROR;
    CSvcCtrlInterface *pThis = (CSvcCtrlInterface*)pData;

#if DBG
    if( SERVICE_CONTROL_STOP == dwControl )
        TrkLog(( TRKDBG_SVR|TRKDBG_WKS, TEXT("\n") ));
    TrkLog(( TRKDBG_SVR|TRKDBG_WKS,
             TEXT("ServiceHandler(%s)"),
             StringizeServiceControl(dwControl) ));
#endif

    // On a stop or shutdown, flag it (e.g. so we don't try to accept new
    // requests from clients) and tell the SCM that we're stopping.

    switch (dwControl)
    {
    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:
        pThis->SetServiceStatus(SERVICE_STOP_PENDING, 0, NO_ERROR);
        _fStoppedOrStopping = TRUE;

        break;
    }

    // Check for PNP timing issues.  The problem is that during a stop
    // or shutdown, we unregister with PNP so that we don't get any more
    // notifications.  This is fine, except that between now and the time
    // we do that unregister, more PNP notifications might get queued.  So
    // when we get called to process those undesired notifications, we need
    // to ignore them here in the static function.
    //
    // As a quick fix, since only trkwks receives PNP notifications, we'll
    // just check to see if it's alive.  A better fix (raided) is to have
    // a static function for each service, so that only the trkwks has to
    // deal with it.

    if( SERVICE_CONTROL_DEVICEEVENT == dwControl && _fStoppedOrStopping )
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Ignoring SERVICE_CONTROL_DEVICEEVENT; service is stopped") ));
        return dwRet;
    }


    // Call this service's service handler.  As a final safety measure,
    // catch any exceptions (there should be none).  We must be sure that we don't
    // kill this thread, since it's shared by everyone in services.exe.

    __try
    {
        dwRet = pThis->_pServiceHandler->ServiceHandler(dwControl, dwEventType, EventData, pData);

        switch (dwControl)
        {
        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
            break;
        case SERVICE_CONTROL_PAUSE:
            pThis->SetServiceStatus(SERVICE_PAUSED, pThis->_dwControlsAccepted, NO_ERROR);
            break;
        case SERVICE_CONTROL_CONTINUE:
            pThis->SetServiceStatus(SERVICE_RUNNING, pThis->_dwControlsAccepted, NO_ERROR);
            break;
        case SERVICE_CONTROL_INTERROGATE:
            pThis->SetServiceStatus(pThis->_dwState, pThis->_dwControlsAccepted, NO_ERROR);
            break;
        case SERVICE_CONTROL_DEVICEEVENT:
            break;
        }
    }
    __except( BREAK_THEN_RETURN( EXCEPTION_EXECUTE_HANDLER ))
    {
        TrkLog(( TRKDBG_ERROR,
                 TEXT("Unexpected exception in CSvcCtrlInterface::ServiceHandler (%08x)"),
                 GetExceptionCode() ));
        dwRet = ERROR_EXCEPTION_IN_SERVICE;
    }

    return dwRet;
}


//+----------------------------------------------------------------------------
//
//  CSvcCtrlInterface::SetServiceStatus
//
//  Send a SetServiceStatus to the SCM.  The checkpoint is automatically
//  maintained by this class.
//
//+----------------------------------------------------------------------------

void
CSvcCtrlInterface::SetServiceStatus(DWORD dwState, DWORD dwControlsAccepted, DWORD dwWin32ExitCode)
{
    SERVICE_STATUS ss;

    _dwState = dwState;
    _dwControlsAccepted = dwControlsAccepted;

    if( SERVICE_START_PENDING != dwState
        &&
        SERVICE_STOP_PENDING != dwState )
    {
        _dwCheckPoint = 0;
    }

    ss.dwServiceType = SERVICE_WIN32;   // XX_SC
    ss.dwCurrentState = _dwState;
    ss.dwControlsAccepted = _dwControlsAccepted;
    ss.dwWin32ExitCode = dwWin32ExitCode;
    ss.dwServiceSpecificExitCode = 0;
    ss.dwCheckPoint = _dwCheckPoint++;
    ss.dwWaitHint = DEFAULT_WAIT_HINT;

    if (_ssh != 0)
    {
        if( !::SetServiceStatus(_ssh, &ss) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("SetServiceStatus(%s) failed, gle=%lu"),
                     (const TCHAR*)CDebugString(SServiceState(dwState)), GetLastError() ));
        }
        else
        {
            TrkLog(( TRKDBG_MISC, TEXT("SetServiceStatus(%s)"),
                     (const TCHAR*)CDebugString(SServiceState(dwState)) ));
        }
    }
}


//+----------------------------------------------------------------------------
//
//  CSvcCtrlInterface::UpdateWaitHint
//
//  Send a non-default wait hint to the SCM.
//
//+----------------------------------------------------------------------------

void
CSvcCtrlInterface::UpdateWaitHint(DWORD dwMilliseconds)
{
    SERVICE_STATUS ss;

    ss.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ss.dwCurrentState = _dwState;
    ss.dwControlsAccepted = _dwControlsAccepted;
    ss.dwWin32ExitCode = NO_ERROR;
    ss.dwServiceSpecificExitCode = 0;
    ss.dwCheckPoint = _dwCheckPoint++;
    ss.dwWaitHint = dwMilliseconds;

    if (_ssh != 0)
        ::SetServiceStatus(_ssh, &ss);
}



//+----------------------------------------------------------------------------
//
//  StringizeServiceControl (debug only)
//
//+----------------------------------------------------------------------------

#if DBG
TCHAR * StringizeServiceControl( DWORD dwControl )
{
    switch( dwControl )
    {
    case SERVICE_CONTROL_STOP:
        return TEXT("SERVICE_CONTROL_STOP");

    case SERVICE_CONTROL_PAUSE:
        return TEXT("SERVICE_CONTROL_PAUSE");

    case SERVICE_CONTROL_CONTINUE:
        return TEXT("SERVICE_CONTROL_CONTINUE");

    case SERVICE_CONTROL_INTERROGATE:
        return TEXT("SERVICE_CONTROL_INTERROGATE");

    case SERVICE_CONTROL_SHUTDOWN:
        return TEXT("SERVICE_CONTROL_SHUTDOWN");

    case SERVICE_CONTROL_PARAMCHANGE:
        return TEXT("SERVICE_CONTROL_PARAMCHANGE");

    case SERVICE_CONTROL_NETBINDADD:
        return TEXT("SERVICE_CONTROL_NETBINDADD");

    case SERVICE_CONTROL_NETBINDREMOVE:
        return TEXT("SERVICE_CONTROL_NETBINDREMOVE");

    case SERVICE_CONTROL_NETBINDENABLE:
        return TEXT("SERVICE_CONTROL_NETBINDENABLE");

    case SERVICE_CONTROL_NETBINDDISABLE:
        return TEXT("SERVICE_CONTROL_NETBINDDISABLE");

    case SERVICE_CONTROL_DEVICEEVENT:
        return TEXT("SERVICE_CONTROL_DEVICEEVENT");

    default:
        return TEXT("Unknown");
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\dltadmin\dltadmin.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//--------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>

#define TRKDATA_ALLOCATE
#include "trkwks.hxx"
#include "trksvr.hxx"
#include "dltadmin.hxx"


OLECHAR *
tcstoocs(OLECHAR *poszBuf, const TCHAR *ptsz)
{
#ifdef OLE2ANSI
    return tcstombs( poszBuf, ptsz );
#else
    return tcstowcs( poszBuf, ptsz );
#endif
}

TCHAR *
ocstotcs(TCHAR *ptszBuf, const OLECHAR *posz)
{
#ifdef OLE2ANSI
    return mbstotcs( ptszBuf, posz );
#else
    return wcstotcs( ptszBuf, posz );
#endif
}



void Usage()
{
    printf( "\nDistributed Link Tracking service admin tools\n"
              "\n"
              "Usage:    dltadmin [command command-parameters]\n"
              "For help: dltadmin [command] -?\n"
              "Commands: -VolInfoFile   (get volume info from a file path)\n"
              "          -VolStat       (volume statistics)\n"
              "          -FileOid       (set/get/use file Object IDs)\n"
              "          -EnumOids      (enumerate object IDs)\n"
              "          -OidSnap       (save/restore all OIDs)\n"
              "          -Link          (create/resolve shell link)\n"
              "          -VolId         (get/set volume IDs)\n"
              "          -CleanVol      (clean Object/Volume IDs)\n"
              "          -LockVol       (lock/dismount a volume)\n"
              "          -SvrStat       (trkSvr statistics)\n"
              "          -LoadLib       (load a dll into a process)\n"
              "          -FreeLib       (unload a dll from a process)\n"
              "          -Config        (configure the registry and/or runing service)\n"
              "          -Refresh       (refresh the trkwks volume list)\n"
              "          -DebugBreak    (break into a process)\n"
              "          -LookupVolId   (look up entry in DC volume table)\n"
              "          -LookupDroid   (look up entry in DC move table)\n"
              "          -DelDcMoveId   (del move table entry from DC)\n"
              "          -DelDcVolId    (del volume table entry from DC)\n"
              "          -SetVolSeq     (set volid sequence number)\n"
              "          -SetDroidSeq   (set move entry sequence number)\n" );
}


// Dummy function to make it link
void
ServiceStopCallback( PVOID pContext, BOOLEAN fTimeout )
{
    return;
}


VOID
TSZ2CLSID( const LPTSTR tszCLSID, CLSID *pclsid )
{
    HRESULT hr = S_OK;
    OLECHAR oszCLSID[ CCH_GUID_STRING + 1 ];

    tcstoocs( oszCLSID, tszCLSID );

    hr = CLSIDFromString( oszCLSID, pclsid );
    if( FAILED(hr) )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't convert string to CLSID") ));
        TrkRaiseException( hr );
    }

}







BOOL
DltAdminLockVol( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{

    HRESULT hr = S_OK;
    NTSTATUS status = 0;
    ULONG iVolume = static_cast<ULONG>(-1);
    TCHAR tszVolume[ ] = TEXT("\\\\.\\A:");
    OBJECT_ATTRIBUTES ObjAttr;
    IO_STATUS_BLOCK Iosb;
    UNICODE_STRING      uPath = { 0, 0, NULL };
    HANDLE hVolume = NULL;
    BOOL fSuccess = FALSE;
    CHAR rgcCommands[ 10 ];
    ULONG iCommand = 0, cCommands = 0;


    *pcEaten = 0;

    if( 0 == cArgs
        ||
        1 <= cArgs && IsHelpArgument(rgptszArgs[0]) )
    {
        *pcEaten = 1;
        printf( "\nOption LockVol\n"
                  "   Purpose: Lock and/or dismount a volume\n"
                  "   Usage:   -LockVol <options> <drive letter>:\n"
                  "   Where:   <options> are any combination (up to %d) of:\n"
                  "               -d    Send FSCTL_DISMOUNT_VOLUME\n"
                  "               -l    Send FSCTL_LOCK_VOLUME\n"
                  "               -u    Send FSCTL_UNLOCK_VOLUME\n"
                  "               -p    Pause for user input\n"
                  "   E.g.:    -LockVol -d -l -u c:\n"
                  "            -LockVol -l c:\n",
                  ELEMENTS(rgcCommands) );

        return( TRUE );
    }

    for( int iArgs = 0; iArgs < cArgs; iArgs++ )
    {
        if( 2 == _tcslen( rgptszArgs[iArgs] ) && TEXT(':') == rgptszArgs[iArgs][1] )
        {
            TCHAR tc = rgptszArgs[iArgs][0];
            if( TEXT('A') <= tc && TEXT('Z') >= tc )
                iVolume = tc - TEXT('A');
            else if( TEXT('a') <= tc && TEXT('z') >= tc )
                iVolume = tc - TEXT('a');
        }
        else if( TEXT('-') == rgptszArgs[iArgs][0]
                 ||
                 TEXT('/') == rgptszArgs[iArgs][0] )
        {
            _tcslwr(rgptszArgs[iArgs]);

            if( iCommand >= ELEMENTS(rgcCommands) )
            {
                printf( "Too many commands to LockVol.  Use -? for usage info.\n" );
                return( FALSE );
            }

            if( TEXT('d') == rgptszArgs[iArgs][1] )
                rgcCommands[iCommand] = 'd';
            else
            if( TEXT('l') == rgptszArgs[iArgs][1] )
                rgcCommands[iCommand] = 'l';
            else
            if( TEXT('u') == rgptszArgs[iArgs][1] )
                rgcCommands[iCommand] = 'u';
            else
            if( TEXT('p') == rgptszArgs[iArgs][1] )
                rgcCommands[iCommand] = 'p';
            else
            {
                printf( "Invalid option.  Use -? for usage info.\n" );
                return( FALSE );
            }
        }

        cCommands++;
        iCommand++;
        (*pcEaten)++;
    }

    if( static_cast<ULONG>(-1) == iVolume )
    {
        printf( "Invalid parameter.  Use -? for usage info\n" );
        return( FALSE );
    }


    tszVolume[4] += static_cast<TCHAR>(iVolume);

    if( !RtlDosPathNameToNtPathName_U( tszVolume, &uPath, NULL, NULL ))
    {
        status = STATUS_OBJECT_NAME_INVALID;
        goto Exit;
    }

    InitializeObjectAttributes(
        &ObjAttr,
        &uPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenFile(
                &hVolume,
                FILE_READ_DATA|FILE_WRITE_DATA|SYNCHRONIZE,
                &ObjAttr,
                &Iosb,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_ALERT
                );
    if( !NT_SUCCESS(status) )
    {
        printf( "Failed NtOpenFile of %s (%08x)\n", tszVolume, status );
        goto Exit;
    }


    for( iCommand = 0; iCommand < cCommands; iCommand++ )
    {
        switch( rgcCommands[iCommand] )
        {
        case 'd':
            {
                status = NtFsControlFile(
                            hVolume,
                            NULL,                       /* Event */
                            NULL,                       /* ApcRoutine */
                            NULL,                       /* ApcContext */
                            &Iosb,
                            FSCTL_DISMOUNT_VOLUME,
                            NULL,                       /* InputBuffer */
                            0,                          /* InputBufferLength */
                            NULL,                       /* OutputBuffer */
                            0                           /* OutputBufferLength */
                            );
                if( !NT_SUCCESS(status) )
                    printf( "Failed FSCTL_DISMOUNT_VOLUME (%08x)\n", status );
                else
                    printf( "Volume dismounted\n" );
            }
            break;

        case 'l':
            {
                status = NtFsControlFile(
                            hVolume,
                            NULL,                       /* Event */
                            NULL,                       /* ApcRoutine */
                            NULL,                       /* ApcContext */
                            &Iosb,
                            FSCTL_LOCK_VOLUME,
                            NULL,                       /* InputBuffer */
                            0,                          /* InputBufferLength */
                            NULL,                       /* OutputBuffer */
                            0                           /* OutputBufferLength */
                            );
                if( !NT_SUCCESS(status) )
                    printf( "Failed FSCTL_LOCK_VOLUME (%08x)\n", status );
                else
                    printf( "Volume is locked\n" );

            }
            break;

        case 'u':
            {
                status = NtFsControlFile(
                            hVolume,
                            NULL,                       /* Event */
                            NULL,                       /* ApcRoutine */
                            NULL,                       /* ApcContext */
                            &Iosb,
                            FSCTL_UNLOCK_VOLUME,
                            NULL,                       /* InputBuffer */
                            0,                          /* InputBufferLength */
                            NULL,                       /* OutputBuffer */
                            0                           /* OutputBufferLength */
                            );
                if( !NT_SUCCESS(status) )
                    printf( "Failed FSCTL_UNLOCK_VOLUME (%08x)\n", status );
                else
                    printf( "Volume unlocked\n" );
            }
            break;

        case 'p':
            {
                printf( "Press enter to unlock ..." );
                getchar();
            }
            break;

        }   // switch( rgcCommands[iCommand] )
    }   // for( iCommand = 0; iCommand < cCommands; iCommand++ )

    fSuccess = TRUE;

Exit:

    if( NULL != uPath.Buffer )
        RtlFreeUnicodeString( &uPath );

    return( fSuccess );

}



void
MakeAbsolutePath( TCHAR * ptszAbsolute, TCHAR * ptszRelative )
{

    if( !_tcsncmp( TEXT("\\\\"), ptszRelative, 2 )     // A UNC path
        ||
        TEXT(':') == ptszRelative[1] )             // A drive-based path
    {
        // The command-line has an absolute path
        _tcscpy( ptszAbsolute, ptszRelative );
    }
    else
    {
        // The command-line has a relative path

        DWORD dwLength = 0;

        dwLength = GetCurrentDirectory( MAX_PATH, ptszAbsolute );
        if( 0 == dwLength )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't get current directory") ));
            TrkRaiseLastError( );
        }
        if( TEXT('\\') != ptszAbsolute[dwLength-1] )
            _tcscat( ptszAbsolute, TEXT("\\") );

        _tcscat( ptszAbsolute, ptszRelative );
    }
}


BOOL
DltAdminFileOid( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    HRESULT hr = S_OK;
    NTSTATUS status = 0;
    TCHAR tszFile[ MAX_PATH + 1 ];
    WCHAR wszFile[ MAX_PATH + 1 ];
    TCHAR tszUNCPath[ MAX_PATH + 1 ];
    WCHAR wszOID[ CCH_GUID_STRING + 1 ];
    ULONG cbInBuffer;
    TCHAR tszMachineName[ MAX_PATH + 1 ];
    LPCTSTR tszVolumePath = NULL;
    USHORT iVolume;

    OLECHAR oszOID[ CCH_GUID_STRING + 1 ];

    EnablePrivilege( SE_RESTORE_NAME );

    *pcEaten = 0;

    //  -------------------------
    //  Validate the command-line
    //  -------------------------

    if( 1 <= cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        *pcEaten = 1;
        printf( "\nOption FileOID\n"
                  "   Purpose: Get/set/use file Object IDs\n"
                  "   Usage:   -fileoid <option> <filename or object id, depending on the option>\n"
                  "   Options: -r  => Read the object ID from a file\n"
                  "            -g  => Get (creating if necessary) the object ID from a file\n"
                  "            -f  => Search the local machine for an object ID's filename\n"
                  "            -s  => Set an ID on a file (specify objid, then filename)\n"
                  "            -sr => Make a file reborn\n"
                  "            -df => Delete the object ID from it's file, given the filename\n"
                  "            -do => Delete the object ID from it's file, given the object ID\n"
                  "   E.g.:    -fileoid -g d:\\test.txt\n"
                  "            -fileoid -r d:\\test.txt\n"
                  "            -fileoid -f {C69F3AA6-8B4C-11D0-8C9D-00C04FD90F85}\n"
                  "            -fileoid -do {C69F3AA6-8B4C-11D0-8C9D-00C04FD90F85}\n"
                  "            -fileoid -df d:\\test.txt\n" );
        return( TRUE );
    }
    else
    if( 2 > cArgs
        ||
        rgptszArgs[0][0] != TEXT('-')
        &&
        rgptszArgs[0][0] != TEXT('/')
        )
    {
        printf( "Parameter error.  Use -? for usage info\n" );
    }

    *pcEaten = 2;

    // Convert the option to upper case (options are case-insensitive).
    _tcsupr( rgptszArgs[0] );

    __try
    {
        // Switch on the option (e.g, the 'F' in "-F")

        switch( rgptszArgs[0][1] )
        {

            //  --------------------------------
            //  Get a file name from an ObjectID
            //  --------------------------------

            case TEXT('F'):
                {
                    CDomainRelativeObjId droidBirth;

                    // Get the OID in binary format
                    CObjId oid;
                    TSZ2CLSID( rgptszArgs[1], (GUID*)&oid );

                    // Scan the volumes for this objectID

                    for (LONG vol = 0; vol < 26; vol++)
                    {
                        if( IsLocalObjectVolume( vol )
                            &&
                            NT_SUCCESS(FindLocalPath(vol, oid, &droidBirth, &tszUNCPath[2])) )
                        {
                            tszUNCPath[0] = VolChar(vol);
                            tszUNCPath[1] = TEXT(':');
                            break;
                        }
                    }

                    if( 'z'-'a' == vol )
                    {
                        hr = ERROR_FILE_NOT_FOUND;
                        __leave;
                    }

                    // Display the filename

                    wprintf( L"File name = \"%s\"\n", tszUNCPath );
                }

                break;


            //  --------------------
            //  Read/Get an ObjectID
            //  --------------------

            case TEXT('R'):
            case TEXT('G'):

                {

                    TCHAR tszFile[ MAX_PATH + 1 ];

                    MakeAbsolutePath( tszFile, rgptszArgs[1] );

                    CDomainRelativeObjId droidCurrent;
                    CDomainRelativeObjId droidBirth;

                    status = GetDroids( tszFile, &droidCurrent, &droidBirth,
                                        rgptszArgs[0][1] == TEXT('R') ? RGO_READ_OBJECTID : RGO_GET_OBJECTID );
                    if( !NT_SUCCESS(status) )
                    {
                        hr = status;
                        __leave;
                    }

                    _tprintf( TEXT("Current:\n") );
                    _tprintf( TEXT("   volid = %s\n"),
                              static_cast<const TCHAR*>(CStringize(droidCurrent.GetVolumeId() )));
                    _tprintf( TEXT("   objid = %s\n"),
                              static_cast<const TCHAR*>(CStringize(droidCurrent.GetObjId() )));

                    _tprintf( TEXT("Birth:\n") );
                    _tprintf( TEXT("   volid = %s\n"),
                              static_cast<const TCHAR*>(CStringize(droidBirth.GetVolumeId() )));
                    _tprintf( TEXT("   objid = %s\n"),
                              static_cast<const TCHAR*>(CStringize(droidBirth.GetObjId() )));

                }

                break;

            //  ---------------
            //  Set an ObjectID
            //  ---------------

            case TEXT('S'):

                {
                    HANDLE hFile;
                    CObjId objid;
                    IO_STATUS_BLOCK IoStatus;
                    TCHAR tszFile[ MAX_PATH + 1 ];

                    if( TEXT('R') == rgptszArgs[0][2] )
                    {
                        if( 2 > cArgs )
                        {
                            printf( "Parameter error.  Use -? for usage info\n" );
                            hr = E_FAIL;
                            goto Exit;
                        }
                        (*pcEaten)++;

                        MakeAbsolutePath( tszFile, rgptszArgs[1] );

                        status = TrkCreateFile( tszFile, FILE_READ_ATTRIBUTES,
                                                FILE_ATTRIBUTE_NORMAL,
                                                FILE_SHARE_DELETE|FILE_SHARE_READ|FILE_SHARE_WRITE, FILE_OPEN,
                                                FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_NO_RECALL | FILE_SYNCHRONOUS_IO_NONALERT,
                                                NULL,
                                                &hFile );
                        if (!NT_SUCCESS(status))
                        {
                            printf( "TrkCreateFile failed\n" );
                            hr = status;
                            __leave;
                        }
                        status = MakeObjIdReborn( hFile );
                        if( NT_SUCCESS(status) )
                            printf( "File is reborn\n" );
                        else
                            printf( "Failed to make reborn (%08x)\n", status );
                    }
                    else
                    {
                        TSZ2CLSID( rgptszArgs[1], (GUID*)&objid );

                        if( 3 > cArgs )
                        {
                            printf( "Parameter error.  Use -? for usage info\n" );
                            hr = E_FAIL;
                            goto Exit;
                        }
                        (*pcEaten)++;

                        MakeAbsolutePath( tszFile, rgptszArgs[2] );

                        status = TrkCreateFile( tszFile, FILE_READ_ATTRIBUTES,
                                                FILE_ATTRIBUTE_NORMAL,
                                                FILE_SHARE_DELETE|FILE_SHARE_READ|FILE_SHARE_WRITE, FILE_OPEN,
                                                FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_NO_RECALL | FILE_SYNCHRONOUS_IO_NONALERT,
                                                NULL,
                                                &hFile );
                        if (!NT_SUCCESS(status))
                        {
                            printf( "TrkCreateFile failed\n" );
                            hr = status;
                            __leave;
                        }

                        status = SetObjId( hFile, objid, CDomainRelativeObjId() );

                        if (!NT_SUCCESS(status))
                        {
                            printf( "FSCTL_SET_OBJECT_ID failed\n" );
                            hr = status;
                            __leave;
                        }
                        printf( "ID set ok\n" );
                    }

                }

                break;

            case TEXT('D'):
                {
                    if( TEXT('F') == rgptszArgs[0][2] )
                    {
                        TCHAR tszFile[ MAX_PATH + 1 ];
                        HANDLE hFile;
                        NTSTATUS status;
                        IO_STATUS_BLOCK IoStatus;

                        MakeAbsolutePath( tszFile, rgptszArgs[1] );

                        status = TrkCreateFile( tszFile, FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                                                FILE_ATTRIBUTE_NORMAL,
                                                FILE_SHARE_READ|FILE_SHARE_WRITE, FILE_OPEN,
                                                FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_NO_RECALL | FILE_SYNCHRONOUS_IO_NONALERT,
                                                NULL,
                                                &hFile );
                        if (!NT_SUCCESS(status))
                        {
                            printf( "TrkCreateFile failed\n" );
                            hr = status;
                            __leave;
                        }

                        status = NtFsControlFile(
                             hFile,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatus,
                             FSCTL_DELETE_OBJECT_ID,
                             NULL,  // in buffer
                             0,     // in buffer size
                             NULL,  // Out buffer
                             0);    // Out buffer size

                        if (!NT_SUCCESS(status))
                        {
                            printf( "FSCTL_DELETE_OBJECT_ID failed\n" );
                            hr = status;
                            __leave;
                        }
                        printf( "Deleted ok\n" );

                    }

                    else if( TEXT('O') == rgptszArgs[0][2] )
                    {
                        // Get the OID in binary format
                        CObjId oid;
                        CDomainRelativeObjId droidBirth;
                        TSZ2CLSID( rgptszArgs[1], (GUID*)&oid );
                        BOOL fFound = FALSE;

                        for (int vol='a'-'a'; vol<'z'-'a'; vol++)
                        {
                            if( IsLocalObjectVolume(CVolumeDeviceName(vol)) )
                            {
                                status = FindLocalPath(vol, oid, &droidBirth, &tszUNCPath[2]);
                                if( STATUS_OBJECT_NAME_NOT_FOUND == status )
                                    continue;
                                if( !NT_SUCCESS(status) ) goto Exit;

                                tszUNCPath[0] = VolChar(vol);
                                tszUNCPath[1] = TEXT(':');

                                _tprintf( TEXT("Deleting object ID on %s\n"), tszUNCPath );

                                status = DelObjId( vol, oid );
                                if( !NT_SUCCESS(status) ) goto Exit;
                                printf( "Deleted ok\n" );

                                break;
                            }
                        }

                        if( fFound ) printf( "Not found\n" );
                    }
                    else
                        printf( "Bad parameter\n" );
                }   // case TEXT('D'):
                break;


        }   // switch

        hr = S_OK;

    }   // __try

    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }


Exit:

    if( FAILED(hr) )
        printf( "HR = %08X\n", hr );

    return SUCCEEDED(hr);

}






BOOL
DltAdminTemp( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    HRESULT hr = E_FAIL;
    RPC_STATUS  rpcstatus;
    RPC_TCHAR * ptszStringBinding;
    RPC_BINDING_HANDLE hBinding = NULL;
    WCHAR wszMachine[ 256 ];
    
    BOOL fBound = FALSE;
    LONG iVol = 4;
    GUID volid = { /* 9f1534ee-ceab-4710-98b9-daaf048e3ad2 */
        0x9f1534ee,
        0xceab,
        0x4710,
        {0x98, 0xb9, 0xda, 0xaf, 0x04, 0x8e, 0x3a, 0xd2}
      };

    if( 2 > cArgs || IsHelpArgument( rgptszArgs[0] ))
    {
        printf("\nOption  Mend\n"
                " Purpose: Temp test placeholder\n"
                " Usage:   -temp <machine>\n" );
        return( TRUE );
    }

    wsprintf( wszMachine, TEXT("\\\\%s"), rgptszArgs[1] );


    rpcstatus = RpcStringBindingCompose( NULL, TEXT("ncacn_np"), wszMachine, TEXT("\\pipe\\trkwks"),
                                         NULL, &ptszStringBinding);
    wprintf( L"StringBinding = %s\n", ptszStringBinding );

    if( rpcstatus )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcStringBindingCompose %lu"), rpcstatus ));
        hr = HRESULT_FROM_WIN32(rpcstatus);
        goto Exit;
    }

    rpcstatus = RpcBindingFromStringBinding( ptszStringBinding, &hBinding );
    RpcStringFree( &ptszStringBinding );

    if( rpcstatus )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcBindingFromStringBinding") ));
        hr = HRESULT_FROM_WIN32(rpcstatus);
        goto Exit;
    }
    fBound = TRUE;


    __try
    {
        //hr = LnkSetVolumeId( hBinding, iVol, volid );

        CDomainRelativeObjId droidBirth, droidLast, droidCurrent;
        CMachineId mcidLast, mcidCurrent;
        FILETIME ftLimit = { 0x01d27f63, 0x01d27f63 };
        WCHAR wsz[ 256 ];
        ULONG cbPath = 128*1024*1024; //256;
        HANDLE hEvent = NULL;

        PRPC_ASYNC_STATE        pRpcAsyncState;

	pRpcAsyncState = reinterpret_cast<PRPC_ASYNC_STATE>( new BYTE[ sizeof(RPC_ASYNC_STATE) ] );
   	if( NULL == pRpcAsyncState )
        {
   		TrkRaiseException( E_OUTOFMEMORY );
                __leave; // Unnecessary, but prevents prefast error.
        }

	rpcstatus = RpcAsyncInitializeHandle( pRpcAsyncState, RPC_ASYNC_VERSION_1_0 );
	if( RPC_S_OK != rpcstatus )
    		TrkRaiseWin32Error( rpcstatus );

        hEvent = CreateEvent(NULL, FALSE, FALSE, NULL); // Auto-reset, not initially signaled
        if (NULL == hEvent)
        	TrkRaiseLastError();

	pRpcAsyncState->NotificationType = RpcNotificationTypeEvent;
	pRpcAsyncState->u.hEvent = hEvent;
    	pRpcAsyncState->UserInfo = NULL;
   	
        memset( &droidBirth, 1, sizeof(droidBirth) );
        memset( &droidLast, 2, sizeof(droidBirth) );
        memset( &droidCurrent, 3, sizeof(droidBirth) );

        memset( &mcidLast, 1, sizeof(mcidLast) );
        memset( &mcidCurrent, 2, sizeof(mcidLast) );

	LnkMendLink( pRpcAsyncState,
		                     hBinding, ftLimit, 0,
					&droidBirth, 
					&droidLast, 
					&mcidLast,
					&droidCurrent,
					&mcidCurrent, 
					&cbPath,
					wsz );




	DWORD dwWaitReturn = WaitForSingleObject(hEvent, INFINITE);

        if (WAIT_OBJECT_0 != dwWaitReturn)
        	TrkRaiseLastError();

	rpcstatus = RpcAsyncCompleteCall(pRpcAsyncState, &hr);
       if (RPC_S_OK != rpcstatus)
       	TrkRaiseWin32Error( rpcstatus );
        
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = HRESULT_FROM_WIN32( GetExceptionCode() );
    }

    if( FAILED(hr) )
    {
        _tprintf( TEXT("Failed call to service (%08x)\n"), hr );
        goto Exit;
    }


Exit:

    if( fBound )
        RpcBindingFree( &hBinding );

    return( TRUE );

}   // main()



BOOL
DltAdminTemp2( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    HRESULT hr = E_FAIL;
    RPC_STATUS  rpcstatus;
    RPC_TCHAR * ptszStringBinding;
    RPC_BINDING_HANDLE hBinding = NULL;
    BOOL fBound = FALSE;
    LONG iVol = 4;
    TCHAR tszMachine[ MAX_PATH ];
    GUID volid = { /* 9f1534ee-ceab-4710-98b9-daaf048e3ad2 */
        0x9f1534ee,
        0xceab,
        0x4710,
        {0x98, 0xb9, 0xda, 0xaf, 0x04, 0x8e, 0x3a, 0xd2}
      };

    if( 2 > cArgs || IsHelpArgument( rgptszArgs[0] ))
    {
        printf("\nOption  Temp2\n"
                " Purpose: Temp2 test placeholder\n"
                " Usage:   -temp2 <machine> <cVolumes>\n"
                " E.g.:    -temp2 mikehill 100\n" );
        return( TRUE );
    }

    wsprintf( tszMachine, TEXT("\\\\%s"), rgptszArgs[1] );
    ULONG cVolumes = _ttoi( rgptszArgs[2] );
    *pcEaten = 2;

    rpcstatus = RpcStringBindingCompose( NULL,
                                         TEXT("ncacn_np"), 
                                         tszMachine,
                                         TEXT("\\pipe\\ntsvcs"),
                                         NULL,
                                         &ptszStringBinding);
    wprintf( L"Binding string = %s\n", ptszStringBinding );

    /*
    rpcstatus = RpcStringBindingCompose( NULL,
                                         TEXT("ncacn_ip_tcp"), 
                                         TEXT("mikehill1"),
                                         TEXT(""),
                                         NULL,
                                         &ptszStringBinding);
    */



    if( rpcstatus )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcStringBindingCompose %lu"), rpcstatus ));
        hr = HRESULT_FROM_WIN32(rpcstatus);
        goto Exit;
    }

    rpcstatus = RpcBindingFromStringBinding( ptszStringBinding, &hBinding );
    RpcStringFree( &ptszStringBinding );

    if( rpcstatus )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcBindingFromStringBinding") ));
        hr = HRESULT_FROM_WIN32(rpcstatus);
        goto Exit;
    }
    fBound = TRUE;


    __try
    {
        /*
        CVolumeId *rgvolid = new CVolumeId[ cVolumes ];

        DWORD *pdw = (DWORD*) rgvolid;
        for( ULONG i = 0; i < (cVolumes * sizeof(CVolumeId)/sizeof(DWORD) ); i++ )
            *(pdw++) = (DWORD)i;

        printf( "Buffer size = %d (0x%x DWORDs)\n",
                cVolumes * sizeof(CVolumeId),
                cVolumes * sizeof(CVolumeId) / sizeof(DWORD) );
        hr = TriggerVolumeClaims( hBinding, cVolumes, rgvolid );
        */

        TRKSVR_MESSAGE_UNION Msg;
        memset( &Msg, 0, sizeof(Msg) );
        Msg.MessageType = SEARCH;
        Msg.Search.cSearch = cVolumes;
        Msg.Search.pSearches = new TRK_FILE_TRACKING_INFORMATION[ cVolumes ];

        hr = LnkCallSvrMessage( hBinding, &Msg );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = HRESULT_FROM_WIN32( GetExceptionCode() );
    }

    if( FAILED(hr) )
    {
        _tprintf( TEXT("Failed call to service (%08x)\n"), hr );
        goto Exit;
    }


Exit:

    if( fBound )
        RpcBindingFree( &hBinding );

    return( TRUE );

}


BOOL
DltAdminTemp3( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    HRESULT hr = E_FAIL;
    RPC_STATUS  rpcstatus;
    RPC_TCHAR * ptszStringBinding;
    RPC_BINDING_HANDLE hBinding = NULL;
    BOOL fBound = FALSE;
    LONG iVol = 4;
    TCHAR tszMachine[ MAX_PATH ];

    /*
    if( 1 > cArgs || IsHelpArgument( rgptszArgs[0] ))
    {
        printf("\nOption  Temp3\n"
                " Purpose: Temp3 test placeholder\n"
                " Usage:   -temp3 <machine>\n"
                " E.g.:    -temp3 mikehill\n" );
        return( TRUE );
    }

    wsprintf( tszMachine, TEXT("\\\\%s"), rgptszArgs[1] );
    ULONG cVolumes = _ttoi( rgptszArgs[2] );
    *pcEaten = 2;
    */

    rpcstatus = RpcStringBindingCompose( NULL,
                                         TEXT("ncacn_np"), 
                                         NULL, //tszMachine,
                                         TEXT("\\pipe\\trkwks"),
                                         NULL,
                                         &ptszStringBinding);
    wprintf( L"Binding string = %s\n", ptszStringBinding );


    if( rpcstatus )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcStringBindingCompose %lu"), rpcstatus ));
        hr = HRESULT_FROM_WIN32(rpcstatus);
        goto Exit;
    }

    rpcstatus = RpcBindingFromStringBinding( ptszStringBinding, &hBinding );
    RpcStringFree( &ptszStringBinding );

    if( rpcstatus )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcBindingFromStringBinding") ));
        hr = HRESULT_FROM_WIN32(rpcstatus);
        goto Exit;
    }
    fBound = TRUE;


    __try
    {
        TRKSVR_MESSAGE_UNION Msg;
        TRKSVR_SYNC_VOLUME syncvol;
        CVolumeSecret *pTempSecret = new CVolumeSecret();

        memset( &Msg, 0, sizeof(Msg) );
        Msg.MessageType = SYNC_VOLUMES;
        Msg.Priority = PRI_0;

        Msg.SyncVolumes.cVolumes = 1;
        Msg.SyncVolumes.pVolumes = &syncvol;

        memset( &syncvol, 0, sizeof(syncvol) );
        ((BYTE*)pTempSecret)[0] = 1;
        syncvol.secret = *pTempSecret;
        syncvol.SyncType = CREATE_VOLUME;

        hr = LnkCallSvrMessage( hBinding, &Msg );
        //hr = LnkSvrMessage( hBinding, &Msg );

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = HRESULT_FROM_WIN32( GetExceptionCode() );
    }

    if( FAILED(hr) )
    {
        _tprintf( TEXT("Failed call to service (%08x)\n"), hr );
        goto Exit;
    }
    else
        _tprintf( TEXT("Call succeeded\n") );


Exit:

    if( fBound )
        RpcBindingFree( &hBinding );

    return( TRUE );

}   // main()




CVolumeId
DisplayLogStatus( LONG iVol )
{
    NTSTATUS status = STATUS_SUCCESS;
    HANDLE hFile = NULL;
    TCHAR tszLog[ MAX_PATH + 1 ];

    ULONG     cbRead;
    LogHeader logheader;
    LogInfo   loginfo;
    VolumePersistentInfo volinfo;

    _tcscpy( tszLog, CVolumeDeviceName(iVol) );
    _tcscat( tszLog, s_tszLogFileName );

    status = TrkCreateFile( tszLog, FILE_GENERIC_READ, FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                            FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, &hFile );
    if( !NT_SUCCESS(status) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open %s"), tszLog ));
        TrkRaiseNtStatus(status);
    }

    if( !ReadFile( hFile, &logheader, sizeof(logheader), &cbRead, NULL )
        ||
        sizeof(logheader) != cbRead )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't read log header") ));
        TrkRaiseLastError();
    }

    if( !ReadFile( hFile, &volinfo, sizeof(volinfo), &cbRead, NULL )
        ||
        sizeof(volinfo) != cbRead )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't read volinfo") ));
        TrkRaiseLastError();
    }

    if( !ReadFile( hFile, &loginfo, sizeof(loginfo), &cbRead, NULL )
        ||
        sizeof(loginfo) != cbRead )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't read loginfo") ));
        TrkRaiseLastError();
    }

    _tprintf( TEXT("\nLog Header:\n") );
    _tprintf( TEXT("    guidSignature = \t%s\n"), static_cast<const TCHAR*>(CStringize(logheader.guidSignature)) );
    _tprintf( TEXT("    dwFormat = \t\t0x%x,0x%x\n"), logheader.dwFormat>>16, logheader.dwFormat&0xFFFF );
    _tprintf( TEXT("    ProperShutdown = \t%s\n"), (logheader.dwFlags & PROPER_SHUTDOWN) ? TEXT("True") : TEXT("False") );
    _tprintf( TEXT("    DownlevelDirtied = \t%s\n"), (logheader.dwFlags & DOWNLEVEL_DIRTIED) ? TEXT("True") : TEXT("False") );
    _tprintf( TEXT("    Expansion start = \t%d\n"), logheader.expand.ilogStart );
    _tprintf( TEXT("              end = \t%d\n"), logheader.expand.ilogEnd );
    _tprintf( TEXT("              cb = \t%d\n"), logheader.expand.cbFile );


    _tprintf( TEXT("\nLog Information:\n") );
    _tprintf( TEXT("    Start = \t\t%lu\n"), loginfo.ilogStart );
    _tprintf( TEXT("    End = \t\t%lu\n"), loginfo.ilogEnd );
    _tprintf( TEXT("    Write = \t\t%lu\n"), loginfo.ilogWrite );
    _tprintf( TEXT("    Read = \t\t%lu\n"), loginfo.ilogRead );
    _tprintf( TEXT("    Last = \t\t%lu\n"), loginfo.ilogLast );
    _tprintf( TEXT("    seqNext = \t\t%li\n"), loginfo.seqNext );
    _tprintf( TEXT("    seqLastRead = \t%li\n"), loginfo.seqLastRead );


    CVolumeId volidNTFS;
    status = QueryVolumeId( iVol, &volidNTFS );
    if( !NT_SUCCESS(status) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get NTFS volume ID") ));
        TrkRaiseNtStatus(status);
    }

    _tprintf( TEXT("\nVolume Information:\n") );
    _tprintf( TEXT("    Machine = \t\t%s\n"), static_cast<const TCHAR*>(CStringize(volinfo.machine)) );
    _tprintf( TEXT("    VolId (log) = \t%s\n"), static_cast<const TCHAR*>(CStringize(volinfo.volid)) );
    _tprintf( TEXT("    VolId (NTFS) = \t%s\n"), static_cast<const TCHAR*>(CStringize(volidNTFS)) );
    _tprintf( TEXT("    Secret = \t\t%s\n"), static_cast<const TCHAR*>(CStringize(volinfo.secret)) );
    _tprintf( TEXT("    Last Refresh = \t%d\n"), volinfo.cftLastRefresh.LowDateTime() );
    _tprintf( TEXT("    Enter not-owned = \t%s\n"), volinfo.cftEnterNotOwned == CFILETIME(0)
                                                        ? TEXT("(N/A)")
                                                        : static_cast<const TCHAR*>(CStringize(volinfo.cftEnterNotOwned)) );
    _tprintf( TEXT("    Make OIDs reborn = \t%s\n"), volinfo.fDoMakeAllOidsReborn ? TEXT("True") : TEXT("False") );
    _tprintf( TEXT("    Not-Created = \t%s\n"), volinfo.fNotCreated ? TEXT("True") : TEXT("False") );

    if( NULL != hFile )
        NtClose( hFile );

    return( volinfo.volid );
}



void
DisplayDcStatus( const CVolumeId &volid )
{
    CRpcClientBinding rc;
    TRKSVR_SYNC_VOLUME SyncVolume;
    TRKSVR_MESSAGE_UNION Msg;
    CMachineId mcidLocal( MCID_LOCAL );
    HRESULT hr = S_OK;

    rc.RcInitialize( mcidLocal, s_tszTrkWksLocalRpcProtocol, s_tszTrkWksLocalRpcEndPoint, NO_AUTHENTICATION );

    printf( "\nDC Information:\n" );

    __try
    {
        Msg.MessageType = SYNC_VOLUMES;
        Msg.ptszMachineID = NULL;
        Msg.Priority = PRI_9;
        Msg.SyncVolumes.cVolumes = 1;
        Msg.SyncVolumes.pVolumes = &SyncVolume;
        SyncVolume.hr = S_OK;
        SyncVolume.SyncType = QUERY_VOLUME;
        SyncVolume.volume = volid;

        hr = LnkCallSvrMessage( rc, &Msg );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = HRESULT_FROM_WIN32(GetExceptionCode());
    }

    if( FAILED(hr) )
    {
        printf( "    Couldn't get status from DC:  %08x\n", hr );

        if( HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr )
            printf( "    Make sure you have the 0x1 bit set in the TestFlags registry value\n" );

        goto Exit;
    }

    if( TRK_S_VOLUME_NOT_FOUND == SyncVolume.hr )
    {
        printf( "    Volume is not in DC\n" );
    }
    else if( TRK_S_VOLUME_NOT_OWNED == SyncVolume.hr )
    {
        printf( "    Volume is not owned by this machine\n" );
    }
    else if( S_OK == SyncVolume.hr )
    {
        _tprintf( TEXT("    Sequence # = \t%li\n"), SyncVolume.seq );
        _tprintf( TEXT("    Last Refresh = \t%lu\n"), SyncVolume.ftLastRefresh.dwLowDateTime );
                  //static_cast<const TCHAR*>(CStringize(CFILETIME(SyncVolume.ftLastRefresh))) );
    }
    else
    {
        printf( "    Volume state couldn't get queried from DC:  %08x\n", hr );
    }

Exit:

    return;
}


void
DisplayOidInformation( LONG iVol )
{

    CObjId                  objid;
    CDomainRelativeObjId    droid;
    CObjIdEnumerator        oie;

    ULONG cFilesWithOid         = 0;
    ULONG cCrossVolumeBitSet    = 0;

    if(oie.Initialize(CVolumeDeviceName(iVol)) == TRUE)
    {
        if(oie.FindFirst(&objid, &droid))
        {
            do
            {
                cFilesWithOid++;

                if( droid.GetVolumeId().GetUserBitState() )
                    cCrossVolumeBitSet++;

            } while(oie.FindNext(&objid, &droid));
        }
    }

    printf( "\nObjectID Information\n" );
    printf( "    Files with ObjectIDs = \t\t%lu\n", cFilesWithOid );
    printf( "    Files with x-volume bit set = \t%lu\n", cCrossVolumeBitSet );

}



VolumeStatistics( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    NTSTATUS status = 0;
    TCHAR tszFile[ MAX_PATH + 1 ];
    TCHAR tszDir[ MAX_PATH + 1 ];
    TCHAR* ptcTmp = NULL;
    BOOL fSuccess = FALSE;
    LONG iVol = 0;

    *pcEaten = 0;

    if( 1 > cArgs || IsHelpArgument(rgptszArgs[0]) )
    {
        printf( "\nOption VolStat\n"
                  "   Purpose:  Get link tracking info about a volume\n"
                  "   Usage:    -volstat <drive letter>\n"
                  "   E.g.:     -volstat D:\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    if( TEXT('a') > rgptszArgs[0][0]
        &&
        TEXT('z') < rgptszArgs[0][0]
        &&
        TEXT('A') > rgptszArgs[0][0]
        &&
        TEXT('Z') < rgptszArgs[0][0]
        ||
        TEXT(':') != rgptszArgs[0][1] )
    {
        printf( "Parameter error.  Use -? for usage info\n" );
        return( FALSE );
    }

    iVol = (LONG)((ULONG_PTR)CharLower((LPTSTR)rgptszArgs[0][0]) - TEXT('a'));

    if( !IsLocalObjectVolume( iVol ))
    {
        _tprintf( TEXT("%c: isn't a local NTFS5 volume\n"), VolChar(iVol) );
        goto Exit;
    }

    __try
    {
        CVolumeId volid;

        EnablePrivilege( SE_RESTORE_NAME );

        volid = DisplayLogStatus(iVol);
        DisplayDcStatus( volid );
        DisplayOidInformation( iVol );

        fSuccess = TRUE;
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        printf( "Fatal error:  %08x\n", GetExceptionCode() );
    }


Exit:

    return( fSuccess );

}   // main()










VolumeIdSetOrGet( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    HRESULT hr = E_FAIL;
    NTSTATUS status = STATUS_SUCCESS;

    TCHAR tszFile[ MAX_PATH + 1 ];
    WCHAR wszFile[ MAX_PATH + 1 ];
    TCHAR tszUNCPath[ MAX_PATH + 1 ];
    WCHAR wszOID[ CCH_GUID_STRING + 1 ];
    ULONG cbInBuffer;
    TCHAR tszMachineName[ MAX_PATH + 1 ];
    LPCTSTR tszVolumePath = NULL;
    USHORT iVolume;

    OLECHAR oszOID[ CCH_GUID_STRING + 1 ];

    if( 1 == cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption VolId\n"
                  "   Purpose: Set or get volume IDs\n"
                  "   Usage:   -volid [-s <drive>: {GUID} | -g <drive>:]\n"
                  "   Where:   '-s' means Set, and '-g' means Get\n"
                  "   E.g.:    -volid -g d:\n"
                  "            -volid -s d: {d2a2ac27-b89a-11d2-9335-00805ffe11b8}\n" );
                               // The volid in this example is actually the well-known invalid volid
        *pcEaten = 1;
        return( TRUE );
    }
    else
    if( 2 > cArgs
        ||
        TEXT('-') != rgptszArgs[0][0]
        &&
        TEXT('/') != rgptszArgs[0][0]
        ||
        TEXT(':') != rgptszArgs[1][1] )
    {
        printf( "Invalid parameter.  Use -? for help\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    *pcEaten = 2;
    __try
    {
        CVolumeId volid;

        TCHAR tcCommand = (TCHAR)CharUpper( (LPTSTR) rgptszArgs[0][1] );
        TCHAR tcDrive   = (TCHAR)CharUpper( (LPTSTR) rgptszArgs[1][0] );
        LONG iVol = tcDrive - TEXT('A');


        if( TEXT('G') == tcCommand )
        {
            OLECHAR *poszVolId;

            status = QueryVolumeId( iVol, &volid );
            if( FAILED(status) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't query for volume id") ));
                TrkRaiseNtStatus(status);
            }

            hr = StringFromCLSID( *(GUID*)&volid, &poszVolId );
            if( FAILED(hr) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Failed StringFromClsid %08x"), hr ));
                TrkRaiseException( hr );
            }

            _tprintf( TEXT("VolID = %s\n"), poszVolId );
            CoTaskMemFree( poszVolId );

        }
        else if( TEXT('S') == tcCommand && 3 <= cArgs )
        {
            TSZ2CLSID( rgptszArgs[2], (GUID*)&volid );
            EnablePrivilege( SE_RESTORE_NAME );
            status = SetVolId( iVol, volid );
            if( FAILED(status) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't set volume id") ));
                TrkRaiseNtStatus(status);
            }
        }
        else
        {
            printf( "Invalid parameter.  Use -? for help\n" );
            goto Exit;
        }

        hr = S_OK;
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }


Exit:

    if( FAILED(hr) )
        printf( "Failed: hr = %08x\n", hr );
    return( SUCCEEDED(hr) );

}   // main()









BOOL
DltAdminVolInfoFile( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    NTSTATUS status;
    HRESULT hr;
    HANDLE hFile = NULL;
    IO_STATUS_BLOCK Iosb;
    OLECHAR *poszVolId = NULL;

    BYTE rgb[ 2 * MAX_PATH ];
    PFILE_FS_VOLUME_INFORMATION pfile_fs_volume_information
        = reinterpret_cast<PFILE_FS_VOLUME_INFORMATION>(rgb);
    PFILE_FS_ATTRIBUTE_INFORMATION pfile_fs_attribute_information
        = reinterpret_cast<PFILE_FS_ATTRIBUTE_INFORMATION>(rgb);
    PFILE_FS_OBJECTID_INFORMATION pfile_fs_objectid_information
        = reinterpret_cast<PFILE_FS_OBJECTID_INFORMATION>(rgb);

    FILE_FS_SIZE_INFORMATION file_fs_size_information;
    FILE_FS_FULL_SIZE_INFORMATION file_fs_full_size_information;
    FILE_FS_DEVICE_INFORMATION file_fs_device_information;

    TCHAR tszFileSystemAttributes[ 2 * MAX_PATH ];
    DWORD dwFileSystemAttributeMask;
    TCHAR *ptszDeviceType = NULL;

    if( 0 == cArgs )
    {
        printf( "Missing parameter: a file/directory name must be specified\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    if( IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption VolInfoFile\n"
                  "   Purpose: Get volume information, given a file or directory name\n"
                  "   Usage:   -volinfofile <file or directory>\n"
                  "   E.g.     -volinfofile C:\\foo.doc\n"
                  "            -volinfofile \\\\scratch\\scratch\\jdoe\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    __try
    {
        *pcEaten = 1;

        TCHAR tszFileTime[ 80 ];

        status = TrkCreateFile(
                    rgptszArgs[0],
                    FILE_READ_ATTRIBUTES,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN,
                    FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    &hFile );
        if( !NT_SUCCESS(status) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open file \"%s\" (%08x)"), rgptszArgs[1], status ));
            TrkRaiseNtStatus(status);
        }

        status = NtQueryVolumeInformationFile( hFile, &Iosb,
                                               pfile_fs_volume_information,
                                               sizeof(rgb),
                                               FileFsVolumeInformation );
        if( !NT_SUCCESS(status) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't query volume information (%08x)"), status ));
            TrkRaiseNtStatus(status);
        }

        pfile_fs_volume_information->VolumeLabel[ pfile_fs_volume_information->VolumeLabelLength/sizeof(WCHAR) ]
            = L'\0';

        static_cast<CFILETIME>(pfile_fs_volume_information->VolumeCreationTime)
                              .Stringize( ELEMENTS(tszFileTime), tszFileTime );

        _tprintf( TEXT("\n")
                  TEXT("Volume creation time:\t%08x:%08x (%s)\n")
                  TEXT("Volume serial number:\t%08x\n")
                  TEXT("Supports objects:\t%s\n")
                  TEXT("Volume label:\t\t%s\n"),
                  pfile_fs_volume_information->VolumeCreationTime.HighPart,
                  pfile_fs_volume_information->VolumeCreationTime.LowPart,
                  tszFileTime,
                  pfile_fs_volume_information->VolumeSerialNumber,
                  pfile_fs_volume_information->SupportsObjects ? TEXT("True") : TEXT("False"),
                  pfile_fs_volume_information->VolumeLabel );

        status = NtQueryVolumeInformationFile( hFile, &Iosb,
                                               pfile_fs_attribute_information,
                                               sizeof(rgb),
                                               FileFsAttributeInformation );
        if( !NT_SUCCESS(status) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't query attribute information (%08x)"), status ));
            TrkRaiseNtStatus(status);
        }

        pfile_fs_attribute_information->FileSystemName[ pfile_fs_attribute_information->FileSystemNameLength/sizeof(WCHAR) ]
            = L'\0';

        _tcscpy( tszFileSystemAttributes, TEXT("") );

        dwFileSystemAttributeMask = FILE_CASE_SENSITIVE_SEARCH
                                    | FILE_CASE_PRESERVED_NAMES
                                    | FILE_UNICODE_ON_DISK
                                    | FILE_PERSISTENT_ACLS
                                    | FILE_FILE_COMPRESSION
                                    | FILE_VOLUME_QUOTAS
                                    | FILE_SUPPORTS_SPARSE_FILES
                                    | FILE_SUPPORTS_REPARSE_POINTS
                                    | FILE_SUPPORTS_REMOTE_STORAGE
                                    | FILE_VOLUME_IS_COMPRESSED
                                    | FILE_SUPPORTS_OBJECT_IDS
                                    | FILE_SUPPORTS_ENCRYPTION;

        if( FILE_CASE_SENSITIVE_SEARCH & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tCase sensitive search\n"));
        if( FILE_CASE_PRESERVED_NAMES & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tCase preserved names\n"));
        if( FILE_UNICODE_ON_DISK & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tUnicode on disk\n"));
        if( FILE_PERSISTENT_ACLS & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tPersistent ACLs\n"));
        if( FILE_FILE_COMPRESSION & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tFile compression\n"));
        if( FILE_VOLUME_QUOTAS & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tVolume quotas\n"));
        if( FILE_SUPPORTS_SPARSE_FILES & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tSupports sparse files\n"));
        if( FILE_SUPPORTS_REPARSE_POINTS & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tSupports reparse points\n"));
        if( FILE_SUPPORTS_REMOTE_STORAGE & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tSupports remote storage\n"));
        if( FILE_VOLUME_IS_COMPRESSED & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tVolume is compressed\n"));
        if( FILE_SUPPORTS_OBJECT_IDS & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tSupports object IDs\n"));
        if( FILE_SUPPORTS_ENCRYPTION & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tSupports encryption\n"));
        if( FILE_NAMED_STREAMS & pfile_fs_attribute_information->FileSystemAttributes )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\tSupports named streams\n"));
        if( !(dwFileSystemAttributeMask & pfile_fs_attribute_information->FileSystemAttributes) )
            _tcscat( tszFileSystemAttributes, TEXT("\t\t\t(Unknown bit)"));


        _tprintf( TEXT("File system attributes:\t%08x\n%s")
                  TEXT("Max component name:\t%d\n")
                  TEXT("File system name\t%s\n"),
                  pfile_fs_attribute_information->FileSystemAttributes, tszFileSystemAttributes,
                  pfile_fs_attribute_information->MaximumComponentNameLength,
                  pfile_fs_attribute_information->FileSystemName );

        status = NtQueryVolumeInformationFile( hFile, &Iosb,
                                               pfile_fs_objectid_information,
                                               sizeof(rgb),
                                               FileFsObjectIdInformation );
        if( NT_SUCCESS(status) )
        {
            hr = StringFromCLSID( *(GUID*)pfile_fs_objectid_information->ObjectId, &poszVolId );
            if( FAILED(hr) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Failed StringFromClsid %08x"), hr ));
                TrkRaiseException( hr );
            }

            _tprintf( TEXT("Volume Id:\t\t%s\n"), poszVolId );
            CoTaskMemFree( poszVolId );
        }
        else if( status != STATUS_INVALID_PARAMETER && status != STATUS_OBJECT_NAME_NOT_FOUND )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't query objectid information (%08x)"), status ));
            TrkRaiseNtStatus(status);
        }

        status = NtQueryVolumeInformationFile( hFile, &Iosb,
                                               &file_fs_full_size_information,
                                               sizeof(file_fs_full_size_information),
                                               FileFsFullSizeInformation );
        if( !NT_SUCCESS(status) )
        {
            status = NtQueryVolumeInformationFile( hFile, &Iosb,
                                                   &file_fs_size_information,
                                                   sizeof(file_fs_size_information),
                                                   FileFsSizeInformation );
            if( !NT_SUCCESS(status) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't query full size info or size info (%08x)"), status ));
                TrkRaiseNtStatus( status );
            }

            double TotalAllocInMB = file_fs_size_information.TotalAllocationUnits.QuadPart
                                    *
                                    file_fs_size_information.SectorsPerAllocationUnit
                                    *
                                    file_fs_size_information.BytesPerSector
                                    /
                                    1000000.0;

            _tprintf( TEXT("Total allocation units:\t%I64u (%.2fMB)\n")
                      TEXT("Available alloc:\t%I64u units\n")
                      TEXT("Sectors per alloc unit:\t%d\n")
                      TEXT("Bytes per sector:\t%d\n"),
                      file_fs_size_information.TotalAllocationUnits.QuadPart,
                      TotalAllocInMB,
                      file_fs_size_information.AvailableAllocationUnits.QuadPart,
                      file_fs_size_information.SectorsPerAllocationUnit,
                      file_fs_size_information.BytesPerSector );

        }
        else
        {
            double TotalAllocInMB = file_fs_full_size_information.TotalAllocationUnits.QuadPart
                                    *
                                    file_fs_full_size_information.SectorsPerAllocationUnit
                                    *
                                    file_fs_full_size_information.BytesPerSector
                                    /
                                    1000000.0;

            double CallerAvailAllocInMB
                                  = file_fs_full_size_information.CallerAvailableAllocationUnits.QuadPart
                                    *
                                    file_fs_full_size_information.SectorsPerAllocationUnit
                                    *
                                    file_fs_full_size_information.BytesPerSector
                                    /
                                    1000000.0;

            double ActualAvailAllocInMB
                                  = file_fs_full_size_information.ActualAvailableAllocationUnits.QuadPart
                                    *
                                    file_fs_full_size_information.SectorsPerAllocationUnit
                                    *
                                    file_fs_full_size_information.BytesPerSector
                                    /
                                    1000000.0;

            _tprintf( TEXT("Total allocation units:\t%I64u (%.2fMB)\n")
                      TEXT("Caller avail alloc:\t%I64u units (%.2fMB)\n")
                      TEXT("Actual avail alloc:\t%I64u units (%.2fMB)\n")
                      TEXT("Sectors per alloc unit:\t%d\n")
                      TEXT("Bytes per sector:\t%d\n"),
                      file_fs_full_size_information.TotalAllocationUnits.QuadPart,
                      TotalAllocInMB,
                      file_fs_full_size_information.CallerAvailableAllocationUnits.QuadPart,
                      CallerAvailAllocInMB,
                      file_fs_full_size_information.ActualAvailableAllocationUnits.QuadPart,
                      ActualAvailAllocInMB,
                      file_fs_full_size_information.SectorsPerAllocationUnit,
                      file_fs_full_size_information.BytesPerSector );
        }

        status = NtQueryVolumeInformationFile( hFile, &Iosb,
                                               &file_fs_device_information,
                                               sizeof(file_fs_device_information),
                                               FileFsDeviceInformation );
        if( !NT_SUCCESS(status) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't query file fs device information (%08x)"), status ));
            TrkRaiseNtStatus(status);
        }

        switch( file_fs_device_information.DeviceType )
        {
        case FILE_DEVICE_NETWORK:
            ptszDeviceType = L"Network"; break;
        case FILE_DEVICE_NETWORK_FILE_SYSTEM:
            ptszDeviceType = L"Network file system"; break;
        case FILE_DEVICE_CD_ROM:
            ptszDeviceType = L"CDROM"; break;
        case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
            ptszDeviceType = L"CDROM file system"; break;
        case FILE_DEVICE_VIRTUAL_DISK:
            ptszDeviceType = L"Virtual disk"; break;
        case FILE_DEVICE_DISK:
            ptszDeviceType = file_fs_device_information.Characteristics & FILE_REMOVABLE_MEDIA
                ? L"Removable disk" : L"Fixed disk";
            break;
        case FILE_DEVICE_DISK_FILE_SYSTEM:
            ptszDeviceType = file_fs_device_information.Characteristics & FILE_REMOVABLE_MEDIA
                ? L"Removable disk file system" : L"Fixed disk file system";
            break;
        default:
            ptszDeviceType = L"Unknown";
        }

        _tprintf( TEXT("Device Type:\t\t%s%s\n"),
                  ptszDeviceType,
                  (file_fs_device_information.Characteristics & FILE_REMOTE_DEVICE)
                      ? TEXT(" (remote)")
                      : TEXT("")
                  );


        hr = S_OK;

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = GetExceptionCode();
    }

    if( NULL != hFile )
        NtClose( hFile );


    if( FAILED(hr) )
        printf( "Failed: hr = %08x\n", hr );
    return SUCCEEDED(hr);
}



BOOL
DeleteIdFromVolumeTable( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    CVolumeId volid;
    CStringize stringize;
    CRpcClientBinding rc;
    TRKSVR_SYNC_VOLUME SyncVolume;
    TRKSVR_MESSAGE_UNION Msg;
    CMachineId mcidLocal( MCID_LOCAL );
    HRESULT hr = S_OK;

    if( 0 == cArgs )
    {
        printf( "Missing parameter: a volume ID name must be specified\n"
                "(in \"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\" form)\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    _tprintf( TEXT("Deleting volume %s from DC volume table\n"), rgptszArgs[0] );

    if( IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption DelDcVolId\n"
                  "   Purpose: Delete a volume ID from the DC volume table\n"
                  "   Usage:   -deldcvolid <stringized volume ID>\n"
                  "   E.g.     -deldcvolid {56730825-3ddc-11d2-a168-00805ffe11b8}\n"
                  "   Note:    The volume ID must be owned by this machine.\n"
                  "            Also, the services\\trkwks\\parameters\\configuration\\trkflags\n"
                  "            reg value must have the 0x1 bit set.\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    *pcEaten = 1;

    // Convert the volid string to a volid

    stringize.Use( rgptszArgs[0] );
    volid = stringize;

    if( CVolumeId() == volid )
    {
        _tprintf( TEXT("Error: Invalid volume ID\n") );
        return( FALSE );
    }

    // Send the delete request

    rc.RcInitialize( mcidLocal, s_tszTrkWksLocalRpcProtocol, s_tszTrkWksLocalRpcEndPoint, NO_AUTHENTICATION );
    __try
    {
        Msg.MessageType = SYNC_VOLUMES;
        Msg.ptszMachineID = NULL;
        Msg.Priority = PRI_9;
        Msg.SyncVolumes.cVolumes = 1;
        Msg.SyncVolumes.pVolumes = &SyncVolume;
        SyncVolume.hr = S_OK;
        SyncVolume.SyncType = DELETE_VOLUME;
        SyncVolume.volume = volid;

        hr = LnkCallSvrMessage( rc, &Msg );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if( SUCCEEDED(hr) )
        hr = SyncVolume.hr;

    if( FAILED(hr) )
        _tprintf( TEXT("Error: %08x\n"), hr );
    else if( S_OK != hr )
        _tprintf( TEXT("Success code: %08x\n"), hr );

    if( FAILED(hr) )
        printf( "Failed: hr = %08x\n", hr );
    return( SUCCEEDED(hr) );

}


BOOL
DeleteIdFromMoveTable( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    CDomainRelativeObjId droid;
    CStringize stringize;
    CRpcClientBinding rc;
    TRKSVR_MESSAGE_UNION Msg;
    CMachineId mcidLocal( MCID_LOCAL );
    HRESULT hr = S_OK;

    if( 0 == cArgs )
    {
        printf( "Missing parameter: a birth ID name must be specified\n"
                "(in \"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\" form)\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    _tprintf( TEXT("Deleting file %s from DC move table\n"), rgptszArgs[0] );

    if( IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption DelDcMoveId\n"
                  "   Purpose: Delete an entry from the DC move table\n"
                  "   Usage:   -deldcmoveid <stringized GUIDs of birth ID>\n"
                  "   E.g.     -deldcmoveid {xxx...xxx}{xxx...xxx}\n"
                  "   Where:   a stringized GUID is e.g. \"{56730825-3ddc-11d2-a168-00805ffe11b8}\"\n"
                  "   Note:    The birth ID must be owned by this machine.\n"
                  "            Also, the services\\trkwks\\parameters\\configuration\\trkflags\n"
                  "            reg value must have the 0x1 bit set.\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    *pcEaten = 1;

    stringize.Use( rgptszArgs[0] );
    droid = stringize;

    if( CDomainRelativeObjId() == droid )
    {
        _tprintf( TEXT("Error: Invalid birth ID\n") );
        return( FALSE );
    }


    rc.RcInitialize( mcidLocal, s_tszTrkWksLocalRpcProtocol, s_tszTrkWksLocalRpcEndPoint, NO_AUTHENTICATION );
    __try
    {
        CVolumeId volidDummy;
        Msg.MessageType = DELETE_NOTIFY;
        Msg.ptszMachineID = NULL;
        Msg.Priority = PRI_5;
        Msg.Delete.cVolumes = 0;
        Msg.Delete.pVolumes = &volidDummy;

        Msg.Delete.adroidBirth = &droid;
        Msg.Delete.cdroidBirth = 1;

        LnkCallSvrMessage(rc, &Msg);
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = HRESULT_FROM_WIN32(GetExceptionCode());
    }


    if( FAILED(hr) )
        _tprintf( TEXT("Error: %08x\n"), hr );
    else if( S_OK != hr )
        _tprintf( TEXT("Success code: %x\n"), hr );

    return( SUCCEEDED(hr) );
}





BOOL
DltAdminLookupVolId( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    CVolumeId volid;
    CStringize stringize;
    CRpcClientBinding rc;
    TRKSVR_SYNC_VOLUME SyncVolume;
    TRKSVR_MESSAGE_UNION Msg;
    CMachineId mcidLocal( MCID_LOCAL );
    HRESULT hr = S_OK;

    if( 0 == cArgs )
    {
        printf( "Missing parameter: a volume ID name must be specified\n"
                "(in \"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\" form)\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    _tprintf( TEXT("Searching for volume %s in DC volume table\n"), rgptszArgs[0] );

    if( IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption LookupVolId\n"
                  "   Purpose: Look up a volume ID from the DC volume table\n"
                  "   Usage:   -lookupvolid <stringized volume ID>\n"
                  "   E.g.     -lookupvolid {56730825-3ddc-11d2-a168-00805ffe11b8}\n"
                  "   Note:    The services\\trkwks\\parameters\\configuration\\trkflags\n"
                  "            reg value must have the 0x1 bit set before trkwks is started.\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    *pcEaten = 1;

    // Convert the volid string to a volid

    stringize.Use( rgptszArgs[0] );
    volid = stringize;

    if( CVolumeId() == volid )
    {
        _tprintf( TEXT("Error: Invalid volume ID\n") );
        return( FALSE );
    }

    // Send the delete request

    rc.RcInitialize( mcidLocal, s_tszTrkWksLocalRpcProtocol, s_tszTrkWksLocalRpcEndPoint, NO_AUTHENTICATION );
    __try
    {
        Msg.MessageType = SYNC_VOLUMES;
        Msg.ptszMachineID = NULL;
        Msg.Priority = PRI_9;
        Msg.SyncVolumes.cVolumes = 1;
        Msg.SyncVolumes.pVolumes = &SyncVolume;
        SyncVolume.hr = S_OK;
        SyncVolume.SyncType = FIND_VOLUME;
        SyncVolume.volume = volid;

        hr = LnkCallSvrMessage( rc, &Msg );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if( SUCCEEDED(hr) )
        hr = SyncVolume.hr;

    if( FAILED(hr) )
        _tprintf( TEXT("Error: %08x\n"), hr );
    else
    {
        if( S_OK != hr )
            _tprintf( TEXT("Success code is %08x\n"), hr );

        _tprintf( TEXT("Machine = \"%s\"\n"), static_cast<const TCHAR*>(CStringize(SyncVolume.machine)) );
    }

    if( FAILED(hr) )
        printf( "Failed: hr = %08x\n", hr );
    return( SUCCEEDED(hr) );

}






BOOL
DltAdminLookupDroid( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    CVolumeId volid;
    CStringize stringize;
    CRpcClientBinding rc;
    TRK_FILE_TRACKING_INFORMATION FileTrackingInformation;
    TRKSVR_MESSAGE_UNION Msg;
    CDomainRelativeObjId droid;
    CMachineId mcidLocal( MCID_LOCAL );
    HRESULT hr = S_OK;

    if( 0 == cArgs )
    {
        printf( "Missing parameter: a DROID must be specified\n"
                "(in \"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\" form)\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    _tprintf( TEXT("Searching for move ID %s in DC volume table\n"), rgptszArgs[0] );

    if( IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption LookupDroid\n"
                  "   Purpose: Look up a DROID from the DC move table\n"
                  "   Usage:   -lookupdroid <stringized DROIID>\n"
                  "   E.g.     -lookupdroid {f8b534f0-b65b-11d2-8fd8-0008c709d19e}{0ed45deb-03ed-11d3-b766-00805ffe11b8}\n"
                  "   Note:    You must be running as an administrator\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    *pcEaten = 1;

    stringize.Use( rgptszArgs[0] );
    droid = stringize;

    if( CDomainRelativeObjId() == droid )
    {
        _tprintf( TEXT("Error: Invalid birth ID\n") );
        return( FALSE );
    }


    rc.RcInitialize( mcidLocal, s_tszTrkWksLocalRpcProtocol, s_tszTrkWksLocalRpcEndPoint, NO_AUTHENTICATION );
    __try
    {
        memset( &FileTrackingInformation, 0, sizeof(FileTrackingInformation) );
        FileTrackingInformation.droidLast = droid;

        Msg.MessageType = SEARCH;
        Msg.ptszMachineID = NULL;
        Msg.Priority = PRI_5;
        Msg.Search.cSearch = 1;
        Msg.Search.pSearches = &FileTrackingInformation;

        LnkCallSvrMessage(rc, &Msg);
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = HRESULT_FROM_WIN32(GetExceptionCode());
    }


    if( SUCCEEDED(hr) )
        hr = FileTrackingInformation.hr;

    if( FAILED(hr) )
        _tprintf( TEXT("Error: %08x\n"), hr );
    else
    {
        if( S_OK != hr )
            _tprintf( TEXT("Success code is %08x\n"), hr );

        _tprintf( TEXT("Machine = \"%s\"\n"), static_cast<const TCHAR*>(CStringize(FileTrackingInformation.mcidLast)) );
    }

    return( TRUE );
}






EXTERN_C void __cdecl _tmain( int cArgs, TCHAR *prgtszArg[])
{
    HRESULT hr = S_OK;
    NTSTATUS status = STATUS_SUCCESS;
    int iArg = 0;
    int iError = 0;

    OLECHAR oszOID[ CCH_GUID_STRING + 1 ];

    TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG, "DltAdmin" );
    hr = CoInitialize( NULL );
    if (FAILED(hr))
    {
        _tprintf( TEXT("Unable to CoInitialize( NULL )-- aborting. (0x%08x)\n"), 
                  hr );
        return;
    }

    TCHAR tszStringizedTime[ 80 ];

    __try
    {
        // Skip over the executable name
        iArg++;
        cArgs--;

        if( 0 == cArgs )
        {
            Usage();
            exit(1);
        }

        for( ; iArg <= cArgs; cArgs--, iArg++ )
        {
            ULONG cEaten = 0;

            if( TEXT('-') != prgtszArg[iArg][0]
                &&
                TEXT('/') != prgtszArg[iArg][0] )
            {
                _tprintf( TEXT("Invalid option, ignoring: %s\n"), prgtszArg[iArg] );
                iError = max( iError, 1 );
                continue;
            }

            if( !_tcsicmp( TEXT("deldcvolid"), &prgtszArg[iArg][1] ) )
            {
                iArg++;
                cArgs--;
                if( !DeleteIdFromVolumeTable( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );

                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("deldcmoveid"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DeleteIdFromMoveTable( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("lookupvolid"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminLookupVolId( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("lookupdroid"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminLookupDroid( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("volinfofile"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminVolInfoFile( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("cleanvol"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminCleanVol( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("svrstat"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminSvrStat( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("volstat"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !VolumeStatistics( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("volid"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !VolumeIdSetOrGet( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("lockvol"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminLockVol( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("fileoid"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminFileOid( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("enumoids"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminEnumOids( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("oidsnap"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminOidSnap( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("link"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminLink( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("loadlib"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminProcessAction( LOAD_LIBRARY, cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("freelib"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminProcessAction( FREE_LIBRARY, cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("debugbreak"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminProcessAction( DEBUG_BREAK, cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("createprocess"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminProcessAction( CREATE_PROCESS, cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("config"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminConfig( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("refresh"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminRefresh( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("setvolseq"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminSetVolumeSeqNumber( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("setdroidseq"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminSetDroidSeqNumber( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("backupread"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminBackupRead( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("backupwrite"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;

                if( !DltAdminBackupWrite( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("sleep"), &prgtszArg[iArg][1] ))
            {
                iArg++;
                cArgs--;
                Sleep( 1000 );
            }
            else if( !_tcsicmp( TEXT("temp"), &prgtszArg[iArg][1] ))
            {
                if( !DltAdminTemp( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("temp2"), &prgtszArg[iArg][1] ))
            {
                if( !DltAdminTemp2( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( !_tcsicmp( TEXT("temp3"), &prgtszArg[iArg][1] ))
            {
                if( !DltAdminTemp3( cArgs, &prgtszArg[iArg], &cEaten ))
                    iError = max( iError, 2 );
                iArg += cEaten;
                cArgs -= cEaten;
            }
            else if( TEXT('?') == prgtszArg[iArg][1] )
            {
                Usage();
                exit( 1 );
            }
            else
            {
                _tprintf( TEXT("Invalid option, ignoring: %s\n"), prgtszArg[iArg] );
                iError = max( iError, 1 );
                continue;
            }
        }
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
        iError = max( iError, 2 );
    }

    if( FAILED(hr) )
        printf( "HR = %08X\n", hr );

    CoUninitialize();

//    return( iError );

}   // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\dltadmin\enumoid.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>
#include "trkwks.hxx"
#include "dltadmin.hxx"



BOOL
DltAdminEnumOids( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    LONG iVol = 0;
    LONG iArg = 0;
    BOOL fSuccess = FALSE;
    BOOL fCrossVolumeOnly = FALSE;
    BOOL fShowPath = FALSE;
    BOOL fShowBirth = FALSE;
    BOOL fAllVolumes = TRUE;

    if( 1 <= cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        *pcEaten = 1;
        printf( "\nOption EnumOIDs\n"
                  "   Purpose: Enumerate the object IDs on one or more volumes\n"
                  "   Usage:   -enumoids [-<options>] [drive letter (all drives if omitted)]\n"
                  "   Options: -x  => Show only files with cross-volume bit set\n"
                  "            -b  => Show the birth ID too\n"
                  "            -f  => Show the filename too\n"
                  "   E.g.:    -enumoids\n"
                  "            -enumoids -xb d:\n" );
        return( TRUE );
    }

    if( cArgs > 0 &&
        ( TEXT('/') == rgptszArgs[iArg][0]
          ||
          TEXT('-') == rgptszArgs[iArg][0]
        ) )
    {
        _tcslwr( rgptszArgs[iArg] );
        for( LONG iOption = 1; TEXT('\0') != rgptszArgs[0][iOption]; iOption++ )
        {
            switch( rgptszArgs[iArg][iOption] )
            {
            case TEXT('x'):
                fCrossVolumeOnly = TRUE;
                break;
            case TEXT('b'):
                fShowBirth = TRUE;
                break;
            case TEXT('f'):
                fShowPath = TRUE;
                break;
            default:
                _tprintf( TEXT("Ignoring invalid option (use -? for help): %c\n"), rgptszArgs[0][iOption] );
                break;
            }
        }
        iArg++;
        (*pcEaten)++;
    }

    if( cArgs > iArg )
    {
        _tcslwr( rgptszArgs[iArg] );
        if( TEXT(':') != rgptszArgs[iArg][1]
            ||
            TEXT('a') > rgptszArgs[iArg][0]
            ||
            TEXT('z') < rgptszArgs[iArg][0] )
        {
            printf( "Invalid arguments.  Use -? for help\n" );
            return( FALSE );
        }

        (*pcEaten)++;
        iVol = rgptszArgs[iArg][0] - TEXT('a');
        fAllVolumes = FALSE;
    }


    while( iVol < 26 )
    {
        if( IsLocalObjectVolume( iVol ))
        {
            LONG lLastError = 0;

            printf( "Volume %c:\n", iVol+TEXT('a') );

            __try // __finally
            {
                CObjId                  objid;
                CDomainRelativeObjId    droidBirth;
                CObjIdEnumerator        oie;
                ULONG                   cObjId = 0;

                if(oie.Initialize(CVolumeDeviceName(iVol)) == TRUE)
                {
                    if( oie.FindFirst( &objid, &droidBirth ))
                    {
                        do
                        {
                            if( fCrossVolumeOnly && droidBirth.GetVolumeId().GetUserBitState()
                                ||
                                !fCrossVolumeOnly )
                            {
                                if( droidBirth.GetVolumeId().GetUserBitState() )
                                    printf( " x " );
                                else
                                    printf( "   " );

                                _tprintf( TEXT("objid = %s\n"),
                                          static_cast<const TCHAR*>(CStringize(objid)));

                                if( fShowBirth )
                                {
                                    _tprintf( TEXT("           %s (birth volid)\n"),
                                              static_cast<const TCHAR*>(CStringize(droidBirth.GetVolumeId() )));
                                    _tprintf( TEXT("           %s (birth objid)\n"),
                                              static_cast<const TCHAR*>(CStringize(droidBirth.GetObjId() )));
                                }

                                if( fShowPath )
                                {
                                    TCHAR tszPath[ MAX_PATH + 1 ];
                                    NTSTATUS status = FindLocalPath( iVol, objid, &droidBirth, &tszPath[2] );
                                    if( NT_SUCCESS(status) )
                                    {
                                        tszPath[0] = VolChar(iVol);
                                        tszPath[1] = TEXT(':');
                                        _tprintf( TEXT("           %s\n"), tszPath );
                                    }
                                    else
                                        _tprintf( TEXT("           %s (%08x)\n"), TEXT("<not found>"), status );
                                }
                            }

                        } while(oie.FindNext(&objid, &droidBirth));

                    }
                }
            }
            __except( BreakOnDebuggableException() )
            {
                printf( "Exception occurred: %08x\n", GetExceptionCode() );
            }

        }   // if( IsLocalObjectVolume( iVol ))

        if( !fAllVolumes )
            break;
        iVol++;

    }   // while( iVol < 26 )

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\dltadmin\link.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>
#include "trkwks.hxx"
#include "dltadmin.hxx"
#include <shlobj.h>
#include <shlguid.h>

#define CB_LINK_CLIENT_MAX  512


void
DoCreateLink(IShellLink * pshlink, const TCHAR *ptszLink, const TCHAR *ptszSrc)
{
    HRESULT hr;
    IPersistFile *pPersistFile = NULL;

    DWORD dwWritten;
    BYTE rgb[ CB_LINK_CLIENT_MAX ];
    ULONG cbPersist = 0;

    memset( rgb, 0, sizeof(rgb) );

    hr = pshlink->QueryInterface( IID_IPersistFile, (void**) &pPersistFile );
    if( FAILED(hr) )
    {
        _tprintf( TEXT("Couldn't QI IShellLink for IPersistFile (%08x)"), hr );
        goto Exit;
    }

    hr = pshlink->SetPath( ptszSrc );
    _tprintf( TEXT("IShellLink::SetPath returned %08X\n"), hr );
    if( S_OK != hr )
        goto Exit;

    hr = pPersistFile->Save( ptszLink, TRUE );
    if( FAILED(hr) )
    {
        _tprintf( TEXT("Couldn't persist IShellLink (%08x"), hr );
        goto Exit;
    }
    pPersistFile->SaveCompleted( ptszLink );

Exit:

    RELEASE_INTERFACE( pPersistFile );
    return;

}

TCHAR *
GetRestrict(DWORD r)
{
    static TCHAR tszError[256];

    tszError[0] = 0;
    if (r == TRK_MEND_DEFAULT)
    {
        _tcscpy(tszError, TEXT("TRK_MEND_DEFAULT "));
    }
    if (r & TRK_MEND_DONT_USE_LOG)
    {
        _tcscat(tszError, TEXT("TRK_MEND_DONT_USE_LOG "));
    }
    if (r & TRK_MEND_DONT_USE_DC)
    {
        _tcscat(tszError, TEXT("TRK_MEND_DONT_USE_DC "));
    }
    if (r & TRK_MEND_SLEEP_DURING_MEND)
    {
        _tcscat(tszError, TEXT("TRK_MEND_SLEEP_DURING_SEARCH "));
    }
    if (r & TRK_MEND_DONT_SEARCH_ALL_VOLUMES)
    {
        _tcscat(tszError, TEXT("TRK_MEND_DONT_SEARCH_ALL_VOLUMES "));
    }
    if (r & TRK_MEND_DONT_USE_VOLIDS)
    {
        _tcscat(tszError, TEXT("TRK_MEND_DONT_USE_VOLIDS "));
    }
    return(tszError);
}



enum EXTRAFLAGS
{
    EXTRAFLAG_SHOW_IDS = 1
};

extern "C"
IID IID_ISLTracker
= { /* 7c9e512f-41d7-11d1-8e2e-00c04fb9386d */
    0x7c9e512f,
    0x41d7,
    0x11d1,
    {0x8e, 0x2e, 0x00, 0xc0, 0x4f, 0xb9, 0x38, 0x6d}
};

class ISLTracker : public IUnknown
{
public:

    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) ()  PURE;
    STDMETHOD_(ULONG,Release) () PURE;

    STDMETHOD(Resolve)(HWND hwnd, DWORD fFlags, DWORD TrackerRestrictions) PURE;
    STDMETHOD(GetIDs)(CDomainRelativeObjId *pdroidBirth, CDomainRelativeObjId *pdroidLast, CMachineId *pmcid) PURE;
};  // interface ISLTracker




void
DisplayIDs( ISLTracker *ptracker )
{
    HRESULT hr = S_OK;
    CDomainRelativeObjId droidBirth, droidLast;
    CMachineId mcid;
    TCHAR tsz[ MAX_PATH ];
    TCHAR *ptsz = tsz;

    hr = ptracker->GetIDs( &droidBirth, &droidLast, &mcid );
    if( FAILED(hr) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get IDs") ));
        TrkRaiseException( hr );
    }

    droidBirth.Stringize( tsz, sizeof(tsz) );
    _tprintf( TEXT("Birth =\t%s\n"), tsz );

    droidLast.Stringize( tsz, sizeof(tsz) );
    _tprintf( TEXT("Last =\t%s\n"), tsz );

    ptsz = tsz;
    mcid.Stringize(ptsz);
    _tprintf( TEXT("Machine =\t%s\n"), tsz );

}


void
DoResolveLink(IShellLink * pshlink, const TCHAR * ptszLink, DWORD r, DWORD dwSLR, DWORD grfExtra,
              DWORD dwTimeout )
{
    IPersistFile * pPersistFile = NULL;
    ISLTracker * ptracker = NULL;

    __try
    {
        DWORD dwRead;
        HRESULT  hr;
        WCHAR    wszPath[MAX_PATH+1];
        ULONG    cbPath = sizeof(wszPath);
        WIN32_FIND_DATA fd;

        hr = pshlink->QueryInterface( IID_IPersistFile, (void**) &pPersistFile );
        if( FAILED(hr) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't QI for IPersistFile")));
            TrkRaiseException( hr );
        }

        hr = pPersistFile->Load( ptszLink, STGM_SHARE_EXCLUSIVE | STGM_READWRITE );
        if( FAILED(hr) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't load IShellLink")));
            TrkRaiseException( hr );
        }
        RELEASE_INTERFACE( pPersistFile );

        if( (SLR_NO_UI & dwSLR) )
        {
            if( 0 != dwTimeout )
            {
                dwTimeout = min( dwTimeout, 0xfffe );
                _tprintf( TEXT("Timeout = %d seconds\n"), dwTimeout/1000 );
            }
        }
        else if( 0 != dwTimeout )
        {
            _tprintf( TEXT("Timeout will be ignored (since SLR_NO_UI isn't set)\n") );
        }

        // Track it
        if( TRK_MEND_DEFAULT == r && 0 == grfExtra )
        {
            hr = pshlink->Resolve( (SLR_NO_UI & dwSLR) ? NULL : GetDesktopWindow(),
                                   (dwTimeout<<16) | dwSLR | SLR_ANY_MATCH );
        }
        else
        {
            hr = pshlink->QueryInterface( IID_ISLTracker, (void**) &ptracker );
            if( FAILED(hr) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't QI for ISLTracker")));
                TrkRaiseException( hr );
            }

            if( EXTRAFLAG_SHOW_IDS & grfExtra )
                DisplayIDs( ptracker );

            hr = ptracker->Resolve( GetDesktopWindow(), (dwTimeout<<16) | dwSLR | SLR_ANY_MATCH, r );

            if( EXTRAFLAG_SHOW_IDS & grfExtra )
                DisplayIDs( ptracker );
        }

        pshlink->GetPath( wszPath, cbPath, &fd, 0 );


        wprintf( L"%s %08X %s\n",
                  wszPath, hr, GetRestrict(r) );

        RELEASE_INTERFACE( ptracker );

    }
    __except( BreakOnDebuggableException() )
    {
        RELEASE_INTERFACE( pPersistFile );
        RELEASE_INTERFACE( ptracker );

    }

}


BOOL
DltAdminLink( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{ 
    BOOL fSuccess = FALSE;
    HRESULT hr;
    CMachineId mcid(MCID_LOCAL);
    DWORD r = TRK_MEND_DEFAULT;
    DWORD grfExtra = 0;
    DWORD dwTimeout = 0;
    DWORD dwSLR = 0;    // SLR_ flags
    IShellLink *pshlink = NULL;
    WCHAR wszFullPath[ MAX_PATH + 1 ];
    DWORD dwMoveFlags = MOVEFILE_FAIL_IF_NOT_TRACKABLE |
                        MOVEFILE_COPY_ALLOWED |
                        MOVEFILE_REPLACE_EXISTING;


    *pcEaten = 0;

    if( 0 == cArgs
        ||
        rgptszArgs[0][0] != TEXT('-') && rgptszArgs[0][0] != TEXT('/') )
    {
        printf( "Invalid parameters.  Use -? for usage info\n" );
        *pcEaten = 0;
        goto Exit;
    }
    else if( 1 <= cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption Link\n"
                  "   Purpose: Create/resolve a shell link\n"
                  "   Usage:   -link [operation]\n"
                  "   E.g.:    -link -c LinkClient LinkSource\n"
                  "            -link -r LinkClient\n"
                  "            -link -rd LinkClient\n" );

        printf(   "   Operations:\n" );
        printf(   "            Operation   Params\n");
        printf(   "            ---------   ------\n");
        printf(   "            CreateLink  -c <link> <src>\n");
        printf(   "            ResolveLink -r<opts> <link>\n");
        printf(   "              where <opts> may use:\n" );
        printf(   "                            -l = don't use log\n");
        printf(   "                            -d = don't use dc\n");
        printf(   "                            -i = don't use volids\n");
        printf(   "                            -m = don't scan all volumes on a machine\n");
        printf(   "                            -s = no search (SLR_NOSEARCH)\n");
        printf(   "                            -t = no track (SLR_NOTRACK)\n");
        printf(   "                            -x = show before/after droids\n");
        printf(   "                            -u = no UI (SLR_NOUI)\n");
        printf(   "                            -w(#)\n");
        printf(   "                               = Timeout (wait) seconds on IShellLink::Resolve\n");
        printf(   "                            -z = sleep in CTrkWksSvc::Mend\n");

        *pcEaten = 1;
        fSuccess = TRUE;
        goto Exit;
    }


    hr = CoCreateInstance( CLSID_ShellLink, NULL, CLSCTX_ALL, IID_IShellLink, (void**)&pshlink );
    if( FAILED(hr) )
    {
        printf( "Couldn't get an IShellLink (%08x)\n", hr );
        goto Exit;
    }

    switch (rgptszArgs[0][1])
    {
    case TEXT('c'):
    case TEXT('C'):

        if( 3 <= cArgs )
        {
            *pcEaten = 3;
            if( MAX_PATH < RtlGetFullPathName_U( rgptszArgs[2],
                                                 sizeof(wszFullPath),
                                                 wszFullPath, NULL ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get full path name") ));
                goto Exit;
            }
            DoCreateLink( pshlink, rgptszArgs[1], wszFullPath );
        }
        break;

    case TEXT('r'):
    case TEXT('R'):

        if( 2 <= cArgs )
        {
            *pcEaten = 2;

            for( int i = 2; rgptszArgs[0][i] != TEXT('\0'); i++ )
            {
                switch(rgptszArgs[0][i])
                {
                    case TEXT('l'):
                    case TEXT('L'):
                        r |= TRK_MEND_DONT_USE_LOG;
                        break;
                    case TEXT('d'):
                    case TEXT('D'):
                        r |= TRK_MEND_DONT_USE_DC;
                        break;
                    case TEXT('i'):
                    case TEXT('I'):
                        r |= TRK_MEND_DONT_USE_VOLIDS;
                        break;
                    case TEXT('m'):
                    case TEXT('M'):
                        r |= TRK_MEND_DONT_SEARCH_ALL_VOLUMES;
                        break;
                    case TEXT('s'):
                    case TEXT('S'):
                        dwSLR |= SLR_NOSEARCH;
                        break;
                    case TEXT('t'):
                    case TEXT('T'):
                        dwSLR |= SLR_NOTRACK;
                        break;
                    case TEXT('u'):
                    case TEXT('U'):
                        dwSLR |= SLR_NO_UI;
                        break;
                    case TEXT('x'):
                    case TEXT('X'):
                        grfExtra |= EXTRAFLAG_SHOW_IDS;
                        break;
                    case TEXT('z'):
                    case TEXT('Z'):
                        r |= TRK_MEND_SLEEP_DURING_MEND;
                        break;

                    case TEXT('w'):
                    case TEXT('W'):

                        // e.g. -link -rw(30)m
                        if( TEXT('(') == rgptszArgs[0][i+1] )
                        {
                            TCHAR *ptc = _tcschr( &rgptszArgs[0][i], TEXT(')') );
                            if( NULL != ptc )
                            {
                                if( 1 == _stscanf( &rgptszArgs[0][i+1], TEXT("(%d)"), &dwTimeout ))
                                {
                                    dwTimeout *= 1000;  // => milliseconds
                                    i = ( (BYTE*) ptc - (BYTE*) rgptszArgs[0] ) / sizeof(TCHAR);
                                    break;
                                }
                            }
                        }


                    default:
                        _tprintf( TEXT("Bad Resolve switch: %c\n"), rgptszArgs[0][i] );
                        goto Exit;
                }   // switch
            }   // for

            DoResolveLink( pshlink, rgptszArgs[1], r, dwSLR, grfExtra, dwTimeout );
        }
        break;

    default:
        _tprintf( TEXT("Invalid Link option: %c\n"), rgptszArgs[0][1] );
        *pcEaten = 1;
        break;
    }


Exit:

    RELEASE_INTERFACE( pshlink );

    return( fSuccess );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\dltadmin\oidsnap.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>
#include "trkwks.hxx"
#include "dltadmin.hxx"


inline void
WriteToSnapshot( HANDLE hFileSnapshot, const TCHAR *ptsz )
{
    ULONG cb, cbWritten;

    if( NULL != ptsz )
        cb = _tcslen( ptsz ) * sizeof(TCHAR);
    else
    {
        cb = sizeof(TCHAR);
        ptsz = TEXT("");
    }

    if( !WriteFile( hFileSnapshot, ptsz, cb, &cbWritten, NULL ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed WriteFile (%lu)"), GetLastError() ));
        TrkRaiseLastError();
    }

    if( cb != cbWritten )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Not all of the data was written (%d/%d)"),
                 cbWritten, cb ));
        TrkRaiseWin32Error( ERROR_WRITE_FAULT );
    }
}


BOOL
DltAdminOidSnap( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    NTSTATUS status = 0;
    TCHAR tszFile[ MAX_PATH + 1 ];
    TCHAR tszDir[ MAX_PATH + 1 ];
    TCHAR* ptcTmp = NULL;
    LONG iVol;
    BOOL fSuccess = TRUE;
    BOOL fSaving = FALSE;
    HANDLE hFileSnapshot = INVALID_HANDLE_VALUE;
    HANDLE hMapping = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK Iosb;
    TCHAR tszFileData[ 3 * MAX_PATH ];
    ULONG cLine = 0;


    if( cArgs >= 2 )
    {
        _tcslwr( rgptszArgs[0] );
        _tcslwr( rgptszArgs[1] );
    }

    if( 3 != cArgs
        ||
        TEXT('-') != rgptszArgs[0][0] && TEXT('/') != rgptszArgs[0][0]
        ||
        TEXT('g') != rgptszArgs[0][1] && TEXT('s') != rgptszArgs[0][1]
        ||
        TEXT(':') != rgptszArgs[1][1]
        ||
        TEXT('a') > rgptszArgs[1][0] || TEXT('z') < rgptszArgs[1][0] )
    {
        printf( "\nOption OidSnap\n"
                " Purpose: Take a snapshot of the volume ID and all object IDs for a volume\n"
                " Usage:   -oidsnap [-g|-s] <drive letter>: <snapshot file>\n"
                " Where:   -g indicates get (create a snapshot)\n"
                "          -s indicates set (from the snapshot file)\n"
                " E.g.:    -oidsnap -g d: snapshot.txt\n"
                "          -oidsnap -s d: snapshot.txt\n" );
        return( TRUE );
    }


    fSaving = TEXT('g') == rgptszArgs[0][1];

    iVol = rgptszArgs[1][0] - TEXT('a');
    if( !IsLocalObjectVolume( iVol ))
    {
        _tprintf( TEXT("%c: isn't an NTFS5 volume\n"), VolChar(iVol) );
        goto Exit;
    }


    __try
    {
        FILE_FS_OBJECTID_INFORMATION fsobOID;

        EnableRestorePrivilege();

        // Open the snapshot file

        hFileSnapshot = CreateFile( rgptszArgs[2],
                            fSaving ? GENERIC_WRITE : GENERIC_READ,
                            0, NULL,
                            fSaving ? CREATE_ALWAYS : OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL, NULL );
        if( INVALID_HANDLE_VALUE == hFileSnapshot )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open file: %s (%lu)"),
                     rgptszArgs[2], GetLastError() ));
            TrkRaiseLastError();
        }

        //  ----
        //  Save
        //  ----

        if( fSaving )
        {
            // Get the volid

            CVolumeId volid;
            status = QueryVolumeId( iVol, &volid );
            if( STATUS_OBJECT_NAME_NOT_FOUND != status && !NT_SUCCESS(status) )
                TrkRaiseNtStatus( status );

            // Write the volid to the snapshot file.

            WriteToSnapshot( hFileSnapshot, TEXT("VolId, ") );

            CStringize strVolid(volid);
            WriteToSnapshot( hFileSnapshot, static_cast<const TCHAR*>(strVolid) );
            WriteToSnapshot( hFileSnapshot, TEXT("\n") );
            WriteToSnapshot( hFileSnapshot, NULL );
            cLine++;

            CObjId                  objid;
            CDomainRelativeObjId    droidBirth;
            CObjIdEnumerator        oie;

            // Loop through the files with object IDs

            if(oie.Initialize(CVolumeDeviceName(iVol)) == TRUE)
            {
                if(oie.FindFirst(&objid, &droidBirth))
                {
                    do
                    {
                        // Open the file so that we can get its path

                        HANDLE hFile;
                        status = OpenFileById(  iVol, objid, SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                                                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                                0, &hFile);
                        if( !NT_SUCCESS(status) )
                        {
                            TrkLog(( TRKDBG_ERROR, TEXT("Failed OpenFileById for %s"),
                                     static_cast<const TCHAR*>(CStringize(objid)) ));
                            TrkRaiseNtStatus(status);
                        }

                        // Get the local path 

                        status = QueryVolRelativePath( hFile, tszFileData );
                        if( !NT_SUCCESS(status) )
                        {
                            TrkLog(( TRKDBG_ERROR, TEXT("Failed QueryVolRelativePath for %s"),
                                     static_cast<const TCHAR*>(CStringize(objid)) ));
                            TrkRaiseNtStatus(status);
                        }

                        // Write the path, objid, and birth ID to the snapshot file.

                        _tcscat( tszFileData, TEXT(" = ") );
                        _tcscat( tszFileData, static_cast<const TCHAR*>(CStringize(objid)) );
                        _tcscat( tszFileData, TEXT(", ") );
                        _tcscat( tszFileData, static_cast<const TCHAR*>(CStringize(droidBirth)) );
                        _tcscat( tszFileData, TEXT("\n") );


                        // Write a line terminator to the snapshot file.

                        WriteToSnapshot( hFileSnapshot, tszFileData );
                        WriteToSnapshot( hFileSnapshot, NULL );

                        cLine++;

                    } while(oie.FindNext(&objid, &droidBirth));

                    // Write an marker to show end-of-file

                    WriteToSnapshot( hFileSnapshot, TEXT("\n") );
                    WriteToSnapshot( hFileSnapshot, NULL );
                }
            }

            printf( "%d IDs saved\n", cLine );
        
        }   // if fSaving

        //  ---------
        //  Restoring
        //  ---------

        else
        {
            ULONG cCollisions = 0, cSuccess = 0;
            TCHAR *ptsz = NULL;

            // Map the snapshot file into memory.

            hMapping = CreateFileMapping( hFileSnapshot, NULL, PAGE_READONLY, 0, 0, NULL );
            if( NULL == hMapping )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Failed CreateFileMapping") ));
                TrkRaiseLastError();
            }

            ptsz = reinterpret_cast<TCHAR*>( MapViewOfFile( hMapping, FILE_MAP_READ, 0, 0, 0 ));
            if( NULL == ptsz )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't map view of file") ));
                TrkRaiseLastError();
            }

            // The file should start with the volid

            if( NULL == _tcsstr( ptsz, TEXT("VolId, ") ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't find volid") ));
                TrkRaiseException( E_FAIL );
            }

            // Move ptsz to the start of the stringized volid
            ptsz += _tcslen(TEXT("VolId, "));

            // Unstringize the volid and set it on the volume.

            CVolumeId volid;
            CStringize stringize;
            stringize.Use( ptsz );
            volid = stringize;

            status = SetVolId( iVol, volid );
            if( !NT_SUCCESS(status) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't set volid") ));
                TrkRaiseNtStatus(status);
            }
            cSuccess++;

            // Move past the eol & null after the volid.

            ptsz = _tcschr( ptsz, TEXT('\n') );
            if( NULL == ptsz || TEXT('\0') != ptsz[1] )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Unexpected end of file") ));
                TrkRaiseException( E_FAIL );
            }
            cLine++;
            ptsz += 2;  // Past '\n' and '\0'

            // Init tszPath with the drive letter.

            TCHAR tszPath[ MAX_PATH + 1 ];
            tszPath[0] = VolChar(iVol);
            tszPath[1] = TEXT(':');

            // Loop through the object IDs in the snapshot file.
            // They are in the form:
            //
            //    <file> = <objid>, <birth ID>
            //
            // E.g.
            //    \test = {...}, {...}{...}

            while( TRUE )
            {
                // Find the separator between the file name and the objid

                TCHAR *ptszSep;
                ptszSep = _tcschr( ptsz, TEXT('=') );
                if( NULL == ptszSep )
                    TrkRaiseException( E_FAIL );

                // cch is the length of the file name

                ULONG cch = ptszSep - ptsz;
                if( 0 == cch )
                    TrkRaiseException( E_FAIL );
                cch--;

                // Put the file name into tszPath

                _tcsncpy( &tszPath[2], ptsz, cch );
                tszPath[2+cch] = TEXT('\0');

                // Move ptsz to the beginning of the stringized objid

                ptsz = ptszSep + 1;
                if( TEXT(' ') != *ptsz )
                    TrkRaiseException( E_FAIL );
                ptsz++;

                // Unstringize the objid

                stringize.Use( ptsz );
                CObjId objid = stringize;

                // Move ptsz to the beginning of the birth ID, and unstringize it.

                ptsz = _tcschr( ptsz, TEXT(',') );
                if( NULL == ptsz || TEXT(' ') != ptsz[1] )
                    TrkRaiseException( E_FAIL );

                ptsz += 2;
                stringize.Use( ptsz );
                CDomainRelativeObjId droidBirth;
                droidBirth = stringize;

                // Set the objid and birth ID

                status = SetObjId( tszPath, objid, droidBirth );
                if( STATUS_OBJECT_NAME_COLLISION == status )
                {
                    cCollisions++;
                    status = STATUS_SUCCESS;
                }
                else if( FAILED(status) )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Couldn't set objid on %s"), tszPath ));
                    TrkRaiseNtStatus( status );
                }
                else
                    cSuccess++;

                //_tprintf( TEXT("Set %s on %s\n"), static_cast<const TCHAR*>(CStringize(objid)), tszPath );

                // Move to the endo of the line

                ptsz = _tcschr( ptsz, TEXT('\n') );
                if( NULL == ptsz || TEXT('\0') != ptsz[1] )
                    TrkRaiseException( E_FAIL );

                // Move to the beginning of the next line
                ptsz += 2;  // '\n' & '\0'

                // If this is an empty line, then we're at the end of the file.
                if( TEXT('\n') == *ptsz )
                    break;

            }   // while( TRUE )

            printf( "%d IDs successfully set, %d ID collisions\n", cSuccess, cCollisions );

        }   // if fSaving ... else
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        printf( "Error exception at line %d: %08x\n", cLine, GetExceptionCode() );
    }


Exit:

    return( TRUE );

}   // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\dltadmin\procact.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>
#include "trkwks.hxx"
#include "dltadmin.hxx"



typedef HINSTANCE (WINAPI *PFNLoadLibrary)(LPCTSTR);
typedef HMODULE (WINAPI *PFNGetModuleHandle)(LPCTSTR);
typedef BOOL (WINAPI *PFNFreeLibrary)(HINSTANCE);
typedef LONG (WINAPI *PFNGetLastError)();
typedef VOID (WINAPI *PFNDebugBreak)();
typedef VOID (WINAPI *PFNOutputDebugStringW)( LPCTSTR );
typedef BOOL (WINAPI *PFNCreateProcessW)(
                                            IN LPCWSTR lpApplicationName,
                                            IN LPWSTR lpCommandLine,
                                            IN LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                            IN LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                            IN BOOL bInheritHandles,
                                            IN DWORD dwCreationFlags,
                                            IN LPVOID lpEnvironment,
                                            IN LPCWSTR lpCurrentDirectory,
                                            IN LPSTARTUPINFOW lpStartupInfo,
                                            OUT LPPROCESS_INFORMATION lpProcessInformation
                                            );

typedef struct
{
    EProcessAction eAction;
    PFNGetModuleHandle pfnGetModuleHandleW;
    PFNFreeLibrary pfnFreeLibrary;
    PFNLoadLibrary pfnLoadLibraryW;
    PFNGetLastError pfnGetLastError;
    PFNDebugBreak pfnDebugBreak;
    PFNOutputDebugStringW pfnOutputDebugStringW;
    PFNCreateProcessW pfnCreateProcessW;
    WCHAR wsz[ 4*MAX_PATH + 1 ];
    WCHAR wszMessage[ 2*MAX_PATH + 1 ];
}   THREADFNSTRUCT;


extern "C"
{

// Turn off stack-probing.
#pragma check_stack (off)

// Also turn off optimizations, to ensure that the compiler doesn't
// consolidate any of this code with that from another function.
#pragma optimize( "", off )

static void BeforeThreadFunc (void)
{
    // Prevent optimizations
    int i = rand();
}

static DWORD WINAPI
RemoteThreadFunc( THREADFNSTRUCT *pStruct )
{
    pStruct->pfnOutputDebugStringW( pStruct->wszMessage );

    if( FREE_LIBRARY == pStruct->eAction )
    {
        HINSTANCE hinst = NULL;

        hinst = pStruct->pfnGetModuleHandleW( pStruct->wsz );
        if( NULL == hinst )
            return( pStruct->pfnGetLastError() );

        if( !pStruct->pfnFreeLibrary( hinst ))
            return( pStruct->pfnGetLastError()  );
        else
            return( ERROR_SUCCESS );

    }
    else if( LOAD_LIBRARY == pStruct->eAction )
    {
        if( NULL == pStruct->pfnLoadLibraryW( pStruct->wsz ))
            return( pStruct->pfnGetLastError() );
        else
            return( ERROR_SUCCESS );
    }
    else if( DEBUG_BREAK == pStruct->eAction )
    {
        pStruct->pfnDebugBreak();
        return( ERROR_SUCCESS );
    }
    else if( CREATE_PROCESS == pStruct->eAction )
    {
        if( !pStruct->pfnCreateProcessW( NULL, pStruct->wsz,
                                         NULL, NULL,
                                         FALSE, NORMAL_PRIORITY_CLASS,
                                         NULL, NULL, NULL, NULL ))
        {
            return GetLastError();
        }
        else
            return ERROR_SUCCESS;
    }
    else
    {
        pStruct->pfnOutputDebugStringW( L"Invalid action to RemoteThreadFunc" );
        return ERROR_INVALID_PARAMETER;
    }

}

static void AfterThreadFunc (void)
{
    // Prevent optimziations
    int i = 2 * rand();
}

#pragma optimize ("", on )  // Restore to default
#pragma check_stack         // Restore to default
}

BOOL
RemoteProcessAction( HANDLE hProcess,
                     EProcessAction eAction,
                     const WCHAR *pwsz )
{
    int cbCodeSize = 0;
    const DWORD cbMemSize = cbCodeSize + sizeof(THREADFNSTRUCT) + 3;
    DWORD *pdwCodeRemote = NULL;
    THREADFNSTRUCT ThreadFnStruct;
    THREADFNSTRUCT *pRemoteThreadFnStruct = NULL;
    HANDLE hThread = NULL;
    DWORD dwThreadID = 0;
    BOOL fSuccess = FALSE;

    __try {

        // Determine the size of RemoteThreadFunc.  Assume the functions
        // either in order or in reverse order.

        if( (LPBYTE) AfterThreadFunc > (LPBYTE) RemoteThreadFunc )
            cbCodeSize = (int)( (LPBYTE) AfterThreadFunc - (LPBYTE) RemoteThreadFunc );
        else if( (LPBYTE) BeforeThreadFunc > (LPBYTE) RemoteThreadFunc )
            cbCodeSize = (int)( (LPBYTE) BeforeThreadFunc - (LPBYTE) RemoteThreadFunc );
        else
        {
            printf( "Can't determine size of code to inject (%p, %p, %p)\n",
                    BeforeThreadFunc, AfterThreadFunc, RemoteThreadFunc );
            __leave;
        }
            

        // Allocate memory in the remote process's address space large 
        // enough to hold our RemoteThreadFunc function and a THREADFNSTRUCT structure.

	pdwCodeRemote = (DWORD*) VirtualAllocEx( hProcess, NULL, cbMemSize,
                                                 MEM_COMMIT, PAGE_EXECUTE_READWRITE );

	if( NULL == pdwCodeRemote )
	{
            printf( "VirtualAllocEx failed: %d\n", GetLastError() );
	    __leave;
        }


	// Write a copy of RemoteThreadFunc to the remote process.
	if( !WriteProcessMemory( hProcess, pdwCodeRemote,
		                (LPVOID) RemoteThreadFunc,
                                cbCodeSize, NULL ))
        {
            printf( "WriteProcessMemory failed:  %d\n", GetLastError() );
            __leave;
        }


	// Write a copy of ThreadFnStruct to the remote process
	// (the structure MUST start on an even 32-bit bourdary).

	pRemoteThreadFnStruct = reinterpret_cast<THREADFNSTRUCT *>
                                ( (BYTE*)pdwCodeRemote + ((cbCodeSize + 4) & ~3) );


        memset( &ThreadFnStruct, 0, sizeof(ThreadFnStruct) );
        ThreadFnStruct.eAction = eAction;

        //wcscpy( ThreadFnStruct.wszMessage, L"*** Remote thread from dltadmin.exe ***\n" );


        if( LOAD_LIBRARY == eAction )
        {
            wcscpy( ThreadFnStruct.wsz, pwsz );
            wsprintf( ThreadFnStruct.wszMessage,
                      L"Received request from dltadmin to load \"%s\"\n",
                      pwsz );

            ThreadFnStruct.pfnLoadLibraryW = (PFNLoadLibrary)
                                             GetProcAddress( GetModuleHandle( L"kernel32.dll" ),
                                                             "LoadLibraryW" );
            if( NULL == ThreadFnStruct.pfnLoadLibraryW )
            {
                printf( "Couldn't load LoadLibraryW (%d)\n", GetLastError() );
                __leave;
            }
        }
        else if( FREE_LIBRARY == eAction )
        {
            wcscpy( ThreadFnStruct.wsz, pwsz );
            wsprintf( ThreadFnStruct.wszMessage,
                      L"Received request from dltadmin to free \"%s\"\n",
                      pwsz );
            ThreadFnStruct.pfnFreeLibrary = (PFNFreeLibrary)
                                            GetProcAddress( GetModuleHandleA("kernel32.dll"),
                                                            "FreeLibrary" );
            if( NULL == ThreadFnStruct.pfnFreeLibrary )
            {
                printf( "Couldn't load FreeLibrary (%d)\n", GetLastError() );
                __leave;
            }

            ThreadFnStruct.pfnGetModuleHandleW = (PFNGetModuleHandle)
                                                 GetProcAddress( GetModuleHandle(L"kernel32.dll"),
                                                 "GetModuleHandleW" );
            if( NULL == ThreadFnStruct.pfnFreeLibrary )
            {
                printf( "Couldn't load FreeLibrary (%d)\n", GetLastError() );
                __leave;
            }
        }
        else if( CREATE_PROCESS == eAction )
        {
            wcscpy( ThreadFnStruct.wsz, pwsz );
            wsprintf( ThreadFnStruct.wszMessage,
                      L"Received request from dltadmin to create \"%s\"\n",
                      pwsz );
            ThreadFnStruct.pfnCreateProcessW = (PFNCreateProcessW)
                                               GetProcAddress( GetModuleHandleA("kernel32.dll"),
                                                               "CreateProcessW" );
            if( NULL == ThreadFnStruct.pfnCreateProcessW )
            {
                printf( "Couldn't load CreateProcess (%d)\n", GetLastError() );
                __leave;
            }

        }
        else    // DEBUG_BREAK
        {
            wsprintf( ThreadFnStruct.wszMessage,
                      L"Received request from dltadmin to DebugBreak\n" );
            ThreadFnStruct.pfnDebugBreak = (PFNDebugBreak)
                                            GetProcAddress( GetModuleHandleA("kernel32.dll"),
                                                            "DebugBreak" );
            if( NULL == ThreadFnStruct.pfnDebugBreak )
            {
                printf( "Couldn't load DebugBreak (%d)\n", GetLastError() );
                __leave;
            }

        }

        ThreadFnStruct.pfnGetLastError = (PFNGetLastError)
                                         GetProcAddress( GetModuleHandle( L"kernel32.dll" ),
                                                         "GetLastError" );
        if( NULL == ThreadFnStruct.pfnGetLastError )
        {
            printf( "Couldn't load GetLastError (%d)\n", GetLastError() );
            __leave;
        }

        ThreadFnStruct.pfnOutputDebugStringW = (PFNOutputDebugStringW)
                                               GetProcAddress( GetModuleHandle( L"kernel32.dll" ),
                                                               "OutputDebugStringW" );
        if( NULL == ThreadFnStruct.pfnOutputDebugStringW )
        {
            printf( "Couldn't load OutputDebugStringW (%d)\n", GetLastError() );
            __leave;
        }

	// Write the struct into the remote thread's memory block.

	if( !WriteProcessMemory( hProcess, pRemoteThreadFnStruct,
		                 &ThreadFnStruct, sizeof(THREADFNSTRUCT), NULL ))
        {
            printf( "Couldn't write ThreadFnStruct to remote thread: %d\n", GetLastError() );
            __leave;
        }


	hThread = CreateRemoteThread( hProcess, NULL, 0,
                                      (LPTHREAD_START_ROUTINE) pdwCodeRemote,
		                      pRemoteThreadFnStruct, 0, &dwThreadID );
	if( NULL == hThread )
	{
            printf( "Couldn't create remote thread: %d\n", GetLastError() );
            __leave;
	}

        DWORD dwWait = WaitForSingleObject( hThread, INFINITE );
        if( WAIT_OBJECT_0 != dwWait )
            printf( "Wait failed: %d, %d\n", dwWait, GetLastError() );

    }	// __try
    __finally
    {

        if( NULL != hThread )
        {
            DWORD dwError;

            if( !AbnormalTermination() )
            {
                if( !GetExitCodeThread( hThread, &dwError ))
                    printf( "Couldn't get remote thread exit code: %d\n", GetLastError() );
                else if( ERROR_MOD_NOT_FOUND == dwError )
                {
                    if( LOAD_LIBRARY == eAction )
                        wprintf( L"DLL \"%s\" not found\n", pwsz );
                    else if( FREE_LIBRARY == eAction )
                        wprintf( L"DLL \"%s\" not already loaded\n", pwsz );
                }
                else if( ERROR_SUCCESS != dwError )
                    printf( "Failed: 0x%x\n", dwError );
                else
                    fSuccess = TRUE;
            }

            CloseHandle(hThread);
        }
        
        if( NULL != pdwCodeRemote )
        {
            if( !VirtualFreeEx( hProcess, pdwCodeRemote, 0, MEM_RELEASE ))
                printf( "Couldn't free remote memory: 0x%x\n", GetLastError() );
        }

    }   // __finally

    if( fSuccess )
        printf( "Succeeded\n" );
    return( fSuccess );

}



BOOL
DltAdminProcessAction( EProcessAction eAction, ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    BOOL fSuccess = FALSE;

    *pcEaten = 0;

    if( 0 == cArgs
        ||
        1 <= cArgs && IsHelpArgument(rgptszArgs[0]) )
    {
        *pcEaten = 1;

        if( LOAD_LIBRARY == eAction )
        {
            printf( "\nOption LoadLib\n"
                      "   Purpose: Load a dll into a process with LoadLibrary\n"
                      "   Usage:   -LoadLib -p <process ID> <library name>\n"
                      "   E.g.:    -LoadLib -p 182 shell32.dll\n" );
        }
        else if( FREE_LIBRARY == eAction )
        {
            printf( "\nOption FreeLib\n"
                      "   Purpose: Unload a dll from a process with FreeLibrary\n"
                      "   Usage:   -FreeLib -p <process ID> <library name>\n"
                      "   E.g.:    -FreeLib -p 182 shell32.dll\n" );
        }
        else
        {
            printf( "\nOption DebugBreak\n"
                      "   Purpose: Execute DebugBreak within a process\n"
                      "   Usage:   -DebugBreak -p <process ID>\n"
                      "   E.g.:    -DebugBreak -p 182\n" );
        }
        return( TRUE );
    }

    ULONG iArgs = 0;

    if( 2 > cArgs
        ||
        TEXT('-') != rgptszArgs[0][0]
        &&
        TEXT('/') != rgptszArgs[0][0]
        ||
        TEXT('P') != rgptszArgs[0][1]
        &&
        TEXT('p') != rgptszArgs[0][1] )

    {
        printf( "Argument error.  Use -? for usage info.\n" );
        return( FALSE );
    }

    HANDLE hProcess = NULL;
    __try
    {
        DWORD dwProcessID = 0;

        _stscanf( rgptszArgs[1], TEXT("%d"), &dwProcessID );
        if( 0 == dwProcessID )
        {
            printf( "Failed to open system process\n" );
            __leave;
        }

        EnablePrivilege(SE_DEBUG_NAME);
        hProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, dwProcessID );
        if( NULL == hProcess )
        {
            printf( "Failed to open process %d (%lu)\n", dwProcessID, GetLastError() );
            __leave;
        }

        if( RemoteProcessAction( hProcess, eAction,
                                 DEBUG_BREAK == eAction ? NULL : rgptszArgs[2] ))
            fSuccess = TRUE;

        if( DEBUG_BREAK == eAction )
            *pcEaten = 2;
        else
            *pcEaten = 3;

    }
    __finally
    {
        if( NULL != hProcess )
            CloseHandle( hProcess );
    }

    return( fSuccess );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\dltadmin\stubs.cxx ===
//+============================================================================
//
//	Stubs to allow the link to succeeded.  None are used.
//
//+============================================================================

#include <pch.cxx>
#pragma hdrstop
#include "trkwks.hxx"



HRESULT StubLnkSearchMachine(RPC_BINDING_HANDLE          IDL_handle,
                             ULONG                       RestrictionsIn,
                             const CDomainRelativeObjId *pdroidBirthLast,
                             const CDomainRelativeObjId *pdroidLast,
                             CDomainRelativeObjId       *pdroidBirthNext,
                             CDomainRelativeObjId       *pdroidNext,
                             CMachineId                 *pmcidNext,
                             TCHAR                      *ptsz )
{
    return E_FAIL;
}

HRESULT StubLnkCallSvrMessage( 
    /* [in] */ handle_t IDL_handle,
    /* [switch_is][out][in] */ TRKSVR_MESSAGE_UNION __RPC_FAR *pMsg)
{
    return E_FAIL;
}

void
StubLnkMendLink(PRPC_ASYNC_STATE            pAsync_handle,
                RPC_BINDING_HANDLE          IDL_handle,
                FILETIME                    ftLimit,
                DWORD                       RestrictionsIn,
                const CDomainRelativeObjId *pdroidBirth,
                const CDomainRelativeObjId *pdroidLast,
                const CMachineId *          pmcidLast,
                CDomainRelativeObjId *      pdroidCurrent,
                CMachineId *                pmcidCurrent,
                ULONG *                     pcbPath,
                WCHAR *                     wsz)
{
    return;
}


HRESULT Stubold2_LnkSearchMachine(  RPC_BINDING_HANDLE           IDL_handle,
                                    ULONG                        RestrictionsIn,
                                    const CDomainRelativeObjId  *pdroidLast,
                                    CDomainRelativeObjId        *pdroidNext,
                                    CMachineId                  *pmcidNext,
                                    TCHAR                       *tsz )
{
    return E_FAIL;
}


HRESULT StubLnkOnRestore(/*[in]*/ RPC_BINDING_HANDLE IDL_handle)
{
    return E_FAIL;
}

HRESULT
StubTriggerVolumeClaims(          RPC_BINDING_HANDLE IDL_handle,
                         /*[in]*/ ULONG cVolumes,
                         /*[in]*/ const CVolumeId *rgvolid )
{
    return E_FAIL;
}

HRESULT
StubGetFileTrackingInformation( RPC_BINDING_HANDLE IDL_handle,
                                /*[in]*/ CDomainRelativeObjId droidCurrent,
                                /*[in]*/ TrkInfoScope scope,
                                /*[out]*/ TRK_FILE_TRACKING_INFORMATION_PIPE pipeFileInfo )
{
    return E_FAIL;
}

HRESULT
StubGetVolumeTrackingInformation( RPC_BINDING_HANDLE IDL_handle,
                                  /*[in]*/ CVolumeId volid,
                                  /*[in]*/ TrkInfoScope scope,
                                  /*[out]*/ TRK_VOLUME_TRACKING_INFORMATION_PIPE pipeVolInfo )
{
    return( E_NOTIMPL );
}

HRESULT StubLnkSetVolumeId( 
    handle_t IDL_handle,
    ULONG iVolume,
    const CVolumeId VolId)
{
    return( E_NOTIMPL );
}



HRESULT StubLnkRestartDcSynchronization(
    RPC_BINDING_HANDLE IDL_handle
    )
{
    return(E_NOTIMPL);
}

HRESULT Stubold_LnkSearchMachine(
    /* [in] */ handle_t IDL_handle,
    /* [in] */ ULONG Restrictions,
    /* [in] */ const CDomainRelativeObjId __RPC_FAR *pdroidLast,
    /* [out] */ CDomainRelativeObjId __RPC_FAR *pdroidReferral,
    /* [string][out] */ TCHAR __RPC_FAR tsz[ MAX_PATH + 1 ])
{
    return E_NOTIMPL;
}


HRESULT Stubold_LnkCallSvrMessage(
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ TRKSVR_MESSAGE_UNION_OLD __RPC_FAR *pMsg)
{
    return E_NOTIMPL;
}

HRESULT Stubold_LnkMendLink(
    /* [in] */ handle_t IDL_handle,
    /* [in] */ FILETIME ftLimit,
    /* [in] */ ULONG Restrictions,
    /* [in] */ const CDomainRelativeObjId __RPC_FAR *pdroidBirth,
    /* [in] */ const CDomainRelativeObjId __RPC_FAR *pdroidLast,
    /* [out] */ CDomainRelativeObjId __RPC_FAR *pdroidCurrent,
    /* [string][out] */ WCHAR __RPC_FAR wsz[ MAX_PATH + 1 ] )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\dltadmin\refresh.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>
#include "trkwks.hxx"
#include "dltadmin.hxx"




BOOL
DltAdminRefresh( ULONG cArgs, TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    HRESULT hr = E_FAIL;
    RPC_STATUS  rpcstatus;
    RPC_TCHAR * ptszStringBinding;
    RPC_BINDING_HANDLE hBinding = NULL;
    BOOL fBound = FALSE;
    TRKSVR_MESSAGE_UNION Msg;

    if( 1 <= cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        printf("\nOption  Refresh\n"
                " Purpose: Tell the tracking service to update volume list\n"
                " Usage:   -refresh\n" );
        return( TRUE );
    }


    rpcstatus = RpcStringBindingCompose( NULL, TEXT("ncalrpc"), NULL, TEXT("trkwks"),
                                         NULL, &ptszStringBinding);

    if( rpcstatus )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcStringBindingCompose %lu"), rpcstatus ));
        hr = HRESULT_FROM_WIN32(rpcstatus);
        goto Exit;
    }

    rpcstatus = RpcBindingFromStringBinding( ptszStringBinding, &hBinding );
    RpcStringFree( &ptszStringBinding );

    if( rpcstatus )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcBindingFromStringBinding") ));
        hr = HRESULT_FROM_WIN32(rpcstatus);
        goto Exit;
    }
    fBound = TRUE;

    memset( &Msg, 0, sizeof(Msg) );
    Msg.MessageType = WKS_VOLUME_REFRESH;
    Msg.Priority = PRI_0;

    __try
    {
        hr = LnkCallSvrMessage( hBinding, &Msg);
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = HRESULT_FROM_WIN32( GetExceptionCode() );
    }

    if( FAILED(hr) )
    {
        _tprintf( TEXT("Failed call to service (%08x)\n"), hr );
        goto Exit;
    }


Exit:

    if( fBound )
        RpcBindingFree( &hBinding );

    return( TRUE );

}   // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\itrkadmn\frcown.cpp ===
// FrcOwn.cpp : Implementation of CForceOwnership

#include "pch.cxx"
#pragma hdrstop

#define TRKDATA_ALLOCATE
#include <trklib.hxx>
#include <trksvr.hxx>
#undef TRKDATA_ALLOCATE

#include "stdafx.h"
#include "ITrkAdmn.h"
#include "FrcOwn.h"




STDMETHODIMP
CTrkForceOwnership::Volumes(BSTR bstrUncPath, long scope )
{

    HRESULT hr = S_OK;
    HANDLE hFile = NULL;
    CVolumeId volid;

    CMachineId mcid( (LPWSTR) bstrUncPath );
    CRpcClientBinding rc;

    CPCVolumes cpcVolumes( &mcid, &_voltab, &_refreshSequenceStorage );
    TRpcPipeControl< TRK_VOLUME_TRACKING_INFORMATION_PIPE,
                     TRK_VOLUME_TRACKING_INFORMATION,
                     CPCVolumes
                   > cpipeVolumes( &cpcVolumes );

    rc.Initialize( mcid );

    if( TRKINFOSCOPE_VOLUME == scope )
    {
        NTSTATUS status;
        IO_STATUS_BLOCK Iosb;
        FILE_FS_OBJECTID_INFORMATION fsobOID;

        status = TrkCreateFile( bstrUncPath, SYNCHRONIZE | FILE_READ_ATTRIBUTES, FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN,
                                FILE_OPEN_NO_RECALL, NULL, &hFile );
        if( !NT_SUCCESS(status) )
        {
            hFile = NULL;
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't open volume %s"), bstrUncPath ));
            TrkRaiseNtStatus( status );
        }

        status = NtQueryVolumeInformationFile( hFile, &Iosb, &fsobOID, sizeof(fsobOID),
                                               FileFsObjectIdInformation );

        if( STATUS_OBJECT_NAME_NOT_FOUND == status )
        {
            TRK_VOLUME_TRACKING_INFORMATION volinfo;

            volinfo.volindex = -1;
            cpcVolumes.Push( &volinfo, 1 );
            hr = S_OK;
            goto Exit;
        }
        else if( !NT_SUCCESS(status) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Failed NtQueryVolumeInformationFile (%s)"), bstrUncPath ));
            TrkRaiseNtStatus( status );
        }

        volid.Load( &volid, fsobOID );

        NtClose( hFile );
        hFile = NULL;
    }
    else if( TRKINFOSCOPE_MACHINE != scope )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Bad scope to CTrkForceOwnership::VolumeStatus (%l)"), scope ));
        TrkRaiseWin32Error( ERROR_INVALID_PARAMETER );
    }


    RpcTryExcept
    {
        hr = GetVolumeTrackingInformation( rc, volid, static_cast<TrkInfoScope>(scope), cpipeVolumes );
        if( SUCCEEDED(hr) && SUCCEEDED(cpcVolumes.GetHResult()) )
            hr = TriggerVolumeClaims( rc, cpcVolumes.Count(), cpcVolumes.GetVolIds() );
    }
    RpcExcept( BreakOnDebuggableException() )
    {
        hr = RpcExceptionCode();
    }
    RpcEndExcept;

Exit:

    if( NULL != hFile )
        NtClose( hFile );

    return( hr );
}



STDMETHODIMP
CTrkForceOwnership::Files(BSTR bstrUncPath, long scope)
{
    HRESULT hr = E_FAIL;
    HANDLE hFile = NULL;

    CPCFiles cpcFiles( &_idt );
    TRpcPipeControl< TRK_FILE_TRACKING_INFORMATION_PIPE,
                     TRK_FILE_TRACKING_INFORMATION,
                     CPCFiles
                   > cpipeFiles( &cpcFiles);

    CMachineId mcid( (LPWSTR) bstrUncPath );
    CRpcClientBinding rc;

    __try
    {
        NTSTATUS status;
        CDomainRelativeObjId droidCurrent, droidBirth;

        if( TRKINFOSCOPE_ONE_FILE == scope )
        {

            // BUGBUG P2:  Optimize this; we don't need droidBirth
            status = GetDroids( bstrUncPath, &droidCurrent, &droidBirth, RGO_READ_OBJECTID );

            if( STATUS_OBJECT_NAME_NOT_FOUND == status )
            {
                TRK_FILE_TRACKING_INFORMATION fileinfo;

                _tcscpy( fileinfo.tszFilePath, TEXT("") );
                fileinfo.hr = HRESULT_FROM_NT( status );

                cpcFiles.Push( &fileinfo, 1 );
                hr = S_OK;
                goto Exit;
            }
            else if( !NT_SUCCESS(status) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed GetDroids (%s)"), bstrUncPath ));
                TrkRaiseNtStatus( status );
            }
        }
        else if( TRKINFOSCOPE_VOLUME == scope )
        {
            NTSTATUS status;
            IO_STATUS_BLOCK Iosb;
            FILE_FS_OBJECTID_INFORMATION fsobOID;
            CVolumeId volid;

            status = TrkCreateFile( bstrUncPath, SYNCHRONIZE | FILE_READ_ATTRIBUTES, FILE_ATTRIBUTE_NORMAL,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN,
                                    FILE_OPEN_NO_RECALL, NULL, &hFile );
            if( !NT_SUCCESS(status) )
            {
                hFile = NULL;
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't open volume %s"), bstrUncPath ));
                TrkRaiseNtStatus( status );
            }

            status = NtQueryVolumeInformationFile( hFile, &Iosb, &fsobOID, sizeof(fsobOID),
                                                   FileFsObjectIdInformation );

            if( STATUS_OBJECT_NAME_NOT_FOUND == status )
            {
                TRK_FILE_TRACKING_INFORMATION fileinfo;

                _tcscpy( fileinfo.tszFilePath, TEXT("") );
                fileinfo.hr = HRESULT_FROM_NT( status );

                cpcFiles.Push( &fileinfo, 1 );
                hr = S_OK;
                goto Exit;
            }
            else if( !NT_SUCCESS(status) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed NtQueryVolumeInformationFile (%s)"), bstrUncPath ));
                TrkRaiseNtStatus( status );
            }
            volid.Load( &volid, fsobOID );
            droidCurrent = CDomainRelativeObjId( volid, CObjId() );

            NtClose( hFile );
            hFile = NULL;
        }
        else if( TRKINFOSCOPE_MACHINE != scope )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Bad scope to CTrkForceOwnership::FileStatus (%d)"), scope ));
            TrkRaiseWin32Error( ERROR_INVALID_PARAMETER );
        }
    
        rc.Initialize( mcid );

        RpcTryExcept
        {
            hr = GetFileTrackingInformation( rc, droidCurrent, static_cast<TrkInfoScope>(scope), cpipeFiles );
        }
        RpcExcept( BreakOnDebuggableException() )
        {
            hr = HRESULT_FROM_WIN32( RpcExceptionCode() );
        }
        RpcEndExcept;
        if( FAILED(hr) ) goto Exit;
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }


Exit:

    if( NULL != hFile )
        NtClose( hFile );

    return( hr );
}

STDMETHODIMP
CTrkForceOwnership::VolumeStatus(BSTR bstrUncPath, long scope,
                                 VARIANT *pvarlongVolIndex, VARIANT *pvarbstrVolId, VARIANT *pvarlongStatus)
{
    HRESULT hr = E_FAIL;
    HANDLE hFile = NULL;
    SAFEARRAYBOUND sabound;
    CVolumeId volid;

    // Determine the machine ID
    CMachineId mcid( (LPWSTR) bstrUncPath );
    CRpcClientBinding rc;

    // This is used by the RPC server to pull the bstrUncPath
    CPCPath cpcPath( bstrUncPath );
    TRpcPipeControl< TCHAR_PIPE, TCHAR, CPCPath> cpipePath( &cpcPath );

    // This is used by the RPC server to push the volume information
    CPCVolumeStatus cpcVolumeStatus( &_voltab );
    TRpcPipeControl< TRK_VOLUME_TRACKING_INFORMATION_PIPE, TRK_VOLUME_TRACKING_INFORMATION, CPCVolumeStatus
                   > cpipeVolumeStatus( &cpcVolumeStatus );


    __try
    {
        NTSTATUS status;

        // Initialize the outputs
        VariantInit( pvarlongVolIndex );
        VariantInit( pvarbstrVolId );
        VariantInit( pvarlongStatus );

        // Initialize the pipe callback
        cpcVolumeStatus.Initialize( &mcid, pvarlongVolIndex, pvarbstrVolId, pvarlongStatus );

        // Connect to the workstation in question
        rc.Initialize( mcid );

        if( TRKINFOSCOPE_VOLUME == scope )
        {
            IO_STATUS_BLOCK Iosb;
            FILE_FS_OBJECTID_INFORMATION fsobOID;

            status = TrkCreateFile( bstrUncPath, SYNCHRONIZE | FILE_READ_ATTRIBUTES, FILE_ATTRIBUTE_NORMAL,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN,
                                    FILE_OPEN_NO_RECALL, NULL, &hFile );
            if( !NT_SUCCESS(status) )
            {
                hFile = NULL;
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't open volume %s"), bstrUncPath ));
                TrkRaiseNtStatus( status );
            }

            status = NtQueryVolumeInformationFile( hFile, &Iosb, &fsobOID, sizeof(fsobOID),
                                                   FileFsObjectIdInformation );

            if( STATUS_OBJECT_NAME_NOT_FOUND == status )
            {
                TRK_VOLUME_TRACKING_INFORMATION volinfo;

                volinfo.volindex = -1;
                cpcVolumeStatus.Push( &volinfo, 1 );
                hr = S_OK;
                goto Exit;
            }
            else if( !NT_SUCCESS(status) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed NtQueryVolumeInformationFile (%s)"), bstrUncPath ));
                TrkRaiseNtStatus( status );
            }
            volid.Load( &volid, fsobOID );

            NtClose( hFile );
            hFile = NULL;
        }
        else if( TRKINFOSCOPE_MACHINE != scope )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Bad scope to CTrkForceOwnership::VolumeStatus (%l)"), scope ));
            TrkRaiseWin32Error( ERROR_INVALID_PARAMETER );
        }


        RpcTryExcept
        {
            hr = GetVolumeTrackingInformation( rc, volid, static_cast<TrkInfoScope>(scope), cpipeVolumeStatus );
        }
        RpcExcept( BreakOnDebuggableException() )
        {
            hr = HRESULT_FROM_WIN32( RpcExceptionCode() );
        }
        RpcEndExcept;

        if( FAILED(hr) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Failed call to GetVolumeTrackInformation")));
            TrkRaiseException( hr );
        }

        if( FAILED(cpcVolumeStatus.GetHResult()) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Failed in VolumeStatus pipe callback")));
            TrkRaiseException( cpcVolumeStatus.GetHResult() );
        }

        // Truncate the safearrays
        cpcVolumeStatus.Compact();

    }
    __except( BreakOnDebuggableException() )
    {
        cpcVolumeStatus.UnInitialize();
        hr = GetExceptionCode();
    }

Exit:

    if( FAILED(hr) )
    {
        VariantClear( pvarlongVolIndex );
        VariantClear( pvarbstrVolId );
        VariantClear( pvarlongStatus );
    }

    if( NULL != hFile )
        NtClose( hFile );

    return( hr );
}


void
CPCVolumeStatus::Initialize( CMachineId *pmcid, VARIANT *pvarlongVolIndex, VARIANT *pvarbstrVolId, VARIANT *pvarlongStatus )
{
    _pmcid = pmcid;
    _pvarlongVolIndex = pvarlongVolIndex;
    _pvarbstrVolId = pvarbstrVolId;
    _pvarlongStatus = pvarlongStatus;

    _iArrays = 0;
    _hr = S_OK;
    _sabound.lLbound = 0;
    _sabound.cElements = NUM_VOLUMES;

    _fInitialized = TRUE;

    _pvarlongVolIndex->parray = SafeArrayCreate( VT_I4, 1, &_sabound );
    if( NULL == _pvarlongVolIndex->parray )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayCreate")));
        TrkRaiseWin32Error( E_OUTOFMEMORY );
    }
    _pvarlongVolIndex->vt = VT_I4 | VT_ARRAY;

    _pvarbstrVolId->parray = SafeArrayCreate( VT_BSTR, 1, &_sabound );
    if( NULL == _pvarbstrVolId->parray )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayCreate")));
        TrkRaiseWin32Error( E_OUTOFMEMORY );
    }
    _pvarbstrVolId->vt = VT_BSTR | VT_ARRAY;

    _pvarlongStatus->parray = SafeArrayCreate( VT_I4, 1, &_sabound );
    if( NULL == _pvarlongStatus->parray )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayCreate")));
        TrkRaiseWin32Error( E_OUTOFMEMORY );
    }
    _pvarlongStatus->vt = VT_I4 | VT_ARRAY;

}

void
CPCVolumeStatus::UnInitialize()
{
    // Nothing to do, the Variants are cleaned by the caller
    return;
}


void
CPCVolumeStatus::Push( TRK_VOLUME_TRACKING_INFORMATION *pVolInfo, unsigned long cElems )
{
    TrkLog(( TRKDBG_ADMIN, TEXT("CPCVolumeStatus received %d elements"), cElems ));

    HRESULT hr = S_OK;
    HRESULT hrGet;
    ULONG iElem = 0;
    BSTR bstrVolId = NULL;

    __try
    {
        for( iElem = 0; iElem < cElems; iElem++ )
        {
            CMachineId mcidCheck;
            CVolumeSecret volsecCheck;
            SequenceNumber seqCheck;
            CVolumeId volNULL;

            TCHAR tszVolId[ 40 ];
            TCHAR *ptszVolId = tszVolId;

            long VolOwnership = OBJOWN_UNKNOWN;

            if( pVolInfo[iElem].volume != volNULL )
                hrGet = _pvoltab->GetVolumeInfo( pVolInfo[iElem].volume, &mcidCheck, &volsecCheck, &seqCheck );

            if( _iArrays >= static_cast<LONG>(_sabound.cElements) )
            {
                TrkAssert( !TEXT("Not yet implemented") );
                // BUGBUG: do a SafeArrayReDim
                return;
            }


            TrkAssert( sizeof(long) == sizeof(pVolInfo[iElem].volindex) );
            hr = SafeArrayPutElement( _pvarlongVolIndex->parray, &_iArrays, &pVolInfo[iElem].volindex );
            if( FAILED(hr) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayPutElement")));
                TrkRaiseException( hr );
            }

            // BUGBUG:  Add a Serialize(BSTR) method to CVolumeId
            pVolInfo[iElem].volume.Stringize( ptszVolId );

            bstrVolId = SysAllocString( tszVolId );
            if( NULL == bstrVolId )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed SysAllocString")));
                TrkRaiseWin32Error( E_OUTOFMEMORY );
            }

            hr = SafeArrayPutElement( _pvarbstrVolId->parray, &_iArrays, bstrVolId );
            if( FAILED(hr) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayPutElement")));
                TrkRaiseException( hr );
            }

            if( S_OK != hrGet )
            {
                VolOwnership = OBJOWN_DOESNT_EXIST;
            }
            else if( mcidCheck == *_pmcid )
            {
                VolOwnership = OBJOWN_OWNED;
            }
            else if( volNULL == pVolInfo[iElem].volume )
            {
                VolOwnership = OBJOWN_NO_ID;
            }
            else
            {
                VolOwnership = OBJOWN_NOT_OWNED;
            }

            hr = SafeArrayPutElement( _pvarlongStatus->parray, &_iArrays, &VolOwnership );
            if( FAILED(hr) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayPutElemnt")));
                TrkRaiseException( hr );
            }

            SysFreeString( bstrVolId ); bstrVolId = NULL;
            _iArrays++;
        }

    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }


Exit:

    if( FAILED(hr) )
    {
        if( NULL != bstrVolId )
            SysFreeString( bstrVolId );

        if( !FAILED(_hr) )
            _hr = hr;
    }

    return;
}


void
CPCVolumeStatus::Compact()
{
    HRESULT hr = S_OK;

    _sabound.cElements = _iArrays;

    hr = SafeArrayRedim( _pvarlongVolIndex->parray, &_sabound );
    if( FAILED(hr) )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't redim safearray")));
        TrkRaiseException( hr );
    }

    hr = SafeArrayRedim( _pvarbstrVolId->parray, &_sabound );
    if( FAILED(hr) )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't redim safearray")));
        TrkRaiseException( hr );
    }

    hr = SafeArrayRedim( _pvarlongStatus->parray, &_sabound );
    if( FAILED(hr) )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't redim safearray")));
        TrkRaiseException( hr );
    }
}


void
CPCVolumes::Push( TRK_VOLUME_TRACKING_INFORMATION *pVolInfo, unsigned long cElems )
{
    TrkLog(( TRKDBG_ADMIN, TEXT("CPCVolumeStatus received %d elements"), cElems ));

    HRESULT hr = S_OK;
    ULONG iElem = 0;

    __try
    {
        for( iElem = 0; iElem < cElems; iElem++ )
        {

            hr = _pvoltab->SetMachine( pVolInfo[iElem].volume, *_pmcid );
            if( TRK_S_VOLUME_NOT_FOUND == hr )
                _pvoltab->CreateVolume(
                    pVolInfo[iElem].volume,
                    *_pmcid,
                    CVolumeSecret(),
                    _pRefreshSequenceStorage->GetSequenceNumber() );

            // BUGBUG P1:  Handle this error
            TrkAssert( SUCCEEDED(hr) );

            _rgvolid[ _cVolIds++ ] = pVolInfo[iElem].volume;
            
        }
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }


    if( FAILED(hr) )
    {
        if( !FAILED(_hr) )
            _hr = hr;
    }

    return;
}

void
CPCFiles::Push( TRK_FILE_TRACKING_INFORMATION *pFileInfo, unsigned long cElems )
{
    ULONG iFile;

    __try
    {
        // BUGBUG P2:  Instead of a loop, batch these up
        for( iFile = 0; iFile < cElems; iFile++ )
        {
            _pidt->Delete( pFileInfo[iFile].droidBirth );

            TrkVerify( _pidt->Add( pFileInfo[iFile].droidBirth, pFileInfo[iFile].droidLast,
                       pFileInfo[iFile].droidBirth ));
        }
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("CPCFiles::Push had an exception (%08x)"), GetExceptionCode() ));
    }

    
}


void
CPCFileStatus::Push( TRK_FILE_TRACKING_INFORMATION *pFileInfo, unsigned long cElems )
{
    TrkLog(( TRKDBG_ADMIN, TEXT("CPCFileStatus received %d elements"), cElems ));

    HRESULT hr = S_OK;
    ULONG iElem = 0;
    BSTR bstr = NULL;

    __try
    {
        for( iElem = 0; iElem < cElems; iElem++ )
        {
            BOOL fExistsInTable = FALSE;
            BOOL fAtBirthplace = FALSE;

            CDomainRelativeObjId droidBirthCheck;
            CDomainRelativeObjId droidNowCheck;
            const CDomainRelativeObjId droidNULL;
            TCHAR tszDroid[ MAX_PATH ];
            long FileOwnership;

            if( droidNULL == pFileInfo[iElem].droidBirth
                ||
                pFileInfo[iElem].droidBirth == pFileInfo[iElem].droidLast )
            {
                fAtBirthplace = TRUE;
            }
            else
            {
                fExistsInTable = _pidt->Query( pFileInfo[iElem].droidBirth, &droidNowCheck, &droidBirthCheck );
            }

            if( _iArrays >= static_cast<LONG>(_sabound.cElements) )
            {
                TrkAssert( !TEXT("Not yet impelemented") );
                // BUGBUG: do a SafeArrayReDim
                return;
            }

            bstr = SysAllocString( pFileInfo[iElem].tszFilePath );
            if( NULL == bstr )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed SysAllocString")));
                TrkRaiseWin32Error( E_OUTOFMEMORY );
            }

            hr = SafeArrayPutElement( _pvarrgbstrFileName->parray, &_iArrays, bstr );
            if( FAILED(hr) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayPutElement")));
                TrkRaiseException( hr );
            }
            SysFreeString( bstr ); bstr = NULL;

            // BUGBUG:  Add a Serialize(BSTR) method to CDroid
            pFileInfo[iElem].droidBirth.Stringize( tszDroid, sizeof(tszDroid) );
            bstr = SysAllocString( tszDroid );
            if( NULL == bstr )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed SysAllocString")));
                TrkRaiseWin32Error( E_OUTOFMEMORY );
            }

            hr = SafeArrayPutElement( _pvarrgbstrFileId->parray, &_iArrays, bstr );
            if( FAILED(hr) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayPutElement")));
                TrkRaiseException( hr );
            }

            if( fAtBirthplace )
                FileOwnership = OBJOWN_OWNED;

            else if( !fExistsInTable )
                FileOwnership = OBJOWN_DOESNT_EXIST;

            else if( droidNowCheck == pFileInfo[iElem].droidLast
                     &&
                     droidBirthCheck == pFileInfo[iElem].droidBirth )
                FileOwnership = OBJOWN_OWNED;

            else
                FileOwnership = OBJOWN_NOT_OWNED;


            hr = SafeArrayPutElement( _pvarrglongStatus->parray, &_iArrays, &FileOwnership );
            if( FAILED(hr) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayPutElemnt")));
                TrkRaiseException( hr );
            }

            _iArrays++;
        }

    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }


Exit:

    if( FAILED(hr) )
    {
        if( NULL != bstr )
            SysFreeString( bstr );

        if( !FAILED(_hr) )
            _hr = hr;
    }

    return;
}



void
CPCFileStatus::Initialize( CMachineId *pmcid, VARIANT *pvarrgbstrFileName,
                           VARIANT *pvarrgbstrFileId, VARIANT *pvarrglongStatus )
{
    _pmcid = pmcid;
    _pvarrgbstrFileName = pvarrgbstrFileName;
    _pvarrgbstrFileId = pvarrgbstrFileId;
    _pvarrglongStatus = pvarrglongStatus;

    _iArrays = 0;
    _hr = S_OK;
    _sabound.lLbound = 0;
    _sabound.cElements = 10;

    _fInitialized = TRUE;

    _pvarrgbstrFileName->parray = SafeArrayCreate( VT_BSTR, 1, &_sabound );
    if( NULL == _pvarrgbstrFileName->parray )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayCreate")));
        TrkRaiseWin32Error( E_OUTOFMEMORY );
    }
    _pvarrgbstrFileName->vt = VT_BSTR | VT_ARRAY;

    _pvarrgbstrFileId->parray = SafeArrayCreate( VT_BSTR, 1, &_sabound );
    if( NULL == _pvarrgbstrFileId->parray )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayCreate")));
        TrkRaiseWin32Error( E_OUTOFMEMORY );
    }
    _pvarrgbstrFileId->vt = VT_BSTR | VT_ARRAY;

    _pvarrglongStatus->parray = SafeArrayCreate( VT_I4, 1, &_sabound );
    if( NULL == _pvarrglongStatus->parray )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Failed SafeArrayCreate")));
        TrkRaiseWin32Error( E_OUTOFMEMORY );
    }
    _pvarrglongStatus->vt = VT_I4 | VT_ARRAY;


}   // CPCFileStatus::Initialize



void
CPCFileStatus::Compact()
{
    HRESULT hr = S_OK;

    _sabound.cElements = _iArrays;

    hr = SafeArrayRedim( _pvarrgbstrFileName->parray, &_sabound );
    if( FAILED(hr) )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't redim safearray")));
        TrkRaiseException( hr );
    }

    hr = SafeArrayRedim( _pvarrgbstrFileId->parray, &_sabound );
    if( FAILED(hr) )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't redim safearray")));
        TrkRaiseException( hr );
    }

    hr = SafeArrayRedim( _pvarrglongStatus->parray, &_sabound );
    if( FAILED(hr) )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't redim safearray")));
        TrkRaiseException( hr );
    }
}



STDMETHODIMP CTrkForceOwnership::FileStatus(BSTR bstrUncPath, long scope,
                                            VARIANT * pvarrgbstrFileName, VARIANT *pvarrgbstrFileId, VARIANT * pvarrglongStatus)
{
    HRESULT hr = E_FAIL;
    SAFEARRAYBOUND sabound;
    HANDLE hFile = NULL;

    // Determine the machine ID
    CMachineId mcid( (LPWSTR) bstrUncPath );
    CRpcClientBinding rc;

    // This is used by the RPC server to push the volume information
    CPCFileStatus cpcFileStatus( &_idt );
    TRpcPipeControl< TRK_FILE_TRACKING_INFORMATION_PIPE, TRK_FILE_TRACKING_INFORMATION, CPCFileStatus
                   > cpipeFileStatus( &cpcFileStatus );


    __try
    {
        NTSTATUS status;

        // Initialize the outputs
        VariantInit( pvarrgbstrFileName );
        VariantInit( pvarrgbstrFileId );
        VariantInit( pvarrglongStatus );

        CDomainRelativeObjId droidCurrent, droidBirth;

        // Initialize the pipe callback
        cpcFileStatus.Initialize( &mcid, pvarrgbstrFileName, pvarrgbstrFileId, pvarrglongStatus );

        if( TRKINFOSCOPE_ONE_FILE == scope )
        {

            // BUGBUG P2:  Optimize this; we don't need droidBirth
            status = GetDroids( bstrUncPath, &droidCurrent, &droidBirth, RGO_READ_OBJECTID );

            if( STATUS_OBJECT_NAME_NOT_FOUND == status )
            {
                TRK_FILE_TRACKING_INFORMATION fileinfo;

                _tcscpy( fileinfo.tszFilePath, TEXT("") );
                fileinfo.hr = HRESULT_FROM_NT( status );

                cpcFileStatus.Push( &fileinfo, 1 );
                hr = S_OK;
                goto Exit;
            }
            else if( !NT_SUCCESS(status) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed GetDroids (%s)"), bstrUncPath ));
                TrkRaiseNtStatus( status );
            }
        }
        else if( TRKINFOSCOPE_VOLUME == scope )
        {
            NTSTATUS status;
            IO_STATUS_BLOCK Iosb;
            FILE_FS_OBJECTID_INFORMATION fsobOID;
            CVolumeId volid;

            status = TrkCreateFile( bstrUncPath, SYNCHRONIZE | FILE_READ_ATTRIBUTES, FILE_ATTRIBUTE_NORMAL,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN,
                                    FILE_OPEN_NO_RECALL, NULL, &hFile );
            if( !NT_SUCCESS(status) )
            {
                hFile = NULL;
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't open volume %s"), bstrUncPath ));
                TrkRaiseNtStatus( status );
            }

            status = NtQueryVolumeInformationFile( hFile, &Iosb, &fsobOID, sizeof(fsobOID),
                                                   FileFsObjectIdInformation );

            if( STATUS_OBJECT_NAME_NOT_FOUND == status )
            {
                TRK_FILE_TRACKING_INFORMATION fileinfo;

                _tcscpy( fileinfo.tszFilePath, TEXT("") );
                fileinfo.hr = HRESULT_FROM_NT( status );

                cpcFileStatus.Push( &fileinfo, 1 );
                hr = S_OK;
                goto Exit;
            }
            else if( !NT_SUCCESS(status) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Failed NtQueryVolumeInformationFile (%s)"), bstrUncPath));
                TrkRaiseNtStatus( status );
            }
            volid.Load( &volid, fsobOID );
            droidCurrent = CDomainRelativeObjId( volid, CObjId() );

            NtClose( hFile );
            hFile = NULL;
        }
        else if( TRKINFOSCOPE_MACHINE != scope )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Bad scope to CTrkForceOwnership::FileStatus (%d)"), scope ));
            TrkRaiseWin32Error( ERROR_INVALID_PARAMETER );
        }

        // Connect to the workstation in question
        rc.Initialize( mcid );

        // Get the volume status info
        RpcTryExcept
        {
            hr = GetFileTrackingInformation( rc, droidCurrent, static_cast<TrkInfoScope>(scope), cpipeFileStatus );
        }
        RpcExcept( BreakOnDebuggableException() )
        {
            hr = HRESULT_FROM_WIN32( RpcExceptionCode() );
        }
        RpcEndExcept;

        if( FAILED(hr) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Failed call to GetFileTrackInformation")));
            TrkRaiseException( hr );
        }

        if( FAILED(cpcFileStatus.GetHResult()) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Failed in FileStatus pipe callback")));
            TrkRaiseException( cpcFileStatus.GetHResult() );
        }
        // Truncate the safearrays
        cpcFileStatus.Compact();

    }
    __except( BreakOnDebuggableException() )
    {
        cpcFileStatus.UnInitialize();
        hr = GetExceptionCode();
    }

Exit:

    if( NULL != hFile )
        NtClose( hFile );

    if( FAILED(hr) )
    {
        VariantClear( pvarrgbstrFileName );
        VariantClear( pvarrgbstrFileId );
        VariantClear( pvarrglongStatus );
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\itrkadmn\frcown.h ===
// FrcOwn.h : Declaration of the CForceOwnership

#ifndef __FRCOWN_H_
#define __FRCOWN_H_

#include "resource.h"       // main symbols
#include <trkwks.hxx>

/////////////////////////////////////////////////////////////////////////////
// CForceOwnership
class ATL_NO_VTABLE CTrkForceOwnership : 
        public CComObjectRootEx<CComSingleThreadModel>,
        public CComCoClass<CTrkForceOwnership, &CLSID_TrkForceOwnership>,
        public IDispatchImpl<ITrkForceOwnership, &IID_ITrkForceOwnership, &LIBID_ITRKADMNLib>
{
public:
        CTrkForceOwnership() :
            _idt(_dbc, &_refreshSequenceStorage),
            _voltab(_dbc, &_refreshSequenceStorage),
            _refreshSequenceStorage( &_voltab )
        {
            __try
            {
                _dbc.Initialize(NULL);
                _voltab.Initialize(NULL,0,0);
                _idt.Initialize();
            }
            __except( BreakOnDebuggableException() )
            {
            }
        }

DECLARE_REGISTRY_RESOURCEID(IDR_FRCOWN)

BEGIN_COM_MAP(CTrkForceOwnership)
        COM_INTERFACE_ENTRY(ITrkForceOwnership)
        COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ITrkForceOwnership
public:
        STDMETHOD(FileStatus)(BSTR bstrUncPath, long lScope, VARIANT *pvarrgbstrFileName, VARIANT* pvarrgbstrFileId, VARIANT* pvarrglongStatus);
        STDMETHOD(VolumeStatus)(BSTR bstrUncPath, long lScope, VARIANT *pvarlongVolIndex,
                                VARIANT *pvarbstrVolId, VARIANT *pvarlongStatus);
        STDMETHOD(Files)(BSTR bstrUncPath, long lScope);
        STDMETHOD(Volumes)(BSTR bstrUncPath, long lScope );

private:

    CDbConnection       _dbc;
    CVolumeTable        _voltab;
    CIntraDomainTable   _idt;
    CRefreshSequenceStorage _refreshSequenceStorage;
};


//
// This class is used on the client side of an RPC pipe parameter that passes
// volume tracking information.  The client provides a derived class which
// overrides the push/pull methods as appropriate.
//

class PVolInfoPipeCallback : public TPRpcPipeCallback<TRK_VOLUME_TRACKING_INFORMATION>
{
public:

    virtual void Pull( TRK_VOLUME_TRACKING_INFORMATION *pVolInfo, unsigned long cbBuffer, unsigned long * pcElems ) = 0;
    virtual void Push( TRK_VOLUME_TRACKING_INFORMATION *pVolInfo, unsigned long cElems ) = 0;

    virtual void Alloc( unsigned long cbRequested, TRK_VOLUME_TRACKING_INFORMATION **ppVolInfo, unsigned long * pcbActual )
    {
        if( cbRequested > sizeof(_rgVolInfo) )
            *pcbActual = sizeof(_rgVolInfo);
        else
            *pcbActual = cbRequested;

        *ppVolInfo = _rgVolInfo;

        return;
    }

private:

    TRK_VOLUME_TRACKING_INFORMATION _rgVolInfo[ 26 ];

};


//
// This class is used on the client side of an RPC pipe parameter that passes
// file tracking information.  The client provides a derived class which
// overrides the push/pull methods as appropriate.
//

class PFileInfoPipeCallback : public TPRpcPipeCallback<TRK_FILE_TRACKING_INFORMATION>
{
public:

    virtual void Pull( TRK_FILE_TRACKING_INFORMATION *pVolInfo, unsigned long cbBuffer, unsigned long * pcElems ) = 0;
    virtual void Push( TRK_FILE_TRACKING_INFORMATION *pFileInfo, unsigned long cElems ) = 0;

    virtual void Alloc( unsigned long cbRequested, TRK_FILE_TRACKING_INFORMATION **ppFileInfo, unsigned long * pcbActual )
    {
        if( cbRequested > sizeof(_rgFileInfo) )
            *pcbActual = sizeof(_rgFileInfo);
        else
            *pcbActual = cbRequested;

        *ppFileInfo = _rgFileInfo;

        return;
    }

protected:

    TRK_FILE_TRACKING_INFORMATION _rgFileInfo[ 32 ];

};



//
// This class is used on the client side of an RPC pipe parameter that passes
// a path from the client to the server.
//

class CPCPath : public TPRpcPipeCallback<TCHAR>
{
public:

    CPCPath( TCHAR *ptszPath )
    {
        _iPath = 0;
        _tcscpy( _tszPath, ptszPath );
        _cchPath = _tcslen(_tszPath) + 1;
    }

public:

    void Pull( TCHAR *ptszPath, unsigned long cbBuffer, unsigned long * pcElems )
    {
        if( 0 > _iPath )
        {
            *pcElems = 0;
            return;
        }
        else
        {
            if( sizeof(TCHAR) * (_cchPath - _iPath) > cbBuffer )
                *pcElems = cbBuffer / sizeof(TCHAR);
            else
                *pcElems = _cchPath - _iPath;

            memcpy( ptszPath, &_tszPath[ _iPath ], *pcElems * sizeof(TCHAR) );
            
            if( _iPath + *pcElems >= _cchPath )
                _iPath = -1;
            else
                _iPath += *pcElems;

            return;
        }
    }

    void Push( TCHAR *ptszPath, unsigned long cElems )
    {
        TrkAssert( !TEXT("CGetPathPipeCallback::push shouldn't be called") );
        return;
    }

    void Alloc( unsigned long cbRequested, TCHAR **pptszPath, unsigned long * pcbActual )
    {
        if( cbRequested > sizeof(_tszBuffer) )
            *pcbActual = sizeof(_tszBuffer);
        else
            *pcbActual = cbRequested;

        *pptszPath = _tszBuffer;

        return;
    }

private:

    TCHAR _tszPath[ MAX_PATH + 1 ]; // BUGBUG P2: Path
    TCHAR _tszBuffer[ MAX_PATH + 1 ];
    LONG  _iPath;
    ULONG _cchPath;

};




class CPCVolumeStatus : public PVolInfoPipeCallback
{
public:

    CPCVolumeStatus( CVolumeTable *pvoltab ) : _fInitialized(FALSE), _pvoltab(pvoltab) {};

public:

    void Initialize( CMachineId *pmcid, VARIANT *pvarlongVolIndex, VARIANT *pvarbstrVolId, VARIANT *pvarlongStatus );
    void UnInitialize();

    void Pull( TRK_VOLUME_TRACKING_INFORMATION *pVolInfo, unsigned long cbBuffer, unsigned long * pcElems )
    {
        TrkAssert( !TEXT("CPCVolumeStatus should not be pulled") );
        *pcElems = 0;
        return;
    }

    void Push( TRK_VOLUME_TRACKING_INFORMATION *pVolInfo, unsigned long cElems );

public:

    HRESULT GetHResult()
    {
        return( _hr );
    }

    void Compact();

private:

    HRESULT         _hr;
    BOOL            _fInitialized;

    CMachineId      *_pmcid;
    CVolumeTable    *_pvoltab;
    VARIANT         *_pvarlongVolIndex;
    VARIANT         *_pvarbstrVolId;
    VARIANT         *_pvarlongStatus;

    SAFEARRAYBOUND  _sabound;
    LONG            _iArrays;

};




class CPCVolumes : public PVolInfoPipeCallback
{
public:

    CPCVolumes( CMachineId *pmcid,
                CVolumeTable *pvoltab,
                CRefreshSequenceStorage *pRefreshSequenceStorage ) :
                    _pmcid(pmcid),
                    _pvoltab(pvoltab),
                    _pRefreshSequenceStorage(pRefreshSequenceStorage)
    {
        _cVolIds = 0;
        _hr = S_OK;
    };

public:

    void Pull( TRK_VOLUME_TRACKING_INFORMATION *pVolInfo, unsigned long cbBuffer, unsigned long * pcElems )
    {
        TrkAssert( !TEXT("CPCVolumes should not be pulled") );
        *pcElems = 0;
        return;
    }

    void Push( TRK_VOLUME_TRACKING_INFORMATION *pVolInfo, unsigned long cElems );

public:

    HRESULT GetHResult()
    {
        return( _hr );
    }

    ULONG   Count()
    {
        return( _cVolIds );
    }

    CVolumeId * GetVolIds()
    {
        return( _rgvolid );
    }


private:

    HRESULT         _hr;
    CMachineId      *_pmcid;
    CVolumeTable    *_pvoltab;
    CRefreshSequenceStorage *_pRefreshSequenceStorage;
    ULONG           _cVolIds;
    CVolumeId       _rgvolid[ NUM_VOLUMES ];  // BUGBUG:  Fixed # volumes

};




class CPCFileStatus : public PFileInfoPipeCallback
{
public:

    CPCFileStatus( CIntraDomainTable *pidt ) : _fInitialized(FALSE), _pidt(pidt) {};

public:

    void Initialize( CMachineId *pmcid, VARIANT *pvarrgbstrFileName, VARIANT *pvarrgbstrFileId, VARIANT *pvarrglongStatus );
    void UnInitialize()
    {
        // Nothing to do, the Variants are cleaned by the caller
        return;
    }

    void Pull( TRK_FILE_TRACKING_INFORMATION *pFileInfo, unsigned long cbBuffer, unsigned long * pcElems )
    {
        TrkAssert( !TEXT("CPCFileStatus should not be pulled") );
        *pcElems = 0;
        return;
    }

    void Push( TRK_FILE_TRACKING_INFORMATION *pFileInfo, unsigned long cElems );

public:

    HRESULT GetHResult()
    {
        return( _hr );
    }

    void Compact();

private:

    HRESULT         _hr;
    BOOL            _fInitialized;

    CMachineId      *_pmcid;
    CIntraDomainTable
                    *_pidt;
    VARIANT         *_pvarrgbstrFileName;
    VARIANT         *_pvarrgbstrFileId;
    VARIANT         *_pvarrglongStatus;

    SAFEARRAYBOUND  _sabound;
    long            _iArrays;

};

class CPCFiles : public PFileInfoPipeCallback
{
public:

    CPCFiles( CIntraDomainTable *pidt )
    {
        _pidt = pidt;
    }

public:

    void Pull( TRK_FILE_TRACKING_INFORMATION *pVolInfo, unsigned long cbBuffer, unsigned long * pcElems )
    {
        TrkAssert( !TEXT("CPCFiles should not be pulled") );
        *pcElems = 0;
        return;
    }

    void Push( TRK_FILE_TRACKING_INFORMATION *pFileInfo, unsigned long cElems );

private:

    CIntraDomainTable   *_pidt;

};




#endif //__FRCOWN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\dltadmin\svrstat.cxx ===
#include <pch.cxx>
#pragma hdrstop

#include <ole2.h>
#include "trkwks.hxx"
#include "trksvr.hxx"
#include "dltadmin.hxx"


void
CDomainRelativeObjId::FillLdapIdtKeyBuffer(TCHAR * const pchCN,
                                DWORD cch) const
{
    TCHAR *pchBuf = pchCN;
    _tcscpy(pchBuf, TEXT("CN="));
    pchBuf = pchBuf + 3;
    _volume.Stringize(pchBuf);
    _object.Stringize(pchBuf);
    TrkAssert(pchBuf <= pchCN+cch);
}

void
ShowMoveCounter( const TCHAR *ptszHostName )
{
    CDbConnection       dbc;
    dbc.Initialize( NULL, ptszHostName );

    CTrkSvrConfiguration
                        configSvr;
    configSvr.Initialize();

    BOOL                    fSuccess = FALSE;
    struct berval**         ppbvCounter = NULL;
    TCHAR*                  rgtszAttrs[2];
    LDAPMessage*            pRes = NULL;
    int                     ldapRV;
    int                     cEntries = 0;
    LDAPMessage*            pEntry = NULL;
    CLdapQuotaCounterKeyDn  dnKeyCounter(dbc.GetBaseDn());
    DWORD dwCounter = 0;

    __try
    {
        rgtszAttrs[0] = const_cast<TCHAR*>(s_volumeSecret);
        rgtszAttrs[1] = NULL;
        ldapRV = ldap_search_s(dbc.Ldap(),
                               dnKeyCounter,
                               LDAP_SCOPE_BASE,
                               TEXT("(ObjectClass=*)"),
                               rgtszAttrs,
                               0,
                               &pRes);
        if( LDAP_NO_SUCH_OBJECT == ldapRV )
        {
            printf( "Move table counter doesn't exist\n" );
            __leave;
        }
        else if( LDAP_SUCCESS != ldapRV )
        {
            printf( "Couldn't read move table counter (%d)\n", ldapRV );
            __leave;
        }

        cEntries = ldap_count_entries(dbc.Ldap(), pRes);
        if( 0 == cEntries )
        {
            printf( "Move table counter didn't exist or couldn't be read\n" );
            __leave;
        }
        else if( 1 != cEntries )
        {
            printf( "Too many move table counters (%d)!\n", cEntries );
            __leave;
        }

        pEntry = ldap_first_entry(dbc.Ldap(), pRes);
        if(NULL == pEntry)
        {
            printf( "Entries couldn't be read from result\n" );
            __leave;
        }

        ppbvCounter = ldap_get_values_len(dbc.Ldap(), pEntry, const_cast<TCHAR*>(s_volumeSecret) );
        if (ppbvCounter == NULL)
        {
            _tprintf( TEXT("Move table counter is corrupt, missing %s attribute\n"),
                      s_volumeSecret );
            __leave;
        }

        if ((*ppbvCounter)->bv_len < sizeof(DWORD))
        {
            _tprintf( TEXT("Move table counter attribute %s has wrong type (%d)\n"),
                      s_volumeSecret, (*ppbvCounter)->bv_len );
            __leave;
        }

        memcpy( (PCHAR)&dwCounter, (*ppbvCounter)->bv_val, sizeof(DWORD) );
        printf( "Move table counter (in DS)              %lu\n", dwCounter );
    }
    __finally
    {
        if(NULL != pRes)
        {
            ldap_msgfree(pRes);
        }
        if (ppbvCounter != NULL)
        {
            ldap_value_free_len(ppbvCounter);
        }
    }

}



/*
ShowDcEntries( const TCHAR *ptszHostName )
{
    TCHAR*              rgptszAttrs[4];
    LDAPMessage*        pRes = NULL;
    int                 ldapRV;
    HRESULT             hr = E_FAIL;

    CDbConnection       dbc;
    dbc.Initialize( NULL, ptszHostName );

    CLdapVolumeKeyDn    dnKey(dbc.GetBaseDn());
    LONGLONG            llCreationTime, llLastAliveTime;
    CFILETIME           cftNow;
    CTrkSvrConfiguration
                        configSvr;
    configSvr.Initialize();

    struct berval **    ppbvMachineId = NULL;
    TCHAR**             pptszCreationTime = NULL;
    TCHAR**             pptszLastAliveTime = NULL;
    LDAPMessage *       pEntry = NULL;

    struct SDcEntries
    {
        CMachineId  mcid;
        BOOL        fSuspended;
        CFILETIME   cftCreation;
        CFILETIME   cftLastAlive;
    };

    SDcEntries rgsDcEntries[ 100 ];
    ULONG               cDcEntries = 0;
    CMachineId          mcidDesignated;
    ULONG               cEntries = 0;


    __try
    {
        rgptszAttrs[0] = const_cast<TCHAR*>(s_Cn);
        rgptszAttrs[1] = const_cast<TCHAR*>(s_timeVolChange);
        rgptszAttrs[2] = const_cast<TCHAR*>(s_timeRefresh);
        rgptszAttrs[3] = NULL;

        ldapRV = ldap_search_s( dbc.Ldap(),
                                dnKey,
                                LDAP_SCOPE_ONELEVEL,
                                TEXT("(cn=QTDC_*)"),
                                rgptszAttrs,
                                0,
                                &pRes);
        if(LDAP_SUCCESS != ldapRV)
        {
            printf( "Failed ldap_search_s (%lu)\n", LdapMapErrorToWin32(ldapRV) );
            hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(ldapRV) );
            __leave;
        }

        cEntries = ldap_count_entries( dbc.Ldap(), pRes );
        if(cEntries < 1)
            __leave;

        pEntry = ldap_first_entry( dbc.Ldap(), pRes );
        if(NULL == pEntry)
        {
            printf( "Invalid ldap_first_entry\n" );
            __leave;
        }

        // Loop through the results.

        while(TRUE)
        {
            // Get the machine id.
            ppbvMachineId = ldap_get_values_len( dbc.Ldap(), pEntry, const_cast<TCHAR*>(s_Cn) );
            if(NULL == ppbvMachineId)
            {
                printf( "Couldn't get machine ID\n" );
                hr = TRK_E_CORRUPT_VOLTAB;
                __leave;
            }
            if((*ppbvMachineId)->bv_val == NULL)
            {
                printf( "Couldn't get machine ID\n" );
                hr = TRK_E_CORRUPT_VOLTAB;
                __leave;
            }
            memcpy( &rgsDcEntries[cDcEntries].mcid,
                    (*ppbvMachineId)->bv_val + 5,
                    strlen((*ppbvMachineId)->bv_val+5));

            // Get the creation time.
            pptszCreationTime = ldap_get_values(dbc.Ldap(), pEntry, const_cast<TCHAR*>(s_timeVolChange) );
            if(NULL == pptszCreationTime)
            {
                printf( "Couldn't get the creation time\n" );
                hr = TRK_E_CORRUPT_VOLTAB;
                __leave;
            }
            _stscanf(*pptszCreationTime, TEXT("%I64u"), &llCreationTime);
            rgsDcEntries[cDcEntries].cftCreation = CFILETIME(llCreationTime);

            // Get the last alive time.
            pptszLastAliveTime = ldap_get_values(dbc.Ldap(), pEntry, const_cast<TCHAR*>(s_timeRefresh) );
            if(NULL == pptszLastAliveTime)
            {
                printf( "Couldn't get last alive time\n" );
                hr = TRK_E_CORRUPT_VOLTAB;
                __leave;
            }
            _stscanf(*pptszLastAliveTime, TEXT("%I64u"), &llLastAliveTime);
            rgsDcEntries[cDcEntries].cftLastAlive = CFILETIME(llLastAliveTime);


            rgsDcEntries[cDcEntries].fSuspended = FALSE;
            if(((LONGLONG)cftNow - (LONGLONG)rgsDcEntries[cDcEntries].cftCreation) / 10000000  < configSvr.GetDcSuspensionPeriod()
               ||
               ((LONGLONG)cftNow - (LONGLONG)rgsDcEntries[cDcEntries].cftLastAlive) / 10000000 > configSvr.GetDcSuspensionPeriod()
                )
            {
                rgsDcEntries[cDcEntries].fSuspended = TRUE;
            }
            else if( rgsDcEntries[cDcEntries].mcid > mcidDesignated )
            {
                mcidDesignated = rgsDcEntries[cDcEntries].mcid;
            }

            if (ppbvMachineId != NULL)
            {
                ldap_value_free_len(ppbvMachineId);
                ppbvMachineId = NULL;
            }

            if (pptszCreationTime != NULL)
            {
                ldap_value_free(pptszCreationTime);
                pptszCreationTime = NULL;
            }

            if (pptszLastAliveTime != NULL)
            {
                ldap_value_free(pptszLastAliveTime);
                pptszLastAliveTime = NULL;
            }

            cDcEntries++;
            pEntry = ldap_next_entry(dbc.Ldap(), pEntry);
            if(!pEntry)
            {
                break;
            }
        }   // while( TRUE )

        for( int iEntry = 0; iEntry < cDcEntries; iEntry++ )
        {
            CFILETIME cftLocal;
            TCHAR tszTime[ 80 ];

            printf( "    %-16s ", &rgsDcEntries[iEntry].mcid );

            if( rgsDcEntries[iEntry].mcid == mcidDesignated )
                printf( "       (** Designated **)\n" );
            else if( rgsDcEntries[iEntry].fSuspended )
                printf("        (suspended)\n" );
            else
                printf("        (not suspended)\n" );

            cftLocal = rgsDcEntries[iEntry].cftCreation.ConvertUtcToLocal();
            cftLocal.Stringize( ELEMENTS(tszTime), tszTime );
            _tprintf(  TEXT("        Create = %s\n"), tszTime );

            cftLocal = rgsDcEntries[iEntry].cftLastAlive.ConvertUtcToLocal();
            cftLocal.Stringize( ELEMENTS(tszTime), tszTime );
            _tprintf( TEXT("        Alive  = %s\n"), tszTime );

        }

    }
    __finally
    {
        if (ppbvMachineId != NULL)
        {
            ldap_value_free_len(ppbvMachineId);
        }
        if (pptszCreationTime != NULL)
        {
            ldap_value_free(pptszCreationTime);
        }
        if (pptszLastAliveTime != NULL)
        {
            ldap_value_free(pptszLastAliveTime);
        }

        if( NULL != pRes )
            ldap_msgfree(pRes);
    }

    return hr;
}
*/



BOOL
DltAdminSvrStat( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    NTSTATUS status;
    HRESULT hr = S_OK;;

    RPC_BINDING_HANDLE BindingHandle;
    BOOL fBound = FALSE;
    BOOL fShowDsInfo = FALSE;
    ULONG iDcName = 0;

    if( 1 <= cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption SvrStat\n"
                  "   Purpose: Query a DC for TrkSvr statistics\n"
                  "   Usage:   -svrstat [options] <DC name>\n"
                  "   E.g.:    -svrstat ntdsdc0\n"
                  "   Note:    To find a DC name for a domain, use the nltest tool\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    _tprintf( TEXT("Checking for TrkSvr statistics\n"), rgptszArgs[0] );

    if( 1 > cArgs )
    {
        printf( "Invalid parameters.  Use -? for usage info\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    *pcEaten = 1;

    if( 2 <= cArgs && TEXT('-') == rgptszArgs[0][0] )
    {
        if( TEXT('d') == rgptszArgs[0][1]
            ||
            TEXT('D') == rgptszArgs[0][1] )
        {
            fShowDsInfo = TRUE;
        }
        else
        {
            printf( "Invalid option.  Use -? for help\n" );
            return( FALSE );
        }

        iDcName = 1;
        (*pcEaten)++;
    }


    __try
    {
        CFILETIME cftLocal(0);
        TCHAR tszLocalFileTime[ 80 ];
        WCHAR wszAuthName[ 80 ];
        WCHAR wszUser[ 80 ];
        WCHAR wszDomain[ 80 ];
        RPC_STATUS rpcstatus = RPC_S_OK;
        RPC_TCHAR * ptszStringBinding = NULL;


        TRKSVR_MESSAGE_UNION Msg;
        memset( &Msg, 0, sizeof(Msg) );
        Msg.MessageType = STATISTICS;
        Msg.Priority = PRI_0;

        // Create a binding string

        rpcstatus = RpcStringBindingCompose(NULL,
                                            L"ncacn_np", //L"ncacn_ip_tcp", //L"ncacn_np",
                                            const_cast<TCHAR*>(rgptszArgs[iDcName]),
                                            L"\\pipe\\trkwks", //L"", //L"\\pipe\\trkwks",
                                            NULL,
                                            &ptszStringBinding);
        if( RPC_S_OK != rpcstatus )
        {
            hr = HRESULT_FROM_WIN32( rpcstatus );
            _tprintf( TEXT("Failed RpcStringBindingCompose (%d)\n"), rpcstatus );
            goto Exit;
        }
        _tprintf( TEXT("String binding = %s\n"), ptszStringBinding );

        // Get a client binding handle.

        rpcstatus = RpcBindingFromStringBinding(ptszStringBinding, &BindingHandle);
        RpcStringFree(&ptszStringBinding);
        if( RPC_S_OK != rpcstatus )
        {
            _tprintf( TEXT("Failed RpcBindingFromStringBinding (%d)\n"), rpcstatus );
            hr = HRESULT_FROM_WIN32( rpcstatus );
            goto Exit;
        }
        fBound = TRUE;

        // Call up to TrkSvr

        __try
        {
            hr = LnkSvrMessage(BindingHandle, &Msg);
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            hr = HRESULT_FROM_WIN32( GetExceptionCode() );
        }
        if( FAILED(hr) )
        {
            _tprintf( TEXT("Failed LnkSvrMessage RPC (%08x)\n"), hr );
            goto Exit;
        }

        // Dump the results

        _tprintf( TEXT("\n") );
        _tprintf( TEXT("%-35s\t%d.%d (Build %d)\n"), TEXT("Version"),
                  Msg.Statistics.Version.dwMajor, Msg.Statistics.Version.dwMinor,
                  Msg.Statistics.Version.dwBuildNumber );

        _tprintf( TEXT("\n") );
        _tprintf( TEXT("%-35s\t%d\t%d\t%d\n"), TEXT("SyncVolume Requests/Errors/Threads"),
                  Msg.Statistics.cSyncVolumeRequests, Msg.Statistics.cSyncVolumeErrors, Msg.Statistics.cSyncVolumeThreads );

        _tprintf( TEXT("%-35s\t%d\t%d\n"), TEXT("   CreateVolume Requests/Errors"),
                  Msg.Statistics.cCreateVolumeRequests, Msg.Statistics.cCreateVolumeErrors );
        _tprintf( TEXT("%-35s\t%d\t%d\n"), TEXT("   ClaimVolume Requests/Errors"),
                  Msg.Statistics.cClaimVolumeRequests, Msg.Statistics.cClaimVolumeErrors );
        _tprintf( TEXT("%-35s\t%d\t%d\n"), TEXT("   QueryVolume Requests/Errors"),
                  Msg.Statistics.cQueryVolumeRequests, Msg.Statistics.cQueryVolumeErrors );
        _tprintf( TEXT("%-35s\t%d\t%d\n"), TEXT("   FindVolume Requests/Errors"),
                  Msg.Statistics.cFindVolumeRequests, Msg.Statistics.cFindVolumeErrors );
        _tprintf( TEXT("%-35s\t%d\t%d\n"), TEXT("   TestVolume Requests/Errors"),
                  Msg.Statistics.cTestVolumeRequests, Msg.Statistics.cTestVolumeErrors );

        _tprintf( TEXT("%-35s\t%d\t%d\t%d\n"), TEXT("Search Requests/Errors/Threads"),
                  Msg.Statistics.cSearchRequests, Msg.Statistics.cSearchErrors, Msg.Statistics.cSearchThreads );
        _tprintf( TEXT("%-35s\t%d\t%d\t%d\n"), TEXT("MoveNotify Requests/Errors/Threads"),
                  Msg.Statistics.cMoveNotifyRequests, Msg.Statistics.cMoveNotifyErrors, Msg.Statistics.cMoveNotifyThreads );
        _tprintf( TEXT("%-35s\t%d\t%d\t%d\n"), TEXT("Refresh Requests/Errors/Threads"),
                  Msg.Statistics.cRefreshRequests, Msg.Statistics.cRefreshErrors, Msg.Statistics.cRefreshThreads );
        _tprintf( TEXT("%-35s\t%d\t%d\t%d\n"), TEXT("DeleteNotify Requests/Errors/Threads"),
                  Msg.Statistics.cDeleteNotifyRequests, Msg.Statistics.cDeleteNotifyErrors, Msg.Statistics.cDeleteNotifyThreads );

        _tprintf( TEXT("\n") );
        cftLocal = static_cast<CFILETIME>(Msg.Statistics.ftServiceStart).ConvertUtcToLocal();
        cftLocal.Stringize( ELEMENTS(tszLocalFileTime), tszLocalFileTime );
        _tprintf( TEXT("%-35s\t%08x:%08x\n%35s\t(%s local time)\n"), TEXT("Service start"),
                  Msg.Statistics.ftServiceStart.dwHighDateTime, Msg.Statistics.ftServiceStart.dwLowDateTime,
                  TEXT(""), tszLocalFileTime );

        cftLocal = static_cast<CFILETIME>(Msg.Statistics.ftLastSuccessfulRequest).ConvertUtcToLocal();
        cftLocal.Stringize( ELEMENTS(tszLocalFileTime), tszLocalFileTime );
        _tprintf( TEXT("%-35s\t%08x:%08x\n%35s\t(%s local time)\n"), TEXT("Last successful request"),
                  Msg.Statistics.ftLastSuccessfulRequest.dwHighDateTime, Msg.Statistics.ftLastSuccessfulRequest.dwLowDateTime,
                  TEXT(""), tszLocalFileTime );
        _tprintf( TEXT("%-35s\t%08x\n"), TEXT("Last Error"), Msg.Statistics.hrLastError );

        _tprintf( TEXT("\nQuota Information:\n") );
        _tprintf( TEXT("   %-32s\t%d\n"), TEXT("Move Limit"), Msg.Statistics.dwMoveLimit );

        _tprintf( TEXT("   %-32s\t%d\n"), TEXT("Volume table cached count"), Msg.Statistics.dwCachedVolumeTableCount );
        _tprintf( TEXT("   %-32s\t%d\n"), TEXT("Move table cached count"), Msg.Statistics.dwCachedMoveTableCount );

        cftLocal = static_cast<CFILETIME>(Msg.Statistics.ftCacheLastUpdated).ConvertUtcToLocal();
        cftLocal.Stringize( ELEMENTS(tszLocalFileTime), tszLocalFileTime );
        _tprintf( TEXT("   %-32s\t%08x:%08x\n%35s\t(%s local time)\n"), TEXT("Cache counts last updated"),
                  Msg.Statistics.ftCacheLastUpdated.dwHighDateTime, Msg.Statistics.ftCacheLastUpdated.dwLowDateTime,
                  TEXT(""), tszLocalFileTime );

        _tprintf( TEXT("   %-32s\t%s\n"), TEXT("Is designated DC"),
                  Msg.Statistics.fIsDesignatedDc ? TEXT("Yes") : TEXT("No") );

        _tprintf( TEXT("\n") );
        cftLocal = static_cast<CFILETIME>(Msg.Statistics.ftNextGC).ConvertUtcToLocal();
        cftLocal.Stringize( ELEMENTS(tszLocalFileTime), tszLocalFileTime );
        _tprintf( TEXT("%-35s\t%08x:%08x\n%35s\t(%s local time)\n"), TEXT("Next GC"),
                  Msg.Statistics.ftNextGC.dwHighDateTime, Msg.Statistics.ftNextGC.dwLowDateTime,
                  TEXT(""), tszLocalFileTime );
        _tprintf( TEXT("%-35s\t%d\n"), TEXT("Entries GC-ed"), Msg.Statistics.cEntriesGCed);
        _tprintf( TEXT("%-35s\t%d\n"), TEXT("Max DS write events"), Msg.Statistics.cMaxDsWriteEvents);
        _tprintf( TEXT("%-35s\t%d\n"), TEXT("Current failed writes"), Msg.Statistics.cCurrentFailedWrites);

        _tprintf( TEXT("\n") );
        _tprintf( TEXT("%-35s\t%d\n"), TEXT("Refresh counter"), Msg.Statistics.lRefreshCounter );
        _tprintf( TEXT("%-35s\t%d/%d/%d\n"), TEXT("Available/least/max RPC server threads"),
                  Msg.Statistics.cAvailableRpcThreads, Msg.Statistics.cLowestAvailableRpcThreads, Msg.Statistics.cMaxRpcThreads );
        _tprintf( TEXT("%-35s\t%d/%d\n"), TEXT("Current/most thread pool threads"),
                  Msg.Statistics.cNumThreadPoolThreads, Msg.Statistics.cMostThreadPoolThreads );
        /*
        _tprintf( TEXT("%-35s\t%s\n"), TEXT("Service controller state"),
                  CDebugString( static_cast<SServiceState>(Msg.Statistics.SvcCtrlState))._tsz );
        */

        //ShowMoveCounter( rgptszArgs[iDcName] );

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = GetExceptionCode();
    }

Exit:

    if( fBound )
        RpcBindingFree( &BindingHandle );

    return( SUCCEEDED(hr) );
}




BOOL
SetRefreshCounter( CDbConnection &dbc,
                   CLdapVolumeKeyDn dnKey,
                   const SequenceNumber seq )
{
    int                 ldapRV;
    HRESULT             hr = E_FAIL;

    CTrkSvrConfiguration
                        configSvr;
    configSvr.Initialize();
    LDAPMod * mods[2];


    __try
    {
        CLdapSeqNum    lsn(seq);
        CLdapStringMod lsmSequence(s_timeRefresh, lsn, LDAP_MOD_REPLACE );

        mods[0] = &lsmSequence._mod;
        mods[1] = 0;

        ldapRV = ldap_modify_s(dbc.Ldap(), dnKey, mods);

        if(LDAP_SUCCESS != ldapRV)
        {
            printf( "Failed ldap_modify_s(%lu)\n", LdapMapErrorToWin32(ldapRV) );
            hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(ldapRV) );
            __leave;
        }

    }
    __finally
    {
    }

    return SUCCEEDED(hr);
}



class CLdapSecret
{
public:
    CLdapSecret()
    {
        memset(_abPad,0,sizeof(_abPad));
    }

    CLdapSecret(const CVolumeSecret &secret)
    {
        _secret = secret;
        memset(_abPad,0,sizeof(_abPad));
    }

    CVolumeSecret _secret;
    BYTE _abPad[sizeof(GUID) - sizeof(CVolumeSecret)];
};



BOOL
DltAdminSetVolumeSeqNumber( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    NTSTATUS status;
    HRESULT hr = S_OK;;
    SequenceNumber seq;
    CVolumeId volid;
    CStringize stringize;

    if( 1 <= cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption SetVolSeq\n"
                  "   Purpose: Set the sequence number in a volume table entry\n"
                  "   Usage:   -setvolseq <DC name> <seq> <volid>\n"
                  "   E.g.:    -setvolseq ntdsdc0 90 {d763433c-73a3-48c7-88a5-d6f3552835c6}\n"
                  "   Note:    Requires write access to volume table in DS.\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    _tprintf( TEXT("Setting sequence number in volume table\n"), rgptszArgs[0] );

    if( 3 > cArgs )
    {
        printf( "Invalid parameters.  Use -? for usage info\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    *pcEaten = 1;

    // Get the sequence number

    if( 1 != _stscanf( rgptszArgs[1], TEXT("%d"), &seq ))
    {
        printf( "Invalid sequence number.  Use -? for usage info\n" );
        return FALSE;
    }

    // Get the volid

    // mikehill_test
    DebugBreak();
    stringize.Use( rgptszArgs[2] );
    volid = stringize;

    /*
    {
        RPC_STATUS rpc_status = RPC_S_INVALID_STRING_UUID;
        TCHAR tszTemp[ MAX_PATH ];
        TCHAR *ptszTemp = NULL;

        if( TEXT('{') == rgptszArgs[2][0] ) 
        {
            _tcscpy( tszTemp, &rgptszArgs[2][1] );
            ptszTemp = _tcschr( tszTemp, TEXT('}') );
            if( NULL != ptszTemp )
            {

                *ptszTemp = TEXT('\0');

                rpc_status = UuidFromString( tszTemp, (GUID*)&volid );
            }
        }

        if( RPC_S_OK != rpc_status )
        {
            _tprintf( TEXT("Error: Invalid volume ID\n") );
            return FALSE;
        }
    }
    */

    // Set the sequence

    CDbConnection       dbc;
    dbc.Initialize( NULL, rgptszArgs[0] );

    CLdapVolumeKeyDn dnKey(dbc.GetBaseDn(), volid);

    return SetRefreshCounter( dbc, dnKey, seq );
}




BOOL
SetRefreshCounter2( CDbConnection &dbc,
                   CLdapIdtKeyDn dnKey,
                   const SequenceNumber seq )
{
    int                 ldapRV;
    HRESULT             hr = E_FAIL;

    CTrkSvrConfiguration
                        configSvr;
    configSvr.Initialize();
    LDAPMod * mods[2];


    __try
    {
        CLdapSeqNum    lsn(seq);
        CLdapStringMod lsmSequence(s_timeRefresh, lsn, LDAP_MOD_REPLACE );

        mods[0] = &lsmSequence._mod;
        mods[1] = 0;

        ldapRV = ldap_modify_s(dbc.Ldap(), dnKey, mods);

        if(LDAP_SUCCESS != ldapRV)
        {
            printf( "Failed ldap_modify_s(%lu)\n", LdapMapErrorToWin32(ldapRV) );
            hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(ldapRV) );
            __leave;
        }

    }
    __finally
    {
    }

    return SUCCEEDED(hr);
}



BOOL
DltAdminSetDroidSeqNumber( ULONG cArgs, const TCHAR * const rgptszArgs[], ULONG *pcEaten )
{
    NTSTATUS status;
    HRESULT hr = S_OK;;
    SequenceNumber seq;
    CDomainRelativeObjId droid;
    CStringize stringize;

    if( 1 <= cArgs && IsHelpArgument( rgptszArgs[0] ))
    {
        printf( "\nOption SetDroidSeq\n"
                  "   Purpose: Set the sequence number in a move table entry\n"
                  "   Usage:   -setdroidseq <DC name> <seq> <volid>\n"
                  "   E.g.:    -setdroidseq ntdsdc0 90 {d763433c-73a3-48c7-88a5-d6f3552835c6}{183c8367-a392-c784-88a5-d6f3552835c6}\n"
                  "   Note:    Requires write access to volume table in DS.\n" );
        *pcEaten = 1;
        return( TRUE );
    }

    _tprintf( TEXT("Setting sequence number in move table\n"), rgptszArgs[0] );

    if( 3 > cArgs )
    {
        printf( "Invalid parameters.  Use -? for usage info\n" );
        *pcEaten = 0;
        return( FALSE );
    }

    *pcEaten = 1;

    // Get the sequence number

    if( 1 != _stscanf( rgptszArgs[1], TEXT("%d"), &seq ))
    {
        printf( "Invalid sequence number.  Use -? for usage info\n" );
        return FALSE;
    }

    // Get the droid

    stringize.Use( rgptszArgs[2] );
    droid = stringize;

    if( CDomainRelativeObjId() == droid )
    {
        _tprintf( TEXT("Error: Invalid DROID\n") );
        return FALSE;
    }

    // Set the sequence

    CDbConnection       dbc;
    dbc.Initialize( NULL, rgptszArgs[0] );

    CLdapIdtKeyDn dnKey(dbc.GetBaseDn(), droid);

    return SetRefreshCounter2( dbc, dnKey, seq );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\itrkadmn\makefile.inc ===
#
# Show that the compiled resource file depends
# on the type library.  Otherwise, when the idl
# file is updated, the nmake won't realize that
# it's necessary to recompile the rc file.
#

typelib: $O\itrkadmn.res

$O\itrkadmn.res : .\itrkadmn.tlb

.\itrkadmn.tlb : .\itrkadmn.h

#  The RC file pulls in COM registration scripts
.\itrkadmn.rc : .\frcown.rgs restore.rgs restpars.rgs

#
# Copy the itrkadmn.h header file to publics
#

copyheader : $(BASEDIR)\public\sdk\inc\itrkadmn.h

$(BASEDIR)\public\sdk\inc\itrkadmn.h: itrkadmn.h
        copy itrkadmn.h $(BASEDIR)\public\sdk\inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\itrkadmn\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ITrkAdmn.rc
//
#define IDS_PROJNAME                    100
#define IDR_FRCOWN                      101
#define IDR_FRCOWN1                     102
#define IDR_RESTORE                     103
#define IDR_RESTORE1                    104
#define IDR_RESTPARS                    105
#define IDR_RESTPARS1                   106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\itrkadmn\itrkadmn.cpp ===
// ITrkAdmn.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//              To build a separate proxy/stub DLL, 
//              run nmake -f ITrkAdmnps.mk in the project directory.

#include "pch.cxx"
#pragma hdrstop
#include <trklib.hxx>
#include <trksvr.hxx>

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "ITrkAdmn.h"

#include "ITrkAdmn_i.c"
#include "FrcOwn.h"
#include "RestPars.hxx"
#include "Restore.h"

#define TRKDATA_ALLOCATE
#include "trkwks.hxx"

const TCHAR tszKeyNameLinkTrack[] = TEXT("System\\CurrentControlSet\\Services\\TrkWks\\Parameters");

#if DBG
DWORD g_Debug = 0;
CTrkConfiguration g_config;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_TrkForceOwnership, CTrkForceOwnership)
        OBJECT_ENTRY(CLSID_TrkRestoreNotify, CTrkRestoreNotify)
        OBJECT_ENTRY(CLSID_TrkRestoreParser, CRestoreParser)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
#if DBG
        g_config.Initialize( );
        g_Debug = g_config._dwDebugFlags;
        TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG, "ITrkAdmn" );
#endif
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
        return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
        return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
        // registers object, typelib and all interfaces in typelib
        return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
        _Module.UnregisterServer();
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\itrkadmn\restore.h ===
// Restore.h : Declaration of the CTrkRestoreNotify

#ifndef __RESTORE_H_
#define __RESTORE_H_

#include "resource.h"       // main symbols

#include <trkwks.hxx>

/////////////////////////////////////////////////////////////////////////////
// CTrkRestoreNotify
class ATL_NO_VTABLE CTrkRestoreNotify : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CTrkRestoreNotify, &CLSID_TrkRestoreNotify>,
	public IDispatchImpl<ITrkRestoreNotify, &IID_ITrkRestoreNotify, &LIBID_ITRKADMNLib>
{
public:
	CTrkRestoreNotify()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_RESTORE)

BEGIN_COM_MAP(CTrkRestoreNotify)
	COM_INTERFACE_ENTRY(ITrkRestoreNotify)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ITrkRestoreNotify
public:
	STDMETHOD(OnRestore)();

public:
	void		SetMachine(const CMachineId& mcid);

private:
	CMachineId	_mcid;
};

#endif //__RESTORE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\itrkadmn\restore.cpp ===
#include "pch.cxx"
#pragma hdrstop
#include <trklib.hxx>
#include <trksvr.hxx>

#include "stdafx.h"
#include "ITrkAdmn.h"
#include "Restore.h"

/////////////////////////////////////////////////////////////////////////////
// CTrkRestoreNotify


STDMETHODIMP CTrkRestoreNotify::OnRestore()
{
    HRESULT     hr = E_FAIL;
    CRpcClientBinding rc;

    TrkLog(( TRKDBG_ADMIN, TEXT("CTrkRestoreNotify::OnRestore called") ));

    rc.Initialize(_mcid);

    RpcTryExcept
    {
        hr = LnkOnRestore(rc);
    }
    RpcExcept(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = HRESULT_FROM_WIN32(RpcExceptionCode());
    }
    RpcEndExcept;

Exit:

    return MapTR2HR(hr);
}

void CTrkRestoreNotify::SetMachine(const CMachineId& mcid)
{
	_mcid = mcid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\itrkadmn\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A2531F39_C67D_11D0_8CB1_00C04FD90F85__INCLUDED_)
#define AFX_STDAFX_H__A2531F39_C67D_11D0_8CB1_00C04FD90F85__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//#define STRICT


//#define _WIN32_WINNT 0x0400
#define _ATL_BOTH_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A2531F39_C67D_11D0_8CB1_00C04FD90F85__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\itrkadmn\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "pch.cxx"
#pragma hdrstop
#include <trklib.hxx>


#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

// Prevent the following warning (and three others like it):
// d:\nt\public\sdk\inc\atl21\atlimpl.cpp(2281) : warning C4273: 'malloc' : inconsistent dll linkage.  dllexport assumed.
#pragma warning(disable:4273)
#include <atlimpl.cpp>
#pragma warning(default:4273)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\itrkadmn\restpars.cxx ===
// RestPars.cxx : Implementation of CRestoreParser


#include "pch.cxx"
#pragma hdrstop
#include <trklib.hxx>
#include <trksvr.hxx>

#include "stdafx.h"
#include "ITrkAdmn.h"
#include "restore.h"
#include "RestPars.hxx"

/////////////////////////////////////////////////////////////////////////////
// CRestoreParser



HRESULT STDMETHODCALLTYPE
CRestoreParser::ParseDisplayName(
        /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
        /* [in] */ LPOLESTR poszDisplayName,
        /* [out] */ ULONG __RPC_FAR *pchEaten,
        /* [out] */ IMoniker __RPC_FAR *__RPC_FAR *ppmkOut)
{
    LPOLESTR        poszTmp = poszDisplayName;
    HRESULT         hr = E_INVALIDARG;

    *ppmkOut = static_cast<IMoniker*>(this);
    *pchEaten = ocslen(poszDisplayName);
    (*ppmkOut)->AddRef();
    
    if(TEXT('@') != poszTmp[0])
    {
        TrkLog((TRKDBG_ERROR, TEXT("Unrecognized display name (%s)"),
                poszDisplayName));
        goto Exit;
    }
    poszTmp++;
    poszTmp = _tcschr(poszTmp, TEXT('@'));
    if(TEXT('\0') == poszTmp)
    {
        TrkLog((TRKDBG_ERROR, TEXT("Unrecognized progid in display name (%s)"),
                poszDisplayName));
        goto Exit;
    }
    poszTmp++;
    if(TEXT('\0') == poszTmp)
    {
        TrkLog((TRKDBG_ERROR, TEXT("Unexpected end of display name (%s)"),
                poszDisplayName));
        goto Exit;
    }
    __try
    {
        _mcid = CMachineId(poszTmp);
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TrkLog((TRKDBG_ERROR, TEXT("Can't convert \"%s\" to machine id"),
                poszTmp));
        hr = GetExceptionCode();
        goto Exit;
    }

Exit:

    return(hr);
}


/* [local] */ HRESULT STDMETHODCALLTYPE
CRestoreParser::BindToObject(
        /* [unique][in] */ IBindCtx __RPC_FAR *pbc,
        /* [unique][in] */ IMoniker __RPC_FAR *pmkToLeft,
        /* [in] */ REFIID riidResult,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvResult)
{ 
    HRESULT hr = E_FAIL;
    IClassFactory *pCF = NULL;

    hr = _Module.GetClassObject(CLSID_TrkRestoreNotify, IID_IClassFactory,
                                reinterpret_cast<void**>(&pCF) );
    if( FAILED(hr) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get ClassFactory in CRestoreParser::BindTobObject (%08x)"), hr ));
        goto Exit;
    }

    hr = pCF->CreateInstance( NULL, riidResult, ppvResult );
    if( FAILED(hr) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't createinstance in CRestoreParser (%08x)"), hr ));
        goto Exit;
    }

    reinterpret_cast<CTrkRestoreNotify*>(*ppvResult)->SetMachine(_mcid);

    hr = S_OK;

Exit:

    RELEASE_INTERFACE( pCF );

    return( hr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\pch\dummy.cxx ===
#include "pch.cxx"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkcom\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/


#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( trkcom )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( trkcom ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkstub\stub_trkwks_c.c ===
#undef RPC_NO_WINDOWS_H
#include <trkwks_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkcom\filelink.cxx ===
#include <pch.cxx>
#pragma hdrstop

#define TRKDATA_ALLOCATE
#include "trkcom.hxx"
#include "trklib.hxx"

#if !defined(_UNICODE) || defined(OLE2ANSI)
#error This ILinkTrack implementation is only compatible on a Unicode build
#endif

//+----------------------------------------------------------------------------
//
//  Method:     CTrackFile/~CTrackFile
//
//  Synopsis:   Construction/Destruction
//
//  Arguments:  None
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

CTrackFile::CTrackFile()
{
    _cRefs = 0;
    _fDirty = FALSE;
    _fLoaded = FALSE;
    memset( &_PersistentState, 0, sizeof(_PersistentState) );
}

CTrackFile::~CTrackFile()
{
}


//+----------------------------------------------------------------------------
//
//  Method:     IUnknown methods
//
//  Synopsis:   IUnknown
//
//+----------------------------------------------------------------------------

ULONG
CTrackFile::AddRef()
{
    long cNew;
    cNew = InterlockedIncrement( &_cRefs );
    return( cNew );
}

ULONG
CTrackFile::Release()
{
    long cNew;
    cNew = InterlockedDecrement( &_cRefs );
    if( 0 == cNew )
        delete this;

    return( cNew >= 0 ? cNew : 0 );
}

HRESULT
CTrackFile::QueryInterface( REFIID iid, void ** ppvObject )
{
    HRESULT hr = E_NOINTERFACE;

    // Parameter validation

    if( NULL == ppvObject )
    {
        hr = E_INVALIDARG;
        goto Exit;
    }


    *ppvObject = NULL;

    if( IID_IUnknown == iid
        ||
        IID_ITrackFile == iid )
    {
        AddRef();
        *ppvObject = (void*) (IUnknown*) (ITrackFile*) this;
        hr = S_OK;
    }
    else if( IID_ITrackFileRestricted == iid )
    {
        AddRef();
        *ppvObject = (void*) (ITrackFileRestricted*) this;
        hr = S_OK;
    }
    else if( IID_IPersistMemory == iid )
    {
        AddRef();
        *ppvObject = (void*) (IPersistMemory*) this;
        hr = S_OK;
    }
    else if( IID_IPersistStreamInit == iid )
    {
        AddRef();
        *ppvObject = (void*) (IPersistStreamInit*) this;
        hr = S_OK;
    }

Exit:

    return( hr );

}


//+----------------------------------------------------------------------------
//
//  Method:     CreateFromPath (ITrack*)
//
//  Synopsis:   Create a link client for a link source file.
//
//  Arguments:  [poszPath] (in)
//                  The file to which to link.
//
//  Returns:    HRESULT
//
//+----------------------------------------------------------------------------  

HRESULT
CTrackFile::CreateFromPath( const OLECHAR * poszPath )
{
    HRESULT hr = S_OK;
    NTSTATUS status = STATUS_SUCCESS;
    CDomainRelativeObjId droidCurrent, droidBirth;

    // Parameter validation

    if( NULL == poszPath )
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    __try
    {
        status = GetDroids( poszPath, &droidCurrent, &droidBirth, RGO_GET_OBJECTID );
        if( !NT_SUCCESS(status) )
        {
            hr = HRESULT_FROM_NT(status);
            goto Exit;
        }
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }
    if( FAILED(hr) ) goto Exit;

    _fLoaded = FALSE;
    InitNew();

    _fDirty = TRUE;
    _PersistentState.droidCurrent = droidCurrent;
    _PersistentState.droidBirth = droidBirth;

Exit:

    if( SUCCEEDED(hr) )
        TrkLog(( TRKDBG_CREATE, TEXT("Link created to %s"), poszPath ));

    hr = MapTR2HR( hr );

    return( hr );
}



//+----------------------------------------------------------------------------
//
//  Method:     Resolve (ITrack*)
//  
//  Synopsis:   Determine the current path of a link source.
//
//  Arguments:  [pcbPath] (in/out)
//                  In:  The size of the poszPath buffer
//                  Out: The actual path length (including the null terminator)
//              [poszPath] (out)
//                  The link source's current path.
//              [dwMillisecondTimeout] (in)
//                  A suggestion as to when this method should give up
//                  and return if it hasn't yet found the file.
//
//  Returns:    HRESULT
//
//+----------------------------------------------------------------------------

// BUGBUG P1:  Optionally return the GetFileAttributesEx info, so that the
// shell doesn't have to re-open the file.

HRESULT
CTrackFile::Resolve( DWORD *pcbPath, OLECHAR * poszPath, DWORD dwMillisecondTimeout )
{
    return( Resolve( pcbPath, poszPath, dwMillisecondTimeout, TRK_MEND_DEFAULT ));
}


HRESULT
CTrackFile::Resolve( DWORD *pcbPath, OLECHAR * poszPath, DWORD dwMillisecondTimeout,
                     DWORD Restrictions )
{
    HRESULT hr = E_FAIL;
    CMachineId mcidLocal( MCID_LOCAL );
    CRpcClientBinding rc;
    CDomainRelativeObjId droidNew;
    CDomainRelativeObjId droidBirth;
    CDomainRelativeObjId droidCurrent;
    OLECHAR oszPathActual[ MAX_PATH + 1 ];
    DWORD cbPathActual = 0;
    CFILETIME cftDue;

    // Parameter validation

    if( NULL == pcbPath
        ||
        NULL == poszPath )
    {
        hr = E_INVALIDARG;
        goto Exit;
    }
        else if( !_fLoaded )
        {
                hr = E_UNEXPECTED;
                goto Exit;
        }

        __try
        {
                cftDue.IncrementMilliseconds( dwMillisecondTimeout );

                droidBirth = _PersistentState.droidBirth;
                droidCurrent = _PersistentState.droidCurrent;

                rc.RcInitialize( mcidLocal, s_tszTrkWksLocalRpcProtocol, s_tszTrkWksLocalRpcEndPoint );

                RpcTryExcept
                {
                        CMachineId mcidLast, mcidCurrent;
                        ULONG cbFileName = (MAX_PATH + 1) * sizeof(TCHAR);
                        CDomainRelativeObjId droidBirthNew;

                        hr = LnkMendLink( rc,
                                          cftDue,
                                          Restrictions,
                                          &droidBirth,
                                          &droidCurrent,
                                          &mcidLast,
                                          &droidBirthNew,
                                          &droidNew,
                                          &mcidCurrent,
                                          &cbFileName,
                                          oszPathActual );
                }
                RpcExcept( BreakOnDebuggableException() )
                {
                        hr = HRESULT_FROM_WIN32( RpcExceptionCode() );
                }
                RpcEndExcept;

                if( FAILED(hr) ) goto Exit;


                // Compare droidBirth and droidCurrent with the ones in _PersistentState.
                // If the same, do not set _fDirty.
                if(droidBirth != _PersistentState.droidBirth)
                {
                        _PersistentState.droidBirth = droidBirth;
                        _fDirty = TRUE;
                }
                if(droidNew != _PersistentState.droidCurrent)
                {
                        _PersistentState.droidCurrent = droidNew;
                        _fDirty = TRUE;
                }

                cbPathActual = ( ocslen(oszPathActual) + 1 ) * sizeof(OLECHAR);
                if( cbPathActual > *pcbPath )
                        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                else
                        ocscpy( poszPath, oszPathActual );

                *pcbPath = cbPathActual;
                if( FAILED(hr) ) goto Exit;
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
                hr = GetExceptionCode();
                goto Exit;
        }


Exit:

    return( hr );

}



//+----------------------------------------------------------------------------
//
//  Method:     Open (ITrackFile)
//  
//  Synopsis:   Open the referent file ensure that its object ID is 
//              correct.  If the object ID is not correct, or the
//              file could not be found, then perform a Resolve.
//
//  Arguments:  [pcbPathHint] (in/out)
//                  In:  The size of the poszPathHint buffer
//                  Out: The actual path length (including the null terminator)
//              [poszPathHint] (in/out)
//                  The suggested path to the file.  If the path turns out not
//                  to be correct, an updated path is returned.
//              [dwMillisecondTimeout] (in)
//                  A suggestion as to when this method should give up
//                  and return if it hasn't yet found the file.
//              [dwDesiredAccess] (in)
//                  Access mode for the open file (see Win32 CreateFile)
//              [dwShareMode] (in)
//                  Sharing for the open file (see Win32 CreateFile)
//              [dwFlags] (in)
//                  Specifies the flags for the file (see the FILE_FLAG_*
//                  values in the Win32 CreateFile).
//              [phFile] (out)
//                  The open file handle.  It is because of this parameter
//                  That the ITrackFile interface is [local].
//
//  Returns:    HRESULT
//
//+----------------------------------------------------------------------------

STDMETHODIMP CTrackFile::Open( /*in, out*/ DWORD * pcbPathHint,
                               /*in, out, size_is(*pcbPathHint), string*/ OLECHAR * poszPathHint,
                               /*in*/ DWORD dwMillisecondTimeout,
                               /*in*/ DWORD dwDesiredAccess,    // access (read-write) mode 
                               /*in*/ DWORD dwShareMode,        // share mode 
                               /*in*/ DWORD dwFlags,
                               /*out*/ HANDLE * phFile )
{
    return E_NOTIMPL;

/*

    HRESULT hr = S_OK;
    BOOL fTimeout = TRUE;
    NTSTATUS status = STATUS_SUCCESS;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    FILE_OBJECTID_BUFFER fobOID;
    IO_STATUS_BLOCK Iosb;
    CObjId cobjidFile;
    DWORD dwTickCountTimeout, dwTickCountNow;

    //  ----------
    //  Initialize
    //  ----------

    *phFile = INVALID_HANDLE_VALUE;

    // Ensure we have an ObjectID to check against.

    if( !_fLoaded )
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    // Calculate the absolute deadline.

    dwTickCountNow = GetTickCount();
    dwTickCountTimeout = dwTickCountNow + dwMillisecondTimeout;
    if( dwTickCountTimeout < dwTickCountNow )
    {
        // Bad dwMillisecondTimeout value
        hr = E_INVALIDARG;
        goto Exit;
    }

    //  -------------
    //  Open the File
    //  -------------

    do
    {
        // Open the file

        hFile = CreateFile( poszPathHint, dwDesiredAccess, dwShareMode, NULL,
                            OPEN_EXISTING, dwFlags, NULL );
        if( INVALID_HANDLE_VALUE == hFile )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Exit;
        }

        // Get the object ID

        status = NtFsControlFile(
                     hFile,
                     NULL,
                     NULL,
                     NULL,
                     &Iosb,
                     FSCTL_GET_OBJECT_ID,
                     NULL,                  // In buffer
                     0,                     // In buffer size
                     &fobOID,               // Out buffer
                     sizeof(fobOID) );      // Out buffer size

        if( !NT_SUCCESS(status) )
        {
            hr = HRESULT_FROM_NT( status );
            goto Exit;
        }

        // Verify the object ID

        cobjidFile.Load( fobOID, LINK_TYPE_FILE );

        if( cobjidFile == _PersistentState.droidCurrent.GetObjId() )
        {
            // We found a good file and we're done.
            fTimeout = FALSE;
            break;
        }
        else
        {
            // Try to find the correct file.
            hr = Resolve( pcbPathHint, poszPathHint, dwTickCountTimeout - GetTickCount() );
            if( FAILED(hr) ) goto Exit;
        }
    
    }   while( GetTickCount() < dwTickCountTimeout );

    // Did the previous loop end because of a timeout?

    if( fTimeout )
    {
        hr = HRESULT_FROM_WIN32( ERROR_TIMEOUT );
        goto Exit;
    }

    // We completed successfully.

    *phFile = hFile;
    hFile = INVALID_HANDLE_VALUE;
    hr = S_OK;

    //  ----
    //  Exit
    //  ----

Exit:

    if( INVALID_HANDLE_VALUE != hFile )
        CloseHandle( hFile );

    return( hr );
*/
}   // CTrackFile::Open()



//+----------------------------------------------------------------------------
//
//  Method:     GetClassID (IPersistMemory & IPersistStreamInit)
//
//  Returns:    HRESULT
//
//+----------------------------------------------------------------------------

STDMETHODIMP
CTrackFile::GetClassID( CLSID *pClassID )
{
    if(NULL == pClassID)
    {
        return E_POINTER;
    }
    *pClassID = IID_ITrackFile;
    return( S_OK );
}


//+----------------------------------------------------------------------------
//
//  Method:     IsDirty (IPersistMemory & IPersistStreamInit)
//
//  Returns:    HRESULT
//                  S_OK => Dirty, S_FALSE => clean
//
//+----------------------------------------------------------------------------


STDMETHODIMP
CTrackFile::IsDirty()
{
    return( _fDirty ? S_OK : S_FALSE );
}


//+----------------------------------------------------------------------------
//
//  Method:     Load (IPersistMemory)
//
//  Synopsis:   Load the TrackFile object from persistent state.
//
//  Arguments:  [pvMem]
//                  Points to the serialization buffer.
//              [cbSize]
//                  Size of the serialization buffer.
//  
//  Returns:    None
//
//+----------------------------------------------------------------------------

STDMETHODIMP
CTrackFile::Load( void * pvMem, ULONG cbSize )
{
    LinkTrackPersistentState PersistentState;

    if( NULL == pvMem )
        return( E_POINTER );

    else if( _fLoaded )
        return( E_UNEXPECTED );

    else if( sizeof(_PersistentState) > cbSize )
        return( E_INVALIDARG );

    else if( ( (LinkTrackPersistentState*) pvMem )->clsid != IID_ITrackFile )
        return( E_INVALIDARG );

    else if( ( (LinkTrackPersistentState*) pvMem )->cbSize < sizeof(_PersistentState) )
        return( E_INVALIDARG );

    else
    {
        _PersistentState = *(LinkTrackPersistentState*) pvMem;
        _fLoaded = TRUE;
        return( S_OK );
    }
        
}


//+----------------------------------------------------------------------------
//
//  Method:     Save(IPersistMemory)
//
//  Synopsis:   Save the persistent state to a memory buffer.
//
//  Arguments:  [pvMem]
//                  The buffer to which we'll save.
//              [fClearDirty]
//                  TRUE => we'll set _fDirty to FALSE on a successful save.
//              [cbSize]
//                  The available buffer in pvMem.
//
//  Returns:    HRESULT
//
//+----------------------------------------------------------------------------

STDMETHODIMP
CTrackFile::Save( void* pvMem, BOOL fClearDirty, ULONG cbSize )
{
    if( NULL == pvMem )
        return( E_POINTER );

    else if( !_fLoaded )
        return( E_UNEXPECTED );

    else if( sizeof(_PersistentState) > cbSize )
        return( E_INVALIDARG );

    else
    {
        *(LinkTrackPersistentState*) pvMem = _PersistentState;

        if( fClearDirty )
            _fDirty = FALSE;

        return( S_OK );
    }
}


//+----------------------------------------------------------------------------
//
//  Method:     InitNew
//
//  Synopsis:   Initialize the TrackFile object.
//
//  Arguments:  None
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

STDMETHODIMP
CTrackFile::InitNew()
{
    if( _fLoaded )
        return( E_UNEXPECTED );
    else
    {
        memset( &_PersistentState, 0, sizeof(_PersistentState) );
        _PersistentState.cbSize = sizeof(_PersistentState);
        _PersistentState.clsid = IID_ITrackFile;
        _fLoaded = TRUE;
        return( S_OK );
    }
}


//+----------------------------------------------------------------------------
//
//  Method:     GetSizeMax (IPersistMemory)
//
//  Synopsis:   Returns the size necessary to pass to IPersist:Save
//
//  Arguments:  [pcbSize]
//
//  Returns:    HRESULT
//
//+----------------------------------------------------------------------------

STDMETHODIMP
CTrackFile::GetSizeMax( ULONG *pcbSize )
{
    if( NULL == pcbSize )
        return( E_POINTER );
    else
    {
        *pcbSize = sizeof(_PersistentState);
        return( S_OK );
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     GetSizeMax (IPersistStreamInit)
//
//  Synopsis:   Returns the size necessary.
//
//  Arguments:  [pcbSize]
//
//  Returns:    HRESULT
//
//+----------------------------------------------------------------------------

STDMETHODIMP
CTrackFile::GetSizeMax( ULARGE_INTEGER* pcbSize )
{
    if( NULL == pcbSize )
        return( E_POINTER );
    else
    {
        pcbSize->QuadPart = sizeof(_PersistentState);
        return( S_OK );
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     Load (IPersistStreamInit)
//
//  Synopsis:   Load the TrackFile object from a stream.
//
//  Arguments:  [pStm]
//                  Points to the IStream interface.
//  
//  Returns:    HRESULT
//
//+----------------------------------------------------------------------------

STDMETHODIMP
CTrackFile::Load(IStream* pStm)
{
    HRESULT                     hr;                     // return value
    LinkTrackPersistentState    PersistentState;        // tmp storage
    ULONG                       cbRead;                 // # of bytes read
    LARGE_INTEGER               cbOffset;               // = -cbRead
    ULONG                       cbSize = sizeof(_PersistentState);

    if(NULL == pStm)
        return(E_POINTER);

    else if(_fLoaded)
        return(E_UNEXPECTED);

    // Read _PersistentState from the stream and check if the read is
    // successful. If not, revert back the seek pointer in pStm, and
    // return the HRESULT.
    hr = pStm->Read((byte*)&PersistentState, cbSize, &cbRead);
    if(FAILED(hr) || cbSize != cbRead)
    {
        cbOffset.QuadPart = -static_cast<LONGLONG>(cbRead);
        goto Exit;
    }

    // So now we successfully read the _PersistentState into memory, check to
    // see if we read garbage. If so, revert and return the error.
    // xxx What error message should be returned for this?
    if(PersistentState.clsid != IID_ITrackFile)
    {
        cbOffset.QuadPart = -static_cast<LONGLONG>(cbRead);
        hr = E_FAIL;
        goto Exit;
    }

    // Everything went well. Now we can copy _PersistentState from its
    // temporary storage to its real storage.
    _PersistentState = PersistentState;
    _fLoaded = TRUE;
    return(S_OK);

Exit:
        
    pStm->Seek(cbOffset, STREAM_SEEK_CUR, NULL);
    return(hr);
}

//+----------------------------------------------------------------------------
//
//  Method:     Save (IPersistStreamInit)
//
//  Synopsis:   Save the persistent state to a stream.
//
//  Arguments:  [pStm]
//                  The IStream interface we use to save.
//              [fClearDirty]
//                  TRUE => we'll set _fDirty to FALSE on a successful save.
//
//  Returns:    HRESULT
//
//+----------------------------------------------------------------------------

STDMETHODIMP
CTrackFile::Save(IStream* pStm, BOOL fClearDirty)
{
    HRESULT         hr;
    ULONG           cbSize = sizeof(_PersistentState);
    ULONG           cbWritten;                          // # of bytes written
    LARGE_INTEGER   cbOffset;                           // same as cbWritten

    if(NULL == pStm)
        return(E_POINTER);

    else if( !_fLoaded )
        return(E_UNEXPECTED);

    else
    {
        // Write the _PersistentState to the stream and check the return value.
        // If failed, revert the changes in IStream and return the HRESULT.
        hr = pStm->Write((byte*)&_PersistentState, cbSize, &cbWritten);
        if(FAILED(hr))
        {
            cbOffset.QuadPart = -static_cast<LONGLONG>(cbWritten);
            pStm->Seek(cbOffset, STREAM_SEEK_CUR, NULL);
            return hr;
        }

        if(fClearDirty)
            _fDirty = FALSE;

        return(S_OK);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkstub\stub_trkwks_s.c ===
// Copyright (c) 1996-1999 Microsoft Corporation


#include <windows.h>
#include <rpc.h>
#include <rpcasync.h>
#include "trkwks_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkcom\cfactory.cxx ===
#include <pch.cxx>
#pragma hdrstop
#include "trkcom.hxx"

const TCHAR tszKeyNameLinkTrack[] = TEXT("System\\CurrentControlSet\\Services\\TrkWks\\Parameters");

long    g_cDllRefs = 0;

#if DBG
DWORD g_Debug = TRKDBG_ERROR;
CTrkConfiguration g_config;
#endif

EXTERN_C int APIENTRY DllMain (HINSTANCE hInstance,
                               DWORD dwReason, 
                               LPVOID lpReserved)
{
    if( DLL_PROCESS_ATTACH == dwReason )
    {
#if DBG
        g_config.Initialize( );
        g_Debug = g_config._dwDebugFlags;
#endif
        TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG, "TrkCom" );
        InterlockedIncrement( &g_cDllRefs );
    }

    else if( DLL_PROCESS_DETACH == dwReason )
        InterlockedDecrement( &g_cDllRefs );

    return TRUE;
}

STDAPI DllCanUnloadNow (void)
{
    return ResultFromScode( (0 == g_cDllRefs) ? S_OK : S_FALSE );
}


EXTERN_C STDAPI DllGetClassObject (REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    *ppv = NULL;

    if (!IsEqualCLSID (rclsid, CLSID_TrackFile))
        return ResultFromScode (CLASS_E_CLASSNOTAVAILABLE);
        
    CClassFactory *pClassFactory = new CClassFactory ();

    if (pClassFactory == NULL)
        return ResultFromScode (E_OUTOFMEMORY);

    HRESULT hr = pClassFactory->QueryInterface (riid, ppv);
    pClassFactory->Release ();
    return hr;
}



STDMETHODIMP
CClassFactory::QueryInterface( REFIID riid, void **ppvObject )
{
    IUnknown *pUnk = NULL;

    if( riid == IID_IUnknown
        ||
        riid == IID_IClassFactory
      )
    {
        pUnk = this;
    }

    if( pUnk != NULL )
    {
        pUnk->AddRef();
        *ppvObject = pUnk;
        return S_OK;
    }

    *ppvObject = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CClassFactory::AddRef( void )
{
    long cNew;
    cNew = InterlockedIncrement( &_cRefs );
    return( cNew );
}


STDMETHODIMP_(ULONG)
CClassFactory::Release( void )
{
    long cNew;
    cNew = InterlockedDecrement( &_cRefs );

    if( 0 == cNew )
        delete this;

    return( cNew >= 0 ? cNew : 0 );
}


STDMETHODIMP
CClassFactory::CreateInstance( IUnknown *pUnkOuter,
                               REFIID riid,
                               void **ppvObject )
{
    CTrackFile *pObj = NULL;

    if( pUnkOuter != NULL )
    {
        return( CLASS_E_NOAGGREGATION );
    }

    pObj = (CTrackFile*) new CTrackFile( );
    if( pObj == NULL )
    {
        return( E_OUTOFMEMORY );
    }

    return pObj->QueryInterface( riid, ppvObject );
}


STDMETHODIMP
CClassFactory::LockServer( BOOL fLock )
{
    if( fLock )
        AddRef();
    else
        Release();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trksvr\crossdom.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       crossdom.cxx
//
//  Contents:   Cross-domain table.
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include "trksvr.hxx"

void
CCrossDomainTable::Initialize()
{
    _fInitializeCalled = TRUE;
}

void
CCrossDomainTable::UnInitialize()
{
    _fInitializeCalled = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkstub\trkstub.cxx ===
#include <pch.cxx>
#pragma hdrstop

#define TRKDATA_ALLOCATE
#include "trklib.hxx"
#include "trkwks.hxx"
#include "trkstub.h"

extern "C"
NTSTATUS
WINAPI
StartTrkWksServiceStubs( 
     PSVCS_START_RPC_SERVER RpcpStartRpcServer,
     LPTSTR SvcsRpcPipeName
    )
{
    NTSTATUS dwStatus = STATUS_SUCCESS;

    dwStatus = RpcpStartRpcServer(
                        SvcsRpcPipeName,
                        Stubtrkwks_v1_2_s_ifspec
                        );

    if(NT_SUCCESS(dwStatus))
    {
        dwStatus = RpcpStartRpcServer(
                    SvcsRpcPipeName,
                    Stubtrkwks_v1_2_s_ifspec
                    );
    }

    return dwStatus;
}


extern "C"
NTSTATUS
WINAPI
StopTrkWksServiceStubs( 
    PSVCS_STOP_RPC_SERVER RpcpStopRpcServer
    )

{

    NTSTATUS dwStatus = STATUS_SUCCESS;

    RpcpStopRpcServer(
                        Stubtrkwks_v1_2_s_ifspec
                        );

    dwStatus = RpcpStopRpcServer(
                        Stubtrkwks_v1_2_s_ifspec
                        );
    return dwStatus;
}

HRESULT
GetBinding( const TCHAR *ptszProtSeq,
            const TCHAR *ptszEndPoint,
            RPC_BINDING_HANDLE *phBinding )
{
    WCHAR *pwszStringBinding = NULL;
    HRESULT hr = E_FAIL;
    RPC_STATUS rpcstatus;

    rpcstatus = RpcStringBindingCompose( NULL,
                                         const_cast<TCHAR*>(ptszProtSeq),
                                         NULL,
                                         const_cast<TCHAR*>(ptszEndPoint),
                                         NULL,
                                         &pwszStringBinding);
    if( RPC_S_OK != rpcstatus )
    {
        hr = rpcstatus;
        goto Exit;
    }

    rpcstatus = RpcBindingFromStringBinding( pwszStringBinding, phBinding );
    if( RPC_S_OK != rpcstatus )
    {
        hr = rpcstatus;
        goto Exit;
    }

    hr = S_OK;

Exit:

    if( NULL != pwszStringBinding )
    {
        RpcStringFree( &pwszStringBinding );
        pwszStringBinding = NULL;
    }

    return hr;
}




HRESULT StubLnkSearchMachine(RPC_BINDING_HANDLE          IDL_handle,
                             ULONG                       RestrictionsIn,
                             const CDomainRelativeObjId *pdroidBirthLast,
                             const CDomainRelativeObjId *pdroidLast,
                             CDomainRelativeObjId       *pdroidBirthNext,
                             CDomainRelativeObjId       *pdroidNext,
                             CMachineId                 *pmcidNext,
                             TCHAR                      *ptsz )
{
    HRESULT hr;
    RPC_STATUS  rpcstatus;
    RPC_BINDING_HANDLE  hBinding = NULL;
    BOOL fImpersonating = FALSE;

    hr = GetBinding( s_tszTrkWksRemoteRpcProtocol,
                     s_tszTrkWksRemoteRpcEndPoint,
                     &hBinding );
    if( FAILED(hr) ) goto Exit;

    rpcstatus = RpcImpersonateClient( IDL_handle );
    if( STATUS_SUCCESS != rpcstatus )
    {
        hr = HRESULT_FROM_WIN32( rpcstatus );
        goto Exit;
    }
    fImpersonating = TRUE;

    __try
    {

        hr = LnkSearchMachine( hBinding,
                               RestrictionsIn,
                               pdroidBirthLast,
                               pdroidLast,
                               pdroidBirthNext,
                               pdroidNext,
                               pmcidNext,
                               ptsz );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = GetExceptionCode();
    }

Exit:

    if( fImpersonating )
    {
        RpcRevertToSelf();
    }

    if( NULL != hBinding )
    {
        RpcBindingFree( &hBinding );
        hBinding = NULL;
    }

    return hr;

}

HRESULT StubLnkCallSvrMessage(
    /* [in] */ handle_t IDL_handle,
    /* [switch_is][out][in] */ TRKSVR_MESSAGE_UNION __RPC_FAR *pMsg)
{
    HRESULT hr;
    RPC_STATUS rpcstatus;
    RPC_BINDING_HANDLE hBinding = NULL;
    BOOL fImpersonating = FALSE;

    hr = GetBinding( s_tszTrkWksRemoteRpcProtocol,
                     s_tszTrkWksRemoteRpcEndPoint,
                     &hBinding );
    if( FAILED(hr) ) goto Exit;

    rpcstatus = RpcImpersonateClient( IDL_handle );
    if( STATUS_SUCCESS != rpcstatus )
    {
        hr = HRESULT_FROM_WIN32( rpcstatus );
        goto Exit;
    }
    fImpersonating = TRUE;

    __try
    {
        hr = LnkCallSvrMessage( hBinding, pMsg );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = GetExceptionCode();
    }


Exit:

    if( fImpersonating )
    {
        RpcRevertToSelf();
    }

    if( NULL != hBinding )
    {
        RpcBindingFree( &hBinding );
        hBinding = NULL;
    }

    return hr;
}


void
StubLnkMendLink(PRPC_ASYNC_STATE            pAsync_handle,
                RPC_BINDING_HANDLE          IDL_handle,
                FILETIME                    ftLimit,
                DWORD                       RestrictionsIn,
                const CDomainRelativeObjId *pdroidBirth,
                const CDomainRelativeObjId *pdroidLast,
                const CMachineId *          pmcidLast,
                CDomainRelativeObjId *      pdroidCurrent,
                CMachineId *                pmcidCurrent,
                ULONG *                     pcbPath,
                WCHAR *                     wsz)
{
    HRESULT hr;
    RPC_STATUS  rpcstatus;
    RPC_BINDING_HANDLE  hBinding = NULL;
    BOOL fImpersonating = FALSE;
    RPC_ASYNC_STATE  RpcAsyncState;
    HANDLE hEvent = NULL;

    hr = GetBinding( s_tszTrkWksLocalRpcProtocol,
                     s_tszTrkWksLocalRpcEndPoint,
                     &hBinding );
    if( FAILED(hr) ) goto Exit;

    rpcstatus = RpcImpersonateClient( IDL_handle );
    if( STATUS_SUCCESS != rpcstatus )
    {
        hr = HRESULT_FROM_WIN32( rpcstatus );
        goto Exit;
    }
    fImpersonating = TRUE;

    __try
    {
        DWORD dwWaitReturn;

        rpcstatus = RpcAsyncInitializeHandle( &RpcAsyncState, RPC_ASYNC_VERSION_1_0 );
        if ( RPC_S_OK != rpcstatus )
        {
            hr = HRESULT_FROM_WIN32( rpcstatus );
            __leave;
        }

        hEvent = CreateEvent( NULL, FALSE, FALSE, NULL ); // Auto-reset, not initially signaled
        if( NULL == hEvent )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            __leave;
        }


        RpcAsyncState.NotificationType = RpcNotificationTypeEvent;
        RpcAsyncState.u.hEvent = hEvent;
        RpcAsyncState.UserInfo = NULL;

        LnkMendLink( &RpcAsyncState,
                     hBinding,
                     ftLimit,
                     RestrictionsIn,
                     pdroidBirth,
                     pdroidLast,
                     pmcidLast,
                     pdroidCurrent,
                     pmcidCurrent,
                     pcbPath,
                     wsz );


        dwWaitReturn = WaitForSingleObject( hEvent, INFINITE );
        if ( WAIT_OBJECT_0 != dwWaitReturn )
        {
            // There was an error of some kind.
            hr = HRESULT_FROM_WIN32( GetLastError() );
            __leave;
        }

        // Now we find out how the LnkMendLink call completed.  If we get
        // RPC_S_OK, then it completed normally, and the result is
        // in hr.

        rpcstatus = RpcAsyncCompleteCall( &RpcAsyncState, &hr );
        if ( RPC_S_OK != rpcstatus )
        {
            // The call either failed or was cancelled (the reason for the
            // cancel would be that the UI thread called CTracker::CancelSearch,
            // or because we timed out above and called RpcAsyncCancelCall).

            hr = HRESULT_FROM_WIN32(rpcstatus);
            __leave;
        }

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = GetExceptionCode();
    }

Exit:

    if( NULL != hEvent )
    {
        CloseHandle( hEvent );
        hEvent = NULL;
    }
    
    if( fImpersonating )
    {
        RpcRevertToSelf();
    }

    if( NULL != hBinding )
    {
        RpcBindingFree( &hBinding );
        hBinding = NULL;
    }

    if( NULL != pAsync_handle )
    {
        HRESULT hrT = RpcAsyncCompleteCall( pAsync_handle, &hr );
    }
}


HRESULT Stubold_LnkMendLink(
    /* [in] */ handle_t IDL_handle,
    /* [in] */ FILETIME ftLimit,
    /* [in] */ ULONG Restrictions,
    /* [in] */ const CDomainRelativeObjId __RPC_FAR *pdroidBirth,
    /* [in] */ const CDomainRelativeObjId __RPC_FAR *pdroidLast,
    /* [out] */ CDomainRelativeObjId __RPC_FAR *pdroidCurrent,
    /* [string][out] */ WCHAR __RPC_FAR wsz[ MAX_PATH + 1 ] )
{
    return E_NOTIMPL;
}

HRESULT Stubold2_LnkSearchMachine(  RPC_BINDING_HANDLE           IDL_handle,
                                    ULONG                        RestrictionsIn,
                                    const CDomainRelativeObjId  *pdroidLast,
                                    CDomainRelativeObjId        *pdroidNext,
                                    CMachineId                  *pmcidNext,
                                    TCHAR                       *tsz )
{
    return E_NOTIMPL;
}

HRESULT Stubold_LnkSearchMachine(
    /* [in] */ handle_t IDL_handle,
    /* [in] */ ULONG Restrictions,
    /* [in] */ const CDomainRelativeObjId __RPC_FAR *pdroidLast,
    /* [out] */ CDomainRelativeObjId __RPC_FAR *pdroidReferral,
    /* [string][out] */ TCHAR __RPC_FAR tsz[ MAX_PATH + 1 ])
{
    return E_NOTIMPL;
}

HRESULT
StubLnkGetBackup(
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ DWORD __RPC_FAR *pcVolumes,
    /* [size_is][size_is][out] */ VolumeMapEntry __RPC_FAR *__RPC_FAR *ppVolumeChanges,
    /* [out] */ FILETIME __RPC_FAR *pft)
{
    return E_NOTIMPL;
}

HRESULT
StubGetFileTrackingInformation( RPC_BINDING_HANDLE IDL_handle,
                                /*[in]*/ CDomainRelativeObjId droidCurrent,
                                /*[in]*/ TrkInfoScope scope,
                                /*[out]*/ TRK_FILE_TRACKING_INFORMATION_PIPE pipeFileInfo )
{
    return E_NOTIMPL;
}

HRESULT
StubGetVolumeTrackingInformation( RPC_BINDING_HANDLE IDL_handle,
                                  /*[in]*/ CVolumeId volid,
                                  /*[in]*/ TrkInfoScope scope,
                                  /*[out]*/ TRK_VOLUME_TRACKING_INFORMATION_PIPE pipeVolInfo )
{
    return E_NOTIMPL;
}

HRESULT StubLnkRestartDcSynchronization(
    RPC_BINDING_HANDLE IDL_handle
    )
{
    return E_NOTIMPL;
}


HRESULT StubLnkSetVolumeId(
    handle_t IDL_handle,
    ULONG iVolume,
    const CVolumeId VolId)
{
    RPC_STATUS rpcstatus;
    RPC_BINDING_HANDLE hBinding = NULL;
    HRESULT hr = E_FAIL;
    BOOL fImpersonating = FALSE;

    hr = GetBinding( s_tszTrkWksRemoteRpcProtocol,
                     s_tszTrkWksRemoteRpcEndPoint,
                     &hBinding );
    if( FAILED(hr) ) goto Exit;

    rpcstatus = RpcImpersonateClient( IDL_handle );
    if( STATUS_SUCCESS != rpcstatus )
    {
        hr = HRESULT_FROM_WIN32( rpcstatus );
        goto Exit;
    }
    fImpersonating = TRUE;

    __try
    {
        hr = LnkSetVolumeId( hBinding, iVolume, VolId );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = GetExceptionCode();
    }

Exit:

    if( fImpersonating )
    {
        RpcRevertToSelf();
    }

    if( NULL != hBinding )
    {
        RpcBindingFree( &hBinding );
        hBinding = NULL;
    }

    return hr;
}

HRESULT
StubTriggerVolumeClaims(          RPC_BINDING_HANDLE IDL_handle,
                         /*[in]*/ ULONG cVolumes,
                         /*[in]*/ const CVolumeId *rgvolid )
{
    return E_NOTIMPL;
}


HRESULT StubLnkOnRestore(/*[in]*/ RPC_BINDING_HANDLE IDL_handle)
{
    return E_NOTIMPL;
}

HRESULT Stubold_LnkCallSvrMessage(
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ TRKSVR_MESSAGE_UNION_OLD __RPC_FAR *pMsg)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trksvr\denial.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       denial.cxx
//
//  Contents:   Code to detect denial of service attacks.
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop
#include "trksvr.hxx"

#define MAX_HISTORY_PERIODS     8   // best to make this a power of two for easy division
#define HISTORY_PERIOD          10  // seconds
#define MAX_MOVING_AVERAGE      20  // 20 notifications per HISTORY_PERIOD

struct ACTIVECLIENT
{
    ACTIVECLIENT(const CMachineId & mcidClient) : _mcidClient(mcidClient)
    {
        _pNextClient = NULL;
        memset(_aRequestHistory, 0, sizeof(_aRequestHistory));
        _iWrite = 0;
        _cNonZero = 0;
    }

    inline void     CountEvent();
    inline BOOL     IsActive();
    inline void     NewPeriod();
    ULONG           Average();

    struct ACTIVECLIENT *  _pNextClient;
    CMachineId             _mcidClient;
    ULONG                  _aRequestHistory[MAX_HISTORY_PERIODS];
    ULONG                  _iWrite;
    ULONG                  _cNonZero;
};


void
CDenialChecker::Initialize( ULONG ulHistoryPeriod )
{

    _cs.Initialize();
    _fInitializeCalled = TRUE;
    _pListHead = NULL;

#if DBG
    _lAllocs = 0;
#endif


    _timer.Initialize(this,
                      NULL,         // No name (non-persistent)
                      0,            // Context ID
                      ulHistoryPeriod,
                      CNewTimer::NO_RETRY,
                      0, 0, 0 );

}

// must be called after the worker thread has exitted
// RPC server stopped already

void
CDenialChecker::UnInitialize()
{
    if (_fInitializeCalled)
    {
        _fInitializeCalled = FALSE;

        _timer.UnInitialize();
        _cs.UnInitialize();

        ACTIVECLIENT * pDel = _pListHead;

        while (pDel)
        {
            ACTIVECLIENT * pNext = pDel->_pNextClient;

            delete pDel;
#if DBG
            _lAllocs--;
#endif
            pDel = pNext;
        }
        TrkLog((TRKDBG_DENIAL, TEXT("CDenialChecker::UnInitialize _lAllocs = %d"), _lAllocs));
    }
}

void
CDenialChecker::CheckClient(const CMachineId & mcidClient)
{

    __try
    {
        _cs.Enter();

        ACTIVECLIENT * pSearch = _pListHead;
        ACTIVECLIENT * pPrevious = NULL;

        while (pSearch)
        {
            if (pSearch->_mcidClient == mcidClient)
            {
                // move to head of list so that we can quickly find the abuser
                // next time
                if ( pSearch != _pListHead )
                {
                    TrkAssert(pPrevious != NULL);
                    pPrevious->_pNextClient = pSearch->_pNextClient;
                    pSearch->_pNextClient = _pListHead;
                    _pListHead = pSearch;
                }
    
                pSearch->CountEvent();
                if (pSearch->Average() > MAX_MOVING_AVERAGE)
                {
                    TrkRaiseException(TRK_E_DENIAL_OF_SERVICE_ATTACK);
                }
                break;
            }

            pPrevious = pSearch;
            pSearch = pSearch->_pNextClient;
        }

        if (pSearch == NULL)
        {
            ACTIVECLIENT * pNew = new ACTIVECLIENT(mcidClient);

            TrkLog(( TRKDBG_DENIAL, TEXT("Adding to denial list (%d)"), _lAllocs+1 ));


            if (!pNew)
            {
                TrkRaiseWin32Error(ERROR_NOT_ENOUGH_MEMORY);
            }
#if DBG
            _lAllocs++;
#endif

            // If the list had gone empty, then the timer was stopped,
            // so start it back up again.

            if( NULL == _pListHead )
            {
                TrkLog(( TRKDBG_DENIAL, TEXT("Starting denial-checker timer") ));
                _timer.SetRecurring();
            }

            pNew->_pNextClient = _pListHead;
            _pListHead = pNew;
        }
    }
    __finally
    {
        _cs.Leave();
    }
}

PTimerCallback::TimerContinuation
CDenialChecker::Timer( ULONG ulTimerId )
{
    //
    // periodically increment iWrite in each entry
    // and throw out entries that are now too old
    // (this is when all counters go to zero i.e.
    // no activity for MAX_HISTORY_PERIODS periods)

    _cs.Enter();

    ACTIVECLIENT * pSearch = _pListHead;
    ACTIVECLIENT * pPrevious = NULL;
    TimerContinuation continuation = CONTINUE_TIMER;

    while (pSearch)
    {
        pSearch->NewPeriod();
        if (!pSearch->IsActive())
        {
            // remove from list and free
            ACTIVECLIENT * pNext = pSearch->_pNextClient;

            TrkLog(( TRKDBG_DENIAL, TEXT("Paring denial list (%d)"), _lAllocs-1 ));

            if (pPrevious)
            {
                pPrevious->_pNextClient = pNext;
            }
            else
            {
                _pListHead = pNext;
            }
            delete pSearch;
#if DBG
            _lAllocs--;
#endif
            pSearch = pNext;
        }
        else
        {
            pPrevious = pSearch;
            pSearch = pSearch->_pNextClient;
        }
    }

    if( NULL == _pListHead )
    {
        TrkLog(( TRKDBG_DENIAL, TEXT("Stopping denial checker timer") ));
        continuation = BREAK_TIMER;
    }

    _cs.Leave();

    //TrkLog((TRKDBG_DENIAL, TEXT("CDenialChecker: SimpleTimer _lAllocs = %d"), _lAllocs));

    TrkAssert( CNewTimer::NO_RETRY == _timer.GetRetryType() );
    TrkAssert( _timer.IsRecurring() );

    return( continuation );
}

inline void
ACTIVECLIENT::CountEvent()
{
    _aRequestHistory[_iWrite] ++;
    if (_aRequestHistory[_iWrite] == 1)
    {
        TrkAssert(_cNonZero < MAX_HISTORY_PERIODS);
        _cNonZero ++;
    }
}

// returns FALSE if we should discard this ACTIVECLIENT

inline void
ACTIVECLIENT::NewPeriod()
{
    // skip the write pointer to next
    if (_iWrite >= sizeof(_aRequestHistory)/sizeof(_aRequestHistory[0]))
        _iWrite = 0;
    else
        _iWrite ++;

    // if what we're writing over is not zero, then keep track of # of zero entries
    if (_aRequestHistory[_iWrite] != 0)
    {
        TrkAssert(_cNonZero != 0);
        _cNonZero --;
    }

    _aRequestHistory[_iWrite] = 0;

}

inline BOOL
ACTIVECLIENT::IsActive()
{
    return(_cNonZero != 0);
}

inline ULONG
ACTIVECLIENT::Average()
{
    ULONG Sum=0;
    for ( ULONG i=0; i<MAX_HISTORY_PERIODS; i++ )
        Sum += _aRequestHistory[i];
    return(Sum / MAX_HISTORY_PERIODS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trksvr\makefile.inc ===
trksvr_s.c : $(BASEDIR)\private\genx\types\tracking\idl\trksvr_s.c
   copy $? $@

clean:
   -del /q /f $(NTTARGETFILE0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trksvr\intradom.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       intradom.cxx
//
//  Contents:   Intra-domain table.
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include "trksvr.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trksvr\dbconn.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       dbconn.cxx
//
//  Contents:   Shared database initialization code.
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "trksvr.hxx"

// LDAP version
void
CDbConnection::Initialize(CSvcCtrlInterface * psvc, OPTIONAL const TCHAR *ptszHostName )
{
    int err;
    LDAPMessage *pRes = NULL;
    TCHAR ** ppszNamingContexts = NULL;
    int tries = 0;
    TCHAR tszLocalHostName[ MAX_COMPUTERNAME_LENGTH + 1 ];

    _fInitializeCalled = TRUE;
    _pszBaseDn = NULL;

    __try
    {
        if( NULL == ptszHostName )
        {
            CMachineId(MCID_LOCAL).GetName( tszLocalHostName, ELEMENTS(tszLocalHostName) );
            ptszHostName = tszLocalHostName;
        }

        TrkLog((TRKDBG_SVR, TEXT("ldap_init(%s, LDAP_PORT)"), ptszHostName ));
        _pldap = ldap_init( const_cast<TCHAR*>(ptszHostName), LDAP_PORT);
        if( NULL == _pldap )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("CDbConnection failed ldap_init (%lu)"),
                     GetLastError() ));
            TrkRaiseLastError();
        }

        // Set the option telling LDAP that we gave it an explicit DC name and
        // that it can avoid the DsGetDcName.

        LONG LdapOption = PtrToLong(LDAP_OPT_ON);
        err = ldap_set_optionW( _pldap, LDAP_OPT_AREC_EXCLUSIVE, &LdapOption );
        if( LDAP_SUCCESS != err  )
        {
            TrkLog(( TRKDBG_ERROR,
                     TEXT("Failed ldap_set_option (LDAP_OPT_AREC_EXCLUSIVE) - %ld"),
                     err ));
            TrkRaiseException( LdapMapErrorToWin32(err) );
        }
    
        // Note:  This method used to do an ldap_open, but that function has been
        // deprecated.  The problem in NT5, was that during bootup call to ldap_open
        // the DS occasionally wasn't yet available.  Thus the logic below was added
        // to do retries.
        // Really, all of this code should go away except for the ldap_init, since
        // ldap_connect is called implicitely by all the ldap apis.  But to minimize
        // the risk, the code has been left basically unchanged, other than using
        // ldap_init/ldap_connect rather than ldap_open.  If this code needs to be
        // modified at any point, it should be reworked to remove the ldap_connect.

        LDAP_TIMEVAL Timeout;
        Timeout.tv_sec = 2;
        Timeout.tv_usec = 0;

retry:

        err = ldap_connect( _pldap, &Timeout );
        if( LDAP_SUCCESS != err )
        {
            if (tries++ < 10)
            {
                TrkLog((TRKDBG_ERROR, TEXT("ldap_open returned NULL, now sleeping...")));
                if (psvc != NULL)
                    psvc->UpdateWaitHint(30000);
                goto retry;
            }

            TrkLog((TRKDBG_ERROR, TEXT("CDbConnection::Initialize() - failed :-(")));
            TrkRaiseLastError( );
        }


        // search to get default base DN
    
        err = ldap_bind_s(_pldap,
                    NULL,       // DN of what ? system account object ?
                    NULL,       // we're running as system, so use our credentials
                    LDAP_AUTH_SSPI);
        if (err != LDAP_SUCCESS)
        {
            TrkLog((TRKDBG_ERROR, TEXT("CDbConnection::Initialize() - ldap_bind_s failed")));
            TrkRaiseWin32Error( LdapMapErrorToWin32(err) );
        }
    
        TCHAR *aszNamingContexts[2] = { TEXT("NamingContexts"), NULL };
    
        err = ldap_search_s(_pldap,
                      NULL, // searching of tree
                      LDAP_SCOPE_BASE,
                      TEXT("(objectclass=*)"),
                      aszNamingContexts,
                      0,
                      &pRes);
    
        if (err != LDAP_SUCCESS)
        {
            TrkLog((TRKDBG_ERROR, TEXT("CDbConnection::Initialize() - ldap_search_s failed (%lu)"), err ));
            TrkRaiseException( TRK_E_DB_CONNECT_ERROR );
        }
    
        if (ldap_count_entries(_pldap, pRes) == 0)
        {
            TrkLog((TRKDBG_ERROR, TEXT("CDbConnection::Initialize() - ldap_count_entries found no entries (%lu)"), err ));
            TrkRaiseException( TRK_E_DB_CONNECT_ERROR );
        }
    
        LDAPMessage * pEntry = ldap_first_entry(_pldap, pRes);
        if (pEntry == NULL)
        {
            TrkLog((TRKDBG_ERROR, TEXT("CDbConnection::Initialize() - ldap_first_entry failed (%lu)"), err ));
            TrkRaiseWin32Error(LdapMapErrorToWin32(_pldap->ld_errno));
        }

        int l;
        ppszNamingContexts = ldap_get_values(_pldap, pEntry, TEXT("NamingContexts"));
        if (ppszNamingContexts == NULL ||
            ppszNamingContexts[0] == NULL ||
            (l=_tcslen(ppszNamingContexts[0])) == 0)
        {
            TrkLog((TRKDBG_ERROR, TEXT("CDbConnection::Initialize() - couldn't find 'NamingContexts'")));
            TrkRaiseWin32Error(LdapMapErrorToWin32(_pldap->ld_errno));
        }

        for (int i=0; i<l-4; i++)
        {
            if (memcmp(&ppszNamingContexts[0][i],
                       TEXT("DC="),
                       3*sizeof(TCHAR)) == 0)
            {
                break;
            }
        }

        if (i == l-3)
        {
            TrkLog((TRKDBG_ERROR, TEXT("CDbConnection::Initialize() - couldn't find 'DC'")));
            TrkRaiseException( TRK_E_DB_CONNECT_ERROR );
        }

        _pszBaseDn = new TCHAR [l-i+1];
        if (_pszBaseDn == NULL)
        {
            TrkLog((TRKDBG_ERROR, TEXT("CDbConnection::Initialize() - out of memory")));
            TrkRaiseWin32Error(ERROR_NOT_ENOUGH_MEMORY);
        }

        _tcscpy(_pszBaseDn, &ppszNamingContexts[0][i]);
    }
    __finally
    {
        if (pRes)
            ldap_msgfree(pRes);
        if (ppszNamingContexts)
            ldap_value_free(ppszNamingContexts);
    }
}

void
CDbConnection::UnInitialize()
{
    if (_fInitializeCalled)
    {
        if (_pldap != NULL)
        {
            // There is no ldap_close.  Call ldap_unbind, even if ldap_bind
            // wasn't called.
            ldap_unbind( _pldap );
            _pldap = NULL;
        }

        if (_pszBaseDn)
        {
            delete [] _pszBaseDn;
            _pszBaseDn = NULL;
        }

        _fInitializeCalled = FALSE;
    }
}

LDAP *
CDbConnection::Ldap()
{
    // The critsec initialization may have failed.
    if( !_cs.IsInitialized() )
        _cs.Initialize();   // Raises on error

    _cs.Enter();

    if (!_fInitializeCalled)
    {
        __try
        {
            Initialize(NULL);
        }
        __finally
        {
            if (AbnormalTermination())
            {
                UnInitialize();
                _cs.Leave();
            }
        }
    }

    _cs.Leave();

    return(_pldap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trksvr\res.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

#ifndef NT_BUILD
#include <afxres.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trksvr\quota.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       quota.cxx
//
//  Contents:   quota table
//
//  Classes:
//
//  Functions:
//
//  Notes:      This table is hidden in the volume table
//
//  History:    18-Nov-97  WeiruC Created.
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "trksvr.hxx"
#include <commctrl.h>
#include <time.h>

CQuotaTable::CQuotaTable(CDbConnection& dbc) :
    _dbc(dbc),
#if DBG
    _cLocks(0),
#endif
    _mcid(MCID_LOCAL),
    _cftCacheLastUpdated(0),
    _cftDesignatedDc(0),
    _pvoltab(NULL)
{
    _fIsDesignatedDc = FALSE;
    _fInitializeCalled = FALSE;
    _fStopping = FALSE;
    _dwMoveLimit = 0;

    _lCachedMoveTableCount = _lCachedVolumeTableCount = 0;

}

CQuotaTable::~CQuotaTable()
{
    UnInitialize();
}

void
CQuotaTable::Initialize(CVolumeTable      *pvoltab,
                        CIntraDomainTable *pidt,
                        CTrkSvrSvc        *psvrsvc,
                        CTrkSvrConfiguration *pcfgsvr )
{
    CMachineId      mcid;
    HRESULT         hr;

    _cs.Initialize();
#if DBG
    _cLocks = 0;
#endif

    _fInitializeCalled = TRUE;

    _pvoltab = pvoltab;
    _pcfgsvr = pcfgsvr;
    _pidt = pidt;
    _psvrsvc = psvrsvc;

    _timer.Initialize(this,
                      TEXT("NextDcSyncTime"),   // Name (this is a persistent timer)
                      QUOTA_TIMER,                        // Context ID
                      _pcfgsvr->GetDcUpdateCounterPeriod(),  // Period
                      CNewTimer::NO_RETRY,
                      0, 0, 0 );                // Ignored for non-retrying timers
    _timer.SetRecurring();
    TrkLog(( TRKDBG_VOLUME, TEXT("DC sync timer: %s"),
             (const TCHAR*) CDebugString(_timer) ));


    // The Reset* routines assume that an entry already exists for
    // this DC. If the operation fails because the entry doesn't exist, it
    // will add the entry. We ignore any error because if we can't add
    // the entry it only means that we are not participating in the race
    // for the designated DC.
}

void
CQuotaTable::UnInitialize()
{
    if(_fInitializeCalled)
    {
        _timer.UnInitialize();
        _lCachedMoveTableCount = 0;
        _lCachedVolumeTableCount = 0;
        _cftCacheLastUpdated = CFILETIME(0);
        _cs.UnInitialize();
        _fInitializeCalled = FALSE;
    }
}


//+----------------------------------------------------------------------------
//
//  CQuotaTable::Timer
//
//  This method is called when _timer fires.  If we're the designated
//  DC, we'll go through the move table and count the uncounted entries, 
//  delete the deleted entries, and shorten any moves chains.
//
//+----------------------------------------------------------------------------

PTimerCallback::TimerContinuation
CQuotaTable::Timer(ULONG ulTimer)
{
    DWORD       dwTrueCount = 0;

    Lock();

    __try
    {
        TrkLog((TRKDBG_QUOTA, TEXT("DC synchronization time")));
        g_ptrksvr->RaiseIfStopped();

        TrkAssert( QUOTA_TIMER == ulTimer );

        if( QUOTA_TIMER == ulTimer )
        {
            if( IsDesignatedDc() )
            {
                GetTrueCount( &dwTrueCount, BACKGROUND );
                TrkLog((TRKDBG_QUOTA, TEXT("Updated counter")));
                _psvrsvc->_OperationLog.Add( COperationLog::TRKSVR_QUOTA, S_OK, CMachineId(MCID_INVALID), dwTrueCount );
            }
        }
    }
    __except( BreakOnDebuggableException() )
    {
        // This timer fires often enough that we'll just
        // wait until it fires again.
        TrkLog(( TRKDBG_WARNING,
                 TEXT("Ignoring exception in CQuotaTable::Timer (%08x)"),
                 GetExceptionCode() ));
        _psvrsvc->_OperationLog.Add( COperationLog::TRKSVR_QUOTA, GetExceptionCode() );
    }
    Unlock();

    TrkAssert( _timer.IsRecurring() );
    return( CONTINUE_TIMER );
}

BOOL
CQuotaTable::IsMoveQuotaExceeded()
{
    BOOL    fExceeded = TRUE;

    Lock();

    __try
    {
        ValidateCache();

        // Compare the cached counter with the limit.  The cached value should
        // never be negative.  But if for some reason it is, don't get confused by it
        // (i.e. bottom it out at zero).  The cached value will get automatically
        // corrected when the cache gets refreshed.

        if( (DWORD) max(0,_lCachedMoveTableCount) < _dwMoveLimit )
        {
            fExceeded = FALSE;
        }
        else
        {
            // Try to force the cache to be updated
            ValidateCache( TRUE );
            if( (DWORD) max(0,_lCachedMoveTableCount) < _dwMoveLimit)
            {
                fExceeded = FALSE;
            }
        }

        if(fExceeded)
        {
            TrkLog((TRKDBG_QUOTA, TEXT("*** Move table quota exceeded (%li/%lu)"), _lCachedMoveTableCount, _dwMoveLimit ));
        }
        else
        {
            TrkLog(( TRKDBG_QUOTA, TEXT("Move quota not exceeded (%li/%lu)"), _lCachedMoveTableCount, _dwMoveLimit ));
        }
    }
    __finally
    {
        Unlock();
    }

    return fExceeded;
}



//+----------------------------------------------------------------------------
//
//  CQuotaTable::IsVolumeQuotaExceeded
//
//  See if this machine is at or over its quota (it can go over in a replicated
//  environment).  The total number of
//  volumes it has is the count of DS entries for the machine, plus
//  cUncountedVolumes.  cUncountedVolumes is non-zero when a machine
//  sends up a request to create multiple volumes, and increments
//  as the service iterates through the requests.
//
//+----------------------------------------------------------------------------

BOOL
CQuotaTable::IsVolumeQuotaExceeded( const CMachineId& mcid, ULONG cUncountedVolumes )
{
    Lock();

    __try
    {
        // How many entries does this machine have in the DS?
        ULONG cVolumes = _pvoltab->CountVolumes(mcid);

        // Is it at/over quota?
        if( cVolumes + cUncountedVolumes >= _pcfgsvr->GetVolumeLimit() )
        {
            TrkLog((TRKDBG_QUOTA, TEXT("VOLUME QUOTA EXCEEDED for %s (%d+%d)"),
                    (const TCHAR*) CDebugString(mcid), 
                    cVolumes, cUncountedVolumes ));
            return TRUE;
        }
        else
            TrkLog(( TRKDBG_QUOTA, TEXT("Volume quota not exceeded for %s (%d+%d, %d)"),
                     (const TCHAR*) CDebugString(mcid), 
                     cVolumes, cUncountedVolumes, _pcfgsvr->GetVolumeLimit() ));
    }
    __finally
    {
        Unlock();
    }

    return FALSE;
}




//+----------------------------------------------------------------------------
//
//  ReadAttribute
//
//  Given an LDAP pointer, a DN, and an attribute name, read the attribute
//  for the entry with that DN.
//
//+----------------------------------------------------------------------------

int
ReadAttribute( LDAP* pldap, const TCHAR *ptszDN, const TCHAR *ptszAttributeName,
               TCHAR ***ppptszAttributeValue )
{
    int           ldapRV = 0;
    const TCHAR   *rgptszAttrs[] = { ptszAttributeName, NULL };
    int           cEntries = 0;
    LDAPMessage   *pRes = NULL;
    LDAPMessage   *pEntry = NULL;

    __try
    {
        ldapRV = ldap_search_s(pldap,
                               const_cast<TCHAR*>(ptszDN),
                               LDAP_SCOPE_BASE,
                               TEXT("(ObjectClass=*)"),
                               const_cast<TCHAR**>(rgptszAttrs),
                               0,
                               &pRes);
        if( LDAP_SUCCESS != ldapRV )
        {
            TrkLog(( TRKDBG_QUOTA, TEXT("Couldn't find %s (%lu)"), ptszDN, ldapRV ));
            __leave;
        }

        cEntries = ldap_count_entries(pldap, pRes);
        if( cEntries < 1 )
        {
            TrkLog(( TRKDBG_QUOTA, TEXT("No entries returned for %s in %s"), ptszAttributeName, ptszDN ));
            ldapRV = LDAP_NO_SUCH_OBJECT;
            __leave;
        }

        pEntry = ldap_first_entry(pldap, pRes);
        if(NULL == pEntry)
        {
            TrkLog(( TRKDBG_QUOTA, TEXT("Entries couldn't be read from result for %s"), ptszDN ));
            ldapRV = LDAP_NO_SUCH_OBJECT;
            __leave;
        }

        *ppptszAttributeValue = ldap_get_values(pldap, pEntry, const_cast<TCHAR*>(ptszAttributeName) );
        if( NULL == *ppptszAttributeValue )
        {
            TrkLog(( TRKDBG_QUOTA, TEXT("Couldn't find %s in %s"), ptszAttributeName, ptszDN ));
            ldapRV = LDAP_NO_SUCH_OBJECT;
            __leave;
        }
    }
    __finally
    {
        if(NULL != pRes)
        {
            ldap_msgfree(pRes);
        }
    }

    return( ldapRV );

}


//+----------------------------------------------------------------------------
//
//  CQuotaTable::IsDesignatedDc
//
//  Determine if this machine is the designated DC.  (The designated DC is
//  responsible for all modifications to link tracking data in the DS that
//  requires a single master).  The "RID Master" DC is used as the designated
//  DC.
//
//+----------------------------------------------------------------------------

BOOL
CQuotaTable::IsDesignatedDc( BOOL fRaiseOnError )
{
    BOOL          fSuccess = FALSE;
    BOOL          fDesignatedDc = FALSE;
    HRESULT       hr = E_FAIL;
    int           ldapRV = 0;
    int           cEntries = 0;
    TCHAR         **pptszRidManagerReference = NULL;
    TCHAR         **pptszRoleOwner = NULL;
    const TCHAR   *rgtszAttrs[] = { s_rIDManagerReference, NULL };
    TCHAR         *ptszDesignatedDC = NULL, *ptszAfterDesignatedDC = NULL;
    CMachineId    mcidDesignated, mcidLocal(MCID_LOCAL);
    CFILETIME     cftNow;
    LONGLONG      llDelta;

    // How old (in seconds) is the _fIsDesignatedDc value?

    llDelta = (LONGLONG) cftNow - (LONGLONG) _cftDesignatedDc;
    llDelta /= 10000000;
    if( llDelta < _pcfgsvr->GetDesignatedDcCacheTTL() )
    {
        // The cached value is young enough.
        //TrkLog(( TRKDBG_QUOTA, TEXT("Cache: %s designated DC"),
        //         _fIsDesignatedDc ? TEXT("is") : TEXT("isn't") ));
        return( _fIsDesignatedDc );
    }
    // The cached value is too old.  Recalculate.

    __try
    {
        // Read the "rIDManagerReference" from the root DC=<domain> object.

        ldapRV = ReadAttribute(Ldap(), GetBaseDn(), s_rIDManagerReference, &pptszRidManagerReference );

        if( LDAP_SUCCESS != ldapRV )
        {
            hr = HRESULT_FROM_WIN32( LdapMapErrorToWin32(ldapRV) );
            TrkLog(( TRKDBG_QUOTA, TEXT("Couldn't get RID manager reference (%lu)"), ldapRV ));
            __leave;
        }
        TrkLog(( TRKDBG_QUOTA, TEXT("RID manager reference: %s"), *pptszRidManagerReference ));

        // The value of the rIDManagerReference is a DN.  Read the "fSMORoleOwner" attribute
        // from that object.

        ldapRV = ReadAttribute( Ldap(), *pptszRidManagerReference, s_fSMORoleOwner, &pptszRoleOwner );
        if( LDAP_SUCCESS != ldapRV )
        {
            hr = HRESULT_FROM_WIN32( LdapMapErrorToWin32(ldapRV) );
            TrkLog(( TRKDBG_QUOTA, TEXT("Couldn't get RID role owner (%lu)"), ldapRV ));
            __leave;
        }
        TrkLog(( TRKDBG_QUOTA, TEXT("Role owner: %s"), *pptszRoleOwner ));


        // The role owner is of the form
        // "CN=NTDS Settings,CN=mikehill4,CN=Servers,CN=Default-FirstSite-Name,CN=Sites,CN=Configuration,DC=trkmikehill,DC=nttest,DC=microsoft,DC=com"
        // Pull out the DC's machine name by getting the second "CN=".

        ptszDesignatedDC = _tcsstr( *pptszRoleOwner, TEXT("CN=") );
        if( NULL == ptszDesignatedDC )
        {
            hr = HRESULT_FROM_WIN32( LdapMapErrorToWin32(LDAP_NO_SUCH_OBJECT) );
            TrkLog(( TRKDBG_QUOTA, TEXT("Couldn't find first component of FSMO role owner") ));
            __leave;
        }

        ptszDesignatedDC = _tcsstr( &ptszDesignatedDC[1], TEXT("CN=") );
        if( NULL == ptszDesignatedDC )
        {
            hr = HRESULT_FROM_WIN32( LdapMapErrorToWin32(LDAP_NO_SUCH_OBJECT) );
            TrkLog(( TRKDBG_QUOTA, TEXT("Couldn't find second component of FSMO role owner") ));
            __leave;
        }

        ptszDesignatedDC += 3;
        ptszAfterDesignatedDC = _tcsstr( ptszDesignatedDC, TEXT(",CN=") );
        if( NULL == ptszAfterDesignatedDC )
        {
            hr = HRESULT_FROM_WIN32( LdapMapErrorToWin32(LDAP_NO_SUCH_OBJECT) );
            TrkLog(( TRKDBG_QUOTA, TEXT("Couldn't find third component of FSMO role owner") ));
            __leave;
        }
        *ptszAfterDesignatedDC = TEXT('\0');

        // Are we the same (and therefore the designated) DC?

        mcidDesignated = CMachineId(ptszDesignatedDC );
        if( mcidDesignated == mcidLocal )
            fDesignatedDc = TRUE;

        TrkLog(( TRKDBG_QUOTA, TEXT("Designated DC is %s %s"), ptszDesignatedDC,
                 fDesignatedDc ? TEXT("(this DC)") : TEXT("") ));

        _fIsDesignatedDc = fDesignatedDc;
        _cftDesignatedDc = cftNow;

        fSuccess = TRUE;
    }
    __finally
    {
        if( NULL != pptszRidManagerReference )
            ldap_value_free( pptszRidManagerReference );

        if( NULL != pptszRoleOwner )
            ldap_value_free( pptszRoleOwner );
    }

    if( !fSuccess && fRaiseOnError )
        TrkRaiseException( hr );

    return( fDesignatedDc );
}

// Returns TRUE if successful, FALSE if entry doesn't exist, raise exception
// otherwise.
BOOL
CQuotaTable::ReadCounter(DWORD* pdwCounter)
{
    BOOL                    fSuccess = FALSE;
    struct berval**         ppbvCounter = NULL;
    TCHAR*                  rgtszAttrs[2];
    LDAPMessage*            pRes = NULL;
    int                     ldapRV;
    int                     cEntries = 0;
    LDAPMessage*            pEntry = NULL;
    CLdapQuotaCounterKeyDn  dnKeyCounter(GetBaseDn());

    __try
    {
        *pdwCounter = 0;
        rgtszAttrs[0] = const_cast<TCHAR*>(s_volumeSecret);
        rgtszAttrs[1] = NULL;
        ldapRV = ldap_search_s(Ldap(),
                               dnKeyCounter,
                               LDAP_SCOPE_BASE,
                               TEXT("(ObjectClass=*)"),
                               rgtszAttrs,
                               0,
                               &pRes);
        if( LDAP_NO_SUCH_OBJECT == ldapRV )
        {
            TrkLog(( TRKDBG_QUOTA, TEXT("Move table counter doesn't exist") ));
            __leave;
        }
        else if( LDAP_SUCCESS != ldapRV )
        {
            TrkLog(( TRKDBG_QUOTA, TEXT("Couldn't read move table counter (%d)"), ldapRV ));
            __leave;
        }

        cEntries = ldap_count_entries(Ldap(), pRes);
        if( cEntries != 1 )
        {
            // This should never happen, the counter has an explicit name.
            // We'll assume that when the designated DC does a WriteCounter, this
            // will be fixed.
            TrkLog(( TRKDBG_ERROR, TEXT("Too many move table counters!") ));
            __leave;
        }

        pEntry = ldap_first_entry(Ldap(), pRes);
        if(NULL == pEntry)
        {
            // This should also never happen, we already know the entry count for
            // this search result is 1.  Again assume that when the designated DC does
            // a WriteCounter, this will be fixed.
            TrkLog(( TRKDBG_ERROR, TEXT("Entries couldn't be read from result") ));
            __leave;
        }

        ppbvCounter = ldap_get_values_len(Ldap(), pEntry, const_cast<TCHAR*>(s_volumeSecret) );
        if (ppbvCounter == NULL)
        {
            // The designated DC will fix this in WriteCounter.
            TrkLog(( TRKDBG_ERROR, TEXT("Move table counter is corrupt, missing %s attribute"),
                     s_volumeSecret ));
            __leave;
        }

        if ((*ppbvCounter)->bv_len < sizeof(DWORD))
        {
            // The designated DC will fix this in WriteCounter
            TrkLog(( TRKDBG_ERROR, TEXT("Move table counter attribute %s has wrong type (%d)"),
                     s_volumeSecret, (*ppbvCounter)->bv_len ));
            __leave;
        }

        memcpy( (PCHAR)pdwCounter, (*ppbvCounter)->bv_val, sizeof(DWORD) );
        fSuccess = TRUE;
    }
    __finally
    {
        if(NULL != pRes)
        {
            ldap_msgfree(pRes);
        }
        if (ppbvCounter != NULL)
        {
            ldap_value_free_len(ppbvCounter);
        }
    }

    return fSuccess;
}



//+----------------------------------------------------------------------------
//
//  CQuotaTable::GetTrueCount
//
//  Update our cached count of the move table entries.  If we're the designated
//  DC, this will also clean up the move table: count uncounted entries, delete
//  deleted entries, and shorten any move chains.
//
//  This routine can be called to run in the background or foreground.  In the
//  background it does periodic sleeps so that we don't use up the CPU.
//
//+----------------------------------------------------------------------------

void
CQuotaTable::GetTrueCount( DWORD* pdwTrueCount,
                           EBackgroundForegroundTask eBackgroundForegroundTask )
{
    CLdapIdtKeyDn       dnKey(GetBaseDn());
    int                 ldapRV;
    TCHAR*              rgptszAttrs[3];
    TCHAR               ldapSearchFilter[256];
    DWORD               dwCounter = 0;
    BOOL                fDoWriteCounter = FALSE;
    BOOL                fNoExistingCounter = FALSE;
    TRUE_COUNT_ENUM_CONTEXT Context;

    __try
    {
        // Read the current counter.

        if( !ReadCounter( &dwCounter ) )
        {
            // There is no counter.  We'll enumerate everything.
            TrkLog(( TRKDBG_QUOTA, TEXT("Getting move table count") ));

            _tcscpy( ldapSearchFilter, TEXT("(ObjectClass=*)") );
            fDoWriteCounter = TRUE;
            Context.fCountAll = TRUE;
            fNoExistingCounter = TRUE;
        }
        else
        {
            // Only enumerate the uncounted and/or deleted entries.
            TrkLog(( TRKDBG_QUOTA, TEXT("Getting delta move table count") ));

            _tcscpy(ldapSearchFilter, TEXT("("));
            _tcscat(ldapSearchFilter, s_oMTIndxGuid);
            _tcscat(ldapSearchFilter, TEXT("=*"));
            _tcscat(ldapSearchFilter, TEXT(")"));
            Context.fCountAll = FALSE;
        }

        rgptszAttrs[0] = const_cast<TCHAR*>(s_currentLocation);
        rgptszAttrs[1] = const_cast<TCHAR*>(s_birthLocation);
        rgptszAttrs[2] = NULL;


        Context.cDelta = 0;
        Context.dwRepetitiveTaskDelay = (BACKGROUND == eBackgroundForegroundTask)
                                         ? _pcfgsvr->GetRepetitiveTaskDelay()
                                         : 0;
        Context.dwPass = Context.FIRST_PASS;

        // Enumerate the move table, subject to the search filter determined
        // above.

        if( !LdapEnumerate( Ldap(),
                            dnKey,
                            LDAP_SCOPE_ONELEVEL,
                            ldapSearchFilter,
                            rgptszAttrs,
                            MoveTableEnumCallback,
                            &Context,
                            this) )
        {
            TrkRaiseException(TRK_E_SERVICE_STOPPING);
        }

        // If we're the designated DC, we need to do a second pass.
        // The first pass may have done some string shortening,
        // and in the process marked some entries for delete.  We need to
        // go through now and remove those entries.

        if( IsDesignatedDc() )
        {
            TrkLog(( TRKDBG_QUOTA, TEXT("Getting delta move table count (pass 2)") ));
            Context.dwPass = Context.SECOND_PASS;

            // We only need to count the delta this time

            _tcscpy(ldapSearchFilter, TEXT("("));
            _tcscat(ldapSearchFilter, s_oMTIndxGuid);
            _tcscat(ldapSearchFilter, TEXT("=*"));
            _tcscat(ldapSearchFilter, TEXT(")"));
            Context.fCountAll = FALSE;

            if( !LdapEnumerate( Ldap(),
                                dnKey,
                                LDAP_SCOPE_ONELEVEL,
                                ldapSearchFilter,
                                rgptszAttrs,
                                MoveTableEnumCallback,
                                &Context,
                                this) )
            {
                TrkRaiseException(TRK_E_SERVICE_STOPPING);
            }
        }

        TrkLog((TRKDBG_QUOTA, TEXT("Uncounted entries ---- %d"), Context.cDelta));
        TrkLog((TRKDBG_QUOTA, TEXT("Counter ---- %d"), dwCounter));
    }
    __finally
    {
        if( Context.cDelta != 0 )
            fDoWriteCounter = TRUE;

        *pdwTrueCount = max( 0, (LONG)dwCounter + Context.cDelta );

        // If we're the designated DC, we may need to write the counter.
        // But only do so if this is a normal termination, or if there
        // wasn't already a counter.  This covers the three cases:
        //
        // 1) The counter didn't already exist, so we were enumerating everything.
        //    a) Normal termination, so we should update the counter
        //       with the newly calculated value.
        //    b) Abnormal termination, so we shouldn't update the counter.
        //       That way we'll know to do the count again later.
        //
        // 2) The counter already existed, so we were counting the uncounted
        //    entries.  In this case, the entries were being updated to
        //    be counted as we went through the enumeration.  So whether
        //    or not we had a normal termination, we need to updated the
        //    counter with what we did so far.
        //
        // The only reason we expect an exception is in the case of a
        // service stop.

        if( IsDesignatedDc()
            &&
            fDoWriteCounter
            &&
            ( !AbnormalTermination() || !fNoExistingCounter ) )
        {
            WriteCounter(*pdwTrueCount);
        }

        TrkLog((TRKDBG_QUOTA, TEXT("True count ---- %d"), *pdwTrueCount));
    }
}


//+----------------------------------------------------------------------------
//
//  CQuotaTable::OnMoveTableGcComplete
//
//  This method is called after a GC of the move table, telling us how
//  many entries were deleted.  We use this to update the move counter
//  (if it still exists).
//
//+----------------------------------------------------------------------------

void
CQuotaTable::OnMoveTableGcComplete( ULONG cEntriesDeleted )
{
    DWORD dwCounter = 0;

    if( 0 == cEntriesDeleted )
        return;

    if( ReadCounter( &dwCounter ) )
    {
        TrkLog(( TRKDBG_QUOTA, TEXT("Old move counter was %d"), dwCounter ));

        if( dwCounter >= cEntriesDeleted )
            dwCounter -= cEntriesDeleted;
        else
            dwCounter = 0;

        WriteCounter(dwCounter);

        TrkLog(( TRKDBG_QUOTA, TEXT("New move counter is %d"), dwCounter ));
    }

}


void
CQuotaTable::WriteCounter(DWORD dwCounter)
{
    LDAPMod*    mods[3];
    int         ldapRV;
    CLdapQuotaCounterKeyDn  dnKeyCounter(GetBaseDn());

    CLdapBinaryMod  lbmCounter(s_volumeSecret, (PCHAR)&dwCounter, sizeof(DWORD), LDAP_MOD_REPLACE);
    mods[0] = &lbmCounter._mod;
    mods[1] = NULL;
    ldapRV = ldap_modify_s(Ldap(), dnKeyCounter, mods);
    if( LDAP_SUCCESS != ldapRV )
    {
        if( LDAP_NO_SUCH_OBJECT != ldapRV )
        {
            // There's some kind of problem with the existing counter.
            // Delete and re-create it.
            ldap_delete_s( Ldap(), dnKeyCounter );
        }

        CLdapStringMod  lsmClass(s_objectClass, s_linkTrackVolEntry, LDAP_MOD_ADD);
        CLdapBinaryMod  lbmCounter(s_volumeSecret, (PCHAR)&dwCounter, sizeof(DWORD), LDAP_MOD_ADD);
        mods[0] = &lsmClass._mod;
        mods[1] = &lbmCounter._mod;
        mods[2] = NULL;

        ldapRV = ldap_add_s(Ldap(), dnKeyCounter, mods);
        TrkLog(( TRKDBG_QUOTA, TEXT("Created counter %d, ldap returned %d"), dwCounter, ldapRV ));
    }
    else
        TrkLog((TRKDBG_QUOTA, TEXT("Wrote counter %d, ldap returned %d"), dwCounter, ldapRV));
}

HRESULT
CQuotaTable::DeleteCounter()
{
    HRESULT hr = S_OK;
    int LdapError = 0;
    CLdapQuotaCounterKeyDn  dnKeyCounter(GetBaseDn());

    LdapError = ldap_delete_s(Ldap(), dnKeyCounter);
    if( LDAP_SUCCESS == LdapError )
        hr = S_OK;
    else
        hr = HRESULT_FROM_WIN32( LdapMapErrorToWin32(LdapError) );

    if( FAILED(hr) )
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't delete move-table counter (%08x)"), hr ));
    else
        TrkLog(( TRKDBG_QUOTA, TEXT("Deleted move-table counter") ));

    return( hr );
}



//+----------------------------------------------------------------------------
//
//  CQuotaTable::ValidateCache
//
//  Validate the cached move and volume counts.  They are valid if they exist
//  and are newer than the max time-to-live.  If they aren't valid, they are
//  re-calculated.  They are also recalculated if the caller sets the
//  fForceHint parameter, and the cache is at least of minimum age.
//
//+----------------------------------------------------------------------------

void
CQuotaTable::ValidateCache( BOOL fForceHint )
{
    // How old is the cache in seconds?
    DWORD dwDelta = ( (LONGLONG)CFILETIME() - (LONGLONG)_cftCacheLastUpdated ) / 10000000;

    // The cache should be updated if any of the following are true

    if( 0 == _cftCacheLastUpdated                   // We have no cached values
        ||
        dwDelta > _pcfgsvr->GetCacheMaxTimeToLive() // The cached values are too old
        ||
                                                    // The cached values are old enough, and the
                                                    // the caller wants us to be aggressive.
        fForceHint && (dwDelta > _pcfgsvr->GetCacheMinTimeToLive()) )
    {
        // Yes, we need to update the cached values.

        CLdapVolumeKeyDn    dnKey(GetBaseDn());
        TCHAR*              rgptszAttrs[2];
        DWORD               cVolumeTableEntries = 0;

        TrkLog(( TRKDBG_QUOTA, TEXT("Updating quota caches (%s)"),
                 fForceHint ? TEXT("forced") : TEXT("not forced") ));

        // Get the true count of move table entries.
        GetTrueCount( (DWORD*) &_lCachedMoveTableCount, FOREGROUND );
        TrkAssert( _lCachedMoveTableCount >= 0 );

        // Get the count of volume table entries

        rgptszAttrs[0] = const_cast<TCHAR*>(s_Cn);
        rgptszAttrs[1] = NULL;

        if( !LdapEnumerate( Ldap(),
                            dnKey,
                            LDAP_SCOPE_ONELEVEL,
                            TEXT("(&(ObjectClass=*)(!(cn=QT*)))"),
                            rgptszAttrs,
                            VolumeTableEnumCallback,
                            &cVolumeTableEntries,
                            this) )
        {
            TrkRaiseException( TRK_E_SERVICE_STOPPING );
        }
        _lCachedVolumeTableCount = (LONG) cVolumeTableEntries;

        // Calculate the move table limit
        _dwMoveLimit = CalculateMoveLimit();


        // Show that the cache is up-to-date
        _cftCacheLastUpdated.SetToUTC();
    }

    TrkLog(( TRKDBG_QUOTA, TEXT("Cache: MoveCount=%d, MoveLimit=%d, VolCount=%d"),
             _lCachedMoveTableCount, _dwMoveLimit, _lCachedVolumeTableCount ));

}


DWORD
CQuotaTable::CalculateMoveLimit()   // Doesn't raise
{
    DWORD dwMoveLimit = 0;
    LONG lVolumeCount = max( 0, _lCachedVolumeTableCount );

    if( lVolumeCount <= _pcfgsvr->GetMoveLimitTransition() )
        dwMoveLimit = lVolumeCount * _pcfgsvr->GetMoveLimitPerVolumeLower();
    else
    {
        dwMoveLimit = _pcfgsvr->GetMoveLimitTransition()
                      *
                      _pcfgsvr->GetMoveLimitPerVolumeLower();

        dwMoveLimit += ( lVolumeCount - _pcfgsvr->GetMoveLimitTransition() )
                       *
                       _pcfgsvr->GetMoveLimitPerVolumeUpper();
    }


    return( dwMoveLimit );
}


HRESULT
CQuotaTable::ReadFlags(LDAP* pLdap, TCHAR* dnKey, BYTE* bFlags)
{
    struct berval** ppbvFlags = NULL;
    TCHAR*          rgptszAttrs[2];
    LDAPMessage*    pRes = NULL;
    int             ldapRV;
    int             cEntries;
    LDAPMessage*    pEntry = NULL;
    HRESULT         hr = S_OK;

    __try
    {
        *bFlags = 0x0;
        rgptszAttrs[0] = const_cast<TCHAR*>(s_oMTIndxGuid);
        rgptszAttrs[1] = NULL;
        ldapRV = ldap_search_s(pLdap,
                               dnKey,
                               LDAP_SCOPE_BASE,
                               TEXT("(ObjectClass=*)"),
                               rgptszAttrs,
                               0,
                               &pRes);
        hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(ldapRV));
        if(ldapRV != LDAP_SUCCESS)
            __leave;

        cEntries = ldap_count_entries(pLdap, pRes);
        if(cEntries != 1)
        {
            // This shouldn't happen.  The caller asked for flags on an entry
            // which doesn't exist.
            TrkLog(( TRKDBG_ERROR, TEXT("ReadFlags, entry doesn't exist: %s"), dnKey ));
            hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(LDAP_NO_SUCH_OBJECT));
            __leave;
        }

        pEntry = ldap_first_entry(pLdap, pRes);
        if(NULL == pEntry)
        {
            // This should never happen.  We already know that there's an entry.
            TrkLog(( TRKDBG_ERROR, TEXT("ReadFlags, couldn't get first entry on %s"), dnKey ));
            hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(LDAP_NO_SUCH_OBJECT));
            __leave;
        }

        ppbvFlags = ldap_get_values_len(pLdap, pEntry, const_cast<TCHAR*>(s_oMTIndxGuid) );
        if(NULL == ppbvFlags)
        {
            hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(LDAP_NO_SUCH_ATTRIBUTE));
            __leave;
        }

        if( (*ppbvFlags)->bv_len < sizeof(BYTE)
            ||
            ((*ppbvFlags)->bv_val == NULL) )
        {
            // The best we can do is pretend the attribute doesn't exist.
            TrkLog(( TRKDBG_ERROR, TEXT("ReadFlags, attribute is wrong type or missing (%d/%p)"),
                     (*ppbvFlags)->bv_len, (*ppbvFlags)->bv_val ));
            hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(LDAP_NO_SUCH_ATTRIBUTE));
            __leave;
        }

        *bFlags = *(BYTE*)(*ppbvFlags)->bv_val;
        hr = S_OK;
    }
    __finally
    {
        if(pRes != NULL)
        {
            ldap_msgfree(pRes);
        }
        if(ppbvFlags != NULL)
        {
            ldap_value_free_len(ppbvFlags);
        }
    }


    return hr;
}

void
CQuotaTable::DeleteFlags(LDAP* pLdap, TCHAR* dnKey)
{
    BYTE                bFlags = 0x0;
    int                 err;

    Lock();

    __try
    {
        CLdapBinaryMod      lbm(s_oMTIndxGuid, NULL, 0, LDAP_MOD_DELETE );//reinterpret_cast<PCCH>(&bFlags), sizeof(BYTE), LDAP_MOD_DELETE);
        LDAPMod*            mods[2];

        mods[0] = &lbm._mod;
        mods[1] = NULL;

        err = ldap_modify_s(pLdap, dnKey, mods);
        TrkLog((TRKDBG_QUOTA, TEXT("Deleted flag %x on entry %s, ldap returned %d"), bFlags, dnKey, err));
    }
    __finally
    {
        Unlock();
    }
}


// TRUE => Found, FALSE => Not found, Raise otherwise
BOOL
CQuotaTable::UpdateFlags(LDAP* pLdap, TCHAR* dnKey, BYTE bFlags)
{
    BOOL            fFound = FALSE;
    BYTE            bOrigFlags;
    HRESULT         hr;
    LDAPMod*        mods[2];
    int     err;

    TrkAssert(!(bFlags & QFLAG_UNCOUNTED && bFlags & QFLAG_DELETED));

    Lock();

    __try
    {
        hr = ReadFlags(pLdap, dnKey, &bOrigFlags);
        if(hr == (HRESULT) HRESULT_FROM_WIN32(LdapMapErrorToWin32(LDAP_NO_SUCH_ATTRIBUTE)))
        {
            CLdapBinaryMod  lbm(s_oMTIndxGuid, reinterpret_cast<PCCH>(&bFlags), sizeof(BYTE), LDAP_MOD_ADD);

            mods[0] = &lbm._mod;
            mods[1] = NULL;

            err = ldap_modify_s(pLdap, dnKey, mods);
            TrkLog((TRKDBG_QUOTA, TEXT("Added flag %01x on entry %s, ldap returned %d"), bFlags, dnKey, err));
        }
        else if(hr == S_OK)
        {
            if(bOrigFlags == QFLAG_UNCOUNTED && bFlags == QFLAG_DELETED)
            {
                bOrigFlags = bOrigFlags | bFlags;
                CLdapBinaryMod  lbm(s_oMTIndxGuid, reinterpret_cast<PCCH>(&bOrigFlags), sizeof(BYTE), LDAP_MOD_REPLACE);
                mods[0] = &lbm._mod;
                mods[1] = NULL;
                err = ldap_modify_s(pLdap, dnKey, mods);
                TrkLog((TRKDBG_QUOTA, TEXT("Updated flag to %01x on entry %s, ldap returned %d"), bOrigFlags, dnKey, err));
            }
            else if(bOrigFlags == QFLAG_DELETED && bFlags == QFLAG_UNCOUNTED)
            {
                DeleteFlags(pLdap, dnKey);
            }
        }

        else
        {
            __leave;
        }

        fFound = TRUE;
    }
    __finally
    {
        Unlock();
    }


    return( fFound );
}



//+----------------------------------------------------------------------------
//
//  CQuotaTable::DeleteOrphanedEntries
//
//  This routine is given a list of move table entries.  The birth entry has
//  been updated by the caller to point to the final entry.  As a result, all
//  the other entries are orphaned and must be deleted.
//
//+----------------------------------------------------------------------------

BOOL
CQuotaTable::DeleteOrphanedEntries( const CDomainRelativeObjId rgdroidList[], ULONG cSegments,
                                    const CDomainRelativeObjId &droidBirth,
                                    const CDomainRelativeObjId &droidCurrent )
{
    BOOL fCurrentNeedsToBeDeleted = FALSE;

    for( int j=0; j < cSegments; j++ )
    {
        // Don't do anything if this is the birth entry

        if( rgdroidList[j] != droidBirth )
        {
            // If this is the current entry we don't delete it, but tell the
            // caller about it.
            if( rgdroidList[j] == droidCurrent )
            {
                fCurrentNeedsToBeDeleted = TRUE;
            }

            // Otherwise, we delete it directly
            else if( _pidt->Delete( rgdroidList[j] ) )
            {
                TrkLog((TRKDBG_QUOTA,
                        TEXT("Orphaned segment deleted %s"),
                        static_cast<const TCHAR*>(CAbbreviatedIDString(rgdroidList[j])) ));
            }
            else
            {
                TrkLog((TRKDBG_QUOTA|TRKDBG_WARNING,
                        TEXT("Orphaned segment failed to delete %s"),
                        static_cast<const TCHAR*>(CAbbreviatedIDString(rgdroidList[j])) ));
            }
        }
    }

    return( fCurrentNeedsToBeDeleted );
}




//+----------------------------------------------------------------------------
//
//  CQuotaTable::ShortenString
//
//  Given an entry in the move table, see if it is part of a string that
//  needs to be shortened, and if so do the shortening.
//
//+----------------------------------------------------------------------------


void
CQuotaTable::ShortenString( LDAP* pLdap, LDAPMessage* pMessage, BYTE *pbFlags,
                            const CDomainRelativeObjId &droidCurrent )
{

    CDomainRelativeObjId droidBirth;
    CDomainRelativeObjId droidScan;
    CDomainRelativeObjId droidNext;
    CDomainRelativeObjId rgdroidList[MAX_SHORTENABLE_SEGMENTS];
    int                  cSegments = 0;
    TCHAR                *ptszCurrentCN = NULL;

    __try
    {
        // Attempt to read the entry and get its birth ID.

        if( _pidt->Query( pLdap, pMessage, droidCurrent, &droidNext, &droidBirth ) )
        {
            // We have a successful read.

            BOOL fStringDeleted = FALSE;

            // Scan forward from that birth to see if we can find multiple entries.

            droidScan = droidBirth;
            _psvrsvc->Scan( NULL, NULL, droidBirth,
                            rgdroidList, ELEMENTS(rgdroidList), &cSegments,
                            &droidScan, &fStringDeleted );

            // If this is a multi-segment string, reduce it to a single segment.

            if( cSegments > 1 )
            {
                // Was the last segment of the string deleted?
                if( fStringDeleted )
                {
                    // Yes, that means that the entired string has been deleted.
                    TrkLog(( TRKDBG_QUOTA, TEXT("Deleting string starting at %s"),
                             static_cast<const TCHAR*>(CAbbreviatedIDString(droidBirth)) ));

                    if( droidCurrent == droidBirth )
                        *pbFlags |= QFLAG_DELETED;
                    else
                        _pidt->Delete( droidBirth );
                }

                // Otherwise, map from the birth to the last droid.
                else if( !_pidt->Modify( droidBirth, droidScan, droidBirth ))
                {
                    TrkLog(( TRKDBG_QUOTA|TRKDBG_WARNING, TEXT("Couldn't shorten %s -> %s"),
                             static_cast<const TCHAR*>(CAbbreviatedIDString(droidBirth)),
                             static_cast<const TCHAR*>(CAbbreviatedIDString(droidScan)) ));
                    __leave;
                }
                else
                {
                    TrkLog(( TRKDBG_QUOTA, TEXT("Shortened %s -> %s [%s]"),
                             static_cast<const TCHAR*>(CAbbreviatedIDString(droidBirth)),
                             static_cast<const TCHAR*>(CAbbreviatedIDString(droidScan)),
                             static_cast<const TCHAR*>(CAbbreviatedIDString(droidBirth)) ));
                }

                // The birth entry has been shortened, or deleted.  So we can delete the
                // rest of the entries.

                if( DeleteOrphanedEntries( rgdroidList, cSegments,
                                           droidBirth,    // Don't delete this one
                                           droidCurrent   // Or this one
                                         ))
                {
                    // Amongst the orphans in need of a delete is the current
                    // entry.  Set the deleted flag, and the caller will take
                    // care of removing the entry.

                    TrkLog(( TRKDBG_QUOTA, TEXT("Current is orphaned and will be deleted") ));
                    *pbFlags |= QFLAG_DELETED;
                }

            }   // if( cSegments > 1 )

        }
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_QUOTA, TEXT("Ignoring exception from Scan in FlaggedEntriesEnumCallback (%08x)"),
                 GetExceptionCode() ));
    }

    if( NULL != ptszCurrentCN )
        ldap_memfree(ptszCurrentCN);
}



//+----------------------------------------------------------------------------
//
//  CQuotaTable::MoveTableEnumCallback
//
//  When the move table is enumerated, this routine is passed to LdapEnumerate
//  as the callback function.  If we're the designated DC, this function
//  takes care of uncounted/deleted entries and shortens move table strings.
//  Whether or not we're the designated DC, we update the count value,
//  according to the uncounted/deleted entries, in the pvContext structure.
//
//+----------------------------------------------------------------------------


ENUM_ACTION // static
CQuotaTable::MoveTableEnumCallback(LDAP* pLdap, LDAPMessage* pMessage, void* pvContext, void* pvThis )
{
    struct berval **    ppbvFlags = NULL;
    BYTE bFlags = 0;
    ENUM_ACTION         action = ENUM_KEEP_ENTRY;
    TRUE_COUNT_ENUM_CONTEXT *pContext = (TRUE_COUNT_ENUM_CONTEXT*) pvContext;
    CQuotaTable *pThis = (CQuotaTable*)pvThis;
    TCHAR *ptszCurrentDN = NULL;
    CDomainRelativeObjId droidCurrent;

    if( pThis->_fStopping )
        return( ENUM_ABORT );

    __try
    {
        // Read the quota flags for this entry.  We can't read them out of the
        // enumeration buffer, because the flags can get updated by the enumeration
        // and the enumeration buffer doesn't reflect the change.

        ptszCurrentDN = ldap_get_dn( pLdap, pMessage );
        if (ptszCurrentDN == NULL)
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't get DN") ));
            TrkRaiseLastError();
        }
        droidCurrent.ReadLdapIdtKeyBuffer(ptszCurrentDN);
        TrkLog(( TRKDBG_QUOTA, TEXT("Enumerating %s"),
                 static_cast<const TCHAR*>(CAbbreviatedIDString(droidCurrent)) ));

        pThis->ReadFlags(pLdap, ptszCurrentDN, &bFlags );

        // Count this entry if we're counting everything, or if we're only
        // counting flagged values and this one is flagged as uncounted.

        if( pContext->fCountAll || (bFlags & QFLAG_UNCOUNTED) )
            pContext->cDelta++;

        // If this is uncounted and we're the designated DC, then it's
        // counted now and we can delete the flags attribute.

        if( (bFlags & QFLAG_UNCOUNTED) && pThis->IsDesignatedDc() )
            action = ENUM_DELETE_QUOTAFLAGS;

        // If we're the designated DC, we can do some additional cleanup here.
        // It's because of this work that we need two passes; one to do the 
        // cleanup, and one to delete the entries that this cleanup marked
        // for deletion (by calling _pidt->Delete).

        if( pThis->IsDesignatedDc() && pContext->FIRST_PASS == pContext->dwPass )
        {
            pThis->ShortenString( pLdap, pMessage, &bFlags, droidCurrent );
        }

        // If this entry is marked for delete, decrement the count.
        // Note that if the entry was marked uncounted and deleted,
        // we incremented at the top and will decrement here for the
        // correct change of zero.

        if( bFlags & QFLAG_DELETED )
        {
            pContext->cDelta--;

            // If we're the designated DC, we can delete the entry.
            if( pThis->IsDesignatedDc() )
                action = ENUM_DELETE_ENTRY;
        }
    }
    __finally
    {
        if(ppbvFlags != NULL)
        {
            ldap_value_free_len(ppbvFlags);
        }

        if( NULL != ptszCurrentDN )
            ldap_memfree( ptszCurrentDN );
    }

    // Be nice to the DS
    if( 0 != pContext->dwRepetitiveTaskDelay )
        Sleep( pContext->dwRepetitiveTaskDelay );

    return action;
}


ENUM_ACTION // static
CQuotaTable::VolumeTableEnumCallback( LDAP * pLdap, LDAPMessage * pResult, void* pcEntries, void* pvThis )
{
    CQuotaTable* pThis = (CQuotaTable*)pvThis;

    if( pThis->_fStopping )
        return( ENUM_ABORT );

    (*((DWORD*)pcEntries))++;
    return ENUM_KEEP_ENTRY;
}


void
CQuotaTable::Statistics( TRKSVR_STATISTICS *pTrkSvrStatistics )
{
    pTrkSvrStatistics->dwMoveLimit = _dwMoveLimit;
    pTrkSvrStatistics->dwCachedVolumeTableCount = (DWORD) _lCachedVolumeTableCount;
    pTrkSvrStatistics->dwCachedMoveTableCount = (DWORD) _lCachedMoveTableCount;
    pTrkSvrStatistics->ftCacheLastUpdated = _cftCacheLastUpdated;
    pTrkSvrStatistics->fIsDesignatedDc = IsDesignatedDc();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trksvr\resource.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by linkui.rc
//
#define IDS_RESTOREMACHINE              1
#define IDS_RESTORESTATUS               2
#define IDS_RESTOREDATE                 3
#define IDS_PENDING                     4
#define IDS_CALLING                     5
#define IDS_UNAVAILABLE                 6
#define IDS_DATAUNAVAILABLE             7
#define IDS_SUCCESS                     8
#define IDS_ACCESSDENIED                9
#define IDS_WORKING                     10
#define IDS_CONFIRMRESTORE              11
#define IDS_RESTOREFROM                 12
#define IDS_MERGE_FORMAT                13
#define IDD_DIALOG1                     101
#define IDD_DIALOG2                     102
#define IDC_EDIT1                       1000
#define IDC_LIST1                       1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trksvr\idt_ldap.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       idt_ldap.cxx
//
//  Contents:   Intra-domain table based on LDAP.
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------



#include "pch.cxx"
#pragma hdrstop

#include "trksvr.hxx"


CLdapOMTAddModify::CLdapOMTAddModify(
                const CDomainRelativeObjId & ldKey,
                const CDomainRelativeObjId & ldNew,
                const CDomainRelativeObjId & ldBirth,
                const ULONG & seqRefresh,
                BYTE bFlags,
                int   mod_op )
                :
                 
    _lsmClass(s_objectClass, s_linkTrackOMTEntry, 0),

    _lbmCurrentLocation( s_currentLocation, reinterpret_cast<PCCH>(&ldNew), sizeof(ldNew), mod_op ),
    _lbmBirthLocation( s_birthLocation, reinterpret_cast<PCCH>(&ldBirth), sizeof(ldBirth), mod_op ),
    _ltvRefresh( seqRefresh ),
    _lsmRefresh( s_timeRefresh, _ltvRefresh, mod_op ),
    _lbmFlags( s_oMTIndxGuid, reinterpret_cast<PCCH>(&bFlags), sizeof(BYTE), mod_op )

{
    int i = 0;
    if (mod_op == LDAP_MOD_ADD)
    {
        _mods[i++] = &_lsmClass._mod;
        _mods[i++] = &_lbmFlags._mod;
    }
    _mods[i++] = &_lbmCurrentLocation._mod;

    if (ldKey != ldBirth)
        _mods[i++] = &_lbmBirthLocation._mod;

    _mods[i++] = &_lsmRefresh._mod;
    _mods[i++] = NULL;

    TrkAssert(i <= sizeof(_mods)/sizeof(_mods[0]));
}

void
CIntraDomainTable::Initialize( CTrkSvrConfiguration *pTrkSvrConfiguration, CQuotaTable* pqtable )
{
    _fInitializeCalled = TRUE;
    _pqtable = pqtable;
    _pTrkSvrConfiguration = pTrkSvrConfiguration;
    _QuotaReported.Initialize();
}

void
CIntraDomainTable::UnInitialize()
{
    if (_fInitializeCalled)
    {
    }
    _fInitializeCalled = FALSE;
}


//+----------------------------------------------------------------------------
//
//  CIntraDomainTable::Add
//
//  Add an entry to the move table.  Return TRUE if the entry was added, but
//  didn't already exist.  Return FALSE if the entry already exists.  If
//  there's an error, raise an exception.
//
//+----------------------------------------------------------------------------

BOOL
CIntraDomainTable::Add(const CDomainRelativeObjId &ldKey, 
                       const CDomainRelativeObjId &ldNew, 
                       const CDomainRelativeObjId &ldBirth,
                       BOOL  *pfQuotaExceeded OPTIONAL )
{
    int     err;
    BYTE    bFlags = QFLAG_UNCOUNTED;

    CLdapIdtKeyDn   dnKey(GetBaseDn(), ldKey);

    // The following constructor sets up the mods array for
    // the ldap_add_s call that we're about to do.

    CLdapOMTAddModify  lam( ldKey,              // Key
                            ldNew,              // New droid
                            ldBirth,            // Birth droid
                                                // Current sequence number
                            _pRefreshSequenceStorage->GetSequenceNumber(),
                            bFlags,             // Flags, will be pointed to
                                                //   (so can't e.g. use a #define value)
                            LDAP_MOD_ADD);      // Add this element

    // Return FALSE here means that we pretend to the caller that the entry
    // already exists. We don't want to raise an exception here. Our caller
    // always tries to add the entry, if the add fails because the entry
    // already exists, the caller will then try to modify the entry. If the
    // quota has been exceeded, we don't want to add more entries, but we
    // still want entries already in the table to be modifiable. So instead of
    // raising an exception, we really want the caller to try to modify the
    // entry instead.

    if(_pqtable->IsMoveQuotaExceeded())
    {
        if( NULL != pfQuotaExceeded )
            *pfQuotaExceeded = TRUE;

        if( !_QuotaReported.IsSet() )
        {
            _QuotaReported.Set();
            TrkReportEvent( EVENT_TRK_SERVICE_MOVE_QUOTA_EXCEEDED, EVENTLOG_WARNING_TYPE,
                            TRKREPORT_LAST_PARAM );
        }

        return FALSE;
    }
    else
    {
        _QuotaReported.Clear();
    }

    err = ldap_add_s(Ldap(), dnKey, lam._mods);
    if (err == LDAP_SUCCESS)
    {
        {
            LDAPMod*        mods[2];
            BYTE bFlags = QFLAG_UNCOUNTED;
            CLdapBinaryMod  lbm(s_oMTIndxGuid, reinterpret_cast<PCCH>(&bFlags), sizeof(BYTE), LDAP_MOD_REPLACE);

            mods[0] = &lbm._mod;
            mods[1] = NULL;

            err = ldap_modify_s(Ldap(), dnKey, mods);
        }

        _pqtable->IncrementMoveCountCache();
        return(TRUE);
    }
    else
    if (err == LDAP_ALREADY_EXISTS)
    {
        return(FALSE);
    }
    else
    {
        TrkRaiseWin32Error(LdapMapErrorToWin32(err));
        return(FALSE);
    }

}

// TRUE if found and deleted, FALSE if not found, exception on other errors

BOOL
CIntraDomainTable::Delete(const CDomainRelativeObjId &ldKey)
{
    int err;
    CLdapIdtKeyDn       dnKey(GetBaseDn(), ldKey);
    BOOL fFound;

    fFound = _pqtable->UpdateFlags(Ldap(), dnKey, QFLAG_DELETED);
    if( fFound )
        _pqtable->DecrementMoveCountCache();
    return fFound;
}

// TRUE if entry exists and modified, FALSE if not existent, exception otherwise
BOOL
CIntraDomainTable::Modify(const CDomainRelativeObjId &ldKey, 
                          const CDomainRelativeObjId &ldNew, 
                          const CDomainRelativeObjId &ldBirth )
{
    int             err;
    CLdapIdtKeyDn   dnKey(GetBaseDn(), ldKey);
    CLdapOMTAddModify  lam( ldKey,
                            ldNew, 
                            ldBirth, 
                            _pRefreshSequenceStorage->GetSequenceNumber(), 
                            0, // Only used with LDAP_MOD_ADD
                            LDAP_MOD_REPLACE);

    err = ldap_modify_s(Ldap(), dnKey, lam._mods);

    if (err == LDAP_SUCCESS)
    {
        return(TRUE);
    }
    else
    if (err == LDAP_NO_SUCH_OBJECT)
    {
        return(FALSE);
    }
    else
    {
        TrkRaiseWin32Error(LdapMapErrorToWin32(err));
        return(FALSE);
    }
}

// must leave outputs unchanged if returning FALSE
BOOL
CIntraDomainTable::Query(const CDomainRelativeObjId &ldKey, 
                         CDomainRelativeObjId *pldNew,
                         CDomainRelativeObjId *pldBirth,
                         BOOL *pfDeleted OPTIONAL,
                         BOOL *pfCounted OPTIONAL )
{
    int             err;
    TCHAR           *aptszAttrs[] = { const_cast<TCHAR*>(s_currentLocation),
                                      const_cast<TCHAR*>(s_birthLocation),
                                      const_cast<TCHAR*>(s_oMTIndxGuid),
                                      NULL };
    LDAPMessage *   pRes = NULL;
    CLdapIdtKeyDn   dnKey(GetBaseDn(), ldKey);
    BOOL            fFound = FALSE;

    __try
    {
        err = ldap_search_s( Ldap(),
                             dnKey,
                             LDAP_SCOPE_BASE,
                             TEXT("(objectclass=*)"),
                             aptszAttrs,
                             0, // attribute types and values are wanted
                             &pRes );

        if (err == LDAP_SUCCESS)
        {
            // found it, lets get the attributes out

            if (ldap_count_entries(Ldap(), pRes) == 1)
            {
                LDAPMessage * pEntry = ldap_first_entry(Ldap(), pRes);
                if (pEntry == NULL)
                {
                    TrkRaiseWin32Error(LdapMapErrorToWin32(Ldap()->ld_errno));
                }

                fFound = Query( Ldap(), pEntry, ldKey, pldNew, pldBirth, pfDeleted, pfCounted );
            }
        }
        else
        if (err != LDAP_NO_SUCH_OBJECT)
        {
            TrkRaiseWin32Error(LdapMapErrorToWin32(err));
        }
    }
    __finally
    {
        if (NULL != pRes)
            ldap_msgfree(pRes);
    }

    return(fFound);
}


BOOL
CIntraDomainTable::Query( LDAP* pLdap,
                          LDAPMessage *pEntry,
                          const CDomainRelativeObjId ldKey,
                          CDomainRelativeObjId *pldNew,
                          CDomainRelativeObjId *pldBirth,
                          BOOL *pfDeleted OPTIONAL,
                          BOOL *pfCounted OPTIONAL )
{
    BOOL fFound = FALSE;
    struct berval **ppbvCurrentLocation = NULL;
    struct berval **ppbvBirthLocation = NULL;
    struct berval **ppbvQuotaFlags = NULL;
    BYTE bQuotaFlags = 0;

    if( NULL != pfDeleted )
        *pfDeleted = FALSE;

    __try
    {
        ppbvBirthLocation = ldap_get_values_len(pLdap, pEntry,
                                                const_cast<TCHAR*>(s_birthLocation) );

        if (NULL != ppbvBirthLocation
            &&
            sizeof(*pldBirth) > (*ppbvBirthLocation)->bv_len)
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't get current location for %s"),
                               (const TCHAR*)CDebugString(ldKey) ));
            TrkRaiseWin32Error( LdapMapErrorToWin32(pLdap->ld_errno) );
        }

        ppbvCurrentLocation = ldap_get_values_len(pLdap, pEntry,
                                                  const_cast<TCHAR*>(s_currentLocation) );
        if (NULL == ppbvCurrentLocation
            ||
            sizeof(*pldNew) > (*ppbvCurrentLocation)->bv_len)
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't get current location for %s"),
                    (const TCHAR*)CDebugString(ldKey) ));
            TrkRaiseWin32Error( LdapMapErrorToWin32(pLdap->ld_errno) );
        }

        ppbvQuotaFlags = ldap_get_values_len(pLdap, pEntry,
                                             const_cast<TCHAR*>(s_oMTIndxGuid) );

        if (NULL != ppbvQuotaFlags
            &&
            sizeof(BYTE) <= (*ppbvQuotaFlags)->bv_len)
        {
            bQuotaFlags = *(BYTE*)(*ppbvQuotaFlags)->bv_val;
        }

        if( NULL != pfCounted )
        {
            if( bQuotaFlags & QFLAG_UNCOUNTED )
                *pfCounted = FALSE;
            else
                *pfCounted = TRUE;
        }
    

        if( bQuotaFlags & QFLAG_DELETED )
        {
            if( NULL != pfDeleted )
                *pfDeleted = TRUE;

            TrkLog(( TRKDBG_IDT, TEXT("IdtQuery: Entry marked deleted will be ignored (0x%x): %s"),
                     bQuotaFlags, 
                     (const TCHAR*)CDebugString(ldKey) ));
        }
        else
        {
            *pldNew   = *reinterpret_cast<CDomainRelativeObjId*>( (*ppbvCurrentLocation)->bv_val );

            if (NULL != ppbvBirthLocation)
                *pldBirth = *reinterpret_cast<CDomainRelativeObjId*>( (*ppbvBirthLocation)->bv_val );
            else
                *pldBirth = ldKey;

            fFound = TRUE;
        }
    }
    __finally
    {
        if (NULL != ppbvCurrentLocation)
            ldap_value_free_len(ppbvCurrentLocation);

        if (NULL != ppbvBirthLocation)
            ldap_value_free_len(ppbvBirthLocation);

        if (NULL != ppbvQuotaFlags)
            ldap_value_free_len(ppbvQuotaFlags);
    }

    return( fFound );
}



//+----------------------------------------------------------------------------
//
//  CIntraDomainTable::Touch
//
//  Update the refresh attribute for an entry in the move table.
//  Return TRUE if the entry exists and was touched, FALSE if it
//  doesn't exist, and raise an exception if there's an error.
//
//+----------------------------------------------------------------------------

// BUGBUG: if we ever move to per-user quotas,
// check ownership of entry being touched.

BOOL
CIntraDomainTable::Touch(
    const CDomainRelativeObjId &ldKey
    )
{
    BOOL            fReturn = FALSE;
    int             err;
    CLdapTimeValue  ltvRefresh( _pRefreshSequenceStorage->GetSequenceNumber());
    CLdapStringMod  lsmRefresh( s_timeRefresh, ltvRefresh, LDAP_MOD_REPLACE );
    CLdapIdtKeyDn   dnKey(GetBaseDn(), ldKey);
    TCHAR **        pptszRefresh = NULL;
    LDAPMessage   * pEntry = NULL;
    LDAPMessage*    pRes = NULL;

    LDAPMod *       mods[2];
    CObjId          objZero;

    __try
    {
        //
        // if the birth id is zero, then it is invalid and not worth doing a refresh
        //

        if (ldKey.GetObjId() == objZero)
        {
            __leave;
        }

        //
        // Check to see if the object already has a recent sequence number.
        //

        TCHAR*          rgptszAttrs[2];
        rgptszAttrs[0] = const_cast<TCHAR*>(s_timeRefresh);
        rgptszAttrs[1] = NULL;

        err = ldap_search_s(Ldap(),
                            dnKey,
                            LDAP_SCOPE_BASE,
                            TEXT("(ObjectClass=*)"),
                            rgptszAttrs,
                            0,
                            &pRes);

        if (err == LDAP_SUCCESS)
        {
            // The search call worked, but did we find an object?
            if( 1 == ldap_count_entries(Ldap(), pRes) )
            {
                // The object already exists
                pEntry = ldap_first_entry(Ldap(), pRes);
                if( NULL != pEntry )
                {
                    // Get the refresh counter
                    pptszRefresh = ldap_get_values( Ldap(), pEntry, const_cast<TCHAR*>(s_timeRefresh) );
                    if( NULL != pptszRefresh )
                    {
                        SequenceNumber seqRefresh = 0;
                        if( 1 == _stscanf( *pptszRefresh, TEXT("%d"), &seqRefresh ))
                        {
                            // Is the refresh counter already set to a recent value?
                            // We'll consider it recent enough if it's within half of the
                            // refresh cycle (15 days)

                            // First, how long is the GC timer in seconds?
                            LONG lGCTimerInSeconds = _pTrkSvrConfiguration->GetGCPeriod()     // 30 days in seconds
                                                     / _pTrkSvrConfiguration->GetGCDivisor(); // => 1 day in seconds

                            // Next, how many ticks is half the period?
                            LONG lWindow =  _pTrkSvrConfiguration->GetGCPeriod()    // 30 days (in seconds)
                                            / 2                                     // => 15 days (in seconds)
                                            / lGCTimerInSeconds;                    // => 15

                            TrkLog(( TRKDBG_WARNING, TEXT("Window = %d"), lWindow ));

                            if( seqRefresh + lWindow
                                >= _pRefreshSequenceStorage->GetSequenceNumber()
                              )
                            {
                                TrkLog(( TRKDBG_GARBAGE_COLLECT | TRKDBG_IDT,
                                         TEXT("Not touching %s with %d, seq %d already set"),
                                         (const TCHAR*)CDebugString(ldKey),
                                         _pRefreshSequenceStorage->GetSequenceNumber(),
                                         seqRefresh ));
                                __leave;
                            }
                        }
                    }
                }
            }
        }
        else if (err == LDAP_NO_SUCH_OBJECT)
        {
            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_IDT,
                TEXT("Touch: object %s not found"),
                (const TCHAR*) CDebugString(ldKey) ));
            __leave;
        }


        //
        // Set the correct sequence number
        //

        mods[0] = &lsmRefresh._mod;
        mods[1] = NULL;

        err = ldap_modify_s(Ldap(), dnKey, mods);

        if (err == LDAP_SUCCESS)
        {
            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_IDT,
                TEXT("Touch: object %s touched"),
                (const TCHAR*) CDebugString(ldKey) ));
            fReturn = TRUE;
            __leave;
        }
        else
        if (err == LDAP_NO_SUCH_OBJECT)
        {
            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_IDT,
                TEXT("Touch: object %s not found"),
                (const TCHAR*) CDebugString(ldKey) ));
            __leave;
        }
        else
        if (err == LDAP_NO_SUCH_ATTRIBUTE)
        {
            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_SVR,
                TEXT("Touch: object %s attribute not found"),
                (const TCHAR*) CDebugString(ldKey) ));

            // deal with old server data
            CLdapStringMod lsmRefresh( s_timeRefresh, ltvRefresh, LDAP_MOD_ADD );
            mods[0] = &lsmRefresh._mod;

            err = ldap_modify_s(Ldap(), dnKey, mods);
        }

        if (err != LDAP_SUCCESS)
        {
            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_IDT,
                TEXT("Touch: object %s --> exceptional error"),
                (const TCHAR*) CDebugString(ldKey) ));
            __leave;
        }
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception during IDT::Touch (%08x)"), GetExceptionCode() ));
    }

    if (pptszRefresh != NULL)
        ldap_value_free(pptszRefresh);
    if(pRes != NULL)
        ldap_msgfree(pRes);

    return( fReturn );
}




ULONG
CIntraDomainTable::GarbageCollect( SequenceNumber seqCurrent, SequenceNumber seqOldestToKeep, const BOOL * pfAbort )
{
    CLdapIdtKeyDn       dn(GetBaseDn());
    TCHAR *             apszAttrs[3];
    GC_ENUM_CONTEXT     EnumContext;

    apszAttrs[0] = const_cast<TCHAR*>(s_Cn);
    apszAttrs[1] = const_cast<TCHAR*>(s_timeRefresh);
    apszAttrs[2] = 0;

    TrkLog(( TRKDBG_GARBAGE_COLLECT | TRKDBG_IDT, TEXT("GC-ing move table (%d/%d)"),
             seqCurrent, seqOldestToKeep ));

    memset( &EnumContext, 0, sizeof(EnumContext) );
    EnumContext.seqOldestToKeep = seqOldestToKeep;
    EnumContext.seqCurrent = seqCurrent;
    EnumContext.pfAbort = pfAbort;
    EnumContext.dwRepetitiveTaskDelay = _pTrkSvrConfiguration->GetRepetitiveTaskDelay();
    EnumContext.pqtable = _pqtable;

    if (!LdapEnumerate(
        Ldap(),
        dn,
        LDAP_SCOPE_ONELEVEL,
        TEXT("(objectClass=*)"),
        apszAttrs,
        GcEnumerateCallback,
        &EnumContext ))
    {
        TrkRaiseException(TRK_E_SERVICE_STOPPING);
    }

    TrkLog(( TRKDBG_GARBAGE_COLLECT | TRKDBG_IDT,
             TEXT("GC-ed %d entries from the move table"),
             EnumContext.cEntries ));

    _pqtable->OnMoveTableGcComplete( EnumContext.cEntries );


    return EnumContext.cEntries;
}

#if DBG
void
CIntraDomainTable::PurgeAll()
{
    int             err;
    TCHAR            *apszAttrs[2] = { TEXT("cn"), NULL };
    LDAPMessage *   pRes;
    TCHAR           tszObjectMoveTable[MAX_PATH+1];
    
    __try
    {
        _tcscpy(tszObjectMoveTable, s_ObjectMoveTableRDN);
        _tcscat(tszObjectMoveTable, GetBaseDn());

        err = ldap_search_s( Ldap(),
                             tszObjectMoveTable,
                             LDAP_SCOPE_ONELEVEL,
                             TEXT("(objectclass=*)"),
                             apszAttrs,
                             0, // attribute types and values are wanted
                             &pRes );

        if (err == LDAP_SUCCESS)
        {
            // found it, lets get the attributes out
    
            int cEntries = ldap_count_entries(Ldap(), pRes);
            LDAPMessage * pEntry = ldap_first_entry(Ldap(), pRes);
            if (pEntry != NULL)
            {
                do
                {
                    TCHAR * ptszDn = ldap_get_dn(Ldap(), pEntry);

                    int errd = ldap_delete_s(Ldap(),ptszDn);

                    TrkLog((TRKDBG_ERROR, TEXT("Purged %s status=%d"), ptszDn, errd));
                    ldap_memfree(ptszDn);

                } while ( pEntry = ldap_next_entry(Ldap(), pEntry));
            }
        }
    }
    __finally
    {
        if (err == LDAP_SUCCESS)
        {
            ldap_msgfree(pRes);
        }
    }
}
#endif

void
CDomainRelativeObjId::FillLdapIdtKeyBuffer(TCHAR * const pchCN,
                                DWORD cch) const
{
    TCHAR *pchBuf = pchCN;
    _tcscpy(pchBuf, TEXT("CN="));
    pchBuf = pchBuf + 3;
    _volume.Stringize(pchBuf);
    _object.Stringize(pchBuf);
    TrkAssert(pchBuf <= pchCN+cch);
}

void
CDomainRelativeObjId::ReadLdapIdtKeyBuffer(const TCHAR * pchCN )
{
    const TCHAR *pchBuf;
    Init();
    if( 0 == _tcsncmp( pchCN, TEXT("CN="), 3 ))
    {
        pchBuf = &pchCN[3];
        if( !_volume.Unstringize(pchBuf)
            ||
            !_object.Unstringize(pchBuf) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't unstringize droid from %s"), pchCN ));
            Init();
        }
    }
}

void
CDomainRelativeObjId::InitFromLdapBuffer(char * pVolumeId, int cbVolumeId,
                              char * pObjId, int cbObjId)
{
    DWORD iBuf = 0;

    if (cbVolumeId != sizeof(_volume) ||
        cbObjId != sizeof(_object))
    {
        TrkRaiseException(TRK_E_CORRUPT_IDT);
    }

    memcpy(&_volume, pVolumeId, sizeof(_volume));
    memcpy(&_object, pObjId, sizeof(_object));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trksvr\seqstg.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       seqstg.cxx
//
//  Contents:   Refresh sequence number storage
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    03-Oct-97  BillMo   Created
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "trksvr.hxx"

class CLdapRefreshSeqDn
{
public:
    // specific volume
    CLdapRefreshSeqDn( const TCHAR * ptszBaseDn )
    {
        // Compose, the following DN:
        //    "CN=RefreshSequence,CN=VolumeTable,CN=FileLinks,DC=TRKDOM"

        _tcscpy(_szDn, TEXT("CN=RefreshSequence,CN=VolumeTable,"));
        _tcscat(_szDn, ptszBaseDn );

        TrkAssert(_tcslen(_szDn) < ELEMENTS(_szDn));
    }

    inline operator TCHAR * () { return _szDn; }

private:
    TCHAR _szDn[MAX_PATH];
};



//+----------------------------------------------------------------------------
//
//  CRefreshSequenceStorage::GetSequenceNumber
//
//  Get the current value of the sequence number.  If the cached value is
//  old and we're not the designated DC, then re-read it from the DS.  (Since
//  the designated DC is the only one that writes this value, it needn't
//  ever refresh its cache).
//
//+----------------------------------------------------------------------------

SequenceNumber
CRefreshSequenceStorage::GetSequenceNumber()
{
    CVolumeId volidZero;
    CMachineId mcidZero(MCID_INVALID);
    CVolumeSecret secretZero;
    CFILETIME cft;  // Initializes to current time

    _cs.Enter();
    __try
    {
        // See if our cached value is young enough.

        cft.DecrementSeconds( _psvrconfig->GetRefreshStorageTTL() );
        if ( _pQuotaTab->IsDesignatedDc() && _cftLastRead != 0
            ||
            _cftLastRead >= cft )
        {
            // Yes, we can just return _seq as is.

            //TrkLog(( TRKDBG_GARBAGE_COLLECT | TRKDBG_SVR,
            //         TEXT("CRefreshSequenceStorage using cached value (%d)"), _seq ));
            __leave;
        }

        // We need to read the sequence number from the DS.

        if ( _pVolTab->GetVolumeInfo( volidZero, &mcidZero, &secretZero, &_seq, &cft ) ==
             TRK_S_VOLUME_NOT_FOUND )
        {
            // volidZero doesn't exist, so we'll assume the sequence number is zero.
            // If we're the designated DC, write this out.

            if( _pQuotaTab->IsDesignatedDc() )
            {
                TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_SVR,
                    TEXT("CRefreshSequenceStorage::GetSequenceNumber - creating volume id 0")));

                _pVolTab->AddVolidToTable( volidZero, mcidZero, secretZero );
            }
            _seq = 0;
        }
        #if DBG
        else
        {
            // We read it successfully.
            TrkLog(( TRKDBG_GARBAGE_COLLECT | TRKDBG_SVR,
                     TEXT("CRefreshSequenceStorage read %d"), _seq ));
        }
        #endif

        _cftLastRead = CFILETIME();

    }
    __finally
    {
        _cs.Leave();
    }

    return(_seq);
}

void
CRefreshSequenceStorage::IncrementSequenceNumber()
{
    SequenceNumber seq;
    CVolumeId volidZero;

    _cs.Enter();
    __try
    {
        TrkAssert( _pQuotaTab->IsDesignatedDc() );

        if( _cftLastRead == CFILETIME(0) )
            GetSequenceNumber();

        _pVolTab->SetSequenceNumber( volidZero, ++_seq );
        _cftLastRead = CFILETIME();
    }
    __finally
    {
        _cs.Leave();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trksvr\trksvr_sp.c ===
// Copyright (c) 1996-1999 Microsoft Corporation


#include <windows.h>
#include <rpc.h>
#include <rpcasync.h>
#include "trksvr_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trksvr\svrsvc.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       svrsvc.cxx
//
//  Contents:   Code for CTrkSvrSvc
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#include "trksvr.hxx"
#include "ntlsa.h"

#define THIS_FILE_NUMBER    SVRSVC_CXX_FILE_NO

#if DBG
DWORD g_Debug = 0;
#endif

const extern  TCHAR s_tszKeyNameLinkTrack[] = TEXT("System\\CurrentControlSet\\Services\\TrkSvr\\Parameters");

// This is the SID used internally by CVerifyAuthentication
PSID CVerifyAuthentication::_psidAuthenticatedUsersGroup = NULL;


//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::Initialize
//
//  Initialize the TrkSvr service.
//
//+----------------------------------------------------------------------------

void
CTrkSvrSvc::Initialize( SVCHOST_GLOBAL_DATA * pSvcsGlobalData )
{

    __try
    {
        _cLowestAvailableThreads = _cAvailableThreads = MAX_SVR_THREADS;

        _fInitializeCalled = TRUE;
        g_ptrksvr = this;
        _pSvcsGlobalData = pSvcsGlobalData;

        // Initialize the object that manages the SCM.
        _svcctrl.Initialize(TEXT("TrkSvr"), this);
    
        // Initialize registry-configurable parameters.
        _configSvr.Initialize();

        // If requested, prepare to log all operations (to a file)
        if( _configSvr.UseOperationLog() )
            _OperationLog.Initialize( _configSvr.GetOperationLog() );

        TrkLog(( TRKDBG_SVR, TEXT("Distributed Link Tracking (Server) service starting on thread=%d(0x%x)"),
                             GetCurrentThreadId(), GetCurrentThreadId() ));

        // This is a hacked stub that looks and acts like the Win32 thread pool services
        #ifdef PRIVATE_THREAD_POOL
        {
            HRESULT hr = S_OK;
            g_pworkman2 = new CThreadPoolStub;
            if( NULL == g_pworkman2 )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't create the thread pool manager") ));
                TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );
            }

            hr = g_pworkman2->Initialize();
            if( FAILED(hr) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't initialize the thread pool manager") ));
                TrkRaiseException( hr );
            }
        }
        #endif

        // The denial checker provides protection against a denial-of-service
        // attack, where a client floods us with calls.
        _denial.Initialize(_configSvr.GetHistoryPeriod() );

        // Initialize the helper class that we use for validating that callers
        // are in the Authenticated Users group

        CVerifyAuthentication::Initialize();

        // This is also a denial checker, which protects against a
        // single client making multiple create-volume calls.
        _activeCreates.Initialize( _configSvr.GetSvrMaxRpcCalls() );

        // This critsec protects _cWritesPerHour & _cftWritesPerHour.
        // See CTrkSvrSvc::CheckWritesPerHour
        _csWritesPerHour.Initialize();

        // This maintains the "time" for purposes of refreshing entries.
        _refreshSequence.Initialize();

        // The cross-domain table
        _cdt.Initialize();

        // The intra-domain table
        _idt.Initialize( &_configSvr, &_qtable );

        // The volume table
        _voltab.Initialize( &_configSvr, &_qtable );

        // The quota manager
        _qtable.Initialize(&_voltab, &_idt, this, &_configSvr );

        // Set the quota timer.  This was originally every 30 days, but is now
        // every day.  In order to maintain compatibility with the tests, we 
        // still use the GCPeriod value (30 days), but divide it by the new
        // GCDivisor value (30) to get the correct period.
        // This timer doesn't have a standard retry, because of the way
        // we hesitate 30 minutes before doing anything.  So retries are
        // done explicitely.

        _timerGC.Initialize(this,
                            TEXT("NextGarbageCollectTime"),   // This is a persistent timer
                            0,     // Context ID
                            _configSvr.GetGCPeriod() / _configSvr.GetGCDivisor(),
                            CNewTimer::NO_RETRY,
                            0, 0, 0 );    // No retries or max lifetime
        _timerGC.SetRecurring();
        TrkLog(( TRKDBG_VOLUME, TEXT("GC timer: %s"),
                 (const TCHAR*) CDebugString(_timerGC) ));

        // Used in the Timer method to determine if we should reset the
        // move table counter value.
        _MoveCounterReset.Initialize();

        // Initialize ourself as an RPC server
        _rpc.Initialize( _pSvcsGlobalData, &_configSvr );

        // Tell the SCM that we're running.

        _svcctrl.SetServiceStatus(SERVICE_RUNNING,
                                  SERVICE_ACCEPT_STOP |
                                   SERVICE_ACCEPT_SHUTDOWN,
                                  NO_ERROR);

        _OperationLog.Add( COperationLog::TRKSVR_START );
    }

    __except( BreakOnDebuggableException() )
    {
        // Don't log an event for protseq-not-supported; this happens during a normal
        // setup.
        if( HRESULT_FROM_WIN32(RPC_S_PROTSEQ_NOT_SUPPORTED) != GetExceptionCode() )
        {
            TrkReportEvent( EVENT_TRK_SERVICE_START_FAILURE, EVENTLOG_ERROR_TYPE,
                            static_cast<const TCHAR*>( CHexStringize( GetExceptionCode() )),
                            NULL );
        }
        TrkRaiseException( GetExceptionCode() );
    }
}


//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::UnInitialize
//
//  Cancel any out-going RPCs, stop all timers, close everything down,
//  and send a service_stopped to the SCM.
//
//+----------------------------------------------------------------------------

void
CTrkSvrSvc::UnInitialize(HRESULT hr)
{
    if (_fInitializeCalled)
    {
        _fInitializeCalled = FALSE;

        // Cancel any out-going RPCs on threads in this service

        if( NULL != g_pActiveThreadList )
            g_pActiveThreadList->CancelAllRpc();

        // stop classes that use threads first ...
        _rpc.UnInitialize( _pSvcsGlobalData );
        CVerifyAuthentication::Uninitialize();

        _timerGC.UnInitialize();
        _csWritesPerHour.UnInitialize();

        // ... then release used resources
        _qtable.UnInitialize();
        _voltab.UnInitialize();
        _idt.UnInitialize();
        _cdt.UnInitialize();
        _dbc.UnInitialize();
        _denial.UnInitialize();

        if (_configSvr.GetTestFlags() & TRK_TEST_FLAG_WAIT_ON_EXIT)
        {
            TrkLog((TRKDBG_ERROR, TEXT("Waiting 60 seconds before exitting for heap dump")));
            Sleep(60000);
        }

        #if PRIVATE_THREAD_POOL
        {
            g_pworkman2->UnInitialize();
            delete g_pworkman2;
            g_pworkman2 = NULL;
        }
        #endif

        g_ptrksvr = NULL;

        // If the error is protseq-not-supported, ignore it.  This is normal
        // during setup.

        if( (hr & 0x0FFF0000) == FACILITY_WIN32 )
            hr = hr & ~(0x0FFF0000);

        _svcctrl.SetServiceStatus(SERVICE_STOPPED, 0,
            HRESULT_FROM_WIN32(RPC_S_PROTSEQ_NOT_SUPPORTED) == hr ? 0 : hr
            );
        //_svcctrl.UnInitialize();
    }
}


//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::ServiceHandler
//
//  This method gets called by the SCM for notification of all service
//  activity.
//
//  NOTE:   In services.exe, this method is called on the one and only ServiceHandler
//          thread.  So while we execute, no other service in this process can 
//          receive notifications.  Thus it is important that we do nothing
//          blocking or time-consuming here.
//
//+----------------------------------------------------------------------------

DWORD
CTrkSvrSvc::ServiceHandler(DWORD dwControl,
                           DWORD dwEventType,
                           PVOID EventData,
                           PVOID pData)
{
    DWORD       dwRet = NO_ERROR;


    switch (dwControl)
    {
    case SERVICE_CONTROL_SHUTDOWN:
    case SERVICE_CONTROL_STOP:

        _fStopping = TRUE;
        _qtable.OnServiceStopRequest();
        
        ServiceStopCallback( this, FALSE );

        break;
    case SERVICE_CONTROL_PAUSE:
        break;
    case SERVICE_CONTROL_CONTINUE:
        break;
    case SERVICE_CONTROL_INTERROGATE:
        break;
    default:
        dwRet = ERROR_CALL_NOT_IMPLEMENTED;
        break;
    }

    return(dwRet);
}


//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::RaiseIfStopped
//
//  This method raises an exception if a global flag is set indicating
//  that we've received a service stop/shutdown request.  This is used
//  in places where we have a thread that could run for a while; we periodically
//  call this method to prevent service stop from blocking.
//
//+----------------------------------------------------------------------------

void
CTrkSvrSvc::RaiseIfStopped()
{
    if ( * _svcctrl.GetStopFlagAddress() )
        TrkRaiseException( TRK_E_SERVICE_STOPPING );
}


//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::CheckWritesPerHour
//
//  Check _cWritesPerHour to see if we're writing to much to the DS.
//  This is a simplistic algorithm in an effort to reduce risk.  We
//  just let _cWritesPerHour increment until it hits the max, then
//  check to see when that count was started.  If more than an
//  hour ago, then reset the count & the clock.
//
//+----------------------------------------------------------------------------

BOOL
CTrkSvrSvc::CheckWritesPerHour()
{
    BOOL fExceeded = FALSE;

    if( _cWritesPerHour >= _configSvr.GetMaxDSWritesPerHour() )
    {
        _csWritesPerHour.Enter();
        __try
        {
            // Check the count again, as it may have changed whil we
            // were waiting for the critsec.
            if( _cWritesPerHour >= _configSvr.GetMaxDSWritesPerHour() )
            {
                CFILETIME cft;  // Defaults to current time

                // Did the "hour" for _cWritesPerHour actually start more
                // than an hour ago?

                cft.DecrementSeconds( _configSvr.GetMaxDSWritesPeriod() );   // An hour

                if( cft > _cftWritesPerHour )
                {
                    TrkLog(( TRKDBG_SVR, TEXT("Resetting writes-per-hour clock (%d)"),
                             _cWritesPerHour ));

                    // Yes, this write is OK, and we should reset the write time.
                    _cftWritesPerHour = CFILETIME();
                    _cWritesPerHour = 0;
                    _Stats.cCurrentFailedWrites = 0;
                }
                else
                {
                    TrkLog(( TRKDBG_WARNING,
                             TEXT("Exceeded writes-per-hour (started at %s)"),
                             (const TCHAR*) CDebugString(_cftWritesPerHour) ));

                    if( 0 == _Stats.cCurrentFailedWrites )
                        _Stats.cMaxDsWriteEvents++;
                    _Stats.cCurrentFailedWrites++;

                    fExceeded = TRUE;
                }
            }
        }
        __finally
        {
            _csWritesPerHour.Leave();
        }
    }

    return fExceeded;
}

void
CTrkSvrSvc::Scan(
    IN     const CDomainRelativeObjId * pdroidNotificationCurrent, OPTIONAL
    IN     const CDomainRelativeObjId * pdroidNotificationNew,     OPTIONAL
    IN     const CDomainRelativeObjId & droidBirth,
    OUT    CDomainRelativeObjId * pdroidList,
    IN     int cdroidList,
    OUT    int * pcSegments,
    IN OUT CDomainRelativeObjId * pdroidScan,
    OUT    BOOL * pfStringDeleted
    )
{
    CDomainRelativeObjId droidNextBirth, droidNextNew;
    BOOL      fFound = FALSE;
    BOOL      fBirthSame = FALSE;
    BOOL      fCycle = FALSE;

    *pfStringDeleted = FALSE;

    //
    // loop through the string until the birth ids don't match, or
    // we've run out of buffer space, or we get to the end of the string
    //

    do
    {
        if (pdroidNotificationCurrent && *pdroidScan == *pdroidNotificationCurrent)
        {
            TrkAssert(pdroidNotificationNew);

            droidNextNew = *pdroidNotificationNew;
            droidNextBirth = droidBirth;
            fFound = TRUE;
            *pfStringDeleted = FALSE;
        }
        else
        {
            fFound = _idt.Query(*pdroidScan, &droidNextNew, &droidNextBirth, pfStringDeleted );
            RaiseIfStopped();
        }

        if (fFound)
        {
            TrkLog((TRKDBG_MEND, TEXT("CTrkSvrSvc::Scan() -  iSegment=%d, %s --> %s [%s] found"),
                *pcSegments,
                static_cast<const TCHAR*>(CAbbreviatedIDString(*pdroidScan)),
                static_cast<const TCHAR*>(CAbbreviatedIDString(droidNextNew)),
                static_cast<const TCHAR*>(CAbbreviatedIDString(droidNextBirth)) ));

            // Check to see if we've already been here before.
            // E.g., don't loop forever on A->Ba, B->Aa.

            for( int j = 0; j < *pcSegments; j++ )
            {
                if( pdroidList[ j ] == droidNextNew )
                {
                    TrkLog(( TRKDBG_MEND, TEXT("Cycle detected during mend (on %s)"),
                             static_cast<const TCHAR*>(CAbbreviatedIDString(*pdroidScan)) ));
                    fCycle = TRUE;
                    break;
                }
            }

            if( !fCycle )
            {
                fBirthSame = droidNextBirth == droidBirth;
                if (fBirthSame)
                {
                    pdroidList[ (*pcSegments)++ ] = *pdroidScan;
                    *pdroidScan = droidNextNew;
                }
                else
                {
                    // We can stop searching.  We found a segment that starts
                    // with *pdroidScan, but it's from another string because
                    // it has a different birth ID.

                    TrkLog(( TRKDBG_MEND, TEXT("Birth IDs don't match: %s, %s"),
                             (const TCHAR*) CDebugString(droidBirth),
                             (const TCHAR*) CDebugString(droidNextBirth) ));
                }
            }
        }
    } while ( *pcSegments < cdroidList && fFound && fBirthSame && !fCycle );

    if ( *pcSegments == cdroidList || fCycle )
    {
        TrkRaiseException(TRK_E_TOO_MANY_UNSHORTENED_NOTIFICATIONS);
    }

}


//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::MoveNotify
//
//  Handle a move notify request from trkwks.
//
//  This routine is complicated by DS replication.  It is possible that two trksvr
//  services may modify the same entry in the IDT within a replication window.
//  The only way to prevent this is to design such that only the designated DC
//  modifies entries.  For this MoveNotify routine, that would mean that an
//  entry would be added for each notification, the designated DC would then
//  shorten the base entry, and delete this new one.  That's not friendly
//  to the DS, however, because deleted objects must continue to be stored
//  for an extended period of time.
//
//  Consequently, if this notify modifies an existing entry, this routine
//  performs a modify rather than an add.  For example, if a file is
//  moved from A to B to C, and this routine is being called for that
//  second move, it would just modify the existing entry from A->B to
//  A->C.
//
//  The risk here is that another DC will attempt to modify this entry
//  within the same replication window.  We don't have to worry though
//  about another DC doing a notify; trkwks only sends to one DC.  
//  There are two cases to worry about.  One is the case where another DC
//  marks an entry to be deleted.  If that happens after we do the modify
//  here, then there is no problem; the entry is no longer needed anyway.
//  If that happens before we do our modify here, then the delete flag
//  will be lost.  This case is rare, and the unnecessary entry won't
//  stay in the table forever; it will be garbage collected.
//
//  The other case of potential conflict is if an entry has not
//  yet been counted; in this case the designated DC might count
//  it and clear the uncounted flag.  If our modify causes that
//  flag to be uncleared, then the move table count would be corrupted.
//  So if the uncounted flag is set, we do an add rather than a modify.
//
//+----------------------------------------------------------------------------

void
CTrkSvrSvc::MoveNotify(const CDomainRelativeObjId &droidCurrent,
                       const CDomainRelativeObjId &droidBirth,
                       const CDomainRelativeObjId &droidNew,
                       BOOL *pfQuotaExceeded )
{
    BOOL fAdded = FALSE, fModified = FALSE, fExists = FALSE;
    BOOL fDeleted = FALSE, fCounted = FALSE;

    // ignore cross-domain moves for now

    CDomainRelativeObjId droidNextNew;
    CDomainRelativeObjId droidNextBirth;
    CDomainRelativeObjId droidNewIDT, droidBirthIDT;

    TrkLog((TRKDBG_MOVE, TEXT("CTrkSvrSvc::MoveNotify\n   curr = %s\n   new = %s\n   birth = %s"),
             (const TCHAR*)CDebugString(droidCurrent),
             (const TCHAR*) CDebugString(droidNew),
             (const TCHAR*) CDebugString(droidBirth) ));

    // Does the entry exist already?

    fExists = _idt.Query( droidBirth, &droidNewIDT, &droidBirthIDT, &fDeleted, &fCounted );


#if DBG
    if( fExists )
        TrkLog(( TRKDBG_MOVE, TEXT("Birth entry already exists (%s, %s)"),
        fDeleted ? TEXT("deleted") : TEXT("not deleted"),
        fCounted ? TEXT("counted") : TEXT("not counted") ));
#endif

    if( fExists
        && 
        fCounted
        &&
        droidNewIDT == droidCurrent )
    {
        TrkLog(( TRKDBG_MOVE, TEXT("Attempting to modify existing entry") ));

        // The birth entry for this file already points to the source
        // of the notify.  We can just modify it.

        fModified = _idt.Modify( droidBirth, droidNew, droidBirth );
    }

    // If the modify didn't work or wasn't attempted, then just add this
    // new entry

    if( !fModified )
        fAdded = _idt.Add( droidCurrent, droidNew, droidBirth, pfQuotaExceeded );

    TrkLog((TRKDBG_MEND, TEXT("CTrkSvrSvc::MoveNotify() %s %s --> %s [%s]"),
        fModified ? TEXT("modified")
                  : (fAdded ? TEXT("added") : TEXT("couldn't be added") ),
        static_cast<const TCHAR*>(CAbbreviatedIDString(droidCurrent)),
        static_cast<const TCHAR*>(CAbbreviatedIDString(droidNew)),
        static_cast<const TCHAR*>(CAbbreviatedIDString(droidBirth)) ));

}




//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::Search
//
//  Given a droid, look up the new droid for that object, and look up
//  the mcid of the machine that owns that droid's volume.
//
//+----------------------------------------------------------------------------

void
CTrkSvrSvc::Search(/*in, out*/ TRK_FILE_TRACKING_INFORMATION *pSearch)
{
    HRESULT                 hr = S_OK;                        
    CDomainRelativeObjId    droidNew;
    CDomainRelativeObjId    droidBirth;
    CMachineId              mcidNew;
    BOOL                    fFoundObject;

    IFDBG( TCHAR * ptszRoute=TEXT(""); )

    TrkLog(( TRKDBG_MEND, TEXT("Searching for %s"),
             static_cast<const TCHAR*>(CAbbreviatedIDString(pSearch->droidLast)) ));

    // If all the move notifies for a file have reached the DC, we can do a 
    // lookup based on the birth ID.  But if one segment is missing, this would fail.
    // So we look up based on the last ID first, and if that files try the birth ID.

    // Try to map the last ID to the current droid.

    fFoundObject = _idt.Query( pSearch->droidLast, &droidNew, &droidBirth);
    if ( fFoundObject )
    {
        IFDBG( ptszRoute = TEXT("'last' found in IDT"); )
    }
    else
    {
        // We couldn't find the last known ID.  Try mapping
        // from the birth ID.

        fFoundObject = _idt.Query( pSearch->droidBirth, &droidNew, &droidBirth );
        if( fFoundObject )
        {
            IFDBG( ptszRoute = TEXT("'birth' found in IDT"); )
        }
    }


    // Did we find the new droid for the file?

    if ( fFoundObject )
    {
        // Yes, we found it.  Is it really the same file (the birth ID matches)?

        if( droidBirth != pSearch->droidBirth )
        {
            TrkLog(( TRKDBG_MEND, TEXT("Birth ID unexpected:\n   %s,\n   %s,\n   %s"),
                     (const TCHAR*) CDebugString(droidBirth),
                     (const TCHAR*) CDebugString(pSearch->droidBirth),
                     (const TCHAR*) CDebugString(droidNew) ));
            pSearch->hr = TRK_E_NOT_FOUND;
            goto Exit;
        }
        
        // We have a good ID.  This file may have multiple segments in the DS.
        // Starting with the one we have, scan across any additional segments
        // to find the most up-to-date droid.

        CDomainRelativeObjId droidList[MAX_SHORTENABLE_SEGMENTS];
        int       cSegments = 0;
        BOOL fStringDeleted = FALSE;
    
        Scan(
            NULL,
            NULL,
            droidBirth,
            droidList,
            sizeof(droidList)/sizeof(droidList[0]),
            &cSegments,
            &droidNew,
            &fStringDeleted
            );

    }
    else
    {
        // We couldn't find either the birth or last ID.

        pSearch->hr = TRK_E_NOT_FOUND;
        TrkLog(( TRKDBG_MEND, TEXT("neither 'birth' nor 'last' found") ));
    }

    // If we found the object in the move table, look up the machine ID in the
    // volume table.

    if (fFoundObject)
    {
        TrkLog((TRKDBG_MEND, TEXT("CTrkSvrSvc::Search( birth=%s last=%s ) successful, 'new=%s', %s"),
                static_cast<const TCHAR*>(CAbbreviatedIDString(pSearch->droidBirth)),
                static_cast<const TCHAR*>(CAbbreviatedIDString(pSearch->droidLast)),
                static_cast<const TCHAR*>(CAbbreviatedIDString(droidNew)),
                ptszRoute ));

        // Find the volume that holds this droid.

        pSearch->hr = _voltab.FindVolume( droidNew.GetVolumeId(),
                                          &mcidNew );
        if( S_OK == pSearch->hr )
        {
            // We found the volume.

            TrkLog(( TRKDBG_MEND, TEXT("CTrkSvrSvc::Search, volid found (%s -> %s)"),
                     (const TCHAR*) CDebugString(droidNew.GetVolumeId()),
                     (const TCHAR*) CDebugString(mcidNew) ));

            pSearch->hr = S_OK;
            pSearch->droidLast = droidNew;
            pSearch->mcidLast = mcidNew;
        }
        else
        {
            // We were able to find the object in the move table, but couldn't
            // find the volume in the volume table.

            TrkLog(( TRKDBG_MEND, TEXT("CTrkSvrSvc::Search, volid not found (%s, %08x)"),
                     (const TCHAR*) CDebugString(droidNew.GetVolumeId()),
                     pSearch->hr ));
            pSearch->hr = TRK_E_NOT_FOUND;
        }

    }
    else
    {
        HRESULT hr = S_OK;

        // We couldn't find the object in the move table.

        TrkLog((TRKDBG_MEND, TEXT("CTrkSvrSvc::Search( birth=%s last=%s ) not found, %s"),
                    static_cast<const TCHAR*>(CAbbreviatedIDString(pSearch->droidBirth)),
                    static_cast<const TCHAR*>(CAbbreviatedIDString(pSearch->droidLast)),
                    ptszRoute));


        // As an optimization, try looking up the last volume anyway.  When this
        // search request fails, the trkwks service typically looks up the location
        // of the volume ID in droidLast, so we do that lookup now instead of forcing
        // trkwks to make a separate request.

        hr = _voltab.FindVolume( pSearch->droidLast.GetVolumeId(),
                                 &mcidNew );
        if( S_OK == hr )
        {
            TrkLog(( TRKDBG_MEND, TEXT("CTrkSvrSvc::Search, but last volid found (%s -> %s)"),
                     (const TCHAR*) CDebugString(pSearch->droidLast.GetVolumeId()),
                     (const TCHAR*) CDebugString(mcidNew) ));

            pSearch->hr = TRK_E_NOT_FOUND_BUT_LAST_VOLUME_FOUND;
            pSearch->mcidLast = mcidNew;
        }
        else
        {
            TrkLog(( TRKDBG_MEND, TEXT("CTrkSvrSvc::Search, volid not found either (%s, %08x)"),
                     (const TCHAR*) CDebugString(pSearch->droidLast.GetVolumeId()),
                     pSearch->hr ));
            pSearch->hr = TRK_E_NOT_FOUND_AND_LAST_VOLUME_NOT_FOUND;
        }
    
    
    }

Exit:

    return;
}


//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::old_Search
//
//  This method is provided for compatibility with NT5/Beta2 clients.  Those
//  clients would do two RPCs, one to get the new droid, then another to map
//  the volid in that droid to an mcid.  In the modern SEARCH request, the 
//  client gets both back in a single call.
//
//  The distinction between the two kinds of clients is made by the 
//  TRKSVR_MESSAGE_TYPE in the request.  Old clients pass the value
//  now defined as old_SEARCH, new clients pass the value SEARCH.
//
//+----------------------------------------------------------------------------

void
CTrkSvrSvc::old_Search(/*in, out*/ old_TRK_FILE_TRACKING_INFORMATION *pSearch)
{
    TRK_FILE_TRACKING_INFORMATION FileTrkInfo;

    FileTrkInfo.droidBirth = pSearch->droidBirth;
    FileTrkInfo.droidLast = pSearch->droidLast;

    Search(&FileTrkInfo);
    
    pSearch->hr = FileTrkInfo.hr;
    pSearch->droidLast = FileTrkInfo.droidLast;
}




//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::Timer
//
//  This callback method is called by the GC timer when it's time to do a
//  GC.
//
//  This method doesn't raise.
//
//+----------------------------------------------------------------------------


PTimerCallback::TimerContinuation
CTrkSvrSvc::Timer( ULONG ulTimerContext )
{
    HRESULT hr = S_OK;
    BOOL fInvalidateCache = FALSE;
    TimerContinuation continuation = CONTINUE_TIMER;
    NTSTATUS Status = STATUS_SUCCESS;

    TrkLog(( TRKDBG_SVR, TEXT("\nGC timer has fired") ));

    __try
    {
        // Only the designated DC does garbage collecting.
        if( !_qtable.IsDesignatedDc( TRUE ) ) // TRUE => raise on error
        {
            TrkLog(( TRKDBG_SVR, TEXT("Not GC-ing; not the designated DC") ));
            continuation = CONTINUE_TIMER;
            __leave;
        }

        // See if this domain is too young to do anything.

        if( _refreshSequence.GetSequenceNumber()
            < 
            static_cast<SequenceNumber>(_configSvr.GetGCMinCycles()) )
        {
            TrkLog(( TRKDBG_GARBAGE_COLLECT | TRKDBG_SVR,
                     TEXT("Nothing to GC (%d)"),
                     _refreshSequence.GetSequenceNumber() ));

            continuation = CONTINUE_TIMER;
            __leave;
        }

        // Is this the part one of the timer ?

        if( !_fHesitatingBeforeGC )
        {
            // Yes, this is part one.  We'll do some work, then 
            // reset the timer for a small delay (so that we don't
            // do a bunch of work during system initialization).

            #if DBG
            {
                if( _configSvr.GetGCHesitation() > (5*60) )
                    TrkLog(( TRKDBG_SVR, TEXT("Hesitating for %d minutes before running GC"),
                             _configSvr.GetGCHesitation() / 60 ));
                else
                    TrkLog(( TRKDBG_SVR, TEXT("Hesitating for %d seconds before running GC"),
                             _configSvr.GetGCHesitation() ));
            }
            #endif


            _fHesitatingBeforeGC = TRUE;

            _timerGC.ReInitialize( _configSvr.GetGCHesitation() ); // Doesn't raise
            continuation = CONTINUE_TIMER;

        }
        else
        {
            _fHesitatingBeforeGC = FALSE;

            _Stats.cEntriesGCed = 0;

            // Update the sequence number

            _refreshSequence.IncrementSequenceNumber();
            TrkLog(( TRKDBG_SVR, TEXT("Updated the GC counter to %d"),
                     _refreshSequence.GetSequenceNumber() ));

            // See if we need to invalidate the move table count cache (once a month).
            // This is done for robustness, so that if the count gets out of sync for any
            // reason, we self-correct. _MoveCounterReset holds the sequence number
            // of the last time we did an invalidate.

            if( (SequenceNumber) _MoveCounterReset.GetValue()
                >=
                _refreshSequence.GetSequenceNumber() )
            {
                // Invalid value
                TrkLog(( TRKDBG_WARNING,
                         TEXT("_MoveCounterReset is invalid (%d, %d), resetting"),
                         _MoveCounterReset.GetValue(),
                         _refreshSequence.GetSequenceNumber() ));
                _MoveCounterReset.Set
                    ( (DWORD) _refreshSequence.GetSequenceNumber() );
            }
            else if( _MoveCounterReset.GetValue() + _configSvr.GetGCDivisor()
                     <= _refreshSequence.GetSequenceNumber()
                   )
            {
                TrkLog(( TRKDBG_SVR | TRKDBG_GARBAGE_COLLECT,
                         TEXT("Cache will be invalidated (%d)"), _MoveCounterReset.GetValue() ));
                fInvalidateCache = TRUE;
            }

            // Calculate the seq number of the oldest entry to keep.

            ULONG seqOldestToKeep = _refreshSequence.GetSequenceNumber() - _configSvr.GetGCMinCycles() + 1;

            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_SVR,
                TEXT("\nGarbage collecting all entries older than %d"),
                seqOldestToKeep));

            // Delete old entries from the move table

            _Stats.cEntriesGCed
                += (SHORT)_idt.GarbageCollect( _refreshSequence.GetSequenceNumber(),
                                               seqOldestToKeep, 
                                               _svcctrl.GetStopFlagAddress() );

            // And delete old entries from the volume table

            _Stats.cEntriesGCed
                += (SHORT)_voltab.GarbageCollect( _refreshSequence.GetSequenceNumber(),
                                                  seqOldestToKeep, 
                                                  _svcctrl.GetStopFlagAddress() );

            _OperationLog.Add( COperationLog::TRKSVR_GC, S_OK, CMachineId(MCID_INVALID),
                               seqOldestToKeep, _Stats.cEntriesGCed );

            // Reset the timer to its normal period.

            _timerGC.ReInitialize( _configSvr.GetGCPeriod() / _configSvr.GetGCDivisor() );
            continuation = CONTINUE_TIMER;
        
        }

    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
        TrkLog(( TRKDBG_WARNING,
                 TEXT("Ignoring exception in CTrkSvrSvc::Timer (%08x)"),
                 hr ));
        _OperationLog.Add( COperationLog::TRKSVR_GC, hr, CMachineId(MCID_INVALID) );
    }

    // The Quota table's cached counts may be bad now that we've deleted
    // entries from the tables.

    if( fInvalidateCache )
    {
        _qtable.InvalidateCache();
        _MoveCounterReset.Set( (DWORD) _refreshSequence.GetSequenceNumber() );
    }

    TrkAssert( _timerGC.IsRecurring() );
    return( continuation );
}





SequenceNumber
CTrkSvrSvc::GetSequenceNumber( const CMachineId & mcidClient, const CVolumeId & volume )
{
    HRESULT hr;
    SequenceNumber seq;
    FILETIME ftLastRefresh;
    
    hr = _voltab.QueryVolume(mcidClient, volume, &seq, &ftLastRefresh);

    if( S_OK != hr )
    {
        // Raise on error.  E.g. if mcidClient doesn't own this volume.
        TrkLog(( TRKDBG_ERROR,
                TEXT("CTrkSvrSvc::GetSequenceNumber --> %08x"), hr ));
        TrkRaiseException(hr);
    }

    return(seq);
}

void
CTrkSvrSvc::SetSequenceNumber( const CVolumeId & volume,    // must ensure that validation already done for volume
                               SequenceNumber seq )
{
    HRESULT hr;

    hr = _voltab.SetSequenceNumber( volume, seq );
    if (hr != S_OK)
    {
        TrkRaiseException( hr );
    }
}

HRESULT
CTrkSvrSvc::MoveNotify( const CMachineId & mcidClient,
                        TRKSVR_CALL_MOVE_NOTIFICATION * pMove )
{
    HRESULT hr = S_OK;
    SequenceNumber seqExpected;
    CVolumeId volid;

    InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cMoveNotifyRequests) );

    pMove->cProcessed = 0;

    //
    // ensure we have at least one notification because we assume that
    // the current volume of the first notification is the same for all
    // of the notifications in this rpc.
    //

    if (pMove->cNotifications == 0)
    {
        return(S_OK);
    }

    // Get the machine for this volume and the sequence number expected
    // ensure that the machine is actually the owner of the volume.
    // (This will raise if mcidClient doesn't own this volid.)

    volid = *pMove->pvolid;
    seqExpected = GetSequenceNumber(mcidClient, volid);
    

    // Is this the sequence number we were expecting for this client volume?

    TrkLog((TRKDBG_MOVE, TEXT("sequence no %d %sexpected for %s (%sforcing, expected %d)"),
            pMove->seq,
            seqExpected != pMove->seq ? TEXT("un") : TEXT(""),
            (const TCHAR*) CDebugString(volid),
            pMove->fForceSeqNumber ? TEXT("") : TEXT("not "),
            seqExpected
            ));


    if( seqExpected != pMove->seq )
    {
        // No, it's not the right sequence number.

        if( !pMove->fForceSeqNumber )
        {
            // The caller hasn't requested an override, so this is an error.

            pMove->seq = seqExpected;
            return TRK_S_OUT_OF_SYNC;
        }
    }

    //
    // Before processing the actual move notifications, ensure that we
    // have enough quota... assume that each move notify is going to
    // to need one unit of quota (the writes will actually update
    // the quota accurately.)
    //
#ifdef VOL_QUOTA
    if (pMove->cNotifications > GetAvailableNotificationQuota( ) )
    {
        TrkRaiseException( TRK_E_NOTIFICATION_QUOTA_EXCEEDED );
    }
#endif

    while (pMove->cProcessed < pMove->cNotifications)
    {
        // the only errors are fatal since we always make a record of
        // a notification or merge it with an existing record

        BOOL fQuotaExceeded = FALSE;

        if( CheckWritesPerHour() )
        {
            TrkLog(( TRKDBG_SVR, TEXT("Stopping move-notifications due to too many writes (%d)"),
                     NumWritesThisHour() ));
            break;
        }

        MoveNotify(CDomainRelativeObjId( volid, pMove->rgobjidCurrent[pMove->cProcessed] ),
                   pMove->rgdroidBirth[pMove->cProcessed],
                   pMove->rgdroidNew[pMove->cProcessed],
                   &fQuotaExceeded
                   );

        if( fQuotaExceeded )
        {
            hr = TRK_S_NOTIFICATION_QUOTA_EXCEEDED;
            break;
        }

        pMove->cProcessed++;
        IncrementWritesPerHour();

        RaiseIfStopped();
    }

    if( 0 != pMove->cProcessed )
    {
        SetSequenceNumber( volid, pMove->seq + pMove->cProcessed );
        TrkLog(( TRKDBG_SVR, TEXT("Updated sequence number to %d"), pMove->seq+pMove->cProcessed ));
    }

    if( 0 != pMove->cNotifications )
    {
        //TrkLog(( TRKDBG_WARNING, TEXT("pMove = %p"), pMove ));
        pMove->cNotifications = 0;  // don't need to send the data back

        //TrkLog(( TRKDBG_WARNING, TEXT("Free rgdroidNew (%p)"), pMove->rgdroidNew ));
        //MIDL_user_free( pMove->rgdroidNew );
        pMove->rgdroidNew = NULL;

        //TrkLog(( TRKDBG_WARNING, TEXT("Free rgobjidCurrent (%p)"), pMove->rgobjidCurrent ));
        //MIDL_user_free( pMove->rgobjidCurrent );
        pMove->rgobjidCurrent = NULL;

        //TrkLog(( TRKDBG_WARNING, TEXT("Free rgdroidBirth (%p)"), pMove->rgdroidBirth ));
        //MIDL_user_free( pMove->rgdroidBirth );
        pMove->rgdroidBirth = NULL;
    }

    return(hr);
}



BOOL
CTrkSvrSvc::VerifyMachineOwnsVolume( const CMachineId &mcid, const CVolumeId & volid )
{
    HRESULT hr;
    SequenceNumber       seq;
    FILETIME             ft;

    hr = _voltab.QueryVolume(
                mcid,
                volid,
                &seq,
                &ft);
    if (hr != S_OK)
        return FALSE;
    else
        return TRUE;
}



//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::DeleteNotify
//
//  Process a delete-notify request from a client.  This request provides
//  information about a file that has been deleted, so that we can purge
//  it from the move table.
//
//+----------------------------------------------------------------------------

void
CTrkSvrSvc::DeleteNotify( const CMachineId & mcidClient, TRKSVR_CALL_DELETE * pDelete )
{
    CVolumeId            vol;
    HRESULT              hr = TRK_S_VOLUME_NOT_FOUND;

    // Loop through all of the notifications in this batch.

    for (ULONG i=0; i < pDelete->cdroidBirth; i++)
    {
        // Look up the current location of the file, and if it
        // is on an owned volume, then allow the delete.

        CDomainRelativeObjId droidCurrent;
        CDomainRelativeObjId droidBirth;

        // Don't embark on a slow operation if the service is stopping.
        RaiseIfStopped();

        // If we've already written a lot to the DS in the past hour,
        // abort so we don't flood the replication queue.

        if( CheckWritesPerHour() )
        {
            TrkLog(( TRKDBG_WARNING, TEXT("Stopping delete-notify due to too many writes") ));
            TrkRaiseException( TRK_E_SERVER_TOO_BUSY );
        }

        // Read the existing entry for this file.

        if (_idt.Query(pDelete->adroidBirth[i], &droidCurrent, &droidBirth))
        {
            // The entry exists.

            TrkAssert(droidBirth == pDelete->adroidBirth[i]);

            // See if this is the same volume that we checked on the
            // previous iteration through the loop.  If so, no need to
            // look up again.

            if (vol == droidCurrent.GetVolumeId())
            {
                hr = S_OK;
            }
            else
            {
                // We need to check that whoever sent this delete-notify
                // request really owns the volume.

                vol = droidCurrent.GetVolumeId();
                if( !VerifyMachineOwnsVolume( mcidClient, vol ))
                {
                    TrkLog((TRKDBG_OBJID_DELETIONS,
                        TEXT("DeleteNotify _voltab.QueryVolume( %s ) -> %s\n"),
                        (const TCHAR*) CDebugString( vol ),
                        GetErrorString(hr) ));

                    vol = CVolumeId();
                }
            }

            // If the volume is owned, go ahead with the deletion.

            if (hr == S_OK)
            {
                BOOL f = _idt.Delete( pDelete->adroidBirth[i] );

                TrkLog((TRKDBG_OBJID_DELETIONS,
                    TEXT("DeleteNotify _idt.Delete( %s ) -> %s\n"),
                    (const TCHAR*) CDebugString( pDelete->adroidBirth[i] ),
                    f ? TEXT("Ok") : TEXT("Not Found") ));

                if( f )
                    IncrementWritesPerHour();
            }
        }   // if (_idt.Query(pDelete->adroidBirth[i], &droidCurrent, &droidBirth))

        else
        {
            // Attempted to delete an entry that doesn't exist.

            TrkLog((TRKDBG_OBJID_DELETIONS,
                TEXT("DeleteNotify _idt.Query( droidBirth=%s ) not found\n"),
                (const TCHAR*) CDebugString( pDelete->adroidBirth[i] ) ));
        }
    }

    if( 0 != pDelete->cdroidBirth )
    {
        //MIDL_user_free( pDelete->adroidBirth );
        //pDelete->adroidBirth = NULL;
        pDelete->cdroidBirth = 0;
    }

}

void
CTrkSvrSvc::Refresh( const CMachineId &mcidClient, TRKSVR_CALL_REFRESH * pRefresh )
{
    // save away the input and zero the output so we don't marshall a
    // ton of refresh info back to the client

    ULONG cSources = pRefresh->cSources;
    ULONG cVolumes = pRefresh->cVolumes;

    InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cRefreshRequests) );

    pRefresh->cSources = 0;
    pRefresh->cVolumes = 0;

    // Touch the move table entries

    for (ULONG i=0; i < cSources ; i++)
    {
        // Ensure we're not overloading the replication log
        if( CheckWritesPerHour() )
        {
            TrkLog(( TRKDBG_SVR, TEXT("Aborting refresh due to writes-per-hour") ));
            TrkRaiseException( TRK_E_SERVER_TOO_BUSY );
        }

        // Touch the entry in the move table.
        if( _idt.Touch( pRefresh->adroidBirth[i] ))
            IncrementWritesPerHour();
    }

    // Touch the volume table entries

    for (i=0; i < cVolumes ; i++)
    {
        // Ensure we're not overloading the replication log
        if( CheckWritesPerHour() )
        {
            TrkLog(( TRKDBG_SVR, TEXT("Aborting refresh due to writes-per-hour") ));
            TrkRaiseException( TRK_E_SERVER_TOO_BUSY );
        }

        // Ensure this volume is owned by the machine.
        // mikehill_test

        if( !VerifyMachineOwnsVolume( mcidClient, pRefresh->avolid[i] ))
        {
            TrkLog(( TRKDBG_WARNING,
                     TEXT("Machine can't touch volume it doesn't own (%s, %s)"),
                     (const TCHAR*) CDebugString(mcidClient),
                     (const TCHAR*) CDebugString(pRefresh->avolid[i]) ));
            continue;
        }

        // Touch the entry in the volume table
        if( _voltab.Touch( pRefresh->avolid[i] ))
            IncrementWritesPerHour();
    }


}

void
CTrkSvrSvc::Statistics( TRKSVR_STATISTICS *pStatistics )
{
    pStatistics->cSyncVolumeRequests      = _Stats.cSyncVolumeRequests;
    pStatistics->cSyncVolumeErrors        = _Stats.cSyncVolumeErrors;
    pStatistics->cSyncVolumeThreads       = _Stats.cSyncVolumeThreads;

    pStatistics->cCreateVolumeRequests    = _Stats.cCreateVolumeRequests;
    pStatistics->cCreateVolumeErrors      = _Stats.cCreateVolumeErrors;
    pStatistics->cClaimVolumeRequests     = _Stats.cClaimVolumeRequests;
    pStatistics->cClaimVolumeErrors       = _Stats.cClaimVolumeErrors;
    pStatistics->cQueryVolumeRequests     = _Stats.cQueryVolumeRequests;
    pStatistics->cQueryVolumeErrors       = _Stats.cQueryVolumeErrors;
    pStatistics->cFindVolumeRequests      = _Stats.cFindVolumeRequests;
    pStatistics->cFindVolumeErrors        = _Stats.cFindVolumeErrors;
    pStatistics->cTestVolumeRequests      = _Stats.cTestVolumeRequests;
    pStatistics->cTestVolumeErrors        = _Stats.cTestVolumeErrors;

    pStatistics->cSearchRequests          = _Stats.cSearchRequests;
    pStatistics->cSearchErrors            = _Stats.cSearchErrors;
    pStatistics->cSearchThreads           = _Stats.cSearchThreads;

    pStatistics->cMoveNotifyRequests      = _Stats.cMoveNotifyRequests;
    pStatistics->cMoveNotifyErrors        = _Stats.cMoveNotifyErrors;
    pStatistics->cMoveNotifyThreads       = _Stats.cMoveNotifyThreads;

    pStatistics->cRefreshRequests         = _Stats.cRefreshRequests;
    pStatistics->cRefreshErrors           = _Stats.cRefreshErrors;
    pStatistics->cRefreshThreads          = _Stats.cRefreshThreads;
    pStatistics->lRefreshCounter          = _refreshSequence.GetSequenceNumber();

    pStatistics->cDeleteNotifyRequests    = _Stats.cDeleteNotifyRequests;
    pStatistics->cDeleteNotifyErrors      = _Stats.cDeleteNotifyErrors;
    pStatistics->cDeleteNotifyThreads     = _Stats.cDeleteNotifyThreads;

    pStatistics->ftLastSuccessfulRequest  = _Stats.cftLastSuccessfulRequest;
    pStatistics->ftServiceStart           = _Stats.cftServiceStartTime;

    //pStatistics->ulGCIterationPeriod      = _Stats.ulGCIterationPeriod;
    //pStatistics->cEntriesToGC             = _Stats.cEntriesToGC;
    pStatistics->cEntriesGCed             = _Stats.cEntriesGCed;

    pStatistics->hrLastError              = _Stats.hrLastError;
    pStatistics->ftNextGC                 = _timerGC.QueryOriginalDueTime();
    pStatistics->cLowestAvailableRpcThreads=_cLowestAvailableThreads;
    pStatistics->cAvailableRpcThreads     = _cAvailableThreads;
    pStatistics->cMaxRpcThreads           = MAX_SVR_THREADS;

    pStatistics->cNumThreadPoolThreads    = g_cThreadPoolThreads;
    pStatistics->cMostThreadPoolThreads   = g_cThreadPoolMaxThreads;
    //pStatistics->SvcCtrlState             = _svcctrl.GetState();
    pStatistics->cMaxDsWriteEvents        = _Stats.cMaxDsWriteEvents;
    pStatistics->cCurrentFailedWrites     = _Stats.cCurrentFailedWrites;

    _qtable.Statistics( pStatistics );

    OSVERSIONINFO verinfo;
    memset( &verinfo, 0, sizeof(verinfo) );
    verinfo.dwOSVersionInfoSize = sizeof(verinfo);

    if( GetVersionEx( &verinfo ))
    {
        pStatistics->Version.dwMajor      = verinfo.dwMajorVersion;
        pStatistics->Version.dwMinor      = verinfo.dwMinorVersion;
        pStatistics->Version.dwBuildNumber  = verinfo.dwBuildNumber;
    }
    else
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed GetVersionInfo (%lu)"), GetLastError() ));
    }

    return;

}

HRESULT
CTrkSvrSvc::SyncVolume(const CMachineId & mcidClient, TRKSVR_SYNC_VOLUME * pSyncVolume,
                       ULONG cUncountedCreates )
{
    HRESULT hr = S_OK;

    switch (pSyncVolume->SyncType)
    {
    case CREATE_VOLUME:

        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cCreateVolumeRequests) );

        if( CheckWritesPerHour() )
        {
            hr = TRK_E_SERVER_TOO_BUSY;
            TrkLog(( TRKDBG_VOLTAB | TRKDBG_WARNING,
                     TEXT("Rejected CreateVolume, too many writes (%d)"),
                     NumWritesThisHour() ));
        }
        else
        {
            hr = _voltab.PreCreateVolume(
                    mcidClient,
                    pSyncVolume->secret,
                    cUncountedCreates,
                    &pSyncVolume->volume );
            if( SUCCEEDED(hr) )
                IncrementWritesPerHour();
        }

        if(hr == S_OK)
        {
            TrkLog((TRKDBG_VOLTAB,
                TEXT("CreateVolume(machine=%s secret=%s volid(out)=%s) -> VOLUME_OK"),
                (const TCHAR*) CDebugString(mcidClient),
                (const TCHAR*) CDebugString(pSyncVolume->secret),
                (const TCHAR*) CDebugString(pSyncVolume->volume) ));
        }
        else
        {
            InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cCreateVolumeErrors) );

            TrkLog((TRKDBG_VOLTAB,
                TEXT("CreateVolume(machine=%s secret=%s) -> CreateFailed (%08x)"),
                (const TCHAR*) CDebugString(mcidClient),
                (const TCHAR*) CDebugString(pSyncVolume->secret),
                hr ));
        }
        break;

    case QUERY_VOLUME:

        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cQueryVolumeRequests) );

        hr = _voltab.QueryVolume(
                mcidClient,
                pSyncVolume->volume,
                &pSyncVolume->seq,
                &pSyncVolume->ftLastRefresh
                );

        TrkLog((TRKDBG_VOLTAB,
                TEXT("QueryVolume(machine=%s volid=%s seq(out)=%d ftLastRefresh(out)=%d) -> %s"),
                (const TCHAR*) CDebugString(mcidClient),
                (const TCHAR*) CDebugString(pSyncVolume->volume),
                pSyncVolume->seq,
                pSyncVolume->ftLastRefresh.dwLowDateTime,
                GetErrorString(hr)));

        if( FAILED(hr) )
            InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cQueryVolumeErrors) );

        break;

    case FIND_VOLUME:

        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cFindVolumeRequests) );

        hr = _voltab.FindVolume(
                pSyncVolume->volume,
                &pSyncVolume->machine
                );

        TrkLog((TRKDBG_VOLTAB,
                TEXT("FindVolume(volid=%s machine(out)=%s) -> %s"),
                (const TCHAR*) CDebugString(pSyncVolume->volume),
                (const TCHAR*) CDebugString(pSyncVolume->machine),
                GetErrorString(hr)));

        if( FAILED(hr) )
            InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cFindVolumeErrors) );

        break;

    case CLAIM_VOLUME:

        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cClaimVolumeRequests) );

        if( CheckWritesPerHour() )
        {
            hr = TRK_E_SERVER_TOO_BUSY;
            TrkLog(( TRKDBG_VOLTAB | TRKDBG_WARNING,
                     TEXT("Rejected ClaimVolume, too many writes (%d)"),
                     NumWritesThisHour() ));
        }
        else
        {
            hr = _voltab.ClaimVolume(
                    mcidClient,
                    pSyncVolume->volume,
                    pSyncVolume->secretOld,
                    pSyncVolume->secret,
                    &pSyncVolume->seq,
                    &pSyncVolume->ftLastRefresh
                    );
            if( S_OK == hr )    // Might return TRK_S_VOLUME_NOT_FOUND
                IncrementWritesPerHour();
        }

        TrkLog((TRKDBG_VOLTAB,
                TEXT("ClaimVolume(machine=%s volid=%s secret=%s->%s seq(out)=%d ftLastRefresh(out)=%s) -> %s"),
                (const TCHAR*) CDebugString(mcidClient),
                (const TCHAR*) CDebugString(pSyncVolume->volume),
                (const TCHAR*) CDebugString(pSyncVolume->secretOld),
                (const TCHAR*) CDebugString(pSyncVolume->secret),
                pSyncVolume->seq,
                (const TCHAR*) CDebugString(pSyncVolume->ftLastRefresh),
                GetErrorString(hr)));

        if( FAILED(hr) )
            InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cClaimVolumeErrors) );

        break;

    case TEST_VOLUME:

        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cTestVolumeRequests) );
    
        if( !(_configSvr.GetTestFlags() & TRK_TEST_FLAG_ALLOC_TEST_VOLUME) )
        {
            hr = E_NOTIMPL;
            break;
        }

        if( CVolumeSecret() != pSyncVolume->secret )
        {
            hr = _voltab.SetSecret( pSyncVolume->volume, pSyncVolume->secret );
            if( FAILED(hr) ) break;
        }

        hr = _voltab.SetSequenceNumber( pSyncVolume->volume, pSyncVolume->seq );
        if( FAILED(hr) ) break;

        if( CMachineId() != pSyncVolume->machine )
        {
            hr = _voltab.SetMachine( pSyncVolume->volume, pSyncVolume->machine );
            if ( FAILED(hr) ) break;
        }

        if( SUCCEEDED(hr) )
            IncrementWritesPerHour();

        if( FAILED(hr) )
            InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cTestVolumeErrors) );

        break;

    case DELETE_VOLUME:

        //InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cDeleteVolumeRequests) );

        if( CheckWritesPerHour() )
        {
            hr = TRK_E_SERVER_TOO_BUSY;
            TrkLog(( TRKDBG_VOLTAB | TRKDBG_WARNING,
                     TEXT("Rejected DeleteVolume, too many writes (%d)"),
                     NumWritesThisHour() ));
        }
        else
        {
            hr = _voltab.DeleteVolume(
                    mcidClient,
                    pSyncVolume->volume
                    );
            if( SUCCEEDED(hr) )
                IncrementWritesPerHour();
        }

        TrkLog((TRKDBG_VOLTAB,
                TEXT("DeleteVolume(machine=%s volid=%s  -> %s"),
                (const TCHAR*) CDebugString(mcidClient),
                (const TCHAR*) CDebugString(pSyncVolume->volume),
                GetErrorString(hr)));

        /*
        if( FAILED(hr) )
            InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cClaimVolumeErrors) );
        */

        break;

    default:
        TrkAssert(0 && "unknown switch type in SyncVolume");
        hr = TRK_S_VOLUME_NOT_FOUND;
        break;
    }

    return(hr);
}


//+----------------------------------------------------------------------------
//
//	CTrkSvrSvc::CountPrioritizedThread
//
//	This routine looks at the number of active threads in the service,
//   	and based on the priority of the message, accepts or rejects
//	the request.
//
//+----------------------------------------------------------------------------

//
// If we have 0 threads, then accept any pri <=9
// If we have 1 thread, then accept  any pri <=9
// If we have 2 threads, then accept any pri <=7
// If we have 3 threads, then accept any pri <=6
// If we have 4 threads, then accept any pri <=5
// If we have 5 threads, then accept any pri <=4
// If we have 6 threads, then accept any pri <=3
// If we have 7 threads, then accept any pri <=0
// If we have 8 threads, then accept any pri <=0
// If we have 9 threads, then accept any pri <=0
// If we have 10 threads, don't accept any
//

BOOL
CTrkSvrSvc::CountPrioritizedThread( const TRKSVR_MESSAGE_UNION * pMsg )
{

    static LONG Accept[10] = { 0, 0, 0, 3, 4, 5, 6, 7, 9, 9 };

    TrkAssert( ELEMENTS(Accept) == MAX_SVR_THREADS );

    // Get the current count of available threads

    LONG cAvailableThreads = InterlockedDecrement( &_cAvailableThreads ); 
    TrkAssert( cAvailableThreads < MAX_SVR_THREADS );

    // It's not worth a lock to protect this statistic, we'll just hope that we
    // don't get pre-empted during the update.

    _cLowestAvailableThreads = min( _cLowestAvailableThreads, cAvailableThreads );


    // There's already too many threads (cAvailableThreads is negative), or this
    // request is of insufficient priority, reject it.

    if (cAvailableThreads < 0 || pMsg->Priority > Accept[ cAvailableThreads ])
    {
        InterlockedIncrement( &_cAvailableThreads );

        TrkLog(( TRKDBG_WARNING,
			      TEXT("CountPrioritizedThread rejecting request (%d)"),
			      cAvailableThreads ));
        
        return( FALSE );
    }

    return(TRUE);
}

void
CTrkSvrSvc::ReleasePrioritizedThread()
{
    LONG l = InterlockedIncrement( &_cAvailableThreads );

    TrkAssert( l >= 0 && l <= MAX_SVR_THREADS );
}

HRESULT
CTrkSvrSvc::CreateVolume(const CMachineId & mcidClient, const TRKSVR_SYNC_VOLUME& pSyncVolume)
{
    return _voltab.AddVolidToTable(pSyncVolume.volume, mcidClient, pSyncVolume.secret );
}


void
CTrkSvrSvc::OnRequestStart( TRKSVR_MESSAGE_TYPE MsgType )
{
    switch( MsgType )
    {
    case SEARCH:
    case old_SEARCH:

        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cSearchRequests) );
        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cSearchThreads) );
        break;

    case MOVE_NOTIFICATION:

        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cMoveNotifyRequests) );
        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cMoveNotifyThreads) );
        break;

    case REFRESH:

        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cRefreshRequests) );
        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cRefreshThreads) );
        break;

    case SYNC_VOLUMES:

        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cSyncVolumeRequests) );
        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cSyncVolumeThreads) );
        break;

    case DELETE_NOTIFY:

        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cDeleteNotifyRequests) );
        InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cDeleteNotifyThreads) );
        break;

    case STATISTICS:
        break;

    default:
        TrkLog(( TRKDBG_ERROR, TEXT("Invalid MsgType in CTrkSvrSvc::OnRequestStart(%d)"),
                 MsgType ));
        TrkAssert( FALSE );
    }
}


void
CTrkSvrSvc::OnRequestEnd( TRKSVR_MESSAGE_UNION * pMsg, const CMachineId &mcid, HRESULT hr )
{
    int i = 0;

    __try
    {
        switch( pMsg->MessageType )
        {
        case SEARCH:
        case old_SEARCH:

            InterlockedDecrement( reinterpret_cast<LONG*>(&_Stats.cSearchThreads) );
            if( FAILED(hr)
                ||
                ( 1 <= pMsg->Search.cSearch && S_OK != pMsg->Search.pSearches->hr ))
            {
                InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cSearchErrors) );
            }
            _OperationLog.Add( COperationLog::TRKSVR_SEARCH, hr, mcid, pMsg->Search.pSearches->droidBirth );

            break;

        case MOVE_NOTIFICATION:

            InterlockedDecrement( reinterpret_cast<LONG*>(&_Stats.cMoveNotifyThreads) );
            if( S_OK != hr  )
                InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cMoveNotifyErrors) );
            _OperationLog.Add( COperationLog::TRKSVR_MOVE_NOTIFICATION, hr, mcid );

            break;

        case REFRESH:

            InterlockedDecrement( reinterpret_cast<LONG*>(&_Stats.cRefreshThreads) );
            if( FAILED(hr) )
                InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cRefreshErrors) );
            _OperationLog.Add( COperationLog::TRKSVR_REFRESH, hr, mcid, pMsg->Refresh.cSources, pMsg->Refresh.cVolumes );

            break;

        case SYNC_VOLUMES:

            InterlockedDecrement( reinterpret_cast<LONG*>(&_Stats.cSyncVolumeThreads) );
            if( FAILED(hr) )
                InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cSyncVolumeErrors) );
            _OperationLog.Add( COperationLog::TRKSVR_SYNC_VOLUMES, hr, mcid );
            break;

        case DELETE_NOTIFY:

            InterlockedDecrement( reinterpret_cast<LONG*>(&_Stats.cDeleteNotifyThreads) );
            if( FAILED(hr) )
                InterlockedIncrement( reinterpret_cast<LONG*>(&_Stats.cDeleteNotifyErrors) );
            _OperationLog.Add( COperationLog::TRKSVR_DELETE_NOTIFY, hr, mcid );

            break;

        case STATISTICS:
            break;

        }

        if( FAILED(hr) )
            SetLastError( hr );
        else if( STATISTICS != pMsg->MessageType )
            _Stats.cftLastSuccessfulRequest = CFILETIME();
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Ignoring exception in OnRequestEnd") ));
    }

    return;
}



//+----------------------------------------------------------------------------
//
//  CTrkSvrSvc::SvrMessage
//
//  This is the primary starting point for processing of the trksvr
//  service's LnkSvrMessage RPC method.  For the most part, it looks
//  at the MessageType (the request is in the form of a union, with
//  a message-type and type-appropriate parameters), then switches
//  to specific handler routine.
//
//+----------------------------------------------------------------------------

HRESULT
CTrkSvrSvc::SvrMessage(
    handle_t IDL_handle,
    TRKSVR_MESSAGE_UNION * pMsg)
{
    HRESULT hr = S_OK;
    ULONG i;
    ULONG cSources;
    CMachineId mcidClient;
    SThreadFromPoolState OriginalThreadFromPoolState;

    if (GetState() != SERVICE_RUNNING)
    {
        return(TRK_E_SERVICE_NOT_RUNNING);
    }

    // If we're getting busy (wrt active threads), we may have 
    // to reject this request, based on how busy we are and the
    // priority of the request.

    if (!CountPrioritizedThread( pMsg ))
    {
        return(TRK_E_SERVER_TOO_BUSY);
    }


    __try
    {

        // Set thread-specific settings, saving the old settings.
        OriginalThreadFromPoolState = InitializeThreadFromPool();

        // Update statistics
        OnRequestStart( pMsg->MessageType );

        // Ensure the client is authenticated.

        if( RequireSecureRPC() )
            CVerifyAuthentication::VerifyAuthentication( IDL_handle );

        if( STATISTICS == pMsg->MessageType )
        {
            // All messages that come in to this routine are from a machine account
            // (in which trkwks runs).  The exception to this rule is the Statistics
            // request, which comes from a user.  We'll allow all Authenticated Users
            // access to the statistics (they can access the DS tables by default
            // anyway).

            mcidClient = CMachineId( MCID_LOCAL );
        }
        else
        {
            mcidClient = NULL != pMsg->ptszMachineID && !g_ptrksvr->RequireSecureRPC()
                                    ? CMachineId(pMsg->ptszMachineID)
                                    : CMachineId(IDL_handle);
        }


        // Check for a client doing a denial-of-service attack.

        if( RequireSecureRPC() )    // Always true except in testing
            CheckClient(mcidClient);

        // Switch on the message type.

        switch (pMsg->MessageType)
        {

        case SEARCH:

            TrkLog((TRKDBG_MEND|TRKDBG_SVR, TEXT("SEARCH from \\\\%s"),    
                    (const TCHAR*) CDebugString( mcidClient )));

            for (i=0; i<pMsg->Search.cSearch; i++)
            {
                TrkAssert( NULL != pMsg->Search.pSearches );
                pMsg->Search.pSearches[i].hr = TRK_E_UNAVAILABLE;
            }
        
            for (i=0; i<pMsg->Search.cSearch; i++)
            {
                Search(&pMsg->Search.pSearches[i]);
            }
            break;

        case old_SEARCH:

            TrkLog((TRKDBG_MEND|TRKDBG_SVR, TEXT("old_SEARCH from \\\\%s"),
                    (const TCHAR*) CDebugString( mcidClient )));

            for (i=0; i<pMsg->old_Search.cSearch; i++)
            {
                pMsg->old_Search.pSearches[i].hr = TRK_E_UNAVAILABLE;
            }
        
            for (i=0; i<pMsg->old_Search.cSearch; i++)
            {
                old_Search(&pMsg->old_Search.pSearches[i]);
            }
            break;

        case MOVE_NOTIFICATION:

            TrkLog((TRKDBG_MOVE|TRKDBG_SVR, TEXT("MOVE_NOTIFICATION from \\\\%s (%d notifications)"),
                    (const TCHAR*) CDebugString( mcidClient ),
                    pMsg->MoveNotification.cNotifications ));

            hr = MoveNotify( mcidClient, &pMsg->MoveNotification );
            break;

        case REFRESH:

            TrkLog((TRKDBG_GARBAGE_COLLECT|TRKDBG_SVR, TEXT("REFRESH from \\\\%s"),
                    (const TCHAR*) CDebugString( mcidClient )));

            Refresh( mcidClient, &pMsg->Refresh );

            break;

        case SYNC_VOLUMES:
        {

            BOOL                fHaveCreateVolume = FALSE;
            ULONG cUncountedCreates = 0;


            // Validate the number of volumes in this request to protect against an unruly
            // client.

            if(pMsg->SyncVolumes.cVolumes > NUM_VOLUMES)
            {
                TrkLog((TRKDBG_ERROR, TEXT("Number of volumes exceeded per machine limit %d"), pMsg->SyncVolumes.cVolumes));
                TrkRaiseException( E_INVALIDARG );
            }

            // Pre-initialize the return buffer.

            for (i=0; i < pMsg->SyncVolumes.cVolumes; i++)
            {
                pMsg->SyncVolumes.pVolumes[i].hr = TRK_S_VOLUME_NOT_FOUND;
            }

            // Perform the sync for each of the volumes.

            for (i=0; i < pMsg->SyncVolumes.cVolumes; i++)
            {
                // Perform the sync.

                pMsg->SyncVolumes.pVolumes[i].hr
                    = SyncVolume(mcidClient, pMsg->SyncVolumes.pVolumes + i, cUncountedCreates );

                // Keep track of the number of CREATE_VOLUME sub-requests.

                if(CREATE_VOLUME == pMsg->SyncVolumes.pVolumes[i].SyncType &&
                   pMsg->SyncVolumes.pVolumes[i].hr == S_OK)
                {
                    fHaveCreateVolume = TRUE;
                    cUncountedCreates++;
                }

            }


            // If there were successful CREATE_VOLUME sub-requests in this
            // SYNC_VOLUME request, and the request is going to succeed
            // overall, update the DS.

            if(TRUE == fHaveCreateVolume && SUCCEEDED(hr) )
            {
	            for (i=0; i < pMsg->SyncVolumes.cVolumes; i++)
	            {
	                if(CREATE_VOLUME == pMsg->SyncVolumes.pVolumes[i].SyncType && S_OK == pMsg->SyncVolumes.pVolumes[i].hr)
	                {
	                    TrkLog(( TRKDBG_VOLTAB, TEXT("Finishing CreateVolume for %s"),
	                    	     (const TCHAR*) CDebugString(pMsg->SyncVolumes.pVolumes[i].volume )));
	                    pMsg->SyncVolumes.pVolumes[i].hr = 
	                        CreateVolume(mcidClient, pMsg->SyncVolumes.pVolumes[i]);
	                }
	            }

            }

            break;
        }

        case DELETE_NOTIFY:

            TrkLog((TRKDBG_OBJID_DELETIONS|TRKDBG_SVR,
                TEXT("DELETE_NOTIFY from \\\\%s"),
                     (const TCHAR*) CDebugString( mcidClient )));

            DeleteNotify( mcidClient, &pMsg->Delete );
            break;

        case STATISTICS:

            TrkLog(( TRKDBG_SVR, TEXT("TRKSVR_STATISTICS"),
                     (const TCHAR*) CDebugString(mcidClient) ));

            memset( &pMsg->Statistics, 0, sizeof(TRKSVR_STATISTICS) );
            Statistics( &pMsg->Statistics );

            break;

        default:
            hr = TRK_E_UNKNOWN_SVR_MESSAGE_TYPE;
            break;
        }
    }
    __except(BreakOnDebuggableException())
    {
        hr = GetExceptionCode();
        TrkLog((TRKDBG_ERROR, TEXT("LnkSvrMessage exception %08X caught during %s"),
                                   hr, 
                                   (const TCHAR*) CDebugString(pMsg->MessageType) ));
    }

    // Update statistics
    OnRequestEnd( pMsg, mcidClient, hr );

    ReleasePrioritizedThread();

    // Restore the thread-specif settings.
    UnInitializeThreadFromPool( OriginalThreadFromPoolState );

    return(hr);
}




HRESULT
StubLnkSvrMessage_Old(
    handle_t IDL_handle,
    TRKSVR_MESSAGE_UNION_OLD * pMsg)
{
    HRESULT hr;

    TrkLog((TRKDBG_SVR, TEXT("Received downlevel call: ... thunking")));

    TRKSVR_MESSAGE_UNION Msg2;

    Msg2.MessageType = pMsg->MessageType;
    Msg2.Priority = PRI_5;

    switch (Msg2.MessageType)
    {
        case (SEARCH):
            Msg2.Search = pMsg->Search;
            break;
        case (MOVE_NOTIFICATION):
            Msg2.MoveNotification = pMsg->MoveNotification;
            break;
        case (REFRESH):
            Msg2.Refresh = pMsg->Refresh;
            break;
        case (SYNC_VOLUMES):
            Msg2.SyncVolumes = pMsg->SyncVolumes;
            break;
        case (DELETE_NOTIFY):
            Msg2.Delete = pMsg->Delete;
            break;
    }

    Msg2.ptszMachineID = pMsg->ptszMachineID;

    hr = StubLnkSvrMessage( IDL_handle, &Msg2 );

    switch (Msg2.MessageType)
    {
        case (SEARCH):
            pMsg->Search = Msg2.Search;
            break;
        case (MOVE_NOTIFICATION):
            pMsg->MoveNotification = Msg2.MoveNotification;
            break;
        case (REFRESH):
            pMsg->Refresh = Msg2.Refresh;
            break;
        case (SYNC_VOLUMES):
            pMsg->SyncVolumes = Msg2.SyncVolumes ;
            break;
        case (DELETE_NOTIFY):
            pMsg->Delete = Msg2.Delete;
            break;
    }

    pMsg->ptszMachineID = Msg2.ptszMachineID;

    return(hr);

}

// must return a positive number (success code) if it doesn't want the caller
// to find another DC to do it on.

HRESULT
StubLnkSvrMessage(
    handle_t IDL_handle,
    TRKSVR_MESSAGE_UNION * pMsg)
{
    return( g_ptrksvr->SvrMessage( IDL_handle, pMsg ));
}


void
CTrkSvrRpcServer::Initialize( SVCHOST_GLOBAL_DATA * pSvcsGlobalData, CTrkSvrConfiguration * pTrkSvrConfig )
{
    RPC_STATUS          rpcstatus;
    NET_API_STATUS      netstatus;

    // Ensure there's a tcp/ip binding handle

    rpcstatus = RpcServerUseProtseq( const_cast<TCHAR*>(s_tszTrkSvrRpcProtocol),
                                     pTrkSvrConfig->GetSvrMaxRpcCalls(), NULL);

    if (rpcstatus != RPC_S_OK &&
        rpcstatus != RPC_S_DUPLICATE_ENDPOINT)
    {
        // Log an event, unless it's a not-supported error, which happens during
        // a normal setup.
        if( RPC_S_PROTSEQ_NOT_SUPPORTED != rpcstatus )
        {
            TrkLog((TRKDBG_ERROR, TEXT("RpcServerUseProtseqEp %08x"), rpcstatus));
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, HRESULT_FROM_WIN32(rpcstatus),
                                    TRKREPORT_LAST_PARAM );
        }
        TrkRaiseWin32Error(rpcstatus);
    }

    // If we don't have a pSvcsGlobalData (we're not running in services.exe),
    // tell RpcServerRegisterIfEx to automatically set up a listen thread.

    CRpcServer::Initialize( Stubtrksvr_v1_0_s_ifspec, 
                            NULL == pSvcsGlobalData ? RPC_IF_AUTOLISTEN : 0,
                            pTrkSvrConfig->GetSvrMaxRpcCalls(),
                            RpcSecurityEnabled(),     // fSetAuthInfo
                            s_tszTrkSvrRpcProtocol );

    TrkLog(( TRKDBG_RPC, TEXT("Registered TrkSvr RPC server %s (%d)"),
             RpcSecurityEnabled() ? TEXT("") : TEXT("(without authorization)"),
             pTrkSvrConfig->GetSvrMaxRpcCalls() ));

}


void
CTrkSvrRpcServer::UnInitialize( SVCHOST_GLOBAL_DATA * pSvcsGlobalData )
{
    TrkLog(( TRKDBG_RPC, TEXT("Unregistering TrkSvr RPC server") ));
    CRpcServer::UnInitialize( );
    TrkLog(( TRKDBG_RPC, TEXT("Unregistered TrkSvr RPC server") ));
}



CMachineId::CMachineId(handle_t ClientBinding)
{
    RPC_STATUS  RpcStatus;
    NTSTATUS    status;
    BOOL        f;
    HANDLE      hToken = NULL;
    PTOKEN_USER pToken;
    BYTE *      pbToken = NULL;
    PSID        LocalSystemSid = NULL;

    PUNICODE_STRING pUserName   = NULL;
    PUNICODE_STRING pUserDomainName = NULL;

    NET_API_STATUS NetStatus;

    WCHAR       *pwszDomain = NULL;
    BOOLEAN     fIsWorkGroup;
    LPBYTE      pbAccountInfo = NULL;
    BOOL        fImpersonating = FALSE;

    // Begin impersonating the user.

    RpcStatus = RpcImpersonateClient(ClientBinding);
    if (RpcStatus != RPC_S_OK)
        TrkRaiseWin32Error(RpcStatus);
    fImpersonating = TRUE;

    __try
    {
        WCHAR wszCurrentUser[ UNLEN+1 ];
        WCHAR wszDomainName[ CNLEN+1 ];

        // Get the local domain name (so we can verify it against the user's).

        NetStatus = NetpGetDomainNameEx(&pwszDomain, &fIsWorkGroup);
        if (NetStatus != NO_ERROR)
        {
            pwszDomain = NULL;
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, HRESULT_FROM_WIN32(NetStatus),
                                    TRKREPORT_LAST_PARAM );
            TrkRaiseWin32Error(NetStatus);
        }
        TrkAssert( !fIsWorkGroup );

        // Get the user's name & domain (possible because we're
        // impersonating).

        status = LsaGetUserName( &pUserName, &pUserDomainName );
        if( !NT_SUCCESS(status) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get user name (%08x)"), status ));
            TrkRaiseNtStatus( status );
        }

        memcpy( wszCurrentUser, pUserName->Buffer, pUserName->Length );
        wszCurrentUser[ pUserName->Length / sizeof(WCHAR) ] = L'\0';

        // Ensure this is a user in this domain
        {
            UNICODE_STRING LocalDomainName = { 0, 0, NULL };
            RtlInitUnicodeString( &LocalDomainName, pwszDomain );

            if( 0 != RtlCompareUnicodeString( pUserDomainName, &LocalDomainName, TRUE ))
            {
                TrkLog(( TRKDBG_WARNING, TEXT("User %s is from another domain"),
                         wszCurrentUser ));
                TrkRaiseException( TRK_E_UNKNOWN_SID );
            }
        }

        // The user name should end in a '$', since it should be a
        // machine account.

        if (wszCurrentUser[ pUserName->Length / sizeof(WCHAR) - 1] != L'$')
        {
            // No dollar suffix, it's probably local system on the DC

            DWORD SizeRequired;
            
            // Get the user's SID

            if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open thread token for %ws (%08x)"), wszCurrentUser, HRESULT_FROM_WIN32(GetLastError()) ));
                TrkRaiseLastError();
            }
            
            if (!GetTokenInformation( hToken,
                     TokenUser,
                     NULL,
                     0,
                     &SizeRequired ) && GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get thread token information (1) for %ws (%08x)"), wszCurrentUser, HRESULT_FROM_WIN32(GetLastError()) ));
                TrkRaiseLastError();
            }

            pbToken = new BYTE [SizeRequired];
            if (pbToken == NULL)
                TrkRaiseWin32Error(ERROR_NOT_ENOUGH_MEMORY);

            pToken = (PTOKEN_USER) pbToken;

            if (!GetTokenInformation( hToken,
                     TokenUser,
                     pToken,
                     SizeRequired,
                     &SizeRequired ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get thread token information (2) for %ws (%08x)"), wszCurrentUser, HRESULT_FROM_WIN32(GetLastError()) ));
                TrkRaiseLastError();
            }

            // Get the local system SID

            SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;

            if (! AllocateAndInitializeSid(
                 &NtAuthority,
                 1,
                 SECURITY_LOCAL_SYSTEM_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &LocalSystemSid ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't Alloc/Init SID for %ws (%08x)"), wszCurrentUser, HRESULT_FROM_WIN32(GetLastError()) ));
                TrkRaiseLastError();
            }

            // Verify that the user is local system.

            BOOL fEqual = EqualSid( pToken->User.Sid, LocalSystemSid );

            if (!fEqual)
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Unknown SID:  %ws"), wszCurrentUser ));
                TrkRaiseException(TRK_E_UNKNOWN_SID);
            }

            *this = CMachineId(MCID_LOCAL);
            Normalize();
            AssertValid();
            
        }   // if (wszCurrentUser[ pUserName->Length / sizeof(WCHAR) - 1] != L'$')

        else
        {
            // We don't need to be impersonating any longer, potentially (though
            // not likely) ACLs on the SAM could prevent the impersonated user
            // from making this call.  So we might as well revert now.

            TrkAssert( fImpersonating );
            if( fImpersonating )
            {
                RpcRevertToSelf();
                fImpersonating = FALSE;
            }

            // Get account info for this user, so we can
            // verify that it's a machine account.

            NetStatus = NetUserGetInfo( NULL, // Check on this server
                                        wszCurrentUser,
                                        1, // Get USER_INFO_1
                                        &pbAccountInfo );
    
    
            if (NetStatus != 0)
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get user %s info (%08x)"),
                         wszCurrentUser,
                         NetStatus));
                TrkRaiseWin32Error(NetStatus);
            }
    
            TrkLog(( TRKDBG_SVR, TEXT("\nUser is %s"), wszCurrentUser));
    
            if ((((USER_INFO_1*)pbAccountInfo)->usri1_flags &
                (UF_WORKSTATION_TRUST_ACCOUNT | UF_SERVER_TRUST_ACCOUNT)) == 0)
            {
                // if the account is not a workstation or backup dc account, fail
                TrkRaiseException( TRK_E_CALLER_NOT_MACHINE_ACCOUNT );
            }
    
            // overwrite the $
            wszCurrentUser[ pUserName->Length / sizeof(WCHAR) - 1] = L'\0';
            
            if (_tcslen(wszCurrentUser) + 1 > sizeof(_szMachine))
                TrkRaiseException(TRK_E_IMPERSONATED_COMPUTERNAME_TOO_LONG);
            else if( TEXT('\0') == wszCurrentUser[0] )
                TrkRaiseException( TRK_E_NULL_COMPUTERNAME );
    
            memset(&_szMachine, 0, sizeof(_szMachine));


            // Convert the Unicode computer name into Ansi, using
            // the OEMCP codepage (NetBios/computer names are always
            // in OEMCP, not Window/Ansi).

            if( 0 == WideCharToMultiByte( CP_OEMCP, 0,
                                          wszCurrentUser,
                                          -1,
                                          _szMachine,
                                          sizeof(_szMachine),
                                          NULL, NULL ))
            {
                TrkLog(( TRKDBG_ERROR,
                         TEXT("Couldn't convert machine name %s to multi-byte (%lu)"),
                         wszCurrentUser, GetLastError() ));
                TrkRaiseLastError();
            }

            TrkLog(( TRKDBG_WARNING,
                     TEXT("Converted machine name: %hs (from %s, ")
                     MCID_BYTE_FORMAT_STRING,
                     _szMachine, wszCurrentUser,
                     (BYTE)_szMachine[0], (BYTE)_szMachine[1], (BYTE)_szMachine[2], (BYTE)_szMachine[3],
                     (BYTE)_szMachine[4], (BYTE)_szMachine[5], (BYTE)_szMachine[6], (BYTE)_szMachine[7],
                     (BYTE)_szMachine[8], (BYTE)_szMachine[9], (BYTE)_szMachine[10], (BYTE)_szMachine[11],
                     (BYTE)_szMachine[12], (BYTE)_szMachine[13], (BYTE)_szMachine[14], (BYTE)_szMachine[15] ));

            Normalize();
            AssertValid();
        
        }   // if (wszCurrentUser[ pUserName->Length / ... else
    }
    __finally
    {
        if( fImpersonating )
        {
            RpcRevertToSelf();
            fImpersonating = FALSE;
        }

        if (hToken != NULL)
        {
            CloseHandle(hToken);
        }
        if (pbToken != NULL)
        {
            delete [] pbToken;
        }
        if (LocalSystemSid != NULL)
        {
            FreeSid( LocalSystemSid );
        }

        if (pUserName != NULL)
        {
            LsaFreeMemory(pUserName->Buffer);
            LsaFreeMemory(pUserName);
        }
        if (pUserDomainName != NULL)
        {
            LsaFreeMemory(pUserDomainName->Buffer);
            LsaFreeMemory(pUserDomainName);
        }

        if (pbAccountInfo != NULL)
        {
            NetApiBufferFree(pbAccountInfo);
        }

        if( NULL != pwszDomain )
            NetApiBufferFree(pwszDomain);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trksvr\svrmain.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       svrmain.cxx
//
//  Contents:   Main startup for Tracking (Server) Service
//
//  Classes:
//
//  Functions:
//
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:
//
//  Codework:   UnInitialize RPC.
//              LnkSvrMoveNotify must not be passed machine id.
//              RPC stub routines should not catch exceptions.
//
//--------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#define THIS_FILE_NUMBER    SVRMAIN_CXX_FILE_NO

#define TRKDATA_ALLOCATE
#include "trksvr.hxx"
#undef TRKDATA_ALLOCATE



//+----------------------------------------------------------------------------
//
//
//+----------------------------------------------------------------------------

HANDLE g_hWait = NULL;

void
ServiceStopCallback( PVOID pContext, BOOLEAN fTimeout )
{
    CTrkSvrSvc *ptrksvr = reinterpret_cast<CTrkSvrSvc*>(pContext);

    __try
    {
        UnregisterWait( g_hWait );
        g_hWait = NULL;

        // Close down the service.  This could block while threads are
        // completed.

        ptrksvr->UnInitialize( S_OK );
        TrkLog((TRKDBG_SVR, TEXT("TrkSvr service stopped") ));
        CTrkRpcConfig::_fInitialized = FALSE;
        delete ptrksvr;

        TrkAssert( NULL == g_ptrksvr );
        TrkAssert( 0 == g_cThreadPoolRegistrations );

        // Uninitialize the DLL since it's never actually unloaded.

        CommonDllUnInit( &g_ctrksvr );
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Exception during service stop - %08x"), GetExceptionCode() ));
    }

#if DBG
    TrkDebugDelete( );
#endif

}


//+----------------------------------------------------------------------------
//
//  ServiceMain
//
//  This function is exported from the dll, and is called when we run
//  under svchost.exe.
//
//+----------------------------------------------------------------------------

VOID WINAPI
ServiceMain(DWORD dwArgc, LPTSTR *lptszArgv)
{
    SVCS_ENTRY_POINT( dwArgc, lptszArgv, NULL, NULL );
}




//+----------------------------------------------------------------------------
//
//  ServiceEntry
//
//  This function is also exported from the dll, and is called directly when
//  we run under services.exe (the normal case), but is also called by
//  ServiceMain when we run under svchost.exe.  We distinguish between the
//  two by checking pSvcsGlobalData (non-NULL iff running under services.exe).
//
//  Since we use the Win32 thread pool, this routine returns after some
//  initialization, it isn't held for the lifetime of the service (except
//  when run under svchost.exe).
//
//+----------------------------------------------------------------------------

VOID
SVCS_ENTRY_POINT(
    DWORD NumArgs,
    LPTSTR *ArgsArray,
    PSVCHOST_GLOBAL_DATA pSvcsGlobalData,
    IN HANDLE  SvcRefHandle
    )
{

    HRESULT     hr = S_OK;
    BOOL fDllInitialized = FALSE;
    CTrkSvrSvc *ptrksvr = NULL;

    __try
    {
        #if DBG
            {
                CTrkConfiguration cTrkConfiguration;
                cTrkConfiguration.Initialize();

                TrkDebugCreate( cTrkConfiguration._dwDebugStoreFlags, "TrkSvr" );
                cTrkConfiguration.UnInitialize();
            }
        #endif

        // Initialize the DLL itself.  This raises if there is already an instance
        // of this service running.

        CommonDllInit( &g_ctrksvr );
        fDllInitialized = TRUE;

        TrkLog(( TRKDBG_SVR, TEXT("\n") ));

        // Create and initialize the primary service object

        ptrksvr = new CTrkSvrSvc;
        if( NULL == ptrksvr )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't alloc CTrkSvrSvc") ));
            return;
        }
        ptrksvr->Initialize( pSvcsGlobalData );    // sets g_ptrksvr

    }
    __except(BreakOnDebuggableException())
    {
        hr = GetExceptionCode();
        TrkLog((TRKDBG_ERROR, TEXT("couldn't initialize, hr=%08X"),hr));

        if( NULL != ptrksvr )
        {
            __try
            {
                ptrksvr->UnInitialize( hr );
            }
            __except( EXCEPTION_EXECUTE_HANDLER )
            {
                TrkAssert( !TEXT("Unexpected exception in trksvr!ServiceEntry") );
            }
            TrkAssert( NULL == g_ptrksvr );
            delete ptrksvr;
            ptrksvr = NULL;
        }

        if( fDllInitialized )
            CommonDllUnInit( &g_ctrksvr );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trksvr\voltab.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       voltab.cxx
//
//  Contents:   volumes table
//
//  Classes:
//
//  Functions:
//
//
//
//  History:    16-Dec-96  MikeHill Created.
//              23-Jan-97  BillMo   Added support for synchronizing clients
//                                  after a DC restore.
//
//  Notes:      There are two sequence numbers that pertain to each volume.
//
//              The first sequence number is used to synchronize the machine
//              move logs with the object move table. This sequence number
//              is relevant to QueryVolume, ClaimVolume, GetVolumeInfo.
//
//              The second sequence number is used to synchronize the
//              automatic backup of the volume to machine table.
//
//  Codework:
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "trksvr.hxx"
#include <commctrl.h>
#include <time.h>

#define MAX_MACHINE_BUF_CHARS 256

TCHAR s_RestoreVolumes[] = TEXT("Software\\Microsoft\\LinkTrack\\RestoreVolumes");

class CLdapTimeVolChange
{
public:
    CLdapTimeVolChange()
    {
        memset(_abPad,0,sizeof(_abPad));
    }

    CLdapTimeVolChange(const CFILETIME &cft)
    {
        _cft = cft;
        memset(_abPad,0,sizeof(_abPad));
    }

    void Swap();

    inline BYTE & Byte(int i)
    {
        return( ((BYTE*)this)[i] );
    }

    CFILETIME _cft;
    BYTE _abPad[sizeof(GUID) - sizeof(CFILETIME)];
};

void
CLdapTimeVolChange::Swap()
{
    BYTE b;

    for (int i=0; i<sizeof(*this)/2; i++)
    {
        b = Byte(i);
        Byte(i) = Byte(sizeof(*this)-i-1);
        Byte(sizeof(*this)-i-1) = b;
    }
}

class CLdapSecret
{
public:
    CLdapSecret()
    {
        memset(_abPad,0,sizeof(_abPad));
    }

    CLdapSecret(const CVolumeSecret &secret)
    {
        _secret = secret;
        memset(_abPad,0,sizeof(_abPad));
    }

    CVolumeSecret _secret;
    BYTE _abPad[sizeof(GUID) - sizeof(CVolumeSecret)];
};


void
CVolumeTable::Initialize(CTrkSvrConfiguration *pconfigSvr, CQuotaTable* pqtable)
{
    _fInitializeCalled = TRUE;

    _pqtable = pqtable;
    _pconfigSvr = pconfigSvr;

#ifdef VOL_REPL
    //  Can raise an NTSTATUS so put before fInitializeCalled=TRUE
    InitializeCriticalSection(&_csQueryCache);  

    if (pwm != NULL)
    {

        //
        // Initialize the cache immediately ready for client queries
        // Service start time, query may take a while. Dependency on ldap being available.
        // => Make this lazy.
        //

        _SecondsPreviousToNow = _pconfigSvr->GetVolumeQueryPeriod()
                                *  _pconfigSvr->GetVolumeQueryPeriods();

        _cftCacheLowest.SetToUTC();
        _cftCacheLowest.DecrementSeconds( _SecondsPreviousToNow );

        // search for all changes since now-period*numperiods (may throw on out of memory)
        _QueryVolumeChanges( _cftCacheLowest, &_VolMap );

        // timer should go off in about 6 hrs
        CFILETIME cft;
        cft.IncrementSeconds(VolumeQueryPeriodSeconds);
        _timerQueryCache.Initialize(this, pwm, 0, VolumeQueryPeriodSeconds, &cft);
    }
#endif
}

void
CVolumeTable::UnInitialize()
{
    if (_fInitializeCalled)
    {
        _fInitializeCalled = FALSE;

#ifdef VOL_REPL
        _timerQueryCache.UnInitialize();

        DeleteCriticalSection(&_csQueryCache);

        _VolMap.UnInitialize();
#endif
    }
}

#ifdef VOL_REPL
void
CVolumeTable::Timer( DWORD dwTimerId )
{
    // redo the query - will leave _VolMap unchanged on error
    // On low memory exception we should retry the timer.

    Raise if stopped

    CFILETIME cftHighest;
    CFILETIME cft;
    cft.DecrementSeconds( _SecondsPreviousToNow );

    CVolumeMap VolMap;

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);

    TrkLog((TRKDBG_VOLTAB | TRKDBG_VOLTAB_RESTORE, TEXT("Volume table cache timer")));

    // search for all changes since now-period*numperiods (may throw on out of memory)
    _QueryVolumeChanges( cft, &VolMap );

    EnterCriticalSection(&_csQueryCache);

    _cftCacheLowest = cft;
    VolMap.MoveTo(&_VolMap);

    LeaveCriticalSection(&_csQueryCache);
}

#if DBG
void
CVolumeTable::PurgeCache()
{
    EnterCriticalSection(&_csQueryCache);

    _cftCacheLowest = CFILETIME(0);
    _VolMap.UnInitialize();

    LeaveCriticalSection(&_csQueryCache);
}
#endif

#endif

HRESULT
CVolumeTable::MapResult(int err) const
{
    if (err == LDAP_SUCCESS)
    {
        return(S_OK);
    }
    else
    if (err == LDAP_NO_SUCH_OBJECT)
    {
        return(TRK_S_VOLUME_NOT_FOUND);
    }
    else
    {
        TrkRaiseWin32Error(LdapMapErrorToWin32(err));
        return(TRK_S_VOLUME_NOT_FOUND);
    }
}


HRESULT
CVolumeTable::AddVolidToTable( const CVolumeId & volume,
                               const CMachineId & mcidClient,
                               const CVolumeSecret & secret )
{
    CVolumeId          volidZero;
    CLdapVolumeKeyDn   dnKey(GetBaseDn(), volume);
    CLdapStringMod     lsmClass(s_objectClass, s_linkTrackVolEntry, LDAP_MOD_ADD);
    CLdapSecret        ls(secret);
    CLdapBinaryMod     lbmVolumeSecret(s_volumeSecret, (PCHAR)&ls, sizeof(ls), LDAP_MOD_ADD);
    CLdapBinaryMod     lbmMachineId(s_currMachineId, (PCHAR)&mcidClient, sizeof(mcidClient), LDAP_MOD_ADD);
    CLdapSeqNum        lsn;
    CLdapStringMod     lsmSequence(s_seqNotification, lsn, LDAP_MOD_ADD );
    CLdapTimeValue     ltv;    // current time
    CLdapStringMod     lsmTimeVolChange(s_timeVolChange, ltv, LDAP_MOD_ADD);

    // When writing the zero volume (the refresh sequence number itself), write a 0 for the
    // sequence number.  (Calling _pRefreshSequenceStorage would cause an infinite loop).
    CLdapRefresh       ltvRefresh( volidZero == volume ? 0 : _pRefreshSequenceStorage->GetSequenceNumber() );
    CLdapStringMod     lsmRefresh(s_timeRefresh, ltvRefresh, LDAP_MOD_ADD);

    LDAPMod * mods[7];

    mods[0] = &lsmClass._mod;
    mods[1] = &lbmVolumeSecret._mod;
    mods[2] = &lbmMachineId._mod;
    mods[3] = &lsmSequence._mod;
    mods[4] = &lsmTimeVolChange._mod;

    // Don't write a refresh time for the null volume (this entry is used
    // to store the current global refresh counter).

    if( CVolumeId() != volume )
    {
        mods[5] = &lsmRefresh._mod;
        mods[6] = 0;
    }
    else
        mods[5] = 0;

    int err = ldap_add_s( Ldap(), dnKey, mods );

    if( LDAP_ALREADY_EXISTS == err )
    {
        ldap_delete_s( Ldap(), dnKey );
        err = ldap_add_s( Ldap(), dnKey, mods );
    }

    if( LDAP_SUCCESS == err )
        _pqtable->IncrementVolumeCountCache();
    else
        TrkLog(( TRKDBG_ERROR, TEXT("Failed AddVolidToDs (%d)"), err ));

    return MapResult(err);
}

HRESULT
CVolumeTable::PreCreateVolume( const CMachineId & mcidClient,
                               const CVolumeSecret & secret,
                               ULONG cUncountedVolumes,
                               CVolumeId * pvolume )
{
    int             err;
    RPC_STATUS      Status;
    CMachineId      mcidZero(MCID_INVALID);
    ULONG           cVolumes = 0;

    if(mcidClient != mcidZero && _pqtable->IsVolumeQuotaExceeded(mcidClient, cUncountedVolumes))
    {
        TrkLog((TRKDBG_ERROR, TEXT("Volume quota exceeded for %s"),
                (const TCHAR*) CDebugString(mcidClient) ));
        return TRK_E_VOLUME_QUOTA_EXCEEDED;
    }

    Status = pvolume->UuidCreate();
    if (Status != RPC_S_OK )
    {
        // Since we use the randomized-guid generation algorithm,
        // we should never get a local guid.
        TrkAssert( RPC_S_UUID_LOCAL_ONLY != Status );

        TrkRaiseWin32Error(Status);
    }

    return S_OK;
}

HRESULT
CVolumeTable::QueryVolume( const CMachineId & mcidClient,
                           const CVolumeId & volume,
                           SequenceNumber * pseq,
                           FILETIME * pftLastRefresh )
{
    HRESULT hr;
    CMachineId mcidTable;
    SequenceNumber seq;
    CVolumeSecret secret;
    CFILETIME cftRefresh(0);

    if (volume == CVolumeId())
    {
        TrkRaiseException( TRK_E_INVALID_VOLUME_ID );
    }

    hr = GetVolumeInfo(volume, &mcidTable, &secret, &seq, &cftRefresh );

    if (S_OK == hr)
    {
        // if (its not the right machine), or (it is the right machine and a nul secret)
        if (mcidTable != mcidClient || secret == CVolumeSecret())
        {
            return(TRK_S_VOLUME_NOT_OWNED);
        }
        *pseq = seq;
        *pftLastRefresh = cftRefresh;
    }

    return(hr);
}

HRESULT
CVolumeTable::FindVolume( const CVolumeId & volume, CMachineId * pmcid )
{
    HRESULT hr;
    CMachineId mcidTable;
    SequenceNumber seq;
    CVolumeSecret secret;
    CFILETIME cftRefresh(0);

    if (volume == CVolumeId())
    {
        TrkRaiseException( TRK_E_INVALID_VOLUME_ID );
    }

    hr = GetVolumeInfo(volume, &mcidTable, &secret, &seq, &cftRefresh );

    if (S_OK == hr)
    {
        *pmcid = mcidTable;
    }

    return(hr);

}



#if DBG
void
CVolumeTable::PurgeAll()
{
    int             err;
    TCHAR            *apszAttrs[2] = { TEXT("cn"), NULL };
    LDAPMessage *   pRes;
    TCHAR           tszVolumeTable[MAX_PATH+1];

    __try
    {
        _tcscpy(tszVolumeTable, s_VolumeTableRDN);
        _tcscat(tszVolumeTable, GetBaseDn());

        err = ldap_search_s( Ldap(),
                             tszVolumeTable,
                             LDAP_SCOPE_ONELEVEL,
                             TEXT("(objectclass=*)"),
                             apszAttrs,
                             0, // attribute types and values are wanted
                             &pRes );

        if (err == LDAP_SUCCESS)
        {
            // found it, lets get the attributes out

            int cEntries = ldap_count_entries(Ldap(), pRes);
            LDAPMessage * pEntry = ldap_first_entry(Ldap(), pRes);
            if (pEntry != NULL)
            {
                do
                {
                    TCHAR * ptszDn = ldap_get_dn(Ldap(), pEntry);

                    int errd = ldap_delete_s(Ldap(),ptszDn);

                    TrkLog((TRKDBG_ERROR, TEXT("Purged %s status %d"), ptszDn, errd));
                    ldap_memfree(ptszDn);

                } while ( pEntry = ldap_next_entry(Ldap(), pEntry));
            }
        }
    }
    __finally
    {
        if (err == LDAP_SUCCESS)
        {
            ldap_msgfree(pRes);
        }
    }
}
#endif

HRESULT
CVolumeTable::ClaimVolume( const CMachineId & mcidClient,
                           const CVolumeId & volume,
                           const CVolumeSecret & secretOld,
                           const CVolumeSecret & secretNew,
                           SequenceNumber * pseq,
                           FILETIME * pftLastRefresh )
{
    HRESULT hr;
    CMachineId mcidTable;
    SequenceNumber seq;
    CVolumeSecret secretCurrent;
    CVolumeSecret nullSecret;
    CFILETIME cftRefresh(0);

    if (volume == CVolumeId())
    {
        TrkRaiseException( TRK_E_INVALID_VOLUME_ID );
    }

    hr = GetVolumeInfo( volume, &mcidTable, &secretCurrent, &seq, &cftRefresh );
    if ( S_OK == hr )
    {
        hr = TRK_E_VOLUME_ACCESS_DENIED;

        if( mcidTable == mcidClient )
            hr = SetSecret( volume, secretNew );
        else if( secretOld == secretCurrent)
            hr = SetMachineAndSecret( volume, mcidClient, secretNew );
    }

    if ( S_OK == hr )
    {
        *pseq = seq;
    }

    TrkAssert( hr == TRK_E_VOLUME_ACCESS_DENIED ||
               hr == S_OK ||
               hr == TRK_S_VOLUME_NOT_FOUND );

    return(hr);
}




//+----------------------------------------------------------------------------
//
//  CVolumeTable::DeleteVolume
//
//  Delete an entry from the volume table, but only if the volume is owned
//  by the calling machine.
//
//+----------------------------------------------------------------------------

HRESULT
CVolumeTable::DeleteVolume( const CMachineId & mcidClient,
                            const CVolumeId & volume )
{
    HRESULT hr;
    int LdapError;
    CMachineId mcidTable;
    SequenceNumber seq;
    CVolumeSecret secret;
    CLdapVolumeKeyDn dnVolume(GetBaseDn(), volume);
    CFILETIME cftRefresh(0);

    if (volume == CVolumeId())
    {
        TrkRaiseException( TRK_E_INVALID_VOLUME_ID );
    }

    hr = GetVolumeInfo( volume, &mcidTable, &secret, &seq, &cftRefresh );
    if ( S_OK == hr )
    {
        if( mcidTable == mcidClient )
        {
            TrkLog(( TRKDBG_VOLTAB, TEXT("Deleting volume %s"),
                     (const TCHAR*) CDebugString(volume) ));

            LdapError = ldap_delete_s(Ldap(), dnVolume);
            if( LDAP_SUCCESS == LdapError )
            {
                hr = S_OK;
                _pqtable->DecrementVolumeCountCache();
            }
            else
                hr = HRESULT_FROM_WIN32( LdapMapErrorToWin32(LdapError) );
        }
        else
            hr = TRK_E_VOLUME_ACCESS_DENIED;
    }
#if DBG
    if( FAILED(hr) )
        TrkLog(( TRKDBG_ERROR, TEXT("Failed attempt to delete volume %s"),
                 (const TCHAR*) CDebugString(volume) ));
#endif
    return(hr);
}


HRESULT
CVolumeTable::GetMachine(const CVolumeId & volume, CMachineId * pmcid)
{
    CVolumeSecret secret;
    SequenceNumber seq;
    CFILETIME cftRefresh(0);

    return GetVolumeInfo( volume, pmcid, &secret, &seq, &cftRefresh );
}

HRESULT
CVolumeTable::SetMachine(const CVolumeId & volume, const CMachineId & mcid)
{
    CLdapVolumeKeyDn    dnKey(GetBaseDn(), volume);
    CLdapTimeValue      ltv;   // Defaults to current UTC
    //ltvc.Swap();
    CLdapStringMod      lsmTimeVolChange(s_timeVolChange, ltv, LDAP_MOD_REPLACE);
    CLdapBinaryMod      lbmMachineId(s_currMachineId, (PCHAR)&mcid, sizeof(mcid), LDAP_MOD_REPLACE);
    LDAPMod *           mods[3];
    HRESULT             hr;
    int                 err;

    mods[0] = &lbmMachineId._mod;
    mods[1] = &lsmTimeVolChange._mod;
    mods[2] = NULL;

    err = ldap_modify_s(Ldap(), dnKey, mods);

    hr = MapResult(err);

    return(hr);
}

HRESULT
CVolumeTable::SetSecret(const CVolumeId & volume, const CVolumeSecret & secret)
{
    CLdapVolumeKeyDn    dnKey(GetBaseDn(), volume);
    CLdapTimeValue      ltv;   // Defaults to current UTC
    CLdapStringMod      lsmTimeVolChange(s_timeVolChange, ltv, LDAP_MOD_REPLACE);
    CLdapSecret         ls(secret);
    CLdapBinaryMod      lbmVolumeSecret(s_volumeSecret, (PCHAR)&ls, sizeof(ls), LDAP_MOD_REPLACE);
    LDAPMod *           mods[3];
    HRESULT             hr;
    int                 err;

    mods[0] = &lbmVolumeSecret._mod;
    mods[1] = &lsmTimeVolChange._mod;
    mods[2] = NULL;

    err = ldap_modify_s(Ldap(), dnKey, mods);

    hr = MapResult(err);

    return(hr);
}


HRESULT
CVolumeTable::SetMachineAndSecret(const CVolumeId & volume, const CMachineId & mcid, const CVolumeSecret & secret)
{
    CLdapVolumeKeyDn    dnKey(GetBaseDn(), volume);
    CLdapTimeValue      ltv;   // Defaults to current UTC
    CLdapStringMod      lsmTimeVolChange(s_timeVolChange, ltv, LDAP_MOD_REPLACE);
    CLdapBinaryMod      lbmMachineId(s_currMachineId, (PCHAR)&mcid, sizeof(mcid), LDAP_MOD_REPLACE);
    CLdapSecret         ls(secret);
    CLdapBinaryMod      lbmVolumeSecret(s_volumeSecret, (PCHAR)&ls, sizeof(ls), LDAP_MOD_REPLACE);
    LDAPMod *           mods[4];
    HRESULT             hr;
    int                 err;

    mods[0] = &lbmMachineId._mod;
    mods[1] = &lbmVolumeSecret._mod;
    mods[2] = &lsmTimeVolChange._mod;
    mods[3] = NULL;

    err = ldap_modify_s(Ldap(), dnKey, mods);

    hr = MapResult(err);

    return(hr);
}


//+----------------------------------------------------------------------------
//
//  CVolumeTable::SetSequenceNumber
//  
//  Set the sequence number of a volume entry.  This is the value
//  of we expect to get in the next move-notification for this volume.
//  (This is used to detect if the trksvr & trkwks get out of sync.)
//
//+----------------------------------------------------------------------------

HRESULT
CVolumeTable::SetSequenceNumber(const CVolumeId & volume, SequenceNumber seq)
{
    int                err;
    HRESULT            hr;

    CLdapVolumeKeyDn   dnKey(GetBaseDn(), volume);
    CLdapSeqNum        lsn(seq);
    CLdapStringMod     lsmSequence(s_seqNotification, lsn, LDAP_MOD_REPLACE );

    LDAPMod * mods[2];

    // Set up the MODs array.

    mods[0] = &lsmSequence._mod;
    mods[1] = 0;

    // Perform the modification.

    err = ldap_modify_s(Ldap(), dnKey, mods);

    // Debug output

#if DBG
    if( LDAP_SUCCESS != err )
        TrkLog(( TRKDBG_SVR, TEXT("Couldn't set sequence number (%d)"), err ));
    else
        TrkLog(( TRKDBG_SVR, TEXT("Set seq %d on %s"), seq,
                 (const TCHAR*) CDebugString(volume) ));
#endif

    // Map back to an HRESULT

    hr = MapResult(err);

    return(hr);
}

HRESULT
CVolumeTable::GetVolumeInfo( const CVolumeId & volume,
                             CMachineId * pmcid,
                             CVolumeSecret * psecret,
                             SequenceNumber * pseq,
                             CFILETIME *pcftRefresh )
{
    // lookup the volume and get the current machine and sequence number if any
    HRESULT             hr;
    int                 err;
    LDAPMessage *       pRes = NULL;
    CLdapVolumeKeyDn    dnKey(GetBaseDn(), volume);
    struct berval **    ppbvMachineId = NULL;
    //struct berval **  ppbvSeq = NULL;
    TCHAR **            pptszSeq = NULL;
    struct berval **    ppbvSecret = NULL;
    TCHAR **            pptszRefresh = NULL;

    TCHAR       *       apszAttrs[5];

    __try
    {

        apszAttrs[0] = const_cast<TCHAR*>(s_currMachineId);
        apszAttrs[1] = const_cast<TCHAR*>(s_seqNotification);
        apszAttrs[2] = const_cast<TCHAR*>(s_volumeSecret);
        apszAttrs[3] = const_cast<TCHAR*>(s_timeRefresh);
        apszAttrs[4] = 0;

        err = ldap_search_s( Ldap(),
                             dnKey,
                             LDAP_SCOPE_BASE,
                             TEXT("(objectclass=*)"),
                             apszAttrs,
                             0, // attribute types and values are wanted
                             &pRes );


        hr = MapResult(err);

        if (S_OK == hr)
        {
            // found it, lets get the attributes out
            int cEntries;

            cEntries = ldap_count_entries(Ldap(), pRes);

            // Get the entry from the search results.

            if (cEntries < 1)
            {
                TrkLog(( TRKDBG_ERROR, TEXT("GetVolumeInfo: ldap_search for %s succeeded, but with %d entries"),
                         (TCHAR*) dnKey /*CDebugString(volume)._tsz*/, cEntries ));
                hr = MapResult(LDAP_NO_SUCH_OBJECT);
                __leave;
            }

            LDAPMessage * pEntry = ldap_first_entry(Ldap(), pRes);
            if (pEntry == NULL)
            {
                // This should also never happen.  We know at this point that we have
                // 1 entry in the search result.  We'll pretend that it doesn't exist.
                TrkLog(( TRKDBG_ERROR, TEXT("GetVolumeInfo: ldap_search has one entry, but it couldn't be retrieved") ));
                hr = MapResult(LDAP_NO_SUCH_OBJECT);
                __leave;
            }

            // Get the machine ID attribute.

            ppbvMachineId = ldap_get_values_len(Ldap(), pEntry, const_cast<TCHAR*>(s_currMachineId) );
            if( NULL == ppbvMachineId
                ||
                sizeof(CMachineId) > (*ppbvMachineId)->bv_len )
            {
                // This entry is corrupt, there should always be a mcid attribute.
                // We'll pretend it doesn't exist for now, and let GC clean it up.
                hr = MapResult(LDAP_NO_SUCH_OBJECT);
                __leave;
            }
            memcpy( pmcid, (*ppbvMachineId)->bv_val, sizeof(*pmcid) );

            // Get the volume secret attribute

            ppbvSecret = ldap_get_values_len(Ldap(), pEntry, const_cast<TCHAR*>(s_volumeSecret) );
            if( NULL == ppbvSecret
                ||
                sizeof(CLdapSecret) > (*ppbvSecret)->bv_len )
            {
                // This entry is corrupt, there should always be a secret attribute.
                // We'll pretend it doesn't exist for now, and let GC clean it up.
                hr = MapResult(LDAP_NO_SUCH_OBJECT);
                __leave;
            }
            memcpy( psecret, (*ppbvSecret)->bv_val, sizeof(*psecret) );

            // Get the sequence number attribute

            *pseq = 0;
            pptszSeq = ldap_get_values(Ldap(), pEntry, const_cast<TCHAR*>(s_seqNotification) );
            if (NULL == pptszSeq || CCH_UINT32 < _tcslen(*pptszSeq))
            {
                // The sequence number is missing or invalid.  We'll just assume it's zero.

                TrkLog((TRKDBG_ERROR, TEXT("Sequence number string too long in vol table (vol=%s)"),
                                   (const TCHAR*) CDebugString(volume) ));
            }
            else if( 1 != _stscanf( *pptszSeq, TEXT("%d"), pseq ))
            {
                // Again, assume the sequnce number is zero.
                TrkLog((TRKDBG_ERROR, TEXT("Invalid sequence number string in vol table (seq=%s, vol=%s)"),
                                   *pptszSeq, 
                                   (const TCHAR*) CDebugString(volume) ));
                *pseq = 0;
            }

            // Get the refresh counter, if it exists.

            *pcftRefresh = 0;
            pptszRefresh = ldap_get_values( Ldap(), pEntry, const_cast<TCHAR*>(s_timeRefresh) );
            if( NULL != pptszRefresh )
            {
                SequenceNumber seqRefresh = 0;
                if( 1 == _stscanf( *pptszRefresh, TEXT("%d"), &seqRefresh ))
                    *pcftRefresh = seqRefresh;
            }

        }
    }
    __finally
    {
        if (NULL != pRes)
        {
            ldap_msgfree(pRes);
        }

        if (ppbvMachineId != NULL)
        {
            ldap_value_free_len(ppbvMachineId);
        }

        if (pptszSeq != NULL)
        {
            ldap_value_free(pptszSeq);
        }

        if (ppbvSecret != NULL)
        {
            ldap_value_free_len(ppbvSecret);
        }

        if (pptszRefresh != NULL)
            ldap_value_free(pptszRefresh);

        if (AbnormalTermination())
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Exception in CVolumeTable::GetVolumeInfo") ));
        }
    }

    return(hr);
}

// TRUE if exists and touched, FALSE if not existent, exception otherwise.
// BUGBUG P2: check ownership of entry being touched.

BOOL
CVolumeTable::Touch(
    const CVolumeId & volid
    )
{

    if (volid == CVolumeId())
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Null volid passed to CVolumeTable::Touch") ));
        return( FALSE );
    }

    BOOL            fReturn = FALSE;
    int             err;
    CLdapRefresh    ltvRefresh( _pRefreshSequenceStorage->GetSequenceNumber());
    CLdapStringMod  lsmRefresh( s_timeRefresh, ltvRefresh, LDAP_MOD_REPLACE );
    CLdapVolumeKeyDn
                    dnKey(GetBaseDn(), volid);

    LDAPMod *       mods[2];
    TCHAR **        pptszRefresh = NULL;
    LDAPMessage   * pEntry = NULL;
    LDAPMessage*    pRes = NULL;


    __try
    {


        //
        // Check to see if the object already has this sequence number.
        //

        TCHAR*          rgptszAttrs[2];
        rgptszAttrs[0] = const_cast<TCHAR*>(s_timeRefresh);
        rgptszAttrs[1] = NULL;

        err = ldap_search_s(Ldap(),
                            dnKey,
                            LDAP_SCOPE_BASE,
                            TEXT("(ObjectClass=*)"),
                            rgptszAttrs,
                            0,
                            &pRes);


        if (err == LDAP_SUCCESS)
        {
            // The search call worked, but did we find an object?
            if( 1 == ldap_count_entries(Ldap(), pRes) )
            {
                // The object already exists
                pEntry = ldap_first_entry(Ldap(), pRes);
                if( NULL != pEntry )
                {
                    // Get the refresh counter
                    pptszRefresh = ldap_get_values( Ldap(), pEntry, const_cast<TCHAR*>(s_timeRefresh) );
                    if( NULL != pptszRefresh )
                    {
                        SequenceNumber seqRefresh = 0;
                        if( 1 == _stscanf( *pptszRefresh, TEXT("%d"), &seqRefresh ))
                        {
                            // First, long is the GC timer in seconds?
                            LONG lGCTimerInSeconds = _pconfigSvr->GetGCPeriod()     // 30 days in seconds
                                                     / _pconfigSvr->GetGCDivisor(); // 30

                            // Next, how many ticks is half the period?
                            LONG lWindow =  _pconfigSvr->GetGCPeriod()        // 30 days (in seconds)
                                            / 2                               // => 15 days (in seconds)
                                            / lGCTimerInSeconds;              // => 15
                            if( seqRefresh + lWindow
                                >= _pRefreshSequenceStorage->GetSequenceNumber()
                              )
                            {
                                TrkLog(( TRKDBG_GARBAGE_COLLECT | TRKDBG_VOLTAB,
                                         TEXT("Not touching volume %s with %d, seq %d already set"),
                                         (const TCHAR*) CDebugString(volid),
                                         _pRefreshSequenceStorage->GetSequenceNumber(),
                                         seqRefresh ));
                                __leave;
                            }
                        }
                    }
                }
            }
        }
        else if (err == LDAP_NO_SUCH_OBJECT)
        {
            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_VOLTAB,
                TEXT("Touch: volume %s not found"), 
                (const TCHAR*) CDebugString(volid)));
            __leave;
        }


        //
        // Set the correct sequence number
        //

        mods[0] = &lsmRefresh._mod;
        mods[1] = NULL;

        err = ldap_modify_s(Ldap(), dnKey, mods);

        if (err == LDAP_SUCCESS)
        {
            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_SVR,
                TEXT("Touch: volume %s touched"), 
                (const TCHAR*) CDebugString(volid)));
            fReturn = TRUE;
            __leave;
        }
        else
        if (err == LDAP_NO_SUCH_OBJECT)
        {
            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_SVR,
                TEXT("Touch:: volume %s doesn't exist"), 
                (const TCHAR*) CDebugString(volid)));
            __leave;
        }
        else
        if (err == LDAP_NO_SUCH_ATTRIBUTE)
        {
            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_SVR,
                TEXT("Touch: volume %s attribute not found"), 
                (const TCHAR*) CDebugString(volid)));

            // deal with old server data
            CLdapStringMod lsmRefresh( s_timeRefresh, ltvRefresh, LDAP_MOD_ADD );
            mods[0] = &lsmRefresh._mod;

            err = ldap_modify_s(Ldap(), dnKey, mods);
        }

        if (err != LDAP_SUCCESS)
        {
            TrkLog((TRKDBG_GARBAGE_COLLECT | TRKDBG_SVR,
                TEXT("Touch:: volume %s gives exceptional error"), 
                (const TCHAR*) CDebugString(volid)));

            __leave;
        }
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception in CVolumeTable::Touch (%08x)"), GetExceptionCode() ));
    }

    if (pptszRefresh != NULL)
        ldap_value_free(pptszRefresh);
    if(pRes != NULL)
        ldap_msgfree(pRes);

    return( fReturn );
}


//+----------------------------------------------------------------------------
//
//  CVolumeTable::GarbageCollect
//
//  This is called by CTrkSvrSvc when it's time to GC the volume table (daily).
//  The entries are enumerated, and if too old they are deleted.
//
//+----------------------------------------------------------------------------

ULONG
CVolumeTable::GarbageCollect( SequenceNumber seqCurrent, SequenceNumber seqOldestToKeep, const BOOL * pfAbort )
{
    CLdapVolumeKeyDn    dn(GetBaseDn());
    TCHAR *             apszAttrs[3];
    GC_ENUM_CONTEXT     EnumContext;

    TrkLog(( TRKDBG_VOLTAB | TRKDBG_GARBAGE_COLLECT, TEXT("GC-ing volume table (%d/%d)"),
             seqCurrent, seqOldestToKeep ));

    // Set up the attributes for the ldap_search_init_page call.

    apszAttrs[0] = const_cast<TCHAR*>(s_Cn);
    apszAttrs[1] = const_cast<TCHAR*>(s_timeRefresh);
    apszAttrs[2] = 0;

    // Set up all the info that the LdapEnumerate call needs.

    memset( &EnumContext, 0, sizeof(EnumContext) );
    EnumContext.seqOldestToKeep = seqOldestToKeep;
    EnumContext.seqCurrent = seqCurrent;
    EnumContext.pfAbort = pfAbort;
    EnumContext.dwRepetitiveTaskDelay = _pconfigSvr->GetRepetitiveTaskDelay();
    EnumContext.pqtable = _pqtable;

    // Do an ldap_search, calling GcEnumerateCallback for each of the
    // returned values.

    if (!LdapEnumerate(
        Ldap(),                     // LDAP handle
        dn,                         // Base DN
        LDAP_SCOPE_ONELEVEL,        // No recursion
        TEXT("(objectClass=*)"),    // Filter
        apszAttrs,                  // Attributes (get CN & refresh time)
        GcEnumerateCallback,        // Called for each iteration
        &EnumContext ))             // Info for GcEnuemrateCallback
    {
        TrkRaiseException(TRK_E_SERVICE_STOPPING);
    }

    TrkLog(( TRKDBG_GARBAGE_COLLECT | TRKDBG_IDT,
             TEXT("GC-ed %d entries from the volume table"),
             EnumContext.cEntries ));

    // If we actually deleted anything, the cached values
    // in the quota object are no longer valid.  Mark it as
    // such, so that it will know to re-generate it the next
    // time it's needed.

    if( 0 != EnumContext.cEntries )
        _pqtable->InvalidateCache();

    return EnumContext.cEntries;
}

ENUM_ACTION
GcEnumerateCallback( LDAP * pLdap, LDAPMessage *pMessage, PVOID pvContext, PVOID )
{
    GC_ENUM_CONTEXT * pContext = (GC_ENUM_CONTEXT *) pvContext;
    TCHAR * ptszDn = NULL;
    TCHAR ** pptszValue = NULL;
    ENUM_ACTION Action = ENUM_KEEP_ENTRY;
    ULONG ulSequence = 0;

    // See if we should abort.  We shouldn't even be here if we're not
    // the designated DC.  The only way it can happen is if the designated
    // DC is changed during the enumeration.

    if( *(pContext->pfAbort)
        ||
        !pContext->pqtable->IsDesignatedDc() )
    {
        Action = ENUM_ABORT;
        goto Exit;
    }

    // Get the DN of this entry so that we can check for special entries.

    ptszDn = ldap_get_dn( pLdap, pMessage );
    if (ptszDn == NULL)
    {
        TrkLog((TRKDBG_GARBAGE_COLLECT,
                TEXT("Couldn't get DN during GcEnumerateCallback") ));
        goto Exit;
    }

    // CQuotaTable stores special values in the volume table, all prefixed by "QT".
    // Don't delete those.

    if( !_tcsnicmp( TEXT("CN=QT"), ptszDn, 5 ))
    {
        TrkLog(( TRKDBG_GARBAGE_COLLECT,
                 TEXT("Skipping quota entry in GC (%s)"),
                 ptszDn ));
        goto Exit;
    }

    // The current value of the Refresh counter is stored in volume ID 0.  So
    // don't delete that either.

    if( !_tcsnicmp( TEXT("CN=00000000000000000000000000000000,"), ptszDn, 35 ))
    {
        TrkLog(( TRKDBG_GARBAGE_COLLECT,
                 TEXT("Skipping volid 0 GC (%s)"),
                 ptszDn ));
        goto Exit;
    }

    // Get the refresh time value.

    pptszValue = ldap_get_values( pLdap, pMessage, const_cast<TCHAR*>(s_timeRefresh) );

    if (pptszValue == NULL)
    {
        TrkLog((TRKDBG_GARBAGE_COLLECT,
                TEXT("Can't find sequence number in %s"),
                ptszDn));

        // This is a corrupted entry that will never get GC-ed,
        // so we'll delete it now.

        pContext->cEntries++;
        Action = ENUM_DELETE_ENTRY;
        goto Exit;
    }

    _stscanf( *pptszValue, TEXT("%d"), &ulSequence );

    // Determine if we should delete this entry.

    if( ulSequence < (ULONG)pContext->seqOldestToKeep )
    {
        Action = ENUM_DELETE_ENTRY;
        pContext->cEntries++;
    }
    else
        Action = ENUM_KEEP_ENTRY;


#if DBG
    if( ENUM_DELETE_ENTRY == Action )
        TrkLog(( TRKDBG_QUOTA, TEXT("Seq to delete:  %d/%d"),
                 ulSequence, (ULONG)pContext->seqOldestToKeep ));
#endif

    // Check to see if the entry has an invalid sequence number.  It's
    // invalid if it's bigger than the current value.  This can happen if the
    // special zero entry gets deleted from the volume table for some reason.

    if( ulSequence > (ULONG)pContext->seqCurrent )
    {
        // Reset the entry's sequence number to the current value.  Otherwise it
        // could be a very long time before it gets GCed.  This case should never
        // happen, but there's no guarantee that someone won't delete the 
        // entry accidentally.

        CLdapRefresh    ltvRefresh( pContext->seqCurrent );
        CLdapStringMod  lsmRefresh( s_timeRefresh, ltvRefresh, LDAP_MOD_REPLACE );
        int err;

        LDAPMod *       mods[2];

        mods[0] = &lsmRefresh._mod;
        mods[1] = NULL;

        err = ldap_modify_s( pLdap, ptszDn, mods );

        TrkLog(( TRKDBG_SVR | TRKDBG_GARBAGE_COLLECT,
                 TEXT("Touched entry with invalid sequence number (%d, %s)"),
                 ulSequence, ptszDn ));

    }

Exit:

    if( NULL != pptszValue )
        ldap_value_free( pptszValue );

    if( NULL != ptszDn )
        ldap_memfree( ptszDn );

    // Be nice to the DS
    if( 0 != pContext->dwRepetitiveTaskDelay )
        Sleep( pContext->dwRepetitiveTaskDelay );

    return( Action );
}

// returns FALSE if aborted

BOOL
LdapEnumerate(
    LDAP * pLdap,
    TCHAR * ptszBaseDn,
    ULONG Scope,
    TCHAR * Filter,
    TCHAR * Attributes[],
    PFN_LDAP_ENUMERATE_CALLBACK pCallback,
    void* UserParam1,
    void* UserParam2)
{
    LDAPMessage * pResults;
    LDAPSearch * pSearch;
    ENUM_ACTION EnumAction = ENUM_KEEP_ENTRY;

    // Start a paged enumeration using the specified base DN & filter.

    pSearch = ldap_search_init_page( pLdap,
                                  ptszBaseDn,
                                  Scope,
                                  Filter,
                                  Attributes,
                                  FALSE,
                                  NULL,
                                  NULL,
                                  0,
                                  20000,
                                  NULL );

    if (pSearch != NULL)
    {
        int err;
        ULONG totalCount;

        // Get the next page of the enumeration

        while ( EnumAction != ENUM_ABORT &&
                LDAP_SUCCESS == (err = ldap_get_next_page_s( pLdap,
                                     pSearch,
                                     NULL,
                                     10,
                                     &totalCount,
                                     &pResults ) && pResults != NULL))
        {

            LDAPMessage * pMessage;
            LDAPMessage * pFirstMessage;

            // Loop through the entries on this page.

            pFirstMessage = pMessage = ldap_first_entry( pLdap, pResults );
            while ( EnumAction != ENUM_ABORT
                    && 
                    pMessage != NULL )
            {
                // Call the callback to process this entry.

                EnumAction = (*pCallback)(
                        pLdap,
                        pMessage,
                        UserParam1,
                        UserParam2);

                if ( EnumAction == ENUM_DELETE_ENTRY )
                {
                    // This entry is to be deleted.  Increment the entry
                    // count, and if we're not just counting, actually delete it.


                    TCHAR * ptszDn = ldap_get_dn( pLdap, pMessage );

                    if (ptszDn != NULL)
                    {
                        TrkLog((TRKDBG_ERROR, TEXT("Deleting Dn=%s"), ptszDn));
                        ldap_delete_s( pLdap, ptszDn );
                        ldap_memfree( ptszDn );
                    }
                }
                else if(EnumAction == ENUM_KEEP_ENTRY)
                {
                }
                else if(EnumAction == ENUM_DELETE_QUOTAFLAGS)
                {
                    TCHAR*          ptszDn = ldap_get_dn(pLdap, pMessage);

                    if(NULL != ptszDn)
                    {
                        if(UserParam2)
                        {
                            ((CQuotaTable*)UserParam2)->DeleteFlags(pLdap, ptszDn);
                        }
                    }
                }
                pMessage = ldap_next_entry( pLdap, pMessage );
            }

            ldap_msgfree( pResults );

            if (pFirstMessage == NULL)
                break;
        }
        ldap_search_abandon_page( pLdap, pSearch );
    }
    return(EnumAction != ENUM_ABORT);
}


#ifdef VOL_REPL
void
CVolumeTable::QueryVolumeChanges( const CFILETIME & cftFirstChange, CVolumeMap * pVolMap )
{
    // protect against the data changing under us
    BOOL fCacheHit;

    __try
    {

        EnterCriticalSection(&_csQueryCache);

        if (fCacheHit = _cftCacheLowest <= cftFirstChange)
        {
            TrkLog((TRKDBG_VOLTAB | TRKDBG_VOLTAB_RESTORE,
                TEXT("CVolumeTable::QueryVolumeChanges(cftFirstChange=%s) HIT, returning %d change entries from cache"),
                    (const TCHAR*) CDebugString(cftFirstChange),
                    _VolMap.Count()));
            _VolMap.CopyTo( pVolMap );
        }
    }
    _finally
    {
        LeaveCriticalSection(&_csQueryCache);
    }

    if (!fCacheHit)
    {
        // the cache was missed... go to the real database.

        CFILETIME cftHighest;
        _QueryVolumeChanges( cftFirstChange, pVolMap );

        TrkLog((TRKDBG_VOLTAB | TRKDBG_VOLTAB_RESTORE,
                TEXT("CVolumeTable::QueryVolumeChanges(cftFirstChange=%s) MISS, returning %d entries from full query"),
                    (const TCHAR*) CDebugString(cftFirstChange),
                    pVolMap->Count()));
    }
}
#endif

// if there are more than zero volume entries, then pVolMap->SetSize and pVolMap->Add will be called,
// otherwise pVolMap will not be called and so must be initialized by the caller

#ifdef VOL_REPL

void
CVolumeTable::_QueryVolumeChanges( const CFILETIME & FirstChangeRequested,
                                   CVolumeMap * pVolMap )
{
    // lookup the volume and get the current machine and sequence number if any
    int                 err;
    LDAPMessage *       pRes = NULL;
    CLdapVolumeKeyDn    dnKey(GetBaseDn());
    struct berval **    ppbvMachineId = NULL;
    TCHAR **            pptszCnVolumeId = NULL;
    TCHAR               szSearchFilter[256];
    TCHAR *             apszAttrs[4];
    HRESULT             hr;
    CLdapTimeValue      ltv(FirstChangeRequested);

    __try
    {
        //
        // Build up a search filter looking for objects with timeVolChange >= FirstChangeRequested
        //
        // (timeVolChange=XXX)
        //

        _tcscpy(szSearchFilter, s_timeVolChangeSearch);

        _tcscat(szSearchFilter, ltv);

        _tcscat(szSearchFilter, TEXT(")"));

        //
        // Build up the list of attributes to query
        //

        apszAttrs[0] = s_currMachineId;
        apszAttrs[1] = s_Cn;
        apszAttrs[2] = 0;

        err = ldap_search_s( Ldap(),
                             dnKey,
                             LDAP_SCOPE_ONELEVEL,
                             szSearchFilter,
                             apszAttrs,
                             0, // attribute types and values are wanted
                             &pRes );

        hr = MapResult(err);

        //
        // Depending on whether DS sets up a maximum query size, we will need to iterate
        // performing multiple searches. Initially just use a single query.
        //

        if (hr == S_OK)
        {
            // found it, lets get the attributes out

            int cEntries = ldap_count_entries(Ldap(), pRes);
            if (cEntries != 0)
            {
                pVolMap->SetSize(cEntries);

                LDAPMessage * pEntry = ldap_first_entry(Ldap(), pRes);
                if (pEntry != NULL)
                {
                    do
                    {
                        //
                        // for each entry get the
                        //   volume id from the CN
                        //   machine id
                        //   time of last volume change
                        //

                        pptszCnVolumeId = ldap_get_values(Ldap(), pEntry, s_Cn);
                        if (pptszCnVolumeId == NULL)
                        {
                            TrkRaiseException(HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY));
                        }

                        if (_tcslen(*pptszCnVolumeId) != 32) // length of stringized volume id
                        {
                            // Add code to recover from this.
                            TrkRaiseException(TRK_E_CORRUPT_VOLTAB);
                        }

                        ppbvMachineId = ldap_get_values_len(Ldap(), pEntry, s_currMachineId);
                        if (ppbvMachineId == NULL)
                        {
                            TrkRaiseException(HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY));
                        }

                        if ((*ppbvMachineId)->bv_len < sizeof(CMachineId))
                        {
                            // Add code to recover from this
                            TrkRaiseException(TRK_E_CORRUPT_VOLTAB);
                        }

                        CVolumeId volume( *pptszCnVolumeId, TRK_E_CORRUPT_VOLTAB );

                        CMachineId machine( (*ppbvMachineId)->bv_val,
                            (*ppbvMachineId)->bv_len,
                            TRK_E_CORRUPT_VOLTAB );

                        pVolMap->Add( volume, machine );

                        ldap_value_free(pptszCnVolumeId);
                        pptszCnVolumeId = NULL;

                        ldap_value_free_len(ppbvMachineId);
                        ppbvMachineId = NULL;

                    } while ( pEntry = ldap_next_entry(Ldap(), pEntry));
                }

                pVolMap->Compact();
            }
        }
    }
    __finally
    {
        if (pRes != NULL)
        {
            ldap_msgfree(pRes);
        }

        if (pptszCnVolumeId != NULL)
        {
            ldap_value_free(pptszCnVolumeId);
        }

        if (ppbvMachineId != NULL)
        {
            ldap_value_free_len(ppbvMachineId);
        }
    }

    TrkLog((TRKDBG_VOLTAB | TRKDBG_VOLTAB_RESTORE,
            TEXT("_QueryVolumeChanges(filter=%s) got %d changes since %s"),
                szSearchFilter,
                pVolMap->Count(),
                (const TCHAR*) CDebugString(FirstChangeRequested)));

}

#endif

// raises on error, returns number of volumes on this machine

DWORD
CVolumeTable::CountVolumes( const CMachineId & mcid )
{
    // lookup the volume and get the current machine and sequence number if any
    int                 err;
    LDAPMessage *       pRes = NULL;
    CLdapVolumeKeyDn    dnKey(GetBaseDn());
    TCHAR               szSearchFilter[256];
    TCHAR *             pszAppend;
    TCHAR *             aptszAttrs[2];
    HRESULT             hr;
    DWORD               cVolumes = 0;

    __try
    {
        //
        // Build up a search filter looking for objects with currMachineId == mcid
        //
        // (volTableIdxGUID;binary=XXX)
        //

        _tcscpy(szSearchFilter, s_currMachineIdSearch);
        pszAppend = szSearchFilter + _tcslen(szSearchFilter);

        // mcid.Stringize(pszAppend);
        mcid.StringizeAsGuid(pszAppend);

        *pszAppend++ = TEXT(')');
        *pszAppend++ = TEXT('\0');

        TrkAssert(_tcslen(szSearchFilter)+1 < ELEMENTS(szSearchFilter));

        //
        // Build up the list of attributes to query
        // If we ever update to allow large numbers of volumes on a machine,
        // this should be a paged enumeration.
        //

        aptszAttrs[0] = const_cast<TCHAR*>(s_Cn);
        aptszAttrs[1] = 0;

        err = ldap_search_s( Ldap(),
                             dnKey,
                             LDAP_SCOPE_ONELEVEL,
                             szSearchFilter,
                             aptszAttrs,
                             0, // attribute types and values are wanted
                             &pRes );

        hr = MapResult(err);

        if (hr == S_OK)
        {
            // found it, lets get the attributes out

            cVolumes = ldap_count_entries(Ldap(), pRes);
        }
    }
    __finally
    {
        if (pRes != NULL)
        {
            ldap_msgfree(pRes);
        }
    }

    TrkLog((TRKDBG_VOLTAB | TRKDBG_VOLTAB_RESTORE,
            TEXT("CountVolumes(filter=%s) got %d volumes"),
                szSearchFilter,
                cVolumes));

    return(cVolumes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\log.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       log.cxx
//
//  Contents:   Implementation of Tracking (Workstation) Service log of moves.
//
//  Classes:    CLog
//
//  Functions:  
//              
//  Notes:      The log is composed of a header and a linked-list of move
//              notification entries.  This structure is provided by the
//              CLogFile class.
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop
#include "trkwks.hxx"


//+----------------------------------------------------------------------------
//
//  Method:     Initialize
//
//  Synopsis:   Initialize a CLog object.
//
//  Arguments:  [pLogCallback] (in)
//                  A PLogCallback object, which we'll call when we have new
//                  data.
//              [pcTrkWksConfiguration] (in)
//                  Configuration parameters for the log.
//              [pcLogFile] (in)
//                  The object representing the log file.
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLog::Initialize( PLogCallback *pLogCallback,
                  const CTrkWksConfiguration *pcTrkWksConfiguration,
                  CLogFile *pcLogFile )
{
    LogInfo loginfo;

    // Save the inputs

    TrkAssert( NULL != pcLogFile || NULL != _pcLogFile );
    if( NULL != pcLogFile )
        _pcLogFile = pcLogFile;

    TrkAssert( NULL != pcTrkWksConfiguration || NULL != _pcTrkWksConfiguration );
    if( NULL != pcTrkWksConfiguration )
        _pcTrkWksConfiguration = pcTrkWksConfiguration;

    TrkAssert( NULL != pLogCallback || NULL != _pLogCallback );
    if( NULL != pLogCallback )
        _pLogCallback = pLogCallback;


    // Read the log info from the log header.

    _pcLogFile->ReadExtendedHeader( CLOG_LOGINFO_START, &loginfo, CLOG_LOGINFO_LENGTH );

    // If the log hadn't been shut down properly, it's been fixed by now, but
    // we can't trust the loginfo we just read from the header.  We also
    // can't trust it if it doesn't make sense.  So if for some reason we
    // can't trust it, we'll recalculate it (this can be slow, though).

    if( !_pcLogFile->IsShutdown() || loginfo.ilogStart == loginfo.ilogEnd )
    {
        _fDirty = TRUE;
        loginfo = QueryLogInfo();
    }

    // Save the now-good information.
    _loginfo = loginfo;

}   // CLog::Initialize()


//+----------------------------------------------------------------------------
//
//  Method:     QueryLogInfo
//
//  Synopsis:   Read the log entries and determine the indices and sequence
//              numbers.
//
//  Arguments:  None
//
//  Returns:    A LogInfo structure
//
//+----------------------------------------------------------------------------

LogInfo
CLog::QueryLogInfo()
{

    SequenceNumber seqMin, seqMax;
    ULONG cEntries;
    LogIndex ilogMin, ilogMax, ilogEntry;
    LogInfo loginfo;
    LogMoveNotification lmn;
    BOOL fLogEmpty = TRUE;
    LogEntryHeader entryheader;

    TrkLog(( TRKDBG_LOG, TEXT("Reading log to determine correct indices") ));

    //  ------------
    //  Scan the log
    //  ------------

    seqMin = 0;
    seqMax = 0;

    cEntries = _pcLogFile->NumEntriesInFile();

    ilogMin = 0;
    ilogMax = cEntries - 1;

    // Scan the log and look at the sequence numbers to find
    // the start and end indices.

    for( ilogEntry = 0; ilogEntry < cEntries; ilogEntry++ )
    {
        _pcLogFile->ReadMoveNotification( ilogEntry, &lmn );

        if( LE_TYPE_MOVE == lmn.type )
        {
            SequenceNumber seq = lmn.seq;

            // If this is the first move notification that we've
            // found, then it is currently both the min and the max.

            if( fLogEmpty )
            {
                fLogEmpty = FALSE;
                seqMin = seqMax = seq;
                ilogMin = ilogMax = seq;
            }

            // If this isn't the first entry we've found, then see
            // if it is a new min or max.

            else
            {
                if( seq <= seqMin )
                {
                    seqMin = seq;
                    ilogMin = ilogEntry;
                }
                else if( seq >= seqMax )
                {
                    seqMax = seq;
                    ilogMax = ilogEntry;
                }
            }
        }   // if( LE_TYPE_MOVE == _pcLogFile->ReadMoveNotification( ilogEntry )->type )
    }   // for( ilogEntry = 0; ilogEntry < cEntries; ilogEntry++ )


    //  -------------------------------
    //  Determine the log indices, etc.
    //  -------------------------------

    // Were there any entries in the log?

    if( fLogEmpty )
    {
        // No, the log is empty.

        loginfo.ilogStart = loginfo.ilogWrite = 0;
        loginfo.ilogLast = loginfo.ilogEnd = cEntries - 1;
    }
    else
    {
        // Yes, the log is non-empty.

        // Point the start index to the oldest move in the log.
        loginfo.ilogStart = ilogMin;

        // Point the last index to the oldest move in the log,
        // and point the write index to the entry after that
        // (which is the first available entry).

        loginfo.ilogLast = loginfo.ilogWrite = ilogMax;
        _pcLogFile->AdjustLogIndex( &loginfo.ilogWrite, 1 );

        // The write & start indices should only be the same 
        // in an empty log.  We know we're not empty at this point,
        // so if they're the same, then the start index must have
        // actually advanced (otherwise, the write index wouldn't be
        // allowed to be here).  So we advance the start index.

        if( loginfo.ilogWrite == loginfo.ilogStart )
        {
            _pcLogFile->AdjustLogIndex( &loginfo.ilogStart, 1 );
        }
    }   // if( fLogEmpty ) ... else

    // The end if the log is just before the start in the circular list.

    loginfo.ilogEnd = loginfo.ilogStart;
    _pcLogFile->AdjustLogIndex( &loginfo.ilogEnd, -1 );


    // The read index and next available
    // sequence number are stored in the last entry header.

    entryheader = _pcLogFile->ReadEntryHeader( loginfo.ilogLast );

    loginfo.ilogRead = entryheader.ilogRead;
    loginfo.seqNext = entryheader.seq;

    // The sequence number of the entry last read is one below the sequence number
    // of the entry currently at the read pointer.  If everything is read 
    // (the read pointer is beyond the last entry) or if the entry at the
    // read pointer is invalid, then we'll assume that the last read seq
    // number is seqNext-1.

    _pcLogFile->ReadMoveNotification( loginfo.ilogRead, &lmn );
    loginfo.seqLastRead = ( loginfo.ilogWrite != loginfo.ilogRead && LE_TYPE_MOVE == lmn.type )
                             ? lmn.seq - 1 : loginfo.seqNext-1;

    TrkAssert( seqMax + 1 == loginfo.seqNext || 0 == loginfo.seqNext );
    TrkAssert( loginfo.seqLastRead < loginfo.seqNext );

    return( loginfo );

}   // CLog::QueryLogInfo()


//+----------------------------------------------------------------------------
//
//  Method:     GenerateDefaultLogInfo
//
//  Synopsis:   Calculates the default _loginfo structure, based only on
//              the last index.  This requires no calls to CLogFile.
//
//  Arguments:  [ilogEnd] (in)
//                  The index of the last entry in the logfile.
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLog::GenerateDefaultLogInfo( LogIndex ilogEnd )
{
    SetDirty( TRUE );   // Must be called before changing _loginfo

    _loginfo.ilogStart = _loginfo.ilogWrite = _loginfo.ilogRead = 0;
    _loginfo.ilogLast = _loginfo.ilogEnd = ilogEnd;

    _loginfo.seqNext = 0;
    _loginfo.seqLastRead = _loginfo.seqNext - 1;

}



//+----------------------------------------------------------------------------
//
//  Method:     Flush
//
//  Synopsis:   Write the _loginfo structure to the CLogFile.
//
//  Arguments:  None
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLog::Flush( )
{
    if( _fDirty )
        _pcLogFile->WriteExtendedHeader( CLOG_LOGINFO_START, &_loginfo, CLOG_LOGINFO_LENGTH );

    SetDirty( FALSE );
}


//+----------------------------------------------------------------------------
//
//  Method:     ExpandLog
//
//  Synopsis:   Grow the log file, initialize the new entries, and update
//              our indices.  We determine how much to grow based on
//              configuration parameters in CTrkWksConfiguration.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//+----------------------------------------------------------------------------

void
CLog::ExpandLog()
{
    TrkAssert( !_pcLogFile->IsMaxSize() );
    TrkAssert( IsFull() );

    SetDirty( TRUE );   // Must be called before changing _loginfo

    // Grow the file, initialize the new log entries, and link the new
    // entries into the existing linked list.  We only need to tell
    // the CLogFile where the start of the circular linked-list is.

    _pcLogFile->Expand( _loginfo.ilogStart );

    // Update the end pointer.

    _loginfo.ilogEnd = _loginfo.ilogStart;
    _pcLogFile->AdjustLogIndex( &_loginfo.ilogEnd, -1 );


}   // CLog::Expand



//+----------------------------------------------------------------------------
//
//  Method:     Read
//
//  Synopsis:   Read zero or more entries from the log, starting at the
//              Read index.  Read until we reach the end of the data in
//              the log, or until we've read as many as the caller
//              requested.
//
//              Note that we don't update the read index after this read,
//              the caller must call Seek to accomplish this.  This was done
//              so that if the caller encountered an error after the Read,
//              the log would still be unchanged for a retry.
//
//  Arguments:  [pNotifications] (in/out)
//                  Receives the move notification records.
//              [pseqFirst] (out)
//                  The sequence number of the first notification returned.
//              [pcRead] (in/out)
//                  (in)  the number of notifications desired
//                  (out) the number of notifications actually read
//                  If the number read is less than the number requested,
//                  the caller may assume that there are no more entries
//                  to read.
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLog::Read(CObjId rgobjidCurrent[],
           CDomainRelativeObjId rgdroidBirth[],
           CDomainRelativeObjId rgdroidNew[],
           SequenceNumber *pseqFirst,
           IN OUT ULONG *pcRead)
{

    //  --------------
    //  Initialization
    //  --------------

    LogIndex ilogEntry;
    ULONG cRead = 0;
    ULONG iRead = 0;
    SequenceNumber seqExpected = 0;

    ilogEntry = _loginfo.ilogRead;

    //  ----------------
    //  Read the entries
    //  ----------------

    // We can NOOP if the call request no entries, or if there
    // are no entries in the log, or if all the entries have
    // been read already.

    if( *pcRead != 0 && !IsEmpty() && !IsRead() )
    {
        LogMoveNotification lmn;

        // There are entries which we can read.

        // Save the sequence number of the first entry that
        // we'll return to the caller.

        _pcLogFile->ReadMoveNotification( ilogEntry, &lmn );
        *pseqFirst = lmn.seq;
        seqExpected = lmn.seq;

        // Read the entries from the log in order, validating
        // the sequence numbers as we go.

        do
        {
            // Copy the move information into the caller's buffer.
            // ReadMoveNotification doesn't make the CLogFile dirty.

            _pcLogFile->ReadMoveNotification( ilogEntry, &lmn );

            TrkAssert( seqExpected == lmn.seq );

            if( seqExpected != lmn.seq )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Invalid sequence numbers reading log (%d, %d)"),
                         seqExpected, lmn.seq ));
                TrkRaiseException( TRK_E_CORRUPT_LOG );
            }
            seqExpected++;

            rgobjidCurrent[iRead] = lmn.objidCurrent;   
            rgdroidNew[iRead]     = lmn.droidNew;
            rgdroidBirth[iRead]   = lmn.droidBirth;

            cRead++;
            iRead++;

            // Move on to the next entry.

            _pcLogFile->AdjustLogIndex( &ilogEntry, 1 );

            // Continue as long as there's still room in the caller's buffer
            // and we haven't reached the last entry.

        } while ( cRead < *pcRead && ilogEntry != _loginfo.ilogWrite );
    }

    *pcRead = cRead;

}   // CLog:Read()



//+----------------------------------------------------------------------------
//
//  CLog::DoSearch
//
//  This is a private worker method that searches the log, either for a
//  sequence number, or an object ID (which to use is determined by the
//  fSearchUsingSeq parameter).
//
//  The log entry data and index are returned.
//
//+----------------------------------------------------------------------------

// NOTE! *piFound is not modified if Search returns FALSE

BOOL
CLog::DoSearch( BOOL fSearchUsingSeq,
                SequenceNumber seqSearch,     // Use this if fSearchUsingSeq
                const CObjId &objidCurrent,   // Use this if !fSearchUsingSeq
                ULONG                *piFound,
                CDomainRelativeObjId *pdroidNew,
                CMachineId           *pmcidNew,
                CDomainRelativeObjId *pdroidBirth )
{
    BOOL fFound = FALSE;
    BOOL fFirstPass = TRUE;
    SequenceNumber seqPrevious = 0;


#if DBG
    LONG l = GetTickCount();
#endif

    // Only bother to look if there's entries in the log.

    if (!IsEmpty())
    {
        // Determine the max entries in the log so that we can
        // detect if we're in an infinite loop.

        ULONG cEntriesMax = _pcLogFile->NumEntriesInFile();
        ULONG cEntryCurrent = 0;

        LogIndex ilogSearch = _loginfo.ilogWrite;

        // Search from the end, until we find what we're looking for,
        // or we reach the beginning of the log.

        // It's important that we search backwards because of tunneling.
        // Here's the scenario ... An object is moved from machine A to
        // B, quickly back to A, and then to C.  Since it reappeared on A
        // quickly after it first disappeared, tunneling will give it the
        // same Object ID that it had before.  So when it moves to C,
        // we end up with two entries in the log for the object.  We want
        // to search backwards so that we see the move to C, not the move
        // to B.

        while( !fFound && ilogSearch != _loginfo.ilogStart )
        {
            // Check to see if we're in an infinite loop.

            if( ++cEntryCurrent > cEntriesMax )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Corrupt log file: cycle found during search")));
                TrkRaiseException( TRK_E_CORRUPT_LOG );
            }

            // Read the previous entry.

            _pcLogFile->AdjustLogIndex( &ilogSearch, -1 );
            LogMoveNotification lmnSearch;
            _pcLogFile->ReadMoveNotification( ilogSearch, &lmnSearch );

            // If this isn't a move entry, then there's nothing left to search.
            if( LE_TYPE_MOVE != lmnSearch.type )
                goto Exit;

            // Or, if this isn't the first pass, ensure that the sequence numbers
            // are consequtive.
            else if( !fFirstPass )
            {
                fFirstPass = FALSE;

                TrkAssert( seqPrevious - 1 == lmnSearch.seq );

                if( seqPrevious - 1 != lmnSearch.seq )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Corrupt log file: non-consequtive sequence numbers (%d %d)"),
                             seqPrevious, lmnSearch.seq ));
                    TrkRaiseException( TRK_E_CORRUPT_LOG );
                }

            }

            // Is this the entry we're looking for?

            if( fSearchUsingSeq && seqSearch == lmnSearch.seq
                ||
                !fSearchUsingSeq && objidCurrent == lmnSearch.objidCurrent )
            {
                if( NULL != piFound )
                    *piFound = ilogSearch;

                if( NULL != pdroidNew )
                {
                    *pdroidNew = lmnSearch.droidNew;
                    *pmcidNew = lmnSearch.mcidNew;
                    *pdroidBirth = lmnSearch.droidBirth;
                }

                fFound = TRUE;
            }
        }   // while( !fFound && ilogSearch != _loginfo.ilogStart )
    }   // if (!IsEmpty())


Exit:

    return( fFound );

}   // CLog::DoSearch



//+----------------------------------------------------------------------------
//
//  Method:     Search
//
//  Synopsis:   Search the log for an Object ID.  Once found, return that
//              entry's LinkData and BirthID.
//
//  Arguments:  [droidCurrent] (in)
//                  The ObjectID for which to search.
//              [pdroidNew] (out)
//                  The entry's LinkData
//              [pdroidBirth] (out)
//                  The entry's Birth ID.
//
//  Returns:    None
//
//+----------------------------------------------------------------------------


BOOL
CLog::Search( const CObjId &objidCurrent,
              CDomainRelativeObjId *pdroidNew,
              CMachineId           *pmcidNew,
              CDomainRelativeObjId *pdroidBirth )
{
    ULONG iFound;
    return DoSearch( FALSE, // => Use objidCurrent
                     0,     // Therefore, we don't need a seq number
                     objidCurrent,
                     &iFound,
                     pdroidNew,
                     pmcidNew,
                     pdroidBirth );

}   // CLog::Search( CDomainRelativeObjId& ...


//+----------------------------------------------------------------------------
//
//  Method:     CLog::Search
//
//  Synopsis:   Search the log for the entry with a particular sequence
//              number.
//
//  Arguments:  [seqSearch] (in)
//                  The sequence number for which to search.
//              [piFound] (out)
//                  The index with this sequence number (if found).
//
//  Returns:    [BOOL]
//                  TRUE if found, FALSE otherwise.
//
//+----------------------------------------------------------------------------

BOOL
CLog::Search( SequenceNumber seqSearch, ULONG *piFound )
{
    CObjId oidNull;
    return DoSearch( TRUE,       // => Use seqSearch
                     seqSearch,
                     oidNull,    // We don't need to pass an objid
                     piFound,
                                 // And we don't need out-droids & mcid.
                     NULL, NULL, NULL );

}   // CLog::Search( SequenceNumber ...




//+----------------------------------------------------------------------------
//
//  Method:     Append
//
//  Synopsis:   Add a move notification to the log.  If the log is full,
//              either overwrite an old entry, or grow the log.
//
//  Arguments:  [droidCurrent] (in)
//                  The link information of the file which was moved.
//              [droidNew] (in)
//                  The link information of the new file.
//              [droidBirth] (in)
//                  The Birth ID of the file.
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

// Perf optimization:  Tell the caller if the log is now full.  The service can then lazily
// expand it, hopefully before the next move occurs.

void
CLog::Append(const CVolumeId &volidCurrent,
             const CObjId &objidCurrent,
             const CDomainRelativeObjId &droidNew,
             const CMachineId           &mcidNew,
             const CDomainRelativeObjId &droidBirth)
{
    LogMoveNotification lmnWrite;

    CFILETIME cftNow;   // Defaults to current UTC
    BOOL fAdvanceStart = FALSE;
    LogEntryHeader entryheader;
    LogInfo loginfoZero;

    //  -----------------
    //  Handle a Full Log
    //  -----------------

    if( IsFull() )
    {
        // Is the log already maxed?  If so, we wrap.

        if( _pcLogFile->IsMaxSize() )
        {
            fAdvanceStart = TRUE;
            TrkLog(( TRKDBG_VOLUME, TEXT("Wrapping log") ));
        }

        // Otherwise, we'll handle it by growing the log file.

        else
            ExpandLog();
    }

    //  -------------------------
    //  Write the data to the log
    //  -------------------------

    // Before anything else, we must mark ourselves dirty.  If the logfile is
    // currently in the ProperShutdown state, this SetDirty call will take it
    // out of that state and do a flush.

    SetDirty( TRUE );

    // Mark our loginfo cache in the header as invalid,
    // in case we get pre-empted.

    memset( &loginfoZero, 0, sizeof(loginfoZero) );
    _pcLogFile->WriteExtendedHeader( CLOG_LOGINFO_START, &loginfoZero, CLOG_LOGINFO_LENGTH );

    // Collect the move-notification information

    memset( &lmnWrite, 0, sizeof(lmnWrite) );
    lmnWrite.seq = _loginfo.seqNext;
    lmnWrite.type = LE_TYPE_MOVE;

    lmnWrite.objidCurrent = objidCurrent;
    lmnWrite.droidNew = droidNew;
    lmnWrite.mcidNew = mcidNew;
    lmnWrite.droidBirth = droidBirth;
    lmnWrite.DateWritten = TrkTimeUnits( cftNow );

    // Collect the entry header information

    memset( &entryheader, 0, sizeof(entryheader) );
    entryheader.ilogRead = _loginfo.ilogRead;
    entryheader.seq = _loginfo.seqNext + 1; // Reflect that we'll increment after the write

    // Write everything to the log (this will do a flush).  If this fails, it will raise.

    _pcLogFile->WriteMoveNotification( _loginfo.ilogWrite, lmnWrite, entryheader );

    // Update the sequence number and last & write indices now that we
    // know the write was successful (all the way to the disk).

    _loginfo.seqNext++;  
    _loginfo.ilogLast = _loginfo.ilogWrite;
    _pcLogFile->AdjustLogIndex( &_loginfo.ilogWrite, 1 );

    // Do we need to advance the start pointer?
    // We save this for the end, because it may cause us to access
    // the disk.

    if( fAdvanceStart )
    {
        // We're about to advance the start index, and thus effectively
        // lose an entry.  If the read index points to the same place,
        // then we should advance it as well.

        if( _loginfo.ilogStart == _loginfo.ilogRead )
            _pcLogFile->AdjustLogIndex( &_loginfo.ilogRead, 1 );

        // Advance the start/end indices.

        _pcLogFile->AdjustLogIndex( &_loginfo.ilogEnd, 1 );
        _pcLogFile->AdjustLogIndex( &_loginfo.ilogStart, 1 );
    }

    TrkLog(( TRKDBG_VOLUME, TEXT("Appended %s to log (seq=%d)"),
             (const TCHAR*)CDebugString(objidCurrent), lmnWrite.seq ));

    // Notify the callback object that there is data available.
    // Note:  This must be the last operation of this method.

    _pLogCallback->OnEntriesAvailable();

}


//+----------------------------------------------------------------------------
//
//  Method:     Seek( SequenceNumber ...
//
//  Synopsis:   Moves the Read index to a the log entry with the specified 
//              sequence number.  If the seq number doesn't exist, we back
//              up to the start of the log.
//
//              If this seek causes us to back up the Read index, we notify
//              the PLogCallback object, since we now have data available
//              to read.
//
//  Arguments:  [seqSeek] (in)
//                  The sequence number to which to seek.
//
//  Returns:    [BOOL]
//                  TRUE if the sequence number was found, FALSE otherwise.
//
//+----------------------------------------------------------------------------

BOOL
CLog::Seek( const SequenceNumber &seqSeek )
{
    BOOL fFound = FALSE;
    SequenceNumber seqReadOriginal, seqReadNew;
    LogMoveNotification lmn;

    LogIndex ilogSearch = 0;

    // Are we seeking to the end of the log?

    if( seqSeek == _loginfo.seqNext )
    {
        // We found what we're looking for.
        fFound = TRUE;

        // Are we already at seqNext?
        if( !IsRead() )
        {
            // No, update the read index.
            SetDirty( TRUE );
            _loginfo.ilogRead = _loginfo.ilogWrite;
        }

        goto Exit;
    }

    // If the log is empty, then there's nothing we need do.

    if( IsEmpty() )
        goto Exit;

    // Or, if the caller wishes to seek beyond the end of our log, then
    // again there's nothing to do.  This could be the case, for example,
    // if the log has been restored.

    if( seqSeek >= _loginfo.seqNext )
        goto Exit;

    // Keep track of the current seq number at the read pointer, so that
    // we can later tell if it's necessary to notify the client that
    // there is "new" data.

    if( IsRead() )
    {
        seqReadOriginal = _loginfo.seqNext;
    }
    else
    {
        _pcLogFile->ReadMoveNotification( _loginfo.ilogRead, &lmn );
        seqReadOriginal = lmn.seq;
    }

    // If this seq number is in the log, set the Read index
    // to it.  Otherwise set it to the oldest entry in the
    // log (that's the best we can do).

    SetDirty( TRUE );   // Must be called before changing _loginfo

    if( fFound = Search( seqSeek, &ilogSearch ))
        _loginfo.ilogRead = ilogSearch;
    else
        _loginfo.ilogRead = _loginfo.ilogStart;

    // Calculate the sequence number of the entry now at the read pointer, and
    // use it to cache the seq number of the last-read entry (recall that
    // the read pointer points to the next entry to be read, not the
    // last entry read).

    if( IsRead() )
    {
        seqReadNew = _loginfo.seqNext;
    }
    else
    {
        _pcLogFile->ReadMoveNotification( _loginfo.ilogRead, &lmn );
        seqReadNew = lmn.seq;
    }

    _loginfo.seqLastRead = seqReadNew - 1;  // We already set _fDirty

    // Update the entry headers with the new read pointer.
    WriteEntryHeader();

    // If we've backed up the read pointer, notify the registered callback.

    if ( seqReadOriginal > seqReadNew )
    {
         // Note:  This must be the last operation of this method.
        _pLogCallback->OnEntriesAvailable();
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return( fFound );

}   // CLog::Seek( SequenceNumber ...



//+----------------------------------------------------------------------------
//
//  Method:     Seek( origin ...
//
//  Synopsis:   Move the read pointer relative to an origin (begin, current, end).
//
//              There are two differences between a CLog seek and a file seek:
//              -  If you seek from the beginning (SEEK_SET), and seek beyond the
//                 end of the log, the pointer is wrapped, rather than growing
//                 the log.
//              -  If you seek from the current location (SEEK_CUR), and seek
//                 beyond the end of the log, the log is not grown, and there
//                 is no wrap, the index simply stops there (either at _loginfo.ilogWrite
//                 or _loginfo.ilogStart).
//
//  Arguments:  [origin]
//                  Must be either SEEK_SET or SEEK_CUR (there is currently no
//                  support for SEEK_END).
//              [iSeek]
//                  The amount to move relative to the origin.
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLog::Seek( int origin, int iSeek )
{

    SequenceNumber seqReadOriginal = 0, seqReadNew = 0;

    LogMoveNotification lmn;

    // Early exit if there's nothing to do

    if( IsEmpty() )
        goto Exit;

    // Keep track of where we are now, so that we can determine if
    // we've gone overall backwards or forwards.

    if( IsRead() )
    {
        seqReadOriginal = _loginfo.seqNext;
    }
    else
    {
        _pcLogFile->ReadMoveNotification( _loginfo.ilogRead, &lmn );
        seqReadOriginal = lmn.seq;
    }

    // Seek based on the origin.

    switch( origin )
    {
    case SEEK_SET:
        {
            // Advance from the start index.

            LogIndex ilogRead = _loginfo.ilogStart;

            _pcLogFile->AdjustLogIndex( &ilogRead, iSeek );

            SetDirty( TRUE );   // Must be called before changing _loginfo
            _loginfo.ilogRead = ilogRead;
        }
        break;

    case SEEK_CUR:
        {
            // Advance or retreat from the current read index.  

            LogIndex ilogRead = _loginfo.ilogRead;

            _pcLogFile->AdjustLogIndex( &ilogRead, iSeek, CLogFile::ADJUST_WITHIN_LIMIT,
                                        iSeek >= 0 ? _loginfo.ilogWrite : _loginfo.ilogStart );

            SetDirty( TRUE );   // Must be called before changing _loginfo
            _loginfo.ilogRead = ilogRead;
        }
        break;

    default:

        TrkAssert( FALSE && TEXT("Unexpected origin in CLog::Seek") );
        break;
    }

    // Calculate the sequence number of the entry at the read pointer, and
    // use it to store the seq number of the last-read entry (recall that
    // the read pointer points to the next entry to be read, not the
    // last entry read).

    if( IsRead() )
    {
        seqReadNew = _loginfo.seqNext;
    }
    else
    {
        _pcLogFile->ReadMoveNotification( _loginfo.ilogRead, &lmn );
        seqReadNew = lmn.seq;
    }

    SetDirty( TRUE );   // Must be called before changing _loginfo
    _loginfo.seqLastRead = seqReadNew - 1;

    // Update the entry headers with the new read pointer.
    WriteEntryHeader();


    // If we've backed up the read pointer, notify the registered callback.

    if ( seqReadOriginal > seqReadNew )
    {
         // Note:  This must be the last operation of this method.
        _pLogCallback->OnEntriesAvailable();
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // CLog::Seek( origin ...



//+----------------------------------------------------------------------------
//
//  Method:     CLog::IsRead( LogIndex ) (private)
//
//  Synopsis:   Determine if the specified entry has been read.  See also
//              the IsRead(void) overload, which checks to see if the whole
//              log has been read.
//
//  Inputs:     [ilog] (in)
//                  The index in the log to be checked.  It is assumed
//                  that this index points to a valid move notification
//                  entry.
//
//  Outputs:    [BOOL]
//                   True if and only if the entry has been marked as read.
//
//+----------------------------------------------------------------------------

BOOL
CLog::IsRead( LogIndex ilog )
{
    LogMoveNotification lmn;

    // Has the whole log been read?

    if( IsRead() )
        return( TRUE );

    // Or, has this entry been read?

    _pcLogFile->ReadMoveNotification( ilog, &lmn );

    if( _loginfo.seqLastRead >= lmn.seq )
        return( TRUE );

    // Otherwise, we know the entry hasn't been read.

    else
        return( FALSE );

}   // CLog::IsRead( LogIndex )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\delmgr.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  delmgr.cxx
//
//  Implementation of CDeletionsManager, which watches file deletes on
//  NTFS5 to determine if a link source delete notification should be
//  sent to trksvr.
//
//+============================================================================

#include "pch.cxx"
#pragma hdrstop
#include "trkwks.hxx"


//+----------------------------------------------------------------------------
//
//  CDeletionsManager::Initialize
//
//  Initialize the delete-notify timer.
//
//+----------------------------------------------------------------------------

void
CDeletionsManager::Initialize( const CTrkWksConfiguration *pconfigWks )
{
    _pLatestDeletions = NULL;
    _pOldestDeletions = NULL;
    _cLatestDeletions = 0;
    _pconfigWks = pconfigWks;

    _csDeletions.Initialize();

    _fInitialized = TRUE;

    _timerDeletions.Initialize( this,
                                NULL,           // No name (non-persistent timer)
                                                // Context ID
                                DELTIMER_DELETE_NOTIFY,
                                pconfigWks->GetDeleteNotifyTimeout(),
                                CNewTimer::NO_RETRY,
                                0, 0, 0 );      // Ignored for non-retrying timer
}


//+----------------------------------------------------------------------------
//
//  CDeleteionsManager::UnInitialize
//
//  Free the lists of deletions, and free the timer.
//
//+----------------------------------------------------------------------------

void
CDeletionsManager::UnInitialize()
{
    if (_fInitialized)
    {
        _fInitialized = FALSE;
        _timerDeletions.Cancel();


        FreeDeletions();
        _pOldestDeletions = _pLatestDeletions;
        FreeDeletions();

        _timerDeletions.UnInitialize();

        _csDeletions.UnInitialize();
    }
}


//+----------------------------------------------------------------------------
//
//  CDeletionsManager::NotifyAddOrDelete
//
//  This method is called (by the CObjIdIndexChangeNotifier) when an object
//  ID has been added, or been removed by a delete (not removed by a move).
//  When an objid is deleted, we add the birth ID to a list, and after a time
//  we'll send it up to trksvr.  When an objid is added, we see if its birth
//  ID is in our list of delete-notifies (this happens after tunnelling), and
//  remove it if it is.
//
//  Since we hold on to deletes for at least 5 minutes (configurable), and
//  the tunnelling windows is 15 seconds (though also configurable), we don't
//  worry about a add (tunnel) message coming in after we've already sent
//  a delete notification to trksvr.
//
//+----------------------------------------------------------------------------

void
CDeletionsManager::NotifyAddOrDelete( ULONG Action, const CDomainRelativeObjId & droid )
{
    // Note: this function must not access _pOldestDeletions

    DROID_LIST_ELEMENT * Element;

    // Ignore if we're uninitialized (this will happen if the machine is
    // in a workgroup).

    if( !_fInitialized )
        return;

    // If bit 0 if the volume id is clear, then the file hasn't moved off the
    // volume and there's nothing we need do.

    if (! droid.GetVolumeId().GetUserBitState())
    {
        if( FILE_ACTION_REMOVED_BY_DELETE == Action )
        {
            TrkLog(( TRKDBG_OBJID_DELETIONS,
                     TEXT("Ignoring droid=%s because bit 0 is clear\n"),
                     (const TCHAR*)CDebugString(droid) ));
        }
        return;
    }

    // Take the lock and see if we care about the action

    _csDeletions.Enter();

    __try
    {
        // Object ID Removed by DeleteFile
        if( FILE_ACTION_REMOVED_BY_DELETE == Action )
        {
            // Add this droid to the list of delete-notifies we need to send to the DC.

            if( _pconfigWks->GetParameter( IGNORE_MOVES_AND_DELETES_CONFIG ) )
            {
                TrkLog(( TRKDBG_OBJID_DELETIONS, TEXT("Ignoring delete due to configuration") ));
            }
            else if( _cLatestDeletions < _pconfigWks->GetParameter( MAX_DELETE_NOTIFY_QUEUE_CONFIG ))
            {
                Element = new DROID_LIST_ELEMENT;
                if( Element )
                {
                    _cLatestDeletions++;

                    Element->droid = droid;
                    Element->droid.GetVolumeId().Normalize();

                    // Insert the deletion onto the head of the first list.

                    if (_pLatestDeletions == NULL)
                    {
                        _timerDeletions.SetRecurring( );
                        TrkLog(( TRKDBG_OBJID_DELETIONS,
                                 TEXT("DeleteNotify Timer: %s"),
                                 (const TCHAR*)CDebugString(_timerDeletions) ));
                    }

                    Element->pNext = _pLatestDeletions;
                    _pLatestDeletions = Element;

                    TrkLog(( TRKDBG_OBJID_DELETIONS,
                             TEXT("Inserted droid=%s into DROID_LIST_ELEMENT at %08x"),
                             (const TCHAR*)CDebugString(droid), Element));
                }
            }
            #if DBG
            else
            {
                TrkLog(( TRKDBG_OBJID_DELETIONS, TEXT("Ignoring delete-notify due to max queue size") ));
            }
            #endif
        }   // if( FILE_ACTION_REMOVED_BY_DELETE == Action )

        else if( FILE_ACTION_ADDED == Action )
        {
            // See if this droid is in our delete-list.  When a document does a safe-save,
            // the first thing we see is the file getting deleted, and we add the droid
            // to our list of delete-notifies to send to the DC.  But when the ID gets
            // tunnelled, we need to remove it from that list.

            BOOL fDone = FALSE;
            DROID_LIST_ELEMENT **ppScan;
            CDomainRelativeObjId droidBirth = droid;
            droidBirth.GetVolumeId().Normalize();

            // Start with the first list
            ppScan = &_pLatestDeletions;

            for( int i = 0; i < 2; i++ )
            {
                while( NULL != *ppScan )
                {
                    if( (*ppScan)->droid == droidBirth )
                    {
                        // This is the entry we're looking for.
                        // Remove it.

                        DROID_LIST_ELEMENT *pDel = *ppScan;
                        *ppScan = (*ppScan)->pNext;
                        delete pDel;
                        fDone = TRUE;

                        TrkLog((TRKDBG_OBJID_DELETIONS,
                                TEXT("Removed droid=%s delete-notify list"),
                                (const TCHAR*)CDebugString(droid) ));

                        break;  // while
                    }

                    // Move to the next element in this list.
                    ppScan = &(*ppScan)->pNext;
                }

                // If we're done then break out.  Otherwise, move on
                // to the other linked list.

                if( fDone )
                    break;
                else
                    ppScan = &_pOldestDeletions;

            }   // for( int i = 0; i < 2; i++ )
        }   // else if( FILE_ACTION_ADDED == Action )
    }
    __finally
    {
        _csDeletions.Leave();
    }
}

//+----------------------------------------------------------------------------
//
//  CDeletionsManager::OnDeleteNotifyTimeout
//
//  Process the delete notifications in the linked list at _pOldestDeletions.
//  The notifications from this list are sent to trksvr, then the entries
//  in that list are freed, and the entries from _pLatestDeletions are
//  moved to _pOldestDeletions.
//
//  Note:  This method assumes it is non-reentrant, since it is only
//  called when the single delete notify timer fires.
//
//+----------------------------------------------------------------------------

PTimerCallback::TimerContinuation
CDeletionsManager::OnDeleteNotifyTimeout()
{

    CAvailableDc adc;
    PTimerCallback::TimerContinuation continuation = CONTINUE_TIMER;

    // Keep track of the number of attempts to send a single
    // batch.
    static cAttempts = 0;


    TrkLog(( TRKDBG_OBJID_DELETIONS, TEXT("Delete notify timeout") ));

    __try   // __finally
    {

        // Are there deletions that need to be sent to trksvr?

        if( _pOldestDeletions != NULL && !_pconfigWks->_fIsWorkgroup )
        {
            TRKSVR_MESSAGE_UNION Msg;
            CDomainRelativeObjId adroidBirth[ MAX_DELETE_NOTIFICATIONS ]; //32 ];
            DROID_LIST_ELEMENT * pScan;
            ULONG cdroidBirth;

            pScan = _pOldestDeletions;

            // Send the delete notifications in batches.

            do
            {
                g_ptrkwks->RaiseIfStopped();

                //
                // Count the number of list elements and put into the
                // array format for the RPC call.
                //

                for ( cdroidBirth = 0;
                      pScan != NULL && cdroidBirth < ELEMENTS(adroidBirth);
                      cdroidBirth++, pScan = pScan->pNext )
                {
                    adroidBirth[cdroidBirth] = pScan->droid;
                    TrkAssert( pScan != pScan->pNext && pScan->pNext != _pOldestDeletions );
                }

                if( cdroidBirth != 0 )
                {
                    // As a sanity check, make sure we don't stick on a single
                    // batch forever.
                    if( cAttempts >= _pconfigWks->GetParameter( MAX_DELETE_NOTIFY_ATTEMPTS_CONFIG ) )
                    {
                        TrkLog(( TRKDBG_WARNING,
                                 TEXT("Aborting delete-notify list") ));
                        break;
                    }

                    // Send the delete notifications to trksvr

                    Msg.MessageType = DELETE_NOTIFY;
                    Msg.Priority = PRI_5;
                    Msg.Delete.cVolumes = 0;
                    Msg.Delete.pVolumes = NULL;

                    Msg.Delete.adroidBirth = adroidBirth;
                    Msg.Delete.cdroidBirth = cdroidBirth;

                    // if the DC is down -> exception (really can't do anything about it)

                    cAttempts++;
                    TrkLog(( TRKDBG_OBJID_DELETIONS, TEXT("Sending %d delete notifications"), cdroidBirth ));
                    adc.CallAvailableDc(&Msg);
                    TrkLog(( TRKDBG_OBJID_DELETIONS, TEXT("Sent %d delete notifications"), cdroidBirth ));

                    // Free the entries that we've sent so far.
                    FreeDeletions( pScan );
                }

                // Reset the per-batch retry count.
                cAttempts = 0;

            } while (pScan != NULL);
        }
    }
    __finally
    {
        if( AbnormalTermination() )
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't send deletions") ));
        else
        {
            // Free the old deletions, and swap the list so that the
            // "new" deletions become "old" (to be sent the next time
            // this timer fires).

            FreeDeletions();
            cAttempts = 0;

            _csDeletions.Enter();

            if (_pLatestDeletions == NULL)
            {
                //
                // If there is nothing to notify, cancel the timer
                //

                continuation = BREAK_TIMER;
            }

            _pOldestDeletions = _pLatestDeletions;
            _pLatestDeletions = NULL;
            _cLatestDeletions = 0;

            _csDeletions.Leave();
        }

        adc.UnInitialize();
    }

    return( continuation );
}


//+----------------------------------------------------------------------------
//
//  CDeletionsManager::FreeDeletions
//
//  Free the delete notifications from the "old" list
//  up to (but not including) pStop or the end.
//
//+----------------------------------------------------------------------------

void
CDeletionsManager::FreeDeletions( DROID_LIST_ELEMENT *pStop )
{
    DROID_LIST_ELEMENT * pScan = _pOldestDeletions;
    while (pScan && pStop != pScan)
    {
        DROID_LIST_ELEMENT * pNext = pScan->pNext;
        delete pScan;
        pScan = pNext;
    }

    _pOldestDeletions = pStop;
}


//+----------------------------------------------------------------------------
//
//  CDeletionsManager::Timer
//
//  Called when the delete timer fires.  This triggers us to send the
//  notifications from the old list, and then to move the "new" items to
//  the old list.
//
//+----------------------------------------------------------------------------

PTimerCallback::TimerContinuation
CDeletionsManager::Timer( ULONG ulTimerId )
{
    TimerContinuation continuation = CONTINUE_TIMER;

    TrkAssert( ulTimerId == DELTIMER_DELETE_NOTIFY );
    TrkAssert( _timerDeletions.IsRecurring() );

    __try
    {
        // This will raise if service is stopping
        continuation = OnDeleteNotifyTimeout();
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
    }

    return( continuation );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\makefile.inc ===
$(O)\trkwks_s.c : $(PROJECT_ROOT)\genx\types\tracking\idl\$(O)\trkwks_s.c
   copy $? $@

clean:
   -del /q /f $(NTTARGETFILE0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\entropy.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  File:   entropy.cxx
//
//  This file implements the CEntropyRecorder class.  That class is used
//  to generate truly random secrets.  It does this by maintaining some
//  state whenever the Put method is called.  It is the responsibility of
//  the caller to call this at non-predictable times, such as based on
//  the timing of user keystrokes or on non-solid-state disk latency.
//
//+============================================================================




#include "pch.cxx"
#pragma hdrstop
#include "trkwks.hxx"

#define THIS_FILE_NUMBER    ENTROPY_CXX_FILE_NO

//+----------------------------------------------------------------------------
//
//  CEntropyRecord::Initialize
//
//  Init the critsec and entropy array.
//
//+----------------------------------------------------------------------------

void
CEntropyRecorder::Initialize()
{
    DWORD dwType;
    DWORD cb;
    HKEY hKey;

    _cs.Initialize();
    _fInitialized = TRUE;

    _cbTotalEntropy = _iNext = 0;

    memset(_abEntropy, 0, sizeof(_abEntropy));

}

//+----------------------------------------------------------------------------
//
//  CEntropyRecord::UnInitialize
//
//  Delete the critsec.
//
//+----------------------------------------------------------------------------

void
CEntropyRecorder::UnInitialize()
{
    if (_fInitialized)
    {
        _cs.UnInitialize();
        _fInitialized = FALSE;
    }
}

//+----------------------------------------------------------------------------
//
//  CEntropyRecorder::Put
//
//  This method is called at random times.  The performance counter is
//  queries, munged, and put into the entropy array.
//
//+----------------------------------------------------------------------------

void
CEntropyRecorder::Put()
{
    LARGE_INTEGER li;

    QueryPerformanceCounter(&li);

    DWORD dw = li.LowPart ^ li.HighPart;
    WORD w = HIWORD(dw) ^ LOWORD(dw);

    _cs.Enter();

    PutEntropy(HIBYTE(w));
    PutEntropy(LOBYTE(w));

    _cs.Leave();
}


//+----------------------------------------------------------------------------
//
//  CEntropyRecorder::PutEntropy
//
//  Add a byte of entropy (from Put) to the entropy array.
//
//+----------------------------------------------------------------------------

void
CEntropyRecorder::PutEntropy( BYTE b )
{
    //
    // Entries are written into the buffer in a circular fashion.
    // A count, _cbTotalEntropy, records total number of writes.
    // If _cbTotalEntropy > buffer size, then we have wrapped and
    // the entire buffer has entropy.
    //


    DWORD iNext = _iNext;

    iNext %= sizeof(_abEntropy);

    TrkAssert(iNext < sizeof(_abEntropy));

    _abEntropy[iNext] ^= b;

    _iNext = iNext+1;

    _cbTotalEntropy ++;
}


//+----------------------------------------------------------------------------
//
//  CEntropyRecorder::GetEntropy
//
//  Get the specified number of bytes of entropy.  If we don't already have 
//  enough bytes, we'll generate them here.
//
//+----------------------------------------------------------------------------

BOOL
CEntropyRecorder::GetEntropy( void * pv, ULONG cb )
{
    BOOL fGotIt = FALSE;

    _cs.Enter();
    __try
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("Getting entropy (%d/%d)"), cb, _cbTotalEntropy ));

        // Do we already have enough entropy?

        if( _cbTotalEntropy <= cb )
        {
            // No, we need to generate it.

            TrkLog(( TRKDBG_VOLUME, TEXT("Generating entropy") ));
            TCHAR tszSysDir[ MAX_PATH + 1 ];
            NTSTATUS Status = STATUS_SUCCESS;
            ULONG cPuts = 0;

            // Get the system directory.

            UINT cchPath = GetSystemDirectory( tszSysDir, ELEMENTS(tszSysDir) );
            if( 0 == cchPath || MAX_PATH < cchPath )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get system directory (%lu, %lu)"),
                         cchPath, GetLastError() ));
                __leave;
            }

            // Keep opening the system directory, capturing entropy each time (with the call to Put),
            // until we have enough.

            while( _cbTotalEntropy <= cb )
            {
                HANDLE hSysDir = NULL;

                Status = TrkCreateFile( tszSysDir, FILE_READ_ATTRIBUTES, FILE_ATTRIBUTE_NORMAL,
                                        FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                                        FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT, NULL, &hSysDir );
                if( !NT_SUCCESS(Status) )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open system directory (%08x)"),
                             Status ));
                    __leave;
                }

                NtClose( hSysDir );
                hSysDir = NULL;
                Put();

                // This is just a cautionary measure.  Never let this loop eat all the
                // CPU forever.

                if( ++cPuts > 100 )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("CEntropy::GetEntropy in infinite loop") ));
                    __leave;
                }
            }
            TrkLog(( TRKDBG_VOLUME, TEXT("Generated enough entropy") ));

        }   // if( _cbTotalEntropy <= cb )


        if (_cbTotalEntropy >= ELEMENTS(_abEntropy))
        {
            // Never allow _cbTotalEntropy to exceed ELEMENTS(_abEntropy)
            // if we're reading out, otherwise we'd get non-random data returned.

            _cbTotalEntropy = ELEMENTS(_abEntropy);
        }

        _cbTotalEntropy -= cb;
        _iNext = _cbTotalEntropy;

        memcpy(pv, _abEntropy, cb);

        memcpy(_abEntropy, _abEntropy+cb, sizeof(_abEntropy)-cb);
        memset(_abEntropy+sizeof(_abEntropy)-cb, 0, cb);

        fGotIt = TRUE;
    }
    __finally
    {
        _cs.Leave();
    }

    return(fGotIt);
}


//+----------------------------------------------------------------------------
//
//  CEntropyRecorder::InitializeSecret
//
//  Create a volume secret, using the entropy buffer.
//
//+----------------------------------------------------------------------------

BOOL
CEntropyRecorder::InitializeSecret( CVolumeSecret * pSecret )
{
    return GetEntropy( pSecret, sizeof(*pSecret) );
}

//+----------------------------------------------------------------------------
//
//  CEntropyRecorder::ReturnUnusedSecret
//
//  Return entropy that was taken with InitializeSecret but not used.
//
//+----------------------------------------------------------------------------

void
CEntropyRecorder::ReturnUnusedSecret( CVolumeSecret * pSecret )
{
    TrkAssert( *pSecret != CVolumeSecret() );

    _cs.Enter();

    if (_cbTotalEntropy <= sizeof(_abEntropy) - sizeof(*pSecret))
    {
        memcpy( _abEntropy+sizeof(*pSecret), _abEntropy, _cbTotalEntropy);
        memcpy( _abEntropy, pSecret, sizeof(CVolumeSecret) );
        _iNext = (_iNext + sizeof(*pSecret)) % sizeof(_abEntropy);
        _cbTotalEntropy += sizeof(*pSecret);
    }

    *pSecret = CVolumeSecret();

    _cs.Leave();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\loghead.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  File:       LogHead.cxx
//
//  Classes:    CLogFileHeader
//
//  This class represents the header (the first sector) of the Tracking
//  (Workstation) Service's log file.
//
//+============================================================================

#include "pch.cxx"
#pragma hdrstop
#include "trkwks.hxx"


//+----------------------------------------------------------------------------
//
//  Method:     Initialize
//
//  Synopsis:   Initialize the header class.  We allocate a buffer here to
//              hold sectors.  This is the only allocation we perform
//              in this class.
//
//  Inputs:     [cbSector] (in)
//                  The size of the file sectors.
//
//  Output:     None
//
//+----------------------------------------------------------------------------

void
CLogFileHeader::Initialize( ULONG cbSector )
{
    TrkAssert( 0 != cbSector );
    TrkAssert( NULL == _hFile );

    // Initialize flags

    _fDirty = FALSE;

    // Store the input

    if( sizeof(*_plogheader) + CB_EXTENDED_HEADER > cbSector )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Sector size isn't large enough for log header") ));
        TrkRaiseWin32Error( ERROR_BAD_CONFIGURATION );
    }
    _cbSector = cbSector;

    // Allocate a buffer to hold the header sector

    if( NULL != _plogheader && _cbSector != cbSector )
    {
        delete [] _plogheader;
        _plogheader = NULL;
    }

    if( NULL == _plogheader )
    {
        _plogheader = reinterpret_cast<LogHeader*>( new BYTE[ cbSector ] );
        if( NULL == _plogheader )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't alloc %d bytes in CLogFileHeader::Initialize"), cbSector ));
            TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );
        }
    }

    // The "extended header" is that portion beyond the regular header
     
    _pextendedheader = &_plogheader[1];

}   // CLogFileHeader::Initialize


//+----------------------------------------------------------------------------
//
//  Method:     UnInitialize
//
//  Synopsis:   Free the sector buffer.
//
//  Inputs:     None
//
//  Output:     None
//
//+----------------------------------------------------------------------------

void
CLogFileHeader::UnInitialize()
{
    if( NULL != _plogheader )
    {
        if( IsOpen() )
            OnClose();

        LogHeader *plogheader = _plogheader;
        _plogheader = NULL;
        delete [] plogheader;
    }

}   // CLogFileHeader::UnInitialize()



//+----------------------------------------------------------------------------
//
//  Method:     LoadHeader
//
//  Synopsis:   Load the header sector from the log file.
//
//  Inputs:     None
//
//  Output:     None
//
//+----------------------------------------------------------------------------

void
CLogFileHeader::LoadHeader( HANDLE hFile )
{
    NTSTATUS status;
    LARGE_INTEGER liOffset;
    IO_STATUS_BLOCK IoStatusBlock;

    // _hFile must not be set until we've successfully loaded the header.
    TrkAssert( NULL == _hFile );

    // Read the header sector from the file

    liOffset.QuadPart = 0;

    status = NtReadFile( hFile, NULL, NULL, NULL,
                         &IoStatusBlock, _plogheader, _cbSector,
                         &liOffset, NULL );

    if ( STATUS_PENDING == status )
    {
        // Wait for the operation to complete.  The resulting status
        // will be put in the IOSB

        status = NtWaitForSingleObject( hFile, FALSE, NULL );

        if( NT_SUCCESS(status) )
            status = IoStatusBlock.Status;
    }

    // Validate the results of the read

    if ( !NT_SUCCESS(status) )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Failed NtReadFile (%08x)"), status ));
        if(STATUS_VOLUME_DISMOUNTED == status)
        {
            TrkRaiseNtStatus(status);
        }
        else
        {
            TrkRaiseException( TRK_E_CORRUPT_LOG );
        }
    }

    if( NULL != g_ptrkwks ) // NULL when called by dltadmin.exe
        g_ptrkwks->_entropy.Put();

    if( _cbSector != IoStatusBlock.Information )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't read header from log") ));
        TrkRaiseException( TRK_E_CORRUPT_LOG );
    }
    _hFile = hFile;

}   // CLogFileHeader::LoadHeader()


//+----------------------------------------------------------------------------
//
//  Method:     ReadExtended
//
//  Synopsis:   Read bytes from the extended header to the caller's
//              buffer.
//  
//  Inputs:     [iOffset] (in)
//                  0-relative offset into the extended header.
//              [pv] (out)
//                  Buffer to receive the extended header bytes
//              [cb] (in)
//                  Size of this extended header segment.
//
//  Outputs:    None
//
//+----------------------------------------------------------------------------

void
CLogFileHeader::ReadExtended( ULONG iOffset, void *pv, ULONG cb )
{
    TrkAssert( NULL != _plogheader );
    RaiseIfNotOpen();

    // Validate the request

    if( sizeof(*_plogheader) + iOffset + cb > _cbSector )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Attempt to read too much data from the extended log header (%d bytes at %d)\n"),
                            iOffset, cb ));
        TrkAssert( !TEXT("Invalid parameters to CLogFileHeader::ReadExtended") );
        TrkRaiseException( TRK_E_CORRUPT_LOG );
    }

    // Read the bytes

    memcpy( pv, &static_cast<BYTE*>(_pextendedheader)[ iOffset ], cb );

}   // CLogFileHeader::ReadExtended()


//+----------------------------------------------------------------------------
//
//  Method:     WriteExtended
//
//  Synopsis:   Writes bytes to the caller-specified portion of the log's
//              extended header area.
//
//  Inputs:     [iOffset] (in)
//                  0-relative index into the extended header
//              [pv] (in)
//                  The bytes to write.
//              [cb] (in)
//                  The number of bytes to write.
//
//  Output:     None
//
//+----------------------------------------------------------------------------

void
CLogFileHeader::WriteExtended( ULONG iOffset, const void *pv, ULONG cb )
{
    TrkAssert( NULL != _plogheader );
    TrkAssert( sizeof(*_plogheader) + iOffset + cb <= 512 );
    RaiseIfNotOpen();

    // Validate the request

    if( sizeof(*_plogheader) + iOffset + cb > _cbSector )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Attempt to read too much data from the extended log header (%d bytes at %d)\n"),
                            iOffset, cb ));
        TrkAssert( !TEXT("Invalid parameters to CLogFileHeader::WriteExtended") );
        TrkRaiseException( TRK_E_CORRUPT_LOG );
    }

    // Write the bytes

    memcpy( &static_cast<BYTE*>(_pextendedheader)[ iOffset ], pv, cb );
    SetDirty();

}   // CLogFileHeader::WriteExtended



//+----------------------------------------------------------------------------
//
//  Method:     SetExpansionData
//
//  Synopsis:   Write information about an expansion to the log header.
//
//  Inputs:     [cbLogFile] (in)
//                  The current size of the file.
//              [ilogStart] (in)
//                  The index of the current starting point in the circular
//                  linked-list.
//              [ilogEnd] (in)
//                  The index of the current ending point in the circular
//                  linked-list.
//
//  Outputs:    None
//
//+----------------------------------------------------------------------------

void
CLogFileHeader::SetExpansionData( ULONG cbLogFile, ULONG ilogStart, ULONG ilogEnd )
{
    TrkAssert( NULL != _plogheader );
    RaiseIfNotOpen();

    // Save the expansion data

    _plogheader->expand.cbFile = cbLogFile;
    _plogheader->expand.ilogStart = ilogStart;
    _plogheader->expand.ilogEnd = ilogEnd;

    // Flush straight to disk

    Flush( );

}   // CLogFileHeader::SetExpansionData()


//+----------------------------------------------------------------------------
//
//  Method:     Flush
//
//  Synopsis:   Flush the current header sector to the underlying file.
//
//  Inputs:     [FlushFlags] (in)
//                  From the FLUSH_* defines.  Used to indicate if we
//                  should flush regardless of the dirty flag, and if
//                  we should flush to cache or to disk.
//
//  Outputs:    None
//
//+----------------------------------------------------------------------------

void
CLogFileHeader::Flush( )
{
    NTSTATUS status = STATUS_SUCCESS;
    RaiseIfNotOpen();

    // Is there anything loaded to even flush?

    if( NULL != _hFile )
    {
        IO_STATUS_BLOCK IoStatusBlock;
        TrkAssert( NULL != _plogheader );

        // Is the in-memory header dirty?

        if( _fDirty )
        {
            LARGE_INTEGER liOffset;

            TrkAssert( NULL != _hFile );

            // Write the header sector to the file

            liOffset.QuadPart = 0;


            status = NtWriteFile( _hFile, NULL, NULL, NULL,
                                  &IoStatusBlock, _plogheader, _cbSector,
                                  &liOffset, NULL );

            if ( STATUS_PENDING == status )
            {
                // Wait for the operation to complete.  The resulting status
                // will be put in the IOSB

                status = NtWaitForSingleObject( _hFile, FALSE, NULL );

                if( NT_SUCCESS(status) )
                    status = IoStatusBlock.Status;
            }


            // Validate the results of the write

            if ( !NT_SUCCESS(status) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't write the log file header")));
                TrkRaiseNtStatus( status );
            }

            if( NULL != g_ptrkwks ) // NULL when called by dltadmin.exe
                g_ptrkwks->_entropy.Put();

            if( _cbSector != IoStatusBlock.Information )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't write all of the log file header (%d)"),
                                   IoStatusBlock.Information ));
                TrkRaiseException( TRK_E_CORRUPT_LOG );
            }

            SetDirty( FALSE );

        }   // if( _fDirty || FLUSH_UNCONDITIONALLY == flush_type )
    }   // if( NULL != _hFile )

}   // CLogFileHeader::Flush
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\logfile.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  File:       logfile.cxx
//
//              This file contains the definition of the CLogFile class.
//
//  Purpose:    This class represents the file which contains the
//              Tracking/Workstation move notification log.  Clients
//              of this class may request one entry or header at a time,
//              using based on a log entry index.
//
//              Entries in the log file are joined by a linked-list,
//              so this class includes methods that clients use to
//              advance their log entry index (i.e., traverse the list).
//
//  Notes:      CLogFile reads/writes a sector at a time for reliability.
//              When a client modifies a log entry in one sector, then
//              attempts to access another sector, CLogFile automatically
//              flushes the changes.  This is dependent, however, on the
//              client properly calling the SetDirty method whenever it
//              changes a log entry or header.
//
//+============================================================================


#include "pch.cxx"
#pragma hdrstop
#include "trkwks.hxx"



const GUID s_guidLogSignature = { /* 6643a7ec-effe-11d1-b2ae-00c04fb9386d */
                                0x6643a7ec, 0xeffe, 0x11d1,
                                {0xb2, 0xae, 0x00, 0xc0, 0x4f, 0xb9, 0x38, 0x6d} };




// Assuming that tszFile is a file under a directory that is under a root
// directory. Try to create tszFile first. If not successful, create its
// parent directory. And then try create the file again.

NTSTATUS
CSecureFile::CreateAlwaysSecureFile(const TCHAR * ptszFile)
{
    NTSTATUS status = STATUS_SUCCESS;
    CSystemSD   ssd;
    SECURITY_ATTRIBUTES security_attributes;

    memset( &security_attributes, 0, sizeof(security_attributes) );

    LONG cLocks = Lock();
    __try
    {
        TrkAssert(!IsOpen());

        ssd.Initialize();
        security_attributes.nLength = sizeof(security_attributes);
        security_attributes.bInheritHandle = FALSE;
        security_attributes.lpSecurityDescriptor = static_cast<const PSECURITY_DESCRIPTOR>(ssd);

        for(int cTries = 0; cTries < 2; cTries++)
        {
            // Create the file, deleting an existing file if there is one.
            // We make it system|hidden so that it's "super-hidden"; the NT5
            // shell won't ever display it.

            status = TrkCreateFile( ptszFile,
                                    FILE_GENERIC_READ|FILE_GENERIC_WRITE,          // Access
                                    FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, // Attributes
                                    0,                                             // Share
                                    FILE_SUPERSEDE,                                // Creation/distribution
                                    0,                                             // Options
                                    &security_attributes,                          // Security
                                    &_hFile );

            if(NT_SUCCESS(status))
                break;
            _hFile = NULL;

            if( STATUS_OBJECT_PATH_NOT_FOUND == status )
            {
                // The create failed because the directory ("System Volume Information")
                // didn't exist.

                WCHAR wszVolumeName[ MAX_PATH ];
                WCHAR *pwszEndVolumeName;
                UNICODE_STRING usVolumeName;
                BOOL TranslationStatus;

                // Get just the volume name in wszVolumeName by truncating
                // the filename.

                wcscpy( wszVolumeName, ptszFile );
                TrkVerify( pwszEndVolumeName = wcschr( &wszVolumeName[4], TEXT('\\')) );
                *pwszEndVolumeName = L'\0';
                TrkLog(( TRKDBG_VOLUME, TEXT("Create SysVolInfo on %s"), wszVolumeName ));

                // Convert the volume name to NT path name syntax.

                TranslationStatus = RtlDosPathNameToNtPathName_U(
                                        wszVolumeName,
                                        &usVolumeName,
                                        NULL,
                                        NULL
                                        );

                if( !TranslationStatus )
                    TrkRaiseWin32Error( ERROR_PATH_NOT_FOUND );

                // Use the RTL routine to create the SysVolInfo directory on 
                // this volume.

                status = RtlCreateSystemVolumeInformationFolder( &usVolumeName );
                if( !NT_SUCCESS(status) )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Couldn't create directory %s"),
                             wszVolumeName ));
                    break;
                }

            }   // path not found
            else
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't create file(status=%08x)"), status ));
                _hFile = NULL;
                break;
            }
        }   // for
    }
    __finally
    {
        ssd.UnInitialize();
#if DBG
        TrkVerify( Unlock() == cLocks );
#else
        Unlock();
#endif
    }

    return( status );
}

NTSTATUS
CSecureFile::OpenExistingSecureFile( const TCHAR * ptszFile, BOOL fReadOnly )
{
    NTSTATUS status = STATUS_SUCCESS;

    LONG cLocks = Lock();
    __try
    {
        TrkAssert(!IsOpen());

        // From the point of view of CSecureFile, we might as well open share_read,
        // since the file's still protected by the ACLs.  From the point of view
        // of the CLogFile derivation, we want to open share_read in order to
        // allow the dltadmin tool to read the log.  We add DELETE access so
        // that the file can be renamed (necessary for migrating pre-nt5beta3 files).

        // Note - this is an async open

        status = TrkCreateFile( ptszFile,
                                fReadOnly                                      // Access
                                    ? FILE_GENERIC_READ
                                    : FILE_GENERIC_READ|FILE_GENERIC_WRITE|DELETE,   
                                FILE_ATTRIBUTE_NORMAL,                         // Attributes
                                FILE_SHARE_READ,                               // Share
                                FILE_OPEN,                                     // Creation/distribution
                                0,                                             // Options (async)
                                NULL,                                          // Security
                                &_hFile );

        if( !NT_SUCCESS(status) )
            _hFile = NULL;
    }
    __finally
    {
#if DBG
        TrkVerify( Unlock() == cLocks );
#else
        Unlock();
#endif
    }

    return( status );
}


NTSTATUS
CSecureFile::RenameSecureFile( const TCHAR *ptszFile )
{
    NTSTATUS status = STATUS_SUCCESS;
    IO_STATUS_BLOCK Iosb;
    FILE_RENAME_INFORMATION *pfile_rename_information = NULL;
    UNICODE_STRING      uPath;
    PVOID               pFreeBuffer = NULL;
    ULONG cbSize = 0;

    LONG cLocks = Lock();
    __try
    {

        // Convert the Win32 path name to an NT name

        if( !RtlDosPathNameToNtPathName_U( ptszFile, &uPath, NULL, NULL ))
        {
            status = STATUS_OBJECT_NAME_INVALID;
            __leave;
        }
        pFreeBuffer = uPath.Buffer;

        // Fill in the rename information

        cbSize = sizeof(*pfile_rename_information) + uPath.Length;
        pfile_rename_information = reinterpret_cast<FILE_RENAME_INFORMATION*>
                                   (new BYTE[ cbSize ]);
        if( NULL == pfile_rename_information )
        {
            status = STATUS_NO_MEMORY;
            __leave;
        }

        pfile_rename_information->ReplaceIfExists = TRUE;
        pfile_rename_information->RootDirectory = NULL;
        pfile_rename_information->FileNameLength = uPath.Length;
        memcpy( pfile_rename_information->FileName, uPath.Buffer, uPath.Length );

        // Rename the file

        status = NtSetInformationFile( _hFile, &Iosb,
                                       pfile_rename_information, cbSize,
                                       FileRenameInformation );
        if( !NT_SUCCESS(status) )
            __leave;
    }
    __finally
    {
#if DBG
        TrkVerify( Unlock() == cLocks );
#else
        Unlock();
#endif
    }


    if( NULL != pfile_rename_information )
        delete [] pfile_rename_information;

    if( NULL != pFreeBuffer )
        RtlFreeHeap( RtlProcessHeap(), 0, pFreeBuffer );


    return( status );

}

//+----------------------------------------------------------------------------
//
//  Method:     Initialize
//
//  Purpose:    Initialize a CLogFile object.
//
//  Arguments:  [hFile] (in)
//                  The file in which the log should be stored.
//              [dwCreationDistribution] (in)
//                  Either CREATE_ALWAYS or OPEN_EXISTING.
//              [pcTrkWksConfiguration] (in)
//                  Configuration parameters for the log.
//
//  Returns:    None.
//
//+----------------------------------------------------------------------------

void
CLogFile::Initialize( const TCHAR *ptszVolumeDeviceName,
                      const CTrkWksConfiguration *pcTrkWksConfiguration,
                      PLogFileNotify *pLogFileNotify,
                      TCHAR tcVolume
                      )
{
    LogHeader logheader;
    TCHAR tszRootPathName[ MAX_PATH + 1];
    DWORD dwSectorsPerCluster, dwNumberOfFreeClusters, dwTotalNumberOfClusters;
    HANDLE hFile = NULL;
    FILE_FS_SIZE_INFORMATION FileSizeInformation;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS status = STATUS_SUCCESS;

    CSecureFile::Initialize();

    // Save caller-provided values

    TrkAssert( NULL != pcTrkWksConfiguration || NULL != _pcTrkWksConfiguration );
    if( NULL != pcTrkWksConfiguration )
        _pcTrkWksConfiguration = pcTrkWksConfiguration;
    TrkAssert( 0 < _pcTrkWksConfiguration->GetLogFileOpenTime() );


    TrkAssert( NULL != ptszVolumeDeviceName || NULL != _ptszVolumeDeviceName );
    if( NULL != ptszVolumeDeviceName )
        _ptszVolumeDeviceName = ptszVolumeDeviceName;

    TrkAssert( NULL != pLogFileNotify || NULL != _pLogFileNotify );
    if( NULL != pLogFileNotify )
        _pLogFileNotify = pLogFileNotify;

    _tcVolume = tcVolume;

    // Calculate the bytes/sector of the log file's volume.
    //
    // It would be easier to use the Win32 GetDiskFreeSpace here, but that
    // API requires a root path name of the form "A:\\", which we don't have.
    // That requirement only exists, though, for some historic reason.

    // Postpend a whack to get a root path.

    TCHAR tszVolumeName[ MAX_PATH + 1 ] = { TEXT('\0') };
    TrkAssert( NULL != _ptszVolumeDeviceName );
    _tcscpy( tszVolumeName, _ptszVolumeDeviceName );
    _tcscat( tszVolumeName, TEXT("\\") );

    // Open the root

    status = TrkCreateFile( tszVolumeName, FILE_READ_ATTRIBUTES, FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ|FILE_SHARE_DELETE|FILE_SHARE_WRITE,
                            FILE_OPEN,
                            FILE_OPEN_FOR_FREE_SPACE_QUERY | FILE_SYNCHRONOUS_IO_NONALERT, 
                            NULL,
                            &hFile );
    if( !NT_SUCCESS(status) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open volume root to query free space") ));
        TrkRaiseNtStatus(status);
    }

    // Query the volume for the free space and unconditionally close the handle.

    status = NtQueryVolumeInformationFile( hFile, &IoStatusBlock, &FileSizeInformation,
                                           sizeof(FileSizeInformation), FileFsSizeInformation );
    NtClose( hFile );
    if( !NT_SUCCESS(status) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't query volume information from log file") ));
        TrkRaiseNtStatus(status);
    }

    // Save the free space away

    _cbLogSector = FileSizeInformation.BytesPerSector;
    if( MIN_LOG_SECTOR_SIZE > _cbLogSector )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Volume sector sizes too small") ));
        TrkRaiseNtStatus( STATUS_INVALID_BUFFER_SIZE );
    }

    // Initialize members

    _header.Initialize( _cbLogSector );
    _sector.Initialize( _header.NumSectors(), _cbLogSector );

    if( INVALID_HANDLE_VALUE == _heventOplock )
    {
        _heventOplock = CreateEvent( NULL,     // Security Attributes.
                                     FALSE,    // Manual Reset Flag.
                                     FALSE,    // Inital State = Signaled, Flag.
                                     NULL );   // Name
        if( INVALID_HANDLE_VALUE == _heventOplock )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't create event for logfile") ));
            TrkRaiseLastError();
        }
    }


    // Open the log file here. We open the log file at initialization time and
    // keeps it open unless the handle is broken or we are notified to give up
    // the volume.

    ActivateLogFile();

}   // CLogFile::Initialize()



//+----------------------------------------------------------------------------
//
//  Method:     UnInitialize
//
//  Purpose:    Free resources
//
//  Arguments:  None
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLogFile::UnInitialize( )
{
    __try
    {
        CloseLog( );

        if( INVALID_HANDLE_VALUE != _heventOplock )
        {
            CloseHandle( _heventOplock );
            _heventOplock = INVALID_HANDLE_VALUE;
        }

    }
    __finally
    {
        _header.UnInitialize();
        _sector.UnInitialize();
    }

}   // CLogFile::UnInitialize()


//+----------------------------------------------------------------------------
//
//  PRobustlyCreateableFile::RobustlyCreateFile
//
//  Open the specified file on the specified volume.  If the file is corrupt,
//  delete it.  If the file doesn't exist (or was deleted), create a new
//  one.
//
//+----------------------------------------------------------------------------

void
PRobustlyCreateableFile::RobustlyCreateFile( const TCHAR * ptszFile, TCHAR tcVolumeDriveLetter )
{
    // Attempt to open the file

    RCF_RESULT r = OpenExistingFile( ptszFile );

#if DBG
    if( r == OK )
        TrkLog(( TRKDBG_LOG, TEXT("Opened log file %s"), ptszFile ));
#endif

    if( r == CORRUPT )
    {
#if DBG
        TCHAR tszFileBak[ MAX_PATH + 1 ];

        // Generate a backup name for the existing log file.

        _tcscpy( tszFileBak, ptszFile );
        _tcscat( tszFileBak, TEXT(".bak") );

        // Rename the existing logfile to the backup location.

        if (!MoveFileEx(ptszFile, tszFileBak, MOVEFILE_REPLACE_EXISTING))
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't make backup of corrupted file name\n   (\"%s\" to \"%s\")"),
                               ptszFile, tszFileBak ));
            TrkRaiseLastError( );
        }
#else

        // Delete the file.
        RobustlyDeleteFile( ptszFile );


#endif // #if DBG

        TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                        static_cast<const TCHAR*>( CStringize(tcVolumeDriveLetter) ),
                        NULL );

        // Go into the file-not-found mode.

        r = NOT_FOUND;
    }

    if( r == NOT_FOUND )
    {
        TCHAR tszLogFileTmp[MAX_PATH+1];

        // Create a temporary file name.  We'll do everything here, and switch it
        // to the real name when everything's set up.

        _tcscpy( tszLogFileTmp, ptszFile );
        _tcscat( tszLogFileTmp, TEXT(".tmp") );

        TrkLog(( TRKDBG_LOG, TEXT("Creating new file %s"), ptszFile ));

        CreateAlwaysFile( tszLogFileTmp );

        // Move the log file into its final name

        if (!( MoveFile(tszLogFileTmp, ptszFile) ))
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't rename file (\"%s\" to \"%s\")"), tszLogFileTmp, ptszFile ));
            TrkRaiseLastError( );
        }

        SetLastError(0);
        r = OpenExistingFile( ptszFile );
    }

    if( r != OK )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't create/open file (%s)"), ptszFile ));
        TrkRaiseLastError();
    }

}


void
PRobustlyCreateableFile::RobustlyDeleteFile( const TCHAR * ptszFile )
{
    TCHAR tszFileBak[ MAX_PATH + 1 ];
    BOOL fDeleted = FALSE;

    // Generate a backup name for the existing log file.

    _tcscpy( tszFileBak, ptszFile );
    _tcscat( tszFileBak, TEXT(".bak") );

    // Delete the file.
    // First rename it, though, so we don't get held up by the case where
    // e.g. backup has the file open.

    if (!MoveFileEx(ptszFile, tszFileBak, MOVEFILE_REPLACE_EXISTING))
    {
        if( ERROR_PATH_NOT_FOUND == GetLastError()
            ||
            ERROR_FILE_NOT_FOUND == GetLastError() )
        {
            fDeleted = TRUE;
        }
        else
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't rename existing log file (%lu, \"%s\")"),
                    GetLastError(), ptszFile ));
            TrkRaiseLastError( );
        }
    }

    if( !fDeleted && !DeleteFile( tszFileBak ))
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Couldn't delete backup log file\n   (%lu, \"%s\")"),
                 GetLastError(), tszFileBak ));
    }


}



void
CLogFile::CloseLog()    // doesn't raise
{
    if( IsOpen() )
    {
        _header.OnClose();
        _sector.OnClose();
        UnregisterOplockFromThreadPool();
        CloseFile();

        TrkLog(( TRKDBG_LOG, TEXT("Log file closed on volume %c"), _tcVolume ));
    }

}

//+----------------------------------------------------------------------------
//
//  Method:     InitializeLogEntries (private)
//
//  Synopsis:   Given a contiguous set of log entries in the log file,
//              initialize all of the fields.  The entries are initialized
//              to link to their neighbors in a circular queue.
//
//  Arguments:  [ilogFirst] (in)
//                  The first log entry in the list.
//              [ilogLast] (in)
//                  The last log entry in the list.
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLogFile::InitializeLogEntries( LogIndex ilogFirst, LogIndex ilogLast )
{
    LogEntry *ple = NULL;
    LogIndex ilogEntry;

    ULONG cEntries = ilogLast - ilogFirst + 1;

    TrkAssert( cEntries > 0 );

    // Initialize the first log entry.

    ple = _sector.GetLogEntry( ilogFirst );

    _sector.SetDirty( TRUE );
    _sector.InitSectorHeader();
    memset( ple, 0, sizeof(*ple) );

    ple->ilogNext = ilogFirst + 1;
    ple->ilogPrevious = ilogLast;
    ple->move.type = LE_TYPE_EMPTY;

    // Initialize all log entries except for the first and last.

    for( ilogEntry = ilogFirst + 1; ilogEntry < ilogLast; ilogEntry++ )
    {
        ple = _sector.GetLogEntry( ilogEntry );

        _sector.InitSectorHeader();
        memset( ple, 0, sizeof(*ple) );

        ple->ilogNext = ilogEntry + 1;
        ple->ilogPrevious = ilogEntry - 1;
        ple->move.type = LE_TYPE_EMPTY;
    }

    // Initialize the last log entry.

    ple = _sector.GetLogEntry( ilogLast );

    _sector.InitSectorHeader();
    memset( ple, 0, sizeof(*ple) );

    ple->ilogNext = ilogFirst;
    ple->ilogPrevious = ilogLast - 1;
    ple->move.type = LE_TYPE_EMPTY;

    Flush( );

    return;

}   // CLogFile::InitializeLogEntries()


//+----------------------------------------------------------------------------
//
//  Method:     Validate (private)
//
//  Synopsis:   Validate the log file by verifying the linked-list pointers,
//              the log file expansion data,
//              and by verifying the Signature and Format IDs in the headers.
//
//  Arguments:  None
//
//  Returns:    None (raises on error)
//
//+----------------------------------------------------------------------------

BOOL
CLogFile::Validate( )
{
    BOOL fValid = FALSE;

    BOOL fFirstPass;
    LogIndex ilog;
    ULONG cEntries;
    ULONG cEntriesSeen;


    //  ---------------
    //  Simple Checking
    //  ---------------

    // Do some quick checking, and only continue if this exposes a problem.

    // Check the signature & format in the first sector's header.

    if( s_guidLogSignature != _header.GetSignature()
        ||
        CLOG_MAJOR_FORMAT != _header.GetMajorFormat()
      )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Corrupted log file on volume %c (Signature=%s, Format=0x%X)"),
                 _tcVolume,
                 (const TCHAR*)CDebugString(_header.GetSignature()),
                 _header.GetFormat() ));
        goto Exit;
    }

    // If this log has an uplevel minor version format, then set a bit
    // to show that the log has been touched by someone that doesn't fully
    // understand it.  This won't actually make the header dirty, but if
    // some other change takes place that does make it dirty, this bit
    // will be included in the flush.

    if( CLOG_MINOR_FORMAT < _header.GetMinorFormat() )
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("Setting downlevel-dirtied (0x%x, 0x%x)"),
                 CLOG_MINOR_FORMAT, _header.GetMinorFormat() ));
        _header.SetDownlevelDirtied();
    }

    // Check for proper shutdown.  The shutdown flag is always stored in the
    // first sector's header, since the log may not be in a state where we can
    // read for the most recent sector's header.  If the header wasn't shutdown,
    // we go into Recovering mode.  If it was shut down, we don't clear the
    // recovery flag, since the there may have been a shutdown during a previous recovery.
    // I.e., CLogFile's responsibility is to set the recovery flag automatically,
    // but to clear it only on request.

    if( _header.IsShutdown() )
    {
        if(_header.IsExpansionDataClear())
        {
            fValid = TRUE;
        }
        else
            goto Exit;

        // On debug builds, go ahead and run the validation code
#if DBG
        fValid = FALSE; // Fall through
#else
        goto Exit;
#endif

    }
    else
        TrkLog(( TRKDBG_ERROR, TEXT("Log was not properly shut down on volume %c:"), _tcVolume ));

    //  -----------------------------------------
    //  Recover after a crash during an expansion
    //  -----------------------------------------

    if( 0 != _header.ExpansionInProgress() )
    {

        TrkLog(( TRKDBG_ERROR, TEXT("Recovering from a previous log expansion attempt on volume %c"), _tcVolume ));
        TrkAssert( _header.GetPreExpansionStart() != _header.GetPreExpansionEnd() );
        TrkAssert( _header.GetPreExpansionSize() <= _cbLogFile );

        // Validate the expansion header.  We'll just ensure that the size is reasonable;
        // the linked-list pointers will be validated below.

        if( _header.GetPreExpansionSize() > _cbLogFile ) {
            TrkLog(( TRKDBG_ERROR, TEXT("Pre-expansion size is corrupted") ));
        }

        // Throw away the extra, uninitialized portion at the end of the file.

        if( !SetSize( _header.GetPreExpansionSize() ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Failed SetSize during validation of log on %c:"), _tcVolume ));
            TrkRaiseLastError();
        }

        // Ensure that the linked list is still circular.

        _sector.GetLogEntry( _header.GetPreExpansionEnd() )->ilogNext
            = _header.GetPreExpansionStart();

        _sector.GetLogEntry( _header.GetPreExpansionStart() )->ilogPrevious
            = _header.GetPreExpansionEnd();

        // Now that we're back in a good state, we can throw away the expansion
        // information.

        _sector.Flush( );
        _header.ClearExpansionData(); // flush through cache

    }   // if( 0 != _header.ExpansionInProgress() )


    //  ----------------------
    //  Check forward pointers
    //  ----------------------

    TrkAssert( 0 == _header.GetPreExpansionSize() );
    TrkAssert( 0 == _header.GetPreExpansionStart() );
    TrkAssert( 0 == _header.GetPreExpansionEnd() );

    // Walk through the next pointers, and verify each of the headers.

    cEntries = _cEntriesInFile;

    fFirstPass = TRUE;
    for( ilog = 0, cEntriesSeen = 0;
         cEntriesSeen < cEntries;
         ilog = _sector.ReadLogEntry(ilog)->ilogNext, cEntriesSeen++ )
    {
        // Ensure that the index is within range

        if( ilog >= cEntries )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Invalid index in log on volume %c (%d)"), _tcVolume, ilog ));
            goto Exit;
        }

        // We should never see index zero after the first pass through this
        // for loop.  If we do, then we have a cycle.

        if( fFirstPass )
            fFirstPass = FALSE;

        else if( 0 == ilog )
        {
            // We have a cycle
            TrkLog(( TRKDBG_ERROR, TEXT( "Forward cycle in log file on volume %c (%d of %d entries)"),
                     _tcVolume, ilog - 1, cEntries ));
            goto Exit;
        }

    }   // for( ilog = 0; ilog < cEntries; ilog = GetLogEntry(ilog)->ilogNext )

    // If the forward pointers are valid, we should have arrived back where
    // we started ... at index 0.

    if( 0 != ilog )
    {
        TrkLog(( TRKDBG_ERROR, TEXT( "Forward cycle in log file on volume %c"), _tcVolume ));
        goto Exit;
    }

    //  -----------------------
    //  Check backward pointers
    //  -----------------------

    // Walk through the prev pointers.  This time, we needn't check
    // the headers.

    fFirstPass = TRUE;
    for( ilog = 0, cEntriesSeen = 0;
         cEntriesSeen < cEntries;
         ilog = _sector.ReadLogEntry(ilog)->ilogPrevious, cEntriesSeen++ )
    {
        // Again, we should never see index zero after the first pass

        if( fFirstPass )
            fFirstPass = FALSE;

        else if( 0 == ilog )
        {
            TrkLog(( TRKDBG_ERROR, TEXT( "Backward cycle in log file on volume %c (%d of %d entries)"),
                     _tcVolume, ilog - 1, cEntries ));
            goto Exit;
        }

    }   // for( ilog = 0; ilog < cEntries; ilog = GetLogEntry(ilog)->ilogPrevious )

    // Ensure that we got back to where we started.

    if( 0 != ilog )
    {
        TrkLog(( TRKDBG_ERROR, TEXT( "Backward cycle in log file on volume %c"), _tcVolume ));
        goto Exit;
    }

    // If we reach this point, the log was valid.
    fValid = TRUE;


    //  ----
    //  Exit
    //  ----

Exit:

    return( fValid );

}   // CLogFile::Validate()


//+----------------------------------------------------------------------------
//
//  Method:     CreateNewLog (private)
//
//  Synopsis:   Create and initialize a new log file.  The file is created
//              so that only Administrators and the system can access it.
//
//  Arguments:  [ptszLogFile] (in)
//                  The name of the log file.
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLogFile::CreateAlwaysFile( const TCHAR *ptszTempName )
{
    NTSTATUS status = STATUS_SUCCESS;

    //  --------------
    //  Initialization
    //  --------------

    HRESULT hr = S_OK;

    DWORD dw = 0;
    DWORD dwWritten = 0;
    ULONG iLogEntry = 0;

    LogEntry *ple;

    //  --------------------------------------
    //  Create and Initialize the New Log File
    //  --------------------------------------

    status = CreateAlwaysSecureFile(ptszTempName);
    if( !NT_SUCCESS(status) )
        TrkRaiseException( status );

    //  ------------------------------
    //  Initialize the CLogFile object
    //  ------------------------------

    // Initialize the file.  Sets _cEntriesInFile.
    if( !SetSize( _pcTrkWksConfiguration->GetMinLogKB() * 1024 ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed SetSize of %s"), ptszTempName ));
        TrkRaiseLastError();
    }

    // We must always have at least 2 entries; an entry to hold data, and a margin
    // entry.

    if( 2 >= _cEntriesInFile )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Log file is too small (%d entries)"), _cEntriesInFile));
        TrkRaiseException( E_FAIL );
    }

    // Initialize the log header and sector

    _header.OnCreate( _hFile );
    _sector.OnCreate( _hFile );

    InitializeLogEntries( 0, _cEntriesInFile - 1 );

    // Since all the clients of the logfile have been notified, we can set the
    // shutdown flag.  This causes the first flush.  If we crash prior to this point,
    // a subsequent open attempt will find a corrupt file and re-create it.

    SetShutdown( TRUE );

    // Close the file
    CloseLog();

}   // CLogFile::CreateNewLog


//+----------------------------------------------------------------------------
//
//  Method:     OpenExistingFile (derived from PRobustlyCreateableFile)
//
//  Synopsis:   Open the log file and use it to initialize our state
//              (such as indices).
//
//  Arguments:  [ptszFile] (in)
//                  The name of the log file.
//
//  Returns:    [RCF_RESULT]
//                  OK  -       file now open
//                  CORRUPT -   file corrupt (and closed)
//                  NOT_FOUND - file not found
//
//              All other conditions result in an exception..
//
//+----------------------------------------------------------------------------

RCF_RESULT
CLogFile::OpenExistingFile( const TCHAR * ptszFile )
{
    //  --------------
    //  Initialization
    //  --------------

    NTSTATUS status = STATUS_SUCCESS;

    RCF_RESULT r = OK;
    ULONG cEntries = 0;
    ULONG cbRead = 0;

    SequenceNumber seqMin;
    SequenceNumber seqMax;
    BOOL fLogEmpty = TRUE;
    BOOL fWriteProtected;

    LogIndex ilogMin;
    LogIndex ilogMax;
    LogIndex ilogEntry;

    LogEntryHeader entryheader;
    const LogMoveNotification *plmn = NULL;

    //  --------------------------
    //  Open and Validate the File
    //  --------------------------

    __try
    {
        // See if the volume is read-only

        status = CheckVolumeWriteProtection( _ptszVolumeDeviceName, &fWriteProtected );
        if( !NT_SUCCESS(status) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't check if volume was write-protected for %s"),
                     ptszFile ));
            TrkRaiseNtStatus(status);
        }
        _fWriteProtected = fWriteProtected;
        TrkLog(( TRKDBG_VOLUME, TEXT("Volume is%s write-protected"),
                 _fWriteProtected ? TEXT("") : TEXT(" not") ));

        // Open the file

        status = OpenExistingSecureFile( ptszFile, _fWriteProtected );
        if( !NT_SUCCESS(status))
        {
            if (status != STATUS_OBJECT_NAME_NOT_FOUND && status != STATUS_OBJECT_PATH_NOT_FOUND)
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open %s"), ptszFile ));
                TrkRaiseNtStatus(status);
            }
            r = NOT_FOUND;
            __leave;
        }

        // Oplock the file

        TrkAssert( INVALID_HANDLE_VALUE != _heventOplock );

        SetOplock();

        _header.OnOpen( _hFile );
        _sector.OnOpen( _hFile );

        // Determine the size of the file.
        GetSize();

        // Validate the log file.  If it's corrupt, the _fRecovering
        // flag will be set in the Validate method.

        if( !Validate() )
        {
            r = CORRUPT;
        }

    }
    __finally
    {
        if( AbnormalTermination() || r == CORRUPT )
        {
            CloseLog( );
            TrkAssert(!IsOpen());
        }
    }

    //  ----
    //  Exit
    //  ----


    return( r );

}   // CLog::OpenExistingFile()



//+----------------------------------------------------------------------------
//
//  Method:     ReadMoveNotification
//
//  Synopsis:   Return a move notification entry from the log.
//
//  Arguments:  [ilogEntry] (in)
//                  The desired entry's index in the physical file.
//
//  Returns:    [LogMoveNotificatoin]
//
//+----------------------------------------------------------------------------

void
CLogFile::ReadMoveNotification( LogIndex ilogEntry, LogMoveNotification *plmn )
{
    const LogEntry *ple = NULL;

    // Load the sector which contains this log entry, if necessary
    // (also if necessary, this will flush the currently loaded
    // sector).

    *plmn = _sector.ReadLogEntry( ilogEntry )->move;

    return;

}   // CLogFile::ReadMoveNotification()


//+----------------------------------------------------------------------------
//
//  Method:     WriteMoveNotification
//
//  Synopsis:   Write a move notification entry to the log.
//
//  Arguments:  [ilogEntry] (in)
//                  The desired entry's index in the physical file.
//              [lmn] (in)
//                  The move notification data.
//              [entryheader] (in)
//                  The new LogEntryHeader
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLogFile::WriteMoveNotification( LogIndex ilogEntry,
                                 const LogMoveNotification &lmn,
                                 const LogEntryHeader &entryheader )
{
    // Load the sector from the file, put the new data into it,
    // and flush it.

    _sector.WriteMoveNotification( ilogEntry, lmn );
    _sector.WriteEntryHeader( ilogEntry, entryheader );
    _sector.Flush( );

}   // CLogFile::WriteMoveNotification()


//+----------------------------------------------------------------------------
//
//  Method:     ReadEntryHeader
//
//  Purpose:    Get the log header, which is stored in the sector of a given
//              log entry.
//
//  Arguments:  [ilogEntry] (in)
//                  The entry whose sector's header is to be loaded.
//
//  Returns:    [LogHeader]
//
//+----------------------------------------------------------------------------

LogEntryHeader
CLogFile::ReadEntryHeader( LogIndex ilogEntry )
{
    return _sector.ReadEntryHeader( ilogEntry );

}   // CLogFile::ReadEntryHeader()


//+----------------------------------------------------------------------------
//
//  Method:     WriteEntryHeader
//
//  Purpose:    Write the log header, which is stored in the sector of a given
//              log entry.
//
//  Arguments:  [ilogEntry] (in)
//                  The entry whose sector's header is to be loaded.
//              [logheader]
//                  The new header.
//
//  Returns:    None.
//
//+----------------------------------------------------------------------------

void
CLogFile::WriteEntryHeader( LogIndex ilogEntry, const LogEntryHeader &EntryHeader )
{
    _sector.WriteEntryHeader( ilogEntry, EntryHeader );

}   // CLogFile::WriteEntryHeader()




//+----------------------------------------------------------------------------
//
//  Method:     ReadExtendedHeader
//
//  Purpose:    Get a portion of the extended log header.  The offset is
//              relative to the extended portion of the header, not to the
//              start of the sector.
//
//  Arguments:  [iOffset] (in)
//                  The offset into the header.
//              [pv] (out)
//                  The buffer to which to read.
//              [cb] (in)
//                  The amount to read.
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLogFile::ReadExtendedHeader( ULONG iOffset, void *pv, ULONG cb )
{
    __try
    {
        ULONG cbRead;

        _header.ReadExtended( iOffset, pv, cb );

    }
    __finally
    {
        if( AbnormalTermination() )
            memset( pv, 0, cb );

    }


}   // CLogFile::ReadEntryHeader()


//+----------------------------------------------------------------------------
//
//  Method:     WriteExtendedHeader
//
//  Purpose:    Write to the extended portion of the log header.
//              log entry.  The offset is
//              relative to the extended portion of the header, not to the
//              start of the sector.
//
//  Arguments:  [iOffset] (in)
//                  The entry whose sector's header is to be loaded.
//              [pv] (in)
//                  The data to be written
//              [cb] (in)
//                  The size of the buffer to be written
//
//  Returns:    None.
//
//+----------------------------------------------------------------------------

void
CLogFile::WriteExtendedHeader( ULONG iOffset, const void *pv, ULONG cb )
{
    ULONG cbWritten;

    _header.WriteExtended( iOffset, pv, cb );

}   // CLogFile::WriteExtendedHeader()



//+----------------------------------------------------------------------------
//
//  Method:     AdjustLogIndex
//
//  Synopsis:   Moves a log entry index (requiring a linked-list
//              traversal).  We adjust by the number of entries specified
//              by the caller, or until we reach an optionally-provided limiting index,
//              whichever comes first.
//
//  Arguments:  [pilog] (in/out)
//                  A pointer to the index to be adjusted.
//              [iDelta] (in)
//                  The amount to adjust.
//              [adjustLimitEnum] (in)
//                  If set, then abide by ilogLimit.
//              [ilogLimit] (in)
//                  Stop if we reach this index.
//
//  Returns:    None.
//
//+----------------------------------------------------------------------------

void
CLogFile::AdjustLogIndex( LogIndex *pilog, LONG iDelta,
                          AdjustLimitEnum adjustLimitEnum, LogIndex ilogLimit )
{
    LogIndex ilogEntry = *pilog;
    LogIndex ilogEntryNew;

    while( iDelta != 0
           &&
           ( ilogEntry != ilogLimit || ADJUST_WITHOUT_LIMIT == adjustLimitEnum ) )
    {
        if( iDelta > 0 )
        {
            ilogEntryNew = _sector.ReadLogEntry( ilogEntry )->ilogNext;
            iDelta--;
        }
        else
        {
            ilogEntryNew = _sector.ReadLogEntry( ilogEntry )->ilogPrevious;
            iDelta++;
        }

        if( ilogEntryNew >= _cEntriesInFile || ilogEntryNew == ilogEntry )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Invalid Next index in log file (%d, %d)"), ilogEntry, ilogEntryNew ));
            TrkRaiseException( TRK_E_CORRUPT_LOG );
        }

        ilogEntry = ilogEntryNew;
    }

    *pilog = ilogEntry;

}   // CLogFile::AdjustLogIndex()


//+----------------------------------------------------------------------------
//
//  Method:     SetSize (private)
//
//  Synopsis:   Sets the size of the log file.
//
//  Arguments:  [cbLogFile] (in)
//                  The new file size.
//
//  Returns:    TRUE iff successfully.  Sets GetLastError otherwise.
//
//+----------------------------------------------------------------------------

BOOL
CLogFile::SetSize( DWORD cbLogFile )
{
    TrkAssert( cbLogFile >= 2 * _cbLogSector );

    if ( 0xFFFFFFFF == SetFilePointer( cbLogFile, NULL, FILE_BEGIN )
         ||
         !SetEndOfFile() )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't reset log file size to %lu (%08x)"),
                cbLogFile, HRESULT_FROM_WIN32(GetLastError()) ));
        return( FALSE );
    }

    _cbLogFile = cbLogFile;
    CalcNumEntriesInFile(); // Sets _cEntriesInFile

    return( TRUE );

}   // CLogFile::SetSize()




//+----------------------------------------------------------------------------
//
//  CLogFile::DoWork
//
//  Called when the log file's oplock breaks.  This calls up to the
//  host CVolume, which in turn calls and closes all handles.
//
//+----------------------------------------------------------------------------

void
CLogFile::DoWork()
{
    NTSTATUS status;
    TrkLog(( TRKDBG_VOLUME,
             TEXT("Logfile oplock broken for %c:\n")
             TEXT("    (info=0x%08x, status=0x%08x, _hreg=%x, this=%p)"),
             _tcVolume,
             _iosbOplock.Status,
             _iosbOplock.Information,
             _hRegisterWaitForSingleObjectEx,
             this ));

    // This is a register-once registration, so we must unregister it now.
    // Unregister with no completion event, since this would cause us to hang
    // (we're executing in the wait thread upon which it would wait).

    UnregisterOplockFromThreadPool( NULL );

    if( STATUS_CANCELLED == _iosbOplock.Status )
    {
        // The thread on which the oplock was created is gone.
        // We should be running on an IO thread now, so reset
        // the oplock.

        SetOplock();
    }
    else if( !NT_SUCCESS(_iosbOplock.Status) )
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Oplock failed (0x%08x)"), _iosbOplock.Status ));
    }
    else
    {
        // The oplock broke because someone tried to open the
        // log file.

        _pLogFileNotify->OnHandlesMustClose();
    }
}



void
CLogFile::SetOplock()
{
    NTSTATUS status;
    TrkAssert( INVALID_HANDLE_VALUE != _heventOplock );
    TrkAssert( NULL == _hRegisterWaitForSingleObjectEx );
    RegisterOplockWithThreadPool();

    status = NtFsControlFile(
                 _hFile,
                 _heventOplock,
                 NULL, NULL,
                 &_iosbOplock,
                 FSCTL_REQUEST_BATCH_OPLOCK,
                 NULL, 0, NULL, 0 );
    if( STATUS_PENDING != status )
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Couldn't oplock logfile (%08x)"), status ));
    }
    else
        TrkLog(( TRKDBG_VOLUME, TEXT("Log file oplocked") ));
}



//+----------------------------------------------------------------------------
//
//  Method:     GetSize (private)
//
//  Synopsis:   Determine the size of the log file.
//
//  Arguments:  None
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLogFile::GetSize()
{
    ULONG cbFile = 0;

    cbFile = GetFileSize( );
    if( 0xffffffff == cbFile )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't get log file size")));
        TrkRaiseLastError( );
    }

    _cbLogFile = cbFile;
    CalcNumEntriesInFile(); // Sets _cEntriesInFile

}   // CLogFile::GetSize()



//+----------------------------------------------------------------------------
//
//  CLogFile::RegisterOplockWithThreadPool
//
//  Register the logfile oplock with the thread pool.  When this event fires,
//  we need to close the log.
//
//+----------------------------------------------------------------------------

void
CLogFile::RegisterOplockWithThreadPool()
{
    if( NULL == _hRegisterWaitForSingleObjectEx )
    {
        // Between the time the event was previously unregistered and the
        // time the oplocked handle was closed, the event may have signaled.
        // Clear this irrelevant state now.

        ResetEvent( _heventOplock );

        // Register the event with the thread pool.

        _hRegisterWaitForSingleObjectEx
            = TrkRegisterWaitForSingleObjectEx( _heventOplock, ThreadPoolCallbackFunction,
                                                static_cast<PWorkItem*>(this), INFINITE,
                                                WT_EXECUTEONLYONCE | WT_EXECUTEINIOTHREAD );
        if( NULL == _hRegisterWaitForSingleObjectEx )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Failed to register log oplock with thread pool (%lu) for %c:"),
                     GetLastError(), _tcVolume ));
            TrkRaiseLastError();
        }
        else
        {
            TrkLog(( TRKDBG_VOLUME, TEXT("Registered log oplock event (h=%p, this=%p)"),
                     _hRegisterWaitForSingleObjectEx, this ));
        }
    }
}


//+----------------------------------------------------------------------------
//
//  CLogFile::UnregisterOplockFromThreadPool
//
//  Unregister the log file oplock from the thread pool.  This should be done
//  before closing the log file, so that we don't get an oplock break
//  notification during the close itself.
//
//+----------------------------------------------------------------------------

void
CLogFile::UnregisterOplockFromThreadPool( HANDLE hCompletionEvent  )
{
    HANDLE hToUnregister1 = NULL;
    HANDLE hToUnregister2 = NULL;

    if( NULL == _hRegisterWaitForSingleObjectEx )
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("No oplock wait to unregister") ));
        return;
    }

    // We don't want to use any kind of locking mechanism, in order to 
    // avoid the risk of blocking during the oplock break (while we're 
    // in this code, someone on the system is indefinitely blocked).

    // Get the current value of the handle.

    hToUnregister1 = _hRegisterWaitForSingleObjectEx;

    // If the handle hasn't changed between the previous line and the
    // following call, set it to null.

    hToUnregister2 = InterlockedCompareExchangePointer( &_hRegisterWaitForSingleObjectEx,
                                                        NULL,
                                                        hToUnregister1 );

    // If _hRegisterWaitForSingleObjectEx was unchanged as of the previous
    // call, we've got a local copy of it now, and we can safely unregister it.

    if( hToUnregister1 == hToUnregister2 )
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("Unregistering oplock wait (%x, %p)"), hToUnregister2, this ));

        if( !TrkUnregisterWait( hToUnregister2, hCompletionEvent ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Failed UnregisterWait for log oplock event (%lu)"),
                     GetLastError() ));
        }
        else
            TrkLog(( TRKDBG_VOLUME, TEXT("Unregistered wait for log oplock (%p)"), hToUnregister2 ));
    }
#if DBG
    else
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("No need to unregister wait for log oplock") ));
    }
#endif
}


//+----------------------------------------------------------------------------
//
//  Method:     Expand
//
//  Synopsis:   Grows the underlying log file, initializes the linked-list
//              entries in this new area, and links the new sub-list into
//              the existing list.  The previous end of the list points
//              to the new sub-list, and the last entry in the new
//              sub-list becomes the new end of the total list.
//
//  Arguments:  [cbDelta] (in)
//                  The amount by which to grow (rounded down to a sector
//                  boundary).
//              [ilogStart] (in)
//
//
//  Returns:    None
//
//+----------------------------------------------------------------------------

void
CLogFile::Expand( LogIndex ilogStart )
{
    ULONG cbLogFileNew;
    ULONG cEntriesOld, cEntriesNew;
    LogIndex ilogEnd = 0, ilogEntry = 0;
    LogHeader logheader;

    //  -------------
    //  Grow the file
    //  -------------

    // Find the end index

    ilogEnd = ilogStart;
    AdjustLogIndex( &ilogEnd, -1 );

    // We'll grow the log file by cbDelta, with a GetLogMaxKB ceiling, and
    // rounded down to an integral number of sectors.

    cbLogFileNew = _cbLogFile + _pcTrkWksConfiguration->GetLogDeltaKB() * 1024;
    cbLogFileNew = min( cbLogFileNew, _pcTrkWksConfiguration->GetMaxLogKB() * 1024 );
    cbLogFileNew = (cbLogFileNew / _cbLogSector) * _cbLogSector;

    TrkAssert( cbLogFileNew > _cbLogFile );

    // Put our current state in the log header, so that we can
    // recover if there is a crash during the remaining code.

    _header.SetExpansionData( _cbLogFile, ilogStart, ilogEnd ); // flush through cache

    // Grow the log file, keeping track of the old and new entry count.

    TrkLog(( TRKDBG_LOG, TEXT("Expanded log on volume %c (%d to %d bytes)"),
             _tcVolume, _cbLogFile, cbLogFileNew ));

    cEntriesOld = _cEntriesInFile;

    if( !SetSize( cbLogFileNew ))   // Updates _cEntriesInFile
    {
        LONG lError = GetLastError();
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't expand log on %c:"), _tcVolume ));
        _header.ClearExpansionData();
        TrkRaiseWin32Error( lError );
    }


    cEntriesNew = _cEntriesInFile;
    TrkAssert( cEntriesNew - cEntriesOld >= 1 );

    //  -----------------------------------------------------
    //  Initialize the new entries and link into current list
    //  -----------------------------------------------------

    // Initialize the new entries

    InitializeLogEntries( cEntriesOld, cEntriesNew - 1 );

    // Link the last new entry and the overall start entry.

    _sector.GetLogEntry( cEntriesNew - 1 )->ilogNext = ilogStart;
    _sector.GetLogEntry( ilogStart )->ilogPrevious = cEntriesNew - 1;


    // Link the end to the first new entry.

    _sector.GetLogEntry( ilogEnd )->ilogNext = cEntriesOld;
    _sector.GetLogEntry( cEntriesOld )->ilogPrevious = ilogEnd;

    // Show that we finished the expansion without crashing.

    _sector.Flush( );
    _header.ClearExpansionData();   // flush through cache

}   // CLogFile::Expand()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\logsect.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+----------------------------------------------------------------------------
//
//  File:       LogSect.cxx
//
//  Classes:    CLogFileSector
//
//+----------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop
#include "trkwks.hxx"


//+----------------------------------------------------------------------------
//
//  Method:     Initialize
//
//  Synopsis:   Initialize CLogFileSector.  This is called once for the object,
//              not for every sector it touches.
//
//  Inputs:     [cSkipSectors] (in)
//                  The number of sectors at the front of the file we're not
//                  allowed to touch.
//              [cbSector] (in)
//                  The size of a disk sector.
//
//  Outputs:    None
//
//+----------------------------------------------------------------------------

void
CLogFileSector::Initialize( ULONG cSkipSectors, ULONG cbSector )
{
    // Is the sector large enough?

    if( sizeof(LogEntry) + sizeof(LogEntryHeader) > cbSector )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Sector size isn't large enough for log sectors") ));
        TrkRaiseWin32Error( ERROR_BAD_CONFIGURATION );
    }

    // Allocate enough memory to hold a single sector.  This is the
    // only alloc in the class.

    if( NULL != _pvSector && _cbSector != cbSector )
    {
        delete [] _pvSector;
        _pvSector = NULL;
    }

    if( NULL == _pvSector )
    {
        _pvSector = static_cast<void*>( new BYTE[ cbSector ] );
        if( NULL == _pvSector )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't alloc a sector in CLogFileSector")));
            TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );
        }
    }

    // The entry header is at the end of every sector, always in the same place.

    _pEntryHeader = reinterpret_cast<LogEntryHeader*>( reinterpret_cast<BYTE*>(_pvSector)
                                                       +
                                                       cbSector
                                                       -
                                                       sizeof(*_pEntryHeader) );

    // Initialize the flags

    _fValid = FALSE;
    _fDirty = FALSE;

    // Save the inputs

    _cSkipSectors = cSkipSectors;
    _cbSector = cbSector;

    // Calculate how many entries can fit in a sector.

    _cEntriesPerSector = ( _cbSector - sizeof(*_pEntryHeader) ) / sizeof(LogEntry);

}   // CLogFileSector::Initialize


//+----------------------------------------------------------------------------
//
//  Method:     UnInitialize
//
//  Synopsis:   Free resources and re-initialize data members.
//
//  Inputs:     None
//
//  Output:     None
//
//+----------------------------------------------------------------------------

void
CLogFileSector::UnInitialize()
{
    if( NULL != _pvSector )
    {
        if( IsOpen() )
            OnClose();

        void *pvSector = _pvSector;
        _pvSector = NULL;
        delete [] pvSector;
    }

    _fValid = FALSE;

}   // CLogFileSector::UnInitialize



//+----------------------------------------------------------------------------
//
//  Method:     LoadSector
//
//  Synopsis:   Load a data sector from the log file.
//
//  Inputs:     [ilogEntry] (in)
//                  The index of the entry to load.  This is a 0-relative
//                  index, relative to the first data sector in the file.
//
//  Output:     None
//
//+----------------------------------------------------------------------------

void
CLogFileSector::LoadSector( LogIndex ilogEntry )
{
    ULONG iSector = 0;
    LARGE_INTEGER liOffset;
    NTSTATUS status = STATUS_SUCCESS;

    TrkAssert( _pvSector );
    TrkAssert( NULL != _hFile );

    // We can skip everything if the correct sector is already loaded

    if( !_fValid 
        ||
        ilogEntry < _ilogCurrentFirst
        ||
        ilogEntry >= _ilogCurrentFirst + _cEntriesPerSector
      )
    {
        // No, the sector isn't currently loaded.

        ULONG cbRead = 0;
        IO_STATUS_BLOCK IoStatusBlock;

        // If the current sector is dirty, flush it now, because we're
        // about to lose it.

        Flush();

        // Which sector contains this log entry?

        iSector = ilogEntry / _cEntriesPerSector + _cSkipSectors;

        // What is the byte index of this sector?

        liOffset.QuadPart = iSector * _cbSector;

        // Read the sector

        status = NtReadFile( _hFile, NULL, NULL, NULL,
                             &IoStatusBlock, _pvSector, _cbSector,
                             &liOffset, NULL );


        if ( STATUS_PENDING == status )
        {
            // Wait for the operation to complete.  The resulting status
            // will be put in the IOSB

            status = NtWaitForSingleObject( _hFile, FALSE, NULL );

            if( NT_SUCCESS(status) )
                status = IoStatusBlock.Status;
        }

        // Validate the results of the read

        if ( !NT_SUCCESS(status) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't read data sector from log file")));
            if(STATUS_VOLUME_DISMOUNTED == status)
            {
                TrkRaiseNtStatus(status);
            }
            else
            {
                TrkRaiseException( TRK_E_CORRUPT_LOG );
            }
        }

        if( NULL != g_ptrkwks ) // NULL when called by dltadmin.exe
            g_ptrkwks->_entropy.Put();

        if( _cbSector != IoStatusBlock.Information )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't read enough data bytes from log (%d)"),
                               IoStatusBlock.Information ));
            TrkRaiseException( TRK_E_CORRUPT_LOG );
        }

        // Remember what sector we've got (we keep the index of the first
        // entry in this sector).

        _ilogCurrentFirst = ( iSector - _cSkipSectors ) * _cEntriesPerSector;
        _fValid = TRUE;

    }   // if( !_fValid ...
}   // CLogFileSector::LoadSector



//+----------------------------------------------------------------------------
//
//  Method:     Flush
//
//  Synopsis:   Flush the current sector (if there is one) to the underlying
//              log file.
//
//  Inputs:     None
//  
//  Output:     None
//
//+----------------------------------------------------------------------------

void
CLogFileSector::Flush( )
{
    NTSTATUS status = STATUS_SUCCESS;
    RaiseIfNotOpen();

    // Is the sector loaded & dirty?

    if( _fValid && _fDirty )
    {
        // Yes, we need to flush it

        ULONG iSector = 0;
        LARGE_INTEGER liOffset;
        IO_STATUS_BLOCK IoStatusBlock;

        TrkAssert( NULL != _hFile );

        // Which sector contains the currently-loaded log entry?

        iSector = _ilogCurrentFirst / _cEntriesPerSector + _cSkipSectors;

        // Write the sector to the file

        liOffset.QuadPart = iSector * _cbSector;


        status = NtWriteFile( _hFile, NULL, NULL, NULL,
                              &IoStatusBlock, _pvSector, _cbSector,
                              &liOffset, NULL );

        if ( STATUS_PENDING == status )
        {
            // Wait for the operation to complete.  The resulting status
            // will be put in the IOSB

            status = NtWaitForSingleObject( _hFile, FALSE, NULL );

            if( NT_SUCCESS(status) )
                status = IoStatusBlock.Status;
        }

        // Validate the results of the write

        if ( !NT_SUCCESS(status) )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't write data to the log file")));
            TrkRaiseNtStatus( status );
        }

        if( _cbSector != IoStatusBlock.Information )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Couldn't write enough data bytes to the log (%d)"),
                               IoStatusBlock.Information ));
            TrkRaiseException( TRK_E_CORRUPT_LOG );
        }

        if( NULL != g_ptrkwks ) // NULL when called by dltadmin.exe
            g_ptrkwks->_entropy.Put();

        SetDirty( FALSE );

    }   // if( _fValid && _fDirty )

}   // CLogFileSector::Flush
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\stub_trkwks_c.c ===
#undef RPC_NO_WINDOWS_H
#include <trkwks_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\main.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       main.cxx
//
//  Contents:   Main startup for Tracking (Workstation) Service
//
//  Classes:
//
//  Functions:
//
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:
//
//  Codework:
//
//--------------------------------------------------------------------------


#include "pch.cxx"
#pragma hdrstop

#define TRKDATA_ALLOCATE
#include "trkwks.hxx"
#undef TRKDATA_ALLOCATE

#include "svcs.h"

#define THIS_FILE_NUMBER    MAIN_CXX_FILE_NO



//+----------------------------------------------------------------------------
//
//  SvcsWorkerCallback
//
//  This is the callback routine that we register with the services.exe
//  thread pool.  We only register one item with that thread pool, an
//  event that gets signaled when the service has been stopped.
//
//+----------------------------------------------------------------------------

//HANDLE g_hWait = NULL;

void
ServiceStopCallback( PVOID pContext, BOOLEAN fTimeout )
{
    CTrkWksSvc *ptrkwks = reinterpret_cast<CTrkWksSvc*>(pContext);

    __try
    {
        /*
        UnregisterWait( g_hWait );
        g_hWait = NULL;
        */

        // Close down the service.  This could block while threads are
        // completed.

        ptrkwks->UnInitialize( S_OK );
        CTrkRpcConfig::_fInitialized = FALSE;
        delete ptrkwks;

        TrkAssert( NULL == g_ptrkwks );

        // Close the stop event and the debug log

        // Uninitialize the DLL, since it's never actually unloaded.
        CommonDllUnInit( &g_ctrkwks );
#if DBG
        TrkDebugDelete( );
#endif

        TrkLog((TRKDBG_WKS, TEXT("TrkWks service stopped") ));
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Exception during service stop - %08x"), GetExceptionCode() ));
    }


}

//+----------------------------------------------------------------------------
//
//  ServiceMain
//
//  This function is exported from the dll, and is called when we run
//  under svchost.exe.
//
//+----------------------------------------------------------------------------

VOID WINAPI
ServiceMain(DWORD dwArgc, LPTSTR *lptszArgv)
{
    SVCS_ENTRY_POINT( dwArgc, lptszArgv, NULL, NULL );
}


//+----------------------------------------------------------------------------
//
//  ServiceEntry
//
//  This function is also exported from the dll, and is called directly when
//  we run under services.exe (the normal case), but is also called by
//  ServiceMain when we run under svchost.exe.  We distinguish between the
//  two by checking pSvcsGlobalData (non-NULL iff running under services.exe).

//  Since we use the Win32 thread pool, this routine returns after some
//  initialization, it isn't held for the lifetime of the service (except
//  when run under svchost.exe).
//
//+----------------------------------------------------------------------------

VOID
SVCS_ENTRY_POINT(
    DWORD NumArgs,
    LPTSTR *ArgsArray,
    PSVCHOST_GLOBAL_DATA pSvcsGlobalData,
    IN HANDLE  SvcRefHandle
    )
{


    HRESULT     hr = S_OK;
    BOOL fDllInitialized = FALSE;
    CTrkWksSvc *ptrkwks = NULL;

#if DBG
    BOOL fDbgLogInitialized = FALSE;
#endif

    __try
    {
        #if DBG
            {
                CTrkConfiguration cTrkConfiguration;
                cTrkConfiguration.Initialize();

                TrkDebugCreate( cTrkConfiguration._dwDebugStoreFlags, "TrkWks" );
                cTrkConfiguration.UnInitialize();
                fDbgLogInitialized = TRUE;
            }
        #endif

        // Initialize the DLL itself.  This raises if there is already a running
        // trkwks service.

        CommonDllInit( &g_ctrkwks );

        TrkLog(( TRKDBG_WKS, TEXT("\n") ));

        // Create and initialize the primary service object

        ptrkwks = new CTrkWksSvc;
        if( NULL == ptrkwks )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't alloc CTrkWksSvc") ));
            return;
        }

        ptrkwks->Initialize( pSvcsGlobalData );
        TrkAssert( NULL != g_ptrkwks );

        // Are we in services.exe?

        /*
        if( NULL != pSvcsGlobalData )
        {
            // Yes.  Register the stop event with the thread pool.
            // Register as a long function, so that when we do an LPC connect
            // in CPort::UnInitialize, the thread pool will be willing to create
            // a thread for CPort::DoWork to process the connect.

            if( !RegisterWaitForSingleObject( &g_hWait,
                                              g_hServiceStopEvent,
                                              ServiceStopCallback,
                                              g_ptrkwks, INFINITE,
                                              WT_EXECUTEONLYONCE | WT_EXECUTELONGFUNCTION  ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't add service stop event to thread pool") ));
                TrkReportInternalError( THIS_FILE_NUMBER, __LINE__,
                                        HRESULT_FROM_WIN32(GetLastError()),
                                        TRKREPORT_LAST_PARAM );
                TrkRaiseLastError();
            }

        }
        else
        {
            // No, we're running in svchost.exe.  We'll use this thread to wait
            // on the stop event.

            if( WAIT_OBJECT_0 != WaitForSingleObject( g_hServiceStopEvent, INFINITE ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't wait for g_hServiceStopEvent (%lu)"),
                         GetLastError() ));
                TrkRaiseLastError();
            }

            // The service is stopping.  Call the same callback routine that's called
            // by the services thread pool when we run under services.exe.

            ServiceStopCallback( ptrkwks, FALSE );
        }
        */

        ptrkwks = NULL;
    }
    __except(BreakOnDebuggableException())
    {
        hr = GetExceptionCode();
#if DBG
        if( fDbgLogInitialized )
            TrkLog((TRKDBG_ERROR, TEXT("couldn't initialize, hr=%08X"),hr));
#endif

        if( NULL != ptrkwks )
        {
            __try
            {
                ptrkwks->UnInitialize( hr );
            }
            __except( EXCEPTION_EXECUTE_HANDLER )
            {
                TrkAssert( !TEXT("Unexpected exception in trkwks!ServiceEntry") );
            }
            TrkAssert( NULL == g_ptrkwks );
            delete ptrkwks;
            ptrkwks = NULL;
        }

        if( fDllInitialized )
            CommonDllUnInit( &g_ctrkwks );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\sid.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  sid.cxx
//
//  Implementation of CSID, which is a wrapper class for a SID.
//
//+============================================================================

#include "pch.cxx"
#pragma hdrstop

#include "trkwks.hxx"


//+----------------------------------------------------------------------------
//
//  CSID::Initialize
//  
//  Alloc and initialize a SID
//
//+----------------------------------------------------------------------------

VOID
CSID::Initialize( enumCSIDAuthority enumcsidAuthority,
                  BYTE  cSubAuthorities ,
                  DWORD dwSubAuthority0 = 0,
                  DWORD dwSubAuthority1 = 0,
                  DWORD dwSubAuthority2 = 0,
                  DWORD dwSubAuthority3 = 0,
                  DWORD dwSubAuthority4 = 0,
                  DWORD dwSubAuthority5 = 0,
                  DWORD dwSubAuthority6 = 0,
                  DWORD dwSubAuthority7 = 0 )
{
    SID_IDENTIFIER_AUTHORITY rgsid_identifier_authority[] = { SECURITY_NT_AUTHORITY };

    if( NULL != _psid )
    {
        FreeSid( _psid );
        _psid = NULL;
    }


    if( !AllocateAndInitializeSid( &rgsid_identifier_authority[ enumcsidAuthority ],
                               cSubAuthorities,
                               dwSubAuthority0,
                               dwSubAuthority1,
                               dwSubAuthority2,
                               dwSubAuthority3,
                               dwSubAuthority4,
                               dwSubAuthority5,
                               dwSubAuthority6,
                               dwSubAuthority7,
                               &_psid ))
        TrkRaiseLastError();

    _fInitialized = TRUE;

            
}

//+----------------------------------------------------------------------------
//
//  CSID::operator PSID
//
//  Return the SID
//
//+----------------------------------------------------------------------------

CSID::operator PSID()
{
    return( _psid );
}


//+----------------------------------------------------------------------------
//
//  CSID::UnInitialize
//
//  Free the SID.
//
//+----------------------------------------------------------------------------

VOID
CSID::UnInitialize()
{
    if( _fInitialized )
    {
        if( NULL != _psid )
        {
            FreeSid( _psid );
            _psid = NULL;
        }

        _fInitialized = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\munglog.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

// This is not production code

#include <stdio.h>
#include <tchar.h>
#include <windows.h>

#include "munglog.hxx"


HRESULT
OpenLog( int vol, HANDLE *phFile )
{
    TCHAR tszPath[ MAX_PATH + 1 ];

    _tcscpy( tszPath, TEXT("A:\\~secure.nt\\tracking.log" ));
    *tszPath += vol;

    *phFile = CreateFile( tszPath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ,
                          NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    if( INVALID_HANDLE_VALUE == *phFile )
        return( HRESULT_FROM_WIN32( GetLastError() ) );
    else
        return( S_OK );
}

HRESULT
WriteLog( HANDLE hFile, ULONG ulOffset, void *pv, const ULONG cb )
{
    HRESULT hr = S_OK;
    ULONG cbWritten;

    if( !SetFilePointer( hFile, ulOffset, NULL, FILE_BEGIN ))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }


    if( !WriteFile( hFile, pv, cb, &cbWritten, NULL )
        ||
        cb != cbWritten
        )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Exit;
    }

Exit:

    return( hr );
}


HRESULT
MungeLog( EnumMunge enumMunge, void *pv, int vol )
{
    HRESULT hr = E_FAIL;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    hr = OpenLog( vol, &hFile );
    if( FAILED(hr) ) goto Exit;

    if( MUNGE_MACHINE_ID == enumMunge )
        hr = WriteLog( hFile, MUNGELOG_MACHINEID_OFFSET, pv, MUNGELOG_CB_MACHINEID );
    else
        hr = WriteLog( hFile, MUNGELOG_VOLSECRET_OFFSET, pv, MUNGELOG_CB_VOLSECRET );

Exit:

    if( INVALID_HANDLE_VALUE != hFile )
        CloseHandle( hFile );

    return( hr );

}


/*
extern "C" void wmain()
{
    HRESULT hr;
    BYTE mcid[ 16 ];
    BYTE secret[ 16 ];

    strncpy( (char*)&mcid, "abcdefghijklmnopqrstuvwxyz", sizeof(mcid) );
    strncpy( (char*)&secret, "zyxwvutsrqponmlkjihgfedcba", sizeof(secret) );

    hr = MungeLog( MUNGE_VOLUME_SECRET, &secret, 4 );
    printf( "Secret = %08x\n", hr );

    hr = MungeLog( MUNGE_MACHINE_ID, &mcid, 4 );
    printf( "Machine = %08x\n", hr );

}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\trkwks_sp.c ===
// Copyright (c) 1996-1999 Microsoft Corporation


#include <windows.h>
#include <rpc.h>
#include <rpcasync.h>
#include "trkwks_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\port.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       port.cxx
//
//  Contents:   Code that receives notifications of moves from
//              kernel.
//
//  Classes:
//
//  Functions:
//
//
//
//  History:
//
//  Notes:
//
//  Codework:   Security on semaphore and port objects
//              _hDllReference when put in services.exe
//              InitializeObjectAttributes( &oa, &name, 0, NULL, NULL /* &sd */ );
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "trkwks.hxx"

#define THIS_FILE_NUMBER    PORT_CXX_FILE_NO

DWORD WINAPI
PortThreadStartRoutine( LPVOID lpThreadParameter );

//+----------------------------------------------------------------------------
//
//  CSystemSD::Initialize
//  CSystemSD::UnInitialize
//
//  Init and uninit the security descriptor that gives access only
//  to System, or to System and Administrators.
//
//+----------------------------------------------------------------------------

void
CSystemSD::Initialize( ESystemSD eSystemSD )
{
    // Add ACEs to the DACL in a Security Descriptor which give the
    // System and Administrators full access.

    _csd.Initialize();

    if( SYSTEM_AND_ADMINISTRATOR == eSystemSD )
    {
        _csidAdministrators.Initialize( CSID::CSID_NT_AUTHORITY,
                                       SECURITY_BUILTIN_DOMAIN_RID,
                                       DOMAIN_ALIAS_RID_ADMINS );

        _csd.AddAce( CSecDescriptor::ACL_IS_DACL, CSecDescriptor::AT_ACCESS_ALLOWED,
                    FILE_ALL_ACCESS, _csidAdministrators );
    }
    else
        TrkAssert( SYSTEM_ONLY == eSystemSD );

    _csidSystem.Initialize( CSID::CSID_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID );

    _csd.AddAce( CSecDescriptor::ACL_IS_DACL, CSecDescriptor::AT_ACCESS_ALLOWED,
                    FILE_ALL_ACCESS, _csidSystem );
}

void
CSystemSD::UnInitialize()
{
    _csidAdministrators.UnInitialize();
    _csidSystem.UnInitialize();
    _csd.UnInitialize();
}



//+----------------------------------------------------------------------------
//
//  CPort::Initialize
//
//  Create an LPC port to which the kernel will send move notifications,
//  and open an event created by the kernel with which we'll signal
//  our readiness to receive requests.
//
//+----------------------------------------------------------------------------

void
CPort::Initialize( CTrkWksSvc *pTrkWks,
                   DWORD dwThreadKeepAliveTime )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING name;
    CSystemSD ssd;
    DWORD dwThreadId;

    __try
    {
        _hListenPort = NULL;
        _hEvent = NULL;
        _pTrkWks = pTrkWks;
        _hLpcPort = NULL;
        _hRegisterWaitForSingleObjectEx = NULL;
        _fTerminating = FALSE;

        // Create an LPC port to which the kernel will send move-notification requests

        RtlInitUnicodeString( &name, TRKWKS_PORT_NAME );
        ssd.Initialize();
        InitializeObjectAttributes( &oa, &name, 0, NULL, ssd.operator const PSECURITY_DESCRIPTOR() );

        Status = NtCreateWaitablePort(&_hListenPort, &oa,
            sizeof(ULONG),          // IN ULONG MaxConnectionInfoLength
            sizeof(TRKWKS_PORT_REQUEST), // IN ULONG MaxMessageLength
            0);                     // not used : IN ULONG MaxPoolUsage

        if (!NT_SUCCESS(Status))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't create LPC connect port") ));
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, Status, TRKWKS_PORT_NAME );
            TrkRaiseException(Status);
        }

        // Show that we need to do work in the UnInitialize method.
        _fInitializeCalled = TRUE;


        // Open the event which is created by the kernel for synchronization.
        // We tell the kernel that we're available for move-notification requests
        // by setting this event.

        RtlInitUnicodeString( &name, TRKWKS_PORT_EVENT_NAME );

        Status = NtOpenEvent( &_hEvent, EVENT_ALL_ACCESS, &oa );
        if (!NT_SUCCESS(Status))
        {
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, Status, TRKWKS_PORT_EVENT_NAME );
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open %s event"), TRKWKS_PORT_EVENT_NAME ));
            TrkRaiseException(Status);
        }

        // Register our LPC connect port with the thread pool.  When that handle signals,
        // we'll run CPort::DoWork (it signals when we get any message, including
        // LPC_CONNECT_REQUEST).

        if( !RegisterWorkItemWithThreadPool() )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Failed RegisterWaitForSingleObjectEx in CPort::Initialize (%lu)"),
                     GetLastError() ));
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, Status, TRKREPORT_LAST_PARAM );
            TrkRaiseLastError();
        }

        // When we receive a move notification and we get a thread from the pool,
        // we'll keep that thread until we've gone idle for this amount of time.
        // So if we receive several requests in a short period of time, we won't
        // have to get a thread out of the pool for each.

        _ThreadKeepAliveTime.QuadPart = -static_cast<LONGLONG>(dwThreadKeepAliveTime) * 10000000;

    }
    __finally
    {
        ssd.UnInitialize();
    }
}


//+----------------------------------------------------------------------------
//
//  CPort::RegisterWorkItemWithThreadPool
//
//  Register the LPC connect port (_hListenPort) with the thread pool.
//
//+----------------------------------------------------------------------------

BOOL
CPort::RegisterWorkItemWithThreadPool()
{
    // This is an execute-only-once work item, so it's inactive now.
    // Delete it, specifying that there should be no completion event
    // (if a completion event were used, this call would hang forever).

    if( NULL != _hRegisterWaitForSingleObjectEx )
        TrkUnregisterWait( _hRegisterWaitForSingleObjectEx, NULL );

    // Now register it again.

    _hRegisterWaitForSingleObjectEx
        = TrkRegisterWaitForSingleObjectEx( _hListenPort, ThreadPoolCallbackFunction,
                                            static_cast<PWorkItem*>(this), INFINITE,
                                            WT_EXECUTEONLYONCE );

    if( NULL == _hRegisterWaitForSingleObjectEx )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RegisterWaitForSingleObjectEx in CPort::DoWork (%lu)"),
                 GetLastError() ));
        return( FALSE );
    }
    else
        TrkLog(( TRKDBG_PORT, TEXT("Registered LPC port work item") ));

    return( TRUE );
}




//+----------------------------------------------------------------------------
//
//  CPort::OnConnectionRequest
//
//  Called when a connection request has been received.  It is either
//  accepted or rejected, depending on the request and the current state
//  of the service.
//
//  When the service is shutting down, CPort::UnInitialize posts a connection
//  request with some connection information.  When that connection request
//  is received, it is rejected, and the pfStopPortThread is set True.
//
//+----------------------------------------------------------------------------

NTSTATUS
CPort::OnConnectionRequest( TRKWKS_PORT_CONNECT_REQUEST *pPortConnectRequest, BOOL *pfStopPortThread )
{
    HANDLE hLpcPortT = NULL;
    HANDLE *phLpcPort = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fAccept = TRUE;

    *pfStopPortThread = FALSE;

    // Determine if we should accept or reject this connection request.

    if( pPortConnectRequest->PortMessage.u1.s1.DataLength
        >=
        sizeof(pPortConnectRequest->Info) )
    {
        // There's extra connection info in this request.  See if it's a request
        // code that indicates that we should close down the port.

        if( TRKWKS_RQ_EXIT_PORT_THREAD == pPortConnectRequest->Info.dwRequest )
        {
            fAccept = FALSE;
            *pfStopPortThread = TRUE;
            TrkLog(( TRKDBG_PORT, TEXT("Received port shutdown connection request") ));
        }
        else
        {
            fAccept = FALSE;
            TrkLog(( TRKDBG_ERROR, TEXT("CPort: unknown Info.dwRequest (%d)"),
                     pPortConnectRequest->Info.dwRequest ));
        }

    }
    else if( _fTerminating )
    {
        // We're shutting down, reject the request
        fAccept = FALSE;
        TrkLog(( TRKDBG_PORT, TEXT("Received connect request during service shutdown") ));
    }


    // Point phLpcPort to the real communications handle, or the dummy one used
    // for rejections.

    if( fAccept )
    {
        phLpcPort = &_hLpcPort;

        // Close out any existing communication port
        if( NULL != _hLpcPort )
        {
            NtClose( _hLpcPort );
            _hLpcPort = NULL;
        }
    }
    else
    {
        phLpcPort = &hLpcPortT;
    }

    // Accept or reject the new connection.
    // In the reject case, this could create a race condition.  After we make the
    // NtAcceptConnectPort call, the CPort::UnInitialize thread might wake up and
    // delete the CPort before this thread runs again.  So, after making this
    // call, we cannot touch anything in 'this'.

    TrkLog(( TRKDBG_PORT, TEXT("%s connect request"),
             fAccept ? TEXT("Accepting") : TEXT("Rejecting") ));

    TRKWKS_PORT_REQUEST *pPortRequest = (TRKWKS_PORT_REQUEST*) pPortConnectRequest;
    pPortRequest->PortMessage.u1.s1.TotalLength = sizeof(*pPortRequest);
    pPortRequest->PortMessage.u1.s1.DataLength = sizeof(pPortRequest->Request); // MaxMessageLength

    Status = NtAcceptConnectPort(
        phLpcPort,              // PortHandle,
        NULL,                   // PortContext OPTIONAL,
        &pPortRequest->PortMessage,
        (BOOLEAN)fAccept,       // AcceptConnection,
        NULL,                   // ServerView OPTIONAL,
        NULL);                  // ClientView OPTIONAL

    if( !NT_SUCCESS(Status) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed NtAcceptConnectPort(%s) %08x"),
                 fAccept ? TEXT("accept"):TEXT("reject"),
                 Status ));
        goto Exit;
    }

    // If we rejected it, then phLpcPort was hLpcPortT, and it's just
    // a dummy argument which must be present but isn't set by NtAcceptConnectPort.
    TrkAssert( NULL != *phLpcPort || !fAccept );

    // Wake up the client thread (unblock its call to NtConnectPort)

    if( fAccept  )
    {

        Status = NtCompleteConnectPort( _hLpcPort );
        if( !NT_SUCCESS(Status) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Failed NtCompleteConnectPort %08x"), Status ));
            goto Exit;
        }
    }

Exit:

    return( Status );

}


//+----------------------------------------------------------------------------
//
//  CPort::DoWork
//
//  This method is called by the thread pool when our LPC connect port
//  (_hLpcListenPort) is signaled to indicate that a request is available.
//  If the request is a connection request, we accept or reject it and continue.
//  If the request is a move notification request, we send it to
//  CTrkWksSvc for processing.
//
//  This work item is registerd with the thread pool with the
//  WT_EXECUTEONLYONCE flag, since the connection port isn't
//  auto-reset.  So after processing, we must
//  re-register.  Before doing so, or if re-registration fails,
//  we keep the thread in a NtReplyWaitReceiveEx call for several
//  (configurable) seconds.  This way, if several requests arrive
//  in a short amount of time, we don't have to thrash the thread pool.
//
//  During service termination, _fTerminate is set, and a connection
//  request is made by CPort::UnInitialize.  This request is rejected,
//  and in that case we don't re-register the connect port with the thread
//  pool.
//
//+----------------------------------------------------------------------------

void
CPort::DoWork()
{
    NTSTATUS                Status = STATUS_SUCCESS;
    TRKWKS_PORT_REQUEST     PortRequest;
    TRKWKS_PORT_REPLY       PortReply;

    PortRequest.PortMessage.u1.s1.TotalLength = sizeof(PortRequest.PortMessage);
    PortRequest.PortMessage.u1.s1.DataLength = (CSHORT)0;

    BOOL fReuseThread = FALSE;

    // The fact that we're running indicates that there's a request
    // waiting for us, and the first NtReplyWaitReceivePortEx below will
    // immediately return.  We loop until nothing is received for 30
    // seconds.

    while( TRUE )
    {
        BOOL fTerminating = FALSE;      // TRUE => service is shutting down
        BOOL fStopPortThread = FALSE;   // TRUE => we should shut down this port

        Status = NtReplyWaitReceivePortEx( _hListenPort, //_hLpcPort,
                                           NULL,
                                           NULL,
                                           &PortRequest.PortMessage,
                                           &_ThreadKeepAliveTime
                                         );

        // Cache a local copy of _fTerminating.  In the shutdown case, there's
        // a race condition where the CPort object gets deleted before this routine
        // can finish.  By caching this flag, we don't have to touch this 'this'
        // pointer in that case, and therefore avoid the problem.

        fTerminating = _fTerminating;

        // If we timeed out, then let the thread return to the thread pool.

        if( STATUS_TIMEOUT != Status )
        {
            // We didn't time out.

#if DBG
            if( fReuseThread )
                TrkLog(( TRKDBG_PORT, TEXT("CPort re-using thread") ));
#endif
            fReuseThread = TRUE;

            // Is this a request for a new connection?

            if( NT_SUCCESS(Status)
                &&
                LPC_CONNECTION_REQUEST == PortRequest.PortMessage.u2.s2.Type )
            {
                TrkLog(( TRKDBG_PORT, TEXT("Received LPC connect request") ));

                Status = OnConnectionRequest( (TRKWKS_PORT_CONNECT_REQUEST*) &PortRequest,
                                               &fStopPortThread );
#if DBG
                if( !NT_SUCCESS(Status) )
                    TrkLog(( TRKDBG_ERROR, TEXT("CPort::DoWork couldn't handle connection request %08x"), Status ));
#endif

            }   // if( ... LPC_CONNECTION_REQUEST == PortRequest.PortMessage.u2.s2.Type )

            // Or, is this a good move notification?

            else if( NT_SUCCESS(Status) && NULL != _hLpcPort )
            {

                // Process the move notification in CTrkWksSvc.  If we're in the proces,
                // though, of shutting the service down, then return the same error that
                // the kernel would see if DisableKernelNotifications had been called
                // in time.

                if( _fTerminating )
                    PortReply.Reply.Status = STATUS_OBJECT_NAME_NOT_FOUND;
                else
                    // The following doesn't raise.
                    PortReply.Reply.Status = _pTrkWks->OnPortNotification( &PortRequest.Request );

                // Send the resulting Status back to the kernel.

                PortReply.PortMessage = PortRequest.PortMessage;
                PortReply.PortMessage.u1.s1.TotalLength = sizeof(PortReply);
                PortReply.PortMessage.u1.s1.DataLength = sizeof(PortReply.Reply);

                Status = NtReplyPort( _hLpcPort, &PortReply.PortMessage );
#if DBG
                if( !NT_SUCCESS(Status) )
                    TrkLog(( TRKDBG_ERROR, TEXT("Failed NtReplyPort (%08x)"), Status ));
#endif
            }

            // Otherwise, we either got an error, or a non-connect message on an
            // unconnected port.

            else
            {
                if( NT_SUCCESS(Status) )
                    Status = STATUS_CONNECTION_INVALID;

                TrkLog(( TRKDBG_ERROR, TEXT("CPort::PortThread - NtReplyWaitReceivePortEx failed %0X/%p"),
                         Status, _hLpcPort ));
            }

            // To be robust against some unknown bug causing thrashing, sleep
            // if there was an error.

            if( !NT_SUCCESS(Status) && !fTerminating && !fStopPortThread )
                Sleep( 1000 );

            // Unless the service is shutting down, we don't want to fall
            // through and re-register yet.  We should go back to the
            // NtReplyWaitReceivePortEx to see if there are more requests
            // or will be soon.

            if( !fStopPortThread )
                continue;


        }   // if( STATUS_TIMEOUT != Status )

        // Re-register the connect port with the thread pool, unless we're supposed
        // to stop the port thread.

        if( fStopPortThread )
        {
            TrkLog(( TRKDBG_PORT, TEXT("Stopping port work item") ));
        }
        else
        {
            // If we can't re-register for some reason, just continue back to the top
            // and sit in the NtReplyWaitReceiveEx for a while.

            if( !RegisterWorkItemWithThreadPool() )
            {
                TrkLog(( TRKDBG_PORT, TEXT("Re-using port thread due to registration error (%lu)"), GetLastError() ));
                continue;
            }
            else
                TrkLog(( TRKDBG_PORT, TEXT("Returning port thread to pool") ));
        }

        // We're either terminating or we've successfully re-registered.  In either case, we can let
        // the thread go back to the pool.

        break;

    }   // while( TRUE )

}



//+----------------------------------------------------------------------------
//
//  CPort::UnInitialize
//
//  Remove the LPC connect port work item from the thread pool, and
//  clean everything up.
//
//  To remove the work item, we can't safely call UnregisterWait, because
//  we register with WT_EXECUTEONLYONCE.  Thus when we call UnregisterWait,
//  the wait may have already been deleted.  So, instead, we attempt a connection
//  to the LPC connect port, after first setting _fTerminating.  This will be
//  picked up on a thread pool thread in DoWork, the connection will be
//  rejected, and the work item will not be re-registered.
//
//+----------------------------------------------------------------------------

void
CPort::UnInitialize()
{
    if (_fInitializeCalled)
    {
        NTSTATUS status = STATUS_SUCCESS;
        UNICODE_STRING usPortName;
        OBJECT_ATTRIBUTES oa;
        HANDLE hPort = NULL;
        ULONG cbMaxMessage = 0;
        TRKWKS_CONNECTION_INFO ConnectionInformation = { TRKWKS_RQ_EXIT_PORT_THREAD };
        ULONG cbConnectionInformation = sizeof(ConnectionInformation);

        _fTerminating = TRUE;

        // Attempt to connect to _hLpcListenPort

        RtlInitUnicodeString( &usPortName, TRKWKS_PORT_NAME );

        SECURITY_QUALITY_OF_SERVICE dynamicQos;
        dynamicQos.ImpersonationLevel = SecurityImpersonation;
        dynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        dynamicQos.EffectiveOnly = TRUE;

        TrkLog(( TRKDBG_PORT, TEXT("CPort::UnInitialize doing an NtConnectPort to %s"), TRKWKS_PORT_NAME ));
        status = NtConnectPort( &hPort, &usPortName, &dynamicQos, NULL, NULL,
                                &cbMaxMessage, &ConnectionInformation, &cbConnectionInformation );
        TrkLog(( TRKDBG_PORT, TEXT("CPort::UnInitialize, NtConnectPort completed (0x%08x)"), status ));

        if( NT_SUCCESS(status) )
        {
            TrkLog(( TRKDBG_PORT, TEXT("CPort::UnInitialize NtConnectPort unexpectedly succeeded"), status ));
            if( NULL != hPort )
                NtClose( hPort );
        }
#if DBG
        else
        {
            TrkAssert( NULL == hPort );
            if( STATUS_PORT_CONNECTION_REFUSED != status )
                TrkLog(( TRKDBG_ERROR, TEXT("CPort::UnInitialize NtConnectPort failed (%08x)"), status ));
        }
#endif

        // DoWork has been called and is done.  Unregister the work item, waiting for the thread
        // to complete.

        if( NULL != _hRegisterWaitForSingleObjectEx )
            TrkUnregisterWait( _hRegisterWaitForSingleObjectEx );
        _hRegisterWaitForSingleObjectEx = NULL;

        // Clean up the port.

        if (_hLpcPort != NULL)
            TrkVerify( NT_SUCCESS( NtClose(_hLpcPort) ) );
        _hLpcPort = NULL;

        if (_hListenPort != NULL)
            TrkVerify( NT_SUCCESS( NtClose(_hListenPort) ) );
        _hListenPort = NULL;

        if( NULL != _hEvent )
            NtClose( _hEvent );
        _hEvent = NULL;


        _fInitializeCalled = FALSE;
    }
}


//+----------------------------------------------------------------------------
//
//  CPort::EnableKernelNotifications
//  CPort::DisableKernelNotifications
//
//  Set/clear the event which tells nt!IopConnectLinkTrackingPort that we're
//  up and ready to receive a connection.
//
//+----------------------------------------------------------------------------

void
CPort::EnableKernelNotifications()
{
    NTSTATUS Status;

    Status = NtSetEvent( _hEvent, NULL );

    TrkVerify( NT_SUCCESS( Status ) );
}

void
CPort::DisableKernelNotifications()
{
    if (_fInitializeCalled)
    {
        NTSTATUS Status;

        Status = NtClearEvent( _hEvent );

        TrkVerify( NT_SUCCESS( Status ) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\stubs.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       stubs.cxx
//
//  Contents:   RPC stub routines that call CTrkWksSvc
//
//  Classes:
//
//  Functions:
//
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "trkwks.hxx"

#define THIS_FILE_NUMBER    STUBS_CXX_FILE_NO


//+----------------------------------------------------------------------------
//
//  StubLnkCallSvrMessage
//
//  Calls CTrkWksSvc::CallSvrMessage.
//
//+----------------------------------------------------------------------------

HRESULT StubLnkCallSvrMessage(
    /* [in] */ handle_t IDL_handle,
    /* [switch_is][out][in] */ TRKSVR_MESSAGE_UNION __RPC_FAR *pMsg)
{
    HRESULT hr;
    SThreadFromPoolState state;

#if DBG
    InterlockedIncrement( &g_cTrkWksRpcThreads );
    TrkAssert( NULL != g_ptrkwks && CTRKWKSSVC_SIG == g_ptrkwks->GetSignature() );
#endif

    
    __try
    {
        state = InitializeThreadFromPool();
        CVerifyAuthentication::VerifyAuthentication( IDL_handle );
        hr = g_ptrkwks->CallSvrMessage( IDL_handle, pMsg );
    }
    __except (BreakOnDebuggableException())
    {
        hr = GetExceptionCode();
    }
    UnInitializeThreadFromPool( state );

#if DBG
    InterlockedDecrement( &g_cTrkWksRpcThreads );
    TrkAssert( 0 <= g_cTrkWksRpcThreads );
#endif

    return(hr);
}


//+----------------------------------------------------------------------------
//
//  Stubold_LnkCallSvrMessage
//
//  Backward compatibility, calls StubLnkCallSvrMessage with new msg
//  structure.
//
//+----------------------------------------------------------------------------

HRESULT Stubold_LnkCallSvrMessage(
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ TRKSVR_MESSAGE_UNION_OLD __RPC_FAR *pMsg)
{
    TRKSVR_MESSAGE_UNION Msg2;

#if DBG
    InterlockedIncrement( &g_cTrkWksRpcThreads );
    TrkAssert( NULL != g_ptrkwks && CTRKWKSSVC_SIG == g_ptrkwks->GetSignature() );
#endif

    Msg2.MessageType = pMsg->MessageType;
    Msg2.Priority = PRI_5;

    switch (Msg2.MessageType)
    {
        case (SEARCH):
            Msg2.Search = pMsg->Search;
            break;
        case (MOVE_NOTIFICATION):
            Msg2.MoveNotification = pMsg->MoveNotification;
            break;
        case (REFRESH):
            Msg2.Refresh = pMsg->Refresh;
            break;
        case (SYNC_VOLUMES):
            Msg2.SyncVolumes = pMsg->SyncVolumes;
            break;
        case (DELETE_NOTIFY):
            Msg2.Delete = pMsg->Delete;
            break;
    }

    Msg2.ptszMachineID = pMsg->ptszMachineID;

#if DBG
    InterlockedDecrement( &g_cTrkWksRpcThreads );
    TrkAssert( 0 <= g_cTrkWksRpcThreads );
#endif

    return StubLnkCallSvrMessage( IDL_handle, &Msg2 );
}


//+----------------------------------------------------------------------------
//
//  StubLnkMendLink
//
//  Calls CTrkWksSvc::MendLink.  This stub is caled from within the local machine.
//
//+----------------------------------------------------------------------------

/*
// Version 1.2 (added pdroidBirthCurrent)
HRESULT
StubLnkMendLink(RPC_BINDING_HANDLE          IDL_handle,
                FILETIME                    ftLimit,
                DWORD                       RestrictionsIn,
                const CDomainRelativeObjId *pdroidBirthLast,
                const CDomainRelativeObjId *pdroidLast,
                const CMachineId           *pmcidLast,
                CDomainRelativeObjId       *pdroidBirthCurrent,
                CDomainRelativeObjId       *pdroidCurrent,
                CMachineId                 *pmcidCurrent,
                ULONG                      *pcbPath,
                WCHAR                      *pwsz )
{
    HRESULT hr = g_ptrkwks->MendLink( IDL_handle, static_cast<CFILETIME>(ftLimit), RestrictionsIn,
                                      *pdroidBirthLast,   *pdroidLast,   *pmcidLast,
                                      pdroidBirthCurrent, pdroidCurrent, pmcidCurrent,
                                      pcbPath, pwsz );

    TrkAssert( TRK_E_POTENTIAL_FILE_FOUND != hr
               ||
               *pdroidBirthLast != *pdroidBirthCurrent );

    TrkAssert( FAILED(hr) || *pdroidBirthLast == *pdroidBirthCurrent
               || *pdroidBirthLast == CDomainRelativeObjId() );

    return( MapTR2HR(hr) );

}
*/

// Version 1.1 (added pmcidLast and pmcidCurrent)
void
StubLnkMendLink(PRPC_ASYNC_STATE            pAsync_handle,
                RPC_BINDING_HANDLE          IDL_handle,
                FILETIME                    ftLimit,
                DWORD                       RestrictionsIn,
                const CDomainRelativeObjId *pdroidBirth,
                const CDomainRelativeObjId *pdroidLast,
                const CMachineId *          pmcidLast,
                CDomainRelativeObjId *      pdroidCurrent,
                CMachineId *                pmcidCurrent,
                ULONG *                     pcbPath,
                WCHAR *                     wsz)
{
#if DBG
    InterlockedIncrement( &g_cTrkWksRpcThreads );
    TrkAssert( NULL != g_ptrkwks && CTRKWKSSVC_SIG == g_ptrkwks->GetSignature() );
#endif

    CDomainRelativeObjId droidBirthCurrent;
    HRESULT hr = S_OK;
    SThreadFromPoolState state;

    __try
    {
        state = InitializeThreadFromPool();
        CVerifyAuthentication::VerifyAuthentication( IDL_handle );

        // Convert the time limit into a tick-count limit, so that we're reslient
        // to clock updates.  Perf: Since this is always a intra-machine call,
        // the interface really ought to be changed so that it just passes
        // in a tick count, but it's not worth changing the interface just
        // for that.

        CFILETIME cftNow, cftLimit(ftLimit);
        DWORD dwTickCountDeadline = GetTickCount();

        if( cftLimit > cftNow )
            dwTickCountDeadline += (DWORD) ( (cftLimit - cftNow)/10000 );


        hr = g_ptrkwks->MendLink( IDL_handle, dwTickCountDeadline, RestrictionsIn,
                                  *pdroidBirth,   *pdroidLast,   *pmcidLast,
                                  &droidBirthCurrent, pdroidCurrent, pmcidCurrent,
                                  pcbPath, wsz );

        TrkAssert( FAILED(hr)
                   ||
                   *pdroidBirth == droidBirthCurrent );


#if DBG
        InterlockedDecrement( &g_cTrkWksRpcThreads );
        TrkAssert( 0 <= g_cTrkWksRpcThreads );
#endif
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        hr = GetExceptionCode();
    }
    UnInitializeThreadFromPool( state );

    hr = MapTR2HR(hr);

    // If this request came in on Async RPC, complete the call and
    // pass back the return code.

    if( NULL != pAsync_handle )
    {
        HRESULT hrT = RpcAsyncCompleteCall( pAsync_handle, &hr );
#if DBG
        if( ERROR_SUCCESS != hrT )
            TrkLog(( TRKDBG_ERROR, TEXT("Failed RpcAsyncCompleteCall (%lu)"), hrT ));
#endif
    }

}

// Version 1.0
HRESULT Stubold_LnkMendLink(
    /* [in] */ handle_t IDL_handle,
    /* [in] */ FILETIME ftLimit,
    /* [in] */ ULONG Restrictions,
    /* [in] */ const CDomainRelativeObjId __RPC_FAR *pdroidBirth,
    /* [in] */ const CDomainRelativeObjId __RPC_FAR *pdroidLast,
    /* [out] */ CDomainRelativeObjId __RPC_FAR *pdroidCurrent,
    /* [string][out] */ WCHAR __RPC_FAR wsz[ MAX_PATH + 1 ] )
{
    TrkLog(( TRKDBG_ERROR, TEXT("Stubold_LnkMendLink was called") ));
    return( E_FAIL );
}


//+----------------------------------------------------------------------------
//
//  StubLnkSearchMachine
//
//  Calls CTrkWksSvc::SearchMachine.  This is called from the trkwks service
//  on another machine, or directly (i.e. not by RPC) from within this
//  service.
//
//+----------------------------------------------------------------------------

// Version 1.2 (added pdroidBirthLast, pdroidBirthNext)
// S_OK || TRK_E_REFERRAL || TRK_E_NOT_FOUND || TRK_E_POTENTIAL_FILE_FOUND
HRESULT StubLnkSearchMachine(RPC_BINDING_HANDLE          IDL_handle,
                             ULONG                       RestrictionsIn,
                             const CDomainRelativeObjId *pdroidBirthLast,
                             const CDomainRelativeObjId *pdroidLast,
                             CDomainRelativeObjId       *pdroidBirthNext,
                             CDomainRelativeObjId       *pdroidNext,
                             CMachineId                 *pmcidNext,
                             TCHAR                      *ptsz )
{
    HRESULT hr;
    SThreadFromPoolState state;

#if DBG
    InterlockedIncrement( &g_cTrkWksRpcThreads );
    TrkAssert( NULL != g_ptrkwks && CTRKWKSSVC_SIG == g_ptrkwks->GetSignature() );
#endif

    
    __try
    {
        state = InitializeThreadFromPool();
        CVerifyAuthentication::VerifyAuthentication( IDL_handle );

        hr = g_ptrkwks->SearchMachine(
                IDL_handle,
                RestrictionsIn,
                *pdroidBirthLast, *pdroidLast,
                pdroidBirthNext, pdroidNext, pmcidNext, ptsz
                );

    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }
    UnInitializeThreadFromPool( state );

#if DBG
    InterlockedDecrement( &g_cTrkWksRpcThreads );
    TrkAssert( 0 <= g_cTrkWksRpcThreads );
#endif

    return( hr );
}


// Version 1.1 (added pmcidNext)
HRESULT Stubold2_LnkSearchMachine(  RPC_BINDING_HANDLE           IDL_handle,
                                    ULONG                        RestrictionsIn,
                                    const CDomainRelativeObjId  *pdroidLast,
                                    CDomainRelativeObjId        *pdroidNext,
                                    CMachineId                  *pmcidNext,
                                    TCHAR                       *tsz )
{
    CDomainRelativeObjId droidBirthLast, droidBirthNext;

    return( StubLnkSearchMachine( IDL_handle, RestrictionsIn,
                                  &droidBirthLast, pdroidLast,
                                  &droidBirthNext, pdroidNext, pmcidNext,
                                  tsz ));
}

// Version 1.0
HRESULT Stubold_LnkSearchMachine(
    /* [in] */ handle_t IDL_handle,
    /* [in] */ ULONG Restrictions,
    /* [in] */ const CDomainRelativeObjId __RPC_FAR *pdroidLast,
    /* [out] */ CDomainRelativeObjId __RPC_FAR *pdroidReferral,
    /* [string][out] */ TCHAR __RPC_FAR tsz[ MAX_PATH + 1 ])
{
    CMachineId mcidNext;

    return Stubold2_LnkSearchMachine( IDL_handle, Restrictions, pdroidLast, pdroidReferral, &mcidNext, tsz );
}






HRESULT
StubLnkGetBackup(
    /* [in] */ handle_t IDL_handle,
    /* [out][in] */ DWORD __RPC_FAR *pcVolumes,
    /* [size_is][size_is][out] */ VolumeMapEntry __RPC_FAR *__RPC_FAR *ppVolumeChanges,
    /* [out] */ FILETIME __RPC_FAR *pft)
{

    return(E_NOTIMPL);
}


HRESULT
StubGetFileTrackingInformation( RPC_BINDING_HANDLE IDL_handle,
                                /*[in]*/ CDomainRelativeObjId droidCurrent,
                                /*[in]*/ TrkInfoScope scope,
                                /*[out]*/ TRK_FILE_TRACKING_INFORMATION_PIPE pipeFileInfo )
{
    HRESULT hr = E_FAIL;
    SThreadFromPoolState state;

#if DBG
    InterlockedIncrement( &g_cTrkWksRpcThreads );
    TrkAssert( NULL != g_ptrkwks && CTRKWKSSVC_SIG == g_ptrkwks->GetSignature() );
#endif

    
    __try
    {
        TCHAR tszUncPath[ MAX_PATH + 1 ];
        ULONG cbPath = sizeof(tszUncPath);

        state = InitializeThreadFromPool();
        CVerifyAuthentication::VerifyAuthentication( IDL_handle );
        hr = g_ptrkwks->GetFileTrackingInformation( droidCurrent, scope, pipeFileInfo );
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }
    UnInitializeThreadFromPool( state );

#if DBG
    InterlockedDecrement( &g_cTrkWksRpcThreads );
    TrkAssert( 0 <= g_cTrkWksRpcThreads );
#endif

    return( hr );

}   // StubGetFileTrackingInformation()


HRESULT
StubGetVolumeTrackingInformation( RPC_BINDING_HANDLE IDL_handle,
                                  /*[in]*/ CVolumeId volid,
                                  /*[in]*/ TrkInfoScope scope,
                                  /*[out]*/ TRK_VOLUME_TRACKING_INFORMATION_PIPE pipeVolInfo )
{
    HRESULT hr = E_FAIL;
    SThreadFromPoolState state;

#if DBG
    InterlockedIncrement( &g_cTrkWksRpcThreads );
    TrkAssert( NULL != g_ptrkwks && CTRKWKSSVC_SIG == g_ptrkwks->GetSignature() );
#endif

    
    __try
    {
        state = InitializeThreadFromPool();
        CVerifyAuthentication::VerifyAuthentication( IDL_handle );
        hr = g_ptrkwks->GetVolumeTrackingInformation( volid, scope, pipeVolInfo );
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }
    UnInitializeThreadFromPool( state );

#if DBG
    InterlockedDecrement( &g_cTrkWksRpcThreads );
    TrkAssert( 0 <= g_cTrkWksRpcThreads );
#endif

    return( hr );

}   // StubGetVolumes()

HRESULT StubLnkOnRestore(/*[in]*/ RPC_BINDING_HANDLE IDL_handle)
{
    HRESULT         hr;
    SThreadFromPoolState state;

#if DBG
    InterlockedIncrement( &g_cTrkWksRpcThreads );
    TrkAssert( NULL != g_ptrkwks && CTRKWKSSVC_SIG == g_ptrkwks->GetSignature() );
#endif

    
    __try
    {
        state = InitializeThreadFromPool();
        CVerifyAuthentication::VerifyAuthentication( IDL_handle );
        hr = g_ptrkwks->OnRestore();
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }
    UnInitializeThreadFromPool( state );

#if DBG
    InterlockedDecrement( &g_cTrkWksRpcThreads );
    TrkAssert( 0 <= g_cTrkWksRpcThreads );
#endif

    return hr;
}

HRESULT StubLnkRestartDcSynchronization(
    RPC_BINDING_HANDLE IDL_handle
    )
{
    return(E_NOTIMPL);
}

HRESULT StubLnkSetVolumeId(
    handle_t IDL_handle,
    ULONG iVolume,
    const CVolumeId VolId)
{
    HRESULT hr;
    SThreadFromPoolState state;

#if DBG
    InterlockedIncrement( &g_cTrkWksRpcThreads );
    TrkAssert( NULL != g_ptrkwks && CTRKWKSSVC_SIG == g_ptrkwks->GetSignature() );
#endif

    
    __try
    {
        state = InitializeThreadFromPool();
        CVerifyAuthentication::VerifyAuthentication( IDL_handle );
        hr = g_ptrkwks->SetVolumeId( iVolume, VolId );
    }
    __except (BreakOnDebuggableException())
    {
        hr = GetExceptionCode();
    }
    UnInitializeThreadFromPool( state );

#if DBG
    InterlockedDecrement( &g_cTrkWksRpcThreads );
    TrkAssert( 0 <= g_cTrkWksRpcThreads );
#endif

    return(hr);
}


HRESULT
StubTriggerVolumeClaims(          RPC_BINDING_HANDLE IDL_handle,
                         /*[in]*/ ULONG cVolumes,
                         /*[in]*/ const CVolumeId *rgvolid )
{
    HRESULT hr = E_FAIL;
    SThreadFromPoolState state;

#if DBG
    InterlockedIncrement( &g_cTrkWksRpcThreads );
    TrkAssert( NULL != g_ptrkwks && CTRKWKSSVC_SIG == g_ptrkwks->GetSignature() );
#endif

    
    __try
    {
        state = InitializeThreadFromPool();
        CVerifyAuthentication::VerifyAuthentication( IDL_handle );
        hr = g_ptrkwks->TriggerVolumeClaims( cVolumes, rgvolid );
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }
    UnInitializeThreadFromPool( state );


#if DBG
    InterlockedDecrement( &g_cTrkWksRpcThreads );
    TrkAssert( 0 <= g_cTrkWksRpcThreads );
#endif

    return( hr );

}   // StubTriggerVolumeClaims
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\oidindex.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  oidindex.cxx
//
//  Implementation of CObjIdIndexChangeNotifier, which moniters the
//  object ID index for changes.  When a change is received, the
//  CVolume is notified.
//
//+============================================================================

#include <pch.cxx>
#pragma hdrstop
#include "trkwks.hxx"

//+----------------------------------------------------------------------------
//
//  CObjIdIndexChangeNotifier::DoWork
//
//  Called by the work manager - on the primary thread - when we've received
//  a notification from the object ID index.
//
//+----------------------------------------------------------------------------

void
CObjIdIndexChangeNotifier::DoWork()
{
    LPBYTE pbScan = _Buffer;    
    FILE_NOTIFY_INFORMATION * pNotifyInfo;

    // Get the size and ntstatus of the notification.

    DWORD dwNumberOfBytesTransfered = static_cast<DWORD>(_Overlapped.InternalHigh);
    NTSTATUS status = static_cast<NTSTATUS>(_Overlapped.Internal);

    _cs.Enter();
    __try   // __except
    {
        // Is this a good notification?

        if( NT_SUCCESS(status) )
        {
            // Did we get data in this notification?
            if( dwNumberOfBytesTransfered >= sizeof(FILE_NOTIFY_INFORMATION) )
            {
                // Yes.  Loop through the entries, calling to special handlers
                // for delete notifications and tunnelling-failure notifications.

                do
                {
                    pNotifyInfo = (FILE_NOTIFY_INFORMATION*)pbScan;
                    FILE_OBJECTID_INFORMATION *poi = (FILE_OBJECTID_INFORMATION*) pNotifyInfo->FileName;
    
                    TrkLog((TRKDBG_OBJID_DELETIONS,
                            TEXT("NTFS ObjId Index: %s"),
                            (const TCHAR*)CDebugString( _pVolume->GetVolIndex(),
                            pNotifyInfo) ));

                    // Check for adds/deletes

                    if (pNotifyInfo->Action == FILE_ACTION_REMOVED_BY_DELETE
                        ||
                        pNotifyInfo->Action == FILE_ACTION_ADDED)
                    {
                        // Notify the general add/deletions handler

                        CDomainRelativeObjId droidBirth( *poi );
                        _pObjIdIndexChangedCallback->NotifyAddOrDelete( pNotifyInfo->Action, droidBirth );
                    }

                    // Check for tunnelling notifications
                    else
                    if (pNotifyInfo->Action == FILE_ACTION_ID_NOT_TUNNELLED)
                    {
                        // An attempt to tunnel an object ID failed because another file on the
                        // same volume was already using it.
                        _pVolume->FileActionIdNotTunnelled( (FILE_OBJECTID_INFORMATION*) pNotifyInfo->FileName );
                    }

                } while ( pNotifyInfo->NextEntryOffset != 0 &&
                          ( pbScan += pNotifyInfo->NextEntryOffset) );
            }   // if( dwNumberOfBytesTransfered >= sizeof(FILE_NOTIFY_INFORMATION) )

            // We didn't get any data.  Is this notification telling us that the IRP was
            // cancelled?

            else if( STATUS_NOTIFY_CLEANUP == status )
            {
                TrkLog(( TRKDBG_OBJID_DELETIONS, TEXT("OverlappedCompletionRoutine on %c: cleaning up"),
                         VolChar( _pVolume->GetIndex() ) ));
            }
        }   // if( NT_SUCCESS(status) )

        else if( STATUS_CANCELLED == status )
        {
            // The thread on which we made the ReadDirectoryChanges call terminated,
            // thus terminating our IRP.  We should now be running on an IO thread, since
            // we register with WT_EXECUTEINIOTHREAD, so we just fall through and
            // re-issue the IRP.

            TrkLog(( TRKDBG_OBJID_DELETIONS,
                     TEXT("OverlappedCompletionRoutine on %c: ignoring status_cancelled"),
                     VolChar( _pVolume->GetIndex() ) ));
        }
        else
        {
            // If we failed for any other reason, there's something wrong.  We don't
            // want to call ReadDirectoryChanges again, because it might give us the
            // same failure right away, and we'd thus be in an infinite loop.

            TrkLog(( TRKDBG_ERROR, TEXT("OverlappedCompletionRoutine on %c: aborting due to %08x"),
                      status ));
            CloseHandle( _hDir );
            _hDir = INVALID_HANDLE_VALUE;
        }

        // When StopListeningAndClose is called, CancelIo is called, which triggers
        // this DoWork routine.  But we don't run until we get the critical section,
        // after which time _hDir will be invalid.

        if( INVALID_HANDLE_VALUE != _hDir )
        {
            StartListening();
        }

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        // We should never get any kind of an error here.  If we do, the simplest
        // recourse is just to reinit the volume.

        _pVolume->OnHandlesMustClose();
    }

    _cs.Leave();

    return;
}

//+----------------------------------------------------------------------------
//
//  CObjIdIndexChangeNotifier::Initialize
//
//  Initialize the critical section and register with the work manager.
//
//+----------------------------------------------------------------------------

void
CObjIdIndexChangeNotifier::Initialize(
    TCHAR *ptszVolumeDeviceName,
    PObjIdIndexChangedCallback * pObjIdIndexChangedCallback,
    CVolume * pVolumeForTunnelNotification
    )
{
    TrkAssert( !_fInitialized );

    _cs.Initialize();
    _fInitialized = TRUE;

    _ptszVolumeDeviceName = ptszVolumeDeviceName;
    _pObjIdIndexChangedCallback = pObjIdIndexChangedCallback;
    _hDir = INVALID_HANDLE_VALUE;
    _pVolume = pVolumeForTunnelNotification;

    TrkAssert( NULL == _hCompletionEvent );
    _hCompletionEvent = CreateEvent( NULL, FALSE, FALSE, NULL );    // Auto-reset, not signaled
    if( NULL == _hCompletionEvent )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't create completion event for objid index change notify (%lu)"),
                 GetLastError() ));
        TrkRaiseLastError();
    }

    // Register the completion event with the thread pool.

    _hRegisterWaitForSingleObjectEx
        = TrkRegisterWaitForSingleObjectEx( _hCompletionEvent, ThreadPoolCallbackFunction,
                                            static_cast<PWorkItem*>(this), INFINITE,
                                            WT_EXECUTEINWAITTHREAD );
    if( NULL == _hRegisterWaitForSingleObjectEx )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RegisterWaitForSingleObjectEx in CObjIdIndexChangeNotifier (%lu) for %s"),
                 GetLastError(), ptszVolumeDeviceName ));
        TrkRaiseLastError();
    }
    else
        TrkLog(( TRKDBG_VOLUME, TEXT("Registered objid index change notification (%p)"),
                 _hRegisterWaitForSingleObjectEx ));
}




//+----------------------------------------------------------------------------
//
//  CObjIdIndexChangeNotifier::StartListening
//
//  Call ReadDirectoryChangesW on the handle to the object ID index.
//  This is an event-based async call, so it returns immediately, and
//  NTFS signals the event when there's a notification ready.
//
//+----------------------------------------------------------------------------

void
CObjIdIndexChangeNotifier::StartListening()
{
    // NTFS will write the notification into the _Overlapped structure.

    memset(&_Overlapped, 0, sizeof(_Overlapped));
    _Overlapped.hEvent = _hCompletionEvent;
    _Overlapped.Internal = STATUS_INTERNAL_ERROR;

    if (!ReadDirectoryChangesW( _hDir,
        _Buffer,                      // pointer to the buffer to receive the read results
        sizeof(_Buffer),              // length of lpBuffer
        FALSE,                        // flag for monitoring directory or directory tree
        FILE_NOTIFY_CHANGE_FILE_NAME, // filter conditions to watch for
        &_dwDummyBytesReturned,       // number of bytes returned
        &_Overlapped,                 // pointer to structure needed for overlapped I/O
        NULL ))                       // pointer to completion routine
    {
        CloseHandle(_hDir);
        _hDir = INVALID_HANDLE_VALUE;

        TrkLog(( TRKDBG_OBJID_DELETIONS, TEXT("AsyncListen failed to ReadDirectoryChanges %d"),
                 GetLastError() ));
        TrkRaiseLastError();
    }

    // Ordinarily, the previous call will leave an IO pending.  If, however,
    // it actually returns right away with data, set the event as if the data came
    // back async.

    if( GetOverlappedResult( _hDir, &_Overlapped, &_dwDummyBytesReturned, FALSE /*Don't Wait*/ ))
    {
        // There was data immediately available.  Handle it in the normal way.
        TrkVerify( SetEvent( _Overlapped.hEvent ));
    }
    else if( ERROR_IO_INCOMPLETE != GetLastError() )    // STATUS_PENDING
    {
        // This should never occur
        TrkLog(( TRKDBG_ERROR, TEXT("GetOverlappedResult failed in CObjIdIndexChangeNotifier::AsyncListen (%lu)"),
                 GetLastError() ));
        TrkRaiseLastError();
    }

}


//+----------------------------------------------------------------------------
//
//  CObjIdIndexChangeNotifier::AsyncListen
//
//  This method begins listening for changes to the NTFS object ID index
//  directory.  It does not block; when notifications are available an
//  event is signaled and handled in DoWork.
//
//+----------------------------------------------------------------------------


BOOL
CObjIdIndexChangeNotifier::AsyncListen( )
{
    TCHAR tszDirPath[MAX_PATH];
    BOOL fStartedListening = FALSE;

    _cs.Enter();
    __try   // __finally
    {
        if( INVALID_HANDLE_VALUE != _hDir )
        {
            TrkLog(( TRKDBG_OBJID_DELETIONS, TEXT("CObjIdIndexChangeNotifier already listening to %s:"),
                     _ptszVolumeDeviceName ));
            __leave;
        }

        _tcscpy( tszDirPath, _ptszVolumeDeviceName );
        _tcscat( tszDirPath, TEXT("\\$Extend\\$ObjId:$O:$INDEX_ALLOCATION") );

        //
        // Should use TrkCreateFile and NtNotifyChangeDirectoryFile
        // but NtNotifyChangeDirectoryFile means writing an APC routine
        // so I'm punting for now.
        // None of these Win32 error codess need to be raised to the user.
        //

        _hDir = CreateFile (
              tszDirPath,
              FILE_LIST_DIRECTORY,
              FILE_SHARE_WRITE|FILE_SHARE_READ|FILE_SHARE_DELETE,
              NULL,                        
              OPEN_EXISTING,               
              FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED,
              NULL );

        if (_hDir == INVALID_HANDLE_VALUE)
        {
            TrkLog((TRKDBG_OBJID_DELETIONS,
                TEXT("AsyncListen failed to open objid index %s %d"),
                tszDirPath,
                GetLastError()));

            TrkRaiseLastError();
        }

        StartListening();    // Call ReadDirectoryChangesW
        fStartedListening = TRUE;

        TrkLog((TRKDBG_OBJID_DELETIONS,
            TEXT("AsyncListen succeeded ReadDirectoryChanges on %c:"), VolChar(_pVolume->GetIndex()) ));


    }
    __finally
    {
        _cs.Leave();
    }

    return fStartedListening;

}



//+----------------------------------------------------------------------------
//
//  CObjIdIndexChangeNotifier::StopListeningAndClose
//
//  Cancel the previous call to ReadDirectoryChangesW, and close the
//  handle to the object ID index directory.
//
//+----------------------------------------------------------------------------

void
CObjIdIndexChangeNotifier::StopListeningAndClose()
{
    if( !_fInitialized )
        return;

    _cs.Enter();

    TrkLog((TRKDBG_OBJID_DELETIONS, TEXT("StopListeningAndClose() on %c:"),
            VolChar(_pVolume->GetIndex())));

    // Cancel the IO, which will trigger once last completion with
    // STATUS_NOTIFY_CLEANUP (why isn't it STATUS_CANCELLED?)
    // Note that this one last completion will see that _hDir
    // has been closed, and won't attempt to re-use it.

    InterlockedCloseHandle( &_hDir, INVALID_HANDLE_VALUE, TRUE );

    _cs.Leave();
}


//+----------------------------------------------------------------------------
//
//  CObjIdIndexChangeNotifier::UnInitialize
//
//  Cancel the notification IRP and close the handle to the
//  object ID index directory.
//
//+----------------------------------------------------------------------------

void
CObjIdIndexChangeNotifier::UnInitialize()
{
    if( _fInitialized )
    {
        StopListeningAndClose();

        // Unregister from the thread pool.  This must be done before closing
        // _hCompletionEvent, because that's the event on which the thread
        // pool is waiting.

        if( NULL != _hRegisterWaitForSingleObjectEx )
        {
            if( !TrkUnregisterWait( _hRegisterWaitForSingleObjectEx ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Failed UnregisterWait for CObjIdIndexChangeNotifier (%lu)"),
                         GetLastError() ));
            }
            else
                TrkLog(( TRKDBG_VOLUME, TEXT("Unregistered wait for CObjIdIndexChangeNotifier (%p)"),
                         _hRegisterWaitForSingleObjectEx ));

            _hRegisterWaitForSingleObjectEx = NULL;
        }

        if( NULL != _hCompletionEvent )
        {
            CloseHandle( _hCompletionEvent );
            _hCompletionEvent = NULL;
        }

        // Delete the critical section.  This must be done after unregistering from
        // the thread pool, because until that time we have to worry about a thread
        // coming in to DoWork.

        _cs.UnInitialize();
        _fInitialized = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\stub_trksvr_c.c ===
#undef RPC_NO_WINDOWS_H
#include <trksvr_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\tlog.cxx ===
//
// The following tests need to be added:
//
//  -   Run the bad-shutdown test on an empty log (forcing a special path
//      in CalcLogInfo).
//



#include "pch.cxx"
#pragma hdrstop

#define TRKDATA_ALLOCATE
#include "trkwks.hxx"



BOOL g_fNotified = FALSE;
extern ULONG g_Debug;
BOOL g_fTLogDebug = FALSE;
CTrkWksConfiguration g_cTrkWksConfiguration;
CWorkManager g_WorkManager;
CTestLog g_cTestLog( &g_cTrkWksConfiguration, &g_WorkManager );

inline void TestRaise( HRESULT hr, TCHAR *ptszMessage, va_list Arguments )
{
    CHAR szHR[8];

    sprintf( szHR, "%#08X", hr );

    if( NULL != ptszMessage )
        TrkLogErrorRoutineInternal( TRKDBG_ERROR, szHR, ptszMessage, Arguments );

    RaiseException( hr, 0, 0, NULL );
}

inline void TestRaiseException( HRESULT hr, TCHAR *ptszMessage = NULL, ... )
{
    va_list Arguments;
    va_start( Arguments, ptszMessage );

    TestRaise( hr, ptszMessage, Arguments );
}

class CTestLogCallback : public PLogCallback
{
    void OnEntriesAvailable();
};

void
CTestLogCallback::OnEntriesAvailable()
{
    g_fNotified = TRUE;
}



CTestLog::CTestLog( CTrkWksConfiguration *pTrkWksConfiguration, CWorkManager *pWorkManager )
{

    _pTrkWksConfiguration = pTrkWksConfiguration;
    _pWorkManager = pWorkManager;
    *_tszLogFile = TEXT('\0');

}   // CTestLog::CTestLog


void
CTestLog::ReInitialize()
{
    _cLogFile.UnInitialize();
    DeleteFile( _tszLogFile );
    _cLogFile.Initialize( _tszLogFile, _pTrkWksConfiguration, &_cSimpleTimer );
    _cLog.Initialize( NULL, _pTrkWksConfiguration, &_cLogFile );
}

void
CTestLog::GenerateLogName()
{
    DWORD dw;
    TCHAR tszRootPath[ MAX_PATH + 1 ];
    DWORD cSectorsPerCluster, cNumberOfFreeClusters, cTotalNumberOfClusters;

    if( TEXT('\0') != *_tszLogFile )
        return;

    // Generate a log file name

    if( !GetCurrentDirectory( sizeof(_tszLogFile), _tszLogFile ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get the current directory") ));
        TrkRaiseLastError( );
    }

    if( TEXT('\\') != _tszLogFile[ _tcslen(_tszLogFile) ] )
        _tcscat( _tszLogFile, TEXT("\\") );
    _tcscat( _tszLogFile, TEXT("TLog.log") );

    // Calculate the sector size

    TrkAssert( TEXT(':') == _tszLogFile[1] );

    _tcsncpy( tszRootPath, _tszLogFile, sizeof("a:\\") - 1 );
    tszRootPath[ sizeof("a:\\") - 1 ] = TEXT('\0');

    if( !GetDiskFreeSpace( tszRootPath,
                           &cSectorsPerCluster, &_cbSector,
                           &cNumberOfFreeClusters, &cTotalNumberOfClusters ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get bytes-per-sector value on %s"), tszRootPath ));
        TrkRaiseLastError( );
    }

}   // CTestLog::GenerateLogName()


const TCHAR*
CTestLog::LogFileName()
{
    return( _tszLogFile );
}

ULONG
CTestLog::DataSectorOffset() const
{
    return( _cLogFile._header.NumSectors() * CBSector() );
}

void
CTestLog::CreateLog( PLogCallback *pLogCallback, BOOL fValidate )
{
    TCHAR tszLogFile[ MAX_PATH + 1 ];

    GenerateLogName();
    DeleteFile( _tszLogFile );

    _pWorkManager->Initialize();
    _cSimpleTimer.Initialize( this, _pWorkManager, 0, 0, NULL );
    _cLogFile.Initialize( _tszLogFile, _pTrkWksConfiguration, &_cSimpleTimer );
    _cLog.Initialize( pLogCallback, _pTrkWksConfiguration, &_cLogFile );
    StartTestWorkerThread(_pWorkManager);

    if( fValidate )
        ValidateLog();

}   // CTestLog::CreateLog()



void
CTestLog::Timer( DWORD dwTimerId )
{
    _cLog.Flush( FLUSH_TO_CACHE );
    _cLogFile.SetShutdown( TRUE );
    _cLogFile.Flush( FLUSH_THROUGH_CACHE );
    _cLogFile.OnLogCloseTimer();
}


void
CTestLog::OpenLog( PLogCallback *pLogCallback, BOOL fValidate )
{
    GenerateLogName();

    _pWorkManager->Initialize();
    _cSimpleTimer.Initialize( this, _pWorkManager, 0, 0, NULL );
    _cLogFile.Initialize( _tszLogFile, _pTrkWksConfiguration, &_cSimpleTimer );
    _cLog.Initialize( pLogCallback, _pTrkWksConfiguration, &_cLogFile );
    StartTestWorkerThread(_pWorkManager);

    if( fValidate )
        ValidateLog();

}   // CTestLog::CreateLog()



void
CTestLog::CloseLog()
{
    _pWorkManager->StopWorkerThread();
    WaitTestThreadExit();

    _cLog.Flush( FLUSH_TO_CACHE );
    _cLogFile.SetShutdown( TRUE );
    _cLogFile.Flush( FLUSH_THROUGH_CACHE );

    _cLogFile.UnInitialize();
    _cSimpleTimer.UnInitialize();
    _pWorkManager->UnInitialize();
}



void
CTestLog::Append( ULONG cMoves, const TRKSVR_MOVE_NOTIFICATION rgNotifications[] )
{
    LogMoveNotification lmn;
    SequenceNumber seqOriginal, seqFinal;

    if( _cLog.IsEmpty() )
        seqOriginal = -1;
    else
    {
        _cLogFile.ReadMoveNotification( _cLog._loginfo.ilogLast, &lmn );
        seqOriginal = lmn.seq;
    }

    g_fNotified = FALSE;

    for( ULONG i = 0; i < cMoves; i++ )
    {
        _cLog.Append( rgNotifications[i].droidCurrent,
                      rgNotifications[i].droidNew,
                      rgNotifications[i].droidBirth );
    }

    _cLogFile.ReadMoveNotification( _cLog._loginfo.ilogLast, &lmn );
    seqFinal = lmn.seq;

    if( seqFinal != (SequenceNumber)(seqOriginal + cMoves) )
        TestRaiseException( E_FAIL, TEXT("Incorrect sequence numbers after Append (%d + %d = %d?)\n"),
                           seqOriginal, cMoves, seqFinal );

    if( !g_fNotified )
        TestRaiseException( E_FAIL, TEXT("Didn't receive a notification during an append\n") );

}   // CTestLog::Append()



ULONG
CTestLog::Read( ULONG cRead, TRKSVR_MOVE_NOTIFICATION rgNotifications[], SequenceNumber *pseqFirst  )
{
    _cLog.Read( rgNotifications, pseqFirst, &cRead );
    return( cRead );

}   // CTestLog::ReadLog()

void
CTestLog::ReadExtendedHeader( ULONG iOffset, void *pv, ULONG cb )
{
    _cLogFile.ReadExtendedHeader( iOffset, pv, cb );
}


void
CTestLog::WriteExtendedHeader( ULONG iOffset, const void *pv, ULONG cb )
{
    _cLogFile.WriteExtendedHeader( iOffset, pv, cb );
}

void
CTestLog::ReadAndValidate( ULONG cToRead, ULONG cExpected,
                           const TRKSVR_MOVE_NOTIFICATION rgNotificationsExpected[],
                           TRKSVR_MOVE_NOTIFICATION rgNotificationsRead[],
                           SequenceNumber seqExpected )
{
    ULONG cLogEntriesRead = 0;
    SequenceNumber seq;

    memset( rgNotificationsRead, 0, sizeof(*rgNotificationsRead) * cExpected );

    cLogEntriesRead = Read( cToRead, rgNotificationsRead, &seq );

    if( cLogEntriesRead != cExpected )
    {
        TestRaiseException( E_FAIL, TEXT("Bad read from log; expected %d entries, got %d\n"),
                           cExpected, cLogEntriesRead );
    }

    if( seq != seqExpected
        &&
        0 != cExpected 
       )
    {
        TestRaiseException( E_FAIL, TEXT("Invalid sequence number from log (got %d, expected %d)\n"),
                           seq, seqExpected );
    }

    if( 0 != cExpected )
    {

        for( ULONG i = 0; i < cExpected; i++ )
            if( memcmp( &rgNotificationsExpected[i], &rgNotificationsRead[i], sizeof(rgNotificationsRead[i]) ))
            {
                TestRaiseException( E_FAIL, TEXT("Log entries read don't match that which was expected\n") );
            }
    }

}   // CTestLog::ReadAndValidate()


SequenceNumber
CTestLog::GetNextSeqNumber( )
{
    return( _cLog.GetNextSeqNumber() );

}   // CTestLog::GetLatestSeqNumber()


BOOL
CTestLog::Search( const CDomainRelativeObjId &droid, TRKSVR_MOVE_NOTIFICATION *pNotification )
{
    pNotification->droidCurrent = droid;

    return(  _cLog.Search( pNotification->droidCurrent,
                           &pNotification->droidNew,
                           &pNotification->droidBirth ) );


}   // CTestLog::Search()


void
CTestLog::Seek( SequenceNumber seq )
{

    SequenceNumber seqOriginal;
    LogIndex ilogOriginal;
    LogMoveNotification lmn;

    ilogOriginal = _cLog._loginfo.ilogRead;
    if( ilogOriginal != _cLog._loginfo.ilogWrite )
    {
        _cLogFile.ReadMoveNotification( _cLog._loginfo.ilogRead, &lmn );
        seqOriginal = lmn.seq;
    }

    g_fNotified = FALSE;
    _cLog.Seek( seq );

    if( seq != _cLog._loginfo.seqNext )
    {
        _cLogFile.ReadMoveNotification( _cLog._loginfo.ilogRead, &lmn );

        if( ilogOriginal == _cLog._loginfo.ilogWrite
            ||
            seqOriginal > lmn.seq
          )
        {

            if( !g_fNotified && !_cLog.IsEmpty() )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Didn't receive a notification after a backwards seek") ));
                TrkRaiseException( E_FAIL );
            }
        }
    }
}   // CTestLog::Seek( SequenceNumber ... )


void
CTestLog::Seek( int origin, int iSeek )
{
    SequenceNumber seqOriginal;
    LogMoveNotification lmn;

    _cLogFile.ReadMoveNotification( _cLog._loginfo.ilogRead, &lmn );

    seqOriginal = _cLog._loginfo.ilogRead == _cLog._loginfo.ilogWrite
                  ? _cLog._loginfo.seqNext
                  : lmn.seq;

    g_fNotified = FALSE;
    _cLog.Seek( origin, iSeek );

    _cLogFile.ReadMoveNotification( _cLog._loginfo.ilogRead, &lmn );

    if( !_cLog.IsRead()
        &&
        seqOriginal > lmn.seq
      )
    {
        if( !g_fNotified && !_cLog.IsEmpty() )
            TestRaiseException( E_FAIL, TEXT("Didn't receive a notification after a backwards seek") );
    }

}   // CTestLog::Seek( origin ... )






void
CTestLog::ValidateLog()
{
    ULONG cEntries = _cLogFile.NumEntriesInFile();
    LogIndex ilogEntry, i, j;
    ULONG *rgiNext = NULL;
    ULONG *rgiPrev = NULL;

    __try
    {
        rgiNext = (ULONG*) new ULONG[ cEntries ];
        rgiPrev = (ULONG*) new ULONG[ cEntries ];

        for( ilogEntry = 0; ilogEntry < cEntries; ilogEntry++ )
        {
            rgiNext[ ilogEntry ] = _cLogFile._sector.GetLogEntry( ilogEntry )->ilogNext;
            rgiPrev[ ilogEntry ] = _cLogFile._sector.GetLogEntry( ilogEntry )->ilogPrevious;
        }


        for( i = 0; i < cEntries; i++ )
        {
            // Validate that the entry pointed to by i->next, points
            // back to i with its prev pointer.

            if( rgiPrev[ rgiNext[i] ] != i )
                TestRaiseException( E_FAIL, TEXT("Two entries don't point to each other:  %d, %d, %d\n"),
                                   i, rgiNext[i], rgiPrev[ rgiNext[i] ] );

            // Verify that noone else's next/prev pointers point to
            // i's next/prev pointers.

            for( j = i+1; j < cEntries; j++ )
            {
                if( rgiNext[i] == rgiNext[j] )
                    TestRaiseException( E_FAIL, TEXT("Two entries in the log have the same next pointer:  %d and %d (point to %d)\n"),
                                       i, j, rgiNext[i] );

                if( rgiPrev[i] == rgiPrev[j] )
                    TestRaiseException( E_FAIL, TEXT("Two entries in the log have the same prev pointer:  %d and %d (point to %d)\n"),
                                       i, j, rgiPrev[i] );

            }
        }


    }
    __finally
    {
        delete[] rgiNext;
        delete[] rgiPrev;
    }


}   // CTestLog::ValidateLog()


ULONG
CTestLog::GetCbLog()
{
    return( _cLogFile._cbLogFile );
}

void
CTestLog::DelayUntilClose()
{
    _tprintf( TEXT("    Sleeping so that the log auto-closes\n") );
    Sleep( 1500 * _pTrkWksConfiguration->GetLogFileOpenTime() );

    if( _cLogFile.IsOpen() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("After delaying, log file did not close") ));
        TrkRaiseException( E_FAIL );
    }
}


void
CTestLog::MakeEntryOld()
{
    _cLogFile._sector.GetLogEntry( _cLog._loginfo.ilogStart )->move.DateWritten
        -= _pTrkWksConfiguration->_dwLogOverwriteAge + 1;
    _cLogFile.Flush( FLUSH_UNCONDITIONALLY );

}   // CTestLog::MakeStartOld()


ULONG
CTestLog::GetNumEntries()
{
    return( _cLogFile.NumEntriesInFile() );

}   // CTestLog::GetNumEntries()


LogIndex
CTestLog::GetStartIndex()
{
    return( _cLog._loginfo.ilogStart );
}

LogIndex
CTestLog::GetEndIndex()
{
    return( _cLog._loginfo.ilogEnd );
}

LogIndex
CTestLog::GetReadIndex()
{
    return( _cLog._loginfo.ilogRead );
}

void
CTestLog::SetReadIndex( LogIndex ilogRead )
{
    _cLog._loginfo.ilogRead = ilogRead;
    _cLog.RefreshHeader();
    _cLogFile.Flush();
}

BOOL
CTestLog::IsEmpty()
{
    BOOL fReturn;
    fReturn = _cLog.IsEmpty();
    return( fReturn );
}
    

ULONG
CTestLog::NumEntriesInFile( )
{
    ULONG cSectors = _cLogFile._cbLogFile / _cbSector - NUM_HEADER_SECTORS;
    ULONG cEntriesPerSector = (_cbSector-sizeof(LogEntryHeader)) / sizeof(LogEntry);

    return( cSectors * cEntriesPerSector );
}

ULONG
CTestLog::NumEntriesPerSector()
{
    return( ( _cbSector-sizeof(LogEntryHeader) ) / sizeof(LogEntry) );
}

ULONG
CTestLog::NumEntriesPerKB()
{
    return( (1024 / _cbSector) * NumEntriesPerSector() );
}

ULONG
CTestLog::CBSector() const
{
    return( _cbSector );
}



void ReadTest( ULONG cEntries,
               TRKSVR_MOVE_NOTIFICATION rgNotificationsExpected[],
               TRKSVR_MOVE_NOTIFICATION rgNotificationsRead[],
               SequenceNumber seqExpected )
{   
    g_cTestLog.ReadAndValidate( cEntries + 1, cEntries,
                                rgNotificationsExpected, rgNotificationsRead,
                                seqExpected );

    g_cTestLog.ReadAndValidate( cEntries, cEntries,
                                rgNotificationsExpected, rgNotificationsRead,
                                seqExpected );

    if( cEntries > 1 )
    {
        g_cTestLog.ReadAndValidate( cEntries - 1, cEntries - 1,
                                    rgNotificationsExpected, rgNotificationsRead,
                                    seqExpected );


        g_cTestLog.ReadAndValidate( 1, 1,
                                    rgNotificationsExpected, rgNotificationsRead,
                                    seqExpected );
    }
}



void
ExerciseLog( ULONG cEntries, SequenceNumber seqFirst, 
             TRKSVR_MOVE_NOTIFICATION rgNotificationsExpected[],
             TRKSVR_MOVE_NOTIFICATION rgNotificationsRead[] )
{
    SequenceNumber seqExpected = seqFirst;
    SequenceNumber seqRead;
    ULONG cRead;

    ULONG iReadOriginal = g_cTestLog.GetReadIndex();

    ReadTest( cEntries, rgNotificationsExpected, rgNotificationsRead, seqExpected );

    if( 0 != cEntries )
    {
        // Skip forward by one entry

        g_cTestLog.Seek( SEEK_CUR, 1 );
        seqExpected++;

        ReadTest( cEntries-1, &rgNotificationsExpected[1], &rgNotificationsRead[1], seqExpected );

        if( cEntries > 1 )
        {
            // Skip forward by one entry, but using an absolute seek.

            g_cTestLog.Seek( SEEK_SET, 2 );
            seqExpected++;

            ReadTest( cEntries-2, &rgNotificationsExpected[2], &rgNotificationsRead[2], seqExpected );

            // Do a relative seek back in the log.

            g_cTestLog.Seek( SEEK_CUR, -1 );
            seqExpected--;

            ReadTest( cEntries-1, &rgNotificationsExpected[1], &rgNotificationsRead[1], seqExpected );

        }

        // Do a relative seek back to the beginning of the log

        g_cTestLog.Seek( SEEK_CUR, -1000 );
        seqExpected--;

        ReadTest( cEntries, &rgNotificationsExpected[0], &rgNotificationsRead[0], seqExpected );

        // Skip forward by the remaining entries

        g_cTestLog.Seek( SEEK_CUR, cEntries );
        seqExpected += cEntries;

        cRead = g_cTestLog.Read( 1, rgNotificationsRead, &seqRead );
        if( 0 != cRead )
            TestRaiseException( E_FAIL, TEXT("Shouldn't have been able to read an already-read log\n") );

        // Seek to the end (which is where the read index already is), to ensure
        // that nothing happens.

        g_fNotified = FALSE;
        g_cTestLog.Seek( seqFirst + cEntries );

        if( g_fNotified )
            TestRaiseException( E_FAIL, TEXT("A seek-to-current shouldn't have caused a notification") );

        cRead = g_cTestLog.Read( 1, rgNotificationsRead, &seqRead );
        if( 0 != cRead )
            TestRaiseException( E_FAIL, TEXT("Shouldn't have been able to read an already-read log\n") );

        // Over-seek to the end.

        g_fNotified = FALSE;
        g_cTestLog.Seek( SEEK_CUR, 1000 );

        if( g_fNotified )
            TestRaiseException( E_FAIL, TEXT("A seek-to-current shouldn't have caused a notification") );

        cRead = g_cTestLog.Read( 1, rgNotificationsRead, &seqRead );
        if( 0 != cRead )
            TestRaiseException( E_FAIL, TEXT("Shouldn't have been able to read an already-read log\n") );

    }

    // Seek to the start of the log

    g_cTestLog.Seek( seqFirst );
    seqExpected = seqFirst;
    ReadTest( cEntries, rgNotificationsExpected, rgNotificationsRead, seqExpected );

    if( 0 != cEntries )
    {
        // Seek to the end of the log

        seqExpected = seqFirst + (ULONG)(cEntries - 1);
        g_cTestLog.Seek( seqExpected );
        ReadTest( 1, &rgNotificationsExpected[cEntries-1], &rgNotificationsRead[cEntries-1], seqExpected );

        g_cTestLog.Seek( SEEK_CUR, 1 );
    }

    // Search for each of the log entries

    for( ULONG i = 0; i < cEntries; i++ )
    {
        if( !g_cTestLog.Search( rgNotificationsExpected[i].droidCurrent,
                                rgNotificationsRead ))
        {
            TestRaiseException( E_FAIL, TEXT("Search failed to find entry") );
        }

        if( memcmp( &rgNotificationsExpected[i], rgNotificationsRead, sizeof(*rgNotificationsRead) ))
            TestRaiseException( E_FAIL, TEXT("Search failed on entry %d"), i );
    }

    g_cTestLog.SetReadIndex( iReadOriginal );

}   // ExerciseLog()


void
FillAndExerciseLog( ULONG cEntriesOriginal, ULONG cEntriesTotal, SequenceNumber seqFirst,
                    TRKSVR_MOVE_NOTIFICATION rgNotificationsWrite[],
                    TRKSVR_MOVE_NOTIFICATION rgNotificationsRead[] )
{
    // Test the log as-is

    ExerciseLog( cEntriesOriginal, seqFirst, rgNotificationsWrite, rgNotificationsRead );

    // Add an entry to the log and re-test

    g_cTestLog.Append( 1, &rgNotificationsWrite[ cEntriesOriginal ] );
    ExerciseLog( cEntriesOriginal + 1, seqFirst,
                 rgNotificationsWrite, rgNotificationsRead );

    // Test a full log

    g_cTestLog.Append( cEntriesTotal - cEntriesOriginal - 2,
                       &rgNotificationsWrite[ cEntriesOriginal + 1] );
    ExerciseLog( cEntriesTotal - 1, seqFirst,
                 rgNotificationsWrite, rgNotificationsRead );

}


ULONG
LogIndex2SectorIndex( ULONG cbSector, LogIndex ilog )
{
    ULONG cEntriesPerSector = ( cbSector - sizeof(LogEntryHeader) ) / sizeof(LogEntry);
    return( ilog / cEntriesPerSector + NUM_HEADER_SECTORS );
}



void
ReadLogSector( HANDLE hFile, LogIndex ilog, ULONG cbSector, BYTE rgbSector[] )
{
    ULONG iSector = LogIndex2SectorIndex( cbSector, ilog );
    ULONG cb;

    if( 0xFFFFFFFF == SetFilePointer(hFile, iSector * cbSector, NULL, FILE_BEGIN ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't seek file to %lu (in test)"), iSector*cbSector ));
        TrkRaiseLastError( );
    }

    if( !ReadFile( hFile, rgbSector, cbSector, &cb, NULL )
        ||
        cbSector != cb
      )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't read from logfile (in test), cbRead = %d"), cb ));
        TrkRaiseLastError( );
    }
}

void
WriteLogSector( HANDLE hFile, LogIndex ilog, ULONG cbSector, BYTE rgbSector[] )
{
    ULONG iSector = LogIndex2SectorIndex( cbSector, ilog );
    ULONG cb;

    if( 0xFFFFFFFF == SetFilePointer(hFile, iSector * cbSector, NULL, FILE_BEGIN ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't seek file to %lu (in test)"), iSector*cbSector ));
        TrkRaiseLastError( );
    }

    if( !WriteFile( hFile, rgbSector, cbSector, &cb, NULL )
        ||
        cbSector != cb
      )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't write to logfile (in test), cbWritten = %d"), cb ));
        TrkRaiseLastError( );
    }
}


void
CreateNewLog( CTestLogCallback *pcTestLogCallback, ULONG *pcLogEntries, ULONG *piNotifications,
              SequenceNumber *pseqFirst)
{

    _tprintf( TEXT("    Creating a log") );

    g_cTrkWksConfiguration._dwMinLogKB = 1;
    g_cTrkWksConfiguration._dwMaxLogKB = 1;

    g_cTestLog.CreateLog( pcTestLogCallback );

    *pcLogEntries = g_cTestLog.NumEntriesInFile();
    *piNotifications = 0;
    *pseqFirst = 0;

    if( 0 != g_cTestLog.GetNextSeqNumber( ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Next sequence number should be zero after a create") ));
        TrkRaiseException( E_FAIL );
    }

    _tprintf( TEXT(" (%d entries)\n"), *pcLogEntries );

}



EXTERN_C void __cdecl _tmain( int argc, TCHAR *argv[] )
{
    CTestLogCallback cTestLogCallback;

    TRKSVR_MOVE_NOTIFICATION rgNotificationsWritten[ 50 ];
    TRKSVR_MOVE_NOTIFICATION rgNotificationsRead[ 50 ];
    TRKSVR_MOVE_NOTIFICATION tempNotificationWrite, tempNotificationRead;

    __try
    {

        ULONG cLogEntries = 0;
        ULONG i;
        DWORD dw;
        ULONG cRead, cb, cbFile;
        SequenceNumber seqFirst = 0;
        BOOL fAppendFailed;
        HANDLE hFile = INVALID_HANDLE_VALUE;
        BYTE rgbSector[ 2048 ];
        LogHeader *plogheader = NULL;
        LogEntry *plogentry = NULL;
        ULONG iNotifications = 0;

        BYTE rgbExtendedHeaderWrite[ 16 ];
        BYTE rgbExtendedHeaderRead[ 16 ];

        LogIndex ilogStart, ilogEnd;


        //  --------------
        //  Initialization
        //  --------------

        _tprintf( TEXT("\nCLog Unit Test\n") );
        _tprintf( TEXT(  "==============\n\n") );

        if( argc > 1 )
        {
            if( !_tcscmp( TEXT("/D"), argv[1] )
                ||
                !_tcscmp( TEXT("/d"), argv[1] )
                ||
                !_tcscmp( TEXT("-D"), argv[1] )
                ||
                !_tcscmp( TEXT("-d"), argv[1] )
              )
            {
                g_fTLogDebug = TRUE;
            }
        }   // if( argc > 1 )


        TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG | (g_fTLogDebug ? TRK_DBG_FLAGS_WRITE_TO_STDOUT : 0), "TLog" );

        g_cTrkWksConfiguration.Initialize();

        g_cTrkWksConfiguration._dwMinLogKB = 1;
        g_cTrkWksConfiguration._dwMaxLogKB = 1;
        g_cTrkWksConfiguration._dwLogDeltaKB = 1;
        g_cTrkWksConfiguration._dwLogOverwriteAge = 10;
        g_cTrkWksConfiguration._dwLogFileOpenTime = 10;
        g_cTrkWksConfiguration._dwDebugFlags = (0xFFFFFFFF & ~TRKDBG_WORKMAN);

        g_Debug = g_cTrkWksConfiguration._dwDebugFlags;

        for( i = 0; i < sizeof(rgNotificationsWritten); i++ )
            ((BYTE*) rgNotificationsWritten)[ i ] = (BYTE) i;



        //  -----------
        //  Basic Tests
        //  -----------

        _tprintf( TEXT("Basic exercises\n") );

        CreateNewLog( &cTestLogCallback, &cLogEntries, &iNotifications, &seqFirst );

        // Test the initial log

        FillAndExerciseLog( 0, cLogEntries, seqFirst, rgNotificationsWritten, rgNotificationsRead );

        // Seek to a non-existent entry in the log

        g_cTestLog.Seek( 1 );
        g_cTestLog.Seek( -1 );
        ExerciseLog( cLogEntries-1, 0,
                     &rgNotificationsWritten[ iNotifications ],
                     &rgNotificationsRead[ iNotifications ] );

        // Cause the log to expand.  Note that in this case, the start/end indices are
        // currently at the start/end of the file.

        _tprintf( TEXT("Cause the log to expand") );

        g_cTrkWksConfiguration._dwLogDeltaKB = 1;
        g_cTrkWksConfiguration._dwMaxLogKB = g_cTrkWksConfiguration._dwMaxLogKB + 1;

        g_cTestLog.Append( 1, &rgNotificationsWritten[ cLogEntries - 1] );

        _tprintf( TEXT(" (%d entries)\n"), g_cTestLog.NumEntriesInFile() );

        g_cTestLog.DelayUntilClose();

        FillAndExerciseLog( cLogEntries,
                            g_cTestLog.NumEntriesInFile(),
                            seqFirst,
                            &rgNotificationsWritten[ iNotifications ],
                            &rgNotificationsRead[ iNotifications ] );
        cLogEntries = g_cTestLog.NumEntriesInFile();

        // Close and re-open the log

        _tprintf( TEXT("Close and re-open the log\n") );

        g_cTestLog.CloseLog();
        g_cTestLog.OpenLog( &cTestLogCallback );

        ExerciseLog( cLogEntries - 1, seqFirst,
                     &rgNotificationsWritten[ iNotifications ],
                     &rgNotificationsRead[ iNotifications ] );

        // Ensure that we can't add to a full log (where the log can't be expanded,
        // the start entry isn't old enough to throw away, and the start entry
        // hasn't yet been read).

        __try
        {
            fAppendFailed = FALSE;
            TrkLog(( TRKDBG_ERROR, TEXT("TLog Unit Test:  Causing an intentional Append exception") ));
            g_cTestLog.Seek( SEEK_SET, 0 ); // Make the start entry un-read
            g_cTestLog.Append( 1, rgNotificationsWritten );
        }
        __except( BreakOnAccessViolation() )
        {
            if( GetExceptionCode() != STATUS_LOG_FILE_FULL )
                TestRaiseException( GetExceptionCode(), TEXT("Wrong exception raised when attempting to write to a full log") );
            fAppendFailed = TRUE;
        }

        if( !fAppendFailed )
            TestRaiseException( E_FAIL, TEXT("Append to a full log should have failed") );

        // Overwrite an entry in the log that's overwritable since it's been read already.

        _tprintf( TEXT("Try to add to a max log (the start entry's been read)\n") );

        g_cTestLog.Seek( SEEK_SET, 1 );
        g_cTestLog.Append( 1, &rgNotificationsWritten[ cLogEntries - 1 ] );

        seqFirst++;
        iNotifications++;

        ExerciseLog( cLogEntries-1, seqFirst,
                     &rgNotificationsWritten[ iNotifications ],
                     &rgNotificationsRead[ iNotifications ] );
        
        g_cTestLog.ValidateLog();

        // Overwrite an old entry in the log

        _tprintf( TEXT("Try to add to a max log (the start entry's old)\n") );
        g_cTestLog.Seek( SEEK_SET, 0 );
        g_cTestLog.MakeEntryOld();
        g_cTestLog.Append( 1, &rgNotificationsWritten[cLogEntries] );

        seqFirst++;
        iNotifications++;

        ExerciseLog( cLogEntries-1, seqFirst,
                     &rgNotificationsWritten[ iNotifications ],
                     &rgNotificationsRead[ iNotifications ] );

        g_cTestLog.ValidateLog();

        // Grow again (note that this time, the start/end indices are in the middle of
        // the file).  Also, this time, we show that the log can grow to up to the max
        // size, even if it means we can't grow an entire delta.

        _tprintf( TEXT("Cause the log to expand again") );

        g_cTrkWksConfiguration._dwLogDeltaKB = 10;
        g_cTrkWksConfiguration._dwMaxLogKB = g_cTrkWksConfiguration._dwMaxLogKB + 1;

        g_cTestLog.Append( 1, &rgNotificationsWritten[ cLogEntries+1 ] );

        if( g_cTestLog.NumEntriesInFile()
            >
            cLogEntries + g_cTestLog.NumEntriesPerKB()
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Log grew by more than the max allowable") ));
            TrkRaiseWin32Error( E_FAIL );
        }

        _tprintf( TEXT(" (%d entries)\n"), g_cTestLog.NumEntriesInFile() );

        FillAndExerciseLog( cLogEntries, g_cTestLog.NumEntriesInFile(),
                            seqFirst,
                            &rgNotificationsWritten[ iNotifications ],
                            &rgNotificationsRead[ iNotifications ] );
        cLogEntries = g_cTestLog.NumEntriesInFile();

        g_cTestLog.ValidateLog();


        //  --------------
        //  Extended Tests
        //  --------------

        // Test the extended header

        _tprintf( TEXT("Extended header area\n") );

        for( i = 0; i < sizeof(rgbExtendedHeaderWrite); i++ )
            rgbExtendedHeaderWrite[ i ] = (BYTE)i;

        g_cTestLog.WriteExtendedHeader( 32, (void*) rgbExtendedHeaderWrite, sizeof(rgbExtendedHeaderWrite) );
        g_cTestLog.ReadExtendedHeader(  32, (void*) rgbExtendedHeaderRead,  sizeof(rgbExtendedHeaderRead) );

        for( i = 0; i < sizeof(rgbExtendedHeaderWrite); i++ )
            rgbExtendedHeaderWrite[ i ] = (BYTE)(i + 1);

        g_cTestLog.WriteExtendedHeader( 32, (void*) rgbExtendedHeaderWrite, sizeof(rgbExtendedHeaderWrite) );
        g_cTestLog.DelayUntilClose();
        g_cTestLog.ReadExtendedHeader(  32, (void*) rgbExtendedHeaderRead,  sizeof(rgbExtendedHeaderRead) );


        if( memcmp( rgbExtendedHeaderWrite, rgbExtendedHeaderRead, sizeof(rgbExtendedHeaderWrite) ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Extended header information couldn't be written/read") ));
            TrkRaiseWin32Error( E_FAIL );
        }

        // Make the log look abnormally shutdown, then open it.

        _tprintf( TEXT("Make log look abnormally shut down\n") );

        g_cTestLog.CloseLog();

        hFile = CreateFile( g_cTestLog.LogFileName(), GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if( INVALID_HANDLE_VALUE == hFile )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open the logfile from the test") ));
            TrkRaiseLastError( );
        }

        if( !ReadFile( hFile, rgbSector, g_cTestLog.CBSector(), &cb, NULL )
            ||
            g_cTestLog.CBSector() != cb
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't read from logfile (in test), cbRead = %d"), cb ));
            TrkRaiseLastError( );
        }

        plogheader = (LogHeader*) rgbSector;
        plogheader->fProperShutdown = FALSE;

        if( 0xFFFFFFFF == SetFilePointer( hFile, 0, NULL, FILE_BEGIN ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't seek logfile (in test)") ));
            TrkRaiseLastError( );
        }

        if( !WriteFile( hFile, rgbSector, g_cTestLog.CBSector(), &cb, NULL )
            ||
            g_cTestLog.CBSector() != cb
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't write to logfile (in test), cbWritten = %d"), cb ));
            TrkRaiseLastError( );
        }

        CloseHandle( hFile );
        hFile = INVALID_HANDLE_VALUE;
        plogheader = NULL;

        g_cTestLog.OpenLog( &cTestLogCallback );
        ExerciseLog( cLogEntries - 1, seqFirst,
                     &rgNotificationsWritten[ iNotifications ],
                     &rgNotificationsRead[ iNotifications ] );


        // Make the log look like it crashed during an expansion.

        _tprintf( TEXT("Expansion crash recovery\n") );

        ilogStart = g_cTestLog.GetStartIndex();
        ilogEnd = g_cTestLog.GetEndIndex();

        g_cTestLog.CloseLog();

        hFile = CreateFile( g_cTestLog.LogFileName(), GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if( INVALID_HANDLE_VALUE == hFile )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open the logfile from the test") ));
            TrkRaiseLastError( );
        }

        cbFile = GetFileSize( hFile, NULL );
        if( 0xffffffff == cbFile )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't get log file size (in test)") ));
            TrkRaiseLastError( );
        }

        if( !ReadFile( hFile, rgbSector, g_cTestLog.CBSector(), &cb, NULL )
            ||
            g_cTestLog.CBSector() != cb
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't read from logfile (in test), cbRead = %d"), cb ));
            TrkRaiseLastError( );
        }

        plogheader = (LogHeader*) rgbSector;

        plogheader->fProperShutdown = FALSE;
        plogheader->expand.cbFile = cbFile;
        plogheader->expand.ilogStart = ilogStart;
        plogheader->expand.ilogEnd = ilogEnd;

        if( 0xFFFFFFFF == SetFilePointer( hFile, 0, NULL, FILE_BEGIN ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't seek logfile (in test)") ));
            TrkRaiseLastError( );
        }

        if( !WriteFile( hFile, rgbSector, g_cTestLog.CBSector(), &cb, NULL )
            ||
            g_cTestLog.CBSector() != cb
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't write to logfile (in test), cbWritten = %d"), cb ));
            TrkRaiseLastError( );
        }

        ReadLogSector( hFile, ilogStart, g_cTestLog.CBSector(), rgbSector );
        plogentry = &( (LogEntry*)rgbSector )[ ilogStart % (g_cTestLog.CBSector()/sizeof(LogEntry)) ];
        plogentry->ilogPrevious = -1;
        WriteLogSector( hFile, ilogStart, g_cTestLog.CBSector(), rgbSector );
        
        ReadLogSector( hFile, ilogEnd, g_cTestLog.CBSector(), rgbSector );
        plogentry = &( (LogEntry*)rgbSector )[ ilogEnd % (g_cTestLog.CBSector()/sizeof(LogEntry)) ];
        plogentry->ilogNext = -1;
        WriteLogSector( hFile, ilogEnd, g_cTestLog.CBSector(), rgbSector );
        

        cbFile += g_cTestLog.CBSector();
        if ( 0xFFFFFFFF == SetFilePointer(hFile, cbFile, NULL, FILE_BEGIN)
             ||
             !SetEndOfFile(hFile) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't reset log file size to %lu (in test)"), cbFile ));
            TrkRaiseLastError( );
        }

        CloseHandle( hFile );
        hFile = INVALID_HANDLE_VALUE;
        plogheader = NULL;

        g_cTestLog.OpenLog( &cTestLogCallback );
        ExerciseLog( cLogEntries - 1, seqFirst,
                     &rgNotificationsWritten[ iNotifications ],
                     &rgNotificationsRead[ iNotifications ] );


        // Corrupt the log header, but in a way that is recoverable.

        _tprintf( TEXT("Make log look corrupted (recoverable)\n") );

        g_cTestLog.CloseLog();

        hFile = CreateFile( g_cTestLog.LogFileName(), GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if( INVALID_HANDLE_VALUE == hFile )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open the logfile from the test") ));
            TrkRaiseLastError( );
        }

        if( !ReadFile( hFile, rgbSector, g_cTestLog.CBSector(), &cb, NULL )
            ||
            g_cTestLog.CBSector() != cb
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't read from logfile (in test), cbRead = %d"), cb ));
            TrkRaiseLastError( );
        }

        plogheader = (LogHeader*) rgbSector;
        plogheader->fProperShutdown = FALSE;

        memset( &reinterpret_cast<BYTE*>(plogheader)[CLOG_LOGINFO_START], 0, CLOG_LOGINFO_LENGTH );


        if( 0xFFFFFFFF == SetFilePointer( hFile, 0, NULL, FILE_BEGIN ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't seek logfile (in test)") ));
            TrkRaiseLastError( );
        }

        if( !WriteFile( hFile, rgbSector, g_cTestLog.CBSector(), &cb, NULL )
            ||
            g_cTestLog.CBSector() != cb
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't write to logfile (in test), cbWritten = %d"), cb ));
            TrkRaiseLastError( );
        }

        CloseHandle( hFile );
        hFile = INVALID_HANDLE_VALUE;
        plogheader = NULL;

        g_cTestLog.OpenLog( &cTestLogCallback );
        if( g_cTestLog.IsEmpty() )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("We got a new log file after what should have been a recoverable corruption") ));
            TrkRaiseWin32Error( E_FAIL );
        }

        ExerciseLog( cLogEntries - 1, seqFirst,
                     &rgNotificationsWritten[ iNotifications ],
                     &rgNotificationsRead[ iNotifications ] );
        

        // Make the log look corrupted and un-recoverable in the header

        _tprintf( TEXT("Make log header look corrupted (un-recoverable)\n") );

        g_cTestLog.CloseLog();

        hFile = CreateFile( g_cTestLog.LogFileName(), GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if( INVALID_HANDLE_VALUE == hFile )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open the logfile from the test") ));
            TrkRaiseLastError( );
        }

        if( !ReadFile( hFile, rgbSector, g_cTestLog.CBSector(), &cb, NULL )
            ||
            g_cTestLog.CBSector() != cb
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't read from logfile (in test), cbRead = %d"), cb ));
            TrkRaiseLastError( );
        }

        plogheader = (LogHeader*) rgbSector;
        plogheader->fProperShutdown = FALSE;
        plogheader->ulSignature = 0;

        if( 0xFFFFFFFF == SetFilePointer( hFile, 0, NULL, FILE_BEGIN ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't seek logfile (in test)") ));
            TrkRaiseLastError( );
        }

        if( !WriteFile( hFile, rgbSector, g_cTestLog.CBSector(), &cb, NULL )
            ||
            g_cTestLog.CBSector() != cb
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't write to logfile (in test), cbWritten = %d"), cb ));
            TrkRaiseLastError( );
        }

        CloseHandle( hFile );
        hFile = INVALID_HANDLE_VALUE;
        plogheader = NULL;

        g_cTestLog.OpenLog( &cTestLogCallback );
        if( !g_cTestLog.IsEmpty() )
        {
            TrkLog(( TRKDBG_ERROR,TEXT("After opening a corrupt log, we should have a new log file") ));
            TrkRaiseWin32Error( E_FAIL );
        }

        
        // Make the log look corrupted and un-recoverable in the sectors

        _tprintf( TEXT("Make log sectors look corrupted (un-recoverable)\n") );

        g_cTestLog.CloseLog();

        CreateNewLog( &cTestLogCallback, &cLogEntries, &iNotifications, &seqFirst );
        FillAndExerciseLog( 0, cLogEntries, seqFirst, rgNotificationsWritten, rgNotificationsRead );
        g_cTestLog.CloseLog();

        hFile = CreateFile( g_cTestLog.LogFileName(), GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if( INVALID_HANDLE_VALUE == hFile )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open the logfile from the test") ));
            TrkRaiseLastError( );
        }

        if( 0xFFFFFFFF == SetFilePointer( hFile,
                                          g_cTestLog.DataSectorOffset(),
                                          NULL, FILE_BEGIN ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't seek logfile to start of first sector (in test)") ));
            TrkRaiseLastError( );
        }

        if( !ReadFile( hFile, rgbSector, g_cTestLog.CBSector(), &cb, NULL )
            ||
            g_cTestLog.CBSector() != cb
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't read from logfile (in test), cbRead = %d"), cb ));
            TrkRaiseLastError( );
        }

        memset( rgbSector, 0, sizeof(rgbSector) );

        if( 0xFFFFFFFF == SetFilePointer( hFile, 
                                          g_cTestLog.DataSectorOffset(),
                                          NULL, FILE_BEGIN ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't re-seek logfile to start of first sector (in test)") ));
            TrkRaiseLastError( );
        }

        if( !WriteFile( hFile, rgbSector, g_cTestLog.CBSector(), &cb, NULL )
            ||
            g_cTestLog.CBSector() != cb
          )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't write to logfile (in test), cbWritten = %d"), cb ));
            TrkRaiseLastError( );
        }

        CloseHandle( hFile );
        hFile = INVALID_HANDLE_VALUE;

        BOOL fExceptionRaised = FALSE;
        __try
        {
            TrkLog(( TRKDBG_ERROR, TEXT("About to open a corrupted log (this should raise)") ));

            // The open should succeed
            g_cTestLog.OpenLog( &cTestLogCallback,
                                FALSE // => Don't validate
                              );

            // This should raise
            ExerciseLog( cLogEntries - 1, seqFirst,
                         &rgNotificationsWritten[ iNotifications ],
                         &rgNotificationsRead[ iNotifications ] );

        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            fExceptionRaised = TRUE;
            if( GetExceptionCode() != TRK_E_CORRUPT_LOG )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("After corrupting a sector, Open should have raised TRK_E_CORRUPT_LOG") ));
                TrkRaiseException( GetExceptionCode() );
            }
        }

        if( !fExceptionRaised )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("We should have gotten an exception after corrupting log sectors") ));
            TrkRaiseWin32Error( E_FAIL );
        }

        g_cTestLog.ReInitialize();

        if( !g_cTestLog.IsEmpty() )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("After opening a corrupt log, we should have a new log file") ));
            TrkRaiseWin32Error( E_FAIL );
        }

        cLogEntries = g_cTestLog.NumEntriesInFile();
        iNotifications = 0;
        seqFirst = 0;

        FillAndExerciseLog( 0, cLogEntries, seqFirst, rgNotificationsWritten, rgNotificationsRead );

        // Test that tunneling works correctly (if there are duplicate entries, we should
        // get the most recent).

        _tprintf( TEXT("Test tunneling\n") );

        tempNotificationWrite = rgNotificationsWritten[0];

        g_cTestLog.Append( 1, &tempNotificationWrite );

        strncpy( (LPSTR) &tempNotificationWrite.droidBirth, "abcdefghijklmnopqrstuvwxyznowiknowmyabcsnexttimewontyousingwithme",
                 sizeof(tempNotificationWrite.droidBirth) );

        g_cTestLog.Append( 1, &tempNotificationWrite );
        g_cTestLog.Search( tempNotificationWrite.droidCurrent, &tempNotificationRead );


        if( memcmp( &tempNotificationWrite, &tempNotificationRead, sizeof(tempNotificationWrite) ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Didn't get the tunneled move notification") ));
            TrkRaiseWin32Error( E_FAIL );
        }



        _tprintf( TEXT("\nTests Passed\n") );

        g_cTestLog.CloseLog();

    }   // __try

    __finally
    {
    }

}   // _tmain()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\vol.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  vol.cxx
//
//  This file implements the CVolume class.  This class maintains all activities
//  for a volume, such as the the log, log file, and deletions manager classes.
//
//+============================================================================




#include <pch.cxx>
#pragma hdrstop
#include "trkwks.hxx"
#include <dbt.h>

#define THIS_FILE_NUMBER    VOL_CXX_FILE_NO

//+----------------------------------------------------------------------------
//
//  CVolume::AddRef
//
//+----------------------------------------------------------------------------

ULONG
CVolume::AddRef()
{
    long cNew;
    cNew = InterlockedIncrement( &_lRef );
    //TrkLog(( TRKDBG_VOLUME, TEXT("+++ Vol %c: refs => %d"), VolChar(_iVol), cNew ));
    return( cNew );
}

//+----------------------------------------------------------------------------
//
//  CVolume::Release
//
//+----------------------------------------------------------------------------

ULONG
CVolume::Release()
{
    long cNew;
    cNew = InterlockedDecrement( &_lRef );
    //TrkLog(( TRKDBG_VOLUME, TEXT("--- Vol %c: refs => %d"), VolChar(_iVol), cNew ));
    if( 0 == cNew )
        delete this;

    return( cNew >= 0 ? cNew : 0 );
}

//+----------------------------------------------------------------------------
//
//  CVolume::Initialize
//
//  Initialize CVolume and open a handle to the volume itself, but nothing
//  more (e.g. don't open the log or verify volume IDs).  The remainder of
//  the initialization will occur later the first time ReopenVolumeHandles
//  is called.  This gets that heavy IO work out of the service initialization
//  path.
//
//+----------------------------------------------------------------------------

BOOL
CVolume::Initialize( TCHAR *ptszVolumeName,
                     const CTrkWksConfiguration * pTrkWksConfiguration,
                     CVolumeManager *pVolMgr,
                     PLogCallback * pLogCallback,
                     PObjIdIndexChangedCallback * pObjIdIndexChangedCallback,
                     SERVICE_STATUS_HANDLE ssh
                     #if DBG
                     , CTestSync * pTunnelTest
                     #endif
                     )
{
    HANDLE              hFile = NULL;
    // const CVolumeId     volNULL;
    // CVolumeId           volidVolume;
    NTSTATUS            status;
    BOOL                fSuccess = FALSE;

    _iVol = -1;
    memset( &_volinfo, 0, sizeof(_volinfo) );

    // Save the volume name, without the trailing whack
    // Volume names are in the form \\?\Volume{guid}\ 

    _tcscpy( _tszVolumeDeviceName, ptszVolumeName );
    TrkAssert( TEXT('\\') == _tszVolumeDeviceName[ _tcslen(_tszVolumeDeviceName)-1 ] );
    _tszVolumeDeviceName[ _tcslen(_tszVolumeDeviceName)-1 ] = TEXT('\0');

    // Save the inputs

    _pTrkWksConfiguration = pTrkWksConfiguration;
    _pVolMgr = pVolMgr;
    _pLogCallback = pLogCallback;
    _ssh = ssh;
    _hdnVolumeLock = NULL;
    _fVolumeDismounted = _fVolumeLocked = FALSE;

    IFDBG( _pTunnelTest = pTunnelTest; )

    __try   // __except
    {

        // Create critical sections

        _csVolume.Initialize();
        _csHandles.Initialize();
        _fInitialized = TRUE;


        Lock();

        __try // __finally
        {
            _VolQuotaReached.Initialize();

            // Open the volume (not a directory in the volume, but the volume itself).
            // We'll use this to do relative-opens by object ID

            status = OpenVolume( _tszVolumeDeviceName, &_hVolume );
            if (!NT_SUCCESS(status))
                TrkRaiseNtStatus(status);

            // Initialize, but don't start, the objid index change notifier.  When started,
            // this will watch for adds/deletes/tunnels/etc. in the index.

            _ObjIdIndexChangeNotifier.Initialize( _tszVolumeDeviceName,
                                                  pObjIdIndexChangedCallback,
                                                  this );


            fSuccess = TRUE;
        }
        __finally
        {
            Unlock();
        }

    }
    __except ( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed initializaion of volume %s (%08x)"),
                 ptszVolumeName, GetExceptionCode() ));

        if( TRK_E_VOLUME_NOT_DRIVE != GetExceptionCode() )
        {
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__,
                                    GetExceptionCode(), TRKREPORT_LAST_PARAM );
        }
    }

    return fSuccess;
}


//+----------------------------------------------------------------------------
//
//  CVolume::SetLocallyGeneratedVolId
//
//  Generate a volume ID and set it on the volume.  If we're in a domain,
//  this will later get replaced with a volume ID from trksvr.
//
//+----------------------------------------------------------------------------

void
CVolume::SetLocallyGeneratedVolId()
{
    NTSTATUS status = STATUS_SUCCESS;

    // Ensure the volume is writeable
    RaiseIfWriteProtectedVolume();

    _fDirty = TRUE;

    // Create the ID

    // Call _volinfo.volid.UuidCreate()
    RPC_STATUS rpc_status = GenerateVolumeIdInVolInfo();
    if( RPC_S_OK != rpc_status )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't create a local volid for new volume") ));
        TrkRaiseWin32Error(rpc_status);
    }

    // Set the ID on the volume.
    status = SetVolIdOnVolume( _volinfo.volid );
    g_ptrkwks->_entropy.Put();

    if( NT_SUCCESS(status) )
        TrkLog(( TRKDBG_VOLUME, TEXT("Locally generated a new volid for %c:, %s"),
                 VolChar(_iVol), (const TCHAR*)CDebugString(_volinfo.volid) ));
    else
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't set new volid on %c: (%08x)"), VolChar(_iVol), status ));
        TrkRaiseNtStatus(status);
    }

    // Get rid of the log and existing object IDs since we have a new volid.
    DeleteAndReinitializeLog();
    MarkForMakeAllOidsReborn();

}

//+----------------------------------------------------------------------------
//
//  CVolume::VolumeSanityCheck
//
//  This routine is called when the volume handles are opened,
//  The caller is responsible for calling CLogFile::Initialize and
//  CLog::Initialize.  The caller must ensure that _volinfo is
//  properly loaded prior to the call.
//
//+----------------------------------------------------------------------------


const GUID s_guidInvalidVolId = { /* {d2a2ac27-b89a-11d2-9335-00805ffe11b8} */
                                0xd2a2ac27, 0xb89a, 0x11d2,
                                {0x93, 0x35, 0x00, 0x80, 0x5f, 0xfe, 0x11, 0xb8} };


void
CVolume::VolumeSanityCheck( BOOL fVolIndexSetAlready )
{
    NTSTATUS            status;
    CVolumeId           volidVolume;
    const CVolumeId     volNULL;
    const CMachineId    mcidLocal( MCID_LOCAL );
    TCHAR               tszVolumeName[ CCH_MAX_VOLUME_NAME + 1 ];

    // Get the volume name that the mount manager has associated with this
    // volume.

    LONG iVolOld = _iVol;

    if( !fVolIndexSetAlready )
    {
        _iVol = MapVolumeDeviceNameToIndex( _tszVolumeDeviceName );
        if( -1 == _iVol )
        {
            TrkLog(( TRKDBG_VOLUME, TEXT("Volume %s does not appear any longer to have a drive letter (was %c:)"),
                     _tszVolumeDeviceName, VolChar( iVolOld ) ));
            MarkSelfForDelete();
            TrkRaiseException( TRK_E_VOLUME_NOT_DRIVE );
        }
        else if( iVolOld != _iVol )
        {
            TrkLog(( TRKDBG_VOLUME, TEXT("Volume %c: is now %c:"), VolChar(iVolOld), VolChar(_iVol) ));
        }
    }


    // Get the filesystem-maintained volume ID

    TCHAR tszRoot[ MAX_PATH ];
    _tcscpy( tszRoot, _tszVolumeDeviceName );
    _tcscat( tszRoot, TEXT("\\") );
    status = QueryVolumeId(tszRoot, &volidVolume);
    g_ptrkwks->_entropy.Put();

    if( !NT_SUCCESS(status) && STATUS_OBJECT_NAME_NOT_FOUND != status )
    {
        // For some reason we couldn't read the NTFS volid
        // (e.g. it's been dismounted).
        TrkLog(( TRKDBG_VOLUME, TEXT("Couldn't get filesys volid for %c:"), VolChar(_iVol) ));
        TrkRaiseNtStatus(status);
    }

    TrkLog(( TRKDBG_VOLUME, TEXT("VolId (from NTFS) for %c: is %s"),
             VolChar(_iVol), (const TCHAR*)CDebugString(volidVolume) ));


    // Compare the volume IDs from the filesystem (volume) and from
    // the VolInfo structure we keep in the log file.  If one is
    // set but not the other, then we'll adopt the one that's set.
    // If they're both set, but to different values, then we'll
    // take the one from NTFS.

    if( volNULL == volidVolume && volNULL != _volinfo.volid )
    {
        // Assume the volid in the VolInfo structure is correct.
        // This scenario occurs after a volume is formatted while the service
        // is running.  In that case, we have the volume info in memory and think
        // it's not dirty, but in fact the log file is gone.  So, just to be safe,
        // we'll go dirty, and the flush at the end will put the latest state out
        // to the file.

        RaiseIfWriteProtectedVolume();
        _fDirty = TRUE;

        TrkLog(( TRKDBG_ERROR, TEXT("Duping the volid from the logfile to the volume for %c:"),
                 VolChar(_iVol) ));
        status = SetVolIdOnVolume(_volinfo.volid);
        g_ptrkwks->_entropy.Put();
        if(!NT_SUCCESS(status))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't set a volume ID on %c:"), VolChar(_iVol) ));
            TrkRaiseNtStatus(status);
        }

        SetState( VOL_STATE_NOTOWNED );

    }
    else if( volidVolume != _volinfo.volid || volNULL == volidVolume)
    {
        // Either the two volids don't match, or they're both NULL.

        if( volNULL != volidVolume && s_guidInvalidVolId != volidVolume )
        {
            // Assume the volid on the volume (NTFS) is correct.

            // If the log has a different volid, it may have invalid move entries.
            // So we delete it.
            if( volNULL != _volinfo.volid )
                DeleteAndReinitializeLog();

            _volinfo.Initialize();

            // Set _volinfo.volid = volidVolume
            SetVolIdInVolInfo( volidVolume );

            _volinfo.machine = mcidLocal;

            SetState( VOL_STATE_NOTOWNED );
        }
        else
        {
            // Both the volume and the _volinfo (the log) are null.  We're going to
            // go into the not-created state, but first put on a volid so that we
            // never have a volume with no ID.

            _volinfo.Initialize();
            _volinfo.machine = mcidLocal;

            // Create a new ID and put it on the volume.

            SetLocallyGeneratedVolId(); // Updates _volinfo.volid

            // Put ourselves in the not-created state.

            TrkAssert( VOL_STATE_OWNED == GetState() );
            SetState( VOL_STATE_NOTCREATED );
        }
    }

    // If the machine ID in the log isn't the current machine, then go into
    // the not-created state so that we'll re-claim the volume.

    if( mcidLocal != _volinfo.machine )
        SetState( VOL_STATE_NOTOWNED );

    // See if this volume duplicates any other on this system.

    CVolume *pvolDuplicate = _pVolMgr->IsDuplicateVolId( this, GetVolumeId() );
    if( NULL != pvolDuplicate )
    {
        // This should never happen; there should never be two
        // volumes on the same machine with the same ID.
        // When this happens on different machines it gets caught during
        // CheckSequenceNumbers, but on the same machine this doesn't work,
        // because TrkSvr accepts the Claim of both machines.

        TrkLog(( TRKDBG_WARNING,
                 TEXT("Volume %c: and %c: have duplicate volume IDs.  Resetting %c:"),
                 VolChar(GetIndex()),
                 VolChar(pvolDuplicate->GetIndex()),
                 VolChar(GetIndex()) ));
        TrkReportEvent( EVENT_TRK_SERVICE_DUPLICATE_VOLIDS, EVENTLOG_INFORMATION_TYPE,
                        static_cast<const TCHAR*>(CStringize( VolChar(GetIndex()))),
                        static_cast<const TCHAR*>(CStringize( VolChar(pvolDuplicate->GetIndex()) )),
                        TRKREPORT_LAST_PARAM );

        SetLocallyGeneratedVolId(); // Updates _volinfo.volid
        SetState( CVolume::VOL_STATE_NOTCREATED );

        pvolDuplicate->SetState( CVolume::VOL_STATE_NOTOWNED );
        pvolDuplicate->Release();
    }

    // If anything's dirty, flush it now.  In the normal initialization path,
    // this will have no effect.

    Flush();
}


//+----------------------------------------------------------------------------
//
//  CVolume::Refresh
//
//+----------------------------------------------------------------------------

void
CVolume::Refresh()
{
    HANDLE hVolume = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    Lock();
    __try
    {
        status = OpenVolume( _tszVolumeDeviceName, &hVolume );

        if( NT_SUCCESS(status) )
            _iVol = MapVolumeDeviceNameToIndex( _tszVolumeDeviceName );
        else if( !IsErrorDueToLockedVolume(status) )
            _iVol = -1;

        if( -1 == _iVol )
        {
            TrkLog(( TRKDBG_VOLUME, TEXT("Drive not found in CVolume::Refresh") ));
            MarkSelfForDelete();
        }
    }
    __except( BreakOnDebuggableException() )
    {
    }

    // Unlock before calling NtClose, since during stress that
    // could raise.
    
    Unlock();
    
    if( NULL != hVolume )
        NtClose( hVolume );


}   // CVolume::Refresh


//+----------------------------------------------------------------------------
//
//  CVolume::MarkSelfForDelete
//
//  Mark this CVolume to be deleted (not the volume, but the class).  The
//  delete will actually occur when this object is completely released
//  and unlocked.  We do, however, as part of this method remove ourself
//  from the volume manager's list.
//
//+----------------------------------------------------------------------------

void
CVolume::MarkSelfForDelete()
{
    AssertLocked();

    if( !_fDeleteSelfPending )
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("Marking %c: for delete"), VolChar(_iVol) ));

        // Show that we need to be deleted.  We can't actually delete now, because there
        // may be threads active in the object.

        _fDeleteSelfPending = TRUE;

        // On the final UnLock, Release will be called to counter this AddRef and
        // cause the actual delete.

        AddRef();

        // Take this object out of the Volume Manager's linked list (which will do
        // a Release, thus the need for the above AddRef);

        _pVolMgr->RemoveVolumeFromLinkedList( this );
    }
    else
        TrkLog(( TRKDBG_VOLUME, TEXT("%c: is already marked for delete"), VolChar(_iVol) ));
}


//+----------------------------------------------------------------------------
//
//  CVolume::RegisterPnpVolumeNotification
//
//  Register to receive PNP notifications for this volume.  If already
//  registered, register again (since the volume handle against which 
//  we'd previously registered may no longer exist).
//
//+----------------------------------------------------------------------------


void
CVolume::RegisterPnPVolumeNotification()
{
    DEV_BROADCAST_HANDLE    dbchFilter;
    HDEVNOTIFY              hdnVolumeLock = _hdnVolumeLock;

    dbchFilter.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
    dbchFilter.dbch_devicetype = DBT_DEVTYP_HANDLE;
    dbchFilter.dbch_handle = _ObjIdIndexChangeNotifier._hDir; // _hVolume;

    __try
    {
        // Register against the oid index handle (as a representative of
        // the volume).
        hdnVolumeLock = RegisterDeviceNotification((HANDLE)_ssh,
                                         &dbchFilter,
                                         DEVICE_NOTIFY_SERVICE_HANDLE);
        if(hdnVolumeLock == NULL)
        {
            TrkLog((TRKDBG_VOLUME, TEXT("Can't register for volume notifications, %08x"), GetLastError()));
            TrkRaiseLastError();
        }

        // Get rid of our old registration, if we had one.

        UnregisterPnPVolumeNotification();

        // Keep the new registration.

        _hdnVolumeLock = hdnVolumeLock;
        TrkLog(( TRKDBG_VOLUME, TEXT("Registered for volume lock/unlock notification on %c: (%p)"),
                 VolChar(_iVol), _hdnVolumeLock ));
    }
    __except(BreakOnDebuggableException())
    {
        TrkLog((TRKDBG_VOLUME, TEXT("Can't register for volume notification, %08x"), GetExceptionCode()));
    }
}


//+----------------------------------------------------------------------------
//
//  CVolume::UnregisterPnpVolumeNotification
//
//  Unregister the device notification handle for this volume (if we have
//  one).
//
//+----------------------------------------------------------------------------

void
CVolume::UnregisterPnPVolumeNotification()
{
    if(_hdnVolumeLock)
    {
        if( !UnregisterDeviceNotification(_hdnVolumeLock)) {
            TrkLog(( TRKDBG_ERROR, TEXT("UnregisterDeviceNotification failed: %lu"), GetLastError() ));
        }

        TrkLog(( TRKDBG_VOLUME, TEXT("Unregistered for volume lock/unlock notification on %c: (%p)"),
                 VolChar(_iVol), _hdnVolumeLock ));

        _hdnVolumeLock = NULL;
    }
}


//+----------------------------------------------------------------------------
//
//  CVolume::DeleteAndReinitializeLog
//
//  Delete the volume log and reinitialize it.
//
//+----------------------------------------------------------------------------

void
CVolume::DeleteAndReinitializeLog()
{
    // Delete and reinitialize the log

    __try
    {
        RaiseIfWriteProtectedVolume();

        TrkLog(( TRKDBG_VOLUME, TEXT("DeleteAndReinitializeLog (%s)"),
                 _tszVolumeDeviceName ));

        if( IsHandsOffVolumeMode() )
            // Volume is locked
            TrkRaiseNtStatus( STATUS_ACCESS_DENIED );

        // Delete the log

        _cLogFile.Delete();

        // Reinitialize the log file, then the log itself.

        _cLogFile.Initialize( NULL, NULL, NULL, VolChar(_iVol) );
        _cLog.Initialize( _pLogCallback, _pTrkWksConfiguration, &_cLogFile );
    }
    __except( IsErrorDueToLockedVolume( GetExceptionCode() )
              ? EXCEPTION_EXECUTE_HANDLER
              : EXCEPTION_CONTINUE_SEARCH )
    {
        // If the volume is locked, start the reopen timer and abort.
        CloseVolumeHandles();   // Never raises
        g_ptrkwks->SetReopenVolumeHandlesTimer();
        TrkRaiseException( GetExceptionCode() );
    }
}


//+----------------------------------------------------------------------------
//
//  CVolume::DeleteLogAndReInitializeVolume
//
//  Delete and reinit the log, then reinitialize the rest of the volume.
//
//+----------------------------------------------------------------------------

void
CVolume::DeleteLogAndReInitializeVolume()
{
    AssertLocked();

    // There's the remote possibility that the VolumeSanityCheck
    // call below will call this routine.  Just to be paranoid, we
    // add protection against an infinite recursion.

    if( _fDeleteLogAndReInitializeVolume )
        TrkRaiseWin32Error( ERROR_OPEN_FAILED );
    _fDeleteLogAndReInitializeVolume = TRUE;

    __try
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("Re-initializing volume %c:"), VolChar(_iVol) ));

        // Re-initialize the CLogFile.
        DeleteAndReinitializeLog();

        // Recreate the volinfo in the new log's header
        _fDirty = TRUE; // Force a flush
        VolumeSanityCheck();
    }
    __finally
    {
        _fDeleteLogAndReInitializeVolume = FALSE;
    }

}


//+----------------------------------------------------------------------------
//
//  CVolume::UnInitialize
//
//  Unregister our PNP handle, free critical sections, etc.
//
//+----------------------------------------------------------------------------

void
CVolume::UnInitialize()
{
    if( _fInitialized )
    {
        IFDBG( _cLocks++; )

        UnregisterPnPVolumeNotification();
        _ssh = NULL;

        if (_hVolume != NULL)
            NtClose(_hVolume);

        __try
        {
            _cLogFile.UnInitialize();
        }
        __except( EXCEPTION_EXECUTE_HANDLER ) // BreakOnDebuggableException() )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception in CVolume::UnInitialize after _cLogFile.UnInitialize for %c: %08x"),
                     VolChar(_iVol), GetExceptionCode() ));
        }


        _fInitialized = FALSE;
        _csHandles.UnInitialize();
        _csVolume.UnInitialize();

        IFDBG( _cLocks--; )

        TrkAssert( 0 == _cLocks );
    }
    _ObjIdIndexChangeNotifier.UnInitialize();
}


//+----------------------------------------------------------------------------
//
//  CVolume::Flush
//
//  Flush the volinfo structure, the log, and the logfile.  In the process,
//  mark the logfile header to show a proper shutdown.  If we're in the middle
//  of a service shutdown, and there's a problem with the log, don't run
//  the recovery code.
//
//+----------------------------------------------------------------------------

void
CVolume::Flush(BOOL fServiceShutdown)
{
    Lock();
    __try
    {
        if( _fDirty )
            SaveVolInfo();

        __try
        {
            _cLog.Flush( );                 // Flushes to CLogFile
            _cLogFile.SetShutdown( TRUE );  // Causes a flush to disk if necessary
        }
        __except( !fServiceShutdown
                  &&
                  0 == _cHandleLocks
                  &&
                  IsRecoverableDiskError( GetExceptionCode() )
                    ? EXCEPTION_EXECUTE_HANDLER
                    : EXCEPTION_CONTINUE_SEARCH )
        {
            // Note that we don't handle this exception if the _cHandleLocks is non-zero.
            // In this case we're in fast-path and must complete quickly, and the following
            // calls could be too time consuming.  We must complete quickly because 
            // CloseVolumeHandles uses that lock, and that call might be called on the 
            // SCM thread (for e.g. a volume lock event).  The SCM thread is shared by
            // all services in the process, so we must fast-path anything on it.

            if( IsErrorDueToLockedVolume( GetExceptionCode() ))
            {
                CloseAndReopenVolumeHandles();  // Reopen might fail
                _cLog.Flush();
                _cLogFile.SetShutdown( TRUE );
            }
            else
            {
                TrkAssert( TRK_E_CORRUPT_LOG == GetExceptionCode() );
                TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                                static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                                NULL );

                DeleteLogAndReInitializeVolume();
            }
        }
    }
    __finally
    {
        Unlock();
    }
}


//+----------------------------------------------------------------------------
//
//  CVolume::OpenFile
//
//  Open a file on this volume, given the file's object ID.
//
//+----------------------------------------------------------------------------

BOOL
CVolume::OpenFile( const CObjId           &objid,
                   ACCESS_MASK            AccessMask,
                   ULONG                  ShareAccess,
                   HANDLE                 *ph)
{
    NTSTATUS status;

    Lock();
    __try
    {
        status = OpenFileById( _tszVolumeDeviceName, objid, AccessMask, ShareAccess, 0, ph );

        if( NT_SUCCESS(status) )
            return TRUE;
        else if( STATUS_OBJECT_NAME_NOT_FOUND == status )
            return FALSE;
        else
            TrkRaiseNtStatus( status );
    }
    __finally
    {
        Unlock();
    }

    return( FALSE );

}   // CVolume::OpenFile()



//+----------------------------------------------------------------------------
//
//  CVolume::LoadSyncVolume
//
//  Load the TRKSVR_SYNC_VOLUME message request for this volume, if necessary.
//  The call of this message to trksvr is actually sent by the caller.  On
//  return of that request, UnloadSyncVolume method will be called.
//
//+----------------------------------------------------------------------------

BOOL
CVolume::LoadSyncVolume( TRKSVR_SYNC_VOLUME *pSyncVolume, EAggressiveness eAggressiveness, BOOL* pfSyncNeeded )
{
    CVOL_STATE      state = GetState();
    BOOL fSuccess = FALSE;

    Lock();
    __try
    {
        if( !_fVolInfoInitialized )
            TrkRaiseException( E_UNEXPECTED );

        memset( pSyncVolume, 0, sizeof(*pSyncVolume) );
        if(pfSyncNeeded)
        {
            *pfSyncNeeded = FALSE;
        }

        // See if it's time to transition from not-owned to not-created.

        if( NotOwnedExpired() )
            SetState( state = VOL_STATE_NOTCREATED );

        // Load the message request, if necessary, based on our current state.

        if(state == VOL_STATE_NOTCREATED)
        {
            // Ordinarily, if we were unable to create this volume due to volume
            // quota, we won't try again.  But if we're told to be aggressive,
            // we'll try anyway.

            if( PASSIVE == eAggressiveness && _VolQuotaReached.IsSet() )
            {
                TrkLog(( TRKDBG_VOLUME, TEXT("Not attempting to create new volume ID on %c:; quota reached"),
                         VolChar(_iVol) ));
            }
            else
            {
                // Generate a new secret for authentication of this volume.

                g_ptrkwks->_entropy.Put();

                if( !g_ptrkwks->_entropy.InitializeSecret( & _tempSecret ) )
                {
                    // This should never happen - even if there hasn't been enough
                    // entropy yet, more will be generated.
                    TrkLog(( TRKDBG_ERROR, TEXT("Couldn't generate secret for volume %c:"), VolChar(_iVol) ));
                    goto Exit;
                }

                TrkLog((TRKDBG_VOLUME, TEXT("Generated secret %s for volume %c"),
                        (const TCHAR*)CDebugString(_tempSecret), VolChar( _iVol )));

                // Put the secret in the request, and set the request type to "create"

                pSyncVolume->secret = _tempSecret;
                pSyncVolume->SyncType = CREATE_VOLUME;

                // Show that we put data into the request that should be sent
                // to trksvr.

                if (pfSyncNeeded != NULL)
                    *pfSyncNeeded = TRUE;
            }

        }   // case CREATE_VOLUME

        else if(state == VOL_STATE_NOTOWNED)
        {
            // Attempt to claim this volume.

            pSyncVolume->volume = _volinfo.volid;
            pSyncVolume->secretOld = _volinfo.secret;
            pSyncVolume->SyncType = CLAIM_VOLUME;

            // Generate a new secret.

            if( !g_ptrkwks->_entropy.InitializeSecret( &_tempSecret ) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't generate secret for volume %c:"), VolChar(_iVol) ));
                goto Exit;
            }

            TrkLog((TRKDBG_VOLUME, TEXT("Generated secret %s for volume %c"),
                    (const TCHAR*)CDebugString(_tempSecret), VolChar( _iVol )));
            pSyncVolume->secret = _tempSecret;

            // Show that the request should be sent.

            if (pfSyncNeeded != NULL)
                *pfSyncNeeded = TRUE;

        }   // case CLAIM_VOLUME
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception in LoadSyncVolume for %c: %08x"),
                 VolChar(_iVol), GetExceptionCode() ));
        goto Exit;
    }

    fSuccess = TRUE;

Exit:

    Unlock();
    return( fSuccess );

}


//+----------------------------------------------------------------------------
//
//  CVolume::OnRestore
//
//  Not currently implemented.
//
//+----------------------------------------------------------------------------

HRESULT
CVolume::OnRestore()
{
    return( E_NOTIMPL );

#if 0
    HRESULT             hr = E_FAIL;
    CVolumeId           volidVolume;
    const CMachineId    mcidLocal( MCID_LOCAL );
    NTSTATUS            status;

    memset( &_volinfo, 0, sizeof(_volinfo) );
    hr = S_OK;

    Lock();
    __try // __finally
    {
        __try
        {

            // Get volume id from two different places: in the log file, and on
            // the volume. If the two
            // disagree, use the object id in the log file, overwrite the other
            // one. Put the volume into NOTOWNED state.

            TrkLog(( TRKDBG_VOLUME,
                     TEXT("Checking for recorded id's on volume %c:"),
                     VolChar(_iVol) ));

            LoadVolInfo();

            TrkLog(( TRKDBG_VOLUME, TEXT("volume id in log file ---- (%s) %c:"),
                     CDebugString(_volinfo.volid)._tsz, VolChar(_iVol) ));

            status = QueryVolumeId(_tszVolumeDeviceName, &volidVolume);
            if(!NT_SUCCESS(status) && status != STATUS_OBJECT_NAME_NOT_FOUND)
            {
                TrkLog((TRKDBG_ERROR, TEXT("Can't get id from volume %c"), VolChar(_iVol)));
                SetState(VOL_STATE_NOTCREATED);
            }
            // if no id is set on the volume, adopt from the log file
            if(volidVolume == CVolumeId() && _volinfo.volid != CVolumeId())
            {
                status = SetVolIdOnVolume(_volinfo.volid);
                g_ptrkwks->_entropy.Put();
                if(!NT_SUCCESS(status))
                {
                    TrkRaiseNtStatus(status);
                }
                SetState( VOL_STATE_NOTOWNED );
            }
            else if(volidVolume != _volinfo.volid)
            // The log file could have been copied or moved before the restore
            // happened, in order to be safe we trash the volume.
            {
                SetState(VOL_STATE_NOTCREATED);
            }

            hr = S_OK;
        }
        __except (BreakOnDebuggableException())
        {
            TrkLog((TRKDBG_ERROR, TEXT("OnRestore failed")));
            hr = GetExceptionCode();
        }

        // If an un-recoverable log error was raised, re-initialize everything

        if( TRK_E_CORRUPT_LOG == hr )
        {
            TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                            static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                            NULL );
            __try
            {
                DeleteLogAndReInitializeVolume();
            }
            __except( BreakOnDebuggableException())
            {
                hr = GetExceptionCode();
            }
        }
        else if( IsErrorDueToLockedVolume(hr) )
        {
            CloseAndReopenVolumeHandles();  // Reopen might fail
            TrkRaiseException( hr );
        }
    }
    __finally
    {
        Unlock();
    }

    return hr;

#endif // #if 0

}

//+----------------------------------------------------------------------------
//
//  CVolume::LoadQueryVolume
//
//  Load a TRKSVR_SYNC_VOLUME request for this volume, if necessary.  If we
//  load it, the caller will send it to trksvr.  On return of that request,
//  UnloadQueryVolume method will be called.
//
//+----------------------------------------------------------------------------

BOOL
CVolume::LoadQueryVolume( TRKSVR_SYNC_VOLUME *pQueryVolume )
{
    BOOL fSuccess = FALSE;

    Lock();
    __try
    {
        // Don't do anything we're not even in trksvr.

        if(GetState() == VOL_STATE_NOTCREATED)
        {
            goto Exit;
        }

        // Put our volid & log sequence number into the request.

        memset( pQueryVolume, 0, sizeof(*pQueryVolume) );

        pQueryVolume->SyncType = QUERY_VOLUME;
        pQueryVolume->volume = _volinfo.volid;
        pQueryVolume->seq = _cLog.GetNextSeqNumber();   // Never raises
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception in LoadQueryVolume for %c: %08x"),
                 VolChar(_iVol), GetExceptionCode() ));
        goto Exit;
    }

    fSuccess = TRUE;

Exit:

    Unlock();
    return( fSuccess );
}

// Originally, trkwks bundle up volume requests (sync, claim, create) and call the DC. After the
// DC returns, this function is called to put necessary information back on the volume. Now the
// DC callback mechanism is added. When there are create volume requests, the DC will callback and
// this function is called by the DC callback function. The DC needs to know if each create volume
// request is successfully finished by the trkwks, so this function has to put an HRESULT to
// indicate that in the hr field of the TRKSVR_SYNC_VOLUME structure.

//+----------------------------------------------------------------------------
//
//  CVolume::UnloadSyncVolume
//
//  A sync-volume request was loaded in LoadSyncVolume, sent to trksvr, and
//  we now need to interpret the result.  If we successfully completed
//  a create or claim, we'll go into the owned state.
//
//+----------------------------------------------------------------------------

BOOL
CVolume::UnloadSyncVolume( TRKSVR_SYNC_VOLUME *pSyncVolume )
{
    BOOL fSuccess = FALSE;
    BOOL fWrite = FALSE;
    CMachineId mcidLocal( MCID_LOCAL );

    Lock();
    __try
    {
        if( !_fVolInfoInitialized )
            TrkRaiseException( E_UNEXPECTED );

        if(pSyncVolume->hr == S_OK)
        {
            // Clear the bit that indicates we've reported a vol quota event.
            // That way, the next time we get a volume quota error, we'll report
            // to the event log.
            _VolQuotaReached.Clear();

            switch( pSyncVolume->SyncType )
            {
            case CREATE_VOLUME:
                {
                    NTSTATUS status = STATUS_SUCCESS;

                    // Write the volume ID to the volume meta-data.

                    status = SetVolIdOnVolume( pSyncVolume->volume );
                    g_ptrkwks->_entropy.Put();
                    if( !NT_SUCCESS(status) ) 
                        __leave;

                    TrkLog(( TRKDBG_VOLUME, TEXT("Newly-created vol id = %s, %c:"),
                            (const TCHAR*)CDebugString(pSyncVolume->volume),
                            VolChar(_iVol) ));

                    // Create a fresh log
                    DeleteAndReinitializeLog();

                    // Update _volinfo

                    _fDirty = TRUE;
                    _volinfo.cftLastRefresh = pSyncVolume->ftLastRefresh;

                    // Set _volinfo.volid = pSyncVolume->volume

                    SetVolIdInVolInfo( pSyncVolume->volume );

                    _volinfo.machine = mcidLocal;
                    _volinfo.secret = _tempSecret;

                    // And update our state.

                    SetState( VOL_STATE_OWNED );    // Flushes _volinfo
                    TrkAssert( VOL_STATE_OWNED == GetState() );

                    TrkReportEvent( EVENT_TRK_SERVICE_VOLUME_CREATE, EVENTLOG_INFORMATION_TYPE,
                                    static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                                    static_cast<const TCHAR*>( CStringize( _volinfo.volid )),
                                    NULL );
                }   // case CREATE_VOLUME

                break;

            case CLAIM_VOLUME:
                {
                    RaiseIfWriteProtectedVolume();
                    _fDirty = TRUE;

                    _volinfo.machine = mcidLocal;
                    _volinfo.cftLastRefresh = pSyncVolume->ftLastRefresh;
                    _volinfo.secret = _tempSecret;

                    SetState( VOL_STATE_OWNED );    // Flushes _volinfo
                    TrkAssert( VOL_STATE_OWNED == GetState() );
                    Seek( pSyncVolume->seq );

                    TrkReportEvent( EVENT_TRK_SERVICE_VOLUME_CLAIM, EVENTLOG_INFORMATION_TYPE,
                                    static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                                    static_cast<const TCHAR*>( CStringize( _volinfo.volid )),
                                    TRKREPORT_LAST_PARAM );

                }   // case CLAIM_VOLUME

                break;


            default:

                TrkAssert( FALSE && TEXT("Invalid SyncType given to CVolume::Serialize") );
                break;

            }   // switch

            fSuccess = TRUE;

        }   // if(pSyncVolume->hr == S_OK)

        else
        {
            // If this is a quota error, log it (but only log it once
            // per machine per transition).
            if( TRK_E_VOLUME_QUOTA_EXCEEDED == pSyncVolume->hr )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Vol quota reached") ));
                if( !_VolQuotaReached.IsSet() )
                {
                    _VolQuotaReached.Set();
                    TrkReportEvent( EVENT_TRK_SERVICE_VOL_QUOTA_EXCEEDED, EVENTLOG_WARNING_TYPE,
                                    TRKREPORT_LAST_PARAM );
                }

                // We'll call this success so that we don't retry.  We'll try again
                // later when the infrequent timer goes off.
                fSuccess = TRUE;
            }

            SetState(VOL_STATE_NOTOWNED);
            __leave;
        }


    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception in UnloadSyncVolume for %c: %08x"),
                 VolChar(_iVol), GetExceptionCode() ));
    }



    if( !fSuccess && pSyncVolume->SyncType == CREATE_VOLUME )
    {
        __try
        {
            CVolumeSecret ToReturn = _tempSecret;
            _tempSecret = CVolumeSecret();
            g_ptrkwks->_entropy.ReturnUnusedSecret( &ToReturn );

            if( SUCCEEDED(pSyncVolume->hr) )
                pSyncVolume->hr = E_FAIL;
        }
        __except( BreakOnDebuggableException() )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception (2) in UnloadSyncVolume for %c: %08x"),
                     VolChar(_iVol), GetExceptionCode() ));
        }
    }

    Unlock();
    return( fSuccess );

}   // CVolume::UnloadSyncVolume



//+----------------------------------------------------------------------------
//
//  CVolume::UnloadQueryVolume
//
//  The volume manager called LoadQueryVolume, sent the request to trskvr,
//  and is now giving us the result.
//
//+----------------------------------------------------------------------------

BOOL
CVolume::UnloadQueryVolume( const TRKSVR_SYNC_VOLUME *pQueryVolume )
{
    BOOL fSuccess = FALSE;

    Lock();
    __try
    {
        // Was the request successful?

        if(pQueryVolume->hr == S_OK)
        {
            // Go into the owned state, if we're not there
            // already.

            SetState( VOL_STATE_OWNED );

            // Seek the log to match what trksvr expects.  If this causes the
            // seek pointer to be backed up, it will set the timer to trigger
            // a new move-notification to trksvr.

            Seek( pQueryVolume->seq );
        }
        else    // DC didn't return VOLUME_OK
        {
            TrkLog((TRKDBG_VOLUME, TEXT("DC returned %s for QueryVolume of volume %s (%c:) -> VOL_STATE_NOTOWNED"),
                    GetErrorString(pQueryVolume->hr),
                    (const TCHAR*)CDebugString(pQueryVolume->volume),
                    VolChar(_iVol) ));

            // If there was a problem, go into the not-owned state.

            SetState(VOL_STATE_NOTOWNED);
        }
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception in UnloadQueryVolume for %c: %08x"),
                 VolChar(_iVol), GetExceptionCode() ));
        goto Exit;
    }

    fSuccess = TRUE;

Exit:

    Unlock();
    return( fSuccess );

}



//+----------------------------------------------------------------------------
//
//  CVolume::Append
//
//  Append a move notification to the end of this volume's log.
//
//+----------------------------------------------------------------------------

void
CVolume::Append( const CDomainRelativeObjId &droidCurrent,
                 const CDomainRelativeObjId &droidNew,
                 const CMachineId           &mcidNew,
                 const CDomainRelativeObjId &droidBirth)
{
    //TrkLog((TRKDBG_VOL_REFCNT, TEXT("CVolume(%08x)::Append refcnt=%d (should be 2, sometimes >2)"), this, _lRef));

    Lock();
    __try   // __finally
    {
        // Validate the IDs

        const CVolumeId volidZero;
        const CObjId objidZero;

        if( volidZero == droidCurrent.GetVolumeId()
            ||
            objidZero == droidCurrent.GetObjId()
            ||
            volidZero == droidNew.GetVolumeId()
            ||
            objidZero == droidNew.GetObjId()
            ||
            volidZero == droidBirth.GetVolumeId()
            ||
            objidZero == droidBirth.GetObjId() )
        {
            // In the append path, we only raise NTSTATUS errors, not HRESULTs
            TrkRaiseException( STATUS_OBJECT_NAME_INVALID );
        }

        __try   // __except
        {
            _cLog.Append( droidCurrent.GetVolumeId(), droidCurrent.GetObjId(), droidNew, mcidNew, droidBirth );
        }
        __except( IsRecoverableDiskError( GetExceptionCode() )
                  ? EXCEPTION_EXECUTE_HANDLER
                  : EXCEPTION_CONTINUE_SEARCH )
        {
            // We had a potentially recoverable exception.  Try to handle it
            // and retry the append.

            if( IsErrorDueToLockedVolume( GetExceptionCode() ) )
            {
                CloseAndReopenVolumeHandles();  // Reopen might fail
            }
            else
            {
                TrkAssert( TRK_E_CORRUPT_LOG == GetExceptionCode() );
                TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                                static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                                NULL );

                // The log is corrupted.  Re-initialize, then attempt the Append again.
                // If this raises, it's an unrecoverable exception, so we just pass
                // it up.
                DeleteLogAndReInitializeVolume();
            }

            // Retry the Append, which could raise again, but this time we won't catch it.
            _cLog.Append( droidCurrent.GetVolumeId(), droidCurrent.GetObjId(), droidNew, mcidNew, droidBirth );

        }
    }
    __finally
    {
        Unlock();
    }
}


//+----------------------------------------------------------------------------
//
//  CVolume::Read
//
//  Read one or more entries from the log, from the current seek position.
//
//+----------------------------------------------------------------------------

void
CVolume::Read(CObjId *pobjidCurrent,
              CDomainRelativeObjId *pdroidBirth,
              CDomainRelativeObjId *pdroidNew,
              SequenceNumber *pseqFirst,
              ULONG *pcRead)
{

    Lock();
    __try   // __finally
    {
        __try
        {
            _cLog.Read( pobjidCurrent, pdroidBirth, pdroidNew,
                        pseqFirst, pcRead );
        }
        __except( IsRecoverableDiskError( GetExceptionCode() )
                  ? EXCEPTION_EXECUTE_HANDLER
                  : EXCEPTION_CONTINUE_SEARCH )
        {
            // Try to recover from this error and if possible retry
            // the read.

            if( IsErrorDueToLockedVolume( GetExceptionCode() ))
            {
                CloseAndReopenVolumeHandles();  // Reopen might fail

                // Retry the read, which could raise again, but this time we won't
                // catch it.
                TrkLog(( TRKDBG_VOLUME, TEXT("Retrying CLog::Read") ));
                _cLog.Read( pobjidCurrent, pdroidBirth, pdroidNew,
                            pseqFirst, pcRead );
            }
            else
            {
                TrkAssert( TRK_E_CORRUPT_LOG == GetExceptionCode() );
                TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                                static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                                NULL );

                // The log is corrupted.  Re-initialize, then pass up the error.
                DeleteLogAndReInitializeVolume();
                TrkRaiseException( GetExceptionCode() );
            }
        }
    }
    __finally
    {
        Unlock();
    }
}


//+----------------------------------------------------------------------------
//
//  CVolume::Search
//
//  Search the log for a move-notification (from droidCurrent).
//
//+----------------------------------------------------------------------------

BOOL
CVolume::Search( const CDomainRelativeObjId & droidCurrent, CDomainRelativeObjId * pdroidNew,
                 CMachineId *pmcidNew, CDomainRelativeObjId * pdroidBirth )
{
    BOOL fFound = FALSE;

    Lock();
    __try   // __finally
    {
        __try
        {
            // Perfbug:  Don't hold the log locked during the whole search such that
            // it locks out Appends.
            fFound = _cLog.Search( droidCurrent.GetObjId(), pdroidNew, pmcidNew, pdroidBirth );
        }
        __except( IsRecoverableDiskError( GetExceptionCode() )
                  ? EXCEPTION_EXECUTE_HANDLER
                  : EXCEPTION_CONTINUE_SEARCH )
        {
            // Try to recover from this error and retry the search.

            if( IsErrorDueToLockedVolume( GetExceptionCode() ))
            {
                CloseAndReopenVolumeHandles();  // Reopen might fail

                // Retry the search, which could raise again, but this time we won't catch it.
                fFound = _cLog.Search( droidCurrent.GetObjId(), pdroidNew, pmcidNew, pdroidBirth );
            }
            else
            {
                TrkAssert( TRK_E_CORRUPT_LOG == GetExceptionCode() );
                TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                                static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                                NULL );

                // The log is corrupted.  Re-initialize, and pass up the error.
                DeleteLogAndReInitializeVolume();
                TrkRaiseException( GetExceptionCode() );
            }
        }
    }
    __finally
    {
        Unlock();
    }

    return( fFound );
}


//+----------------------------------------------------------------------------
//
//  CVolume::Seek
//
//  Seek the log to a particular sequence number.
//
//+----------------------------------------------------------------------------

BOOL
CVolume::Seek( SequenceNumber seq )
{
    BOOL fSuccess = FALSE;

    Lock();
    __try
    {
        __try
        {
            fSuccess = _cLog.Seek( seq );
        }
        __except( IsRecoverableDiskError( GetExceptionCode() )
                  ? EXCEPTION_EXECUTE_HANDLER
                  : EXCEPTION_CONTINUE_SEARCH )
        {
            // Try to recover from this error and retry the seek.

            if( IsErrorDueToLockedVolume( GetExceptionCode() ))
            {
                CloseAndReopenVolumeHandles();  // Reopen might fail

                // Retry the Seek, which could raise again, but this time we won't catch it.
                fSuccess = _cLog.Seek( seq );
            }
            else
            {
                TrkAssert( TRK_E_CORRUPT_LOG == GetExceptionCode() );
                TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                                static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                                NULL );

                // The log is corrupted.  Re-initialize and pass up the error.
                DeleteLogAndReInitializeVolume();
                TrkRaiseException( GetExceptionCode() );
            }
        }
    }
    __finally
    {
        Unlock();
    }

    if( fSuccess )
        TrkLog(( TRKDBG_VOLUME, TEXT("Log on %c: sought to seq %d"),
                 VolChar(_iVol), seq ));
    else
        TrkLog(( TRKDBG_VOLUME, TEXT("Log on %c: couldn't be sought to seq %d"),
                 VolChar(_iVol), seq ));

    return( fSuccess );
}


//+----------------------------------------------------------------------------
//
//  CVolume::Seek
//
//  Seek to a relative (e.g. back up 2) or absolute (e.g. first) position.
//
//+----------------------------------------------------------------------------

void
CVolume::Seek( int origin, int iSeek )
{
    Lock();
    __try   // __finally
    {
        __try
        {
            _cLog.Seek( origin, iSeek );
        }
        __except( IsRecoverableDiskError( GetExceptionCode() )
                  ? EXCEPTION_EXECUTE_HANDLER
                  : EXCEPTION_CONTINUE_SEARCH )
        {
            // Attempt to recover from this error and retry the seek.

            if( IsErrorDueToLockedVolume( GetExceptionCode() ))
            {
                CloseAndReopenVolumeHandles();  // Reopen might fail

                // Retry the Seek, which could raise again, but this time we won't catch it.
                _cLog.Seek( origin, iSeek );
            }
            else
            {
                TrkAssert( TRK_E_CORRUPT_LOG == GetExceptionCode() );
                TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                                static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                                NULL );

                // The log is corrupted.  Re-initialize and pass up the error.
                DeleteLogAndReInitializeVolume();
                TrkRaiseException( GetExceptionCode() );
            }
        }
    }
    __finally
    {
        Unlock();
    }

}




//+----------------------------------------------------------------------------
//
//  CVolume::GetVolumeId
//
//  Get the volume ID without taking the lock.  This was done
//  so that CVolumeManager::IsDuplicateID can check the volid
//  of other volumes without deadlocking.  Otherwise we run the
//  risk of one volume holding its locks and trying to get
//  another volume's lock (using GetVolumeId on that volume)
//  while another thread is in that volume doing the same for
//  this volume.
//
//+----------------------------------------------------------------------------

const CVolumeId
CVolume::GetVolumeId()
{
    CVolumeId       volid;
    ULONG           cAttempts = 0;

    // Spin until we get a good volid.

    while( TRUE )
    {
        // Get the update counter before and after reading
        // from the volid.  (This assumes that
        // reading the long is atomic.)

        LONG lVolidUpdatesBefore = _lVolidUpdates;

        volid = _volinfo.volid;

        LONG lVolidUpdatesAfter = _lVolidUpdates;

        // When the _volinfo is updated, the _lVolidUpdates is
        // incremented before and after the update.  So if there
        // was an update in progress when we started, it will
        // be an odd number.
        //
        // Ensure there was no update in progress when we read
        // the volid, and there was no update started while we
        // were reading the volid.


        if( (lVolidUpdatesBefore & 1)
            ||
            lVolidUpdatesBefore != lVolidUpdatesAfter )
        {
            // Check for timeout (30 seconds)
            if( 3000 < ++cAttempts )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Failed spin in GetVolumeId") ));
                TrkRaiseWin32Error( WAIT_TIMEOUT );
            }

            // Wait for the update to complete then try again.
            Sleep( 10 );
            continue;
        }
        else
            break;
    }

    return( volid );
}



//+----------------------------------------------------------------------------
//
//  CVolume::GetState
//
//  Get the current state of this volume (owned, not-owned, or not-created).
//
//+----------------------------------------------------------------------------

CVolume::CVOL_STATE
CVolume::GetState()
{
    CVolumeId       volNULL;
    CVOL_STATE      state = VOL_STATE_UNKNOWN;

    Lock();
    __try
    {

        if( _volinfo.fNotCreated )
        {
            state = VOL_STATE_NOTCREATED;
        }

        // If the time we entered the not-owned state is non-zero, then
        // we're certainly in the not-owned state.  Also, if the machine ID
        // in the _volinfo header doesn't match the local machine, we're
        // not owned.

        else if(_volinfo.cftEnterNotOwned != 0
                ||
                _volinfo.machine != CMachineId(MCID_LOCAL)
               )
        {
            // Is this the first time that we realized we're not owned?
            if( !IsWriteProtectedVolume() && 0 == _volinfo.cftEnterNotOwned )
            {
                _volinfo.cftEnterNotOwned.SetToUTC();
                _fDirty = TRUE;
                Flush();
            }

            state = VOL_STATE_NOTOWNED;
        }

        // Otherwise, we must be properly owned.

        else
        {
            state = VOL_STATE_OWNED;
        }
    }
    __finally
    {
        Unlock();
    }

    return state;
}


//+----------------------------------------------------------------------------
//
//  CVolume::SetState
//
//  Change the current state of the volume.  This checks for valid transitions.
//  For example, you can't transition from not-created to not-owned (such
//  a request is silently ignored).  This alleviates the caller from having
//  to perform this logic.
//
//+----------------------------------------------------------------------------

void
CVolume::SetState(CVOL_STATE volstateTarget)
{
    CVOL_STATE  volstateCurrent = GetState();
    NTSTATUS    status = STATUS_SUCCESS;
    VolumePersistentInfo volinfoNew = _volinfo;
    BOOL fDirtyNew = _fDirty;

    // Make sure the volume is writeable
    RaiseIfWriteProtectedVolume();

    Lock();
    __try
    {
        switch( volstateTarget )
        {

        case VOL_STATE_NOTOWNED:

            // We can only go to not-owned from owned.

            if( VOL_STATE_OWNED == volstateCurrent )
            {
                TrkAssert( !volinfoNew.fNotCreated );
                TrkLog(( TRKDBG_VOLUME, TEXT("Entering not-owned state on vol %c:"), VolChar(_iVol) ));

                RaiseIfWriteProtectedVolume();
                fDirtyNew = TRUE;
                volinfoNew.cftEnterNotOwned.SetToUTC();
            }
            break;

        case VOL_STATE_NOTCREATED:

            // We can always go to not-created.

            if( volstateCurrent != VOL_STATE_NOTCREATED )
            {
                TrkLog(( TRKDBG_VOLUME, TEXT("Entering not-created state on vol %c:"), VolChar(_iVol) ));

                RaiseIfWriteProtectedVolume();
                fDirtyNew = TRUE;
                volinfoNew.fNotCreated = TRUE;
                volinfoNew.cftEnterNotOwned = CFILETIME(0);
            }

            break;

        case VOL_STATE_OWNED:

            if( VOL_STATE_NOTCREATED == volstateCurrent )
            {
                // We're going from not-created to owned, so we need to make
                // all our OIDs reborn.

                TrkLog(( TRKDBG_VOLUME, TEXT("Entering owned state (from not-created) on vol %c:"), VolChar(_iVol) ));

                RaiseIfWriteProtectedVolume();
                fDirtyNew = TRUE;
                volinfoNew.fNotCreated = FALSE;
                TrkAssert( CFILETIME(0) == volinfoNew.cftEnterNotOwned );

                // Since we now have a new volid, we must give all the existing
                // files new object IDs.

                //MarkForMakeAllOidsReborn();
                volinfoNew.fDoMakeAllOidsReborn = TRUE;
            }
            else if( VOL_STATE_NOTOWNED == volstateCurrent )
            {
                // We're going from not-owned to owned.

                TrkLog(( TRKDBG_VOLUME, TEXT("Entering owned state (from not-owned) on vol %c:"), VolChar(_iVol) ));
                TrkAssert( !volinfoNew.fNotCreated );

                RaiseIfWriteProtectedVolume();
                fDirtyNew = TRUE;
                volinfoNew.cftEnterNotOwned = CFILETIME(0);
            }

            TrkAssert( CVolumeId() != _volinfo.volid );
            break;

        default:
            TrkAssert( !TEXT("Bad target state in CVolume::SetState") );

        }   // switch( volstateTarget )

        // If we modified the volinfo, write it back out.

        _volinfo = volinfoNew;
        _fDirty |= fDirtyNew;

        Flush();

    }
    __finally
    {
        Unlock();
    }

    return;

}


//+----------------------------------------------------------------------------
//
//  CVolume::NotOwnedExpired
//
//  Have we been in the not-owned state for long enough that we should be
//  in the not-created state?
//
//+----------------------------------------------------------------------------

BOOL
CVolume::NotOwnedExpired()
{
    Lock();
    __try
    {
        if(_volinfo.cftEnterNotOwned != 0)
        {
            CFILETIME   cftDiff = CFILETIME() - _volinfo.cftEnterNotOwned;
            ULONG SecondsDiff = static_cast<ULONG>((LONGLONG)cftDiff/10000000);

            if(SecondsDiff > _pTrkWksConfiguration->GetVolNotOwnedExpireLimit())
            {
                return TRUE;
            }
        }
    }
    __finally
    {
        Unlock();
    }

    return FALSE;
}



//+----------------------------------------------------------------------------
//
//  CVolume::MakeAllOidsReborn
//
//  Reset (zero out) the birth IDs (actually, all 48 extended bytes) of
//  all the files on this volume.  That makes the file no longer a link source,
//  so we won't try to track it.  If someone subsequently makes a link
//  to it, NTFS will fill in a new birth ID.
//
//+----------------------------------------------------------------------------

BOOL
CVolume::MakeAllOidsReborn()
{
    CObjIdEnumerator        oie;
    BOOL                    fSuccess = FALSE;
    CObjId                  objid;
    CDomainRelativeObjId    droidBirth;
    NTSTATUS                status;
    CVolumeId               vidNull;
    BOOL                    fLocked = FALSE;

    __try
    {
        // Give all the files with object IDs a fresh birth ID, as if the
        // file had first been linked to on this volume.

        TrkLog(( TRKDBG_VOLUME, TEXT("Making OIDs reborn on volume %c:"), VolChar(_iVol) ));

        if(oie.Initialize(_tszVolumeDeviceName))
        {
            if(oie.FindFirst(&objid, &droidBirth))
            {
                do
                {
                    g_ptrkwks->RaiseIfStopped();

                    // If this has what looks like an invalid birth ID, ignore it.

                    if( CObjId() == droidBirth.GetObjId() )
                        continue;

                    // We only take the lock directly around the make-reborn
                    // call, since with the sleep below we could be in this routine
                    // for a while.

                    Lock();   fLocked = TRUE;
                    TrkAssert( 1 == _cLocks );
                    MakeObjIdReborn( _tszVolumeDeviceName, objid );
                    Unlock(); fLocked = FALSE;

                    Sleep( 100 );   // don't hog the machine
                } while(oie.FindNext(&objid, &droidBirth));
            }
        }
    }
    __except( BreakOnDebuggableException() )
    {
        __try
        {
            if( TRK_E_CORRUPT_LOG == GetExceptionCode() )
            {
                TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                                static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                                NULL );
                BreakIfRequested();
                DeleteLogAndReInitializeVolume();
            }
            else if( IsErrorDueToLockedVolume( GetExceptionCode() ))
            {
                CloseAndReopenVolumeHandles();
                TrkRaiseException( GetExceptionCode() );
            }

            TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception in CVolume::MakeAllOidsReborn for %c: %08x"),
                     VolChar(_iVol), GetExceptionCode() ));
        }
        __finally
        {
            if( fLocked )
                Unlock();
        }

        goto Exit;
    }


    fSuccess = TRUE;

Exit:

    oie.UnInitialize();

    if(!fSuccess)
    {
        TrkLog((TRKDBG_ERROR,
                TEXT("Can't delete all object ids on volume %c:"),
                VolChar(_iVol)  ));
    }

    return fSuccess;
}





//+----------------------------------------------------------------------------
//
//  CVolume::OnHandlesMustClose
//
//  This routine is called from CLogFile if it discovers that the log file
//  needs to be closed (an oplock break).  We close all handles on the volume
//  and start the reopen timer.
//
//+----------------------------------------------------------------------------

void
CVolume::OnHandlesMustClose()
{
    CloseVolumeHandles();   // Doesn't raise
    g_ptrkwks->SetReopenVolumeHandlesTimer();
}





//+----------------------------------------------------------------------------
//
//  CVolume::FileActionIdNotTunnelled
//
//  This method is called as an event notification, indicating that NTFS has
//  notified us that a file could not be tunnelled.  We do the tunnelling manually
//  here.
//
//+----------------------------------------------------------------------------

#define ON_NOT_TUNNELLED_DELAY   500 // .5 seconds

void
CVolume::FileActionIdNotTunnelled( FILE_OBJECTID_INFORMATION * poi )
{
    ULONG  ulMillisecondsSleptSoFar = 0;
    HANDLE hFile = NULL;

    // We don't take the volume lock here.  So don't attempt to
    // do anything other than simple I/O.  We don't take the lock because
    // we want to ensure that tunnelling is resolved quickly without
    // getting blocked.

    //
    // Open the file being "tunnelled from" by OBJECTID
    // Delete the object id
    // Close
    // Open the file being "tunnelled to" by FileReference
    // Set the object id and extra data
    // Close

    // Test hook
    IFDBG( _pTunnelTest->ReleaseAndWait() );

    __try
    {
        if (_hVolume == NULL)
        {
            // Couldn't reopen the volume
            __leave;
        }

        NTSTATUS            Status;

        OBJECT_ATTRIBUTES   oa;
        UNICODE_STRING      uId;
        IO_STATUS_BLOCK     ios;
        CObjId              objid( FOI_OBJECTID, *poi );
        int                 i;

        // Ignore if this isn't a link tracking (e.g. it's an NTFRS) object ID.

        if( CObjId() == CObjId(FOI_BIRTHID, *poi) )
        {
            TrkLog(( TRKDBG_VOLUME, TEXT("Ignoring not-tunneled notification for %s"),
                     (const TCHAR*)CDebugString( objid ) ));
            __leave;
        }

        uId.Length = sizeof(poi->ObjectId);
        uId.MaximumLength = sizeof(poi->ObjectId);
        uId.Buffer = (PWSTR) poi->ObjectId;

        InitializeObjectAttributes( &oa, &uId, OBJ_CASE_INSENSITIVE, _hVolume, NULL );

        //  -----------------
        //  Open the old file
        //  -----------------

        // Some kind of write access, along with restore privelege, is required
        // for set/delete OID calls.

        EnableRestorePrivilege();
        Status = NtCreateFile(
                    &hFile,
                    SYNCHRONIZE | FILE_WRITE_ATTRIBUTES,
                    &oa,
                    &ios,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN,
                    FILE_OPEN_BY_FILE_ID | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_NO_RECALL
                        | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

        //  ------------------------------
        //  Delete the OID on the old file
        //  ------------------------------

        if (NT_SUCCESS(Status))
        {
            Status = NtFsControlFile(
                     hFile,
                     NULL,
                     NULL,
                     NULL,
                     &ios,
                     FSCTL_DELETE_OBJECT_ID,
                     NULL,  // in buffer
                     0,     // in buffer size
                     NULL,  // Out buffer
                     0);    // Out buffer size

            NtClose( hFile );
            hFile = NULL;

            if (NT_SUCCESS(Status))
            {
                TrkLog((TRKDBG_TUNNEL, TEXT("Tunnelling objid %s - deleted from old file"),
                        (const TCHAR*)CDebugString(objid) ));
            }
            else
            {
                TrkLog((TRKDBG_TUNNEL, TEXT("Tunnelling objid %c:%s - couldn't FSCTL_DELETE_OBJECT_ID ntstatus=%08x"),
                        VolChar(_iVol),
                        (const TCHAR*)CDebugString(objid),
                        Status ));
            }
        }   // if (NT_SUCCESS(Status))

        else
        {
            // We couldn't open the old file, so we'll ignore it and try to set the
            // object ID.
            TrkLog((TRKDBG_TUNNEL, TEXT("Tunnelling objid %c:%s - couldn't open old file %08x"),
                    VolChar(_iVol),
                    (const TCHAR*)CDebugString(objid),
                    Status));
        }

        if( Status == STATUS_INVALID_DEVICE_REQUEST ||
            IsErrorDueToLockedVolume( Status ) )
        {
            // If we get STATUS_INVALID_DEVICE_REQUEST, then _hVolume is
            // broken.

            CloseVolumeHandles();
            g_ptrkwks->SetReopenVolumeHandlesTimer();
            __leave;
        }

        //  -----------------
        //  Open the new file
        //  -----------------

        uId.Length = sizeof(poi->FileReference);
        uId.MaximumLength = sizeof(poi->FileReference);
        uId.Buffer = (PWSTR) &poi->FileReference;

        Status = NtCreateFile(
                     &hFile,
                     SYNCHRONIZE | FILE_WRITE_ATTRIBUTES,
                     &oa,
                     &ios,
                     NULL,
                     FILE_ATTRIBUTE_NORMAL,
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     FILE_OPEN,
                     FILE_OPEN_BY_FILE_ID | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_NO_RECALL
                        | FILE_SYNCHRONOUS_IO_NONALERT,
                     NULL,
                     0 );

        //  ---------------------------
        //  Set the OID on the new file
        //  ---------------------------

        if (NT_SUCCESS(Status))
        {
            Status = NtFsControlFile(
                         hFile,
                         NULL,
                         NULL,
                         NULL,
                         &ios,
                         FSCTL_SET_OBJECT_ID,
                         poi->ObjectId,
                         sizeof(FILE_OBJECTID_BUFFER),
                         NULL,  // Out buffer
                         0);    // Out buffer size
            NtClose(hFile);
            hFile = NULL;

            TrkLog((TRKDBG_TUNNEL, TEXT("Tunnelling objid %s: FSCTL_SET_OBJECT_ID %s %08x"),
                    (const TCHAR*)CDebugString(objid),
                    NT_SUCCESS(Status) ? TEXT("succeeded") : TEXT("failed"),
                    Status ));
        }
        else
        {
            TrkLog((TRKDBG_TUNNEL, TEXT("Tunnelling objid %c:%s - couldn't OpenByFileReference ntstatus=%08x"),
                    VolChar(_iVol),
                    (const TCHAR*)CDebugString(objid),
                    Status ));
        }

        if(Status == STATUS_INVALID_DEVICE_REQUEST ||
           IsErrorDueToLockedVolume( Status ) )
        {
            // If we get STATUS_INVALID_DEVICE_REQUEST, then _hVolume is
            // broken.

            CloseVolumeHandles();
            g_ptrkwks->SetReopenVolumeHandlesTimer();
            __leave;
        }

    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Exception %08x in CVolume::FileActionIdNotTunnelled"),
                 GetExceptionCode() ));
    }

    if( NULL != hFile )
        NtClose( hFile );


    return;
}





//+----------------------------------------------------------------------------
//
//  CVolume::NotifyAddOrDelete
//
//  This method is called as an event notification, indicating that NTFS has
//  notified us that the volume ID has been modified.  We use this to ensure
//  the volume ID doesn't get incorrectly modified.
//
//  If you watch the object ID notification queue while someone sets the
//  volume ID directly in NTFS, you'll see:
//  *   a remove of the old ID (setting a new ID shows up as a remove/add),
//  *   an add of the bogus ID,
//  *   a remove of the bogus ID (part of the SetVolid that we do in this routine),
//  *   an add of the correct ID.
//
//+----------------------------------------------------------------------------


void
CVolume::NotifyAddOrDelete( ULONG Action, const CObjId & objid )
{
    // Not supported
    return;
}

//+----------------------------------------------------------------------------
//
//  CVolume::LoadVolInfo
//
//  Load the _volinfo member from the log.
//
//+----------------------------------------------------------------------------

void
CVolume::LoadVolInfo()
{
    AssertLocked();
    TrkAssert( CVOLUME_HEADER_LENGTH == sizeof(_volinfo) );

    // Read _volinfo from the extended header portion of the log.

    __try
    {
        _cLogFile.ReadExtendedHeader( CVOLUME_HEADER_START, &_volinfo, sizeof(_volinfo) );
    }
    __except( IsRecoverableDiskError( GetExceptionCode() )
              ? EXCEPTION_EXECUTE_HANDLER
              : EXCEPTION_CONTINUE_SEARCH )
    {
        // Attempt to recover from this error and retry the read.

        if( IsErrorDueToLockedVolume( GetExceptionCode() ))
        {
            CloseAndReopenVolumeHandles();
            _cLogFile.ReadExtendedHeader( CVOLUME_HEADER_START, &_volinfo, sizeof(_volinfo) );
        }
        else
        {
            TrkAssert( TRK_E_CORRUPT_LOG == GetExceptionCode() );
            TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                            static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                            NULL );
            DeleteLogAndReInitializeVolume();
        }
    }
}


//+----------------------------------------------------------------------------
//
//  CVolume::SaveVolInfo
//
//  Write the _volinfo structure to the extended header portion of the log.
//  Clear _fDirty if successful.
//
//+----------------------------------------------------------------------------

void
CVolume::SaveVolInfo( )
{
    AssertLocked();

    __try
    {
        _cLogFile.WriteExtendedHeader( CVOLUME_HEADER_START, &_volinfo, sizeof(_volinfo) );
        _fDirty = FALSE;
    }
    __except( IsRecoverableDiskError( GetExceptionCode() )
              ? EXCEPTION_EXECUTE_HANDLER
              : EXCEPTION_CONTINUE_SEARCH )
    {
        // Attempt to recover from this error and retry the write.

        if( IsErrorDueToLockedVolume( GetExceptionCode() ) )
        {
            CloseAndReopenVolumeHandles();
            _cLogFile.WriteExtendedHeader( CVOLUME_HEADER_START, &_volinfo, sizeof(_volinfo) );
            _fDirty = FALSE;
        }
        else
        {
            TrkAssert( TRK_E_CORRUPT_LOG == GetExceptionCode() );
            TrkReportEvent( EVENT_TRK_SERVICE_CORRUPT_LOG, EVENTLOG_ERROR_TYPE,
                            static_cast<const TCHAR*>( CStringize( VolChar(_iVol) )),
                            NULL );
            DeleteLogAndReInitializeVolume();
        }
    }

}




//+----------------------------------------------------------------------------
//
//  CVolume::CloseVolumeHandles
//
//  This method close all handle that this object maintains on the volume.
//  This will allow e.g. format or chkdsk /f to run successfully.
//  We don't take the volume critsec, so we're guaranteed to run quickly
//  and not block.
//
//+----------------------------------------------------------------------------

void
CVolume::CloseVolumeHandles( HDEVNOTIFY hdnVolume, EHandleChangeReason eHandleChangeReason )
{
    HANDLE hVolToClose = NULL;

    // This routine never raises

    // Is this notification intended for everyone, or specifically
    // for us?
    if( hdnVolume != NULL && hdnVolume != _hdnVolumeLock )
        // No, it's just for another volume.
        return;

    // Are we already in a CloseVolumeHandles somewhere?
    // If so, there's no need to continue, and worse yet if we were
    // to continue we could deadlock (scenario:  one thread is in 
    // _cLogFile.Close below unregistering the oplock wait, which is
    // blocking, and another thread is executing an oplock break).

    if( !BeginSingleInstanceTask( &_cCloseVolumeHandlesInProgress ) )
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("Skipping CloseVolumeHandles, another instance already in progress") ));
        return;
    }


    // We don't want this method to take the normal _csVolume lock, because
    // we're called from threads that must not block (such as the service control handler
    // thread).  So we just take the limited lock that's used in this method
    // and in ReopenVolumeHandles.

    LockHandles();
    __try
    {
        BOOL fAlreadyLockedOrDismounted = _fVolumeLocked || _fVolumeDismounted;

        TrkLog(( TRKDBG_WARNING, TEXT("Closing volume handles on %c:"), VolChar(_iVol) ));

        // If this notification is specifically for us, then remember
        // if we're locked/dismounted.

        if( hdnVolume != NULL )
        {
            if( VOLUME_LOCK_CHANGE == eHandleChangeReason )
                _fVolumeLocked = TRUE;
            else if( VOLUME_MOUNT_CHANGE == eHandleChangeReason )
                _fVolumeDismounted = TRUE;
        }

        // Is this volume already locked or dismounted?
        if( fAlreadyLockedOrDismounted )
        {
            TrkAssert( NULL == _hVolume );
            __leave;
        }

        // Close the object ID index directory handle.

        _ObjIdIndexChangeNotifier.StopListeningAndClose();

        // Close the log.

        _cLogFile.Close();  // Doesn't raise

        // Prepare to close the volume handle.

        if (_hVolume != NULL)
        {
            hVolToClose = _hVolume;
            _hVolume = NULL;
        }

        TrkLog((TRKDBG_VOLUME, TEXT("Volume %c: closed"), VolChar(_iVol)));
    }

    __except( EXCEPTION_EXECUTE_HANDLER ) // BreakThenReturn( EXCEPTION_EXECUTE_HANDLER ))
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring unexpected exception in CVolume::CloseVolumeHandles (%08x)"),
                 GetExceptionCode() ));
    }

    UnlockHandles();
    EndSingleInstanceTask( &_cCloseVolumeHandlesInProgress );

    if( NULL != hVolToClose )
    {
        NtClose( hVolToClose );
        TrkLog((TRKDBG_VOLUME, TEXT("(Volume %c: fully closed)"), VolChar(_iVol)));
    }

}



//+----------------------------------------------------------------------------
//
//  CVolume::ReopenVolumeHandles
//
//  Reopen the handles that we maintain on the volume.  This is synchronized
//  with CloseVolumeHandles using the handle critsec.  This method does
//  nothing if the volume is locked (as indicated by _fVolumeLocked),
//  or if the volume handles are already opened.
//
//+----------------------------------------------------------------------------

BOOL
CVolume::ReopenVolumeHandles()
{
    NTSTATUS    status;
    BOOL        fHandlesLocked = FALSE;
    BOOL        fHandlesOpen = FALSE;
    BOOL        fReopenedLog = FALSE;
    BOOL        fStartedListening = FALSE;


    // Don't open if the service is stopping.
    g_ptrkwks->RaiseIfStopped();

    TrkLog(( TRKDBG_WARNING, TEXT("\nReopenVolumeHandles called on %c:"), VolChar(_iVol) ));

    // This method must acquire the _csVolumes critical section like every other
    // public method (via the Lock call).  It must also acquire the _csHandles
    // lock, in order to coordinate with the CloseVolumeHandles and SetUnlockVolume
    // methods, which have special needs.

    Lock();
    __try
    {
        LockHandles(); fHandlesLocked = TRUE;
        
        // Are we supposed to reopen?
        if( IsHandsOffVolumeMode() )
        {
            // Don't open yet, wait until we get an UnLock notification.
            TrkLog(( TRKDBG_VOLUME, TEXT("Didn't open handles on %c:, it's %s"),
                     VolChar(_iVol),
                     _fVolumeLocked
                        ? ( _fVolumeDismounted ? TEXT("locked & dismounted") : TEXT("locked") )
                        : TEXT("dismounted") ));
            __leave;
        }

        // Open the main volume handle.
        if( NULL == _hVolume )
        {
            status = OpenVolume(_tszVolumeDeviceName, &_hVolume);
            if(!NT_SUCCESS(status))
            {
                if( STATUS_OBJECT_NAME_NOT_FOUND == status )
                {
                    TrkLog(( TRKDBG_VOLUME, TEXT("Volume not found in ReopenVolumeHandles, deleting CVolume") ));
                    MarkSelfForDelete();
                }

                TrkRaiseNtStatus(status);
            }
        }


        // Start listening for objid index change notifications
        __try
        {
            fStartedListening = _ObjIdIndexChangeNotifier.AsyncListen( );
        }
        __except( BreakOnDebuggableException() )
        {
            // We should never get a path-not-found error, because meta-files always exist
            // on a good NTFS5 volume.  If we get one, it's probably because an NTFS5
            // volume has been reformatted as a FAT volume.

            HRESULT hr = GetExceptionCode();
            if( HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr )
            {
                TrkLog(( TRKDBG_VOLUME, TEXT("ObjId Index not found in ReopenVolumeHandles, deleting CVolume") ));
                MarkSelfForDelete();
            }

            TrkRaiseException( hr );

        }

        // Register for PNP notifications.  We don't hold the handle lock because this
        // call can take a while, and we don't want to block the service control
        // handler thread from doing a CloseVolumeHandles.

        if( fStartedListening )
        {

#if DBG
            TrkVerify( 0 == UnlockHandles() );
#else
            UnlockHandles();
#endif
            fHandlesLocked = FALSE;
            RegisterPnPVolumeNotification();
            LockHandles(); fHandlesLocked = TRUE;
        }

        // If CloseVolumeHandles came in after we released the handle lock just now,
        // then abort.

        if( NULL == _hVolume )
        {
            TrkLog(( TRKDBG_VOLUME, TEXT("Aborting ReopenVolumeHandles") ));
            TrkRaiseException( E_FAIL );
        }

        // Open the log

        if( !_cLogFile.IsOpen() )
        {
            for( int i = 0; i < 2; i++ )
            {
                __try
                {
                    _cLogFile.Initialize( _tszVolumeDeviceName, _pTrkWksConfiguration, this, VolChar(_iVol) );
                    _cLog.Initialize( _pLogCallback, _pTrkWksConfiguration, &_cLogFile );
                }
                __except( (0 == i && TRK_E_CORRUPT_LOG == GetExceptionCode())
                          ? EXCEPTION_EXECUTE_HANDLER
                          : EXCEPTION_CONTINUE_SEARCH )
                {
                    BreakIfRequested();

                    // Get rid of the corrupt file
                    _cLogFile.Delete();

                    // Loop back and try again.
                    continue;
                }
                break;
            }

            fReopenedLog = TRUE;
        }

        // If we've never read in the volinfo, do so now.

        if( !_fVolInfoInitialized )
        {
            LoadVolInfo();
            _fVolInfoInitialized = TRUE;
            TrkLog(( TRKDBG_VOLUME, TEXT("VolId (from log file) for %c: is %s"),
                     VolChar(_iVol), (const TCHAR*)CDebugString(_volinfo.volid) ));
        }




        if( fReopenedLog )
        {
            // Reconcile our volinfo with the log.
            // BUGBUG (removable media): We haven't re-read the volinfo out of the log, we're still
            // using what we already had in memory.  This won't work for removeable
            // media, so we need to add some extra checking here.

            VolumeSanityCheck();

            // Start the move notify timer; we may have been trying to send
            // notifies when we discovered that the volume handles were bad.

            g_ptrkwks->OnEntriesAvailable();
        }

        TrkLog((TRKDBG_VOLUME, TEXT("Volume %c open"), VolChar(_iVol)));
        fHandlesOpen = TRUE;
    }
    __finally
    {
//        __try
        {
            // We either open everything, or open nothing
            if( AbnormalTermination() )
            {
                CloseVolumeHandles();
                g_ptrkwks->SetReopenVolumeHandlesTimer();   // Try again later
            }
        }
//        __finally
        {
            if( fHandlesLocked )
                UnlockHandles();

            Unlock();
        }
    }

    return( fHandlesOpen );
}


//+----------------------------------------------------------------------------
//
//  CVolume::CloseAndReopenVolumeHandles
//
//  One or more of the handles maintained on the volume are bad (for example,
//  the handle may have been broken by a dismount).  Close all of them, and
//  attempt to reopen new ones.
//
//+----------------------------------------------------------------------------

void
CVolume::CloseAndReopenVolumeHandles()
{

    Lock();

    __try
    {
        // There's the remote possibility that the ReopenVolumeHandles
        // call below will call this routine.  Just to be paranoid, we
        // add protection against an infinite recursion.

        if( _fCloseAndReopenVolumeHandles )
            TrkRaiseWin32Error( ERROR_OPEN_FAILED );
        _fCloseAndReopenVolumeHandles = TRUE;

        // Close then reopen the handles

        CloseVolumeHandles();
        ReopenVolumeHandles();
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog((TRKDBG_VOLUME, TEXT("Immediate reopen of volume handle failed, set the reopen timer")));
        g_ptrkwks->SetReopenVolumeHandlesTimer();
    }

    _fCloseAndReopenVolumeHandles = FALSE;
    Unlock();
}



//+----------------------------------------------------------------------------
//
//  CVolume::PrepareToReopenVolumeHandles
//
//  The handles to the volume were closed at some point, but they may now
//  be reopened.  Call CVolumeManager::OnVolumeToBeReopened, so that it can
//  call us in ReopenVolumeHandles on a worker thread (right now we're on
//  the services handler thread, which is shared by all of services.exe).
//
//+----------------------------------------------------------------------------

void
CVolume::PrepareToReopenVolumeHandles( HDEVNOTIFY hdnVolume, EHandleChangeReason eHandleChangeReason )
{
    // It is important that this method does not take any lock.
    // This method is called during the volume unlock notification
    // that we receive in CTrkWksSvc::ServiceHandler, and we can
    // never allow that thread to hang.
    // Fortunately, the flags touched in this routine are only
    // touched in a single-threaded manner, because they're only 
    // touched as a result of a message from the service controller,
    // for which there's a single thread in the process.

    __try
    {
        if( _hdnVolumeLock == hdnVolume )
        {
            if( VOLUME_LOCK_CHANGE == eHandleChangeReason )
                _fVolumeLocked = FALSE;
            else if( VOLUME_MOUNT_CHANGE == eHandleChangeReason )
                _fVolumeDismounted = FALSE;

            if( !_fVolumeLocked && !_fVolumeDismounted )
            {
                TrkLog(( TRKDBG_VOLUME, TEXT("Volume %c: is to be reopened"), VolChar(_iVol) ));
                _pVolMgr->OnVolumeToBeReopened();
            }
        }
    }
    __finally
    {
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\utest\tbackup.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       tbackup.cxx
//
//  Contents:   testing backup read/write
//
//  History:    1-Aug-97  weiruc      Created.
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define TRKDATA_ALLOCATE
#include <trkwks.hxx>
#include <cfiletim.hxx>
#include <ocidl.h>

// DWORD g_Debug = TRKDBG_ERROR;

#define BUFFERSIZE      1000

EXTERN_C void __cdecl _tmain(int argc, TCHAR **argv)
{ 
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    HANDLE      hBackupFile = INVALID_HANDLE_VALUE;
    BYTE        rgbBuffer[BUFFERSIZE];
    DWORD       dwBytesRead = 0;
    DWORD       dwBytesWritten = 0;
    LPVOID      pReadContext = NULL;
    LPVOID      pWriteContext = NULL;
    BOOL        fReadSuccessful = TRUE;

    if(argc != 3)
    {
        _tprintf(TEXT("usage: %s <testfile> <backupfile>\n"), argv[0]);
        goto Exit;
    }

    EnablePrivilege( SE_RESTORE_NAME );

    // open test file
    hFile = CreateFile(argv[1],
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if(INVALID_HANDLE_VALUE == hFile)
    {
        _tprintf(TEXT("Can't open (%s), %08x\n"), argv[1], GetLastError());
        goto Exit;
    }

    // open backup file
    hBackupFile = CreateFile(argv[2],
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             CREATE_NEW,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS,
                             NULL);
    if(INVALID_HANDLE_VALUE == hBackupFile)
    {
        _tprintf(TEXT("Can't open (%s), %08x\n"), argv[2], GetLastError());
        goto Exit;
    }

    // All we are doing is to backup read a file and backup write the file to
    // a different file. We are assuming the file is smaller than the
    // BUFFERSIZE.
    while(TRUE)
    {
        if(!BackupRead(hFile,
                       rgbBuffer,
                       BUFFERSIZE,
                       &dwBytesRead,
                       FALSE,
                       FALSE,
                       &pReadContext))
        {
            _tprintf(TEXT("BackupRead failed, %08x\n"), GetLastError());
            break;
        }
        else
        {
            _tprintf(TEXT("    %d bytes read\n"), dwBytesRead);
        }
        if(0 == dwBytesRead)
        {
            break;
        }
        if(!BackupWrite(hBackupFile,
                        rgbBuffer,
                        dwBytesRead,
                        &dwBytesWritten,
                        FALSE,
                        FALSE,
                        &pWriteContext))
        {
            _tprintf(TEXT("BackupWrite failed, %08x\n"), GetLastError());
            break;
        }
        else
        {
            _tprintf(TEXT("    %d bytes wrote\n"), dwBytesWritten);
        }
    }

    // Deallocate data structures used by BackupRead/Write.
    if(!BackupRead(hFile,
                   rgbBuffer,
                   BUFFERSIZE,
                   &dwBytesRead,
                   TRUE,
                   TRUE,
                   &pReadContext))
    {
        _tprintf(TEXT("Last BackupRead failed, %08x\n"), GetLastError());
    }
    if(!BackupWrite(hBackupFile,
                    rgbBuffer,
                    dwBytesRead,
                    &dwBytesWritten,
                    TRUE,
                    TRUE,
                    &pWriteContext))
    {
        _tprintf(TEXT("Last BackupWrite failed, %08x\n"), GetLastError());
    }

Exit:

    if(INVALID_HANDLE_VALUE != hFile)
    {
        if(!CloseHandle(hFile))
        {
            _tprintf(TEXT("Can't close (%s), %08x\n"), argv[1], GetLastError());
        }
    }
    if(INVALID_HANDLE_VALUE != hBackupFile)
    {
        if(!CloseHandle(hBackupFile))
        {
            _tprintf(TEXT("Can't close (%s), %08x\n"), argv[2], GetLastError());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\volmgr.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  volmgr.cxx
//
//  This file implements the CVolumeManager class.  That class maintains
//  a list of CVolume objects.
//
//+============================================================================

#include <pch.cxx>
#pragma hdrstop
#include "trkwks.hxx"
#include <dbt.h>

#define THIS_FILE_NUMBER    VOLMGR_CXX_FILE_NO


void
CVolumeManager::Initialize(CTrkWksSvc * pTrkWks,
                        const CTrkWksConfiguration *pTrkWksConfiguration,
                        PLogCallback * pLogCallback,
                        SERVICE_STATUS_HANDLE ssh
                        #if DBG
                        , CTestSync * pTunnelTest
                        #endif
                        )
{
    BOOL fReg = FALSE;
    HKEY hKey;
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING name;
    CSystemSD ssd;
    NTSTATUS Status;

    TrkLog(( TRKDBG_VOLUME, TEXT("Initializing the volume list") ));

    TrkAssert( !_fInitialized );

    _csVolumeNodeList.Initialize();
    _fInitialized = TRUE;

    _pTrkWks = pTrkWks;
    _pTrkWksConfiguration = pTrkWksConfiguration;
    _pVolumeNodeListHead = NULL;

    __try
    {
        // This timer is started when we unexpectedly lose our volume handles.
        // When it fires, we try to reopen them.  After a number of such retries,
        // we give up and stop the timer.

        _timerObjIdIndexReopen.Initialize(
            this,
            NULL,                           // No name (non-persistent timer)
            VOLTIMER_OBJID_INDEX_REOPEN,    // Context ID
            pTrkWksConfiguration->GetObjIdIndexReopen(),
            CNewTimer::RETRY_WITH_BACKOFF,
            pTrkWksConfiguration->GetObjIdIndexReopenRetryMin(),
            pTrkWksConfiguration->GetObjIdIndexReopenRetryMax(),
            pTrkWksConfiguration->GetObjIdIndexReopenLifetime()
            );

        // Create and register an event that we'll signal when a volume has been unlocked.
        // We have to run this on an IO thread so that the logfile oplock and
        // ReadDirectoryChanges on the objid index will work.

        _heventVolumeToBeReopened = CreateEvent( NULL, FALSE, FALSE, NULL );
        if( NULL == _heventVolumeToBeReopened )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't create _hVolumeUnlockEvent") ));
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, HRESULT_FROM_WIN32(GetLastError()),
                                    NULL );
            TrkRaiseWin32Error( GetLastError() );
        }

        _hRegisterWaitForSingleObjectEx
            = TrkRegisterWaitForSingleObjectEx( _heventVolumeToBeReopened, ThreadPoolCallbackFunction,
                                                static_cast<PWorkItem*>(this), INFINITE,
                                                WT_EXECUTEINIOTHREAD | WT_EXECUTELONGFUNCTION );

        if( NULL == _hRegisterWaitForSingleObjectEx )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Failed RegisterWaitForSingleObjectEx in CVolumeManager::Initialize (%lu)"),
                     GetLastError() ));
            TrkRaiseLastError();
        }

        // Create a list of CVolume objects, one for each local NTFS5 volume.
        InitializeVolumeList( pTrkWksConfiguration, pLogCallback, ssh
                              #if DBG
                              , pTunnelTest
                              #endif
                              );

        if( !pTrkWksConfiguration->_fIsWorkgroup )
        {
            InitializeDomainObjects();
            StartDomainTimers();
        }

        // Set the event that will get us to open the volume handles on an
        // IO thread.

        OnVolumeToBeReopened();


    }
    __finally
    {
        ssd.UnInitialize();
    }
}

void
CVolumeManager::UnInitialize()
{
    if( _fInitialized )
    {
        if( NULL != _hRegisterWaitForSingleObjectEx )
        {
            if( !TrkUnregisterWait( _hRegisterWaitForSingleObjectEx ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Failed UnregisterWait for CVolumeManager (%lu)"),
                         GetLastError() ));
            }
            else
                TrkLog(( TRKDBG_VOLUME, TEXT("Unregistered wait CVolumeManager") ));

            _hRegisterWaitForSingleObjectEx = NULL;
        }

        if( NULL != _heventVolumeToBeReopened )
        {
            CloseHandle( _heventVolumeToBeReopened );
            _heventVolumeToBeReopened = NULL;
        }

        UnInitializeDomainObjects();
        _timerObjIdIndexReopen.UnInitialize();

        CVolumeNode * pVolumeNode = _pVolumeNodeListHead;
        _pVolumeNodeListHead = NULL;

        while (pVolumeNode)
        {
            CVolumeNode * pNext = pVolumeNode->_pNext;

            // By this time, all timers and the LPC port are stopped and have unregistered
            // with the thread pool.  Therefore, there are no other threads running,
            // and each of the volume should have a ref count of only 1.  For robustness,
            // if any volumes have leaked, we release the extra refs here.

            while( 0 != pVolumeNode->_pVolume->Release() );

            delete pVolumeNode;
            pVolumeNode = pNext;
        }

        _fFrequentTaskHesitation = _fInfrequentTaskHesitation = FALSE;

        _csVolumeNodeList.UnInitialize();
        _fInitialized = FALSE;
    }
}

void
CVolumeManager::DoWork()
{
    // One of the volumes has been unlocked.  Just try to reopen them all
    // (those that aren't in need of opening will noop).

    __try
    {
        // These raise if the service is stopping.
        ReopenVolumeHandles();

        // If a volume has just been re-created, it may be necessary
        // to clean up some object IDs.

        CleanUpOids();
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("Ignoring exception %08x in CVolumeManager::DoWork"),
                 GetExceptionCode() ));
    }
}



//+----------------------------------------------------------------------------
//
//  CVolumeManager::InitializeDomainObjects
//
//  Initialize member objects that we don't use in a workgroup.  These
//  objects can come and go without restarting the service (thus we can
//  go between domains or move to/from domain without requiring a reboot).
//
//+----------------------------------------------------------------------------

void
CVolumeManager::InitializeDomainObjects()
{
    __try
    {
        TrkAssert( !_pTrkWksConfiguration->_fIsWorkgroup );

        // When this timer fires, we send all our IDs to trksvr so that the entries may
        // be touched (entries that are not touched will be GC-ed by trksvr).
        // Before actuallying doing the refresh, we sleep a random period, in order to
        // avoid too many workstations refreshing at the same time.

        _timerRefresh.Initialize( this,
                                  TEXT("NextRefreshTime"),      // Name (for persistent timer)
                                  VOLTIMER_REFRESH,             // Context ID
                                                                // Timer period
                                  _pTrkWksConfiguration->GetRefreshPeriod(),
                                  CNewTimer::RETRY_RANDOMLY,    //Retry values
                                  _pTrkWksConfiguration->GetRefreshRetryMin(),
                                  _pTrkWksConfiguration->GetRefreshRetryMax(),
                                  0 );                          // No max lifetime
        _timerRefresh.SetRecurring();
        TrkLog(( TRKDBG_VOLUME, TEXT("Refresh timer: %s"),
                 (const TCHAR*)CDebugString(_timerRefresh) ));

        // The Notify timer is set when we receive a move notification from ntos.
        // When it expires we send all unsent notifications up to trksvr.

        _timerNotify.Initialize( this,
                                 NULL,                          // No name (non-persistent timer)
                                 VOLTIMER_NOTIFY,               // Context ID
                                 _pTrkWksConfiguration->GetParameter( MOVE_NOTIFY_TIMEOUT_CONFIG ),
                                 CNewTimer::RETRY_WITH_BACKOFF,
                                 _pTrkWksConfiguration->GetParameter( MIN_MOVE_NOTIFY_RETRY_CONFIG ),
                                 _pTrkWksConfiguration->GetParameter( MAX_MOVE_NOTIFY_RETRY_CONFIG ),
                                 _pTrkWksConfiguration->GetParameter( MAX_MOVE_NOTIFY_LIFETIME_CONFIG ) );

        // The deletions manager watches for files with object IDs to get
        // deleted.  When they are, and they're not subsequently tunnelled back,
        // a notification is sent to trksvr so that it can remove that birth ID
        // from the object move table.

        _deletions.Initialize( _pTrkWksConfiguration );

        // When this timer fires, we do our ~daily tasks

        _timerFrequentTasks.Initialize( this,
                                        TEXT("NextVolFrequentTask"),    // Persistent timer
                                        VOLTIMER_FREQUENT,              // Context ID
                                        _pTrkWksConfiguration->GetVolFrequentTasksPeriod(),
                                        CNewTimer::NO_RETRY,
                                        0, 0, 0 );                      // Ignored for non-retrying timer

        // When this timer fires, we do our ~weekly tasks

        _timerInfrequentTasks.Initialize( this,
                                          TEXT("NextVolInfrequentTask"),//Persistent timer
                                          VOLTIMER_INFREQUENT,          // Context ID
                                          _pTrkWksConfiguration->GetVolInfrequentTasksPeriod(),
                                          CNewTimer::NO_RETRY,
                                          0, 0, 0 );                    // Ignored for non-retrying timer

        // When this timer fires, we do the initial volume synchronizations.
        // This timer is also used to do slow retries.  E.g, if we try to send
        // a move notification and get a busy error, we retry at this slow rate.

        _timerVolumeInit.Initialize( this,
                                     NULL,                // No name (non-persistent)
                                     VOLTIMER_INIT,       // Context ID
                                     _pTrkWksConfiguration->GetVolInitInitialDelay(),
                                     CNewTimer::RETRY_RANDOMLY,
                                                          // Initial retry period
                                     _pTrkWksConfiguration->GetVolInitRetryDelay1(),
                                                          // Max retry period
                                     _pTrkWksConfiguration->GetVolInitRetryDelay2(),
                                     _pTrkWksConfiguration->GetVolInitLifetime() );

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception %08x in CVolumeManager::InitializeDomainObjects"),
                 GetExceptionCode() ));
    }

}



//+----------------------------------------------------------------------------
//
//  CVolumeManager::UnInitializeObjects
//
//  Free the objects that we don't use in a workgroup.  This doesn't require
//  stopping the service.
//
//+----------------------------------------------------------------------------

void
CVolumeManager::UnInitializeDomainObjects()
{
    __try
    {
        _timerRefresh.UnInitialize();
        _timerNotify.UnInitialize();

        _deletions.UnInitialize( );

        _timerInfrequentTasks.UnInitialize();
        _timerFrequentTasks.UnInitialize();
        _timerVolumeInit.UnInitialize();

    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception %08x in CVolumeManager::UnInitializeDomainObjects"),
                 GetExceptionCode() ));
    }
}



//+----------------------------------------------------------------------------
//
//  CVolumeManager::StartDomainTimers
//
//  Start the timers that we don't use in a workgroup.
//
//+----------------------------------------------------------------------------

void
CVolumeManager::StartDomainTimers()
{
    if( !_pTrkWksConfiguration->_fIsWorkgroup )
    {
        _timerFrequentTasks.SetSingleShot();
        TrkLog(( TRKDBG_VOLUME, TEXT("Frequent timer: %s"),
                 (const TCHAR*)CDebugString(_timerFrequentTasks) ));

        _timerInfrequentTasks.SetSingleShot();
        TrkLog(( TRKDBG_VOLUME, TEXT("Infrequent timer: %s"),
                 (const TCHAR*)CDebugString(_timerInfrequentTasks) ));

        _timerVolumeInit.SetSingleShot();
        TrkLog(( TRKDBG_VOLUME, TEXT("VolInit timer: %s"),
                 (const TCHAR*)CDebugString(_timerVolumeInit) ));
    }
}



//+----------------------------------------------------------------------------
//
//  Method:     CVolumeManager::RefreshVolumes
//
//  Refresh the CVolume objects.  This gives them the chance to
//  get an updated drive letter, and to delete themselves if the volume
//  they represent is now gone.
//
//+----------------------------------------------------------------------------


void
CVolumeManager::RefreshVolumes( PLogCallback *pLogCallback,
                                SERVICE_STATUS_HANDLE ssh
                                #if DBG
                                , CTestSync *pTunnelTest
                                #endif
                                )
{
    InitializeVolumeList( _pTrkWksConfiguration, pLogCallback, ssh
                          #if DBG
                          , pTunnelTest
                          #endif
                          );
    OnVolumeToBeReopened();
}



//+----------------------------------------------------------------------------
//
//  Method:     CVolumeManager::InitializeVolumeList
//
//  This method initializes the linked list of CVolume objects.
//
//+----------------------------------------------------------------------------

void
CVolumeManager::InitializeVolumeList( const CTrkWksConfiguration    *pTrkWksConfiguration,
                                      PLogCallback                  *pLogCallback,
                                      SERVICE_STATUS_HANDLE         ssh
                                      #if DBG
                                      , CTestSync                   *pTunnelTest
                                      #endif
                                      )
{
    ULONG               cVolumes = 0;
    TCHAR               tszVolumeName[ CCH_MAX_VOLUME_NAME + 1 ];
    HANDLE              hFindVolume = INVALID_HANDLE_VALUE;
    CVolumeNode         *pVolNode = NULL;

    __try
    {
        // Begin a physical volume enumeration using the mount manager.
        // Volume names represent the root in Win32 format, e.g.
        //      \\?\Volume{8baec120-078b-11d2-824b-000000000000}\ 

        hFindVolume = FindFirstVolume( tszVolumeName, ELEMENTS(tszVolumeName) );
        if( INVALID_HANDLE_VALUE == hFindVolume )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("FindFirstVolume failed") ));
            TrkRaiseLastError();
        }

        // For each local NTFS5 volume, create a CVolume, add it to the linked-list,
        // and initialize.

        cVolumes = 1;
        while( NUM_VOLUMES >= cVolumes )
        {
            CVolume *pvolOpen = NULL;
            TCHAR tszVolumeDeviceName[ MAX_PATH + 1 ];
            ULONG cchVolumeName;

            TrkLog(( TRKDBG_VOLUME, TEXT("Initializing volume %s"), tszVolumeName ));

            // If we already have this volume open, continue on.

            cchVolumeName = wcslen(tszVolumeName);
            memcpy( tszVolumeDeviceName, tszVolumeName, cchVolumeName*sizeof(TCHAR) );
            tszVolumeDeviceName[ cchVolumeName - 1 ] = TEXT('\0');

            if( pvolOpen = FindVolume( tszVolumeDeviceName ))
            {
                TrkLog(( TRKDBG_VOLUME, TEXT("Volume already open" ) ));
                pvolOpen->Release();
                cVolumes++;
            }

            // If this isn't an NTFS5 volume, move on.

            else if( IsLocalObjectVolume(tszVolumeName) )
            {
                // Alloc a new node for the volume list

                pVolNode = new CVolumeNode;
                if (pVolNode == NULL)
                {
                    TrkRaiseException(E_OUTOFMEMORY);
                }

                // Put a volume into the node

                pVolNode->_pVolume = new CVolume();
                if (pVolNode->_pVolume == NULL)
                {
                    TrkRaiseException(E_OUTOFMEMORY);
                }


                // Initialize the volume.  Returns true if successful, raises on error.
                __try
                {
                    if( pVolNode->_pVolume->Initialize(tszVolumeName, _pTrkWksConfiguration, this,
                                                       pLogCallback, &_deletions, ssh
                                                       #if DBG
                                                       ,pTunnelTest
                                                       #endif
                                                       ))
                    {
                        cVolumes++;

                        // Add this volume node (and its associated CVolume) to the linked list.

                        AddNodeToLinkedList( pVolNode );
                        pVolNode = NULL;

                    }   // if( pVolNode->_pVolume->Initialize(v, _pTrkWksConfiguration, ...
                }
                __except( BreakOnDebuggableException() )
                {
                }

                if( NULL != pVolNode )
                {
                    TrkLog(( TRKDBG_VOLUME, TEXT("Volume initialization failed, deleting node") ));
                    pVolNode->_pVolume->Release();
                    delete pVolNode;
                    pVolNode = NULL;
                }

            }   // else if( IsLocalObjectVolume(tszVolumeName) )
            #if DBG
            else
            {
                TrkLog(( TRKDBG_VOLUME, TEXT("Skipping volume %s"), tszVolumeName ));
            }
            #endif

            // Move on to the next volume in the system.

            if( !FindNextVolume( hFindVolume, tszVolumeName, ELEMENTS(tszVolumeName) ))
            {
                if( ERROR_NO_MORE_FILES == GetLastError() )
                    // We've enumerated all of the volumes.
                    break;
                else
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("FindNextVolume failed") ));
                    TrkRaiseLastError();
                }
            }

        }   // while( NUM_VOLUMES >= cVolumes )
    }
    __finally
    {
        if( INVALID_HANDLE_VALUE != hFindVolume )
            FindVolumeClose( hFindVolume );

        if( NULL != pVolNode )
            delete pVolNode;

    }

}

//+----------------------------------------------------------------------------
//
//  Method:     CVolumeManager::AddNodeToLinkedList
//
//  Adds a CVolumeNode (and its embedded CVolume) to the volume manager's
//  linked list.
//
//  The CVolumeNode elements in the linked list are kept sorted in
//  increasing address order.  This is so a CVolumeEnumerator can handle a
//  node being deleted while such an enumeration is active.
//
//+----------------------------------------------------------------------------

void
CVolumeManager::AddNodeToLinkedList( CVolumeNode *pVolNode )
{
    TrkAssert( _fInitialized );
    _csVolumeNodeList.Enter();
    __try
    {
        if( NULL == _pVolumeNodeListHead )
        {
            pVolNode->_pNext = NULL;
            _pVolumeNodeListHead = pVolNode;
        }
        else if( pVolNode < _pVolumeNodeListHead )
        {
            pVolNode->_pNext = _pVolumeNodeListHead;
            _pVolumeNodeListHead = pVolNode;
        }
        else
        {
            CVolumeNode *pNode = _pVolumeNodeListHead;
            while( NULL != pNode->_pNext && pNode->_pNext < pVolNode )
                pNode = pNode->_pNext;

            if( NULL == pNode->_pNext )
            {
                TrkAssert( pNode < pVolNode );
                pNode->_pNext = pVolNode;
                pVolNode->_pNext = NULL;
            }
            else
            {
                TrkAssert( pNode < pVolNode );
                TrkAssert( pNode->_pNext > pVolNode );
                pVolNode->_pNext = pNode->_pNext;
                pNode->_pNext = pVolNode;
            }
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        TrkAssert( !TEXT("Unexpected exception in CVolumeManager::AddNodeToLinkedList") );
    }
    _csVolumeNodeList.Leave();
}



//+----------------------------------------------------------------------------
//
//  Method:     CVolumeManager::RemoveVolumeFromLinkedList
//
//  Removes a volume from the volume manager's linked list.
//  The CVolume is Released (which may or may not make it go away, depending
//  on ref-counts), and the CVolumeNode is deleted.
//
//+----------------------------------------------------------------------------

void
CVolumeManager::RemoveVolumeFromLinkedList( const CVolume *pvol )
{
    CVolumeNode **ppvolnodePrev = NULL;
    CVolumeNode *pvolnode = NULL;

    TrkAssert( _fInitialized );
    _csVolumeNodeList.Enter();
    __try
    {
        pvolnode = _pVolumeNodeListHead;
        ppvolnodePrev = &_pVolumeNodeListHead;

        while( NULL != pvolnode )
        {
            if( pvol == pvolnode->_pVolume )
            {
                TrkLog(( TRKDBG_VOLUME, TEXT("Removing volume %p from the list"), pvolnode->_pVolume ));

                CVolumeNode *pvolnodeDel = pvolnode;
                *ppvolnodePrev = pvolnode->_pNext;

                // Releasing the volume will usually cause it to delete itself, unless
                // someone else is holding a ref on it.

                pvolnodeDel->_pVolume->Release();
                delete pvolnodeDel;

                break;
            }
            else
            {
                ppvolnodePrev = &pvolnode->_pNext;
                pvolnode = pvolnode->_pNext;
            }
        }
    }
    __except( BreakOnDebuggableException() )
    {
    }
    _csVolumeNodeList.Leave();

}

void
CVolumeManager::CloseVolumeHandles( HDEVNOTIFY hdnVolume )
{
    CVolumeEnumerator   volEnum = Enum();
    CVolume*            vol = volEnum.GetNextVolume();

    while (vol != NULL)
    {
        __try
        {
            vol->CloseVolumeHandles( hdnVolume );
        }
        __except( BreakOnDebuggableException() )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception in CloseVolumeHandles (%08x)"),
                     GetExceptionCode() ));
        }

        vol->Release();
        vol = volEnum.GetNextVolume();
    }
}

void
CVolumeManager::CleanUpOids()
{
    CVolumeEnumerator   volEnum = Enum();
    CVolume*            vol = volEnum.GetNextVolume();

    while(vol != NULL)
    {
        if(vol->IsMarkedForMakeAllOidsReborn())
        {
            __try
            {
                if( vol->MakeAllOidsReborn() )
                    vol->ClearMarkForMakeAllOidsReborn();
            }
            __except( BreakOnDebuggableException() )
            {
                TrkLog(( TRKDBG_VOLUME, TEXT("Ignoring exception in CVolumeManager::CleanUpOids") ));
            }
        }

        vol->Release();
        vol = volEnum.GetNextVolume();
    }
}


//+----------------------------------------------------------------------------
//
//  CVolumeManager::SyncVolumes
//
//  Give each active volume an opportunity to synchronize with trksvr.
//  This allows the volumes to create a new ID, claim an existing ID,
//  etc.
//
//  Note:: This routine is guaranteed not to raise.
//
//+----------------------------------------------------------------------------

BOOL
CVolumeManager::SyncVolumes( EAggressiveness eAggressiveness,
                             CFILETIME cftLastDue,
                             ULONG ulPeriodInSeconds )
{
    BOOL fSuccess = FALSE;
    BOOL fDoRetry = FALSE;
    CAvailableDc adc;
    CVolumeEnumerator   volEnum;
    CVolume*            pvol;
    BOOL                fIsOnlyInstance = FALSE;

    __try
    {

        TRKSVR_SYNC_VOLUME   rgSyncVolumes[ NUM_VOLUMES ];
        TRKSVR_MESSAGE_UNION Msg;
        ULONG                cVolumes = 0;
        const CVolumeId      volNULL;
        BOOL                 fSyncNeeded;

        // If there's already a thread doing a SyncVolumes, we don't need to
        // do it again simultaneously.

        fIsOnlyInstance = BeginSingleInstanceTask( &_cSyncVolumesInProgress );
        if( !fIsOnlyInstance )
        {
            TrkLog(( TRKDBG_VOLUME, TEXT("Skipping SyncVolumes, another instance already in progress") ));
            fSuccess = TRUE;
            goto Exit;
        }

        // If we haven't fully initialized the volumes yet, do so now.
        ReopenVolumeHandles();

        // Start a CVolume enumeration

        volEnum = Enum();
        pvol = volEnum.GetNextVolume();

        // Loop through the enumerated volumes.
        // When we're done, cVolumes will show the count of volumes
        // that requested to sync with trksvr (could be zero).

        while ( NULL != pvol )
        {
            BOOL fFound = FALSE;

            // Add this volume to the array of volumes needing update with trksvr.
            // If this particular volume turns out not to need an update, we won't
            // increment cVolumes, consequently it will get overwritten on the
            // next pass.  If this volume does need an update, we'll addref it.

            _rgVolumesToUpdate[cVolumes] = pvol;

            // Call the volume to load the sync-volume request.

            if(TRUE == pvol->LoadSyncVolume(&rgSyncVolumes[cVolumes], eAggressiveness, &fSyncNeeded))
            {
                // The LoadSyncVolumes request succeeded.  
                // Does the volume need a sync with trksvr?

                if(fSyncNeeded == FALSE)
                {
                    // No, the volume doesn't need a sync.  It's
                    // apparantly neither new nor newly attached.

                    TrkLog(( TRKDBG_VOLUME | TRKDBG_MOVE,
                             TEXT("Volume %c is properly ID-ed already"),
                             'A'+pvol->GetIndex() ));
                }
                else if(rgSyncVolumes[cVolumes].SyncType == CREATE_VOLUME)
                {
                    // This is a newly-formatted volume.
                    TrkLog(( TRKDBG_VOLUME | TRKDBG_MOVE,
                             TEXT("Having a new ID created for volume %c"),
                             TEXT('A')+pvol->GetIndex() ));
                    _rgVolumesToUpdate[cVolumes]->AddRef();
                    cVolumes++;
                }
                else
                {
                    // The volume is new to this machine
                    TrkLog(( TRKDBG_VOLUME | TRKDBG_MOVE,
                             TEXT("Claiming volume %c"),
                             TEXT('A')+pvol->GetIndex() ));
                    _rgVolumesToUpdate[cVolumes]->AddRef();
                    cVolumes++;
                }
            }
            else
            {
                // The volume needs to be synced but failed for some reason
                TrkLog(( TRKDBG_VOLUME | TRKDBG_MOVE,
                         TEXT("Volume %c can not be synced"),
                         'A'+pvol->GetIndex() ));
            }

            // Move on to the next item in the enumeration.
            // If this volumes needs an update, it's addref-ed in 
            // _rgVolumesToUpdate.

            pvol->Release();
            pvol = volEnum.GetNextVolume();

        }   // while ( vol != NULL )


        // Were there any volumes in need of a sync with trksvr?

        if( 0 != cVolumes )
        {
            // Yes, send the sync_volumes request.

            __try
            {
                HRESULT hr;

                // Construct the Msg union

                Msg.MessageType = SYNC_VOLUMES;

                Msg.Priority = (0 == ulPeriodInSeconds)
                                    ? PRI_6
                                    : GetSvrMessagePriority( cftLastDue, ulPeriodInSeconds );

                Msg.SyncVolumes.cVolumes = cVolumes;

                Msg.SyncVolumes.pVolumes = rgSyncVolumes;
#ifdef VOL_REPL
                Msg.SyncVolumes.cChanges = 0;
                Msg.SyncVolumes.ppVolumeChanges = NULL;
#endif

                // Send the request to trksvr.  We pass it under privacy encryption
                // because there could be a volume secret in it.
                // This will raise if there's an error.

                hr = adc.CallAvailableDc(&Msg, PRIVACY_AUTHENTICATION );

                // now we've successfully told the DC we should update the
                // DcInformed flags

                TrkLog((TRKDBG_VOLUME, TEXT("CallAvailableDc returned %d volumes (%08X)"),
                         Msg.SyncVolumes.cVolumes, hr ));

                // See if there were problems and we should do a retry
                // (This gets set in the DcCallback method).

                if( TRK_S_VOLUME_NOT_SYNCED == hr )
                    fDoRetry = TRUE;

                // Process the responses

                for( ULONG v = 0; v < Msg.SyncVolumes.cVolumes; v++ )
                {
                    // If the problem is server-too-busy, have the caller do 
                    // a retry.  Otherwise (e.g. quota error) ignore the error.
                    // E.g. for a quota error, we'll ignore the error, but the
                    // volume will still be in a not-created state, and we'll
                    // retry the next time the infrequent timer fires.

                    if( TRK_E_SERVER_TOO_BUSY == rgSyncVolumes[v].hr )
                        fDoRetry = TRUE;

                    if( _rgVolumesToUpdate[v]->UnloadSyncVolume( &rgSyncVolumes[v] )
                        &&
                        rgSyncVolumes[v].hr == S_OK
                      )
                    {
                        TrkLog(( TRKDBG_VOLUME | TRKDBG_MOVE,
                                 TEXT("Volume %c successfully synced with server"),
                                 'A'+_rgVolumesToUpdate[v]->GetIndex() ));
                    }
                    else
                    {
                        TrkLog(( TRKDBG_VOLUME | TRKDBG_MOVE,
                                 TEXT("Couldn't sync vol %c with server (%08x, %s)"),
                                 'A'+_rgVolumesToUpdate[v]->GetIndex(),
                                 rgSyncVolumes[v].hr, GetErrorString(rgSyncVolumes[v].hr) ));
                    }
                }   // for( v = 0; v < Msg.SyncVolumes.cVolumes; v++ )
            }
            __finally
            {
                for( ULONG v = 0; v < cVolumes; v++ )
                {
                    _rgVolumesToUpdate[v]->Release();
                }
            }

        }   // if( 0 != cVolumes )

        // If any volids have been changed, make all the existing object IDs
        // reborn.

        CleanUpOids();

        fSuccess = TRUE;

    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't sync with server (0x%08x)"), GetExceptionCode() ));
    }

    if( pvol != NULL )
    {
        pvol->Release();
    }

Exit:

    if( fIsOnlyInstance )
        EndSingleInstanceTask( &_cSyncVolumesInProgress );

    return fSuccess && !fDoRetry;
}


void
CVolumeManager::Append( const CDomainRelativeObjId &droidCurrent,
                        const CDomainRelativeObjId &droidNew,
                        const CMachineId           &mcidNew,
                        const CDomainRelativeObjId &droidBirth)
{
    CVolumeEnumerator   enumerator = Enum();
    CVolume*            cvolCur = enumerator.GetNextVolume();
    BOOL                fVolumeFound = FALSE;

    __try   // __finally
    {

        while ( cvolCur != NULL )
        {
            if( cvolCur->GetVolumeId() == droidCurrent.GetVolumeId())
            {
                fVolumeFound = TRUE;
                cvolCur->Append(droidCurrent, droidNew, mcidNew, droidBirth);
                break;
            }

            cvolCur->Release();
            cvolCur = enumerator.GetNextVolume();
        }
    }
    __finally
    {
        if (cvolCur != NULL)
        {
            cvolCur->Release();
        }
    }

    if( !fVolumeFound )
        TrkRaiseNtStatus( STATUS_NO_TRACKING_SERVICE );
}


// search all volumes (and each log) or just the given volume
//
// S_OK || TRK_E_NOT_FOUND || TRK_E_REFERRAL

HRESULT
CVolumeManager::Search( DWORD Restrictions,
                        const CDomainRelativeObjId & droidBirthLast,
                        const CDomainRelativeObjId & droidLast,
                        CDomainRelativeObjId * pdroidBirthNext,
                        CDomainRelativeObjId * pdroidNext,
                        CMachineId           * pmcidNext,
                        TCHAR                * ptszLocalPath )
{
    NTSTATUS status;
    HRESULT hr = TRK_E_NOT_FOUND;
    CVolumeEnumerator   enumerator;
    CVolume*            pvol = NULL;
    const CMachineId mcidLocal( MCID_LOCAL );
    BOOL fPotentialFile = FALSE;
    CDomainRelativeObjId droidZero;

    // Local working stores for what we'll return in pdroidNew & pmcidNew
    // if we have a referral.

    CDomainRelativeObjId droidBirthNext = droidBirthLast;
    CDomainRelativeObjId droidNext = droidLast;
    CMachineId           mcidNext = mcidLocal;

    __try   // __finally
    {

        g_ptrkwks->RaiseIfStopped();

        //  -------------------------------
        //  Search the volumes for the file
        //  -------------------------------

        // Search the last volume first, then search all the volumes.
        // Thus we'll end up searching droidLast.GetVolumeId() twice.
        // This is necessary, though, because there could be multiple
        // local volumes with this volid.

        if( !(Restrictions & TRK_MEND_DONT_SEARCH_ALL_VOLUMES) )
            enumerator = Enum();

        if( !(Restrictions & TRK_MEND_DONT_USE_VOLIDS) )
            pvol = FindVolume( droidLast.GetVolumeId() );

        if( NULL == pvol )
            pvol = enumerator.GetNextVolume();

        for( ; NULL != pvol; pvol = enumerator.GetNextVolume() )
        {
            status = FindLocalPath( pvol->GetIndex(), droidLast.GetObjId(),
                                    &droidBirthNext, &ptszLocalPath[2] );
            if( NT_SUCCESS(status) )
            {
                // Is this in the SystemVolumeInformation directory?  If so, we'll
                // pretend we didn't find it (it's probably in the System Recovery
                // directory).

                if( IsSystemVolumeInformation( &ptszLocalPath[2] ))
                {
                    TrkLog(( TRKDBG_VOLUME | TRKDBG_MEND,
                             TEXT("CVolumeManager::Search ignoring %c:%s"),
                             VolChar(pvol->GetIndex()), &ptszLocalPath[2] ));
                }

                // Or, is this the correct birth ID (or the caller doesn't want us to check)?
                else if( droidBirthLast == droidBirthNext
                         ||
                         droidBirthLast == droidZero )
                {
                    // Yes.  We've found our file and we're done.

                    // Give the path a drive letter
                    TrkAssert( -1 != pvol->GetIndex() );
                    ptszLocalPath[0] = VolChar(pvol->GetIndex());
                    ptszLocalPath[1] = TEXT(':');

                    // droidBirthNext is already set by FindLocalPath
                    droidNext = CDomainRelativeObjId( pvol->GetVolumeId(), droidLast.GetObjId() );
                    mcidNext = mcidLocal;

                    TrkLog(( TRKDBG_VOLUME | TRKDBG_MEND, TEXT("CVolumeManager::Search found %s"),
                             ptszLocalPath ));

                    hr = S_OK;
                    fPotentialFile = FALSE;
                    __leave;
                }

                // Otherwise, is it the first potential hit?
                else if( !fPotentialFile )
                {
                    // We found a file with the right object ID, but the wrong birth ID.
                    // By rule of law, it's therefore not the right file.  However, it could be
                    // the right file, but was re-born due to a volid change.  So we'll keep
                    // it and let the caller (eventually, the user) decide.

                    // Give the path a drive letter
                    ptszLocalPath[0] = VolChar(pvol->GetIndex());
                    ptszLocalPath[1] = TEXT(':');

                    // droidBirthNext is already set by FindLocalPath
                    droidNext = CDomainRelativeObjId( pvol->GetVolumeId(), droidLast.GetObjId() );
                    mcidNext = mcidLocal;

                    TrkLog(( TRKDBG_VOLUME | TRKDBG_MEND,
                             TEXT("CVolumeManager::Search found *potential* %s"),
                             ptszLocalPath ));

                    fPotentialFile = TRUE;
                }
            }

            pvol->Release(); pvol = NULL;

        }   // for( ; NULL != pvol, pvol = enumerator.GetNextVolume() );
        enumerator.UnInitialize();

        // We didn't find the file on any of the volumes, let's search the logs
        // to see if they know where it went.

        //  ---------------------
        //  Search the local logs
        //  ---------------------

        if( Restrictions & TRK_MEND_DONT_USE_LOG )
            __leave;

        // Start by searching the log of the last volume, then enumerate through all the
        // volume logs.  Again we'll end up searching the last volume twice, because
        // there could be dup volids.

        if( !(Restrictions & TRK_MEND_DONT_SEARCH_ALL_VOLUMES) )
            enumerator = Enum();

        if( !(Restrictions & TRK_MEND_DONT_USE_VOLIDS) )
            pvol = FindVolume( droidLast.GetVolumeId() );

        if( NULL == pvol )
            pvol = enumerator.GetNextVolume();

        for( ; NULL != pvol; pvol = enumerator.GetNextVolume() )
        {
            CDomainRelativeObjId droidNextT, droidBirthT;
            CMachineId mcidNextT;

            if (pvol->Search( droidLast, &droidNextT, &mcidNextT, &droidBirthT ))
            {
                // We found a match in the log.

                TrkLog(( TRKDBG_VOLUME | TRKDBG_MEND, TEXT("Referral on vol %c: %s\n  => %s:%s"),
                         VolChar(pvol->GetVolIndex()),
                         (const TCHAR*)CDebugString(droidLast.GetObjId()),
                         (const TCHAR*)CDebugString(mcidNextT),
                         (const TCHAR*)CDebugString(droidNextT) ));

                // If the volid is useful (it's non-NULL and non-local), keep these IDs
                // as the best to return.

                if( CVolumeId() != droidNextT.GetVolumeId()
                    &&
                    (  !IsLocal( droidNextT.GetVolumeId() )
                       ||
                       droidLast.GetObjId() != droidNextT.GetObjId()
                       ||
                       (Restrictions & TRK_MEND_DONT_SEARCH_ALL_VOLUMES)
                    )
                  )
                {
                    hr = TRK_E_REFERRAL;
                    droidBirthNext = droidBirthLast;
                    droidNext = droidNextT;
                    mcidNext = mcidNextT;

                    fPotentialFile = FALSE;
                    break;
                }

                // Or, if the mcid is useful (not this machine), keep the IDs as the
                // best to return

                else if( CMachineId() != mcidNextT
                         &&
                         ( mcidLocal != mcidNextT
                           ||
                           (Restrictions & TRK_MEND_DONT_SEARCH_ALL_VOLUMES)
                         )
                       )
                {
                    hr = TRK_E_REFERRAL;
                    droidBirthNext = droidBirthLast;
                    mcidNext = mcidNextT;
                    droidNext = droidNextT;

                    fPotentialFile = FALSE;
                    break;
                }
            }

            pvol->Release(); pvol = NULL;

        }   // for( ; NULL != pvol, pvol = enumerator.GetNextVolume() );

    }   // __try
    _finally
    {
        if( NULL != pvol )
        {
            pvol->Release();
            pvol = NULL;
        }

        enumerator.UnInitialize();
    }

    // If we didn't find the file or a referral, but did find a potential hit,
    // return that potential hit.

    if( TRK_E_NOT_FOUND == hr && fPotentialFile )
        hr = TRK_E_POTENTIAL_FILE_FOUND;

    if( SUCCEEDED(hr) || TRK_E_REFERRAL == hr || TRK_E_POTENTIAL_FILE_FOUND == hr )
    {
        *pdroidBirthNext = droidBirthNext;
        *pmcidNext       = mcidNext;
        *pdroidNext      = droidNext;
    }

    return( hr );
}

PTimerCallback::TimerContinuation
CVolumeManager::Timer( DWORD dwTimerId )
{
    PTimerCallback::TimerContinuation continuation = CONTINUE_TIMER;

    __try
    {
        switch ( dwTimerId )
        {
        case VOLTIMER_OBJID_INDEX_REOPEN:
            TrkAssert( _timerObjIdIndexReopen.IsRecurring() );

            if( ReopenVolumeHandles() ) // Raises if service is stopped
                continuation = BREAK_TIMER;
            else
                continuation = RETRY_TIMER;

            break;

        case VOLTIMER_FREQUENT:
        case VOLTIMER_INFREQUENT:
        case VOLTIMER_INIT:

            TrkAssert( !_timerFrequentTasks.IsRecurring() );
            TrkAssert( !_timerInfrequentTasks.IsRecurring() );
            TrkAssert( !_timerVolumeInit.IsRecurring() );

            continuation = OnVolumeTimer( dwTimerId );
            break;

        // Time to send MoveNotifies to the DC
        case VOLTIMER_NOTIFY:

            TrkAssert( !_timerNotify.IsRecurring() );
            TrkAssert( CNewTimer::RETRY_WITH_BACKOFF == _timerNotify.GetRetryType() );

            __try
            {
                continuation = _pTrkWks->OnMoveBatchTimeout();
            }
            __except( BreakOnDebuggableException() )
            {
                // If there was an unexpected error, instead of retrying the
                // MoveNotify timer, use the slower (thus DC-friendlier) VolInit
                // timer.

                TrkLog(( TRKDBG_ERROR, TEXT("Server to busy to receive move notifications, starting VolInit timer") ));
                continuation = BREAK_TIMER;
                SetVolInitTimer();
            }

            break;

        // Time to refresh the DC with all our active IDs
        case VOLTIMER_REFRESH:

            // The first time we're called, we hesitate for a random amount of time.
            // This hesitation is implemented by setting a flag, then resetting the timer.
            // When the timer fires again a little later, we'll do the real work.

            if( !_fRefreshHesitation )
            {
                // This is the first time we've been called.

                ULONG ulHesitation = 0;

                // Delay a random number of seconds within an interval

                _fRefreshHesitation = TRUE;

                ulHesitation = QuasiRandomDword()
                               %
                               ( 1 + _pTrkWksConfiguration->GetRefreshHesitation() );

                TrkLog(( TRKDBG_LOG, TEXT("Hesitating %d seconds before executing refresh"), ulHesitation ));
                _timerRefresh.ReInitialize( ulHesitation );
                continuation = CONTINUE_TIMER;
            }
            else
            {
                TrkAssert( _timerRefresh.IsRecurring() );
                continuation = _pTrkWks->OnRefreshTimeout(
                                    _timerRefresh.QueryOriginalDueTime(),
                                    _pTrkWksConfiguration->GetRefreshPeriod() );

                if( CONTINUE_TIMER == continuation )
                {
                    _timerRefresh.ReInitialize( _pTrkWksConfiguration->GetRefreshPeriod() );
                    _fRefreshHesitation = FALSE;
                }
            }

            break;


        default:
            TrkAssert( 0 && "invalid timer id" );
            break;
        }
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("Ignoring exception %08x in CVolumeManager::Timer"),
                 GetExceptionCode() ));
    }


    return( continuation );
}


BOOL
CVolumeManager::ReopenVolumeHandles()
{
    BOOL fAllOk = TRUE;

    // If there's another thread already executing this routine, we'll just skip out.
    // This is a reasonable idea, but really shouldn't be necessary; the volumes
    // can protect themselves, and one thread should basically noop.  However,
    // there was an iostress break where these two threads got each other into
    // a deadly embrace.  This was due to the fact that the win32 thread pool
    // has the tendency to put multiple IO work items on the same thread (since
    // it queues to IO threads using APCs).  So as a workaround, don't run
    // this method more than once at a time.

    if( !BeginSingleInstanceTask( &_cReopenVolumeHandles ))
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("Skipping ReopenVolumeHandles, another instance is already in progress") ));
        return FALSE;
    }

    // Get a volume enumerator.  After initialization, none of the volumes 
    // have yet been opened.  Ordinarily the Enum method gives us nothing until
    // they've been opened once.  But this routine is the one that originally does
    // the opens, so we need the enumerator to give us everything.

    CVolumeEnumerator enumerator = Enum( ENUM_UNOPENED_VOLUMES );

    TrkLog(( TRKDBG_OBJID_DELETIONS, TEXT("\nAttempting to reopen all volume handles") ));

    for( CVolume* pVol = enumerator.GetNextVolume();
         pVol != NULL;
         pVol = enumerator.GetNextVolume())
    {
        __try
        {
            if( !pVol->ReopenVolumeHandles() )
                fAllOk = FALSE;
        }
        __except(BreakOnDebuggableException())
        {
            fAllOk = FALSE;
        }
        pVol->Release();
    }

    // Show that at least an attempt has been made to open all
    // volume handles.  This is checked in Enum().
    _fVolumesHaveBeenOpenedOnce = TRUE;

    // Show that we're done with this method.
    EndSingleInstanceTask( &_cReopenVolumeHandles );

    TrkLog(( TRKDBG_OBJID_DELETIONS,
             fAllOk ? TEXT("All volume handles are open") : TEXT("Not all volume handles are open") ));
    return( fAllOk );
}


void
CVolumeManager::VolumeDeviceEvent( HDEVNOTIFY hdnVolume, EVolumeDeviceEvent eVolumeDeviceEvent )
{
    CVolumeEnumerator enumerator = Enum();
    BOOL fAllOk = TRUE;

    for( CVolume* pVol = enumerator.GetNextVolume();
         pVol != NULL;
         pVol = enumerator.GetNextVolume() )
    {
        __try
        {
            switch( eVolumeDeviceEvent )
            {
            case ON_VOLUME_LOCK:
                pVol->OnVolumeLock( hdnVolume );
                break;
            case ON_VOLUME_UNLOCK:
                pVol->OnVolumeUnlock( hdnVolume );
                break;
            case ON_VOLUME_LOCK_FAILED:
                pVol->OnVolumeLockFailed( hdnVolume );
                break;

            case ON_VOLUME_MOUNT:
                pVol->OnVolumeMount( hdnVolume );
                break;
            case ON_VOLUME_DISMOUNT:
                pVol->OnVolumeDismount( hdnVolume );
                break;

            case ON_VOLUME_DISMOUNT_FAILED:
                pVol->OnVolumeDismountFailed( hdnVolume );
                break;

            default:
                TrkLog(( TRKDBG_ERROR, TEXT("Invalid event to OnVolumeDeviceEvent (%d)"),
                         eVolumeDeviceEvent ));
                TrkAssert( !TEXT("Invalid event to OnVolumeDeviceEvent") );
                break;

            }   // switch( eVolumeDeviceEvent )
        }
        __except(BreakOnDebuggableException())
        {
        }
        pVol->Release();
    }

    return;
}


//+----------------------------------------------------------------------------
//
//  CVolumeManager::OnEntriesAvailable
//
//  The CLog calls this routine when it has new data available
//  for us to read.  We don't read it right away, but start the Notify timer.
//  When it goes off, we'll upload all notifications to the DC that haven't
//  yet been sent.
//
//+----------------------------------------------------------------------------

void
CVolumeManager::OnEntriesAvailable()
{
    if( !_pTrkWksConfiguration->_fIsWorkgroup )
    {
        _timerNotify.SetSingleShot();

        TrkLog(( TRKDBG_MOVE | TRKDBG_WKS,
                 TEXT("log called CVolumeManager::OnEntriesAvailable(), %s"),
                 (const TCHAR*)CDebugString(_timerNotify) ));
    }

}





//+----------------------------------------------------------------------------
//
//  CVolumeManager::ForceVolumeClaims
//
//  Put all of the volumes in the not-owned state so that they will
//  try to do a claim.
//
//+----------------------------------------------------------------------------

void
CVolumeManager::ForceVolumeClaims()
{
    CVolumeEnumerator enumerator = Enum();

    TrkLog(( TRKDBG_OBJID_DELETIONS, TEXT("Force volume claims") ));

    for( CVolume* pVol = enumerator.GetNextVolume();
         pVol != NULL;
         pVol = enumerator.GetNextVolume())
    {
        __try
        {
            pVol->SetState(CVolume::VOL_STATE_NOTOWNED);
        }
        __except(BreakOnDebuggableException())
        {
        }
        pVol->Release();
    }

    // Do a SyncVolumes so that the volumes can all send up a
    // volume-claim request.  If it fails, just start the volinit
    // timer to have it called again later.

    if( !SyncVolumes( AGGRESSIVE ))    // Doesn't raise
        SetVolInitTimer();
}

PTimerCallback::TimerContinuation
CVolumeManager::OnVolumeTimer( DWORD dwTimerId )
{
    ULONG ulTimerResetPeriod = 0;
    BOOL  fTimerRetry = FALSE;
    CNewTimer * ptimer;
    PTimerCallback::TimerContinuation continuation = CONTINUE_TIMER;

    __try
    {
        switch( static_cast<VOLTIMERID>(dwTimerId) )
        {

        // Initialization tasks
        // This timer is started during initialization, and then usually stops after
        // one iteration.  It can be restarted, however, if a MoveNotify gets a
        // TRK_E_SERVER_TOO_BUSY error.

        case VOLTIMER_INIT:

            TrkLog(( TRKDBG_VOLUME, TEXT("VolInit timer has fired") ));

            ptimer = &_timerVolumeInit;
            TrkAssert( CNewTimer::RETRY_RANDOMLY == ptimer->GetRetryType() );
            TrkAssert( !ptimer->IsRecurring() );

            // Create/claim volumes as necessary.

            fTimerRetry = TRUE;
            if( SyncVolumes( PASSIVE,
                             _timerVolumeInit.QueryOriginalDueTime(),
                             _timerVolumeInit.QueryPeriodInSeconds() )) // Doesn't raise
                fTimerRetry = FALSE;

            // If we have a new volid, make the existing object IDs reborn.
            CleanUpOids();

            // Give each of the volumes an opportunity to upload any pending
            // MoveNotifies.

            // BUGBUG:  Move the MoveBatchTimeout controlling code into CVolumeManager,
            // so that all such control is in one place.

            __try
            {
                continuation = g_ptrkwks->OnMoveBatchTimeout();
            }
            __except( BreakOnDebuggableException() )
            {
                TrkAssert( TRK_E_SERVER_TOO_BUSY == GetExceptionCode() );
                TrkLog(( TRKDBG_ERROR, TEXT("VolInit timer caught %08x during MoveNotify"), GetExceptionCode() ));
                fTimerRetry = TRUE;
            }

            break;

        // Frequent tasks (i.e. ~daily)

        case VOLTIMER_FREQUENT:
            ptimer = &_timerFrequentTasks;

            if( _fFrequentTaskHesitation )
            {
                TrkLog(( TRKDBG_VOLUME, TEXT("Executing frequent tasks") ));
                _fFrequentTaskHesitation = FALSE;
                ulTimerResetPeriod = _pTrkWksConfiguration->GetVolFrequentTasksPeriod() + 1;
                SyncVolumes( PASSIVE );  // Doesn't raise
                ReopenVolumeHandles();
            }
            else
            {
                // Delay a random number of seconds within an interval

                _fFrequentTaskHesitation = TRUE;
                ulTimerResetPeriod = QuasiRandomDword()
                                     %
                                     (1+_pTrkWksConfiguration->GetVolPeriodicTasksHesitation());
                ulTimerResetPeriod++;
                TrkLog(( TRKDBG_VOLUME, TEXT("Hesitating %d seconds before executing frequent tasks"), ulTimerResetPeriod ));
            }

            break;

        // Infrequent tasks (i.e. ~weekly)

        case VOLTIMER_INFREQUENT:
            ptimer = &_timerInfrequentTasks;

            if( _fInfrequentTaskHesitation )
            {
                TrkLog(( TRKDBG_VOLUME, TEXT("Executing infrequent tasks") ));
                _fInfrequentTaskHesitation = FALSE;
                ulTimerResetPeriod = _pTrkWksConfiguration->GetVolInfrequentTasksPeriod() + 1;
                CheckSequenceNumbers();

                // Be aggressive about the sync; if we have not-created volumes, try
                // to create them again even if the last time we got a vol-quota-exceeded
                // error.

                SyncVolumes( AGGRESSIVE );  // Doesn't raise

                // Give each of the volumes an opportunity to upload any pending
                // MoveNotifies.  Again, be aggressive about it in the face of previous
                // quota errors.

                g_ptrkwks->OnMoveBatchTimeout( AGGRESSIVE );

            }
            else
            {
                // Delay a random number of seconds within an interval

                _fInfrequentTaskHesitation = TRUE;
                ulTimerResetPeriod = QuasiRandomDword()
                                     %
                                     (1+_pTrkWksConfiguration->GetVolPeriodicTasksHesitation());
                ulTimerResetPeriod++;
                TrkLog(( TRKDBG_VOLUME, TEXT("Hesitating %d seconds before executing infrequent tasks"), ulTimerResetPeriod ));
            }

            break;

        default:

            TrkAssert( FALSE && TEXT("Invalid timerID in CVolumeManager::Timer") );
            break;

        }   // switch
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception in CVolumeManager::OnVolumeTimer %08x"), GetExceptionCode() ));
    }

    if( fTimerRetry )
        continuation = RETRY_TIMER;
    else if( 0 != ulTimerResetPeriod )
    {
        ptimer->ReInitialize( ulTimerResetPeriod );
        ptimer->SetSingleShot();
        continuation = CONTINUE_TIMER;
    }

    return( continuation );
}

ULONG
CVolumeManager::GetVolumeIds( CVolumeId * pVolumeIds, ULONG cMax )
{
    CVolumeEnumerator   enumerator = Enum();
    CVolume*            pvol = enumerator.GetNextVolume();
    ULONG               cVolumes;
    CVolumeId           volidZero;

    __try
    {
        for( cVolumes = 0;
             cVolumes < cMax && NULL != pvol;
             pvol = enumerator.GetNextVolume()
           )
        {
            *pVolumeIds = pvol->GetVolumeId();
            if (*pVolumeIds != volidZero)
            {
                pVolumeIds ++;
                cVolumes ++;
            }
            pvol->Release();
            pvol = NULL;
        }
    }
    __finally
    {
        enumerator.UnInitialize();
        if(pvol)
        {
            pvol->Release();
            pvol = NULL;
        }
    }

    return(cVolumes);
}


HRESULT
CVolumeManager::OnRestore()
{
    return( E_NOTIMPL );
#if 0

    CVolumeEnumerator   enumerator = Enum();
    CVolume*            pvol = enumerator.GetNextVolume();
    HRESULT             hr = S_OK;
    HRESULT             hrRet = S_OK;

    __try
    {
        for(; NULL != pvol; pvol = enumerator.GetNextVolume())
        {
            hr = pvol->OnRestore();
            if(hr != S_OK && hrRet == S_OK)
            // Return the hr from the first failed volume.
            {
                hrRet = hr;
            }
            pvol->Release();
            pvol = NULL;
        }
    }
    __finally
    {
        enumerator.UnInitialize();
        if(pvol)
        {
            pvol->Release();
            pvol = NULL;
        }
    }


    return hr;

#endif // #if 0

}

BOOL
CVolumeManager::CheckSequenceNumbers()
{
    BOOL fSuccess = FALSE;
    HRESULT hr = S_OK;
    CAvailableDc adc;
    CVolume* rgVolsToCheck[ NUM_VOLUMES ];
    ULONG cVolumes = 0;

    __try
    {
        TRKSVR_SYNC_VOLUME      rgQueryVolumes[ NUM_VOLUMES ];
        ULONG                   v;
        const CVolumeId         volNULL;
        CVolumeEnumerator       enumerator = Enum();
        CVolume*                cvolCur = enumerator.GetNextVolume();

        for(; cvolCur != NULL; cvolCur = enumerator.GetNextVolume())
        {
            rgVolsToCheck[cVolumes] = cvolCur;
            if(cvolCur->LoadQueryVolume(&rgQueryVolumes[cVolumes]))
            {
                cVolumes++;
            }
            else
            {
                cvolCur->Release();
            }
        }

        if( 0 != cVolumes )
        {
            TrkLog(( TRKDBG_VOLUME  | TRKDBG_MOVE, TEXT("Verifying sequence numbers on %d volumes"), cVolumes ));

            _pTrkWks->CallDcSyncVolumes(cVolumes, rgQueryVolumes);


            for( v = 0; v < cVolumes; v++ )
            {
                if( rgVolsToCheck[v]->UnloadQueryVolume( &rgQueryVolumes[v] )
                    &&
                    S_OK == rgQueryVolumes[ v ].hr )
                {
                    TrkLog(( TRKDBG_VOLUME | TRKDBG_MOVE,
                             TEXT("Seq number for volume %c should be %d"),
                             'A'+rgVolsToCheck[v]->GetIndex(),
                             rgQueryVolumes[v].seq ));
                }
                else
                {
                    TrkLog(( TRKDBG_ERROR,
                             TEXT("Couldn't verify the seq number on vol %c"),
                             'A'+rgVolsToCheck[v]->GetIndex() ));

                }
            }   // for( v = 0; v < cVolumes; v++ )

            fSuccess = TRUE;

        }   // if( cVolumes != 0 )
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_VOLUME, TEXT("Couldn't check sequence numbers against server"), GetExceptionCode() ));
    }

    for( ULONG v = 0; v < cVolumes; v++ )
    {
        rgVolsToCheck[v]->Release();
    }   // for( v = 0; v < cVolumes; v++ )

    return( fSuccess );

}

void
CVolumeManager::SetReopenVolumeHandlesTimer()
{
    CFILETIME ft;

    // Start the timer (if it's not already running).
    _timerObjIdIndexReopen.SetRecurring();

    TrkLog(( TRKDBG_VOLUME, TEXT("ReOpen timer: %s"),
             (const TCHAR*)CDebugString(_timerObjIdIndexReopen) ));
}

CVolumeEnumerator
CVolumeManager::Enum( EEnumType eEnumType )
{
    CVolumeEnumerator volenum;

    if( _fVolumesHaveBeenOpenedOnce
        ||
        _fInitialized
        &&
        ENUM_UNOPENED_VOLUMES == eEnumType )
    {
        volenum = CVolumeEnumerator( &_pVolumeNodeListHead, &_csVolumeNodeList );
    }

    return( volenum );
}

CVolume *
CVolumeManager::FindVolume( const CVolumeId &vol )
{
    CVolumeEnumerator   enumerator = Enum();
    CVolume             *pvol = enumerator.GetNextVolume();

    for(; pvol != NULL; pvol = enumerator.GetNextVolume())
    {
        if( pvol->GetVolumeId() == vol )
        {
            break;
        }
        pvol->Release();
    }   // for(; pvol != NULL; pvol = enumerator.GetNextVolume())

    return( pvol );
}


//+----------------------------------------------------------------------------
//
//  CVolumeManager::FlushAllVolumes
//
//  Flush all of the volumes.
//
//+----------------------------------------------------------------------------

void
CVolumeManager::FlushAllVolumes( BOOL fServiceShutdown )
{
    CVolumeEnumerator   enumerator = Enum();
    CVolume             *pvol = enumerator.GetNextVolume();

    for(; pvol != NULL; pvol = enumerator.GetNextVolume())
    {
        __try
        {
            pvol->Flush( fServiceShutdown );
        }
        __except( BreakOnDebuggableException() )
        {
        }
        pvol->Release();
    }
}


//+----------------------------------------------------------------------------
//
//  CVolumeManager::FindVolume
//  
//  Find a volume in the linked-list, given it's device name,
//  and return its CVolume*.
//
//+----------------------------------------------------------------------------

CVolume *
CVolumeManager::FindVolume( const TCHAR *ptszVolumeDeviceName )
{
    CVolumeEnumerator   enumerator = Enum();
    CVolume             *pvol = enumerator.GetNextVolume();

    for(; pvol != NULL; pvol = enumerator.GetNextVolume())
    {
        if( 0 == _tcscmp( pvol->GetVolumeDeviceName(), ptszVolumeDeviceName ))
        {
            break;
        }
        pvol->Release();
    }   // for(; pvol != NULL; pvol = enumerator.GetNextVolume())

    return( pvol );
}




//+----------------------------------------------------------------------------
//
//  CVolumeManager::IsDuplicatevolId
//
//  Check to see if there is a volume, aside from the caller, that
//  has a particular volume ID.  This should never happen, so this
//  method allows a volume to check for it and respond appropriately.
//
//  When checking another volume's volid, we can't take its lock.
//  See the description in CVolume::GetVolumeId.
//
//+----------------------------------------------------------------------------

CVolume *
CVolumeManager::IsDuplicateVolId( CVolume *pvolCheck, const CVolumeId &volid )
{
    CVolumeNode *pVolNode = NULL;
    CVolume *pvol = NULL;
    
    _csVolumeNodeList.Enter();
    __try
    {
    
        pVolNode = _pVolumeNodeListHead;
        while( NULL != pVolNode )
        {
            if( NULL != pVolNode->_pVolume
                &&
                volid == pVolNode->_pVolume->GetVolumeId()    // Doesn't take lock.
                &&
                pvolCheck != pVolNode->_pVolume )
            {
                pvol = pVolNode->_pVolume;
                pvol->AddRef();
                __leave;
            }

            pVolNode = pVolNode->_pNext;
            TrkAssert( pVolNode != _pVolumeNodeListHead );
        }
    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Ignoring exception in IsDuplicateVolId") ));
    }
    _csVolumeNodeList.Leave();

    return pvol;
}


//+----------------------------------------------------------------------------
//
//  CVolumeManager::IsLocal
//
//  Determine if a given volume ID represents a local volume.  Note that
//  if it's not in the linked list of volumes, we'll return false, though
//  the volume may in fact exist on the system (since we don't respond
//  to new volumes after service start).
//
//+----------------------------------------------------------------------------

BOOL
CVolumeManager::IsLocal( const CVolumeId &vol )
{
    CVolume *pvol = FindVolume( vol );

    if( NULL == pvol )
        return FALSE;
    else
    {
        pvol->Release();
        return( TRUE );
    }
}


//+----------------------------------------------------------------------------
//
//  CVolumeManager::Seek
//
//  Seek the specified volume's log to the specified sequence number.
//
//+----------------------------------------------------------------------------

void
CVolumeManager::Seek( CVolumeId vol, SequenceNumber seq )
{
    CVolumeEnumerator   enumerator = Enum();
    CVolume*            cvolCur = enumerator.GetNextVolume();

    for(; cvolCur != NULL; cvolCur = enumerator.GetNextVolume())
    {
        if( cvolCur->GetVolumeId() == vol )
        {
            cvolCur->Seek( seq );
            cvolCur->Release();
            return;
        }
        cvolCur->Release();
    }   // for( ULONG i = 0; i < 26; i++ )
}


//+----------------------------------------------------------------------------
//
//  CVolumeEnumerator::GetNextVolume
//
//  Get the next CVolume* in the enumeration.
//
//+----------------------------------------------------------------------------

CVolume *
CVolumeEnumerator::GetNextVolume()
{
    CVolume *pVol = NULL;

    if( NULL == _ppVolumeNodeListHead )
        return( NULL );

    TrkAssert( NULL != _pcs );

    _pcs->Enter();
    __try
    {

        if( NULL == *_ppVolumeNodeListHead )
        {
            // There are no volumes in the list
            pVol = NULL;
        }
        else if( NULL == _pVolNodeLast )
        {
            // This is a new enumeration.  Pass back the first volume
            pVol = (*_ppVolumeNodeListHead)->_pVolume;
            _pVolNodeLast = *_ppVolumeNodeListHead;
        }
        else
        {
            // Find the next volume in the list, the one that's
            // just beyond _pVolNodeLast.
            // If we terminate this while loop because pVolNode goes to
            // NULL, it means that there are no more volumes left to
            // enumerate.

            CVolumeNode *pVolNode = *_ppVolumeNodeListHead;
            while( NULL != pVolNode )
            {
                if( pVolNode > _pVolNodeLast )
                {
                    pVol = pVolNode->_pVolume;
                    _pVolNodeLast = pVolNode;
                    break;
                }

                pVolNode = pVolNode->_pNext;
            }
        }

        if( NULL != pVol )
            pVol->AddRef();
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        TrkAssert( !TEXT("Unexpected exception in GetNextVolume") );
    }

    _pcs->Leave();
    return( pVol );

}



//+----------------------------------------------------------------------------
//
//  CVolumeManager::DcCallback
//  StubLnkSvrMessageCallback
//
//  When we RPC to trksvr to do a create volume (in the SyncVolumes method),
//  trksvr does an RPC callback on that connection to StubLnkSvrMessageCallback,
//  which in turn calls the DcCallback method.  This was done so that
//  we can verify that the volid actually gets to the volume before taking
//  the hit of writing it into the DS.  (At one point, the request to trksvr
//  was being received, the entry was being put into the DS, but then the
//  response back to trkwks was getting an RPC error, so trkwks would retry
//  the create, etc.
//
//+----------------------------------------------------------------------------

HRESULT CVolumeManager::DcCallback(ULONG cVolumes, TRKSVR_SYNC_VOLUME* rgVolumes)
{
    HRESULT     hr = S_OK;
    BOOL fSuccess = TRUE;

    TrkLog((TRKDBG_VOLUME, TEXT("Dc Callback with %d volumes"), cVolumes ));
    for( ULONG v = 0; v < cVolumes; v++ )
    {
        if( _rgVolumesToUpdate[v]->UnloadSyncVolume( &rgVolumes[v] )
            &&
            rgVolumes[v].hr == S_OK )
        {
            TrkLog(( TRKDBG_VOLUME | TRKDBG_MOVE,
                     TEXT("Volume %c successfully synced with server"),
                     'A'+_rgVolumesToUpdate[v]->GetIndex() ));
        }
        else
        {
            fSuccess = FALSE;
            TrkLog(( TRKDBG_ERROR | TRKDBG_MOVE,
                     TEXT("Couldn't sync vol %c with server (%08x, %s)"),
                     'A'+_rgVolumesToUpdate[v]->GetIndex(),
                     rgVolumes[v].hr, GetErrorString(rgVolumes[v].hr) ));
        }
    }   // for( v = 0; v < cVolumes; v++ )


    if( S_OK == hr )
        return fSuccess ? S_OK : TRK_S_VOLUME_NOT_SYNCED;
    else
        return hr;
}



// DC callback function. When calling CAvailableDc::CallAvailableDc, DC will callback to the
// trkwks service to set the volume ids on the volumes.
HRESULT	StubLnkSvrMessageCallback(TRKSVR_MESSAGE_UNION* pMsg)
{
    return g_ptrkwks->_volumes.DcCallback(pMsg->SyncVolumes.cVolumes, pMsg->SyncVolumes.pVolumes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\volmap.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

// Not currently implemented


#include "pch.cxx"
#pragma hdrstop
#include "trkwks.hxx"


#ifdef VOL_REPL
void
CPersistentVolumeMap::Initialize()
{
    InitializeCriticalSection(&_cs);
    _fInitializeCalled = TRUE;
}

void
CPersistentVolumeMap::UnInitialize()
{
    if (IsOpen())
        CloseFile();
    CVolumeMap::UnInitialize();
    if (_fInitializeCalled)
    {
        DeleteCriticalSection(&_cs);
        _fInitializeCalled = FALSE;
    }
}

CFILETIME
CPersistentVolumeMap::GetLastUpdateTime( )
{
    CFILETIME cft(0);

    EnterCriticalSection(&_cs);

    __try
    {
        if (!IsOpen())
        {
            Load( );
        }

        cft = _cft;
    }
    __finally
    {
        LeaveCriticalSection(&_cs);
    }

    return(cft);
}

void
CPersistentVolumeMap::CopyTo(DWORD * pcVolumes, VolumeMapEntry ** ppVolumeChanges)
{
    EnterCriticalSection(&_cs);

    __try
    {
        if (!IsOpen())
        {
            Load( );    // BUGBUG: we may want to close this file after a period and free the map
        }

        CVolumeMap VolMap;

        CVolumeMap::CopyTo( &VolMap );
        VolMap.MoveTo( pcVolumes, ppVolumeChanges );

    }
    __finally
    {
        LeaveCriticalSection(&_cs);
    }

}

BOOL
CPersistentVolumeMap::FindVolume( const CVolumeId & volume, CMachineId * pmcid )
{
    ULONG i;

    EnterCriticalSection(&_cs);

    __try
    {
        if (!IsOpen())
        {
            Load( );    // BUGBUG: we may want to close this file after a period
        }

        for (i=0; i < _cVolumeMapEntries; i++)
        {
            if (_pVolumeMapEntries[i].volume == volume)
            {
                *pmcid = _pVolumeMapEntries[i].machine;
                break;
            }
        }

    }
    __finally
    {
        LeaveCriticalSection(&_cs);
    }

    return( i != _cVolumeMapEntries );
}

void
CPersistentVolumeMap::Merge( CVolumeMap * pOther )
{
    EnterCriticalSection(&_cs);

    __try
    {
        if (!IsOpen())
        {
            Load( );
        }

        _fMergeDirtiedMap |= CVolumeMap::Merge( pOther );
    }
    __finally
    {
        LeaveCriticalSection(&_cs);
    }
}

void
CPersistentVolumeMap::SetLastUpdateTime( const CFILETIME & cft )
{
    _cft = cft;
    Save();
}

// format:
//  DWORD Version
//  DWORD cVolumeMapEntries
//  CFILETIME time of last query on DC
//  VolumeMapEntry[cVolumeMapEntries]
//  CFILETIME time of last query on DC

void
CPersistentVolumeMap::Load()
{
    TCHAR tsz[MAX_PATH+1];
    DWORD cch = ExpandEnvironmentStrings( TEXT("%systemroot%\\system32\\volumes.trk"),
                    tsz,
                    ELEMENTS(tsz) );

    if (cch >= ELEMENTS(tsz))
    {
        TrkLog((TRKDBG_ERROR, TEXT("CPersistentVolumeMap::Load path too long")));
        TrkRaiseException(TRK_E_PATH_TOO_LONG);
    }

    TrkAssert(!IsOpen());

    RobustlyCreateFile(tsz);

    // after RobustlyCreateFile has succeeded without an exception we know that
    // OpenExistingFile has just returned OK (even after recreating the file.)

    TrkLog((TRKDBG_VOLMAP | TRKDBG_VOLTAB_RESTORE,
        TEXT("CPersistentVolumeMap::Load() - _cftFirstChange = %s"),
        CDebugString(_cft)._tsz));
}

void
CPersistentVolumeMap::Save()
{
    TrkAssert(IsOpen());

    DWORD Version = PVM_VERSION;
    DWORD cbWritten;

    if (0 != SetFilePointer(0, NULL, FILE_BEGIN) ||
        !WriteFile(&Version, sizeof(Version), &cbWritten) ||
        cbWritten != sizeof(Version) ||
        !WriteFile(&_cVolumeMapEntries, sizeof(_cVolumeMapEntries), &cbWritten) ||
        cbWritten != sizeof(_cVolumeMapEntries) ||

        // the following part of the header is read in Load()
        !WriteFile(&_cft, sizeof(_cft), &cbWritten) ||
        cbWritten != sizeof(_cft))
    {
        TrkLog((TRKDBG_ERROR, TEXT("CPersistentVolumeMap::Save() failed")));
        TrkRaiseLastError();
    }

    if (_fMergeDirtiedMap)
    {
        TrkLog((TRKDBG_VOLMAP | TRKDBG_VOLTAB_RESTORE,
            TEXT("CPersistentVolumeMap::Save() - writing map data, _cftFirstChange = %s"),
            CDebugString(_cft)._tsz));
        if (!WriteFile(_pVolumeMapEntries, _cVolumeMapEntries * sizeof(VolumeMapEntry), &cbWritten) ||
             cbWritten != _cVolumeMapEntries * sizeof(VolumeMapEntry))
        {
            TrkLog((TRKDBG_ERROR, TEXT("CPersistentVolumeMap::Save() failed 2")));
            TrkRaiseLastError();
        }
    }
    else
    {
        TrkLog((TRKDBG_VOLMAP | TRKDBG_VOLTAB_RESTORE,
            TEXT("CPersistentVolumeMap::Save() - seeking past map data, _cftFirstChange = %s"),
            CDebugString(_cft)._tsz));

        if (!SetFilePointer(_cVolumeMapEntries * sizeof(VolumeMapEntry), NULL, FILE_CURRENT))
        {
            TrkLog((TRKDBG_ERROR, TEXT("CPersistentVolumeMap::Save() failed 3")));
            TrkRaiseLastError();
        }
    }

    if (!WriteFile(&_cft, sizeof(_cft), &cbWritten) ||
             cbWritten != sizeof(_cft) )
    {
        TrkLog((TRKDBG_ERROR, TEXT("CPersistentVolumeMap::Save() failed 4")));
        TrkRaiseLastError();
    }

    _fMergeDirtiedMap = FALSE;
}

// BUGBUG P2: checksum, header alignment


RCF_RESULT
CPersistentVolumeMap::OpenExistingFile( const TCHAR * ptszFile )
{
    RCF_RESULT r;

    DWORD cVolumeMapEntries;
    DWORD Version;
    NTSTATUS status;

    status = OpenExistingSecureFile(ptszFile);
    if ( NT_SUCCESS(status) )
    {
        TrkAssert(IsOpen());
        DWORD cbRead;

        r = CORRUPT;

        if (ReadFile(&Version, sizeof(Version), &cbRead) &&
            cbRead == sizeof(Version) &&
            Version == PVM_VERSION &&
            ReadFile(&cVolumeMapEntries, sizeof(cVolumeMapEntries), &cbRead) &&
            cbRead == sizeof(cVolumeMapEntries) &&
            cVolumeMapEntries < 100000 &&
            GetFileSize() == sizeof(Version) +
                             sizeof(cVolumeMapEntries) +
                             sizeof(CFILETIME) +
                             cVolumeMapEntries * sizeof(VolumeMapEntry) +
                             sizeof(CFILETIME) )
        {
            CFILETIME cft1, cft2;

            SetSize(cVolumeMapEntries);

            if ( ReadFile( &cft1, sizeof(cft1), &cbRead ) &&
                cbRead == sizeof(cft1)  &&
                (_cVolumeMapEntries == 0 ||
                    ( ReadFile(_pVolumeMapEntries, _cVolumeMapEntries * sizeof(VolumeMapEntry), &cbRead) &&
                      cbRead == _cVolumeMapEntries * sizeof(VolumeMapEntry) ) ) &&
                ReadFile( &cft2, sizeof(cft2), &cbRead ) &&
                cbRead == sizeof(cft2) &&
                memcmp(&cft1, &cft2, sizeof(cft1)) == 0)
            {
                _cft = cft1;
                r = OK;
            }
        }

        if (r != OK)
        {
            CloseFile();
        }
    }
    else
    if (status != STATUS_OBJECT_NAME_NOT_FOUND)
    {
        TrkLog((TRKDBG_ERROR, TEXT("CPersistentVolumeMap::OpenExistingFile() failed %08x"), status));
        TrkRaiseNtStatus(status);
    }
    else
    {
        r = NOT_FOUND;
    }

    TrkLog((TRKDBG_VOLMAP | TRKDBG_VOLTAB_RESTORE,
        TEXT("CPersistentVolumeMap::OpenExistingFile() -> %s"),
        (r == NOT_FOUND ? TEXT("NOT_FOUND") : r == OK ? TEXT("OK") : r == CORRUPT ? TEXT("CORRUPT") : TEXT("unknown"))));

    return (r);
}

// BUGBUG P1: CPersistentVolumeMap::UnInitialize

void
CPersistentVolumeMap::CreateAlwaysFile( const TCHAR * ptszFile )
{
    NTSTATUS status = CreateAlwaysSecureFile(ptszFile);

    if( !NT_SUCCESS(status) )
        TrkRaiseNtStatus( status );

    CVolumeMap::SetSize(0);

    _cft = CFILETIME(0);
    Save();

    CloseFile();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\wkssvc.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+-------------------------------------------------------------------------
//
//  wkssvc.cxx
//
//  Top level class for Tracking (Workstation) Service
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#define INITGUID
#include <guiddef.h>
#include <ioevent.h>
#include <mountmgr.h>   // MOUNTMGR_CHANGE_NOTIFY_INFO, MOUNTDEV_MOUNTED_DEVICE_GUID
#include "trkwks.hxx"
#include <dbt.h>
#include <lmconfig.h>

#define THIS_FILE_NUMBER    WKSSVC_CXX_FILE_NO


#if DBG
DWORD g_Debug = 0;
int CVolume::_cVolumes = 0;
#endif

const extern  TCHAR s_tszKeyNameLinkTrack[] = TEXT("System\\CurrentControlSet\\Services\\TrkWks\\Parameters");

// Initialize the static used by CVerifyAuthentication.
PSID CVerifyAuthentication::_psidAuthenticatedUsersGroup = NULL;

#if TRK_OWN_PROCESS
#pragma message("Building TrkWks for services.exe")
#else
#pragma message("Building TrkWks for separate process")
#endif

//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::Initialize/UnInitialize
//
//  Initialize the tracking service (trkwks).
//
//+----------------------------------------------------------------------------

#if DBG
#include <locale.h>
#endif

void
CTrkWksSvc::Initialize( SVCHOST_GLOBAL_DATA * pSvcsGlobalData )
{
    NTSTATUS Status;


    __try
    {
        g_ptrkwks = this;
        _csDomainNameChangeNotify.Initialize();
        _csmcidDC.Initialize();
        _fInitializeCalled = TRUE;
        _MoveQuotaReached.Initialize();

        // Initialize the entropy object, which is used to generate volume secrets.

        _entropy.Initialize();
        _entropy.Put();

        // Get configuration information from HKLM\System\CurrentControlSet\Services\TrkWks\Parameters
        // This can't be initialized until _entropy is.

        _configWks.Initialize();

        /*
        if( _configWks.UseOperationLog() )
            _OperationLog.Initialize( _configWks.GetOperationLog() );
        */

        #if DBG
        {
            CMachineId mcidLocal( MCID_LOCAL );
            TrkLog(( TRKDBG_WKS,
                     TEXT("Distributed Link Tracking service starting on thread=%d(0x%x) for %hs"),
                     GetCurrentThreadId(), GetCurrentThreadId(),
                     (CHAR*)&mcidLocal ));
            TrkLog(( TRKDBG_WKS, TEXT("Locale:  %hs"), setlocale( LC_ALL, NULL ) ));
        }
        #endif

        // This is a hacked stub that looks and acts like the Win32 thread pool services
        #ifdef PRIVATE_THREAD_POOL
        {
            HRESULT hr = S_OK;
            g_pworkman2 = new CThreadPoolStub;
            if( NULL == g_pworkman2 )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't create the thread pool manager") ));
                TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );
            }

            hr = g_pworkman2->Initialize();
            if( FAILED(hr) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't initialize the thread pool manager") ));
                TrkRaiseException( hr );
            }
        }
        #endif

        // Disable popup dialogs during critical errors
        // (i.e., during NtRaiseHardError).
        RtlSetThreadErrorMode(RTL_ERRORMODE_FAILCRITICALERRORS, NULL);

        // Save the global structure for the services.exe process (though we don't currently
        // use it).
        _pSvcsGlobalData = pSvcsGlobalData;

        // Initialize the object that manages the SCM.
        _svcctrl.Initialize(TEXT("TrkWks"), this);

    #ifdef VOL_REPL
        _persistentVolumeMap.Initialize();
    #endif

        // Initialize our local cache of the VolId->MachineID table (the
        // real table is maintained in the DS)

        _volumeLocCache.Initialize( _configWks.GetParameter( VOLCACHE_TIME_TO_LIVE_CONFIG ));

        _entropy.Put();

        // Initialize the helper class that we use for validating that callers
        // are in the Authenticated Users group

        CVerifyAuthentication::Initialize();

        // See if we're in a domain, and initialize timers, etc., accordingly

        CheckForDomainOrWorkgroup();

        // These synchronization objects are used during test to emulate
        // race conditions.

        #if DBG
        if (_configWks.GetTestFlags() & TRK_TEST_FLAG_MOVE_BATCH_SYNC)
            _testsyncMoveBatch.Initialize(TEXT("MoveBatchTimeout"));

        if (_configWks.GetTestFlags() & TRK_TEST_FLAG_TUNNEL_SYNC)
            _testsyncTunnel.Initialize(TEXT("TunnelSync"));
        #endif


        // Build up a linked list of volume structures.

        _volumes.Initialize( static_cast<CTrkWksSvc*>(this), &_configWks, this,
                             _svcctrl._ssh
                             #if DBG
                             ,&_testsyncTunnel
                             #endif
                             );

        /*
        if( !_configWks._fIsWorkgroup )
        {
            _volumes.InitializeDomainObjects();
            _volumes.StartDomainTimers();
        }
        */

        //_mountmanager.Initialize( this, &_volumes );

        // Initialize the LPC port which receives the up-calls from the kernel
        // during a MoveFile notification

        _port.Initialize(this, _configWks.GetPortThreadKeepAliveTime() );

        // Initialize our RPC server, which receives requests to mend from shell shortcuts,
        // and requests to search from other trkwks instances (on other machines).

        _rpc.Initialize( _pSvcsGlobalData, &_configWks );

        // Initialize an object that handles changes to the domain name (i.e., when
        // we move into a new domain).

        _dnchnotify.Initialize();


        // Register with PNP to be notified of events from the volume mount manager
        // (i.e. drives appearing and disappearing).
        /*
        DEV_BROADCAST_DEVICEINTERFACE  DevClass;
        memset( &DevClass, 0, sizeof(DevClass) );
        DevClass.dbcc_size=sizeof(DEV_BROADCAST_DEVICEINTERFACE);
        DevClass.dbcc_devicetype=DBT_DEVTYP_DEVICEINTERFACE;
        memcpy( &DevClass.dbcc_classguid, &MOUNTDEV_MOUNTED_DEVICE_GUID, sizeof(DevClass.dbcc_classguid) );

        _hdnDeviceInterface = RegisterDeviceNotification( reinterpret_cast<HANDLE>(_svcctrl._ssh),
                                                          &DevClass,
                                                          DEVICE_NOTIFY_SERVICE_HANDLE);
        if( NULL == _hdnDeviceInterface )
        {
            // There's nothing we can do, so we'll just ignore the error.
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't register w/PNP for DeviceInterface broadcasts (%08x)"),
                     HRESULT_FROM_WIN32(GetLastError()) ));
        }
        else
            TrkLog(( TRKDBG_WKS, TEXT("Registered for device interface notifications") ));
        */


        // Start the port that receives move notifications from ntos
        _port.EnableKernelNotifications();

        // Let that SCM know that we're running

        _svcctrl.SetServiceStatus(SERVICE_RUNNING,
                                  SERVICE_ACCEPT_STOP |
                                  SERVICE_ACCEPT_SHUTDOWN,    // for log safe closedown
                                  NO_ERROR);
    }
    __except( BreakOnDebuggableException() )
    {
        TrkReportEvent( EVENT_TRK_SERVICE_START_FAILURE, EVENTLOG_ERROR_TYPE,
                        static_cast<const TCHAR*>( CHexStringize( GetExceptionCode() )),
                        NULL );
        TrkRaiseException( GetExceptionCode() );
    }

}



//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::UnInitialize
//
//  Called during service stop to close everything down and clean up.
//
//+----------------------------------------------------------------------------

void
CTrkWksSvc::UnInitialize(HRESULT hr)
{
    if (_fInitializeCalled)
    {
        TrkLog(( TRKDBG_WKS, TEXT("Stopping TrkWks Service") ));


        /*
        UnregisterDeviceNotification( _hdnDeviceInterface );
        _hdnDeviceInterface = NULL;
        */

        // Force the volumes to close their handles.  We do this now because
        // some of the following calls could block

        _volumes.FlushAllVolumes( TRUE );   // TRUE => fServiceShutdown
        _volumes.CloseVolumeHandles();

        IFDBG( _testsyncTunnel.UnInitialize(); )
        IFDBG( _testsyncMoveBatch.UnInitialize(); )

        // Cancel any out-going RPCs on threads in this service

        if( NULL != g_pActiveThreadList )
            g_pActiveThreadList->CancelAllRpc();

        // Close down our RPC server and LPC port.  Each will block until
        // all active threads have exited.  Once these two calls have completed,
        // we know that the current thread is the only thread in the service.

        _rpc.UnInitialize( _pSvcsGlobalData );
        _port.UnInitialize();
        CVerifyAuthentication::Uninitialize();

        //_mountmanager.UnInitialize();
        _dnchnotify.UnInitialize();


        // Stop the timers before stopping the volumes.  That way we don't have
        // a Refresh or MoveNotify going on while the volumes are being deleted.

        _volumes.UnInitializeDomainObjects();

        _volumes.UnInitialize();
        _volumeLocCache.UnInitialize();

#ifdef VOL_REPL
        _persistentVolumeMap.UnInitialize();
#endif

        _entropy.UnInitialize();

        #if PRIVATE_THREAD_POOL
        {
            g_pworkman2->UnInitialize();
            delete g_pworkman2;
            g_pworkman2 = NULL;
        }
        #endif

        _csDomainNameChangeNotify.UnInitialize();
        _fInitializeCalled = FALSE;

        if (_configWks.GetTestFlags() & TRK_TEST_FLAG_WAIT_ON_EXIT)
        {
            TrkLog((TRKDBG_ERROR, TEXT("Waiting 60 seconds before exitting for heap dump")));
            Sleep( 60 * 1000 );
        }


        TrkAssert( 0 == g_cTrkWksRpcThreads );
        g_ptrkwks = NULL;
        _fInitialized = FALSE;

        TrkLog((TRKDBG_WKS, TEXT("CVolume::_cVolumes = %d"), CVolume::_cVolumes ));
        TrkAssert( 0 == CVolume::_cVolumes );

        // This must be the last call.

        if( (hr & 0x0FFF0000) == FACILITY_WIN32 )
            hr = hr & ~(0x0FFF0000);
        _svcctrl.SetServiceStatus(SERVICE_STOPPED, 0, hr);

        //_svcctrl.UnInitialize();
    }
}





//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::CheckForDomainOrWorkgroup
//
//  Determine if this computer is a member of a domain or just a workgroup.
//  Even if we're in a domain, there might be a policy setting in the registry
//  that tells us that we should behave as if we're in a workgroup (i.e. don't
//  talk to the DC for anything).
//
//  The result of this check is stored in _configWks._fIsWorkgroup.
//
//+----------------------------------------------------------------------------

void
CTrkWksSvc::CheckForDomainOrWorkgroup()
{
    NET_API_STATUS NetStatus;
    WCHAR * pwszDomain = NULL;
    BOOLEAN fIsWorkGroup = TRUE;
    ULONG   lResult;
    HKEY    hkey = NULL;
    DWORD   dwType;
    DWORD   dwValue;
    DWORD   cbValue = sizeof(dwValue);

    __try
    {
        // Check to see if we're in a domain or a workgroup.

        NetStatus = NetpGetDomainNameEx(&pwszDomain, &fIsWorkGroup);

        if (NetStatus != NO_ERROR)
        {
            pwszDomain = NULL;
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, HRESULT_FROM_WIN32(NetStatus),
                                    TRKREPORT_LAST_PARAM );
            TrkRaiseWin32Error(NetStatus);
        }

        TrkLog(( TRKDBG_WKS, TEXT("In %s %s"), fIsWorkGroup ? TEXT("workgroup") : TEXT("domain"), pwszDomain ));

        // If we're in a workgroup, we don't need to check the behave-like-your-in-a-workgroup
        // policy setting.

        if( fIsWorkGroup )
            __leave;

        // Read registry to see if DC tracking is allowed, otherwise we'll just
        // act like we're in a workgroup.  This key is set by the policy manager.

        fIsWorkGroup = TRUE;

        lResult = RegOpenKey(HKEY_LOCAL_MACHINE,
                               TEXT("Software\\Policies\\Microsoft\\Windows\\System"),
                               &hkey);
        if(ERROR_SUCCESS == lResult)
        {
            lResult = RegQueryValueEx(hkey,
                                      TEXT("DLT_AllowDomainMode"),
                                      NULL,
                                      &dwType,
                                      (LPBYTE)&dwValue,
                                      &cbValue);
            if(ERROR_SUCCESS == lResult)
            {
                if(REG_DWORD == dwType)
                {
                    if( dwValue )
                    {
                        fIsWorkGroup = FALSE;
                        TrkLog((TRKDBG_WKS, TEXT("Domain link tracking *allowed* by policy")));
                    }
                    else
                    {
                        fIsWorkGroup = TRUE;
                        TrkLog((TRKDBG_WKS, TEXT("Domain link tracking not allowed by policy")));
                    }
                }
            }
        }

    }
    __finally
    {
        if( NULL != hkey )
            RegCloseKey(hkey);

        if( NULL != pwszDomain )
            NetApiBufferFree(pwszDomain);
    }

    _configWks._fIsWorkgroup = fIsWorkGroup;

}





//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::OnPortNotification
//
//  This method is called when the service receives a message at its
//  LPC port from the kernel.  This message is always a move notification,
//  and its comes here via a CPort object.  The message is handled
//  off to the CVolumeManager object, which finds the correct CVolume
//  object to ultimately handle the notification.
//
//+----------------------------------------------------------------------------

NTSTATUS
CTrkWksSvc::OnPortNotification(const TRKWKS_REQUEST *pRequest)
{
    NTSTATUS Status;

    Status = STATUS_SUCCESS;

    _entropy.Put();

    // Test hook:  return an error on the port notification rather than
    // doing any processing.

    if( 0 != _configWks.GetPortNotifyError() )
    {
        TrkLog(( TRKDBG_PORT, TEXT("Returning explicit error per configuration (0x%x)"),
                 _configWks.GetPortNotifyError() ));
        return( _configWks.GetPortNotifyError() );
    }
    else if( _configWks.GetIgnoreMovesAndDeletes() )
    {
        TrkLog(( TRKDBG_PORT, TEXT("Ignoring move due to configuration") ));
        return( STATUS_SUCCESS );
    }

    __try   // __except
    {
        LARGE_INTEGER liDueTime;

        // Abort if the service is being stopped.
        RaiseIfStopped();

        // Verify that the machine ID has a zero in it.

        for( int i = 0; i < sizeof(pRequest->MoveMessage.MachineId); i++ )
        {
            if( '\0' == ((BYTE*)&pRequest->MoveMessage.MachineId)[i] )
                break;
        }
        if( i == sizeof(pRequest->MoveMessage.MachineId) )
            TrkRaiseWin32Error( ERROR_INVALID_COMPUTERNAME );

        // Append this notification to the end of the appropriate volume log.

        switch (pRequest->dwRequest)
        {
        case TRKWKS_RQ_MOVE_NOTIFY:

            CLogMoveMessage lm( pRequest->MoveMessage );
            CDomainRelativeObjId droidZero;

            // Verify that the IDs are non-zero.

            if( droidZero == lm._droidCurrent||
                droidZero == lm._droidNew ||
                droidZero == lm._droidBirth )
            {
                TrkLog(( TRKDBG_WKS, TEXT("Invalid ID in move notification: %s %s %s"),
                    droidZero == lm._droidCurrent ? TEXT("Current") : TEXT(""),
                    droidZero == lm._droidNew     ? TEXT("New")     : TEXT(""),
                    droidZero == lm._droidBirth   ? TEXT("Birth")   : TEXT("") ));
                TrkRaiseWin32Error( ERROR_INVALID_DATA );
            }


            TrkLog((TRKDBG_PORT | TRKDBG_MOVE,
                TEXT("Port:\n      Current=%s\n      New    =%s:%s\n      Birth  =%s"),
                (const TCHAR*)CDebugString(lm._droidCurrent),
                (const TCHAR*)CDebugString(lm._mcidNew),
                (const TCHAR*)CDebugString(lm._droidNew),
                (const TCHAR*)CDebugString(lm._droidBirth) ));

            g_ptrkwks->_volumes.Append(
                lm._droidCurrent,
                lm._droidNew,
                lm._mcidNew,
                lm._droidBirth
                );

            // Take this opportunity to cache the volid-to-mcid mapping,
            // so we might be able to avoid a DC call later.

            _volumeLocCache.AddVolume( lm._droidNew.GetVolumeId(), lm._mcidNew );

            break;
        }
    }
    __except(BreakOnDebuggableException())
    {
        Status = GetExceptionCode();
    }

    return Status;
}



//+----------------------------------------------------------------------------
//
//  GetSvrMessagePriority
//
//  This method is used to determine the priority of a message that's going
//  to be sent to trksvr (priority 9 is the low, 0 is high).  When trksvr
//  gets too busy, it uses these priorities to determine which requests
//  to reject.
//
//  The priority is based on the length of time the caller's activity is
//  past due; the further it is past due (relative to the frequency of the
//  activity), the higher it's priority.
//
//  For example, a once-per-month activity that's one week past due will
//  get a moderate priority, while a once-per-week activity that's one
//  week past due will get the highest priority.
//
//+----------------------------------------------------------------------------


TRKSVR_MESSAGE_PRIORITY
GetSvrMessagePriority(
    LONGLONG llLastDue,
    LONGLONG llPeriod ) // pass in in seconds
{
    LONGLONG llDiff = CFILETIME() - llLastDue;

    TrkAssert( 0 != llLastDue );

    llPeriod *= 10000000;

    if ( llDiff < 0 )
    {
        return(PRI_9);
    }
    else
    if ( llDiff >= llPeriod )
    {
        return(PRI_0);
    }
    else
    {
        return (TRKSVR_MESSAGE_PRIORITY) ( 9 - (llDiff * 10) / llPeriod );
    }
}


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::GetDcName
//
//  Get the appropriate DC computer name for this domain.  If fForce, we'll
//  do a domain-rediscovery, otherwise we'll return the cached value (assuming
//  it exists).  
//
//+----------------------------------------------------------------------------

CMachineId
CTrkWksSvc::GetDcName( BOOL fForce )
{
    CMachineId mcid;
    
    if( _rpc.UseCustomDc() )
        // The registry specifies which DC to use (and that we shouldn't use Kerberos).
        mcid = CMachineId( _rpc.GetCustomDcName() );
    else if( _rpc.UseCustomSecureDc() )
        // The registry specifies which DC to use
        mcid = CMachineId( _rpc.GetCustomSecureDcName() );
    else
        mcid = CMachineId( fForce ? MCID_DOMAIN_REDISCOVERY : MCID_DOMAIN );

    return mcid;
}


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::OnRefreshTimeout
//
//  Called when the refresh timer signals.  Upload all volume IDs and
//  birth IDs on this system to the DC, so that it can mark them in
//  its tables as active.  The DC (trksvr) automatically garbage collects
//  objects which are not active for a period of time.
//
//  The first time this routine is called, it does nothing and restarts the
//  timer for a randome amount of time.  That way, if a large number
//  of machines are booted at once, and they all need to send a refresh,
//  they will not all do so at the same time.
//
//+----------------------------------------------------------------------------


PTimerCallback::TimerContinuation
CTrkWksSvc::OnRefreshTimeout( CFILETIME cftOriginalDueTime,
                              ULONG ulPeriodInSeconds )
{
    PTimerCallback::TimerContinuation continuation = PTimerCallback::RETRY_TIMER;

    __try
    {
        TrkLog((TRKDBG_WKS | TRKDBG_GARBAGE_COLLECT, TEXT("CTrkWksSvc::OnRefreshTimeout")));


        // We'ave already hesitated.  Now is the time to upload all the IDs.

        const ULONG      cBatch = REFRESH_OBJECT_BATCH_SIZE; //128;
        CVolumeId        *avolid = new CVolumeId[26];
        ULONG            cVolumes;
        CObjId           *aobjid = new CObjId[cBatch];
        CAvailableDc     adc;
        int              cSources=0;

        CDomainRelativeObjId       *adroid = new CDomainRelativeObjId[cBatch];
        CAllVolumesObjIdEnumerator *pAllSources = new CAllVolumesObjIdEnumerator;


        __try
        {
            // Get an array of all the volume IDs.

            cVolumes = _volumes.GetVolumeIds( avolid, 26 );

            if( NULL == avolid || NULL == aobjid || NULL == adroid || NULL == pAllSources )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Out of memory in OnRefreshTimeout") ));
                TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );
            }

            // The AllSources enumerator enums all the files on all the volumes.

            if (pAllSources->FindFirst( &_volumes, &aobjid[cSources], &adroid[cSources] ))
            {
                do  // while ( pAllSources->FindNext( &aobjid[cSources], &adroid[cSources]) );
                {

                    RaiseIfStopped();

                    // If this link source has been in a cross-volume move, then we
                    // need to upload it.  Normalize the value, and increment the count
                    // (so that we'll keep it).

                    if (adroid[cSources].GetVolumeId().GetUserBitState()) // if moved across volumes
                    {
                        adroid[cSources].GetVolumeId().Normalize();
                        cSources ++;
                    }

                    // If we have enough link sources for a batch, send them up now.

                    if (cSources == cBatch)
                    {
                        TRKSVR_MESSAGE_UNION Msg;

                        Msg.MessageType = REFRESH;

                        // Set the priority based on how long we're overdue.

                        Msg.Priority = GetSvrMessagePriority(
                            cftOriginalDueTime,
                            ulPeriodInSeconds );

                        Msg.Refresh.cSources = cSources;
                        Msg.Refresh.adroidBirth = adroid;

                        Msg.Refresh.cVolumes = cVolumes;
                        Msg.Refresh.avolid = cVolumes == 0 ? NULL : avolid;

                        TrkLog((TRKDBG_WKS | TRKDBG_GARBAGE_COLLECT,
                            TEXT("CTrkWksSvc::OnRefreshTimeout calling DC with %d volumes, ")
                            TEXT("%d sources, %d priority"), cVolumes, cSources, Msg.Priority ));

                        // If the DC is down we'll get an exception.  This will cause the
                        // timer to go into a retry.

                        adc.CallAvailableDc(&Msg);

                        cSources = 0;
                        cVolumes = 0;
                    }
                } while ( pAllSources->FindNext( &aobjid[cSources], &adroid[cSources]) );
            }

            // Upload the final block of link sources (which is smaller than a normal
            // batch size).

            if (cVolumes != 0 || cSources != 0)
            {
                TRKSVR_MESSAGE_UNION Msg;

                Msg.MessageType = REFRESH;

                TrkLog(( TRKDBG_WKS | TRKDBG_GARBAGE_COLLECT,
                         TEXT("Refresh priority based on %I64i"),
                         static_cast<LONGLONG>( CFILETIME() - cftOriginalDueTime ) ));

                Msg.Priority = GetSvrMessagePriority(
                    cftOriginalDueTime,
                    ulPeriodInSeconds );

                Msg.Refresh.cSources = cSources;
                Msg.Refresh.adroidBirth = cSources == 0 ? NULL : adroid;

                Msg.Refresh.cVolumes = cVolumes;
                Msg.Refresh.avolid = cVolumes == 0 ? NULL : avolid;

                TrkLog((TRKDBG_WKS | TRKDBG_GARBAGE_COLLECT,
                    TEXT("CTrkWksSvc::OnRefreshTimeout calling DC with %d volumes, ")
                    TEXT("%d sources, %d priority"), cVolumes, cSources, Msg.Priority ));

                adc.CallAvailableDc(&Msg);
            }
        }
        __finally
        {
            pAllSources->UnInitialize();

            adc.UnInitialize();

            if( NULL != avolid )
                delete[] avolid;
            if( NULL != aobjid )
                delete[] aobjid;
            if( NULL != adroid )
                delete[] adroid;
            if( NULL != pAllSources )
                delete pAllSources;
        }

        // Put the timer back into it's original mode, so that it will go
        // off in the next period (one month?).

        continuation = PTimerCallback::CONTINUE_TIMER;

        TrkLog((TRKDBG_WKS | TRKDBG_GARBAGE_COLLECT,
            TEXT("CTrkWksSvc::OnRefreshTimeout successfully refreshed DC")));

    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_WARNING,
                 TEXT("Ignoring exception in CVolumeManager::OnRefreshTimeout (%08x)"),
                 GetExceptionCode() ));
    }


    return( continuation );
}



//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::OnEntriesAvailable
//
//  Pass this on to the volume manager.
//
//+----------------------------------------------------------------------------

void
CTrkWksSvc::OnEntriesAvailable()
{
    _volumes.OnEntriesAvailable();
}


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::OnMoveBatchTimeout
//
//  Called by the _timerNotify when it expires so that we can send all
//  move notifications to the DC that haven't been sent.
//
//+----------------------------------------------------------------------------


PTimerCallback::TimerContinuation
CTrkWksSvc::OnMoveBatchTimeout( EAggressiveness eAggressiveness )
{
    HRESULT hr;
    BOOL fSuccess = FALSE;
    SequenceNumber seqLog;
    CAvailableDc     adc;
    CVolume * pVol = NULL;
    ULONG cSendsToServer = 0;
    PTimerCallback::TimerContinuation continuation = PTimerCallback::BREAK_TIMER;

    TrkLog((TRKDBG_MOVE | TRKDBG_WKS, TEXT("CTrkWksSvc::OnMoveBatchTimeout")));

    IFDBG( _testsyncMoveBatch.ReleaseAndWait(); )

    // If we found ourselves to be above quota recently, and we're not
    // being aggressive, then do nothing.

    if( PASSIVE == eAggressiveness && _MoveQuotaReached.IsSet() )
    {
        TrkLog(( TRKDBG_LOG, TEXT("Skipping OnMoveBatchTimeout, move quota was exceeded before") ));
        return( PTimerCallback::BREAK_TIMER );
    }

    // Ensure that we're the only thread trying to do a MoveNotify.
    // If we're not, then simple abort this call; we'll assume
    // that the other thread will take care of things.

    if( !BeginSingleInstanceTask( &_cOnMoveBatchTimeout ))
    {
        TrkLog(( TRKDBG_LOG, TEXT("Skipping OnMoveBatchTimeout") ));
        return( PTimerCallback::BREAK_TIMER );
    }

    //
    // The move batch timeout has expired. We are in a different thread to
    // that which may be concurrently writing the log and starting another
    // move batch time period.
    // We then get the current range of log entries that need to be sent to
    // the DC. The range may be empty because we may have read everything out
    // of the log during a thread switch at NoteXXXX in OnPortNotification.
    //

    __try
    {

        CVolumeEnumerator VolumeEnum;
        ULONG cPerVolumePasses = 0;

        // Iterate through an enumeration of the volumes.

        VolumeEnum = _volumes.Enum();
        while (pVol = VolumeEnum.GetNextVolume())
        {

            CObjId rgobjidCurrent[MOVE_BATCH_SIZE];
            CDomainRelativeObjId rgdroidBirth[MOVE_BATCH_SIZE];
            CDomainRelativeObjId rgdroidNew[MOVE_BATCH_SIZE];

            // Don't do anything if the volumes isn't owned.

            if( CVolume::VOL_STATE_OWNED != pVol->GetState() )
            {
                TrkLog(( TRKDBG_WKS, TEXT("Skipping MoveNotify on volume %c:; it is not in the owned state"),
                    VolChar(pVol->GetVolIndex()) ));

                // Skip to the next volume.

                pVol->Release();
                continue;
            }

            ULONG   cNotifications = sizeof(rgobjidCurrent)/sizeof(rgobjidCurrent[0]);
            BOOL fForceSeqNumber = FALSE;

            __try   // __except
            {
                // Read a batch of move notifications from this volume's log.

                pVol->Read(rgobjidCurrent, rgdroidBirth, rgdroidNew, &seqLog, &cNotifications);

                // Process entries from the log
#if DBG
                if( 0 == cNotifications )
                    TrkLog(( TRKDBG_LOG, TEXT("Nothing to send for %c:"), VolChar(pVol->GetVolIndex()) ));
#endif

                while( cNotifications )
                {
                    // Pass the entries up to the server.

                    // Abort if the service is stopping
                    RaiseIfStopped();

                    // Also abort if we're putting too much strain on the server

                    if( ++cSendsToServer > _configWks.GetMaxSendsPerMoveNotify() )
                    {
                        TrkLog(( TRKDBG_LOG, TEXT("Too many moves are going to the server, aborting for now") ));
                        TrkRaiseException( TRK_E_SERVER_TOO_BUSY );
                    }

                    TRKSVR_MESSAGE_UNION Msg;
                    CVolumeId volid = pVol->GetVolumeId();

                    Msg.MessageType = MOVE_NOTIFICATION;
                    Msg.Priority = PRI_0;

                    Msg.MoveNotification.cNotifications = cNotifications;
                    Msg.MoveNotification.seq = seqLog;
                    Msg.MoveNotification.fForceSeqNumber = fForceSeqNumber;
                    Msg.MoveNotification.pvolid = &volid;
                    Msg.MoveNotification.rgobjidCurrent = rgobjidCurrent;
                    Msg.MoveNotification.rgdroidBirth = rgdroidBirth;
                    Msg.MoveNotification.rgdroidNew = rgdroidNew;
                    Msg.MoveNotification.cProcessed = 0;

                    TrkLog(( TRKDBG_MOVE | TRKDBG_WKS, TEXT("Sending %d move %s for %c: (seq=%d)."),
                             cNotifications,
                             cNotifications > 1 ? TEXT("notifications") : TEXT("notification"),
                             VolChar(pVol->GetVolIndex()), seqLog ));

                    hr = adc.CallAvailableDc(&Msg);
                    TrkAssert( SUCCEEDED(hr) );

                    // If the upload was successful (even if not complete),
                    // advance the read pointer in the log.

                    if( S_OK == hr )
                    {
                        TrkLog(( TRKDBG_MOVE | TRKDBG_WKS, TEXT("MoveNotify succeeded") ));
                        _MoveQuotaReached.Clear();

                        // Advance the read cursor in the log.
                        pVol->Seek(SEEK_CUR, Msg.MoveNotification.cProcessed );

                        if( Msg.MoveNotification.cProcessed != cNotifications )
                        {
                            // The server is being over-loaded, and not everything
                            // was uploaded.  Try again later to upload the rest.

                            hr = TRK_E_SERVER_TOO_BUSY;
                            TrkLog(( TRKDBG_ERROR,
                                     TEXT("OnMoveBatchTimeout server too busy (%d entries processed)"),
                                     Msg.MoveNotification.cProcessed ));
                            __leave;
                        }
                        else
                        {
                            // After a good upload, we don't expect the sequence
                            // numbers to be out of sync.

                            fForceSeqNumber = FALSE;
                        }
                    }

                    // We had an error.  See if it's because we're out
                    // of sync with the server

                    else
                    if ( hr == TRK_S_OUT_OF_SYNC )
                    {

                        TrkAssert( seqLog != Msg.MoveNotification.seq );
                        TrkAssert( !fForceSeqNumber );

                        // Are we ahead or behind the server?

                        if( seqLog < Msg.MoveNotification.seq )
                        {
                            // We're behind the server (probably because we were restored).
                            // Just tell the server to take our sequence number.

                            TrkAssert( !fForceSeqNumber );
                            fForceSeqNumber = TRUE;
                        }
                        else
                        {
                            // We're ahead of the server.  Let's back up our log
                            // so that everything the server needs will get uploaded.
                            // If this sequence number isn't in the log, then just
                            // force the server to take everything we have.

                            if( !pVol->Seek( Msg.MoveNotification.seq ))
                                fForceSeqNumber = TRUE;
                        }
                    }

                    // Or maybe the error is that we don't currently own the volume
                    // from which this file was moved.

                    else
                    if( TRK_S_VOLUME_NOT_FOUND == hr
                        ||
                        TRK_S_VOLUME_NOT_OWNED == hr
                      )
                    {
                        TrkLog(( TRKDBG_LOG, TEXT("Volume %c: found to be not-owned during MoveNotify"),
                                 TEXT('A')+pVol->GetVolIndex() ));
                        pVol->SetState( CVolume::VOL_STATE_NOTOWNED );
                        break; // Move on to the next volume
                    }

                    // Or maybe we hit the move notification quota limit

                    else
                    if( TRK_S_NOTIFICATION_QUOTA_EXCEEDED == hr )
                    {
                        TrkLog(( TRKDBG_MOVE|TRKDBG_WKS, TEXT("Hit move limit after %d entries"),
                                 Msg.MoveNotification.cProcessed ));
                        _MoveQuotaReached.Set();

                        // Advance the read cursor in the log.
                        if( 0 != Msg.MoveNotification.cProcessed )
                            pVol->Seek(SEEK_CUR, Msg.MoveNotification.cProcessed );

                        __leave;
                    }


                    else
                        TrkRaiseException(hr);

                    // Get the next batch of data to be uploaded.

                    Sleep( 5000 );  // Pause a little to be sure we're not overloading.

                    cNotifications = sizeof(rgobjidCurrent)/sizeof(rgobjidCurrent[0]);
                    pVol->Read(rgobjidCurrent, rgdroidBirth, rgdroidNew, &seqLog, &cNotifications);

                }   // while( cNotifications )

                pVol->Flush();

            }   // __try
            __except( IsErrorDueToLockedVolume(GetExceptionCode())
                      ? EXCEPTION_EXECUTE_HANDLER
                      : EXCEPTION_CONTINUE_SEARCH )
            {
                // This volume is locked, so there's nothing we can do other
                // than just carry on to the next volume.
            }

            pVol->Release();
            pVol = NULL;

            // If we're at quota, there's no point in continuing
            if( _MoveQuotaReached.IsSet() )
            {
                TrkLog(( TRKDBG_MOVE|TRKDBG_WKS, TEXT("Stopping move notifications due to quota") ));
                break;
            }

        } // while (pVol = VolumeEnum.GetNextVolume())

    }   // __try
    __except (BreakOnDebuggableException())
    {
        hr = GetExceptionCode();

        // Restart the timer for a retry (with backoff).
        continuation = PTimerCallback::RETRY_TIMER;
        TrkLog((TRKDBG_MOVE | TRKDBG_WKS, TEXT("Retrying move notify (%08x)"), GetExceptionCode() ));
    }

    EndSingleInstanceTask( &_cOnMoveBatchTimeout  );

    if (pVol)
    {
        pVol->Release();
    }


    // If we failed because the server is too busy, don't do a normal continuation

    if( TRK_E_SERVER_TOO_BUSY == hr )
        TrkRaiseException( hr );

    return( continuation );

}


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::ServiceHandler
//
//  This method is the service control handler callback function, which is
//  called by the SCM.  We handle service messages (start/stop/shutdown),
//  and PNP messages.
//
//  NOTE:   In services.exe, this method is called on the one and only ServiceHandler
//          thread.  So while we execute, no other service in this process can
//          receive notifications.  Thus it is important that we do nothing
//          blocking or time-consuming here.
//
//+----------------------------------------------------------------------------

DWORD
CTrkWksSvc::ServiceHandler(DWORD dwControl,
                           DWORD dwEventType,
                           PVOID EventData,
                           PVOID pData)
{
    DWORD       dwRet = NO_ERROR;
    NTSTATUS    status;

    switch (dwControl)
    {

    //  ----------------
    //  Service Messages
    //  ----------------

    case SERVICE_CONTROL_SHUTDOWN:
    case SERVICE_CONTROL_STOP:

        // Stop receiving move notifications from NTOS
        _port.DisableKernelNotifications();

        /*
        // Run the service cleanup on a worker thread.  Run it
        // as a long function, so that when we do an LPC connect
        // in CPort::UnInitialize, the thread pool will be willing to create
        // a thread for CPort::DoWork to process the connect.

        status = TrkQueueWorkItem( (PWorkItem*)this, WT_EXECUTELONGFUNCTION );
        if( !NT_SUCCESS(status) )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't queue service stop to thread pool") ));
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__,
                                    status,
                                    TRKREPORT_LAST_PARAM );
        }
        */

        ServiceStopCallback( this, FALSE );

        break;

    case SERVICE_CONTROL_PAUSE:
        break;
    case SERVICE_CONTROL_CONTINUE:
        break;
    case SERVICE_CONTROL_INTERROGATE:
        break;

    //  ------------
    //  PNP messages
    //  ------------

    case SERVICE_CONTROL_DEVICEEVENT:

        switch( dwEventType )
        {
        
        // PNP events identified by GUID:  Volume lock/unlock/lockfail, plus
        // volume mount/dismount.

        case DBT_CUSTOMEVENT:
            {

                PDEV_BROADCAST_HANDLE pbh = reinterpret_cast<PDEV_BROADCAST_HANDLE>(EventData);

                if( pbh->dbch_devicetype == DBT_DEVTYP_HANDLE )
                {
                    TrkAssert(pbh->dbch_hdevnotify);

                    if( pbh->dbch_eventguid == GUID_IO_VOLUME_LOCK )
                    {
                        // Never raises
                        TrkLog(( TRKDBG_WKS, TEXT("Received volume lock notification (%p)"),
                                 pbh->dbch_hdevnotify ));
                        _volumes.OnVolumeLock( pbh->dbch_hdevnotify );
                    }
                    else if( pbh->dbch_eventguid == GUID_IO_VOLUME_UNLOCK )
                    {
                        // Doesn't raise or block
                        TrkLog(( TRKDBG_WKS, TEXT("Received volume unlock notification (%p)"),
                                 pbh->dbch_hdevnotify ));
                        _volumes.OnVolumeUnlock( pbh->dbch_hdevnotify );
                    }
                    else if( pbh->dbch_eventguid == GUID_IO_VOLUME_LOCK_FAILED )
                    {
                        // Doesn't raise or block
                        TrkLog(( TRKDBG_WKS, TEXT("Received volume lock fail notification (%p)"),
                                 pbh->dbch_hdevnotify ));
                        _volumes.OnVolumeLockFailed(pbh->dbch_hdevnotify);
                    }
                    else if( pbh->dbch_eventguid == GUID_IO_VOLUME_DISMOUNT )
                    {
                        TrkLog(( TRKDBG_WKS, TEXT("Volume Dismount") ));
                        _volumes.OnVolumeDismount( pbh->dbch_hdevnotify );
                    }
                    else if( pbh->dbch_eventguid == GUID_IO_VOLUME_MOUNT )
                    {
                        TrkLog(( TRKDBG_WKS, TEXT("Volume Mount") ));
                        _volumes.OnVolumeMount( pbh->dbch_hdevnotify );
                    }
                }

            }
            break;


        case DBT_DEVICEQUERYREMOVE:

            // We treat this like a dismount and close all of our handles.

            TrkLog(( TRKDBG_WKS, TEXT("DBT_DEVICEQUERYREMOVE") ));
            {
                PDEV_BROADCAST_HANDLE pbh = reinterpret_cast<PDEV_BROADCAST_HANDLE>(EventData);
                if( pbh->dbch_devicetype == DBT_DEVTYP_HANDLE )
                {
                    _volumes.OnVolumeDismount( pbh->dbch_hdevnotify );
                }
            }
            break;

        case DBT_DEVICEQUERYREMOVEFAILED:

            // We can reopen the handles, because someone else made the 
            // query fail.

            TrkLog(( TRKDBG_WKS, TEXT("DBT_DEVICEQUERYREMOVEFAILED") ));
            {
                PDEV_BROADCAST_HANDLE pbh = reinterpret_cast<PDEV_BROADCAST_HANDLE>(EventData);
                if( pbh->dbch_devicetype == DBT_DEVTYP_HANDLE )
                {
                    _volumes.OnVolumeDismountFailed( pbh->dbch_hdevnotify );
                }
            }
            break;

        case DBT_DEVICEREMOVECOMPLETE:

            // The volume was successfully removed.

            TrkLog(( TRKDBG_WKS, TEXT("DBT_DEVICEREMOVECOMPLETE") ));
            {
                PDEV_BROADCAST_HANDLE pbh = reinterpret_cast<PDEV_BROADCAST_HANDLE>(EventData);
                if( pbh->dbch_devicetype == DBT_DEVTYP_HANDLE )
                {
                    // The volume handles should have been closed already
                    // in the DBT_DEVICEQUERYREMOVE, in which case the following
                    // call will have no effect.
                    _volumes.OnVolumeDismount( pbh->dbch_hdevnotify );
                }
                else
                {
                    PDEV_BROADCAST_DEVICEINTERFACE pintf
                        = reinterpret_cast<PDEV_BROADCAST_DEVICEINTERFACE>(EventData);

                    if( MOUNTDEV_MOUNTED_DEVICE_GUID == pintf->dbcc_classguid )
                    {
                        TrkLog(( TRKDBG_WKS, TEXT("Received mounted device remove complete") ));
                        TrkLog(( TRKDBG_WKS, TEXT("DeviceType=%08x, Name=%s"), pintf->dbcc_devicetype, pintf->dbcc_name ));
                    }
                }
                break;
            }

        case DBT_DEVICEARRIVAL:

            TrkLog(( TRKDBG_WKS, TEXT("DBT_DEVICEARRIVAL") ));
            /*  Need to figure out what device-type to check for
            {
                PDEV_BROADCAST_DEVICEINTERFACE pintf
                    = reinterpret_cast<PDEV_BROADCAST_DEVICEINTERFACE>(EventData);

                if( MOUNTDEV_MOUNTED_DEVICE_GUID == pintf->dbcc_classguid )
                {
                    TrkLog(( TRKDBG_WKS, TEXT("Received mounted device arrival") ));
                    TrkLog(( TRKDBG_WKS, TEXT("DeviceType=%08x, Name=%s"), pintf->dbcc_devicetype, pintf->dbcc_name ));
                }
            }
            */
            break;

        }   // switch( dwEventType )

    }
    return(dwRet);
}


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::CallDcSyncVolumes
//
//  Send a SYNC_VOLUMES request to the DC.  There are multiple types if
//  SYNC_VOLUMES requests, for example it can be used to create or claim
//  volumes, or to verify sequence numbers for volumes.
//
//  This implementation is part of CTrkWksSvc, even though it is only
//  called from CVolumeManager.  This was done because during the request
//  we also get information that's used to update the _persistentVolumeMap
//  table, which is part of CTrkWksSvc.
//
//+----------------------------------------------------------------------------

void
CTrkWksSvc::CallDcSyncVolumes(ULONG cVolumes, TRKSVR_SYNC_VOLUME rgSyncVolumes[])
{
    TRKSVR_MESSAGE_UNION Msg;
    CAvailableDc         adc;
    VolumeMapEntry *     pVolumeChanges = NULL;
#ifdef VOL_REPL
    CVolumeMap           VolumeMapNew;
#endif
    __try
    {
        HRESULT hr;

        // Compose the SyncVolumes message buffer

        Msg.MessageType = SYNC_VOLUMES;
        Msg.Priority = PRI_0;
        Msg.SyncVolumes.cVolumes = cVolumes;
        Msg.SyncVolumes.pVolumes = rgSyncVolumes;

#ifdef VOL_REPL
        // pass in the DC time that we last got volume changes
        Msg.SyncVolumes.ftFirstChange = _persistentVolumeMap.GetLastUpdateTime( );
        Msg.SyncVolumes.cChanges = 0;
        Msg.SyncVolumes.ppVolumeChanges = & pVolumeChanges;
#endif
        // Call the DC

        adc.CallAvailableDc(&Msg);

#ifdef VOL_REPL
        // Process volume table updates
        if (Msg.SyncVolumes.cChanges != 0 && pVolumeChanges != NULL)
        {
            // takes ownership of *pVolumeChanges
            VolumeMapNew.Initialize(Msg.SyncVolumes.cChanges, &pVolumeChanges);

            // ftFirstChange is now the time that we pass back into the DC next time
            _persistentVolumeMap.Merge(&VolumeMapNew);
        }
        _persistentVolumeMap.SetLastUpdateTime( CFILETIME(Msg.SyncVolumes.ftFirstChange) );
#endif

    }
    __finally
    {
        adc.UnInitialize();
#ifdef VOL_REPL
        midl_user_free(pVolumeChanges);
        VolumeMapNew.UnInitialize();
#endif
    }
}

// Always returns a success code (positive number), exception if RPC error or service
// returns a negative number.

//+----------------------------------------------------------------------------
//
//  CAvailableDc::CallAvailableDc
//
//  Find a DC and call TrkSvr's LnkSvrMessage method with the caller-provided
//  message.  All communications between the trkwks & trksvr services goes
//  through this method.  This routine raises if LnkSvrMessage returns an
//  error.
//
//+----------------------------------------------------------------------------


HRESULT
CAvailableDc::CallAvailableDc(
    TRKSVR_MESSAGE_UNION * pMsg,
    RC_AUTHENTICATE auth )
{
    HRESULT hr = E_FAIL;
    CMachineId mcidLocal( MCID_LOCAL );
    TCHAR tszMachineID[ MAX_PATH + 1 ];
    CMachineId mcidFirstTry;

    // Set the machine ID in the message.  Ordinarily this is set to NULL;
    // trksvr infers the machine ID by impersonating us.  It's non-NULL
    // if the registry is configured to use a custom DC.

    if( UseCustomDc() )
    {
        mcidLocal.GetName( tszMachineID, sizeof(tszMachineID) );
        pMsg->ptszMachineID = tszMachineID;
    }
    else
        pMsg->ptszMachineID = NULL;

    // Try twice to talk to the DC.  If it fails the first time, we'll try
    // another DC.

    for (int tries=0; tries<2; tries++)
    {

        // If the service is stopping, don't even attempt to make a call that
        // could hang indefinitely.

        g_ptrkwks->RaiseIfStopped();

        // If we don't have an association with the DC, establish it now.

        if (! _rcDomain.IsConnected())
        {

            _mcidDomain = g_ptrkwks->GetDcName( 1 == tries ); // Force on the second try
            TrkLog(( TRKDBG_WKS, TEXT("Connecting to DC %s"),
                     (const TCHAR*)CDebugString(_mcidDomain) ));
            _rcDomain.RcInitialize( _mcidDomain,
                                    s_tszTrkSvrRpcProtocol, s_tszTrkSvrRpcEndPoint,
                                    auth );

            TrkAssert( _rcDomain.IsConnected() );
        }

        // If this is the second try, and we're about to try the same DC as
        // the first time, then don't bother.

        if (tries == 1 && mcidFirstTry == _mcidDomain)
        {
            break;
        }

        // Call the DC
        __try
        {
            if (tries == 0)
            {
                // Remember which DC we try first, so we don't bother to try
                // it a second time.
                mcidFirstTry = _mcidDomain;
            }

            TrkLog(( TRKDBG_WKS, TEXT("Calling LnkSvrMessage on %s"),
                     (const TCHAR*)CDebugString(_mcidDomain) ));

            hr = LnkSvrMessage(_rcDomain, pMsg);
        }
        __except (BreakOnDebuggableException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            TrkLog(( TRKDBG_WKS, TEXT("Couldn't call DC %s (%08x)"),
                     (const TCHAR*)CDebugString(_mcidDomain),
                     HRESULT_FROM_WIN32(GetExceptionCode()) ));
        }


        // If the call succeeded, we're done.

        if (SUCCEEDED(hr))
        {
            break;
        }

        if( NULL != g_ptrkwks )
            g_ptrkwks->RaiseIfStopped();

        _rcDomain.UnInitialize();

    }   // for (int tries=0; tries<2; tries++)

    if (FAILED(hr))
    {
        TrkLog((TRKDBG_WKS, TEXT("CallAvailableDc failed %08X"), hr));
        TrkRaiseException(hr);
    }

    return hr;

}   // CAvailableDc::CallAvailableDc



//+----------------------------------------------------------------------------
//
//  CAvailableDc::UnInitialize
//
//  Uninitialize the RPC association and registry configuration.
//
//+----------------------------------------------------------------------------

void
CAvailableDc::UnInitialize()
{
    _rcDomain.UnInitialize();
    CTrkRpcConfig::UnInitialize();
}


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::CallSvrMessage
//
//  This method is the implementation within CTrkWksSvc of the
//  LnkCallSvrMessage RPC request.  This purpose of this request is to
//  provide a means for a utility to send a message to trksvr via trkwks,
//  no pre- or post-processing is done by trkwks.  This is only provided
//  for testing purposes, and is disabled unless a flag is set in the
//  registry.
//
//+----------------------------------------------------------------------------

HRESULT
CTrkWksSvc::CallSvrMessage( handle_t IDL_handle, TRKSVR_MESSAGE_UNION * pMsg )
{
    HRESULT hr = S_OK;
    CAvailableDc adc;
    BOOL fAllowCall = FALSE;

    TrkLog(( TRKDBG_MEND, TEXT("CallSvrMessage request") ));

    // Is the special registry flag set that allows us to perform this call?

    if( _configWks.GetTestFlags() & TRK_TEST_FLAG_CALL_SERVER )
    {
        fAllowCall = TRUE;
    }
    else
    {
        // Otherwise, see if the client is running as an administrator.
        // If so, then it's OK to make this call.

        RPC_STATUS rpc_status = RpcImpersonateClient( IDL_handle );
        if( S_OK == rpc_status )
        {
            if( RunningAsAdministratorHack() )
            {
                fAllowCall = TRUE;

                TCHAR tszCurrentUser[ 200 ] = { TEXT("") };
                ULONG cchCurrentUser = sizeof(tszCurrentUser)/sizeof(tszCurrentUser[0]);
                GetUserName( tszCurrentUser, &cchCurrentUser );
                TrkLog(( TRKDBG_MEND, TEXT("CallSvrMessage from %s"), tszCurrentUser ));
            }
            RpcRevertToSelf();
        }
    }

    if( !fAllowCall )
        return( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED) );

    __try
    {
        // Is this a request to modify our configuration?

        if( WKS_CONFIG == pMsg->MessageType )
        {
            // Yes, this is a trkwks configuration change request.  Are we
            // attempt to change a dynamic parameter?

            if( !_configWks.IsParameterDynamic( pMsg->WksConfig.dwParameter ) )
            {
                // No, this parameter is static and can't be changed.

                TrkLog(( TRKDBG_WARNING, TEXT("Attempt to modify a static parameter (%d)"),
                         pMsg->WksConfig.dwParameter ));
                hr = HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
            }

            // Otherwise, we can change the parameter.

            else if( !_configWks.SetParameter( pMsg->WksConfig.dwParameter,
                                               pMsg->WksConfig.dwNewValue ) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't set parameter %d to %d"),
                         pMsg->WksConfig.dwParameter, pMsg->WksConfig.dwNewValue ));
                hr = E_FAIL;
            }
            else
            {
                hr = S_OK;
                TrkLog(( TRKDBG_WKS, TEXT("Set parameter %s to %d"),
                         _configWks.GetParameterName( pMsg->WksConfig.dwParameter ),
                         pMsg->WksConfig.dwNewValue ));
            }

        }   // if( WKS_CONFIG == pMsg->MessageType )

        // Or, is it a request to refresh the volume list (to look for new volumes)?

        else if( WKS_VOLUME_REFRESH == pMsg->MessageType )
        {
            _volumes.RefreshVolumes( (PLogCallback*) this, _svcctrl._ssh
                                     #if DBG
                                     , &_testsyncTunnel
                                     #endif
                                     );
            hr = S_OK;
        }

        else
        {
            // No, this isn't a request to change trkwks configuration.  Just pass
            // the request up to trksvr unchanged.

            hr = adc.CallAvailableDc(pMsg);
        }
    }
    __finally
    {
        adc.UnInitialize();
    }

    return(hr);

}


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::GetBackup
//
//  Not currently implemented.
//
//+----------------------------------------------------------------------------

#ifdef VOL_REPL
HRESULT
CTrkWksSvc::GetBackup(DWORD *           pcVolumes,
                      VolumeMapEntry ** ppVolumeChanges,
                      FILETIME          *pft)
{
    HRESULT hr = S_OK;

    __try
    {
        _persistentVolumeMap.CopyTo( pcVolumes, ppVolumeChanges );
        *pft = _persistentVolumeMap.GetLastUpdateTime();
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        hr = GetExceptionCode();
    }

    return(hr);
}
#endif



//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::SearchMachine
//
//  This is the implementation witthin CTrkWksSvc of LnkSearchMachine.  This
//  request is sent by other instances of CTrkWksSvc (trkwks) on remote
//  machines.
//
//  Give a link source's last known droid and birth droid, find the file
//  on this machine, or a referral to the file from the logs.
//
//+----------------------------------------------------------------------------


HRESULT
CTrkWksSvc::SearchMachine(
    RPC_BINDING_HANDLE           IDL_handle,
    DWORD                        Restrictions,
    const CDomainRelativeObjId  &droidBirthLast,
    const CDomainRelativeObjId  &droidLast,
    CDomainRelativeObjId *       pdroidBirthNext,
    CDomainRelativeObjId *       pdroidNext,
    CMachineId *                 pmcidNext,
    TCHAR* ptszPath )
{
    HRESULT hr = S_OK;

    // Over-size the path for now, to ensure there's enough
    // room for the vol-relative path and the UNC prefix.
    TCHAR                   tszLocalPath[2*MAX_PATH+1];

    // Abort if the service is being stopped
    RaiseIfStopped();

    // Show who made the call in the debugger.

    #if 1==DBG
    {
        RPC_STATUS rpc_status = RpcImpersonateClient( IDL_handle );
        if( S_OK == rpc_status )
        {
            TCHAR tszCurrentUser[ 200 ] = { TEXT("") };
            ULONG cchCurrentUser = sizeof(tszCurrentUser);
            GetUserName( tszCurrentUser, &cchCurrentUser );
            TrkLog(( TRKDBG_MEND, TEXT("Searching on behalf of %s, Restrictions = %08x"),
                     tszCurrentUser, Restrictions ));
            RpcRevertToSelf();
        }
    }
    #endif // #if 1==DBG

    // Search all the local volumes

    hr = g_ptrkwks->_volumes.Search( Restrictions, droidBirthLast, droidLast,
                                     pdroidBirthNext, pdroidNext, pmcidNext,
                                     tszLocalPath );

    // Did we find the file?

    if( SUCCEEDED(hr) || TRK_E_POTENTIAL_FILE_FOUND == hr )
    {
        // Yes, we either found the link source, or a potential match for
        // the link source (potential means that the objid was right, but the birth
        // ID didn't match).

        TrkLog((TRKDBG_MEND | TRKDBG_WKS, TEXT("CVolumeManager::Search returned local %spath %s"),
                TRK_E_POTENTIAL_FILE_FOUND == hr ? TEXT("potential ") : TEXT(""),
                tszLocalPath ));

        RPC_STATUS rpc_status;
        UINT uiRpcTransportType;
        BOOL fPotential = TRK_E_POTENTIAL_FILE_FOUND == hr;

        // See if the client is on the local machine.  If so, we'll simply
        // return this local path (e.g. "C:\path\file").  Otherwise, we have
        // to generate a UNC path.  We know it's local if the rpc client came to
        // us over the LRPC protocol.

        rpc_status = I_RpcBindingInqTransportType (IDL_handle, &uiRpcTransportType );
        if( RPC_S_OK != rpc_status )
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't inq the RPC transport type (%lu)"), rpc_status ));
            TrkRaiseWin32Error( rpc_status );
        }

        if( TRANSPORT_TYPE_LPC != uiRpcTransportType )
        {
            // It's not local.  Map the local path to the "best" UNC path.
            hr = MapLocalPathToUNC( IDL_handle, tszLocalPath, ptszPath, MAX_PATH+1 );
            if( SUCCEEDED(hr) && fPotential )
                hr = TRK_E_POTENTIAL_FILE_FOUND;
        }
        else
        {
            // Just return this local path.

            if( _tcslen(tszLocalPath) > MAX_PATH )
                hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
            else
                _tcscpy( ptszPath, tszLocalPath );
        }

    }   // if (hr == S_OK)


    TrkLog(( TRKDBG_MEND | TRKDBG_WKS,
             TEXT("LnkSearchMachine returns %s %s"),
             GetErrorString(hr),
             ( (hr == S_OK || hr == TRK_E_POTENTIAL_FILE_FOUND) ? ptszPath : TEXT("")) ));

    return(hr);
}


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::SetVolumeId
//
//  Implementation of LnkSetVolumeId RPC request.  This is test-only code.
//  BUGBUG:  Is this used?
//
//+----------------------------------------------------------------------------

HRESULT
CTrkWksSvc::SetVolumeId(
    ULONG iVolume,
    const CVolumeId VolId)
{
    NTSTATUS status = E_FAIL;

    if (g_ptrkwks->_configWks.GetTestFlags() & TRK_TEST_FLAG_SET_VOLUME_ID)
    {
        CVolumeEnumerator VolumeEnum;
        CVolume * pVol = NULL;

        // We have to ask the volume to set the ID, otherwise the volid
        // protection code will restore the old ID after we set it.

        VolumeEnum = _volumes.Enum();
        while (pVol = VolumeEnum.GetNextVolume())
        {
            if( iVolume == pVol->GetVolIndex() )
            {
                status = pVol->SetVolIdOnVolume( VolId );
                pVol->Release();
                break;
            }

            pVol->Release();
        }
    }

    return status;
}



//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::MendLink
//
//  Implementation of the LnkMendLink RPC request.
//
//  Given the last known droid, machine, and birth droid, this method
//  searches for a link source.  The client may also specify a time
//  limit and certain restrictions on how the search will be performed.
//
//  The result returned is the new droid, machine, and path.  Also, the new
//  birth ID is returned, though it is normally unchanged (it is only changed
//  if TRK_E_POTENTIAL_FILE is returned).
//
//  The search algorithm is:
//
//      -   Search the last known machine.  The identity of the last known
//          machine is as specified by the caller in mcidLast, though if
//          the volid in droidLast shows up in our volume cache, we'll use that.
//
//      -   Contact the DC to find what it believes is the latest droid and
//          that droid's host machine ID.  Search that machine.
//
//      -   Starting with the last known machine, search for the file
//          by following referrals provided in the logs.
//
//+----------------------------------------------------------------------------


HRESULT
CTrkWksSvc::MendLink(
                RPC_BINDING_HANDLE          IDL_handle,
                DWORD                       dwTickCountDeadline,
                DWORD                       Restrictions,

                IN const CDomainRelativeObjId  &droidBirthLast,
                IN const CDomainRelativeObjId  &droidLast,
                IN const CMachineId            &mcidLast,
                OUT CDomainRelativeObjId       *pdroidBirthNew,
                OUT CDomainRelativeObjId       *pdroidNew,
                OUT CMachineId                 *pmcidNew,

                IN OUT ULONG                   *pcbPath,
                OUT WCHAR                      *pwsz )
{
    HRESULT     hr = S_OK, hrFirst = S_OK;

    // Temp values to be used within this routine
    SAllIDs                 allidsFromLog( droidBirthLast, droidLast, mcidLast );
    SAllIDs                 allidsFromDC     = allidsFromLog;

    TCHAR                   tsz[ MAX_PATH + 1 ];

    // Temp values to hold a potential match while we continue to look for
    // a perfect match.
    SAllIDs                 allidsPotential, allidsResult;
    TCHAR                   tszPotential[ MAX_PATH + 1 ];
    BOOL                    fPotential = FALSE;


    wcstotcs(tsz, pwsz);

    TrkLog(( TRKDBG_MEND, TEXT("\nMending birth=%s, last=%s"),
             (const TCHAR*)CDebugString(droidBirthLast),
             (const TCHAR*)CDebugString(droidLast) ));

    __try
    {
        if( GetTickCount() >= dwTickCountDeadline )
        {
            TrkLog((TRKDBG_MEND, TEXT("Mend: timeout")));
            hr = TRK_E_TIMEOUT;
            __leave;
        }

        //  -----------------------
        //  Search the last machine
        //  -----------------------

        TrkLog(( TRKDBG_MEND, TEXT("Mend: search last machine") ));

        hrFirst = hr = SearchChain( IDL_handle, 1, dwTickCountDeadline, &Restrictions,
                                    USE_SPECIFIED_MCID,
                                    &allidsFromLog, tsz);
        if( SUCCEEDED(hr) || TRK_E_TIMEOUT == hrFirst )
        {
            allidsResult = allidsFromLog;

            // If we succeeded and the droids don't match, then we must
            // have been searching all the volumes on the machine (if
            // we failed with a timeout, the droids shouldn't have changed).

            TrkAssert( !(TRK_MEND_DONT_SEARCH_ALL_VOLUMES & Restrictions)
                       ||
                       allidsFromLog.droidRevised == droidLast );

            __leave;
        }
        else if( TRK_E_POTENTIAL_FILE_FOUND == hrFirst )
        {
            // We have a potential hit (the object ID matched, but the birth ID didn't).

            fPotential = TRUE;

            TrkAssert( allidsFromLog.droidBirth != droidBirthLast );
            TrkAssert( 0 < _tcslen(tsz) );

            // Save these potential values

            allidsPotential = allidsFromLog;
            _tcscpy( tszPotential, tsz );

        }

        //  (droidLastT/mcidLastT always contains last referral)

        //  --------------------------------
        //  Get an updated droid from the DC
        //  --------------------------------

        if( GetTickCount() >= dwTickCountDeadline )
        {
            TrkLog((TRKDBG_MEND, TEXT("Mend: timeout")));
            hr = TRK_E_TIMEOUT;
            __leave;
        }

        hr = TRK_E_NOT_FOUND;
        if( !(TRK_MEND_DONT_USE_DC & Restrictions) )
        {
            TrkLog(( TRKDBG_MEND, TEXT("Mend: ConnectAndSearchDomain") ));
            hr = ConnectAndSearchDomain( droidBirthLast,
                                         &Restrictions,
                                         &allidsFromDC.droidRevised,
                                         &allidsFromDC.mcid );

        }

        //  ---------------------------------
        //  Search using the info from the DC
        //  ---------------------------------

        if( GetTickCount() >= dwTickCountDeadline )
        {
            TrkLog((TRKDBG_MEND, TEXT("Mend: timeout")));
            hr = TRK_E_TIMEOUT;
            __leave;
        }

        if( SUCCEEDED(hr) )
        {
            TrkLog(( TRKDBG_MEND, TEXT("Mend: SearchChain using IDs from DC") ));
            allidsResult = allidsFromDC;

            // Specify USE_SPECIFIED_MCID so that we don't look up the volid
            // in the DC; the DC already mapped the volid to the mcid in the
            // ConnectAndSearchDomain call.

            hr = SearchChain( IDL_handle, -1, dwTickCountDeadline, &Restrictions,
                              USE_SPECIFIED_MCID,
                              &allidsResult, tsz );

        }

        //  ---------------------
        //  Search using the logs
        //  ---------------------

        if( GetTickCount() >= dwTickCountDeadline )
        {
            TrkLog((TRKDBG_MEND, TEXT("Mend: timeout")));
            hr = TRK_E_TIMEOUT;
            __leave;
        }

        if( FAILED(hr) && TRK_E_REFERRAL == hrFirst )
        {
            TrkLog(( TRKDBG_MEND, TEXT("Mend: SearchChain using IDs from Log") ));
            allidsResult = allidsFromLog;
            hr = SearchChain( IDL_handle, -1, dwTickCountDeadline, &Restrictions, SEARCH_FLAGS_DEFAULT,
                              &allidsResult, tsz );
        }

        // If we still haven't found it, try searching the last known machine
        // for potential files.  Potential files are ignored if a referral is found
        // in the log, so we block usage of the log.

        if( GetTickCount() >= dwTickCountDeadline )
        {
            TrkLog((TRKDBG_MEND, TEXT("Mend: timeout")));
            hr = TRK_E_TIMEOUT;
            __leave;
        }

        if( TRK_E_NOT_FOUND == hr && TRK_E_UNAVAILABLE != hrFirst )
        {
            allidsResult.droidBirth = droidBirthLast;
            allidsResult.droidRevised = droidLast;
            allidsResult.mcid = mcidLast;

            TrkLog(( TRKDBG_MEND, TEXT("Mend: SearchChain using IDs from client, don't use log") ));
            Restrictions |= TRK_MEND_DONT_USE_LOG;
            hr = SearchChain( IDL_handle, 1, dwTickCountDeadline, &Restrictions, SEARCH_FLAGS_DEFAULT,
                              &allidsResult, tsz );
        }
    }
    __except(BreakOnDebuggableException())
    {
        hr = GetExceptionCode();
    }
    //} while (ft.Redo(hr));

    // If the birth ID doesn't look correct, consider this a potential
    // hit.

    if( SUCCEEDED(hr) )
    {
        if( CVolumeId() == allidsResult.droidBirth.GetVolumeId()
            ||
            CObjId() == allidsResult.droidBirth.GetObjId() )
        {
            TrkLog(( TRKDBG_MEND, TEXT("Birth ID doesn't look valid, flagging as potential hit") ));
            hr = TRK_E_POTENTIAL_FILE_FOUND;
        }
    }


    // Did the last search step succeed, or return a potential file?

    if( SUCCEEDED(hr) || TRK_E_POTENTIAL_FILE_FOUND == hr )
    {
        TrkAssert( 0 < _tcslen(tsz) );

        if( *pcbPath > _tcslen(tsz) * sizeof(WCHAR) )
        {
            tcstowcs(pwsz, tsz);
            *pdroidBirthNew = allidsResult.droidBirth;
            *pdroidNew = allidsResult.droidRevised;
            *pmcidNew = allidsResult.mcid;

        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
            *pcbPath = ( _tcslen(tsz) + 1 ) * sizeof(WCHAR);
        }
    }

    // Or, did an earlier search step return a potential file?
    else if( fPotential )
    {
        hr = TRK_E_POTENTIAL_FILE_FOUND;

        if( *pcbPath > _tcslen(tszPotential) * sizeof(WCHAR) )
        {
            tcstowcs(pwsz, tszPotential);
            *pdroidBirthNew = allidsPotential.droidBirth;
            *pdroidNew = allidsPotential.droidRevised;
            *pmcidNew = allidsPotential.mcid;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
            *pcbPath = ( _tcslen(tszPotential) + 1 ) * sizeof(WCHAR);
        }
    }

    // Test hook:  If requested, pause here to allow timeout testing

    if( Restrictions & TRK_MEND_SLEEP_DURING_MEND )
    {
        TrkLog(( TRKDBG_MEND, TEXT("Mend: sleep 15 seconds (for testing)") ));
        Sleep( 15 * 1000 );
    }

    TrkLog(( TRKDBG_MEND, TEXT("MendLink returned %s(%08x) \"%ws\""),
             GetErrorString(hr), hr,
             (S_OK == hr || TRK_E_POTENTIAL_FILE_FOUND == hr) ? pwsz : L""
          ));

    return(hr);

}   // CTrkWksSvc::MendLink()


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::GetVolumeTrackingInformation
//
//  This method is unused (it was being used by a utility that ran on the DC
//  and called down to a workstation to get info about its volumes).
//
//  Not currently implemented.
//
//+----------------------------------------------------------------------------

HRESULT
CTrkWksSvc::GetVolumeTrackingInformation( const CVolumeId & volid,
                                          TrkInfoScope scope,
                                          TRK_VOLUME_TRACKING_INFORMATION_PIPE pipeVolInfo )
{
    return( E_NOTIMPL );

#if 0
    HRESULT hr = S_OK;
    CVolumeEnumerator VolEnum;
    CVolume *pvol = NULL;
    TRK_VOLUME_TRACKING_INFORMATION rgvolinfo[10];
    int iVolInfo = -1;

    TrkLog(( TRKDBG_WKS, TEXT("Getting volume-tracking information") ));

    TrkAssert( (TRKINFOSCOPE_MACHINE == scope) ^ (TRKINFOSCOPE_VOLUME == scope) );

    __try
    {
        //  -----------------
        //  Get *all* volumes
        //  -----------------

        if( TRKINFOSCOPE_MACHINE == scope )
        {

            // Get an enumerator

            VolEnum = _volumes.Enum();

            // Get the first volume

            pvol = VolEnum.GetNextVolume();

            // Loop until we run out of volumes

            while( NULL != pvol )
            {
                // Load the data for this volume

                iVolInfo++;
                rgvolinfo[iVolInfo].volindex = pvol->GetVolIndex();
                rgvolinfo[iVolInfo].volume   = pvol->GetVolumeId();

                // Get the next volume

                pvol->Release();

                pvol = VolEnum.GetNextVolume();

                // If there are no more volumes, or if we've got a full load,
                // then send the data we have in rgvolinfo

                if( NULL == pvol
                    ||
                    sizeof(rgvolinfo)/sizeof(*rgvolinfo) - 1 == iVolInfo )
                {
                    // Send the volume information
                    pipeVolInfo.push( pipeVolInfo.state, rgvolinfo, iVolInfo + 1 );

                    // Reset to the start of rgvolinfo.
                    iVolInfo = -1;
                }
            }

        }   // if( NULL == ptszShareName )


        //  ---------------------
        //  Get a *single* volume
        //  ---------------------

        else
        {
            TrkAssert( TRKINFOSCOPE_VOLUME == scope );
            TrkAssert( CVolumeId() != volid );

            NTSTATUS status = STATUS_SUCCESS;

            // Get the CVolume for this volume

            pvol = _volumes.FindVolume( volid );
            if( NULL == pvol )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Couldn't find volid %s"),
                         (const TCHAR*)CDebugString(volid) ));
                TrkRaiseWin32Error( ERROR_FILE_NOT_FOUND );
            }

            // Send the volume info

            rgvolinfo[0].volindex = pvol->GetVolIndex();
            rgvolinfo[0].volume = pvol->GetVolumeId();

            pipeVolInfo.push( pipeVolInfo.state, rgvolinfo, 1 );


        }   // if( NULL == ptszShareName ) ... else

        // Show that we're done with the pipe

        pipeVolInfo.push( pipeVolInfo.state, NULL, 0 );

    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }


    if (pvol)
        pvol->Release();

    return( hr );

#endif // #if 0

}   // CTrkWksSvc::GetVolumeTrackingInformation()


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::GetFileTrackingInformation
//
//  This method is unused (it was being used by a utility that ran on the DC
//  and called down to a workstation to get info about its link sources).
//
//  Not currently implemented.
//
//+----------------------------------------------------------------------------

HRESULT
CTrkWksSvc::GetFileTrackingInformation( const CDomainRelativeObjId & droidCurrent,
                                        TrkInfoScope scope,
                                        TRK_FILE_TRACKING_INFORMATION_PIPE pipeFileInfo )
{
    return( E_NOTIMPL );

#if 0

    HRESULT hr = S_OK;
    NTSTATUS status;
    CVolumeEnumerator VolEnum;
    CVolume *pvol = NULL;    // Doesn't need to be freed
    HANDLE hFile = NULL;

    TRK_FILE_TRACKING_INFORMATION rgfileinfo[10];
    int iFileInfo = -1;
    TCHAR tszRelativePathBase[ MAX_PATH ];

    TrkLog(( TRKDBG_WKS, TEXT("Getting file-tracking information") ));

    __try
    {
        if( TRKINFOSCOPE_ONE_FILE == scope )
        {
            CDomainRelativeObjId droidT, droidBirth;

            pvol = _volumes.FindVolume( droidCurrent.GetVolumeId() );
            if( NULL == pvol )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't find volid %s"),
                        (const TCHAR*)CDebugString(droidCurrent.GetVolumeId()) ));
                TrkRaiseWin32Error( ERROR_FILE_NOT_FOUND );
            }
            if( !pvol->OpenFile( droidCurrent.GetObjId(),
                                 SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                 &hFile ) )
            {
                hFile = NULL;
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't open file")));
                TrkRaiseWin32Error( ERROR_FILE_NOT_FOUND );
            }

            status = QueryVolRelativePath( hFile, &rgfileinfo[0].tszFilePath[2] );
            if( !NT_SUCCESS(status) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't query file for vol-relative path")));
                TrkRaiseNtStatus( status );
            }
            rgfileinfo[0].tszFilePath[0] = (TCHAR)(0 <= pvol->GetVolIndex() ? TEXT('A') + pvol->GetVolIndex() : TEXT('?'));
            rgfileinfo[0].tszFilePath[1] = TEXT(':');

            // BUGBUG P2:  Optimize so we don't have to get droidT

            status = GetDroids( hFile, &droidT, &droidBirth, RGO_READ_OBJECTID );
            if( !NT_SUCCESS(status) )
            {
                TrkLog((TRKDBG_ERROR, TEXT("Couldn't get droids in GetFileTrkInfo")));
                TrkRaiseNtStatus( status );
            }
            TrkAssert( droidT == droidCurrent );

            NtClose( hFile ); hFile = NULL;

            rgfileinfo[0].droidBirth = droidBirth;
            rgfileinfo[0].droidLast = droidCurrent;

            rgfileinfo[0].hr = S_OK;

            pipeFileInfo.push( pipeFileInfo.state, rgfileinfo, 1 );
        }
        else if( TRKINFOSCOPE_DIRECTORY == scope )
        {
            TrkRaiseException( E_NOTIMPL );
        }
        else
        {
            if( TRKINFOSCOPE_VOLUME == scope )
            {
                // Get the volume object
                TrkAssert(!pvol);
                pvol = _volumes.FindVolume( droidCurrent.GetVolumeId() );
                if( NULL == pvol )
                {
                    TrkLog((TRKDBG_ERROR, TEXT("Couldn't find volid %s"),
                            (const TCHAR*)CDebugString(droidCurrent.GetVolumeId()) ));
                    TrkRaiseWin32Error( ERROR_FILE_NOT_FOUND );
                }
            }
            else if( TRKINFOSCOPE_MACHINE == scope )
            {
                VolEnum = _volumes.Enum();
                TrkAssert(!pvol);
                pvol = VolEnum.GetNextVolume(); // BUGBUG P1: ref count on enum
                if( NULL == pvol )
                {
                    TrkLog((TRKDBG_ERROR, TEXT("Couldn't find first volume in enumerator")));
                    TrkRaiseWin32Error( ERROR_FILE_NOT_FOUND );
                }
            }
            else
            {
                TrkRaiseException( E_NOTIMPL );
            }


            while( NULL != pvol )
            {
                CObjIdEnumerator objidenum;
                CObjId VolRelativeFileTrackingInfoObjId;
                CDomainRelativeObjId VolRelativeFileTrackingInfoDroid;

                if( !pvol->EnumObjIds( &objidenum ))
                {
                    pvol->Release();
                    pvol = VolEnum.GetNextVolume();
                    continue;
                }

                iFileInfo = -1;
                if( objidenum.FindFirst( &VolRelativeFileTrackingInfoObjId,
                                         &VolRelativeFileTrackingInfoDroid))
                {
                    TCHAR tszRelativePathFile[ MAX_PATH ]; // BUGBUG P1: path

                    do
                    {
                        if( !pvol->OpenFile( VolRelativeFileTrackingInfoObjId,
                                             SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                                             FILE_SHARE_READ | FILE_SHARE_WRITE, &hFile ))
                        {
                            TrkAssert( FALSE && TEXT("File is in object directory but doesn't exist") );
                            hFile = NULL;
                            continue;
                        }

                        status = QueryVolRelativePath( hFile, &tszRelativePathFile[2] );
                        NtClose( hFile ); hFile = NULL;
                        if( !NT_SUCCESS(status) )
                        {
                            TrkLog((TRKDBG_ERROR, TEXT("Couldn't get vol-relative path for objid %s"),
                                    (const TCHAR*)CDebugString(VolRelativeFileTrackingInfoObjId) ));
                            TrkRaiseNtStatus( status );
                        }

                        tszRelativePathFile[0] = (TCHAR)(0 <= pvol->GetVolIndex() ? TEXT('A') + pvol->GetVolIndex() : TEXT('?'));
                        tszRelativePathFile[1] = TEXT(':');

                        ++iFileInfo;

                        _tcscpy( rgfileinfo[ iFileInfo ].tszFilePath, tszRelativePathFile );
                        rgfileinfo[ iFileInfo ].droidBirth = VolRelativeFileTrackingInfoDroid;
                        rgfileinfo[ iFileInfo ].droidLast
                            = CDomainRelativeObjId( pvol->GetVolumeId(),
                                                    VolRelativeFileTrackingInfoObjId );

                        if( iFileInfo == sizeof(rgfileinfo)/sizeof(*rgfileinfo) - 1)
                        {
                            pipeFileInfo.push( pipeFileInfo.state, rgfileinfo, iFileInfo + 1 );
                            iFileInfo = -1;
                        }

                    } while( objidenum.FindNext( &VolRelativeFileTrackingInfoObjId,
                        &VolRelativeFileTrackingInfoDroid ));

                    if( iFileInfo >= 0 )
                        pipeFileInfo.push( pipeFileInfo.state, rgfileinfo, iFileInfo );

                }   // if( objidenum.FindFirst( ))

                if (pvol)
                {
                    pvol->Release();
                }
                pvol = VolEnum.GetNextVolume();

            }   // while( NULL != pVol )
        }   // if( NULL != hFile ) ... else
    }   // __try

    __finally
    {
        // Show that we're done with the pipe
        pipeFileInfo.push( pipeFileInfo.state, NULL, 0 );

        if( NULL != hFile )
            NtClose( hFile );

        if ( NULL != pvol )
            pvol->Release();
    }


    return( hr );

#endif // #if 0

}   // CTrkWksSvc::GetFileTrackingInformation()



//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::TriggerVolumeClaims
//
//  This method is not currently used.  (It was being used by a utility run
//  on the DC that would trigger volume claim requests after updating
//  the DS.)
//
//  Not currently implemented.
//
//+----------------------------------------------------------------------------

HRESULT
CTrkWksSvc::TriggerVolumeClaims( ULONG cVolumes, const CVolumeId *rgvolid )
{
    return( E_NOTIMPL );

#if 0

    CVolume *pvol = NULL;
    CAvailableDc adc;
    HRESULT hr = E_FAIL;
    ULONG iVol;
    TRKSVR_SYNC_VOLUME rgsyncvol[ NUM_VOLUMES ]; // BUGBUG:  fix number of volumes
    TRKSVR_MESSAGE_UNION Msg;

    TrkLog(( TRKDBG_WKS, TEXT("Triggering %d volume claims"), cVolumes ));

    if( 0 == cVolumes || NUM_VOLUMES < cVolumes )
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    __try
    {
        for( iVol = 0; iVol < cVolumes; iVol++ )
        {
            pvol = _volumes.FindVolume( rgvolid[iVol] );
            if( NULL == pvol )
            {
                // We don't handle the case where a volume is removed during the call
                TrkLog(( TRKDBG_ERROR, TEXT("CTrkWksSvc::TriggerVolumeClaims couldn't find volid %s"),
                         (const TCHAR*)CDebugString(rgvolid[iVol]) ));
                hr = TRK_E_NOT_FOUND;
                goto Exit;
            }

            if( !pvol->LoadSyncVolume( /* CLAIM_VOLUME, */ &rgsyncvol[iVol] ) )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("CTrkWksSvc::TriggerVolumeClaims couldn't load volid %s"),
                         (const TCHAR*)CDebugString(rgvolid[iVol]) ));
                hr = E_FAIL;
                goto Exit;
            }

            pvol->Release();
            pvol = NULL;
        } // for( iVol = 0; iVol < cVolumes; iVol++ )

        Msg.MessageType = SYNC_VOLUMES;
        Msg.Priority = PRI_0;
        Msg.SyncVolumes.cVolumes = cVolumes;

        Msg.SyncVolumes.pVolumes = rgsyncvol;

#ifdef VOL_REPL
        Msg.SyncVolumes.cChanges = 0;
        Msg.SyncVolumes.ppVolumeChanges = NULL;
#endif


        adc.CallAvailableDc(this, &Msg);

        for( iVol = 0; iVol < cVolumes; iVol++ )
        {
            pvol = _volumes.FindVolume( rgvolid[iVol] );
            if( NULL == pvol )
            {
                // We don't handle the case where a volume is removed during this call.
                TrkLog(( TRKDBG_ERROR, TEXT("CTrkWksSvc::TriggerVolumeClaims couldn't find volid %s"),
                         (const TCHAR*)CDebugString(rgvolid[iVol]) ));
                hr = TRK_E_NOT_FOUND;
                goto Exit;
            }

            if( !pvol->UnloadSyncVolume( &rgsyncvol[iVol] ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("CTrkWksSvc::TriggerVolumeClaims couldn't unload volid %s"),
                         (const TCHAR*)CDebugString(rgvolid[iVol]) ));
                hr = E_FAIL;
                goto Exit;
            }

            pvol->Release();
            pvol = NULL;
        }
    }
    __finally
    {
        if( AbnormalTermination() && NULL != pvol )
            pvol->Release();

        adc.UnInitialize();
    }

    hr = S_OK;

Exit:

    if (pvol != NULL)
        pvol->Release();

    return( hr );

#endif // #if 0

}   // CTrkWksSvc::TriggerVolumeClaims


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::ConnectAndSearchDomain
//
//  This method looks up a birth ID in the DC (trksvr).  If it was
//  found, it returns the new droid, and the machine that owns that
//  droid.
//
//  Arguments:
//      [droidBirth]
//          The ID of the file to look up.
//      [pRestrictions]
//          The TrkMendRestrictions flags.  If we can't talk to the
//          DC for some reason, TRK_MEND_DONT_USE_DC will be set.
//      [pdroidLast]
//          On successful return, holds the file's last known droid.
//      [pmcidLast]
//          On successful return, identifies the machine that holds
//          the volume specified in pdroidLast.
//
//+----------------------------------------------------------------------------

HRESULT
CTrkWksSvc::ConnectAndSearchDomain(IN const CDomainRelativeObjId &droidBirth,
                                   IN OUT DWORD                  *pRestrictions,
                                   IN OUT CDomainRelativeObjId   *pdroidLast,
                                   OUT CMachineId                *pmcidLast )
{
    TRKSVR_MESSAGE_UNION Msg;
    TRK_FILE_TRACKING_INFORMATION TrkFileInfo;

    HRESULT hr = TRK_E_UNAVAILABLE;
    CAvailableDc adc;

    // If the volid in the birth ID isn't specified, then there's nothing
    // we can look up.

    if( CVolumeId() == droidBirth.GetVolumeId() )
        return( TRK_E_NOT_FOUND );

    // Also, if there is no DC, then there's no need trying to RPC to it.

    else if( _configWks._fIsWorkgroup )
        return( TRK_E_UNAVAILABLE );

    __try
    {
        memset( &TrkFileInfo, 0, sizeof(TrkFileInfo) );
        TrkFileInfo.droidBirth = droidBirth;
        TrkFileInfo.droidLast = *pdroidLast;
        TrkFileInfo.mcidLast = CMachineId();

        Msg.MessageType = SEARCH;
        Msg.Priority = PRI_0;
        Msg.Search.cSearch = 1;
        Msg.Search.pSearches = &TrkFileInfo;

        // Send the search request to trksvr.

        adc.CallAvailableDc(&Msg);

        // Was it found?

        if( TrkFileInfo.hr == S_OK )
        {
            // Get the last known droid & mcid for return.
            *pdroidLast = TrkFileInfo.droidLast;
            *pmcidLast = TrkFileInfo.mcidLast;
            hr = S_OK;
            _volumeLocCache.AddVolume( TrkFileInfo.droidLast.GetVolumeId(), TrkFileInfo.mcidLast );
        }
        else
        {
            // Either the last/birth DROIDs weren't found, or they mapped
            // to a volume that didn't exist.

            hr = TRK_E_NOT_FOUND;

            if( TRK_E_NOT_FOUND_BUT_LAST_VOLUME_FOUND     == TrkFileInfo.hr
                ||
                TRK_E_NOT_FOUND_AND_LAST_VOLUME_NOT_FOUND == TrkFileInfo.hr )
            {
                // The last/birth DROIDs weren't found.  If the error was
                // TRK_E_NOT_FOUND_BUT_LAST_VOLUME_FOUND, then the volume
                // for droidLast did exist as was looked up.  If the error
                // was just TRK_E_NOT_FOUND, then the volume for droidLast
                // couldn't be found.  In either case, take this opportunity
                // to add it to the volume cache, because we're probably about
                // to use it in a fallback search.

                _volumeLocCache.AddVolume( TrkFileInfo.droidLast.GetVolumeId(), TrkFileInfo.mcidLast );
            }

        }
    }
    __except (BreakOnDebuggableException())
    {
        hr = TRK_E_UNAVAILABLE;
        if( HRESULT_FROM_WIN32(RPC_S_INVALID_TAG) == GetExceptionCode() )
        {
            // We get this error when we talk to a beta2 DC.  Retry
            // the request using the old two-call mechanism.
            TrkLog(( TRKDBG_MEND, TEXT("Trying downlevel ConnectAndSearchDomain") ));
            hr = OldConnectAndSearchDomain( droidBirth, pdroidLast, pmcidLast );
        }
        else
        {
            // Something's wrong with the DC and there's no point
            // trying to call it again during this mend operation.
            *pRestrictions |= TRK_MEND_DONT_USE_DC;
        }

    }

    TrkLog((TRKDBG_MEND, TEXT("ConnectAndSearchDomain returning %s"), GetErrorString(hr)));

    TrkAssert(hr == S_OK ||
        hr == TRK_E_NOT_FOUND ||
        hr == TRK_E_UNAVAILABLE);

    return(hr);
}


//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::OldConnectAndSearchDomain
//
//  This method is functionally equivalent to ConnectAndSearchDomain.
//  The difference is that it uses an older interface, it makes
//  an old_SEARCH request followed by a FIND_VOLUME request (the
//  modern SEARCH request returns the volume, making the FIND_VOLUME
//  request unecessary).
//
//+----------------------------------------------------------------------------

HRESULT
CTrkWksSvc::OldConnectAndSearchDomain(IN const CDomainRelativeObjId & droidBirth,
                                      IN OUT CDomainRelativeObjId *pdroidLast,
                                      OUT CMachineId *pmcidLast )
{
    HRESULT hr = S_OK;
    CAvailableDc adc;

    __try
    {
        TRKSVR_MESSAGE_UNION Msg;
        old_TRK_FILE_TRACKING_INFORMATION OldTrkFileInfo;
        TRKSVR_SYNC_VOLUME SyncVolume;

        // Search for the the latest droid.

        OldTrkFileInfo.droidBirth = droidBirth;
        OldTrkFileInfo.droidLast = *pdroidLast;

        Msg.MessageType = old_SEARCH;
        Msg.Priority = PRI_0;
        Msg.old_Search.cSearch = 1;
        Msg.old_Search.pSearches = &OldTrkFileInfo;

        adc.CallAvailableDc(&Msg);
        if( S_OK != OldTrkFileInfo.hr )
        {
            hr = TRK_E_NOT_FOUND;
            __leave;
        }

        // Search for the location of the volume in the droid just returned.

        SyncVolume.hr = S_OK;
        SyncVolume.SyncType = FIND_VOLUME;
        SyncVolume.volume = OldTrkFileInfo.droidLast.GetVolumeId();

        Msg.MessageType = SYNC_VOLUMES;
        Msg.Priority = PRI_0;
        Msg.SyncVolumes.cVolumes = 1;
        Msg.SyncVolumes.pVolumes = &SyncVolume;

        hr = adc.CallAvailableDc(&Msg);

        if( S_OK != hr || S_OK != SyncVolume.hr )
        {
            hr = TRK_E_NOT_FOUND;
            __leave;
        }

        // We found both the droid and the machine.

        TrkLog(( TRKDBG_MEND, TEXT("Downlevel ConnectAndSearchDomain finds %s, %s"),
                 (const TCHAR*)CDebugString(OldTrkFileInfo.droidLast),
                 (const TCHAR*)CDebugString(SyncVolume.machine) ));

        *pdroidLast = OldTrkFileInfo.droidLast;
        *pmcidLast = SyncVolume.machine;

    }
    __except( BreakOnDebuggableException() )
    {
    }

    return( hr );
}



//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::ConnectAndSearchMachine
//
//  RPC to the machine specified by the mcid parameter, and execute the
//  LnkSearchMachine method.  If the target is actually the local machine,
//  this method just calls StubLnkSearchMachine directly.
//
//+----------------------------------------------------------------------------


HRESULT
CTrkWksSvc::ConnectAndSearchMachine(RPC_BINDING_HANDLE          IDL_handle,
                                    const CMachineId            &mcid,
                                    IN OUT DWORD                *pRestrictions,
                                    IN OUT CDomainRelativeObjId *pdroidBirthLast,
                                    IN OUT CDomainRelativeObjId *pdroidLast,
                                    OUT CMachineId              *pmcidLast,
                                    OUT TCHAR                   *ptsz)
{
    CRpcClientBinding    rc;
    HRESULT              hr;
    CDomainRelativeObjId droidBirthNext, droidNext;
    CMachineId           mcidNext;
    RPC_STATUS           rpc_status = S_OK;
    BOOL                 fImpersonating = FALSE;

    __try
    {
        //FAILTEST();

        // Are we calling the local machine?
        if( CMachineId(MCID_LOCAL) == mcid )
        {
            // Yes, don't bother going through RPC.
            // (Actually, this isn't just for performance; this is also so that
            // a local path may be returned.)

            hr = StubLnkSearchMachine( IDL_handle, *pRestrictions,
                                       pdroidBirthLast, pdroidLast,
                                       &droidBirthNext, &droidNext, &mcidNext, ptsz );
        }

        // Or, is this an unservicable request?

        else if( CMachineId() == mcid )
            hr = TRK_E_UNAVAILABLE;

        // Otherwise, RPC to mcid.

        else
        {
            // Impersonate the client during this call, so that the target
            // can determine what UNC path is best for this user.

            if( RpcSecurityEnabled() )  // Normal case
            {
                rpc_status = RpcImpersonateClient( IDL_handle );
                if( STATUS_SUCCESS != rpc_status )
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Couldn't impersonate client") ));
                    TrkRaiseWin32Error( rpc_status );
                }
                fImpersonating = TRUE;
            }
            else    // Test case
            {
                if( !ImpersonateSelf( SecurityImpersonation ))
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Couldn't impersonate self") ));
                    TrkRaiseLastError();
                }
                fImpersonating = TRUE;
            }

            //
            // Set up the client binding after the impersonation so that RPC
            // picks up the right user security info - but specify no Rpc auth
            // so that we get named pipes auth
            //

            for( int cRetries = 0; cRetries < 2; cRetries++ )
            {
                BOOL fContinue = FALSE;

                // We'll try the normal endpoint name (trkwks) first.  If that gives
                // us rpc_s_server_unavailable, we'll try the Win2K name (ntsvcs).
                // (This change happened when we moved from services.exe to svchost.)

                rc.RcInitialize(mcid,
                    s_tszTrkWksRemoteRpcProtocol,
                    0 == cRetries
                        ? s_tszTrkWksRemoteRpcEndPoint
                        : s_tszTrkWksRemoteRpcEndPointOld,
                    NO_AUTHENTICATION);

                TrkLog(( TRKDBG_MEND, TEXT("Attempting LnkSearchMachine on %s"),
                         0 == cRetries
                             ? s_tszTrkWksRemoteRpcEndPoint
                             : s_tszTrkWksRemoteRpcEndPointOld ));

                __try
                {
                    hr = LnkSearchMachine(rc, *pRestrictions,
                                          const_cast<const CDomainRelativeObjId*>(pdroidBirthLast),
                                          const_cast<const CDomainRelativeObjId*>(pdroidLast),
                                          &droidBirthNext, &droidNext, &mcidNext, ptsz );
                }
                __except( (0 == cRetries && RPC_S_SERVER_UNAVAILABLE == GetExceptionCode())
                            ? EXCEPTION_EXECUTE_HANDLER 
                            : EXCEPTION_CONTINUE_SEARCH )
                {
                    // On the first attempt, we got an error consistent with calling
                    // a Win2K box.  Try again (and this time we'll use the endpoint name
                    // that was used back then).

                    rc.UnInitialize();
                    fContinue = TRUE;
                }

                if( !fContinue )
                    break;
            }

            if( FAILED(hr) )
            {
                TrkLog(( TRKDBG_MEND, TEXT("LnkSearchMachine(%s) returns %08x"),
                         (const TCHAR*)CDebugString(mcid), hr ));
            }

        }    // if( CMachineId( MCID_LOCAL ) == mcid ) ... else

        // Did we find the file?

        if( SUCCEEDED(hr) || TRK_E_REFERRAL == hr || TRK_E_POTENTIAL_FILE_FOUND == hr )
        {
            *pdroidBirthLast = droidBirthNext;
            *pdroidLast = droidNext;
            *pmcidLast = mcidNext;
        }
        else
        if (hr != S_OK && hr != TRK_E_NOT_FOUND && hr != TRK_S_VOLUME_NOT_FOUND)
        {
            hr = TRK_E_UNAVAILABLE;
        }

    }
    __except(BreakOnDebuggableException())
    {
        hr = TRK_E_UNAVAILABLE;
    }

    // Revert to self

    if( fImpersonating )
    {
        if( RpcSecurityEnabled() )
            RpcRevertToSelf();
        else
            RevertToSelf();
    }


    TrkLog((TRKDBG_MEND, TEXT("ConnectAndSearchMachine returning %s"), GetErrorString(hr)));

    TrkAssert(hr == S_OK ||
        hr == TRK_E_REFERRAL ||
        hr == TRK_E_NOT_FOUND ||
        hr == TRK_E_UNAVAILABLE ||
        hr == TRK_S_VOLUME_NOT_FOUND ||
        hr == TRK_E_POTENTIAL_FILE_FOUND );

    return(hr);
}


/*
CMachineId::CMachineId(handle_t ClientBinding)
{
    TrkAssert( !TEXT("CMachineId(handle_t)") );
}
*/




//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::FindAndSearchVolume
//
//  Find the location of a volume, and send a search request to that
//  machine.  The machine is located by using either the volume ID
//  in pdroidLast, or by using the machine ID in pmcidLast, depending
//  on what works, what the client specified in pRestrictions, and
//  depending on what the caller specified in SearchFlags.
//
//  Assuming no special Restrictions or SearchFlags, the algorithm for
//  locating a volume is:
//
//      -   Search the local machine.
//
//      -   Search the local cache that maps volumes to machines.  If
//          that fails, or the subsequent call to the machine fails
//          with a volume error, continue to the next step.
//
//      -   Call to the DC and ask it to map the volume ID to the
//          current machine ID.
//
//  If a search of a remote machine is successful, we add the volid->mcid
//  mapping to the local cache for later use.
//
//+----------------------------------------------------------------------------


HRESULT
CTrkWksSvc::FindAndSearchVolume(RPC_BINDING_HANDLE  IDL_handle,
                                IN OUT DWORD *pRestrictions,
                                IN SEARCH_FLAGS SearchFlags,
                                IN OUT CDomainRelativeObjId *pdroidBirthLast,
                                IN OUT CDomainRelativeObjId *pdroidLast,
                                IN OUT CMachineId           *pmcidLast,
                                TCHAR                       *ptsz)
{
    HRESULT hr = TRK_E_NOT_FOUND;
    HRESULT hrFromSearchUsingCachedVolId = TRK_E_NOT_FOUND;
    BOOL fFoundVolumeOnThisMachine = FALSE;
    BOOL fRecentVolCacheEntryFound = FALSE;
    CMachineId mcidSearch;
    CMachineId mcidFromVolumeCache;
    CAvailableDc adc;
    CVolume * pVol = NULL;
    CVolumeId volid;

    __try
    {
        //  ------------------------------------------------------
        //  Determine what machine to search and put in mcidSearch
        //  ------------------------------------------------------

        // If this isn't a meaningfull volid, or we don't have a DC in which to
        // look up volids, then just use the last machine ID.

        if( CVolumeId() == pdroidLast->GetVolumeId()
            ||
            _configWks._fIsWorkgroup
            ||
            (*pRestrictions & TRK_MEND_DONT_USE_VOLIDS)
            ||
            (USE_SPECIFIED_MCID & SearchFlags) )
        {
            mcidSearch = *pmcidLast;
            hr = TRK_E_NOT_FOUND;

            TrkLog(( TRKDBG_MEND, TEXT("Didn't search for %s, using machine %s"),
                     _configWks._fIsWorkgroup ? TEXT("volume in workgroup") : TEXT("volume"),
                     (const TCHAR*)CDebugString(mcidSearch) ));
        }

        // Try to find the volume locally

        else if( !(TRK_MEND_DONT_SEARCH_ALL_VOLUMES & *pRestrictions)
                 &&
                 NULL != (pVol = _volumes.FindVolume( pdroidLast->GetVolumeId()) ))
        {
            // found the volume on this machine
            fFoundVolumeOnThisMachine = TRUE;
            mcidSearch = CMachineId(MCID_LOCAL);
            hr = S_OK;

            TrkLog((TRKDBG_MEND, TEXT("Found volume %s on THIS (%s) machine."),
                    (const TCHAR*)CDebugString(pdroidLast->GetVolumeId()),
                    (const TCHAR*)CDebugString(mcidSearch) ));
        }

        else
        {
            // The volume isn't on the local machine.  See if we can find it in the
            // local volume cache.

            if( TRK_MEND_DONT_SEARCH_ALL_VOLUMES & *pRestrictions )
                hr = TRK_E_NOT_FOUND;
            else
                hr = _volumeLocCache.FindVolume( pdroidLast->GetVolumeId(),
                                                 &mcidFromVolumeCache,
                                                 &fRecentVolCacheEntryFound )
                        ? S_OK
                        : TRK_E_NOT_FOUND;

            if (hr == S_OK)
            {
                // Yes, the volid-to-mcid mapping is in the local cache.

                CDomainRelativeObjId droidBirthLast = *pdroidBirthLast;
                CDomainRelativeObjId droidLast = *pdroidLast;
                CMachineId           mcidLast = *pmcidLast;
                TCHAR                tsz[ MAX_PATH + 1 ];

                TrkLog((TRKDBG_MEND, TEXT("LocalCache--> %s (%s)"),
                        (const TCHAR*)CDebugString(mcidFromVolumeCache),
                        fRecentVolCacheEntryFound
                            ? TEXT("young cache entry") 
                            : TEXT("old cache entry") ));

                mcidSearch = mcidFromVolumeCache;
                volid = pdroidLast->GetVolumeId();

                // Search using temporaries, so that we can ignore the result if
                // we just get a TRK_E_POTENTIAL_FILE_FOUND.

                hr = ConnectAndSearchMachine(IDL_handle, mcidSearch, pRestrictions,
                                             &droidBirthLast, &droidLast, &mcidLast, tsz);

                // If the volume is good, put it back into the cache.  This
                // refreshes it so that it's least likely to be removed in a trim.

                if (hr != TRK_S_VOLUME_NOT_FOUND
                    &&
                    hr != TRK_E_UNAVAILABLE)
                {
                    TrkLog((TRKDBG_MEND, TEXT("%s --> %s"),
                            (const TCHAR*)CDebugString(mcidSearch),
                            GetErrorString(hr) ));

                    _volumeLocCache.AddVolume(volid, mcidSearch);
                }

                if( SUCCEEDED(hr) )
                {
                    // We found the file and we're done.

                    *pdroidBirthLast = droidBirthLast;
                    *pdroidLast = droidLast;
                    *pmcidLast = mcidLast;
                    _tcscpy( ptsz, tsz );
                    __leave;
                }

                // We didn't find the file.  Save this result.
                // We might look up the volid in the DC to handle
                // the case where the cache is out of date.  But if the DC agrees on
                // where that volume lives, we won't bother to search again.
                hrFromSearchUsingCachedVolId = hr;

            }   // if (hr == S_OK)

#ifdef VOL_REPL
            if (hr != S_OK)
            {
                hr = _persistentVolumeMap.FindVolume(pdroidLast->GetVolumeId(), &mcidSearch) ? S_OK : TRK_E_NOT_FOUND;
                if (hr == S_OK)
                {
                    TrkLog((TRKDBG_MEND, TEXT("FindAndSearchVolume: Volume on machine %s, (found in local persist volume map)"),
                        CDebugString(mcidSearch)._tsz));
                }
            }
#endif

            // The volume isn't local, or wasn't in the local cache, or if it was in the
            // local cache the cache is out of date.  So, we'll ask the TrkSvr (DC).

            if( hr != S_OK )
            {
                BOOL fSearchedDC = FALSE;
                TRKSVR_SYNC_VOLUME SyncVolume;
                SyncVolume.hr = TRK_S_VOLUME_NOT_FOUND;

                // Not found on this machine ... go look in the DC for the volume.
                // Don't look in the DC, however, if restricted to avoid it,
                // or if we had a good (recent) entry for it in the volume cache.

                if( !fRecentVolCacheEntryFound
                    &&
                    !(TRK_MEND_DONT_USE_DC & *pRestrictions)
                    &&
                    !(DONT_USE_DC & SearchFlags) )
                {
                    TRKSVR_MESSAGE_UNION Msg;
                    VolumeMapEntry * pVolumeChanges = NULL;

                    SyncVolume.hr = S_OK;
                    SyncVolume.SyncType = FIND_VOLUME;
                    SyncVolume.volume = pdroidLast->GetVolumeId();
                    SyncVolume.machine = CMachineId();

                    Msg.MessageType = SYNC_VOLUMES;
                    Msg.Priority = PRI_0;
                    Msg.SyncVolumes.cVolumes = 1;
                    Msg.SyncVolumes.pVolumes = &SyncVolume;

#ifdef VOL_REPL
                    Msg.SyncVolumes.ppVolumeChanges = &pVolumeChanges;
                    Msg.SyncVolumes.cChanges = 0;
                    Msg.SyncVolumes.ftFirstChange = CFILETIME(-1);
#endif

                    __try
                    {
                        hr = adc.CallAvailableDc(&Msg);
                        fSearchedDC = TRUE;
                    }
                    __except( EXCEPTION_EXECUTE_HANDLER )
                    {
                        hr = GetExceptionCode();

                        // Something's wrong with the DC and there's no point
                        // trying to call it again during this mend operation.

                        *pRestrictions |= TRK_MEND_DONT_USE_DC;
                    }

                }   // if( !(TRK_MEND_DONT_USE_DC & *pRestrictions) )

#if DBG
                else
                {
                    TrkLog(( TRKDBG_MEND, TEXT("Not searching for volume on DC because of %s, %s, %s"),
                        fRecentVolCacheEntryFound ? TEXT("VolCache") : TEXT(""),
                        (TRK_MEND_DONT_USE_DC & *pRestrictions) ? TEXT("Restrictions") : TEXT(""),
                        (DONT_USE_DC & SearchFlags) ? TEXT("SearchFlags") : TEXT("") ));
                }
#endif

                // Did we successfully get a mcid back from the DC
                // that's different than the one we found in the volume cache?

                if( S_OK == hr && S_OK == SyncVolume.hr )
                {
                    // We got an mcid back from the DC

                    if( SyncVolume.machine != mcidFromVolumeCache )
                    {
                        // And the mcid from the DC differs from the one in the
                        // volume cache (the volume has moved since the time we cached it).

                        mcidSearch = SyncVolume.machine;
                        hr = S_OK;
                        TrkLog((TRKDBG_MEND, TEXT("Found volume %s in DC on %s"),
                                (const TCHAR*)CDebugString(pdroidLast->GetVolumeId()),
                                (const TCHAR*)CDebugString(mcidSearch) ));
                    }
                    else
                    {
                        // We've already searched this volume.

                        TrkLog((TRKDBG_MEND, TEXT("DC matches volume cache") ));

                        hr = hrFromSearchUsingCachedVolId;
                        __leave;
                    }

                }
                else
                {
                    // We couldn't find the volume in the DC.
#if DBG
                    if( fSearchedDC )
                    {
                        TrkLog((TRKDBG_MEND, TEXT("DC--> %s -> %s,%s."),
                                (const TCHAR*)CDebugString(pdroidLast->GetVolumeId()),
                                GetErrorString(hr),
                                GetErrorString(SyncVolume.hr) ));
                    }
#endif

                    mcidSearch = *pmcidLast;
                    hr = TRK_E_NOT_FOUND;
                }

                // Save this result in the volume cache.  If we didn't find the volume,
                // then we'll be putting a null machine ID into the cache as a way
                // of remembering not to ask the DC again in the near future.

                if( fSearchedDC )
                    _volumeLocCache.AddVolume( SyncVolume.volume, SyncVolume.machine );


            }   // if (hr != S_OK)
        }   // if (pVol != NULL)

        //  -------------------------------------------------
        //  We've found a machine.  Connect to it and search.
        //  -------------------------------------------------

        // Save the volid from pdroidLast before it gets overwritten.
        volid = pdroidLast->GetVolumeId();

        if( !(TRK_MEND_DONT_SEARCH_LAST_MACHINE & *pRestrictions)
            ||
            mcidSearch != *pmcidLast )
        {
            hr = ConnectAndSearchMachine(IDL_handle, mcidSearch, pRestrictions,
                                         pdroidBirthLast, pdroidLast, pmcidLast, ptsz);
        }
        else
            hr = TRK_E_NOT_FOUND;

        // Take advantage of our work to find the owner of this volume, and
        // add it to the cache.

        if( S_OK == hr && !fFoundVolumeOnThisMachine )
            _volumeLocCache.AddVolume(volid, mcidSearch);

        // S_OK || TRK_E_REFERRAL || TRK_E_NOT_FOUND || TRK_E_UNAVAILABLE
    }
    __finally
    {
        if (pVol != NULL)
        {
            pVol->Release();
        }

        if (AbnormalTermination())
        {
            TrkLog((TRKDBG_MEND, TEXT("FindAndSearchVolume: abnormal termination")));
        }

        adc.UnInitialize();

    }

    TrkLog((TRKDBG_MEND, TEXT("Call to %s to FindAndSearchVolume returned %s"),
            (const TCHAR*)CDebugString(mcidSearch),
            GetErrorString(hr) ));

    return(hr);
}



//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::SearchChain
//
//  Search for a link source, possibly searching a chain of moves using
//  referrals from the log.  The caller can specify how many referrals
//  (links in the chain) to follow.  The search starts at the location
//  specified by the IDs in the pallidsLast parameter.
//
//+----------------------------------------------------------------------------


HRESULT
CTrkWksSvc::SearchChain(RPC_BINDING_HANDLE IDL_handle,
                        int             cMaxReferrals,
                        DWORD           dwTickCountDeadline,
                        IN OUT DWORD    *pRestrictions,
                        IN SEARCH_FLAGS SearchFlags,
                        IN OUT SAllIDs  *pallidsLast,
                        OUT TCHAR       *ptsz)
{
    int cReferrals = 0;
    HRESULT hr;
    IFDBG( CDomainRelativeObjId droidBirthOriginal = pallidsLast->droidBirth );

    struct CDroidList
    {
        CDomainRelativeObjId droid;
        CDroidList  *pNext;
    };
    CDroidList *pdroidList = NULL;

    // As a sanity check, never search over (100) places.
    if( -1 == cMaxReferrals )
        cMaxReferrals = _configWks.GetMaxReferrals();


    __try
    {
        while (TRUE)
        {
            CDroidList *pdroidNode = NULL;

            // Abort if the service has been requested to stop.
            RaiseIfStopped();

            if( GetTickCount() >= dwTickCountDeadline )
            {
                TrkLog((TRKDBG_MEND, TEXT("Mend: timeout")));
                hr = TRK_E_TIMEOUT;
                __leave;
            }

            // Have we searched this droid before?

            for( pdroidNode = pdroidList; NULL != pdroidNode; pdroidNode = pdroidNode->pNext )
            {
                if( pdroidNode->droid == pallidsLast->droidRevised )
                {
                    // Yes, we've see this droid before.  Abort.

                    TrkLog(( TRKDBG_MEND | TRKDBG_WKS,
                             TEXT("Aborting SearchChain; cycle found at %s"),
                             (const TCHAR*)CDebugString( pdroidNode->droid ) ));

                    hr = TRK_E_NOT_FOUND;
                    goto Exit;
                }
            }

            // Add a new node to the list for this volume (this is used above
            // for cycle detection).

            pdroidNode = new CDroidList;
            if( NULL == pdroidNode )
                TrkRaiseWin32Error( ERROR_NOT_ENOUGH_MEMORY );

            pdroidNode->droid = pallidsLast->droidRevised;
            pdroidNode->pNext = pdroidList;
            pdroidList = pdroidNode;
            pdroidNode = NULL;

            // Now find the volume and search it for the file.

            hr = FindAndSearchVolume( IDL_handle, pRestrictions, SearchFlags,
                                      &pallidsLast->droidBirth, &pallidsLast->droidRevised,
                                      &pallidsLast->mcid, ptsz);

            // If we got anything other than a referral (including S_OK) we're done.

            if( TRK_E_REFERRAL != hr )
            {
                TrkLog((TRKDBG_MEND | TRKDBG_WKS, TEXT("SearchChain - %s != TRK_E_REFERRAL so returning (%s)"),
                        GetErrorString(hr),
                        droidBirthOriginal == pallidsLast->droidBirth
                            ? TEXT("birth IDs match")
                            : TEXT("birth IDs don't match")

                        ));
                goto Exit;
            }

            // We got a referral.  Either return the referral, or follow it.

            if( ++cReferrals >= cMaxReferrals )
            {
                // Return the referral.
                TrkLog((TRKDBG_MEND, TEXT("SearchChain: Reached chain limit.")));
                goto Exit;
            }
        }
    }
    __finally
    {
        while( NULL != pdroidList )
        {
            CDroidList *pdroidNext = pdroidList->pNext;
            delete pdroidList;
            pdroidList = pdroidNext;
        }
    }

Exit:

    TrkAssert( NULL == pdroidList );
    return( hr );
}



//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::OnDomainNameChange
//
//  This method is called when we receive a notification that the domain
//  name has changed (which also happens if we move between a workgroup
//  and domain).  We handle this by putting all the volumes in the
//  not-owned state.
//
//+----------------------------------------------------------------------------

void
CTrkWksSvc::OnDomainNameChange()
{
    BOOL fWasWorkgroup;
    TrkLog(( TRKDBG_WKS, TEXT("Domain name change notification") ));

    _csDomainNameChangeNotify.Enter();
    __try
    {
        RaiseIfStopped();

        fWasWorkgroup = _configWks._fIsWorkgroup;
        CheckForDomainOrWorkgroup();    // Sets _configWks._fIsWorkgroup

        // Workgroup => Domain
        if( fWasWorkgroup && !_configWks._fIsWorkgroup )
        {
            _volumes.InitializeDomainObjects();
            StartDomainTimers();
            _volumes.StartDomainTimers();
        }

        // Domain => Workgroup
        else if( !fWasWorkgroup && _configWks._fIsWorkgroup )
        {
            _volumes.UnInitializeDomainObjects();
        }

        // If we switched into a domain, or between domains, claim
        // our volumes to get in sync with the DC or begin the process
        // of re-creating the volume.

        if( !_configWks._fIsWorkgroup )
            _volumes.ForceVolumeClaims();
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Ignoring exception %08x in OnDomainNameChange"),
                 GetExceptionCode() ));
    }
    _csDomainNameChangeNotify.Leave();
}



//+----------------------------------------------------------------------------
//
//  CTrkWksSvc::DoWork
//
//  This is an override of the PWorkItem base class.  This method is called
//  on a thread pool thread, and is queued when the service needs to stop.
//
//+----------------------------------------------------------------------------


void
CTrkWksSvc::DoWork()
{
    ServiceStopCallback( this, FALSE );
}


//+----------------------------------------------------------------------------
//
//  CTestSync::Initialize
//
//  Open the test sync semaphores.
//
//+----------------------------------------------------------------------------

#if DBG

void
CTestSync::Initialize(const TCHAR * ptszBaseName)
{
    TCHAR tsz[MAX_PATH];
    TCHAR * ptszSuffix;

    _tcscpy(tsz, ptszBaseName);
    ptszSuffix = _tcschr(tsz, 0);

    _tcscat(ptszSuffix, TEXT("Reached"));
    _hSemReached = OpenSemaphore(SEMAPHORE_ALL_ACCESS, FALSE, tsz);

    _tcscat(ptszSuffix, TEXT("Wait"));
    _hSemWait    = OpenSemaphore(SEMAPHORE_ALL_ACCESS, FALSE, tsz);

    _tcscat(ptszSuffix, TEXT("Flag"));
    _hSemFlag    = OpenSemaphore(SEMAPHORE_ALL_ACCESS, FALSE, tsz);

    if (_hSemFlag != NULL && _hSemWait != NULL && _hSemReached != NULL)
    {
        Beep(2000,500);
        Sleep(500);
        Beep(2000,500);
    }
}

#endif // #if DBG

//+----------------------------------------------------------------------------
//
//  CTestSync::UnInitialize
//
//  Close down the semaphores.
//
//+----------------------------------------------------------------------------

#if DBG

void
CTestSync::UnInitialize()
{
    if (_hSemFlag != NULL)
    {
        CloseHandle(_hSemFlag);
        _hSemFlag = NULL;
    }
    if (_hSemWait != NULL)
    {
        CloseHandle(_hSemWait);
        _hSemWait = NULL;
    }
    if (_hSemReached != NULL)
    {
        CloseHandle(_hSemReached);
        _hSemReached = NULL;
    }
}

#endif // #if DBG

//+----------------------------------------------------------------------------
//
//  CTestSync::ReleaseAndWait
//
//  Wait for "Flag", release "Reached", then wait for "Wait".
//
//+----------------------------------------------------------------------------

#if DBG
void
CTestSync::ReleaseAndWait()
{
    if (_hSemFlag != NULL && _hSemWait != NULL && _hSemReached != NULL)
    {
        TrkLog(( TRKDBG_WARNING, TEXT("About to wait for test sync") ));
        DWORD dw;
        if ((dw = WaitForSingleObject(_hSemFlag, 0)) == WAIT_OBJECT_0)
        {
            TrkVerify(ReleaseSemaphore(_hSemReached, 1, NULL));
            TrkVerify(WAIT_OBJECT_0 == WaitForSingleObject(_hSemWait, INFINITE));
        }
        else
        {
            TrkVerify(dw == WAIT_TIMEOUT);
        }
    }
}
#endif // #if DBG



//+----------------------------------------------------------------------------
//
//  CTrkWksRpcServer::Initialize
//
//  Register the interface with RPC.
//+----------------------------------------------------------------------------

void
CTrkWksRpcServer::Initialize( SVCHOST_GLOBAL_DATA * pSvcsGlobalData, CTrkWksConfiguration *pTrkWksConfig )
{
    RPC_STATUS          rpcstatus;
    NET_API_STATUS      netstatus;

    // Register the ncacn_np protocol sequence with RPC (used when we're 
    // called by another trkwks) as well as ncalrpc (used when we're called
    // by CTracker::Search in shell32).

    rpcstatus = RpcServerUseProtseqEp( const_cast<TCHAR*>(s_tszTrkWksRemoteRpcProtocol),  // ncacn_np
                                       pTrkWksConfig->GetWksMaxRpcCalls(),
                                       const_cast<TCHAR*>(s_tszTrkWksRemoteRpcEndPoint),
                                       NULL );
    if( RPC_S_OK != rpcstatus && RPC_S_DUPLICATE_ENDPOINT != rpcstatus )
    {
        TrkReportInternalError( THIS_FILE_NUMBER, __LINE__,
                                HRESULT_FROM_WIN32(rpcstatus), s_tszTrkWksRemoteRpcProtocol );
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't register %s/%s(%lu)"),
                 s_tszTrkWksRemoteRpcProtocol,
                 s_tszTrkWksRemoteRpcEndPoint,
                 rpcstatus ));
        TrkRaiseWin32Error( rpcstatus );
    }
    TrkLog(( TRKDBG_RPC, TEXT("UseProtseqEp on %s, %s"),
             s_tszTrkWksRemoteRpcProtocol,
             s_tszTrkWksRemoteRpcEndPoint ));

    rpcstatus = RpcServerUseProtseqEp( const_cast<TCHAR*>(s_tszTrkWksLocalRpcProtocol), // ncalrpc
                                       pTrkWksConfig->GetWksMaxRpcCalls(),
                                       const_cast<TCHAR*>(s_tszTrkWksLocalRpcEndPoint),
                                       NULL );
    if( RPC_S_OK != rpcstatus && RPC_S_DUPLICATE_ENDPOINT != rpcstatus )
    {
        TrkReportInternalError( THIS_FILE_NUMBER, __LINE__,
                                HRESULT_FROM_WIN32(rpcstatus), s_tszTrkWksLocalRpcProtocol );
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't register %s/%s (%lu)"),
                 s_tszTrkWksLocalRpcProtocol,
                 s_tszTrkWksLocalRpcEndPoint,
                 rpcstatus ));
        TrkRaiseWin32Error( rpcstatus );
    }
    TrkLog(( TRKDBG_RPC, TEXT("UseProtseqEp on %s, %s"),
             s_tszTrkWksLocalRpcProtocol,
             s_tszTrkWksLocalRpcEndPoint ));

    // If we don't have a pSvcsGlobalData (we're not running in services.exe),
    // tell RpcServerRegisterIfEx to automatically set up a listen thread
    // (by specifying RPC_IF_AUTOLISTEN).  Also, since we use static endpoints,
    // we don't need to register with the endpoint mapper.

    CRpcServer::Initialize( Stubtrkwks_v1_2_s_ifspec,
                            NULL == pSvcsGlobalData ? RPC_IF_AUTOLISTEN : 0,
                            pTrkWksConfig->GetWksMaxRpcCalls(),
                            FALSE,  // fSetAuthInfo
                            NULL ); // Don't register with the endpoint mapper

    TrkLog(( TRKDBG_RPC, TEXT("Registered TrkWks RPC server (%d)"), pTrkWksConfig->GetWksMaxRpcCalls() ));
}

//+----------------------------------------------------------------------------
//  
//  CTrkWksRpcServer::UnInitialize
//
//  Unregister the server interface.
//
//+----------------------------------------------------------------------------

void
CTrkWksRpcServer::UnInitialize( SVCHOST_GLOBAL_DATA * pSvcsGlobalData )
{
    TrkLog(( TRKDBG_RPC, TEXT("Unregistering TrkWks RPC server") ));
    CRpcServer::UnInitialize( );
    TrkLog(( TRKDBG_RPC, TEXT("Unregistered TrkWks RPC server") ));
}

//+----------------------------------------------------------------------------
//
//  CMountManager::Initialize
//
//  Not currently implemented
//
//+----------------------------------------------------------------------------

#if 0
void
CMountManager::Initialize(CTrkWksSvc * pTrkWksSvc, CVolumeManager *pVolMgr )
{
    LONG lErr;
    UNICODE_STRING ustrMountManagerDriverName;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS status = STATUS_SUCCESS;

    _pTrkWksSvc = pTrkWksSvc;
    _pVolMgr = pVolMgr;
    _hMountManager = NULL;
    _hRegisterWaitForSingleObjectEx = NULL;


    _hCompletionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if( NULL == _hCompletionEvent )
        TrkRaiseLastError();

    _info.EpicNumber = 0;

    // Open the MountManager device driver

    RtlInitUnicodeString( &ustrMountManagerDriverName, MOUNTMGR_DEVICE_NAME );
    InitializeObjectAttributes( &ObjectAttributes,
                                &ustrMountManagerDriverName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                            );

    status = NtCreateFile( &_hMountManager,
                           FILE_READ_ATTRIBUTES|FILE_READ_DATA|SYNCHRONIZE,
                           &ObjectAttributes,
                           &IoStatusBlock, NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                           FILE_OPEN_IF,
                           FILE_CREATE_TREE_CONNECTION,
                           NULL,
                           0 );
    if( !NT_SUCCESS(status) )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Couldn't open the mount manager") ));
        TrkRaiseNtStatus(status);
    }

    _hRegisterWaitForSingleObjectEx
        = TrkRegisterWaitForSingleObjectEx( _hCompletionEvent, ThreadPoolCallbackFunction,
                                            static_cast<PWorkItem*>(this), INFINITE,
                                            WT_EXECUTEDEFAULT );
    if( NULL == _hRegisterWaitForSingleObjectEx )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Failed RegisterWaitForSingleObjectEx in CDomainNameChangeNotify (%lu)"),
                 GetLastError() ));
        TrkRaiseLastError();
    }

    AsyncListen();

}
#endif // #if 0


//+----------------------------------------------------------------------------
//
//  CMountManager::UnInitialize
//
//  Not currently implemented.
//
//+----------------------------------------------------------------------------

#if 0
void
CMountManager::UnInitialize()
{
    if( NULL != _hRegisterWaitForSingleObjectEx )
    {
        if( !TrkUnregisterWait( _hRegisterWaitForSingleObjectEx ))
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Failed UnregisterWait for CMountManager (%lu)"),
                     GetLastError() ));
        }
        _hRegisterWaitForSingleObjectEx = NULL;

    }
    if( NULL != _hCompletionEvent )
    {
        CloseHandle( _hCompletionEvent );
        _hCompletionEvent = NULL;
    }

    if( NULL != _hMountManager )
    {
        NtClose( _hMountManager );
        _hMountManager = NULL;
    }
}
#endif // #if 0


//+----------------------------------------------------------------------------
//
//  CMountManager::DoWork
//
//  Not currently implemented.
//
//+----------------------------------------------------------------------------

#if 0
void
CMountManager::DoWork()
{
    Raise If Stopped

    TrkLog((TRKDBG_WKS, TEXT("CMountManager received a notification (Epic=%d)"), _info.EpicNumber ));

    __try
    {
        // Update drive letters if they've changed, pick up any new volumes,
        // and delete the CVolume objects for volumes that have gone away.

        //_pVolMgr->RefreshVolumes();

    }
    __except( BreakOnDebuggableException() )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Exception in CMountManager::DoWork (%08x)"), GetExceptionCode() ));
    }

    AsyncListen();
}
#endif // #if 0



//+----------------------------------------------------------------------------
//
//  CMountManager::AsyncListen
//
//  Not currently implemented.
//
//+----------------------------------------------------------------------------

#if 0
void
CMountManager::AsyncListen(  )
{
    NTSTATUS status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;
    MOUNTMGR_CHANGE_NOTIFY_INFO infoIn = _info;

    for( int i = 0; i < 2; i++ )
    {
        TrkAssert( 0 == i || 0 != infoIn.EpicNumber );

        status = NtDeviceIoControlFile(
                    _hMountManager,
                    _hCompletionEvent,          // Event
                    NULL,                       // ApcRoutine
                    NULL,                       // ApcContext
                    &IoStatusBlock,
                    IOCTL_MOUNTMGR_CHANGE_NOTIFY,
                    &infoIn,                    // InputBuffer
                    sizeof(infoIn),             // InputBufferLength
                    &_info,                     // OutputBuffer
                    sizeof(_info)               // OutputBufferLength
                    );


        if( STATUS_SUCCESS == status )
        {
            // The MountManager is at a newer EpicNumber than we are.  This means that
            // changes have occurred for which we didn't receive a notification
            // (i.e., we were processing one notification when another was sent).
            // This is always the case, though, during service initialization.

            if( 0 == infoIn.EpicNumber )
            {
                // We must be in service initialization.  Just resend the ioctl
                // with the latest EpicNumber.

                infoIn = _info;
                TrkAssert( 0 != _info.EpicNumber );
            }
            else
            {
                // Fire the event as if it came from an ioctl completion
                if( !SetEvent( _hCompletionEvent ))
                {
                    TrkLog(( TRKDBG_ERROR, TEXT("Couldn't fire mount manager completion event") ));
                    TrkRaiseLastError();
                }

                break; // for
            }
        }

        // Ordinarily, we'll get status_pending

        else if( STATUS_PENDING )
            break;
        else
        {
            TrkLog(( TRKDBG_ERROR, TEXT("Couldn't send mount manager notify ioctl") ));
            TrkRaiseNtStatus(status);
        }

    }   // for( int i = 0; i < 2; i++ )


    return;

}
#endif



/*
HRESULT
GetTCharsFromPipe( TCHAR_PIPE *ppipe, TCHAR *ptsz, ULONG *pcb )
{
    return( E_FAIL );

#if 0

    ULONG cbActual = 0;
    TCHAR tszVerify[ 1 ];

    ppipe->pull( ppipe->state, ptsz, *pcb, &cbActual );
    *pcb = cbActual;

    if( 0 == cbActual )
        return( HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME) );

    ppipe->pull( ppipe->state, tszVerify, sizeof(tszVerify), &cbActual );
    if( 0 != cbActual )
        return( HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW) );

    return( S_O );

#endif // #if 0
}
*/


//+----------------------------------------------------------------------------
//
//  CDomainNameChangeNotify::Initialize
//
//  Call NetRegisterDomainNameChangeNotification, and then register that
//  handle with the NTDLL thread pool.
//
//+----------------------------------------------------------------------------

void
CDomainNameChangeNotify::Initialize()
{
    NET_API_STATUS NetStatus;

    _fInitialized = TRUE;
    _hDomainNameChangeNotification = INVALID_HANDLE_VALUE;

    __try
    {
        // Register for domain name change notification

        NetStatus = NetRegisterDomainNameChangeNotification(&_hDomainNameChangeNotification);
        if(NetStatus != NO_ERROR)
        {
            _hDomainNameChangeNotification = INVALID_HANDLE_VALUE;
            TrkReportInternalError( THIS_FILE_NUMBER, __LINE__, NetStatus, TRKREPORT_LAST_PARAM );
            TrkLog((TRKDBG_ERROR, TEXT("Can't register domain name change notification, %08x"), NetStatus));
            TrkRaiseWin32Error( NetStatus );
        }
        else
        {
            // Register the change handle with the thread pool.

            TrkLog((TRKDBG_LOG, TEXT("NetRegisterDomainNameChangeNotification succeeded")));
            TrkAssert(_hDomainNameChangeNotification != INVALID_HANDLE_VALUE);


            _hRegisterWaitForSingleObjectEx
                = TrkRegisterWaitForSingleObjectEx( _hDomainNameChangeNotification, ThreadPoolCallbackFunction,
                                                    static_cast<PWorkItem*>(this), INFINITE,
                                                    WT_EXECUTEDEFAULT );
            if( NULL == _hRegisterWaitForSingleObjectEx )
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Failed RegisterWaitForSingleObjectEx in CDomainNameChangeNotify (%lu)"),
                         GetLastError() ));
                TrkRaiseLastError();
            }
        }
    }
    __except(BreakOnDebuggableException())
    {
        if(_hDomainNameChangeNotification != INVALID_HANDLE_VALUE)
        {
            NetUnregisterDomainNameChangeNotification(_hDomainNameChangeNotification);
            _hDomainNameChangeNotification = INVALID_HANDLE_VALUE;
        }
        _fInitialized = FALSE;
    }
}



//+----------------------------------------------------------------------------
//
//  CDomainNameChangeNotify::UnInitialize
//
//  Unregister with the thread pool, then unregister the change notify.
//
//+----------------------------------------------------------------------------

void
CDomainNameChangeNotify::UnInitialize()
{
    if( _fInitialized )
    {
        if( NULL != _hRegisterWaitForSingleObjectEx )
        {
            if( !TrkUnregisterWait( _hRegisterWaitForSingleObjectEx ))
            {
                TrkLog(( TRKDBG_ERROR, TEXT("Failed UnregisterWait for CDomainNameChangeNotify (%lu)"),
                         GetLastError() ));
            }
            else
                TrkLog(( TRKDBG_WKS, TEXT("Unregistered wait for CDomainNameChangeNotify") ));

            _hRegisterWaitForSingleObjectEx = NULL;

        }

        if( INVALID_HANDLE_VALUE != _hDomainNameChangeNotification )
            NetUnregisterDomainNameChangeNotification(_hDomainNameChangeNotification);

        _hDomainNameChangeNotification = INVALID_HANDLE_VALUE;
        _fInitialized = FALSE;
    }
}


//+----------------------------------------------------------------------------
//
//  CDomainNameChangeNotify::DoWork
//  
//  This is called when we move into a new domain.  Just calls CTrkWksSvc
//  to do the work.
//
//+----------------------------------------------------------------------------

void
CDomainNameChangeNotify::DoWork()
{
    g_ptrkwks->OnDomainNameChange();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\volcache.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  volcache.cxx
//
//  Implementation for CVolumeLocationCache.  This class is used by trkwks
//  to keep a cache of volid->mcid mappings.
//
//+============================================================================

#include "pch.cxx"
#pragma hdrstop

#include "trkwks.hxx"


//+----------------------------------------------------------------------------
//
//  CVolumeLocationCache::Initialize
//
//  Init the critsec and set the lifetime value.
//
//+----------------------------------------------------------------------------

void
CVolumeLocationCache::Initialize( DWORD dwEntryLifetimeSeconds )
{
    _cs.Initialize();
    _fInitialized = TRUE;
    _cVols = 0;

    _cftEntryLifetime = 0;
    _cftEntryLifetime.IncrementSeconds( dwEntryLifetimeSeconds );
}


//+----------------------------------------------------------------------------
//
//  CVolumeLocationCache::UnInitialize
//
//  Free the critsec.
//
//+----------------------------------------------------------------------------

void
CVolumeLocationCache::UnInitialize()
{
    if (_fInitialized)
    {
        _fInitialized = FALSE;
        _cs.UnInitialize();
    }
}


//+----------------------------------------------------------------------------
//
//  CVolumeLocationCache::_FindVolume
//
//  Search the cache for a volid.  If it's found, return it's index in the
//  cache array.
//
//+----------------------------------------------------------------------------

int
CVolumeLocationCache::_FindVolume(const CVolumeId & volid)
{
    for (int i=0; i<_cVols; i++)
    {
        if (_vl[i].volid == volid)
        {
            return(i);
        }
    }

    return(-1);
}


//+----------------------------------------------------------------------------
//
//  CVolumeLocationCache::FindVolume
//
//  search the cache for a volid.  If found, return the machine ID it was
//  last known to be on, and a bool indicating if this entry in the cache
//  is old or new.  If it's old and doesn't work, the caller shouldn't
//  trust the cache.  If it's new and doesn't work, the caller shouldn't
//  bother the DC trying to find it.
//
//+----------------------------------------------------------------------------

BOOL
CVolumeLocationCache::FindVolume(const CVolumeId & volid, CMachineId * pmcid, BOOL *pfRecentEntry )
{
    int i;

    _cs.Enter();

    i=_FindVolume(volid );
    if (i != -1)
    {
        // We found the volume.  Load the data.

        CFILETIME cftNow;
        *pmcid=_vl[i].mcid;
        *pfRecentEntry = ( (cftNow - _vl[i].cft) <= _cftEntryLifetime );
    }

    _cs.Leave();
    return(i != -1);
}


//+----------------------------------------------------------------------------
//
//  CVolumeLocationCache::AddVolume
//
//  Add a volid->mcid mapping to the cache.  The entry in the cache is
//  timestamped so we know how trustworthy it is.  If the entry is already
//  in the cache, we just update the timestamp.  In either case, this entry
//  will be at the front of the array.
//
//+----------------------------------------------------------------------------

void
CVolumeLocationCache::AddVolume(const CVolumeId & volid, const CMachineId & mcid)
{
    int i;

    if( CVolumeId() == volid )
        return;

    _cs.Enter();

    i = _FindVolume(volid);
    if (i == -1)
    {
        // This volid isn't already in the cache.  Shift back the existing
        // entries so that this entry can be in front.

        BOOL fFull = _cVols >= MAX_CACHED_VOLUME_LOCATIONS;
        memcpy(&_vl[1], &_vl[0], sizeof(VolumeLocation)*(fFull ? _cVols-1 : _cVols));
        if (!fFull)
        {
            _cVols++;
        }

    }
    else
    {
        // Move the prior part of the array back, overwriting
        // the this entry.  That way we can put this entry
        // at the front.

        memcpy(&_vl[1], &_vl[0], sizeof(VolumeLocation)*i);
    }

    // Put this entry at the front of the array.

    _vl[0].volid = volid;
    _vl[0].mcid = mcid;
    _vl[0].cft = CFILETIME();

#if DBG
    for (i=0; i<_cVols; i++)
    {
        TrkLog((TRKDBG_VOLCACHE,
                TEXT("%02d: %s -> %s") MCID_BYTE_FORMAT_STRING,
                i,
                (const TCHAR*)CDebugString(_vl[i].volid),
                (const TCHAR*)CDebugString(_vl[i].mcid),
                ((BYTE*)&(_vl[i].mcid))[0], ((BYTE*)&(_vl[i].mcid))[1], ((BYTE*)&(_vl[i].mcid))[2], ((BYTE*)&(_vl[i].mcid))[3],
                ((BYTE*)&(_vl[i].mcid))[4], ((BYTE*)&(_vl[i].mcid))[5], ((BYTE*)&(_vl[i].mcid))[6], ((BYTE*)&(_vl[i].mcid))[7],
                ((BYTE*)&(_vl[i].mcid))[8], ((BYTE*)&(_vl[i].mcid))[9], ((BYTE*)&(_vl[i].mcid))[10], ((BYTE*)&(_vl[i].mcid))[11],
                ((BYTE*)&(_vl[i].mcid))[12], ((BYTE*)&(_vl[i].mcid))[13], ((BYTE*)&(_vl[i].mcid))[14], ((BYTE*)&(_vl[i].mcid))[15] ));

    }
#endif

    _cs.Leave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\utest\teststub.cxx ===
//
// This file allows the utests to link.
// This is necessary because the utest sources file links in every obj
// in the project.  So without these definitions we get unnecessary
// linker errors in things like tldap.
//

#include <trklib.hxx>
#include <trkwks.hxx>

CTrkWksSvc *  g_ptrkwks = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\trkwks\wksconfig.cxx ===
// Copyright (c) 1996-1999 Microsoft Corporation

//+============================================================================
//
//  wksconfig.cxx
//
//  This file implements the CTrkWksConfiguration class, which maintains
//  run-time configuration parameters for the trkwks service.
//
//+============================================================================

#include "pch.cxx"
#include "trkwks.hxx"


//+----------------------------------------------------------------------------
//
//  CTrkWksConfiguration::_Parameters
//
//  This array holds all the configurable parameters for the trkwks service.
//  It holds the registry value name, the default value, etc.  Static
//  configuration values may only 
//
//+----------------------------------------------------------------------------

STrkConfigRecord CTrkWksConfiguration::_Parameters[] =
{ 
    TRKCONFIGRECORD( TEXT("Refresh"),                  ( 30 * TRKDAY ),    0, TRKCONFIG_STATIC, REFRESH_PERIOD_CONFIG ),
    TRKCONFIGRECORD( TEXT("RefreshHesitation"),        ( 6 * TRKHOUR ),    0, TRKCONFIG_STATIC, REFRESH_HESITATION_CONFIG ),
    TRKCONFIGRECORD( TEXT("RefreshRetryMin"),          ( 1 * TRKHOUR ),    0, TRKCONFIG_STATIC, REFRESH_RETRY_MIN_CONFIG ),
    TRKCONFIGRECORD( TEXT("RefreshRetryMax"),          ( 1 * TRKDAY ),     0, TRKCONFIG_STATIC, REFRESH_RETRY_MAX_CONFIG ),

    TRKCONFIGRECORD( TEXT("PortThreadKeepAliveTime"),  30,                 0, TRKCONFIG_STATIC, PORT_THREAD_KEEP_ALIVE_TIME_CONFIG ),
    TRKCONFIGRECORD( TEXT("MaxReferrals"),             100,                0, TRKCONFIG_STATIC, MAX_REFERRALS_CONFIG ),
    TRKCONFIGRECORD( TEXT("PortNotifyError"),          0,                  0, TRKCONFIG_STATIC, PORT_NOTIFY_ERROR_CONFIG ),

    TRKCONFIGRECORD( TEXT("MinLogKB"),                 20,                 0, TRKCONFIG_STATIC, MIN_LOG_KB_CONFIG ),
    TRKCONFIGRECORD( TEXT("MaxLogKB"),                 1000,               0, TRKCONFIG_STATIC, MAX_LOG_KB_CONFIG ),
    TRKCONFIGRECORD( TEXT("LogDeltaKB"),               10,                 0, TRKCONFIG_STATIC, LOG_DELTA_KB_CONFIG ),
    TRKCONFIGRECORD( TEXT("LogOverwriteAge"),          ( 30 * TRKDAY ),    0, TRKCONFIG_STATIC, LOG_OVERWRITE_AGE_CONFIG ),
    TRKCONFIGRECORD( TEXT("LogFileOpenTime"),          10 /*seconds*/,     0, TRKCONFIG_STATIC, LOG_FILE_OPEN_TIME_CONFIG ),

    TRKCONFIGRECORD( TEXT("VolFrequentTasksPeriod"),   TRKDAY,             0, TRKCONFIG_STATIC, VOL_FREQUENT_TASKS_PERIOD_CONFIG ),
    TRKCONFIGRECORD( TEXT("VolInfrequentTasksPeriod"), TRKWEEK,            0, TRKCONFIG_STATIC, VOL_INFREQUENT_TASKS_PERIOD_CONFIG ),

    TRKCONFIGRECORD( TEXT("VolInitInitialDelay"),      TRKMINUTE,          0, TRKCONFIG_STATIC, VOL_INIT_INITIAL_DELAY_CONFIG ),
    TRKCONFIGRECORD( TEXT("VolInitRetryDelay1"),       (30*TRKMINUTE),     0, TRKCONFIG_STATIC, VOL_INIT_RETRY_DELAY1_CONFIG ),
    TRKCONFIGRECORD( TEXT("VolInitRetryDelay2"),       (2*TRKHOUR),        0, TRKCONFIG_STATIC, VOL_INIT_RETRY_DELAY2_CONFIG ),
    TRKCONFIGRECORD( TEXT("VolInitLifetime"),          (6*TRKHOUR),        0, TRKCONFIG_STATIC, VOL_INIT_LIFETIME_CONFIG ),

    TRKCONFIGRECORD( TEXT("VolNotOwnedExpireLimit"),   TRKWEEK,            0, TRKCONFIG_STATIC, VOL_NOT_OWNED_EXPIRE_LIMIT_CONFIG ),
    TRKCONFIGRECORD( TEXT("VolPeriodicTasksHesitation"), 2*TRKHOUR,        0, TRKCONFIG_STATIC, VOL_PERIODIC_TASKS_HESITATION_CONFIG ),

    TRKCONFIGRECORD( TEXT("MoveNotifyTimeout"),        30,                 0, TRKCONFIG_STATIC, MOVE_NOTIFY_TIMEOUT_CONFIG ),

    TRKCONFIGRECORD( TEXT("MinMoveNotifyRetry"),       30,                 0, TRKCONFIG_STATIC, MIN_MOVE_NOTIFY_RETRY_CONFIG ),
    TRKCONFIGRECORD( TEXT("MaxMoveNotifyRetry"),       ( 4 * TRKHOUR ),    0, TRKCONFIG_STATIC, MAX_MOVE_NOTIFY_RETRY_CONFIG ),
    TRKCONFIGRECORD( TEXT("MaxMoveNotifyLifetime"),    TRKDAY,             0, TRKCONFIG_STATIC, MAX_MOVE_NOTIFY_LIFETIME_CONFIG ),

    TRKCONFIGRECORD( TEXT("ObjIdIndexReopen"),         TRKMINUTE,          0, TRKCONFIG_STATIC, OBJID_INDEX_REOPEN_CONFIG ),
    TRKCONFIGRECORD( TEXT("ObjIdIndexReopenRetryMax"), TRKMINUTE,          0, TRKCONFIG_STATIC, OBJID_INDEX_REOPEN_RETRY_MAX_CONFIG ),
    TRKCONFIGRECORD( TEXT("ObjIdIndexReopenRetryMin"), TRKMINUTE,          0, TRKCONFIG_STATIC, OBJID_INDEX_REOPEN_RETRY_MIN_CONFIG ),
    TRKCONFIGRECORD( TEXT("ObjIdIndexReopenLifetime"), ( 20 * TRKMINUTE ), 0, TRKCONFIG_STATIC, OBJID_INDEX_REOPEN_LIFETIME_CONFIG ),

    TRKCONFIGRECORD( TEXT("IgnoreMovesAndDeletes"),    0,                  0, TRKCONFIG_DYNAMIC,IGNORE_MOVES_AND_DELETES_CONFIG ),

    TRKCONFIGRECORD( TEXT("BreakOnErrors"),            0,                  0, TRKCONFIG_STATIC, BREAK_ON_ERRORS_CONFIG ), // Treated as a bool
    TRKCONFIGRECORD( TEXT("DeleteNotifyTimeout"),      ( 5 * TRKMINUTE ),  0, TRKCONFIG_STATIC, DELETE_NOTIFY_TIMEOUT_CONFIG ),
    TRKCONFIGRECORD( TEXT("MaxTunnelDelay"),           3,                  0, TRKCONFIG_STATIC, MAX_TUNNEL_DELAY_CONFIG ), // Seconds
    TRKCONFIGRECORD( TEXT("MaxSendsPerMoveNotify"),    26,                 0, TRKCONFIG_STATIC, MAX_SENDS_PER_MOVE_NOTIFY_CONFIG ),
    TRKCONFIGRECORD( TEXT("WksMaxRpcCalls"),           20,                 0, TRKCONFIG_STATIC, WKS_MAX_RPC_CALLS_CONFIG ),
    TRKCONFIGRECORD( TEXT("VolCacheTimeToLive"),       ( 5 * TRKMINUTE ),  0, TRKCONFIG_DYNAMIC,VOLCACHE_TIME_TO_LIVE_CONFIG ),
    TRKCONFIGRECORD( TEXT("MaxDeleteNotifyQueue"),     5000,               0, TRKCONFIG_STATIC, MAX_DELETE_NOTIFY_QUEUE_CONFIG ),
    TRKCONFIGRECORD( TEXT("MaxDeleteNotifyAttempts"),  100,                0, TRKCONFIG_STATIC, MAX_DELETE_NOTIFY_ATTEMPTS_CONFIG )


};


//+----------------------------------------------------------------------------
//
//  CTrkWksConfiguration::SetParameter
//
//  Set a DWORD parameter in the _Parameters array, but don't update
//  the registry value.
//
//+----------------------------------------------------------------------------

BOOL
CTrkWksConfiguration::SetParameter( DWORD dwParameter, DWORD dwValue )
{
    if( dwParameter >= ELEMENTS( _Parameters ))
        return( FALSE );

    _Parameters[ dwParameter ].dwValue = dwValue;
    return( TRUE );
}


//+----------------------------------------------------------------------------
//
//  CTrkWksConfiguration::PersistParameter
//
//  Set a DWORD parameter value in the registry, but don't update it
//  in the _Parameters array.
//
//+----------------------------------------------------------------------------

BOOL
CTrkWksConfiguration::PersistParameter( DWORD dwParameter, DWORD dwValue )
{
    if( dwParameter >= _cParameters )
    {
        TrkLog(( TRKDBG_WARNING, TEXT("Attempt to set invalid parameter (%d/%d)"),
                 dwParameter, _cParameters ));
        return( FALSE );
    }

    return( Write( _Parameters[dwParameter].ptszName, dwValue ));

}


//+----------------------------------------------------------------------------
//
//  CTrkWksConfiguration::ProcessInvalidParameter
//
//  Common code for handling an attempt to set/get a parameter that does
//  not exist.
//
//+----------------------------------------------------------------------------

void
CTrkWksConfiguration::ProcessInvalidParameter( DWORD dwParameter ) const
{
    // This is a non-inline routine so that we can use TrkLog & TrkRaise
    TrkLog(( TRKDBG_WARNING, TEXT("Invalid parameter request (%d)"), dwParameter ));
    TrkRaiseException( E_FAIL );

}


//+----------------------------------------------------------------------------
//
//  CTrkWksConfiguration::Initialize
//
//  Initialize this trkwks configuration class by initializing the base
//  CTrkConfiguration class and reading in all the parameters.  If
//  fPersistable is set, we'll keep the registry key open so that
//  we can later do writes.
//
//+----------------------------------------------------------------------------

void
CTrkWksConfiguration::Initialize( BOOL fPersistable )
{
    ULONG cb;

    _fInitialized = TRUE;
    _cParameters = sizeof(_Parameters)/sizeof(_Parameters[0]);

    CTrkConfiguration::Initialize( );

    for( int i = 0; i <= MAX_TRKWKS_CONFIG; i++ )
    {
        Read( _Parameters[i].ptszName, &_Parameters[i].dwValue, _Parameters[i].dwDefault );
        TrkAssert( _Parameters[i].Index == i );
    }
    TrkAssert( MAX_TRKWKS_CONFIG + 1 == ELEMENTS(_Parameters) );

    if( !fPersistable )
        // Allow the base class to close it's registry key.
        CTrkWksConfiguration::UnInitialize();

}


//+----------------------------------------------------------------------------
//
//  CTrkWksConfiguration::UnInitialize
//
//  Uninit the base CTrkConfiguration class.
//
//+----------------------------------------------------------------------------

VOID
CTrkWksConfiguration::UnInitialize()
{
    if( _fInitialized )
    {
        CTrkConfiguration::UnInitialize();
        _fInitialized = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\utest\tforceown.cxx ===
#include "pch.cxx"
#pragma hdrstop
#include "teststub.cxx"

#define TRKDATA_ALLOCATE
#include "trksvr.hxx"
#undef TRKDATA_ALLOCATE

#import "itrkadmn.tlb" no_namespace

#include "itrkadmn.hxx"

const TCHAR tszKeyNameLinkTrack[] = TEXT("System\\CurrentControlSet\\Services\\TrkWks\\Parameters");

DWORD g_Debug = TRKDBG_ERROR;

void Usage()
{
    _tprintf( TEXT("\n")
              TEXT("Purpose:  Use this test to check the ownership status - or take ownership - of\n")
              TEXT("          file(s) or volume(s).\n")
              TEXT("Usage:    TForceOwn <options> <file(s) or volume(s)>\n")
              TEXT("Options:  -f<scope>      Take ownership of file(s)\n")
              TEXT("          -f<scope>s     Check file ownership status\n")
              TEXT("          -v<scope>      Take ownership of volume(s)\n")
              TEXT("          -v<scope>s     Check volume ownership status\n")
              TEXT("Where <scope> is:\n")
              TEXT("          f              One file\n")
              TEXT("          v              One volume\n")
              TEXT("          m              Whole machine\n")
              TEXT("E.g.:\n")
              TEXT("          TForceOwn -vs \\\\machine\\share\\path\\file.txt\n")
              TEXT("                // Gets status for the volume containing file.txt\n")
              TEXT("          TForceOwn -ffs \\\\machine\\share\\path\\file.txt\n")
              TEXT("                // Gets status for a single file\n")
              TEXT("          TForceOwn -fm\n")
              TEXT("                // Forces all files on \\\\machine to be owned by that machine\n") );
}


void
DoVolumeStatus( TrkInfoScope scope, TCHAR *ptszUncPath )
{

    HRESULT hr = E_FAIL;
    LONG cVols = 0;
    LONG iVol;
    BSTR bstr = NULL;
    LONG lLowerBound, lUpperBound;

    // BUGBUG: we should have a try/catch(_com_error) here, but to do that
    // we need to set USE_NATIVE_EH in the sources file, and we can't do
    // that yet because the itrkadmn dll is still using __try.

    _bstr_t bstrPath( ptszUncPath );

    VARIANT varrglongIndex;
    VARIANT varrgbstrVolId;
    VARIANT varrglongStatus;

    ITrkForceOwnershipPtr pForceOwn( TEXT("LinkTrack.TrkForceOwnership.1") );

    __try
    {
        SAFEARRAYBOUND sabound;

        hr = pForceOwn->VolumeStatus( bstrPath, scope, &varrglongIndex, &varrgbstrVolId, &varrglongStatus );
        if( FAILED(hr) ) TrkRaiseException( hr );

        TrkAssert( (VT_ARRAY|VT_I4) == varrglongIndex.vt );
        TrkAssert( (VT_ARRAY|VT_BSTR) == varrgbstrVolId.vt );
        TrkAssert( (VT_ARRAY|VT_I4) == varrglongStatus.vt );

        TrkAssert( 1 == SafeArrayGetDim( varrglongIndex.parray ));
        TrkAssert( 1 == SafeArrayGetDim( varrgbstrVolId.parray ));
        TrkAssert( 1 == SafeArrayGetDim( varrglongStatus.parray ));

        hr = SafeArrayGetLBound( varrglongIndex.parray, 1, &lLowerBound );
        TrkAssert( SUCCEEDED(hr) && 0 == lLowerBound );

        hr = SafeArrayGetLBound( varrgbstrVolId.parray, 1, &lLowerBound );
        TrkAssert( SUCCEEDED(hr) && 0 == lLowerBound );

        hr = SafeArrayGetLBound( varrglongStatus.parray, 1, &lLowerBound );
        TrkAssert( SUCCEEDED(hr) && 0 == lLowerBound );

        hr = SafeArrayGetUBound( varrglongIndex.parray, 1, &lUpperBound );
        if( FAILED(hr) ) TrkRaiseException( hr );

        cVols = lUpperBound + 1;

        hr = SafeArrayGetUBound( varrgbstrVolId.parray, 1, &lUpperBound );
        TrkAssert( SUCCEEDED(hr) && cVols == lUpperBound + 1 );

        hr = SafeArrayGetUBound( varrglongStatus.parray, 1, &lUpperBound );
        TrkAssert( SUCCEEDED(hr) && cVols == lUpperBound + 1 );

        _tprintf( TEXT("\n")
                  TEXT("Volume ownership status for %s\n"),
                  ptszUncPath );

        for( iVol = 0; iVol < cVols; iVol++ )
        {
            LONG lVolIndex, lStatus;
            BSTR bstr = NULL;

            _tprintf( TEXT("\n") );

            hr = SafeArrayGetElement( varrglongIndex.parray, &iVol, &lVolIndex );
            if( FAILED(hr) ) TrkRaiseException( hr );

            _tprintf( TEXT("%10s  %c\n"), TEXT("Volume:"), TEXT('A')+static_cast<TCHAR>(lVolIndex) );

            hr = SafeArrayGetElement( varrgbstrVolId.parray, &iVol, &bstr );
            if( FAILED(hr) ) TrkRaiseException( hr );

            _tprintf( TEXT("%10s  %s\n"), TEXT("ID:"), bstr );
            SysFreeString( bstr ); bstr = NULL;

            hr = SafeArrayGetElement( varrglongStatus.parray, &iVol, &lStatus );
            if( FAILED(hr) ) TrkRaiseException( hr );

            _tprintf( TEXT("%10s  %s\n"), TEXT("Status:"), (TCHAR*) CObjectOwnershipString(lStatus) );

        }
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
        TrkAssert( STATUS_ACCESS_VIOLATION != hr );
    }

Exit:

    VariantClear( &varrglongIndex );
    VariantClear( &varrgbstrVolId );
    VariantClear( &varrglongStatus );

    if( bstr ) SysFreeString( bstr );

    if( FAILED(hr) )
        _tprintf( TEXT("DoVolumeStatus failed:  %08x\n"), hr );
}





void
DoVolumes( TrkInfoScope scope, TCHAR *ptszUncPath )
{

    HRESULT hr = E_FAIL;

    // BUGBUG: we should have a try/catch(_com_error) here, but to do that
    // we need to set USE_NATIVE_EH in the sources file, and we can't do
    // that yet because the itrkadmn dll is still using __try.

    _bstr_t bstrPath( ptszUncPath );

    ITrkForceOwnershipPtr pForceOwn( TEXT("LinkTrack.TrkForceOwnership.1") );

    __try
    {
        hr = pForceOwn->Volumes( bstrPath, scope );
        if( FAILED(hr) ) TrkRaiseException( hr );
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
        TrkAssert( STATUS_ACCESS_VIOLATION != hr );
    }

Exit:

    if( FAILED(hr) )
        _tprintf( TEXT("DoVolumes failed:  %08x\n"), hr );
}




void
DoFileStatus( TrkInfoScope scope, TCHAR *ptszUncPath )
{

    HRESULT hr = E_FAIL;
    LONG cFiles = 0;
    LONG iFile;
    BSTR bstr = NULL;
    LONG lLowerBound, lUpperBound;

    // BUGBUG: we should have a try/catch(_com_error) here, but to do that
    // we need to set USE_NATIVE_EH in the sources file, and we can't do
    // that yet because the itrkadmn dll is still using __try.

    _bstr_t bstrPath( ptszUncPath );

    VARIANT varrgbstrFileName;
    VARIANT varrgbstrFileId;
    VARIANT varrglongStatus;

    ITrkForceOwnershipPtr pForceOwn( TEXT("LinkTrack.TrkForceOwnership.1") );

    __try
    {
        SAFEARRAYBOUND sabound;

        hr = pForceOwn->FileStatus( bstrPath, scope, &varrgbstrFileName, &varrgbstrFileId, &varrglongStatus );
        if( FAILED(hr) ) TrkRaiseException( hr );

        TrkAssert( (VT_ARRAY|VT_BSTR) == varrgbstrFileName.vt );
        TrkAssert( (VT_ARRAY|VT_BSTR) == varrgbstrFileId.vt );
        TrkAssert( (VT_ARRAY|VT_I4) == varrglongStatus.vt );

        TrkAssert( 1 == SafeArrayGetDim( varrgbstrFileName.parray ));
        TrkAssert( 1 == SafeArrayGetDim( varrgbstrFileId.parray ));
        TrkAssert( 1 == SafeArrayGetDim( varrglongStatus.parray ));

        hr = SafeArrayGetLBound( varrgbstrFileName.parray, 1, &lLowerBound );
        TrkAssert( SUCCEEDED(hr) && 0 == lLowerBound );

        hr = SafeArrayGetLBound( varrgbstrFileId.parray, 1, &lLowerBound );
        TrkAssert( SUCCEEDED(hr) && 0 == lLowerBound );

        hr = SafeArrayGetLBound( varrglongStatus.parray, 1, &lLowerBound );
        TrkAssert( SUCCEEDED(hr) && 0 == lLowerBound );

        hr = SafeArrayGetUBound( varrgbstrFileName.parray, 1, &lUpperBound );
        if( FAILED(hr) ) TrkRaiseException( hr );

        cFiles = lUpperBound + 1;

        hr = SafeArrayGetUBound( varrgbstrFileId.parray, 1, &lUpperBound );
        TrkAssert( SUCCEEDED(hr) && cFiles == lUpperBound + 1 );

        hr = SafeArrayGetUBound( varrglongStatus.parray, 1, &lUpperBound );
        TrkAssert( SUCCEEDED(hr) && cFiles == lUpperBound + 1 );

        _tprintf( TEXT("\n")
                  TEXT("File ownership status for %s\n"),
                  ptszUncPath );


        for( iFile = 0; iFile < cFiles; iFile++ )
        {
            BSTR bstr = NULL;
            long lStatus;

            _tprintf( TEXT("\n") );

            hr = SafeArrayGetElement( varrgbstrFileName.parray, &iFile, &bstr );
            if( FAILED(hr) ) TrkRaiseException( hr );

            _tprintf( TEXT("%10s  %s\n"), TEXT("File:"), bstr );
            SysFreeString( bstr ); bstr = NULL;

            hr = SafeArrayGetElement( varrgbstrFileId.parray, &iFile, &bstr );
            if( FAILED(hr) ) TrkRaiseException( hr );

            _tprintf( TEXT("%10s  %s\n"), TEXT("ID:"), bstr );
            SysFreeString( bstr ); bstr = NULL;

            hr = SafeArrayGetElement( varrglongStatus.parray, &iFile, &lStatus );
            if( FAILED(hr) ) TrkRaiseException( hr );

            _tprintf( TEXT("%10s  %s\n"), TEXT("Status:"), (TCHAR*) CObjectOwnershipString(lStatus) );

        }
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
        TrkAssert( STATUS_ACCESS_VIOLATION != hr );
    }

Exit:

    VariantClear( &varrgbstrFileName );
    VariantClear( &varrgbstrFileId );
    VariantClear( &varrglongStatus );

    if( bstr ) SysFreeString( bstr );

    if( FAILED(hr) )
        _tprintf( TEXT("DoFileStatus failed:  %08x\n"), hr );
}



void
DoFiles( TrkInfoScope scope, TCHAR *ptszUncPath )
{

    HRESULT hr = E_FAIL;

    // BUGBUG: we should have a try/catch(_com_error) here, but to do that
    // we need to set USE_NATIVE_EH in the sources file, and we can't do
    // that yet because the itrkadmn dll is still using __try.

    _bstr_t bstrPath( ptszUncPath );

    ITrkForceOwnershipPtr pForceOwn( TEXT("LinkTrack.TrkForceOwnership.1") );

    __try
    {
        hr = pForceOwn->Files( bstrPath, scope );
        if( FAILED(hr) ) TrkRaiseException( hr );
    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
        TrkAssert( STATUS_ACCESS_VIOLATION != hr );
    }

Exit:

    if( FAILED(hr) )
        _tprintf( TEXT("DoFiles failed:  %08x\n"), hr );
}


struct tagStartOle
{
    tagStartOle() { CoInitialize( NULL ); }
    ~tagStartOle() { CoUninitialize(); }
} StartOle;


EXTERN_C void __cdecl _tmain( ULONG cArgs, TCHAR *rgtszArgs[] )
{
    TrkInfoScope scope;

    TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG | TRK_DBG_FLAGS_WRITE_TO_STDOUT, "TForceOwn" );

    if( 3 > cArgs
        ||
        ( rgtszArgs[1][0] != TEXT('-')
          &&
          rgtszArgs[1][0] != TEXT('/') 
        )
      )
    {
        Usage();
        goto Exit;
    }


    _tcsupr( rgtszArgs[1] );

    switch( rgtszArgs[ 1 ][ 1 ] )
    {
        case TEXT('V'):

            switch( rgtszArgs[1][2] )
            {
                case TEXT('V'):
                    scope = TRKINFOSCOPE_VOLUME;
                    break;
                case TEXT('M'):
                    scope = TRKINFOSCOPE_MACHINE;
                    break;
                default:
                    _tprintf( TEXT("Unsupported option:  %s\n"), rgtszArgs[1] );
                    goto Exit;
            }

            if( TEXT('S') == rgtszArgs[1][3] )
                DoVolumeStatus( scope, rgtszArgs[2] );
            else
                DoVolumes( scope, rgtszArgs[2] );
            break;

        case TEXT('F'):

            switch( rgtszArgs[1][2] )
            {
                case TEXT('F'):
                    scope = TRKINFOSCOPE_ONE_FILE;
                    break;
                case TEXT('V'):
                    scope = TRKINFOSCOPE_VOLUME;
                    break;
                case TEXT('M'):
                    scope = TRKINFOSCOPE_MACHINE;
                    break;
                default:
                    _tprintf( TEXT("Unsupported option:  %s\n"), rgtszArgs[1] );
                    goto Exit;
            }

            if( TEXT('S') == rgtszArgs[1][3] )
                DoFileStatus( scope, rgtszArgs[2] );
            else
                DoFiles( scope, rgtszArgs[2] );
            break;

        default:

            _tprintf( TEXT("Unsupported option:  %s\n"), rgtszArgs[1] );
            break;
    }


Exit:

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\utest\ttimer.cxx ===
#include "pch.cxx"
#pragma hdrstop

#define TRKDATA_ALLOCATE
#include "trkwks.hxx"


const TCHAR *g_tszDefaultName = TEXT("TimerTestDefault");
const TCHAR *g_tszContinueName = TEXT("TimerTestContinue");

DWORD g_Debug = TRKDBG_ERROR | TRKDBG_TIMER;
ULONG g_ulDefaultPeriod = 4;   // Seconds
ULONG g_ulMinRetry = g_ulDefaultPeriod * 3 / 2;
ULONG g_ulMaxRetry = g_ulMinRetry * 4;
ULONG g_ulTimerContext = 0;

CFILETIME g_cftDeltaMargin = 10*1000*1000; // 1 second

#include "ttimer.hxx"


void
CTimerTest::Initialize( PTimerCallback *pTimerCallback,
                        const TCHAR *ptszName,
                        ULONG ulTimerContext,
                        ULONG ulPeriodInSeconds,
                        CNewTimer::TimerRetryType retrytype,
                        ULONG ulLowerRetryTime,
                        ULONG ulUpperRetryTime,
                        ULONG ulMaxLifetime )
{
    _ptszName = ptszName;

    _fInitialized = TRUE;

    _timer.Initialize(pTimerCallback, ptszName,
                      ulTimerContext, ulPeriodInSeconds, retrytype,
                      ulLowerRetryTime, ulUpperRetryTime, ulMaxLifetime );

    _hEvent = CreateEvent( NULL, FALSE, FALSE, TEXT("TTimer Test") );
    if( INVALID_HANDLE_VALUE == _hEvent )
        TrkRaiseLastError( );

}


void
CTimerTest::SetTimerRegistryValue( const TCHAR *ptszName,
                                   const CFILETIME &cftSet, const CFILETIME cftDue,
                                   ULONG ulRetry )
{
    HKEY hkey;
    LONG lRet;

    if( ERROR_SUCCESS != RegOpenKeyEx( HKEY_LOCAL_MACHINE, s_tszKeyNameLinkTrack,
                                       0, KEY_ALL_ACCESS, &hkey ))
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't open persistent registry key") ));
        TrkRaiseLastError( );
    }

    CNewTimer::PersistentState TimerPersistence;

    TimerPersistence.cftDue = cftDue;
    TimerPersistence.cftSet = cftSet;
    TimerPersistence.ulCurrentRetryTime = ulRetry;

    RegDeleteValue( hkey, ptszName );
    lRet = RegSetValueEx(  hkey,
                           ptszName,
                           0,
                           REG_BINARY,
                           (CONST BYTE *)&TimerPersistence,
                           sizeof(TimerPersistence) );

    if( ERROR_SUCCESS != lRet )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't write to registry") ));
        TrkRaiseWin32Error( lRet );
    }

    RegCloseKey( hkey );
}



void
CTimerTest::VerifyRegistryDataCorrect()
{
    LONG lRet = ERROR_SUCCESS;
    CFILETIME cftDelta(0), cftNow;
    CNewTimer::PersistentState persist;
    DWORD dwType = 0, cbData = sizeof(persist);
    HKEY hkey;

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, s_tszKeyNameLinkTrack,
                         0, KEY_ALL_ACCESS, &hkey );
    if( ERROR_SUCCESS != lRet )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't open primary registry key")));
        TrkRaiseWin32Error( lRet );
    }

    lRet = RegQueryValueEx( hkey,
                            _ptszName,
                            NULL,
                            &dwType,
                            (BYTE *)&persist,
                            &cbData );
    RegCloseKey( hkey );

    cftDelta = _cftExpected - persist.cftDue;

    if( lRet != ERROR_SUCCESS
        ||
        dwType != REG_BINARY
        ||
        cbData != sizeof(persist)
        ||
        persist.cftDue > _cftExpected
        ||
        cftDelta > g_cftDeltaMargin )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Registry data isn't correct (%d, %d, %d,\n  %s,\n  %s"),
            lRet, dwType, cbData, CDebugString(persist.cftDue)._tsz, CDebugString(_cftExpected)._tsz ));
        TrkRaiseWin32Error( E_FAIL );
    }
}


void
CTimerTest::VerifyRegistryDataRemoved()
{
    LONG lRet = ERROR_SUCCESS;
    CNewTimer::PersistentState persist;
    DWORD dwType = 0, cbData = sizeof(persist);
    HKEY hkey;

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, s_tszKeyNameLinkTrack,
                         0, KEY_ALL_ACCESS, &hkey );
    if( ERROR_SUCCESS != lRet )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't open primary registry key")));
        TrkRaiseWin32Error( lRet );
    }

    lRet = RegQueryValueEx( hkey, g_tszDefaultName, NULL, &dwType, (BYTE*)&persist, &cbData );
    RegCloseKey( hkey );

    if( ERROR_FILE_NOT_FOUND != lRet )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Registry data wasn't removed") ));
        TrkRaiseWin32Error( E_FAIL );
        return;
    }

    return;
}




PTimerCallback::TimerContinuation
CTimerTest0::Timer( ULONG ulTimerContext)
{
    CFILETIME cftDelta(0);

    if( ulTimerContext != 0 )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Incorrect context from timer")));
        TrkRaiseWin32Error( E_FAIL );
    }

    // Verify that we got called at approximately the right time.

    cftDelta = abs( static_cast<int>(CFILETIME() - _cftExpected) );
    if( cftDelta > g_cftDeltaMargin )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Timer expired too late in phase 0")));
        TrkRaiseWin32Error( E_FAIL );
    }

    // Release the main test controller

    MarkTestCompleted();

    return( CONTINUE_TIMER );
}


PTimerCallback::TimerContinuation
CTimerTest1::Timer( ULONG ulTimerContext)
{
    TimerContinuation continuation = BREAK_TIMER;

    CFILETIME cftDelta(0), cftNow;
    CNewTimer::PersistentState persist;
    DWORD dwType = 0, cbData = sizeof(persist);
    HKEY hkey;
    LONG lRet = ERROR_SUCCESS;
    ULONG ulRetryPeriod;
    static CFILETIME cftBeforeRetries(0);

    if( ulTimerContext != 1 )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Incorrect context from timer")));
        TrkRaiseWin32Error( E_FAIL );
    }

    // We shouldn't be called in the final sub-phase.

    if( FINAL == _SubPhase )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Called after the timer was stopped\n")));
        TrkRaiseWin32Error( E_FAIL );
    }

    // Verify that we got called at approximately the right time.

    cftDelta = abs(static_cast<int>(cftNow - _cftExpected));
    if( cftDelta > g_cftDeltaMargin )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Timer expired too late in phase 1")));
        TrkRaiseWin32Error( E_FAIL );
    }

    // Verify that this time was stored in the Registry

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, s_tszKeyNameLinkTrack,
                         0, KEY_ALL_ACCESS, &hkey );
    if( ERROR_SUCCESS != lRet )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't open primary registry key") ));
        TrkRaiseWin32Error( lRet );
    }

    lRet = RegQueryValueEx( hkey,
                            _ptszName,
                            NULL,
                            &dwType,
                            (BYTE *)&persist,
                            &cbData );
    RegCloseKey( hkey );

    if( lRet != ERROR_SUCCESS
        ||
        dwType != REG_BINARY
        ||
        cbData != sizeof(persist)
        ||
        cftNow - persist.cftDue > g_cftDeltaMargin )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Value in registry wasn't correct") ));
        TrkRaiseWin32Error( E_FAIL );
    }
    
    //  -----------------------------
    //  Move on to the next sub-phase
    //  -----------------------------

    ulRetryPeriod = g_ulMinRetry;

    // Switch on the sub-phase which just completed.

    switch( _SubPhase )
    {

    case INITIAL:

        _tprintf( TEXT("   Letting recur\n") );

        continuation = CONTINUE_TIMER;
        _cftExpected.SetToUTC();
        _cftExpected.IncrementSeconds( g_ulDefaultPeriod );

        break;

    case THIRD_RETRY:
    case SECOND_RETRY:

        ulRetryPeriod *= 2;

    case FIRST_RETRY:

        ulRetryPeriod *= 2;

    case FIRST_RECURRENCE:

        _tprintf( TEXT("   Retrying timer (%ds)\n"), ulRetryPeriod );
        _cftExpected.SetToUTC();
        _cftExpected.IncrementSeconds( ulRetryPeriod );

        continuation = RETRY_TIMER;

        break;

    case FOURTH_RETRY:

        _tprintf( TEXT("   Letting timer recur\n") );
        continuation = CONTINUE_TIMER;

        _cftExpected.SetToUTC();
        _cftExpected.IncrementSeconds( g_ulDefaultPeriod  );

        break;

    case SECOND_RECURRENCE:

        VerifyRegistryDataCorrect();

        _tprintf( TEXT("   Retrying one more time (%ds)\n"), g_ulMinRetry );

        _cftExpected.SetToUTC();
        _cftExpected.IncrementSeconds( g_ulMinRetry );

        continuation = RETRY_TIMER;
        break;

    case LAST_RETRY:

        _tprintf( TEXT("   Stopping timer\n") );
        continuation = BREAK_TIMER;
        MarkTestCompleted();

        break;

    default:

        TrkLog((TRKDBG_ERROR, TEXT("Invalid sub-phase in phase 1 (%d)"), _SubPhase ));
        TrkRaiseWin32Error( E_FAIL );
        break;

    }   // switch

    _SubPhase++;

    return( continuation );
}


PTimerCallback::TimerContinuation
CTimerTest2::Timer( ULONG ulTimerContext)
{
    TimerContinuation continuation = BREAK_TIMER;

    CFILETIME cftDelta(0), cftNow;
    CNewTimer::PersistentState persist;
    DWORD dwType = 0, cbData = sizeof(persist);
    HKEY hkey;
    LONG lRet = ERROR_SUCCESS;
    ULONG ulRetryPeriod;
    static CFILETIME cftBeforeRetries(0);

    if( ulTimerContext != 2 )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Incorrect context from timer")));
        TrkRaiseWin32Error( E_FAIL );
    }

    // We shouldn't be called in the final sub-phase.

    if( FINAL == _SubPhase )
    {
        TrkLog(( TRKDBG_ERROR, TEXT("Called after the timer was stopped\n")));
        TrkRaiseWin32Error( E_FAIL );
    }

    // Verify that we got called at approximately the right time.

    cftDelta = abs(static_cast<int>(cftNow - _cftExpected));
    if( cftDelta > g_cftDeltaMargin )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Timer expired too late in phase 1")));
        TrkRaiseWin32Error( E_FAIL );
    }

    //  -----------------------------
    //  Move on to the next sub-phase
    //  -----------------------------

    switch( _SubPhase )
    {
    case INITIAL:

        // Verify that the registry was set correctly
        VerifyRegistryDataCorrect();

        // Restart the timer to a new time

        _tprintf( TEXT("   Restarting timer (%ds), still recurring and non-retrying\n"),
                  g_ulDefaultPeriod * 2 );
        _timer.ReInitialize( g_ulDefaultPeriod * 2 );
        continuation = CONTINUE_TIMER;

        _cftExpected.SetToUTC();
        _cftExpected.IncrementSeconds( g_ulDefaultPeriod * 2  );

        break;

    case RESET:

        // Verify that the registry was set correctly
        VerifyRegistryDataCorrect();

        // Release the main test controller
        MarkTestCompleted();

        break;

    default:

        TrkLog((TRKDBG_ERROR, TEXT("Invalid sub-phase in phase 2 (%d)"), _SubPhase ));
        TrkRaiseWin32Error( E_FAIL );
        break;

    }   // switch( (SUB_PHASE2_ENUM) g_SubPhase )

    _SubPhase++;


    return( continuation );
}



PTimerCallback::TimerContinuation
CTimerTest3::Timer( ULONG ulTimerContext)
{
    TimerContinuation continuation = BREAK_TIMER;

    CFILETIME cftDelta(0), cftNow;

    if( ulTimerContext != 3 )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Incorrect context from timer")));
        TrkRaiseWin32Error( E_FAIL );
    }


    // Verify that we got called at approximately the right time.

    cftDelta = abs(static_cast<int>(cftNow - _cftExpected));
    if( cftDelta > g_cftDeltaMargin )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Timer expired too late in phase 3")));
        TrkRaiseWin32Error( E_FAIL );
    }


    // Switch on the sub-phase which *just completed* to determine what to
    // do next.

    switch( _SubPhase )
    {
    case INITIAL:

        VerifyRegistryDataCorrect();

        // We're done

        continuation = BREAK_TIMER;

        // Release the main test controller
        MarkTestCompleted();

        break;

    default:

        TrkLog((TRKDBG_ERROR, TEXT("Invalid sub-phase in phase 3 (%d)"), _SubPhase ));
        TrkRaiseWin32Error( E_FAIL );
        break;

    }   // switch( _SubPhase )

    _SubPhase++;

    return( continuation );
}



PTimerCallback::TimerContinuation
CTimerTest4::Timer( ULONG ulTimerContext)
{
    TimerContinuation continuation = BREAK_TIMER;

    CFILETIME cftDelta(0), cftNow;

    if( ulTimerContext != 4 )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Incorrect context from timer")));
        TrkRaiseWin32Error( E_FAIL );
    }


    // Verify that we got called at approximately the right time.

    cftDelta = abs(static_cast<int>(cftNow - _cftExpected));
    if( cftDelta > g_cftDeltaMargin )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Timer expired too late in phase 1")));
        TrkRaiseWin32Error( E_FAIL );
    }



    // Switch on the sub-phase which *just completed* to determine what to
    // do next.

    switch( _SubPhase )
    {
    case INITIAL:

        _tprintf( TEXT("   Retrying (%ds)\n"), g_ulDefaultPeriod/2 );
        VerifyRegistryDataRemoved();

        continuation = RETRY_TIMER;
        _cftExpected.SetToUTC();
        _cftExpected.IncrementSeconds( g_ulDefaultPeriod / 2 );

        break;

    case SECOND:

        _tprintf( TEXT("   Retrying (%ds)\n"), g_ulDefaultPeriod );
        continuation = RETRY_TIMER;

        _cftExpected.SetToUTC();
        _cftExpected.IncrementSeconds( g_ulDefaultPeriod );

        break;

    case THIRD:

        _tprintf( TEXT("   Retrying (%ds)\n"), g_ulDefaultPeriod*2 );
        continuation = RETRY_TIMER;

        _cftExpected.SetToUTC();
        _cftExpected.IncrementSeconds( g_ulDefaultPeriod * 2 );

        break;

    case FOURTH:

        _tprintf( TEXT("   Retrying (%ds)\n"), g_ulDefaultPeriod/4 );
        continuation = RETRY_TIMER;

        _cftExpected.SetToUTC();
        _cftExpected.IncrementSeconds( g_ulDefaultPeriod / 4 );

        break;

    case FINAL:

        continuation = BREAK_TIMER;
        MarkTestCompleted();
        break;

    default:

        TrkLog((TRKDBG_ERROR, TEXT("Unexpected sub-phase in phase 4"), _SubPhase ));
        TrkRaiseWin32Error( E_FAIL );
        break;

    }   // switch( _SubPhase )

    _SubPhase++;

    return( continuation );
}



PTimerCallback::TimerContinuation
CTimerTest5::Timer( ULONG ulTimerContext)
{
    TimerContinuation continuation = BREAK_TIMER;

    CFILETIME cftDelta(0), cftNow;

    if( ulTimerContext != 5 )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Incorrect context from timer")));
        TrkRaiseWin32Error( E_FAIL );
    }


    // Verify that we got called at approximately the right time.

    cftDelta = abs(static_cast<int>(cftNow - _cftExpected));
    if( cftDelta > g_cftDeltaMargin )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Timer expired too late in phase 1")));
        TrkRaiseWin32Error( E_FAIL );
    }



    // Switch on the sub-phase which *just completed* to determine what to
    // do next.

    switch( _SubPhase )
    {
    case INITIAL:

        continuation = BREAK_TIMER;
        VerifyRegistryDataRemoved();    // Since this is a non-persistent timer
        MarkTestCompleted();
        break;


    default:

        TrkLog((TRKDBG_ERROR, TEXT("Unexpected sub-phase in phase 5"), _SubPhase ));
        TrkRaiseWin32Error( E_FAIL );
        break;

    }   // switch( _SubPhase )

    _SubPhase++;

    return( continuation );
}



PTimerCallback::TimerContinuation
CTimerTest6::Timer( ULONG ulTimerContext )
{
    CFILETIME cftDelta(0), cftNow;
    PTimerCallback::TimerContinuation continuation = BREAK_TIMER;

    if( ulTimerContext != 6 )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Incorrect context from timer")));
        TrkRaiseWin32Error( E_FAIL );
    }

    // Validate the fire time

    if( _SubPhase == INITIAL )
    {
        cftDelta = abs(static_cast<int>(cftNow - _cftExpected));
        if( cftDelta > g_cftDeltaMargin )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Timer expired too soon/late in phase 4") ));
            TrkRaiseWin32Error( E_FAIL );
        }
    }
    else
    {
        if( cftNow < _cftLower - g_cftDeltaMargin
            ||
            cftNow > _cftUpper + g_cftDeltaMargin )
        {
            TrkLog((TRKDBG_ERROR, TEXT("Timer expired too soon/late in phase 6") ));
            TrkRaiseWin32Error( E_FAIL );
        }
    }

    // Switch on the sub-phase which *just completed* to determine what to
    // do next.

    switch( _SubPhase )
    {
    case INITIAL:

        _tprintf( TEXT("   Letting recur\n") );
        continuation = CONTINUE_TIMER;
        
        // Set the due time
        _cftLastSet = _cftLower = cftNow;
        _cftLower.IncrementSeconds( g_ulDefaultPeriod );
        _cftUpper = _cftLower;

        break;

    case FIRST_RECURRENCE:

        _tprintf( TEXT("   Retrying ") );
        continuation = RETRY_TIMER;

        _cftLastSet = _cftLower = _cftUpper = cftNow;
        _cftLower.IncrementSeconds( g_ulMinRetry );
        _cftUpper.IncrementSeconds( g_ulMaxRetry );

        break;

    case FIRST_RETRY:
    case SECOND_RETRY:
    case THIRD_RETRY:

        // Show how long the retry was
        _tprintf( TEXT("(%2ds)\n"), static_cast<LONG>(cftNow-_cftLastSet)/10000000 );

        _tprintf( TEXT("   Retrying ") );
        continuation = RETRY_TIMER;

        _cftLastSet = _cftLower = _cftUpper = cftNow;
        _cftLower.IncrementSeconds( g_ulMinRetry );
        _cftUpper.IncrementSeconds( g_ulMaxRetry );

        break;

    case FOURTH_RETRY:

        // Show how long the retry was
        _tprintf( TEXT("(%2ds)\n"), static_cast<LONG>(cftNow-_cftLastSet)/10000000 );

        _tprintf( TEXT("   Recurring one last time (%ds)\n"), g_ulDefaultPeriod );
        continuation = CONTINUE_TIMER;

        _cftLastSet = _cftLower = cftNow;
        _cftLower.IncrementSeconds( g_ulDefaultPeriod );
        _cftUpper = _cftLower;

        break;

    case FINAL:

        continuation = BREAK_TIMER;
        MarkTestCompleted();

        break;
        

    default:

        TrkLog((TRKDBG_ERROR, TEXT("Unexpected sub-phase %d in test 6"), _SubPhase ));
        TrkRaiseWin32Error( E_FAIL );
        break;

    }   // switch( (SUB_PHASE4_ENUM) g_SubPhase )

    _SubPhase++;

    return( continuation );
}



PTimerCallback::TimerContinuation
CTimerTest7::Timer( ULONG ulTimerContext )
{
    CFILETIME cftDelta(0), cftNow;
    PTimerCallback::TimerContinuation continuation = BREAK_TIMER;

    if( ulTimerContext != 7 )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Incorrect context from timer")));
        TrkRaiseWin32Error( E_FAIL );
    }

    // Verify that we got called at approximately the right time.

    cftDelta = abs(static_cast<int>(cftNow - _cftExpected));
    if( cftDelta > g_cftDeltaMargin )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Timer expired too late in phase 1")));
        TrkRaiseWin32Error( E_FAIL );
    }


    // Switch on the sub-phase which *just completed* to determine what to
    // do next.

    switch( _SubPhase )
    {
    case INITIAL:

        _tprintf( TEXT("   Starting again from the callback, while returning retry_timer\n") );

        _tprintf( TEXT("      Ensure the timer doesn't fire while we're in the callback\n") );
        Set();
        Sleep( _ulPeriod * 2 );

        _timer.Cancel();
        Set();

        continuation = RETRY_TIMER;
        break;

    case FINAL:

        continuation = BREAK_TIMER;
        MarkTestCompleted();

        break;
        

    default:

        TrkLog((TRKDBG_ERROR, TEXT("Unexpected sub-phase %d in test 7"), _SubPhase ));
        TrkRaiseWin32Error( E_FAIL );
        break;

    }   // switch( g_SubPhase )

    _SubPhase++;

    return( continuation );
}



PTimerCallback::TimerContinuation
CTimerTest8::Timer( ULONG ulTimerContext)
{
    TimerContinuation continuation = BREAK_TIMER;

    CFILETIME cftDelta(0), cftNow;

    if( ulTimerContext != 8 )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Incorrect context from timer")));
        TrkRaiseWin32Error( E_FAIL );
    }


    // Verify that we got called at approximately the right time.

    cftDelta = abs(static_cast<int>(cftNow - _cftExpected));
    if( cftDelta > g_cftDeltaMargin )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Timer expired too late in phase 8 (%s - %s)"),
                CDebugString(cftNow)._tsz, CDebugString(_cftExpected)._tsz ));
        TrkRaiseWin32Error( E_FAIL );
    }



    // Switch on the sub-phase which *just completed* to determine what to
    // do next.

    switch( _SubPhase )
    {
    case INITIAL:

        continuation = RETRY_TIMER;
        
        _cftExpected = CFILETIME();
        _cftExpected.IncrementSeconds( _ulPeriod*4 );   // The second retry
        
        break;

    case FIRST_RETRY:

        continuation = RETRY_TIMER;
        
        _cftExpected = CFILETIME();
        _cftExpected.IncrementSeconds( _ulPeriod ); // Up to max lifetime
        
        break;

    case FINAL:

        continuation = BREAK_TIMER;
        MarkTestCompleted();
        break;

    default:

        TrkLog((TRKDBG_ERROR, TEXT("Unexpected sub-phase in phase 8"), _SubPhase ));
        TrkRaiseWin32Error( E_FAIL );
        break;

    }   // switch( _SubPhase )

    _SubPhase++;

    return( continuation );
}






BOOL
IsRegistryEntryExtant()
{
    LONG lRet = ERROR_SUCCESS;
    CNewTimer::PersistentState persist;
    DWORD dwType = 0, cbData = sizeof(persist);
    HKEY hkey;

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, s_tszKeyNameLinkTrack,
                         0, KEY_ALL_ACCESS, &hkey );
    if( ERROR_SUCCESS != lRet )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't open primary registry key")));
        TrkRaiseWin32Error( lRet );
    }

    lRet = RegQueryValueEx( hkey, g_tszDefaultName, NULL, &dwType, (BYTE*)&persist, &cbData );
    RegCloseKey( hkey );

    if( ERROR_FILE_NOT_FOUND == lRet )
        return FALSE;
    else
        return TRUE;
}


BOOL
IsRegistryEntryCorrect( const CFILETIME &cftExpected )
{
    LONG lRet = ERROR_SUCCESS;
    CFILETIME cftDelta(0), cftNow;
    CNewTimer::PersistentState persist;
    DWORD dwType = 0, cbData = sizeof(persist);
    HKEY hkey;

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, s_tszKeyNameLinkTrack,
                         0, KEY_ALL_ACCESS, &hkey );
    if( ERROR_SUCCESS != lRet )
    {
        TrkLog((TRKDBG_ERROR, TEXT("Couldn't open primary registry key")));
        TrkRaiseWin32Error( lRet );
    }

    lRet = RegQueryValueEx( hkey,
                            g_tszDefaultName,
                            NULL,
                            &dwType,
                            (BYTE *)&persist,
                            &cbData );
    RegCloseKey( hkey );

    cftDelta = cftExpected - persist.cftDue;

    if( lRet != ERROR_SUCCESS
        ||
        dwType != REG_BINARY
        ||
        cbData != sizeof(persist)
        ||
        persist.cftDue > cftExpected
        ||
        cftDelta > g_cftDeltaMargin )
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }

}



EXTERN_C void __cdecl _tmain( int argc, TCHAR **argv )
{
    HRESULT hr = S_OK;
    CNewTimer::PersistentState TimerPersistence;
    
    __try
    {

        LONG lRet = ERROR_SUCCESS;
        ULONG ulMaxLifetime;
        CFILETIME cftTimer0(0);

        TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG | TRK_DBG_FLAGS_WRITE_TO_STDOUT, "TTimer" );
        RegDeleteValue( HKEY_LOCAL_MACHINE, s_tszKeyNameLinkTrack );

        CTimerTest0 cTimer0;
        CTimerTest1 cTimer1;
        CTimerTest2 cTimer2;
        CTimerTest3 cTimer3;
        CTimerTest4 cTimer4;
        CTimerTest5 cTimer5;
        CTimerTest6 cTimer6;
        CTimerTest7 cTimer7;
        CTimerTest8 cTimer8;

        //goto phase8;

        //  -------
        //  Phase 0
        //  -------

        cTimer0.Initialize( );
        cTimer0.Set();
        cTimer0.WaitForTestToComplete();
        cTimer0.EnsureTimerIsStopped(  );

        //  -------
        //  Phase 1
        //  -------
phase1:
        cTimer1.Initialize( );
        cTimer1.Set();
        cTimer1.WaitForTestToComplete();
        cTimer1.EnsureTimerIsStopped(  );


        //  -------
        //  Phase 2
        //  -------

        cTimer2.Initialize( );
        cTimer2.Set();
        cTimer2.WaitForTestToComplete();
        cTimer2.EnsureTimerIsStopped(  );

        //  -------
        //  Phase 3
        //  -------
phase3:
        cTimer3.Initialize();
        cTimer3.Set();
        cTimer3.WaitForTestToComplete();
        cTimer3.EnsureTimerIsStopped();

        // Pause to ensure that the timer clears itself
        Sleep( 1000 );

        //  -------
        //  Phase 4
        //  -------

        cTimer4.Initialize();
        cTimer4.Set();
        cTimer4.WaitForTestToComplete();
        cTimer3.EnsureTimerIsStopped();

        //  -------
        //  Phase 5
        //  -------

phase5:
        cTimer5.Initialize();
        cTimer5.Set();
        cTimer5.WaitForTestToComplete();
        cTimer5.EnsureTimerIsStopped();

        //  -------
        //  Phase 6
        //  -------
phase6:
        cTimer6.Initialize( );
        cTimer6.Set();
        cTimer6.WaitForTestToComplete();
        cTimer6.EnsureTimerIsStopped(  );

phase7:

        cTimer7.Initialize();
        cTimer7.Set();
        cTimer7.WaitForTestToComplete();
        cTimer7.EnsureTimerIsStopped();

phase8:

        cTimer8.Initialize();
        cTimer8.Set();
        cTimer8.WaitForTestToComplete();
        cTimer8.EnsureTimerIsStopped();

    }
    __except( BreakOnDebuggableException() )
    {
        hr = GetExceptionCode();
    }


    if( FAILED(hr) )
        _tprintf( TEXT("\nFailed:  hr = %#08x\n"), hr );
    else
        _tprintf( TEXT("\nPassed\n") );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\svcdlls\trksvcs\utest\tldap.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       tldap.cxx
//
//  Contents:   Command line test utility for LDAP link tracking db
//
//  Classes:
//
//  Functions:  
//              
//
//
//  History:    18-Nov-96  BillMo      Created.
//
//  Notes:      
//
//  Codework:
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop
#include "teststub.cxx"

#define TRKDATA_ALLOCATE
#include <trksvr.hxx>
#undef TRKDATA_ALLOCATE

#if DBG

class CTestSvrSvc
{
public:

    void    Initialize()
    {
        _svc.Initialize(STANDALONE_DEBUGGABLE_PROCESS);
    }

    void    UnInitialize(HRESULT hr)
    {
        _svc.UnInitialize(hr);
    }

    void    DoSwitch(TCHAR ** &tszArgs, int & cArgs, BOOL & fError);

private:

    void    DoAdd(TCHAR * pszKey, TCHAR * ptszNew, TCHAR * ptszBirth);
    void    DoDelete(TCHAR * ptszKey);
    void    DoModify(TCHAR * ptszKey, TCHAR * ptszNew, TCHAR * ptszBirth);
    void    DoQuery(TCHAR * ptszKey);
    void    DoTouch(TCHAR * ptszKey);
    void    DoFill(TCHAR * ptszNum);
    void    DoPurge();
    void    DoCachePurge();
    void    DoVolumeTable();
    void    DoShorten();
    void    DoRunTests();
    void    DoIdt();

    void    TryCreateVolume(const CMachineId & mcid,
                const CVolumeSecret & secret,
                CVolumeId * pVolumeId);

    inline  CIntraDomainTable & idt()
    {
        return(_svc._idt);
    }

    inline  CVolumeTable & voltab()
    {
        return(_svc._voltab);
    }

private:

    CTrkSvrSvc  _svc;

};

void
CTestSvrSvc::TryCreateVolume(const CMachineId & mcid,
            const CVolumeSecret & secret,
            CVolumeId * pVolumeId)
{
    __try
    {
        voltab().CreateVolume(mcid, secret, pVolumeId);
    }
    __except(BreakOnDebuggableException())
    {
        printf("Exception %08X caught\n", GetExceptionCode());
    }
}

void
CTestSvrSvc::DoAdd(TCHAR  * ptszKey, TCHAR * ptszNew, TCHAR * ptszBirth)
{
    __try
    {
        BOOL f = idt().Add(CDomainRelativeObjId(ptszKey), CDomainRelativeObjId(ptszNew), CDomainRelativeObjId(ptszBirth));
        printf("Add returns %s\n", f ? "TRUE" : "FALSE");
    }
    __except (BreakOnDebuggableException())
    {
        printf("Exception %08X caught\n", GetExceptionCode());
    }
}

void
CTestSvrSvc::DoDelete(TCHAR * ptszKey)
{
    __try
    {
        BOOL f = idt().Delete(CDomainRelativeObjId(ptszKey));
        printf("Delete returns %s\n", f ? "TRUE" : "FALSE");
    }
    __except (BreakOnDebuggableException())
    {
        printf("Exception %08X caught\n", GetExceptionCode());
    }

}

void
CTestSvrSvc::DoModify(TCHAR * ptszKey, TCHAR * ptszNew, TCHAR * ptszBirth)
{
    __try
    {
        BOOL f = idt().Modify(CDomainRelativeObjId(ptszKey), CDomainRelativeObjId(ptszNew), CDomainRelativeObjId(ptszBirth));
        printf("Modify returns %s\n", f ? "TRUE" : "FALSE");
    }
    __except (BreakOnDebuggableException())
    {
        printf("Exception %08X caught\n", GetExceptionCode());
    }

}


void
CTestSvrSvc::DoQuery(TCHAR * ptszKey)
{
    __try
    {
        CDomainRelativeObjId ldNew;
        CDomainRelativeObjId ldBirth;

        BOOL f = idt().Query(CDomainRelativeObjId(ptszKey), &ldNew, &ldBirth);
        printf("Query returns %s\n", f ? "TRUE" : "FALSE");
        if (f)
        {
            ldNew.DebugPrint(TEXT("ldNew="));
            ldBirth.DebugPrint(TEXT("ldBirth="));
        }
    }
    __except (BreakOnDebuggableException())
    {
        printf("Exception %08X caught\n", GetExceptionCode());
    }

}

void
CTestSvrSvc::DoTouch(TCHAR * ptszKey)
{
    __try
    {
        BOOL f = idt().Touch(CDomainRelativeObjId(ptszKey));
        printf("Touch returns %s\n", f ? "TRUE" : "FALSE");
    }
    __except (BreakOnDebuggableException())
    {
        printf("Exception %08X caught\n", GetExceptionCode());
    }

}

class CName
{
public:
    CName(int i)
    {
        _tsz[0] = i/(26*26) + TEXT('a');
        _tsz[1] = (i%(26*26))/26 + TEXT('a');
        _tsz[2] = i%26 + TEXT('a');
        _tsz[3] = 0;
    }

    operator TCHAR * ()
    {
        return(_tsz);
    }
private:
    TCHAR _tsz[10];
};

void
CTestSvrSvc::DoFill(TCHAR * ptszNum)
{
    int cEntries;

    _stscanf(ptszNum, TEXT("%d"), &cEntries);

    __try
    {
        for (int i=0; i<cEntries; i++)
        {
            CDomainRelativeObjId ldNew, ldBirth;
            idt().Add(CDomainRelativeObjId(CName(i)),  ldNew, ldBirth);
        }
    }
    __except (BreakOnDebuggableException())
    {
        printf("Exception %08X caught\n", GetExceptionCode());
    }
}

void
CTestSvrSvc::DoPurge()
{
    int cEntries;

    __try
    {
       idt().PurgeAll();
       voltab().PurgeAll();
    }
    __except (BreakOnDebuggableException())
    {
        printf("Exception %08X caught\n", GetExceptionCode());
    }
}

void
CTestSvrSvc::DoCachePurge()
{
    const int size = 64000000;
    LPDWORD p, pOrig;

    p = pOrig = (LPDWORD)GlobalAlloc(GMEM_FIXED, size);
    if (p)
    {
        for (int i=0; i<size/sizeof(*p); i++)
        {
            *p++ = 0;
        }
        GlobalFree((HGLOBAL)pOrig);
    }
    else
        printf("couldn't alloc 64M");
}

#define Check(exp) TrkAssert(exp)

void
CTestSvrSvc::DoVolumeTable()
{
    // test out volume table functionality
    HRESULT hr;
    CMachineId mcid1("mcid1");
    CMachineId mcid2("mcid2");
    CMachineId mcid3("mcid3");
    CMachineId mcid4("mcid4");
    CVolumeSecret secret1;
    CVolumeSecret secret2;
    CVolumeSecret secret3;
    CVolumeSecret secret4;
    CVolumeId volume1;
    CVolumeId volume2;
    CVolumeId volume3;
    CVolumeId volume4;
    SequenceNumber seq;
    FILETIME ft;

    DoPurge();

    UuidCreate((GUID*)&volume1);
    UuidCreate((GUID*)&volume2);
    UuidCreate((GUID*)&volume3);
    UuidCreate((GUID*)&volume4);
    UuidCreate((GUID*)&secret1);
    UuidCreate((GUID*)&secret2);
    UuidCreate((GUID*)&secret3);
    UuidCreate((GUID*)&secret4);

    // Check Queries

    CFILETIME cftStart;

    // check non-existent volume
    hr = voltab().QueryVolume(mcid1, volume1, &seq, &ft);
    Check(hr == TRK_S_VOLUME_NOT_FOUND);

    // exception when setting seq number on non-existent volume
    hr = voltab().SetSequenceNumber(volume1, seq);
    Check(hr != S_OK);

    hr = voltab().QueryVolume(mcid1, volume1, &seq, &ft);
    Check(hr == TRK_S_VOLUME_NOT_FOUND);

    // exception when setting seq number on non-existent volume
    hr = voltab().SetSequenceNumber(volume1, seq);
    Check(hr != S_OK);

    // create a volume

    TryCreateVolume(mcid1, secret1, & volume1);

    // check we can query it if it is us
    hr = voltab().QueryVolume(mcid1, volume1, &seq, &ft);
    Check(hr == S_OK);

    // check we can't query it if it isn't us
    hr = voltab().QueryVolume(mcid2, volume1, &seq, &ft);
    Check(hr == TRK_S_VOLUME_NOT_OWNED);

    // Check Claims

    // claim a non-existent volume
    hr = voltab().ClaimVolume(mcid1, volume2, secret1, secret1, &seq, &ft);
    Check(hr == TRK_S_VOLUME_NOT_FOUND);

    // claim an existent volume using the wrong secret
    hr = voltab().ClaimVolume(mcid2, volume1, secret2, secret2, &seq, &ft);
    Check(hr == TRK_E_VOLUME_ACCESS_DENIED);

    // claim an existent volume using the right secret
    hr = voltab().ClaimVolume(mcid2, volume1, secret1, secret1, &seq, &ft);
    Check(hr == S_OK);

    // check the query fails from the original machine
    hr = voltab().QueryVolume(mcid1, volume1, &seq, &ft);
    Check(hr == TRK_S_VOLUME_NOT_OWNED);

    // check the query succeeds from the new machine
    hr = voltab().QueryVolume(mcid2, volume1, &seq, &ft);
    Check(hr == S_OK);

    // Check sequence numbers
    SequenceNumber seq2 = seq;
    seq ++;
    hr = voltab().SetSequenceNumber(volume1, seq);
    Check(hr == S_OK);

    SequenceNumber seq3;
    hr = voltab().QueryVolume(mcid2, volume1, &seq3, &ft);
    Check(hr == S_OK);

    Check(seq3 == seq);
    Check(seq2 + 1 == seq);

}

class CSegString
{
public:
            CSegString(int length);
            ~CSegString();

            
private:
    
};


class CSegment
{
public:
            CSegment()  {  _fInitialized = FALSE; }
            ~CSegment();

            const CDomainRelativeObjId  Current();
            const CDomainRelativeObjId  New();
            const CDomainRelativeObjId  Birth();

private:
    BOOL    _fInitialized;
};

class COrder
{
public:
            COrder(int iLength, int iCurrent) : _iLength(iLength) { }
            ~COrder();

            BOOL    GetSegment(CSegment * pSegment);

private:

            int     _iLength;

};

class COrderEnum
{
public:
            COrderEnum(int length);
            ~COrderEnum();

            BOOL GetOrder(COrder * pOrder);

private:
            int _iCurrent;
            int _iEnd;
            int _iLength;
};

COrderEnum::COrderEnum(int iLength)
{
    _iLength = iLength;
    _iCurrent = 1;
    _iEnd = 1;

    while (iLength)
    {
        _iEnd *= iLength;
        iLength --;
    }
}

BOOL
COrderEnum::GetOrder(COrder * pOrder)
{
    if (_iCurrent > _iEnd)
    {
        return(FALSE);
    }

    

    return(TRUE);
}

void
CTestSvrSvc::DoIdt()
{
    int cChanges=0;

    CDomainRelativeObjId droidCurrent, droidBirth, droidNew;

    memcpy( &droidCurrent, "12345678", 8 );
    droidBirth = droidCurrent;
    memcpy( &droidNew, "87654321", 8 );

    _svc.MoveNotify(droidCurrent, droidBirth, droidNew, &cChanges);

    CDomainRelativeObjId droidNewRead, droidBirthRead;

    idt().Query(droidBirth, &droidNewRead, &droidBirthRead);

    Check( droidNewRead == droidNew );




#if 0
    // Each letter represents a (volume,oid) pair
    //
    // Various string lengths:
    //
    // Length 1:
    //      a->b a                  (1 order A)
    //              
    //      
    // Length 2:
    //      a->b a, b->c a          (2 orders AB, BA)
    //
    //
    // Length 3:
    //      a->b a, b->c a, c->d a  (6 orders ABC, ACB, BAC, BCA, CAB, CBA)
    //
    //
    // Each combination could have a non-matching birth id which should prevent shortening and search
    // Each segment  can be created either through replication (directly to idt) or
    //  through MoveNotify.
    // Each segment can be shortened through MoveNotify or Search
    //

    // three lengths
    for (int l=1; l<=3; l++)
    {
        COrderEnum oe(l);
        COrder     o;

        while (oe.GetOrder(&o))
        {
            CSegString ss(l);   // make segment string of length l

            BOOL fFirst = TRUE;
            CSegment seg, segFirst, segLast;
            int index;

            while (-1 != (index = o.GetIndex()))
            {
                seg = ss[index];

                if (fFirst)
                {
                    segFirst = seg;
                    fFirst = FALSE;
                }

                TRKSVR_MOVE_NOTIFICATION Notification;
                Notification.ldCurrent = seg.Current();
                Notification.ldNew = seg.New();
                Notification.ldBirth = seg.Birth();

                _svc.MoveNotify(Notification);

                segLast = seg;
            }

            CDomainRelativeObjId ldNew, ldBirth;

            idt().Query(segFirst.Birth(), &ldNew, &ldBirth);

            Check(ldNew == segLast.Current());
        }
    }

#endif // #if 0

}

void
CTestSvrSvc::DoRunTests()
{
    DoVolumeTable();
    DoIdt();
}


void
CTestSvrSvc::DoSwitch(TCHAR ** &tszArgs, int & cArgs, BOOL & fError)
{

    if (cArgs == 0)
    {
        return;
    }
    switch (tszArgs[0][1])
    {
    case TEXT('a'):
    case TEXT('A'):
        if (cArgs >= 4)
        {
            DoAdd(tszArgs[1], tszArgs[2], tszArgs[3]);
            cArgs -= 4;
            tszArgs += 4;
            fError = FALSE;
        }
        break;
    case TEXT('d'):
    case TEXT('D'):
        if (cArgs >= 2)
        {
            DoDelete(tszArgs[1]);
            cArgs -= 2;
            tszArgs += 2;
            fError = FALSE;
        }
        break;
    case TEXT('m'):
    case TEXT('M'):
        if (cArgs >= 4)
        {
            DoModify(tszArgs[1], tszArgs[2], tszArgs[3]);
            cArgs -= 4;
            tszArgs += 4;
            fError = FALSE;
        }
        break;
    case TEXT('q'):
    case TEXT('Q'):
        if (cArgs >= 2)
        {
            DoQuery(tszArgs[1]);
            cArgs -= 2;
            tszArgs += 2;
            fError = FALSE;
        }
        break;
    case TEXT('t'):
    case TEXT('T'):
        if (cArgs >= 2)
        {
            DoTouch(tszArgs[1]);
            cArgs -= 2;
            tszArgs += 2;
            fError = FALSE;
        }
        break;

    case TEXT('f'):
    case TEXT('F'):
        if (cArgs >= 2)
        {
            DoFill(tszArgs[1]);
            cArgs -= 2;
            tszArgs += 2;
            fError = FALSE;
        }
        break;

    case TEXT('p'):
    case TEXT('P'):
        if (cArgs >= 1)
        {
            DoPurge();
            cArgs -= 1;
            tszArgs += 1;
            fError = FALSE;
        }
        break;
    case TEXT('c'):
    case TEXT('C'):
        DoCachePurge();
        cArgs -= 1;
        tszArgs += 1;
        fError = FALSE;
        break;

    case TEXT('r'):
    case TEXT('R'):
        DoRunTests();
        cArgs -= 1;
        tszArgs += 1;
        fError = FALSE;
        break;

    case TEXT('i'):
    case TEXT('I'):
        printf("Type a command line switch at the prompt (control-c to exit.)\n");
        do
        {

            TCHAR buf[256];
            TCHAR * tszArgs2[16];
            TCHAR ** tszArgsI = tszArgs2;
            int    cArgsI=0;
            BOOL fError2;

            printf("> ");

            _getts(buf);

            TCHAR * p = buf;
            
            while (*p)
            {
                tszArgs2[cArgsI++] = p++;
                while (*p && *p != TEXT(' ')) p++;
                if (*p == ' ')
                {
                    *p = 0;
                    p++;
                }
            }
    
            DoSwitch(tszArgsI, cArgsI, fError2);
        }
        while (TRUE);
        break;
    default:
        break;
    }
}

EXTERN_C int __cdecl _tmain(int cArgs, TCHAR **tszArgs )
{ 
    BOOL fError = FALSE;
    HRESULT hr;
    LARGE_INTEGER liFreq;
    CTestSvrSvc test;

    __try
    {
    
        TrkDebugCreate( TRK_DBG_FLAGS_WRITE_TO_DBG | TRK_DBG_FLAGS_WRITE_TO_STDOUT, "TLDAP" );
        g_Debug = 0xffffffff & ~TRKDBG_WORKMAN;
        test.Initialize();

        cArgs--;
        tszArgs++;
redo:    
        if (cArgs == 0)
        {
            fError = TRUE;
        }
    
    
        while (!fError && cArgs > 0)
        {
            fError = TRUE;
            if (tszArgs[0][0] == '-' || tszArgs[0][0] == '/')
            {
                test.DoSwitch(tszArgs, cArgs, fError);
            }
        }

        if (fError)
        {
            printf("Usage: \n");
            printf(" Operation   Params\n");
    