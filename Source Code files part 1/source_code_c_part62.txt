 );
        VariantClear( &AdsValue );
        // NTRAID#NTBUG9-542354-2002/02/14-dantra-Errors returned by IADs::Put and PutEx are being masked.
        if ( SUCCEEDED( hr ) ) hr = m_pIADsObject->SetInfo();

        if ( SUCCEEDED( hr )) {

            //
            // Update the aux class list in the cache.
            //

            hr = StringListToColumnList( m_pScopeControl,
                                         strlistAuxiliary,
                                         &pNewList );

            if ( SUCCEEDED( hr )) {

                m_pScopeControl->g_SchemaCache.FreeColumnList(
                    m_pSchemaObject->auxiliaryClass );
                m_pSchemaObject->auxiliaryClass = pNewList;

                //
                // Refresh the display!
                //

                m_pScopeControl->QueryConsole()->UpdateAllViews(
                    m_lpScopeDataObj, SCHMMGMT_CLASS, SCHMMGMT_UPDATEVIEW_REFRESH );
            }

            //
            // Continue with the directory operation even if
            // we couldn't update the display.
            //

            hr = S_OK;

        } else {

            //
            // Flush the IADS property cache so future
            // operations won't fail because of this one.
            //

            IADsPropertyList *pPropertyList;

            flush_result = m_pIADsObject->QueryInterface(
                             IID_IADsPropertyList,
                             reinterpret_cast<void**>(&pPropertyList) );

            if ( SUCCEEDED( flush_result ) ) {
                pPropertyList->PurgePropertyList();
                pPropertyList->Release();
            }
        }

    }

    if ( SUCCEEDED(hr) && m_listboxSuperior.IsModified() )
    {
        //
        // Update the superior classes
        //

        VARIANT AdsValue;
        VariantInit( &AdsValue );

        hr = StringListToVariant( AdsValue, strlistSuperior );
        // NTRAID#NTBUG9-543624-2002/02/15-dantra-Result of StringListToVariant being ignored resulting in call to IADs::PutEx with incorrect data

        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        if( SUCCEEDED( hr ) ) hr = m_pIADsObject->PutEx( ADS_PROPERTY_UPDATE, CComBSTR(g_Superiors), AdsValue );
        VariantClear( &AdsValue );

        // NTRAID#NTBUG9-542354-2002/02/14-dantra-Errors returned by IADs::Put and PutEx are being masked.
        if ( SUCCEEDED( hr ) ) hr = m_pIADsObject->SetInfo();
    }

    if ( hr == ADS_EXTENDED_ERROR )
    {
        DoExtErrMsgBox();
    }
    else if ( FAILED(hr) )
    {
        if( ERROR_DS_UNWILLING_TO_PERFORM == HRESULT_CODE(hr) )
        {
            fApplyFailed = TRUE;
            DoErrMsgBox( ::GetActiveWindow(), TRUE, IDS_ERR_CHANGE_REJECT );
        }
        else
        {
            fApplyAbort = TRUE; 
            DoErrMsgBox( ::GetActiveWindow(), TRUE, GetErrorMessage(hr,TRUE) );
        }
    }
    else
    {

        // page is no longer "dirty"
        m_listboxAuxiliary.SetModified( FALSE );
        m_listboxSuperior.SetModified( FALSE );

		// Update comboBox status
		OnAuxiliarySelChange();
		OnSuperiorSelChange();
        
		SetModified( FALSE );
    }

    return !fApplyAbort && !fApplyFailed ;      // return TRUE if nothing happened
}



void ClassRelationshipPage::OnAuxiliarySelChange()
{
    m_listboxAuxiliary.OnSelChange();
}



void ClassRelationshipPage::OnSuperiorSelChange()
{
    m_listboxSuperior.OnSelChange();
}


void ClassRelationshipPage::OnButtonAuxiliaryClassRemove()
{
    if( m_listboxAuxiliary.RemoveListBoxItem() )
        SetModified( TRUE );
}


void ClassRelationshipPage::OnButtonSuperiorClassRemove()
{
    if( m_listboxSuperior.RemoveListBoxItem() )
        SetModified( TRUE );
}


void
ClassRelationshipPage::OnButtonAuxiliaryClassAdd()
{
    if( m_listboxAuxiliary.AddNewObjectToList() )
        SetModified( TRUE );
}


void
ClassRelationshipPage::OnButtonSuperiorClassAdd()
{
    if( m_listboxSuperior.AddNewObjectToList() )
        SetModified( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\schmmgmt.cpp ===
//
// SchmMgmt.cpp : Implementation of DLL Exports.
// Cory West


#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "schmmgmt.h"
#include "regkey.h" // AMC::CRegKey
#include "strings.h" // SNAPINS_KEY
#include "macros.h" // MFC_TRY/MFC_CATCH
#include "stdutils.h" // g_aNodetypeGuids

#include "cookie.h"
#include "compdata.h" // ComponentData
#include "about.h"        // CSchemaMgmtAbout

USE_HANDLE_MACROS("SchmMgmt(SchmMgmt.cpp)")



// Snapin CLSID - {632cccf4-cbed-11d0-9c16-00c04fd8d86e}
const CLSID CLSID_SchmMgmt =
 {0x632cccf4, 0xcbed, 0x11d0, {0x9c, 0x16, 0x00, 0xc0, 0x4f, 0xd8, 0xd8, 0x6e}};

// Snapin about CLSID - {333fe3fb-0a9d-11d1-bb10-00c04fc9a3a3}
const CLSID CLSID_SchemaManagementAbout =
 {0x333fe3fb, 0x0a9d, 0x11d1, {0xbb, 0x10, 0x00, 0xc0, 0x4f, 0xc9, 0xa3, 0xa3}};



CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_SchmMgmt, ComponentData)
                OBJECT_ENTRY(CLSID_SchemaManagementAbout, CSchemaMgmtAbout)
END_OBJECT_MAP()

class CSchmMgmtApp : public CWinApp
{
public:
        virtual BOOL InitInstance();
        virtual int ExitInstance();
};

CSchmMgmtApp theApp;

BOOL CSchmMgmtApp::InitInstance()
{
        _Module.Init(ObjectMap, m_hInstance);

        // Add theming support

        SHFusionInitializeFromModuleID(m_hInstance, 2);

        return CWinApp::InitInstance();
}

int CSchmMgmtApp::ExitInstance()
{
         // Theming support

         SHFusionUninitialize();

        _Module.Term();
        return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
        return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer( void ) {

    MFC_TRY;

    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hRes = S_OK;
    CString Name, Microsoft, About, Provider, Version, VerString;

    Name.LoadString(IDS_REGSERV_NAME);
    Microsoft.LoadString(IDS_REGSERV_MICROSOFT);
    About.LoadString(IDS_REGSERV_ABOUT);
    Provider.LoadString(IDS_REGSERV_PROVIDER);
    Version.LoadString(IDS_REGSERV_VERSION);
    VerString = IDS_SNAPINABOUT_VERSION;

    //
    // registers object, typelib and all interfaces in typelib
    //

    hRes = _Module.RegisterServer(FALSE);

    try {

        AMC::CRegKey regkeySnapins;
        BOOL fFound = regkeySnapins.OpenKeyEx( HKEY_LOCAL_MACHINE, SNAPINS_KEY );

        if ( !fFound ) {
        
            ASSERT(FALSE);
            return SELFREG_E_CLASS;
        }

        {
            AMC::CRegKey regkeySchmMgmtSnapin;
            CString strGUID;

            HRESULT hr = GuidToCString(OUT &strGUID, CLSID_SchmMgmt );

            if ( FAILED(hr) ) {
        
                ASSERT(FALSE);
                return SELFREG_E_CLASS;
             }

             regkeySchmMgmtSnapin.CreateKeyEx( regkeySnapins, strGUID );
             regkeySchmMgmtSnapin.SetString( g_szNodeType, g_aNodetypeGuids[SCHMMGMT_SCHMMGMT].bstr );
             regkeySchmMgmtSnapin.SetString( g_szNameString, Name );

             hr = GuidToCString(OUT &strGUID, CLSID_SchemaManagementAbout );
        
             if ( FAILED(hr) ) {
                 ASSERT(FALSE);
                 return SELFREG_E_CLASS;
             }

             regkeySchmMgmtSnapin.SetString( About, strGUID );
             regkeySchmMgmtSnapin.SetString( Provider, Microsoft );
             regkeySchmMgmtSnapin.SetString( Version, VerString );
             AMC::CRegKey regkeySchmMgmtStandalone;
             regkeySchmMgmtStandalone.CreateKeyEx( regkeySchmMgmtSnapin, g_szStandAlone );
             AMC::CRegKey regkeyMyNodeTypes;
             regkeyMyNodeTypes.CreateKeyEx( regkeySchmMgmtSnapin, g_szNodeTypes );
             AMC::CRegKey regkeyMyNodeType;

                 for (int i = SCHMMGMT_SCHMMGMT; i < SCHMMGMT_NUMTYPES; i++)
                 {
                         regkeyMyNodeType.CreateKeyEx( regkeyMyNodeTypes, g_aNodetypeGuids[i].bstr );
                         regkeyMyNodeType.CloseKey();
                 }
                }

                AMC::CRegKey regkeyNodeTypes;
                fFound = regkeyNodeTypes.OpenKeyEx( HKEY_LOCAL_MACHINE, NODE_TYPES_KEY );
                if ( !fFound )
                {
                        ASSERT(FALSE);
                        return SELFREG_E_CLASS;
                }
                AMC::CRegKey regkeyNodeType;
                for (int i = SCHMMGMT_SCHMMGMT; i < SCHMMGMT_NUMTYPES; i++)
                {
                        regkeyNodeType.CreateKeyEx( regkeyNodeTypes, g_aNodetypeGuids[i].bstr );
                        regkeyNodeType.CloseKey();
                }
        }
    catch (COleException* e)
    {
                ASSERT(FALSE);
        e->Delete();
                return SELFREG_E_CLASS;
    }

        return hRes;

        MFC_CATCH;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
        _Module.UnregisterServer();
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\relation.h ===
//
// relation.h : Declaration of ClassRelationshipPage
//
// Jon Newman <jonn@microsoft.com>
// Copyright (c) Microsoft Corporation 1997
//

#ifndef __RELATION_H_INCLUDED__
#define __RELATION_H_INCLUDED__

#include "cookie.h"     // Cookie
#include "resource.h"   // IDD_CLASS_RELATIONSHIP
#include "CPropertyPageAutoDelete.hpp"

class ClassRelationshipPage : public CPropertyPageAutoDelete
{
   public:

    ClassRelationshipPage( ComponentData *pScope,
                                LPDATAOBJECT lpDataObject );

    ~ClassRelationshipPage();

    void Load( Cookie& CookieRef );

    //
    // The schema object that this property page is for.
    //

    Cookie *m_pCookie;
    CString m_szAdsPath;

    ComponentData* m_pScopeControl;
    LPDATAOBJECT m_lpScopeDataObj;

        //
        // The ADSI object that this property page is for
        //

        IADs *m_pIADsObject;
        SchemaObject* m_pSchemaObject;


    // Dialog Data
    enum { IDD = IDD_CLASS_RELATIONSHIP};
    CStatic               m_staticParent;
    CSchemaObjectsListBox m_listboxAuxiliary;
    CSchemaObjectsListBox m_listboxSuperior;
    CString               ObjectName;
    CString               ParentClass;
    BOOL                  fSystemClass;

    
// Overrides
        // ClassWizard generate virtual function overrides

        public:
        virtual BOOL OnApply();

        protected:
        virtual BOOL OnInitDialog();
        virtual BOOL OnSetActive();
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
        // Generated message map functions
        afx_msg void OnButtonAuxiliaryClassAdd();
        afx_msg void OnButtonAuxiliaryClassRemove();
        afx_msg void OnButtonSuperiorClassRemove();
        afx_msg void OnButtonSuperiorClassAdd();
        afx_msg void OnAuxiliarySelChange();
        afx_msg void OnSuperiorSelChange();


        static const DWORD help_map[];

        BOOL         OnHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, FALSE ); };
        BOOL         OnContextHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, TRUE ); };


        DECLARE_MESSAGE_MAP()

public:
// User defined variables

        CStringList strlistAuxiliary;
        CStringList strlistSystemAuxiliary;
        CStringList strlistSuperior;
        CStringList strlistSystemSuperior;
};

#endif // __RELATION_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\schmutil.cpp ===
/****

SchmUtil.cpp

Various common utility routines for the Schema Editor Snap-In.

****/

#include "stdafx.h"

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(schmutil.cpp)")

#include "resource.h"
#include "cache.h"
#include "schmutil.h"
#include "compdata.h"

#include <wincrypt.h>  // CryptEncodeObject() and CryptDecodeObject()

//
// Removed from public headers by DS guys
// See bug 454342	XOM will not survive the transition to Win64
//
//#include <xom.h>

//
// Global strings for classes and attributes in the DS.
// These are NOT subject to localization.
//

LPWSTR g_DisplayName =          L"ldapDisplayName";
LPWSTR g_ClassFilter =          L"classSchema";
LPWSTR g_AttributeFilter =      L"attributeSchema";
LPWSTR g_Description =          L"adminDescription";
LPWSTR g_MayContain =           L"mayContain";
LPWSTR g_MustContain =          L"mustContain";
LPWSTR g_SystemMayContain =     L"systemMayContain";
LPWSTR g_SystemMustContain =    L"systemMustContain";
LPWSTR g_AuxiliaryClass =       L"auxiliaryClass";
LPWSTR g_SystemAuxiliaryClass = L"systemAuxiliaryClass";
LPWSTR g_SubclassOf =           L"subclassOf";
LPWSTR g_ObjectClassCategory =  L"objectClassCategory";
LPWSTR g_ObjectClass =		    L"objectClass";
LPWSTR g_omObjectClass =        L"oMObjectClass";
LPWSTR g_CN =                   L"CN";
LPWSTR g_omSyntax =             L"oMSyntax";
LPWSTR g_AttributeSyntax =      L"attributeSyntax";
LPWSTR g_SystemOnly =           L"systemOnly";
LPWSTR g_Superiors =            L"possSuperiors";
LPWSTR g_SystemSuperiors =      L"systemPossSuperiors";
LPWSTR g_GlobalClassID =        L"governsID";
LPWSTR g_GlobalAttributeID =    L"attributeID";
LPWSTR g_RangeUpper =           L"rangeUpper";
LPWSTR g_RangeLower =           L"rangeLower";
LPWSTR g_IsSingleValued =       L"isSingleValued";
LPWSTR g_IndexFlag =            L"searchFlags";
LPWSTR g_ShowInAdvViewOnly =    L"showInAdvancedViewOnly";
LPWSTR g_UpdateSchema =         LDAP_OPATT_SCHEMA_UPDATE_NOW_W;
LPWSTR g_BecomeFsmo =           LDAP_OPATT_BECOME_SCHEMA_MASTER_W;
LPWSTR g_isDefunct =            L"isDefunct";
LPWSTR g_GCReplicated =         L"isMemberOfPartialAttributeSet";
LPWSTR g_DefaultAcl =           L"defaultSecurityDescriptor";
LPWSTR g_DefaultCategory =      L"defaultObjectCategory";
LPWSTR g_systemFlags =          L"systemFlags";
LPWSTR g_fsmoRoleOwner =        L"fsmoRoleOwner";

LPWSTR g_allowedChildClassesEffective = L"allowedChildClassesEffective";
LPWSTR g_allowedAttributesEffective =   L"allowedAttributesEffective";


LPWSTR g_ClassSearchRequest =   L"objectClass=classSchema";
LPWSTR g_AttribSearchRequest =  L"objectClass=attributeSchema";

//
// Syntax values.  Not subject to localization.
//

class CSyntaxDescriptor g_Syntax[] =
{
 // NTRAID#NTBUG9-540278-2002/05/15-lucios
 // Added SYNTAX_CASE_STRING_TYPE

 // This list should be kept in alphabetical order since the combo box is not sorted
 // so that the index from the combo box can map to an entry in this table
 //                                                                 nResourceID,            fIsSigned,	fIsANRCapable,  pszAttributeSyntax,                                  nOmSyntax, dwOmObjectClass,    pOmObjectClass
 /*SYNTAX_DISTNAME_STRING_TYPE (Access-Point) */ CSyntaxDescriptor( IDS_SYNTAX_ACCESS_POINT,FALSE,      FALSE,          _T("2.5.5.14"), /*OM_S_OBJECT                    */  127,       9,                  (LPBYTE)"\x2B\x0C\x02\x87\x73\x1C\x00\x85\x3E" ),
 /*SYNTAX_ADDRESS_TYPE                        */ CSyntaxDescriptor( IDS_SYNTAX_ADDRESS,     FALSE,      FALSE,          _T("2.5.5.13"), /*OM_S_OBJECT                    */  127,       9,                  (LPBYTE)"\x2B\x0C\x02\x87\x73\x1C\x00\x85\x5C" ),
 /*SYNTAX_BOOLEAN_TYPE                        */ CSyntaxDescriptor( IDS_SYNTAX_BOOLEAN,     FALSE,      FALSE,          _T("2.5.5.8") , /*OM_S_BOOLEAN                   */  1  ,       0,                  NULL ),
 /*SYNTAX_NOCASE_STRING_TYPE                  */ CSyntaxDescriptor( IDS_SYNTAX_NOCASE_STR,  FALSE,      TRUE,           _T("2.5.5.4") , /*OM_S_TELETEX_STRING            */  20 ,       0,                  NULL ),
 /*SYNTAX_CASE_STRING_TYPE                    */ CSyntaxDescriptor( IDS_SYNTAX_CASE_STR,    FALSE,      TRUE ,          _T("2.5.5.3"),  /*OM_S_GENERAL_STRING            */  27 ,       0,                  NULL ),
 /*SYNTAX_DISTNAME_TYPE                       */ CSyntaxDescriptor( IDS_SYNTAX_DN,          FALSE,      FALSE,          _T("2.5.5.1") , /*OM_S_OBJECT                    */  127,       9,                  (LPBYTE)"\x2B\x0C\x02\x87\x73\x1C\x00\x85\x4A" ),
 /*SYNTAX_DISTNAME_STRING_TYPE (DN-String)    */ CSyntaxDescriptor( IDS_SYNTAX_DNSTRING,    FALSE,      FALSE,          _T("2.5.5.14"), /*OM_S_OBJECT                    */  127,       10,                 (LPBYTE)"\x2A\x86\x48\x86\xF7\x14\x01\x01\x01\x0C" ),
 /*SYNTAX_DISTNAME_BINARY_TYPE (DN-Binary)    */ CSyntaxDescriptor( IDS_SYNTAX_DN_BINARY,   FALSE,      FALSE,          _T("2.5.5.7") , /*OM_S_OBJECT                    */  127,       10,                 (LPBYTE)"\x2A\x86\x48\x86\xF7\x14\x01\x01\x01\x0B" ),
 /*SYNTAX_INTEGER_TYPE                        */ CSyntaxDescriptor( IDS_SYNTAX_ENUMERATION,  TRUE,      FALSE,          _T("2.5.5.9") , /*OM_S_ENUMERATION               */  10 ,       0,                  NULL ),
 /*SYNTAX_TIME_TYPE                           */ CSyntaxDescriptor( IDS_SYNTAX_GEN_TIME,    FALSE,      FALSE,          _T("2.5.5.11"), /*OM_S_GENERALISED_TIME_STRING   */  24 ,       0,                  NULL ),
 /*SYNTAX_PRINT_CASE_STRING_TYPE              */ CSyntaxDescriptor( IDS_SYNTAX_I5_STR,      FALSE,      TRUE,           _T("2.5.5.5") , /*OM_S_IA5_STRING                */  22 ,       0,                  NULL ),
 /*SYNTAX_INTEGER_TYPE                        */ CSyntaxDescriptor( IDS_SYNTAX_INTEGER,      TRUE,      FALSE,          _T("2.5.5.9") , /*OM_S_INTEGER                   */  2  ,       0,                  NULL ),
 /*SYNTAX_I8_TYPE                             */ CSyntaxDescriptor( IDS_SYNTAX_LINT,        FALSE,      FALSE,          _T("2.5.5.16"), /*OM_S_I8                        */  65 ,       0,                  NULL ),
 /*SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE         */ CSyntaxDescriptor( IDS_SYNTAX_SEC_DESC,    FALSE,      FALSE,          _T("2.5.5.15"), /*OM_S_OBJECT_SECURITY_DESCRIPTOR*/  66 ,       0,                  NULL ),
 /*SYNTAX_NUMERIC_STRING_TYPE                 */ CSyntaxDescriptor( IDS_SYNTAX_NUMSTR,      FALSE,      FALSE,          _T("2.5.5.6") , /*OM_S_NUMERIC_STRING            */  18 ,       0,                  NULL ),
 /*SYNTAX_OBJECT_ID_TYPE                      */ CSyntaxDescriptor( IDS_SYNTAX_OID,         FALSE,      FALSE,          _T("2.5.5.2") , /*OM_S_OBJECT_IDENTIFIER_STRING  */  6  ,       0,                  NULL ),
 /*SYNTAX_OCTET_STRING_TYPE                   */ CSyntaxDescriptor( IDS_SYNTAX_OCTET,       FALSE,      FALSE,          _T("2.5.5.10"), /*OM_S_OCTET_STRING              */  4  ,       0,                  NULL ),
 /*SYNTAX_DISTNAME_BINARY_TYPE (OR-Name)      */ CSyntaxDescriptor( IDS_SYNTAX_OR_NAME,     FALSE,      FALSE,          _T("2.5.5.7") , /*OM_S_OBJECT                    */  127,       7,                  (LPBYTE)"\x56\x06\x01\x02\x05\x0B\x1D" ),
 /*SYNTAX_PRINT_CASE_STRING_TYPE              */ CSyntaxDescriptor( IDS_SYNTAX_PRCS_STR,    FALSE,      TRUE,           _T("2.5.5.5") , /*OM_S_PRINTABLE_STRING          */  19 ,       0,                  NULL ),
 /*SYNTAX_OCTET_STRING_TYPE                   */ CSyntaxDescriptor( IDS_SYNTAX_REPLICA_LINK,FALSE,      FALSE,          _T("2.5.5.10"), /*OM_S_OBJECT                    */  127,       10,                 (LPBYTE)"\x2A\x86\x48\x86\xF7\x14\x01\x01\x01\x06" ),
 /*SYNTAX_SID_TYPE                            */ CSyntaxDescriptor( IDS_SYNTAX_SID,         FALSE,      FALSE,          _T("2.5.5.17"), /*OM_S_OCTET_STRING              */  4  ,       0,                  NULL ),
 /*SYNTAX_UNICODE_TYPE                        */ CSyntaxDescriptor( IDS_SYNTAX_UNICODE,     FALSE,      TRUE,           _T("2.5.5.12"), /*OM_S_UNICODE_STRING            */  64 ,       0,                  NULL ),
 /*SYNTAX_TIME_TYPE                           */ CSyntaxDescriptor( IDS_SYNTAX_UTC,         FALSE,      FALSE,          _T("2.5.5.11"), /*OM_S_UTC_TIME_STRING           */  23 ,       0,                  NULL ),
 /*   *** unknown -- must be last ***         */ CSyntaxDescriptor( IDS_SYNTAX_UNKNOWN,     FALSE,      TRUE,  NULL,                                                0  , 0, NULL ),
};

const UINT SCHEMA_SYNTAX_UNKNOWN = sizeof( g_Syntax ) / sizeof( g_Syntax[0] ) - 1;


// Number formating printf strings
const LPWSTR g_UINT32_FORMAT	= L"%u";

#ifdef ENABLE_NEGATIVE_INT
    const LPWSTR g_INT32_FORMAT		= L"%d";
#else
	// if there is no negative numbers support, format as unsigned
    const LPWSTR g_INT32_FORMAT		= g_UINT32_FORMAT;
#endif





//
// *******************************************************************
// These are loaded from the resources as they need to be localizable.
// *******************************************************************
//

//
// Global strings for our static nodes.
//

CString g_strSchmMgmt;
CString g_strClasses;
CString g_strAttributes;

//
// Strings for various object types.
//

CString g_88Class;
CString g_StructuralClass;
CString g_AuxClass;
CString g_AbstractClass;
CString g_MandatoryAttribute;
CString g_OptionalAttribute;
CString g_Yes;
CString g_No;
CString g_Unknown;
CString g_Defunct;
CString g_Active;

//
// Message strings.
//

CString g_NoDescription;
CString g_NoName;
CString g_MsgBoxErr;
CString g_MsgBoxWarn;

//
// Menu strings.
//

CString g_MenuStrings[MENU_LAST_COMMAND];
CString g_StatusStrings[MENU_LAST_COMMAND];

BOOL g_fScopeStringsLoaded = FALSE;

//
// Utility functions.
//

void
LoadGlobalCookieStrings(
)
/***

Load the global strings out of our resource table.

***/
{
   if ( !g_fScopeStringsLoaded )
   {
      //
      // Static node strings.
      //

      VERIFY( g_strSchmMgmt.LoadString(IDS_SCOPE_SCHMMGMT) );
      VERIFY( g_strClasses.LoadString(IDS_SCOPE_CLASSES) );
      VERIFY( g_strAttributes.LoadString(IDS_SCOPE_ATTRIBUTES) );

      //
      // Object name strings.
      //

      VERIFY( g_88Class.LoadString(IDS_CLASS_88) );
      VERIFY( g_StructuralClass.LoadString(IDS_CLASS_STRUCTURAL) );
      VERIFY( g_AuxClass.LoadString(IDS_CLASS_AUXILIARY) );
      VERIFY( g_AbstractClass.LoadString(IDS_CLASS_ABSTRACT) );
      VERIFY( g_MandatoryAttribute.LoadString(IDS_ATTRIBUTE_MANDATORY) );
      VERIFY( g_OptionalAttribute.LoadString(IDS_ATTRIBUTE_OPTIONAL) );
      VERIFY( g_Yes.LoadString(IDS_YES) );
      VERIFY( g_No.LoadString(IDS_NO) );
      VERIFY( g_Unknown.LoadString(IDS_UNKNOWN) );
      VERIFY( g_Defunct.LoadString(IDS_DEFUNCT) );
      VERIFY( g_Active.LoadString(IDS_ACTIVE) );

      //
      // Message strings.
      //

      VERIFY( g_NoDescription.LoadString(IDS_ERR_NO_DESCRIPTION) );
      VERIFY( g_NoName.LoadString(IDS_ERR_NO_NAME) );
      VERIFY( g_MsgBoxErr.LoadString(IDS_ERR_ERROR) );
      VERIFY( g_MsgBoxWarn.LoadString(IDS_ERR_WARNING) );

      //
      // Syntax strings.
      //

      for( UINT i = 0;  i <= SCHEMA_SYNTAX_UNKNOWN;  i++ )
      {
         ASSERT( g_Syntax[i].m_nResourceID );
         VERIFY( g_Syntax[i].m_strSyntaxName.LoadString( g_Syntax[i].m_nResourceID ) );
      }
      

      //
      // Menu Strings
      //

      VERIFY( g_MenuStrings[CLASSES_CREATE_CLASS].LoadString(IDS_MENU_CLASS) );
      VERIFY
      (
         g_MenuStrings[VIEW_DEFUNCT_OBJECTS].LoadString
         (
            IDS_MENU_VIEW_DEFUNCT_OBJECTS
         )
      );
      VERIFY( g_MenuStrings[NEW_CLASS].LoadString(IDS_MENU_NEW_CLASS) );
      VERIFY( g_MenuStrings[ATTRIBUTES_CREATE_ATTRIBUTE].LoadString(
        IDS_MENU_ATTRIBUTE) );
      VERIFY(g_MenuStrings[NEW_ATTRIBUTE].LoadString(IDS_MENU_NEW_ATTRIBUTE));

      VERIFY( g_MenuStrings[SCHEMA_RETARGET].LoadString(IDS_MENU_RETARGET) );
      VERIFY( g_MenuStrings[SCHEMA_EDIT_FSMO].LoadString(IDS_MENU_EDIT_FSMO) );
      VERIFY( g_MenuStrings[SCHEMA_REFRESH].LoadString(IDS_MENU_REFRESH) );
      VERIFY( g_MenuStrings[SCHEMA_SECURITY].LoadString(IDS_MENU_SECURITY) );


      VERIFY( g_StatusStrings[CLASSES_CREATE_CLASS].LoadString(
                 IDS_STATUS_CREATE_CLASS) );
      VERIFY
      (
         g_StatusStrings[VIEW_DEFUNCT_OBJECTS].LoadString
         (
            IDS_STATUS_VIEW_DEFUNCT_OBJECTS
         )
      );
      VERIFY( g_StatusStrings[ATTRIBUTES_CREATE_ATTRIBUTE].LoadString(
                 IDS_STATUS_CREATE_ATTRIBUTE) );
      VERIFY( g_StatusStrings[NEW_CLASS].LoadString(
                 IDS_STATUS_CREATE_CLASS) );
      VERIFY( g_StatusStrings[NEW_ATTRIBUTE].LoadString(
                 IDS_STATUS_CREATE_ATTRIBUTE) );
      VERIFY( g_StatusStrings[SCHEMA_RETARGET].LoadString(IDS_STATUS_RETARGET) );
      VERIFY( g_StatusStrings[SCHEMA_EDIT_FSMO].LoadString(IDS_STATUS_EDIT_FSMO) );
      VERIFY( g_StatusStrings[SCHEMA_REFRESH].LoadString(IDS_STATUS_REFRESH) );
      VERIFY( g_StatusStrings[SCHEMA_SECURITY].LoadString(IDS_STATUS_SECURITY) );

      g_fScopeStringsLoaded = TRUE;
   }
}

INT
DoErrMsgBox(
    HWND hwndParent,    // IN: Parent of the dialog box
    BOOL fError,        // IN: Is this a warning or an error?
    UINT wIdString,     // IN: String resource Id of the error.
    HRESULT hr          // IN: the error code (optional)
)
/***

    Display a message box with the error.

***/
{
    CString Error;

    VERIFY( Error.LoadString( wIdString ) );

	return DoErrMsgBox( hwndParent, fError, Error, hr );
}


INT
DoErrMsgBox(
    HWND hwndParent,    // IN: Parent of the dialog box
    BOOL fError,        // IN: Is this a warning or an error?
    PCWSTR pszError,    // IN: String to display.
    HRESULT hr          // IN: the error code (optional)
)
/***

    Display a message box with the error.

***/
{
   CThemeContextActivator activator;

   PTSTR ptzSysMsg = NULL;
   int cch = 0;
   
   if (FAILED(hr))
   {
      cch = cchLoadHrMsg(hr, &ptzSysMsg, TRUE);
   }

   if (!cch)
   {
	   return MessageBox(
                       hwndParent,
                       pszError,
                       (fError ? g_MsgBoxErr : g_MsgBoxWarn),
                       (fError ? MB_ICONSTOP : MB_ICONEXCLAMATION) | MB_OK
                        );
   }

   CString szError = pszError;
   szError += L"\n";
   szError += ptzSysMsg;

   return MessageBox(
                    hwndParent,
                    szError,
                    (fError ? g_MsgBoxErr : g_MsgBoxWarn),
                    (fError ? MB_ICONSTOP : MB_ICONEXCLAMATION) | MB_OK
                     );
}


HRESULT
ComponentData::ForceDsSchemaCacheUpdate(
    VOID
)
/***

    Force the schema container to reload its interal cache.
    If this succeeds, it returns TRUE.  Otherwise, it returns
    FALSE.

***/
{

    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    CWaitCursor wait;
    CString RootDsePath;
    IADs *pSchemaRootDse = NULL;

    SAFEARRAYBOUND RootDseBoundary[1];
    SAFEARRAY* pSafeArray = NULL;
    VARIANT AdsArray, AdsValue;
    long ArrayLen = 1;
    long ArrayPos = 0;
    HRESULT hr = S_OK;


    do
    {
        //
        // Open the root DSE on the current focus server.
        //

        GetBasePathsInfo()->GetRootDSEPath(RootDsePath);

        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        // NOTE: const_cast not necessary here since ADsGetObject takes a WSTR for the first parameter.
        hr = SchemaOpenObject(
                 ( const_cast<BSTR>((LPCTSTR) RootDsePath ) ),
                 IID_IADs,
                 (void **)&pSchemaRootDse );

        BREAK_ON_FAILED_HRESULT(hr);

        //
        // Create the safe array for the PutEx call.
        //

        RootDseBoundary[0].lLbound = 0;
        RootDseBoundary[0].cElements = ArrayLen;

        pSafeArray = SafeArrayCreate( VT_VARIANT, ArrayLen, RootDseBoundary );
        BREAK_ON_FAILED_HRESULT(hr);

        VariantInit( &AdsArray );
        V_VT( &AdsArray ) = VT_ARRAY | VT_VARIANT;
        V_ARRAY( &AdsArray ) = pSafeArray;

        VariantInit( &AdsValue );

        V_VT(&AdsValue) = VT_I4;
        V_I4(&AdsValue) = 1;

        hr = SafeArrayPutElement( pSafeArray, &ArrayPos, &AdsValue );
        BREAK_ON_FAILED_HRESULT(hr);

        //
        // Write the update parameter.  This is synchronous
        // and when it returns, the cache is up to date.
        //

        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        hr = pSchemaRootDse->PutEx( ADS_PROPERTY_APPEND,
                                    const_cast<BSTR>((LPCTSTR)g_UpdateSchema),
                                    AdsArray );
        if(FAILED(hr)) {hr=S_FALSE;break;} // schema is read only

        hr = pSchemaRootDse->SetInfo();
        if(FAILED(hr)) {hr=S_FALSE;break;} // schema is read only
    } while( FALSE );

   
    SafeArrayDestroy( pSafeArray );

    if( pSchemaRootDse )
        pSchemaRootDse->Release();

    return hr;
}

BOOLEAN
ComponentData::AsynchForceDsSchemaCacheUpdate(
    VOID
) {

    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    CWaitCursor wait;
    CString szSchemaContainerPath;
    IADs *pSchemaContainer;
    VARIANT AdsValue;
    HRESULT hr;
    SYSTEMTIME CurrentTime;
    double variant_time;

    //
    // Get the schema container path.
    //

    GetBasePathsInfo()->GetSchemaPath(szSchemaContainerPath);

    if (szSchemaContainerPath.IsEmpty() ) {
        return FALSE;
    }

    //
    // Open the schema container.
    //

    hr = SchemaOpenObject(
             (LPWSTR)(LPCWSTR)szSchemaContainerPath,
             IID_IADs,
             (void **)&pSchemaContainer );

    if ( FAILED(hr) ) {
        return FALSE;
    }

    //
    // Write the update parameter.
    //

    GetSystemTime( &CurrentTime );
    BOOL result = SystemTimeToVariantTime( &CurrentTime, &variant_time );

    ASSERT( result );

    VariantInit( &AdsValue );

    V_VT(&AdsValue) = VT_DATE;
    V_DATE(&AdsValue) = variant_time;

    // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
    hr = pSchemaContainer->Put( const_cast<BSTR>((LPCTSTR)g_UpdateSchema),
                                AdsValue );
    // NTRAID#NTBUG9-542354-2002/02/14-dantra-Errors returned by IADs::Put and PutEx are being masked.
    if ( SUCCEEDED( hr ) ) hr = pSchemaContainer->SetInfo();

    pSchemaContainer->Release();

    if ( FAILED( hr ) ) {
        return FALSE;
    }

    return TRUE;
}


HRESULT
InsertEditItems(
    HWND hwnd,
    VARIANT *AdsResult
) {

    HRESULT hr;
    SAFEARRAY *saAttributes;
    long start, end, current;
    VARIANT SingleResult;

    //
    // Check the VARIANT to make sure we have
    // an array of variants.
    //

    ASSERT( V_VT(AdsResult) == ( VT_ARRAY | VT_VARIANT ) );
    saAttributes = V_ARRAY( AdsResult );

    //
    // Figure out the dimensions of the array.
    //

    hr = SafeArrayGetLBound( saAttributes, 1, &start );

    if ( FAILED(hr) ) {
        return S_FALSE;
    }

    hr = SafeArrayGetUBound( saAttributes, 1, &end );

    if ( FAILED(hr) ) {
        return S_FALSE;
    }

    VariantInit( &SingleResult );

    //
    // Process the array elements.
    //

    for ( current = start       ;
          current <= end        ;
          current++   ) {

        hr = SafeArrayGetElement( saAttributes, &current, &SingleResult );

        if ( SUCCEEDED( hr ) ) {

            ASSERT( V_VT(&SingleResult) == VT_BSTR );

            ::SendMessage( hwnd, LB_ADDSTRING, 0,
                           reinterpret_cast<LPARAM>(V_BSTR(&SingleResult)) );

            ::SendMessage( hwnd, LB_SETITEMDATA, 0, NULL );
             
            VariantClear( &SingleResult );
        }
    }

    return S_OK;

}

HRESULT
InsertEditItems(
    CListBox& refListBox,
    CStringList& refstringlist
)
{
    POSITION pos = refstringlist.GetHeadPosition();
    while (pos != NULL)
    {
        int iItem = refListBox.AddString( refstringlist.GetNext(pos) );
        if (0 > iItem)
        {
            ASSERT(FALSE);
            return E_OUTOFMEMORY;
        }
        else
        {
            VERIFY( LB_ERR != refListBox.SetItemDataPtr( iItem, NULL ) );
        }
    }
    return S_OK;
}


inline BOOL
IsEqual( ADS_OCTET_STRING * ostr1, ADS_OCTET_STRING * ostr2 )
{
   ASSERT(ostr1);
   ASSERT(ostr2);

   if( ostr1->dwLength == ostr2->dwLength )
   {
      if( 0 == ostr1->dwLength )
         return TRUE;
      else
         return !memcmp( ostr1->lpValue, ostr2->lpValue, ostr1->dwLength );
   }
   else
      return FALSE;
}


UINT
GetSyntaxOrdinal( PCTSTR attributeSyntax, UINT omSyntax, ADS_OCTET_STRING * pOmObjectClass )
{
      ASSERT( attributeSyntax );
      ASSERT( omSyntax );
      ASSERT( pOmObjectClass );

    //
    // Return the syntax ordinal, or the unknown syntax ordinal.
    //

    UINT Ordinal = 0;

    while ( Ordinal < SCHEMA_SYNTAX_UNKNOWN) {

        if ( !_tcscmp(g_Syntax[Ordinal].m_pszAttributeSyntax, attributeSyntax))
        {
           if( omSyntax && g_Syntax[Ordinal].m_nOmSyntax == omSyntax &&
                  IsEqual( &g_Syntax[Ordinal].m_octstrOmObjectClass, pOmObjectClass ) )
              break;
        }

        Ordinal++;
    }

    return Ordinal;
}


// Coded to fail on anything suspicious
HRESULT
VariantToStringList(
    VARIANT& refvar,
        CStringList& refstringlist
)
{
    HRESULT hr = S_OK;
    long start, end, current;

    //
    // Check the VARIANT to make sure we have
    // an array of variants.
    //

    if ( V_VT(&refvar) != ( VT_ARRAY | VT_VARIANT ) )
        {
                ASSERT(FALSE);
                return E_UNEXPECTED;
        }
    SAFEARRAY *saAttributes = V_ARRAY( &refvar );

    //
    // Figure out the dimensions of the array.
    //

    hr = SafeArrayGetLBound( saAttributes, 1, &start );
        if( FAILED(hr) )
                return hr;

    hr = SafeArrayGetUBound( saAttributes, 1, &end );
        if( FAILED(hr) )
                return hr;

    VARIANT SingleResult;
    VariantInit( &SingleResult );

    //
    // Process the array elements.
    //

    for ( current = start       ;
          current <= end        ;
          current++   ) {

        hr = SafeArrayGetElement( saAttributes, &current, &SingleResult );
        if( FAILED(hr) )
            return hr;
        if ( V_VT(&SingleResult) != VT_BSTR )
                        return E_UNEXPECTED;

                refstringlist.AddHead( V_BSTR(&SingleResult) );
        VariantClear( &SingleResult );
    }

    return S_OK;
}

HRESULT
StringListToVariant(
    VARIANT& refvar,
    CStringList& refstringlist
)
{
    HRESULT hr = S_OK;
    int cCount = (int) refstringlist.GetCount();

    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = cCount;

    SAFEARRAY* psa = SafeArrayCreate(VT_VARIANT, 1, rgsabound);
    if (NULL == psa)
        return E_OUTOFMEMORY;

    VariantClear( &refvar );
    V_VT(&refvar) = VT_VARIANT|VT_ARRAY;
    V_ARRAY(&refvar) = psa;

    VARIANT SingleResult;
    VariantInit( &SingleResult );
    V_VT(&SingleResult) = VT_BSTR;
    POSITION pos = refstringlist.GetHeadPosition();
    long i;
    for (i = 0; i < cCount, pos != NULL; i++)
    {
        V_BSTR(&SingleResult) = T2BSTR((LPCTSTR)refstringlist.GetNext(pos));
        hr = SafeArrayPutElement(psa, &i, &SingleResult);
        if( FAILED(hr) )
            return hr;
    }
    if (i != cCount || pos != NULL)
        return E_UNEXPECTED;

    return hr;
}

HRESULT
StringListToColumnList(
    ComponentData* pScopeControl,
    CStringList& refstringlist,
    ListEntry **ppNewList
) {

    //
    // Make a column list from a string list.  We use
    // this to update the cached attributes lists.
    //

    int cCount = (int) refstringlist.GetCount();
    ListEntry *pHead = NULL;
    ListEntry *pCurrent = NULL, *pPrevious = NULL;
    POSITION pos = refstringlist.GetHeadPosition();
    CString Name;
    SchemaObject *pSchemaObject, *pSchemaHead;
    BOOLEAN fNameFound;

    for ( long i = 0; i < cCount, pos != NULL; i++ ) {

        pCurrent = new ListEntry;
        if ( !pCurrent ) {
            pScopeControl->g_SchemaCache.FreeColumnList( pHead );
            return E_OUTOFMEMORY;
        }

        if ( !pHead ) {

            pHead = pPrevious = pCurrent;

        } else {

            pPrevious->pNext = pCurrent;
            pPrevious = pCurrent;
        }

        //
        // We need to list all of these by their ldapDisplayNames,
        // so we have to reverse lookup the oid entries.
        //

        Name = ((LPCTSTR)refstringlist.GetNext(pos));
        pSchemaObject = pScopeControl->g_SchemaCache.LookupSchemaObject(
                                                         Name,
                                                         SCHMMGMT_CLASS );

        if ( !pSchemaObject ) {

            pSchemaObject = pScopeControl->g_SchemaCache.LookupSchemaObject(
                                                             Name,
                                                             SCHMMGMT_ATTRIBUTE );

            if ( !pSchemaObject) {

                //
                // We have to look up this oid.
                // First try the list of classes.
                //

                pSchemaHead = pScopeControl->g_SchemaCache.pSortedClasses;
                pSchemaObject = pSchemaHead;
                fNameFound = FALSE;

                do {

                    if ( pSchemaObject->oid == Name ) {

                        Name = pSchemaObject->ldapDisplayName;
                        fNameFound = TRUE;
                        break;
                    }

                    pSchemaObject = pSchemaObject->pSortedListFlink;

                } while ( pSchemaObject != pSchemaHead );

                //
                // Then try the list of attributes.
                //

                if ( !fNameFound ) {

                    pSchemaHead = pScopeControl->g_SchemaCache.pSortedAttribs;
                    pSchemaObject = pSchemaHead;

                    do {

                        if ( pSchemaObject->oid == Name ) {

                            Name = pSchemaObject->ldapDisplayName;
                            fNameFound = TRUE;
                            break;
                        }

                        pSchemaObject = pSchemaObject->pSortedListFlink;

                    } while ( pSchemaObject != pSchemaHead );
                }

                ASSERT( fNameFound );

            } else {

                pScopeControl->g_SchemaCache.ReleaseRef( pSchemaObject );
            }

        } else {

            pScopeControl->g_SchemaCache.ReleaseRef( pSchemaObject );
        }

        //
        // This is the ldapDisplayName!!
        //

        pCurrent->Attribute = Name;
    }

    ASSERT( cCount == i );
    ASSERT( pos == NULL );

    *ppNewList = pHead;
    return S_OK;
}


const UINT	MAX_ERROR_BUF = 2048;


VOID
DoExtErrMsgBox(
    VOID
)
{
    CThemeContextActivator activator;

    DWORD dwLastError;
    WCHAR szErrorBuf[MAX_ERROR_BUF + 1];
    WCHAR szNameBuf[MAX_ERROR_BUF + 1];

    // get extended error value
    HRESULT hr_return = ADsGetLastError( &dwLastError,
										   szErrorBuf,
										   MAX_ERROR_BUF,
											szNameBuf,
										   MAX_ERROR_BUF);
    if (SUCCEEDED(hr_return))
    {
		MessageBox( ::GetActiveWindow(),
					szErrorBuf,
					szNameBuf,
					MB_OK | MB_ICONSTOP );
    }
	else
		ASSERT( FALSE );
}


// INVALID_POINTER is returned by CListBox::GetItemDataPtr() in case of an error.
const VOID * INVALID_POINTER = reinterpret_cast<void *>( LB_ERR );


HRESULT
RetrieveEditItemsWithExclusions(
    CListBox& refListBox,
    CStringList& refstringlist,
    CStringList* pstringlistExclusions)
{
    CString     str;
    CString   * pstr    = NULL;
    int         nCount  = refListBox.GetCount();

    if (LB_ERR == nCount)
    {
        ASSERT(FALSE);
        return E_UNEXPECTED;
    }

    for (INT i = 0; i < nCount; i++)
    {
        pstr = static_cast<CString *>( refListBox.GetItemDataPtr(i) );
        ASSERT( INVALID_POINTER != pstr );

        // don't need to search for pstr because pstr can only be a new item,
        // and they are never excluded.

        if( pstr && INVALID_POINTER != pstr )
        {
            refstringlist.AddHead( *pstr );
        }
        else
        {
            refListBox.GetText( i, str );
            if (NULL != pstringlistExclusions)
            {
                POSITION pos = pstringlistExclusions->Find( str );
                if (NULL != pos)
                    continue;
            }

            refstringlist.AddHead( str );
        }

    }
    
    return S_OK;
}


//
// The global cookie lists for scope and result pane items.
//

VOID
CCookieList::AddCookie(
    Cookie *pCookie,
    HSCOPEITEM hScope
) {

    CCookieListEntry *pNewEntry = new CCookieListEntry;

    //
    // If there's no memory, we can't remember this and hence
    // our display may get a little out of whack.
    //

    if ( !pNewEntry ) {
        return;
    }

    pNewEntry->pCookie = pCookie;
    pNewEntry->hScopeItem = hScope;

    if ( !pHead ) {

        //
        // If this is the first one, just set the
        // head pointer.  The constructor for the
        // list entry has already set the next and
        // back pointers.
        //

        pHead = pNewEntry;

    } else {

        //
        // Insert this at the end of the circular
        // doubly-linked list.
        //

        pNewEntry->pBack = pHead->pBack;
        pNewEntry->pNext = pHead;
        pHead->pBack->pNext = pNewEntry;
        pHead->pBack = pNewEntry;
    }

    return;
}


VOID
CCookieList::InsertSortedDisplay(
    ComponentData *pScopeControl,
    SchemaObject *pNewObject
)
/***

Notes:

    This function inserts the object into the
    sorted display list.

    If the object is a class and the ComponentData
    interface pointer is provided, this routine will
    also create a cookie for this object and insert
    the scope item into the view.

***/
{

    HRESULT hr;
    CCookieListEntry *pNewEntry = NULL, *pCurrent = NULL;
    // NTRAID#NTBUG9-562405-2002/03/04-dantra-Possible use of uninitalized SCOPEDATAITEM
    SCOPEDATAITEM ScopeItem={0};
    Cookie *pNewCookie= NULL;
    int compare;

    //
    // If this cookie list is empty, there's nothing
    // in the display and we don't need to do anything.
    //

    if ( !pHead ) {
        return;
    }

    //
    // Allocate a new cookie list entry.  If we can't
    // do nothing.  The display will be out of sync
    // until the user refreshes.
    //

    pNewEntry = new CCookieListEntry;

    if ( !pNewEntry ) {
        return;
    }

    //
    // Prepare the required mmc structures.
    //

    if ( pNewObject->schemaObjectType == SCHMMGMT_CLASS ) {

        if ( !pScopeControl ) {

            //
            // If there's no scope control, we can't insert anything.
            //

            delete pNewEntry;
            return;
        }

        // prefix believes that this allocation (or construction) may throw
        // an exception, and if an exception is thrown, pNewEntry is
        // leaked.  After a lot of digging, it's possible that a
        // CMemoryException instance may be thrown by one of the base
        // classes of one the members of CBaseCookieBlock, which is a base
        // clase of Cookie.        
        // NTRAID#NTBUG9-294879-2001/01/26-sburns
        
        try
        {
           pNewCookie = new Cookie( SCHMMGMT_CLASS,
                         pParentCookie->QueryNonNULLMachineName() );
        }
        catch (...)
        {
           delete pNewEntry;
           return;
        }

        if ( !pNewCookie ) {

            //
            // If we can't allocate a cookie, do nothing.
            //

            delete pNewEntry;
            return;
        }

        pNewCookie->pParentCookie = pParentCookie;
        pNewCookie->strSchemaObject = pNewObject->commonName;

        pParentCookie->m_listScopeCookieBlocks.AddHead(
            (CBaseCookieBlock*)pNewCookie );

        pNewEntry->pCookie = pNewCookie;

        ::ZeroMemory( &ScopeItem, sizeof(ScopeItem) );
        ScopeItem.displayname = MMC_CALLBACK;
        ScopeItem.nState = 0;

        ScopeItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pNewCookie);
        ScopeItem.nImage = pScopeControl->QueryImage( *pNewCookie, FALSE );
        ScopeItem.nOpenImage = pScopeControl->QueryImage( *pNewCookie, TRUE );

    }

    //
    // Should this be the new head of the list?
    //

    compare = pNewObject->ldapDisplayName.CompareNoCase(
                  pHead->pCookie->strSchemaObject );

    if ( compare < 0 ) {

        if ( pNewObject->schemaObjectType == SCHMMGMT_CLASS ) {

            //
            // Insert this into the scope pane.
            //

            ScopeItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_STATE |
                             SDI_PARAM | SDI_NEXT | SDI_CHILDREN;
            ScopeItem.cChildren = 0;

            ScopeItem.relativeID = pHead->hScopeItem;

            hr = pScopeControl->m_pConsoleNameSpace->InsertItem( &ScopeItem );

            pNewEntry->hScopeItem = ScopeItem.ID;
            pNewEntry->pCookie->m_hScopeItem = ScopeItem.ID;

        } else {

            hr = S_OK;
        }

        if ( SUCCEEDED(hr) ) {

            pNewEntry->pNext = pHead;
            pNewEntry->pBack = pHead->pBack;
            pHead->pBack->pNext = pNewEntry;
            pHead->pBack = pNewEntry;

            pHead = pNewEntry;

        } else {

            delete pNewEntry;
            delete pNewCookie;
        }

        return;
    }

    //
    // Determine the sorted insertion point.  The sorted list is circular.
    //

    pCurrent = pHead;

    while ( pCurrent->pNext != pHead ) {

        compare = pNewObject->ldapDisplayName.CompareNoCase(
                      pCurrent->pNext->pCookie->strSchemaObject );

        if ( compare < 0 ) {
            break;
        }

        pCurrent = pCurrent->pNext;
    }

    //
    // We want to insert the new object after pCurrent.
    //

    if ( pNewObject->schemaObjectType == SCHMMGMT_CLASS ) {

        ScopeItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_STATE |
                         SDI_PARAM | SDI_PREVIOUS | SDI_CHILDREN;
        ScopeItem.cChildren = 0;

        ScopeItem.relativeID = pCurrent->hScopeItem;

        hr = pScopeControl->m_pConsoleNameSpace->InsertItem( &ScopeItem );

        pNewEntry->hScopeItem = ScopeItem.ID;
        pNewEntry->pCookie->m_hScopeItem = ScopeItem.ID;

    } else {

        hr = S_OK;
    }

    if ( SUCCEEDED( hr )) {

       pNewEntry->pNext = pCurrent->pNext;
       pNewEntry->pBack = pCurrent;
       pCurrent->pNext->pBack = pNewEntry;
       pCurrent->pNext = pNewEntry;

    } else {

        delete pNewEntry;
        delete pNewCookie;
    }

    return;
}

bool
CCookieList::DeleteCookie(Cookie* pCookie)
{
   bool result = false;

   if (!pHead)
   {
      return result;
   }

   // walk the links and stop when the scope item matches.
   // Since the list is circular,
   // we use pHead as the sentinal value instead of null.

   CCookieListEntry* pCurrent = pHead;
   do
   {
       ASSERT(pCurrent);

       if (pCurrent->pCookie == pCookie)
       {
          // Remove the node from the list

          pCurrent->pBack->pNext = pCurrent->pNext;
          pCurrent->pNext->pBack = pCurrent->pBack;

          if (pCurrent == pHead)
          {
             pHead = pCurrent->pNext;
          }

          result = true;

          delete pCurrent;
          break;
       }

       pCurrent = pCurrent->pNext;

   } while (pCurrent != pHead);

   return result;
}

void
CCookieList::DeleteAll()
{
   if (!pHead)
   {
      return;
   }


   CCookieListEntry* pCurrent = pHead;
   do
   {
      CCookieListEntry* next = pCurrent->pNext;
      delete pCurrent;
      pCurrent = next;
   }
   while (pCurrent != pHead);

   pHead = 0;
}



CString
GetHelpFilename()
{
   TCHAR buf[MAX_PATH + 1];

   UINT result = ::GetSystemWindowsDirectory(buf, MAX_PATH);
   ASSERT(result != 0 && result <= MAX_PATH);

   CString f(buf);
   f += TEXT("\\help\\schmmgmt.hlp");

   return f;
}


BOOL
ShowHelp( HWND hParent, WPARAM wParam, LPARAM lParam, const DWORD ids[], BOOL fContextMenuHelp )
{
   HWND hWndMain = NULL;
   UINT uCommand = 0;

   if( !fContextMenuHelp )
   {
       // The user has clicked ? and the control, or just F1 (if enabled)
       const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
       if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
       {
            hWndMain = (HWND) pHelpInfo->hItemHandle;
            uCommand = HELP_WM_HELP;
       }
   }
   else
   {
       hWndMain = (HWND) wParam;
       uCommand = HELP_CONTEXTMENU;

       // Optimization for non-static enabled windows.
       // This way users don't have to do an extra menu click

       // $$ don't know why this call returns NULL all the time
       // HWND hWnd = ChildWindowFromPoint( hParent, CPoint(lParam) );
       // if( hWnd )
       //   hWndMain = hWnd;

       if( -1 != GET_X_LPARAM(lParam) &&
           -1 != GET_Y_LPARAM(lParam) &&
           hParent                    &&
           hWndMain != hParent )
       {
           uCommand = HELP_WM_HELP;
       }
   }
   

   if( hWndMain && uCommand )
   {
       // Display context help for a control
       ::WinHelp( hWndMain,
                  GetHelpFilename(),
                  uCommand,
                  (DWORD_PTR) ids );
   }

   return TRUE;
}


#if 0

VOID
DebugTrace(
    LPWSTR Format,
    ...
) {

    WCHAR DbgString[1024];
    va_list arglist;
    int Length;

    //
    // Format the output into a buffer and then print it.
    //

    va_start(arglist, Format);

    Length = wvsprintf( DbgString, Format, arglist );

    va_end(arglist);

    ASSERT( Length <= 1024 );
    ASSERT( Length != 0 );

    OutputDebugString( DbgString );

    return;

}

#else


VOID
DebugTrace(
    LPWSTR,
    ...
) {
 ;
}

#endif




// Attempt to locate a message in a given module.  Return the message string
// if found, the empty string if not.
// 
// flags - FormatMessage flags to use
// 
// module - module handle of message dll to look in, or 0 to use the system
// message table.
// 
// code - message code to look for

CString
getMessageHelper(DWORD flags, HMODULE module, HRESULT code)
{
   ASSERT(code);
   ASSERT(flags & FORMAT_MESSAGE_ALLOCATE_BUFFER);

   CString message;

   TCHAR* sys_message = 0;
   DWORD result =
      ::FormatMessage(
         flags,
         module,
         static_cast<DWORD>(code),
         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
         reinterpret_cast<LPTSTR>(&sys_message),
         0,
         0);
   if (result)
   {
      ASSERT(sys_message);
      if (sys_message)
      {
         message = sys_message;
         ::LocalFree(sys_message);
      }
   }

   return message;
}


#define MAX_ERROR_BUF   2048

HRESULT
GetLastADsError( HRESULT hr, CString& refErrorMsg, CString& refName )
{
  ASSERT(FAILED(hr));

  refErrorMsg.Empty();
  refName.Empty();

  if (!FAILED(hr))
  {
       return hr;
  }

   if( FACILITY_WIN32 == HRESULT_FACILITY(hr) )
   {
       DWORD dwLastError = 0;
       WCHAR szErrorBuf[ MAX_ERROR_BUF + 1 ];
       WCHAR szNameBuf[ MAX_ERROR_BUF + 1 ];

       //Get extended error value.
       HRESULT hr_return = ADsGetLastError( &dwLastError,
                                            szErrorBuf,
                                            MAX_ERROR_BUF,
                                            szNameBuf,
                                            MAX_ERROR_BUF );
       
       ASSERT( SUCCEEDED(hr_return) );
       if( SUCCEEDED(hr_return) && dwLastError )
       {
            refErrorMsg = szErrorBuf;
            refName     = szNameBuf;
            return HRESULT_FROM_WIN32( dwLastError );
       }
   }

   return hr;
}

// Attempts to locate message strings for various facility codes in the
// HRESULT.  If fTryADSIExtError is true, check ADsGetLastError() first


CString
GetErrorMessage( HRESULT hr, BOOL fTryADSIExtError /* = FALSE */ )
{
   ASSERT(FAILED(hr));

   if (!FAILED(hr))
   {
      // no messages for success!
      return CString();
   }

   
   CString  strExtMsg;
   
   if( fTryADSIExtError &&
       FACILITY_WIN32 == HRESULT_FACILITY(hr) )
   {
       DWORD dwLastError = 0;
       WCHAR szErrorBuf[ MAX_ERROR_BUF + 1 ];
       WCHAR szNameBuf[ MAX_ERROR_BUF + 1 ];

       //Get extended error value.
       HRESULT hr_return = ADsGetLastError( &dwLastError,
                                            szErrorBuf,
                                            MAX_ERROR_BUF,
                                            szNameBuf,
                                            MAX_ERROR_BUF );
       
       ASSERT( SUCCEEDED(hr_return) );
       if( SUCCEEDED(hr_return) && dwLastError )
       {
            hr = HRESULT_FROM_WIN32( dwLastError );

            strExtMsg = szErrorBuf;
       }
   }

   int code = HRESULT_CODE(hr);

   CString message;

   // default is the system error message table
   HMODULE module = 0;

   DWORD flags =
         FORMAT_MESSAGE_ALLOCATE_BUFFER
      |  FORMAT_MESSAGE_IGNORE_INSERTS
      |  FORMAT_MESSAGE_FROM_SYSTEM;

   int facility = HRESULT_FACILITY(hr);
   switch (facility)
   {
      case FACILITY_WIN32:    // 0x7
      {
         // included here:
         // lanman error codes (in it's own dll)
         // dns
         // winsock

         static HMODULE lm_err_res_dll = 0;
         if (code >= NERR_BASE && code <= MAX_NERR)
         {
            // use the net error message resource dll
            if (lm_err_res_dll == 0)
            {
               lm_err_res_dll =
                  ::LoadLibraryEx(
                     L"netmsg.dll",
                     0,
                     LOAD_LIBRARY_AS_DATAFILE);
            }

            module = lm_err_res_dll;
            flags |= FORMAT_MESSAGE_FROM_HMODULE;
         }
         break;
      }
      case 0x0:
      {
         if (code >= 0x5000 && code <= 0x50FF)
         {
            // It's an ADSI error.  They put the facility code (5) in the
            // wrong place!
            static HMODULE adsi_err_res_dll = 0;
            // use the net error message resource dll
            if (adsi_err_res_dll == 0)
            {
               adsi_err_res_dll =
                  ::LoadLibraryEx(
                     L"activeds.dll",
                     0,
                     LOAD_LIBRARY_AS_DATAFILE);
            }

            module = adsi_err_res_dll;
            flags |= FORMAT_MESSAGE_FROM_HMODULE;

            // the message dll expects the entire error code
            code = hr;
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   message = getMessageHelper(flags, module, code);


#ifdef SHOW_EXT_LDAP_MSG

   if( !strExtMsg.IsEmpty() )
       message += L"\n" + strExtMsg;

#endif //SHOW_EXT_LDAP_MSG


   if (message.IsEmpty())
   {
      message.LoadString(IDS_UNKNOWN_ERROR_MESSAGE);
   }

   return message;
}



//
// Get range from edit controls, Verify the range, attempt to correct, make sure lower <= upper.
//
//	an exception will be thrown in case of an error.
//
void DDXV_VerifyAttribRange( CDataExchange *pDX, BOOL fIsSigned,
								UINT idcLower, CString & strLower,
								UINT idcUpper, CString & strUpper )
{
	INT64		llLower	= 0;
	INT64		llUpper	= 0;

	ASSERT( pDX );
	ASSERT( pDX->m_pDlgWnd );


	// Update the values.
	llLower = DDXV_SigUnsigINT32Value( pDX, fIsSigned, idcLower, strLower );
	llUpper = DDXV_SigUnsigINT32Value( pDX, fIsSigned, idcUpper, strUpper );


#ifdef ENABLE_NEGATIVE_INT
    // verify that lower <= upper  --  only if supporting ENABLE_NEGATIVE_INT
    if ( pDX->m_bSaveAndValidate && !strLower.IsEmpty() && !strUpper.IsEmpty() )
	{
		if( llLower > llUpper )
		{
			DoErrMsgBox( pDX->m_pDlgWnd->m_hWnd, TRUE, IDS_ERR_EDIT_MINMAX );
			pDX->Fail();		// we are still at the second edit control.
		}
	}
#endif //ENABLE_NEGATIVE_INT
}


//
// Get string from an edit control, verify it attempting to correct
//
//	an exception will be thrown in case of an error.
//
// Returns corrected value
//
INT64 DDXV_SigUnsigINT32Value( CDataExchange *pDX, BOOL fIsSigned,
						UINT idc, CString & str )
{
	INT64	llVal	= 0;
	HRESULT	hr		= S_OK;
	
	ASSERT( pDX );
	ASSERT( pDX->m_pDlgWnd );

	// Get/Put the string
	DDX_Text( pDX, idc, str );

    if ( pDX->m_bSaveAndValidate )
	{
		if( !str.IsEmpty() )
		{
			hr = GetSafeINT32FromString( pDX->m_pDlgWnd, llVal, str,
										fIsSigned, GETSAFEINT_ALLOW_CANCEL );

			if( FAILED(hr) )
			{
				pDX->Fail();
			}
			else if( S_VALUE_MODIFIED == hr )
			{
				// update the string in case of some conversion things ('010' --> '10')
				// or if the value was changed
				pDX->m_pDlgWnd->SetDlgItemText( idc, str );
			}
		}
	}

	return llVal;
}



//
// Converts a string to a DWORD, asks to correct to be within the range.
// returns HRESULT:
//	S_OK				llDst is the value from string
//	S_VALUE_MODIFIED	llDst is the truncated value, strSrc is updated
//	E_ABORT				llDst is unchanged; E_ABORT may be returned only if fAllowCancel is TRUE
//
HRESULT GetSafeSignedDWORDFromString( CWnd * pwndParent, DWORD & dwDst, CString & strSrc,
										BOOL fIsSigned, BOOL fAllowCancel /* =FALSE */)
{
	INT64	llDst	= 0;
	HRESULT	hr		= GetSafeINT32FromString( pwndParent, llDst, strSrc, fIsSigned, fAllowCancel );

	if( SUCCEEDED( hr ) )
		dwDst = (DWORD) llDst;

	return hr;
}


//
//		*** internal use ***
// Converts a string to a INT64, asks to correct to be within the range.
// returns HRESULT:
//	S_OK				llDst is the value from string
//	S_VALUE_MODIFIED	llDst is the truncated value, strSrc is updated
//	E_ABORT				llDst is the truncated value
//							E_ABORT only happens if fAllowCancel is TRUE
//
HRESULT GetSafeINT32FromString( CWnd * pwndParent, INT64 & llDst, CString & strSrc,
								BOOL fIsSigned, BOOL fAllowCancel)
{
   CThemeContextActivator activator;

	HRESULT		hr				= S_OK;
	UINT		nMessageBoxType	= 0;
	CString		szMsg;
	CString		szSugestedNumber;
	BOOL		fIsValidNumber	= TRUE;
	BOOL		fIsValidString	= TRUE;
	

	ASSERT( pwndParent );

	// the string must be limited in length & not empty
	ASSERT( !strSrc.IsEmpty() );
	ASSERT( strSrc.GetLength() <= cchMinMaxRange );

	fIsValidString	= IsValidNumberString( strSrc );

	llDst			= _wtoi64( (LPCWSTR) strSrc );
	fIsValidNumber	= IsValidNumber32( llDst, fIsSigned );
	szSugestedNumber.Format( fIsSigned ? g_INT32_FORMAT : g_UINT32_FORMAT, (DWORD) llDst );

	if( !fIsValidString || !fIsValidNumber )
	{
		szMsg.FormatMessage( !fIsValidString ? IDS_ERR_NUM_IS_ILLIGAL : IDS_ERR_INT_OVERFLOW,
								(LPCWSTR) strSrc, (LPCWSTR) szSugestedNumber );

		// make sure the user wants to do it
        nMessageBoxType = (fAllowCancel ? MB_OKCANCEL : MB_OK) | MB_ICONEXCLAMATION ;

        if( IDOK == pwndParent->MessageBox( szMsg, g_MsgBoxErr, nMessageBoxType ) )
		{
			strSrc	= szSugestedNumber;
			hr		= S_VALUE_MODIFIED;
		}
		else
		{
			hr		= E_ABORT;
		}
	}
	else if( strSrc != szSugestedNumber )
	{
		// fixing number formating
		strSrc	= szSugestedNumber;
		hr		= S_VALUE_MODIFIED;
	}

	return hr;
}


//
// Verify & correct Min/Max for a signed/unsigned INT64 value
//
BOOL IsValidNumber32( INT64 & llVal, BOOL fIsSigned )
{

#ifdef ENABLE_NEGATIVE_INT
	const INT64	llMinVal	= fIsSigned ? (INT64) _I32_MIN : (INT64) 0 ;
	const INT64	llMaxVal	= fIsSigned ? (INT64) _I32_MAX : (INT64) _UI32_MAX ;
#else
	// if there is no negative numbers support, always use unsigned numbers
	const INT64	llMinVal	= (INT64) 0;
	const INT64	llMaxVal	= (INT64) _UI32_MAX;
#endif

	BOOL		fIsValid	= FALSE;

	// if larger than 32bit number (signed/unsigned), truncate...
	if( llVal < llMinVal )
	{
		llVal		= llMinVal;
	}
	else if( llVal > llMaxVal )
	{
		llVal		= llMaxVal;
	}
	else
	{
		fIsValid	= TRUE;
	}

	return fIsValid;
}


//
// Search number string for illigal characters.
//
BOOL IsValidNumberString( CString & str )
{
	int i = 0;

#ifdef ENABLE_NEGATIVE_INT
	if( str.GetLength() > 0 &&					// allow negative sign in front of the number
		g_chNegativeSign == str[ i ] )
	{
		i++;	// skip first character
	}
#endif //ENABLE_NEGATIVE_INT

	for( ;  i < str.GetLength();  i++ )
	{
		if( !IsCharNumeric( str[i] ) )
			return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// ParsedEdit

BEGIN_MESSAGE_MAP(CParsedEdit, CEdit)
	//{{AFX_MSG_MAP(CParsedEdit)
	ON_WM_CHAR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize subclassing

BOOL CParsedEdit::SubclassEdit( UINT nID,
                                CWnd* pParent,
                                int cchMaxTextSize )   // 0 == unlimited
{
    ASSERT( IsInitialized() );
	ASSERT( nID );
	ASSERT( pParent );
	ASSERT( pParent->GetDlgItem(nID) );
    ASSERT( cchMaxTextSize >= 0 );

    ( static_cast<CEdit *>( pParent->GetDlgItem(nID) ) ) -> LimitText( cchMaxTextSize ) ;

    if( EDIT_TYPE_GENERIC == GetEditType() )
    {
        return TRUE;        // no need to subclass - everything is allowed.
    }
    else
    {
        return SubclassDlgItem(nID, pParent);
    }
}

/////////////////////////////////////////////////////////////////////////////
// Input character filter

void CParsedEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    ASSERT( IsInitialized() ); // initialized?
	
	BOOL	fIsSpecialChar	= ( nChar < 0x20 );

    BOOL    fAllowChar      = FALSE;


    if( fIsSpecialChar )
    {
        fAllowChar = TRUE;      // always allow control chars
    }
    else
    {
        // is this a digit?
        BOOL	fIsDigit		= IsCharNumeric( (TCHAR)nChar );

        switch( GetEditType() )
        {
            default:
                ASSERT( FALSE );
                break;

            case EDIT_TYPE_GENERIC:         // everything is allowed
                fAllowChar = TRUE;
                break;

            case EDIT_TYPE_INT32:
            case EDIT_TYPE_UINT32:
                {
                    #ifdef ENABLE_NEGATIVE_INT
    	              const BOOL    fAllowNegativeNumbers   = TRUE;
                    #else
	                  const BOOL    fAllowNegativeNumbers   = FALSE;
                    #endif

                    DWORD	dwSel			= GetSel();

	                //	is the caret in the begining of the box
	                BOOL	fLineFront		= ! LOWORD( dwSel );

	                //	is the first character selected? (thus, typing anything will overide it)
	                BOOL	fIsSelFirstChar	= fLineFront && HIWORD( dwSel );

	                BOOL	fIsNegSign		= ( (TCHAR)nChar == g_chNegativeSign );

                  WCHAR	szBuf[ 2 ] = {0};		// we only need the first character to check for '-'

	                // if the first character is selected, no matter what we type it will be overwritten
	                // an empty value is a positive value.
	                // rellies on left to right execution.
	                BOOL	fIsAlreadyNeg	= (	!fIsSelFirstChar &&
							                GetWindowText( szBuf, 2 ) &&
							                g_chNegativeSign == szBuf[0] );

	                ASSERT( !fIsDigit || !fIsNegSign ); // cannot be both!


                    if (
                        (	fIsDigit &&                         // allow numeric if ...
                              ( !fAllowNegativeNumbers ||       //      ignore error checking if false
                                !fLineFront ||                  //    	not first position
                                (fLineFront && !fIsAlreadyNeg)) //    	first pos & no '-' sign
                        )
                  
                        ||

                        (	fIsNegSign &&                       // allow '-' if
                              fAllowNegativeNumbers &&          //  negatives are allowed
                              FIsSigned() &&                    //	signed numbers are allowed
                              !fIsAlreadyNeg &&                 //	the number was positive
                              fLineFront                        //	entering as the first character
                        )
                       )
                    {
                        fAllowChar = TRUE;
                    }
                }
                break;

            case EDIT_TYPE_OID:     // do a light checking -- allow digits & periods
                {
                    if( fIsDigit ||
                        g_chPeriod == (TCHAR)nChar )
                    {
                        fAllowChar = TRUE;
                    }
                }
                break;
        }
    }
    
	
    if( fAllowChar )
    {
		CEdit::OnChar(nChar, nRepCnt, nFlags);  // permitted
	}
	else
	{											// not permitted
		MessageBeep((UINT)-1);					// Standard beep
	}
}



/////////////////////////////////////////////////////////////////////////////
//
//  Search a list of PCTSTR for a strValue, returns TRUE if found
//      rgszList[] last element must be NULL
//
//  puIndex - optional pointer, will be set to the position of the value if found.
//
BOOL
IsInList( PCTSTR rgszList[], const CString & strValue, UINT * puIndex /* = NULL */ )
{
    UINT   uIndex = 0;

    while( rgszList[ uIndex ] )
    {
        if( !strValue.CompareNoCase( rgszList[uIndex] ) )
        {
            if( puIndex )
                *puIndex = uIndex;
            return TRUE;
        }
        else
            uIndex++;
    }

    return FALSE;
}


#define ADS_SYSTEMFLAG_SCHEMA_CONSTRUCTED 0x04
#define ADS_SYSTEMFLAG_SCHEMA_BASE_OBJECT 0x10


//
//  Determine if the object pointed to by pIADsObject is a constructed object.
//
HRESULT
IsConstructedObject( IADs *pIADsObject, BOOL & fIsConstructed )
{
    LONG    fSysAttribs = 0;
    HRESULT hr          = GetSystemAttributes( pIADsObject, fSysAttribs );

    if( SUCCEEDED(hr) )
        fIsConstructed = ADS_SYSTEMFLAG_SCHEMA_CONSTRUCTED & fSysAttribs;

    return hr;
}



//
//  Determine if the object pointed to by pIADsObject is category 1 object.
//
HRESULT
IsCategory1Object( IADs *pIADsObject, BOOL & fIsCategory1 )
{
    LONG    fSysAttribs = 0;
    HRESULT hr          = GetSystemAttributes( pIADsObject, fSysAttribs );

    if( SUCCEEDED(hr) )
        fIsCategory1 = ADS_SYSTEMFLAG_SCHEMA_BASE_OBJECT & fSysAttribs;

    return hr;
}



//
//  Read object's System Attribute
//
HRESULT
GetSystemAttributes( IADs *pIADsObject, LONG &fSysAttribs )
{
    HRESULT hr = E_FAIL;
    VARIANT	AdsResult;

    if( !pIADsObject )
        ASSERT( FALSE );
    else
    {
        VariantInit( &AdsResult );

        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        hr = pIADsObject->Get( const_cast<BSTR>((LPCTSTR)g_systemFlags), &AdsResult );
        
        if ( SUCCEEDED( hr ) )
        {
            ASSERT(AdsResult.vt == VT_I4);
            fSysAttribs = V_I4(&AdsResult);
        }
        else if( E_ADS_PROPERTY_NOT_FOUND == hr )
        {
            fSysAttribs = 0;
            hr = S_OK;
        }

        VariantClear( &AdsResult );
    }

    return hr;
}


HRESULT
DissableReadOnlyAttributes( CWnd * pwnd, IADs *pIADsObject, const CDialogControlsInfo * pCtrls, UINT cCtrls )
{
    ASSERT( pwnd );
    ASSERT( pIADsObject );
    ASSERT( pCtrls );
    ASSERT( cCtrls );

    HRESULT         hr      = S_OK;
    CStringList     strlist;

    do
    {
        // extract the list of allowed attributes
        hr = GetStringListElement( pIADsObject, &g_allowedAttributesEffective, strlist );
        BREAK_ON_FAILED_HRESULT(hr);

        for( UINT ind = 0; ind < cCtrls; ind++ )
        {
            BOOL    fFound = FALSE;

            // search for needed attributes
            for( POSITION pos = strlist.GetHeadPosition(); !fFound && pos != NULL; )
            {
                CString * pstr = &strlist.GetNext( pos );
            
                if( !pstr->CompareNoCase( pCtrls[ind].m_pszAttributeName ) )
                {
                    fFound = TRUE;
                }
            }

            if( !fFound )
            {
                ASSERT( pwnd->GetDlgItem( pCtrls[ind].m_nID ) );

                if( pCtrls[ind].m_fIsEditBox )
                    reinterpret_cast<CEdit *>( pwnd->GetDlgItem(pCtrls[ind].m_nID) )->SetReadOnly();
                else
                    pwnd->GetDlgItem(pCtrls[ind].m_nID)->EnableWindow( FALSE );
            }
        }

    } while( FALSE );

    return hr;
}


HRESULT GetStringListElement( IADs *pIADsObject, LPWSTR *lppPathNames, CStringList &strlist )
{
    ASSERT( pIADsObject );
    ASSERT( lppPathNames );
    ASSERT( *lppPathNames );

    HRESULT         hr      = S_OK;
    VARIANT         varAttributes;

    VariantInit( &varAttributes );

    strlist.RemoveAll();
    
    do
    {
        // build an array of one element
        hr = ADsBuildVarArrayStr( lppPathNames, 1, &varAttributes );
        ASSERT_BREAK_ON_FAILED_HRESULT(hr);

        hr = pIADsObject->GetInfoEx( varAttributes, 0 );
        BREAK_ON_FAILED_HRESULT(hr);

        hr = VariantClear( &varAttributes );
        ASSERT_BREAK_ON_FAILED_HRESULT(hr);


        // Get all allowed attributes
        // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
        hr = pIADsObject->GetEx( CComBSTR(*lppPathNames), &varAttributes );
        BREAK_ON_FAILED_HRESULT(hr);

        // Convert result to a string list
        hr = VariantToStringList( varAttributes, strlist );
        ASSERT( SUCCEEDED(hr) || E_ADS_PROPERTY_NOT_FOUND == hr );
        BREAK_ON_FAILED_HRESULT(hr);

    } while( FALSE );

    VariantClear( &varAttributes );

    return hr;
}

// FUTURE-2002-03/94/2002-dantra-Needs comments
// NTRAID#NTBUG9-567089-2002/03/06-dantra-OIDHasValidFormat should use the safe string functions.
bool OIDHasValidFormat (PCWSTR pszOidValue, int& rErrorTypeStrID)
{
    rErrorTypeStrID = 0;

    bool bFormatIsValid = false;
    // NOTE: Safe Use - query length including NULL terminator
    int  nLen = WideCharToMultiByte(
          CP_ACP,                   // code page
          0,                        // performance and mapping flags
          pszOidValue,              // wide-character string
          (int) wcslen (pszOidValue),  // number of chars in string
          0,                        // buffer for new string
          0,                        // size of buffer
          0,                        // default for unmappable chars
          0);                       // set when default char used
    
    if ( nLen > 0 )
    {
        nLen++; // account for Null terminator
        PSTR    pszAnsiBuf = new CHAR[nLen];
        if ( pszAnsiBuf )
        {
            // NOTE: Safe Use
            ZeroMemory (pszAnsiBuf, nLen*sizeof(CHAR));
            // NOTE: Safe Use - nLen obtained from first call to WideCharToMultiByte
            nLen = WideCharToMultiByte(
                    CP_ACP,                 // code page
                    0,                      // performance and mapping flags
                    pszOidValue,            // wide-character string
                    (int) wcslen (pszOidValue),   // number of chars in string
                    pszAnsiBuf,             // buffer for new string
                    nLen,                   // size of buffer
                    0,                      // default for unmappable chars
                    0);                     // set when default char used
            if ( nLen )
            {
                // According to PhilH:
                // The first number is limited to 
                // 0,1 or 2. The second number is 
                // limited to 0 - 39 when the first 
                // number is 0 or 1. Otherwise, any 
                // number.
                // Also, according to X.208, there 
                // must be at least 2 numbers.
                bFormatIsValid = true;
                size_t cbAnsiBufLen = strlen (pszAnsiBuf);

                // check for only digits and "."
                size_t nIdx = strspn (pszAnsiBuf, "0123456789.\0");
                
                if ( nIdx > 0 && nIdx < cbAnsiBufLen )
                {
                    bFormatIsValid = false;
                    rErrorTypeStrID = IDS_OID_CONTAINS_NON_DIGITS;
                }

                // check for consecutive "."s - string not valid if present
                if ( bFormatIsValid && strstr (pszAnsiBuf, "..") )
                {
                    bFormatIsValid = false;
                    rErrorTypeStrID = IDS_OID_CONTAINS_CONSECUTIVE_DOTS;
                }
                

                // must begin with "0." or "1." or "2."
                bool bFirstNumberIs0 = false;
                bool bFirstNumberIs1 = false;
                bool bFirstNumberIs2 = false;
                if ( bFormatIsValid )
                {
                    if ( !strncmp (pszAnsiBuf, "0.", 2) )
                        bFirstNumberIs0 = true;
                    else if ( !strncmp (pszAnsiBuf, "1.", 2) )
                        bFirstNumberIs1 = true;
                    else if ( !strncmp (pszAnsiBuf, "2.", 2) )
                        bFirstNumberIs2 = true;
                    
                    if ( !bFirstNumberIs0 && !bFirstNumberIs1 && !bFirstNumberIs2 )
                    {
                        bFormatIsValid = false;
                        rErrorTypeStrID = IDS_OID_MUST_START_WITH_0_1_2;
                    }
                }

                if ( bFormatIsValid && ( bFirstNumberIs0 || bFirstNumberIs1 ) )
                {
                    PSTR pszBuf = pszAnsiBuf;
                    pszBuf += 2;

                    // there must be a number after the dot
                    if ( strlen (pszBuf) )
                    {
                        // truncate the string at the next dot, if any
                        PSTR pszDot = strstr (pszBuf, ".");
                        if ( pszDot )
                            pszDot[0] = 0;

                        // convert the string to a number and check for range 0-39
                        int nValue = atoi (pszBuf);
                        if ( nValue < 0 || nValue > 39 )
                        {
                            bFormatIsValid = false;
                            rErrorTypeStrID = IDS_OID_0_1_MUST_BE_0_TO_39;
                        }
                    }
                    else
                    {
                        bFormatIsValid = false;
                        rErrorTypeStrID = IDS_OID_MUST_HAVE_TWO_NUMBERS;
                    }
                }

                // ensure no trailing "."
                if ( bFormatIsValid )
                {
                    if ( '.' == pszAnsiBuf[cbAnsiBufLen - 1] )
                    {
                        bFormatIsValid = false;
                        rErrorTypeStrID = IDS_OID_CANNOT_END_WITH_DOT;
                    }
                }

                if ( bFormatIsValid )
                {
                    bFormatIsValid = false;
                    CRYPT_ATTRIBUTE cryptAttr;
                    // FUTURE-2002-03/94/2002-dantra-Although this is a safe usage of ZeroMemory, suggest changing
                    // the definition CRYPT_ATTRIBUTE cryptAttr = {0} and removing the ZeroMemory call.
                    ::ZeroMemory (&cryptAttr, sizeof (CRYPT_ATTRIBUTE));

                    cryptAttr.cValue = 0;
                    cryptAttr.pszObjId = pszAnsiBuf;
                    cryptAttr.rgValue = 0;

                    DWORD   cbEncoded = 0;
                    BOOL bResult = CryptEncodeObject (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                            PKCS_ATTRIBUTE,
                            &cryptAttr,
                            NULL,
                            &cbEncoded);
                    if ( cbEncoded > 0 )
                    {
                        BYTE* pBuffer = new BYTE[cbEncoded];
                        if ( pBuffer )
                        {
                            bResult = CryptEncodeObject (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    PKCS_ATTRIBUTE,
                                    &cryptAttr,
                                    pBuffer,
                                    &cbEncoded);
                            if ( bResult )
                            {   
                                DWORD   cbStructInfo = 0;
                                bResult = CryptDecodeObject (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        PKCS_ATTRIBUTE,
                                        pBuffer,
                                        cbEncoded,
                                        0,
                                        0,
                                        &cbStructInfo);
                                if ( cbStructInfo > 0 )
                                {
                                    BYTE* pStructBuf = new BYTE[cbStructInfo];
                                    if ( pStructBuf )
                                    {
                                        bResult = CryptDecodeObject (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                                PKCS_ATTRIBUTE,
                                                pBuffer,
                                                cbEncoded,
                                                0,
                                                pStructBuf,
                                                &cbStructInfo);
                                        if ( bResult )
                                        {
                                            CRYPT_ATTRIBUTE* pCryptAttr = (CRYPT_ATTRIBUTE*) pStructBuf;
                                            if ( !strcmp (pszAnsiBuf, pCryptAttr->pszObjId) )
                                            {
                                                bFormatIsValid = true;
                                            }
                                        }
                                        delete [] pStructBuf;
                                    }
                                }
                            }
                            delete [] pBuffer;
                        }
                    }
                }
            }
            else
            {
                DebugTrace(L"WideCharToMultiByte (%s) failed: 0x%x\n", pszOidValue, 
                        GetLastError ());
            }

            delete [] pszAnsiBuf;
        }
    }
    else
    {
        rErrorTypeStrID = IDS_OID_MUST_NOT_BE_EMPTY;
        DebugTrace(L"WideCharToMultiByte (%s) return: 0x%x\n", pszOidValue, 
                GetLastError ());
    }

    return bFormatIsValid;
}

HRESULT
DeleteObject(
    const CString& path,
    Cookie* pcookie,
    PCWSTR pszClass
)
/***

    This deletes an attribute from the schema

***/
{
   HRESULT hr = S_OK;

   do
   {
      if ( !pcookie )
      {
         hr = E_INVALIDARG;
         break;
      }

      CComPtr<IADsPathname> spIADsPathname;

      hr = ::CoCreateInstance( CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                              IID_IADsPathname, (void**)&spIADsPathname);
      if ( FAILED(hr) )
      {
         break;
      }

      // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
      hr = spIADsPathname->Set( CComBSTR(path), ADS_SETTYPE_FULL );
      if ( FAILED(hr) )
      {
         break;
      }

      // Get the RDN so that we have it for deleting

      CComBSTR sbstrRDN;
      hr = spIADsPathname->Retrieve( ADS_FORMAT_LEAF, &sbstrRDN );
      if ( FAILED(hr) )
      {
         break;
      }

      // Get the path to the parent container

      hr = spIADsPathname->RemoveLeafElement();
      if ( FAILED(hr) )
      {
         break;
      }

      CComBSTR sbstrParentPath;
      hr = spIADsPathname->Retrieve( ADS_FORMAT_X500, &sbstrParentPath );
      if ( FAILED(hr) )
      {
         break;
      }

      // Now open the parent object

      CComPtr<IADsContainer> spContainer;
      hr = ::AdminToolsOpenObject( sbstrParentPath, NULL, NULL, ADS_SECURE_AUTHENTICATION,
                                    IID_IADsContainer, (void**)&spContainer);
      if ( FAILED(hr) )
      {
         break;
      }

      // NTRAID#NTBUG9-540866-2002/02/13-dantra-Schema Manager:  passing WCHAR * instead of BSTR to method requiring a BSTR
      hr = spContainer->Delete( CComBSTR(pszClass), sbstrRDN );
      if ( FAILED(hr) )
      {
         break;
      }

   } while (false);

   return hr;
}


//////////////////////////////////////////////////////////////////
// Theming support

HPROPSHEETPAGE MyCreatePropertySheetPage(AFX_OLDPROPSHEETPAGE* psp)
{
    PROPSHEETPAGE_V3 sp_v3 = {0};
    // NTRAID#NTBUG9-567166-2002/03/06-dantra-Possible buffer overrun in MyCreatePropertySheetPage
    CopyMemory (&sp_v3, psp, psp->dwSize);
    sp_v3.dwSize = sizeof(sp_v3);

    return (::CreatePropertySheetPage(&sp_v3));
}




// Menu Helper
HRESULT
_InsertMenuHelper(
   LPCONTEXTMENUCALLBACK piCallback,       
   long                  lInsertionPointID,
   int                   index,
   BOOL                  fEnabled, /* = TRUE */
   BOOL                  fChecked /* = FALSE */)
{
   CONTEXTMENUITEM MenuItem;
   MenuItem.lInsertionPointID   = lInsertionPointID;
   MenuItem.fFlags              = (fEnabled ? 0 : MF_GRAYED) | 
                                  (fChecked ? MF_CHECKED : 0);
   MenuItem.fSpecialFlags       = 0;

   MenuItem.strName = const_cast<BSTR>(
     (LPCTSTR)g_MenuStrings[index] );
   MenuItem.strStatusBarText = const_cast<BSTR>(
     (LPCTSTR)g_StatusStrings[index] );
   MenuItem.lCommandID = index;

   return piCallback->AddItem( &MenuItem );
}

HRESULT
SchemaOpenObject
(
   PCWSTR pathName,
   REFIID  riid,
   void**  object
)
{

    return
    (
        AdminToolsOpenObject
        (
            const_cast<LPWSTR>((LPCWSTR) pathName),
            NULL,
            NULL,
            ADS_SECURE_AUTHENTICATION,
            riid,
            object
        )
     );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\select.cpp ===
//
// select.cpp : Implementation of the common select dialog.
//
// Cory West <corywest@microsoft.com>
// Copyright (c) Microsoft Corporation 1997
//

#include "stdafx.h"

#include "macros.h"
USE_HANDLE_MACROS("SCHMMGMT(compdata.cpp)")

#include "schmutil.h"
#include "cache.h"
#include "select.h"
#include "resource.h"



const DWORD CSchmMgmtSelect::help_map[] =
{
    IDC_SCHEMA_LIST, IDH_SCHEMA_LIST,
    0,0
};



BEGIN_MESSAGE_MAP(CSchmMgmtSelect, CDialog)
   ON_MESSAGE(WM_HELP, OnHelp)
   ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
   ON_LBN_DBLCLK(IDC_SCHEMA_LIST, OnDblclk)
END_MESSAGE_MAP()



CSchmMgmtSelect::CSchmMgmtSelect(
    ComponentData *pScope,
    SELECT_TYPE st,
    SchemaObject **pSchemaObject
) :
    CDialog(IDD_SCHEMA_SELECT, NULL),
    fDialogLoaded( FALSE ),
    SelectType( st ),
    pSchemaTarget( pSchemaObject ),
    pScopeControl( pScope )
{
    ASSERT( NULL != pScopeControl );
}



CSchmMgmtSelect::~CSchmMgmtSelect()
{ ; }



void
CSchmMgmtSelect::DoDataExchange(
    CDataExchange *pDX
) {

    HWND hSelect;
    SchemaObject *pObject, *pHead;
    LRESULT strIndex;
    WPARAM wStrIndex;

    CDialog::DoDataExchange( pDX );

    hSelect = ::GetDlgItem( m_hWnd, IDC_SCHEMA_LIST );

    if ( !pDX->m_bSaveAndValidate &&
         !fDialogLoaded ) {

        //
        // Load the select box.
        //

        if ( hSelect != NULL ) {

            ::SendMessage( hSelect, LB_RESETCONTENT, 0, 0 );

            if ( SelectType == SELECT_CLASSES || 
                SelectType == SELECT_AUX_CLASSES) {

                //
                // Insert the sorted classes.
                //

                pObject = pScopeControl->g_SchemaCache.pSortedClasses;
                ASSERT( pObject != NULL );

                pHead = pObject;

                if( pHead )
                {
                    do {
                        // if not defunct & if selecting only Aux, is this an aux class.
                        if ( pObject->isDefunct == FALSE &&
                              ( SelectType != SELECT_AUX_CLASSES ||
                                pObject->dwClassType == 0        ||
                                pObject->dwClassType == 3  )
                            ) {

                            strIndex = ::SendMessage( hSelect, LB_ADDSTRING, 0,
                                reinterpret_cast<LPARAM>( (LPCTSTR)pObject->ldapDisplayName) );

                            if ( ( strIndex != LB_ERR ) &&
                                 ( strIndex != LB_ERRSPACE ) ) {

                                //
                                // The insert was successful.  Associate the pointer.
                                //

                                wStrIndex = strIndex;

                                ::SendMessage( hSelect, LB_SETITEMDATA, wStrIndex,
                                    reinterpret_cast<LPARAM>( pObject ) );

                            }
                        }

                        pObject = pObject->pSortedListFlink;

                    } while ( pObject != pHead );
                }

            } else {

                //
                // Insert the sorted attributes.
                //

                pObject = pScopeControl->g_SchemaCache.pSortedAttribs;
                ASSERT( pObject != NULL );

                pHead = pObject;

                do {

                    if ( pObject->isDefunct == FALSE ) {

                        strIndex = ::SendMessage( hSelect, LB_ADDSTRING, 0,
                            reinterpret_cast<LPARAM>( (LPCTSTR)pObject->ldapDisplayName ) );

                        if ( ( strIndex != LB_ERR ) &&
                             ( strIndex != LB_ERRSPACE ) ) {

                            //
                            // The insert was successful.  Associate the pointer.
                            //

                            wStrIndex = strIndex;

                            ::SendMessage( hSelect, LB_SETITEMDATA, wStrIndex,
                                reinterpret_cast<LPARAM>( pObject ) );

                        }
                    }

                    pObject = pObject->pSortedListFlink;

                } while ( pObject != pHead );

            }

            ::SendMessage( hSelect, LB_SETCURSEL, 0, 0 );
        }

        fDialogLoaded = TRUE;
    }

    //
    // Figure out which one was selected.
    //

    if ( pSchemaTarget ) {
        strIndex = ::SendMessage( hSelect, LB_GETCURSEL, 0, 0 );
        *pSchemaTarget = reinterpret_cast<SchemaObject*>(
            ::SendMessage( hSelect, LB_GETITEMDATA, strIndex, 0 ) );
    }

    return;
}



void CSchmMgmtSelect::OnDblclk() 
{
    OnOK();
}



CSchemaObjectsListBox::CSchemaObjectsListBox() :
    m_pScope                ( NULL           ),
    m_stType                ( SELECT_CLASSES ),
    m_nRemoveBtnID          ( 0              ),
    m_pstrlistUnremovable   ( NULL           ),
    m_nUnableToDeleteID     ( 0              ),
    m_fModified             ( FALSE          )

{
}


CSchemaObjectsListBox::~CSchemaObjectsListBox()
{
    POSITION pos = m_stringList.GetHeadPosition();

    while( pos != NULL )
    {
        delete m_stringList.GetNext( pos );
    }

    m_stringList.RemoveAll();
}


void CSchemaObjectsListBox::InitType(
                              ComponentData * pScope,
                              SELECT_TYPE     stType,               /* = SELECT_CLASSES*/
                              int             nRemoveBtnID,         /* = 0*/
                              CStringList   * pstrlistUnremovable,  /* = NULL*/
                              int             nUnableToDeleteID)    /* = 0*/
{
    ASSERT( pScope );
    
    // if nUnableToDeleteID is present, pstrlistUnremovable cannot be NULL
    ASSERT( nUnableToDeleteID ? NULL != pstrlistUnremovable : TRUE  );
    
    m_pScope                = pScope;
    m_stType                = stType;
    m_nRemoveBtnID          = nRemoveBtnID;
    m_pstrlistUnremovable   = pstrlistUnremovable;
    m_nUnableToDeleteID     = nUnableToDeleteID;
}



//
// Add a new object to the listbox.
//

BOOL CSchemaObjectsListBox::AddNewObjectToList( void )
{
    CThemeContextActivator activator;

    ASSERT( m_pScope );     // initialized??

    SchemaObject  * pClass      = NULL;
    BOOL            fModified   = FALSE;

    //
    // Start the common select dialog box.
    //

    CSchmMgmtSelect dlgSelectDialog( m_pScope, m_stType, &pClass );

    //
    // When this returns, the class schema object pointer
    // will be filled into pClass.
    //
    
    if ( IDOK == dlgSelectDialog.DoModal() && pClass != NULL )
    {
        //
        // If it is not already present, add and select it.
        // If it is already present, just select it.
        //
        
        int iItem = FindStringExact( -1, pClass->ldapDisplayName );
        
        if (LB_ERR == iItem)
        {
            
            iItem = FindStringExact( -1, pClass->oid );
            
            if ( LB_ERR == iItem )
            {
                iItem = AddString( pClass->ldapDisplayName );
                ASSERT( LB_ERR != iItem );
                
                CString * pstr = new CString( pClass->oid );
                ASSERT( pstr );
                
                m_stringList.AddTail( pstr );
                VERIFY( LB_ERR != SetItemDataPtr( iItem, static_cast<void *>(pstr) ) );

                SetModified();
                fModified = TRUE;
            }
        }
        
        iItem = SetCurSel( iItem );
        ASSERT( LB_ERR != iItem );
        OnSelChange();
    }

    return fModified;
}



BOOL CSchemaObjectsListBox::RemoveListBoxItem( void )
{
    ASSERT(m_pScope); 

    int i = GetCurSel();
    ASSERT( LB_ERR != i );
    
    if( LB_ERR != i )
    {
        // if there is an oid string allocated, delete it.
        CString * pstr = reinterpret_cast<CString *>( GetItemDataPtr( i ) );
        ASSERT( INVALID_POINTER != pstr );

        if( pstr && INVALID_POINTER != pstr )
        {
            ASSERT( m_stringList.Find( pstr ) );
            m_stringList.RemoveAt( m_stringList.Find(pstr) );
            delete pstr;
        }

        VERIFY( LB_ERR != DeleteString( i ) );

        
        int nElems = GetCount();
        ASSERT( LB_ERR != nElems );

        if( nElems > 0 )
        {                   // if not last item, move forward, otherwise, go to last.
            VERIFY( LB_ERR != SetCurSel( i < nElems ? i : nElems - 1 ) );
        }

        SetModified();
        OnSelChange();
        return TRUE;
    }
    else
    {
        ASSERT( FALSE );    // remove btn should've been disabled
        OnSelChange();
        return FALSE;
    }
}



void CSchemaObjectsListBox::OnSelChange( void )
{
    ASSERT(m_pScope);
    ASSERT( GetParent() );

    int iItemSelected   = GetCurSel();
    BOOL fEnableRemove  = (LB_ERR != iItemSelected);
    
    if (fEnableRemove && m_pstrlistUnremovable)
    {
        // determine if object is in the exception list
        CString strItemSelected;
        GetText( iItemSelected, strItemSelected );
        
        // here the case sensitive search is enough
        // only items from the DS are added, no user input
        if ( m_pstrlistUnremovable->Find( strItemSelected ) )
        {
            fEnableRemove = FALSE;
        }

        // if we have a warning control, show/hide it.
        if( m_nUnableToDeleteID )
        {
            ASSERT( GetParent()->GetDlgItem( m_nUnableToDeleteID ) );
            GetParent()->GetDlgItem( m_nUnableToDeleteID )->ShowWindow( !fEnableRemove );
        }
    }

    if( m_nRemoveBtnID )
    {
         // NTRAID#NTBUG9-477267-2001/10/19-lucios 
         CWnd *remove = GetParent()->GetDlgItem( m_nRemoveBtnID );
         ASSERT(remove != NULL);
         if(fEnableRemove) remove->EnableWindow(true);
         else
         {
            // so that we don't disable the current 
            // focused window
            if (GetFocus()==remove)
            {
               CDialog *father=(CDialog*)remove->GetParent();
               ASSERT(father != NULL);
               CWnd *prev=father->GetNextDlgTabItem(remove,true);
               ASSERT(prev != NULL);
               father->GotoDlgCtrl(prev);
            }
            remove->EnableWindow(false);
         }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\select.h ===
#ifndef _SELECT_H_INCLUDED
#define _SELECT_H_INCLUDED


//
// The common select dialog.
//

#include "cookie.h"
#include "cache.h"
#include "compdata.h"

typedef enum _SELECT_TYPE {
    SELECT_CLASSES=0,
    SELECT_ATTRIBUTES,
    SELECT_AUX_CLASSES
} SELECT_TYPE;

class CSchmMgmtSelect : public CDialog
{
   public:

   CSchmMgmtSelect( ComponentData *pScope,
                  SELECT_TYPE st=SELECT_CLASSES,
                  SchemaObject **pSchemaObject=NULL );

   ~CSchmMgmtSelect();

   BOOL fDialogLoaded;
   SELECT_TYPE SelectType;
   SchemaObject **pSchemaTarget;

   ComponentData *pScopeControl;

   virtual void DoDataExchange( CDataExchange *pDX );


   static const DWORD help_map[];

   BOOL         OnHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, FALSE ); };
   BOOL         OnContextHelp(WPARAM wParam, LPARAM lParam) { return ShowHelp( GetSafeHwnd(), wParam, lParam, help_map, TRUE ); };

   afx_msg void OnDblclk();

   DECLARE_MESSAGE_MAP()
};


class CSchemaObjectsListBox : public CListBox
{
private:
    ComponentData * m_pScope;
    SELECT_TYPE     m_stType;
    int             m_nRemoveBtnID;
    CStringList   * m_pstrlistUnremovable;
    int             m_nUnableToDeleteID;

    BOOL            m_fModified;

    CPtrList        m_stringList;

public:

    CSchemaObjectsListBox();
    virtual ~CSchemaObjectsListBox();

    void InitType( ComponentData * pScope,
                   SELECT_TYPE     stType               = SELECT_CLASSES,
                   int             nRemoveBtnID         = 0,
                   CStringList   * pstrlistUnremovable  = NULL,
                   int             nUnableToDeleteID    = 0 );

    BOOL AddNewObjectToList( void );
    BOOL RemoveListBoxItem( void );

    void OnSelChange( void );

    BOOL IsModified( void )                     { ASSERT(m_pScope); return m_fModified; }
    void SetModified( BOOL fModified = TRUE )   { ASSERT(m_pScope); m_fModified = fModified; }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED_)
#define AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//
// Disable warnings that will fail in retail mode
//
#ifndef DBG

#pragma warning (disable: 4189 4100)

#endif // DBG

#define STRICT

extern "C"
{
    #include <nt.h>         // SE_TAKE_OWNERSHIP_PRIVILEGE, etc
    #include <ntrtl.h>
    #include <nturtl.h>
}
#undef ASSERT
#undef ASSERTMSG

#include <afxwin.h>
#include <afxdisp.h>
#include <afxtempl.h> // CTypedPtrList
#include <afxdlgs.h>  // CPropertyPage
#include <activeds.h>   // ADS Stuff
#include <iadsp.h>
#include <dsgetdc.h>
#include <lm.h>
#include <sddl.h>
#include <ntdsapi.h>
#include <ntldap.h>
#include <aclui.h>
#include <windowsx.h>

#include <dssec.h> // private\inc
#include <comstrm.h>

// #define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include "dbg.h"
#include "mmc.h"
#include "schmmgmt.h"
#include "helpids.h"
#include "guidhelp.h" // ExtractData

EXTERN_C const CLSID CLSID_SchmMgmt;

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <dscmn.h>
#include <shlobj.h>
#include <dsclient.h>
#include <dsadminp.h> // DS Admin utilities

#include "MyBasePathsInfo.h"
//
// Display context sensitive help
//
// This function is implemented in SchmUtil.cpp.  Declared here due to the wide usage
//
BOOL
ShowHelp( HWND hParent, WPARAM wParam, LPARAM lParam, const DWORD ids[], BOOL fContextMenuHelp );


#ifdef _DEBUG
  #define SHOW_EXT_LDAP_MSG
#endif //_DEBUG


#ifndef BREAK_ON_FAILED_HRESULT
#define BREAK_ON_FAILED_HRESULT(hr)                               \
   if (FAILED(hr))                                                \
   {                                                              \
      break;                                                      \
   }
#endif  // BREAK_ON_FAILED_HRESULT


#ifndef ASSERT_BREAK_ON_FAILED_HRESULT
#define ASSERT_BREAK_ON_FAILED_HRESULT(hr)                        \
   if (FAILED(hr))                                                \
   {                                                              \
      ASSERT( FALSE );                                            \
      break;                                                      \
   }
#endif  // ASSERT_BREAK_ON_FAILED_HRESULT


#ifndef BREAK_ON_FAILED_HRESULT_AND_SET
#define BREAK_ON_FAILED_HRESULT_AND_SET(hr,newHr)                 \
   if (FAILED(hr))                                                \
   {                                                              \
      hr = (newHr);                                               \
      break;                                                      \
   }
#endif  // BREAK_ON_FAILED_HRESULT_AND_SET


#ifndef NO_HELP
  #define NO_HELP (static_cast<DWORD>(-1))
#endif //NO_HELP


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\schmutil.h ===
/****

SchmUtil.h

Various common utility routines for the Schema Editor Snap-In.

****/


#include "cache.h"
#include "cookie.h"
#include "select.h"
#include <shfusion.h>

#ifndef __SCHMUTIL_H_INCLUDED__
#define __SCHMUTIL_H_INCLUDED__



//
//	uncomment to enable the negative numbers support
//
#define ENABLE_NEGATIVE_INT



// Returns the full pathname of the .hlp file for this snapin

CString
GetHelpFilename();


//
// The global list of class scope cookies.
//

class CCookieListEntry {

public:

    CCookieListEntry() :
        pCookie( NULL ),
        pNext( this ),
        pBack( this ) { ; }

    ~CCookieListEntry() { ; }

    Cookie *pCookie;
    HSCOPEITEM hScopeItem;

    CCookieListEntry *pNext;
    CCookieListEntry *pBack;
};



class CCookieList
{
   public:

   CCookieList() :
     pHead( NULL ),
     pParentCookie( NULL ) { ; }

   ~CCookieList() { DeleteAll(); }

   VOID AddCookie( Cookie *pCookie,
                 HSCOPEITEM hScope );

   VOID InsertSortedDisplay( ComponentData *pScopeControl,
                           SchemaObject *pNewClass );

   bool DeleteCookie(Cookie* pCookie);

   void
   DeleteAll();

   //
   // Data members.
   //

   Cookie *pParentCookie;
   HSCOPEITEM hParentScopeItem;

   CCookieListEntry *pHead;

   //
   // We provide no functions to walk this list.  The
   // user of this list has to walk it manually.
   //
};


//
// Some schema magic numbers.
//

#define CLASS_TYPE_88           0
#define CLASS_TYPE_STRUCTURAL   1
#define CLASS_TYPE_ABSTRACT     2
#define CLASS_TYPE_AUXILIARY    3

#define ATTRIBUTE_OPTIONAL      1
#define ATTRIBUTE_MANDATORY     2

//
// Global DS class and attribute strings.
//

extern LPWSTR g_DisplayName;
extern LPWSTR g_ClassFilter;
extern LPWSTR g_AttributeFilter;
extern LPWSTR g_Description;
extern LPWSTR g_MayContain;
extern LPWSTR g_MustContain;
extern LPWSTR g_SystemMayContain;
extern LPWSTR g_SystemMustContain;
extern LPWSTR g_AuxiliaryClass;
extern LPWSTR g_SystemAuxiliaryClass;
extern LPWSTR g_SubclassOf;
extern LPWSTR g_ObjectClassCategory;
extern LPWSTR g_ObjectClass;
extern LPWSTR g_CN;
extern LPWSTR g_ClassSearchRequest;
extern LPWSTR g_AttribSearchRequest;
extern LPWSTR g_omSyntax;
extern LPWSTR g_AttributeSyntax;
extern LPWSTR g_omObjectClass;
extern LPWSTR g_SystemOnly;
extern LPWSTR g_Superiors;
extern LPWSTR g_SystemSuperiors;
extern LPWSTR g_GlobalClassID;
extern LPWSTR g_GlobalAttributeID;
extern LPWSTR g_RangeUpper;
extern LPWSTR g_RangeLower;
extern LPWSTR g_ShowInAdvViewOnly;
extern LPWSTR g_IsSingleValued;
extern LPWSTR g_IndexFlag;
extern LPWSTR g_UpdateSchema;
extern LPWSTR g_isDefunct;
extern LPWSTR g_GCReplicated;
extern LPWSTR g_DefaultAcl;
extern LPWSTR g_DefaultCategory;
extern LPWSTR g_systemFlags;
extern LPWSTR g_fsmoRoleOwner;
extern LPWSTR g_allowedChildClassesEffective;
extern LPWSTR g_allowedAttributesEffective;

//
// *******************************************************************
// These are loaded from the resources as they need to be localizable.
// *******************************************************************
//

//
// Global strings for our static nodes.
//

extern CString g_strSchmMgmt;
extern CString g_strClasses;
extern CString g_strAttributes;

//
// Strings for various object types.
//

extern CString g_88Class;
extern CString g_StructuralClass;
extern CString g_AuxClass;
extern CString g_AbstractClass;
extern CString g_MandatoryAttribute;
extern CString g_OptionalAttribute;
extern CString g_Yes;
extern CString g_No;
extern CString g_Unknown;
extern CString g_Defunct;
extern CString g_Active;

//
// Message strings.
//

extern CString g_NoDescription;
extern CString g_NoName;
extern CString g_MsgBoxErr;
extern CString g_MsgBoxWarn;

//
// Utility function declarations.
//

void
LoadGlobalCookieStrings(
);

VOID
DebugTrace(
    LPWSTR Format,
    ...
);

INT
DoErrMsgBox(
    HWND hwndParent,
    BOOL fError,
    UINT wIdString,
    HRESULT hr = S_OK
);

INT
DoErrMsgBox(
    HWND hwndParent,
    BOOL fError,
    PCWSTR pszError,
    HRESULT hr = S_OK
);

VOID
DoExtErrMsgBox(
    VOID
);


// INVALID_POINTER is returned by CListBox::GetItemDataPtr() in case of an error.
extern const VOID * INVALID_POINTER;


// add items from the VT_ARRAY|VT_BSTR variant to the listbox
HRESULT
InsertEditItems(
    HWND hwnd,
    VARIANT *AdsResult
);

// as above but takes a CListBox&
inline HRESULT
InsertVariantEditItems(
    CListBox& refListBox,
    VARIANT *AdsResult
)
{
        return InsertEditItems( refListBox.m_hWnd, AdsResult );
}

// add items from stringlist to the listbox
HRESULT
InsertEditItems(
    CListBox& refListBox,
    CStringList& refstringlist
);

// Add items from the listbox to the stringlist, skipping those
//  from the exclusion stringlist if one is present
HRESULT
RetrieveEditItemsWithExclusions(
    CListBox& refListBox,
    CStringList& refstringlist,
        CStringList* pstringlistExclusions = NULL
);

// Helper function for octet string comparisson
BOOL
IsEqual( ADS_OCTET_STRING * ostr1, ADS_OCTET_STRING * ostr2 );

UINT
GetSyntaxOrdinal(
    PCTSTR attributeSyntax, UINT omSyntax, ADS_OCTET_STRING * omObjectClass
);

// add items from the VT_ARRAY|VT_BSTR variant to the stringlist
HRESULT
VariantToStringList(
    VARIANT& refvar,
        CStringList& refstringlist
);

// Creates a new VT_ARRAY|VT_BSTR variant from the stringlist
HRESULT
StringListToVariant(
    VARIANT& refvar,
        CStringList& refstringlist
);

HRESULT
StringListToColumnList(
    ComponentData* pScopeControl,
    CStringList& refstringlist,
    ListEntry **ppNewList
);

//
// The menu command ids.
//

enum MENU_COMMAND
{
   CLASSES_CREATE_CLASS = 0,
   ATTRIBUTES_CREATE_ATTRIBUTE,
   SCHEMA_RETARGET,
   SCHEMA_EDIT_FSMO,
   SCHEMA_REFRESH,
   SCHEMA_SECURITY,
   NEW_CLASS,
   NEW_ATTRIBUTE,
   VIEW_DEFUNCT_OBJECTS,
   MENU_LAST_COMMAND
};

//
// The menu strings.
//

extern CString g_MenuStrings[MENU_LAST_COMMAND];
extern CString g_StatusStrings[MENU_LAST_COMMAND];



//
// Schema Object Syntax Descriptor class
//

class CSyntaxDescriptor
{
public:
	CSyntaxDescriptor(	UINT	nResourceID,
						BOOL	fIsSigned,				// Should the range be signed or unsigned number?
						BOOL	fIsANRCapable,
						PCTSTR	pszAttributeSyntax,
						UINT	nOmSyntax,
						DWORD	dwOmObjectClass,
						LPBYTE	pOmObjectClass ) :
				m_nResourceID(nResourceID),
				m_fIsSigned(fIsSigned),
				m_fIsANRCapable(fIsANRCapable),
				m_pszAttributeSyntax(pszAttributeSyntax),
				m_nOmSyntax(nOmSyntax)
	{
		ASSERT( nResourceID );
		ASSERT( (!pszAttributeSyntax && !nOmSyntax) ||		// either both are given
				(pszAttributeSyntax && nOmSyntax) );		// or both are 0

		ASSERT( (!dwOmObjectClass && !pOmObjectClass) ||	// either both are given
				(dwOmObjectClass && pOmObjectClass) );		// or both are 0

		m_octstrOmObjectClass.dwLength = dwOmObjectClass;
		m_octstrOmObjectClass.lpValue = pOmObjectClass;
	};     

   UINT              m_nResourceID;
   BOOL              m_fIsSigned;
   BOOL              m_fIsANRCapable;
   PCTSTR            m_pszAttributeSyntax;
   UINT              m_nOmSyntax;
   ADS_OCTET_STRING  m_octstrOmObjectClass;
   CString           m_strSyntaxName;
};

extern CSyntaxDescriptor g_Syntax[];
extern const UINT SCHEMA_SYNTAX_UNKNOWN;

extern const LPWSTR g_UINT32_FORMAT;
extern const LPWSTR g_INT32_FORMAT;

//
// ADS Provider Specific Extended Error
//

const HRESULT ADS_EXTENDED_ERROR = HRESULT_FROM_WIN32(ERROR_EXTENDED_ERROR);


CString
GetErrorMessage( HRESULT hr, BOOL fTryADSIExtError = FALSE );

HRESULT
GetLastADsError( HRESULT hr, CString& refErrorMsg, CString& refName );

//
// string to dword conversion utils, verification, etc.
//

const DWORD cchMinMaxRange = 11;   // the largest numbers possible in the Range settings
const DWORD cchMaxOID      = 1024;

const BOOL		GETSAFEINT_ALLOW_CANCEL	= TRUE;
const HRESULT	S_VALUE_MODIFIED		= S_FALSE;
const WCHAR		g_chSpace				= TEXT(' ');
const WCHAR		g_chNegativeSign		= TEXT('-');
const WCHAR		g_chPeriod      		= TEXT('.');


void DDXV_VerifyAttribRange( CDataExchange *pDX, BOOL fIsSigned,
								UINT idcLower, CString & strLower,
								UINT idcUpper, CString & strUpper );

INT64 DDXV_SigUnsigINT32Value( CDataExchange *pDX, BOOL fIsSigned,
						UINT idc, CString & str );

HRESULT GetSafeSignedDWORDFromString( CWnd * pwndParent, DWORD & lDst, CString & strSrc,
										BOOL fIsSigned, BOOL fAllowCancel = FALSE);

HRESULT GetSafeINT32FromString( CWnd * pwndParent, INT64 & llDst, CString & strSrc,
								BOOL fIsSigned, BOOL fAllowCancel);


BOOL IsValidNumber32( INT64 & llVal, BOOL fIsSigned );
BOOL IsValidNumberString( CString & str );

inline BOOL IsCharNumeric( WCHAR ch )
{
	return IsCharAlphaNumeric( ch ) && !IsCharAlpha( ch );
}


/////////////////////////////////////////////////////////////////////////////
// CParsedEdit is a specialized CEdit control that only allows characters
//  of the number type ( signed/unsigned can be set dynamically )
//  originally from the MFC samples

class CParsedEdit : public CEdit
{
public:
    enum EditType
    {
        EDIT_TYPE_INVALID = 0,  // should never be used, must be the first type
        EDIT_TYPE_GENERIC,
        EDIT_TYPE_INT32,
        EDIT_TYPE_UINT32,
        EDIT_TYPE_OID,
        EDIT_TYPE_LAST          // should never be used, must be the last type
    };

private:
    EditType    m_editType;

public:
	// Construction
	CParsedEdit( EditType et )                  { SetEditType( et ); }



    // subclassed construction
	BOOL        SubclassEdit(   UINT nID,
                                CWnd* pParent,
                                int cchMaxTextSize );     // 0 == unlimited


    // Edit box type
protected:
    static BOOL IsNumericType( EditType et )    { return EDIT_TYPE_INT32 == et || EDIT_TYPE_UINT32 == et; }
    static BOOL IsValidEditType( EditType et )  { return EDIT_TYPE_INVALID < et && et < EDIT_TYPE_LAST; }
    BOOL        IsInitialized() const           { return IsValidEditType( m_editType ); }

    // can the current type be changed to et?
    BOOL        IsCompatibleType( EditType et ) { ASSERT( IsValidEditType( et ) );
                                                  return !IsInitialized()       ||          // everything is ok
                                                         et == GetEditType()    ||          // no change
                                                          ( IsNumericType(GetEditType()) && // allow sign/unsign
                                                            IsNumericType(et)) ; }          // switch

    void        SetEditType( EditType et )      { ASSERT( IsValidEditType(et) );
                                                  ASSERT( IsCompatibleType(et) );
                                                  m_editType = et; }

public:
    EditType    GetEditType() const             { ASSERT( IsInitialized() );                // initialized?
                                                  return m_editType; }

	// IsSigned access functions
    BOOL        FIsSigned() const               { ASSERT( IsNumericType(GetEditType()) );
                                                  return EDIT_TYPE_INT32 == GetEditType(); }

    void        SetSigned( BOOL fIsSigned )     { ASSERT( IsInitialized() );
                                                  SetEditType( fIsSigned ? EDIT_TYPE_INT32 : EDIT_TYPE_UINT32 ); }


// Implementation
protected:
	//{{AFX_MSG(CParsedEdit)
	afx_msg void OnChar(UINT, UINT, UINT); // for character validation
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


///////////////////////////////////////////////////////////////////////////////
//  Search a list of PCTSTR for a strValue, returns TRUE if found
//      rgszList[] last element must be NULL
//
//  puIndex - optional pointer, will be set to the position of the value if found.
//
BOOL IsInList( PCTSTR rgszList[], const CString & strValue, UINT * puIndex = NULL );

//
//  Determine if the object pointed to by pIADsObject is category 1 object.
//
HRESULT IsCategory1Object( IADs *pIADsObject, BOOL & fIsCategory1 );

//
//  Determine if the object pointed to by pIADsObject is a constructed object.
//
HRESULT IsConstructedObject( IADs *pIADsObject, BOOL & fIsConstructed );

//
//  Read object's System Attribute
//
HRESULT GetSystemAttributes( IADs *pIADsObject, LONG &fSysAttribs );


//
//
//
class CDialogControlsInfo
{
public:
    UINT    m_nID;
    LPCTSTR m_pszAttributeName;
    BOOL    m_fIsEditBox;
};


HRESULT DissableReadOnlyAttributes( CWnd * pwnd, IADs *pIADsObject, const CDialogControlsInfo * pCtrls, UINT cCtrls );

HRESULT GetStringListElement( IADs *pIADsObject, LPWSTR *lppPathNames, CStringList &strlist );

//
// Validate an OID string format
//
bool OIDHasValidFormat (PCWSTR pszOidValue, int& rErrorTypeStrID);


HRESULT DeleteObject( const CString& path, Cookie* pcookie, PCWSTR pszClass);



////////////////////////////////////////////////////////////////////////////////////
// Theme support

class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
        { SHActivateContext (&m_ulActivationCookie); }

    ~CThemeContextActivator()
        { SHDeactivateContext (m_ulActivationCookie); }

private:
    ULONG_PTR m_ulActivationCookie;
};

HRESULT
_InsertMenuHelper(
   LPCONTEXTMENUCALLBACK piCallback,       
   long                  lInsertionPointID,
   int                   index,
   BOOL                  fEnabled = TRUE,
   BOOL                  fChecked = FALSE );

#ifdef UNICODE
#define PROPSHEETPAGE_V3 PROPSHEETPAGEW_V3
#else
#define PROPSHEETPAGE_V3 PROPSHEETPAGEA_V3
#endif

HRESULT
SchemaOpenObject
(
   PCWSTR pathName,
   REFIID  riid,
   void**  object
);

HPROPSHEETPAGE MyCreatePropertySheetPage(AFX_OLDPROPSHEETPAGE* psp);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\uuids.h ===
//
// Nodetypes for the Schema Management snap in.
// Created by UUIDGEN 5/13/97 CoryWest.
//

//
// These are the guids for the node types in the schema management
// snap in.  These node types have to correspond to the node enum
// types that are used in the cookies.  The mapping table between
// the enum types and the guids is in cookie.cpp and cookie.h.
//

#ifndef _UUIDS_SCHEMA_MANAGEMENT_
#define _UUIDS_SCHEMA_MANAGEMENT_

#define strUuidNodetypeSchmMgmt                 "{3d7b8f72-cd87-11d0-9c19-00c04fd8d86e}"
#define strUuidNodetypeClasses                  "{c880afb6-cbd5-11d0-9c15-00c04fd8d86e}"
#define strUuidNodetypeAttributes               "{0d5fbd84-cbd6-11d0-9c15-00c04fd8d86e}"
#define strUuidNodetypeDisplaySpecifiers        "{18669dc4-cbd6-11d0-9c15-00c04fd8d86e}"
#define strUuidNodetypeClass                    "{23a6b674-cbd6-11d0-9c15-00c04fd8d86e}"
#define strUuidNodetypeAttribute                "{2d7c69b4-cbd6-11d0-9c15-00c04fd8d86e}"
#define strUuidNodetypeDisplaySpecifier         "{37cbb4e2-cbd6-11d0-9c15-00c04fd8d86e}"

#define lstrUuidNodetypeSchmMgmt                L"{3d7b8f72-cd87-11d0-9c19-00c04fd8d86e}"
#define lstrUuidNodetypeClasses                 L"{c880afb6-cbd5-11d0-9c15-00c04fd8d86e}"
#define lstrUuidNodetypeAttributes              L"{0d5fbd84-cbd6-11d0-9c15-00c04fd8d86e}"
#define lstrUuidNodetypeDisplaySpecifiers       L"{18669dc4-cbd6-11d0-9c15-00c04fd8d86e}"
#define lstrUuidNodetypeClass                   L"{23a6b674-cbd6-11d0-9c15-00c04fd8d86e}"
#define lstrUuidNodetypeAttribute               L"{2d7c69b4-cbd6-11d0-9c15-00c04fd8d86e}"
#define lstrUuidNodetypeDisplaySpecifier        L"{37cbb4e2-cbd6-11d0-9c15-00c04fd8d86e}"

#define structUuidNodetypeSchmMgmt              \
    { 0x3d7b8f72, 0xcd87, 0x11d0, { 0x9c, 0x15, 0x0, 0xc0, 0x4f, 0xd8, 0xd8, 0x6e } }

#define structUuidNodetypeClasses               \
    { 0xc880afb6, 0xcbd5, 0x11d0, { 0x9c, 0x15, 0x0, 0xc0, 0x4f, 0xd8, 0xd8, 0x6e } }
#define structUuidNodetypeAttributes            \
    { 0x0d5fbd84, 0xcbd6, 0x11d0, { 0x9c, 0x15, 0x0, 0xc0, 0x4f, 0xd8, 0xd8, 0x6e } }
#define structUuidNodetypeDisplaySpecifiers     \
    { 0x18669dc4, 0xcbd6, 0x11d0, { 0x9c, 0x15, 0x0, 0xc0, 0x4f, 0xd8, 0xd8, 0x6e } }

#define structUuidNodetypeClass                 \
    { 0x23a6b674, 0xcbd6, 0x11d0, { 0x9c, 0x15, 0x0, 0xc0, 0x4f, 0xd8, 0xd8, 0x6e } }
#define structUuidNodetypeAttribute             \
    { 0x2d7c69b4, 0xcbd6, 0x11d0, { 0x9c, 0x15, 0x0, 0xc0, 0x4f, 0xd8, 0xd8, 0x6e } }
#define structUuidNodetypeDisplaySpecifier      \
    { 0x37cbb4e2, 0xcbd6, 0x11d0, { 0x9c, 0x15, 0x0, 0xc0, 0x4f, 0xd8, 0xd8, 0x6e } }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\wizinfo.cpp ===
#include "stdafx.h"
#include "wizinfo.hpp"



CreateClassWizardInfo::CreateClassWizardInfo()
   :
   cn(),
   ldapDisplayName(),
   oid(),
   description(),
   parentClass(),
   type(),
   strlistMandatory(),
   strlistOptional()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\snapmgr.h ===
// SnapMgr.h : header file for Snapin Manager property page
//

#ifndef __SNAPMGR_H__
#define __SNAPMGR_H__

#include "cookie.h"

// forward declarations
class ComponentData;

/////////////////////////////////////////////////////////////////////////////
// CSchmMgmtGeneral dialog

class CSchmMgmtGeneral : public CPropertyPage
{
        // DECLARE_DYNCREATE(CSchmMgmtGeneral)

// Construction
public:
        CSchmMgmtGeneral();
        ~CSchmMgmtGeneral();

        // load initial state into CSchmMgmtGeneral
        void Load( Cookie& refcookie );

// Dialog Data
        //{{AFX_DATA(CSchmMgmtGeneral)
        CString m_strMachineName;
        int m_iRadioObjectType;
        int     m_iRadioIsLocal;
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CSchmMgmtGeneral)
        public:
        virtual BOOL OnWizardFinish();
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CSchmMgmtGeneral)
        virtual BOOL OnInitDialog();
        afx_msg void OnRadioLocalMachine();
        afx_msg void OnRadioSpecificMachine();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

public:
        // User defined member variables        
        class ComponentData * m_pSchmMgmtData;
        BOOL m_fServiceDialog;

        // This mechanism deletes the CSchmMgmtGeneral when the property sheet is finished
        LPFNPSPCALLBACK m_pfnOriginalPropSheetPageProc;
        INT m_refcount;
        static UINT CALLBACK PropSheetPageProc(
                HWND hwnd,      
                UINT uMsg,      
                LPPROPSHEETPAGE ppsp );
};

#endif // ~__SNAPMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\schmmgmt\wizinfo.hpp ===
#ifndef WIZINFO_HPP_INCLUDED
#define WIZINFO_HPP_INCLUDED



class CreateClassWizardInfo
{
   public:

   CreateClassWizardInfo();

   // use default dtor   

   CString  cn;
   CString  ldapDisplayName;
   CString  oid;
   CString  description;
   CString  parentClass;
   int      type;

   CStringList strlistMandatory;
   CStringList strlistOptional;
};



#endif   // WIZINFO_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\sendcmsg\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       debug.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
//	Debug.h
//
#ifdef _DEBUG
	#define DEBUG
#endif

#ifdef DEBUG
	//
	// Debug code
	//
	#define DebugCode(x)	x
	int CchLoadString(UINT uIdString, WCHAR szBuffer[], int cchBuffer);
#else
	//
	// Retail code
	//
	#define DebugCode(x)
	#define GarbageInit(pv, cb)
	#define CchLoadString(uIdString, szBuffer, cchBuffer)	\
			::LoadString(g_hInstance, uIdString, szBuffer, cchBuffer)
#endif


#ifdef DEBUG
	/////////////////////////////////////////////
	void DoDebugAssert(PCWSTR pszFile, int nLine, PCWSTR pszExpr);
	#define Assert(f)	if (!(f)) { DoDebugAssert(_T(__FILE__), __LINE__, _T(#f)); } else { }
	#define Report(f)	Assert(f)
	#define Endorse(f)	if (f) { } else { }
	#define VERIFY(f)	Assert(f)

	/////////////////////////////////////////////
	void DebugTracePrintf(const WCHAR * szFormat, ...);
	#define Trace0(sz)				DebugTracePrintf(_T("%s"), _T(sz));
	#define Trace1(sz, p1)			DebugTracePrintf(_T(sz), p1);
	#define Trace2(sz, p1, p2)		DebugTracePrintf(_T(sz), p1, p2);
	#define Trace3(sz, p1, p2, p3)	DebugTracePrintf(_T(sz), p1, p2, p3);
	
#else
	#define Assert(f)
	#define Report(f)
	#define Endorse(f)
	#define VERIFY(f)	f

	#define Trace0(sz)
	#define Trace1(sz, p1)
	#define Trace2(sz, p1, p2)
	#define Trace3(sz, p1, p2, p3)

#endif // ~DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\sendcmsg\app.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       App.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
// App.h: Definition of the CSendConsoleMessageApp class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_APP_H__B1AFF7D1_0C49_11D1_BB12_00C04FC9A3A3__INCLUDED_)
#define AFX_APP_H__B1AFF7D1_0C49_11D1_BB12_00C04FC9A3A3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CSendConsoleMessageApp

class CSendConsoleMessageApp : 
	public ISendConsoleMessageApp,
	public IExtendContextMenu,
	public CComObjectRoot,
	public CComCoClass<CSendConsoleMessageApp,&CLSID_SendConsoleMessageApp>
{
public:
	CSendConsoleMessageApp() {}
BEGIN_COM_MAP(CSendConsoleMessageApp)
	COM_INTERFACE_ENTRY(ISendConsoleMessageApp)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CSendConsoleMessageApp) 

DECLARE_REGISTRY( CSendConsoleMessageApp,
                  _T("SENDCMSG.SendConsoleMessageApp.1"),
                  _T("SENDCMSG.SendConsoleMessageApp.1"),
                  IDS_SENDCONSOLEMESSAGEAPP_DESC,
                  THREADFLAGS_BOTH )

public:
// IExtendContextMenu
	STDMETHOD(AddMenuItems)(
		IN IDataObject * pDataObject,
		OUT	IContextMenuCallback * pContextMenuCallback,
		INOUT long * pInsertionAllowed);
	STDMETHOD(Command)(LONG lCommandID, IDataObject * pDataObject);

public:

}; // CSendConsoleMessageApp

#endif // !defined(AFX_APP_H__B1AFF7D1_0C49_11D1_BB12_00C04FC9A3A3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\sendcmsg\dialogs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       dialogs.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
//	Dialogs.h



/////////////////////////////////////////////////////////////////////
class CSendConsoleMessageDlg
{
  protected:
	HWND m_hdlg;					// Handle of the dialog
	HWND m_hwndEditMessageText;		// Handle of edit control for the message text
	HWND m_hwndListviewRecipients;	// Handle of the listview of the recipients
	HIMAGELIST m_hImageList;		// Image list for the listview control
	volatile int m_cRefCount;		// Reference count of object

  public:
	CSendConsoleMessageDlg();
	~CSendConsoleMessageDlg();
	static INT_PTR DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

  protected:
	void AddRef();
	void Release();
	
	void OnInitDialog(HWND hdlg, IDataObject * pDataObject);
	void OnOK();
	LRESULT OnNotify(NMHDR * pNmHdr);
	BOOL OnHelp(LPARAM lParam, int nDlgIDD);
    void DoContextHelp (HWND hWndControl, int nDlgIDD);
    void DoSendConsoleMessageContextHelp (HWND hWndControl);

  protected:
	int AddRecipient(PCWSTR pszRecipient, BOOL fSelectItem = FALSE);

	void UpdateUI();
	void EnableDlgItem(INT nIdDlgItem, BOOL fEnable);

  protected:
	// Dispatch info
	enum PROGRES_STATUS_ENUM
	{
		e_statusDlgInit = 1,	// Dialog is initializing
		e_statusDlgDispatching,	// Dialog is dispatching message to recipients
		e_statusDlgCompleted,	// The dialog completed the operation (with or without errors)
		e_statusUserCancel,		// The user clicked on the "Cancel" button
	};
	struct
	{
		PROGRES_STATUS_ENUM status;
		BYTE * pargbItemStatus;		// Array of boolean indicating the status of each recipient
		int cErrors;				// Number of errors while sending messages
		CRITICAL_SECTION cs;		// Synchronization object for the "status" variable
		volatile HWND hdlg;					// Handle of the "Progress Dialog"
		volatile HWND hctlStaticRecipient;
		volatile HWND hctlStaticMessageOf;
		volatile HWND hctlStaticErrors;
		volatile HWND hctlProgressBar;
	} m_DispatchInfo;
	void DispatchMessageToRecipients();
	static INT_PTR CALLBACK DlgProcDispatchMessageToRecipients(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
	static DWORD WINAPI ThreadProcDispatchMessageToRecipients(CSendConsoleMessageDlg * pThis);
}; // CSendConsoleMessageDlg


/////////////////////////////////////////////////////////////////////
class CSendMessageAdvancedOptionsDlg
{
  protected:
	HWND m_hdlg;
	BOOL m_fSendAutomatedMessage;

  public:
	static INT_PTR DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

  protected:
	void OnInitDialog(HWND hdlg);	
	void UpdateUI();
	BOOL OnHelp(LPARAM lParam);
}; // CSendMessageAdvancedOptionsDlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\sendcmsg\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       Debug.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
//  Debug.cpp

#include "stdafx.h"
#include "debug.h"
#include "util.h"
#include "StrSafe.h"

#ifdef DEBUG


#define DoBreakpoint()  DebugBreak()

void DoDebugAssert(PCWSTR pszFile, int nLine, PCWSTR pszExpr)
{
    if ( !pszFile || nLine < 0 || !pszExpr )
        return;

    // MSDN says itow returns a string of up to 33 wchars in length
    const size_t  MAX_INT_WIDTH = 33;
    PCWSTR  pwszFormat = L"Assertion: (%s)\nFile %s, line %d.";
    size_t cchFormat = 0;
    HRESULT hr = StringCchLength (pwszFormat, 1000, &cchFormat);
    if ( FAILED (hr) )
        return;

    size_t cchExpr = 0;
    hr = StringCchLength (pszExpr, 1000, &cchExpr);
    if ( FAILED (hr) )
        return;

    size_t cchFile = 0;
    hr = StringCchLength (pszFile, 1000, &cchFile);
    if ( FAILED (hr) )
        return;

    size_t cchBuf = cchFormat + cchExpr + cchFile + MAX_INT_WIDTH + 1;

    PWSTR   pwszBuf = new WCHAR[cchBuf];
    if ( pwszBuf )
    {
        hr = StringCchPrintf (pwszBuf, cchBuf, pwszFormat, pszExpr, pszFile, nLine);
        if ( SUCCEEDED (hr) )
        {
            int nRet = MessageBox(::GetActiveWindow(), pwszBuf, L"Send Console Message - Assertion Failed",
                MB_ABORTRETRYIGNORE | MB_ICONERROR);
            switch (nRet)
            {
            case IDABORT:
                DoBreakpoint();
                exit(-1);

            case IDRETRY:
                DoBreakpoint();
            }
        }
        delete [] pwszBuf;
    }

} // DoDebugAssert()

/////////////////////////////////////////////////////////////////////////////
void DebugTracePrintf(
        const WCHAR * szFormat, 
        ...)
{
    va_list arglist;
    const size_t BUF_LEN = 1024;
    WCHAR sz[BUF_LEN];

    Assert(szFormat != NULL);
    if ( !szFormat )
        return;

    va_start(arglist, szFormat);    
    // ISSUE convert to strsafe
    HRESULT hr = StringCchPrintf(OUT sz, BUF_LEN, szFormat, arglist);
    if ( SUCCEEDED (hr) )
    {
        Assert(wcslen(sz) < LENGTH(sz));
        sz[LENGTH(sz) - 1] = 0;  // Just in case we overflowed into sz
        ::OutputDebugString(sz);
    }
} // DebugTracePrintf()

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\sendcmsg\app.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       App.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
// App.cpp : Implementation of CSendConsoleMessageApp snapin

#include "stdafx.h"
#include "debug.h"
#include "util.h"
#include "resource.h"
#include "SendCMsg.h"
#include "dialogs.h"
#include "App.h"

// Menu IDs
#define cmSendConsoleMessage    100     // Menu Command Id to invoke the dialog

#if !defined(UNICODE)

#error This project requires UNICODE to be defined

#endif

#define IID_PPV_ARG(Type, Expr) IID_##Type, \
    reinterpret_cast<void**>(static_cast<Type **>(Expr))

/////////////////////////////////////////////////////////////////////
//  CSendConsoleMessageApp::IExtendContextMenu::AddMenuItems()
STDMETHODIMP 
CSendConsoleMessageApp::AddMenuItems(
    IN IDataObject * /*pDataObject*/,
    OUT IContextMenuCallback * pContextMenuCallback,
    INOUT long * /*pInsertionAllowed*/)
{
    HRESULT hr = S_OK;

    if ( !pContextMenuCallback )
        return E_POINTER;

    do {
        CComPtr<IContextMenuCallback2> spContextMenuCallback2;
        hr = pContextMenuCallback->QueryInterface (IID_PPV_ARG (IContextMenuCallback2, &spContextMenuCallback2));
        if ( FAILED (hr) )
            break;
        
        if ( !spContextMenuCallback2 )
        {
            hr = E_NOTIMPL;
            break;
        }

        CONTEXTMENUITEM cmiSeparator = { 0 };
        cmiSeparator.lInsertionPointID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
        cmiSeparator.fSpecialFlags = CCM_SPECIAL_SEPARATOR;
        hr = pContextMenuCallback->AddItem(IN &cmiSeparator);

        WCHAR szMenuItem[128];
        WCHAR szStatusBarText[256];
        CchLoadString(IDS_MENU_SEND_MESSAGE, OUT szMenuItem, LENGTH(szMenuItem));
        CchLoadString(IDS_STATUS_SEND_MESSAGE, OUT szStatusBarText, LENGTH(szStatusBarText));
        CONTEXTMENUITEM2 cmi = { 0 };
        cmi.lInsertionPointID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
        cmi.lCommandID = cmSendConsoleMessage;
        cmi.strName = szMenuItem;
        cmi.strStatusBarText = szStatusBarText;
        cmi.strLanguageIndependentName = L"_SENDCONSOLEMESSAGE"; // not to be localized
        hr = spContextMenuCallback2->AddItem(IN &cmi);
        if ( FAILED (hr) )
            break;

        hr = pContextMenuCallback->AddItem(IN &cmiSeparator);
    } while (0);

    return S_OK;
}


/////////////////////////////////////////////////////////////////////
//  CSendConsoleMessageApp::IExtendContextMenu::Command()
STDMETHODIMP
CSendConsoleMessageApp::Command(LONG lCommandID, IDataObject * pDataObject)
{
    if (lCommandID == cmSendConsoleMessage)
    {
        (void)DoDialogBox(
            IDD_SEND_CONSOLE_MESSAGE,
            ::GetActiveWindow(),
            CSendConsoleMessageDlg::DlgProc,
            (LPARAM)pDataObject);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\sendcmsg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sendcmsg.rc
//
#define IDS_CAPTION                     100
#define IDS_SENDCONSOLEMESSAGEAPP_DESC  101
#define IDB_BITMAP_COMPUTER             102
#define IDD_DISPATCH_MESSAGES           103
#define IDS_MENU_SEND_MESSAGE           105
#define IDS_STATUS_SEND_MESSAGE         106
#define IDD_SEND_CONSOLE_MESSAGE        130
#define IDD_ADVANCED_MESSAGE_OPTIONS    132
#define IDS_RECIPIENT_ALREADY_EXISTS    200
#define IDS_ERR_CANNOT_SEND_TO_ALL_RECIPIENTS 201
#define IDS_MESSAGE_COULD_NOT_BE_SENT   202
#define IDS_1_RECIPIENT_NOT_CONTACTED   203
#define IDS_RECIPIENT                   204
#define IDS_MESSAGE_STATUS              205
#define IDC_EDIT_MESSAGE_TEXT           900
#define IDC_LIST_RECIPIENTS             901
#define IDC_BUTTON_ADVANCED             902
#define IDC_BUTTON_ADD_RECIPIENT        903
#define IDC_BUTTON_REMOVE_RECIPIENT     904
#define IDC_STATIC_RESOURCE_NAME        1000
#define IDC_STATIC_SHUTDOWN_OCCURS      1001
#define IDC_STATIC_SHUTDOWN_OCCURS_UNIT 1002
#define IDC_STATIC_RESEND               1003
#define IDC_EDIT_RESOURCE_NAME          1004
#define IDC_EDIT_SHUTDOWN_OCCURS        1005
#define IDC_EDIT_RESEND                 1006
#define IDC_CHECK_SEND_AUTOMATED_MESSAGE 1007
#define IDC_EDIT_RESOURCE_BACK_ONLINE   1008
#define IDC_SPIN_SHUTDOWN_OCCURS        1009
#define IDC_SPIN_RESEND                 1010
#define IDC_STATIC_RESEND_UNIT          1011
#define IDC_STATIC_RESOURCE_BACK_ONLINE 1012
#define IDC_PROGRESS_MESSAGES           1013
#define IDC_STATIC_RECIPIENT            1014
#define IDC_STATIC_MESSAGE_OF           1015
#define IDC_STATIC_ERRORS_ENCOUNTERED   1016

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1019
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\sendcmsg\dialogs.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       Dialogs.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////
//      Dialogs.cpp
//
//      DlgProc for Send Console Message Snapin.
//
//      HISTORY
//      4-Aug-97    t-danm      Creation.
//      13 Feb 2001 bryanwal    Use object picker instead of add recipients 
//                              dialog
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <strsafe.h>
#include <objsel.h>
#include "debug.h"
#include "util.h"
#include "dialogs.h"
#include "resource.h"
#include <htmlhelp.h> //<mmc.h>

#if 1
    #define ThreadTrace0(sz)        Trace0(sz)
    #define ThreadTrace1(sz, p1)    Trace1(sz, p1)
#else
    #define ThreadTrace0(sz)
    #define ThreadTrace1(sz, p1)
#endif

const PCWSTR CONTEXT_HELP_FILE = L"sendcmsg.hlp";
const PCWSTR HTML_HELP_FILE = L"sendcmsg.chm";

// Register clipboard formats used by the Send Console Message
UINT g_cfSendConsoleMessageText = ::RegisterClipboardFormat(_T("mmc.sendcmsg.MessageText"));
UINT g_cfSendConsoleMessageRecipients = ::RegisterClipboardFormat(_T("mmc.sendcmsg.MessageRecipients"));

enum
{
    iImageComputer = 0,         // Generic image of a computer
    iImageComputerOK,
    iImageComputerError
};

// Maximum length of a recipient (machine name)
const int cchRECIPIENT_NAME_MAX = MAX_PATH;

enum
{
    COL_NAME = 0,
    COL_RESULT,
    NUM_COLS        // must be last
};

/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Generic Computer Picker
///////////////////////////////////////////////////////////////////////////////

//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForComputers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick a single computer object.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT InitObjectPickerForComputers(IDsObjectPicker *pDsObjectPicker)
{
    if ( !pDsObjectPicker )
        return E_POINTER;

    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int SCOPE_INIT_COUNT = 2;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(aScopeInit));

    //
    // 127399: JonN 10/30/00 JOINED_DOMAIN should be starting scope
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                         | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
    aScopeInit[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                         | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                         | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                         | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                         | DSOP_SCOPE_TYPE_WORKGROUP
                         | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                         | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
    aScopeInit[1].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
    aScopeInit[1].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  initInfo;
    ZeroMemory(&initInfo, sizeof(initInfo));

    initInfo.cbSize = sizeof(initInfo);
    initInfo.pwzTargetComputer = NULL;  // NULL == local machine
    initInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    initInfo.aDsScopeInfos = aScopeInit;
    initInfo.cAttributesToFetch = 1;
    static PCWSTR pwszDnsHostName = L"dNSHostName";
    initInfo.apwzAttributeNames = &pwszDnsHostName;

    //
    // Note object picker makes its own copy of initInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    return pDsObjectPicker->Initialize(&initInfo);
}

//+--------------------------------------------------------------------------
//
//  Function:   ProcessSelectedObjects
//
//  Synopsis:   Retrieve the list of selected items from the data object
//              created by the object picker and print out each one.
//
//  Arguments:  [pdo] - data object returned by object picker
//
//  History:    10-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT ProcessSelectedObjects(IDataObject *pdo, PWSTR computerName, int cchLen)
{
    Assert (pdo && computerName);
    if ( !pdo || !computerName)
        return E_POINTER;

    HRESULT hr = S_OK;
    static UINT g_cfDsObjectPicker =
        RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    FORMATETC formatetc =
    {
        (CLIPFORMAT)g_cfDsObjectPicker,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    bool fGotStgMedium = false;

    do
    {
        hr = pdo->GetData(&formatetc, &stgmedium);
        if ( SUCCEEDED (hr) )
        {
            fGotStgMedium = true;

            PDS_SELECTION_LIST pDsSelList =
                (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

            if (!pDsSelList)
            {
                hr = HRESULT_FROM_WIN32 (GetLastError());
                break;
            }

            Assert (1 == pDsSelList->cItems);
            if ( 1 == pDsSelList->cItems )
            {
                PDS_SELECTION psel = &(pDsSelList->aDsSelection[0]);
                VARIANT* pvarDnsName = &(psel->pvarFetchedAttributes[0]);
                if (   NULL == pvarDnsName
                    || VT_BSTR != pvarDnsName->vt
                    || NULL == pvarDnsName->bstrVal
                    || L'\0' == (pvarDnsName->bstrVal)[0] )
                {
                    // security review 3/1/2002 BryanWal
                    // ISSUE - possible non-null termination - convert to strsafe
                    // NTRAID# Bug9 560859 security: SendCMsg: possible non-null termination of computer name
                    wcsncpy (computerName, psel->pwzName, cchLen);
                } 
                else 
                {
                    // security review 3/1/2002 BryanWal
                    // ISSUE - possible non-null termination - convert to strsafe
                    // NTRAID# Bug9 560859 security: SendCMsg: possible non-null termination of computer name
                    wcsncpy (computerName, pvarDnsName->bstrVal, cchLen);
                }
            }
            else
                hr = E_UNEXPECTED;
            

            GlobalUnlock(stgmedium.hGlobal);
        }
    } while (0);

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium);
    }

    return hr;
}



///////////////////////////////////////////////////////////////////////////////
// Generic method for launching a single-select computer picker
//
//  Paremeters:
//      hwndParent (IN) - window handle of parent window
//      computerName (OUT) - computer name returned
//
//  Returns S_OK if everything succeeded, S_FALSE if user pressed "Cancel"
//      
//////////////////////////////////////////////////////////////////////////////
HRESULT ComputerNameFromObjectPicker (HWND hwndParent, PWSTR computerName, int cchLen)
{
    Assert (computerName);
    if ( !computerName )
        return E_POINTER;
    //
    // Create an instance of the object picker.  The implementation in
    // objsel.dll is apartment model.
    //
    CComPtr<IDsObjectPicker> spDsObjectPicker;
    // security review 3/1/2002 BryanWal ok
    HRESULT hr = CoCreateInstance(CLSID_DsObjectPicker,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IDsObjectPicker,
                                  (void **) &spDsObjectPicker);
    if ( SUCCEEDED (hr) )
    {
        Assert(!!spDsObjectPicker);
        //
        // Initialize the object picker to choose computers
        //

        hr = InitObjectPickerForComputers(spDsObjectPicker);
        if ( SUCCEEDED (hr) )
        {
            //
            // Now pick a computer
            //
            CComPtr<IDataObject> spDataObject;

            hr = spDsObjectPicker->InvokeDialog(hwndParent, &spDataObject);
            if ( S_OK == hr )
            {
                Assert(!!spDataObject);
                hr = ProcessSelectedObjects(spDataObject, computerName, cchLen);
            }
        }
    }

    return hr;
}




/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
CSendConsoleMessageDlg::CSendConsoleMessageDlg()
: m_cRefCount (0),
    m_hImageList (0),
    m_hdlg (0),
    m_hwndEditMessageText (0),
    m_hwndListviewRecipients (0)
{
    m_DispatchInfo.pargbItemStatus = NULL;
    // security review 3/1/2002 BryanWal
    // ISSUE - can raise a STATUS_NO_MEMORY exception.  consider pre-allocating at DLL_PROCESS_ATTACH
    // NTRAID Bug9 565939 SendCMsg: InitializeCriticalSection throws uncaught exception
    InitializeCriticalSection(OUT &m_DispatchInfo.cs);
}

CSendConsoleMessageDlg::~CSendConsoleMessageDlg()
{
    ThreadTrace0("Destroying CSendConsoleMessageDlg object.\n");
    Assert(m_hdlg == NULL);
    delete m_DispatchInfo.pargbItemStatus;
    DeleteCriticalSection(IN &m_DispatchInfo.cs);
}

/////////////////////////////////////////////////////////////////////
void CSendConsoleMessageDlg::AddRef()
{
    // ISSUE - use interlocked increment
    // security review 3/1/2002 BryanWal
    // NTRAID# Bug9 561315 Security: SendCMsg:  Replace critical sections with interlocked_increment
    EnterCriticalSection(INOUT &m_DispatchInfo.cs);
    Assert(m_cRefCount >= 0);
    Assert(HIWORD(m_cRefCount) == 0);
    m_cRefCount++;
    LeaveCriticalSection(INOUT &m_DispatchInfo.cs);
}

/////////////////////////////////////////////////////////////////////
void CSendConsoleMessageDlg::Release()
{
    // Security Review 3/1/2002 BryanWal ok
    EnterCriticalSection(INOUT &m_DispatchInfo.cs);
    Assert(HIWORD(m_cRefCount) == 0);
    m_cRefCount--;
    BOOL fDeleteObject = (m_cRefCount <= 0);
    if (m_hdlg != NULL)
    {
        Assert(IsWindow(m_hdlg));
        // Cause the UI to refresh
        PostMessage(m_hdlg, WM_COMMAND, MAKEWPARAM(IDC_EDIT_MESSAGE_TEXT, EN_CHANGE), 0);
    }
    LeaveCriticalSection(INOUT &m_DispatchInfo.cs);
    if (fDeleteObject)
        delete this;
}

/////////////////////////////////////////////////////////////////////
void CSendConsoleMessageDlg::OnInitDialog(HWND hdlg, IDataObject * pDataObject)
{
    Assert(IsWindow(hdlg));
    Assert(pDataObject != NULL);
    if ( !IsWindow (hdlg) || ! pDataObject )
        return;

    m_hdlg = hdlg;
    m_hwndEditMessageText = GetDlgItem(m_hdlg, IDC_EDIT_MESSAGE_TEXT);
    m_hwndListviewRecipients = GetDlgItem(m_hdlg, IDC_LIST_RECIPIENTS);
    Assert(::IsWindow(m_hwndEditMessageText));
    Assert(::IsWindow(m_hwndListviewRecipients));

    WCHAR * pawszMessage = NULL;
    (void) HrExtractDataAlloc(IN pDataObject, g_cfSendConsoleMessageText, OUT (PVOID *)&pawszMessage);

    // Set the initial message text
    if ( pawszMessage )
    {
        SetWindowTextW(m_hwndEditMessageText, pawszMessage);
        GlobalFree(pawszMessage);
    }
    SendMessage(m_hwndEditMessageText, EM_SETSEL, 0, 0);
    SetFocus(m_hwndEditMessageText);

    Assert(m_hImageList == NULL);
    m_hImageList = ImageList_LoadImage(
        g_hInstance,
        MAKEINTRESOURCE(IDB_BITMAP_COMPUTER),
        16, 3, RGB(255, 0, 255),
        IMAGE_BITMAP, 0);
    Report(m_hImageList != NULL);
    ListView_SetImageList(m_hwndListviewRecipients, m_hImageList, LVSIL_SMALL);

    // Set up columns in list view
    int         colWidths[NUM_COLS] = {200, 200};
    LVCOLUMN    lvColumn;
    WCHAR       szColumnText[128];
    ::ZeroMemory (&lvColumn, sizeof (lvColumn));

    lvColumn.mask = LVCF_WIDTH | LVCF_TEXT;
    lvColumn.cx = colWidths[COL_NAME];
    CchLoadString (IDS_RECIPIENT, OUT szColumnText, LENGTH(szColumnText));
    lvColumn.pszText = szColumnText;
    int nCol = ListView_InsertColumn (m_hwndListviewRecipients, COL_NAME, &lvColumn);
    Assert (-1 != nCol);

    lvColumn.cx = colWidths[COL_RESULT];
    CchLoadString (IDS_MESSAGE_STATUS, OUT szColumnText, LENGTH(szColumnText));
    lvColumn.pszText = szColumnText;
    nCol = ListView_InsertColumn (m_hwndListviewRecipients, COL_RESULT, &lvColumn);
    Assert (-1 != nCol);
    if ( -1 != nCol )
    {
        // Make column fill remaining space
        ListView_SetColumnWidth (m_hwndListviewRecipients, COL_RESULT, 
                LVSCW_AUTOSIZE_USEHEADER);
    }


    // Get the list of recipients
    WCHAR * pagrwszRecipients = NULL;
    (void)HrExtractDataAlloc(IN pDataObject, g_cfSendConsoleMessageRecipients, OUT (PVOID *)&pagrwszRecipients);
    if (pagrwszRecipients == NULL)
    {
        UpdateUI();
        return;
    }
    // Add the recipients to the listview
    const WCHAR * pszRecipient = pagrwszRecipients;
    while (*pszRecipient != '\0')
    {
        // Strip off leading "\\" if present.
        // security review 3/1/2002 BryanWal ok
        if ( !_wcsnicmp (pszRecipient, L"\\\\", 2) )
        {
            pszRecipient+= 2;
        }
        AddRecipient(pszRecipient);
        while(*pszRecipient++ != '\0')
            ;   // Skip until the next string
    } // while

    // NTRAID# 213370 [SENDCMSG] Accessibility - Main dialog tab stop on 
    // Recipients listview has no visible focus indicator until object is 
    // selected
    int nIndex = ListView_GetTopIndex (m_hwndListviewRecipients);
    ListView_SetItemState (m_hwndListviewRecipients, nIndex, LVIS_FOCUSED, 
            LVIS_FOCUSED);

    GlobalFree(pagrwszRecipients);
    UpdateUI();
} // CSendConsoleMessageDlg::OnInitDialog()


/////////////////////////////////////////////////////////////////////
void CSendConsoleMessageDlg::OnOK()
{
    Assert(m_cRefCount == 1 && "There is already another thread running.");
    m_DispatchInfo.status = e_statusDlgInit;
    m_DispatchInfo.cErrors = 0;
    delete m_DispatchInfo.pargbItemStatus;
    m_DispatchInfo.pargbItemStatus = NULL;
    (void)DoDialogBox(IDD_DISPATCH_MESSAGES, m_hdlg,
        DlgProcDispatchMessageToRecipients, (LPARAM)this);
    if (m_DispatchInfo.cErrors == 0 && m_DispatchInfo.status == e_statusDlgCompleted)
    {
        // No problems dispatching the message to recipients
        EndDialog(m_hdlg, TRUE);    // Close the dialog
        return;
    }
    Assert(IsWindow(m_hwndListviewRecipients));
    ListView_UnselectAllItems(m_hwndListviewRecipients);
    if (m_DispatchInfo.cErrors > 0)
    {
        DoMessageBox(m_hdlg, IDS_ERR_CANNOT_SEND_TO_ALL_RECIPIENTS);
    }
    // We did not finished the job, so display the status to the UI
    if (m_DispatchInfo.pargbItemStatus == NULL)
    {
        // The progress was unable to allocate memory for the status
        Trace0("CSendConsoleMessageDlg::OnOK() - Out of memory.\n");
        return;
    }

    // Remove all the successful items, leaving only the failed targets and
    // the unsent targets (in the event the user pressed Cancel).
    int     iItem = ListView_GetItemCount (m_hwndListviewRecipients);
    iItem--;
    const BYTE * pb = m_DispatchInfo.pargbItemStatus + iItem;

    for (; iItem >= 0 && pb >= m_DispatchInfo.pargbItemStatus;
            pb--, iItem--)
    {
        if ( *pb == iImageComputerOK )
            VERIFY (ListView_DeleteItem (m_hwndListviewRecipients, iItem));
    }
} // CSendConsoleMessageDlg::OnOK()


/////////////////////////////////////////////////////////////////////
void CSendConsoleMessageDlg::DispatchMessageToRecipients()
{
    const size_t FORMAT_BUF_LEN = 128;
    const int cRecipients = ListView_GetItemCount(m_hwndListviewRecipients);
    WCHAR szT[FORMAT_BUF_LEN + cchRECIPIENT_NAME_MAX];
    WCHAR szFmtStaticRecipient[FORMAT_BUF_LEN];    // "Sending console message to %s..."
    WCHAR szFmtStaticMessageOf[FORMAT_BUF_LEN];    // "Sending message %d of %d."
    WCHAR szFmtStaticTotalErrors[FORMAT_BUF_LEN];      // "Total errors encountered\t%d."
    GetWindowText(m_DispatchInfo.hctlStaticRecipient, OUT szFmtStaticRecipient, LENGTH(szFmtStaticRecipient));
    GetWindowText(m_DispatchInfo.hctlStaticMessageOf, szFmtStaticMessageOf, LENGTH(szFmtStaticMessageOf));
    GetWindowText(m_DispatchInfo.hctlStaticErrors, OUT szFmtStaticTotalErrors, LENGTH(szFmtStaticTotalErrors));
    SendMessage(m_DispatchInfo.hctlProgressBar, PBM_SETRANGE, 0, MAKELPARAM(0, cRecipients));

    //
    // Set the image of each recipient to normal computer
    //
    ListView_UnselectAllItems(m_hwndListviewRecipients);
    for (int i = 0; i < cRecipients; i++)
    {
        ListView_SetItemImage(m_hwndListviewRecipients, i, iImageComputer);
        ListView_SetItemText(m_hwndListviewRecipients, i, COL_RESULT, L"");
    }
    UpdateUI();         // Update the other UI controls (especially OK button)

    //
    // Get the text from the edit control
    //
    int cchMessage = GetWindowTextLength(m_hwndEditMessageText) + 1;
    WCHAR * pawszMessage = new WCHAR[cchMessage];
    if (pawszMessage != NULL)
    {
        // security review 3/1/2002 BryanWal ok - cchMessage includes null terminator
        GetWindowTextW(m_hwndEditMessageText, OUT pawszMessage, cchMessage);
    }
    else
    {
        cchMessage = 0;
        Trace0("Unable to allocate memory for message.\n");
    }

    WCHAR wszRecipient[cchRECIPIENT_NAME_MAX];
    LV_ITEMW lvItem;
    ::ZeroMemory (&lvItem, sizeof(lvItem));
    lvItem.iItem = 0;
    lvItem.iSubItem = 0;
    lvItem.pszText = wszRecipient;
    lvItem.cchTextMax = LENGTH(wszRecipient);

    Assert(m_DispatchInfo.pargbItemStatus == NULL && "Memory Leak");
    m_DispatchInfo.pargbItemStatus = new BYTE[cRecipients+1];
    if (m_DispatchInfo.pargbItemStatus != NULL)
    {
        // security review 3/1/2002 BryanWal ok
        memset(OUT m_DispatchInfo.pargbItemStatus, iImageComputer, cRecipients+1);
    }
    else
    {
        Trace0("Unable to allocate memory for listview item status.\n");
    }

    Assert(m_DispatchInfo.status == e_statusDlgInit);
    m_DispatchInfo.status = e_statusDlgDispatching; // Allow the user to cancel the dialog

    WCHAR szFailure[128];
    CchLoadString(IDS_MESSAGE_COULD_NOT_BE_SENT, OUT szFailure,
            LENGTH(szFailure));

    for (i = 0; i < cRecipients; i++)
    {
        ThreadTrace1("Sending message to recipient %d.\n", i + 1);
        // security review 3/1/2002 BryanWal ok
        EnterCriticalSection(INOUT &m_DispatchInfo.cs);
        if (m_DispatchInfo.status == e_statusUserCancel)
        {
            ThreadTrace0("DispatchMessageToRecipients() - Aborting loop @1...\n");
            LeaveCriticalSection(INOUT &m_DispatchInfo.cs);
            break;
        }
        ListView_SelectItem(m_hwndListviewRecipients, i);
        ListView_EnsureVisible(m_hwndListviewRecipients, i, FALSE);
        lvItem.iItem = i;
        wszRecipient[0] = '\0';
        // Get the recipient name
        SendMessage(m_hwndListviewRecipients, LVM_GETITEMTEXTW, i, OUT (LPARAM)&lvItem);
        if (m_DispatchInfo.pargbItemStatus != NULL)
            m_DispatchInfo.pargbItemStatus[i] = iImageComputerError;
        // security review 3/1/2002 BryanWal
        // Issue: convert to strsafe - possible buffer overflow because of static allocation
        HRESULT hr = ::StringCchPrintf (OUT szT, sizeof (szT)/sizeof (szT[0]), szFmtStaticRecipient, wszRecipient);
        Assert (SUCCEEDED (hr));
        if ( FAILED (hr) )
            continue;

        SetWindowTextW(m_DispatchInfo.hctlStaticRecipient, szT);
        // security review 3/1/2002 BryanWal
        // Issue: convert to strsafe - possible buffer overflow because of static allocation
        hr = ::StringCchPrintf (OUT szT, sizeof (szT)/sizeof (szT[0]), szFmtStaticMessageOf, i + 1, cRecipients);
        Assert (SUCCEEDED (hr));
        if ( FAILED (hr) )
            continue;
        SetWindowText(m_DispatchInfo.hctlStaticMessageOf, szT);

        switch ( m_DispatchInfo.cErrors )
        {
        case 0:
            break;

        case 1:
            ::ShowWindow (m_DispatchInfo.hctlStaticErrors, SW_SHOW);
            {
                WCHAR sz1NotSet[128];
                CchLoadString(IDS_1_RECIPIENT_NOT_CONTACTED, OUT sz1NotSet,
                        LENGTH(sz1NotSet));

                SetWindowText(m_DispatchInfo.hctlStaticErrors, sz1NotSet);
            }
            break;

        default:
            // security review 3/1/2002 BryanWal
            // ISSUE - convert to strsafe - possible buffer overflow because of static allocation
            hr = ::StringCchPrintf (OUT szT, sizeof (szT)/sizeof (szT[0]), szFmtStaticTotalErrors, m_DispatchInfo.cErrors);
            Assert (SUCCEEDED (hr));
            if ( SUCCEEDED (hr) )
                SetWindowText(m_DispatchInfo.hctlStaticErrors, szT);
            break;
        }
        LeaveCriticalSection(INOUT &m_DispatchInfo.cs);

        // Send the message to the recipient (ie, computer)
        NET_API_STATUS err;
        err = ::NetMessageBufferSend(
            NULL,
            wszRecipient,
            NULL,
            (BYTE *)pawszMessage,
            cchMessage * sizeof(WCHAR));
        int iImage = iImageComputerOK;
        if (err != ERROR_SUCCESS)
        {
            Trace3("Error sending message to recipient %ws. err=%d (0x%X).\n", wszRecipient, err, err);
            m_DispatchInfo.cErrors++;
            iImage = iImageComputerError;
        }
        if (m_DispatchInfo.pargbItemStatus != NULL)
            m_DispatchInfo.pargbItemStatus[i] = (BYTE)iImage;

        // security review 3/1/2002 BryanWal - ok - nothing in here throws an exception
        EnterCriticalSection(INOUT &m_DispatchInfo.cs);
        if (m_DispatchInfo.status == e_statusUserCancel)
        {
            ThreadTrace0("DispatchMessageToRecipients() - Aborting loop @2...\n");
            LeaveCriticalSection(INOUT &m_DispatchInfo.cs);
            break;
        }
        //
        // Update the listview
        //
        ListView_UnselectItem(m_hwndListviewRecipients, i);
        ListView_SetItemImage(m_hwndListviewRecipients, i, iImage);
        if ( iImage == iImageComputerError )
            ListView_SetItemText(m_hwndListviewRecipients, i, COL_RESULT,
                    szFailure);

        //
        // Update the progress dialog
        //
        SendMessage(m_DispatchInfo.hctlProgressBar, PBM_SETPOS, i + 1, 0);
        LeaveCriticalSection(INOUT &m_DispatchInfo.cs);
    } // for
    delete [] pawszMessage;
    Sleep(500);
    // security review 3/1/2002 BryanWal ok
    EnterCriticalSection(INOUT &m_DispatchInfo.cs);
    if (m_DispatchInfo.status != e_statusUserCancel)
    {
        // We are done dispatching the message to all the recipients
        // and the user did not canceled the operation.
        m_DispatchInfo.status = e_statusDlgCompleted;
        Assert(IsWindow(m_DispatchInfo.hdlg));
        EndDialog(m_DispatchInfo.hdlg, TRUE);   // Gracefully close the dialog
    }
    LeaveCriticalSection(INOUT &m_DispatchInfo.cs);
} // CSendConsoleMessageDlg::DispatchMessageToRecipients()


/////////////////////////////////////////////////////////////////////
//      Add a recipient to the listview control
//
//      Return the index of the inserted item.
//
int CSendConsoleMessageDlg::AddRecipient(
    PCWSTR pszRecipient,   // IN: Machine name
    BOOL fSelectItem)           // TRUE => Select the item that is inserted
{
    Assert(pszRecipient != NULL);

    // NTRAID# 498210 [Send Console Message] User can add the same computer to 
    // the Recipients listbox multiple times, sending multiple messages
    LVFINDINFO  lvfi;
    ::ZeroMemory (&lvfi, sizeof (lvfi));
    lvfi.flags = LVFI_STRING;
    lvfi.psz = const_cast<WCHAR *>(pszRecipient);
    if ( -1 == ListView_FindItem (m_hwndListviewRecipients, -1, &lvfi) )
    {
        LV_ITEM lvItem;
        ::ZeroMemory (&lvItem, sizeof(lvItem));
        lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
        lvItem.iSubItem = 0;
        lvItem.iImage = iImageComputer;
        lvItem.pszText = const_cast<WCHAR *>(pszRecipient);
        if (fSelectItem)
        {
            lvItem.mask = LVIF_TEXT | LVIF_IMAGE |LVIF_STATE;
            lvItem.state = LVIS_SELECTED;
        }
        return ListView_InsertItem(m_hwndListviewRecipients, IN &lvItem);
    }
    else
        return -1;

} // CSendConsoleMessageDlg::AddRecipient()


/////////////////////////////////////////////////////////////////////
LRESULT CSendConsoleMessageDlg::OnNotify(NMHDR * pNmHdr)
{
    Assert(pNmHdr != NULL);

    switch (pNmHdr->code)
    {
    case LVN_ENDLABELEDIT:
    {
        WCHAR * pszText = ((LV_DISPINFO *)pNmHdr)->item.pszText;
        if (pszText == NULL)
            break; // User canceled editing
        // HACK: Modifying a string which I'm not sure where it is allocated
        (void)FTrimString(INOUT pszText);
        // Check out if there is already another recipient
        int iItem = ListView_FindString(m_hwndListviewRecipients, pszText);
        if (iItem >= 0)
        {
            ListView_SelectItem(m_hwndListviewRecipients, iItem);
            DoMessageBox(m_hdlg, IDS_RECIPIENT_ALREADY_EXISTS);
            break;
        }
        // Otherwise accept the changes
        SetWindowLongPtr(m_hdlg, DWLP_MSGRESULT, TRUE);
        return TRUE;
    }
    case LVN_ITEMCHANGED:   // Selection changed
        UpdateUI();
        break;
    case LVN_KEYDOWN:
        switch (((LV_KEYDOWN *)pNmHdr)->wVKey)
            {
        case VK_INSERT:
            SendMessage(m_hdlg, WM_COMMAND, IDC_BUTTON_ADD_RECIPIENT, 0);
            break;
        case VK_DELETE:
            SendMessage(m_hdlg, WM_COMMAND, IDC_BUTTON_REMOVE_RECIPIENT, 0);
            break;
        } // switch
        break;
    case NM_CLICK:
        UpdateUI();
        break;
    case NM_DBLCLK:
        UpdateUI();
        break;
    } // switch
    return 0;
} // CSendConsoleMessageDlg::OnNotify()


/////////////////////////////////////////////////////////////////////
void CSendConsoleMessageDlg::EnableDlgItem(INT nIdDlgItem, BOOL fEnable)
{
    Assert(::IsWindow(::GetDlgItem(m_hdlg, nIdDlgItem)));
    ::EnableWindow(::GetDlgItem(m_hdlg, nIdDlgItem), fEnable);
}


/////////////////////////////////////////////////////////////////////
void CSendConsoleMessageDlg::UpdateUI()
{
    Assert(m_cRefCount > 0);
    int cchMessage = GetWindowTextLength(m_hwndEditMessageText);
    int cItems = ListView_GetItemCount(m_hwndListviewRecipients);
    EnableDlgItem(IDOK, (cchMessage > 0) && (cItems > 0) && (m_cRefCount == 1));
    int iItemSelected = ListView_GetSelectedItem(m_hwndListviewRecipients);
    EnableDlgItem(IDC_BUTTON_REMOVE_RECIPIENT, iItemSelected >= 0);
    UpdateWindow(m_hwndListviewRecipients);
} // CSendConsoleMessageDlg::UpdateUI()


/////////////////////////////////////////////////////////////////////
//      Dialog proc for the Send Console Message snapin.
//
//      USAGE
//      DoDialogBox(IDD_SEND_CONSOLE_MESSAGE, ::GetActiveWindow(), CSendConsoleMessageDlg::DlgProc);
//
INT_PTR CALLBACK CSendConsoleMessageDlg::DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CSendConsoleMessageDlg * pThis;
    pThis = (CSendConsoleMessageDlg *)::GetWindowLongPtr(hdlg, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        Assert(pThis == NULL);
        if (pThis != NULL)
            return FALSE; 
        pThis = new CSendConsoleMessageDlg;
        if (pThis == NULL)
        {
            Trace0("Unable to allocate CSendConsoleMessageDlg object.\n");
            return -1;
        }
        SetWindowLongPtr(hdlg, GWLP_USERDATA, (LONG_PTR)pThis);
        pThis->AddRef();
        pThis->OnInitDialog(hdlg, (IDataObject *)lParam);
        SendDlgItemMessage (hdlg, IDC_EDIT_MESSAGE_TEXT, EM_LIMITTEXT, 885, 0);
        return FALSE;

    case WM_NCDESTROY:
        ThreadTrace0("CSendConsoleMessageDlg::DlgProc() - WM_NCDESTROY.\n");
        // security review 3/1/2002 BryanWal
        EnterCriticalSection(INOUT &pThis->m_DispatchInfo.cs);
        pThis->m_hdlg = NULL;
        LeaveCriticalSection(INOUT &pThis->m_DispatchInfo.cs);
        pThis->Release();
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                Assert((HWND)lParam == GetDlgItem(hdlg, IDOK));
                pThis->OnOK();
            }
            break;

        case IDCANCEL:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                Assert((HWND)lParam == GetDlgItem(hdlg, IDCANCEL));
                EndDialog(hdlg, FALSE);
            }
            break;

        case IDC_EDIT_MESSAGE_TEXT:
            if (HIWORD(wParam) == EN_CHANGE)
                pThis->UpdateUI();
            break;

        case IDC_BUTTON_ADD_RECIPIENT:
            {
                WCHAR szComputerName[MAX_PATH];
                // S_FALSE means user pressed "Cancel"
                if ( S_OK == ComputerNameFromObjectPicker (hdlg, 
                        szComputerName, MAX_PATH) )
                {
                    pThis->AddRecipient (szComputerName, TRUE);
                }

                pThis->UpdateUI();
            }
            break;

        case IDC_BUTTON_REMOVE_RECIPIENT:
            while (TRUE)
            {
                // Remove all the selected recipients
                int iItem = ListView_GetSelectedItem(pThis->m_hwndListviewRecipients);
                if (iItem < 0)
                    break;
                ListView_DeleteItem(pThis->m_hwndListviewRecipients, iItem);
            }
            ::SetFocus(pThis->m_hwndListviewRecipients);
            pThis->UpdateUI();
            break;

        case IDC_BUTTON_ADVANCED:
            (void)DoDialogBox(IDD_ADVANCED_MESSAGE_OPTIONS, hdlg, CSendMessageAdvancedOptionsDlg::DlgProc);
            break;
        } // switch
        break;

    case WM_NOTIFY:
        return pThis->OnNotify((NMHDR *)lParam);

    case WM_HELP:
        return pThis->OnHelp (lParam, IDD_SEND_CONSOLE_MESSAGE);

    default:
        return FALSE;
    } // switch
    return TRUE;
} // CSendConsoleMessageDlg::DlgProc()



/////////////////////////////////////////////////////////////////////
//      DlgProcDispatchMessageToRecipients()
//
//      Private dialog to indicate the progress while a background
//      thread dispatches a message to each recipient.
//
INT_PTR CALLBACK CSendConsoleMessageDlg::DlgProcDispatchMessageToRecipients(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CSendConsoleMessageDlg * pThis = (CSendConsoleMessageDlg *)::GetWindowLongPtr(hdlg, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        Assert(pThis == NULL);
        if (pThis != NULL)
            return FALSE;   
        pThis = (CSendConsoleMessageDlg *)lParam;
        SetWindowLongPtr(hdlg, GWLP_USERDATA, (LONG_PTR)pThis);
        Assert(pThis != NULL);
        Assert(pThis->m_DispatchInfo.status == e_statusDlgInit);
        pThis->m_DispatchInfo.hdlg = hdlg;
        pThis->m_DispatchInfo.hctlStaticRecipient = GetDlgItem(hdlg, IDC_STATIC_RECIPIENT);
        pThis->m_DispatchInfo.hctlStaticMessageOf = GetDlgItem(hdlg, IDC_STATIC_MESSAGE_OF);
        pThis->m_DispatchInfo.hctlStaticErrors = GetDlgItem(hdlg, IDC_STATIC_ERRORS_ENCOUNTERED);
        pThis->m_DispatchInfo.hctlProgressBar = GetDlgItem(hdlg, IDC_PROGRESS_MESSAGES);
        {
            DWORD dwThreadId;
            HANDLE hThread = ::CreateThread(NULL, 0,
                (LPTHREAD_START_ROUTINE)ThreadProcDispatchMessageToRecipients, pThis, 0, OUT &dwThreadId);
            Report(hThread != NULL && "Unable to create thread");
            if (hThread != NULL)
            {
                VERIFY( ::CloseHandle(hThread) );
            }
            else
            {
                Trace0("Unable to create thread.\n");
                // Prevent a potential deadlock
                pThis->m_DispatchInfo.status = e_statusUserCancel;      // Pretend the user clicked on cancel
                EndDialog(hdlg, FALSE);
            }
        }
        break;

    case WM_DESTROY:
        // Those variables are set to NULL just in case
        pThis->m_DispatchInfo.hdlg = NULL;
        pThis->m_DispatchInfo.hctlStaticRecipient = NULL;
        pThis->m_DispatchInfo.hctlStaticMessageOf = NULL;
        pThis->m_DispatchInfo.hctlStaticErrors = NULL;
        pThis->m_DispatchInfo.hctlProgressBar = NULL;
        break;

    case WM_COMMAND:
        if (wParam == IDCANCEL)
        {
            Trace0("INFO: WM_COMMAND: IDCANCEL: User canceled operation.\n");
            BOOL fEndDialog = FALSE;
            if (TryEnterCriticalSection(INOUT &pThis->m_DispatchInfo.cs))
            {
                if (pThis->m_DispatchInfo.status != e_statusDlgInit)
                {
                    pThis->m_DispatchInfo.status = e_statusUserCancel;
                    fEndDialog = TRUE;
                }
                LeaveCriticalSection(INOUT &pThis->m_DispatchInfo.cs);
            }
            if (fEndDialog)
            {
                EndDialog(hdlg, FALSE);
            }
            else
            {
                ThreadTrace0("Critical section already in use.  Try again...\n");
                PostMessage(hdlg, WM_COMMAND, IDCANCEL, 0);
                Sleep(100);
            } // if...else
        } // if
        break;

    case WM_HELP:
        return pThis->OnHelp (lParam, IDD_DISPATCH_MESSAGES);

    default:
        return FALSE;
    } // switch
    return TRUE;
} // CSendConsoleMessageDlg::DlgProcDispatchMessageToRecipients()


/////////////////////////////////////////////////////////////////////
DWORD CSendConsoleMessageDlg::ThreadProcDispatchMessageToRecipients(CSendConsoleMessageDlg * pThis)
{
    Assert(pThis != NULL);
    pThis->AddRef();
    Assert(pThis->m_cRefCount > 1);
    pThis->DispatchMessageToRecipients();
    pThis->Release();
    return 0;
} // CSendConsoleMessageDlg::ThreadProcDispatchMessageToRecipients()


#define IDH_EDIT_MESSAGE_TEXT 900
#define IDH_LIST_RECIPIENTS 901
#define IDH_BUTTON_ADD_RECIPIENT 903
#define IDH_BUTTON_REMOVE_RECIPIENT 904

const DWORD g_aHelpIDs_IDD_SEND_CONSOLE_MESSAGE[]=
{
    IDC_EDIT_MESSAGE_TEXT, IDH_EDIT_MESSAGE_TEXT,
    IDOK, IDOK,
    IDC_LIST_RECIPIENTS, IDH_LIST_RECIPIENTS,
    IDC_BUTTON_ADD_RECIPIENT, IDH_BUTTON_ADD_RECIPIENT,
    IDC_BUTTON_REMOVE_RECIPIENT, IDH_BUTTON_REMOVE_RECIPIENT,
    0, 0
};


BOOL CSendConsoleMessageDlg::OnHelp(LPARAM lParam, int nDlgIDD)
{
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        switch (nDlgIDD)
        {
        case IDD_SEND_CONSOLE_MESSAGE:
            DoSendConsoleMessageContextHelp ((HWND) pHelpInfo->hItemHandle);
            break;
        }
    }
    else
        HtmlHelpW (NULL, HTML_HELP_FILE, HH_DISPLAY_TOPIC, 0);
    return TRUE;
}

void CSendConsoleMessageDlg::DoSendConsoleMessageContextHelp (HWND hWndControl)
{
    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDCANCEL:
    case IDC_BUTTON_ADVANCED:
        break;

    default:
        // Display context help for a control
        if ( !::WinHelp (
                hWndControl,
                CONTEXT_HELP_FILE,
                HELP_WM_HELP,
                (DWORD_PTR) g_aHelpIDs_IDD_SEND_CONSOLE_MESSAGE) )
        {
            Trace1 ("WinHelp () failed: 0x%x\n", GetLastError ());        
        }
        break;
    }
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
void CSendMessageAdvancedOptionsDlg::OnInitDialog(HWND hdlg)
{
    m_hdlg = hdlg;
    m_fSendAutomatedMessage = FALSE;
    CheckDlgButton(m_hdlg, IDC_CHECK_SEND_AUTOMATED_MESSAGE, m_fSendAutomatedMessage);
    UpdateUI();
}

/////////////////////////////////////////////////////////////////////
void CSendMessageAdvancedOptionsDlg::UpdateUI()
{
    static const UINT rgid[] =
    {
        IDC_STATIC_RESOURCE_NAME,
        IDC_EDIT_RESOURCE_NAME,

        IDC_STATIC_SHUTDOWN_OCCURS,
        IDC_EDIT_SHUTDOWN_OCCURS,
        //IDC_SPIN_SHUTDOWN_OCCURS,
        IDC_STATIC_SHUTDOWN_OCCURS_UNIT,

        IDC_STATIC_RESEND,
        IDC_EDIT_RESEND,
        //IDC_SPIN_RESEND,
        IDC_STATIC_RESEND_UNIT,

        IDC_STATIC_RESOURCE_BACK_ONLINE,
        IDC_EDIT_RESOURCE_BACK_ONLINE,
    };

    for (int i = 0; i < LENGTH(rgid); i++)
    {
        EnableWindow(GetDlgItem(m_hdlg, rgid[i]), m_fSendAutomatedMessage);
    }
} // CSendMessageAdvancedOptionsDlg::UpdateUI()

/////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CSendMessageAdvancedOptionsDlg::DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM /*lParam*/)
{
    CSendMessageAdvancedOptionsDlg * pThis;
    pThis = (CSendMessageAdvancedOptionsDlg *)GetWindowLongPtr(hdlg, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        Assert(pThis == NULL);
        pThis = new CSendMessageAdvancedOptionsDlg;
        if (pThis == NULL)
            return -1;
        SetWindowLongPtr(hdlg, GWLP_USERDATA, (LONG_PTR)pThis);
        pThis->OnInitDialog(hdlg);
        break;
    case WM_COMMAND:
        switch (wParam)
        {
        case IDOK:
            EndDialog(hdlg, TRUE);
            break;
        case IDCANCEL:
            EndDialog(hdlg, FALSE);
            break;
        case IDC_CHECK_SEND_AUTOMATED_MESSAGE:
            pThis->m_fSendAutomatedMessage = IsDlgButtonChecked(hdlg, IDC_CHECK_SEND_AUTOMATED_MESSAGE);
            pThis->UpdateUI();
            break;
        } // switch
        break;
    default:
        return FALSE;
    } // switch

    return TRUE;
} // CSendMessageAdvancedOptionsDlg::DlgProc()

BOOL CSendMessageAdvancedOptionsDlg::OnHelp(LPARAM /*lParam*/)
{
    HtmlHelpW (NULL, HTML_HELP_FILE, HH_DISPLAY_TOPIC, 0);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\sendcmsg\stdafx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       stdafx.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\sendcmsg\stdafx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       stdafx.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B1AFF7C6_0C49_11D1_BB12_00C04FC9A3A3__INCLUDED_)
#define AFX_STDAFX_H__B1AFF7C6_0C49_11D1_BB12_00C04FC9A3A3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <commctrl.h>

extern "C"
{
#include <lmcons.h>
#include <lmmsg.h>
}

#include <mmc.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B1AFF7C6_0C49_11D1_BB12_00C04FC9A3A3__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\sendcmsg\util.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       util.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
//  Util.h

extern HINSTANCE g_hInstance;

#ifndef APIERR
    typedef DWORD APIERR;       // Error code typically returned by ::GetLastError()
#endif

/////////////////////////////////////////////////////////////////////
//
// Dummy macros
//
#define INOUT       // Parameter is both input and output
#define IGNORED     // Output parameter is ignored

/////////////////////////////////////////////////////////////////////
//
// Handy macros
//
#define LENGTH(x)           (sizeof(x)/sizeof(x[0]))


/////////////////////////////////////////////////////////////////////
int ListView_FindString(HWND hwndListview, PCWSTR pszTextSearch);
int ListView_GetSelectedItem(HWND hwndListview);
void ListView_SelectItem(HWND hwndListview, int iItem);
void ListView_UnselectItem(HWND hwndListview, int iItem);
void ListView_UnselectAllItems(HWND hwndListview);
void ListView_SetItemImage(HWND hwndListview, int iItem, int iImage);

BOOL FTrimString(INOUT WCHAR szString[]);

/////////////////////////////////////////////////////////////////////
INT_PTR DoDialogBox(
    UINT wIdDialog,
    HWND hwndParent,
    DLGPROC dlgproc,
    LPARAM lParam = 0);

int DoMessageBox (HWND hwndParent, UINT uStringId, UINT uFlags = MB_OK | MB_ICONINFORMATION);

/////////////////////////////////////////////////////////////////////
HKEY RegOpenOrCreateKey(HKEY hkeyRoot, const WCHAR szSubkey[]);
BOOL RegWriteString(HKEY hkey, const WCHAR szKey[], const WCHAR szValue[]);
BOOL RegWriteString(HKEY hkey, const WCHAR szKey[], UINT uStringId);

/////////////////////////////////////////////////////////////////////
HRESULT HrExtractDataAlloc(
    IN IDataObject * pDataObject,
    IN UINT cfClipboardFormat,
    OUT PVOID * ppavData,
    OUT UINT * pcbData = NULL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\sendcmsg\util.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       Util.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////
//  Util.cpp
//
//  Utility routines.
//
//  HISTORY
//  4-Aug-97    t-danm      Creation.
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "debug.h"
#include "util.h"
#include "resource.h"


/////////////////////////////////////////////////////////////////////
//  ListView_FindString()
//
//  Searches the listview items and return the index of the item
//  matching the string. Return -1 if no matches.
//
//  INTERFACE NOTES
//  Although not documented, the search is performed without case.
//
int
ListView_FindString(
    HWND hwndListview,
    PCWSTR pszTextSearch)
{
    Assert(IsWindow(hwndListview));
    Assert(pszTextSearch != NULL);

    LV_FINDINFO lvFindInfo;
    ::ZeroMemory (&lvFindInfo, sizeof(lvFindInfo));
    lvFindInfo.flags = LVFI_STRING;
    lvFindInfo.psz = pszTextSearch;
    return ListView_FindItem(hwndListview, -1, &lvFindInfo);
} // ListView_FindString()


/////////////////////////////////////////////////////////////////////
//  ListView_GetSelectedItem()
//
//  Return the index of the selected item.
//  If no items are selected, return -1.
//
int
ListView_GetSelectedItem(HWND hwndListview)
{
    Assert(IsWindow(hwndListview));
    return ListView_GetNextItem(hwndListview, -1, LVNI_SELECTED);
}


/////////////////////////////////////////////////////////////////////
//  ListView_SelectItem()
//
//  Set the selection of a specific listview item.
//
void
ListView_SelectItem(
    HWND hwndListview,
    int iItem)
{
    Assert(IsWindow(hwndListview));
    Assert(iItem >= 0);
    ListView_SetItemState(hwndListview, iItem, LVIS_SELECTED, LVIS_SELECTED);
} // ListView_SelectItem()


/////////////////////////////////////////////////////////////////////
//  ListView_UnselectItem()
//
//  Clear the selection of a specific listview item.
//
void
ListView_UnselectItem(
    HWND hwndListview,
    int iItem)
{
    Assert(IsWindow(hwndListview));
    Assert(iItem >= 0);
    ListView_SetItemState(hwndListview, iItem, 0, LVIS_SELECTED);
} // ListView_UnselectItem()


/////////////////////////////////////////////////////////////////////
//  ListView_UnselectAllItems()
//  
//  Remove the selection of any selected item.
//
void
ListView_UnselectAllItems(HWND hwndListview)
{
    Assert(IsWindow(hwndListview));
    
    int iItem = -1;
    while (TRUE)
    {
        // Search the listview for any selected items
        iItem = ListView_GetNextItem(hwndListview, iItem, LVNI_SELECTED);
        if (iItem < 0)
            break;
        // Clear the selection
        ListView_SetItemState(hwndListview, iItem, 0, LVIS_SELECTED);
    }
} // ListView_UnselectAllItems()


/////////////////////////////////////////////////////////////////////
//  ListView_SetItemImage()
//
//  Change the image of a listview item.
//
void
ListView_SetItemImage(HWND hwndListview, int iItem, int iImage)
{
    Assert(IsWindow(hwndListview));
    Assert(iItem >= 0);

    LV_ITEM lvItem;
    ::ZeroMemory (OUT &lvItem, sizeof(lvItem));
    lvItem.mask = LVIF_IMAGE;
    lvItem.iItem = iItem;
    lvItem.iSubItem = 0;
    lvItem.iImage = iImage;
    ListView_SetItem(hwndListview, IN &lvItem);
} // ListView_SetItemImage()


/////////////////////////////////////////////////////////////////////////////
//  FTrimString()
//
//  Trim leading and trailing spaces of the string.
//  Return TRUE if one or more spaces has been removed, otherwise FALSE.
//
BOOL FTrimString(INOUT WCHAR szString[])
{
    WCHAR * pchSrc;
    WCHAR * pchDst;

    Assert(szString != NULL);
    if (szString[0] == 0)
        return FALSE;
    pchSrc = szString;
    if (*pchSrc == ' ')
    {
        while (*pchSrc == ' ')
            pchSrc++;
        pchDst = szString;
        do
        {
            *pchDst++ = *pchSrc++;
        }
        while (*pchSrc != '\0');

        while (pchDst > szString && *(pchDst - 1) == ' ')
            pchDst--;
        *pchDst = '\0';
        return TRUE;
    }
    pchDst = szString;
    while (*pchDst != '\0')
        pchDst++;
    Assert(pchDst > szString);
    if (*(pchDst - 1) != ' ')
        return FALSE;
    while (pchDst > szString && *(pchDst - 1) == ' ')
        pchDst--;
    *pchDst = '\0';
    return TRUE;
} // FTrimString()


/////////////////////////////////////////////////////////////////////
INT_PTR DoDialogBox(
    UINT wIdDialog,
    HWND hwndParent,
    DLGPROC dlgproc,
    LPARAM lParam)
{
    Assert(wIdDialog != 0);
    Endorse(hwndParent == NULL);
    Assert(dlgproc != NULL);
    Endorse(lParam == NULL);

    INT_PTR nResult = ::DialogBoxParam(
        g_hInstance,
        MAKEINTRESOURCE(wIdDialog),
        hwndParent,
        dlgproc,
        lParam);
    Report(nResult != -1 && "Failure to display dialog");
    return nResult;
} // DoDialogBox()


/////////////////////////////////////////////////////////////////////
int DoMessageBox(
	HWND hwndParent,
    UINT uStringId,
    UINT uFlags)
{
    WCHAR szCaption[128];
    WCHAR szMessage[512];

    CchLoadString(IDS_CAPTION, OUT szCaption, LENGTH(szCaption));
    CchLoadString(uStringId, OUT szMessage, LENGTH(szMessage));
    return ::MessageBox(hwndParent ? hwndParent : ::GetActiveWindow(), 
			szMessage, szCaption, uFlags);
} // DoMessageBox()
        
#ifdef DEBUG
/////////////////////////////////////////////////////////////////////////////
//  CchLoadString()
//
//  Same as ::LoadString() but with extra error checking.
//  CchLoadString is #defined to ::LoadString in the retail build.
//
int CchLoadString(
    UINT uIdString,     // IN: String Id
    WCHAR szBuffer[],   // OUT: Buffer to receive the string
    int cchBuffer)      // IN: Length of the buffer (in characters; not in bytes)
{
    int cch;

    Assert(szBuffer != NULL);
    cch = ::LoadString(g_hInstance, uIdString, OUT szBuffer, cchBuffer);
    Report(cch > 0 && "String not found");
    Report(cch < cchBuffer - 2 && "Output buffer too small");
    return cch;
} // CchLoadString()

#endif // DEBUG

/////////////////////////////////////////////////////////////////////
//  RegOpenOrCreateKey()
//
//  Open an existing key or create it if does not exists
//
HKEY
RegOpenOrCreateKey(
    HKEY hkeyRoot,          // IN: Root of an existing key
    const WCHAR szSubkey[]) // IN: Subkey to create
{
    Assert(hkeyRoot != NULL);
    Assert(szSubkey != NULL);
    HKEY hkey;              // Primary Registry key
    DWORD dwDisposition;    // Disposition (REG_OPENED_EXISTING_KEY or REG_CREATED_NEW_KEY)
    LONG lRetCode;          // Code returned by the Registry functions
    lRetCode = RegCreateKeyEx(
        hkeyRoot, szSubkey,
        0, NULL, REG_OPTION_NON_VOLATILE, 
        KEY_ALL_ACCESS,         // required to create keys
        NULL,                   // SecurityAttributes
        &hkey,                  // OUT: Returned registry key handle
        &dwDisposition);        // OUT: Returned disposition
    if (lRetCode != ERROR_SUCCESS)
    {
        Assert(hkey == NULL);
        return NULL;
    }
    return hkey;
} // RegOpenOrCreateKey()


/////////////////////////////////////////////////////////////////////
//  RegWriteString()
//
//  Write a tring to the Registry.
//
BOOL
RegWriteString(
    HKEY hkey,                  // IN: Key to append to
    const WCHAR szKey[],        // IN: Key to save
    const WCHAR szValue[])      // IN: Value of the key
{
    Assert(hkey != NULL);   // Verify Registry has been opened
    Assert(szKey != NULL);
    Assert(szValue != NULL);
    LONG lRetCode = RegSetValueEx(hkey, szKey, 0, REG_SZ,
        (LPBYTE)szValue, (DWORD) (wcslen(szValue) * sizeof(WCHAR)));
    // There should be no error writing to the Registry
    Report((lRetCode == ERROR_SUCCESS) && "RegWriteString() - Error writing to Registry");
    return (lRetCode == ERROR_SUCCESS);
} // RegWriteString()


/////////////////////////////////////////////////////////////////////
BOOL
RegWriteString(
    HKEY hkey,                  // IN: Key to append to
    const WCHAR szKey[],        // IN: Key to save
    UINT uStringId)             // IN: Value of the key
{
    if ( szKey )
    {
        WCHAR szValue[512];
        CchLoadString(uStringId, OUT szValue, LENGTH(szValue));
        return RegWriteString(hkey, szKey, szValue);
    }
    else
        return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
//  HrExtractDataAlloc()
//
//  Extract data from a source DataObject for a particular clipboard format.
//
//  RETURNS
//  Return S_OK if data was successfully retrieved and placed into allocated buffer.
//
//  INTERFACE NOTES
//  The routine will allocate memory, copy the data from the source to
//  the allocated buffer and return a pointer to the allocated buffer.
//  The caller is responsible to free the allocated memory using GlobalFree()
//  when no longer needed.
//
//  IMPLEMENTATION NOTES
//  The memory block is allocated by pDataObject->GetData() rather
//  than by the routine itself.
//
//  HISTORY
//  12-Aug-97   t-danm      Creation.
//
HRESULT
HrExtractDataAlloc(
    IDataObject * pDataObject,  // IN: Data source to extract data from
    UINT cfClipboardFormat,     // IN: Clipboard format to extract data
    PVOID * ppavData,           // OUT: Pointer to allocated memory
    UINT * pcbData)             // OUT: OPTIONAL: Number of bytes stored in memory buffer
{
    Assert(pDataObject != NULL);
    Assert(cfClipboardFormat != NULL);
    Assert(ppavData != NULL);
    Assert(*ppavData == NULL && "Memory Leak");
    Endorse(pcbData == NULL);   // TRUE => Don't care about the size of the allocated buffer

    FORMATETC formatetc = { (CLIPFORMAT)cfClipboardFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    Assert(stgmedium.hGlobal == NULL);
    HRESULT hr = pDataObject->GetData(IN &formatetc, OUT &stgmedium);
    if (FAILED(hr))
    {
        Trace1("HrExtractDataAlloc() - Call to pDataObject->GetData() failed. hr=0x%X.\n", hr);
        return hr;
    }
    if (stgmedium.hGlobal == NULL)
    {
        // This is because the producer did not set the hGlobal handle
        Trace0("HrExtractDataAlloc() - Memory handle hGlobal is NULL.\n");
        return S_FALSE;
    }
    UINT cbData = (UINT)GlobalSize(stgmedium.hGlobal);
    if (cbData == 0)
    {
        Trace1("HrExtractDataAlloc() - Corrupted hGlobal handle. err=%d.\n", GetLastError());
        return E_UNEXPECTED;
    }
    *ppavData = stgmedium.hGlobal;
    if (pcbData != NULL)
        *pcbData = cbData;
    return S_OK;
} // HrExtractDataAlloc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\sendcmsg\sendcmsg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       SendCMsg.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
// SendCMsg.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f SendCMsgps.mk in the project directory.


#include "stdafx.h"
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>
#include "initguid.h"
#include "SendCMsg.h"
#include "SendCMsg_i.c"
#include "debug.h"
#include "util.h"
#include "resource.h"
#include "App.h"

#include <atlimpl.cpp>

HINSTANCE g_hInstance;
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_SendConsoleMessageApp, CSendConsoleMessageApp)
END_OBJECT_MAP()

// GUID for the CSendConsoleMessageApp class
#define d_szGuidSendConsoleMessageApp	_T("{B1AFF7D0-0C49-11D1-BB12-00C04FC9A3A3}")

#if 0
// To have sendcmsg.dll to extend your context menu, add the following
// key into the registry
//
[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\MMC\NodeTypes\
	{476e6448-aaff-11d0-b944-00c04fd8d5b0}\Extensions\ContextMenu]
		"{B1AFF7D0-0C49-11D1-BB12-00C04FC9A3A3}"="Send Console Message"

// where {476e6448-aaff-11d0-b944-00c04fd8d5b0} is
// the GUID for the nodetype which you want to be extended.
#endif

// The following is an array of GUIDs of snapins that wants to be
// automatically extended by the Send Console Message Snapin.
// When the snapin registers itself, it will extend those nodetypes.
const PCWSTR rgzpszGuidNodetypeContextMenuExtensions[] =
	{
	_T("{476e6446-aaff-11d0-b944-00c04fd8d5b0}"),	// Computer Management
	_T("{4e410f0e-abc1-11d0-b944-00c04fd8d5b0}"),	// Root of File Service Management subtree	
	_T("{4e410f0f-abc1-11d0-b944-00c04fd8d5b0}"),	// FSM - Shares
	_T("{4e410f12-abc1-11d0-b944-00c04fd8d5b0}"),	// System Service Management
	};

// The following is an array of GUIDs of snapins that no longer want
// to be automatically extended by the Send Console Message Snapin.
const PCWSTR rgzpszRemoveContextMenuExtensions[] =
	{
	_T("{476e6448-aaff-11d0-b944-00c04fd8d5b0}"),	// Computer Management -> SystemTools
	_T("{0eeeeeee-d390-11cf-b607-00c04fd8d565}"), // invalid
	_T("{1eeeeeee-d390-11cf-b607-00c04fd8d565}"),	// invalid
	_T("{7eeeeeee-d390-11cf-b607-00c04fd8d565}"), // invalid
	};

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	g_hInstance = hInstance;
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	HRESULT hr = _Module.RegisterServer(TRUE);

	HKEY hkey = RegOpenOrCreateKey(
		HKEY_LOCAL_MACHINE,
		_T("Software\\Microsoft\\MMC\\SnapIns\\") d_szGuidSendConsoleMessageApp);
	if (hkey == NULL)
	{
		Assert(FALSE && "DllRegisterServer() - Unable to create key from registry.");
		return SELFREG_E_CLASS;
	}
	RegWriteString(hkey, _T("NameString"), IDS_CAPTION);
	RegCloseKey(hkey);

    const PWSTR pwszREG_FORMAT_KEY = L"Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\ContextMenu";

	for (int i = 0; i < LENGTH(rgzpszGuidNodetypeContextMenuExtensions); i++)
	{
		WCHAR szRegistryKey[256];
		Assert(rgzpszGuidNodetypeContextMenuExtensions[i] != NULL);
        // security review 3/1/2002 BryanWal
        // ISSUE - potential buffer overflow - use wsnprintf or strsafe
        hr = ::StringCchPrintf (OUT szRegistryKey, sizeof (szRegistryKey)/sizeof (szRegistryKey[0]), 
                pwszREG_FORMAT_KEY,
		         rgzpszGuidNodetypeContextMenuExtensions[i]);
        Assert (SUCCEEDED (hr));
        if ( SUCCEEDED (hr) )
        {
            Assert(wcslen(szRegistryKey) < LENGTH(szRegistryKey));
            hkey = ::RegOpenOrCreateKey(HKEY_LOCAL_MACHINE, szRegistryKey);
		    if (hkey == NULL)
		    {
			    Assert(FALSE && "DllRegisterServer() - Unable to create key from registry.");
			    continue;
		    }
            ::RegWriteString(hkey, d_szGuidSendConsoleMessageApp, IDS_CAPTION);
            ::RegCloseKey(hkey);
        }
	} // for

	for (i = 0; i < LENGTH(rgzpszRemoveContextMenuExtensions); i++)
	{
		WCHAR szRegistryKey[256];
		Assert(rgzpszRemoveContextMenuExtensions[i] != NULL);
        // security review 3/1/2002 BryanWal
        // ISSUE - potential buffer overflow - use wsnprintf or strsafe
        hr = ::StringCchPrintf (OUT szRegistryKey, sizeof (szRegistryKey)/sizeof (szRegistryKey[0]), 
                pwszREG_FORMAT_KEY,
		        rgzpszRemoveContextMenuExtensions[i]);
        Assert (SUCCEEDED (hr));
        if ( SUCCEEDED (hr) )
        {
		    Assert(wcslen(szRegistryKey) < LENGTH(szRegistryKey));
		    (void) RegOpenKey(HKEY_LOCAL_MACHINE, szRegistryKey, &hkey);
		    if (hkey == NULL)
		    {
			    // not a problem
			    continue;
		    }
		    (void) RegDeleteValue(hkey, d_szGuidSendConsoleMessageApp);
		    // ignore error code, the only likely code is ERROR_FILE_NOT_FOUND
		    RegCloseKey(hkey);
		    hkey = NULL;
        }
	} // for
	return hr;
} // DllRegisterServer()


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\common\common.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    common.h

Abstract:

    SMONLOG common definitions

--*/

#ifndef _SMONLOG_COMMON_H_
#define _SMONLOG_COMMON_H_

#include <wtypes.h>

#define _CONFIG_DLL_NAME_W_     L"SmLogCfg.dll"
#define _SERVICE_EXE_NAME_W_    L"SmLogSvc.exe"   

// Communication between smlogcfg and smlogsvc

#define SERVICE_CONTROL_SYNCHRONIZE 128
#define SLQ_QUERY_STOPPED       ((DWORD)0x00000000)              
#define SLQ_QUERY_RUNNING       ((DWORD)0x00000001)
#define SLQ_QUERY_START_PENDING ((DWORD)0x00000002)

#define SLQ_NEW_LOG         ((DWORD)0xFFFFFFFF)
#define SLQ_FIRST_LOG_TYPE  ((DWORD)0x00000000)
#define SLQ_COUNTER_LOG     ((DWORD)0x00000000)
#define SLQ_TRACE_LOG       ((DWORD)0x00000001)
#define SLQ_ALERT           ((DWORD)0x00000002)
#define SLQ_LAST_LOG_TYPE   ((DWORD)0x00000002)
#define SLQ_NUM_LOG_TYPES   ((DWORD)0x00000003)

#define SLQ_DEFAULT_SYS_QUERY   ((DWORD)(0x00000001))      

// Sysmon log output file configuration definitions

#define SLF_FIRST_FILE_TYPE ((DWORD)0x00000000)
#define SLF_CSV_FILE        ((DWORD)0x00000000)
#define SLF_TSV_FILE        ((DWORD)0x00000001)
#define SLF_BIN_FILE        ((DWORD)0x00000002)
#define SLF_BIN_CIRC_FILE   ((DWORD)0x00000003)
#define SLF_CIRC_TRACE_FILE ((DWORD)0x00000004)
#define SLF_SEQ_TRACE_FILE  ((DWORD)0x00000005)
#define SLF_SQL_LOG         ((DWORD)0x00000006)
#define SLF_NUM_FILE_TYPES  ((DWORD)0x00000007)
#define SLF_FILE_OVERWRITE  ((DWORD)0x00010000)     // Obsolete after Whistler Beta 2
#define SLF_FILE_APPEND     ((DWORD)0x00020000)     // Obsolete after Whistler Beta 2

#define SLF_NAME_NONE           ((DWORD)0xFFFFFFFF)
#define SLF_NAME_FIRST_AUTO     ((DWORD)0x00000000)
#define SLF_NAME_MMDDHH         ((DWORD)0x00000000)
#define SLF_NAME_NNNNNN         ((DWORD)0x00000001)
#define SLF_NAME_YYYYDDD        ((DWORD)0x00000002)
#define SLF_NAME_YYYYMM         ((DWORD)0x00000003)
#define SLF_NAME_YYYYMMDD       ((DWORD)0x00000004)
#define SLF_NAME_YYYYMMDDHH     ((DWORD)0x00000005)
#define SLF_NAME_MMDDHHMM       ((DWORD)0x00000006)
#define SLF_NUM_AUTO_NAME_TYPES ((DWORD)0x00000007)

#define SLQ_MAX_AUTO_NAME_LEN   ((DWORD)0x0000000B)
#define SLQ_MAX_BASE_NAME_LEN   ((DWORD)(_MAX_FNAME - SLQ_MAX_AUTO_NAME_LEN - 1))
#define SLQ_MAX_LOG_NAME_LEN    SLQ_MAX_BASE_NAME_LEN
#define SLQ_MAX_LOG_SET_NAME_LEN ((DWORD)0x000000FF)

#define SLF_DATA_STORE_APPEND_MASK  ((DWORD)0x000000F)     
#define SLF_DATA_STORE_OVERWRITE    ((DWORD)0x0000001)     
#define SLF_DATA_STORE_APPEND       ((DWORD)0x0000002)     

#define SLF_DATA_STORE_SIZE_MASK         ((DWORD)0x00000F0)     
#define SLF_DATA_STORE_SIZE_ONE_RECORD   ((DWORD)0x0000010)     
#define SLF_DATA_STORE_SIZE_ONE_KB       ((DWORD)0x0000020)     
#define SLF_DATA_STORE_SIZE_ONE_MB       ((DWORD)0x0000040)     

#define  ONE_MB     ((DWORD)0x00100000) 
#define  ONE_KB     ((DWORD)0x00000400) 
#define  ONE_RECORD ((DWORD)0x00000001) 

// Constants
#define SLQ_DISK_MAX_SIZE   ((DWORD)-1)

#define SLQ_TLI_ENABLE_BUFFER_FLUSH         ((DWORD)0x00000001)
#define SLQ_TLI_ENABLE_KERNEL_TRACE         ((DWORD)0x00000002)
#define SLQ_TLI_ENABLE_MEMMAN_TRACE         ((DWORD)0x00000004)
#define SLQ_TLI_ENABLE_FILEIO_TRACE         ((DWORD)0x00000008)
#define SLQ_TLI_ENABLE_PROCESS_TRACE        ((DWORD)0x00000010)
#define SLQ_TLI_ENABLE_THREAD_TRACE         ((DWORD)0x00000020)
#define SLQ_TLI_ENABLE_DISKIO_TRACE         ((DWORD)0x00000040)
#define SLQ_TLI_ENABLE_NETWORK_TCPIP_TRACE  ((DWORD)0x00000080)

#define SLQ_TLI_ENABLE_MASK                 ((DWORD)0x000000FF)
#define SLQ_TLI_ENABLE_KERNEL_MASK          ((DWORD)0x000000FE)

// dwMode values
#define SLQ_AUTO_MODE_NONE      ((DWORD)0x00000000)       // Manual
#define SLQ_AUTO_MODE_SIZE      ((DWORD)0x00000001)       // Size
#define SLQ_AUTO_MODE_AT        ((DWORD)0x00000002)       // Time
#define SLQ_AUTO_MODE_AFTER     ((DWORD)0x00000003)       // Value & unit type
#define SLQ_AUTO_MODE_CALENDAR  ((DWORD)0x00000004)       // Value & unit type

// wDataType values
#define SLQ_TT_DTYPE_DATETIME   ((WORD)0x0001)
#define SLQ_TT_DTYPE_UNITS      ((WORD)0x0002)

// wTimeType values
#define SLQ_TT_TTYPE_START              ((WORD)0x0001)
#define SLQ_TT_TTYPE_STOP               ((WORD)0x0002)
#define SLQ_TT_TTYPE_RESTART            ((WORD)0x0003)
#define SLQ_TT_TTYPE_SAMPLE             ((WORD)0x0004)
#define SLQ_TT_TTYPE_LAST_MODIFIED      ((WORD)0x0005)
#define SLQ_TT_TTYPE_CREATE_NEW_FILE    ((WORD)0x0006)
#define SLQ_TT_TTYPE_REPEAT_SCHEDULE    ((WORD)0x0007)
#define SLQ_TT_TTYPE_REPEAT_START       ((WORD)0x0008)
#define SLQ_TT_TTYPE_REPEAT_STOP        ((WORD)0x0009)

// dwUnitType values
#define SLQ_TT_UTYPE_SECONDS        ((DWORD)0x00000001)    
#define SLQ_TT_UTYPE_MINUTES        ((DWORD)0x00000002)   
#define SLQ_TT_UTYPE_HOURS          ((DWORD)0x00000003)   
#define SLQ_TT_UTYPE_DAYS           ((DWORD)0x00000004)   
#define SLQ_TT_UTYPE_DAYS_OF_WEEK   ((DWORD)0x00000005)   

#pragma warning ( disable : 4201 )

typedef struct _SLQ_TIME_INFO {
    WORD    wDataType;
    WORD    wTimeType;
    DWORD   dwAutoMode;
    union {
        LONGLONG    llDateTime; // filetime stored as a LONGLONG
        struct {
            DWORD   dwValue;
            DWORD   dwUnitType;
        };
    };
} SLQ_TIME_INFO, *PSLQ_TIME_INFO;

#pragma warning ( default : 4201 )

// alert action flags
#define ALRT_ACTION_LOG_EVENT   ((DWORD)0x00000001)
#define ALRT_ACTION_SEND_MSG    ((DWORD)0x00000002)
#define ALRT_ACTION_EXEC_CMD    ((DWORD)0x00000004)
#define ALRT_ACTION_START_LOG   ((DWORD)0x00000008)
#define ALRT_ACTION_MASK        ((DWORD)0x0000000F)

#define ALRT_CMD_LINE_SINGLE    ((DWORD)0x00000100)
#define ALRT_CMD_LINE_A_NAME    ((DWORD)0x00000200)
#define ALRT_CMD_LINE_C_NAME    ((DWORD)0x00000400)
#define ALRT_CMD_LINE_D_TIME    ((DWORD)0x00000800)
#define ALRT_CMD_LINE_L_VAL     ((DWORD)0x00001000)
#define ALRT_CMD_LINE_M_VAL     ((DWORD)0x00002000)
#define ALRT_CMD_LINE_U_TEXT    ((DWORD)0x00004000)
#define ALRT_CMD_LINE_MASK      ((DWORD)0x00007F00)

#define ALRT_DEFAULT_ACTION     ((DWORD)0x00000001) // log event is default

#define AIBF_UNDER  0L
#define AIBF_OVER   ((DWORD)0x00000001) // true when "over" limit is selected
#define AIBF_SEEN   ((DWORD)0x00000002) // set when the user has seen this value
#define AIBF_SAVED  ((DWORD)0x00000004) // true when user has saved this entry in an edit box

#ifdef __cplusplus
extern "C" {
#endif
 
typedef struct _ALERT_INFO_BLOCK {
    DWORD   dwSize;
    LPWSTR  szCounterPath;
    DWORD   dwFlags;
    double  dLimit;
} ALERT_INFO_BLOCK, *PALERT_INFO_BLOCK;

// Common constants
#define FILETIME_TICS_PER_MILLISECOND   ((DWORD)(10000))
#define FILETIME_TICS_PER_SECOND        ((DWORD)(FILETIME_TICS_PER_MILLISECOND*1000))

#define  ONE_MB     ((DWORD)0x00100000) 
#define  ONE_KB     ((DWORD)0x00000400) 
#define  ONE_RECORD ((DWORD)0x00000001) 

#define  MAX_ALIGN_BYTES (8)


// Memory allocation for smlogsvc, pdhpla methods
#define G_ALLOC(size)           HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, size)
#define G_REALLOC(ptr, size)    HeapReAlloc (GetProcessHeap(), (HEAP_ZERO_MEMORY), ptr, size)
#define G_ZERO(ptr, size)       ZeroMemory (ptr, size)
#define G_FREE(ptr)             if (ptr != NULL) HeapFree (GetProcessHeap(), 0, ptr)


// Constants found in utils.c

#define SLQ_MAX_VALUE_LEN (30)

// Functions found in utils.c
BOOL __stdcall PerfCreateDirectory(LPWSTR szDirectory);
void __stdcall ReplaceBlanksWithUnderscores ( LPWSTR szString);
BOOL __stdcall MakeInfoFromString ( LPCWSTR szBuffer, PALERT_INFO_BLOCK pInfo, LPDWORD pdwBufferSize);
BOOL __stdcall MakeStringFromInfo (PALERT_INFO_BLOCK pInfo, LPWSTR szBuffer, LPDWORD pcchBufferLength);
BOOL __stdcall GetLocalFileTime (LONGLONG    *pFileTime );

void __stdcall TimeInfoToMilliseconds ( SLQ_TIME_INFO* pTimeInfo, LONGLONG* pllmsecs );
void __stdcall TimeInfoToTics ( SLQ_TIME_INFO* pTimeInfo, LONGLONG* plltics );

DWORD __stdcall SmReadRegistryIndirectStringValue (
                    HKEY hKey, 
                    LPCWSTR szValue,
                    LPCWSTR szDefault, 
                    LPWSTR* pszBuffer, 
                    UINT*   puiLength );

DWORD __stdcall ahextoi(LPWSTR s);

#ifdef __cplusplus
}
#endif

#endif //_SMONLOG_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\alrtactp.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    alrtactp.cpp

Abstract:

    Implementation of the alerts action property page.

--*/

#include "stdafx.h"
#include <assert.h>
#include <common.h>
#include "smcfgmsg.h"
#include "globals.h"
#include "smlogs.h"
#include "smlogqry.h"
#include "smalrtq.h"
#include "alrtcmdd.h"
#include "AlrtActP.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("SMLOGCFG(alrtactp.cpp)");

static ULONG
s_aulHelpIds[] =
{
    IDC_ACTION_APPLOG_CHK,                  IDH_ACTION_APPLOG_CHK,
    IDC_ACTION_NETMSG_CHK,                  IDH_ACTION_NETMSG_CHK,
    IDC_ACTION_NETMSG_NAME_EDIT,            IDH_ACTION_NETMSG_NAME_EDIT,
    IDC_ACTION_EXECUTE_CHK,                 IDH_ACTION_EXECUTE_CHK,
    IDC_ACTION_EXECUTE_EDIT,                IDH_ACTION_EXECUTE_EDIT,
    IDC_ACTION_EXECUTE_BROWSE_BTN,          IDH_ACTION_EXECUTE_BROWSE_BTN,
    IDC_ACTION_CMD_ARGS_BTN,                IDH_ACTION_CMD_ARGS_BTN,
    IDC_ACTION_START_LOG_CHK,               IDH_ACTION_START_LOG_CHK,
    IDC_ACTION_START_LOG_COMBO,             IDH_ACTION_START_LOG_COMBO,
    IDC_ACTION_CMD_ARGS_DISPLAY,            IDH_ACTION_CMD_ARGS_DISPLAY,
    0,0
};

/////////////////////////////////////////////////////////////////////////////
// CAlertActionProp property page

IMPLEMENT_DYNCREATE(CAlertActionProp, CSmPropertyPage)

CAlertActionProp::CAlertActionProp(MMC_COOKIE mmcCookie, LONG_PTR hConsole) 
:   CSmPropertyPage(CAlertActionProp::IDD, hConsole),
    m_pAlertInfo ( NULL )

{
    //::OutputDebugStringA("\nCAlertActionProp::CAlertActionProp");

    // init variables from arg list
    m_pAlertQuery = reinterpret_cast <CSmAlertQuery *>(mmcCookie);
    ASSERT ( m_pAlertQuery->CastToAlertQuery() );
    m_pQuery = dynamic_cast <CSmLogQuery*> (m_pAlertQuery);

    // init AFX data
    InitAfxDataItems();

}

CAlertActionProp::CAlertActionProp() 
:   CSmPropertyPage(CAlertActionProp::IDD),
    m_pAlertQuery ( NULL ),
    m_pAlertInfo ( NULL )

{
    ASSERT (FALSE); // the constructor w/ args should be used instead

    // init AFX data
    InitAfxDataItems();
}

CAlertActionProp::~CAlertActionProp()
{
    if (m_pAlertInfo != NULL) {
        delete [] (CHAR*)m_pAlertInfo;
    }
}

void CAlertActionProp::InitAfxDataItems ()
{
    //{{AFX_DATA_INIT(CAlertActionProp)
    m_Action_bLogEvent = TRUE;
    m_Action_bExecCmd = FALSE;
    m_Action_bSendNetMsg = FALSE;
    m_Action_bStartLog = FALSE;
    m_Action_strCmdPath = L"";
    m_Action_strNetName = L"";
    m_CmdArg_bAlertName = FALSE;
    m_CmdArg_bDateTime = FALSE;
    m_CmdArg_bLimitValue = FALSE;
    m_CmdArg_bCounterPath = FALSE;
    m_CmdArg_bSingleArg = FALSE;
    m_CmdArg_bMeasuredValue = FALSE;
    m_CmdArg_bUserText = FALSE;
    m_CmdArg_strUserText = L"";
    m_nCurLogSel = LB_ERR;
    //}}AFX_DATA_INIT
}

void CAlertActionProp::DoDataExchange(CDataExchange* pDX)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAlertActionProp)
    DDX_Control(pDX, IDC_ACTION_START_LOG_COMBO, m_pLogCombo);
    DDX_Check(pDX, IDC_ACTION_APPLOG_CHK, m_Action_bLogEvent);
    DDX_Check(pDX, IDC_ACTION_EXECUTE_CHK, m_Action_bExecCmd);
    DDX_Check(pDX, IDC_ACTION_NETMSG_CHK, m_Action_bSendNetMsg);
    DDX_Check(pDX, IDC_ACTION_START_LOG_CHK, m_Action_bStartLog);
    DDX_CBIndex(pDX, IDC_ACTION_START_LOG_COMBO, m_nCurLogSel);
    DDX_Text(pDX, IDC_ACTION_EXECUTE_EDIT, m_Action_strCmdPath);
    DDV_MaxChars(pDX, m_Action_strCmdPath, MAX_PATH );
    DDX_Text(pDX, IDC_ACTION_NETMSG_NAME_EDIT, m_Action_strNetName);
    DDV_MaxChars(pDX, m_Action_strNetName, MAX_PATH );
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAlertActionProp, CSmPropertyPage)
    //{{AFX_MSG_MAP(CAlertActionProp)
    ON_WM_DESTROY()
    ON_BN_CLICKED(IDC_ACTION_EXECUTE_BROWSE_BTN, OnActionExecuteBrowseBtn)
    ON_BN_CLICKED(IDC_ACTION_APPLOG_CHK, OnActionApplogChk)
    ON_BN_CLICKED(IDC_ACTION_NETMSG_CHK, OnActionNetmsgChk)
    ON_BN_CLICKED(IDC_ACTION_EXECUTE_CHK, OnActionExecuteChk)
    ON_BN_CLICKED(IDC_ACTION_CMD_ARGS_BTN, OnActionCmdArgsBtn)
    ON_BN_CLICKED(IDC_ACTION_START_LOG_CHK, OnActionStartLogChk)
    ON_EN_CHANGE(IDC_ACTION_NETMSG_NAME_EDIT, OnNetNameTextEditChange)
    ON_EN_CHANGE(IDC_ACTION_EXECUTE_EDIT, OnCmdPathTextEditChange)
    ON_EN_KILLFOCUS(IDC_ACTION_EXECUTE_EDIT, OnCmdPathTextEditChange)
    ON_CBN_SELENDOK(IDC_ACTION_START_LOG_COMBO, OnSelendokStartLogCombo)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



BOOL    
CAlertActionProp::SetControlState()
{
    // Net Message items
    (GetDlgItem(IDC_ACTION_NETMSG_NAME_EDIT))->EnableWindow(m_Action_bSendNetMsg);

    // command line items
    if ( !m_Action_bExecCmd ) {
        m_Action_strCmdPath.Empty();
        SetDlgItemText ( IDC_ACTION_EXECUTE_EDIT, m_Action_strCmdPath );  
    }
    (GetDlgItem(IDC_ACTION_EXECUTE_EDIT))->EnableWindow(m_Action_bExecCmd);
    (GetDlgItem(IDC_ACTION_EXECUTE_BROWSE_BTN))->EnableWindow(m_Action_bExecCmd);
    (GetDlgItem(IDC_ACTION_CMD_ARGS_BTN))->EnableWindow(m_Action_bExecCmd);
    (GetDlgItem(IDC_ACTION_CMD_ARGS_CAPTION))->EnableWindow(m_Action_bExecCmd);
    (GetDlgItem(IDC_ACTION_CMD_ARGS_DISPLAY))->EnableWindow(m_Action_bExecCmd);

    // perf data Log entries
    (GetDlgItem(IDC_ACTION_START_LOG_COMBO))->EnableWindow(m_Action_bStartLog);

    return TRUE;
}

BOOL 
CAlertActionProp::LoadLogQueries ( DWORD dwLogType )
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD   dwQueryIndex = 0;
    LONG    lEnumStatus = ERROR_SUCCESS;
    WCHAR   szQueryName[MAX_PATH + 1];
    DWORD   dwQueryNameSize = MAX_PATH;
    LPWSTR  szCollectionName = NULL;
    UINT    uiCollectionNameLen = 0;
    FILETIME    ftLastWritten;
    HKEY    hKeyQuery;
    HKEY    hKeyLogService;
    DWORD   dwRegValue;
    
    dwStatus = RegOpenKeyExW (
        HKEY_LOCAL_MACHINE,         // handle of open key
        L"System\\CurrentControlSet\\Services\\Sysmonlog\\Log Queries",  // address of name of subkey to open
        0L, 
        KEY_READ,   // reserved  REGSAM samDesired, // security access mask
        &hKeyLogService);

    if (dwStatus != ERROR_SUCCESS) return FALSE;
    // Load all queries for the specified registry key.
    // Enumerate the log names and create a new log object
    // for each one found.

    while ((lEnumStatus = RegEnumKeyEx (hKeyLogService,
        dwQueryIndex, szQueryName, &dwQueryNameSize,
        NULL, NULL, NULL, &ftLastWritten)) == ERROR_SUCCESS) {

        // open the query specified
        dwStatus = RegOpenKeyExW (
            hKeyLogService,
            szQueryName,
            0,
            KEY_READ,
            &hKeyQuery);
        if ( ERROR_SUCCESS == dwStatus ) {

            //
            // create a new object and add it to the query list            
            //
            // Determine the log type.    
            //

            dwRegValue = SLQ_LAST_LOG_TYPE + 1;
            dwStatus = (DWORD) CSmLogQuery::ReadRegistryDwordValue (
                                    hKeyQuery, 
                                    IDS_REG_LOG_TYPE,
                                    SLQ_LAST_LOG_TYPE + 1,  // Invalid value
                                    &dwRegValue ); 

        
            if ( ( ERROR_SUCCESS == dwStatus ) 
                && ( dwLogType == dwRegValue ) ) 
            {
                // Query key is Guid if written by post Win2000 snapin.
                // Query key is name if written by Win2000 snapin.

                dwStatus = CSmLogQuery::SmNoLocReadRegIndStrVal (
                                hKeyQuery,
                                IDS_REG_COLLECTION_NAME,
                                NULL,
                                &szCollectionName,
                                &uiCollectionNameLen );
            
                ASSERT ( MAX_PATH >= uiCollectionNameLen );
                if ( ERROR_SUCCESS == dwStatus 
                        && NULL != szCollectionName ) 
                {
                    if (  0 < lstrlen ( szCollectionName ) 
                        && ( MAX_PATH >= lstrlen ( szCollectionName ) ) )
                    {
                        // Length of szCollectionName checked above.
                        lstrcpy ( szQueryName, szCollectionName );
                    }
                    G_FREE ( szCollectionName );
                    szCollectionName = NULL;
                }
            
                // add this to the combo box
                m_pLogCombo.AddString  (szQueryName);
            }
            RegCloseKey (hKeyQuery);
        }
        // set up for the next item in the list
        dwQueryNameSize = sizeof (szQueryName) / sizeof (szQueryName[0]);
        dwQueryIndex++;
        memset (szQueryName, 0, sizeof (szQueryName));
    }

    RegCloseKey (hKeyLogService);

    return TRUE;
}

BOOL 
CAlertActionProp::IsValidLocalData()
{
    BOOL    bActionSet = FALSE;
    INT     iPrevLength = 0;
    BOOL    bUpdateNetNameUI = FALSE;

    ResourceStateManager rsm;

    if (m_Action_bLogEvent) {
        bActionSet = TRUE;
    }

    // assumes UpdateData has been called
    
    // Trim text fields before validating.
    iPrevLength = m_Action_strCmdPath.GetLength();
    m_Action_strCmdPath.TrimLeft();
    m_Action_strCmdPath.TrimRight();

    if ( iPrevLength != m_Action_strCmdPath.GetLength() ) {
        SetDlgItemText ( IDC_ACTION_EXECUTE_EDIT, m_Action_strCmdPath );  
    }

    iPrevLength = m_Action_strNetName.GetLength();
    m_Action_strNetName.TrimLeft();
    m_Action_strNetName.TrimRight();

    if ( iPrevLength != m_Action_strNetName.GetLength() ) {
        bUpdateNetNameUI = TRUE;
    }

    if (m_Action_bSendNetMsg) {

        // make sure a net name has been entered

        while ( L'\\' == m_Action_strNetName[0] ) {
            // NetMessageBufferSend does not understand machine names preceded by "\\"
            m_Action_strNetName = m_Action_strNetName.Right( m_Action_strNetName.GetLength() - 1 );  
            bUpdateNetNameUI = TRUE;
        }


        if (m_Action_strNetName.GetLength() == 0) {
            CString strMessage;

            strMessage.LoadString ( IDS_ACTION_ERR_NONETNAME );
            MessageBox ( strMessage, m_pAlertQuery->GetLogName(), MB_OK  | MB_ICONERROR);
            SetFocusAnyPage ( IDC_ACTION_NETMSG_NAME_EDIT );
            return FALSE;
        }

        bActionSet = TRUE;
    }

    if ( bUpdateNetNameUI ) {
        SetDlgItemText ( IDC_ACTION_NETMSG_NAME_EDIT, m_Action_strNetName );  
    }

    if (m_Action_bExecCmd) {
        // make sure a command file has been entered
        if (m_Action_strCmdPath.GetLength() == 0) {
            CString strMessage;
            strMessage.LoadString ( IDS_ACTION_ERR_NOCMDFILE );
            MessageBox ( strMessage, m_pAlertQuery->GetLogName(), MB_OK  | MB_ICONERROR);
            SetFocusAnyPage ( IDC_ACTION_EXECUTE_EDIT );
            return FALSE;
        }

        // If on local machine, make sure the command file exists.
        if ( m_pAlertQuery->GetLogService()->IsLocalMachine() ) {

            DWORD dwStatus;
        
            dwStatus = IsCommandFilePathValid ( m_Action_strCmdPath );

            if ( ERROR_SUCCESS != dwStatus ) {
                CString strMessage;

                FormatSmLogCfgMessage ( 
                    strMessage,
                    m_hModule, 
                    dwStatus );
                    
                MessageBox ( strMessage, m_pAlertQuery->GetLogName(), MB_OK  | MB_ICONERROR);
                SetFocusAnyPage ( IDC_ACTION_EXECUTE_EDIT );
                return FALSE;
            }
        }
        bActionSet = TRUE;
    }
    
    if (m_Action_bStartLog ) {
        // make sure a log has been selected
        if (m_pLogCombo.GetCurSel() == CB_ERR) {
            CString strMessage;
            strMessage.LoadString ( IDS_ACTION_ERR_NOLOGNAME );
            MessageBox ( strMessage, m_pAlertQuery->GetLogName(), MB_OK  | MB_ICONERROR);
            SetFocusAnyPage ( IDC_ACTION_START_LOG_COMBO );
            return FALSE;
        }
        bActionSet = TRUE;
    }

    if (!bActionSet ) {
        // make sure some action has been selected
        CString strMessage;
        strMessage.LoadString ( IDS_ACTION_ERR_NOACTION );
        MessageBox ( strMessage, m_pAlertQuery->GetLogName(), MB_OK  | MB_ICONERROR);
        return FALSE;
    }
    
    return bActionSet;
}

void 
CAlertActionProp::UpdateCmdActionBox ()
{
    UpdateData(TRUE);
    SetControlState();  
    SetModifiedPage(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// CAlertActionProp message handlers

BOOL 
CAlertActionProp::OnSetActive()
{
    BOOL        bReturn = TRUE;

    bReturn = CSmPropertyPage::OnSetActive();
    if ( bReturn ) {
        m_pAlertQuery->GetPropPageSharedData ( &m_SharedData );
    }
    return bReturn;
}

BOOL 
CAlertActionProp::OnKillActive() 
{
    BOOL bContinue = TRUE;
    ResourceStateManager    rsm;

    // Parent class OnKillActive calls UpdateData(TRUE)
    bContinue = CPropertyPage::OnKillActive();

    if ( bContinue ) {
        bContinue = IsValidData(m_pAlertQuery, VALIDATE_FOCUS );
        if ( bContinue ) {
            // Save property page shared data.
            m_pAlertQuery->SetPropPageSharedData ( &m_SharedData );
        }
    }

    if ( bContinue ) {
        SetIsActive ( FALSE );
    }

    return bContinue;
}

BOOL 
CAlertActionProp::OnApply() 
{
    DWORD   dwFlags = 0;
    DWORD   dwBufferSize = sizeof(ALERT_ACTION_INFO);
    LPWSTR  szNextString;
    INT     nCurLogSel = CB_ERR;
    BOOL    bContinue = TRUE;
    
    ResourceStateManager rsm;

    // get current settings
    bContinue = UpdateData(TRUE);

    if ( bContinue ) {
        bContinue = IsValidData( m_pAlertQuery, VALIDATE_APPLY ); 
    }

    if ( bContinue ) {
        bContinue = SampleTimeIsLessThanSessionTime ( m_pAlertQuery );
    }

    // Write the data to the query.
    if ( bContinue ) {
        dwFlags |= (m_Action_bLogEvent ? ALRT_ACTION_LOG_EVENT : 0);
        dwFlags |= (m_Action_bExecCmd ? ALRT_ACTION_EXEC_CMD : 0);
        dwFlags |= (m_Action_bSendNetMsg ? ALRT_ACTION_SEND_MSG : 0);
        dwFlags |= (m_Action_bStartLog ? ALRT_ACTION_START_LOG : 0);

        if (m_Action_bSendNetMsg) {
            dwBufferSize += (m_Action_strNetName.GetLength() + 1) * sizeof (WCHAR);
        }
    
        if (m_Action_bExecCmd) {

            dwBufferSize += (m_Action_strCmdPath.GetLength() + 1) * sizeof (WCHAR);
            dwBufferSize += (m_CmdArg_strUserText .GetLength() + 1) * sizeof (WCHAR);
            dwFlags |= (m_CmdArg_bAlertName ? ALRT_CMD_LINE_A_NAME : 0);
            dwFlags |= (m_CmdArg_bDateTime ? ALRT_CMD_LINE_D_TIME : 0);
            dwFlags |= (m_CmdArg_bLimitValue ? ALRT_CMD_LINE_L_VAL : 0);
            dwFlags |= (m_CmdArg_bCounterPath ? ALRT_CMD_LINE_C_NAME : 0);
            dwFlags |= (m_CmdArg_bSingleArg ? ALRT_CMD_LINE_SINGLE : 0);
            dwFlags |= (m_CmdArg_bMeasuredValue ? ALRT_CMD_LINE_M_VAL : 0);
            dwFlags |= (m_CmdArg_bUserText ? ALRT_CMD_LINE_U_TEXT : 0);
        }

        if (m_Action_bStartLog) {
            nCurLogSel = m_pLogCombo.GetCurSel();
            if (nCurLogSel != CB_ERR) {
                dwBufferSize += (m_pLogCombo.GetLBTextLen(nCurLogSel) + 1) * sizeof(WCHAR);
            }
        }

        if (m_pAlertInfo != NULL) delete [] (CHAR*)(m_pAlertInfo);
        MFC_TRY
            m_pAlertInfo = (PALERT_ACTION_INFO) new CHAR[dwBufferSize];
        MFC_CATCH_MINIMUM
        if (m_pAlertInfo != NULL) {
            m_pAlertInfo->dwSize = dwBufferSize;
            m_pAlertInfo->dwActionFlags = dwFlags;
            szNextString = (LPWSTR)&m_pAlertInfo[1];
            if ((m_Action_bSendNetMsg) && (m_Action_strNetName.GetLength() > 0)) {
                m_pAlertInfo->szNetName = szNextString;
                // Length of szNetName calculated from length of m_Action_strNetName
                lstrcpyW(m_pAlertInfo->szNetName, (LPCWSTR)m_Action_strNetName);
                szNextString += m_Action_strNetName.GetLength() + 1;
            } else {
                m_pAlertInfo->szNetName = NULL;
            }
            if (m_Action_bExecCmd) {
                if (m_Action_strCmdPath.GetLength() > 0) {
                    m_pAlertInfo->szCmdFilePath = szNextString;
                    // Length of szCmdFilePath calculated from length of m_Action_strCmdPath
                    lstrcpyW (m_pAlertInfo->szCmdFilePath, (LPCWSTR)m_Action_strCmdPath);
                    szNextString += m_Action_strCmdPath.GetLength() + 1;
                } else {
                    m_pAlertInfo->szCmdFilePath = NULL;
                }

                if (m_CmdArg_strUserText.GetLength() > 0) {
                    m_pAlertInfo->szUserText = szNextString;
                    // Length of szUserText calculated from length of m_CmdArg_strUserText
                    lstrcpyW (m_pAlertInfo->szUserText, (LPCWSTR)m_CmdArg_strUserText);
                    szNextString += m_CmdArg_strUserText.GetLength() + 1;
                } else {
                    m_pAlertInfo->szUserText = NULL;
                }
            } else {
                m_pAlertInfo->szCmdFilePath = NULL;
                m_pAlertInfo->szUserText = NULL;
            }

            if ((m_Action_bStartLog) && (nCurLogSel != CB_ERR)) {
                // get log name 
                m_pAlertInfo->szLogName = szNextString; // for now
                m_pLogCombo.GetLBText(nCurLogSel, szNextString);
            } else {
                m_pAlertInfo->szLogName = NULL;
            }
        }

        if ( bContinue ) {
            // ApplyRunAs must be called before UpdateService
            bContinue = ApplyRunAs(m_pAlertQuery); 
        }

        bContinue = CSmPropertyPage::OnApply();

        if ( bContinue ) {
            bContinue = ( ERROR_SUCCESS == m_pAlertQuery->SetActionInfo ( m_pAlertInfo ) );
        }

        if ( bContinue ) {
            // Save property page shared data.
            m_pAlertQuery->UpdatePropPageSharedData();

            bContinue = UpdateService( m_pAlertQuery, FALSE );
        }
    }

    return bContinue;
}

void 
CAlertActionProp::OnCancel() 
{
    CPropertyPage::OnCancel();
}

void 
CAlertActionProp::OnActionCmdArgsBtn() 
{
    DWORD dwStatus = ERROR_SUCCESS;
    CAlertCommandArgsDlg dlgCmdArgs;
    INT_PTR iResult;
    
    dlgCmdArgs.SetAlertActionPage( this );
    dwStatus = m_pAlertQuery->GetLogName ( dlgCmdArgs.m_strAlertName );

    if ( ERROR_SUCCESS == dwStatus ) {
        MFC_TRY    

            dlgCmdArgs.m_CmdArg_bAlertName = m_CmdArg_bAlertName;
            dlgCmdArgs.m_CmdArg_bDateTime = m_CmdArg_bDateTime;
            dlgCmdArgs.m_CmdArg_bLimitValue = m_CmdArg_bLimitValue;
            dlgCmdArgs.m_CmdArg_bCounterPath = m_CmdArg_bCounterPath;
            dlgCmdArgs.m_CmdArg_bSingleArg = m_CmdArg_bSingleArg;
            dlgCmdArgs.m_CmdArg_bMeasuredValue = m_CmdArg_bMeasuredValue;
            dlgCmdArgs.m_CmdArg_bUserText = m_CmdArg_bUserText;
            dlgCmdArgs.m_CmdArg_strUserText = m_CmdArg_strUserText;

            iResult = dlgCmdArgs.DoModal();

            if ( IDOK == iResult ) {
                if (dlgCmdArgs.m_CmdArg_bAlertName != m_CmdArg_bAlertName ) {
                    m_CmdArg_bAlertName = dlgCmdArgs.m_CmdArg_bAlertName;
                    SetModifiedPage ( TRUE );
                }
                if (dlgCmdArgs.m_CmdArg_bDateTime != m_CmdArg_bDateTime ) {
                    m_CmdArg_bDateTime = dlgCmdArgs.m_CmdArg_bDateTime;
                    SetModifiedPage ( TRUE );
                }
                if (dlgCmdArgs.m_CmdArg_bLimitValue != m_CmdArg_bLimitValue ) {
                    m_CmdArg_bLimitValue = dlgCmdArgs.m_CmdArg_bLimitValue;
                    SetModifiedPage ( TRUE );
                }
                if (dlgCmdArgs.m_CmdArg_bCounterPath != m_CmdArg_bCounterPath ) {
                    m_CmdArg_bCounterPath = dlgCmdArgs.m_CmdArg_bCounterPath;
                    SetModifiedPage ( TRUE );
                }
                if (dlgCmdArgs.m_CmdArg_bSingleArg != m_CmdArg_bSingleArg ) {
                    m_CmdArg_bSingleArg = dlgCmdArgs.m_CmdArg_bSingleArg;
                    SetModifiedPage ( TRUE );
                }
                if (dlgCmdArgs.m_CmdArg_bMeasuredValue != m_CmdArg_bMeasuredValue ) {
                    m_CmdArg_bMeasuredValue = dlgCmdArgs.m_CmdArg_bMeasuredValue;
                    SetModifiedPage ( TRUE );
                }
                if (dlgCmdArgs.m_CmdArg_bUserText != m_CmdArg_bUserText ) {
                    m_CmdArg_bUserText = dlgCmdArgs.m_CmdArg_bUserText;
                    SetModifiedPage ( TRUE );
                }
                if ( 0 != dlgCmdArgs.m_CmdArg_strUserText.CompareNoCase( m_CmdArg_strUserText ) ) {
                    m_CmdArg_strUserText = dlgCmdArgs.m_CmdArg_strUserText;
                    SetModifiedPage ( TRUE );
                }
                m_strCmdArgsExample = dlgCmdArgs.m_strSampleArgList;

                SetDlgItemText (IDC_ACTION_CMD_ARGS_DISPLAY, m_strCmdArgsExample);
                // Clear the selection
                ((CEdit*)GetDlgItem( IDC_ACTION_CMD_ARGS_DISPLAY ))->SetSel ( -1, FALSE );
            }
        MFC_CATCH_DWSTATUS
    }

    if ( ERROR_SUCCESS != dwStatus ) {
        CString strSysMessage;
        CString strMessage;
        
        MFC_TRY
            // TODO:  Use static string for message in order to display in low memory situations.
            strMessage.LoadString ( IDS_ERRMSG_GENERAL );
            FormatSystemMessage ( dwStatus, strSysMessage );

            strMessage += strSysMessage;
            MessageBox ( strMessage, m_pAlertQuery->GetLogName(), MB_OK  | MB_ICONERROR);
        MFC_CATCH_MINIMUM
        
            (GetDlgItem(IDC_ACTION_CMD_ARGS_BTN))->SetFocus();
    }
    return;
}

void 
CAlertActionProp::OnSelendokStartLogCombo() 
{
    INT nSel;
    
    nSel = m_pLogCombo.GetCurSel();
    
    if ( nSel != m_nCurLogSel && LB_ERR != nSel ) {
        UpdateData ( TRUE );
        SetModifiedPage ( TRUE );
    }
}

void CAlertActionProp::OnActionExecuteBrowseBtn() 
{
    CString strCmdPath;
    
    UpdateData (TRUE);  // to get the current filename
    
    strCmdPath = m_Action_strCmdPath;

    if ( IDOK == BrowseCommandFilename ( this, strCmdPath )) {
        // Update the fields with the new information
        if ( strCmdPath != m_Action_strCmdPath ) {
            m_Action_strCmdPath = strCmdPath;
            if (!m_pAlertQuery->m_strUser.IsEmpty() ) {
                if( !( m_pAlertQuery->m_strUser.GetAt(0) == L'<' ) ){
                    m_pAlertQuery->m_fDirtyPassword |= PASSWORD_DIRTY;
                }
            }
            SetModifiedPage();
            UpdateData(FALSE);
        }
    } // else ignore if they canceled out
}

BOOL CAlertActionProp::OnInitDialog() 
{
    INT             nSelLog;
    DWORD           dwInfoBufSize = 0;

    ResourceStateManager    rsm;

    // Parent OnInitDialog calls UpdateData to initialize combo members.
    CSmPropertyPage::OnInitDialog();
        SetHelpIds ( (DWORD*)&s_aulHelpIds );

    // load service name combo box
    LoadLogQueries (SLQ_COUNTER_LOG);
    LoadLogQueries (SLQ_TRACE_LOG);

    if (m_pAlertInfo == NULL) {
        // get alert query info from alert class
        // get initial size by passing asking to fill a 0 len buffer
        m_pAlertQuery->GetActionInfo (m_pAlertInfo, &dwInfoBufSize);
        ASSERT (dwInfoBufSize > 0); // or something is wierd
        MFC_TRY;
        m_pAlertInfo = (PALERT_ACTION_INFO) new CHAR [dwInfoBufSize];
        MFC_CATCH_MINIMUM;
        ASSERT (m_pAlertInfo != NULL);
        if ( NULL != m_pAlertInfo ) {
            memset (m_pAlertInfo, 0, dwInfoBufSize);    // init new buffer
            if (!m_pAlertQuery->GetActionInfo (m_pAlertInfo, &dwInfoBufSize)) {
                // then free the info block and use the defaults
                delete [] (CHAR*)m_pAlertInfo;
                m_pAlertInfo = NULL;
            }
        }
    }        

    if (m_pAlertInfo != NULL) {
        // then initialize using the settings passed in
        m_Action_bLogEvent = ((m_pAlertInfo->dwActionFlags & ALRT_ACTION_LOG_EVENT) != 0);

        m_Action_bSendNetMsg = ((m_pAlertInfo->dwActionFlags & ALRT_ACTION_SEND_MSG) != 0);
        if (m_pAlertInfo->szNetName != NULL) {
            m_Action_strNetName = m_pAlertInfo->szNetName;
        } else {
            m_Action_strNetName.Empty();
        }

        m_Action_bExecCmd = ((m_pAlertInfo->dwActionFlags & ALRT_ACTION_EXEC_CMD) != 0);
        
        if (m_pAlertInfo->szCmdFilePath != NULL) {
            m_Action_strCmdPath = m_pAlertInfo->szCmdFilePath;
        } else {
            m_Action_strCmdPath.Empty();
        }

        if ( m_Action_bExecCmd ) {
            m_CmdArg_bAlertName = ((m_pAlertInfo->dwActionFlags & ALRT_CMD_LINE_A_NAME) != 0);
            m_CmdArg_bDateTime = ((m_pAlertInfo->dwActionFlags & ALRT_CMD_LINE_D_TIME) != 0);
            m_CmdArg_bLimitValue = ((m_pAlertInfo->dwActionFlags & ALRT_CMD_LINE_L_VAL) != 0);
            m_CmdArg_bCounterPath = ((m_pAlertInfo->dwActionFlags & ALRT_CMD_LINE_C_NAME) != 0);
            m_CmdArg_bSingleArg = ((m_pAlertInfo->dwActionFlags & ALRT_CMD_LINE_SINGLE) != 0);
            m_CmdArg_bMeasuredValue = ((m_pAlertInfo->dwActionFlags & ALRT_CMD_LINE_M_VAL) != 0);
            m_CmdArg_bUserText = ((m_pAlertInfo->dwActionFlags & ALRT_CMD_LINE_U_TEXT) != 0);

        } else {        
            m_CmdArg_bAlertName = TRUE;
            m_CmdArg_bDateTime = TRUE;
            m_CmdArg_bLimitValue = TRUE;     
            m_CmdArg_bCounterPath = TRUE;    
            m_CmdArg_bSingleArg = TRUE;      
            m_CmdArg_bMeasuredValue = TRUE;         
            m_CmdArg_bUserText = FALSE;
        } 

        if (m_pAlertInfo->szUserText != NULL) {
            m_CmdArg_strUserText = m_pAlertInfo->szUserText;
        }

        m_Action_bStartLog = ((m_pAlertInfo->dwActionFlags & ALRT_ACTION_START_LOG) != 0);

        if (m_pAlertInfo->szLogName != NULL) {
            nSelLog = m_pLogCombo.FindString (-1, m_pAlertInfo->szLogName);
            if (nSelLog != CB_ERR) {
                m_pLogCombo.SetCurSel (nSelLog);
                m_nCurLogSel = nSelLog;
            }
        }

    } else {
        // initialize using the default values as defined
        // in the constructor
    }
    
    MakeSampleArgList (
        m_strCmdArgsExample,
        m_CmdArg_bSingleArg,
        m_CmdArg_bAlertName,
        m_CmdArg_bDateTime,
        m_CmdArg_bCounterPath,
        m_CmdArg_bMeasuredValue,
        m_CmdArg_bLimitValue,
        m_CmdArg_bUserText,
        m_CmdArg_strUserText );

    SetDlgItemText (IDC_ACTION_CMD_ARGS_DISPLAY, m_strCmdArgsExample);
    // Clear the selection
    ((CEdit*)GetDlgItem( IDC_ACTION_CMD_ARGS_DISPLAY ))->SetSel ( -1, FALSE );
    
    // Call UpdateData again, after loading data.
    UpdateData ( FALSE );

    SetControlState();
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CAlertActionProp::OnActionApplogChk() 
{
    UpdateData(TRUE);
    SetControlState();
    SetModifiedPage(TRUE);
}

void CAlertActionProp::OnActionNetmsgChk() 
{
    UpdateData(TRUE);
    SetControlState();
    SetModifiedPage(TRUE);
}

void CAlertActionProp::OnActionExecuteChk() 
{
    UpdateData(TRUE);
    SetControlState();  
    SetModifiedPage(TRUE);
}

void CAlertActionProp::OnActionStartLogChk() 
{
    UpdateCmdActionBox ();
}


void CAlertActionProp::OnCmdPathTextEditChange() 
{
    CString strOldText;

    // When the user hits OK in the folder browse dialog, 
    // the folder name might not have changed.
    strOldText = m_Action_strCmdPath;
    UpdateData( TRUE );
    if ( 0 != strOldText.Compare ( m_Action_strCmdPath ) ) {
        if (!m_pAlertQuery->m_strUser.IsEmpty() ) {
            if( !( m_pAlertQuery->m_strUser.GetAt(0) == L'<' ) ){
                m_pAlertQuery->m_fDirtyPassword |= PASSWORD_DIRTY;
            }
        }
        SetModifiedPage(TRUE);
    }
}

void CAlertActionProp::OnNetNameTextEditChange() 
{
    CString strOldText;

    // When the user hits OK in the folder browse dialog, 
    // the folder name might not have changed.
    strOldText = m_Action_strNetName;
    UpdateData( TRUE );
    if ( 0 != strOldText.Compare ( m_Action_strNetName ) ) {
        SetModifiedPage(TRUE);
    }
}

DWORD 
CAlertActionProp::MakeSampleArgList (
    CString&    rstrResult,
    const BOOL  bSingleArg,
    const BOOL  bAlertName,
    const BOOL  bDateTime,
    const BOOL  bCounterPath,
    const BOOL  bMeasuredValue,
    const BOOL  bLimitValue,
    const BOOL  bUserText,
    const CString& rstrUserText )
{
    DWORD       dwStatus = ERROR_SUCCESS;
    CString     strDelim1;
    CString     strDelim2;
    BOOL        bFirstArgDone = FALSE;
    CString     strSampleString;
    CString     strTimeString;
    CString     strTemp;

    ResourceStateManager rsm;

    rstrResult.Empty(); // clear the old path

    MFC_TRY
        if ( bSingleArg ) {
            // then args are comma delimited
            strDelim1 = L",";
            strDelim2.Empty();
        } else {
            // for multiple args, they are enclosed in double quotes
            // and space delimited
            strDelim1 = L" \"";
            strDelim2 = L"\"";
        }

        if ( bAlertName ) {
            if (bFirstArgDone) {
                strSampleString += strDelim1; // add leading delimiter
            } else {
                strSampleString += L"\""; // add leading quote
                bFirstArgDone = TRUE;
            }
            strSampleString += m_pAlertQuery->GetLogName();
            strSampleString += strDelim2;
        }

        if ( bDateTime ) {
            if (bFirstArgDone) {
                strSampleString += strDelim1; // add leading delimiter
            } else {
                strSampleString += L"\""; // add leading quote
                bFirstArgDone = TRUE;
            }
            MakeTimeString(&strTimeString);
            strSampleString += strTimeString;
            strSampleString += strDelim2;
        }

        if ( bCounterPath ) {
            strTemp.LoadString ( IDS_SAMPLE_CMD_PATH );
            if (bFirstArgDone) {
                strSampleString += strDelim1; // add leading delimiter
            } else {
                strSampleString += L"\""; // add leading quote
                bFirstArgDone = TRUE;
            }
            strSampleString += strTemp;
            strSampleString += strDelim2;
        }

        if ( bMeasuredValue ) {

            strTemp.LoadString ( IDS_SAMPLE_CMD_MEAS_VAL );
            if (bFirstArgDone) {
                strSampleString += strDelim1; // add leading delimiter
            } else {
                strSampleString += L"\""; // add leading quote
                bFirstArgDone = TRUE;
            }
            strSampleString += strTemp;
            strSampleString += strDelim2;
        }

        if ( bLimitValue ) {
            strTemp.LoadString ( IDS_SAMPLE_CMD_LIMIT_VAL );
            if (bFirstArgDone) {
                strSampleString += strDelim1; // add leading delimiter
            } else {
                strSampleString += L"\""; // add leading quote
                bFirstArgDone = TRUE;
            }
            strSampleString += strTemp;
            strSampleString += strDelim2;
        }

        if ( bUserText ) {
            if (bFirstArgDone) {
                strSampleString += strDelim1; // add leading delimiter
            } else {
                strSampleString += L"\""; // add leading quote
                bFirstArgDone = TRUE;
            }
            strSampleString += rstrUserText;
            strSampleString += strDelim2;
        }

        if ( bFirstArgDone && bSingleArg ) {
            // add closing quote if there's at least 1 arg in the command line
            strSampleString += L"\"";
        }

        rstrResult = strSampleString;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

void CAlertActionProp::MakeTimeString(CString *pTimeString)
{
    SYSTEMTIME  st;
    pTimeString->Empty();

    GetLocalTime(&st);

    // Build string
    pTimeString->Format (L"%2.2d/%2.2d/%2.2d-%2.2d:%2.2d:%2.2d.%3.3d",
        st.wYear, st.wMonth, st.wDay, st.wHour, 
        st.wMinute, st.wSecond, st.wMilliseconds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\alrtactp.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    alrtactp.h

Abstract:

    Header file for the alert actions property page.

--*/

#if !defined(_AFX_ALRTACTP_H__INCLUDED_)
#define _AFX_ALRTACTP_H__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "smalrtq.h"    // For PALERT_ACTION_INFO
#include "smproppg.h"   // Base class
#include "smcfghlp.h"
// Dialog controls
#define IDD_ALERT_ACTION_PROP           1600

#define IDC_ACTION_CAPTION              1601
#define IDC_ACTION_CMD_ARGS_CAPTION     1602
#define IDC_ACTION_FIRST_HELP_CTRL_ID   1603
#define IDC_ACTION_APPLOG_CHK           1603
#define IDC_ACTION_NETMSG_CHK           1604
#define IDC_ACTION_NETMSG_NAME_EDIT     1605
#define IDC_ACTION_EXECUTE_CHK          1606
#define IDC_ACTION_EXECUTE_EDIT         1607
#define IDC_ACTION_EXECUTE_BROWSE_BTN   1608
#define IDC_ACTION_CMD_ARGS_BTN         1609    
#define IDC_ACTION_START_LOG_CHK        1610
#define IDC_ACTION_START_LOG_COMBO      1611
#define IDC_ACTION_CMD_ARGS_DISPLAY     1612

class CSmAlertQuery;
class CAlertCommandArgsDlg;

/////////////////////////////////////////////////////////////////////////////
// CAlertActionProp dialog

class CAlertActionProp : public CSmPropertyPage
{
    DECLARE_DYNCREATE(CAlertActionProp)

friend class CAlertCommandArgsDlg;

// Construction
public:
            CAlertActionProp();
            CAlertActionProp(MMC_COOKIE mmcCookie, LONG_PTR hConsole);
    virtual ~CAlertActionProp();

// Dialog Data
    //{{AFX_DATA(CAlertActionProp)
    enum { IDD = IDD_ALERT_ACTION_PROP };
    CComboBox   m_pLogCombo;
    BOOL    m_Action_bLogEvent;
    BOOL    m_Action_bExecCmd;
    BOOL    m_Action_bSendNetMsg;
    BOOL    m_Action_bStartLog;
    CString m_Action_strCmdPath;
    CString m_Action_strNetName;
    INT     m_nCurLogSel;
    BOOL    m_CmdArg_bAlertName;
    BOOL    m_CmdArg_bDateTime;
    BOOL    m_CmdArg_bLimitValue;
    BOOL    m_CmdArg_bCounterPath;
    BOOL    m_CmdArg_bSingleArg;
    BOOL    m_CmdArg_bMeasuredValue;
    BOOL    m_CmdArg_bUserText;
    CString m_CmdArg_strUserText;
    CString m_strCmdArgsExample;
    //}}AFX_DATA

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CAlertActionProp)
    public:
    protected:
    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
public:
    void    MakeTimeString(CString *pTimeString);

    PALERT_ACTION_INFO m_pAlertInfo;

protected:

    virtual INT GetFirstHelpCtrlId ( void ) { return IDC_ACTION_FIRST_HELP_CTRL_ID; };  // Subclass must override.
    virtual BOOL    IsValidLocalData();

    // Generated message map functions
    //{{AFX_MSG(CAlertActionProp)
    afx_msg void OnActionExecuteBrowseBtn();
    afx_msg void OnActionApplogChk();
    afx_msg void OnActionNetmsgChk();
    afx_msg void OnActionExecuteChk();
    afx_msg void OnActionCmdArgsBtn();
    afx_msg void OnActionStartLogChk();
    afx_msg void OnNetNameTextEditChange();
    afx_msg void OnCmdPathTextEditChange();
    afx_msg void OnSelendokStartLogCombo();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    BOOL    LoadLogQueries ( DWORD dwLogType );
    BOOL    SetControlState(void);

private:
    DWORD   MakeSampleArgList (
                CString&    rstrResult,
                const BOOL  bSingleArg,
                const BOOL  bAlertName,
                const BOOL  bDateTime,
                const BOOL  bCounterPath,
                const BOOL  bMeasuredValue,
                const BOOL  bLimitValue,
                const BOOL  bUserText,
                const CString& rstrUserText );
    void    InitAfxDataItems (void);
    void    UpdateCmdActionBox (void);
    

    CSmAlertQuery       *m_pAlertQuery;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(_AFX_ALRTACTP_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\alrtcmdd.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    alrtcmdd.cpp

Abstract:

    Implementation of the alerts action command arguments dialog.

--*/

#include "stdafx.h"
#include "alrtactp.h"
#include "alrtcmdd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static ULONG
s_aulHelpIds[] =
{
IDC_CMD_ARG_SINGLE_CHK,	IDH_CMD_ARG_SINGLE_CHK,
IDC_CMD_ARG_ALERT_CHK,	IDH_CMD_ARG_ALERT_CHK,
IDC_CMD_ARG_NAME_CHK,	IDH_CMD_ARG_NAME_CHK,
IDC_CMD_ARG_DATE_CHK,	IDH_CMD_ARG_DATE_CHK,
IDC_CMD_ARG_LIMIT_CHK,	IDH_CMD_ARG_LIMIT_CHK,
IDC_CMD_ARG_VALUE_CHK,	IDH_CMD_ARG_VALUE_CHK,
IDC_CMD_USER_TEXT_CHK,	IDH_CMD_USER_TEXT_CHK,
IDC_CMD_USER_TEXT_EDIT,	IDH_CMD_USER_TEXT_EDIT,
IDC_CMD_ARG_SAMPLE_DISPLAY,	IDH_CMD_ARG_SAMPLE_DISPLAY,
0,0
};

/////////////////////////////////////////////////////////////////////////////
// CAlertCommandArgsDlg dialog


CAlertCommandArgsDlg::CAlertCommandArgsDlg(CWnd* pParent)
 : CDialog(CAlertCommandArgsDlg::IDD, pParent),
    m_pAlertActionPage( NULL ),
    m_strSampleArgList ( L"" ),
    m_strAlertName ( L"" ),
    m_CmdArg_bAlertName ( FALSE ),
    m_CmdArg_bDateTime ( FALSE ),
    m_CmdArg_bLimitValue ( FALSE ),
    m_CmdArg_bCounterPath ( FALSE ),
    m_CmdArg_bSingleArg ( FALSE ),
    m_CmdArg_bMeasuredValue ( FALSE ),
    m_CmdArg_bUserText ( FALSE ),
    m_CmdArg_strUserText ( L"" )
{
//    EnableAutomation();

    //{{AFX_DATA_INIT(CAlertCommandArgsDlg)
    //}}AFX_DATA_INIT
}

CAlertCommandArgsDlg::~CAlertCommandArgsDlg()
{
}

void CAlertCommandArgsDlg::OnFinalRelease()
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CDialog::OnFinalRelease();
}

void CAlertCommandArgsDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAlertCommandArgsDlg)
    DDX_Check(pDX, IDC_CMD_ARG_ALERT_CHK, m_CmdArg_bAlertName);
    DDX_Check(pDX, IDC_CMD_ARG_DATE_CHK, m_CmdArg_bDateTime);
    DDX_Check(pDX, IDC_CMD_ARG_LIMIT_CHK, m_CmdArg_bLimitValue);
    DDX_Check(pDX, IDC_CMD_ARG_NAME_CHK, m_CmdArg_bCounterPath);
    DDX_Check(pDX, IDC_CMD_ARG_SINGLE_CHK, m_CmdArg_bSingleArg);
    DDX_Check(pDX, IDC_CMD_ARG_VALUE_CHK, m_CmdArg_bMeasuredValue);
    DDX_Check(pDX, IDC_CMD_USER_TEXT_CHK, m_CmdArg_bUserText);
    DDX_Text(pDX, IDC_CMD_USER_TEXT_EDIT, m_CmdArg_strUserText);
    DDV_MaxChars(pDX, m_CmdArg_strUserText, MAX_PATH);
    DDX_Text(pDX, IDC_CMD_ARG_SAMPLE_DISPLAY, m_strSampleArgList);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAlertCommandArgsDlg, CDialog)
    //{{AFX_MSG_MAP(CAlertCommandArgsDlg)
    ON_BN_CLICKED(IDC_CMD_ARG_SINGLE_CHK, OnCmdArgSingleChk)
    ON_BN_CLICKED(IDC_CMD_ARG_ALERT_CHK, OnCmdArgAlertChk)
    ON_BN_CLICKED(IDC_CMD_ARG_NAME_CHK, OnCmdArgNameChk)
    ON_BN_CLICKED(IDC_CMD_ARG_DATE_CHK, OnCmdArgDateChk)
    ON_BN_CLICKED(IDC_CMD_ARG_LIMIT_CHK, OnCmdArgLimitChk)
    ON_BN_CLICKED(IDC_CMD_ARG_VALUE_CHK, OnCmdArgValueChk)
    ON_BN_CLICKED(IDC_CMD_USER_TEXT_CHK, OnCmdUserTextChk)
    ON_EN_CHANGE(IDC_CMD_USER_TEXT_EDIT, OnCmdArgUserTextEditChange)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAlertCommandArgsDlg message handlers

BOOL CAlertCommandArgsDlg::OnInitDialog() 
{
    ResourceStateManager rsm;
    
    ASSERT ( NULL != m_pAlertActionPage );

    m_pAlertActionPage->MakeSampleArgList (
                            m_strSampleArgList,
                            m_CmdArg_bSingleArg,
                            m_CmdArg_bAlertName,
                            m_CmdArg_bDateTime,
                            m_CmdArg_bCounterPath,
                            m_CmdArg_bMeasuredValue,
                            m_CmdArg_bLimitValue,
                            m_CmdArg_bUserText,
                            m_CmdArg_strUserText );

    CDialog::OnInitDialog();

    UpdateCmdActionBox();

    return FALSE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CAlertCommandArgsDlg::OnOK() 
{
    UpdateData (TRUE);
    
    CDialog::OnOK();
}

void CAlertCommandArgsDlg::OnCmdArgSingleChk() 
{
    UpdateCmdActionBox ();
}

void CAlertCommandArgsDlg::OnCmdArgAlertChk() 
{
    UpdateCmdActionBox ();
}

void CAlertCommandArgsDlg::OnCmdArgNameChk() 
{
    UpdateCmdActionBox ();
}

void CAlertCommandArgsDlg::OnCmdArgDateChk() 
{
    UpdateCmdActionBox ();
}

void CAlertCommandArgsDlg::OnCmdArgLimitChk() 
{
    UpdateCmdActionBox ();
}

void CAlertCommandArgsDlg::OnCmdArgValueChk() 
{
    UpdateCmdActionBox ();
}

void CAlertCommandArgsDlg::OnCmdUserTextChk() 
{
    UpdateCmdActionBox ();
}

void CAlertCommandArgsDlg::OnCmdArgUserTextEditChange()
{
    UpdateCmdActionBox ();
}

BOOL 
CAlertCommandArgsDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    ASSERT( NULL != m_pAlertActionPage );

    if ( pHelpInfo->iCtrlId >= IDC_CMD_ARG_FIRST_HELP_CTRL ||
         pHelpInfo->iCtrlId == IDOK ||
         pHelpInfo->iCtrlId == IDCANCEL) {
        InvokeWinHelp(WM_HELP, NULL, (LPARAM)pHelpInfo, m_pAlertActionPage->GetContextHelpFilePath(), s_aulHelpIds);
    }

    return TRUE;
}

void 
CAlertCommandArgsDlg::OnContextMenu(CWnd* pWnd, CPoint /* point */) 
{
    ASSERT( NULL != m_pAlertActionPage );

    InvokeWinHelp(WM_CONTEXTMENU, (WPARAM)(pWnd->m_hWnd), NULL, m_pAlertActionPage->GetContextHelpFilePath(), s_aulHelpIds);

    return;
}

// Helper functions

void    
CAlertCommandArgsDlg::SetAlertActionPage( CAlertActionProp* pPage ) 
{ 
    // The alert action page is not always the parent, so store a separate pointer
    m_pAlertActionPage = pPage; 
}

void CAlertCommandArgsDlg::UpdateCmdActionBox ()
{
    UpdateData(TRUE);

    ASSERT ( NULL != m_pAlertActionPage );

    m_pAlertActionPage->MakeSampleArgList (
                            m_strSampleArgList,
                            m_CmdArg_bSingleArg,
                            m_CmdArg_bAlertName,
                            m_CmdArg_bDateTime,
                            m_CmdArg_bCounterPath,
                            m_CmdArg_bMeasuredValue,
                            m_CmdArg_bLimitValue,
                            m_CmdArg_bUserText,
                            m_CmdArg_strUserText );
    UpdateData(FALSE);
    SetControlState();  
}


BOOL    
CAlertCommandArgsDlg::SetControlState()
{
    (GetDlgItem(IDC_CMD_USER_TEXT_EDIT))->EnableWindow(m_CmdArg_bUserText);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\alrtcmdd.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    alrtcmdd.h

Abstract:

    Header file for the alert action command arguments dialog.

--*/

#ifndef _ALRTCMDD_H_
#define _ALRTCMDD_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// Dialog controls
#define IDD_ALERT_CMD_ARGS          1700

#define IDC_CMD_ARG_SAMPLE_CAPTION  1701
#define IDC_CMD_ARG_FIRST_HELP_CTRL 1702
#define IDC_CMD_ARG_SINGLE_CHK      1702
#define IDC_CMD_ARG_ALERT_CHK       1703
#define IDC_CMD_ARG_NAME_CHK        1704
#define IDC_CMD_ARG_DATE_CHK        1705
#define IDC_CMD_ARG_LIMIT_CHK       1706
#define IDC_CMD_ARG_VALUE_CHK       1707
#define IDC_CMD_USER_TEXT_CHK       1708
#define IDC_CMD_USER_TEXT_EDIT      1709
#define IDC_CMD_ARG_SAMPLE_DISPLAY  1710

class CAlertActionProp;

/////////////////////////////////////////////////////////////////////////////
// CAlertCommandArgsDlg dialog

class CAlertCommandArgsDlg : public CDialog
{
// Construction
public:
            CAlertCommandArgsDlg(CWnd* pParent=NULL);
    virtual ~CAlertCommandArgsDlg();

    void    SetAlertActionPage( CAlertActionProp* pPage );
    // Dialog Data
    //{{AFX_DATA(CProvidersProperty)
    enum { IDD = IDD_ALERT_CMD_ARGS };
    CString m_strAlertName;
    CString m_strSampleArgList;
    BOOL    m_CmdArg_bAlertName;
    BOOL    m_CmdArg_bDateTime;
    BOOL    m_CmdArg_bLimitValue;
    BOOL    m_CmdArg_bCounterPath;
    BOOL    m_CmdArg_bSingleArg;
    BOOL    m_CmdArg_bMeasuredValue;
    BOOL    m_CmdArg_bUserText;
    CString m_CmdArg_strUserText;
    // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CAlertCommandArgsDlg)
    public:
    virtual void OnFinalRelease();
    protected:
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CAlertCommandArgsDlg)
    afx_msg void OnCmdArgSingleChk();
    afx_msg void OnCmdArgAlertChk();
    afx_msg void OnCmdArgNameChk();
    afx_msg void OnCmdArgDateChk();
    afx_msg void OnCmdArgLimitChk();
    afx_msg void OnCmdArgValueChk();
    afx_msg void OnCmdUserTextChk();
    afx_msg void OnCmdArgUserTextEditChange();
    afx_msg BOOL OnHelpInfo( HELPINFO* );
    afx_msg void OnContextMenu( CWnd*, CPoint );
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CProvidersProperty)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH

private:
    void    UpdateCmdActionBox (void);
    BOOL    SetControlState(void);

    CAlertActionProp*   m_pAlertActionPage;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif //  _ALRTCMDD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\alrtgenp.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    alrtgenp.cpp

Abstract:

    Implementation of the alerts general property page.

--*/

#include "stdafx.h"
#include <assert.h>
#include <math.h>
#include <limits.h>
#include <float.h>
#include <strsafe.h>
#include <pdh.h>
#include <pdhmsg.h>
#include <common.h>
#include "smcfgmsg.h"
#include "dialogs.h"
#include "smlogs.h"
#include "smalrtq.h"
#include "AlrtGenP.h"
#include <pdhp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("SMLOGCFG(alrtgenp.cpp)");

static const COMBO_BOX_DATA_MAP OverUnderCombo[] = 
{
    {OU_OVER,       IDS_OVER},
    {OU_UNDER,      IDS_UNDER}
};
static const DWORD dwOverUnderComboEntries = sizeof(OverUnderCombo)/sizeof(OverUnderCombo[0]);

static ULONG
s_aulHelpIds[] =
{
    IDC_ALRTS_COUNTER_LIST,         IDH_ALRTS_COUNTER_LIST,
    IDC_ALRTS_ADD_BTN,              IDH_ALRTS_ADD_BTN,
    IDC_ALRTS_REMOVE_BTN,           IDH_ALRTS_REMOVE_BTN,
    IDC_ALRTS_OVER_UNDER,           IDH_ALRTS_OVER_UNDER,
    IDC_ALRTS_VALUE_EDIT,           IDH_ALRTS_VALUE_EDIT,
    IDC_ALRTS_COMMENT_EDIT,         IDH_ALRTS_COMMENT_EDIT,
    IDC_ALRTS_SAMPLE_EDIT,          IDH_ALRTS_SAMPLE_EDIT,
    IDC_ALRTS_SAMPLE_SPIN,          IDH_ALRTS_SAMPLE_EDIT,
    IDC_ALRTS_SAMPLE_UNITS_COMBO,   IDH_ALRTS_SAMPLE_UNITS_COMBO,
    IDC_RUNAS_EDIT,                 IDH_RUNAS_EDIT,
    IDC_SETPWD_BTN,                 IDH_SETPWD_BTN,
    0,0
};


ULONG 
CAlertGenProp::HashCounter(
    LPWSTR szCounterName,
    ULONG  lHashSize)
{
    ULONG       h = 0;
    ULONG       a = 31415;  //a, b, k are primes
    const ULONG k = 16381;
    const ULONG b = 27183;
    LPWSTR szThisChar;
    WCHAR Char;

    if (szCounterName) {
        for (szThisChar = szCounterName; * szThisChar; szThisChar ++) {
            Char = * szThisChar;
            if (_istupper(Char) ) {
                Char = _tolower(Char);
            }

            h = (a * h + ((ULONG) Char)) % k;
            a = a * b % (k - 1);
        }
    }
    return (h % lHashSize);
}

PDH_STATUS
CAlertGenProp::InsertAlertToHashTable(
    PALERT_INFO_BLOCK paibInfo)
{
    ULONG       lHashValue;
    PHASH_ENTRY pEntry;
    PHASH_ENTRY pNewEntry  = NULL;
    BOOLEAN     bInsert    = TRUE;
    PPDH_COUNTER_PATH_ELEMENTS pCounter = NULL;

    PDH_STATUS pdhStatus = ERROR_SUCCESS;

    // Todo:  validate pointers
    lHashValue = HashCounter(paibInfo->szCounterPath, eHashTableSize);

    pEntry = m_HashTable[lHashValue];

    pdhStatus = AllocInitCounterPath ( paibInfo->szCounterPath, &pCounter );

    if (pdhStatus == ERROR_SUCCESS && pCounter ) {
        while (pEntry) {
            pdhStatus = CheckDuplicateCounterPaths(pCounter, pEntry->pCounter );

            if ( ( AIBF_OVER & pEntry->dwFlags ) == ( AIBF_OVER & paibInfo->dwFlags )
                && pEntry->dLimit == paibInfo->dLimit  
                && ERROR_SUCCESS != pdhStatus ) 
            {
                pdhStatus = SMCFG_DUPL_SINGLE_PATH;
                bInsert = FALSE;
                break;
            }
            pEntry = pEntry->pNext;
            
        }
        if (bInsert) {
            // Insert at head of bucket list
            pNewEntry = (PHASH_ENTRY) G_ALLOC(sizeof(HASH_ENTRY));
            if (pNewEntry) {
                pNewEntry->pCounter = pCounter;
                pCounter = NULL;
                pNewEntry->dwFlags = paibInfo->dwFlags;
                pNewEntry->dLimit = paibInfo->dLimit;
                pNewEntry->pNext    = m_HashTable[lHashValue];
                m_HashTable[lHashValue]  = pNewEntry;
            } else {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                bInsert = FALSE;
            }
        }        
    } else {
         bInsert = FALSE;
    }

    if ( NULL != pCounter ) {
        G_FREE(pCounter);
    }

    if ( bInsert ) {
        pdhStatus = ERROR_SUCCESS;
    }

    return (pdhStatus);
}


void 
CAlertGenProp::InitAlertHashTable( void )
{
    memset(&m_HashTable, 0, sizeof(m_HashTable));
}

void 
CAlertGenProp::ClearAlertHashTable( void )
{
    ULONG       i;
    PHASH_ENTRY pEntry;
    PHASH_ENTRY pNext;

    for (i = 0; i < eHashTableSize; i ++) {
        pNext = m_HashTable[i];
        while (pNext != NULL) {
            pEntry = pNext;
            pNext  = pEntry->pNext;

            G_FREE(pEntry->pCounter);
            G_FREE(pEntry);
        }
    }
}

//
//  browse counters callback function
//
static 
PDH_FUNCTION 
DialogCallBack(CAlertGenProp *pDlg)
{
    // add strings in buffer to list box
    LPWSTR          NewCounterName;
    INT             iListIndex;
    LONG            lFirstNewIndex = LB_ERR;
    DWORD           dwItemExtent;
    CListBox        *pCounterList;
    PALERT_INFO_BLOCK   paibInfo = NULL;
    DWORD           dwIbSize;
    DWORD           dwReturnStatus = ERROR_SUCCESS;
    CDC*            pCDC = NULL;
    ResourceStateManager    rsm;

#define CTRBUFLIMIT (0x7fffffff)
    if ( PDH_MORE_DATA == pDlg->m_dlgConfig.CallBackStatus ) {
        if ( pDlg->m_dlgConfig.cchReturnPathLength < CTRBUFLIMIT ) {

            pDlg->m_dwCounterListBufferSize *= 2;
            delete [] pDlg->m_szCounterListBuffer;
            pDlg->m_szCounterListBuffer = NULL;

            try {
                pDlg->m_szCounterListBuffer = new WCHAR[pDlg->m_dwCounterListBufferSize];
        
            } catch ( ... ) {
                pDlg->m_dwCounterListBufferSize = 0;
                pDlg->m_dlgConfig.CallBackStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                dwReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }

            if ( ERROR_SUCCESS == dwReturnStatus ) {
                // clear buffer
                memset (pDlg->m_szCounterListBuffer, 0, pDlg->m_dwCounterListBufferSize);

                pDlg->m_dlgConfig.szReturnPathBuffer = pDlg->m_szCounterListBuffer;
                pDlg->m_dlgConfig.cchReturnPathLength = pDlg->m_dwCounterListBufferSize;
                pDlg->m_dlgConfig.CallBackStatus = PDH_RETRY;
                dwReturnStatus = PDH_RETRY;
            }
        } else {
            pDlg->m_dlgConfig.CallBackStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            dwReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }

    } else if ( ERROR_SUCCESS == pDlg->m_dlgConfig.CallBackStatus ) {

        pCounterList = (CListBox *)pDlg->GetDlgItem(IDC_ALRTS_COUNTER_LIST);
        pCDC = pCounterList->GetDC();
    
        for (NewCounterName = pDlg->m_szCounterListBuffer;
            *NewCounterName != 0;
            NewCounterName += (lstrlen(NewCounterName) + 1)) {

            // Allocate a buffer to hold the alert info and
            // add to list box
            dwIbSize = sizeof(ALERT_INFO_BLOCK) + 
                ((lstrlen(NewCounterName) + 1) * sizeof(WCHAR));

            MFC_TRY
                paibInfo = (PALERT_INFO_BLOCK) new UCHAR[dwIbSize];
            MFC_CATCH_MINIMUM;

            if (paibInfo != NULL) {
                // load the fields
                paibInfo->dwSize = dwIbSize;
                paibInfo->szCounterPath = (LPWSTR)&paibInfo[1];
                paibInfo->dwFlags = AIBF_OVER;       // clear all the flags, setting default to "Over"
                paibInfo->dLimit = CAlertGenProp::eInvalidLimit;

                StringCchCopy (paibInfo->szCounterPath, lstrlen(NewCounterName) + 1, NewCounterName);

                // Insert the new string at the end of the list box.
                iListIndex = pCounterList->InsertString (-1, NewCounterName );    
                if (iListIndex != LB_ERR) {
                    pCounterList->SetItemDataPtr (iListIndex, (LPVOID)paibInfo);
                    if ( LB_ERR == lFirstNewIndex ) 
                        lFirstNewIndex = iListIndex;
                    // update list box extent
                    if ( NULL != pCDC ) {
                        dwItemExtent = (DWORD)(pCDC->GetTextExtent(NewCounterName)).cx;
                        if (dwItemExtent > pDlg->m_dwMaxHorizListExtent) {
                            pDlg->m_dwMaxHorizListExtent = dwItemExtent;
                            pCounterList->SetHorizontalExtent(dwItemExtent);
                        }
                    }
                } else {
                    dwReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    delete [] (char*)paibInfo;
                }
            } else {
                dwReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }        
        if ( NULL != pCDC ) {
            pDlg->m_CounterList.ReleaseDC(pCDC);
            pCDC = NULL;
        }
    
        // select the first new entry in the list box.
        if (lFirstNewIndex != LB_ERR) {
            pCounterList->SetCurSel (lFirstNewIndex);
            pDlg->PublicOnSelchangeCounterList();
            pDlg->SetModifiedPage();  // to indicate a change
        }

        // clear buffer
        memset (pDlg->m_szCounterListBuffer, 0, pDlg->m_dwCounterListBufferSize);
        dwReturnStatus = ERROR_SUCCESS;
    } else {
        // Not successful
        dwReturnStatus = pDlg->m_dlgConfig.CallBackStatus; 
    }
    return dwReturnStatus;
}

/////////////////////////////////////////////////////////////////////////////
// CAlertGenProp property page

IMPLEMENT_DYNCREATE(CAlertGenProp, CSmPropertyPage)

CAlertGenProp::CAlertGenProp(MMC_COOKIE mmcCookie, LONG_PTR hConsole) 
:   CSmPropertyPage ( CAlertGenProp::IDD, hConsole )
{
    // save variables from arg list
    m_pAlertQuery = reinterpret_cast <CSmAlertQuery *>(mmcCookie);
    ASSERT ( m_pAlertQuery->CastToAlertQuery() );
    m_pQuery = dynamic_cast <CSmLogQuery*>(m_pAlertQuery);

    // init AFX variables
    InitAfxDataItems();

    // init other member variables
    ZeroMemory ( &m_dlgConfig, sizeof(m_dlgConfig) );
    m_szCounterListBuffer = NULL;
    m_dwCounterListBufferSize = 0L;
    m_ndxCurrentItem = LB_ERR;  // nothing selected
    m_szAlertCounterList = NULL;
    m_cchAlertCounterListSize = 0;
    m_dwMaxHorizListExtent = 0;
}

CAlertGenProp::CAlertGenProp() : CSmPropertyPage(CAlertGenProp::IDD)
{
    ASSERT (FALSE); // the constructor w/ args should be used instead
    // init variables that should be from arg list
    m_pAlertQuery = NULL;

    // init AFX variables
    InitAfxDataItems();

    // init other member variables
    m_szCounterListBuffer = NULL;
    m_dwCounterListBufferSize = 0L;
    m_ndxCurrentItem = LB_ERR;  // nothing selected
    m_szAlertCounterList = NULL;
    m_cchAlertCounterListSize = 0;
    m_dwMaxHorizListExtent = 0;
}

CAlertGenProp::~CAlertGenProp()
{
    if (m_szAlertCounterList != NULL) delete [] (m_szAlertCounterList);
    if (m_szCounterListBuffer != NULL) delete [] (m_szCounterListBuffer);
}

void 
CAlertGenProp::InitAfxDataItems()
{
    //{{AFX_DATA_INIT(CAlertGenProp)
    m_dLimitValue = eInvalidLimit;
    m_nSampleUnits = 0;
    //}}AFX_DATA_INIT
}

void 
CAlertGenProp::DoDataExchange(CDataExchange* pDX)
{
    HWND    hWndCtrl = NULL;
    CString strTemp;
    WCHAR   szT[MAXSTR];
    LPWSTR  szStop;
    DOUBLE  dTemp;
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAlertGenProp)
    DDX_Control(pDX, IDC_ALRTS_SAMPLE_UNITS_COMBO, m_SampleUnitsCombo);
    DDX_Control(pDX, IDC_ALRTS_OVER_UNDER, m_OverUnderCombo);
    DDX_Control(pDX, IDC_ALRTS_COUNTER_LIST, m_CounterList);
    ValidateTextEdit(pDX, IDC_ALRTS_SAMPLE_EDIT, 6, &m_SharedData.stiSampleTime.dwValue, eMinSampleInterval, eMaxSampleInterval);
    DDX_CBIndex(pDX, IDC_ALRTS_SAMPLE_UNITS_COMBO, m_nSampleUnits);
    DDX_Text(pDX, IDC_ALRTS_COMMENT_EDIT, m_strComment);
    DDV_MaxChars(pDX, m_strComment, 255);
    DDX_Text(pDX, IDC_ALRTS_START_STRING, m_strStartDisplay);
    DDX_Text(pDX, IDC_RUNAS_EDIT, m_strUserDisplay );
    //}}AFX_DATA_MAP

    //
    // User defined DDX
    //
    if ( pDX->m_bSaveAndValidate ) {
        m_SharedData.stiSampleTime.dwUnitType = 
            (DWORD)((CComboBox *)GetDlgItem(IDC_ALRTS_SAMPLE_UNITS_COMBO))->
                    GetItemData(m_nSampleUnits);    
    }
    // Alert limit value
    {
        hWndCtrl = pDX->PrepareEditCtrl(IDC_ALRTS_VALUE_EDIT);

        if (pDX->m_bSaveAndValidate) {
            ::GetWindowText(hWndCtrl, szT, MAXSTR);

            strTemp = szT;
            DDV_MaxChars(pDX, strTemp, 23);

            if (szT[0] == L'.' || (szT[0] >= L'0' && szT[0] <= L'9')) {
                dTemp = _tcstod(szT, & szStop);
                if ( HUGE_VAL != dTemp ) {
                    m_dLimitValue = dTemp;
                } else {
                    StringCchPrintf ( szT, MAXSTR, L"%.*g", DBL_DIG, m_dLimitValue ); 
                    strTemp.Format (IDS_ALERT_CHECK_LIMIT_VALUE, DBL_MAX );
                    MessageBox (strTemp, m_pAlertQuery->GetLogName(), MB_OK | MB_ICONERROR);
                    GetDlgItem(IDC_ALRTS_VALUE_EDIT)->SetWindowText(szT);
                    GetDlgItem(IDC_ALRTS_VALUE_EDIT)->SetFocus();
                }
            } else {
                m_dLimitValue = eInvalidLimit;
            }
        } else {
            if ( eInvalidLimit != m_dLimitValue ) {
                StringCchPrintf ( szT, MAXSTR, L"%.*g", DBL_DIG, m_dLimitValue ); 
            } else {
                // Display NULL string for invalid limit value.
                szT[0] = L'\0';
            }
            GetDlgItem(IDC_ALRTS_VALUE_EDIT)->SetWindowText(szT);
        }
    }
}

void 
CAlertGenProp::ImplementAdd() 
{
    LONG    lBeforeCount;
    LONG    lAfterCount;
    CString strText;
    CString strBrowseTitle;
    CString strDefaultPath;
    CString strObjCounter;

    ResourceStateManager    rsm;

    static DWORD sdwDefaultBufferListSize = 0x4000;

    if (m_szCounterListBuffer == NULL) {

        MFC_TRY
            strObjCounter.LoadString ( IDS_DEFAULT_PATH_OBJ_CTR );
            m_dwCounterListBufferSize = sdwDefaultBufferListSize;
            m_szCounterListBuffer = new WCHAR[m_dwCounterListBufferSize];
            if ( ((CSmLogService*)m_pAlertQuery->GetLogService())->IsLocalMachine() ) {
                strDefaultPath = L"\\";
            } else {
                strDefaultPath = L"\\\\";
                strDefaultPath += ((CSmLogService*)m_pAlertQuery->GetLogService())->GetMachineName();
            }
            strDefaultPath += strObjCounter;
        MFC_CATCH_MINIMUM;

        if ( NULL != m_szCounterListBuffer && !strDefaultPath.IsEmpty() ) {
            StringCchCopy ( m_szCounterListBuffer, m_dwCounterListBufferSize, strDefaultPath );
        } else {
            m_dwCounterListBufferSize = 0;
            return;
        }
    }

    m_dlgConfig.bIncludeInstanceIndex = 1;
    m_dlgConfig.bLocalCountersOnly = 0;

    m_dlgConfig.bSingleCounterPerAdd = 0;
    m_dlgConfig.bSingleCounterPerDialog = 0;

    // disallow wild cards. 
    m_dlgConfig.bWildCardInstances = 0; 

    m_dlgConfig.bHideDetailBox = 1;
    m_dlgConfig.bInitializePath = 1;
    m_dlgConfig.bDisableMachineSelection = 0;
    m_dlgConfig.bIncludeCostlyObjects = 0;
    m_dlgConfig.bReserved = 0;

    m_dlgConfig.hWndOwner = this->m_hWnd;
    m_dlgConfig.szDataSource = NULL;

    m_dlgConfig.szReturnPathBuffer = m_szCounterListBuffer;
    m_dlgConfig.cchReturnPathLength = m_dwCounterListBufferSize;
    m_dlgConfig.pCallBack = (CounterPathCallBack)DialogCallBack;
    m_dlgConfig.dwDefaultDetailLevel = PERF_DETAIL_WIZARD;
    m_dlgConfig.dwCallBackArg = (UINT_PTR)this;

    strBrowseTitle.LoadString ( IDS_ADD_COUNTERS );
    m_dlgConfig.szDialogBoxCaption = strBrowseTitle.GetBuffer( strBrowseTitle.GetLength() );

    // get count of items in the list box before calling the browser
    lBeforeCount = m_CounterList.GetCount();

    PdhBrowseCountersW (&m_dlgConfig);

    strBrowseTitle.ReleaseBuffer();

    // get count of items in the list box After calling the browser
    // to see if the Apply button should enabled
    lAfterCount = m_CounterList.GetCount();

    if (lAfterCount > lBeforeCount) 
        SetModifiedPage(TRUE);

    // see if the remove button should be enabled
    GetDlgItem (IDC_ALRTS_REMOVE_BTN)->EnableWindow(
        lAfterCount > 0 ? TRUE : FALSE);

    delete [] m_szCounterListBuffer;
    m_szCounterListBuffer = NULL;
    m_dwCounterListBufferSize = 0;
    GetDlgItem(IDC_ALRTS_VALUE_EDIT)->SetFocus();
    
    SetButtonState ();
}


BEGIN_MESSAGE_MAP(CAlertGenProp, CSmPropertyPage)
    //{{AFX_MSG_MAP(CAlertGenProp)
    ON_BN_CLICKED(IDC_ALRTS_ADD_BTN, OnAddBtn)
    ON_LBN_DBLCLK(IDC_ALRTS_COUNTER_LIST, OnDblclkAlrtsCounterList)
    ON_BN_CLICKED(IDC_ALRTS_REMOVE_BTN, OnRemoveBtn)
    ON_LBN_SELCHANGE(IDC_ALRTS_COUNTER_LIST, OnSelchangeCounterList)
    ON_EN_CHANGE(IDC_ALRTS_COMMENT_EDIT, OnCommentEditChange)
    ON_EN_KILLFOCUS(IDC_ALRTS_COMMENT_EDIT, OnCommentEditKillFocus)
    ON_NOTIFY(UDN_DELTAPOS, IDC_ALRTS_SAMPLE_SPIN, OnDeltaposSampleSpin)
    ON_CBN_SELENDOK(IDC_ALRTS_SAMPLE_UNITS_COMBO, OnSelendokSampleUnitsCombo)
    ON_EN_CHANGE( IDC_RUNAS_EDIT, OnChangeUser )
    ON_EN_CHANGE(IDC_ALRTS_SAMPLE_EDIT, OnSampleTimeChanged)
    ON_EN_KILLFOCUS(IDC_ALRTS_SAMPLE_EDIT, OnSampleTimeChanged)
    ON_CBN_SELENDOK(IDC_ALRTS_OVER_UNDER, OnKillFocusUpdateAlertData)
    ON_CBN_KILLFOCUS (IDC_ALRTS_OVER_UNDER, OnKillFocusUpdateAlertData)
    ON_EN_CHANGE(IDC_ALRTS_VALUE_EDIT, OnChangeAlertValueEdit)
    ON_EN_KILLFOCUS (IDC_ALRTS_VALUE_EDIT, OnKillFocusUpdateAlertData)
    ON_BN_CLICKED(IDC_SETPWD_BTN, OnPwdBtn)
    ON_WM_CLOSE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAlertGenProp message handlers

void 
CAlertGenProp::OnChangeUser()
{
    //
    // If you can not access remote WBEM, you can not modify RunAs info,
    // changing the user name is not allowed.
    //
    if (m_bCanAccessRemoteWbem) {
        // When the user hits OK in the password dialog,
        // the user name might not have changed.
        UpdateData ( TRUE );

        m_strUserDisplay.TrimLeft();
        m_strUserDisplay.TrimRight();

        if ( 0 != m_strUserSaved.Compare ( m_strUserDisplay ) ) {
            m_pAlertQuery->m_fDirtyPassword = PASSWORD_DIRTY;
            SetModifiedPage(TRUE);
        }
        else {
            m_pAlertQuery->m_fDirtyPassword &= ~PASSWORD_DIRTY;
        }
        //
        // If default user is typed, never need to set password
        //
        if (m_strUserDisplay.IsEmpty() || m_strUserDisplay.GetAt(0) == L'<') {
            if (m_bPwdButtonEnabled) {
                GetDlgItem(IDC_SETPWD_BTN)->EnableWindow(FALSE);
                m_bPwdButtonEnabled = FALSE;
            }
        }
        else {
            if (!m_bPwdButtonEnabled) {
                GetDlgItem(IDC_SETPWD_BTN)->EnableWindow(TRUE);
                m_bPwdButtonEnabled = TRUE;
            }
        }
    }
    else {
        //
        // We can not modify the RunAs info, then display
        // an error message and retore the original user name in RunAs
        //
        UpdateData(TRUE);
        if (ConnectRemoteWbemFail(m_pAlertQuery, FALSE)) {
            GetDlgItem(IDC_RUNAS_EDIT)->SetWindowText(m_strUserSaved);
        }
    }
}

void 
CAlertGenProp::OnPwdBtn()
{
    CString strTempUser;

    UpdateData();

    if (!m_bCanAccessRemoteWbem) {
        ConnectRemoteWbemFail(m_pAlertQuery, TRUE);
        return;
    }

    MFC_TRY
        strTempUser = m_strUserDisplay;

        m_strUserDisplay.TrimLeft();
        m_strUserDisplay.TrimRight();

        m_pAlertQuery->m_strUser = m_strUserDisplay;

        SetRunAs(m_pAlertQuery);

        m_strUserDisplay = m_pAlertQuery->m_strUser;

        if ( 0 != strTempUser.CompareNoCase ( m_strUserDisplay ) ) {
            SetDlgItemText ( IDC_RUNAS_EDIT, m_strUserDisplay );
        }
    MFC_CATCH_MINIMUM;
}

void 
CAlertGenProp::OnAddBtn() 
{
    ImplementAdd();

    return;
}

void 
CAlertGenProp::OnDblclkAlrtsCounterList() 
{
    ImplementAdd();

    return;
}
void 
CAlertGenProp::OnRemoveBtn() 
{
    PALERT_INFO_BLOCK   paibInfo;
    INT                 nCurSel;
    INT                 nLbItemCount;
    BOOL                bChanged = FALSE;
    DWORD               dwItemExtent;
    INT                 iIndex;
    LPWSTR              szPath= NULL;
    LONG                lSize = 0;
    CDC*                pCDC = NULL;

    nLbItemCount = m_CounterList.GetCount();
    nCurSel = m_CounterList.GetCurSel();
    if (nCurSel != LB_ERR) {
        paibInfo = (PALERT_INFO_BLOCK)m_CounterList.GetItemDataPtr(nCurSel);
        if ( paibInfo != NULL ) 
            delete [] (char*)paibInfo;
        if ( LB_ERR != m_CounterList.DeleteString(nCurSel) ) {
            
            // clear the max extent
            m_dwMaxHorizListExtent = 0;

            szPath = new WCHAR [PDH_MAX_COUNTER_PATH+1];
            if (szPath == NULL) {
                return;
            }
            lSize = PDH_MAX_COUNTER_PATH;

            pCDC = m_CounterList.GetDC();

            if ( NULL != pCDC ) {
                for ( iIndex = 0; iIndex < m_CounterList.GetCount(); iIndex++ ) {
                    if (m_CounterList.GetTextLen(iIndex) > lSize) {
                        lSize = max(m_CounterList.GetTextLen(iIndex) + 1, lSize * 2);
                        delete [] szPath;
                        szPath = new WCHAR [lSize];
                        if (szPath == NULL) {
                            m_CounterList.ReleaseDC(pCDC);
                            return;
                        }
                    }

                    if ( 0 < m_CounterList.GetText( iIndex, szPath ) ) {
                        dwItemExtent = (DWORD)(pCDC->GetTextExtent (szPath)).cx;
                        if (dwItemExtent > m_dwMaxHorizListExtent) {
                            m_dwMaxHorizListExtent = dwItemExtent;
                            m_CounterList.SetHorizontalExtent(dwItemExtent);
                        }
                    }
                }

                if (nCurSel == (nLbItemCount - 1)) {
                    // then the last item was deleted so select the new "last"
                    if ( 0 == nCurSel ) {
                        nCurSel = LB_ERR;
                    } else {
                        nCurSel--;
                    }
                } //else the current selection should still be in the list box
                m_CounterList.SetCurSel (nCurSel);
                m_ndxCurrentItem = nCurSel;
                LoadAlertItemData (nCurSel);
                bChanged = TRUE;
            }
            if ( NULL != pCDC ) {
                m_CounterList.ReleaseDC(pCDC);
                pCDC = NULL;
            }
            if ( szPath ) {
                delete [] szPath;
            }
        }
    }
    SetButtonState();
    SetModifiedPage(bChanged);
}

void 
CAlertGenProp::OnDeltaposSampleSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
    OnDeltaposSpin(pNMHDR, pResult, &m_SharedData.stiSampleTime.dwValue, eMinSampleInterval, eMaxSampleInterval);
}

void 
CAlertGenProp::OnSelendokSampleUnitsCombo() 
{
    int nSel;
    
    nSel = ((CComboBox *)GetDlgItem(IDC_ALRTS_SAMPLE_UNITS_COMBO))->GetCurSel();
    
    if ((nSel != LB_ERR) && (nSel != m_nSampleUnits)) {
        UpdateData ( TRUE );
        SetModifiedPage ( TRUE );
    }
}

void CAlertGenProp::OnSampleTimeChanged()
{
    DWORD   dwOldValue;
    dwOldValue = m_SharedData.stiSampleTime.dwValue;
    UpdateData ( TRUE );
    if (dwOldValue != m_SharedData.stiSampleTime.dwValue) {
        SetModifiedPage(TRUE);
    }
}

void CAlertGenProp::OnChangeAlertValueEdit() 
{
    SaveAlertItemData();
}

void CAlertGenProp::PublicOnSelchangeCounterList() 
{
    OnSelchangeCounterList();
}

void CAlertGenProp::OnKillFocusUpdateAlertData()
{
    SaveAlertItemData();
}

void CAlertGenProp::OnSelchangeCounterList() 
{
    INT                 nCurSel;

    nCurSel = m_CounterList.GetCurSel();
    if (nCurSel != LB_ERR) {
        // Save the data from the previous item.
        SaveAlertItemData();
        // Load the data from the new item.
        LoadAlertItemData(nCurSel);
    } else {
        // clear the fields
        m_dLimitValue=eInvalidLimit;
        UpdateData(FALSE);
    }
}

void 
CAlertGenProp::UpdateAlertStartString ()
{
    eStartType  eCurrentStartType;
    int         nResId = 0;
    ResourceStateManager    rsm;

    eCurrentStartType = DetermineCurrentStartType();

    if ( eStartManually == eCurrentStartType ) {
        nResId = IDS_ALERT_START_MANUALLY;
    } else if ( eStartImmediately == eCurrentStartType ) {
        nResId = IDS_ALERT_START_IMMED;
    } else if ( eStartSched == eCurrentStartType ) {
        nResId = IDS_ALERT_START_SCHED;
    }
    
    if ( 0 != nResId ) {
        m_strStartDisplay.LoadString(nResId);
    } else {
        m_strStartDisplay.Empty();
    }

    return;
}

BOOL 
CAlertGenProp::IsValidLocalData() 
{
    BOOL bIsValid = FALSE;
    INT nInvalidIndex = -1;
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    PALERT_INFO_BLOCK   paibInfo;
    int iListCount;
    int iIndex;
    BOOL bInsert;
    BOOL bAtLeastOneDuplicateCounter = FALSE;
    BOOL bSelectionDeleted = FALSE;
    CString strText;
   
    // test to see if there are any counters in the list box
    if (m_CounterList.GetCount() > 0) {
        if ( GetDlgItem(IDC_ALRTS_VALUE_EDIT) == GetFocus() ) {
            SaveAlertItemData();    // Set the Is Saved flag for this value.
        }
        bIsValid = LoadListFromDlg(&nInvalidIndex, TRUE);
        if (   ((!bIsValid) && (nInvalidIndex != -1))
            || ((m_dLimitValue < 0.0) || (m_dLimitValue > DBL_MAX)))
        {
            // then one of the list items has not been reviewed
            // by the user so remind them
            strText.Format (IDS_ALERT_CHECK_LIMITS, DBL_MAX );
            MessageBox (strText, m_pAlertQuery->GetLogName(), MB_OK | MB_ICONERROR);
            m_CounterList.SetCurSel(nInvalidIndex);
            OnSelchangeCounterList();
            SetFocusAnyPage ( IDC_ALRTS_VALUE_EDIT );
            bIsValid = FALSE;                   
        } else {
            
            // Eliminate duplicate alert paths, then reload the list

            iListCount = m_CounterList.GetCount();
            if ( LB_ERR != iListCount ) {
                InitAlertHashTable ( );
                // Walk the list backwards to delete duplicate items.
                for ( iIndex = iListCount - 1; iIndex >= 0; iIndex-- ) {
                    paibInfo = (PALERT_INFO_BLOCK)m_CounterList.GetItemDataPtr(iIndex);
                    if ( NULL != paibInfo ) {
                        pdhStatus = InsertAlertToHashTable ( paibInfo );
                        if (SMCFG_DUPL_SINGLE_PATH == pdhStatus) {
                            bAtLeastOneDuplicateCounter = TRUE;
                        }
                        bInsert = (pdhStatus == ERROR_SUCCESS) ? TRUE : FALSE;
                    } else {
                        bInsert = FALSE;
                    }
                    //
                    // If the item is duplicated, then remove it
                    //
                    if (! bInsert) {
						// Set item data pointer to NULL because 
						// SaveAlertItemData can be called after this.
                        // Clear the selection if >= current index.
                        if ( m_ndxCurrentItem >= iIndex ) {
                            m_ndxCurrentItem = LB_ERR;
                            bSelectionDeleted = TRUE;
                        }
                        m_CounterList.SetItemDataPtr(iIndex, NULL);
                        m_CounterList.DeleteString(iIndex);
                        delete [] (char*)paibInfo;
                    }


                    //
                    // Display error code other than duplicated counter in loop
                    //
                    if ( SMCFG_DUPL_SINGLE_PATH != pdhStatus && ERROR_SUCCESS != pdhStatus) {
                        // Message box Pdh error message, go on to next 
                        CString strMsg;
                        CString strPdhMessage;

                        FormatSystemMessage ( pdhStatus, strPdhMessage );

                        MFC_TRY
                            strMsg.Format ( IDS_CTRS_PDH_ERROR, paibInfo->szCounterPath );
                            strMsg += strPdhMessage;
                        MFC_CATCH_MINIMUM

                        MessageBox ( strMsg, m_pAlertQuery->GetLogName(), MB_OK  | MB_ICONERROR);
                    }

                }

                ClearAlertHashTable ( );

                //
                // If there is at least one duplicated case, display the error message 
                // outside the loop above
                //
                if ( bAtLeastOneDuplicateCounter ) {
                    CString strMsg;

                    strMsg.LoadString ( IDS_ALERT_DUPL_PATH );
                    MessageBox ( strMsg, m_pAlertQuery->GetLogName(), MB_OK  | MB_ICONWARNING);

                    // Only deleting duplicates, so no need to recalculate the max extent

                    // Reset the selection if necessary
                    if ( bSelectionDeleted && LB_ERR == m_ndxCurrentItem ) {
                        if (m_CounterList.GetCount() > 0) {
                            m_CounterList.SetCurSel (0);
                            m_ndxCurrentItem = 0;
                            SetFocusAnyPage ( IDC_ALRTS_COUNTER_LIST );
                            LoadAlertItemData (0);
                        }
                    }

                }
                bIsValid = LoadListFromDlg ( &nInvalidIndex );
                assert ( bIsValid );
            }
        }
    } else {
        // the counter list is empty
        strText.LoadString (IDS_NO_COUNTERS);
        MessageBox (strText, m_pAlertQuery->GetLogName(), MB_OK | MB_ICONERROR);
        SetFocusAnyPage ( IDC_ALRTS_ADD_BTN );
        bIsValid = FALSE;
    }

    if (bIsValid)
    {
        bIsValid = ValidateDWordInterval(IDC_ALRTS_SAMPLE_EDIT,
                                         m_pAlertQuery->GetLogName(),
                                         (long) m_SharedData.stiSampleTime.dwValue,
                                         eMinSampleInterval,
                                         eMaxSampleInterval);
    }

    if (bIsValid) {
        // Validate sample interval value and unit type
        bIsValid = SampleIntervalIsInRange(
                        m_SharedData.stiSampleTime,
                        m_pAlertQuery->GetLogName() );

        if ( !bIsValid ) {
            SetFocusAnyPage ( IDC_ALRTS_SAMPLE_EDIT );
        }
    }

    return bIsValid;
}

BOOL 
CAlertGenProp::OnSetActive()
{
    BOOL        bReturn;

    bReturn = CSmPropertyPage::OnSetActive();
    if (!bReturn) return FALSE;

    ResourceStateManager    rsm;

    m_pAlertQuery->GetPropPageSharedData ( &m_SharedData );

    UpdateAlertStartString();
    m_strUserDisplay = m_pAlertQuery->m_strUser;
    UpdateData(FALSE); //to load the static string.

    return TRUE;
}

BOOL 
CAlertGenProp::OnKillActive() 
{
    BOOL bContinue = TRUE;
    ResourceStateManager    rsm;

    // Parent class OnKillActive calls UpdateData(TRUE)
    bContinue = CPropertyPage::OnKillActive();

    if ( bContinue ) {
        m_pAlertQuery->m_strUser = m_strUserDisplay;
        bContinue = IsValidData(m_pAlertQuery, VALIDATE_FOCUS);
        if ( bContinue ) {
            // Save property page shared data.
            m_pAlertQuery->SetPropPageSharedData ( &m_SharedData );
        }
    }

    if ( bContinue ) {
        SetIsActive ( FALSE );
    }

    return bContinue;
}

BOOL 
CAlertGenProp::OnApply() 
{
    BOOL    bContinue = TRUE;
    CString strText;

    ResourceStateManager    rsm;

    bContinue = UpdateData(TRUE);

    if ( bContinue ) {
        bContinue = IsValidData(m_pAlertQuery, VALIDATE_APPLY );
    }

    if ( bContinue ) {
        bContinue = SampleTimeIsLessThanSessionTime( m_pAlertQuery );
        if ( !bContinue ) {
            SetFocusAnyPage ( IDC_ALRTS_SAMPLE_EDIT );
        }
    }

    // Write the data to the query.

    if ( bContinue ) {
        // send the list to the parent query
        // update counter list
        m_pAlertQuery->SetCounterList( m_szAlertCounterList, m_cchAlertCounterListSize );

        m_pAlertQuery->SetLogComment ( m_strComment );

        // Sample interval
        ASSERT ( SLQ_TT_TTYPE_SAMPLE == m_SharedData.stiSampleTime.wTimeType );
        ASSERT ( SLQ_TT_DTYPE_UNITS == m_SharedData.stiSampleTime.wDataType );

        // update counter sample interval
        bContinue = m_pAlertQuery->SetLogTime (&m_SharedData.stiSampleTime, (DWORD)m_SharedData.stiSampleTime.wTimeType);
    }

    if ( bContinue ) {
        // ApplyRunAs must be called before UpdateService
        bContinue = ApplyRunAs(m_pAlertQuery); 
    }

    if (bContinue) {
        bContinue = CSmPropertyPage::OnApply();
    }

    if (bContinue) {
        // Save property page shared data.
        m_pAlertQuery->UpdatePropPageSharedData();
        bContinue = UpdateService ( m_pAlertQuery, FALSE );
    }

    return bContinue;
}

void CAlertGenProp::OnCancel() 
{
    m_pAlertQuery->SyncPropPageSharedData();  // clear memory shared between property pages.
}

void CAlertGenProp::OnClose() 
{
    // free the item data pointers from the list box
    INT                 nNumItems;
    INT                 nCurSel;
    PALERT_INFO_BLOCK   paibInfo;

    nNumItems = m_CounterList.GetCount();
    if (nNumItems != LB_ERR) {
        for (nCurSel = 0; nCurSel < nNumItems; nCurSel++) {
            paibInfo = (PALERT_INFO_BLOCK)m_CounterList.GetItemDataPtr(nCurSel);
            if (paibInfo != NULL) {
                delete [] (char*)paibInfo;
                m_CounterList.SetItemDataPtr(nCurSel, NULL);
            }
        }
    }
    
    CPropertyPage::OnClose();
}

void CAlertGenProp::PostNcDestroy() 
{
//  delete this;      

    if ( NULL != m_pAlertQuery ) {
        m_pAlertQuery->SetActivePropertyPage( NULL );
    }

    CPropertyPage::PostNcDestroy();
}

BOOL CAlertGenProp::SaveAlertItemData ()
{
    // update the info block to reflect the current values
    PALERT_INFO_BLOCK   paibInfo;
    BOOL                bReturn = FALSE;
    CComboBox*          pOverUnder;
    INT                 nCurSel;
    DWORD               dwFlags;

    pOverUnder = (CComboBox *)GetDlgItem(IDC_ALRTS_OVER_UNDER);
    if ((pOverUnder != NULL) && (m_ndxCurrentItem != LB_ERR)) {
        nCurSel = m_ndxCurrentItem;
        if (nCurSel != LB_ERR) {
            paibInfo = (PALERT_INFO_BLOCK)m_CounterList.GetItemDataPtr(nCurSel);
            if (paibInfo != NULL) {
                DWORD dwOldFlags;
                double dOldLimit;
                dwOldFlags = paibInfo->dwFlags;
                dOldLimit = paibInfo->dLimit;

                if (UpdateData(TRUE)) {
                    paibInfo->dLimit = m_dLimitValue;
                    dwFlags = (pOverUnder->GetCurSel() == OU_OVER) ? AIBF_OVER : 0;
                    if ( eInvalidLimit < paibInfo->dLimit ) {
                        dwFlags |= AIBF_SAVED;
                    }
                    paibInfo->dwFlags = dwFlags;

                    if ( ( dOldLimit != m_dLimitValue ) 
                            || ( dwOldFlags & AIBF_OVER ) != ( dwFlags & AIBF_OVER ) ) { 
                        SetModifiedPage();  // to indicate a change
                    }
                    bReturn = TRUE;
                }
            }
        }
    }

    return bReturn;
}

BOOL CAlertGenProp::LoadAlertItemData (INT nIndex)
{
    // update the info block to reflect the current values
    PALERT_INFO_BLOCK   paibInfo;
    BOOL                bReturn = FALSE;
    CComboBox*          pOverUnder;
    INT                 nCurSel;

    pOverUnder = (CComboBox *)GetDlgItem(IDC_ALRTS_OVER_UNDER);

    if ( pOverUnder != NULL ) {
        nCurSel = m_CounterList.GetCurSel();
        if (nCurSel != LB_ERR) {
            paibInfo = (PALERT_INFO_BLOCK)m_CounterList.GetItemDataPtr(nCurSel);
            if (paibInfo != NULL) {
                pOverUnder->SetCurSel(
                    ((paibInfo->dwFlags & AIBF_OVER) == AIBF_OVER) ? OU_OVER : OU_UNDER);
                m_dLimitValue = paibInfo->dLimit;
                m_ndxCurrentItem = nIndex;
                // If the data is loaded from a property bag, the limit might not have been seen.
                if ( eInvalidLimit < m_dLimitValue ) {
                    paibInfo->dwFlags |= AIBF_SEEN;
                }
                UpdateData(FALSE);
                bReturn = TRUE;
            }
        }
    }

    return bReturn;
}

BOOL CAlertGenProp::SetButtonState ()
{
    BOOL    bState;
    // enable the windows base on whether or not the list box 
    // has any contents
    bState = (m_CounterList.GetCount() > 0);
    GetDlgItem(IDC_ALRTS_TRIGGER_CAPTION)->EnableWindow(bState);
    GetDlgItem(IDC_ALRTS_TRIGGER_VALUE_CAPTION)->EnableWindow(bState);
    GetDlgItem(IDC_ALRTS_OVER_UNDER)->EnableWindow(bState);
    GetDlgItem(IDC_ALRTS_VALUE_EDIT)->EnableWindow(bState);
    GetDlgItem(IDC_ALRTS_REMOVE_BTN)->EnableWindow(bState);
    GetDlgItem(IDC_ALRTS_SAMPLE_EDIT)->EnableWindow(bState);
    GetDlgItem(IDC_ALRTS_SAMPLE_CAPTION)->EnableWindow(bState);
    GetDlgItem(IDC_ALRTS_SAMPLE_INTERVAL_CAPTION)->EnableWindow(bState);
    GetDlgItem(IDC_ALRTS_SAMPLE_SPIN)->EnableWindow(bState);
    GetDlgItem(IDC_ALRTS_SAMPLE_UNITS_CAPTION)->EnableWindow(bState);
    GetDlgItem(IDC_ALRTS_SAMPLE_UNITS_COMBO)->EnableWindow(bState);
    
    if (m_pAlertQuery->GetLogService()->TargetOs() == OS_WIN2K) {
        GetDlgItem(IDC_RUNAS_STATIC)->EnableWindow(FALSE);
        GetDlgItem(IDC_RUNAS_EDIT)->EnableWindow(FALSE);
    }

    if (m_pAlertQuery->GetLogService()->TargetOs() == OS_WIN2K || 
        m_strUserDisplay.IsEmpty() || 
        m_strUserDisplay.GetAt(0) == L'<') {

        GetDlgItem(IDC_SETPWD_BTN)->EnableWindow(FALSE);
        m_bPwdButtonEnabled = FALSE;
    }

    return bState;
}

BOOL CAlertGenProp::LoadDlgFromList ()
{
    BOOL    bReturn = TRUE;
    LPWSTR  szThisString = NULL;
    DWORD   dwBufSize;
    DWORD   dwThisStringLen;
    UINT    nIndex;
    DWORD   dwItemExtent;
    CDC*    pCDC = NULL;

    PALERT_INFO_BLOCK   paibInfo = NULL;

    if (m_szAlertCounterList != NULL) {
        pCDC = m_CounterList.GetDC();

        if ( NULL != pCDC ) {

            for (szThisString = m_szAlertCounterList;
                *szThisString != 0 && TRUE == bReturn;
                szThisString += dwThisStringLen +1) {

                dwThisStringLen = lstrlen(szThisString);
                dwBufSize = sizeof (ALERT_INFO_BLOCK) + ((dwThisStringLen + 1) * sizeof (WCHAR));
                MFC_TRY
                    paibInfo = (PALERT_INFO_BLOCK) new CHAR[dwBufSize];
                MFC_CATCH_MINIMUM;
                if (paibInfo != NULL) {
                    if (MakeInfoFromString(szThisString, paibInfo, &dwBufSize)) {
                        if ( 0 <= paibInfo->dLimit ) {
                            paibInfo->dwFlags |= AIBF_SAVED;
                        }
                        nIndex = m_CounterList.AddString(paibInfo->szCounterPath);
                        if (nIndex != LB_ERR) {

                            m_CounterList.SetItemDataPtr (nIndex, (LPVOID)paibInfo);
                            // update list box extent
                            if ( NULL != pCDC ) {
                                dwItemExtent = (DWORD)(pCDC->GetTextExtent (paibInfo->szCounterPath)).cx;
                                if (dwItemExtent > m_dwMaxHorizListExtent) {
                                    m_dwMaxHorizListExtent = dwItemExtent;
                                    m_CounterList.SetHorizontalExtent(dwItemExtent);
                                }
                            }
                            paibInfo = NULL;
                        } else {
                            delete [] (char*)paibInfo;
                            bReturn = FALSE;
                        }
                    } else {
                        delete [] (char*)paibInfo;
                        bReturn = FALSE;
                    } 
                } else {
                    bReturn = FALSE;
                }
            }
        }
    }
    if ( NULL != pCDC ) {
        m_CounterList.ReleaseDC(pCDC);
        pCDC = NULL;
    }
   
    // Todo:  Error message on failure

    return bReturn;
}

BOOL CAlertGenProp::LoadListFromDlg ( INT *piInvalidEntry, BOOL bInvalidateOnly )
{
    INT                 nNumItems;
    INT                 nCurSel;
    PALERT_INFO_BLOCK   paibInfo;
    DWORD               dwSizeReqd = 0;
    DWORD               dwSize;
    DWORD               dwSizeLeft = 0;
    LPWSTR              szNextString;
    BOOL                bReturn = TRUE;

    nNumItems = m_CounterList.GetCount();
    if ((nNumItems != LB_ERR) && (nNumItems > 0)) {
        // find size required for buffer
        for (nCurSel = 0; nCurSel < nNumItems; nCurSel++) {
            paibInfo = (PALERT_INFO_BLOCK)m_CounterList.GetItemDataPtr(nCurSel);
            if (paibInfo != NULL) {
                if ((paibInfo->dwFlags & (AIBF_SEEN | AIBF_SAVED)) != 0) {
                    // First addition includes room for NULL
                    dwSizeReqd += (paibInfo->dwSize - sizeof(ALERT_INFO_BLOCK)) / sizeof (WCHAR);
                    dwSizeReqd += 1;                    // for '<' or '>'
                    dwSizeReqd += SLQ_MAX_VALUE_LEN;
                    dwSizeReqd += MAX_ALIGN_BYTES;
                } else {
                    if (piInvalidEntry != NULL) {
                        *piInvalidEntry = nCurSel;
                        bReturn = FALSE;
                        break;
                    }
                }
            }
        }
        if ( bReturn && !bInvalidateOnly ) {
            LPWSTR  pszTemp = NULL;

            dwSizeReqd += 1; // add room for the MSZ NULL
            MFC_TRY;
            pszTemp = new WCHAR[dwSizeReqd];
            MFC_CATCH_MINIMUM;

            if ( NULL != pszTemp ) {
                // allocate a block of memory for the list
                if (m_szAlertCounterList != NULL) {
                    delete [] (m_szAlertCounterList);
                }

                m_cchAlertCounterListSize = 0;
                m_szAlertCounterList = pszTemp;

                // now fill it with the Alert paths
                dwSizeLeft = dwSizeReqd;
                szNextString = m_szAlertCounterList;
                for (nCurSel = 0; nCurSel < nNumItems; nCurSel++) {
                    paibInfo = (PALERT_INFO_BLOCK)m_CounterList.GetItemDataPtr(nCurSel);
                    if (paibInfo != NULL) {
                        dwSize = dwSizeLeft;
                        if (MakeStringFromInfo (paibInfo, szNextString, &dwSize)) {
                            dwSizeLeft -= dwSize;
                            m_cchAlertCounterListSize += dwSize;
                            szNextString += dwSize; 
                            ASSERT (m_cchAlertCounterListSize < dwSizeReqd);
                        } else {
                            // ran out of buffer
                            bReturn = FALSE;
                            break;
                        }
                    }
                }
                if (bReturn) {
                    *szNextString++ = 0; // MSZ Null
                    m_cchAlertCounterListSize++;
                    if (piInvalidEntry != NULL) {
                        *piInvalidEntry = -1;
                    }
                }
            } // else error
        }
    } else {
        // no items to return
        bReturn = FALSE;
    }
    return bReturn;
}

BOOL CAlertGenProp::OnInitDialog() 
{
    CComboBox       *pCombo;
    CString         csComboBoxString;
    DWORD           nIndex;
    UINT            nResult;
    LPWSTR          szTmpCtrLst;
    DWORD           dwSize;

    ResourceStateManager    rsm;

    //
    // Here m_pAlertQuery should not be NULL, if it is,
    // There must be something wrong.
    //
    if ( NULL == m_pAlertQuery ) {
        return TRUE;
    }

    m_pAlertQuery->TranslateCounterListToLocale();
    m_bCanAccessRemoteWbem = m_pAlertQuery->GetLogService()->CanAccessWbemRemote();

    m_pAlertQuery->SetActivePropertyPage( this );

    // call property page init to init combo members.
    CSmPropertyPage::OnInitDialog();
    SetHelpIds ( (DWORD*)&s_aulHelpIds );

    Initialize( m_pAlertQuery );
    m_strUserDisplay = m_pAlertQuery->m_strUser;
    m_strUserSaved = m_strUserDisplay;

    // Load the shared data to get the sample data unit type.
    m_pAlertQuery->GetPropPageSharedData ( &m_SharedData );
    
    // load combo box    
    pCombo = &m_SampleUnitsCombo;
    pCombo->ResetContent();
    for (nIndex = 0; nIndex < dwTimeUnitComboEntries; nIndex++) {
        csComboBoxString.Empty();
        if (csComboBoxString.LoadString ( TimeUnitCombo[nIndex].nResId)) {
            nResult = pCombo->InsertString (nIndex, (LPCWSTR)csComboBoxString);
            ASSERT (nResult != CB_ERR);
            nResult = pCombo->SetItemData (nIndex, (DWORD)TimeUnitCombo[nIndex].nData);
            ASSERT (nResult != CB_ERR);
            // set selected in combo box here
            if (m_SharedData.stiSampleTime.dwUnitType == (DWORD)(TimeUnitCombo[nIndex].nData)) {
                m_nSampleUnits = nIndex;
                nResult = pCombo->SetCurSel(nIndex);
                ASSERT (nResult != CB_ERR);
            }
        }
    }

    pCombo = &m_OverUnderCombo;
    pCombo->ResetContent();
    for (nIndex = 0; nIndex < dwOverUnderComboEntries; nIndex++) {
        csComboBoxString.Empty();
        if (csComboBoxString.LoadString ( OverUnderCombo[nIndex].nResId)) {
            nResult = pCombo->InsertString (nIndex, (LPCWSTR)csComboBoxString);
            ASSERT (nResult != CB_ERR);
            nResult = pCombo->SetItemData (nIndex, (DWORD)TimeUnitCombo[nIndex].nData);
            ASSERT (nResult != CB_ERR);
        }
    }

    // get data from current alert query
    m_pAlertQuery->GetLogComment( m_strComment );
    szTmpCtrLst = (LPWSTR)m_pAlertQuery->GetCounterList (&dwSize);
    if (szTmpCtrLst != NULL) {
        MFC_TRY;
        m_szAlertCounterList = new WCHAR [dwSize];
        MFC_CATCH_MINIMUM;
        if ( NULL != m_szAlertCounterList ) {
            memcpy (m_szAlertCounterList, szTmpCtrLst, (dwSize * sizeof(WCHAR)));
            m_cchAlertCounterListSize = dwSize;
        }
    }

    // Call UpdateData again, after loading data into members.
    UpdateData ( FALSE );

    // load list box

    LoadDlgFromList();

    // m_CounterList is initialized in UpdateData    
    if (m_CounterList.GetCount() > 0) {
        m_CounterList.SetCurSel (0);
        m_CounterList.SetFocus();
        LoadAlertItemData (0);
    }

    SetButtonState ();

    return FALSE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CAlertGenProp::OnCommentEditChange()
{
    UpdateData( TRUE );    
    SetModifiedPage(TRUE);
}

void CAlertGenProp::OnCommentEditKillFocus()
{
    CString strOldText;
    strOldText = m_strComment;
    UpdateData ( TRUE );
    if ( 0 != strOldText.Compare ( m_strComment ) ) {
        SetModifiedPage(TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\alrtgenp.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    alrtgenp.h

Abstract:

    Header file for the alerts general property page.

--*/

#if !defined(_AFX_ALRTGENP_H__INCLUDED_)
#define _AFX_ALRTGENP_H__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "smalrtq.h"    // For PALERT_ACTION_INFO
#include "smproppg.h"   // Base class
#include "smcfghlp.h"

// define entries in the Over/Under combo box here
#define OU_OVER 0
#define OU_UNDER 1

// resource definitions
#define IDD_ALERT_GENERAL_PROP          1500

#define IDC_ALRTS_START_STRING          1501
#define IDC_ALRTS_SAMPLE_CAPTION        1502
#define IDC_ALRTS_SAMPLE_INTERVAL_CAPTION 1503
#define IDC_ALRTS_SAMPLE_UNITS_CAPTION  1504
#define IDC_ALRTS_TRIGGER_CAPTION       1505
#define IDC_ALRTS_TRIGGER_VALUE_CAPTION 1506
#define IDC_ALRTS_FIRST_HELP_CTRL_ID    1507
#define IDC_ALRTS_COUNTER_LIST          1507
#define IDC_ALRTS_ADD_BTN               1508
#define IDC_ALRTS_REMOVE_BTN            1509
#define IDC_ALRTS_OVER_UNDER            1510
#define IDC_ALRTS_VALUE_EDIT            1511
#define IDC_ALRTS_COMMENT_EDIT          1512
#define IDC_ALRTS_SAMPLE_EDIT           1513
#define IDC_ALRTS_SAMPLE_SPIN           1514
#define IDC_ALRTS_SAMPLE_UNITS_COMBO    1515

/////////////////////////////////////////////////////////////////////////////
// CAlertGenProp dialog

class CAlertGenProp : public CSmPropertyPage
{
    DECLARE_DYNCREATE(CAlertGenProp)

// Construction
public:
            CAlertGenProp();
            CAlertGenProp(MMC_COOKIE mmcCookie, LONG_PTR hConsole);
    virtual ~CAlertGenProp();

    enum eConstants {
        eInvalidLimit = -1
    };

// Dialog Data
    //{{AFX_DATA(CAlertGenProp)
    enum { IDD = IDD_ALERT_GENERAL_PROP };
    int         m_nSampleUnits;
    CComboBox   m_SampleUnitsCombo;
    CComboBox   m_OverUnderCombo;
    CListBox    m_CounterList;
    double      m_dLimitValue;
    CString     m_strComment;
    CString     m_strStartDisplay;
    //}}AFX_DATA
    

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CAlertGenProp)
    public:
    protected:
    virtual BOOL OnApply();
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL

// Implementation
public:
    void PublicOnSelchangeCounterList(void);

    // All of these members are Public to be accessed by the callback routine.
    LPWSTR  m_szCounterListBuffer;
    DWORD   m_dwCounterListBufferSize;
    DWORD   m_dwMaxHorizListExtent;
    PDH_BROWSE_DLG_CONFIG   m_dlgConfig;
    CSmAlertQuery       *m_pAlertQuery; // Public for callback function

    // buffers used to pass data to/from property page
    LPWSTR  m_szAlertCounterList;   // MSZ list of alert items
    DWORD   m_cchAlertCounterListSize;   // size of buffer in characters

protected:

    virtual INT GetFirstHelpCtrlId ( void ) { return IDC_ALRTS_FIRST_HELP_CTRL_ID; };
    virtual BOOL IsValidLocalData();

    // Generated message map functions
    //{{AFX_MSG(CAlertGenProp)
    afx_msg void OnDeltaposSampleSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnAddBtn();
    afx_msg void OnRemoveBtn();
    afx_msg void OnDblclkAlrtsCounterList();
    afx_msg void OnChangeAlertValueEdit();
    afx_msg void OnSelchangeCounterList();
    afx_msg void OnClose();
    afx_msg void OnCommentEditChange();
    afx_msg void OnSampleTimeChanged();
    afx_msg void OnKillFocusUpdateAlertData();
    afx_msg void OnCommentEditKillFocus();
    afx_msg void OnSelendokSampleUnitsCombo();
   	afx_msg void OnPwdBtn();
    afx_msg void OnChangeUser();

    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    INT                 m_ndxCurrentItem;

    BOOL SaveAlertItemData (void);
    BOOL LoadAlertItemData (INT nIndex);
    BOOL SetButtonState    (void);

    BOOL LoadDlgFromList ( void );
    BOOL LoadListFromDlg ( INT *piInvalidIndex, BOOL bValidateOnly = FALSE );

private:

    enum eValueRange {
        eMinSampleInterval = 1,
        eMaxSampleInterval = 999999,
        eHashTableSize = 257
    };

    // Counter Name Multi-SZ Hash Table

    typedef struct _HASH_ENTRY {
        struct _HASH_ENTRY         * pNext;
        PPDH_COUNTER_PATH_ELEMENTS   pCounter;
        DWORD   dwFlags;
        double  dLimit;
    } HASH_ENTRY, *PHASH_ENTRY;

    void    InitAlertHashTable ( void );
    void    ClearAlertHashTable ( void );
    ULONG   HashCounter ( LPWSTR szCounterName, ULONG  lHashSize );
    PDH_STATUS InsertAlertToHashTable ( PALERT_INFO_BLOCK paibInfo );

    void ImplementAdd ( void );
    void InitAfxDataItems (void);
    void UpdateAlertStartString ( void );

    PHASH_ENTRY  m_HashTable[257];
    
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(_AFX_ALRTGENP_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\cmponent.h ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation

Module Name:

    cmponent.h

Abstract:

    CComponent handles interactions with the result pane.
	MMC calls the IComponent interfaces.


--*/

#ifndef __COMPONENT_H_
#define __COMPONENT_H_

#include "Globals.h"

#include "smlogres.h"        // Resource symbols
#include "compData.h"
/////////////////////////////////////////////////////////////////////////////
// CComponent

#ifdef UNICODE
#define PROPSHEETPAGE_V3 PROPSHEETPAGEW_V3
#else
#define PROPSHEETPAGE_V3 PROPSHEETPAGEA_V3
#endif

class CSmPropertyPage;
class CSmLogQuery;
class CSmNode;

class ATL_NO_VTABLE CComponent : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CComponent, &CLSID_Component>,
    public IComponent,
    public IExtendContextMenu,               
    public IExtendControlbar,                
    public IExtendPropertySheet              

{
  public:
            CComponent();
    virtual ~CComponent();

DECLARE_REGISTRY_RESOURCEID(IDR_COMPONENT)
DECLARE_NOT_AGGREGATABLE(CComponent)

BEGIN_COM_MAP(CComponent)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)  
    COM_INTERFACE_ENTRY(IExtendControlbar)   
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
END_COM_MAP()

  // IComponent interface methods
    STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)(MMC_COOKIE cookie);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  LPOLESTR* ppViewType, long* pViewOptions);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM*  pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

  // IExtendContextMenu 
    STDMETHOD(AddMenuItems)( LPDATAOBJECT pDataObject,
                             LPCONTEXTMENUCALLBACK pCallbackUnknown,
                             long *pInsertionAllowed
                           );
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);
    
  // IExtendControlBar     
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

  // IExtendPropertySheet
    STDMETHOD(CreatePropertyPages)( LPPROPERTYSHEETCALLBACK lpProvider,
                                    LONG_PTR handle,
                                    LPDATAOBJECT lpIDataObject
                                  );

    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

    // Other public methods        
    
    HRESULT SetIComponentData(CComponentData* pData);

  private:
    enum eToolbarType {
        eLog = 1,
        eAlert = 2
    };

    HRESULT OnPaste(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM Param);
    HRESULT OnQueryPaste(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM Param);
    HRESULT OnShow(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM Param);
    HRESULT OnSelect(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM Param);
    HRESULT OnAddImages(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM Param);
    HRESULT OnRefresh(LPDATAOBJECT pDataObject);
    HRESULT OnDelete(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM Param);
    HRESULT OnDoubleClick(ULONG ulRecNo,LPDATAOBJECT pDataObject);
    HRESULT OnDisplayHelp( LPDATAOBJECT pDataObject );
    HRESULT OnViewChange(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM Param);
    HRESULT StartLogQuery(LPDATAOBJECT pDataObject);
    HRESULT StopLogQuery(LPDATAOBJECT pDataObject, BOOL bWarnOnRestartCancel=TRUE);
    HRESULT SaveLogQueryAs(LPDATAOBJECT pDataObject);
    HRESULT OnPropertyChange( LPARAM Param );
    HRESULT HandleExtToolbars( bool bDeselectAll, LPARAM arg, LPARAM Param );
    HRESULT PopulateResultPane ( MMC_COOKIE cookie );
    HRESULT RefreshResultPane ( LPDATAOBJECT pDataObject );

    HRESULT AddPropertyPage ( LPPROPERTYSHEETCALLBACK, CSmPropertyPage*& );

    HRESULT LoadLogToolbarStrings ( MMCBUTTON * Buttons );
    HRESULT LoadAlertToolbarStrings ( MMCBUTTON * Buttons );

    HRESULT _InvokePropertySheet(ULONG ulRecNo,LPDATAOBJECT pDataObject);
    HRESULT InvokePropertySheet(
                                IPropertySheetProvider *pPrshtProvider,
                                LPCWSTR wszTitle,
                                LONG lCookie,
                                LPDATAOBJECT pDataObject,
                                IExtendPropertySheet *pPrimary,
                                USHORT usStartingPage);


    LPCONSOLE        m_ipConsole;      // MMC interface to console
    IHeaderCtrl*     m_ipHeaderCtrl;   // MMC interface to header control
    IResultData*     m_ipResultData;   // MMC interface to result data
    IConsoleVerb*    m_ipConsoleVerb;  // MMC interface to console verb
    LPIMAGELIST      m_ipImageResult;  // MMC interface to result pane images
    CComponentData*  m_ipCompData;     // Parent scope pane object
    LPTOOLBAR        m_ipToolbarLogger;// Toolbar for result pane view loggers
    LPTOOLBAR        m_ipToolbarAlerts;   // Toolbar for result pane view alerts
    LPTOOLBAR        m_ipToolbarAttached;   // Currently attached toolbar
    LPCONTROLBAR     m_ipControlbar;   // Control bar to hold the tool bars
    CSmNode*         m_pViewedNode;
    HINSTANCE        m_hModule;         // resource handle for strings    
    

    // Store string data (reference) locally until per-line redraw is complete.
    CString          m_strDisplayInfoName;      
    CString          m_strDisplayInfoComment; 
    CString          m_strDisplayInfoLogFileType; 
    CString          m_strDisplayInfoLogFileName; 
    CString          m_strDisplayInfoQueryType; 
    CString          m_strDisplayInfoDesc; 
};

#endif //__COMPONENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\cmponent.cpp ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation

Module Name:

    cmponent.cpp

Abstract:

    Implementation of the CComponent class.

--*/

#include "StdAfx.h"
#include <shfolder.h>
#include <strsafe.h>
#include "smcfgmsg.h"
#include "smproppg.h"
//
#include "ctrsprop.h"
#include "fileprop.h"
#include "provprop.h"
#include "schdprop.h"
#include "tracprop.h"
#include "AlrtGenP.h"
#include "AlrtActP.h"
//
#include "newqdlg.h"
#include "ipropbag.h"
#include "smrootnd.h"
#include "smlogs.h"
#include "smtracsv.h"
#include "cmponent.h"


USE_HANDLE_MACROS("SMLOGCFG(cmponent.cpp)")

// These globals are used for dialogs and property sheets
//


#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

static MMCBUTTON ToolbarResultBtnsLog[] =
{
   { 0, IDM_NEW_QUERY,      TBSTATE_ENABLED,    TBSTYLE_BUTTON, 0, 0 },
   { 0, 0,                  TBSTATE_ENABLED,    TBSTYLE_SEP,    0, 0 },
   { 1, IDM_START_QUERY,    TBSTATE_ENABLED,    TBSTYLE_BUTTON, 0, 0 },
   { 2, IDM_STOP_QUERY,     TBSTATE_ENABLED,    TBSTYLE_BUTTON, 0, 0 }
};

static MMCBUTTON ToolbarResultBtnsAlert[] =
{
   { 0, IDM_NEW_QUERY,      TBSTATE_ENABLED,    TBSTYLE_BUTTON, 0, 0 },
   { 0, 0,                  TBSTATE_ENABLED,    TBSTYLE_SEP,    0, 0 },
   { 1, IDM_START_QUERY,    TBSTATE_ENABLED,    TBSTYLE_BUTTON, 0, 0 },
   { 2, IDM_STOP_QUERY,     TBSTATE_ENABLED,    TBSTYLE_BUTTON, 0, 0 }
};

class CButtonStringsHolder
{
public:
  CButtonStringsHolder()
  {
    m_astr = NULL;
  }
  ~CButtonStringsHolder()
  {
    if (m_astr != NULL)
      delete[] m_astr;
  }
  CString* m_astr; // dynamic array of CStrings
};

CButtonStringsHolder g_astrButtonStringsLog;
CButtonStringsHolder g_astrButtonStringsAlert;

CONST INT cResultBtnsLog = sizeof ( ToolbarResultBtnsLog ) / sizeof ( MMCBUTTON );
CONST INT cResultBtnsAlert = sizeof ( ToolbarResultBtnsAlert ) / sizeof ( MMCBUTTON );

/////////////////////////////////////////////////////////////////////////////
// CComponent

HRESULT 
CComponent::LoadLogToolbarStrings ( MMCBUTTON * Buttons )
{
    UINT i;
    HRESULT hr = S_OK;
    ResourceStateManager rsm;

    if ( NULL != Buttons ) {

        if ( NULL == g_astrButtonStringsLog.m_astr ) {
            // Load strings
            g_astrButtonStringsLog.m_astr = new CString[2*cResultBtnsLog];

            if ( NULL != g_astrButtonStringsLog.m_astr ) {
                for ( i = 0; i < cResultBtnsLog; i++) {
                    // Skip separator buttons
                    if ( 0 != Buttons[i].idCommand ) {
                        UINT iButtonTextId = 0, iTooltipTextId = 0;
    
                        switch (Buttons[i].idCommand)
                        {
                            case IDM_NEW_QUERY:
                                iButtonTextId = IDS_BUTTON_NEW_LOG;
                                iTooltipTextId = IDS_TOOLTIP_NEW_LOG;
                                break;
                            case IDM_START_QUERY:
                                iButtonTextId = IDS_BUTTON_START_LOG;
                                iTooltipTextId = IDS_TOOLTIP_START_LOG;
                                break;
                            case IDM_STOP_QUERY:
                                iButtonTextId = IDS_BUTTON_STOP_LOG;
                                iTooltipTextId = IDS_TOOLTIP_STOP_LOG;
                                break;
                            default:
                                ASSERT(FALSE);
                                break;
                        }

                        g_astrButtonStringsLog.m_astr[i*2].LoadString(iButtonTextId);
                        Buttons[i].lpButtonText =
                        const_cast<BSTR>((LPCWSTR)(g_astrButtonStringsLog.m_astr[i*2]));

                        g_astrButtonStringsLog.m_astr[(i*2)+1].LoadString(iTooltipTextId);
                        Buttons[i].lpTooltipText =
                        const_cast<BSTR>((LPCWSTR)(g_astrButtonStringsLog.m_astr[(i*2)+1]));        
                    }   
                }
            }
        } else {
            hr = E_OUTOFMEMORY;
        }
    } else {
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT 
CComponent::LoadAlertToolbarStrings ( MMCBUTTON * Buttons )
{
    HRESULT hr = S_OK;
    UINT i;
    ResourceStateManager rsm;

    if ( NULL == g_astrButtonStringsAlert.m_astr ) {
        // Load strings
        g_astrButtonStringsAlert.m_astr = new CString[2*cResultBtnsAlert];

        if ( NULL != g_astrButtonStringsAlert.m_astr ) {
        
            for ( i = 0; i < cResultBtnsAlert; i++) {
                // Skip separator buttons
                if ( 0 != Buttons[i].idCommand ) {

                  UINT iButtonTextId = 0, iTooltipTextId = 0;
                  switch (Buttons[i].idCommand)
                  {
                  case IDM_NEW_QUERY:
                    iButtonTextId = IDS_BUTTON_NEW_ALERT;
                    iTooltipTextId = IDS_TOOLTIP_NEW_ALERT;
                    break;
                  case IDM_START_QUERY:
                    iButtonTextId = IDS_BUTTON_START_ALERT;
                    iTooltipTextId = IDS_TOOLTIP_START_ALERT;
                    break;
                  case IDM_STOP_QUERY:
                    iButtonTextId = IDS_BUTTON_STOP_ALERT;
                    iTooltipTextId = IDS_TOOLTIP_STOP_ALERT;
                    break;
                  default:
                    ASSERT(FALSE);
                    break;
                  }

                  g_astrButtonStringsAlert.m_astr[i*2].LoadString(iButtonTextId);
                  Buttons[i].lpButtonText =
                    const_cast<BSTR>((LPCWSTR)(g_astrButtonStringsAlert.m_astr[i*2]));

                  g_astrButtonStringsAlert.m_astr[(i*2)+1].LoadString(iTooltipTextId);
                  Buttons[i].lpTooltipText =
                    const_cast<BSTR>((LPCWSTR)(g_astrButtonStringsAlert.m_astr[(i*2)+1]));
                }
            }
        } else {
            hr = E_OUTOFMEMORY;
        }
    } else {
        hr = E_INVALIDARG;
    }
    return hr;
}

CComponent::CComponent()
:   m_ipConsole     ( NULL ),
    m_ipHeaderCtrl  ( NULL ),
    m_ipResultData  ( NULL ),
    m_ipConsoleVerb ( NULL ),
    m_ipImageResult ( NULL ),
    m_ipCompData    ( NULL ),
    m_ipControlbar  ( NULL ),
    m_ipToolbarLogger  ( NULL ),
    m_ipToolbarAlerts  ( NULL ),
    m_ipToolbarAttached  ( NULL ),

    m_pViewedNode   ( NULL )
{
    m_hModule = (HINSTANCE)GetModuleHandleW (_CONFIG_DLL_NAME_W_);

} // end Constructor()

//---------------------------------------------------------------------------
//
CComponent::~CComponent()
{
} // end Destructor()

/////////////////////////////////////////////////////////////////////////////
// IComponent implementation
//

//---------------------------------------------------------------------------
// IComponent::Initialize is called when a snap-in is being created and
// has items in the result pane to enumerate. The pointer to IConsole that
// is passed in is used to make QueryInterface calls to the console for
// interfaces such as IResultData.
//
STDMETHODIMP
CComponent::Initialize (
    LPCONSOLE lpConsole )       // [in] Pointer to IConsole's IUnknown interface
{
    HRESULT hr = E_POINTER;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT( NULL != lpConsole );

    if ( NULL != lpConsole ) {
        // Save away all the interfaces we'll need.
        // Fail if we can't QI the required interfaces.

        m_ipConsole = lpConsole;
        m_ipConsole->AddRef();
        
        hr = m_ipConsole->QueryInterface( 
                            IID_IResultData,
                            (VOID**)&m_ipResultData );
        if ( SUCCEEDED ( hr ) ) {
            hr = m_ipConsole->QueryInterface( 
                                IID_IHeaderCtrl,
                                (VOID**)&m_ipHeaderCtrl );
            if( SUCCEEDED ( hr ) ) {
                m_ipConsole->SetHeader( m_ipHeaderCtrl );
            }

            if ( SUCCEEDED ( hr ) ) {
                hr = m_ipConsole->QueryResultImageList( &m_ipImageResult);
            }

            if ( SUCCEEDED ( hr ) ) {
                hr = m_ipConsole->QueryConsoleVerb( &m_ipConsoleVerb );
            }
        }
    }

    return hr;

} // end Initialize()


//---------------------------------------------------------------------------
//  Handle the most important notifications.
//
STDMETHODIMP
CComponent::Notify (
    LPDATAOBJECT     pDataObject,  // [in] Points to data object
    MMC_NOTIFY_TYPE  event,        // [in] Identifies action taken by user
    LPARAM           arg,          // [in] Depends on the notification type
    LPARAM           Param         // [in] Depends on the notification type
    )
{
    HRESULT hr = S_OK;
    CDataObject* pDO = NULL;
    CSmLogQuery* pQuery = NULL;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT( NULL != m_ipCompData );  

    switch( event ) {
    case MMCN_ADD_IMAGES:
        hr = OnAddImages( pDataObject, arg, Param );
        break;

    case MMCN_DELETE:
        hr = OnDelete ( pDataObject, arg, Param );
        break;

    case MMCN_PASTE:
        LOCALTRACE( L"CComponent::Notify: MMCN_PASTE unimplemented\n" );
        /*
        hr = OnPaste( pDataObject, arg, Param );
        */
        break;

    case MMCN_QUERY_PASTE:
        LOCALTRACE( L"CComponent::Notify: MMCN_QUERY_PASTE unimplemented\n" );
        /*
        hr = OnQueryPaste( pDataObject, arg, Param );
        */
        break;

    case MMCN_REFRESH:
        hr = OnRefresh( pDataObject );
        break;

    case MMCN_SELECT:
        hr = OnSelect( pDataObject, arg, Param );
        break;

    case MMCN_SHOW:
        hr = OnShow( pDataObject, arg, Param );
        break;

    case MMCN_VIEW_CHANGE:
        hr = OnViewChange( pDataObject, arg, Param );
        break;

    case MMCN_PROPERTY_CHANGE:

        if ( NULL != Param ) {
            // Data object is passed as parameter
            hr = OnViewChange( (LPDATAOBJECT)Param, arg, CComponentData::eSmHintModifyQuery );
        } else {
            hr = S_FALSE;
        }
        break;

    case MMCN_CLICK:
        LOCALTRACE( L"CComponent::Notify: MMCN_CLICK unimplemented\n" );
        break;

    case MMCN_DBLCLICK:
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL != pDO ) {
            hr = (HRESULT) OnDoubleClick ((ULONG) pDO->GetCookie(),pDataObject);
        } else { 
            hr = S_FALSE;
        }
        break;

    case MMCN_ACTIVATE:
        LOCALTRACE( L"CComponent::Notify: MMCN_ACTIVATE unimplemented\n" );
        break;

    case MMCN_MINIMIZED:
        LOCALTRACE( L"CComponent::Notify: MMCN_MINIMIZED unimplemented\n" );
        break;

    case MMCN_BTN_CLICK:
        LOCALTRACE( L"CComponent::Notify: MMCN_BTN_CLICK unimplemented\n" );
        break;

    case MMCN_CONTEXTHELP:
        hr = OnDisplayHelp( pDataObject );
        break;

    default:
        LOCALTRACE( L"CComponent::Notify: unimplemented event %x\n", event );
        hr = S_FALSE;
        break;
    }
    return hr;

} // end Notify()


//---------------------------------------------------------------------------
// Releases all references to the console.
// Only the console should call this method.
//
STDMETHODIMP
CComponent::Destroy (
    MMC_COOKIE     /* mmcCookie */         // Reserved, not in use at this time
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Release the interfaces that we QI'ed
    m_ipConsole->SetHeader(NULL);

    SAFE_RELEASE( m_ipHeaderCtrl  );
    SAFE_RELEASE( m_ipResultData  );
    SAFE_RELEASE( m_ipImageResult );
    SAFE_RELEASE( m_ipConsoleVerb );
    SAFE_RELEASE( m_ipConsole     );
    SAFE_RELEASE( m_ipControlbar  );
    SAFE_RELEASE( m_ipToolbarLogger );
    SAFE_RELEASE( m_ipToolbarAlerts );

    return S_OK;

} // end Destroy()


//---------------------------------------------------------------------------
// Returns a data object that can be used to retrieve context information
// for the specified mmcCookie.
//
STDMETHODIMP
CComponent::QueryDataObject (
    MMC_COOKIE         mmcCookie,   // [in]  Specifies the unique identifier
    DATA_OBJECT_TYPES  context,     // [in]  Type of data object
    LPDATAOBJECT*      ppDataObject // [out] Points to address of returned data
    )
{
    HRESULT hr = S_OK;
    BOOL bIsQuery = FALSE;
    CComObject<CDataObject>* pDataObj = NULL;
    CSmLogQuery* pQuery = NULL;
    INT iResult;
    CString strMessage;
    ResourceStateManager    rsm;
    
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    ASSERT( CCT_SCOPE == context                // Must have a context
            || CCT_RESULT == context            // we understand
            || CCT_SNAPIN_MANAGER == context );

    ASSERT( NULL != m_ipCompData );  

    if ( NULL != ppDataObject 
        && ( CCT_SCOPE == context                // Must have a context
                || CCT_RESULT == context            // we understand
                || CCT_SNAPIN_MANAGER == context ) ) 
    {
        if ( NULL != m_ipCompData 
            && NULL != m_ipConsole ) 
        {

            if( CCT_RESULT == context && NULL != mmcCookie ) {
                CComObject<CDataObject>::CreateInstance( &pDataObj );
                if( NULL == pDataObj ) {             // DataObject was not created
                    MFC_TRY
                        strMessage.LoadString( IDS_ERRMSG_OUTOFMEMORY );
                    MFC_CATCH_HR
                    hr = m_ipConsole->MessageBox( strMessage,
                        L"CComponent::QueryDataObject", // not localized
                        MB_OK | MB_ICONERROR,
                        &iResult
                        );
                    hr = E_OUTOFMEMORY;
                } else {
                    // Now we have a data object, init the mmcCookie, context and type
                    bIsQuery = m_ipCompData->IsLogQuery (mmcCookie);

                    if ( bIsQuery ) {
                        pQuery = (CSmLogQuery*)mmcCookie;
                        ASSERT ( NULL != pQuery );
                        if ( NULL != pQuery ) {
                            if ( CComponentData::eCounterLog == pQuery->GetLogType() ) {
                                pDataObj->SetData( mmcCookie, CCT_RESULT, COOKIE_IS_COUNTERMAINNODE );
                            } else if ( CComponentData::eTraceLog == pQuery->GetLogType() ) {
                                pDataObj->SetData( mmcCookie, CCT_RESULT, COOKIE_IS_TRACEMAINNODE );
                            } else if ( CComponentData::eAlert == pQuery->GetLogType() ) {
                                pDataObj->SetData( mmcCookie, CCT_RESULT, COOKIE_IS_ALERTMAINNODE );
                            } else {
                                ::MessageBox( NULL,
                                    L"Bad Cookie",
                                    L"CComponentData::QueryDataObject",
                                    MB_OK | MB_ICONERROR
                                    );
                                hr = E_OUTOFMEMORY;
                            }
                        }                 
                    } else {
                        if  ( m_ipCompData->IsScopeNode( mmcCookie ) ) {
                            if ( NULL != (reinterpret_cast<PSMNODE>(mmcCookie))->CastToRootNode() ) {
                                pDataObj->SetData(mmcCookie, CCT_RESULT, COOKIE_IS_ROOTNODE);
                            } else {
                                ::MessageBox( NULL,
                                    L"Bad Cookie",
                                    L"CComponentData::QueryDataObject",
                                    MB_OK | MB_ICONERROR
                                    );
                                hr = E_OUTOFMEMORY;
                            }
                        }
                    }
                }
            } else if ((CCT_SNAPIN_MANAGER == context) && (NULL != mmcCookie)) {
                // this is received by the snap in when it is added
                // as an extension snap ine
                CComObject<CDataObject>::CreateInstance( &pDataObj );
                if( NULL == pDataObj ) {            // DataObject was not created
                    MFC_TRY
                        strMessage.LoadString( IDS_ERRMSG_OUTOFMEMORY );
                    MFC_CATCH_HR
                    hr = m_ipConsole->MessageBox( strMessage,
                        L"CComponent::QueryDataObject",  // not localized
                        MB_OK | MB_ICONERROR,
                        &iResult
                        );
                    hr = E_OUTOFMEMORY;
                } else {
                    // Now we have a data object, init the mmcCookie, context and type
                    pDataObj->SetData( mmcCookie, CCT_SNAPIN_MANAGER, COOKIE_IS_MYCOMPUTER );
                }
            } else {                                // Request must have been from an
                                                    // unknown source.  Should never see
                ASSERT ( FALSE );
                hr = E_UNEXPECTED;
            }

            if ( SUCCEEDED ( hr ) ) {
                hr = pDataObj->QueryInterface( IID_IDataObject,
                    reinterpret_cast<void**>(ppDataObject) );
            } else {
                if ( NULL != pDataObj ) {
                    delete pDataObj;
                }
                *ppDataObject = NULL;
            }
        } else {
            hr = S_FALSE;
        }
    } else {
        hr = E_POINTER;
    }

    return hr;
} // end QueryDataObject()


//---------------------------------------------------------------------------
// This is where we provide strings for items we added to the the result
// pane.  We get asked for a string for each column.
// Note that we still need to provide strings for items that are actually
// scope pane items. Notice that when the scope pane item was asked for a
// string for the scope pane we gave it. Here we actually have two columns
// of strings - "Name" and "Type".
// We also get asked for the icons for items in both panes.
//

STDMETHODIMP
CComponent::GetDisplayInfo (
    LPRESULTDATAITEM pResultItem )  // [in,out] Type of info required
{
    HRESULT     hr = S_OK;
    PSLQUERY    pQuery;
    CSmNode*    pNode;
    PSROOT      pRoot;
    PSLSVC      pSvc;
    WCHAR       szErrorText[MAX_PATH + 1];
    ResourceStateManager    rsm;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if ( NULL == pResultItem ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        if( FALSE == pResultItem->bScopeItem ) {  // Doing result items...
            if( pResultItem->mask & RDI_STR ) {   // Now we have a object
                // Note:  Text buffer allocated for each information type, so that
                // the buffer pointer is persistent for a single item (line in the result pane).

                MFC_TRY

                switch (pResultItem->nCol) {
                case ROOT_COL_QUERY_NAME:
                    pQuery = reinterpret_cast<PSLQUERY>(pResultItem->lParam);
                    m_strDisplayInfoName = pQuery->GetLogName ( );
                    pResultItem->str = m_strDisplayInfoName.GetBuffer( 0 );
                    m_strDisplayInfoName.ReleaseBuffer( );
                    break;

                case ROOT_COL_COMMENT:
                    pQuery= reinterpret_cast<PSLQUERY>(pResultItem->lParam);
                    m_strDisplayInfoComment = pQuery->GetLogComment ( );
                    pResultItem->str = m_strDisplayInfoComment.GetBuffer( 0 );
                    m_strDisplayInfoComment.ReleaseBuffer( );
                    break;

                case ROOT_COL_LOG_TYPE:
                    pQuery= reinterpret_cast<PSLQUERY>(pResultItem->lParam);
                    // Query type should not be Alert
                    ASSERT ( SLQ_ALERT != pQuery->GetLogType() );
                    m_strDisplayInfoLogFileType =  pQuery->GetLogFileType ( );
                    pResultItem->str = m_strDisplayInfoLogFileType.GetBuffer( 0 );
                    m_strDisplayInfoLogFileType.ReleaseBuffer( );
                    break;

                case ROOT_COL_LOG_NAME:
                    pQuery= reinterpret_cast<PSLQUERY>(pResultItem->lParam);
                    // Query type should not be Alert
                    ASSERT ( SLQ_ALERT != pQuery->GetLogType() );
                    m_strDisplayInfoLogFileName = pQuery->GetLogFileName ();
                    pResultItem->str = m_strDisplayInfoLogFileName.GetBuffer( 0 );
                    m_strDisplayInfoLogFileName.ReleaseBuffer( );
                    break;

                default:
                    StringCchPrintf ( szErrorText, MAX_PATH + 1, L"Error: Column %d Selected for Result Item\n", pResultItem->nCol);
                    ASSERT ( FALSE );
                    LOCALTRACE( szErrorText );
                    hr = E_UNEXPECTED;
                }

                MFC_CATCH_HR 
            }

            if (pResultItem->mask & RDI_IMAGE) {
                pQuery= reinterpret_cast<PSLQUERY>(pResultItem->lParam);
                if ( NULL != pQuery ) {
                    pResultItem->nImage = (pQuery->IsRunning() ? 0 : 1);
                } else {
                    ASSERT ( FALSE );
                    hr = E_UNEXPECTED;
                }
            }
        }
        else  // TRUE == pResultItem->bScopeItem
        {
            pNode = reinterpret_cast<CSmNode*>(pResultItem->lParam);

            if( pResultItem->mask & RDI_STR ) {
                if ( pNode->CastToRootNode() ) {

                    MFC_TRY

                    pRoot = reinterpret_cast<PSROOT>(pResultItem->lParam);

                    switch ( pResultItem->nCol ) {
                    case EXTENSION_COL_NAME:
                        m_strDisplayInfoName = pRoot->GetDisplayName();
                        pResultItem->str = m_strDisplayInfoName.GetBuffer( 0 );
                        m_strDisplayInfoName.ReleaseBuffer( );
                        break;

                    case EXTENSION_COL_TYPE:
                        m_strDisplayInfoQueryType = pRoot->GetType();
                        pResultItem->str = m_strDisplayInfoQueryType.GetBuffer( 0 );
                        m_strDisplayInfoQueryType.ReleaseBuffer( );
                        break;

                    case EXTENSION_COL_DESC:
                        m_strDisplayInfoDesc = pRoot->GetDescription();
                        pResultItem->str = m_strDisplayInfoDesc.GetBuffer( 0 );
                        m_strDisplayInfoDesc.ReleaseBuffer( );
                        break;

                    default:
                        StringCchPrintf ( szErrorText, MAX_PATH + 1, L"Error: Column %d Selected for Scope Item\n", pResultItem->nCol);
                             ASSERT ( FALSE );
                        LOCALTRACE( szErrorText );
                        hr = E_UNEXPECTED;
                    }
                    
                    MFC_CATCH_HR
                } else {

                    ASSERT ( pNode->CastToLogService() );

                    MFC_TRY

                    if( pResultItem->nCol == MAIN_COL_NAME ) {
                        pSvc = reinterpret_cast<PSLSVC>(pResultItem->lParam);
                        m_strDisplayInfoName = pSvc->GetDisplayName();
                        pResultItem->str = m_strDisplayInfoName.GetBuffer( 0 );
                        m_strDisplayInfoName.ReleaseBuffer( );
                    } else if( pResultItem->nCol == MAIN_COL_DESC ) {
                        pSvc = reinterpret_cast<PSLSVC>(pResultItem->lParam);
                        m_strDisplayInfoDesc = pSvc->GetDescription();
                        pResultItem->str = m_strDisplayInfoDesc.GetBuffer( 0 );
                        m_strDisplayInfoDesc.ReleaseBuffer( );
                    } else {
                        StringCchPrintf ( szErrorText, MAX_PATH + 1, L"Error: Column %d Selected for Result Item\n", pResultItem->nCol);
                        ASSERT ( FALSE );
                        LOCALTRACE( szErrorText );
                        hr = E_UNEXPECTED;
                    }

                    MFC_CATCH_HR
                }
            }

            if (pResultItem->mask & RDI_IMAGE)
            {
                if ( NULL != pNode->CastToRootNode() ) {
                    pResultItem->nImage = CComponentData::eBmpRootIcon;
                } else if ( NULL != pNode->CastToAlertService() ) {
                    pResultItem->nImage = CComponentData::eBmpAlertType;
                } else {
                    pResultItem->nImage = CComponentData::eBmpLogType;
                }
            }
        }
    }

    return hr;

} // end GetDisplayInfo()


//---------------------------------------------------------------------------
// Determines what the result pane view should be
//
STDMETHODIMP
CComponent::GetResultViewType (
    MMC_COOKIE  /* mmcCookie */,        // [in]  Specifies the unique identifier
    BSTR  *ppViewType,   // [out] Points to address of the returned view type
    long  *pViewOptions  // [out] Pointer to the MMC_VIEW_OPTIONS enumeration
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Ask for default listview.
    if ( NULL != ppViewType ) {
        *ppViewType = NULL;
    }

    if ( NULL != pViewOptions ) {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
    }

    return S_FALSE;

} // end GetResultViewType()


//---------------------------------------------------------------------------
// Not used
//
HRESULT
CComponent::CompareObjects (
    LPDATAOBJECT /* lpDataObjectA */,  // [in] First data object to compare
    LPDATAOBJECT /* lpDataObjectB */  // [in] Second data object to compare
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return S_FALSE;

} // end CompareObjects()


/////////////////////////////////////////////////////////////////////////////
//  Support methods
//

//---------------------------------------------------------------------------
// Here is where we handle the MMCN_SHOW message.  Insert the column
// headers, and then the rows of data into the result pane.
//
HRESULT
CComponent::OnShow (
    LPDATAOBJECT pDataObject,    // [in] Points to data object
    LPARAM       Arg,            // [in]
    LPARAM       /* Param */ )   // [in] not used
{
    HRESULT         hr = S_OK;
    CDataObject*    pDO = NULL;
    CString         strColHeader;
    INT             iCommentSize;
    PSLSVC          pSvc = NULL;

    ResourceStateManager rsm;

    if ( TRUE == Arg ) {
    
        if ( NULL == pDataObject ) {
            ASSERT ( FALSE );
            hr = E_POINTER;
        } else {
            pDO = ExtractOwnDataObject(pDataObject);
            if ( NULL == pDO ) {
                ASSERT ( FALSE );
                hr = E_UNEXPECTED;
            }
        }

        if ( SUCCEEDED ( hr ) ) {

            if ( NULL == m_ipHeaderCtrl ) { 
                hr = S_FALSE;
            } else {
            
                m_pViewedNode = (CSmNode*)pDO->GetCookie();
            
                if( !(COOKIE_IS_ROOTNODE == pDO->GetCookieType() ) ) {

                    // Query name
                    MFC_TRY
                        strColHeader.LoadString ( IDS_ROOT_COL_QUERY_NAME );
                    MFC_CATCH_HR;

                    hr = m_ipHeaderCtrl->InsertColumn(  
                            ROOT_COL_QUERY_NAME,
                            strColHeader,
                            LVCFMT_LEFT,
                            ROOT_COL_QUERY_NAME_SIZE );
                    ASSERT( S_OK == hr );

                    // Comment
                    STANDARD_TRY
                        strColHeader.LoadString ( IDS_ROOT_COL_COMMENT );
                    MFC_CATCH_HR

                    iCommentSize = ROOT_COL_COMMENT_SIZE;
            
                    if ( COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() ) {
                         iCommentSize += ROOT_COL_ALERT_COMMENT_XTRA;
                    }

                    hr = m_ipHeaderCtrl->InsertColumn(  
                            ROOT_COL_COMMENT,
                            strColHeader,
                            LVCFMT_LEFT,
                            iCommentSize);
                    ASSERT( S_OK == hr );

                    // Log type
                    if ( COOKIE_IS_COUNTERMAINNODE == pDO->GetCookieType()
                        || COOKIE_IS_TRACEMAINNODE == pDO->GetCookieType() ) {

                        STANDARD_TRY
                            strColHeader.LoadString ( IDS_ROOT_COL_LOG_TYPE );
                        MFC_CATCH_HR

                        hr = m_ipHeaderCtrl->InsertColumn(  
                                ROOT_COL_LOG_TYPE,
                                strColHeader,
                                LVCFMT_LEFT,
                                ROOT_COL_LOG_TYPE_SIZE);
                        ASSERT( S_OK == hr );

                        STANDARD_TRY
                            strColHeader.LoadString ( IDS_ROOT_COL_LOG_FILE_NAME );
                        MFC_CATCH_HR

                        hr = m_ipHeaderCtrl->InsertColumn(  
                                ROOT_COL_LOG_NAME,
                                strColHeader,
                                LVCFMT_LEFT,
                                ROOT_COL_LOG_NAME_SIZE);
                        ASSERT( S_OK == hr );
                    }

                    // Set the items in the results pane rows
                    ASSERT( CCT_SCOPE == pDO->GetContext() );
                    ASSERT( COOKIE_IS_COUNTERMAINNODE == pDO->GetCookieType()
                            || COOKIE_IS_TRACEMAINNODE == pDO->GetCookieType()
                            || COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() );


                    // The lParam is what we see in QueryDataObject as the mmcCookie.
                    // Now we have an object representing row data, so that the
                    // mmcCookie knows what to display in the results pane, when we
                    // get into GetDisplayInfo we cast the mmcCookie to our object,
                    // and then we can get the data to display.
                    //

                    pSvc = reinterpret_cast<PSLSVC>(pDO->GetCookie());
                    if ( NULL != pSvc ) {
                        // m_pViewedNode has already been set to the cookie value.
                        if ( TRUE == pSvc->GetRefreshOnShow() ) {
                            hr = RefreshResultPane( pDataObject );
                        } else {
                            hr = PopulateResultPane( pDO->GetCookie() );
                        }
                        if ( SUCCEEDED ( hr ) ) {
                            pSvc->SetRefreshOnShow ( FALSE );
                        }
                    }
                } else {

                    MFC_TRY
                        strColHeader.LoadString ( IDS_MAIN_COL_NODE_NAME );
                    MFC_CATCH_HR

                    if ( SUCCEEDED ( hr ) ) {
                        // Set the column headers in the results pane
                        hr = m_ipHeaderCtrl->InsertColumn(  
                                MAIN_COL_NAME,
                                strColHeader,
                                LVCFMT_LEFT,
                                MAIN_COL_NAME_SIZE);
                        ASSERT( S_OK == hr );

                        STANDARD_TRY
                            strColHeader.LoadString ( IDS_MAIN_COL_NODE_DESCRIPTION );
                        MFC_CATCH_HR

                        hr = m_ipHeaderCtrl->InsertColumn(  
                                MAIN_COL_DESC,
                                strColHeader,
                                LVCFMT_LEFT,
                                MAIN_COL_DESC_SIZE);
                        ASSERT( S_OK == hr );
                    }
                }
            }
        }
    } else {
        m_pViewedNode = NULL;
    }
    return hr;

} // end OnShow()

//---------------------------------------------------------------------------
//
HRESULT
CComponent::OnAddImages (
    LPDATAOBJECT /* pDataObject */,  // [in] Points to the data object
    LPARAM /* arg */,                  // [in] Not used
    LPARAM /* param */                // [in] Not used
    )
{
    HRESULT hr = S_FALSE;
    ASSERT( NULL != m_ipImageResult );

    HBITMAP hbmp16x16 = NULL;
    HBITMAP hbmp32x32 = NULL;

    if ( NULL != g_hinst && NULL != m_ipImageResult ) {
        hbmp16x16 = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_NODES_16x16));
        hbmp32x32 = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_NODES_32x32));

        hr = m_ipImageResult->ImageListSetStrip(
            (LONG_PTR *)hbmp16x16,
            (LONG_PTR *)hbmp32x32,
            0,
            RGB(0,255,0)
            );

        ASSERT( S_OK == hr );

        if ( NULL != hbmp16x16 ) 
        {
            DeleteObject (hbmp16x16);
        }

        if ( NULL != hbmp32x32 ) 
        {
            DeleteObject (hbmp32x32);
        }
    }
    return hr;

} // end OnAddImages()

//---------------------------------------------------------------------------
//  This is a handler for the MMCN_PASTE notification. The user
//  copied a node to the clipboard.  Paste the counters from the data object
//  into the currently selected node.
//
HRESULT
CComponent::OnPaste (
    LPDATAOBJECT   pDataObject,  // [in] Points to the data object
    LPARAM         arg,          // [in] Points to source data object
    LPARAM     /*  param  */     // [in] Not used
    )
{
    HRESULT hr = S_FALSE;
    CDataObject* pDO = NULL;
    CDataObject* pDOSource = NULL;
    BOOL bIsQuery = FALSE;

    ASSERT( NULL != m_ipCompData );  

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
    }

    if ( SUCCEEDED ( hr ) ) {
        // Bail if we couldn't get the console verb interface, or if the
        // selected item is the root;
        if ( NULL == (LPDATAOBJECT)arg ) {
            ASSERT ( FALSE );
            hr = E_INVALIDARG;
        } else {
            pDOSource = ExtractOwnDataObject((LPDATAOBJECT)arg);
        }
    }

    if ( SUCCEEDED ( hr ) 
        && NULL != pDO 
        && NULL != pDOSource
        && NULL != m_ipCompData ) 
    {
        bIsQuery = m_ipCompData->IsLogQuery (pDO->GetCookie())
                    && m_ipCompData->IsLogQuery (pDOSource->GetCookie());
        // Note: Can't check with compdata to determine if query, because
        // can be from another compdata

        if ( bIsQuery )
            hr = S_OK;
    }
    return hr;
} // end OnPaste()

//---------------------------------------------------------------------------
//  This is a handler for the MMCN_QUERY_PASTE notification. The user
//  copied a node to the clipboard.  Determine if that data object
//  can be pasted into the currently selected node.
//
HRESULT
CComponent::OnQueryPaste (
    LPDATAOBJECT   pDataObject,  // [in] Points to the data object
    LPARAM         arg,          // [in] Points to source data object
    LPARAM     /*  param  */ )   // [in] Not used
{
    HRESULT hr = S_FALSE;
    CDataObject* pDO = NULL;
    CDataObject* pDOSource = NULL;
    BOOL bIsQuery = FALSE;
    BOOL bState;

    ASSERT( NULL != m_ipCompData );  

    // Bail if we couldn't get the console verb interface, or if the
    // selected item is the root;
    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
    }

    if ( SUCCEEDED ( hr ) ) {
        if ( NULL == (LPDATAOBJECT)arg ) {
            ASSERT ( FALSE );
            hr = E_INVALIDARG;
        } else {
            pDOSource = ExtractOwnDataObject((LPDATAOBJECT)arg);
        }
    }

    if ( SUCCEEDED ( hr) 
        && NULL != pDO 
        && NULL != pDOSource
        && NULL != m_ipCompData 
        && NULL != m_ipConsoleVerb ) 
    {
        bIsQuery = m_ipCompData->IsLogQuery (pDO->GetCookie());

        if ( bIsQuery ) {
            hr = m_ipConsoleVerb->GetVerbState ( MMC_VERB_PASTE, ENABLED, &bState );
            hr = m_ipConsoleVerb->SetVerbState( MMC_VERB_PASTE, ENABLED, TRUE );
            hr = m_ipConsoleVerb->GetVerbState ( MMC_VERB_PASTE, ENABLED, &bState );
            ASSERT( S_OK == hr );

            hr = S_OK;
        }
    }
    return hr;
} // end OnQueryPaste()

//---------------------------------------------------------------------------
//  This is a handler for the MMCN_SELECT notification. The user
//  selected the node that populated the result pane. We have a
//  chance to enable verbs.
//
HRESULT
CComponent::OnSelect (
    LPDATAOBJECT   pDataObject,  // [in] Points to the data object
    LPARAM         arg,          // [in] Contains flags about the selected item
    LPARAM     /*  param  */ )   // [in] Not used
{
    HRESULT     hr = S_OK;
    BOOL        fScopePane;
    BOOL        fSelected;
    CDataObject* pDO = NULL;
    MMC_COOKIE  mmcCookie = 0;
    BOOL    bIsQuery = FALSE;
    CSmNode* pNode = NULL;
    PSLQUERY pQuery = NULL;

    ASSERT( NULL != m_ipCompData );  

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    if ( SUCCEEDED ( hr ) ) {
        // Bail if we couldn't get the console verb interface, or if the
        // selected item is the root;
        if( NULL == m_ipConsoleVerb || COOKIE_IS_ROOTNODE == pDO->GetCookieType() ) {
            hr = S_OK;
        } else {

            // Use selections and set which verbs are allowed

            fScopePane = LOWORD(arg);
            fSelected  = HIWORD(arg);

            if( fScopePane ) {                    // Selection in the scope pane
                // Enabled refresh for main node type, only if that node type is currently
                // being viewed in the result pane.
                if ( fSelected ) {
                    if ( COOKIE_IS_COUNTERMAINNODE == pDO->GetCookieType()
                                || COOKIE_IS_TRACEMAINNODE == pDO->GetCookieType()
                                || COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() ) {
                        if ( NULL != m_pViewedNode ) {
                            if ( m_pViewedNode == (CSmNode*)pDO->GetCookie() ) {
                                hr = m_ipConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );
                                ASSERT( S_OK == hr );
                            }
                        }
                    }
                }
            } else {                                 
                // Selection in the result pane
                // Properties is default verb

                if ( NULL != m_ipCompData
                    && NULL != m_ipConsoleVerb ) 
                {

                    if ( COOKIE_IS_COUNTERMAINNODE == pDO->GetCookieType()
                                || COOKIE_IS_TRACEMAINNODE == pDO->GetCookieType()
                                || COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() ) 
                    {
                        if ( NULL != m_pViewedNode ) {
                            mmcCookie = (MMC_COOKIE)pDO->GetCookie();

                            bIsQuery = m_ipCompData->IsLogQuery (mmcCookie);

                            if ( bIsQuery ) {
                                pQuery = (PSLQUERY)pDO->GetCookie();
                                if ( NULL != pQuery ) {
                                    pNode = (CSmNode*)pQuery->GetLogService();
                                }
                            } else {
                                pNode = (CSmNode*)pDO->GetCookie();
                            }

                            if ( NULL != m_pViewedNode && m_pViewedNode == pNode ) {
                                hr = m_ipConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );
                                ASSERT( S_OK == hr );
                            }
                        }
                    }

                    if ( fSelected ) {
                        hr = m_ipConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES );
                        ASSERT( S_OK == hr );

                        // Enable properties and delete verbs
                        hr = m_ipConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE );
                        ASSERT( S_OK == hr );
                        hr = m_ipConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, TRUE );
                        ASSERT( S_OK == hr );
    /*
                        // Enable copying and pasting the object
                        hr = m_ipConsoleVerb->SetVerbState( MMC_VERB_COPY, ENABLED, TRUE );
                        ASSERT( S_OK == hr );
                        hr = m_ipConsoleVerb->SetVerbState( MMC_VERB_PASTE, HIDDEN, FALSE );
                        hr = m_ipConsoleVerb->SetVerbState( MMC_VERB_PASTE, ENABLED, FALSE );
                        ASSERT( S_OK == hr );
                    } else {
                        hr = m_ipConsoleVerb->SetVerbState( MMC_VERB_PASTE, HIDDEN, FALSE );
                        hr = m_ipConsoleVerb->SetVerbState( MMC_VERB_PASTE, ENABLED, FALSE );
                        ASSERT( S_OK == hr );
    */
                    }
                }
            }
            hr = S_OK;
        }
    }

    return hr;

} // end OnSelect()


//---------------------------------------------------------------------------
//  Respond to the MMCN_REFRESH notification and refresh the rows.
//
HRESULT
CComponent::OnRefresh (
    LPDATAOBJECT pDataObject )  // [in] Points to the data object
{
    HRESULT hr = S_OK;
    CDataObject* pDO = NULL;
    
    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    if ( SUCCEEDED ( hr ) ) {
        // If this is the root node, don't need to do anything
        if( COOKIE_IS_ROOTNODE == pDO->GetCookieType() ) {
            hr = S_FALSE;
        } else {
            // Refresh the data model and update the result pane.
            if ( NULL != m_pViewedNode ) {
                hr = RefreshResultPane( pDataObject );
            }
            // RefreshResultPane cancels any selection.
            hr = HandleExtToolbars( TRUE, (LPARAM)0, (LPARAM)pDataObject );
        }
    }
    return hr;
} // end OnRefresh()

//---------------------------------------------------------------------------
//  Respond to the MMCN_VIEW_CHANGE notification and refresh as specified.
//
HRESULT
CComponent::OnViewChange (
    LPDATAOBJECT   pDataObject,  // [in] Points to the data object
    LPARAM         /* arg */,    // [in] Not used
    LPARAM         param )       // [in] Contains view change hint
{
    HRESULT hr = S_OK;
    CDataObject* pDO = NULL;

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    if ( SUCCEEDED ( hr ) ) {

        if ( NULL == m_ipCompData 
            || NULL == m_ipResultData ) 
        {
            hr = S_FALSE;
        } else {
                
            if ( m_ipCompData->IsLogService ( pDO->GetCookie() ) 
                && CComponentData::eSmHintNewQuery == param ) 
            {
                hr = OnRefresh( pDataObject );
            } else if ( CComponentData::eSmHintPreRefresh == param ) 
            {   
                // Delete the result items in each view before refreshing 
                // the queries, to handle the case where queries have been deleted.
                hr = m_ipResultData->DeleteAllRsltItems();
            } else if ( CComponentData::eSmHintRefresh == param ) 
            {
                // Use the stored pointer to the known viewed node, to handle the
                // case where the result pane contains scope nodes, and to handle
                // the case where the cookie is a query.
                hr = PopulateResultPane( (MMC_COOKIE)m_pViewedNode );
            } else {
                hr = S_FALSE;
                if ( CCT_RESULT == pDO->GetContext() ) {
                    HRESULTITEM hItemID = NULL;
                    PSLQUERY    pSlQuery = reinterpret_cast<PSLQUERY>(pDO->GetCookie());

                    if ( NULL != pSlQuery ) {
                        // Redraw the item or delete it.
                        hr = m_ipResultData->FindItemByLParam ( (LPARAM)pSlQuery, &hItemID );
                        if ( SUCCEEDED(hr) ) {
                            if ( CComponentData::eSmHintPreDeleteQuery == param ) {
                                hr = m_ipResultData->DeleteItem ( hItemID, 0 );
                            } else {
                                // Query modified via property dialog, or by manual start or stop.
                                hr = m_ipResultData->UpdateItem  ( hItemID );
                            }
                        }
                    }

                    // Sync the toolbar start/stop buttons.
                    // 0 second arg indicates result scope.
                    hr = HandleExtToolbars( FALSE, (LPARAM)0, (LPARAM)pDataObject );
                }
            }
        }
    }
    return hr;
}
//---------------------------------------------------------------------------
//          Implementing a handler for MMCN_PROPERTY_CHANGE.
//          Param is the address of the PROPCHANGE struct that originally
//          came from the PropertySheet via MMCPropertyChangeNotify()
//
HRESULT
CComponent::OnPropertyChange (
    LPARAM     /*  param  */   // [in] PROPCHANGE_DATA struct with new data
    )
{

    return S_OK;
} // end OnPropertyChange()

//---------------------------------------------------------------------------
//  Store the parent IComponetData object.
//
HRESULT
CComponent::SetIComponentData (
    CComponentData*  pData )    // [in] Parent CComponentData object
{
    HRESULT hr = E_POINTER;
    LPUNKNOWN pUnk = NULL;

    ASSERT( NULL == m_ipCompData );        // Can't do this twice

    if ( NULL != pData 
        && NULL == m_ipCompData ) 
    {
        pUnk = pData->GetUnknown();  // Get the object IUnknown

        if ( NULL != pUnk ) {
            hr = pUnk->QueryInterface( IID_IComponentData,
                    reinterpret_cast<void**>(&m_ipCompData) );
        } else {
            hr = E_UNEXPECTED;
        }
    }
    return hr;
} // end SetIComponentData()

//---------------------------------------------------------------------------
//  Respond to the MMCN_CONTEXTHELP notification.
//
HRESULT
CComponent::OnDisplayHelp (
    LPDATAOBJECT /* pDataObject */ )  // [in] Points to the data object
{
    HRESULT hr = E_FAIL;
    IDisplayHelp* pDisplayHelp;
    CString strTopicPath;
    LPOLESTR pCompiledHelpFile = NULL;
    UINT    nBytes;
    
    USES_CONVERSION;

    if ( NULL == m_ipCompData
            || NULL == m_ipConsole )
    { 
        hr = S_FALSE;
    } else {

        hr = m_ipConsole->QueryInterface(IID_IDisplayHelp, reinterpret_cast<void**>(&pDisplayHelp));
    
        if ( SUCCEEDED(hr) ) {
            MFC_TRY
                // construct help topic path = (help file::topic string)
                strTopicPath = m_ipCompData->GetConceptsHTMLHelpFileName(); 

                strTopicPath += L"::/";
                strTopicPath += m_ipCompData->GetHTMLHelpTopic();           // sample.chm::/helptopic.htm

                nBytes = (strTopicPath.GetLength()+1) * sizeof(WCHAR);
                pCompiledHelpFile = (LPOLESTR)::CoTaskMemAlloc(nBytes);

                if ( NULL == pCompiledHelpFile ) {
                    hr = E_OUTOFMEMORY;
                } else {
                    memcpy(pCompiledHelpFile, (LPCWSTR)strTopicPath, nBytes);

                    hr = pDisplayHelp->ShowTopic( pCompiledHelpFile );
                
                    ::CoTaskMemFree ( pCompiledHelpFile );

                    pDisplayHelp->Release();
                }
            MFC_CATCH_HR
        }
    }
    return hr;
} // end OnDisplayHelp()

/////////////////////////////////////////////////////////////////////////////
//  IExtendContextMenu methods
//

//---------------------------------------------------------------------------
//  Implement some context menu items
//
STDMETHODIMP
CComponent::AddMenuItems (
    LPDATAOBJECT           pDataObject,         // [in] Points to data object
    LPCONTEXTMENUCALLBACK  pCallbackUnknown,    // [in] Points to callback function
    long*                  pInsertionAllowed )  // [in,out] Insertion flags
{
    HRESULT hr = S_OK;
    static CONTEXTMENUITEM ctxMenu[3];
    CDataObject* pDO = NULL;
    CString strTemp1, strTemp2, strTemp3, strTemp4, strTemp5, strTemp6;
    CSmLogQuery* pQuery;
    ResourceStateManager    rsm;
    
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT( NULL != m_ipCompData );  

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject( pDataObject );
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    if ( SUCCEEDED ( hr ) ) {

        if ( NULL == m_ipCompData ) {
            hr = S_FALSE;
        } else {

            // Only add menu items when we are allowed to.
            if ( ( COOKIE_IS_COUNTERMAINNODE == pDO->GetCookieType() )
                    || ( COOKIE_IS_TRACEMAINNODE == pDO->GetCookieType() )
                    || ( COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() ) )
            {
                if( CCM_INSERTIONALLOWED_NEW & *pInsertionAllowed ) {
                    // Add "New Query..." context menu item
                    hr = m_ipCompData->AddMenuItems ( pDataObject, pCallbackUnknown, pInsertionAllowed );
            
                } else if( CCM_INSERTIONALLOWED_TASK & *pInsertionAllowed ) {
                    if ( m_ipCompData->IsLogQuery ( pDO->GetCookie() ) ) {
                        pQuery = (CSmLogQuery*)pDO->GetCookie();

                        if ( NULL != pQuery ) {

                            ZeroMemory ( &ctxMenu, sizeof ctxMenu );

                            // Add "Start" context menu item
                            strTemp1.LoadString ( IDS_MMC_MENU_START );
                            strTemp2.LoadString ( IDS_MMC_STATUS_START );
                            ctxMenu[0].strName = const_cast<LPWSTR>((LPCWSTR)strTemp1);
                            ctxMenu[0].strStatusBarText = const_cast<LPWSTR>((LPCWSTR)strTemp2);
                            ctxMenu[0].lCommandID        = IDM_START_QUERY;
                            ctxMenu[0].lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
                            ctxMenu[0].fFlags            = MF_ENABLED;
                            ctxMenu[0].fSpecialFlags     = 0;

                            // Add "Stop" context menu item
                            strTemp3.LoadString ( IDS_MMC_MENU_STOP );
                            strTemp4.LoadString ( IDS_MMC_STATUS_STOP );
                            ctxMenu[1].strName = const_cast<LPWSTR>((LPCWSTR)strTemp3);
                            ctxMenu[1].strStatusBarText = const_cast<LPWSTR>((LPCWSTR)strTemp4);
                            ctxMenu[1].lCommandID        = IDM_STOP_QUERY;
                            ctxMenu[1].lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
                            ctxMenu[1].fFlags            = MF_ENABLED;
                            ctxMenu[1].fSpecialFlags     = 0;

                            // Add "Save As..." context menu item
                            strTemp5.LoadString ( IDS_MMC_MENU_SAVE_AS );
                            strTemp6.LoadString ( IDS_MMC_STATUS_SAVE_AS );
                            ctxMenu[2].strName = const_cast<LPWSTR>((LPCWSTR)strTemp5);
                            ctxMenu[2].strStatusBarText = const_cast<LPWSTR>((LPCWSTR)strTemp6);
                            ctxMenu[2].lCommandID        = IDM_SAVE_QUERY_AS;
                            ctxMenu[2].lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
                            ctxMenu[2].fFlags            = MF_ENABLED;
                            ctxMenu[2].fSpecialFlags     = 0;

                            if ( pQuery->IsRunning() ) {
                                ctxMenu[0].fFlags = MF_GRAYED;
                            } else {
                                ctxMenu[1].fFlags = MF_GRAYED;
                            }

                            hr = pCallbackUnknown->AddItem( &ctxMenu[0] );

                            if ( SUCCEEDED( hr ) ) {
                                hr = pCallbackUnknown->AddItem( &ctxMenu[1] );
                            }
                            if ( SUCCEEDED( hr ) ) {
                                hr = pCallbackUnknown->AddItem( &ctxMenu[2] );
                            }
                        } else {
                            ASSERT ( FALSE );
                            hr = E_UNEXPECTED;
                        }
                    }
                }
            } else {
                hr = S_OK;
            }
        }
    }
    
    return hr;
} // end AddMenuItems()

//---------------------------------------------------------------------------
//  Implement the command method so we can handle notifications
//  from our Context menu extensions.
//
STDMETHODIMP
CComponent::Command (
    long nCommandID,                // [in] Command to handle
    LPDATAOBJECT pDataObject )      // [in] Points to data object, pass through
{
    HRESULT hr = S_OK;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT( NULL != m_ipCompData );  

    if ( NULL != m_ipCompData ) {

        switch( nCommandID ) {

        case IDM_NEW_QUERY:
            m_ipCompData->CreateNewLogQuery( pDataObject );
            break;

        case IDM_NEW_QUERY_FROM:
            m_ipCompData->CreateLogQueryFrom( pDataObject );
            break;

        case IDM_START_QUERY:
            StartLogQuery( pDataObject );
            break;

        case IDM_STOP_QUERY:
            StopLogQuery( pDataObject );
            break;

        case IDM_SAVE_QUERY_AS:
            SaveLogQueryAs( pDataObject );
            break;

        default:
            hr = S_FALSE;
        }
    } else {
        hr = S_FALSE;
    }

    return hr;

} // end Command()

/////////////////////////////////////////////////////////////////////////////
// IExtendControlBar implementation

//---------------------------------------------------------------------------
// Now the toolbar has three buttons
// We don't attach the toolbar to a window yet, that is handled
// after we get a notification.
//
STDMETHODIMP
CComponent::SetControlbar (
    LPCONTROLBAR  pControlbar )  // [in] Points to IControlBar
{
    HRESULT hr = S_OK;
    HBITMAP hbmpToolbarRes = NULL;
    HWND    hwndMain = NULL;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if ( NULL != m_ipConsole ) {

        if( NULL != pControlbar ) {           // Make sure the Controlbar is OK

            if( NULL != m_ipControlbar ) {       // Don't orphan it if we already
                                                 // had a pointer to it
                m_ipControlbar->Release();
            }

            m_ipControlbar = pControlbar;      // Cache the pointer
            m_ipControlbar->AddRef();

            if( NULL == m_ipToolbarLogger ) {        // Toolbar not created yet...

                hr = m_ipControlbar->Create(
                                        TOOLBAR,
                                        this,
                                        reinterpret_cast<LPUNKNOWN*>(&m_ipToolbarLogger) );
                if ( SUCCEEDED ( hr ) ) {
                    hr = m_ipConsole->GetMainWindow( &hwndMain );
                }
                if ( SUCCEEDED ( hr ) ) {

                    LoadLogToolbarStrings ( ToolbarResultBtnsLog );
                
                    // Add the toolbar bitmap

                    // Load special start button bitmap if RTL layout is enabled.
                    if ( ! ( CWnd::FromHandle(hwndMain)->GetExStyle() & WS_EX_LAYOUTRTL ) ) {
                        hbmpToolbarRes = LoadBitmap( g_hinst, MAKEINTRESOURCE(IDB_TOOLBAR_RES));
                    } else {
                        hbmpToolbarRes = LoadBitmap( g_hinst, MAKEINTRESOURCE(IDB_TOOLBAR_RES_RTL ));
                    }
                
                    hr = m_ipToolbarLogger->AddBitmap( 3, hbmpToolbarRes, 16, 16, RGB(255,0,255) );
                
                    ASSERT( SUCCEEDED(hr) );
                    // Add a few buttons
                    hr = m_ipToolbarLogger->AddButtons(cResultBtnsLog, ToolbarResultBtnsLog);
                }
            }
            if( NULL == m_ipToolbarAlerts ) {        // Toolbar not created yet...

                hr = m_ipControlbar->Create(
                                        TOOLBAR,
                                        this,
                                        reinterpret_cast<LPUNKNOWN*>(&m_ipToolbarAlerts) );

                if ( SUCCEEDED ( hr ) ) {
                    hr = m_ipConsole->GetMainWindow( &hwndMain );
                }

                if ( SUCCEEDED ( hr ) ) {

                    LoadAlertToolbarStrings ( ToolbarResultBtnsAlert );

                    // Add the toolbar bitmap
                    // Load special start button bitmap if RTL layout is enabled.
                    if ( ! ( CWnd::FromHandle(hwndMain)->GetExStyle() & WS_EX_LAYOUTRTL ) ) {
                        hbmpToolbarRes = LoadBitmap( g_hinst, MAKEINTRESOURCE(IDB_TOOLBAR_RES));
                    } else {
                        hbmpToolbarRes = LoadBitmap( g_hinst, MAKEINTRESOURCE(IDB_TOOLBAR_RES_RTL ));
                    }
                    hr = m_ipToolbarAlerts->AddBitmap( 3, hbmpToolbarRes, 16, 16, RGB(255,0,255) );
                    // Add a few buttons
                    hr = m_ipToolbarAlerts->AddButtons(cResultBtnsAlert, ToolbarResultBtnsAlert);
                }
            }

            if( NULL != hbmpToolbarRes ) {
                DeleteObject(hbmpToolbarRes);
            }
        
            // Finished creating the toolbars
            hr = S_OK;
        } else {                    
            hr = S_FALSE;                    // No ControlBar available
        }
    } else {                    
        hr = S_FALSE;                    // No m_ipConsole
    }

    return hr;

} // end SetControlBar()


//---------------------------------------------------------------------------
//  Handle ControlBar notifications to our toolbar
//  Now we can delete an object
//
STDMETHODIMP
CComponent::ControlbarNotify (
    MMC_NOTIFY_TYPE    event,    // [in] Type of notification
    LPARAM             arg,      // [in] Depends on notification
    LPARAM             param )    // [in] Depends on notification
{
    HRESULT hr = S_OK;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT( NULL != m_ipCompData );  

    if ( NULL != m_ipCompData ) {

        switch( event ){
            case MMCN_BTN_CLICK:                    // For a Controlbar click, the
                switch( param ) {                   // param is the MenuItemID
                    case IDM_NEW_QUERY:
                        m_ipCompData->CreateNewLogQuery( reinterpret_cast<LPDATAOBJECT>(arg) );
                        break;

                    case IDM_START_QUERY:
                        StartLogQuery ( reinterpret_cast<LPDATAOBJECT>(arg) );
                        break;

                    case IDM_STOP_QUERY:
                        StopLogQuery ( reinterpret_cast<LPDATAOBJECT>(arg) );
                        break;

                    default:
                        LOCALTRACE( L"ControlbarNotify: Unknown message" );
                    }
                break;

            case MMCN_DESELECT_ALL:            // How to display the Toolbar
            case MMCN_SELECT:
                hr = HandleExtToolbars( (event == MMCN_DESELECT_ALL), arg, param );
                break;

            case MMCN_MENU_BTNCLICK:           // Not handling menus here
                  DebugMsg( L"MMCN_MENU_BTNCLICK", L"CComponent::ControlbarNotify");
                  // Drop through...
            default:
                  hr = S_FALSE;
                  break;
        }
    } else {
        hr = S_FALSE;
    }

    return hr;

} // end ControlbarNotify()

//---------------------------------------------------------------------------
//  Handle how the toolbars are displayed
//
HRESULT
CComponent::HandleExtToolbars (
    bool    bDeselectAll,       // [in] Notification
    LPARAM     /* arg */,       // [in] Depends on notification
    LPARAM  param               // [in] Depends on notification
    )          
{
    HRESULT hr = S_OK;
    BOOL bStartEnable = FALSE;
    BOOL bStopEnable = FALSE;
    BOOL bNewEnable = FALSE;
    CDataObject* pDO = NULL;
    LPDATAOBJECT pDataObject;
    CSmLogQuery* pQuery = NULL;
    
    ASSERT( NULL != m_ipCompData );  

    if ( NULL != m_ipCompData ) {

        pDataObject = reinterpret_cast<LPDATAOBJECT>(param);

        if( NULL == pDataObject ) {
            hr = S_FALSE;
        } else {
            pDO = ExtractOwnDataObject( pDataObject );
            if ( NULL == pDO ) {
                hr = E_UNEXPECTED;
            }

            if ( SUCCEEDED ( hr ) ) {
                hr = S_FALSE;
                if( CCT_SCOPE == pDO->GetContext() ) {
                    // Scope item selected, in either the scope or result pane.
                    if( COOKIE_IS_ROOTNODE == pDO->GetCookieType() ) {
                        if ( NULL != m_ipToolbarAttached ) {
                            hr = m_ipControlbar->Detach( (LPUNKNOWN)m_ipToolbarAttached );
                            m_ipToolbarAttached = NULL;
                        }
                        ASSERT( SUCCEEDED(hr) );
                    } else if( COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() ) {
                        // Attach the Alerts toolbar
                        if ( m_ipToolbarAttached != NULL && m_ipToolbarAttached != m_ipToolbarAlerts ) {
                            hr = m_ipControlbar->Detach( (LPUNKNOWN)m_ipToolbarAttached );
                            m_ipToolbarAttached = NULL;
                        }

                        hr = m_ipControlbar->Attach(TOOLBAR, (LPUNKNOWN)m_ipToolbarAlerts);
                        ASSERT( SUCCEEDED(hr) );
                        m_ipToolbarAttached = m_ipToolbarAlerts;

                        bNewEnable = TRUE;
                    } else {
                        // Attach the Logger toolbar
                        if ( m_ipToolbarAttached != NULL && m_ipToolbarAttached != m_ipToolbarLogger ) {
                            hr = m_ipControlbar->Detach( (LPUNKNOWN)m_ipToolbarAttached );
                            m_ipToolbarAttached = NULL;
                        }

                        hr = m_ipControlbar->Attach(TOOLBAR, (LPUNKNOWN)m_ipToolbarLogger);
                        ASSERT( SUCCEEDED(hr) );
                        m_ipToolbarAttached = m_ipToolbarLogger;

                        bNewEnable = TRUE;
                    }
                } else {

                    if ( !bDeselectAll ) {

                        // Result pane context.
                        if( CCT_RESULT == pDO->GetContext() ) {
                            bStartEnable = m_ipCompData->IsLogQuery (pDO->GetCookie()) ? TRUE : FALSE;
                            if (bStartEnable) {
                                // then this is a log query, so see if the item is running or not
                                pQuery = (CSmLogQuery*)pDO->GetCookie();
                                if ( NULL != pQuery ) {
                                    if (pQuery->IsRunning()) {
                                        // enable only the stop button
                                        bStartEnable = FALSE;
                                    } else {
                                        // enable only the start button
                                    }
                                } else {
                                    ASSERT ( FALSE );
                                }
                                bStopEnable = !bStartEnable;
                            }
                        }
                    } else {
                        bNewEnable = TRUE;
                    }
                }

                if ( NULL != m_ipToolbarAttached ) {
                    hr = m_ipToolbarAttached->SetButtonState( IDM_NEW_QUERY, ENABLED , bNewEnable );
                    ASSERT( SUCCEEDED(hr) );

                    hr = m_ipToolbarAttached->SetButtonState( IDM_START_QUERY, ENABLED , bStartEnable );
                    ASSERT( SUCCEEDED(hr) );

                    hr = m_ipToolbarAttached->SetButtonState( IDM_STOP_QUERY, ENABLED , bStopEnable );
                    ASSERT( SUCCEEDED(hr) );
                }
            }
        }

    } else {
        hr = S_FALSE;
    }
    return hr;

} // end HandleExtToolbars()


/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet implementation
//

HRESULT 
CComponent::AddPropertyPage ( 
    LPPROPERTYSHEETCALLBACK lpProvider, 
    CSmPropertyPage*& rpPage 
    )
{
    HRESULT hr = S_OK;
    PROPSHEETPAGE_V3 sp_v3 = {0};
    HPROPSHEETPAGE   hPage = NULL;

    ASSERT( NULL != m_ipCompData ); 
    
    if ( NULL != m_ipCompData ) {

        if ( NULL == rpPage ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        } else {

            rpPage->SetContextHelpFilePath( m_ipCompData->GetContextHelpFilePath() );
    
            rpPage->m_psp.lParam = (INT_PTR)rpPage;
            rpPage->m_psp.pfnCallback = &CSmPropertyPage::PropSheetPageProc;

            CopyMemory (&sp_v3, &rpPage->m_psp, rpPage->m_psp.dwSize);
            sp_v3.dwSize = sizeof(sp_v3);

            hPage = CreatePropertySheetPage (&sp_v3);

            if ( NULL != hPage ) {
                hr = lpProvider->AddPage(hPage);
                if ( FAILED(hr) ) {
                    ASSERT ( FALSE );
                    delete rpPage;
                    rpPage = NULL;
                }
            } else {
                delete rpPage;
                rpPage = NULL;
                ASSERT ( FALSE );
                hr = E_UNEXPECTED;
            }
        }
    } else {
        hr = S_FALSE;
    }
    return hr;

}


HRESULT
CComponent::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,    // Pointer to the callback interface
    LONG_PTR                handle,        // Handle for routing notification
    LPDATAOBJECT            pDataObject    // Pointer to the data object
    )
{
    HRESULT         hr = S_OK;
    CDataObject*    pDO = NULL;
    MMC_COOKIE      Cookie;
    CSmLogQuery*    pQuery = NULL;
    DWORD           dwLogType;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT( NULL != m_ipCompData );  

    if ( NULL == pDataObject 
                || NULL == lpProvider ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    //         We cheat a little here and pass what we need to a custom
    //         constructor for our derived property page class

    if ( SUCCEEDED ( hr ) ) {
        if ( NULL != m_ipCompData ) {
            Cookie = pDO->GetCookie();
            if ( NULL != Cookie ) {
                CWnd* pPropSheet = NULL;
            
                pQuery = (CSmLogQuery *)Cookie;

                if ( NULL != pQuery ) {
                    // If the property sheet for this query is already active, just bring it to the foreground.

                    pPropSheet = pQuery->GetActivePropertySheet();

                    if ( NULL != pPropSheet ) {

                        pPropSheet->SetForegroundWindow();
                        MMCFreeNotifyHandle(handle);
                        hr = S_FALSE;
            
                    } else {

                        dwLogType = pQuery->GetLogType();

                        if (SLQ_ALERT != dwLogType) { 
        
                            if ( SLQ_TRACE_LOG == dwLogType) {
                                CSmPropertyPage*    pPage1 = NULL;  
                                CWaitCursor         WaitCursor;
                    
                                // Connect to the server before creating the dialog 
                                // so that the wait cursor can be used consistently.

                                // Sync the providers here so that the WMI calls are consistently
                                // from a single thread.
                                ASSERT ( NULL != pQuery->CastToTraceLogQuery() );
                                hr = (pQuery->CastToTraceLogQuery())->SyncGenProviders();

                                if ( SUCCEEDED ( hr ) ) {
                                    MFC_TRY
                                        pPage1 = new CProvidersProperty (Cookie, handle);
                                        if ( NULL != pPage1 ) {
                                            hr = AddPropertyPage ( lpProvider, pPage1 );
                                        }
                                    MFC_CATCH_HR
                                } else {
                                    CString strMachineName;
                                    CString strLogName;

                                    pQuery->GetMachineDisplayName( strMachineName );
                                    strLogName = pQuery->GetLogName();
                        
                                    m_ipCompData->HandleTraceConnectError ( 
                                        hr, 
                                        strLogName,
                                        strMachineName );
                                }

                            } else {
                                CSmPropertyPage *pPage1 = NULL;

                                MFC_TRY
                                    pPage1 = new CCountersProperty (Cookie, handle );
                                    if ( NULL != pPage1 ) {
                                        hr = AddPropertyPage ( lpProvider, pPage1 );
                                    } 
                                MFC_CATCH_HR
                            }

                            if ( SUCCEEDED(hr) ) {
                                CSmPropertyPage* pPage2 = NULL;
                                CSmPropertyPage* pPage3 = NULL;
        
                                MFC_TRY
                                    pPage2 = new CFilesProperty(Cookie, handle);
                                    if ( NULL != pPage2 ) {
                                        hr = AddPropertyPage ( lpProvider, pPage2 );
                                    } 

                                    if ( SUCCEEDED(hr) ) {
                                        pPage3 = new CScheduleProperty (Cookie, handle, pDataObject );
                                        if ( NULL != pPage3 ) {
                                            hr = AddPropertyPage ( lpProvider, pPage3 );
                                        } 
                                    }
                                MFC_CATCH_HR

                                if ( FAILED(hr) ) {
                                    if ( NULL != pPage3 ) {
                                        delete pPage3;
                                    }
                                    if ( NULL != pPage2 ) {
                                        delete pPage2;
                                    }
                                }
                            }

                            if ( SUCCEEDED(hr) ) {

                                if ( SLQ_TRACE_LOG == pQuery->GetLogType() ) {
                                    CSmPropertyPage*    pPage4 = NULL;
                        
                                    MFC_TRY
                                        pPage4 = new CTraceProperty(Cookie, handle);
                                        if ( NULL != pPage4 ) {
                                            hr = AddPropertyPage ( lpProvider, pPage4 );
                                        } 
                                    MFC_CATCH_HR
                                }
                            }
                        } else {
                            ASSERT ( SLQ_ALERT == dwLogType );

                            CSmPropertyPage*    pPage1 = NULL;
                            CSmPropertyPage*    pPage2 = NULL;
                            CSmPropertyPage*    pPage3 = NULL;
        
                            MFC_TRY
                                pPage1 = new CAlertGenProp (Cookie, handle);
                                if ( NULL != pPage1 ) {
                                    hr = AddPropertyPage ( lpProvider, pPage1 );
                                } 

                                if ( SUCCEEDED(hr) ) {
                                    pPage2 = new CAlertActionProp (Cookie, handle);
                                    if ( NULL != pPage2 ) {
                                        hr = AddPropertyPage ( lpProvider, pPage2 );
                                    } 
                                }

                                if ( SUCCEEDED(hr) ) {
                                    pPage3 = new CScheduleProperty (Cookie, handle, pDataObject);
                                    if ( NULL != pPage3 ) {
                                        hr = AddPropertyPage ( lpProvider, pPage3 );
                                    } 
                                }
                            MFC_CATCH_HR

                            if ( FAILED(hr) ) {
                                if ( NULL != pPage3 ) {
                                    delete pPage3;
                                }
                                if ( NULL != pPage2 ) {
                                    delete pPage2;
                                }
                                if ( NULL != pPage1 ) {
                                    delete pPage1;
                                }
                            }
                        }
                    }
                } else {
                    ASSERT ( FALSE );
                    hr = E_UNEXPECTED;
                }
            } else {
                ASSERT ( FALSE );
                hr = E_UNEXPECTED;
            }
        } else {
            hr = S_FALSE;
        }
    }
    return hr;

} // end CreatePropertyPages()


//---------------------------------------------------------------------------
// The console calls this method to determine whether the Properties menu
// item should be added to the context menu.  We added the Properties item
// by enabling the verb.  So long as we have a vaild DataObject we
// can return OK.
//
HRESULT
CComponent::QueryPagesFor (
    LPDATAOBJECT pDataObject ) // [in] Points to IDataObject for selected node
{
    HRESULT hr = S_OK;
    CDataObject* pDO = NULL;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    if ( SUCCEEDED ( hr ) ) {
        if ( COOKIE_IS_COUNTERMAINNODE == pDO->GetCookieType()
                || COOKIE_IS_TRACEMAINNODE == pDO->GetCookieType()
                || COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() )
        {
            hr = S_OK;
        } else {
            hr = S_FALSE;
        }
    }
    return hr;

} // end QueryPagesFor()

HRESULT
CComponent::PopulateResultPane (
    MMC_COOKIE  mmcCookie )
{
    HRESULT     hr = S_OK;
    PSLSVC      pSLSVC = NULL;
    PSLQUERY    pSlQuery = NULL;
    POSITION    Pos;
    RESULTDATAITEM rdi;

    ASSERT ( NULL != m_ipResultData );

    if ( NULL == mmcCookie ) {
        ASSERT ( FALSE );
        hr = E_INVALIDARG;
    } else {
        
        if ( NULL == m_ipResultData ) {
            hr = S_FALSE;
        } else {

            pSLSVC = reinterpret_cast<PSLSVC>(mmcCookie);       
            ASSERT ( NULL != pSLSVC->CastToLogService() ); 

            hr = m_ipResultData->DeleteAllRsltItems();

            if( SUCCEEDED(hr) ) {

                memset(&rdi, 0, sizeof(RESULTDATAITEM));
                rdi.mask =   RDI_STR     |         // Displayname is valid
                             // RDI_IMAGE   |         // nImage is valid
                             RDI_PARAM;            // lParam is valid

                rdi.str    = MMC_CALLBACK;
                rdi.nImage = 2;

                Pos = pSLSVC->m_QueryList.GetHeadPosition();

                // load the query object pointers into the results page
                while ( Pos != NULL) {
                    pSlQuery = pSLSVC->m_QueryList.GetNext( Pos );
                    rdi.lParam = reinterpret_cast<LPARAM>(pSlQuery);
                    hr = m_ipResultData->InsertItem( &rdi );
                    if( FAILED(hr) )
                        DisplayError( hr, L"PopulateResultPane" );
                }
            }
        }
    }

    return hr;
} // end PopulateResultPane()

HRESULT
CComponent::RefreshResultPane (
    LPDATAOBJECT pDataObject )
{
    HRESULT hr = S_OK;
    DWORD   dwStatus = ERROR_SUCCESS;
    PSLSVC    pSLSVC = NULL;
    PSLQUERY    pActiveQuery = NULL;
    CString     strMessage;
    CString     strTitle;
    INT         iResult;

    // pDataObject is provided to pass through to UpdateAllViews.

    // Use the stored pointer to the known viewed node, to handle the
    // case where the result pane contains scope nodes, and to handle
    // the case where the cookie is a query.

    pSLSVC = reinterpret_cast<PSLSVC>(m_pViewedNode);
    
    if ( NULL != pSLSVC ) {

        dwStatus = pSLSVC->CheckForActiveQueries ( &pActiveQuery );

        if ( ERROR_SUCCESS == dwStatus ) {
            // UpdateAllViews is called to delete list items in all result panes.
            m_ipConsole->UpdateAllViews ( pDataObject, 0, CComponentData::eSmHintPreRefresh );

            dwStatus = pSLSVC->SyncWithRegistry ( &pActiveQuery );
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            // UpdateAllViews is called to populate all result panes.
            m_ipConsole->UpdateAllViews ( pDataObject, 0, CComponentData::eSmHintRefresh );
        } else {
            if ( NULL != pActiveQuery ) {
                // Don't refresh queries with open property pages.
                strMessage.LoadString ( IDS_ERRMSG_REFRESH_OPEN_QUERY );
                strTitle.LoadString ( IDS_PROJNAME );
                hr = m_ipConsole->MessageBox(
                        (LPCWSTR)strMessage,
                        (LPCWSTR)strTitle,
                        MB_OK | MB_ICONWARNING,
                        &iResult );
    
                ((CWnd*)pActiveQuery->GetActivePropertySheet())->SetForegroundWindow();
            }
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT
CComponent::OnDelete (
    LPDATAOBJECT pDataObject,      // [in] Points to data object
    LPARAM     /* arg */   ,       // Not used     
    LPARAM     /* param */         // Not used
    )
{
    HRESULT     hr = S_OK;
    DWORD       dwStatus = ERROR_SUCCESS;
    CDataObject *pDO = NULL;
    PSLQUERY    pQuery = NULL;
    CSmLogService* pSvc = NULL;
    int         iResult;
    CString     strMessage;
    CString     csTitle;
    CString     strMachineName;
    MMC_COOKIE  mmcCookie = 0;
    BOOL        bIsQuery = FALSE;
    BOOL        bContinue = TRUE;
    ResourceStateManager    rsm;
    HRESULTITEM hItemID = NULL;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT( NULL != m_ipCompData );  

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else if ( NULL == m_ipCompData || NULL == m_ipConsole ) {
        hr = S_FALSE;
    } else {

        pDO = ExtractOwnDataObject( pDataObject );

        if( NULL == pDO ) {
            // Unknown data object
            strMessage.LoadString ( IDS_ERRMSG_UNKDATAOBJ );
            hr = m_ipConsole->MessageBox( (LPCWSTR)strMessage,
                    L"CComponentData::OnDelete",
                MB_OK | MB_ICONERROR,
                &iResult
                );
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        } else {
            // If this is the root node, don't need to do anything
            if( COOKIE_IS_ROOTNODE == pDO->GetCookieType() ) {
                hr = S_FALSE;
            } else {
                // Just make sure we are where we think we are
                ASSERT( CCT_RESULT == pDO->GetContext() );
                ASSERT( COOKIE_IS_COUNTERMAINNODE == pDO->GetCookieType()
                        || COOKIE_IS_TRACEMAINNODE == pDO->GetCookieType()
                        || COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() );

                mmcCookie = (MMC_COOKIE)pDO->GetCookie();

                bIsQuery = m_ipCompData->IsLogQuery (mmcCookie);

                if (bIsQuery) {
                    pQuery = (PSLQUERY)mmcCookie;

                    if ( NULL != pQuery ) {
                        pSvc = ( pQuery->GetLogService() );
                        if ( !pQuery->IsExecuteOnly() ) {
                            if ( pQuery->IsModifiable() ) {
                                if ( m_ipCompData->IsRunningQuery( pQuery ) ) {
                                    iResult = IDOK;

                                    // Don't delete running queries.  Stop the query if requested
                                    // by the user.
                                    strMessage.LoadString ( IDS_ERRMSG_DELETE_RUNNING_QUERY );
                                    csTitle.LoadString ( IDS_PROJNAME );
                                    hr = m_ipConsole->MessageBox(
                                            (LPCWSTR)strMessage,
                                            (LPCWSTR)csTitle,
                                            MB_OKCANCEL | MB_ICONWARNING,
                                            &iResult
                                            );

                                    if ( IDOK == iResult ) {
                                        // If property page is open, StopLogQuery 
                                        // shows error message
                                        hr = StopLogQuery ( pDataObject, FALSE );
                                        if ( FAILED ( hr ) 
                                            || S_FALSE == hr ) {
                                            bContinue = FALSE;
                                            hr = S_FALSE;
                                        }
                                    } else {
                                        bContinue = FALSE;
                                        hr = S_FALSE;
                                    }
                                } else if ( NULL != pQuery->GetActivePropertySheet() ){
                                    // Don't delete queries with open property pages.
                                    strMessage.LoadString ( IDS_ERRMSG_DELETE_OPEN_QUERY );
                                    csTitle.LoadString ( IDS_PROJNAME );
                                    hr = m_ipConsole->MessageBox(
                                            (LPCWSTR)strMessage,
                                            (LPCWSTR)csTitle,
                                            MB_OK | MB_ICONWARNING,
                                            &iResult );
                        
                                    ((CWnd*)pQuery->GetActivePropertySheet())->SetForegroundWindow();

                                    bContinue = FALSE;
                                    hr = S_FALSE;

                                } 
                                            
                                if ( bContinue ) {
                                    if ( NULL != pSvc ) {
                                        hr = m_ipConsole->UpdateAllViews ( 
                                            pDataObject, 
                                            0, 
                                            CComponentData::eSmHintPreDeleteQuery );

                                        if ( SUCCEEDED(hr) ) {

                                            dwStatus = pSvc->DeleteQuery(pQuery);

                                            // Mark as deleted.  Already deleted 
                                            // from the UI of each view.  
                                            hr = S_OK; 
                                        
                                        } else {
                                            hr = S_FALSE;
                                        }
                                    } else {
                                        ASSERT ( FALSE );
                                        hr = E_UNEXPECTED;
                                    }
                                }
                            } else {
                                if ( NULL != pSvc ) {
                                    strMachineName = pSvc->GetMachineDisplayName();
                                } else {
                                    strMachineName.Empty();
                                }

                                FormatSmLogCfgMessage (
                                    strMessage,
                                    m_hModule,
                                    SMCFG_NO_MODIFY_ACCESS,
                                    (LPCWSTR)strMachineName);

                                csTitle.LoadString ( IDS_PROJNAME );
                                hr = m_ipConsole->MessageBox(
                                                    (LPCWSTR)strMessage,
                                                    (LPCWSTR)csTitle,
                                                    MB_OK | MB_ICONERROR,
                                                    &iResult );
                                hr = S_FALSE; 
                            }
                        } else {

                            // Don't delete template queries.
                            strMessage.LoadString ( IDS_ERRMSG_DELETE_TEMPLATE_QRY );
                            csTitle.LoadString ( IDS_PROJNAME );
                            hr = m_ipConsole->MessageBox(
                                    (LPCWSTR)strMessage,
                                    (LPCWSTR)csTitle,
                                    MB_OK | MB_ICONERROR,
                                    &iResult
                                    );
                            hr = S_FALSE;
                        }
                    } else {
                        ASSERT ( FALSE );
                        hr = E_UNEXPECTED;
                    }
                } else {
                    hr = S_FALSE;
                }
            }
        }
    }

    return hr;
}

HRESULT
CComponent::OnDoubleClick (
    ULONG ulRecNo,
    LPDATAOBJECT pDataObject )  // [in] Points to the data object
{
    HRESULT     hr = S_OK;
    CDataObject* pDO = NULL;
    MMC_COOKIE  mmcCookie;
    BOOL bIsQuery = FALSE;
    PSLQUERY    pQuery = NULL;
    LONG_PTR    handle = NULL;
    CWnd*       pPropSheet = NULL;

    ASSERT( NULL != m_ipCompData );  

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL == pDO ) {
            hr = S_OK;
        } else {

            // If this is the root node, don't need to do anything
            if( COOKIE_IS_ROOTNODE == pDO->GetCookieType() ) {
                hr = S_FALSE;
            } else if ( CCT_RESULT != pDO->GetContext() ) {
                // Just make sure we are where we think we are
                hr = S_FALSE;
            }

            if ( S_OK == hr ) {

                if ( NULL == m_ipCompData ) {
                    hr = S_FALSE;
                } else {
                    mmcCookie = (MMC_COOKIE)pDO->GetCookie();
                    bIsQuery = m_ipCompData->IsLogQuery (mmcCookie);

                    if (!bIsQuery) {
                        // Pass the notification to the scope pane to expand.
                        hr = S_FALSE;
                    } else {
                        pQuery = (PSLQUERY)mmcCookie;
 
                        if ( NULL != pQuery ) {
                            // If the property sheet for this query is already active, just bring it to the foreground.                
                            pPropSheet = pQuery->GetActivePropertySheet();

                            if ( NULL != pPropSheet ) {

                                pPropSheet->SetForegroundWindow();
                                MMCFreeNotifyHandle(handle);
                                hr = S_OK;
            
                            } else {
                                hr = _InvokePropertySheet(ulRecNo, pDataObject);
                            }
                        } else {
                            ASSERT ( FALSE );
                            hr = E_UNEXPECTED;
                        }
                    }
                }
            }
        }
    }

    return hr;

} // end OnDoubleClick()


HRESULT
CComponent::StartLogQuery (
    LPDATAOBJECT pDataObject ) // [in] Points to the data object
{
    HRESULT                 hr = S_OK;
    CDataObject*            pDO = NULL;
    CSmLogQuery*            pQuery = NULL;
    CString                 strMessage;
    CString                 strSysMessage;
    CString                 strTitle;
    CString                 strMachineName;
    int                     iResult;
    DWORD                   dwStatus = ERROR_SUCCESS;
    ResourceStateManager    rsm;

    ASSERT( NULL != m_ipCompData );  

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    if ( NULL == m_ipCompData
        || NULL == m_ipConsole ) {
        hr = E_FAIL;
    }

    if ( SUCCEEDED ( hr ) ) {

        if ( m_ipCompData->IsLogQuery ( pDO->GetCookie() ) ) {
                
            pQuery = (CSmLogQuery*)pDO->GetCookie();

            if ( NULL != pQuery ) {

                if ( NULL != pQuery->GetActivePropertySheet() ) {

                    // Don't start queries with open property pages.
                    strMessage.LoadString ( IDS_ERRMSG_START_OPEN_QUERY );
                    hr = m_ipConsole->MessageBox(
                            (LPCWSTR)strMessage,
                            pQuery->GetLogName(),
                            MB_OK | MB_ICONWARNING,
                            &iResult );
            
                    ((CWnd*)pQuery->GetActivePropertySheet())->SetForegroundWindow();

                    hr = S_FALSE;

                } else {        

                    {
                        CWaitCursor WaitCursor;
                        dwStatus = pQuery->ManualStart();
                    }
            
                    // Ignore errors related to autostart setting.
                    if ( ERROR_SUCCESS == dwStatus  ) {
                        // Update all views generates view change notification.
                        m_ipConsole->UpdateAllViews (pDO, 0, CComponentData::eSmHintStartQuery );
                    } else {

                        strTitle.LoadString ( IDS_PROJNAME );

                        if ( ERROR_ACCESS_DENIED == dwStatus ) {

                            pQuery->GetMachineDisplayName ( strMachineName );

                            FormatSmLogCfgMessage (
                                strMessage,
                                m_hModule,
                                SMCFG_NO_MODIFY_ACCESS,
                                (LPCWSTR)strMachineName);

                        } else if ( SMCFG_START_TIMED_OUT == dwStatus ) {
                            FormatSmLogCfgMessage (
                                strMessage,
                                m_hModule,
                                SMCFG_START_TIMED_OUT,
                                (LPCWSTR)pQuery->GetLogName());

                        } else {
                    
                            FormatSmLogCfgMessage (
                                strMessage,
                                m_hModule,
                                SMCFG_SYSTEM_MESSAGE,
                                (LPCWSTR)pQuery->GetLogName());

                            FormatMessage ( 
                                FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL, 
                                dwStatus,
                                0,
                                strSysMessage.GetBufferSetLength( MAX_PATH ),
                                MAX_PATH,
                                NULL );
    
                            strSysMessage.ReleaseBuffer();

                            if ( strSysMessage.IsEmpty() ) {
                                strSysMessage.Format ( L"0x%08lX", dwStatus );   
                            }

                            strMessage += strSysMessage;
                        }

                        hr = m_ipConsole->MessageBox(
                            strMessage,
                            strTitle,
                            MB_OK | MB_ICONERROR,
                            &iResult );

                        hr = E_FAIL;
                    }
                }
            } else {
                ASSERT ( FALSE );
                hr = E_UNEXPECTED;
            }
        }
    }
    return hr;
} // end StartLogQuery()

HRESULT
CComponent::StopLogQuery (
    LPDATAOBJECT pDataObject,  // [in] Points to the data object
    BOOL bWarnOnRestartCancel )  
{
        HRESULT         hr = S_OK;
        CDataObject*    pDO = NULL;
        CSmLogQuery*    pQuery = NULL;
        DWORD           dwStatus = ERROR_SUCCESS;
        INT             iResult = IDOK;
        CString         strMessage;
        CString         strSysMessage;
        CString         strTitle;
        CString         strMachineName;
        ResourceStateManager    rsm;
 
    ASSERT( NULL != m_ipCompData );  

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    if ( NULL == m_ipCompData
        || NULL == m_ipConsole ) {
        hr = E_FAIL;
    }

    if ( SUCCEEDED ( hr ) ) {
        if ( m_ipCompData->IsLogQuery ( pDO->GetCookie() ) ) {
            pQuery = (CSmLogQuery*)pDO->GetCookie();

            if ( NULL != pQuery ) {
                if ( NULL != pQuery->GetActivePropertySheet() ) {

                    // Don't stop queries with open property pages.
                    strMessage.LoadString ( IDS_ERRMSG_STOP_OPEN_QUERY );
                    hr = m_ipConsole->MessageBox(
                            (LPCWSTR)strMessage,
                            pQuery->GetLogName(),
                            MB_OK | MB_ICONWARNING,
                            &iResult );
            
                    ((CWnd*)pQuery->GetActivePropertySheet())->SetForegroundWindow();

                    hr = S_FALSE;

                } else {

                    if ( pQuery->IsAutoRestart() && bWarnOnRestartCancel ) {
                        CString strMessage;

                        strMessage.LoadString( IDS_CANCEL_AUTO_RESTART );

                        hr = m_ipConsole->MessageBox(
                            strMessage,
                            pQuery->GetLogName(),
                            MB_OKCANCEL | MB_ICONINFORMATION,
                            &iResult );
                    }

                    if ( IDOK == iResult ) {
                        {
                            CWaitCursor WaitCursor;
                            dwStatus = pQuery->ManualStop ();
                        }
    
                        // Ignore errors related to autostart setting.
                        if ( ERROR_SUCCESS == dwStatus  ) {
                            // Update all views generates view change notification.
                            m_ipConsole->UpdateAllViews (pDO, 0, CComponentData::eSmHintStopQuery );
                        } else {
                            strTitle.LoadString ( IDS_PROJNAME );

                            if ( ERROR_ACCESS_DENIED == dwStatus ) {

                                pQuery->GetMachineDisplayName ( strMachineName );

                                FormatSmLogCfgMessage (
                                    strMessage,
                                    m_hModule,
                                    SMCFG_NO_MODIFY_ACCESS,
                                    (LPCWSTR)strMachineName);

                            } else if ( SMCFG_STOP_TIMED_OUT == dwStatus ) {
                                FormatSmLogCfgMessage (
                                    strMessage,
                                    m_hModule,
                                    SMCFG_STOP_TIMED_OUT,
                                    (LPCWSTR)pQuery->GetLogName());

                            } else {
                    
                                FormatSmLogCfgMessage (
                                    strMessage,
                                    m_hModule,
                                    SMCFG_SYSTEM_MESSAGE,
                                    (LPCWSTR)pQuery->GetLogName());

                                FormatMessage ( 
                                    FORMAT_MESSAGE_FROM_SYSTEM,
                                    NULL, 
                                    dwStatus,
                                    0,
                                    strSysMessage.GetBufferSetLength( MAX_PATH ),
                                    MAX_PATH,
                                    NULL );

                                strSysMessage.ReleaseBuffer();

                                if ( strSysMessage.IsEmpty() ) {
                                    strSysMessage.Format ( L"0x%08lX", dwStatus );   
                                }

                                strMessage += strSysMessage;
                            } 

                            hr = m_ipConsole->MessageBox(
                                strMessage,
                                strTitle,
                                MB_OK | MB_ICONERROR,
                                &iResult );

                            hr = E_FAIL;
                        }
                    }
                }
            } else {
                ASSERT ( FALSE );
                hr = E_UNEXPECTED;
            }
        }
    }
    return hr;
} // end StopLogQuery()

HRESULT
CComponent::SaveLogQueryAs (
    LPDATAOBJECT pDataObject )  // [in] Points to the data object
{
    HRESULT hr = S_OK;
    DWORD   dwStatus = ERROR_SUCCESS;
    CDataObject* pDO = NULL;
    CSmLogQuery* pQuery = NULL;
    CString strFileExtension;
    CString strFileFilter;
    WCHAR   szDefaultFileName[MAX_PATH + 1];

    INT_PTR iPtrResult = IDCANCEL;
    HWND    hwndMain;
    WCHAR   szInitialDir[MAX_PATH + 1];
    ResourceStateManager    rsm;

    ASSERT( NULL != m_ipCompData );  

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    if ( NULL == m_ipCompData 
        || NULL == m_ipConsole ) {
        hr = E_FAIL;
    }

    if ( SUCCEEDED ( hr ) ) {
        if ( m_ipCompData->IsLogQuery ( pDO->GetCookie() ) ) {

            pQuery = (CSmLogQuery*)pDO->GetCookie();

            if ( NULL != pQuery ) {

                MFC_TRY
                    strFileExtension.LoadString ( IDS_HTML_EXTENSION );
                    strFileFilter.LoadString ( IDS_HTML_FILE );
                MFC_CATCH_HR

                strFileFilter.Replace ( L'|', L'\0' );
                
                StringCchCopy ( szDefaultFileName, MAX_PATH + 1, pQuery->GetLogName() );

                ReplaceBlanksWithUnderscores( szDefaultFileName );

                hr = m_ipConsole->GetMainWindow( &hwndMain );

                if ( SUCCEEDED(hr) ) {
                    
                    OPENFILENAME ofn;
                    BOOL bResult;
                    
                    ZeroMemory( &ofn, sizeof( OPENFILENAME ) );

                    ofn.lStructSize = sizeof(OPENFILENAME);
                    ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;
                    ofn.lpstrDefExt = (LPCWSTR)strFileExtension;
                    ofn.lpstrFile = szDefaultFileName;
                    ofn.lpstrFilter = strFileFilter;
                    ofn.nMaxFile = MAX_PATH;
                    ofn.hwndOwner = hwndMain;
                    ofn.hInstance = m_hModule;

                    if ( SUCCEEDED ( SHGetFolderPathW ( NULL, CSIDL_PERSONAL, NULL, 0, szInitialDir ) ) ) {
                        ofn.lpstrInitialDir = szInitialDir;
                    }

                    bResult = GetSaveFileName( &ofn );

                    if ( bResult ) {

                        dwStatus = pQuery->SaveAs( ofn.lpstrFile );

                        if ( ERROR_SUCCESS != dwStatus ) {
                            hr = E_FAIL;
                        }
                    }
                }
            } else {
                ASSERT ( FALSE );
                hr = E_UNEXPECTED;
            }
        }
    }
    return hr;
} // end SaveLogQueryAs()

//+--------------------------------------------------------------------------
//
//  Member:     CComponent::_InvokePropertySheet
//
//  Synopsis:   Open or bring to foreground an event record details
//              property sheet focused on record [ulRecNo].
//
//  Arguments:  [ulRecNo]     - number of rec to display in prop sheet
//              [pDataObject] - data object containing rec [ulRecNo]
//
//  Returns:    HRESULT
//
//  History:    5-28-1999   a-akamal
//
//---------------------------------------------------------------------------

HRESULT
CComponent::_InvokePropertySheet(
    ULONG ulRecNo,
    LPDATAOBJECT pDataObject)
{
    //TRACE_METHOD(CComponent, _InvokePropertySheet);
    HRESULT     hr = S_OK;
    MMC_COOKIE  Cookie;
    PSLQUERY    pQuery = NULL;
    CDataObject* pDO = NULL;

    ASSERT( NULL != m_ipCompData );  
       
    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject(pDataObject);
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    if ( SUCCEEDED ( hr ) ) {
        
        Cookie = (MMC_COOKIE)pDO->GetCookie();;
        pQuery = (PSLQUERY)Cookie;
    
        if ( NULL != pQuery && NULL != m_ipCompData ) 
        {
            hr = InvokePropertySheet (
                    m_ipCompData->GetPropSheetProvider(),
                    (LPCWSTR)pQuery->GetLogName(),
                    (LONG) ulRecNo,
                    pDataObject,
                    (IExtendPropertySheet*) this,
                    0 );
        } else {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   InvokePropertySheet
//
//  Synopsis:   Bring to top an existing or create a new property sheet
//              using the parameters provided.
//
//  Arguments:  [pPrshtProvider] - used to search for or create sheet
//              [wszTitle]       - sheet caption
//              [lCookie]        - a loginfo* or an event record number
//              [pDataObject]    - DO on object sheet's being opened on
//                                  (cookie in DO should == cookie)
//              [pPrimary]       - IExtendPropertySheet interface on
//                                  calling CSnapin or CComponentData
//              [usStartingPage] - which page number should be active when
//                                  sheet opens
//
//  Returns:    HRESULT
//
//  History:    5-28-1999   a-akamal
//
//  Notes:      Call this routine when you want a property sheet to appear
//              as if the user had just selected "Properties" on it.
//
//---------------------------------------------------------------------------

HRESULT
CComponent::
InvokePropertySheet(
    IPropertySheetProvider *pPrshtProvider,
    LPCWSTR wszTitle,
    LONG lCookie,
    LPDATAOBJECT pDataObject,
    IExtendPropertySheet *pPrimary,
    USHORT usStartingPage)
{
    HRESULT hr = S_OK;

    //
    // Because we pass NULL for the second arg, the first is not allowed
    // to be null.
    //
    if ( 0 == lCookie ) {
        ASSERT ( FALSE );
        hr = E_INVALIDARG;
    } else {

        do {
            hr = pPrshtProvider->FindPropertySheet(lCookie, NULL, pDataObject);
        
            if ( S_OK == hr ) {
                break;
            }
        
            hr = pPrshtProvider->CreatePropertySheet(wszTitle,
                                                      TRUE,
                                                      lCookie,
                                                      pDataObject,
                                                      0);
            if ( S_OK != hr ) {
                break;
            }
        
            hr = pPrshtProvider->AddPrimaryPages(pPrimary, TRUE, NULL, FALSE);

            if ( S_OK != hr ) {
                break;
            }
        
            hr = pPrshtProvider->Show(NULL, usStartingPage);
        
        } while (0);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\ctrsprop.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    ctrsprop.cpp

Abstract:

    Implementation of the counters general property page.

--*/

#include "stdafx.h"
#include <strsafe.h>
#include <pdh.h>
#include <pdhmsg.h>
#include "smlogs.h"
#include "smcfgmsg.h"
#include "smctrqry.h"
#include "ctrsprop.h"
#include "smlogres.h"
#include <pdhp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("SMLOGCFG(ctrsprop.cpp)");

static ULONG
s_aulHelpIds[] =
{
    IDC_CTRS_COUNTER_LIST,      IDH_CTRS_COUNTER_LIST,
    IDC_CTRS_ADD_BTN,           IDH_CTRS_ADD_BTN,
    IDC_CTRS_ADD_OBJ_BTN,       IDH_CTRS_ADD_OBJ_BTN,
    IDC_CTRS_REMOVE_BTN,        IDH_CTRS_REMOVE_BTN,
    IDC_CTRS_FILENAME_DISPLAY,  IDH_CTRS_FILENAME_DISPLAY,
    IDC_CTRS_SAMPLE_SPIN,       IDH_CTRS_SAMPLE_EDIT,
    IDC_CTRS_SAMPLE_EDIT,       IDH_CTRS_SAMPLE_EDIT,
    IDC_CTRS_SAMPLE_UNITS_COMBO,IDH_CTRS_SAMPLE_UNITS_COMBO,
    IDC_RUNAS_EDIT,             IDH_RUNAS_EDIT,
    IDC_SETPWD_BTN,             IDH_SETPWD_BTN,
    0,0
};

/////////////////////////////////////////////////////////////////////////////
// CCountersProperty property page

IMPLEMENT_DYNCREATE(CCountersProperty, CSmPropertyPage)

CCountersProperty::CCountersProperty(MMC_COOKIE mmcCookie, LONG_PTR hConsole)
:   CSmPropertyPage ( CCountersProperty::IDD, hConsole )
// lCookie is really the pointer to the Log Query object
{
    //::OutputDebugStringA("\nCCountersProperty::CCountersProperty");

    // save pointers from arg list
    m_pCtrLogQuery = reinterpret_cast <CSmCounterLogQuery *>(mmcCookie);
    ASSERT ( m_pCtrLogQuery->CastToCounterLogQuery() );
    m_pQuery = dynamic_cast <CSmLogQuery*> (m_pCtrLogQuery);

    ZeroMemory ( &m_dlgConfig, sizeof(m_dlgConfig) );
    m_szCounterListBuffer = NULL;
    m_dwCounterListBufferSize = 0;
    m_lCounterListHasStars = 0;
    m_dwMaxHorizListExtent = 0;
    memset(&m_HashTable, 0, sizeof(m_HashTable));
    
    //  EnableAutomation();
    //{{AFX_DATA_INIT(CCountersProperty)
    m_nSampleUnits = 0;
    //}}AFX_DATA_INIT
}

CCountersProperty::CCountersProperty() : CSmPropertyPage ( CCountersProperty::IDD )
{
    ASSERT (FALSE); // the constructor w/ args should be used instead
}

CCountersProperty::~CCountersProperty()
{
//    ::OutputDebugStringA("\nCCountersProperty::~CCountersProperty");

    if (m_szCounterListBuffer != NULL) {
        delete [] m_szCounterListBuffer;
    }
    ClearCountersHashTable();
}

void CCountersProperty::OnFinalRelease()
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CPropertyPage::OnFinalRelease();
}

void CCountersProperty::DoDataExchange(CDataExchange* pDX)
{
    CString strTemp;
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CCountersProperty)
    DDX_Text(pDX, IDC_CTRS_LOG_SCHED_TEXT, m_strStartDisplay);
    ValidateTextEdit(pDX, IDC_CTRS_SAMPLE_EDIT, 6, &m_SharedData.stiSampleTime.dwValue, eMinSampleInterval, eMaxSampleInterval);
    DDX_CBIndex(pDX, IDC_CTRS_SAMPLE_UNITS_COMBO, m_nSampleUnits);
    DDX_Text(pDX, IDC_RUNAS_EDIT, m_strUserDisplay );
    //}}AFX_DATA_MAP

    if ( pDX->m_bSaveAndValidate ) {
        m_SharedData.stiSampleTime.dwUnitType = 
            (DWORD)((CComboBox *)GetDlgItem(IDC_CTRS_SAMPLE_UNITS_COMBO))->
                    GetItemData(m_nSampleUnits);    
    }
}


BEGIN_MESSAGE_MAP(CCountersProperty, CSmPropertyPage)
    //{{AFX_MSG_MAP(CCountersProperty)
    ON_BN_CLICKED(IDC_CTRS_ADD_BTN, OnCtrsAddBtn)
    ON_BN_CLICKED(IDC_CTRS_ADD_OBJ_BTN, OnCtrsAddObjBtn)
    ON_BN_CLICKED(IDC_CTRS_REMOVE_BTN, OnCtrsRemoveBtn)
    ON_LBN_DBLCLK(IDC_CTRS_COUNTER_LIST, OnDblclkCtrsCounterList)
    ON_EN_CHANGE(IDC_CTRS_SAMPLE_EDIT, OnKillfocusSchedSampleEdit)
    ON_EN_KILLFOCUS(IDC_CTRS_SAMPLE_EDIT, OnKillfocusSchedSampleEdit)
    ON_EN_CHANGE( IDC_RUNAS_EDIT, OnChangeUser )
    ON_NOTIFY(UDN_DELTAPOS, IDC_CTRS_SAMPLE_SPIN, OnDeltaposSchedSampleSpin)
    ON_CBN_SELENDOK(IDC_CTRS_SAMPLE_UNITS_COMBO, OnSelendokSampleUnitsCombo)
    ON_BN_CLICKED(IDC_SETPWD_BTN, OnPwdBtn)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CCountersProperty, CSmPropertyPage)
    //{{AFX_DISPATCH_MAP(CCountersProperty)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_ICountersProperty to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {65154EA9-BDBE-11D1-BF99-00C04F94A83A}
static const IID IID_ICountersProperty =
{ 0x65154ea9, 0xbdbe, 0x11d1, { 0xbf, 0x99, 0x0, 0xc0, 0x4f, 0x94, 0xa8, 0x3a } };

BEGIN_INTERFACE_MAP(CCountersProperty, CSmPropertyPage)
    INTERFACE_PART(CCountersProperty, IID_ICountersProperty, Dispatch)
END_INTERFACE_MAP()



ULONG 
CCountersProperty::HashCounter(
    LPWSTR szCounterName
    )
{
    ULONG       h = 0;
    ULONG       a = 31415;  //a, b, k are primes
    const ULONG k = 16381;
    const ULONG b = 27183;
    LPWSTR szThisChar;

    if (szCounterName) {
        for (szThisChar = szCounterName; * szThisChar; szThisChar ++) {
            h = (a * h + ((ULONG) (* szThisChar))) % k;
            a = a * b % (k - 1);
        }
    }
    return (h % eHashTableSize);
}


//++
// Description:
//    Remove a counter path from hash table. One counter
//    path must exactly match the given one in order to be
//    removed, even it is one with wildcard
//
// Parameters:
//    pszCounterPath - Pointer to counter path to be removed
//
// Return:
//    Return TRUE if the counter path is removed, otherwis return FALSE
//--
BOOL
CCountersProperty::RemoveCounterFromHashTable(
    LPWSTR szCounterName,
    PPDH_COUNTER_PATH_ELEMENTS pCounterPath
    )
{
    ULONG lHashValue;
    PHASH_ENTRY pEntry = NULL;
    PHASH_ENTRY pPrev = NULL;
    BOOL bReturn = FALSE;

    SetLastError(ERROR_SUCCESS);

    if (szCounterName == NULL || pCounterPath == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto ErrorOut;
    }

    lHashValue = HashCounter(szCounterName);
    pEntry = m_HashTable[lHashValue];

    //
    // Check if there is a counter path which is exactly the same
    // as the given one
    //
    while (pEntry) {
        if (pEntry->pCounter == pCounterPath) 
            break;
        pPrev = pEntry;
        pEntry = pEntry->pNext;
    }

    //
    // If we found it, remove it
    //
    if (pEntry) {
        if (pPrev == NULL) {
            m_HashTable[lHashValue] = pEntry->pNext;
        }
        else {
            pPrev->pNext = pEntry->pNext;
        }
        G_FREE(pEntry->pCounter);
        G_FREE(pEntry);
        bReturn = TRUE;
    }

ErrorOut:
    return bReturn;
}


//++
// Description:
//    Insert a counter path into hash table. 
//
// Parameters:
//    pszCounterPath - Pointer to counter path to be inserted
//
// Return:
//    Return the pointer to new inserted PDH_COUNTER_PATH_ELEMENTS structure
//--
PPDH_COUNTER_PATH_ELEMENTS
CCountersProperty::InsertCounterToHashTable(
    LPWSTR pszCounterPath
    )
{
    ULONG       lHashValue;
    PHASH_ENTRY pNewEntry  = NULL;
    PPDH_COUNTER_PATH_ELEMENTS pCounter = NULL;
    PDH_STATUS pdhStatus;

    if (pszCounterPath == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto ErrorOut;
    }

    pdhStatus = AllocInitCounterPath ( pszCounterPath, &pCounter );

    if (pdhStatus != ERROR_SUCCESS) {
        SetLastError( pdhStatus );
        goto ErrorOut;
    }

    //
    // Insert at head of bucket list
    //
    lHashValue = HashCounter(pszCounterPath);

    pNewEntry = (PHASH_ENTRY) G_ALLOC(sizeof(HASH_ENTRY));
    if (pNewEntry == NULL) {
        SetLastError( ERROR_OUTOFMEMORY );
        goto ErrorOut;
    }

    pNewEntry->pCounter = pCounter;
    pNewEntry->pNext = m_HashTable[lHashValue];
    m_HashTable[lHashValue] = pNewEntry;
    return pCounter;

ErrorOut:
    if (pCounter != NULL)
        G_FREE (pCounter);
    return NULL;
}

//++
// Description:
//    Check if the new counter path overlaps with a existing
//    one in logical sense
//
// Parameters:
//    pCounter - Pointer to counter path to be inserted
//
// Return:
//    Return the relation between the new and existing counter
//    paths. Possible relation is as following:
//         ERROR_SUCCESS - The two counter paths are different
//         SMCFG_DUPL_FIRST_IS_WILD - The first counter path has wildcard name
//         SMCFG_DUPL_SECOND_IS_WILD - The second counter path has wildcard name
//         SMCFG_DUPL_SINGLE_PATH - The two counter paths are the same(may 
//                                  contain wildcard)
//--
DWORD 
CCountersProperty::CheckDuplicate( PPDH_COUNTER_PATH_ELEMENTS pCounter)
{
    ULONG       lHashValue;
    PHASH_ENTRY pHead;
    PHASH_ENTRY pEntry;
    DWORD       dwStatus = ERROR_SUCCESS;

    for (lHashValue = 0; lHashValue < eHashTableSize; lHashValue++) {
        pHead = m_HashTable[lHashValue];
        if (pHead == NULL)
            continue;

        pEntry = pHead;
        while (pEntry) {
            dwStatus = CheckDuplicateCounterPaths ( pEntry->pCounter, pCounter );
            if ( dwStatus != ERROR_SUCCESS ) {
                return dwStatus;
            }
            pEntry = pEntry->pNext;
        }
    }
    return dwStatus;
}


//++
// Description:
//    The function clears all the entries in hash table
//    and set hash-table-not-set-up flag
//
// Parameters:
//    None
//
// Return:
//    None
//--
void 
CCountersProperty::ClearCountersHashTable( void )
{
    ULONG       i;
    PHASH_ENTRY pEntry;
    PHASH_ENTRY pNext;

    for (i = 0; i < eHashTableSize; i ++) {
        pNext = m_HashTable[i];
        while (pNext != NULL) {
            pEntry = pNext;
            pNext  = pEntry->pNext;

            G_FREE(pEntry->pCounter);
            G_FREE(pEntry);
            pEntry = NULL;
        }
    }
}


static 
PDH_FUNCTION
DialogCallBack(CCountersProperty *pDlg)
{
    // add strings in buffer to list box
    LPWSTR      szNewCounterName;
    INT         iListIndex;   
    INT         iItemCnt;   
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwReturnStatus = ERROR_SUCCESS;
    CListBox    *pCounterList;
    DWORD       dwItemExtent;
    DWORD       dwStatus = ERROR_SUCCESS;
    BOOL        bAtLeastOneCounterRemoved = FALSE;
    BOOL        bAtLeastOneCounterNotAdded = FALSE;
    LPWSTR      szCounterPath = NULL;
    LONG        lSize = 0;
    PPDH_COUNTER_PATH_ELEMENTS pPathInfoNew = NULL;
    CDC*        pCDC = NULL;
    ResourceStateManager    rsm;
    

#define CTRBUFLIMIT (0x7fffffff)

    if ( PDH_MORE_DATA == pDlg->m_dlgConfig.CallBackStatus ) {
        if ( pDlg->m_dlgConfig.cchReturnPathLength < CTRBUFLIMIT ) {

            pDlg->m_dwCounterListBufferSize *= 2;
            delete [] pDlg->m_szCounterListBuffer;
            pDlg->m_szCounterListBuffer = NULL;

            try {
                pDlg->m_szCounterListBuffer = new WCHAR[pDlg->m_dwCounterListBufferSize];
        
            } catch ( ... ) {
                pDlg->m_dwCounterListBufferSize = 0;
                pDlg->m_dlgConfig.CallBackStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                dwReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }

            if ( ERROR_SUCCESS == dwReturnStatus ) {
                // clear buffer
                memset (
                    pDlg->m_szCounterListBuffer, 
                    0, 
                    pDlg->m_dwCounterListBufferSize * sizeof(WCHAR) );
            
                pDlg->m_dlgConfig.szReturnPathBuffer = pDlg->m_szCounterListBuffer;
                pDlg->m_dlgConfig.cchReturnPathLength = pDlg->m_dwCounterListBufferSize;
                pDlg->m_dlgConfig.CallBackStatus = PDH_RETRY;
                dwReturnStatus = PDH_RETRY;
            }
        } else {
            pDlg->m_dlgConfig.CallBackStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            dwReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
    } else if ( ERROR_SUCCESS == pDlg->m_dlgConfig.CallBackStatus ) {

        pCounterList = (CListBox *)pDlg->GetDlgItem(IDC_CTRS_COUNTER_LIST);
    
        if ( NULL != pCounterList ) {
            pCDC = pCounterList->GetDC();
        }

        if ( NULL != pCDC ) {

            for (szNewCounterName = pDlg->m_szCounterListBuffer;
                *szNewCounterName != 0;
                szNewCounterName += (lstrlen(szNewCounterName) + 1)) {

                //
                // Parse new pathname
                //
                pdhStatus = pDlg->AllocInitCounterPath ( szNewCounterName, &pPathInfoNew );
            
                //
                // Check for duplicate
                //
                if (pdhStatus == ERROR_SUCCESS && NULL != pPathInfoNew ) {
                    dwStatus = pDlg->CheckDuplicate( pPathInfoNew);
                    if ( ERROR_SUCCESS != dwStatus ) {
                        if ( SMCFG_DUPL_SINGLE_PATH == dwStatus 
                                || SMCFG_DUPL_FIRST_IS_WILD == dwStatus ) {
                            // NOTE:  This includes case where both first
                            // and second are wild.
                            bAtLeastOneCounterNotAdded = TRUE;
                        } else {
                            ASSERT( dwStatus == SMCFG_DUPL_SECOND_IS_WILD);
                        }
                    }
                }

                //
                // Check if there is a valid counter to add to the list
                //
                if ( ERROR_SUCCESS == pdhStatus && ( NULL != pPathInfoNew ) &&
                    ( ERROR_SUCCESS == dwStatus || SMCFG_DUPL_SECOND_IS_WILD == dwStatus)) {

                    if ( SMCFG_DUPL_SECOND_IS_WILD == dwStatus ) {
                        //
                        // Scan for the duplicated items in the list box and
                        // remove them
                        //
                        iItemCnt = pCounterList->GetCount();
                    
                        szCounterPath = new WCHAR [MAX_PATH+1];
                        if (szCounterPath == NULL) {
                            return PDH_MEMORY_ALLOCATION_FAILURE;
                        }
                        lSize = MAX_PATH;

                        for (iListIndex = iItemCnt-1; iListIndex >= 0; iListIndex--) {
                            PPDH_COUNTER_PATH_ELEMENTS pPathInfoExist;

                            if (pCounterList->GetTextLen(iListIndex) > lSize) {
                                delete [] szCounterPath;
                                lSize = max(pCounterList->GetTextLen(iListIndex) + 1, lSize*2);
                                szCounterPath = new WCHAR [lSize];
                                if (szCounterPath == NULL) {
                                    return PDH_MEMORY_ALLOCATION_FAILURE;
                                }
                            }

                            if ( 0 < pCounterList->GetText( iListIndex, szCounterPath ) ) {
                                pPathInfoExist = (PPDH_COUNTER_PATH_ELEMENTS) 
                                                             pCounterList->GetItemDataPtr(iListIndex);

                                if (pPathInfoExist == NULL)
                                    continue;

                                dwStatus = CheckDuplicateCounterPaths ( pPathInfoExist, pPathInfoNew ); 

                                if (dwStatus != ERROR_SUCCESS ) {
                                    ASSERT( dwStatus == SMCFG_DUPL_SECOND_IS_WILD );

                                    pDlg->RemoveCounterFromHashTable(szCounterPath, pPathInfoExist);
                                    pCounterList->DeleteString(iListIndex);
                                }
                            }
                        }
                        if (szCounterPath) {
                            delete [] szCounterPath;
                        }

                        bAtLeastOneCounterRemoved = TRUE;
                    }

                    //
                    // Add new counter name and select the current entry in the list box
                    //
                    iListIndex = pCounterList->AddString(szNewCounterName);

                    if (iListIndex != LB_ERR) {
                        if (pDlg->m_lCounterListHasStars != PDLCNFIG_LISTBOX_STARS_YES) {
                            // save a string compare if this value is already set
                            if (wcsstr (szNewCounterName, L"*") == NULL) {
                                pDlg->m_lCounterListHasStars = PDLCNFIG_LISTBOX_STARS_YES;
                            }
                        }

                        if (! bAtLeastOneCounterRemoved) {
                            // update list box extent
                            if ( NULL != pCDC ) {
                                dwItemExtent = (DWORD)(pCDC->GetTextExtent (szNewCounterName)).cx;
                                if (dwItemExtent > pDlg->m_dwMaxHorizListExtent) {
                                    pDlg->m_dwMaxHorizListExtent = dwItemExtent;
                                    pCounterList->SetHorizontalExtent(dwItemExtent);
                                }
                            }
                        }

                        pCounterList->SetSel (-1, FALSE);    // cancel existing selections
                        pCounterList->SetSel (iListIndex);
                        pCounterList->SetCaretIndex (iListIndex);
                        pCounterList->SetItemDataPtr(iListIndex,
                                               (void*)pDlg->InsertCounterToHashTable(szNewCounterName));
                    }
                }
        
                if ( ERROR_SUCCESS != pdhStatus ) {
                    // Message box Pdh error message, go on to next 
                    CString strMsg;
                    CString strPdhMessage;

                    FormatSystemMessage ( pdhStatus, strPdhMessage );

                    MFC_TRY
                        strMsg.Format ( IDS_CTRS_PDH_ERROR, szNewCounterName );
                        strMsg += strPdhMessage;
                    MFC_CATCH_MINIMUM
        
                    ::AfxMessageBox( strMsg, MB_OK|MB_ICONERROR, 0 );
                }
                // Go on to next path to add
                dwStatus = ERROR_SUCCESS;
            }
        } else {
            dwReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        if ( ERROR_SUCCESS == dwReturnStatus && bAtLeastOneCounterRemoved) {
            // 
            // Clear the max extent and recalculate
            //
            pDlg->m_dwMaxHorizListExtent = 0;
            for ( iListIndex = 0; iListIndex < pCounterList->GetCount(); iListIndex++ ) {
 
                pCounterList->GetText(iListIndex, szCounterPath);

                if ( NULL != pCDC ) {
                    dwItemExtent = (DWORD)(pCDC->GetTextExtent(szCounterPath)).cx;
                    if (dwItemExtent > pDlg->m_dwMaxHorizListExtent) {
                        pDlg->m_dwMaxHorizListExtent = dwItemExtent;
                    }
                }
            }
            pCounterList->SetHorizontalExtent(pDlg->m_dwMaxHorizListExtent);
        }

        if ( NULL != pCDC ) {
            pCounterList->ReleaseDC(pCDC);
            pCDC = NULL;
        }

        // Message box re: duplicates not added, or duplicates were removed.
        if ( bAtLeastOneCounterRemoved ) {
            CString strMsg;
        
            strMsg.LoadString ( IDS_CTRS_DUPL_PATH_DELETED );

            ::AfxMessageBox ( strMsg, MB_OK  | MB_ICONWARNING, 0);
        }

        if ( bAtLeastOneCounterNotAdded ) {
            CString strMsg;
            
            strMsg.LoadString ( IDS_CTRS_DUPL_PATH_NOT_ADDED );
            
            ::AfxMessageBox( strMsg, MB_OK|MB_ICONWARNING, 0 );
        }

        // clear buffer
        memset (pDlg->m_szCounterListBuffer, 0, pDlg->m_dwCounterListBufferSize);
        dwReturnStatus = ERROR_SUCCESS;
    } else {
        // Not successful
        dwReturnStatus = pDlg->m_dlgConfig.CallBackStatus; 
    }

    return dwReturnStatus;
}


void CCountersProperty::OnPwdBtn()
{
    CString strTempUser;

    UpdateData(TRUE);

    if (!m_bCanAccessRemoteWbem) {
        ConnectRemoteWbemFail(m_pCtrLogQuery, TRUE);
        return;
    }

    MFC_TRY
        strTempUser = m_strUserDisplay;

        m_strUserDisplay.TrimLeft();
        m_strUserDisplay.TrimRight();

        m_pCtrLogQuery->m_strUser = m_strUserDisplay;

        SetRunAs(m_pCtrLogQuery);

        m_strUserDisplay = m_pCtrLogQuery->m_strUser;

        if ( 0 != strTempUser.CompareNoCase ( m_strUserDisplay ) ) {
            SetDlgItemText ( IDC_RUNAS_EDIT, m_strUserDisplay );
        }
    MFC_CATCH_MINIMUM;
}

BOOL 
CCountersProperty::IsValidLocalData()
{
    BOOL bIsValid = TRUE;
    CListBox * pCounterList = (CListBox *)GetDlgItem(IDC_CTRS_COUNTER_LIST);
    long    lNumCounters;

    ResourceStateManager rsm;

    lNumCounters = pCounterList->GetCount();
    if ( 0 == lNumCounters ) {
        CString strMsg;

        bIsValid = FALSE;
        
        strMsg.LoadString ( IDS_CTRS_REQUIRED );
    
        MessageBox ( strMsg, m_pCtrLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
        GetDlgItem ( IDC_CTRS_ADD_BTN )->SetFocus();    
    }

    if (bIsValid) {
        // Validate sample interval value
        bIsValid = ValidateDWordInterval(IDC_CTRS_SAMPLE_EDIT,
                                         m_pCtrLogQuery->GetLogName(),
                                         (long) m_SharedData.stiSampleTime.dwValue,
                                         eMinSampleInterval,
                                         eMaxSampleInterval);
    }

    if (bIsValid) {
        // Validate sample interval value and unit type
        bIsValid = SampleIntervalIsInRange(                         
                    m_SharedData.stiSampleTime,
                    m_pCtrLogQuery->GetLogName() );

        if ( !bIsValid ) {
            GetDlgItem ( IDC_CTRS_SAMPLE_EDIT )->SetFocus();    
        }
    }

    return bIsValid;
}
/////////////////////////////////////////////////////////////////////////////
// CCountersProperty message handlers

void 
CCountersProperty::OnChangeUser()
{
    //
    // If you can not access remote WBEM, you can not modify RunAs info,
    // changing the user name is not allowed.
    //
    if (m_bCanAccessRemoteWbem) {
        //
        // When the user hits OK in the password dialog, 
        // the user name might not have changed.
        //
        UpdateData ( TRUE );

        m_strUserDisplay.TrimLeft();
        m_strUserDisplay.TrimRight();

        if ( 0 != m_strUserSaved.Compare ( m_strUserDisplay ) ) {
            m_pCtrLogQuery->m_fDirtyPassword = PASSWORD_DIRTY;
            SetModifiedPage(TRUE);
        }
        else {
            m_pCtrLogQuery->m_fDirtyPassword &= ~PASSWORD_DIRTY;
        }
        //
        // If default user is typed, never need to set password
        //
        if (m_strUserDisplay.IsEmpty() || m_strUserDisplay.GetAt(0) == L'<') {
            if (m_bPwdButtonEnabled) {
                GetDlgItem(IDC_SETPWD_BTN)->EnableWindow(FALSE);
                m_bPwdButtonEnabled = FALSE;
            }
        }
        else {
            if (!m_bPwdButtonEnabled) {
                GetDlgItem(IDC_SETPWD_BTN)->EnableWindow(TRUE);
                m_bPwdButtonEnabled = TRUE;
            }
        }
    }
    else {
        //
        // We can not modify the RunAs info, then display
        // an error message and retore the original user name in RunAs
        //
        UpdateData(TRUE);
        if (ConnectRemoteWbemFail(m_pCtrLogQuery, FALSE)) {
            GetDlgItem(IDC_RUNAS_EDIT)->SetWindowText(m_strUserSaved);
        }
    }
}

void 
CCountersProperty::OnCtrsAddBtn() 
{
    ImplementAdd( FALSE );
}

void
CCountersProperty::OnCtrsAddObjBtn() 
{
    ImplementAdd( TRUE );
}

void CCountersProperty::OnCtrsRemoveBtn() 
{
    CListBox    *pCounterList;
    LONG        lThisItem;
    BOOL        bDone;
    LONG        lOrigCaret;
    LONG        lItemStatus;
    LONG        lItemCount;
    BOOL        bChanged = FALSE;
    DWORD       dwItemExtent;
    CString     strItemText;
    PPDH_COUNTER_PATH_ELEMENTS pCounter;
    CDC*        pCDC = NULL;

    pCounterList = (CListBox *)GetDlgItem(IDC_CTRS_COUNTER_LIST);

    if ( NULL == pCounterList ) {
        return;
    }

    // delete all selected items in the list box and
    // set the cursor to the item above the original caret position
    // or the first or last if that is out of the new range
    lOrigCaret = pCounterList->GetCaretIndex();
    lThisItem = 0;
    bDone = FALSE;
    // clear the max extent
    m_dwMaxHorizListExtent = 0;
    // clear the value and see if any non deleted items have a star, if so
    // then set the flag back

    pCDC = pCounterList->GetDC();

    if ( NULL != pCDC ) {

        do {
            lItemStatus = pCounterList->GetSel(lThisItem);
            if (lItemStatus > 0) {
                // then it's selected so delete it
                pCounterList->GetText(lThisItem, strItemText);
                pCounter = (PPDH_COUNTER_PATH_ELEMENTS) pCounterList->GetItemDataPtr(lThisItem);
                if (RemoveCounterFromHashTable(strItemText.GetBuffer(1), pCounter) == FALSE) {
                    ClearCountersHashTable ();
                }
                pCounterList->DeleteString(lThisItem);
                bChanged = TRUE;
            } else if (lItemStatus == 0) {
                // get the text length of this item since it will stay
                pCounterList->GetText(lThisItem, strItemText);
                if (m_lCounterListHasStars != PDLCNFIG_LISTBOX_STARS_YES) {
                    // save a string compare if this value is already set
                    if (wcsstr (strItemText, L"*") == NULL) {
                        m_lCounterListHasStars = PDLCNFIG_LISTBOX_STARS_YES;
                    }
                }
                dwItemExtent = (DWORD)(pCDC->GetTextExtent(strItemText)).cx;
                if (dwItemExtent > m_dwMaxHorizListExtent) {
                    m_dwMaxHorizListExtent = dwItemExtent;
                }
                // then it's not selected so go to the next one
                lThisItem++;
            } else {
                // we've run out so exit
                bDone = TRUE;
            }
        } while (!bDone);
    }

    if ( NULL != pCDC ) {
        pCounterList->ReleaseDC(pCDC);
        pCDC = NULL;
    }
    
    if ( bDone ) {
        // update the text extent of the list box
        pCounterList->SetHorizontalExtent(m_dwMaxHorizListExtent);
    }

    // see how many entries are left and update the
    // caret position and the remove button state
    lItemCount = pCounterList->GetCount();
    if (lItemCount > 0) {
        // the update the caret
        if (lOrigCaret >= lItemCount) {
            lOrigCaret = lItemCount-1;
        } else {
            // caret should be within the list
        }
        pCounterList->SetSel(lOrigCaret);
        pCounterList->SetCaretIndex(lOrigCaret);
    } else {
        // the list is empty so remove caret, selection
        // disable the remove button and activate the
        // add button
        pCounterList->SetSel(-1);
    }

    SetButtonState();
    SetModifiedPage(bChanged);
}

void CCountersProperty::OnDblclkCtrsCounterList() 
{
    ImplementAdd( FALSE );
}

BOOL CCountersProperty::OnSetActive()
{
    BOOL        bReturn;

    bReturn = CSmPropertyPage::OnSetActive();
    
    if (bReturn) {

        ResourceStateManager    rsm;

        m_pCtrLogQuery->GetPropPageSharedData ( &m_SharedData );

        UpdateFileNameString();

        UpdateLogStartString();

        m_strUserDisplay = m_pCtrLogQuery->m_strUser;
        UpdateData(FALSE); //to load the edit & combo box
    }
    
    return bReturn;
}

BOOL CCountersProperty::OnKillActive() 
{
    BOOL bContinue = TRUE;
    ResourceStateManager    rsm;

    bContinue = CPropertyPage::OnKillActive();

    if ( bContinue ) {
        m_pCtrLogQuery->m_strUser = m_strUserDisplay;
        bContinue = IsValidData(m_pCtrLogQuery, VALIDATE_FOCUS);
        if ( bContinue ) {
            m_pCtrLogQuery->SetPropPageSharedData ( &m_SharedData );
            SetIsActive ( FALSE );
        }
    }
    return bContinue;
}

void
CCountersProperty::OnCancel()
{
    m_pCtrLogQuery->SyncPropPageSharedData();  // clear memory shared between property pages.
}

BOOL 
CCountersProperty::OnApply() 
{
    CListBox * pCounterList = (CListBox *)GetDlgItem(IDC_CTRS_COUNTER_LIST);
    long    lThisCounter;
    BOOL    bContinue = TRUE;
    LPWSTR  szCounterPath = NULL;
    LONG    lSize = 0;

    ResourceStateManager    rsm;

    bContinue = UpdateData(TRUE);
    
    if ( bContinue ) {
        bContinue = IsValidData(m_pCtrLogQuery, VALIDATE_APPLY );
    }

    if ( bContinue ) {
        bContinue = SampleTimeIsLessThanSessionTime ( m_pCtrLogQuery );
        if ( !bContinue ) {
            SetFocusAnyPage ( IDC_CTRS_SAMPLE_EDIT );
        }
    }

    // Write data to the query object.
    if ( bContinue ) {

        ASSERT ( 0 < pCounterList->GetCount() );

        // update the counter MSZ string using the counters from the list box        
        m_pCtrLogQuery->ResetCounterList(); // clear the old counter list
    
        szCounterPath = new WCHAR [MAX_PATH+1];
        if (szCounterPath == NULL) {
            return FALSE;
        }

        lSize = MAX_PATH;

        for ( lThisCounter = 0; lThisCounter < pCounterList->GetCount(); lThisCounter++ ) {
            if (pCounterList->GetTextLen(lThisCounter) > lSize) {
                delete [] szCounterPath;
                lSize = max(pCounterList->GetTextLen(lThisCounter) + 1, lSize*2);
                szCounterPath = new WCHAR [lSize];
                if (szCounterPath == NULL) {
                    bContinue = FALSE;
                    break;
                }
            }
            pCounterList->GetText(lThisCounter, szCounterPath);
            m_pCtrLogQuery->AddCounter(szCounterPath);
        }

        if (szCounterPath != NULL) 
            delete [] szCounterPath;

        if ( bContinue ) {
        
            // Sample interval
            ASSERT ( SLQ_TT_TTYPE_SAMPLE == m_SharedData.stiSampleTime.wTimeType );
            ASSERT ( SLQ_TT_DTYPE_UNITS == m_SharedData.stiSampleTime.wDataType );

            bContinue = m_pCtrLogQuery->SetLogTime (&m_SharedData.stiSampleTime, (DWORD)m_SharedData.stiSampleTime.wTimeType);

            // Save property page shared data.
            m_pCtrLogQuery->UpdatePropPageSharedData();
            
            if ( bContinue ) {
                // ApplyRunAs must be called before UpdateService
                bContinue = ApplyRunAs(m_pCtrLogQuery); 
            }

            if ( bContinue ) { 
                bContinue = UpdateService( m_pCtrLogQuery, TRUE );
            }
        }
    }

    if ( bContinue ){
        bContinue = CSmPropertyPage::OnApply();
    }

    return bContinue;
}

void 
CCountersProperty::UpdateLogStartString ()
{
    eStartType  eCurrentStartType;
    int     nResId = 0;
    ResourceStateManager    rsm;

    eCurrentStartType = DetermineCurrentStartType();

    if ( eStartManually == eCurrentStartType ) {
        nResId = IDS_LOG_START_MANUALLY;
    } else if ( eStartImmediately == eCurrentStartType ) {
        nResId = IDS_LOG_START_IMMED;
    } else if ( eStartSched == eCurrentStartType ) {
        nResId = IDS_LOG_START_SCHED;
    }
    if ( 0 != nResId ) {
        m_strStartDisplay.LoadString(nResId);
    } else {
        m_strStartDisplay.Empty();
    }

    return;
}


void CCountersProperty::UpdateFileNameString ()
{
    m_strFileNameDisplay.Empty();

    // Todo:  Handle failure status
    // Todo:  Check pointers
    CreateSampleFileName (
        m_pCtrLogQuery->GetLogName(),
        m_pCtrLogQuery->GetLogService()->GetMachineName(),
        m_SharedData.strFolderName, 
        m_SharedData.strFileBaseName,
        m_SharedData.strSqlName,
        m_SharedData.dwSuffix, 
        m_SharedData.dwLogFileType, 
        m_SharedData.dwSerialNumber,
        m_strFileNameDisplay );

    SetDlgItemText( IDC_CTRS_FILENAME_DISPLAY, m_strFileNameDisplay );
    
    // Clear the selection
    ((CEdit*)GetDlgItem( IDC_CTRS_FILENAME_DISPLAY ))->SetSel ( -1, FALSE );

    return;
}

BOOL CCountersProperty::OnInitDialog() 
{
    LPWSTR szCounterName;
    CListBox * pCounterList = (CListBox *)GetDlgItem(IDC_CTRS_COUNTER_LIST);
    CComboBox       *pCombo;
    int             nIndex;
    CString         strComboBoxString;
    int             nResult;
    DWORD           dwItemExtent;
    PPDH_COUNTER_PATH_ELEMENTS pCounterPath;
    CDC*            pCDC = NULL;

    ResourceStateManager rsm;

    //
    // Here m_pCtrLogQuery should not be NULL, if it is,
    // There must be something wrong.
    //
    if ( NULL == m_pCtrLogQuery ) {
        return TRUE;
    }

    m_pCtrLogQuery->TranslateCounterListToLocale();
    m_bCanAccessRemoteWbem = m_pCtrLogQuery->GetLogService()->CanAccessWbemRemote();

    MFC_TRY
    m_pCtrLogQuery->SetActivePropertyPage( this );

    //load counter list box from string in counter list
    pCounterList->ResetContent();
    ClearCountersHashTable();
    szCounterName = (LPWSTR)m_pCtrLogQuery->GetFirstCounter();

    pCDC = pCounterList->GetDC();

    while (szCounterName != NULL) {

        nIndex = pCounterList->AddString(szCounterName);
        if (nIndex < 0)
            continue;

        //
        // Insert counter path into hash table
        //

        pCounterPath = InsertCounterToHashTable(szCounterName);
        if (pCounterPath == NULL) {
            pCounterList->DeleteString(nIndex);
            continue;
        }
        
        pCounterList->SetItemDataPtr(nIndex, (void*)pCounterPath); 

        // update list box extent
        if ( NULL != pCDC ) {
            dwItemExtent = (DWORD)(pCDC->GetTextExtent (szCounterName)).cx;
            if (dwItemExtent > m_dwMaxHorizListExtent) {
                m_dwMaxHorizListExtent = dwItemExtent;
            }
        }

        szCounterName = (LPWSTR)m_pCtrLogQuery->GetNextCounter();
    }

    if ( NULL != pCDC ) {
        pCounterList->ReleaseDC(pCDC);
        pCDC = NULL;
    }

    if (m_dwMaxHorizListExtent != 0) {
        pCounterList->SetHorizontalExtent(m_dwMaxHorizListExtent);
    }

    if (pCounterList->GetCount() > 0) {
        // select first entry
        pCounterList->SetSel (0, TRUE);
        pCounterList->SetCaretIndex (0, TRUE);
    }

    // Load the shared data to get the sample unit type selection.
    m_pCtrLogQuery->GetPropPageSharedData ( &m_SharedData );

    // load combo boxes
    pCombo = (CComboBox *)(GetDlgItem(IDC_CTRS_SAMPLE_UNITS_COMBO));
    pCombo->ResetContent();
    for (nIndex = 0; nIndex < (int)dwTimeUnitComboEntries; nIndex++) {
        strComboBoxString.LoadString( TimeUnitCombo[nIndex].nResId );
        nResult = pCombo->InsertString (nIndex, (LPCWSTR)strComboBoxString);
        ASSERT (nResult != CB_ERR);
        nResult = pCombo->SetItemData (nIndex, (DWORD)TimeUnitCombo[nIndex].nData);
        ASSERT (nResult != CB_ERR);
        // set selected in combo box here
        if ( m_SharedData.stiSampleTime.dwUnitType == (DWORD)(TimeUnitCombo[nIndex].nData)) {
            m_nSampleUnits = nIndex;
            nResult = pCombo->SetCurSel(nIndex);
            ASSERT (nResult != CB_ERR);
        }
    }

    CSmPropertyPage::OnInitDialog();
    Initialize( m_pCtrLogQuery );
    m_strUserDisplay = m_pCtrLogQuery->m_strUser;
    m_strUserSaved = m_strUserDisplay;

    if (m_pCtrLogQuery->GetLogService()->TargetOs() == OS_WIN2K) {
        GetDlgItem(IDC_RUNAS_STATIC)->EnableWindow(FALSE);
        GetDlgItem(IDC_RUNAS_EDIT)->EnableWindow(FALSE);
    }
    if ( m_pCtrLogQuery->GetLogService()->TargetOs() == OS_WIN2K || 
        m_strUserDisplay.IsEmpty() || 
        m_strUserDisplay.GetAt(0) == L'<') {

        GetDlgItem(IDC_SETPWD_BTN)->EnableWindow(FALSE);
        m_bPwdButtonEnabled = FALSE;
    }

    SetHelpIds ( (DWORD*)&s_aulHelpIds );

    SetButtonState();
MFC_CATCH_MINIMUM;
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void 
CCountersProperty::OnDeltaposSchedSampleSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
    OnDeltaposSpin(pNMHDR, pResult, &m_SharedData.stiSampleTime.dwValue, eMinSampleInterval, eMaxSampleInterval);
}

void 
CCountersProperty::OnSelendokSampleUnitsCombo() 
{
    int nSel;
    
    nSel = ((CComboBox *)GetDlgItem(IDC_CTRS_SAMPLE_UNITS_COMBO))->GetCurSel();
    
    if ((nSel != LB_ERR) && (nSel != m_nSampleUnits)) {
        UpdateData ( TRUE );
        SetModifiedPage ( TRUE );
    }
}

void 
CCountersProperty::OnKillfocusSchedSampleEdit() 
{
    DWORD   dwOldValue;
    dwOldValue = m_SharedData.stiSampleTime.dwValue;
    UpdateData ( TRUE );
    if (dwOldValue != m_SharedData.stiSampleTime.dwValue ) {
        SetModifiedPage(TRUE);
    }
}

void CCountersProperty::PostNcDestroy() 
{
//  delete this;      

    if ( NULL != m_pCtrLogQuery ) {
        m_pCtrLogQuery->SetActivePropertyPage( NULL );
    }

    CPropertyPage::PostNcDestroy();
}

//
//  Helper functions.
//
void 
CCountersProperty::ImplementAdd( BOOL bShowObjects ) 
{
    CListBox                *pCounterList;
    LONG                    lBeforeCount;
    LONG                    lAfterCount;
    CString                 strBrowseTitle;

    ResourceStateManager    rsm;

    static DWORD sdwDefaultBufferListSize = 0x4000;

    if (m_szCounterListBuffer == NULL) {
        CString strDefaultPath;
        CString strObjCounter;

        try {
            strObjCounter.LoadString ( IDS_DEFAULT_PATH_OBJ_CTR );
            m_dwCounterListBufferSize = sdwDefaultBufferListSize;
            m_szCounterListBuffer = new WCHAR[m_dwCounterListBufferSize];
            if ( ((CSmLogService*)m_pCtrLogQuery->GetLogService())->IsLocalMachine() ) {
                strDefaultPath = L"\\";
            } else {
                strDefaultPath = L"\\\\";
                strDefaultPath += ((CSmLogService*)m_pCtrLogQuery->GetLogService())->GetMachineName();
            }
            strDefaultPath += strObjCounter;
            StringCchCopy ( m_szCounterListBuffer, m_dwCounterListBufferSize, strDefaultPath );
        } catch ( ... ) {
            m_dwCounterListBufferSize = 0;
            return;
        }
    }

    m_dlgConfig.bIncludeInstanceIndex = 1;
    m_dlgConfig.bSingleCounterPerAdd = 0;
    m_dlgConfig.bSingleCounterPerDialog = 0;
    m_dlgConfig.bLocalCountersOnly = 0;

    // allow wild cards. 
    // the log service should expand them if necessary.
    m_dlgConfig.bWildCardInstances = 1; 

    m_dlgConfig.bHideDetailBox = 1;
    m_dlgConfig.bInitializePath = 1;
    m_dlgConfig.bDisableMachineSelection = 0;
    m_dlgConfig.bIncludeCostlyObjects = 0;
    m_dlgConfig.bReserved = 0;

    m_dlgConfig.hWndOwner = this->m_hWnd;
    m_dlgConfig.szDataSource = NULL;

    m_dlgConfig.szReturnPathBuffer = m_szCounterListBuffer;
    m_dlgConfig.cchReturnPathLength = m_dwCounterListBufferSize;
    m_dlgConfig.pCallBack = (CounterPathCallBack)DialogCallBack;
    m_dlgConfig.dwDefaultDetailLevel = PERF_DETAIL_WIZARD;
    m_dlgConfig.dwCallBackArg = (UINT_PTR)this;
    m_dlgConfig.CallBackStatus = ERROR_SUCCESS;
    m_dlgConfig.bShowObjectBrowser = (bShowObjects ? 1 : 0);

    strBrowseTitle.LoadString (bShowObjects ? IDS_ADD_OBJECTS
                                            : IDS_ADD_COUNTERS);
    m_dlgConfig.szDialogBoxCaption = strBrowseTitle.GetBuffer( strBrowseTitle.GetLength() );

    pCounterList = (CListBox *)GetDlgItem(IDC_CTRS_COUNTER_LIST);
    // get count of items in the list box before calling the browser
    lBeforeCount = pCounterList->GetCount();

    PdhBrowseCounters (&m_dlgConfig);

    strBrowseTitle.ReleaseBuffer();

    // get count of items in the list box After calling the browser
    // to see if the Apply button should enabled
    lAfterCount = pCounterList->GetCount();

    if (lAfterCount > lBeforeCount) 
        SetModifiedPage(TRUE);

    // see if the remove button should be enabled
    SetButtonState();

    delete [] m_szCounterListBuffer;
    m_szCounterListBuffer = NULL;
    m_dwCounterListBufferSize = 0;
}

void 
CCountersProperty::SetButtonState ()
{
    BOOL bCountersExist;
    CListBox                *pCounterList;

    pCounterList = (CListBox *)GetDlgItem(IDC_CTRS_COUNTER_LIST);
    bCountersExist = ( 0 < pCounterList->GetCount()) ? TRUE : FALSE;

    GetDlgItem(IDC_CTRS_SAMPLE_CAPTION)->EnableWindow(bCountersExist);
    GetDlgItem(IDC_CTRS_SAMPLE_INTERVAL_CAPTION)->EnableWindow(bCountersExist);
    GetDlgItem(IDC_CTRS_SAMPLE_EDIT)->EnableWindow(bCountersExist);
    GetDlgItem(IDC_CTRS_SAMPLE_SPIN)->EnableWindow(bCountersExist);
    GetDlgItem(IDC_CTRS_SAMPLE_UNITS_CAPTION)->EnableWindow(bCountersExist);
    GetDlgItem(IDC_CTRS_SAMPLE_UNITS_COMBO)->EnableWindow(bCountersExist);

    GetDlgItem(IDC_CTRS_REMOVE_BTN)->EnableWindow(bCountersExist);
    if ( bCountersExist ) {
        GetDlgItem(IDC_CTRS_ADD_BTN)->SetFocus();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\compdata.h ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation

Module Name:

    compdata.h

Abstract:

	This class is the interface that handles anything to do with 
	the scope pane. MMC calls the IComponentData interfaces.  

--*/

#ifndef __COMPDATA_H_
#define __COMPDATA_H_

#include "smlogres.h"       // Resource symbols
#include "smlogcfg.h"       // For CLSID_ComponentData
#include "Globals.h"
#include "common.h"
#include "smctrsv.h"
#include "smtracsv.h"
#include "smalrtsv.h"
#include "shfusion.h"

// result pane column indices

#define ROOT_COL_QUERY_NAME         0
#define ROOT_COL_QUERY_NAME_SIZE    80

#define ROOT_COL_COMMENT            1
#define ROOT_COL_COMMENT_SIZE       166
#define ROOT_COL_ALERT_COMMENT_XTRA 195

#define ROOT_COL_LOG_TYPE           2
#define ROOT_COL_LOG_TYPE_SIZE      75

#define ROOT_COL_LOG_NAME           3
#define ROOT_COL_LOG_NAME_SIZE      120

#define MAIN_COL_NAME               0
#define MAIN_COL_NAME_SIZE          120

#define MAIN_COL_DESC               1
#define MAIN_COL_DESC_SIZE          321

#define EXTENSION_COL_NAME          0
#define EXTENSION_COL_TYPE          1
#define EXTENSION_COL_DESC          2

class CSmLogQuery;
class CSmRootNode;
class CLogWarnd;

class ATL_NO_VTABLE CComponentData : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IComponentData,
    public IExtendContextMenu,
    public IExtendPropertySheet,
    public ISnapinHelp
    // *** CComObjectRoot is from framewrk\stdcdata.h
  //public CComObjectRoot
{
  public:
            CComponentData();
    virtual ~CComponentData();

//DECLARE_REGISTRY_RESOURCEID(IDR_COMPONENTDATA)
//DECLARE_NOT_AGGREGATABLE(CComponentData)

    enum eBitmapIndex {
        eBmpQueryStarted = 0,
        eBmpQueryStopped = 1,
        eBmpLogType = 2,
        eBmpRootIcon = 3,
        eBmpAlertType = 4
    };

    enum eUpdateHint {
        eSmHintNewQuery = 1,
        eSmHintPreDeleteQuery = 2,
        eSmHintStartQuery = 3,
        eSmHintStopQuery = 4,
        eSmHintModifyQuery = 5,
        eSmHintPreRefresh = 6,
        eSmHintRefresh = 7
    };

    enum eNodeType {
        eCounterLog = SLQ_COUNTER_LOG,
        eTraceLog = SLQ_TRACE_LOG,
        eAlert = SLQ_ALERT,
        eMonitor = SLQ_LAST_LOG_TYPE + 1
    };

BEGIN_COM_MAP(CComponentData)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

  // IComponentData methods
  public:
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);
    STDMETHOD(GetDisplayInfo)(LPSCOPEDATAITEM pItem);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT * ppDataObject);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(CreateComponent)(LPCOMPONENT * ppComponent);
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(Destroy)();

// IExtendPropertySheet methods
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK pCall, LONG_PTR handle, LPDATAOBJECT pDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject);

// ISnapinHelp interface members
    STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);

// IExtendContextMenu 
    STDMETHOD(AddMenuItems)( LPDATAOBJECT pDataObject,
                             LPCONTEXTMENUCALLBACK pCallbackUnknown,
                             long *pInsertionAllowed
                           );
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);
    
// other helper methods
  public:
            BOOL    IsLogService(MMC_COOKIE mmcCookie);
            BOOL    IsScopeNode(MMC_COOKIE mmcCookie);
            BOOL    IsAlertService (MMC_COOKIE mmcCookie);

            BOOL    IsLogQuery(MMC_COOKIE mmcCookie);
            BOOL    IsRunningQuery( CSmLogQuery* pQuery);

            LPCWSTR GetConceptsHTMLHelpFileName ( void );
            LPCWSTR GetSnapinHTMLHelpFileName ( void );
            LPCWSTR GetHTMLHelpTopic ( void );            
            const CString& GetContextHelpFilePath ( void );
            IPropertySheetProvider * GetPropSheetProvider();
            BOOL    LogTypeCheckNoMore (CLogWarnd* LogWarnd);

            // *** NOTE: Use of extension subclass not implemented.
            BOOL    IsExtension(){ return m_bIsExtension; };

            void    HandleTraceConnectError( HRESULT&, CString&, CString& );

            HRESULT CreateNewLogQuery( LPDATAOBJECT pDataObject, IPropertyBag* pPropBag = NULL);
            HRESULT CreateLogQueryFrom(LPDATAOBJECT pDataObject);

//  Methods to support IComponentData
  private:
            HRESULT OnExpand(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
            HRESULT OnRemoveChildren(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param );
            
            HRESULT ProcessCommandLine ( CString& rstrMachineName );
            HRESULT LoadFromFile ( LPWSTR  pszFileName );

            LPRESULTDATA    GetResultData ( void );

            void    SetExtension( BOOL bExt ){ m_bIsExtension = bExt; };
            BOOL    IsMyComputerNodetype (GUID& refguid);

            HRESULT InitPropertySheet ( CSmLogQuery*, MMC_COOKIE, LONG_PTR, CPropertySheet* );
            HRESULT NewTypedQuery( CSmLogService* pSvc, IPropertyBag* pPropBag ,LPDATAOBJECT pDataObject);
        
            BOOL    IsPreWindows2000Server ( const CString& rstrMachineName );

            CSmRootNode* GetOrphanedRootNode ( const CString& rstrMachineName );

    CString             m_strServerNamePersist; 

    // *** override not implemented
    BOOL                m_fAllowOverrideMachineName;        // TRUE => Allow the machine name to be overriden by the command line
    LPCONSOLENAMESPACE  m_ipConsoleNameSpace;  // Pointer name space interface
    LPCONSOLE           m_ipConsole;           // Pointer to the console interface
    LPRESULTDATA        m_ipResultData;        // Pointer to the result data interface

    LPIMAGELIST         m_ipScopeImage;        // Caching the image list
    HINSTANCE           m_hModule;             // for load string operations
    IPropertySheetProvider    *m_ipPrshtProvider;// from MMC 

    // list of root nodes 
    CTypedPtrList<CPtrList, CSmRootNode*> m_listpRootNode;     

    // list of orphaned root nodes, due to machine retargeting 
    CTypedPtrList<CPtrList, CSmRootNode*> m_listpOrphanedRootNode;
    
    CString                 m_strDisplayInfoName; 

    BOOL                    m_bIsExtension;

    CString                 m_strWindowsDirectory;
    CString                 m_strContextHelpFilePath;

};

//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::GetPropSheetProvider
//
//  Synopsis:   Access function for saved MMC IPropertySheetProvider
//              interface.
//
//  History:    05-28-1999   a-akamal
//
//---------------------------------------------------------------------------

inline IPropertySheetProvider *
CComponentData::GetPropSheetProvider()
{
    return m_ipPrshtProvider;
}

/////////////////////////////////////////////////////////////////////
class CSmLogSnapin: public CComponentData,
    public CComCoClass<CSmLogSnapin, &CLSID_ComponentData>
{
public:
    CSmLogSnapin() : CComponentData () {};
    virtual ~CSmLogSnapin() {};

DECLARE_REGISTRY_RESOURCEID(IDR_COMPONENTDATA)
DECLARE_NOT_AGGREGATABLE(CSmLogSnapin)

    virtual BOOL IsExtension() { return FALSE; }

// IPersistStream or IPersistStorage
    STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID)
    {
        *pClassID = CLSID_ComponentData;
        return S_OK;
    }
};

/////////////////////////////////////////////////////////////////////
class CSmLogExtension: public CComponentData,
    public CComCoClass<CSmLogExtension, &CLSID_ComponentData>
{
public:
            CSmLogExtension() : CComponentData () {};
    virtual ~CSmLogExtension() {};

DECLARE_REGISTRY_RESOURCEID(IDR_EXTENSION)
DECLARE_NOT_AGGREGATABLE(CSmLogExtension)

    virtual BOOL IsExtension() { return TRUE; }

// IPersistStream or IPersistStorage
    STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID)
    {
        *pClassID = CLSID_ComponentData;
        return S_OK;
    }
};

class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
        { SHActivateContext (&m_ulActivationCookie); }

    ~CThemeContextActivator()
        { SHDeactivateContext (m_ulActivationCookie); }

private:
    ULONG_PTR m_ulActivationCookie;
};

#endif //__COMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\dataobj.cpp ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation
				
Module Name:

    DATAOBJ.CPP

Abstract:

    Implementation of IDataObject for data communication

--*/

#include "StdAfx.h"
#include "smlogcfg.h"
#include "smnode.h"
#include "dataobj.h"

// MMC uses these to get necessary information from our snapin about
// our nodes.

// Register the clipboard formats
unsigned int CDataObject::s_cfMmcMachineName =
    RegisterClipboardFormat(CF_MMC_SNAPIN_MACHINE_NAME);
unsigned int CDataObject::s_cfDisplayName =
    RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CDataObject::s_cfNodeType =
    RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CDataObject::s_cfSnapinClsid =
    RegisterClipboardFormat(CCF_SNAPIN_CLASSID);

unsigned int CDataObject::s_cfInternal =
    RegisterClipboardFormat(CF_INTERNAL);

#ifdef _DEBUG                          // For tracking data objects
  static UINT nCount = 0;
  WCHAR wszMsg[64];
#endif

/////////////////////////////////////////////////////////////////////////////
// CDataObject - This class is used to pass data back and forth with MMC. It
//               uses a standard interface, IDataObject to acomplish this.
//               Refer to OLE documentation for a description of clipboard
//               formats and the IdataObject interface.

//---------------------------------------------------------------------------
// Added some code to check on data objects  
CDataObject::CDataObject()
:   m_cRefs(0),
    m_ulCookie(0),
    m_Context(CCT_UNINITIALIZED),
    m_CookieType(COOKIE_IS_ROOTNODE)
{

#ifdef _DEBUG
  swprintf( wszMsg, L"DATAOBJECT Create %u\n", nCount );
  LOCALTRACE( wszMsg );
  nCount++;
#endif

} // end Constructor()

//---------------------------------------------------------------------------
// Added some code to check on data objects  
//
CDataObject::~CDataObject()
{
  if ( ( COOKIE_IS_COUNTERMAINNODE == m_CookieType )
     || ( COOKIE_IS_TRACEMAINNODE == m_CookieType )
     || ( COOKIE_IS_ALERTMAINNODE == m_CookieType ) )
  {
    ASSERT( m_ulCookie );
  }

#ifdef _DEBUG
  swprintf( wszMsg, L"DATAOBJECT Delete %u\n", nCount );
  LOCALTRACE( wszMsg );
  nCount--;
#endif

} // end Destructor()


/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
// 

//---------------------------------------------------------------------------
//  Fill the hGlobal in pmedium with the requested data
//
STDMETHODIMP 
CDataObject::GetDataHere
(
  FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure 
  STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure  
)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  HRESULT hr = DV_E_FORMATETC;         // Unknown format
  const   CLIPFORMAT cf = pFormatEtc->cfFormat;
  IStream *pStream = NULL;

  pMedium->pUnkForRelease = NULL;      // by OLE spec

  do                                   // Write data to the stream based
  {                                    // of the clipformat
    hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
      return hr;                       // Minimal error checking

    if( cf == s_cfDisplayName )
    {
      hr = WriteDisplayName( pStream );
    }
    else if( cf == s_cfInternal)
    {
      hr = WriteInternal (pStream);
    }
    else if( cf == s_cfMmcMachineName)
    {
      hr = WriteMachineName( pStream );
    }
    else if( cf == s_cfNodeType )
    {
      hr = WriteNodeType( pStream );
    }
    else if( cf == s_cfSnapinClsid )
    {
      hr = WriteClsid( pStream );
    }
  } while( 0 );

  pStream->Release();

  return hr;

} // end GetDataHere()


/////////////////////////////////////////////////////////////////////////////
//  Support methods
//

//---------------------------------------------------------------------------
//  Write the appropriate GUID to the stream
//
HRESULT
CDataObject::WriteNodeType
(
  IStream* pStream           // [in] Stream we are writing to
)
{
  const GUID *pGuid = NULL;
    
  switch( m_CookieType )
  {
    case COOKIE_IS_ROOTNODE:
      pGuid = &GUID_RootNode;
      break;

    case COOKIE_IS_COUNTERMAINNODE:
      pGuid = &GUID_CounterMainNode;
      break;

    case COOKIE_IS_TRACEMAINNODE:
      pGuid = &GUID_TraceMainNode;
      break;

    case COOKIE_IS_ALERTMAINNODE:
      pGuid = &GUID_AlertMainNode;
      break;

    default:
     ASSERT( FALSE );
     return E_UNEXPECTED;
  }

  return pStream->Write( (PVOID)pGuid, sizeof(GUID), NULL );

} // end WriteNodeType()


//---------------------------------------------------------------------------
//  Writes the display name to the stream.  This is the name associated 
//  with the root node
// 
HRESULT
CDataObject::WriteDisplayName
(
  IStream* pStream           // [in] Stream we are writing to     
)
{
    CString strName;
    ULONG ulSizeofName;
    ResourceStateManager    rsm;

    if( NULL == m_ulCookie )
    { 
        // Add Local vs machine name when implement machine name override/change.
        // NOTE:  For root node, cookie is either NULL or points to a root node object.
        strName.LoadString( IDS_MMC_DEFAULT_NAME ); 
    } else {
        PSMNODE pTmp = reinterpret_cast<PSMNODE>(m_ulCookie);
//???        strName = *pTmp->GetDisplayName();
        strName = pTmp->GetDisplayName();
    }

    ulSizeofName = strName.GetLength();
    ulSizeofName++;                      // Count null character
    ulSizeofName *= sizeof(WCHAR);

    return pStream->Write((LPCWSTR)strName, ulSizeofName, NULL);

} // end WriteDisplayName()

//---------------------------------------------------------------------------
//  Writes the machine name to the stream.  
// 
HRESULT
CDataObject::WriteMachineName
(
  IStream* pStream           // [in] Stream we are writing to     
)
{
    CString strName;
    ULONG ulSizeOfName;

    if( NULL == m_ulCookie ) {  
        // Cookie is null if not an extension.  In that case, only support
        // local machine.
        strName = L"";  // local
    } else {
        PSMNODE pTmp = reinterpret_cast<PSMNODE>(m_ulCookie);
        strName = pTmp->GetMachineName();
    }

    ulSizeOfName = strName.GetLength();
    ulSizeOfName++;                      // Count null character
    ulSizeOfName *= sizeof(WCHAR);

    return pStream->Write((LPCWSTR)strName, ulSizeOfName, NULL);

} // end WriteMachineName()

//---------------------------------------------------------------------------
//  Writes a pointer to this data object to the stream
//
HRESULT
CDataObject::WriteInternal
(
  IStream* pStream           // [in] Stream we are writing to 
)
{
  CDataObject *pThis = this;
  return pStream->Write( &pThis, sizeof(CDataObject*), NULL );

} // end WriteInternal

//---------------------------------------------------------------------------
//  Writes the Class ID to the stream
//
HRESULT
CDataObject::WriteClsid
(
  IStream* pStream           // [in] Stream we are writing to
)
{
  return pStream->Write( &CLSID_ComponentData,
                         sizeof(CLSID_ComponentData),
                         NULL
                       );
} // end WriteClsid()


//---------------------------------------------------------------------------
//  The cookie is what ever we decide it is going to be.
//  This is being called from QueryDataObject. Refer to that code.
//
VOID 
CDataObject::SetData
(
  MMC_COOKIE         ulCookie, // [in] Unique indentifier
  DATA_OBJECT_TYPES  Context,  // [in] Context of the caller
  COOKIETYPE         Type      // [in] Type of cookie
)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  ASSERT( NULL == m_ulCookie );
  m_ulCookie   = ulCookie;
  m_Context    = Context;
  m_CookieType = Type;

} // end SetData()


/////////////////////////////////////////////////////////////////////////////
// IUnknown implementation
// 


//---------------------------------------------------------------------------
//  Standard implementation
//
STDMETHODIMP
CDataObject::QueryInterface
(
  REFIID  riid,
  LPVOID *ppvObj
)
{
  HRESULT hr = S_OK;

  do
  {
    if( NULL == ppvObj )
    {
      hr = E_INVALIDARG;
      break;
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
      *ppvObj = (IUnknown *)(IDataObject *)this;
    }
    else if (IsEqualIID(riid, IID_IDataObject))
    {
      *ppvObj = (IUnknown *)(IDataObject *)this;
    }
    else
    {
      hr = E_NOINTERFACE;
      *ppvObj = NULL;
      break;
    }

    // If we got this far we are handing out a new interface pointer on 
    // this object, so addref it.  
    AddRef();
  } while (0);

  return hr;

} // end QueryInterface()

//---------------------------------------------------------------------------
//  Standard implementation
//
STDMETHODIMP_(ULONG)
CDataObject::AddRef()
{
  return InterlockedIncrement((LONG*) &m_cRefs);
}

//---------------------------------------------------------------------------
//  Standard implementation
//
STDMETHODIMP_(ULONG)
CDataObject::Release()
{
  ULONG cRefsTemp;
  cRefsTemp = InterlockedDecrement((LONG *)&m_cRefs);

  if( 0 == cRefsTemp )
  {
    delete this;
  }

  return cRefsTemp;

} // end Release()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\dialogs.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    fileprop.cpp

Abstract:

    Implementation of the files property page.

--*/

#include "stdafx.h"
#include "globals.h"
#include "dialogs.h"
#include "smcfghlp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("SMLOGCFG(dialogs.cpp)");

static ULONG
sPASSWORD_aulHelpIds[] =
{
    IDC_USERNAME,    IDH_USERNAME,
    IDC_PASSWORD1,   IDH_CTRS_ENTER_PWD,
    IDC_PASSWORD2,   IDH_CTRS_REENTER_PWD,
    0,0
};


/////////////////////////////////////////////////////////////////////////////
// CPasswordDlg dialog


CPasswordDlg::CPasswordDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CPasswordDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPasswordDlg)
	m_strUserName = L"";
	m_strPassword1 = L"";
	m_strPassword2 = L"";
	//}}AFX_DATA_INIT
}

CPasswordDlg::~CPasswordDlg()
{
    KillString( m_strPassword1 );
    KillString( m_strPassword2 );
}

void CPasswordDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPasswordDlg)
	DDX_Text(pDX, IDC_USERNAME,  m_strUserName);
	DDX_Text(pDX, IDC_PASSWORD1, m_strPassword1);
	DDX_Text(pDX, IDC_PASSWORD2, m_strPassword2);
	//}}AFX_DATA_MAP
}

BOOL CPasswordDlg::OnInitDialog()
{
    if( m_strUserName.GetLength() ){
        GetDlgItem( IDC_USERNAME )->EnableWindow(FALSE);
        GetDlgItem( IDC_PASSWORD1 )->SetFocus();
    }
    
    CDialog::OnInitDialog();
    return FALSE;
}

void CPasswordDlg::OnOK() 
{
    UpdateData();
    if( m_strPassword1 != m_strPassword2 ){
        CString strMessage;
        CString strTitle;
        strMessage.LoadString ( IDS_BAD_PASSWORD_MATCH );
        strTitle.LoadString( IDS_PASSWORD_TITLE );
        MessageBox ( strMessage, strTitle, MB_OK  | MB_ICONERROR);            
        GetDlgItem( IDC_PASSWORD1 )->SetFocus();
        return;
    }

	CDialog::OnOK();
}

BOOL
CPasswordDlg::OnHelpInfo(HELPINFO * pHelpInfo)
{
    if (pHelpInfo->iCtrlId >= IDC_PWD_FIRST_HELP_CTRL_ID || 
        pHelpInfo->iCtrlId == IDOK ||
        pHelpInfo->iCtrlId== IDCANCEL ) {

        InvokeWinHelp(WM_HELP,
                      NULL,
                      (LPARAM) pHelpInfo,
                      m_strHelpFilePath,
                      sPASSWORD_aulHelpIds);
    }
    return TRUE;
}

DWORD
CPasswordDlg::SetContextHelpFilePath(const CString& rstrPath)
{
    DWORD dwStatus = ERROR_SUCCESS;
    MFC_TRY
        m_strHelpFilePath = rstrPath;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

BEGIN_MESSAGE_MAP(CPasswordDlg, CDialog)
	//{{AFX_MSG_MAP(CPasswordDlg)
     ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\dataobj.h ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation

Module Name:

    DataObj.h

Abstract:

    The IDataObject Interface is used to communicate data

--*/

#ifndef __DATAOBJ_H_
#define __DATAOBJ_H_

// Disable 64-bit warnings in atlctl.h
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4510 )
#pragma warning ( disable : 4610 )
#pragma warning ( disable : 4100 )
#include <atlctl.h>
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

/////////////////////////////////////////////////////////////////////////////
// Defines, Types etc...
//

class CComponentData;        // Forward declaration


typedef enum tagCOOKIETYPE
{
  COOKIE_IS_ROOTNODE,
  COOKIE_IS_COUNTERMAINNODE,
  COOKIE_IS_TRACEMAINNODE,
  COOKIE_IS_ALERTMAINNODE,
  COOKIE_IS_MYCOMPUTER,

} COOKIETYPE;


/////////////////////////////////////////////////////////////////////////////
// CDataObject - This class is used to pass data back and forth with MMC. It
//               uses a standard interface, IDataObject to acomplish this.
//                Refer to OLE documentation for a description of clipboard
//               formats and the IDataObject interface.

class CDataObject:
    public IDataObject,
    public CComObjectRoot

{
public:

DECLARE_NOT_AGGREGATABLE(CDataObject)

BEGIN_COM_MAP(CDataObject)
    COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP_X()


            CDataObject();
    virtual ~CDataObject();

    // IUnknown overrides
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

  // IDataObject methods 
  public:
    STDMETHOD(GetDataHere)(FORMATETC *pformatetc, STGMEDIUM *pmedium);

  // The rest are not implemented in this sample    
    STDMETHOD(GetData)(LPFORMATETC /*lpFormatetcIn*/, LPSTGMEDIUM /*lpMedium*/)
    { AFX_MANAGE_STATE(AfxGetStaticModuleState());
      return E_NOTIMPL; 
    };

    STDMETHOD(EnumFormatEtc)(DWORD /*dwDirection*/, LPENUMFORMATETC* /*ppEnumFormatEtc*/)
    { return E_NOTIMPL; };

    STDMETHOD(QueryGetData)(LPFORMATETC /*lpFormatetc*/) 
    { AFX_MANAGE_STATE(AfxGetStaticModuleState());
      return E_NOTIMPL;
    };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC /*lpFormatetcIn*/, LPFORMATETC /*lpFormatetcOut*/)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC/* lpFormatetc */, LPSTGMEDIUM /* lpMedium */, BOOL /* bRelease */)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC /* lpFormatetc */, DWORD /* advf */, 
        LPADVISESINK /* pAdvSink */, LPDWORD /* pdwConnection */)
    { return E_NOTIMPL; };
    
    STDMETHOD(DUnadvise)(DWORD /* dwConnection */)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* /* ppEnumAdvise */)
    { return E_NOTIMPL; };

  // Non-interface member functions
  public:
    DATA_OBJECT_TYPES GetContext()     { return m_Context;    }
    COOKIETYPE        GetCookieType()  { return m_CookieType; } 
    MMC_COOKIE        GetCookie()      { return m_ulCookie;   }

    VOID     SetData(MMC_COOKIE ulCookie, DATA_OBJECT_TYPES Type, COOKIETYPE ct);

  private:
    HRESULT  WriteInternal(IStream *pstm);
    HRESULT  WriteDisplayName(IStream *pstm);
    HRESULT  WriteMachineName(IStream *pstm);
    HRESULT  WriteNodeType(IStream *pstm);
    HRESULT  WriteClsid(IStream *pstm);

    ULONG               m_cRefs;       // Object refcount
    MMC_COOKIE          m_ulCookie;    // What this obj refers to
    DATA_OBJECT_TYPES   m_Context;     // Context in which this was created (Data object type)
    COOKIETYPE          m_CookieType;  // How to interpret m_ulCookie

  public:
    static UINT s_cfMmcMachineName;     // format for machine name when ext. snapin
    static UINT s_cfInternal;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
};

#endif // __DATAOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\compdata.cpp ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation

Module Name:

    compdata.cpp

Abstract:

    Implementation of the CComponentData class.
    This class is the interface to handle anything to do
    with the scope pane. MMC calls the IComponentData interfaces.
    This class keeps a few pointers to interfaces that MMC
    implements.

--*/

#include "stdafx.h"
#include <shfolder.h>
#include <strsafe.h>
#include <pdhp.h>       // For pdhi structures and methods
#include "smcfgmsg.h"
#include "smtprov.h"
#include "smrootnd.h"
#include "ipropbag.h"
#include "smlogqry.h"
#include "cmponent.h"
#include "smcfgmsg.h"
#include "newqdlg.h"
#include "logwarnd.h"
#include "strnoloc.h"

#include "ctrsprop.h"
#include "fileprop.h"
#include "provprop.h"
#include "schdprop.h"
#include "tracprop.h"
#include "AlrtGenP.h"
#include "AlrtActP.h"
//
#include "compdata.h"

USE_HANDLE_MACROS("SMLOGCFG(compdata.cpp)");

GUID g_guidSystemTools = structuuidNodetypeSystemTools;

extern DWORD g_dwRealTimeQuery;

/////////////////////////////////////////////////////////////////////////////
// CComponentData 

CComponentData::CComponentData()
:   m_bIsExtension( FALSE ),
    m_ipConsoleNameSpace ( NULL ),
    m_ipConsole          ( NULL ),
    m_ipResultData       ( NULL ),
    m_ipPrshtProvider     ( NULL ),
    m_ipScopeImage       ( NULL )
{
    m_hModule    = (HINSTANCE)GetModuleHandleW (_CONFIG_DLL_NAME_W_);

}

CComponentData::~CComponentData()
{
    // Make sure the list is empty.
    ASSERT ( m_listpRootNode.IsEmpty() );
    ASSERT ( m_listpOrphanedRootNode.IsEmpty() );
}


/////////////////////////////////////////////////////////////////////////////
// IComponentData methods
//

//---------------------------------------------------------------------------
// We get here only once, when the user clicks on the snapin.
//
// This method should not change as we progress through further steps.
// Here we get a chance to get pointer to some interfaces MMC provides.
// We QueryInterface for pointers to the name space and console, which
// we cache in local variables
// The other task to acomplish here is the adding of a bitmap that contains
// the icons to be used in the scope pane.
//
STDMETHODIMP
CComponentData::Initialize (
    LPUNKNOWN pUnknown         // [in] Pointer to the IConsoles IUnknown interface
    )
{
    HRESULT      hr;
    ASSERT( NULL != pUnknown );
    HBITMAP hbmpSNodes16 = NULL;
    HBITMAP hbmpSNodes32 = NULL;
    BOOL bWasReleased;
    
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //  LPIMAGELIST  lpScopeImage;
    
    // MMC should only call ::Initialize once!
    ASSERT( NULL == m_ipConsoleNameSpace );
    
    // Get pointer to name space interface
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (VOID**)(&m_ipConsoleNameSpace));
    ASSERT( S_OK == hr );
    
    // Get pointer to console interface
    hr = pUnknown->QueryInterface(IID_IConsole, (VOID**)(&m_ipConsole));
    ASSERT( S_OK == hr );
    
    // Get pointer to property sheet provider interface
    hr = m_ipConsole->QueryInterface(IID_IPropertySheetProvider, (VOID**)&m_ipPrshtProvider);
    ASSERT( S_OK == hr );

    // Add the images for the scope tree
    hr = m_ipConsole->QueryScopeImageList(&m_ipScopeImage);
    ASSERT( S_OK == hr );
    
    // Load the bitmaps from the dll
    hbmpSNodes16 = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_NODES_16x16));
    ASSERT( NULL != hbmpSNodes16 );
    
    hbmpSNodes32 = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_NODES_32x32));
    ASSERT( NULL != hbmpSNodes32 );
    
    // Set the images
    hr = m_ipScopeImage->ImageListSetStrip( 
        (LONG_PTR *)hbmpSNodes16,
        (LONG_PTR *)hbmpSNodes32,
        0,
        RGB(0,255,0)
        );
    ASSERT( S_OK == hr );

    if ( NULL != hbmpSNodes16 ) {
        bWasReleased = DeleteObject( hbmpSNodes16 );
        ASSERT( bWasReleased );
    }

    if ( NULL != hbmpSNodes32 ) {
        bWasReleased = DeleteObject( hbmpSNodes32 );
        ASSERT( bWasReleased );
    }


    return S_OK;
    
} // end Initialize()


//---------------------------------------------------------------------------
// Release interfaces and clean up objects which allocated memory
//
STDMETHODIMP
CComponentData::Destroy()
{
    CSmRootNode*    pRootNode = NULL;
    POSITION        Pos = m_listpRootNode.GetHeadPosition();

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    while ( Pos != NULL) {
        pRootNode = m_listpRootNode.GetNext( Pos );
        // Close all queries and the connection to the log service.
        pRootNode->Destroy();
        delete (pRootNode);
    }
    // empty the list now that everything has been closed;
    m_listpRootNode.RemoveAll();    

    Pos = m_listpOrphanedRootNode.GetHeadPosition();

    while ( Pos != NULL) {
        pRootNode = m_listpOrphanedRootNode.GetNext( Pos );
        // Close all queries and the connection to the log service.
        pRootNode->Destroy();
        delete (pRootNode);
    }
    // empty the list now that everything has been closed;
    m_listpOrphanedRootNode.RemoveAll();    

    // Free interfaces
    if ( NULL != m_ipConsoleNameSpace )
        m_ipConsoleNameSpace->Release();

    if ( NULL != m_ipConsole )
        m_ipConsole->Release();
    
    if ( NULL != m_ipResultData )
        m_ipResultData->Release();
    
    if ( NULL != m_ipScopeImage )
        m_ipScopeImage->Release();
    
    if ( NULL != m_ipPrshtProvider)
        m_ipPrshtProvider->Release();
    
    return S_OK;
    
} // end Destroy()


//---------------------------------------------------------------------------
// Come in here once right after Initialize. MMC wants a pointer to the
// IComponent interface.
//
STDMETHODIMP
CComponentData::CreateComponent (
    LPCOMPONENT* ppComponent     // [out] Pointer to the location that stores
    )                            // the newly created pointer to IComponent
{
    HRESULT hr = E_FAIL;    
    CComObject<CComponent>* pObject;
    
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // MMC asks us for a pointer to the IComponent interface
    //
    // For those getting up to speed with COM...
    // If we had implemented IUnknown with its methods QueryInterface, AddRef,
    // and Release in our CComponent class...
    // The following line would have worked
    //
    // pNewSnapin = new CComponent(this);
    //
    // In this code we will have ATL take care of IUnknown for us and create
    // an object in the following manner...
    
    if ( NULL == ppComponent ) {
        ASSERT ( FALSE );
        hr = E_INVALIDARG;
    } else {
    
        CComObject<CComponent>::CreateInstance( &pObject );

        if ( NULL != pObject ) {
            hr = pObject->SetIComponentData( this );
            
            if ( SUCCEEDED ( hr ) ) {
                hr = pObject->QueryInterface ( 
                                IID_IComponent,
                                reinterpret_cast<void**>(ppComponent) );
            } else {
                // SetIComponentData adds reference.
                pObject->Release();
            }
        }
    }
    return hr;
} // end CreateComponent()


//---------------------------------------------------------------------------
// In this first step, we only implement EXPAND.
// The expand message asks us to populate what is under our root node.
// We just put one item under there.
//
STDMETHODIMP
CComponentData::Notify (
    LPDATAOBJECT     pDataObject,   // [in] Points to the selected data object
    MMC_NOTIFY_TYPE  event,         // [in] Identifies action taken by user.
    LPARAM           arg,           // [in] Depends on the notification type
    LPARAM           param          // [in] Depends on the notification type
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    
    switch (event)
    {
    case MMCN_EXPAND:
        hr = OnExpand( pDataObject, arg, param );
        break;
        
    case MMCN_DELETE:                  // Function not implemented
        LOCALTRACE( L"ComponentData::Notify: MMCN_DELETE unimplemented\n" );
        hr = S_FALSE;
        break;
        
    case MMCN_RENAME:                  // Function not implemented
        LOCALTRACE( L"ComponentData::Notify: MMCN_RENAME unimplemented\n" );
        hr = S_FALSE;   // False signifies Rename not allowed.
        break;
        
    case MMCN_SELECT:                  // Function not implemented
        LOCALTRACE( L"ComponentData::Notify: MMCN_SELECT unimplemented\n" );
        hr = S_FALSE;
        break;
        
    case MMCN_PROPERTY_CHANGE:         // Function not implemented
        LOCALTRACE( L"ComponentData::Notify: MMCN_PROPERTY_CHANGE unimplemented\n" );
        hr = S_FALSE;
        break;
        
    case MMCN_REMOVE_CHILDREN:         // Function not implemented
        hr = OnRemoveChildren( pDataObject, arg, param );
        break;
        
    default:
        LOCALTRACE( L"CComponentData::Notify: unimplemented event %x\n", event );
        hr = S_FALSE;
        break;
    }
    return hr;
    
} // end Notify()


//---------------------------------------------------------------------------
// This is where MMC asks us to provide IDataObjects for every node in the
// scope pane.  We have to QI the object so it gets AddRef'd.  The node
// manager handles deleting the objects.
//
STDMETHODIMP
CComponentData::QueryDataObject (
    LPARAM            mmcCookie,    // [in]  Data object's unique identifier
    DATA_OBJECT_TYPES context,      // [in]  Data object's type
    LPDATAOBJECT*     ppDataObject  // [out] Points to the returned data object
    )
{
    HRESULT hr = S_OK;
    CSmNode* pNode = NULL;
    CComObject<CDataObject>* pDataObj = NULL;
    CString strMessage;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    UNREFERENCED_PARAMETER (context);            

    ASSERT( CCT_SCOPE      == context  ||      // Must have a context
        CCT_RESULT         == context  ||      // we understand
        CCT_SNAPIN_MANAGER == context
        );

    if ( NULL != ppDataObject 
        && ( CCT_SCOPE == context  
             || CCT_RESULT == context  
             || CCT_SNAPIN_MANAGER == context ) ) {

        CComObject<CDataObject>::CreateInstance( &pDataObj );

        if( NULL == pDataObj ) {            // DataObject was not created
   
            MFC_TRY
                strMessage.LoadString ( IDS_ERRMSG_UNABLEALLOCDATAOBJECT );
        
                ::MessageBox( NULL,
                    (LPCWSTR)strMessage,
                    L"CComponentData::QueryDataObject",
                    MB_OK | MB_ICONERROR
                    );
            MFC_CATCH_HR;

            hr = E_OUTOFMEMORY;
        } else {

            // If the passed-in mmcCookie is non-NULL, then it should be one we 
            // created when we added a node to the scope pane. 
            //
            // Otherwise the mmcCookie refers to the root folder (this snapin's 
            // static folder in the scope pane or snapin manager). 
            //
            // Init the mmCookie, context and type in the data object.
            if( mmcCookie ) {                        
                                            
                pNode = (CSmNode*)mmcCookie;
                if ( NULL != pNode->CastToRootNode() ) {
                    pDataObj->SetData( mmcCookie, CCT_SCOPE, COOKIE_IS_ROOTNODE );
                } else if ( NULL != pNode->CastToCounterLogService() ) {
                    pDataObj->SetData( mmcCookie, CCT_SCOPE, COOKIE_IS_COUNTERMAINNODE );
                } else if ( NULL != pNode->CastToTraceLogService() ) {
                    pDataObj->SetData( mmcCookie, CCT_SCOPE, COOKIE_IS_TRACEMAINNODE );
                } else if ( NULL != pNode->CastToAlertService() ) {
                    pDataObj->SetData( mmcCookie, CCT_SCOPE, COOKIE_IS_ALERTMAINNODE );
                } else {
                    ::MessageBox( NULL,
                        L"Bad mmcCookie",
                        L"CComponentData::QueryDataObject",
                        MB_OK | MB_ICONERROR
                        );
                    hr = E_FAIL;
                }
            } else {
                ASSERT( CCT_RESULT != context );
                // NOTE:  Passed in scope might be either CCT_SNAPIN_MANAGER or CCT_SCOPE
                // This case occcurs when the snapin is not an extension.
                pDataObj->SetData( mmcCookie, CCT_SCOPE, COOKIE_IS_ROOTNODE );
            }
            if ( SUCCEEDED ( hr ) ) {
                hr = pDataObj->QueryInterface( 
                                    IID_IDataObject,
                                    reinterpret_cast<void**>(ppDataObject) );
            } else {
                if ( NULL != pDataObj ) {
                    delete pDataObj;
                }
                *ppDataObject = NULL;
            }
        }
    } else {
        ASSERT ( FALSE );
        hr = E_POINTER;
    }
    return hr;
} // end QueryDataObject()


//---------------------------------------------------------------------------
// This is where we provide strings for nodes in the scope pane.
// MMC handles the root node string.
//
STDMETHODIMP
CComponentData::GetDisplayInfo (
    LPSCOPEDATAITEM pItem )    // [in, out] Points to a SCOPEDATAITEM struct
{
    HRESULT hr = S_OK;
    PSMNODE pTmp = NULL;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ResourceStateManager    rsm;
    
    if ( NULL != pItem ) {
        if( pItem->mask & SDI_STR ) {
            // Note:  Text buffer allocated for each information type, so that
            // the buffer pointer is persistent for a single item (line in the result pane).
    
            // Set the name of the selected node
            pTmp = reinterpret_cast<PSMNODE>(pItem->lParam);
            if ( NULL != pTmp ) {
                m_strDisplayInfoName = pTmp->GetDisplayName();
                pItem->displayname = m_strDisplayInfoName.GetBuffer( m_strDisplayInfoName.GetLength() );
            }
        }

        if( pItem->mask & SDI_IMAGE ) {  // Looking for image
            pTmp = reinterpret_cast<PSMNODE>(pItem->lParam);
            if ( NULL != pTmp ) {
                if ( NULL != pTmp->CastToRootNode() ) {
                    ASSERT((pItem->mask & (SDI_IMAGE | SDI_OPENIMAGE)) == 0);
                    pItem->nImage     = eBmpRootIcon;
                    pItem->nOpenImage = eBmpRootIcon;
                    hr = S_OK;
                } else if ( NULL != pTmp->CastToAlertService() ){   
                    pItem->nImage = eBmpAlertType;
                } else {
                    pItem->nImage = eBmpLogType;
                }
            }
        }
    } else {
        ASSERT ( FALSE );
        hr = E_POINTER;
    }

    return hr;
    
} // end GetDisplayInfo()


//---------------------------------------------------------------------------
//
STDMETHODIMP
CComponentData::CompareObjects (
    LPDATAOBJECT pDataObjectA,    // [in] First data object to compare
    LPDATAOBJECT pDataObjectB )   // [in] Second data object to compare
{
    HRESULT hr = S_OK;
    CDataObject *pdoA = NULL;
    CDataObject *pdoB = NULL;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
            
    // At least one of these data objects is supposed to be ours, so one
    // of the extracted pointers should be non-NULL.
    pdoA = ExtractOwnDataObject( pDataObjectA );
    pdoB = ExtractOwnDataObject( pDataObjectB );
    ASSERT( pdoA || pdoB );              // Assert if we can't get any objects
    
    // If extraction failed for one of them, then that one is foreign and
    // can't be equal to the other one.  (Or else ExtractOwnDataObject
    // returned NULL because it ran out of memory, but the most conservative
    // thing to do in that case is say they're not equal.)
    if( !pdoA || !pdoB ) {
        hr = S_FALSE;
    } else {
        if( pdoA->GetCookieType() != pdoB->GetCookieType() ) {
            // The cookie type could be COOKIE_IS_ROOTNODE or COOKIE_IS_MAINNODE
            // If they differ then the objects refer to different things.
            hr = S_FALSE;
        }
    }
    
    return hr;
    
} // end CompareObjects()


/////////////////////////////////////////////////////////////////////////////
//  Methods needed to support IComponentData
//

//---------------------------------------------------------------------------
// Here is our chance to place things under the root node.
//
HRESULT
CComponentData::OnExpand (
    LPDATAOBJECT pDataObject,      // [in] Points to data object
    LPARAM       arg,              // [in] TRUE is we are expanding
    LPARAM       param )             // [in] Points to the HSCOPEITEM
{
    HRESULT         hr = S_FALSE;
    HRESULT         hrBootState= NOERROR;
    INT             iBootState;
    GUID            guidObjectType;
    CSmRootNode*    pRootNode = NULL;
    CDataObject*    pDO = NULL;
    SCOPEDATAITEM   sdi;
    INT             iResult;
    CString         strTmp;
    CString         strServerName;
    CString         strMessage;
    CString         strSysMessage;
    CString         strTitle;
    CString         strComputerName;

    ResourceStateManager    rsm;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT( NULL != m_ipConsoleNameSpace );  // Make sure we QI'ed for the interface
    ASSERT( NULL != pDataObject );           // Must have valid data object
    
    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        if( TRUE == arg ) {
            hr = ExtractObjectTypeGUID (pDataObject, &guidObjectType);
            ASSERT ( SUCCEEDED (hr) );
            if ( SUCCEEDED ( hr) ) {
                if ( IsMyComputerNodetype (guidObjectType) ) {
                    // Is extension of Computer Management snapin
                    hr = ExtractMachineName (
                            pDataObject,
                            strServerName);
        
                    ASSERT ( SUCCEEDED ( hr ) );
                    if ( SUCCEEDED (hr) ) {

                        pRootNode = GetOrphanedRootNode ( strServerName );

                        if ( NULL == pRootNode ) {            
                            MFC_TRY
                                pRootNode = new CSmRootNode;
                            MFC_CATCH_HR
                            if ( SUCCEEDED (hr) ) {
                                pRootNode->SetMachineName ( strServerName );
                            }
                        }

                        if ( SUCCEEDED (hr) ) {

                            //
                            // As an extension snapin, the log nodes should be added
                            // beneath a "Performance Logs and Alerts" node.  Insert that node, 
                            // and remember it as the root of the Performance Logs and Alerts namespace.
                            //
 
                            ZeroMemory(&sdi, sizeof sdi);
                            sdi.mask        =   SDI_STR       | 
                                                SDI_PARAM     | 
                                                SDI_IMAGE     | 
                                                SDI_OPENIMAGE |   // nOpenImage is valid
                                                SDI_PARENT;
                            sdi.relativeID  = (HSCOPEITEM)param;
                            sdi.displayname = MMC_CALLBACK;
                            sdi.nImage      = eBmpRootIcon;
                            sdi.nOpenImage  = eBmpRootIcon;
                            sdi.lParam      = reinterpret_cast<LPARAM>(pRootNode);                
 
                            hr = m_ipConsoleNameSpace->InsertItem( &sdi );
 
                            if (SUCCEEDED(hr)) {
                                // Make this node the the root node 
                                pRootNode->SetExpanded ( FALSE );
                                pRootNode->SetScopeItemHandle ( (HSCOPEITEM)sdi.ID );
                                pRootNode->SetParentScopeItemHandle( (HSCOPEITEM)param );
                                pRootNode->SetExtension( TRUE );
                                SetExtension( TRUE );
                                m_listpRootNode.AddTail(pRootNode);
                            } else {
                                hr = E_UNEXPECTED;
                            }
                        } // Allocate CSmRootNode
                    } // ExtractMachineName
                } else { // Not IsMyComputerNodeType
    
                    pDO = ExtractOwnDataObject( pDataObject );
        
                    if( NULL != pDO ) {      
                        // Make sure that what we are placing ourselves under is the root node
                        // or the extension root node!
                        if ( COOKIE_IS_ROOTNODE == pDO->GetCookieType() ) {
                            pRootNode = (CSmRootNode*)pDO->GetCookie();
                            if ( NULL == pRootNode ) {
                                // If root node cookie is null, then the root node was created by 
                                // the snapin manager, and this is a standalone node.

                                pRootNode = GetOrphanedRootNode ( strServerName );

                                if ( NULL == pRootNode ) {
                                    MFC_TRY
                                        pRootNode = new CSmRootNode;
                                    MFC_CATCH_HR
                                    if ( SUCCEEDED (hr) ) {
                                        pRootNode->SetMachineName ( strServerName );
                                    }
                                }

                                if ( SUCCEEDED ( hr ) ) {
                                    pRootNode->SetExpanded ( FALSE );
                                    // Cache the root node handle 
                                    pRootNode->SetScopeItemHandle ( (HSCOPEITEM)param );
                                    pRootNode->SetParentScopeItemHandle( NULL );
                                    pRootNode->SetExtension( FALSE );
                                    SetExtension( FALSE );
                                    // NOTE:  No way to associate root node data directly with node.
                                    // Node only added once, so no need to check for duplicates.
                                    m_listpRootNode.AddTail(pRootNode);
                                }
                            } else {
                                if ( m_listpRootNode.IsEmpty() ) {
                                    hr = S_FALSE; 
                                }
                            }

                            if ( SUCCEEDED ( hr ) && S_FALSE != hr ) {
                
                                ASSERT ( NULL != pRootNode->CastToRootNode() );
                                ASSERT ( NULL != pRootNode->GetScopeItemHandle() );
                
                                ASSERT( CCT_SCOPE == pDO->GetContext() );    // Scope pane must be current context  
            
                                // For extensions, the root node was created in a previous call to this method.
                                // The root was NOT expanded in that call.
                                // For non-extensions, the root node is expanded in the same call as it is created.
                                if ( !pRootNode->IsExpanded() ) {        

                                    strServerName = pRootNode->GetMachineName();

                                    if ( !IsPreWindows2000Server( strServerName ) ) {
                                        CWaitCursor     WaitCursor;
                                        DWORD dwStatus = ERROR_SUCCESS;
                                        hr = S_OK;

                                        // Open each node independently of status of last loaded node.
                                        dwStatus = ERROR_SUCCESS;
                                        if ( !pRootNode->GetCounterLogService()->IsOpen() ) {
                                            pRootNode->GetCounterLogService()->SetRootNode( pRootNode );
                                            dwStatus = pRootNode->GetCounterLogService()->Open ( strServerName );
                                        }

                                        if ( ERROR_SUCCESS == dwStatus ) {

                                            // Place node for counter logs
                                            memset( &sdi, 0, sizeof(SCOPEDATAITEM) );
                                            sdi.mask = SDI_STR       |   // Displayname is valid
                                                       SDI_PARAM     |   // lParam is valid
                                                       SDI_IMAGE     |   // nImage is valid
                                                       SDI_OPENIMAGE |   // nOpenImage is valid
                                                       SDI_CHILDREN  |   // Children count (0 vs. 1) is valid.
                                                       SDI_PARENT;
                                            sdi.relativeID  = pRootNode->GetScopeItemHandle();  // Performance Logs and Alerts root node
                                            sdi.nImage      = eBmpLogType;
                                            sdi.nOpenImage  = sdi.nImage;   // select icon is same as non select
                                            sdi.displayname = MMC_CALLBACK;
                                            sdi.lParam      = reinterpret_cast<LPARAM>(pRootNode->GetCounterLogService());  // The cookie
                                            sdi.cChildren = 0;      // No children in the scope pane.

                                            hr = m_ipConsoleNameSpace->InsertItem( &sdi );
                                        } else {

                                            hr = E_FAIL;
                        
                                            strComputerName = strServerName;
                                            if ( strComputerName.IsEmpty() )
                                                strComputerName.LoadString ( IDS_LOCAL );

                                            if ( SMCFG_NO_READ_ACCESS == dwStatus 
                                                || SMCFG_NO_INSTALL_ACCESS == dwStatus ) 
                                            {
                                                FormatSmLogCfgMessage ( 
                                                    strMessage,
                                                    m_hModule, 
                                                    dwStatus, 
                                                    (LPCWSTR)strComputerName);
                                            } else  {
                                                FormatMessage ( 
                                                    FORMAT_MESSAGE_FROM_SYSTEM,
                                                    NULL, 
                                                    dwStatus,
                                                    0,
                                                    strMessage.GetBufferSetLength( MAX_PATH ),
                                                    MAX_PATH,
                                                    NULL );
    
                                                strMessage.ReleaseBuffer();

                                                if ( strMessage.IsEmpty() ) {
                                                    strMessage.Format ( L"0x%08lX", dwStatus );   
                                                }
                                            }
                        
                                            strTitle.LoadString ( IDS_PROJNAME );

                                            m_ipConsole->MessageBox( 
                                                (LPCWSTR)strMessage,
                                                (LPCWSTR)strTitle,
                                                MB_OK | MB_ICONWARNING,
                                                &iResult
                                                );
                                        }

                                        // Open each node independently of status of last loaded node, 
                                        // except in case of SMCFG_NO_READ_ACCESS or SMCFG_NO_INSTALL_ACCESS
                                        if ( SMCFG_NO_READ_ACCESS != dwStatus 
                                            && SMCFG_NO_INSTALL_ACCESS != dwStatus ) {
                                            dwStatus = ERROR_SUCCESS;
                                            hr = NOERROR;

                                            if ( SUCCEEDED(hr) && !pRootNode->GetTraceLogService()->IsOpen() ) {
                                                pRootNode->GetTraceLogService()->SetRootNode( pRootNode );
                                                dwStatus = pRootNode->GetTraceLogService()->Open ( strServerName );
                                            }
                                            if ( ERROR_SUCCESS == dwStatus ) {
                                                hrBootState = NOERROR;
                                                hrBootState = pRootNode->GetTraceLogService()->GetProviders()->GetBootState ( iBootState ); 
                                            } 
                                            if ( ERROR_SUCCESS == dwStatus 
                                                    && SUCCEEDED ( hrBootState ) 
                                                    && 0 == iBootState ) 
                                            {
                                                // Place node for trace logs
                                                memset( &sdi, 0, sizeof(SCOPEDATAITEM) );
                                                sdi.mask = SDI_STR       |   // Displayname is valid
                                                           SDI_PARAM     |   // lParam is valid
                                                           SDI_IMAGE     |   // nImage is valid
                                                           SDI_OPENIMAGE |   // nOpenImage is valid
                                                           SDI_CHILDREN  |   // Children count (0 vs. 1) is valid.
                                                           SDI_PARENT;
                                                sdi.relativeID  = pRootNode->GetScopeItemHandle();  // Performance Logs and Alerts root node
                                                sdi.nImage      = eBmpLogType;
                                                sdi.nOpenImage  = sdi.nImage;   // select icon is same as non select
                                                sdi.displayname = MMC_CALLBACK;
                                                sdi.lParam      = reinterpret_cast<LPARAM>(pRootNode->GetTraceLogService());  // The cookie
                                                sdi.cChildren = 0;      // No children in the scope pane.

                                                hr = m_ipConsoleNameSpace->InsertItem( &sdi );
                                            } else {
                                                strComputerName = strServerName;
                                                if ( strComputerName.IsEmpty() )
                                                    strComputerName.LoadString ( IDS_LOCAL );

                                                if ( SMCFG_NO_READ_ACCESS == dwStatus 
                                                    || SMCFG_NO_INSTALL_ACCESS == dwStatus ) 
                                                {
                                                    hr = E_FAIL;
                                                    FormatSmLogCfgMessage ( 
                                                        strMessage,
                                                        m_hModule, 
                                                        dwStatus, 
                                                        (LPCWSTR)strComputerName);
                                                } else if ( ERROR_SUCCESS != dwStatus ) {
                                                    hr = E_FAIL;
                                                    FormatMessage ( 
                                                        FORMAT_MESSAGE_FROM_SYSTEM,
                                                        NULL, 
                                                        dwStatus,
                                                        0,
                                                        strMessage.GetBufferSetLength( MAX_PATH ),
                                                        MAX_PATH,
                                                        NULL );
    
                                                    strMessage.ReleaseBuffer();

                                                    if ( strMessage.IsEmpty() ) {
                                                        strMessage.Format ( L"0x%08lX", dwStatus );   
                                                    }
                                                } else if ( FAILED ( hrBootState ) ) {

                                                    FormatSmLogCfgMessage ( 
                                                        strMessage,
                                                        m_hModule, 
                                                        SMCFG_UNABLE_OPEN_TRACESVC, 
                                                        (LPCWSTR)strComputerName);

                                                    FormatMessage ( 
                                                        FORMAT_MESSAGE_FROM_SYSTEM,
                                                        NULL, 
                                                        hrBootState,
                                                        0,
                                                        strSysMessage.GetBufferSetLength( MAX_PATH ),
                                                        MAX_PATH,
                                                        NULL );
    
                                                    strSysMessage.ReleaseBuffer();

                                                    if ( strSysMessage.IsEmpty() ) {
                                                        strSysMessage.Format ( L"0x%08lX", hrBootState );
                                                    }

                                                    strMessage += strSysMessage;
                        
                                                } else if ( 0 != iBootState ) {

                                                    FormatSmLogCfgMessage ( 
                                                        strMessage,
                                                        m_hModule, 
                                                        SMCFG_SAFE_BOOT_STATE, 
                                                        (LPCWSTR)strComputerName);
                                                }
                        
                                                strTitle.LoadString ( IDS_PROJNAME );

                                                m_ipConsole->MessageBox( 
                                                    (LPCWSTR)strMessage,
                                                    (LPCWSTR)strTitle,
                                                    MB_OK | MB_ICONWARNING,
                                                    &iResult
                                                    );
                                            }
                                        }

                                        // Open each node independently of status of last loaded node, 
                                        // except in case of SMCFG_NO_READ_ACCESS or SMCFG_NO_INSTALL_ACCESS
                                        if ( SMCFG_NO_READ_ACCESS != dwStatus 
                                            && SMCFG_NO_INSTALL_ACCESS != dwStatus ) {
                                            dwStatus = ERROR_SUCCESS;
                                            hr = NOERROR;
                                            if ( SUCCEEDED(hr) && !pRootNode->GetAlertService()->IsOpen() ) {
                                                pRootNode->GetAlertService()->SetRootNode( pRootNode );
                                                dwStatus = pRootNode->GetAlertService()->Open ( strServerName );
                                            }
                                            if ( ERROR_SUCCESS == dwStatus ) {
                                                // Place node for alerts
                                                memset( &sdi, 0, sizeof(SCOPEDATAITEM) );
                                                sdi.mask = SDI_STR       |   // Displayname is valid
                                                           SDI_PARAM     |   // lParam is valid
                                                           SDI_IMAGE     |   // nImage is valid
                                                           SDI_OPENIMAGE |   // nOpenImage is valid
                                                           SDI_CHILDREN  |   // Children count (0 vs. 1) is valid.
                                                           SDI_PARENT;
                                                sdi.relativeID  = pRootNode->GetScopeItemHandle();  // Performance Logs and Alerts root node
                                                sdi.nImage      = eBmpAlertType;
                                                sdi.nOpenImage  = sdi.nImage;   // select icon is same as non select
                                                sdi.displayname = MMC_CALLBACK;
                                                sdi.lParam      = reinterpret_cast<LPARAM>(pRootNode->GetAlertService());  // The cookie
                                                sdi.cChildren = 0;      // No children in the scope pane.

                                                hr = m_ipConsoleNameSpace->InsertItem( &sdi );
                                            } else {

                                                hr = E_FAIL;
                        
                                                strComputerName = strServerName;
                                                if ( strComputerName.IsEmpty() )
                                                    strComputerName.LoadString ( IDS_LOCAL );

                                                if ( SMCFG_NO_READ_ACCESS == dwStatus 
                                                    || SMCFG_NO_INSTALL_ACCESS == dwStatus ) 
                                                {
                                                    FormatSmLogCfgMessage ( 
                                                        strMessage,
                                                        m_hModule, 
                                                        dwStatus, 
                                                        (LPCWSTR)strComputerName);
                                                } else  {
                                                    FormatMessage ( 
                                                        FORMAT_MESSAGE_FROM_SYSTEM,
                                                        NULL, 
                                                        dwStatus,
                                                        0,
                                                        strMessage.GetBufferSetLength( MAX_PATH ),
                                                        MAX_PATH,
                                                        NULL );
    
                                                    strMessage.ReleaseBuffer();

                                                    if ( strMessage.IsEmpty() ) {
                                                        strMessage.Format ( L"0x%08lX", dwStatus );   
                                                    }
                                                }
                                
                                                strTitle.LoadString ( IDS_PROJNAME );

                                                m_ipConsole->MessageBox( 
                                                    (LPCWSTR)strMessage,
                                                    (LPCWSTR)strTitle,
                                                    MB_OK | MB_ICONWARNING,
                                                    &iResult
                                                    );
                                            }
                                        }
                                                        
                                        if ( SMCFG_NO_READ_ACCESS != dwStatus 
                                            && SMCFG_NO_INSTALL_ACCESS != dwStatus ) {
                                            pRootNode->SetExpanded( TRUE );
                                            hr = ProcessCommandLine( strServerName );
                                        }
                                    } else {    // NT4 system or earlier
                                        strComputerName = strServerName;
                                        if ( strComputerName.IsEmpty() ) {
                                            strComputerName.LoadString ( IDS_LOCAL );
                                        }
                                    
                                        strMessage.Format ( IDS_ERRMSG_PREWIN2000, strComputerName );
                                        
                                        strTitle.LoadString ( IDS_PROJNAME );

                                        m_ipConsole->MessageBox( 
                                            (LPCWSTR)strMessage,
                                            (LPCWSTR)strTitle,
                                            MB_OK | MB_ICONWARNING,
                                            &iResult
                                            );
                                    }
                                }
                            } // Insert other scope nodes
                        } // COOKIE_IS_ROOTNODE
                    } else {
                        // Unknown data object
                        strMessage.LoadString ( IDS_ERRMSG_UNKDATAOBJ );
                        m_ipConsole->MessageBox( 
                            (LPCWSTR)strMessage,
                            L"CComponentData::OnExpand",
                            MB_OK | MB_ICONERROR,
                            &iResult
                            );
                        hr = E_UNEXPECTED;
                    }   // ExtractOwnDataObject
                } // IsMyComputerNodeType
            } // ExtractObjectTypeGUID
        } else { // FALSE == arg
            hr = S_FALSE;
        }
    } // Parameters are valid

    return hr;
    
} // end OnExpand()

//---------------------------------------------------------------------------
// Remove and delete all children under the specified node.
//
HRESULT
CComponentData::OnRemoveChildren (
    LPDATAOBJECT pDataObject,      // [in] Points to data object of node whose children are to be deleted.
    LPARAM       arg,              // [in] HSCOPEITEM of node whose children are to be deleted;
    LPARAM       /* param */       // [in] Not used
    )
{
    HRESULT         hr = S_FALSE;
    HRESULT         hrLocal;
    CSmRootNode*    pRootNode = NULL;
    CSmRootNode*    pTestNode;
    POSITION        Pos;
    HSCOPEITEM      hParent = (HSCOPEITEM)arg;
    LPRESULTDATA    pResultData;
    CDataObject*    pDO = NULL;

    ASSERT ( !m_listpRootNode.IsEmpty() );

    if ( NULL == pDataObject ) {
        hr = E_POINTER;
    } else {

        // Multiple root nodes can exist if multiple smlogcfg snapins are loaded into
        // a single console.  
        
        // If the user selects "Create Window From Here", a second view is created on the same
        // (root or other) node.
        Pos = m_listpRootNode.GetHeadPosition();
        while ( NULL != Pos ) {
            pTestNode = m_listpRootNode.GetNext( Pos );
            // For standalone, the root node's parent handle is NULL.  
            if ( hParent == pTestNode->GetScopeItemHandle() 
                    || ( hParent == pTestNode->GetParentScopeItemHandle() 
                            && pTestNode->IsExtension() ) ) {
                pRootNode = pTestNode;
                break;
            }
        }

        // Optimization - If root node, remove all of the result items here.
        if ( pRootNode ) {
            pResultData = GetResultData ();
            ASSERT (pResultData);
            if ( pResultData ) {
                hrLocal = pResultData->DeleteAllRsltItems ();
            }
        } 
    
        // For standalone, we didn't create the root node view, so don't delete it.
        // For extension, the parent of the root node is passed so the root node gets deleted.
        hrLocal = m_ipConsoleNameSpace->DeleteItem ( hParent, FALSE );

        if ( pRootNode ) {
            // Remove the root node from its list and add it to the list 
            // of orphaned root nodes.
            // All queries are left open, and the connection to the log service
            // remains.
            m_listpRootNode.RemoveAt( m_listpRootNode.Find ( pRootNode ) );
            
            // Service should attempt to refresh query data when loaded 
            // into the result pane
            pRootNode->GetCounterLogService()->SetRefreshOnShow ( TRUE );
            pRootNode->GetTraceLogService()->SetRefreshOnShow ( TRUE );
            pRootNode->GetAlertService()->SetRefreshOnShow ( TRUE );

            m_listpOrphanedRootNode.AddHead ( pRootNode );
            hr = S_OK;
        } else {
            // Close all queries and the connection to the log service for this service type.
            // Orphan mechanism applies to Root node only.
            pDO = ExtractOwnDataObject( pDataObject );
            if ( NULL != pDO ) {
                if ( NULL != pDO->GetCookie() ) { 

                    if ( COOKIE_IS_COUNTERMAINNODE == pDO->GetCookieType() ) {
                        CSmCounterLogService* pService = (CSmCounterLogService*)pDO->GetCookie();
                        pService->Close();
                    } else if ( COOKIE_IS_TRACEMAINNODE == pDO->GetCookieType() ) {
                        CSmTraceLogService* pService = (CSmTraceLogService*)pDO->GetCookie();
                        pService->Close();
                    } else if ( COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() ) {
                        CSmAlertService* pService = (CSmAlertService*)pDO->GetCookie();
                        pService->Close();
                    } else {
                        ASSERT ( FALSE );
                    }
                }
            } else {
                hr = E_UNEXPECTED;
            }
        }
    }

    return hr;
}

BOOL CComponentData::IsMyComputerNodetype (GUID& refguid)
{
    return (::IsEqualGUID (refguid, g_guidSystemTools));
}

BOOL
CComponentData::IsScopeNode
(
    MMC_COOKIE mmcCookie
)
{
    BOOL bIsScopeNode = FALSE;
    CSmRootNode*    pRootNode = NULL;
    POSITION        Pos = m_listpRootNode.GetHeadPosition();

    while ( Pos != NULL) {
        pRootNode = m_listpRootNode.GetNext( Pos );
        if ( mmcCookie == (MMC_COOKIE)pRootNode ) {
            bIsScopeNode = TRUE;
            break;
        }
        if ( !bIsScopeNode ) {
            bIsScopeNode = IsLogService ( mmcCookie );
        }
    }
    return bIsScopeNode;
}

BOOL
CComponentData::IsLogService (
    MMC_COOKIE mmcCookie )
{
    CSmRootNode*    pRootNode = NULL;
    POSITION        Pos = m_listpRootNode.GetHeadPosition();
    BOOL            bReturn = FALSE;

    while ( Pos != NULL) {
        pRootNode = m_listpRootNode.GetNext( Pos );
        bReturn = pRootNode->IsLogService( mmcCookie );
        if ( bReturn )
            break;
    }

    return bReturn;
}

BOOL
CComponentData::IsAlertService ( MMC_COOKIE mmcCookie)
{
    CSmRootNode*    pRootNode = NULL;
    POSITION        Pos = m_listpRootNode.GetHeadPosition();
    BOOL            bReturn = FALSE;

    while ( Pos != NULL) {
        pRootNode = m_listpRootNode.GetNext( Pos );
        bReturn = pRootNode->IsAlertService( mmcCookie );
        if ( bReturn )
            break;
    }

    return bReturn;
}

BOOL
CComponentData::IsLogQuery ( 
    MMC_COOKIE  mmcCookie )
{
    CSmRootNode*    pRootNode = NULL;
    POSITION        Pos = m_listpRootNode.GetHeadPosition();
    BOOL            bReturn = FALSE;

    while ( Pos != NULL ) {
        pRootNode = m_listpRootNode.GetNext ( Pos );
        bReturn = pRootNode->IsLogQuery ( mmcCookie );
        if ( bReturn )
            break;
    }

    return bReturn;
}

BOOL
CComponentData::IsRunningQuery (
    PSLQUERY pQuery )
{
    return pQuery->IsRunning();
}

///////////////////////////////////////////////////////////////////////////////
/// IExtendPropertySheet

STDMETHODIMP 
CComponentData::QueryPagesFor ( LPDATAOBJECT pDataObject )
{
    HRESULT hr = S_FALSE;
    CDataObject *pDO = NULL;

    if (NULL == pDataObject) {
        ASSERT(FALSE);
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject( pDataObject );

        if ( NULL == pDO ) {
            ASSERT(FALSE);
            hr = E_UNEXPECTED;
        } else {
            if ( NULL != pDO->GetCookie() ) {
                hr = m_ipPrshtProvider->FindPropertySheet((MMC_COOKIE)pDO->GetCookie(), NULL, pDataObject);
            } else {
                hr = S_FALSE;
            }
        }
    }

    return hr;
    
} // CComponentData::QueryPagesFor()

//---------------------------------------------------------------------------
//  Implement some context menu items
//
STDMETHODIMP
CComponentData::AddMenuItems (
    LPDATAOBJECT           pDataObject,         // [in] Points to data object
    LPCONTEXTMENUCALLBACK  pCallbackUnknown,    // [in] Points to callback function
    long*                  pInsertionAllowed )  // [in,out] Insertion flags
{
    HRESULT hr = S_OK;
    BOOL    bIsLogSvc = FALSE;
    CDataObject* pDO = NULL;
    PSLSVC  pLogService;
    static CONTEXTMENUITEM ctxMenu[1];
    CString strTemp1, strTemp2, strTemp3, strTemp4;

    ResourceStateManager    rsm;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else if ( NULL == pCallbackUnknown ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject( pDataObject );
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    // Only add menu items when we are allowed to.

    if ( SUCCEEDED ( hr ) ) {
        if ( ( COOKIE_IS_COUNTERMAINNODE == pDO->GetCookieType() )
                || ( COOKIE_IS_TRACEMAINNODE == pDO->GetCookieType() )
                || ( COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() ) )
        {
            if( CCM_INSERTIONALLOWED_NEW & *pInsertionAllowed ) {
                // Add "New Query..." context menu item
                bIsLogSvc = IsLogService ( pDO->GetCookie() );
                if (bIsLogSvc) {
                    pLogService = (PSLSVC)pDO->GetCookie();

                    ZeroMemory ( &ctxMenu, sizeof ctxMenu );
                
                    MFC_TRY

                        if ( NULL != pLogService->CastToCounterLogService() ) {
                            strTemp1.LoadString( IDS_MMC_MENU_NEW_PERF_LOG );
                            strTemp2.LoadString( IDS_MMC_STATUS_NEW_PERF_LOG );
                            strTemp3.LoadString( IDS_MMC_MENU_PERF_LOG_FROM );
                            strTemp4.LoadString( IDS_MMC_STATUS_PERF_LOG_FROM );
                        } else if ( pLogService->CastToTraceLogService() ) {
                            strTemp1.LoadString( IDS_MMC_MENU_NEW_TRACE_LOG );
                            strTemp2.LoadString( IDS_MMC_STATUS_NEW_TRACE_LOG );
                            strTemp3.LoadString( IDS_MMC_MENU_TRACE_LOG_FROM );
                            strTemp4.LoadString( IDS_MMC_STATUS_TRACE_LOG_FROM );
                        } else if ( pLogService->CastToAlertService() ) {
                            strTemp1.LoadString( IDS_MMC_MENU_NEW_ALERT );
                            strTemp2.LoadString( IDS_MMC_STATUS_NEW_ALERT );
                            strTemp3.LoadString( IDS_MMC_MENU_ALERT_FROM );
                            strTemp4.LoadString( IDS_MMC_STATUS_ALERT_FROM );

                        } else {
                            ::MessageBox( NULL,
                                L"Bad Cookie",
                                L"CComponent::AddMenuItems",
                                MB_OK | MB_ICONERROR
                                );
                            hr = E_OUTOFMEMORY;
                        }
                    MFC_CATCH_HR_RETURN

                    if ( SUCCEEDED( hr ) ) {
                        // Create new...
                        ctxMenu[0].strName = const_cast<LPWSTR>((LPCWSTR)strTemp1);
                        ctxMenu[0].strStatusBarText = const_cast<LPWSTR>((LPCWSTR)strTemp2);
                        ctxMenu[0].lCommandID        = IDM_NEW_QUERY;
                        ctxMenu[0].lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
                        ctxMenu[0].fFlags            = MF_ENABLED;
                        ctxMenu[0].fSpecialFlags     = 0;

                        hr = pCallbackUnknown->AddItem( &ctxMenu[0] );

                        if ( SUCCEEDED(hr) ) {
                            // Create from...
                            ctxMenu[0].strName = const_cast<LPWSTR>((LPCWSTR)strTemp3);
                            ctxMenu[0].strStatusBarText = const_cast<LPWSTR>((LPCWSTR)strTemp4);
                            ctxMenu[0].lCommandID        = IDM_NEW_QUERY_FROM;
                            ctxMenu[0].lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
                            ctxMenu[0].fFlags            = MF_ENABLED;
                            ctxMenu[0].fSpecialFlags     = 0;

                            hr = pCallbackUnknown->AddItem( &ctxMenu[0] );
                        }
                    }
                }        
            }
        }
    }
    return hr;
} // end AddMenuItems()

//---------------------------------------------------------------------------
//  Implement the command method so we can handle notifications
//  from our Context menu extensions.  
//
STDMETHODIMP
CComponentData::Command (
    long nCommandID,           // [in] Command to handle
    LPDATAOBJECT pDataObject   // [in] Points to data object, pass through
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;

    switch( nCommandID ) {

    case IDM_NEW_QUERY:
        CreateNewLogQuery( pDataObject );
        break;

    case IDM_NEW_QUERY_FROM:
        CreateLogQueryFrom( pDataObject );
        break;

    default:
        hr = S_FALSE;
    }

    return hr;

} // end Command()

STDMETHODIMP 
CComponentData::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK pCallBack,
    LONG_PTR /* handle */,      // This handle must be saved in the property 
                                // page object to notify the parent when modified
    LPDATAOBJECT pDataObject)
{
    
    if (NULL == pCallBack || NULL == pDataObject)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }
    return S_FALSE;
    
} // CComponentData::CreatePropertyPages()


LPCWSTR
CComponentData::GetConceptsHTMLHelpFileName()
{
    return CGlobalString::m_cszConceptsHTMLHelpFileName;
}

LPCWSTR
CComponentData::GetSnapinHTMLHelpFileName()
{
    return CGlobalString::m_cszSnapinHTMLHelpFileName;
}

LPCWSTR
CComponentData::GetHTMLHelpTopic()
{
    return CGlobalString::m_cszHTMLHelpTopic;
}

const CString&
CComponentData::GetContextHelpFilePath()
{
    LPWSTR lpszBuffer;
    UINT nLen;
    if ( m_strContextHelpFilePath.IsEmpty() ) {
        MFC_TRY
            if ( m_strWindowsDirectory.IsEmpty() ) {
                lpszBuffer = m_strWindowsDirectory.GetBuffer(2*MAX_PATH);
                nLen = ::GetWindowsDirectory(lpszBuffer, 2*MAX_PATH);
                m_strWindowsDirectory.ReleaseBuffer();
            }
            if ( !m_strWindowsDirectory.IsEmpty() ) 
            {
                m_strContextHelpFilePath = m_strWindowsDirectory + CGlobalString::m_cszContextHelpFileName;
            }
        MFC_CATCH_MINIMUM;
    }    
    
    return m_strContextHelpFilePath;
}

// CComponentData::GetHelpTopic()
HRESULT
CComponentData::GetHelpTopic (
    LPOLESTR* lpCompiledHelpFile )                              
{
    HRESULT hr = E_FAIL;
    LPCWSTR lpszHelpFileName;
    CString strHelpFilePath;
    LPWSTR  lpszBuffer;
    UINT    nLen;
    UINT    nBytes;
    
    if ( NULL == lpCompiledHelpFile) {
        hr = E_POINTER;
    } else {
        *lpCompiledHelpFile = NULL;

        MFC_TRY
            lpszHelpFileName = GetSnapinHTMLHelpFileName();

            if ( NULL == lpszHelpFileName) {
                hr = E_UNEXPECTED;
            } else {
                lpszBuffer = strHelpFilePath.GetBuffer(2*MAX_PATH);
                nLen = ::GetWindowsDirectory(lpszBuffer, 2*MAX_PATH);
                if ( 0 == nLen ) {
                    hr = E_UNEXPECTED;
                } else {
                    hr = StringCchCopy (&lpszBuffer[nLen], (2*MAX_PATH) - nLen, lpszHelpFileName );
                    hr = ERROR_SUCCESS;

                    nBytes = (lstrlen(lpszBuffer)+1) * sizeof(WCHAR);
                    *lpCompiledHelpFile = (LPOLESTR)::CoTaskMemAlloc(nBytes);
                    if ( NULL == *lpCompiledHelpFile ) {
                        hr = E_OUTOFMEMORY;
                    } else {
                        memcpy(*lpCompiledHelpFile, (LPCWSTR)strHelpFilePath, nBytes);
                        hr = S_OK;
                    }
                }
                strHelpFilePath.ReleaseBuffer();
            }
        MFC_CATCH_HR
    }
    return hr;
}

LPRESULTDATA 
CComponentData::GetResultData()
{
    if ( !m_ipResultData )
    {
        if ( m_ipConsole )
        {
            HRESULT hResult = m_ipConsole->QueryInterface(IID_IResultData, (void**)&m_ipResultData);
            ASSERT (SUCCEEDED (hResult));
        }
    }
    
    return m_ipResultData;
}

HRESULT
CComponentData::ProcessCommandLine ( CString& rstrMachineName )
{
    HRESULT hr = S_OK;
    LPCWSTR pszNext = NULL;
    LPWSTR* pszArgList = NULL;
    INT     iNumArgs;
    INT     iArgIndex;
    LPWSTR  pszNextArg = NULL;
    LPWSTR  pszThisArg = NULL;
    WCHAR   szTemp[MAX_PATH + 1];
    LPWSTR  pszToken = NULL;
    WCHAR   szFileName[MAX_PATH + 1];
    CString strSettings;
    CString strWmi;

    // Process only for local node.
    if ( rstrMachineName.IsEmpty() ) {
        pszNext = GetCommandLineW();
        pszArgList = CommandLineToArgvW ( pszNext, &iNumArgs );
    }

    if ( NULL != pszArgList ) {        
        
        for ( iArgIndex = 0; iArgIndex < iNumArgs; iArgIndex++ ) {
            pszNextArg = (LPWSTR)pszArgList[iArgIndex];
            pszThisArg = pszNextArg;

            while (pszThisArg ) {
                if (0 == *pszThisArg) {
                    break;
                }

                if ( *pszThisArg++ == L'/' ) {  // argument found
                    
                    hr = StringCchCopyN (szTemp, MAX_PATH + 1, pszThisArg, lstrlen(pszThisArg)+1 );
                    hr = S_OK;
                    pszToken = _tcstok ( szTemp, L"/ =\"" );

                    MFC_TRY
                        strSettings.LoadString( IDS_CMDARG_SYSMONLOG_SETTINGS );
                        strWmi.LoadString(IDS_CMDARG_SYSMONLOG_WMI);
                    MFC_CATCH_MINIMUM;

                    if ( !strSettings.IsEmpty() && !strWmi.IsEmpty() ) {
                        if ( 0 == strSettings.CompareNoCase ( pszToken ) ) {
                    
                            // Strip the initial non-token characters for string comparison.
                            pszThisArg = _tcsspnp ( pszNextArg, L"/ =\"" );

                            if ( NULL != pszThisArg ) {
                                if ( 0 == strSettings.CompareNoCase ( pszThisArg ) ) {
                                    // Get the next argument (the file name)
                                    iArgIndex++;
                                    pszNextArg = (LPWSTR)pszArgList[iArgIndex];
                                    pszThisArg = pszNextArg;                                                
                                } else {

                                    // File was created by Windows 2000 perfmon5.exe, 
                                    // so file name is part of the arg.
                                    ZeroMemory ( szFileName, sizeof ( szFileName ) );
                                    pszThisArg += strSettings.GetLength();
                                    hr = StringCchCopyN (szFileName, MAX_PATH + 1, pszThisArg, lstrlen(pszThisArg)+1 );
                                    hr = S_OK;
                                    pszThisArg = _tcstok ( szFileName, L"=\"" );
                                }
                                hr = LoadFromFile( pszThisArg );
                            }                    
                        } else if ( 0 == strWmi.CompareNoCase ( pszToken ) ) {
                            g_dwRealTimeQuery = DATA_SOURCE_WBEM;
                        }
                    }
                }
            }
        }
    }

    if ( NULL != pszArgList ) {
        GlobalFree ( pszArgList );
    }

    return hr;
}

HRESULT 
CComponentData::LoadFromFile ( LPWSTR  pszFileName )
{
    HRESULT         hr = S_OK;
    WCHAR           szLocalName [MAX_PATH + 1];
    LPWSTR          pFileNameStart;
    HANDLE          hFindFile;
    WIN32_FIND_DATA FindFileInfo;
    INT             iNameOffset;

    szLocalName [0] = L'\0';
    hr = StringCchCopyN (szLocalName, MAX_PATH + 1, pszFileName, lstrlen(pszFileName)+1 );
    pFileNameStart = ExtractFileName (szLocalName) ;
    iNameOffset = (INT)(pFileNameStart - szLocalName);

    // convert short filename to long NTFS filename if necessary
    hFindFile = FindFirstFile ( szLocalName, &FindFileInfo) ;
    if (hFindFile && hFindFile != INVALID_HANDLE_VALUE) {
       HANDLE hOpenFile;

        // append the file name back to the path name
        hr = StringCchCopyN (
                &szLocalName[iNameOffset], 
                (MAX_PATH + 1) - lstrlen (szLocalName), 
                FindFileInfo.cFileName, 
                lstrlen(FindFileInfo.cFileName)+1 );

        FindClose (hFindFile) ;
        // Open the file
        hOpenFile = CreateFile (
                        szLocalName, 
                        GENERIC_READ,
                        0,                  // Not shared
                        NULL,               // Security attributes
                        OPEN_EXISTING,     
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

        if ( hOpenFile && hOpenFile != INVALID_HANDLE_VALUE ) {
            DWORD dwFileSize;
            DWORD dwFileSizeHigh;
            LPWSTR pszFirstData = NULL;
        
            // Read the file contents into a memory buffer.
            dwFileSize = GetFileSize ( hOpenFile, &dwFileSizeHigh );

            ASSERT ( 0 == dwFileSizeHigh );

            MFC_TRY
            pszFirstData = new WCHAR[(dwFileSize + sizeof(WCHAR))/sizeof(WCHAR)];
            MFC_CATCH_HR    

            if ( NULL != pszFirstData ) {
                BOOL bAtLeastOneSysmonObjectRead = FALSE;

                if ( FileRead ( hOpenFile, pszFirstData, dwFileSize ) ) {
                    LPWSTR pszCurrentObject = NULL;
                    LPWSTR pszNextObject = NULL;
                
                    pszCurrentObject = pszFirstData;

                    while ( SUCCEEDED ( hr ) && NULL != pszCurrentObject ) {
                    
                        CImpIPropertyBag* pPropBag = NULL;

                        // Write contents to a property bag
                        MFC_TRY
                            pPropBag = new CImpIPropertyBag;
                        MFC_CATCH_HR

                        if ( NULL != pPropBag ) {
                            DWORD dwStatus = pPropBag->LoadData( pszCurrentObject, &pszNextObject );
                            hr = HRESULT_FROM_WIN32( dwStatus );

                            if ( SUCCEEDED ( hr ) ) {
                                PSLSVC  pSvc = NULL;            
                                PSLQUERY    pQuery = NULL;
                                DWORD   dwLogType;
                                LPWSTR  pszQueryName = NULL;
                                DWORD   dwBufSize = 0;
                                CSmRootNode* pRoot = NULL;
                                CString strQueryName;
                                
                                bAtLeastOneSysmonObjectRead = TRUE;
                                
                                // Get root node
                                ASSERT ( !m_listpRootNode.IsEmpty() );
                                    
                                pRoot = m_listpRootNode.GetHead();

                                // Determine log type from property bag.  Default to counter log.
                                hr = CSmLogQuery::DwordFromPropertyBag ( 
                                        pPropBag, 
                                        NULL, 
                                        IDS_HTML_LOG_TYPE, 
                                        SLQ_COUNTER_LOG, 
                                        dwLogType);

                                // Get service pointer and log/alert name based on log type.
                                if ( SLQ_ALERT == dwLogType ) {
                                    pSvc = pRoot->GetAlertService();
                                    
                                    hr = CSmLogQuery::StringFromPropertyBag (
                                            pPropBag,
                                            NULL,
                                            IDS_HTML_ALERT_NAME,
                                            L"",
                                            &pszQueryName,
                                            &dwBufSize );

                                    if ( NULL == pszQueryName ) {
                                        hr = CSmLogQuery::StringFromPropertyBag (
                                                pPropBag,
                                                NULL,
                                                IDS_HTML_LOG_NAME,
                                                L"",
                                                &pszQueryName,
                                                &dwBufSize );
                                    }
                                } else {
                                    if ( SLQ_TRACE_LOG == dwLogType ) {
                                       pSvc = pRoot->GetTraceLogService();
                                    } else {
                                        // Default to counter log service
                                        pSvc = pRoot->GetCounterLogService();
                                    }

                                    hr = CSmLogQuery::StringFromPropertyBag (
                                            pPropBag,
                                            NULL,
                                            IDS_HTML_LOG_NAME,
                                            L"",
                                            &pszQueryName,
                                            &dwBufSize );

                                    if ( NULL == pszQueryName ) {
                                        hr = CSmLogQuery::StringFromPropertyBag (
                                                pPropBag,
                                                NULL,
                                                IDS_HTML_ALERT_NAME,
                                                L"",
                                                &pszQueryName,
                                                &dwBufSize );
                                    }
                                }

                                strQueryName = pszQueryName;
                                delete [] pszQueryName;
                                
                                while ( NULL == pQuery ) {                                    
                                    
                                    if ( !strQueryName.IsEmpty() ) {
                                        pQuery = pSvc->CreateQuery ( strQueryName );
                    
                                        if ( NULL != pQuery ) {
                                            BOOL bRegistryUpdated;
                                            pQuery->LoadFromPropertyBag ( pPropBag, NULL );
                                            dwStatus = pQuery->UpdateService ( bRegistryUpdated );
                                            break;
                                        } else {
                                            dwStatus = GetLastError();
                                        }

                                        if ( ERROR_SUCCESS != dwStatus ) {
                                            INT iResult;
                                            CString strMessage;
                                            CString csTitle;
                                            BOOL bBreakImmediately = TRUE;

                                            if ( SMCFG_NO_MODIFY_ACCESS == dwStatus ) {
                                                CString strMachineName;

                                                strMachineName = pSvc->GetMachineDisplayName ();

                                                FormatSmLogCfgMessage (
                                                    strMessage,
                                                    m_hModule,
                                                    SMCFG_NO_MODIFY_ACCESS,
                                                    (LPCWSTR)strMachineName);

                                            } else if ( SMCFG_DUP_QUERY_NAME == dwStatus ) {
                                                FormatSmLogCfgMessage (
                                                    strMessage,
                                                    m_hModule,
                                                    SMCFG_DUP_QUERY_NAME,
                                                    (LPCWSTR)strQueryName);
                                                bBreakImmediately = FALSE;
                                            } else {
                                                CString strSysMessage;

                                                FormatSmLogCfgMessage (
                                                    strMessage,
                                                    m_hModule,
                                                    SMCFG_SYSTEM_MESSAGE,
                                                    (LPCWSTR)strQueryName);

                                                FormatMessage (
                                                    FORMAT_MESSAGE_FROM_SYSTEM,
                                                    NULL,
                                                    dwStatus,
                                                    0,
                                                    strSysMessage.GetBufferSetLength( MAX_PATH ),
                                                    MAX_PATH,
                                                    NULL );

                                                strSysMessage.ReleaseBuffer();

                                                if ( strSysMessage.IsEmpty() ) {
                                                    strSysMessage.Format ( L"0x%08lX", dwStatus );   
                                                }

                                                strMessage += strSysMessage;
                                            }

                                            csTitle.LoadString ( IDS_PROJNAME );

                                            hr = m_ipConsole->MessageBox(
                                                    (LPCWSTR)strMessage,
                                                    (LPCWSTR)csTitle,
                                                    MB_OK | MB_ICONERROR,
                                                    &iResult
                                                    );

                                            if ( bBreakImmediately ) {
                                                break;
                                            }
                                        }
                                    }

                                    if ( NULL == pQuery ) { 
                                        CNewQueryDlg    cNewDlg(NULL, ((SLQ_ALERT == dwLogType) ? FALSE : TRUE));
                                        AFX_MANAGE_STATE(AfxGetStaticModuleState());
                                        
                                        cNewDlg.SetContextHelpFilePath( GetContextHelpFilePath() );
                                        cNewDlg.m_strName = strQueryName;
                                        if ( IDOK == cNewDlg.DoModal() ) {
                                            strQueryName = cNewDlg.m_strName;
                                        } else {
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        pszCurrentObject = pszNextObject;
                        delete pPropBag;
                    } // end while
                }        
                delete [] pszFirstData;
                // Message to the user if no queries Read.
                if ( !bAtLeastOneSysmonObjectRead ) {
                    CString strMessage;
                    CString strTitle;
                    INT iResult;

                    FormatSmLogCfgMessage ( 
                        strMessage,
                        m_hModule, 
                        SMCFG_NO_HTML_SYSMON_OBJECT );

                    strTitle.LoadString ( IDS_PROJNAME );

                    m_ipConsole->MessageBox ( 
                        strMessage, 
                        strTitle, 
                        MB_OK  | MB_ICONERROR,
                        &iResult );
                }
            } else {
                hr = E_OUTOFMEMORY;
            }

            CloseHandle ( hOpenFile );
        }
    }
    return hr;
}

HRESULT 
CComponentData::InitPropertySheet (
    CSmLogQuery* pQuery,
    MMC_COOKIE mmcCookie,
    LONG_PTR handle,
    CPropertySheet* pcpsMain ) 
{ 
    CCountersProperty   *pPage1 = NULL;
    CFilesProperty      *pPage2 = NULL;
    CScheduleProperty   *pPage3 = NULL;
    CTraceProperty      *pPage4 = NULL;
    CProvidersProperty  *pPage5 = NULL;
    CAlertActionProp    *pPage6 = NULL;
    CAlertGenProp       *pPage7 = NULL;
    HRESULT hr = NOERROR;

    ASSERT ( NULL != pQuery );

    pcpsMain->SetTitle (pQuery->GetLogName());
    //
    // Load all property pages
    //
    pcpsMain->m_psh.dwFlags |= PSP_PREMATURE;

    MFC_TRY
        if ( SLQ_ALERT == pQuery->GetLogType() ) {
            pPage7 = new CAlertGenProp (mmcCookie, handle);
            pPage6 = new CAlertActionProp (mmcCookie, handle);
            pPage3 = new CScheduleProperty (mmcCookie, handle, NULL);
            if ( NULL != pPage7 ) {
                pPage7->SetContextHelpFilePath( GetContextHelpFilePath() );
                pPage7->m_psp.dwFlags |= PSP_PREMATURE;
                pcpsMain->AddPage (pPage7);
            }
            if ( NULL != pPage6 ) {
                pPage6->SetContextHelpFilePath( GetContextHelpFilePath() );
                pPage6->m_psp.dwFlags |= PSP_PREMATURE;
                pcpsMain->AddPage (pPage6);
            }
            if ( NULL != pPage3 ) {
                pPage3->SetContextHelpFilePath( GetContextHelpFilePath() );
                pPage3->m_psp.dwFlags |= PSP_PREMATURE;
                pcpsMain->AddPage (pPage3);
            }
        } else {
            if ( SLQ_TRACE_LOG == pQuery->GetLogType() ) {
                CWaitCursor     WaitCursor;

                // Connect to the server before creating the dialog 
                // so that the wait cursor can be used consistently.                    
                // Sync the providers here so that the WMI calls are consistently
                // from a single thread.
                ASSERT ( NULL != pQuery->CastToTraceLogQuery() );
                hr = (pQuery->CastToTraceLogQuery())->SyncGenProviders();
                
                if ( SUCCEEDED ( hr ) ) {
                    pPage5 = new CProvidersProperty(mmcCookie, handle);
                    if ( NULL != pPage5 )
                        pPage5->SetContextHelpFilePath( GetContextHelpFilePath() );
                        pPage5->m_psp.dwFlags |= PSP_PREMATURE;
                        pcpsMain->AddPage (pPage5);
                } else {
                    CString strMachineName;
                    CString strLogName;

                    pQuery->GetMachineDisplayName( strMachineName );
                    strLogName = pQuery->GetLogName();
                    
                    HandleTraceConnectError ( 
                        hr, 
                        strLogName,
                        strMachineName );
                }
            } else {
                pPage1 = new CCountersProperty ( mmcCookie, handle );
                if ( NULL != pPage1 ) {
                    pPage1->SetContextHelpFilePath( GetContextHelpFilePath() );
                    pPage1->m_psp.dwFlags |= PSP_PREMATURE;
                    pcpsMain->AddPage (pPage1);
                }
            }
            if ( SUCCEEDED ( hr ) ) {
                pPage2 = new CFilesProperty(mmcCookie, handle);
                if ( NULL != pPage2 ) {
                    pPage2->SetContextHelpFilePath( GetContextHelpFilePath() );
                    pPage2->m_psp.dwFlags |= PSP_PREMATURE;
                    pcpsMain->AddPage (pPage2);
                }

                pPage3 = new CScheduleProperty(mmcCookie, handle, NULL);
                if ( NULL != pPage3 ) {
                    pPage3->SetContextHelpFilePath( GetContextHelpFilePath() );
                    pPage3->m_psp.dwFlags |= PSP_PREMATURE;
                    pcpsMain->AddPage (pPage3);
                }
                if ( SLQ_TRACE_LOG == pQuery->GetLogType() ) {
                    pPage4 = new CTraceProperty(mmcCookie, handle);
                    if ( NULL != pPage4 ) {
                        pPage4->SetContextHelpFilePath( GetContextHelpFilePath() );
                        pPage4->m_psp.dwFlags |= PSP_PREMATURE;
                        pcpsMain->AddPage (pPage4);
                    }
                }
            }
        }
    MFC_CATCH_HR

    if ( SUCCEEDED ( hr ) ) {
        pQuery->SetInitialPropertySheet ( pcpsMain );
    }

    return hr;
} // End InitPropertySheet

void 
CComponentData::HandleTraceConnectError ( 
    HRESULT& rhr, 
    CString& rstrLogName,
    CString& rstrMachineName )
{
    ASSERT ( FAILED ( rhr ) );
    
    if ( FAILED ( rhr ) ) {
        
        CString strMessage;
        CString strSysMessage;
        INT     iResult;

        FormatSmLogCfgMessage ( 
            strMessage,
            m_hModule, 
            SMCFG_UNABLE_OPEN_TRACESVC_DLG, 
            rstrMachineName,
            rstrLogName );

        FormatMessage ( 
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL, 
            rhr,
            0,
            strSysMessage.GetBufferSetLength( MAX_PATH ),
            MAX_PATH,
            NULL );

        strSysMessage.ReleaseBuffer();

        if ( strSysMessage.IsEmpty() ) {
            strSysMessage.Format ( L"0x%08lX", rhr );
        }

        strMessage += strSysMessage;

        m_ipConsole->MessageBox( 
            strMessage,
            rstrLogName,
            MB_OK | MB_ICONERROR,
            &iResult);
    }
    return;

}// end HandleTraceConnectError()

HRESULT
CComponentData::NewTypedQuery (
    CSmLogService* pSvc,
    IPropertyBag* pPropBag,
    LPDATAOBJECT pDataObject )  // [in] Points to the data object
{
    HRESULT  hr = S_OK;
    LPWSTR  szQueryName = NULL;
    CString strPreviousQueryName;
    DWORD   dwBufSize = 0;
    ResourceStateManager    rsm;
    CNewQueryDlg    cNewDlg(NULL, (((CSmNode*)pSvc)->CastToAlertService() ? FALSE : TRUE));
    CThemeContextActivator activator;

    ASSERT ( NULL != pSvc );

    if ( NULL != pPropBag && NULL != pSvc ) {
        if ( NULL != ((CSmNode*)pSvc)->CastToAlertService() ) {
            hr = CSmLogQuery::StringFromPropertyBag (
                    pPropBag,
                    NULL,
                    IDS_HTML_ALERT_NAME,
                    L"",
                    &szQueryName,
                    &dwBufSize );

            if ( NULL == szQueryName ) {
                hr = CSmLogQuery::StringFromPropertyBag (
                        pPropBag,
                        NULL,
                        IDS_HTML_LOG_NAME,
                        L"",
                        &szQueryName,
                        &dwBufSize );
            }
        } else {
            hr = CSmLogQuery::StringFromPropertyBag (
                    pPropBag,
                    NULL,
                    IDS_HTML_LOG_NAME,
                    L"",
                    &szQueryName,
                    &dwBufSize );

            if ( NULL == szQueryName ) {
                hr = CSmLogQuery::StringFromPropertyBag (
                        pPropBag,
                        NULL,
                        IDS_HTML_ALERT_NAME,
                        L"",
                        &szQueryName,
                        &dwBufSize );
            }
        }
    }
    cNewDlg.SetContextHelpFilePath( GetContextHelpFilePath() );

    if ( NULL != szQueryName ) {
        strPreviousQueryName = szQueryName;
        cNewDlg.m_strName = szQueryName;
    } else {
        strPreviousQueryName.Empty();
        cNewDlg.m_strName.Empty();
    }

    // Loop until the user hits Cancel or CreateQuery fails.
       
    while ( IDOK == cNewDlg.DoModal() ) {
        PSLQUERY pQuery;

        pQuery = pSvc->CreateQuery ( cNewDlg.m_strName );

        if ( NULL != pQuery ) {
            MMC_COOKIE  mmcQueryCookie = (MMC_COOKIE)pQuery;
            LONG_PTR    handle = NULL;
            INT         iPageIndex;
            CPropertySheet*  pcpsMain;
            CSmPropertyPage* pActivePage = NULL;
            CString     strFolderName;
            CString     strBaseFileName;
            CString     strSqlName;
            CString     strDsn;
            CString     strSqlLogSetName;
            INT         iPageCount;
            INT         iTotalLength;
            INT         iRightLength;
            BOOL        bDirty = FALSE;

            // If property bag provided, override defaults with the provided properties.
            if ( NULL != pPropBag ) {
                hr = pQuery->LoadFromPropertyBag ( pPropBag, NULL );   
                if ( FAILED(hr) ) {
                    hr = S_OK;
                }
                pQuery->GetFileNameParts ( strFolderName, strBaseFileName );
                //
                // Compare base file name with the old query name from the settings file.
                // If they match, change the file name to match the new query name.
                //
                if ( ! strBaseFileName.CompareNoCase ( strPreviousQueryName ) ) {
                    pQuery->SetFileNameParts ( strFolderName, cNewDlg.m_strName );
                    bDirty = TRUE;
                }
                
                // Format string:  "SQL:%s!%s"    
                MFC_TRY
                    strSqlName = pQuery->GetSqlName();
                    
                    iTotalLength = strSqlName.GetLength();
        
                    iRightLength = iTotalLength - strSqlName.Find(L"!");

                    strDsn = strSqlName.Mid ( 4, iTotalLength - iRightLength - 4 );
                    strSqlLogSetName = strSqlName.Right( iTotalLength - strSqlName.Find(L"!") - 1 );

                    if ( ! strSqlLogSetName.CompareNoCase ( strPreviousQueryName ) ) {
                        strSqlName.Format ( L"SQL:%s!%s",strDsn, cNewDlg.m_strName );

                        pQuery->SetSqlName ( strSqlName );
                        bDirty = TRUE;
                    }
                MFC_CATCH_HR;

                if ( bDirty ) {
                    pQuery->SyncPropPageSharedData(); 
                }
            }

            if ( FAILED(hr) ) {
                hr = S_OK;
            }

            // now show property pages to modify the new query

            MFC_TRY
                pcpsMain = new CPropertySheet;

                hr = InitPropertySheet ( pQuery, mmcQueryCookie, handle, pcpsMain );

                iPageCount = pcpsMain->GetPageCount();
            
                if ( SUCCEEDED(hr) ) {
                
                    pActivePage = (CSmPropertyPage*)pcpsMain->GetActivePage();
                    if (pActivePage) {
                        pActivePage->SetModifiedPage(TRUE);
                    }
                
                    pcpsMain->DoModal();
                }

                if ( pQuery->IsFirstModification() ) {
                    pQuery->SetInitialPropertySheet ( NULL );
                    m_ipConsole->UpdateAllViews ( pDataObject, 0, eSmHintNewQuery );
                } else {
                    // Delete query if newly created and OnApply was never called.
                    pSvc->DeleteQuery ( pQuery );
                }

                for ( iPageIndex = iPageCount - 1; iPageIndex >= 0; iPageIndex-- ) {
                    delete pcpsMain->GetPage( iPageIndex );
                }
                delete pcpsMain;
                pcpsMain = NULL;

                break;
            MFC_CATCH_HR
        } else {
            INT iResult;
            CString strMessage;
            CString csTitle;
            DWORD dwStatus;
            BOOL bBreakImmediately = TRUE;

            dwStatus = GetLastError();

            if ( SMCFG_NO_MODIFY_ACCESS == dwStatus ) {
                CString strMachineName;

                strMachineName = pSvc->GetMachineDisplayName ();

                FormatSmLogCfgMessage (
                    strMessage,
                    m_hModule,
                    SMCFG_NO_MODIFY_ACCESS,
                    (LPCWSTR)strMachineName);

            } else if ( SMCFG_DUP_QUERY_NAME == dwStatus ) {
                FormatSmLogCfgMessage (
                    strMessage,
                    m_hModule,
                    SMCFG_DUP_QUERY_NAME,
                    (LPCWSTR)cNewDlg.m_strName);
                bBreakImmediately = FALSE;
            } else {

                FormatMessage (
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    dwStatus,
                    0,
                    strMessage.GetBufferSetLength( MAX_PATH ),
                    MAX_PATH,
                    NULL );

                strMessage.ReleaseBuffer();

                if ( strMessage.IsEmpty() ) {
                    strMessage.Format ( L"0x%08lX", dwStatus );   
                }
            }

            csTitle.LoadString ( IDS_PROJNAME );

            hr = m_ipConsole->MessageBox(
                    (LPCWSTR)strMessage,
                    (LPCWSTR)csTitle,
                    MB_OK | MB_ICONERROR,
                    &iResult
                    );

            if ( bBreakImmediately ) {
                break;
            }
        }
    }

    delete [] szQueryName;
    return hr;
}

HRESULT
CComponentData::CreateNewLogQuery (
    LPDATAOBJECT pDataObject,  // [in] Points to the data object
    IPropertyBag* pPropBag )
{
    HRESULT         hr = S_OK;
    CDataObject*    pDO = NULL;
    MMC_COOKIE      mmcSvcCookie;
    BOOL            bIsLogSvc;
    PSLSVC          pLogService;
    ResourceStateManager    rsm;

    ASSERT( NULL != GetResultData() );

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject( pDataObject );
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }
    
    if ( SUCCEEDED ( hr ) ) {
        // If this is the root node, don't need to do anything
        if( COOKIE_IS_ROOTNODE == pDO->GetCookieType() ) {
            hr = S_FALSE;
        } else {

            // Just make sure we are where we think we are
            ASSERT ( COOKIE_IS_COUNTERMAINNODE == pDO->GetCookieType()
                    || COOKIE_IS_TRACEMAINNODE == pDO->GetCookieType()
                    || COOKIE_IS_ALERTMAINNODE == pDO->GetCookieType() );

            mmcSvcCookie = (MMC_COOKIE)pDO->GetCookie();
            bIsLogSvc = IsLogService (mmcSvcCookie);

            if (bIsLogSvc) {        
                pLogService = (PSLSVC)mmcSvcCookie;
                hr = NewTypedQuery ( pLogService, pPropBag, pDataObject );
            }

            hr = S_OK;
        }
    }

    return hr;

} // end CreateNewLogQuery()

HRESULT
CComponentData::CreateLogQueryFrom (
    LPDATAOBJECT pDataObject )  // [in] Points to the data object
{
    HRESULT         hr = S_OK;
    INT_PTR         iPtrResult = IDCANCEL;
    INT             iResult = IDCANCEL;
    CDataObject*    pDO = NULL;
    HWND            hwndMain;
    CString         strFileExtension;
    CString         strFileFilter;
    HANDLE          hOpenFile;
    WCHAR           szInitialDir[MAX_PATH + 1];
    DWORD           dwFileSize;
    DWORD           dwFileSizeHigh;
    LPWSTR          pszData = NULL;
    CString         strMessage;
    CString         strTitle;
    CImpIPropertyBag* pPropBag = NULL;
    DWORD           dwStatus;
    DWORD           dwLogType;
    CLogWarnd       LogWarnd;
    DWORD           dwCookieType;
    ResourceStateManager    rsm;

    if ( NULL == pDataObject ) {
        ASSERT ( FALSE );
        hr = E_POINTER;
    } else {
        pDO = ExtractOwnDataObject( pDataObject );
        if ( NULL == pDO ) {
            ASSERT ( FALSE );
            hr = E_UNEXPECTED;
        }
    }

    if ( SUCCEEDED ( hr ) ) {

        if ( IsLogService ( pDO->GetCookie() ) ) {

            // Find file to create from.
            MFC_TRY
                strFileExtension.LoadString ( IDS_HTML_EXTENSION );
                strFileFilter.LoadString ( IDS_HTML_FILE );
            MFC_CATCH_HR

            strFileFilter.Replace ( L'|', L'\0' );

            hr = m_ipConsole->GetMainWindow( &hwndMain );

            if ( SUCCEEDED(hr) ) {

                OPENFILENAME ofn;
                BOOL bResult;
                WCHAR szFileName[MAX_PATH + 1];
                
                ZeroMemory( szFileName, MAX_PATH*sizeof(WCHAR) );
                ZeroMemory( &ofn, sizeof( OPENFILENAME ) );

                ofn.lStructSize = sizeof(OPENFILENAME);
                ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
                ofn.lpstrFile = szFileName;
                ofn.nMaxFile = MAX_PATH;
                ofn.lpstrDefExt = (LPCWSTR)strFileExtension;
                ofn.lpstrFilter = strFileFilter;
                ofn.hwndOwner = hwndMain;
                ofn.hInstance = m_hModule;
                if ( SUCCEEDED ( SHGetFolderPathW ( NULL, CSIDL_PERSONAL, NULL, 0, szInitialDir ) ) ) {
                    ofn.lpstrInitialDir = szInitialDir;
                }

                bResult = GetOpenFileName( &ofn );

                if ( bResult ) {

                    // Open the file to find the query name.
                    hOpenFile =  CreateFile (
                                ofn.lpstrFile,
                                GENERIC_READ,
                                0,              // Not shared
                                NULL,           // Security attributes
                                OPEN_EXISTING,  //
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );

                    if ( hOpenFile && INVALID_HANDLE_VALUE != hOpenFile ) {

                        // Create a property bag and load it.  Use the existing query
                        // name as the default to ask the user for a new query name.
                        // New query name is required if the current name exists in the registry.

                        // Read the file contents into a memory buffer.
                        dwFileSize = GetFileSize ( hOpenFile, &dwFileSizeHigh );

                        // kathsetodo:  Handle larger files?
                        ASSERT ( 0 == dwFileSizeHigh );

                        if ( 0 == dwFileSizeHigh ) {

                            // 1 for NULL
                            MFC_TRY
                                pszData = new WCHAR[(dwFileSize/sizeof(WCHAR)) + 1 ];
                            MFC_CATCH_HR    

                            if ( NULL != pszData ) {
                                if ( FileRead ( hOpenFile, pszData, dwFileSize ) ) {

                                    // Read contents from a property bag
                                    MFC_TRY
                                        pPropBag = new CImpIPropertyBag;
                                    MFC_CATCH_HR

                                    if ( NULL != pPropBag ) {
                                        MFC_TRY
                                            strTitle.LoadString ( IDS_PROJNAME );
                                        MFC_CATCH_HR
                                    
                                        dwStatus = pPropBag->LoadData( pszData );

                                        hr = HRESULT_FROM_WIN32( dwStatus );
                                        if ( SUCCEEDED ( hr ) ) {
                    
                                            //get the log type from the  pPropBag and compare it with service(cookie) type
                                    
                                            // Determine log type from property bag. Default to -1  SMONCTRL_LOG
                                  
                                            hr = CSmLogQuery::DwordFromPropertyBag ( 
                                                pPropBag, 
                                                NULL, 
                                                IDS_HTML_LOG_TYPE, 
                                                SMONCTRL_LOG, //indicates tha it's a smonctrl log
                                                dwLogType);
                                    
                                            if (SUCCEEDED (hr) ){
                                                dwCookieType = (DWORD)pDO->GetCookieType();
                                                switch(dwCookieType){
                                            
                                                    case COOKIE_IS_COUNTERMAINNODE:
                                               
                                                        if (dwLogType != SLQ_COUNTER_LOG ){
                                                          //Error
                                                          LogWarnd.m_ErrorMsg = ID_ERROR_COUNTER_LOG;
                                                          hr = S_FALSE;
                                                        }
                                                        break;
                                            
                                                    case COOKIE_IS_TRACEMAINNODE:
                                               
                                                        if (dwLogType != SLQ_TRACE_LOG ){
                                                         //Error
                                                            LogWarnd.m_ErrorMsg = ID_ERROR_TRACE_LOG;
                                                            hr = S_FALSE;
                                                        }
                                                        break;
                                            
                                                    case COOKIE_IS_ALERTMAINNODE:

                                                       if (dwLogType != SLQ_ALERT){
                                                         //Error
                                                         LogWarnd.m_ErrorMsg = ID_ERROR_ALERT_LOG;
                                                         hr = S_FALSE;
                                                       }
                                                       break;

                                            
                                                    case SMONCTRL_LOG:
                                                         //Error
                                                         LogWarnd.m_ErrorMsg = ID_ERROR_SMONCTRL_LOG;
                                                         hr = S_FALSE;

                                                       break;
                                                }
                                                if (hr == S_FALSE){
                                                    if(dwLogType == SLQ_TRACE_LOG || LogWarnd.m_ErrorMsg == ID_ERROR_TRACE_LOG ){
                                                        MFC_TRY
                                                            strMessage.LoadString(IDS_ERRMSG_TRACE_LOG);
                                                        MFC_CATCH_HR
                                                        m_ipConsole->MessageBox ( 
                                                                     strMessage, 
                                                                     strTitle, 
                                                                     MB_OK  | MB_ICONERROR,
                                                                     &iResult );
                                            
                                                    } else {
                                                        LogWarnd.m_dwLogType = dwLogType;
                                                        MFC_TRY
                                                            LogWarnd.m_strContextHelpFile = GetContextHelpFilePath();
                                                            // TODO:  Handle error
                                                        MFC_CATCH_MINIMUM
                                                        if(!LogTypeCheckNoMore(&LogWarnd)){
                                                            LogWarnd.SetTitleString ( strTitle );
                                                            LogWarnd.DoModal();
                                                        }
                                                        CreateNewLogQuery ( pDataObject, pPropBag );
                                                    }
                                                }
                                            }
                                    
                                            if ( S_OK == hr ) {
                                                  hr = CreateNewLogQuery ( pDataObject, pPropBag );
                                            }
                                        } else {
                                            FormatSmLogCfgMessage ( 
                                                strMessage,
                                                m_hModule, 
                                                SMCFG_NO_HTML_SYSMON_OBJECT );

                                            m_ipConsole->MessageBox ( 
                                                strMessage, 
                                                strTitle, 
                                                MB_OK  | MB_ICONERROR,
                                                &iResult );
                                        }
                                    }
                                }
                                delete [] pszData;
                            }
                        } else {
                            // kathsetodo:  error message re: file too large.
                        }

                        CloseHandle ( hOpenFile );
                    }
                }
            }
        }
    }
    return hr;
} // End CreateLogQueryFrom

BOOL
CComponentData::LogTypeCheckNoMore (
    CLogWarnd* LogWarnd )
{
    
    BOOL bretVal = FALSE;
    long nErr;
    HKEY hKey;
    DWORD dwWarnFlag;
    DWORD dwDataType = 0;
    DWORD dwDataSize = 0;
    DWORD dwDisposition;
    WCHAR RegValName[MAX_PATH];

    switch (LogWarnd->m_dwLogType){
        case SLQ_COUNTER_LOG:
            StringCchPrintf ( RegValName, MAX_PATH,L"NoWarnCounterLog");
            break;
          
        case SLQ_ALERT:
            StringCchPrintf ( RegValName, MAX_PATH,L"NoWarnAlertLog");
            break;
    }
    
    // check registry setting to see if we need to pop up warning dialog
    nErr = RegOpenKey( 
                HKEY_CURRENT_USER,
                L"Software\\Microsoft\\PerformanceLogsAndAlerts",
                &hKey );

    if( nErr != ERROR_SUCCESS ) {
        nErr = RegCreateKeyEx( 
                    HKEY_CURRENT_USER,
                    L"Software\\Microsoft\\PerformanceLogsAndAlerts",
                    0,
                    L"REG_DWORD",
                    REG_OPTION_NON_VOLATILE,
                    KEY_READ | KEY_WRITE,
                    NULL,
                    &hKey,
                    &dwDisposition );
    }

    dwWarnFlag = 0;
    if( nErr == ERROR_SUCCESS ) {

        dwDataSize = sizeof(DWORD);
        nErr = RegQueryValueExW(
                    hKey,
                    RegValName,
                    NULL,
                    &dwDataType,
                    (LPBYTE) &dwWarnFlag,
                    (LPDWORD) &dwDataSize
                    );
        if (ERROR_SUCCESS == nErr ){       
           LogWarnd->m_hKey = hKey;
        }

        if ( (dwDataType != REG_DWORD) || (dwDataSize != sizeof(DWORD)))
            dwWarnFlag = 0;

        if (dwWarnFlag) 
            bretVal = TRUE;
        
        nErr = RegCloseKey( hKey );
        
        if( ERROR_SUCCESS != nErr ){
//          DisplayError( GetLastError(), L"Close PerfLog user Key Failed" );
            bretVal =  FALSE;
        }
    }

    return bretVal;
}

BOOL    
CComponentData::IsPreWindows2000Server ( const CString& rstrMachineName )
{
    BOOL    bIsPreWindows2000Server = FALSE;
    PLA_VERSION structVersion;

    if ( ERROR_SUCCESS == PdhiPlaGetVersion ( rstrMachineName, &structVersion ) ) 
    {
        if ( 5 > structVersion.dwMajorVersion
            && 2195 > structVersion.dwBuild ) 
        {
            bIsPreWindows2000Server = TRUE;
        }
    }
    return bIsPreWindows2000Server;
}

CSmRootNode* 
CComponentData::GetOrphanedRootNode ( const CString& rstrMachineName )
{
    CSmRootNode*    pRootNode = NULL;
    CSmRootNode*    pFoundNode = NULL;
    POSITION        Pos1, Pos2; 

    // Remove the selected node from the list and return it, if it exists.
    for ( 
        Pos1 = m_listpOrphanedRootNode.GetHeadPosition();
        NULL != (Pos2 = Pos1); )
    {
        pRootNode = m_listpOrphanedRootNode.GetNext( Pos1 );

        if ( !pRootNode->GetMachineName().CompareNoCase ( rstrMachineName ) ) {
            pRootNode = m_listpOrphanedRootNode.GetAt( Pos2 );
            pFoundNode = pRootNode;
            m_listpOrphanedRootNode.RemoveAt ( Pos2 );
            break;
        }
    }
    return pFoundNode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\dialogs.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    fileprop.h

Abstract:

    Header file for the files property page.

--*/

#ifndef _DIALOGS_H_08222000_
#define _DIALOGS_H_08222000_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define IDC_PWD_FIRST_HELP_CTRL_ID     2201

#define IDD_PASSWORD_DLG               2200
#define IDC_PASSWORD1                  2201
#define IDC_PASSWORD2                  2202
#define IDC_USERNAME                   2203

/////////////////////////////////////////////////////////////////////////////
// CPasswordDlg dialog

class CPasswordDlg : public CDialog
{
// Construction
public:
	CPasswordDlg(CWnd* pParent = NULL);   // standard constructor
    virtual ~CPasswordDlg();

    DWORD SetContextHelpFilePath(const CString& rstrPath);

    // Dialog Data
	//{{AFX_DATA(CPasswordDlg)
	enum { IDD = IDD_PASSWORD_DLG };
    CString m_strUserName;
	CString	m_strPassword1;
	CString	m_strPassword2;
	//}}AFX_DATA
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPasswordDlg)
	protected:
    virtual BOOL OnInitDialog();
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPasswordDlg)
	virtual void OnOK();
    afx_msg BOOL OnHelpInfo(HELPINFO *);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
        CString     m_strHelpFilePath;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _DIALOGS_H_08222000_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\ctrsprop.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    ctrsprop.h

Abstract:

    Header file for the counters general property page

--*/

#ifndef _CTRSPROP_H_
#define _CTRSPROP_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "smproppg.h"   // Base class
#include "smcfghlp.h"
// Dialog controls
#define IDD_COUNTERS_PROP               800

#define IDC_CTRS_FILENAME_CAPTION       801
#define IDC_CTRS_LOG_SCHED_TEXT         802
#define IDC_CTRS_SAMPLE_CAPTION         803
#define IDC_CTRS_SAMPLE_INTERVAL_CAPTION 804
#define IDC_CTRS_SAMPLE_UNITS_CAPTION   805
#define IDC_CTRS_FIRST_HELP_CTRL_ID     806     // First control with Help text.
#define IDC_CTRS_COUNTER_LIST           806
#define IDC_CTRS_ADD_OBJ_BTN	        807
#define IDC_CTRS_ADD_BTN                808
#define IDC_CTRS_REMOVE_BTN             809
#define IDC_CTRS_FILENAME_DISPLAY       810
#define IDC_CTRS_SAMPLE_SPIN            811
#define IDC_CTRS_SAMPLE_UNITS_COMBO     812
#define IDC_CTRS_SAMPLE_EDIT            813

#define PDLCNFIG_LISTBOX_STARS_YES  1

class CSmCounterLogQuery;

/////////////////////////////////////////////////////////////////////////////
// CCountersProperty dialog

class CCountersProperty : public CSmPropertyPage
{
    DECLARE_DYNCREATE(CCountersProperty)

// Construction
public:
            CCountersProperty();
            CCountersProperty(MMC_COOKIE mmcCookie, LONG_PTR hConsole);
    virtual ~CCountersProperty();

public:

// Dialog Data
    //{{AFX_DATA(CCountersProperty)
    enum { IDD = IDD_COUNTERS_PROP };
    int     m_nSampleUnits;
    CString m_strFileNameDisplay;
    CString m_strStartDisplay;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CCountersProperty)
public:
protected:
    virtual void OnFinalRelease();
    virtual BOOL OnInitDialog();
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL

public:

    // All of these members are Public to be accessed by the callback routine.
    LPWSTR          m_szCounterListBuffer;
    DWORD           m_dwCounterListBufferSize;
    long            m_lCounterListHasStars;
    DWORD           m_dwMaxHorizListExtent;
    
    
    PDH_BROWSE_DLG_CONFIG   m_dlgConfig;

    CSmCounterLogQuery      *m_pCtrLogQuery;    
// Implementation
protected:

    virtual INT GetFirstHelpCtrlId ( void ) 
    { 
        return IDC_CTRS_FIRST_HELP_CTRL_ID; 
    };  // Subclass must override.

    virtual BOOL    IsValidLocalData ();
    
    // Generated message map functions
    //{{AFX_MSG(CCountersProperty)
    afx_msg void OnCtrsAddBtn();
    afx_msg void OnCtrsAddObjBtn();
    afx_msg void OnCtrsRemoveBtn();
    afx_msg void OnPwdBtn();
    afx_msg void OnDblclkCtrsCounterList();
    afx_msg void OnKillfocusSchedSampleEdit();
    afx_msg void OnDeltaposSchedSampleSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSelendokSampleUnitsCombo();
    afx_msg void OnChangeUser();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CCountersProperty)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()

private:


    enum eValueRange {
        eMinSampleInterval = 1,
        eMaxSampleInterval = 999999,
        eHashTableSize = 257
    };

    typedef struct _HASH_ENTRY {
        struct _HASH_ENTRY       * pNext;
        PPDH_COUNTER_PATH_ELEMENTS pCounter;
    } HASH_ENTRY, *PHASH_ENTRY;

    PHASH_ENTRY  m_HashTable[257];

    ULONG HashCounter ( LPWSTR szCounterName );

    void ImplementAdd ( BOOL bShowObjects );
    void UpdateFileNameString ( void );
    void UpdateLogStartString ( void );
    void SetButtonState( void ); 

public:

    DWORD CheckDuplicate( PPDH_COUNTER_PATH_ELEMENTS pCounter);
    BOOL  RemoveCounterFromHashTable( LPWSTR szCounterName, PPDH_COUNTER_PATH_ELEMENTS pCounterPath);
    void  ClearCountersHashTable ( void );
    PPDH_COUNTER_PATH_ELEMENTS InsertCounterToHashTable ( LPWSTR szCounterName );

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif //  _CTRSPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\enabldlg.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    enabldlg.cpp

Abstract:

    Implementation of the provider status dialog box.

--*/

#include "stdafx.h"
#include "provprop.h"
#include "smcfgmsg.h"
#include "smlogcfg.h"
#include "enabldlg.h"
#include "smcfghlp.h"
#include "smtprov.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static ULONG
s_aulHelpIds[] =
{
	IDC_PACT_CHECK_SHOW_ENABLED,	IDH_PACT_CHECK_SHOW_ENABLED,
	IDC_PACT_PROVIDERS_LIST,		IDH_PACT_PROVIDERS_LIST,
    0,0
};

/////////////////////////////////////////////////////////////////////////////
// CActiveProviderDlg dialog


CActiveProviderDlg::CActiveProviderDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CActiveProviderDlg::IDD, pParent),
      m_pProvidersPage( NULL ),
      m_iListViewWidth(0)
{
    //{{AFX_DATA_INIT(CActiveProviderDlg)
    
    //}}AFX_DATA_INIT
}


void CActiveProviderDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CActiveProviderDlg)
    DDX_Control(pDX, IDC_PACT_PROVIDERS_LIST, m_Providers);
    DDX_Check(pDX, IDC_PACT_CHECK_SHOW_ENABLED, m_bShowEnabledOnly);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CActiveProviderDlg, CDialog)
    //{{AFX_MSG_MAP(CActiveProviderDlg)
    ON_BN_CLICKED(IDC_PACT_CHECK_SHOW_ENABLED, OnCheckShowEnabled)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CActiveProviderDlg message handlers

BOOL 
CActiveProviderDlg::OnInitDialog() 
{
    RECT    rect;

    m_bShowEnabledOnly = FALSE;

    CDialog::OnInitDialog();    // Calls UpdateDate ( FALSE ) to init the checkbox value.

    // Get the width of the list view control, then delete the default column.
    m_Providers.GetClientRect(&rect);
    m_iListViewWidth = rect.right;    

    UpdateList();   

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void 
CActiveProviderDlg::OnCheckShowEnabled() 
{
    
//    ::SendMessage(m_Providers.m_hWnd, WM_SETREDRAW, TRUE, 0);
    UpdateData(TRUE);
    UpdateList();
    
}

BOOL 
CActiveProviderDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    ASSERT( NULL != m_pProvidersPage );

    if ( pHelpInfo->iCtrlId >= IDC_PACT_FIRST_HELP_CTRL_ID
         || pHelpInfo->iCtrlId == IDCANCEL )
    {
        InvokeWinHelp(WM_HELP, NULL, (LPARAM)pHelpInfo, m_pProvidersPage->GetContextHelpFilePath(), s_aulHelpIds);
    }
    return TRUE;
}

void 
CActiveProviderDlg::OnContextMenu(CWnd* pWnd, CPoint /* point */) 
{
    ASSERT( NULL != m_pProvidersPage );

    InvokeWinHelp(WM_CONTEXTMENU, (WPARAM)( pWnd->m_hWnd), NULL, m_pProvidersPage->GetContextHelpFilePath(), s_aulHelpIds);

    return;
}

// Helper functions
void CActiveProviderDlg::UpdateList()
{
    LVCOLUMN    lvCol;
    LVITEM      lvItem;
    INT         iGenIndex;
    INT         iAllIndex;
    INT         iEnabledIndex;
    INT         iCount;
    CString     arrstrHeader[2]; 
    CString     strEnabled;
    INT         iColWidth[2];
    CString     strItemText;

    ResourceStateManager    rsm;

    (arrstrHeader[0]).LoadString( IDS_PROV_NAME );
    (arrstrHeader[1]).LoadString( IDS_PROV_STATUS );
    strEnabled.LoadString(IDS_PROV_ENABLED);

    m_Providers.DeleteAllItems();
    m_Providers.DeleteColumn(1);        // Note - Column 1 might not exist.
    m_Providers.DeleteColumn(0);

    lvCol.mask = LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH | LVCF_FMT;
    lvCol.fmt = LVCFMT_LEFT;

    if ( m_bShowEnabledOnly ) {
        iColWidth[0] = m_iListViewWidth;
        iColWidth[1] = 0;
    } else {
        iColWidth[0] = (m_iListViewWidth * 75) / 100;
        iColWidth[1] = (m_iListViewWidth * 25) / 100;
    }

    if ( m_bShowEnabledOnly ) {
        lvCol.iSubItem = 0;
        lvCol.pszText = arrstrHeader[0].GetBufferSetLength( arrstrHeader[0].GetLength());
        lvCol.cx = iColWidth[0];
        m_Providers.InsertColumn(0,&lvCol);
    } else {
        INT iColIndex;
        for (iColIndex = 0 ; iColIndex < 2 ;iColIndex++ ){
            lvCol.iSubItem = 0;
            lvCol.pszText = arrstrHeader[iColIndex].GetBufferSetLength( arrstrHeader[iColIndex].GetLength());
            lvCol.cx = iColWidth[iColIndex];
            m_Providers.InsertColumn(iColIndex,&lvCol);
        }
    }
    
    iEnabledIndex = 0;
    iAllIndex = 0;
    // Add Kernel provider separately.
    if(m_bShowEnabledOnly) { 
        if ( m_pProvidersPage->GetKernelProviderEnabled() ) {
            m_Providers.InsertItem(iEnabledIndex,(LPCWSTR)(m_pProvidersPage->GetKernelProviderDescription()));
        }
    } else {
        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = 0;
        lvItem.iSubItem = 0;    

        m_Providers.InsertItem(iAllIndex++,(LPCWSTR)(m_pProvidersPage->GetKernelProviderDescription()));
    
        // Show status
        if ( m_pProvidersPage->GetKernelProviderEnabled() ) {
            lvItem.pszText = strEnabled.GetBufferSetLength( strEnabled.GetLength() );
            lvItem.iSubItem = 1;
            m_Providers.SetItem(&lvItem);
        }
    }

    // Add general providers
    m_pProvidersPage->GetGenProviderCount( iCount );
    for ( iGenIndex = 0; iGenIndex < iCount ; iGenIndex++ ){
        
        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = iAllIndex;
        lvItem.iSubItem = 0;  
        
        if ( m_pProvidersPage->IsActiveProvider(iGenIndex) ) {
            CString strProviderName;
            
            if(m_bShowEnabledOnly){
                if ( m_pProvidersPage->IsEnabledProvider(iGenIndex) ){
                    m_pProvidersPage->GetProviderDescription ( iGenIndex, strProviderName );
                    m_Providers.InsertItem (iEnabledIndex++,strProviderName );
                }
            } else {
                m_pProvidersPage->GetProviderDescription ( iGenIndex, strProviderName );
                m_Providers.InsertItem (iAllIndex,strProviderName );

                // Show status
                if ( m_pProvidersPage->IsEnabledProvider(iGenIndex) ){
                    lvItem.pszText = strEnabled.GetBufferSetLength( strEnabled.GetLength() );
                    lvItem.iSubItem = 1;
                    m_Providers.SetItem(&lvItem);
                }
            }
        }
    }
}

void    
CActiveProviderDlg::SetProvidersPage( CProvidersProperty* pPage ) 
{ 
    // The providers page is not always the parent, so store a separate pointer
    m_pProvidersPage = pPage; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\enabldlg.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    enabldlg.h

Abstract:

    Header file for the provider status dialog box.

--*/

#ifndef _ENABLDLG_H_
#define _ENABLDLG_H_


#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Dialog controls
#define IDD_PROVIDERS_ACTIVE_DLG        1300

#define IDC_PACT_FIRST_HELP_CTRL_ID     1301
#define IDC_PACT_PROVIDERS_LIST         1301
#define IDC_PACT_CHECK_SHOW_ENABLED     1302


/////////////////////////////////////////////////////////////////////////////
// CActiveProviderDlg dialog

class CProvidersProperty;

class CActiveProviderDlg : public CDialog
{
// Construction
public:
            CActiveProviderDlg(CWnd* pParent = NULL);   // standard constructor
    virtual ~CActiveProviderDlg() {};

            void    SetProvidersPage( CProvidersProperty* pPage );
            void    UpdateList();

    // Dialog Data
    //{{AFX_DATA(CActiveProviderDlg)
    enum { IDD = IDD_PROVIDERS_ACTIVE_DLG };
    CListCtrl       m_Providers;
    BOOL            m_bShowEnabledOnly;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CActiveProviderDlg)
    protected:
    virtual BOOL OnInitDialog();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CActiveProviderDlg)
    afx_msg void OnCheckShowEnabled();
    afx_msg BOOL OnHelpInfo( HELPINFO* );
    afx_msg void OnContextMenu( CWnd*, CPoint );
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CProvidersProperty* m_pProvidersPage;
    INT                 m_iListViewWidth;


};


#endif // _ENABLDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\filelogs.cpp ===
// FileLogs.cpp : implementation file
//

#include "stdafx.h"
#include <strsafe.h>
#include "smlogcfg.h"
#include "fileprop.h"
#include "smlogs.h"
#include "smcfgmsg.h"
#include "smlogqry.h"
#include "fileprop.h" // for eValueRange
#include "FileLogs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("SMLOGCFG(filelogs.cpp)");

static ULONG
s_aulHelpIds[] =
{
    IDC_FILES_FOLDER_EDIT,    IDH_FILES_FOLDER_EDIT,
    IDC_FILES_FOLDER_BTN,     IDH_FILES_FOLDER_BTN,
    IDC_FILES_FILENAME_EDIT,  IDH_FILES_FILENAME_EDIT,
    IDC_FILES_SIZE_MAX_BTN,   IDH_FILES_SIZE_MAX_BTN,
    IDC_FILES_SIZE_LIMIT_EDIT,IDH_FILES_SIZE_LIMIT_EDIT,
    IDC_FILES_SIZE_LIMIT_BTN, IDH_FILES_SIZE_LIMIT_BTN,
    0,0
};

/////////////////////////////////////////////////////////////////////////////
// CFileLogs dialog


CFileLogs::CFileLogs(CWnd* pParent /*=NULL*/)
    : CDialog(CFileLogs::IDD, pParent)
{
    //{{AFX_DATA_INIT(CFileLogs)
    m_strFileBaseName = L"";
    m_strFolderName = L"";
    m_nFileSizeRdo = 0;
    m_bAutoNameSuffix = FALSE;
    m_dwMaxSize = 0;
    m_dwFocusControl = 0;
    //}}AFX_DATA_INIT
}


void CFileLogs::DoDataExchange(CDataExchange* pDX)
{
    CFilesProperty::eValueRange eMaxFileSize;

    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFileLogs)
    DDX_Text(pDX, IDC_FILES_FILENAME_EDIT, m_strFileBaseName);
    DDV_MaxChars(pDX, m_strFileBaseName, (SLQ_MAX_BASE_NAME_LEN));
    DDX_Text(pDX, IDC_FILES_FOLDER_EDIT, m_strFolderName);
    DDV_MaxChars(pDX, m_strFolderName, MAX_PATH);
    DDX_Radio(pDX, IDC_FILES_SIZE_MAX_BTN, m_nFileSizeRdo);
    if ( SLF_BIN_FILE == m_dwLogFileTypeValue ) {
        eMaxFileSize = CFilesProperty::eMaxCtrSeqBinFileLimit;
    } else if ( SLF_SEQ_TRACE_FILE == m_dwLogFileTypeValue ) {
        eMaxFileSize = CFilesProperty::eMaxTrcSeqBinFileLimit;
    } else {
        eMaxFileSize = CFilesProperty::eMaxFileLimit;
    }
    ValidateTextEdit(pDX, IDC_FILES_SIZE_LIMIT_EDIT, 9, &m_dwMaxSize, CFilesProperty::eMinFileLimit, eMaxFileSize);
    //}}AFX_DATA_MAP
    
    if ( pDX->m_bSaveAndValidate ) {

        if (((CButton *)GetDlgItem(IDC_FILES_SIZE_MAX_BTN))->GetCheck() == 1) {
            m_dwMaxSizeInternal = SLQ_DISK_MAX_SIZE;
        } else {
            m_dwMaxSizeInternal = m_dwMaxSize;
        }    

    }
}


BEGIN_MESSAGE_MAP(CFileLogs, CDialog)
    //{{AFX_MSG_MAP(CFileLogs)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    ON_BN_CLICKED(IDC_FILES_FOLDER_BTN, OnFilesFolderBtn)
    ON_EN_CHANGE(IDC_FILES_FILENAME_EDIT, OnChangeFilesFilenameEdit)
    ON_EN_CHANGE(IDC_FILES_FOLDER_EDIT, OnChangeFilesFolderEdit)
    ON_EN_CHANGE(IDC_FILES_SIZE_LIMIT_EDIT, OnChangeFilesSizeLimitEdit)
    ON_BN_CLICKED(IDC_FILES_SIZE_LIMIT_BTN, OnFilesSizeLimitBtn)
    ON_NOTIFY(UDN_DELTAPOS, IDC_FILES_SIZE_LIMIT_SPIN, OnDeltaposFilesSizeLimitSpin)
    ON_BN_CLICKED(IDC_FILES_SIZE_MAX_BTN, OnFilesSizeMaxBtn)
    ON_EN_KILLFOCUS(IDC_FILES_FILENAME_EDIT, OnKillfocusFilesFilenameEdit)
    ON_EN_KILLFOCUS(IDC_FILES_FOLDER_EDIT, OnKillfocusFilesFolderEdit)
    ON_EN_KILLFOCUS(IDC_FILES_SIZE_LIMIT_EDIT, OnKillfocusFilesSizeLimitEdit)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFileLogs message handlers

int
BrowseCallbackProc(
    HWND    hwnd,
    UINT    uMsg,
    LPARAM  /*lParam*/,
    LPARAM  lpData
   )

/*++

Routine Description:

    Callback function for SHBrowseForFolder

Arguments:

    hwnd - Handle to the browse dialog box
    uMsg - Identifying the reason for the callback
    lParam - Message parameter
    lpData - Application-defined value given in BROWSEINFO.lParam

Return Value:

    0

--*/

{
    if (uMsg == BFFM_INITIALIZED && NULL != lpData ) {

        INT     iBufLen = MAX_PATH+1; 
        WCHAR*  szBuffer = NULL;
        CFileLogs* pdlgFileLogs = NULL;
        
        pdlgFileLogs = (CFileLogs*) lpData; 

        if ( NULL != pdlgFileLogs ) {

            szBuffer = new WCHAR [ iBufLen ];

            if ( NULL != szBuffer ) {

                // GetDlgItemText size includes space for NULL character.
                if ( pdlgFileLogs->GetDlgItemText (IDC_FILES_FOLDER_EDIT, szBuffer, iBufLen)) {
                    SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM) szBuffer);
                }
                delete [] szBuffer;
            }
        }
    } 
    return 0;
}

void 
CFileLogs::OnFilesFolderBtn() 
{
    HRESULT       hr = NOERROR;
    BROWSEINFO    bi;
    LPMALLOC      pMalloc = NULL;
    LPITEMIDLIST  pidlItem = NULL;
    LPITEMIDLIST  pidlRoot = NULL;
    INT           iBufLen = MAX_PATH;
    WCHAR*        szFolderName;
    CString       strTitle;
 
    ResourceStateManager rsm;
    
    m_hModule = (HINSTANCE)GetModuleHandleW (_CONFIG_DLL_NAME_W_);
    
    hr = SHGetSpecialFolderLocation(m_hWnd, CSIDL_DRIVES, &pidlRoot);

    if ( SUCCEEDED ( hr ) ) {
        hr = SHGetMalloc(&pMalloc);
    }

    if ( FAILED ( hr ) || pMalloc == NULL || pidlRoot == NULL) {
        //
        // Something wrong from SHELL api, just return
        //
        return;
    }

    // SHBrowseForFolder restricts the return buffer to length MAX_PATH
    szFolderName = new WCHAR [ iBufLen ];

    if ( NULL != szFolderName ) {

        bi.hwndOwner = m_hWnd;
        bi.pidlRoot = (LPCITEMIDLIST)pidlRoot;
        bi.pszDisplayName = szFolderName;
        strTitle.LoadString ( IDS_SELECT_FILE_FOLDER );
        bi.lpszTitle = strTitle.GetBuffer ( strTitle.GetLength() );
        bi.ulFlags = BIF_RETURNONLYFSDIRS |  
                     BIF_NEWDIALOGSTYLE |
                     BIF_RETURNFSANCESTORS |
                     BIF_DONTGOBELOWDOMAIN ;

        bi.lpfn = BrowseCallbackProc;
        bi.lParam = (LPARAM)this;

        pidlItem = SHBrowseForFolder (&bi);
        if ( pidlItem != NULL ) {
            SHGetPathFromIDList(pidlItem, szFolderName);
            SetDlgItemText (IDC_FILES_FOLDER_EDIT, szFolderName);
        } // else ignore if they canceled out
        delete [] szFolderName;
    } // else malloc failed
    // Todo; Error message

    //
    // Free the ITEMIDLIST structure returned from shell
    //
    pMalloc->Free(pidlRoot); 

    if (pidlItem != NULL) {
        pMalloc->Free(pidlItem); 
    }
}


void CFileLogs::OnChangeFilesFilenameEdit() 
{
    CString strOldText;

    // When the user hits OK in the folder browse dialog, 
    // the file name might not have changed.
    strOldText = m_strFileBaseName;
    UpdateData( TRUE );
    if ( 0 != strOldText.Compare ( m_strFileBaseName ) ) {
//        UpdateSampleFileName();     
    }
}

void CFileLogs::OnChangeFilesFolderEdit() 
{
    CString strOldText;

    // When the user hits OK in the folder browse dialog, 
    // the folder name might not have changed.
    strOldText = m_strFolderName;
    UpdateData( TRUE );
    if ( 0 != strOldText.Compare ( m_strFolderName ) ) {
//        UpdateSampleFileName();     
    }
}

void CFileLogs::OnChangeFilesSizeLimitEdit() 
{
    UpdateData( TRUE );    
    
}

void CFileLogs::OnFilesSizeLimitBtn() 
{
    FileSizeBtn(FALSE);      
}

void CFileLogs::OnDeltaposFilesSizeLimitSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
    CFilesProperty::eValueRange eMaxFileSize;

    if ( SLF_BIN_FILE == m_dwLogFileTypeValue ) {
        eMaxFileSize = CFilesProperty::eMaxCtrSeqBinFileLimit;
    } else if ( SLF_SEQ_TRACE_FILE == m_dwLogFileTypeValue ) {
        eMaxFileSize = CFilesProperty::eMaxTrcSeqBinFileLimit;
    } else {
        eMaxFileSize = CFilesProperty::eMaxFileLimit;
    }
    OnDeltaposSpin(pNMHDR, pResult, & m_dwMaxSize, CFilesProperty::eMinFileLimit, eMaxFileSize);
}

void CFileLogs::OnFilesSizeMaxBtn() 
{
    FileSizeBtn(FALSE);    
}

void CFileLogs::OnKillfocusFilesFilenameEdit() 
{
    CString strOldText;
    strOldText = m_strFileBaseName;
    UpdateData ( TRUE );
}

void CFileLogs::OnKillfocusFilesFolderEdit() 
{
    CString strOldText;
    strOldText = m_strFolderName;
    UpdateData ( TRUE );
}

void CFileLogs::OnKillfocusFilesSizeLimitEdit() 
{
    DWORD   dwOldValue;
    dwOldValue = m_dwMaxSize;
    UpdateData ( TRUE );
}

BOOL CFileLogs::OnInitDialog() 
{
    BOOL bLimitBtnSet;
    BOOL bReturn = TRUE;

    CDialog::OnInitDialog();

    // set the buttons 

    m_nFileSizeRdo = 1;
    if (m_dwMaxSizeInternal == SLQ_DISK_MAX_SIZE) {
        m_nFileSizeRdo = 0;
        m_dwMaxSize = 1; // default
    } else {
        m_nFileSizeRdo = 1;
        m_dwMaxSize = m_dwMaxSizeInternal;
    }
    bLimitBtnSet = (m_nFileSizeRdo == 1);
    GetDlgItem(IDC_FILES_SIZE_LIMIT_EDIT)->EnableWindow(bLimitBtnSet);

    // Disable the file browse button for remote machines
    ASSERT ( NULL != m_pLogQuery );
    if ( NULL != m_pLogQuery ) {
        if ( !m_pLogQuery->GetLogService()->IsLocalMachine() ) {
            GetDlgItem ( IDC_FILES_FOLDER_BTN )->EnableWindow ( FALSE );
        }
    }

    UpdateData(FALSE);

    FileSizeBtnEnable();
    FileSizeBtn(FALSE);
    
    if ( 0 != m_dwFocusControl ) {
        GetDlgItem ( m_dwFocusControl )->SetFocus();  
        bReturn = FALSE;
    }

    return bReturn;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CFileLogs::OnOK() 
{
    // load data from dialog
    if ( UpdateData (TRUE) ) { 
        if ( IsValidLocalData() ) {
            CDialog::OnOK();
        }
    }
}

void 
CFileLogs::OnDeltaposSpin(
    NMHDR   *pNMHDR, 
    LRESULT *pResult, 
    DWORD   *pValue, 
    DWORD   dMinValue, 
    DWORD   dMaxValue)
{
    NM_UPDOWN* pNMUpDown;
    LONG       lValue;
    BOOL       bResult   = TRUE;

    UpdateData(TRUE);

    ASSERT(dMinValue <= dMaxValue);

    if ( NULL != pNMHDR
        && NULL != pResult
        && NULL != pValue ) 
    {
        pNMUpDown = (NM_UPDOWN *) pNMHDR;
        lValue    = (LONG) (*pValue);

        if (lValue == INVALID_DWORD) {
            lValue = (DWORD) dMinValue;
        } else {

            if ( ((lValue >= (LONG) dMinValue + 1) && (pNMUpDown->iDelta > 0))
                || ((lValue <= (LONG) dMaxValue - 1) && (pNMUpDown->iDelta < 0)))
            {
                lValue += (pNMUpDown->iDelta * -1);

                if (lValue > (LONG) dMaxValue) {
                    lValue = (DWORD) dMaxValue;
                } else if (lValue < (LONG) dMinValue) {
                    lValue = (DWORD) dMinValue;
                }
            } else if (lValue > (LONG) dMaxValue) {        
                lValue = (DWORD) dMaxValue;
            } else if (lValue < (LONG) dMinValue) {
                lValue = (DWORD) dMinValue;
            } else {
                bResult = FALSE;
            }
        }

        if (bResult) {
            *pValue = lValue;
            UpdateData(FALSE);
        }
        *pResult = 0;
    } else {
        ASSERT ( FALSE );
    }

    return;
}

void CFileLogs::FileSizeBtnEnable()
{
    if ( ( SLF_BIN_CIRC_FILE == m_dwLogFileTypeValue ) 
        ||( SLF_CIRC_TRACE_FILE == m_dwLogFileTypeValue ) ) {
        ((CButton *)GetDlgItem(IDC_FILES_SIZE_LIMIT_BTN))->SetCheck(1);
        ((CButton *)GetDlgItem(IDC_FILES_SIZE_MAX_BTN))->SetCheck(0);
        GetDlgItem(IDC_FILES_SIZE_MAX_BTN)->EnableWindow ( FALSE );
    } else {
        GetDlgItem(IDC_FILES_SIZE_MAX_BTN)->EnableWindow ( TRUE );
    }

}

void CFileLogs::FileSizeBtn(BOOL bInit)
{
    INT     m_nFileSizeOld;
    
    m_nFileSizeOld = m_nFileSizeRdo;

    UpdateData ( TRUE );
    
    if (bInit || (m_nFileSizeOld != m_nFileSizeRdo)) {
        BOOL    bMaxBtnSet, bLimitBtnSet;
        
        // *** This can be replaced since DDX_Radio implemented.
        // get btn state    
        bMaxBtnSet = ((CButton *)GetDlgItem(IDC_FILES_SIZE_MAX_BTN))->GetCheck() == 1;
        bLimitBtnSet = ((CButton *)GetDlgItem(IDC_FILES_SIZE_LIMIT_BTN))->GetCheck() == 1;
    
        ASSERT (bLimitBtnSet != bMaxBtnSet);

        GetDlgItem(IDC_FILES_SIZE_LIMIT_EDIT)->EnableWindow(bLimitBtnSet);
        GetDlgItem(IDC_FILES_SIZE_LIMIT_SPIN)->EnableWindow(bLimitBtnSet);
        GetDlgItem(IDC_FILES_SIZE_LIMIT_UNITS)->EnableWindow(bLimitBtnSet);
    }
}

BOOL CFileLogs::IsValidLocalData()
{
    BOOL bIsValid = TRUE;
    CFilesProperty::eValueRange eMaxFileSize;
    INT iPrevLength = 0;

    ResourceStateManager    rsm;

    // assumes UpdateData has been called

    // Trim folder name and file name before validation
    iPrevLength = m_strFolderName.GetLength();
    m_strFolderName.TrimLeft();
    m_strFolderName.TrimRight();
    
    if ( iPrevLength != m_strFolderName.GetLength() ) {
        SetDlgItemText ( IDC_FILES_FOLDER_EDIT, m_strFolderName );  
    }

    iPrevLength = m_strFileBaseName.GetLength();
    m_strFileBaseName.TrimLeft();
    m_strFileBaseName.TrimRight();

    if ( iPrevLength != m_strFileBaseName.GetLength() ) {
        SetDlgItemText ( IDC_FILES_FILENAME_EDIT, m_strFileBaseName );  
    }

    if ( bIsValid ) {

        if ( m_strFolderName.IsEmpty() ) {
            CString strMessage;
            strMessage.LoadString ( IDS_FILE_ERR_NOFOLDERNAME );
            MessageBox ( strMessage, m_pLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
            (GetDlgItem(IDC_FILES_FOLDER_EDIT))->SetFocus();
            bIsValid = FALSE;
        }
    }
    
    if ( bIsValid ) {

        if ( m_strFileBaseName.IsEmpty() ) {
            if ( !m_bAutoNameSuffix ) {
                CString strMessage;
                strMessage.LoadString ( IDS_FILE_ERR_NOFILENAME );
                MessageBox ( strMessage, m_pLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
                (GetDlgItem(IDC_FILES_FILENAME_EDIT))->SetFocus();
                bIsValid = FALSE;
            }
        } else {
            if ( !FileNameIsValid ( &m_strFileBaseName ) ){
                CString strMessage;
                strMessage.LoadString (IDS_ERRMSG_INVALIDCHAR);
                MessageBox( strMessage, m_pLogQuery->GetLogName(), MB_OK| MB_ICONERROR );
                (GetDlgItem(IDC_FILES_FILENAME_EDIT))->SetFocus();
                bIsValid = FALSE;
            }
        }
    }

    if ( bIsValid ) {
        if ( m_pLogQuery->GetLogService()->IsLocalMachine() ) {

            ProcessDirPath ( m_pLogQuery->GetLogService()->GetDefaultLogFileFolder(),
                             m_strFolderName, 
                             m_pLogQuery->GetLogName(), 
                             this, 
                             bIsValid, 
                             TRUE );

            if ( !bIsValid ) {
                GetDlgItem(IDC_FILES_FOLDER_EDIT)->SetFocus();
            }
        }
    }

    if (bIsValid)
    {
        if ( SLQ_DISK_MAX_SIZE != m_dwMaxSizeInternal ) {
            if ( SLF_BIN_FILE == m_dwLogFileTypeValue ) {
                eMaxFileSize = CFilesProperty::eMaxCtrSeqBinFileLimit;
            } else if ( SLF_SEQ_TRACE_FILE == m_dwLogFileTypeValue ) {
                eMaxFileSize = CFilesProperty::eMaxTrcSeqBinFileLimit;
            } else {
                eMaxFileSize = CFilesProperty::eMaxFileLimit;
            }
            bIsValid = ValidateDWordInterval(IDC_FILES_SIZE_LIMIT_EDIT,
                                             m_pLogQuery->GetLogName(),
                                             (long) m_dwMaxSizeInternal,
                                             CFilesProperty::eMinFileLimit,
                                             eMaxFileSize);
        }
    }

    return bIsValid;
}


void
CFileLogs::ValidateTextEdit(
    CDataExchange * pDX,
    int             nIDC,
    int             nMaxChars,
    DWORD*          pValue,
    DWORD           /* minValue */,
    DWORD           /* maxValue */)
{
    HWND    hWndCtrl       = NULL;
    LONG    currentValue   = INVALID_DWORD;
    WCHAR   szW[MAXSTR];
    CString strTemp;

    // This method can only be called within DoDataExchange, 
    // because it throws an exception.

    ASSERT ( nMaxChars < MAXSTR );

    if ( NULL != pDX ) {
        hWndCtrl = pDX->PrepareEditCtrl(nIDC);
    }

    if ( NULL != pDX && NULL != pValue && NULL != hWndCtrl ) {
        if (pDX->m_bSaveAndValidate)
        {
            * pValue = (DWORD) currentValue;

            ::GetWindowText(hWndCtrl, szW, MAXSTR);

            strTemp = szW;
            DDV_MaxChars(pDX, strTemp, nMaxChars);

            if (szW[0] >= L'0' && szW[0] <= L'9') {
                currentValue = _wtol(szW);
                * pValue      = (DWORD) currentValue;
            }
        } else {
            if ( INVALID_DWORD != *pValue ) {
                StringCchPrintf ( szW, MAXSTR, L"%lu", *pValue );
            } else {
                szW[0] = L'\0';
            }
            GetDlgItem(nIDC)->SetWindowText(szW);
        }
    } else {
        ASSERT ( FALSE );
    }
}

BOOL
CFileLogs::ValidateDWordInterval(int     nIDC,
                                       LPCWSTR strLogName,
                                       long    lValue,
                                       DWORD   minValue,
                                       DWORD   maxValue)
{
    CString strMsg;
    BOOL    bResult =  (lValue >= (long) minValue)
                    && (lValue <= (long) maxValue);

    if (! bResult)
    {
        strMsg.Format ( IDS_ERRMSG_INVALIDDWORD, minValue, maxValue );
        MessageBox(strMsg, strLogName, MB_OK  | MB_ICONERROR);
        GetDlgItem(nIDC)->SetFocus();
        strMsg.Empty();
    }
    return (bResult);
}

BOOL
CFileLogs::OnHelpInfo(HELPINFO * pHelpInfo)
{
    if (pHelpInfo->iCtrlId >= IDC_FILELOG_FIRST_HELP_CTRL_ID || 
        pHelpInfo->iCtrlId == IDOK ||
        pHelpInfo->iCtrlId == IDCANCEL ) {
        InvokeWinHelp(WM_HELP,
                      NULL,
                      (LPARAM) pHelpInfo,
                      m_strHelpFilePath,
                      s_aulHelpIds);
    }
    return TRUE;
}


void 
CFileLogs::OnContextMenu(CWnd* pWnd, CPoint /* point */) 
{
    InvokeWinHelp(WM_CONTEXTMENU, (WPARAM)(pWnd->m_hWnd), NULL, m_strHelpFilePath, s_aulHelpIds);

    return;
}

DWORD
CFileLogs::SetContextHelpFilePath(const CString& rstrPath)
{
    DWORD dwStatus = ERROR_SUCCESS;

    MFC_TRY
        m_strHelpFilePath = rstrPath;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\filelogs.h ===
#if !defined(AFX_FILELOGS_H_INCLUDED_)
#define AFX_FILELOGS_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FileLogs.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFileLogs dialog

#define IDD_FILE_LOGS_DLG               2000

#define IDC_FILELOG_FIRST_HELP_CTRL_ID  2006

#define IDC_FILES_SIZE_GROUP            2001
#define IDC_FILES_FOLDER_CAPTION        2002
#define IDC_FILES_FILENAME_CAPTION      2003
#define IDC_FILES_SIZE_LIMIT_UNITS      2004
#define IDC_FILES_SIZE_LIMIT_SPIN       2005

#define IDC_FILES_FOLDER_EDIT           2006
#define IDC_FILES_FOLDER_BTN            2007
#define IDC_FILES_FILENAME_EDIT         2008
#define IDC_FILES_SIZE_MAX_BTN          2009
#define IDC_FILES_SIZE_LIMIT_BTN        2010
#define IDC_FILES_SIZE_LIMIT_EDIT       2011


class CFileLogs : public CDialog
{    

public:

    // Construction
	        CFileLogs(CWnd* pParent = NULL);   // standard constructor
    virtual ~CFileLogs(){};

    DWORD SetContextHelpFilePath(const CString& rstrPath);

	//{{AFX_DATA(CFileLogs)
	enum { IDD = IDD_FILE_LOGS_DLG };
	CString	m_strFileBaseName;
	CString	m_strFolderName;
    DWORD   m_dwSerialNumber;
    DWORD   m_dwMaxSize;
	int		m_nFileSizeRdo;
	//}}AFX_DATA

    UINT    m_dwMaxSizeInternal;
    DWORD   m_dwLogFileTypeValue;
    BOOL    m_bAutoNameSuffix;
    DWORD   m_dwFocusControl;
    HINSTANCE m_hModule;
	CSmLogQuery* m_pLogQuery;

private:

	BOOL IsValidLocalData();
    void FileSizeBtn(BOOL bInit);
	void FileSizeBtnEnable();
	void OnDeltaposSpin(NMHDR *pNMHDR, LRESULT *pResult, DWORD *pValue, DWORD dMinValue, DWORD dMaxValue);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFileLogs)
    protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
	//{{AFX_MSG(CFileLogs)
	afx_msg void OnFilesFolderBtn();
	afx_msg void OnChangeFilesFilenameEdit();
	afx_msg void OnChangeFilesFolderEdit();
	afx_msg void OnChangeFilesSizeLimitEdit();
	afx_msg void OnFilesSizeLimitBtn();
	afx_msg void OnDeltaposFilesSizeLimitSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnFilesSizeMaxBtn();
	afx_msg void OnKillfocusFilesFilenameEdit();
	afx_msg void OnKillfocusFilesFolderEdit();
	afx_msg void OnKillfocusFilesSizeLimitEdit();
    afx_msg BOOL OnHelpInfo(HELPINFO *);
    afx_msg void OnContextMenu( CWnd*, CPoint );
	virtual BOOL OnInitDialog();
    virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

    void    ValidateTextEdit(CDataExchange * pDX,
                             int             nIDC,
                             int             nMaxChars,
                             DWORD         * value,
                             DWORD           minValue,
                             DWORD           maxValue);
    
    BOOL    ValidateDWordInterval(int     nIDC,
                                  LPCWSTR strLogName,
                                  long    lValue,
                                  DWORD   minValue,
                                  DWORD   maxValue);

    CString     m_strHelpFilePath;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FILELOGS_H__92E00D45_B61D_4CDF_82E4_96BB52D4D236__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\fileprop.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    fileprop.cpp

Abstract:

    Implementation of the files property page.

--*/

#include "stdafx.h"
#include "smlogs.h"
#include "smcfgmsg.h"
#include "smlogqry.h"
#include "FileLogs.h"
#include "sqlprop.h"
#include "fileprop.h"
#include "globals.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("SMLOGCFG(fileprop.cpp)");

static ULONG
s_aulHelpIds[] =
{
    IDC_FILES_COMMENT_EDIT,     IDH_FILES_COMMENT_EDIT,
    IDC_FILES_LOG_TYPE_COMBO,   IDH_FILES_LOG_TYPE_COMBO,
    IDC_CFG_BTN,                IDH_CFG_BTN,
    IDC_FILES_AUTO_SUFFIX_CHK,  IDH_FILES_AUTO_SUFFIX_CHK,
    IDC_FILES_SUFFIX_COMBO,     IDH_FILES_SUFFIX_COMBO,
    IDC_FILES_FIRST_SERIAL_EDIT,IDH_FILES_FIRST_SERIAL_EDIT,
    IDC_FILES_SAMPLE_DISPLAY,   IDH_FILES_SAMPLE_DISPLAY,
    IDC_FILES_OVERWRITE_CHK,    IDH_FILES_OVERWRITE_CHK,
    0,0
};


/////////////////////////////////////////////////////////////////////////////
// CFilesProperty property page

IMPLEMENT_DYNCREATE(CFilesProperty, CSmPropertyPage)

CFilesProperty::CFilesProperty(MMC_COOKIE   mmcCookie, LONG_PTR hConsole) 
:   CSmPropertyPage ( CFilesProperty::IDD, hConsole )
{
//    ::OutputDebugStringA("\nCFilesProperty::CFilesProperty");

    // save pointers from arg list
    m_pQuery = reinterpret_cast <CSmLogQuery *>(mmcCookie);
    m_dwSuffixValue = 0;
    m_dwLogFileTypeValue = 0;
    m_dwAppendMode = 0;
    m_dwMaxSizeInternal = 0;
    m_dwSubDlgFocusCtrl = 0;
//  EnableAutomation();
    //{{AFX_DATA_INIT(CFilesProperty)
    m_iLogFileType = -1;
    m_dwSuffix = -1;
    m_dwSerialNumber = 1;
    m_bAutoNameSuffix = FALSE;
    m_bOverWriteFile  = FALSE;
    //}}AFX_DATA_INIT
}

CFilesProperty::CFilesProperty() : CSmPropertyPage ( CFilesProperty::IDD )
{
    ASSERT (FALSE); // only the constructor with args above should be used

    EnableAutomation();
    m_dwSuffixValue = 0;
    m_dwAppendMode = 0;
    m_dwMaxSizeInternal = 0;
    m_dwSubDlgFocusCtrl = 0;
//  //{{AFX_DATA_INIT(CFilesProperty)
    m_iLogFileType = -1;
    m_dwSuffix = -1;
    m_dwSerialNumber = 1;
    m_bAutoNameSuffix = FALSE;
    m_bOverWriteFile  = FALSE;
//  //}}AFX_DATA_INIT

    // CString variables are empty on construction.
}

CFilesProperty::~CFilesProperty()
{
//    ::OutputDebugStringA("\nCFilesProperty::~CFilesProperty");
}

void CFilesProperty::OnFinalRelease()
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CPropertyPage::OnFinalRelease();
}

void CFilesProperty::DoDataExchange(CDataExchange* pDX)
{
    CString strTemp;

    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFilesProperty)
    DDX_Text(pDX, IDC_FILES_COMMENT_EDIT, m_strCommentText);
    DDV_MaxChars(pDX, m_strCommentText, MAX_PATH);
    DDX_CBIndex(pDX, IDC_FILES_LOG_TYPE_COMBO, m_iLogFileType);
    DDX_CBIndex(pDX, IDC_FILES_SUFFIX_COMBO, m_dwSuffix);
    DDX_Check(pDX, IDC_FILES_AUTO_SUFFIX_CHK, m_bAutoNameSuffix);
    DDX_Check(pDX, IDC_FILES_OVERWRITE_CHK, m_bOverWriteFile);
    ValidateTextEdit(pDX, IDC_FILES_FIRST_SERIAL_EDIT, 6, (DWORD *) & m_dwSerialNumber, eMinFirstSerial, eMaxFirstSerial);
    //}}AFX_DATA_MAP
    
    if ( pDX->m_bSaveAndValidate ) {
        m_dwLogFileTypeValue = (DWORD)((CComboBox *)GetDlgItem(IDC_FILES_LOG_TYPE_COMBO))->GetItemData(m_iLogFileType);    
        if ( m_bAutoNameSuffix ) {
            m_dwSuffixValue = (DWORD)((CComboBox *)GetDlgItem(IDC_FILES_SUFFIX_COMBO))->GetItemData(m_dwSuffix);    
        }
    }
}


BEGIN_MESSAGE_MAP(CFilesProperty, CSmPropertyPage)
    //{{AFX_MSG_MAP(CFilesProperty)
    ON_WM_DESTROY()
    ON_BN_CLICKED(IDC_FILES_AUTO_SUFFIX_CHK, OnAutoSuffixChk)
    ON_BN_CLICKED(IDC_FILES_OVERWRITE_CHK, OnOverWriteChk)
    ON_EN_CHANGE(IDC_FILES_COMMENT_EDIT, OnChangeFilesCommentEdit)
    ON_EN_KILLFOCUS(IDC_FILES_COMMENT_EDIT, OnKillfocusFilesCommentEdit)
    ON_EN_CHANGE(IDC_FILES_FIRST_SERIAL_EDIT, OnChangeFilesFirstSerialEdit)    
    ON_EN_KILLFOCUS(IDC_FILES_FIRST_SERIAL_EDIT, OnKillfocusFirstSerialEdit)
    ON_CBN_SELENDOK(IDC_FILES_LOG_TYPE_COMBO, OnSelendokFilesLogFileTypeCombo)
    ON_CBN_SELENDOK(IDC_FILES_SUFFIX_COMBO, OnSelendokFilesSuffixCombo)
    ON_CBN_KILLFOCUS(IDC_FILES_SUFFIX_COMBO, OnKillfocusFilesSuffixCombo)
    ON_CBN_KILLFOCUS(IDC_FILES_LOG_TYPE_COMBO, OnKillfocusFilesLogFileTypeCombo)
    ON_BN_CLICKED(IDC_CFG_BTN, OnCfgBtn)

    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CFilesProperty, CSmPropertyPage)
    //{{AFX_DISPATCH_MAP(CFilesProperty)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IFilesProperty to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {65154EAB-BDBE-11D1-BF99-00C04F94A83A}
static const IID IID_IFilesProperty =
{ 0x65154eab, 0xbdbe, 0x11d1, { 0xbf, 0x99, 0x0, 0xc0, 0x4f, 0x94, 0xa8, 0x3a } };

BEGIN_INTERFACE_MAP(CFilesProperty, CSmPropertyPage)
    INTERFACE_PART(CFilesProperty, IID_IFilesProperty, Dispatch)
END_INTERFACE_MAP()

void 
CFilesProperty::EnableSerialNumber( void ) 
{
    BOOL bEnable = ( SLF_NAME_NNNNNN == m_dwSuffixValue );
    
    if ( bEnable )
        bEnable = m_bAutoNameSuffix;

    GetDlgItem(IDC_FILES_FIRST_SERIAL_CAPTION)->EnableWindow( bEnable );
    GetDlgItem(IDC_FILES_FIRST_SERIAL_EDIT)->EnableWindow( bEnable );

}

BOOL
CFilesProperty::UpdateSampleFileName( void )
{
    CString     strCompositeName;
    BOOL        bIsValid = TRUE;
    DWORD       dwLocalSuffixValue = SLF_NAME_NONE;

    ResourceStateManager    rsm;
    
    if (m_bAutoNameSuffix) {
        dwLocalSuffixValue = m_dwSuffixValue;
    }

    CreateSampleFileName (
        m_pQuery->GetLogName(),
        m_pQuery->GetLogService()->GetMachineName(),
        m_strFolderName,   
        m_strFileBaseName, 
        m_strSqlName, 
        dwLocalSuffixValue,
        m_dwLogFileTypeValue,
        m_dwSerialNumber,
        strCompositeName );
    
    m_strSampleFileName = strCompositeName;

    // Or call UpdateData ( FALSE );
    SetDlgItemText (IDC_FILES_SAMPLE_DISPLAY, strCompositeName);

    // Clear the selection
    ((CEdit*)GetDlgItem( IDC_FILES_SAMPLE_DISPLAY ))->SetSel ( -1, FALSE );

    if ( MAX_PATH <= m_strSampleFileName.GetLength() ) {
        bIsValid = FALSE;
    }

    return bIsValid;
}

void 
CFilesProperty::HandleLogTypeChange() 
{
    int nSel;
    
    nSel = ((CComboBox *)GetDlgItem(IDC_FILES_LOG_TYPE_COMBO))->GetCurSel();

    // nSel != m_iLogFileType determines data change.
    if ((nSel != LB_ERR) && (nSel != m_iLogFileType)) {

        UpdateData( TRUE );

        if ( (m_pQuery->GetLogService()->TargetOs() == OS_WIN2K) ||
             (SLF_BIN_FILE != m_dwLogFileTypeValue && SLF_SEQ_TRACE_FILE != m_dwLogFileTypeValue )) 
        {
            GetDlgItem(IDC_FILES_OVERWRITE_CHK)->EnableWindow(FALSE);
        } else {
            GetDlgItem(IDC_FILES_OVERWRITE_CHK)->EnableWindow( TRUE );
        }


        OnOverWriteChk();

        EnableSerialNumber();
        UpdateSampleFileName();
        SetModifiedPage(TRUE);
    }
}

BOOL 
CFilesProperty::IsValidLocalData()
{
    BOOL bIsValid = TRUE;
    CString strTest;
    eValueRange eMaxFileSize;

    ResourceStateManager rsm;

    // assumes UpdateData has been called

    if ( !UpdateSampleFileName() ) {
        CString strMessage;
        strMessage.LoadString ( IDS_FILE_ERR_NAMETOOLONG );
        MessageBox ( strMessage, m_pQuery->GetLogName(), MB_OK  | MB_ICONERROR);            
        bIsValid = FALSE;
        if ( SLF_SQL_LOG != m_dwLogFileTypeValue ) {
            m_dwSubDlgFocusCtrl = IDC_FILES_FILENAME_EDIT;
        } else {
            m_dwSubDlgFocusCtrl = IDC_SQL_LOG_SET_EDIT;
        }
            
        OnCfgBtn();
    }

    if ( bIsValid ) {
        if ( m_strFolderName.IsEmpty() && (SLF_SQL_LOG != m_dwLogFileTypeValue)) {
            CString strMessage;
            strMessage.LoadString ( IDS_FILE_ERR_NOFOLDERNAME );
            MessageBox ( strMessage, m_pQuery->GetLogName(), MB_OK  | MB_ICONERROR);
            bIsValid = FALSE;
            m_dwSubDlgFocusCtrl = IDC_FILES_FOLDER_EDIT;
            OnCfgBtn();
        }
    }

    if ( bIsValid ) {
        if ( SLF_SQL_LOG != m_dwLogFileTypeValue ) {
            if ( m_strFileBaseName.IsEmpty() && !m_bAutoNameSuffix ) {
                CString strMessage;
                strMessage.LoadString ( IDS_FILE_ERR_NOFILENAME );
                MessageBox ( strMessage, m_pQuery->GetLogName(), MB_OK  | MB_ICONERROR);
                bIsValid = FALSE;
                m_dwSubDlgFocusCtrl = IDC_FILES_FILENAME_EDIT;
                OnCfgBtn();
            }

            if ( bIsValid ) {
                if ( !FileNameIsValid ( &m_strFileBaseName ) ) {
                    CString strMessage;
                    strMessage.LoadString (IDS_ERRMSG_INVALIDCHAR);
                    MessageBox( strMessage, m_pQuery->GetLogName(), MB_OK| MB_ICONERROR );
                    bIsValid = FALSE;
                    m_dwSubDlgFocusCtrl = IDC_FILES_FILENAME_EDIT;
                    OnCfgBtn();
                }
            }
        } else {

            ExtractDSN ( strTest );
            if ( strTest.IsEmpty() ) {
                CString strMessage;
                strMessage.LoadString ( IDS_SQL_ERR_NODSN );
                MessageBox ( strMessage, m_pQuery->GetLogName(), MB_OK  | MB_ICONERROR);
                bIsValid = FALSE;
                m_dwSubDlgFocusCtrl = IDC_SQL_DSN_COMBO;
                OnCfgBtn();
            }

            if ( bIsValid ) {

                ExtractLogSetName ( strTest );
                if ( strTest.IsEmpty() && !m_bAutoNameSuffix ) {
                    CString strMessage;
                    strMessage.LoadString ( IDS_SQL_ERR_NOLOGSETNAME );
                    MessageBox ( strMessage, m_pQuery->GetLogName(), MB_OK  | MB_ICONERROR);
                    bIsValid = FALSE;
                    m_dwSubDlgFocusCtrl = IDC_SQL_LOG_SET_EDIT;
                    OnCfgBtn();
                } else if ( !FileNameIsValid ( &strTest ) ){
                    CString strMessage;
                    strMessage.LoadString (IDS_ERRMSG_INVALIDCHAR);
                    MessageBox( strMessage, m_pQuery->GetLogName(), MB_OK| MB_ICONERROR );
                    bIsValid = FALSE;
                    m_dwSubDlgFocusCtrl = IDC_SQL_LOG_SET_EDIT;
                    OnCfgBtn();
                }
            }
        }
    }

    // Must set max log file size if circular file.
    if (bIsValid)
    {
        if ( SLQ_DISK_MAX_SIZE == m_dwMaxSizeInternal 
            && ( SLF_BIN_CIRC_FILE == m_dwLogFileTypeValue
                || SLF_CIRC_TRACE_FILE == m_dwLogFileTypeValue ) )
        {
            CString strMessage;
            strMessage.LoadString ( IDS_ERRMSG_SETMAXSIZE );
            MessageBox ( strMessage, m_pQuery->GetLogName(), MB_OK  | MB_ICONERROR);
            bIsValid = FALSE;
            m_dwSubDlgFocusCtrl = IDC_FILES_SIZE_LIMIT_EDIT;
            m_dwMaxSizeInternal = eMinFileLimit;            // Default value
            OnCfgBtn();
        }
    }  
    
    // Validate max log file size based on log file type
    if ( bIsValid ){
        if ( SLQ_DISK_MAX_SIZE != m_dwMaxSizeInternal ) {
            if ( SLF_BIN_FILE == m_dwLogFileTypeValue ) {
                eMaxFileSize = eMaxCtrSeqBinFileLimit;
            } else if ( SLF_SEQ_TRACE_FILE == m_dwLogFileTypeValue ) {
                eMaxFileSize = eMaxTrcSeqBinFileLimit;
            } else if ( SLF_SQL_LOG == m_dwLogFileTypeValue ) {
                eMaxFileSize = eMaxSqlRecordsLimit;
            } else {
                eMaxFileSize = eMaxFileLimit;
            }

            bIsValid = ValidateDWordInterval(IDC_CFG_BTN,
                                             m_pQuery->GetLogName(),
                                             (long) m_dwMaxSizeInternal,
                                             eMinFileLimit,
                                             eMaxFileSize); 
            if ( !bIsValid ) {
                if ( SLF_SQL_LOG == m_dwLogFileTypeValue ) {
                    m_dwSubDlgFocusCtrl = IDC_SQL_SIZE_LIMIT_EDIT;
                } else {
                    m_dwSubDlgFocusCtrl = IDC_FILES_SIZE_LIMIT_EDIT;
                }
                OnCfgBtn();
            }
        }
    }

    if (bIsValid)
    {
        bIsValid = ValidateDWordInterval(IDC_FILES_FIRST_SERIAL_EDIT,
                                         m_pQuery->GetLogName(),
                                         (long) m_dwSerialNumber,
                                         eMinFirstSerial,
                                         eMaxFirstSerial);
    }

    return bIsValid;
}
/////////////////////////////////////////////////////////////////////////////
// CFilesProperty message handlers

void 
CFilesProperty::OnCancel() 
{
    m_pQuery->SyncPropPageSharedData(); // Clear the memory shared between property pages.
}

BOOL 
CFilesProperty::OnApply() 
{
    BOOL bContinue = TRUE;
    
    ResourceStateManager    rsm;
    // load data from dialog
    bContinue = UpdateData (TRUE); 

    if ( bContinue ) {
        bContinue = IsValidData(m_pQuery, VALIDATE_APPLY );
    }

    if ( bContinue ) { 
        bContinue = SampleTimeIsLessThanSessionTime ( m_pQuery );
    }

    // pass data to the query object
    if ( bContinue ) { 
        bContinue = UpdateSharedData( TRUE );
    }

    if ( bContinue ) {
        m_pQuery->SetLogComment(m_strCommentText);
        m_pQuery->SetFileNameParts(m_strFolderName, m_strFileBaseName);
        m_pQuery->SetSqlName(m_strSqlName);
        if ( TRUE == m_bAutoNameSuffix ) {
            m_pQuery->SetFileNameAutoFormat(m_dwSuffixValue);
        } else {
            m_pQuery->SetFileNameAutoFormat(SLF_NAME_NONE);
        }

        m_pQuery->SetFileSerialNumber( m_dwSerialNumber );
        m_pQuery->SetMaxSize(m_dwMaxSizeInternal);

        // Save property page shared data.
        m_pQuery->UpdatePropPageSharedData();

        if ( LOWORD(m_dwLogFileTypeValue) == SLF_BIN_FILE 
                || SLF_SEQ_TRACE_FILE == LOWORD(m_dwLogFileTypeValue) ) {
            if ( m_bOverWriteFile ) {
                m_pQuery->SetDataStoreAppendMode( SLF_DATA_STORE_OVERWRITE );
            } else {
                m_pQuery->SetDataStoreAppendMode( SLF_DATA_STORE_APPEND );
            }
        } else {
            if ( SLF_SQL_LOG == LOWORD(m_dwLogFileTypeValue) ) {
                m_pQuery->SetDataStoreAppendMode ( SLF_DATA_STORE_APPEND );
            } else {
                m_pQuery->SetDataStoreAppendMode ( SLF_DATA_STORE_OVERWRITE );
            }
        }

        m_pQuery->SetLogFileType ( m_dwLogFileTypeValue );

        if ( bContinue ) {
            // ApplyRunAs must be called before UpdateService
            bContinue = ApplyRunAs(m_pQuery); 
        }

        bContinue = CSmPropertyPage::OnApply();
        
        // Sync the service with changes.
        if ( bContinue ) {
            
            bContinue = UpdateService( m_pQuery, FALSE );

            if ( bContinue ) {
                AFX_MANAGE_STATE(AfxGetStaticModuleState());                
                CWaitCursor     WaitCursor;
                // Service might have changed the serial number, so sync it.
                // Don't sync data that is modified by other pages.
                m_pQuery->SyncSerialNumberWithRegistry();
                m_dwSerialNumber = m_pQuery->GetFileSerialNumber();   
            }
        }
    }

    return bContinue;
}

BOOL CFilesProperty::OnInitDialog() 
{
    UINT    nIndex;
    CString strComboBoxString;
    CComboBox *pCombo;
    UINT    nResult;
    DWORD   dwEntries;
    PCOMBO_BOX_DATA_MAP pCbData;

    ResourceStateManager    rsm;

    m_strLogName = m_pQuery->GetLogName();
    
    m_pQuery->GetLogComment ( m_strCommentText );

    // Why get max size internal when it is in the shared data?
    // This should not be a problem, because only this page
    // modifies the value, and GetMaxSize is only called in OnInitDialog.
    m_dwMaxSizeInternal = m_pQuery->GetMaxSize();
        
    // load log file type combo box
    
    m_pQuery->GetLogFileType ( m_dwLogFileTypeValue );
    //
    // If remote box is Win2K system, we don't support SQL data base, use
    // .CSV instead
    //
    if (m_dwLogFileTypeValue == SLF_SQL_LOG && m_pQuery->GetLogService()->TargetOs() == OS_WIN2K) {
        m_dwLogFileTypeValue = SLF_CSV_FILE;
    }

    m_pQuery->GetDataStoreAppendMode ( dwEntries );

    m_bOverWriteFile = ( SLF_DATA_STORE_OVERWRITE == dwEntries );
    
    if ( SLQ_TRACE_LOG == m_pQuery->GetLogType() ) {
        dwEntries = dwTraceFileTypeComboEntries;
        pCbData = (PCOMBO_BOX_DATA_MAP)&TraceFileTypeCombo[0];
    } else {
        dwEntries = dwFileTypeComboEntries;
        pCbData = (PCOMBO_BOX_DATA_MAP)&FileTypeCombo[0];
    }
    pCombo = (CComboBox *)GetDlgItem(IDC_FILES_LOG_TYPE_COMBO);
    pCombo->ResetContent();

    for (nIndex = 0; nIndex < dwEntries; nIndex++) {
        if (pCbData[nIndex].nResId == IDS_FT_SQL && m_pQuery->GetLogService()->TargetOs() == OS_WIN2K) {
            continue;
        }
        strComboBoxString.LoadString( pCbData[nIndex].nResId );
        nResult = pCombo->InsertString (nIndex, (LPCWSTR)strComboBoxString);
        ASSERT (nResult != CB_ERR);

        nResult = pCombo->SetItemData (nIndex, (DWORD)pCbData[nIndex].nData);
        ASSERT (nResult != CB_ERR);

        // set log type in combo box here
        if (m_dwLogFileTypeValue == (int)(pCbData[nIndex].nData)) {
            m_iLogFileType = nIndex;
            nResult = pCombo->SetCurSel(nIndex);
            ASSERT (nResult != CB_ERR);

            if ( SLF_BIN_FILE != m_dwLogFileTypeValue
                    && SLF_SEQ_TRACE_FILE != m_dwLogFileTypeValue )
            {
                GetDlgItem(IDC_FILES_OVERWRITE_CHK)->EnableWindow(FALSE);
            } else {
                GetDlgItem(IDC_FILES_OVERWRITE_CHK)->EnableWindow( TRUE );
            }
        }
    }

    if (m_pQuery->GetLogService()->TargetOs() == OS_WIN2K) {
        GetDlgItem(IDC_FILES_OVERWRITE_CHK)->EnableWindow(FALSE);
    }

    m_pQuery->GetFileNameParts ( m_strFolderName, m_strFileBaseName );
    m_pQuery->GetSqlName ( m_strSqlName );

    m_dwSerialNumber = m_pQuery->GetFileSerialNumber();
    
    // load the filename suffix combo box here
    m_dwSuffixValue = m_pQuery->GetFileNameAutoFormat();

    pCombo = (CComboBox *)GetDlgItem(IDC_FILES_SUFFIX_COMBO);
    pCombo->ResetContent();
    for (nIndex = 0; nIndex < dwFileNameSuffixComboEntries; nIndex++) {
        strComboBoxString.LoadString ( FileNameSuffixCombo[nIndex].nResId  );
        nResult = pCombo->InsertString (nIndex, (LPCWSTR)strComboBoxString);
        ASSERT (nResult != CB_ERR);
        pCombo->SetItemData (nIndex, (DWORD)FileNameSuffixCombo[nIndex].nData);
        ASSERT (nResult != CB_ERR);
        // set the correct entry in the combo box here
        if (m_dwSuffixValue == (int)(FileNameSuffixCombo[nIndex].nData)) {
            m_dwSuffix = nIndex;
            nResult = pCombo->SetCurSel(nIndex);
            ASSERT (nResult != CB_ERR);
        }
        if ( SLF_NAME_NNNNNN == (int)(FileNameSuffixCombo[nIndex].nData ) ) {
            m_dwSuffixIndexNNNNNN = nIndex;
        }
    }

    if ( SLF_NAME_NONE == m_dwSuffixValue ) {
        // then the combo box will not have been selected so:
        pCombo->SetCurSel(m_dwSuffixIndexNNNNNN);
        // disable 
        pCombo->EnableWindow(FALSE);
        // and clear the check box
        m_bAutoNameSuffix = FALSE;
    } else {
        m_bAutoNameSuffix = TRUE;
    }

    // set the check box in UpdateData ( FALSE );
    // update the dialog box
    CSmPropertyPage::OnInitDialog();
    SetHelpIds ( (DWORD*)&s_aulHelpIds );

    EnableSerialNumber();
    UpdateSampleFileName();

    SetModifiedPage( FALSE );

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void 
CFilesProperty::OnAutoSuffixChk() 
{
    UpdateData( TRUE );

    // enable the suffix combo window based on the state of the button
    GetDlgItem(IDC_FILES_SUFFIX_COMBO)->EnableWindow (m_bAutoNameSuffix);

    if (m_bAutoNameSuffix) {
        if ( SLF_NAME_NONE == m_dwSuffixValue ) {
            // then initialize a new default
            // select the default serial numbering
            ((CComboBox *)(GetDlgItem(IDC_FILES_SUFFIX_COMBO)))->SetCurSel( m_dwSuffixIndexNNNNNN );
            m_dwSuffixValue = SLF_NAME_NNNNNN;
        }
    } 

    EnableSerialNumber();
    UpdateSampleFileName();
    // This method is only called when the checkbox value has changed.
    SetModifiedPage(TRUE);
}

void
CFilesProperty::OnOverWriteChk()
{
    BOOL    bOldValue;
    bOldValue = m_bOverWriteFile;
    UpdateData(TRUE);
    if (bOldValue != m_bOverWriteFile) {
        SetModifiedPage(TRUE);
    }
}


void CFilesProperty::OnChangeFilesFirstSerialEdit() 
{
    DWORD    dwOldValue;
    dwOldValue = m_dwSerialNumber;
    UpdateData( TRUE );    

    UpdateSampleFileName(); 
    
    if (dwOldValue != m_dwSerialNumber) {
        SetModifiedPage(TRUE);
    }
}

void CFilesProperty::OnChangeFilesCommentEdit() 
{
    CString strOldText;
    strOldText = m_strCommentText;
    UpdateData ( TRUE );
    if ( 0 != strOldText.Compare ( m_strCommentText ) ) {
        SetModifiedPage(TRUE);
    }
}

void CFilesProperty::OnSelendokFilesSuffixCombo() 
{
    int nSel;
    
    nSel = ((CComboBox *)GetDlgItem(IDC_FILES_SUFFIX_COMBO))->GetCurSel();

    // Check of m_dwSuffix ensures that the value has changed.
    if ( LB_ERR != nSel && m_dwSuffix != nSel ) {

        UpdateData ( TRUE );
        EnableSerialNumber();
/*
            if (m_dwLogFileTypeValue == SLF_BIN_FILE) {
                GetDlgItem(IDC_FILES_OVERWRITE_CHK)->EnableWindow(
                            m_dwSuffixValue == SLF_NAME_NNNNNN ? FALSE : TRUE);
            }

            else {
                GetDlgItem(IDC_FILES_OVERWRITE_CHK)->EnableWindow(FALSE);
            }
*/
        UpdateSampleFileName();

        SetModifiedPage(TRUE);
    }
}

void 
CFilesProperty::OnSelendokFilesLogFileTypeCombo() 
{
    HandleLogTypeChange();
    return;
}


void CFilesProperty::OnKillfocusFilesCommentEdit() 
{
    CString strOldText;
    strOldText = m_strCommentText;
    UpdateData ( TRUE );
    if ( 0 != strOldText.Compare ( m_strCommentText ) ) {
        SetModifiedPage(TRUE);
    }
}

void CFilesProperty::OnKillfocusFirstSerialEdit() 
{
    DWORD   dwOldValue;
    dwOldValue = m_dwSerialNumber;
    UpdateData ( TRUE );
    if (dwOldValue != m_dwSerialNumber) {
        SetModifiedPage(TRUE);
    }
}


void CFilesProperty::OnKillfocusFilesSuffixCombo() 
{
    int nSel;
    
    nSel = ((CComboBox *)GetDlgItem(IDC_FILES_SUFFIX_COMBO))->GetCurSel();
    if ((nSel != LB_ERR) && (nSel != m_dwSuffix)) {
        SetModifiedPage(TRUE);
    }
}

void CFilesProperty::OnKillfocusFilesLogFileTypeCombo() 
{
    int nSel;
    
    nSel = ((CComboBox *)GetDlgItem(IDC_FILES_LOG_TYPE_COMBO))->GetCurSel();
    if ((nSel != LB_ERR) && (nSel != m_iLogFileType)) {
        SetModifiedPage(TRUE);
    }
}

void CFilesProperty::PostNcDestroy() 
{
//  delete this;      

    CPropertyPage::PostNcDestroy();
}

BOOL 
CFilesProperty::UpdateSharedData( BOOL bUpdateModel ) 
{
    BOOL  bContinue = TRUE;

    if ( SLQ_AUTO_MODE_SIZE == m_SharedData.stiStopTime.dwAutoMode ) {
        CString strMsg;

        if ( ( SLF_BIN_CIRC_FILE == m_dwLogFileTypeValue 
            || SLF_CIRC_TRACE_FILE == m_dwLogFileTypeValue )
            || SLQ_DISK_MAX_SIZE == m_dwMaxSizeInternal ) 
        {
            if ( SLF_BIN_CIRC_FILE == m_dwLogFileTypeValue 
                || SLF_CIRC_TRACE_FILE == m_dwLogFileTypeValue ) 
            {
                strMsg.LoadString ( IDS_FILE_CIRC_SET_MANUAL_STOP );
            } else {
                ASSERT( SLQ_DISK_MAX_SIZE == m_dwMaxSizeInternal );
                strMsg.LoadString ( IDS_FILE_MAX_SET_MANUAL_STOP );
            }            

            MessageBox( strMsg, m_pQuery->GetLogName(), MB_OK  | MB_ICONINFORMATION);

            m_SharedData.stiStopTime.dwAutoMode = SLQ_AUTO_MODE_NONE;

            if ( bUpdateModel ) {
                SLQ_TIME_INFO   slqTime;
                memset (&slqTime, 0, sizeof(slqTime));
        
                slqTime.wTimeType = SLQ_TT_TTYPE_STOP;
                slqTime.wDataType = SLQ_TT_DTYPE_DATETIME;
                slqTime.dwAutoMode = SLQ_AUTO_MODE_NONE; 

                bContinue = m_pQuery->SetLogTime ( &slqTime, (DWORD)slqTime.wTimeType );
            }
        }
    }

    m_SharedData.strFileBaseName = m_strFileBaseName;
    m_SharedData.strFolderName = m_strFolderName;
    m_SharedData.strSqlName = m_strSqlName;
    m_SharedData.dwLogFileType = m_dwLogFileTypeValue;
    if ( TRUE == m_bAutoNameSuffix ) {
        m_SharedData.dwSuffix = m_dwSuffixValue;
    } else {
        m_SharedData.dwSuffix = SLF_NAME_NONE;
    }
    m_SharedData.dwSerialNumber = m_dwSerialNumber;
    m_SharedData.dwMaxFileSize = m_dwMaxSizeInternal;

    m_pQuery->SetPropPageSharedData ( &m_SharedData );

    return bContinue;
}


BOOL CFilesProperty::OnKillActive() 
{
    BOOL bContinue = TRUE;

    ResourceStateManager    rsm;

    bContinue = CPropertyPage::OnKillActive();
    
    if ( bContinue ) {
        bContinue = IsValidData(m_pQuery, VALIDATE_FOCUS );
    }

    if ( bContinue ) {
        m_SharedData.dwLogFileType = m_dwLogFileTypeValue;

        bContinue = UpdateSharedData( FALSE );
    }
    
    if ( bContinue ) {
        SetIsActive ( FALSE );
    }

    return bContinue;
}

BOOL CFilesProperty::OnSetActive() 
{
    BOOL        bReturn;

    bReturn = CSmPropertyPage::OnSetActive();
    if ( bReturn ) {

        m_pQuery->GetPropPageSharedData ( &m_SharedData );

        UpdateData( FALSE );
    }
    return bReturn;
}

DWORD
CFilesProperty::ExtractDSN ( CString& rstrDSN )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    INT     iTotalLength;
    INT     iRightLength;

    // Format string:  "SQL:%s!%s"    
    MFC_TRY
        iTotalLength = m_strSqlName.GetLength();
        iRightLength = iTotalLength - m_strSqlName.Find(L"!");

        rstrDSN = m_strSqlName.Mid ( 4, iTotalLength - iRightLength - 4 );
    MFC_CATCH_DWSTATUS;

    return dwStatus;
}

DWORD
CFilesProperty::ExtractLogSetName ( CString& rstrLogSetName )
{
    DWORD   dwStatus = ERROR_SUCCESS;
 
    // Format string:  "SQL:%s!%s"    
    MFC_TRY
        rstrLogSetName = m_strSqlName.Right(m_strSqlName.GetLength() - m_strSqlName.Find(L"!") - 1);
    MFC_CATCH_DWSTATUS;
    
    return dwStatus;
}

void CFilesProperty::OnCfgBtn() 
{
    DWORD       dwStatus = ERROR_SUCCESS;
    CFileLogs   FilelogsDlg;
    CSqlProp    SqlLogDlg; 
    CString     strTempBaseName;
    CString     strTempFolderName;
    CString     strTempSqlName;
    DWORD       dwTempMaxSize;
    
    if ( SLF_SQL_LOG == m_dwLogFileTypeValue ){
        SqlLogDlg.m_pLogQuery = m_pQuery;
        SqlLogDlg.m_dwLogFileTypeValue = m_dwLogFileTypeValue;
        SqlLogDlg.m_bAutoNameSuffix = m_bAutoNameSuffix;

        //Extract the DSN and logset name from the formatted Sql Log name
        dwStatus = ExtractDSN ( SqlLogDlg.m_strDSN );
        dwStatus = ExtractLogSetName ( SqlLogDlg.m_strLogSetName );
        
        // Default the log set name to the base file name.
        if (SqlLogDlg.m_strLogSetName.IsEmpty() ) {
            SqlLogDlg.m_strLogSetName = m_strFileBaseName;
        }
       
        // Todo:  Handle bad status
        SqlLogDlg.m_dwFocusControl = m_dwSubDlgFocusCtrl;
        SqlLogDlg.m_dwMaxSizeInternal = m_dwMaxSizeInternal;
        SqlLogDlg.SetContextHelpFilePath(GetContextHelpFilePath());
        
        if ( IDOK == SqlLogDlg.DoModal() ) {

            strTempSqlName = m_strSqlName;
            dwTempMaxSize = m_dwMaxSizeInternal;

            m_strSqlName = SqlLogDlg.m_SqlFormattedLogName;
            m_dwMaxSizeInternal = SqlLogDlg.m_dwMaxSizeInternal;

            if ( 0 != strTempSqlName.CompareNoCase ( m_strSqlName )
                    || m_dwMaxSizeInternal != dwTempMaxSize ) 
            {
                SetModifiedPage(TRUE);
            }
        }
    }else{
        FilelogsDlg.m_pLogQuery = m_pQuery;
        FilelogsDlg.m_dwLogFileTypeValue = m_dwLogFileTypeValue;
        FilelogsDlg.m_strFolderName = m_strFolderName;
        FilelogsDlg.m_strFileBaseName = m_strFileBaseName;
        FilelogsDlg.m_dwMaxSizeInternal = m_dwMaxSizeInternal;
        FilelogsDlg.m_bAutoNameSuffix = m_bAutoNameSuffix;
        FilelogsDlg.SetContextHelpFilePath(GetContextHelpFilePath());
    
        FilelogsDlg.m_dwFocusControl = m_dwSubDlgFocusCtrl;

        if ( IDOK ==  FilelogsDlg.DoModal() ) {

            strTempFolderName = m_strFolderName;
            strTempBaseName = m_strFileBaseName;
            dwTempMaxSize = m_dwMaxSizeInternal;

            m_strFolderName = FilelogsDlg.m_strFolderName ;
            m_strFileBaseName = FilelogsDlg.m_strFileBaseName;
            m_dwMaxSizeInternal = FilelogsDlg.m_dwMaxSizeInternal;

            if ( 0 != strTempFolderName.CompareNoCase ( m_strFolderName )
                    || 0 != strTempBaseName.CompareNoCase ( m_strFileBaseName )
                    || m_dwMaxSizeInternal != dwTempMaxSize ) 
            {
                SetModifiedPage(TRUE);
            }
        }
    }
    m_dwSubDlgFocusCtrl = 0;
    UpdateSampleFileName();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\fileprop.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    fileprop.h

Abstract:

    Header file for the files property page.

--*/

#ifndef _FILEPROP_H_
#define _FILEPROP_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "smlogqry.h"   // For shared property page data structure
#include "smproppg.h"   // Base class
#include "smcfghlp.h"

// Dialog controls
#define IDD_FILES_PROP                  500

#define IDC_FILE_FIRST_HELP_CTRL_ID     507

#define IDC_FILES_LOG_TYPE_CAPTION      501
#define IDC_FILES_NAME_GROUP            502
#define IDC_FILES_COMMENT_CAPTION       503
#define IDC_FILES_SAMPLE_CAPTION        504
#define IDC_FILES_FIRST_SERIAL_CAPTION  505
#define IDC_FILES_SUFFIX_CAPTION        506

#define IDC_FILES_COMMENT_EDIT          507
#define IDC_FILES_LOG_TYPE_COMBO        508
#define IDC_CFG_BTN                     509
#define IDC_FILES_AUTO_SUFFIX_CHK       510
#define IDC_FILES_SUFFIX_COMBO          511
#define IDC_FILES_FIRST_SERIAL_EDIT     512
#define IDC_FILES_SAMPLE_DISPLAY        513
#define IDC_FILES_OVERWRITE_CHK         514

class CSmLogQuery;

/////////////////////////////////////////////////////////////////////////////
// CFilesProperty dialog

class CFilesProperty : public CSmPropertyPage
{
    friend class CFileLogs;
    friend class CSqlProp;

    DECLARE_DYNCREATE(CFilesProperty)

// Construction
public:
            CFilesProperty(MMC_COOKIE   mmcCookie, LONG_PTR hConsole);
            CFilesProperty();
    virtual ~CFilesProperty();

// Dialog Data
    //{{AFX_DATA(CFilesProperty)
	enum { IDD = IDD_FILES_PROP };
    CString m_strCommentText;
    CString m_strLogName;
    int     m_iLogFileType;
    CString m_strSampleFileName;
    int     m_dwSuffix;
    DWORD   m_dwSerialNumber;
    BOOL    m_bAutoNameSuffix;
    BOOL    m_bOverWriteFile;
	//}}AFX_DATA

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CFilesProperty)
    public:
    protected:
    virtual void OnFinalRelease();
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL

// Implementation
protected:

    virtual INT GetFirstHelpCtrlId ( void ) { return IDC_FILE_FIRST_HELP_CTRL_ID; };  // Subclass must override.
    virtual BOOL    IsValidLocalData();
    
    // Generated message map functions
    //{{AFX_MSG(CFilesProperty)
    afx_msg void OnAutoSuffixChk();
    afx_msg void OnOverWriteChk();
    afx_msg void OnChangeFilesCommentEdit();
    afx_msg void OnChangeFilesFirstSerialEdit();
    afx_msg void OnKillfocusFilesCommentEdit();
    afx_msg void OnKillfocusFirstSerialEdit();
    afx_msg void OnSelendokFilesLogFileTypeCombo();
    afx_msg void OnSelendokFilesSuffixCombo();
    afx_msg void OnKillfocusFilesSuffixCombo();
    afx_msg void OnKillfocusFilesLogFileTypeCombo();
   	afx_msg void OnCfgBtn();

    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CFilesProperty)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()

private:

    BOOL    UpdateSampleFileName( void );
    void    EnableSerialNumber( void );
    void    HandleLogTypeChange( void );
    BOOL    UpdateSharedData( BOOL bUpdateModel );
    DWORD   ExtractDSN ( CString& rstrDSN );
    DWORD   ExtractLogSetName ( CString& rstrLogSetName );

    enum eValueRange {
        eMinFileLimit = 1,
        eMaxFileLimit = 0x00000FFF,             // * 0x0100000 = 0xFFFFFFF - no size restriction
                                                //      for non-binary and circ files
        eMaxCtrSeqBinFileLimit = 0x00000FFF,    // * 0x0100000 = 0xFFFFFFF - for binary files
        eMaxTrcSeqBinFileLimit = 0x30000000,    // 0x30000000 - for trace seq binary files
        eMinSqlRecordsLimit = 0x00000004,
        eMaxSqlRecordsLimit = 0x30000000,       // 0x30000000 - for SQL logs 
        eMinFirstSerial = 0,
        eMaxFirstSerial = 999999
    };
    
    DWORD       m_dwLogFileTypeValue;
    DWORD       m_dwAppendMode;
    DWORD       m_dwSuffixValue;
    DWORD       m_dwSuffixIndexNNNNNN;
    DWORD       m_dwMaxSizeInternal;

    CString     m_strFileBaseName;
    CString     m_strFolderName;
    CString     m_strSqlName;

    DWORD       m_dwSubDlgFocusCtrl;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _FILEPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\globals.h ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation

Module Name:

    GLOBALS.H

Abstract:

    Utility functions and global variables for the Performance Logs and
	Alerts MMC snap-in.

--*/

#ifndef __GLOBALS_H_
#define __GLOBALS_H_

#include <pdh.h>
#include "DataObj.h"
#include "common.h"
#include <compuuid.h>   // for MyComputer guids

// global strings that don't need to be localized
const LPWSTR    szEmptyString = L"";

extern HINSTANCE g_hinst;
extern CRITICAL_SECTION g_critsectInstallDefaultQueries;

//---------------------------------------------------------------------------
//  Property change stuff
//
#define PROPCHANGE_ATTRIBUTE   1
#define PROPCHANGE_FILENAME    2
#define PROPCHANGE_COMMENT     3
#define PROPCHANGE_TIMESTAMP   4

//#define __SHOW_TRACES
#ifdef __SHOW_TRACES
#undef __SHOW_TRACES
#endif

#ifdef __SHOW_TRACES
#define LOCALTRACE  ATLTRACE
#else
#define LOCALTRACE    
#endif

typedef struct tag_PROPCHANGE_DATA
{
  ULONG    fAttr2Change;         // Which attribute we're changing
  ULONG    nDataLength;          // Length of the new data
  VOID*    pData2Change;         // The new data

}PROPCHANGE_DATA;  


//---------------------------------------------------------------------------
//  Menu IDs
//
#define IDM_NEW_QUERY           40001
#define IDM_NEW_QUERY_FROM      40002
#define IDM_START_QUERY         40003
#define IDM_STOP_QUERY          40004
#define IDM_SAVE_QUERY_AS       40005

// Custom clipboard formats
#define CF_MMC_SNAPIN_MACHINE_NAME  L"MMC_SNAPIN_MACHINE_NAME"
#define CF_INTERNAL             L"SYSMON_LOG_INTERNAL_DATA"

#define MEM_UNINITIALIZED    -1

// Constants
const UINT uiSmLogGuidStringBufLen = 39;

// Generated with uuidgen. Each node must have a GUID associated with it.
const GUID GUID_SnapInExt = /* {7478EF65-8C46-11d1-8D99-00A0C913CAD4} */
{
    0x7478eF65,
    0x8c46,
    0x11d1,
    { 0x8d, 0x99, 0x0, 0xa0, 0xc9, 0x13, 0xca, 0xd4 }
};

// This one is for the main root node.
const GUID GUID_RootNode = /* {7478EF63-8C46-11d1-8D99-00A0C913CAD4} */
{ 
    0x7478ef63, 
    0x8c46, 
    0x11d1, 
    { 0x8d, 0x99, 0x0, 0xa0, 0xc9, 0x13, 0xca, 0xd4 } 
};

// These are the children nodes of the main root node
const GUID GUID_CounterMainNode = /* {7478EF66-8C46-11d1-8D99-00A0C913CAD4} */
{ 
    0x7478ef66, 
    0x8c46, 
    0x11d1, 
    { 0x8d, 0x99, 0x0, 0xa0, 0xc9, 0x13, 0xca, 0xd4 } 
};

const GUID GUID_TraceMainNode = /* {7478EF67-8C46-11d1-8D99-00A0C913CAD4} */
{ 
    0x7478ef67, 
    0x8c46, 
    0x11d1, 
    { 0x8d, 0x99, 0x0, 0xa0, 0xc9, 0x13, 0xca, 0xd4 } 
};

const GUID GUID_AlertMainNode = /* {7478EF68-8C46-11d1-8D99-00A0C913CAD4} */
{ 
    0x7478ef68, 
    0x8c46, 
    0x11d1, 
    { 0x8d, 0x99, 0x0, 0xa0, 0xc9, 0x13, 0xca, 0xd4 } 
};

// Obsolete after Beta 3:
const GUID GUID_MainNode = /* {7478EF64-8C46-11d1-8D99-00A0C913CAD4} */
{ 
    0x7478ef64, 
    0x8c46, 
    0x11d1, 
    { 0x8d, 0x99, 0x0, 0xa0, 0xc9, 0x13, 0xca, 0xd4 } 
};


extern "C" {
extern WCHAR GUIDSTR_TypeLibrary[];
extern WCHAR GUIDSTR_ComponentData[];
extern WCHAR GUIDSTR_Component[];
extern WCHAR GUIDSTR_RootNode[];
extern WCHAR GUIDSTR_MainNode[];    // Obsolete after Beta 3
extern WCHAR GUIDSTR_SnapInExt[];
extern WCHAR GUIDSTR_CounterMainNode[];
extern WCHAR GUIDSTR_TraceMainNode[];
extern WCHAR GUIDSTR_AlertMainNode[];
extern WCHAR GUIDSTR_PerformanceAbout[];
};


extern "C" {
    typedef struct _COMBO_BOX_DATA_MAP {
        UINT    nData;
        UINT    nResId;
    } COMBO_BOX_DATA_MAP, *PCOMBO_BOX_DATA_MAP;
}

extern const COMBO_BOX_DATA_MAP TimeUnitCombo[];
extern const DWORD dwTimeUnitComboEntries;

//---------------------------------------------------------------------------
// Global function defines
//
#define MsgBox(wszMsg, wszTitle) ::MessageBox(NULL, wszMsg, wszTitle, MB_OK)

int DebugMsg( LPWSTR wszMsg, LPWSTR wszTitle ); 

DWORD __stdcall CreateSampleFileName (
                    const   CString&  rstrQueryName, 
                    const   CString&  rstrMachineName, 
                    const   CString&  rstrFolderName, 
                    const   CString&  rstrInputBaseName,
                    const   CString&  rstrSqlName,
                            DWORD   dwSuffixFormat, 
                            DWORD   dwLogFileTypeValue,
                            DWORD   dwCurrentSerialNumber,
                            CString&  rstrReturnName );

DWORD __stdcall IsDirPathValid (
                    CString&  rstrDefault,
                    CString&  csPath,
                    BOOL bLastNameIsDirectory,
                    BOOL bCreateMissingDirs,
                    BOOL& rbIsValid);

DWORD __stdcall ProcessDirPath (
                    const CString&  rstrDefault,
                    CString&  rstrPath,
                    const CString&  rstrLogName,
                    CWnd*   pwndParent,
                    BOOL&   rbIsValid,
                    BOOL    bOnFilesPage);

INT __stdcall   BrowseCommandFilename ( CWnd* pwndParent, CString&  rstrFilename );

DWORD __stdcall FormatSmLogCfgMessage ( CString& rstrMessage,HINSTANCE hResourceHandle, UINT uiMessageId, ... );

BOOL _stdcall   FileRead ( HANDLE hFile, void* lpMemory, DWORD nAmtToRead );

BOOL _stdcall   FileWrite ( HANDLE hFile, void* lpMemory, DWORD nAmtToWrite );

// Pdh counter paths - return status

#define SMCFG_DUPL_NONE             ERROR_SUCCESS
#define SMCFG_DUPL_SINGLE_PATH      ((DWORD)0x00000001)
#define SMCFG_DUPL_FIRST_IS_WILD    ((DWORD)0x00000002)
#define SMCFG_DUPL_SECOND_IS_WILD   ((DWORD)0x00000003)

DWORD _stdcall
CheckDuplicateCounterPaths (
    PDH_COUNTER_PATH_ELEMENTS* pFirst,
    PDH_COUNTER_PATH_ELEMENTS* pSecond );

LPWSTR _stdcall
ExtractFileName ( LPWSTR pFileSpec );

//---------------------------------------------------------------------------
template<class TYPE>
inline void SAFE_RELEASE( TYPE*& pObj )
{
  if( NULL != pObj ) 
  { 
    pObj->Release(); 
    pObj = NULL; 
  } 
  else 
  { 
    LOCALTRACE( L"Release called on NULL interface ptr\n" ); 
  }
} // end SAFE_RELEASE()


/////////////////////////////////////////////////////////////////////////////
//  We need a few functions to help work with dataobjects and
//  clipboard formats
//
HRESULT ExtractFromDataObject(LPDATAOBJECT lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);

CDataObject* ExtractOwnDataObject(LPDATAOBJECT lpDataObject);

VOID DisplayError( LONG nErrorCode, LPWSTR wszDlgTitle );
VOID DisplayError( LONG nErrorCode, UINT nTitleString );

HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType );
HRESULT ExtractMachineName( IDataObject* piDataObject, CString& rstrMachineName );

class ResourceStateManager 
{
public:
    ResourceStateManager(); 
    
    ~ResourceStateManager();

private:
    HINSTANCE m_hResInstance;

};

static const COMBO_BOX_DATA_MAP FileNameSuffixCombo[] = 
{
    {SLF_NAME_NNNNNN,       IDS_FS_NNNNNN},
    {SLF_NAME_MMDDHH,       IDS_FS_MMDDHH},
    {SLF_NAME_MMDDHHMM,     IDS_FS_MMDDHHMM},
    {SLF_NAME_YYYYDDD,      IDS_FS_YYYYDDD},
    {SLF_NAME_YYYYMM,       IDS_FS_YYYYMM},
    {SLF_NAME_YYYYMMDD,     IDS_FS_YYYYMMDD},
    {SLF_NAME_YYYYMMDDHH,   IDS_FS_YYYYMMDDHH}
};
static const DWORD dwFileNameSuffixComboEntries = sizeof(FileNameSuffixCombo)/sizeof(FileNameSuffixCombo[0]);

static const COMBO_BOX_DATA_MAP FileTypeCombo[] = 
{
    {SLF_CSV_FILE,      IDS_FT_CSV},
    {SLF_TSV_FILE,      IDS_FT_TSV},
    {SLF_BIN_FILE,      IDS_FT_BINARY},
    {SLF_BIN_CIRC_FILE, IDS_FT_BINARY_CIRCULAR},
    {SLF_SQL_LOG,       IDS_FT_SQL}
};
static const DWORD dwFileTypeComboEntries = sizeof(FileTypeCombo)/sizeof(FileTypeCombo[0]);

static const COMBO_BOX_DATA_MAP TraceFileTypeCombo[] = 
{
    {SLF_CIRC_TRACE_FILE,    IDS_FT_CIRCULAR_TRACE},
    {SLF_SEQ_TRACE_FILE,     IDS_FT_SEQUENTIAL_TRACE}
};
static const DWORD dwTraceFileTypeComboEntries = sizeof(TraceFileTypeCombo)/sizeof(TraceFileTypeCombo[0]);


/////////////////////////////////////////////////////////////////////////////
//  We need a few functions to help work with dataobjects and
//  clipboard formats
//

// Exception handling macros from snapin\corecopy\macros.h



//____________________________________________________________________________
//
//  Macro:      EXCEPTION HANDLING MACROS
//
//  Purpose:    Provide standard macros for exception-handling in
//              OLE servers.
//
//  History:    7/23/1996   JonN    Created
//
//  Notes:      Declare USE_HANDLE_MACROS("Component name") in each source
//              file before these are used.
//
//              These macros can only be used in function calls which return
//              type HRESULT.
//
//              Bracket routines which can generate exceptions
//              with STANDARD_TRY and STANDARD_CATCH.
//
//              Where these routines are COM methods requiring MFC
//              support, use MFC_TRY and MFC_CATCH instead.
//____________________________________________________________________________
//

#define USE_HANDLE_MACROS(component)                                        \
    static WCHAR* You_forgot_to_declare_USE_HANDLE_MACROS = L"component";

#define STANDARD_TRY                                                        \
    try {

#define MFC_TRY                                                             \
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));                           \
    STANDARD_TRY

//
// CODEWORK don't quite have ENDMETHOD_READBLOCK working yet
//
#ifdef DEBUG
#define ENDMETHOD_STRING                                                    \
    "%s: The unexpected error can be identified as \"%s\" context %n\n"
#define ENDMETHOD_READBLOCK                                                 \
    {                                                                       \
        WCHAR szError[MAX_PATH];                                            \
        UINT nHelpContext = 0;                                              \
        if ( e->GetErrorMessage( szError, MAX_PATH, &nHelpContext ) )       \
        {                                                                   \
            TRACE( ENDMETHOD_STRING,                                        \
                You_forgot_to_declare_USE_HANDLE_MACROS,                    \
                szError,                                                    \
                nHelpContext );                                             \
        }                                                                   \
    }
#else
#define ENDMETHOD_READBLOCK
#endif


#define ERRSTRING_MEMORY       L"%s: An out-of-memory error occurred\n"
#define ERRSTRING_FILE         L"%s: File error 0x%lx occurred on file \"%s\"\n"
#define ERRSTRING_OLE          L"%s: OLE error 0x%lx occurred\n"
#define ERRSTRING_UNEXPECTED   L"%s: An unexpected error occurred\n"
#define BADPARM_STRING         L"%s: Bad string parameter\n"
#define BADPARM_POINTER        L"%s: Bad pointer parameter\n"

#define TRACEERR(s) TRACE( s, You_forgot_to_declare_USE_HANDLE_MACROS )
#define TRACEERR1(s,a) TRACE( s, You_forgot_to_declare_USE_HANDLE_MACROS,a )
#define TRACEERR2(s,a,b) TRACE( s, You_forgot_to_declare_USE_HANDLE_MACROS,a,b )

// Note that it is important to use "e->Delete();" and not "delete e;"
#define STANDARD_CATCH                                                      \
    }                                                                       \
    catch (CMemoryException* e)                                             \
    {                                                                       \
        TRACEERR( ERRSTRING_MEMORY );                                       \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
        return E_OUTOFMEMORY;                                               \
    }                                                                       \
    catch (COleException* e)                                                \
    {                                                                       \
        HRESULT hr = (HRESULT)e->Process(e);                                \
        TRACEERR1( ERRSTRING_OLE, hr );                                     \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
        ASSERT( FAILED(hr) );                                               \
        return hr;                                                          \
    }                                                                       \
    catch (CFileException* e)                                               \
    {                                                                       \
        HRESULT hr = (HRESULT)e->m_lOsError;                                \
        TRACEERR2( ERRSTRING_FILE, hr, e->m_strFileName );                  \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
        ASSERT( FAILED(hr) );                                               \
        return hr;                                                          \
    }                                                                       \
    catch (CException* e)                                                   \
    {                                                                       \
        TRACEERR( ERRSTRING_UNEXPECTED );                                   \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
        return E_UNEXPECTED;                                                \
    }

#define MFC_CATCH_HR_RETURN                                                 \
    STANDARD_CATCH

#define MFC_CATCH_HR                                                        \
    }                                                                       \
    catch (CMemoryException* e)                                             \
    {                                                                       \
        TRACEERR( ERRSTRING_MEMORY );                                       \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
        hr = E_OUTOFMEMORY;                                               \
    }                                                                       \
    catch (COleException* e)                                                \
    {                                                                       \
        hr = (HRESULT)e->Process(e);                                \
        TRACEERR1( ERRSTRING_OLE, hr );                                     \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
        ASSERT( FAILED(hr) );                                               \
    }                                                                       \
    catch (CFileException* e)                                               \
    {                                                                       \
        hr = (HRESULT)e->m_lOsError;                                        \
        TRACEERR2( ERRSTRING_FILE, hr, e->m_strFileName );                  \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
        ASSERT( FAILED(hr) );                                               \
    }                                                                       \
    catch (CException* e)                                                   \
    {                                                                       \
        TRACEERR( ERRSTRING_UNEXPECTED );                                   \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
        hr = E_UNEXPECTED;                                                  \
    }

#define MFC_CATCH_DWSTATUS                                                  \
    }                                                                       \
    catch (CMemoryException* e)                                             \
    {                                                                       \
        dwStatus = ERROR_OUTOFMEMORY;                                       \
        TRACEERR( ERRSTRING_MEMORY );                                       \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
    }                                                                       \
    catch (COleException* e)                                                \
    {                                                                       \
        dwStatus = e->Process(e);                                           \
        TRACEERR1( ERRSTRING_OLE, dwStatus );                               \
        ASSERT( ERROR_SUCCESS != dwStatus );                                \
        e->Delete();                                                        \
    }                                                                       \
    catch (CFileException* e)                                               \
    {                                                                       \
        dwStatus = e->m_lOsError;                                           \
        TRACEERR2( ERRSTRING_FILE, dwStatus, e->m_strFileName );            \
        ASSERT( ERROR_SUCCESS != dwStatus );                                \
        e->Delete();                                                        \
    }                                                                       \
    catch (CException* e)                                                   \
    {                                                                       \
        dwStatus = GetLastError();                                          \
        TRACEERR( ERRSTRING_UNEXPECTED );                                   \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
    }

#define MFC_CATCH_MINIMUM                                                   \
    }                                                                       \
    catch ( ... )                                                           \
    {                                                                       \
        TRACEERR( ERRSTRING_MEMORY );                                       \
    }                                                                       \

VOID
InvokeWinHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    const CString& rstrHelpFileName,
    DWORD   adwControlIdToHelpIdMap[]);

DWORD __stdcall
IsCommandFilePathValid (    
    CString&  rstrPath );

BOOL
FileNameIsValid(
    CString* pstrFileName );

DWORD _stdcall
FormatSystemMessage (
    DWORD       dwMessageId,
    CString&    rstrSystemMessage );


BOOL _stdcall
wGUIDFromString (
    LPCWSTR lpsz, 
    LPGUID pguid );


void _stdcall
KillString( CString& str );

#endif // __GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\ipropbag.h ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    ipropbag.h

Abstract:

    Header file for the private IPropertyBag interface.

--*/

#ifndef _IPROPBAG_H_
#define _IPROPBAG_H_

// Disable 64-bit warnings in atlctl.h
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4510 )
#pragma warning ( disable : 4610 )
#pragma warning ( disable : 4100 )
#include <atlctl.h>
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif
        
// Property Bag Class
class CImpIPropertyBag: 
	public IPropertyBag,
	public CComObjectRoot

{

    public:
DECLARE_NOT_AGGREGATABLE(CImpIPropertyBag)

BEGIN_COM_MAP(CImpIPropertyBag)
    COM_INTERFACE_ENTRY(IPropertyBag)
END_COM_MAP_X()
        
                CImpIPropertyBag();
        virtual ~CImpIPropertyBag(void);

        //IUnknown overrides
        STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG, AddRef) ();
        STDMETHOD_(ULONG, Release) ();

        //IConnectionPoint methods
        STDMETHOD(Read)(LPCOLESTR, VARIANT*, IErrorLog* );
        STDMETHOD(Write)(LPCOLESTR, VARIANT* );

        //Members not exposed by IPropertyBag
        LPWSTR  GetData ( void );
        DWORD   LoadData ( LPWSTR pszData, LPWSTR* ppszNextData = NULL );

    private:

        typedef struct _param_data {
            _param_data*    pNextParam; 
            WCHAR           pszPropertyName[MAX_PATH+1];
            VARIANT         vValue;
        } PARAM_DATA, *PPARAM_DATA;

        enum eConstants {
            eDefaultBufferLength = 8192
        };

        PPARAM_DATA FindProperty ( LPCWSTR pszPropName );
        void        DataListAddHead ( PPARAM_DATA );
        PPARAM_DATA DataListRemoveHead ( void );

        ULONG           m_cRef;        //Object reference count
        LPUNKNOWN       m_pUnkOuter;   //Controlling unknown
        LPWSTR          m_pszData;
        DWORD           m_dwCurrentDataLength;
        PPARAM_DATA     m_plistData;
        HINSTANCE       m_hModule;
};

typedef CImpIPropertyBag *PCImpIPropertyBag;

#endif // _IPROPBAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\logwarnd.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

     LogWarnd.h

Abstract:

    Class definition for the expensive trace data warning dialog.

--*/

#ifndef _LOGWARND_H_
#define _LOGWARND_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Dialog controls
#define IDD_LOGTYPEWARN                     1400

#define IDC_LWARN_MSG_WARN                  1401
#define IDC_LWARN_FIRST_HELP_CTRL_ID        1402
#define IDC_LWARN_CHECK_NO_MORE_LOG_TYPE    1402

#define SMONCTRL_LOG                    10
#define ID_ERROR_COUNTER_LOG            0
#define ID_ERROR_TRACE_LOG              1
#define ID_ERROR_ALERT_LOG              2
#define ID_ERROR_SMONCTRL_LOG           3
#define ID_ERROR_UNKNOWN_LOG            4

/////////////////////////////////////////////////////////////////////////////
// CLogWarnd dialog
    
class CLogWarnd: public CDialog
{
// Construction
public:
                    CLogWarnd(CWnd* pParent = NULL);   // standard constructor
    virtual         ~CLogWarnd(){};

    void    SetTitleString ( CString& strTitle ) { m_strTitle = strTitle; };

// Dialog Data
    //{{AFX_DATA(CLogWarnd)
    enum { IDD = IDD_LOGTYPEWARN };
    BOOL    m_CheckNoMore;
    INT m_ErrorMsg;
    DWORD   m_dwLogType;
    HKEY    m_hKey;
    CString m_strContextHelpFile;
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLogWarnd)
    protected:
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CLogWarnd)
    afx_msg void OnCheckNoMoreLogType();
    afx_msg BOOL OnHelpInfo( HELPINFO* );
    afx_msg void OnContextMenu( CWnd*, CPoint );

    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CString m_strTitle;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // _LOGWARND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\globals.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    GLOBALS.CPP

Abstract:

    Utility methods for the Performance Logs and Alerts MMC snap-in.

--*/

#include "stdAfx.h"
#include <pdhmsg.h>         // For CreateSampleFileName
#include <pdhp.h>           // For CreateSampleFileName
#include "smcfgmsg.h"
#include "globals.h"

USE_HANDLE_MACROS("SMLOGCFG(globals.cpp)");

extern "C" {
    WCHAR GUIDSTR_TypeLibrary[] = {L"{7478EF60-8C46-11d1-8D99-00A0C913CAD4}"};
    WCHAR GUIDSTR_ComponentData[] = {L"{7478EF61-8C46-11d1-8D99-00A0C913CAD4}"};
    WCHAR GUIDSTR_Component[] = {L"{7478EF62-8C46-11d1-8D99-00A0C913CAD4}"};
    WCHAR GUIDSTR_RootNode[] = {L"{7478EF63-8C46-11d1-8D99-00A0C913CAD4}"};
    WCHAR GUIDSTR_MainNode[] = {L"{7478EF64-8C46-11d1-8D99-00A0C913CAD4}"}; // Obsolete after Beta 3 
    WCHAR GUIDSTR_SnapInExt[] = {L"{7478EF65-8C46-11d1-8D99-00A0C913CAD4}"};
    WCHAR GUIDSTR_CounterMainNode[] = {L"{7478EF66-8C46-11d1-8D99-00A0C913CAD4}"};
    WCHAR GUIDSTR_TraceMainNode[] = {L"{7478EF67-8C46-11d1-8D99-00A0C913CAD4}"};
    WCHAR GUIDSTR_AlertMainNode[] = {L"{7478EF68-8C46-11d1-8D99-00A0C913CAD4}"};
    WCHAR GUIDSTR_PerformanceAbout[] = {L"{7478EF69-8C46-11d1-8D99-00A0C913CAD4}"};
};


HINSTANCE g_hinst;           // Global instance handle
CRITICAL_SECTION g_critsectInstallDefaultQueries;


const COMBO_BOX_DATA_MAP TimeUnitCombo[] = 
{
    {SLQ_TT_UTYPE_SECONDS,   IDS_SECONDS},
    {SLQ_TT_UTYPE_MINUTES,   IDS_MINUTES},
    {SLQ_TT_UTYPE_HOURS,     IDS_HOURS},
    {SLQ_TT_UTYPE_DAYS,      IDS_DAYS}
};
const DWORD dwTimeUnitComboEntries = sizeof(TimeUnitCombo)/sizeof(TimeUnitCombo[0]);


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfMmcMachineName clipboard format
// 
CDataObject*
ExtractOwnDataObject
(
 LPDATAOBJECT lpDataObject      // [in] IComponent pointer 
 )
{
    HGLOBAL      hGlobal;
    HRESULT      hr  = S_OK;
    CDataObject* pDO = NULL;
    
    hr = ExtractFromDataObject( lpDataObject,
        CDataObject::s_cfInternal, 
        sizeof(CDataObject **),
        &hGlobal
        );
    
    if( SUCCEEDED(hr) )
    {
        pDO = *(CDataObject **)(hGlobal);
        ASSERT( NULL != pDO );    
       
        VERIFY ( NULL == GlobalFree(hGlobal) ); // Must return NULL
    }
    
    return pDO;
    
} // end ExtractOwnDataObject()

//---------------------------------------------------------------------------
//  Extracts data based on the passed-in clipboard format
//
HRESULT
ExtractFromDataObject
(
 LPDATAOBJECT lpDataObject,   // [in]  Points to data object
 UINT         cfClipFormat,   // [in]  Clipboard format to use
 ULONG        nByteCount,     // [in]  Number of bytes to allocate
 HGLOBAL      *phGlobal       // [out] Points to the data we want 
 )
{
    ASSERT( NULL != lpDataObject );
    
    HRESULT hr = S_OK;
    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { (USHORT)cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    
    *phGlobal = NULL;
    
    do 
    {
        // Allocate memory for the stream
        stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, nByteCount );
        
        if( !stgmedium.hGlobal )
        {
            hr = E_OUTOFMEMORY;
            LOCALTRACE( L"Out of memory\n" );
            break;
        }
        
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );
        if (FAILED(hr))
        {
            break;       
        }
        
        // stgmedium now has the data we need 
        *phGlobal = stgmedium.hGlobal;
        stgmedium.hGlobal = NULL;
        
    } while (0); 
    
    if (FAILED(hr) && stgmedium.hGlobal)
    {
        VERIFY ( NULL == GlobalFree(stgmedium.hGlobal)); // Must return NULL
    }
    return hr;
    
} // end ExtractFromDataObject()

//---------------------------------------------------------------------------
//
VOID DisplayError( LONG nErrorCode, LPWSTR wszDlgTitle )
{
    LPVOID lpMsgBuf = NULL;
    ::FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        nErrorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
        (LPWSTR)&lpMsgBuf,
        0,
        NULL
        );
    if (lpMsgBuf) {
        ::MessageBox( NULL, (LPWSTR)lpMsgBuf, wszDlgTitle,
                      MB_OK|MB_ICONINFORMATION );
        LocalFree( lpMsgBuf );
    }
    
} // end DisplayError()

VOID DisplayError( LONG nErrorCode, UINT nTitleString )
{
    CString strTitle;
    LPVOID lpMsgBuf = NULL;
    ResourceStateManager    rsm;

    ::FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        nErrorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
        (LPWSTR)&lpMsgBuf,
        0,
        NULL
        );
    strTitle.LoadString ( nTitleString );
    if (lpMsgBuf) {
        ::MessageBox( NULL, (LPWSTR)lpMsgBuf, (LPCWSTR)strTitle,
                      MB_OK|MB_ICONINFORMATION );
        LocalFree( lpMsgBuf );
    }
    
} // end DisplayError()


//---------------------------------------------------------------------------
//  Debug only message box
//
int DebugMsg( LPWSTR wszMsg, LPWSTR wszTitle )
{
    int nRetVal = 0;
    wszMsg;
    wszTitle;
#ifdef _DEBUG
    nRetVal = ::MessageBox( NULL, wszMsg, wszTitle, MB_OK );
#endif
    return nRetVal;
}


//---------------------------------------------------------------------------
//  Extracts data based on the passed-in clipboard format

HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType )
{
    HGLOBAL      hGlobal;
    HRESULT      hr  = S_OK;
    
    hr = ExtractFromDataObject( piDataObject,
        CDataObject::s_cfNodeType, 
        sizeof(GUID),
        &hGlobal
        );
    if( SUCCEEDED(hr) )
    {
        *pguidObjectType = *(GUID*)(hGlobal);
        ASSERT( NULL != pguidObjectType );    
        
        VERIFY ( NULL == GlobalFree(hGlobal) ); // Must return NULL
    }
    
    return hr;
}

HRESULT 
ExtractMachineName( 
                   IDataObject* piDataObject, 
                   CString& rstrMachineName )
{
    
    HRESULT hr = S_OK;
    HGLOBAL hMachineName;
    
    hr = ExtractFromDataObject(piDataObject, 
        CDataObject::s_cfMmcMachineName, 
        sizeof(WCHAR) * (MAX_PATH + 1),
        &hMachineName);
    if( SUCCEEDED(hr) )
    {
        
        LPWSTR pszNewData = reinterpret_cast<LPWSTR>(hMachineName);
        if (NULL == pszNewData)
        {
            ASSERT(FALSE);
            hr = E_UNEXPECTED;
        } else {
            //
            // Null terminate just to be safe.
            //
            pszNewData[MAX_PATH] = L'\0'; 
            
            rstrMachineName = pszNewData;
            
            VERIFY ( NULL == GlobalFree(hMachineName) ); // Must return NULL
        }
    }
    return hr;
}

DWORD __stdcall
CreateSampleFileName ( 
    const   CString&  rstrQueryName, 
    const   CString&  rstrMachineName, 
    const CString&  rstrFolderName,
    const CString&  rstrInputBaseName,
    const CString&  rstrSqlName,
    DWORD    dwSuffixValue,
    DWORD    dwLogFileTypeValue,
    DWORD    dwCurrentSerialNumber,
    CString& rstrReturnName)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    PPDH_PLA_INFO  pInfo = NULL;
    DWORD dwStrBufLen = 0;
    DWORD dwInfoSize = 0;
    DWORD dwFlags = 0;

    rstrReturnName.Empty();

    dwStatus = PdhPlaGetInfo( 
       (LPWSTR)(LPCWSTR)rstrQueryName, 
       (LPWSTR)(LPCWSTR)rstrMachineName, 
       &dwInfoSize, 
       pInfo );
    if( ERROR_SUCCESS == dwStatus && 0 != dwInfoSize ){
        pInfo = (PPDH_PLA_INFO)malloc(dwInfoSize);
        if( NULL != pInfo && (sizeof(PDH_PLA_INFO) <= dwInfoSize) ){
            ZeroMemory( pInfo, dwInfoSize );

            pInfo->dwMask = PLA_INFO_CREATE_FILENAME;

            dwStatus = PdhPlaGetInfo( 
                        (LPWSTR)(LPCWSTR)rstrQueryName, 
                        (LPWSTR)(LPCWSTR)rstrMachineName, 
                        &dwInfoSize, 
                        pInfo );
            
            pInfo->dwMask = PLA_INFO_CREATE_FILENAME;
            
			pInfo->dwFileFormat = dwLogFileTypeValue;
            pInfo->strBaseFileName = (LPWSTR)(LPCWSTR)rstrInputBaseName;
            pInfo->dwAutoNameFormat = dwSuffixValue;
            // PLA_INFO_FLAG_TYPE is counter log vs trace log vs alert
            pInfo->strDefaultDir = (LPWSTR)(LPCWSTR)rstrFolderName;
            pInfo->dwLogFileSerialNumber = dwCurrentSerialNumber;
            pInfo->strSqlName = (LPWSTR)(LPCWSTR)rstrSqlName;
            pInfo->dwLogFileSerialNumber = dwCurrentSerialNumber;

            // Create file name based on passed parameters only.
            dwFlags = PLA_FILENAME_CREATEONLY;      // PLA_FILENAME_CURRENTLOG for latest run log

            dwStatus = PdhPlaGetLogFileName (
                    (LPWSTR)(LPCWSTR)rstrQueryName,
                    (LPWSTR)(LPCWSTR)rstrMachineName, 
                    pInfo,
                    dwFlags,
                    &dwStrBufLen,
                    NULL );

            if ( ERROR_SUCCESS == dwStatus || PDH_INSUFFICIENT_BUFFER == dwStatus ) {
                dwStatus = PdhPlaGetLogFileName (
                        (LPWSTR)(LPCWSTR)rstrQueryName, 
                        (LPWSTR)(LPCWSTR)rstrMachineName, 
                        pInfo,
                        dwFlags,
                        &dwStrBufLen,
                        rstrReturnName.GetBufferSetLength ( dwStrBufLen ) );
                rstrReturnName.ReleaseBuffer();
            }
        }
    }

    if ( NULL != pInfo ) { 
        free( pInfo );
    }
    return dwStatus;
}


DWORD __stdcall
IsDirPathValid (    
    CString&  rstrDefault,
    CString&  rstrPath,
    BOOL bLastNameIsDirectory,
    BOOL bCreateMissingDirs,
    BOOL& rbIsValid )
/*++

Routine Description:

    Creates the directory specified in szPath and any other "higher"
        directories in the specified path that don't exist.

Arguments:
    IN  CString rstrDefault
        The default log file folder

    IN  CString rstrPath
        directory path to create (assumed to be a DOS path, not a UNC)

    IN  BOOL bLastNameIsDirectory
        TRUE when the last name in the path is a Directory and not a File
        FALSE if the last name is a file

    IN  BOOL bCreateMissingDirs
        TRUE will create any dirs in the path that are not found
        FALSE will only test for existence and not create any
            missing dirs.

    OUT BOOL rbIsValid
        TRUE    if the directory path now exists
        FALSE   if error (GetLastError to find out why)

Return Value:

    DWSTATUS
--*/
{
    CString  strLocalPath;
    LPWSTR   szLocalPath;
    LPWSTR   szEnd;
    DWORD    dwAttr;
    WCHAR    cBackslash = L'\\';
    DWORD    dwStatus = ERROR_SUCCESS;

    rbIsValid = FALSE;

    szLocalPath = strLocalPath.GetBufferSetLength ( MAX_PATH );
    
    if ( NULL == szLocalPath ) {
        dwStatus = ERROR_OUTOFMEMORY;
    } else {

        if (GetFullPathName (
                rstrPath,
                MAX_PATH,
                szLocalPath,
                NULL) > 0) {

            //
            // Check for prefix
            //
            // Go one past the first backslash after the drive or remote machine name
            // N.B. We are assuming the full path name looks like either "\\machine\share\..."
            //      or "C:\xxx". How about "\\?\xxx" style names
            //
            if ( cBackslash == szLocalPath[0] && cBackslash == szLocalPath[1] ) {
                szEnd = &szLocalPath[2];
                while ((*szEnd != cBackslash) && (*szEnd != 0) ) szEnd++;

                if ( cBackslash == *szEnd ) {
                    szEnd++;
                }
            } else {
                szEnd = &szLocalPath[3];
            }

            if (*szEnd != L'\0') {
                int  iPathLen;
  
                iPathLen = lstrlen(szEnd) - 1;
                while (iPathLen >= 0 && cBackslash == szEnd[iPathLen]) {
                    szEnd[iPathLen] = L'\0';
                    iPathLen -= 1;
                } 
                // then there are sub dirs to create
                while (*szEnd != L'\0') {
                    // go to next backslash
                    while ((*szEnd != cBackslash) && (*szEnd != L'\0')) szEnd++;
                    if (*szEnd == cBackslash) {
                        // terminate path here and create directory
                        *szEnd = L'\0';
                        if (bCreateMissingDirs) {
                            if (!CreateDirectory (szLocalPath, NULL)) {
                                // see what the error was and "adjust" it if necessary
                                dwStatus = GetLastError();
                                if ( ERROR_ALREADY_EXISTS == dwStatus ) {
                                    // this is OK
                                    dwStatus = ERROR_SUCCESS;
                                    rbIsValid = TRUE;
                                } else {
                                    rbIsValid = FALSE;
                                }
                            } else {
                                // directory created successfully so update count
                                rbIsValid = TRUE;
                            }
                        } else {
                            if ((dwAttr = GetFileAttributes(szLocalPath)) != 0xFFFFFFFF) {
                                //
                                // make sure it's a dir
                                // N.B. Why not simply use if (dwAttr & FILE_ATTRIBUTE_DIRECTORY)??
                                //      Special purpose?
                                //
                                if ((dwAttr & FILE_ATTRIBUTE_DIRECTORY) ==
                                    FILE_ATTRIBUTE_DIRECTORY) {
                                    rbIsValid = TRUE;
                                } else {
                                    // if any dirs fail, then clear the return value
                                    rbIsValid = FALSE;
                                }
                            } else {
                                // if any dirs fail, then clear the return value
                                rbIsValid = FALSE;
                            }
                        }
                        // replace backslash and go to next dir
                        *szEnd++ = cBackslash;
                    }
                }

                // create last dir in path now if it's a dir name and not a filename
                if (bLastNameIsDirectory) {
                    if (bCreateMissingDirs) {
                        BOOL fDirectoryCreated;

                        rstrDefault.MakeLower();
                        strLocalPath.MakeLower(); 
                        if (rstrDefault == strLocalPath) {
                            fDirectoryCreated = PerfCreateDirectory (szLocalPath);
                        } else {
                            fDirectoryCreated = CreateDirectory (szLocalPath, NULL);
                        }
                        if (!fDirectoryCreated) {
                            // see what the error was and "adjust" it if necessary
                            dwStatus = GetLastError();
                            if ( ERROR_ALREADY_EXISTS == dwStatus ) {
                                // this is OK
                                dwStatus = ERROR_SUCCESS;
                                rbIsValid = TRUE;
                            } else {
                                rbIsValid = FALSE;
                            }
                        } else {
                            // directory created successfully
                            rbIsValid = TRUE;
                        }
                    } else {
                        if ((dwAttr = GetFileAttributes(szLocalPath)) != 0xFFFFFFFF) {
                            //
                            // make sure it's a dir
                            // N.B. Why not simply use if (dwAttr & FILE_ATTRIBUTE_DIRECTORY)??
                            //      Special purpose?
                            //
                            if ((dwAttr & FILE_ATTRIBUTE_DIRECTORY) ==
                                FILE_ATTRIBUTE_DIRECTORY) {
                                rbIsValid = TRUE;
                            } else {
                                // if any dirs fail, then clear the return value
                                rbIsValid = FALSE;
                            }
                        } else {
                            // if any dirs fail, then clear the return value
                            rbIsValid = FALSE;
                        }
                    }
                }
            } else {
                // else this is a root dir only so return success.
                dwStatus = ERROR_SUCCESS;
                rbIsValid = TRUE;
            }
        }
        strLocalPath.ReleaseBuffer();
    }
        
    return dwStatus;
}

DWORD __stdcall
ProcessDirPath (    
    const CString&  rstrDefault,
    CString&  rstrPath,
    const CString& rstrLogName,
    CWnd* pwndParent,
    BOOL& rbIsValid,
    BOOL  bOnFilesPage )
{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD cchLen;
    CString strExpanded;
    CString strDefaultFolder;
    LPWSTR  szExpanded;
    DWORD   cchExpandedLen;
    ResourceStateManager    rsm;

    // Parse all environment symbols    
    cchLen = 0;

    cchLen = ExpandEnvironmentStrings ( rstrPath, NULL, 0 );

    if ( 0 < cchLen ) {

        MFC_TRY
            //
            // CString size does not include NULL.
            // cchLen includes NULL.  Include NULL count for safety.
            //
            szExpanded = strExpanded.GetBuffer ( cchLen );
        MFC_CATCH_DWSTATUS;

        if ( ERROR_SUCCESS == dwStatus ) {
            cchExpandedLen = ExpandEnvironmentStrings (
                        rstrPath, 
                        szExpanded,
                        cchLen);
            
            if ( 0 == cchExpandedLen ) {
                dwStatus = GetLastError();
            }
        }
        strExpanded.ReleaseBuffer();

    } else {
        dwStatus = GetLastError();
    }


    if ( ERROR_SUCCESS == dwStatus ) {
        //
        // Get the default log file folder.(It must have already been expanded)
        //
        strDefaultFolder = rstrDefault;
        dwStatus = IsDirPathValid (strDefaultFolder,
                                   strExpanded, 
                                   TRUE, 
                                   FALSE, 
                                   rbIsValid);
    }

    if ( ERROR_SUCCESS != dwStatus ) {
        rbIsValid = FALSE;
    } else {
        if ( !rbIsValid ) {        
            INT nMbReturn;
            CString strMessage;
            
            MFC_TRY
                strMessage.Format ( IDS_FILE_DIR_NOT_FOUND, rstrPath );
                nMbReturn = pwndParent->MessageBox ( strMessage, rstrLogName, MB_YESNO | MB_ICONWARNING );
                if (nMbReturn == IDYES) {
                    // create the dir(s)
                    dwStatus = IsDirPathValid (strDefaultFolder,
                                               strExpanded, 
                                               TRUE, 
                                               TRUE, 
                                               rbIsValid);
                    if (ERROR_SUCCESS != dwStatus || !rbIsValid ) {
                        // unable to create the dir, display message
                        if ( bOnFilesPage ) {
                            strMessage.Format ( IDS_FILE_DIR_NOT_MADE, rstrPath );
                        } else {
                            strMessage.Format ( IDS_DIR_NOT_MADE, rstrPath );
                        }
                        nMbReturn = pwndParent->MessageBox ( strMessage, rstrLogName, MB_OK  | MB_ICONERROR);
                        rbIsValid = FALSE;
                    }
                } else if ( IDNO == nMbReturn ) {
                    // then abort and return to the dialog
                    if ( bOnFilesPage ) {
                        strMessage.LoadString ( IDS_FILE_DIR_CREATE_CANCEL );
                    } else {
                        strMessage.LoadString ( IDS_DIR_CREATE_CANCEL );
                    }
                    nMbReturn = pwndParent->MessageBox ( strMessage, rstrLogName, MB_OK  | MB_ICONINFORMATION);
                    rbIsValid = FALSE;
                } 
            MFC_CATCH_DWSTATUS
        } // else the path is OK
    }

    return dwStatus;
}

DWORD __stdcall
IsCommandFilePathValid (    
    CString&  rstrPath )
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    ResourceStateManager rsm;

    if ( !rstrPath.IsEmpty() ) {
    
        HANDLE hOpenFile;

        hOpenFile =  CreateFile (
                        rstrPath,
                        GENERIC_READ,
                        0,              // Not shared
                        NULL,           // Security attributes
                        OPEN_EXISTING,  //
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

        if ( ( NULL == hOpenFile ) 
                || INVALID_HANDLE_VALUE == hOpenFile ) {
            dwStatus = SMCFG_NO_COMMAND_FILE_FOUND;
        } else {
            CloseHandle(hOpenFile);
        }
    } else {
        dwStatus = SMCFG_NO_COMMAND_FILE_FOUND;
    }
    return dwStatus;
}

INT __stdcall
BrowseCommandFilename ( 
    CWnd* pwndParent,
    CString&  rstrFilename )
{
    INT iReturn  = IDCANCEL;
    OPENFILENAME    ofn;
    CString         strInitialDir;
    WCHAR           szFileName[MAX_PATH + 1];
    WCHAR           szDrive[MAX_PATH + 1];
    WCHAR           szDir[MAX_PATH + 1];
    WCHAR           szExt[MAX_PATH + 1];
    WCHAR           szFileFilter[MAX_PATH + 1];
    LPWSTR          szNextFilter;
    CString         strTemp;

    ResourceStateManager    rsm;

    _wsplitpath((LPCWSTR)rstrFilename,
        szDrive, szDir, szFileName, szExt);

    strInitialDir = szDrive;
    strInitialDir += szDir;

    lstrcat (szFileName, szExt);

    ZeroMemory( &ofn, sizeof( OPENFILENAME ) );

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = pwndParent->m_hWnd;
    ofn.hInstance = GetModuleHandle(NULL);
    // load the file filter MSZ
    szNextFilter = &szFileFilter[0];
    strTemp.LoadString ( IDS_BROWSE_CMD_FILE_FILTER1 );
    lstrcpyW (szNextFilter, (LPCWSTR)strTemp);
    szNextFilter += strTemp.GetLength();
    *szNextFilter++ = 0;
    strTemp.LoadString ( IDS_BROWSE_CMD_FILE_FILTER2 );
    lstrcpyW (szNextFilter, (LPCWSTR)strTemp);
    szNextFilter += strTemp.GetLength();
    *szNextFilter++ = 0;
    strTemp.LoadString ( IDS_BROWSE_CMD_FILE_FILTER3 );
    lstrcpyW (szNextFilter, (LPCWSTR)strTemp);
    szNextFilter += strTemp.GetLength();
    *szNextFilter++ = 0;
    strTemp.LoadString ( IDS_BROWSE_CMD_FILE_FILTER4 );
    lstrcpyW (szNextFilter, (LPCWSTR)strTemp);
    szNextFilter += strTemp.GetLength();
    *szNextFilter++ = 0;
    *szNextFilter++ = 0; // msz terminator
    ofn.lpstrFilter = szFileFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1; // nFilterIndex is 1-based
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = (LPCWSTR)strInitialDir;
    strTemp.LoadString( IDS_BROWSE_CMD_FILE_CAPTION );
    ofn.lpstrTitle = (LPCWSTR)strTemp;
    ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = NULL;
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    iReturn = GetOpenFileName (&ofn);

    if ( IDOK == iReturn ) {
        // Update the fields with the new information
        rstrFilename = szFileName;
    } // else ignore if they canceled out

    return iReturn;
}

DWORD __stdcall 
FormatSmLogCfgMessage ( 
    CString& rstrMessage,
    HINSTANCE hResourceHandle,
    UINT uiMessageId,
    ... )
{
    DWORD dwStatus = ERROR_SUCCESS;
    LPWSTR lpszTemp = NULL;


    // format message into temporary buffer lpszTemp
    va_list argList;
    va_start(argList, uiMessageId);

    dwStatus = ::FormatMessage ( 
                    FORMAT_MESSAGE_FROM_HMODULE 
                        | FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_MAX_WIDTH_MASK, 
                    hResourceHandle,
                    uiMessageId,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (LPWSTR)&lpszTemp,
                    0,
                    &argList );

    if ( 0 != dwStatus && NULL != lpszTemp ) {
        rstrMessage.GetBufferSetLength( lstrlen (lpszTemp) + 1 );
        rstrMessage.ReleaseBuffer();
        rstrMessage = lpszTemp;
    } else {
        dwStatus = GetLastError();
    }

    if ( NULL != lpszTemp ) {
        LocalFree( lpszTemp);
        lpszTemp = NULL;
    }

    va_end(argList);

    return dwStatus;
}

BOOL __stdcall 
FileRead (
    HANDLE hFile,
    void* lpMemory,
    DWORD nAmtToRead)
{  
    BOOL           bSuccess ;
    DWORD          nAmtRead ;

    bSuccess = ReadFile (hFile, lpMemory, nAmtToRead, &nAmtRead, NULL) ;
    return (bSuccess && (nAmtRead == nAmtToRead)) ;
}  // FileRead


BOOL __stdcall
FileWrite (
    HANDLE hFile,
    void* lpMemory,
    DWORD nAmtToWrite)
{  
   BOOL           bSuccess = FALSE;
   DWORD          nAmtWritten  = 0;
   DWORD          dwFileSizeLow, dwFileSizeHigh;
   LONGLONG       llResultSize;
    
   dwFileSizeLow = GetFileSize (hFile, &dwFileSizeHigh);
   // limit file size to 2GB

   if (dwFileSizeHigh > 0) {
      SetLastError (ERROR_WRITE_FAULT);
      bSuccess = FALSE;
   } else {
      // note that the error return of this function is 0xFFFFFFFF
      // since that is > the file size limit, this will be interpreted
      // as an error (a size error) so it's accounted for in the following
      // test.
      llResultSize = dwFileSizeLow + nAmtToWrite;
      if (llResultSize >= 0x80000000) {
          SetLastError (ERROR_WRITE_FAULT);
          bSuccess = FALSE;
      } else {
          // write buffer to file
          bSuccess = WriteFile (hFile, lpMemory, nAmtToWrite, &nAmtWritten, NULL) ;
          if (bSuccess) bSuccess = (nAmtWritten == nAmtToWrite ? TRUE : FALSE);
      }
   }

   return (bSuccess) ;
}  // FileWrite


static 
DWORD _stdcall
CheckDuplicateInstances (
    PDH_COUNTER_PATH_ELEMENTS* pFirst,
    PDH_COUNTER_PATH_ELEMENTS* pSecond )
{
    DWORD dwStatus = ERROR_SUCCESS;

    ASSERT ( 0 == lstrcmpi ( pFirst->szMachineName, pSecond->szMachineName ) ); 
    ASSERT ( 0 == lstrcmpi ( pFirst->szObjectName, pSecond->szObjectName ) );

    if ( 0 == lstrcmpi ( pFirst->szInstanceName, pSecond->szInstanceName ) ) { 
        if ( 0 == lstrcmpi ( pFirst->szParentInstance, pSecond->szParentInstance ) ) { 
            if ( pFirst->dwInstanceIndex == pSecond->dwInstanceIndex ) { 
                dwStatus = SMCFG_DUPL_SINGLE_PATH;
            }
        }
    } else if ( 0 == lstrcmpi ( pFirst->szInstanceName, L"*" ) ) {
        dwStatus = SMCFG_DUPL_FIRST_IS_WILD;
    } else if ( 0 == lstrcmpi ( pSecond->szInstanceName, L"*" ) ) {
        dwStatus = SMCFG_DUPL_SECOND_IS_WILD;
    }

    return dwStatus;
}

//++
// Description:
//     The function checks the relation between two counter paths
//
// Parameter:
//     pFirst - First counter path
//     pSecond - Second counter path
//
// Return:
//     ERROR_SUCCESS - The two counter paths are different
//     SMCFG_DUPL_FIRST_IS_WILD - The first counter path has wildcard name
//     SMCFG_DUPL_SECOND_IS_WILD - The second counter path has wildcard name
//     SMCFG_DUPL_SINGLE_PATH - The two counter paths are the same(may include 
//                              wildcard name) 
//     
//--
DWORD _stdcall
CheckDuplicateCounterPaths (
    PDH_COUNTER_PATH_ELEMENTS* pFirst,
    PDH_COUNTER_PATH_ELEMENTS* pSecond )
{
    DWORD dwStatus = ERROR_SUCCESS;

    if ( 0 == lstrcmpi ( pFirst->szMachineName, pSecond->szMachineName ) ) { 
        if ( 0 == lstrcmpi ( pFirst->szObjectName, pSecond->szObjectName ) ) { 
            if ( 0 == lstrcmpi ( pFirst->szCounterName, pSecond->szCounterName ) ) { 
                dwStatus = CheckDuplicateInstances ( pFirst, pSecond );
            } else if ( 0 == lstrcmpi ( pFirst->szCounterName, L"*" ) 
                    || 0 == lstrcmpi ( pSecond->szCounterName, L"*" ) ) {

                // Wildcard counter.
                BOOL bIsDuplicate = ( ERROR_SUCCESS != CheckDuplicateInstances ( pFirst, pSecond ) );

                if ( bIsDuplicate ) {
                    if ( 0 == lstrcmpi ( pFirst->szCounterName, L"*" ) ) {
                        dwStatus = SMCFG_DUPL_FIRST_IS_WILD;
                    } else if ( 0 == lstrcmpi ( pSecond->szCounterName, L"*" ) ) {
                        dwStatus = SMCFG_DUPL_SECOND_IS_WILD;
                    }
                }
            }
        }
    }

    return dwStatus;
};

// This routine extracts the filename portion from a given full-path filename
LPWSTR _stdcall 
ExtractFileName (LPWSTR pFileSpec)
{
   LPWSTR   pFileName = NULL ;
   WCHAR    DIRECTORY_DELIMITER1 = L'\\' ;
   WCHAR    DIRECTORY_DELIMITER2 = L':' ;

   if (pFileSpec)
      {
      pFileName = pFileSpec + lstrlen (pFileSpec) ;

      while (*pFileName != DIRECTORY_DELIMITER1 &&
         *pFileName != DIRECTORY_DELIMITER2)
         {
         if (pFileName == pFileSpec)
            {
            // done when no directory delimiter is found
            break ;
            }
         pFileName-- ;
         }

      if (*pFileName == DIRECTORY_DELIMITER1 ||
         *pFileName == DIRECTORY_DELIMITER2)
         {
         // directory delimiter found, point the
         // filename right after it
         pFileName++ ;
         }
      }
   return pFileName ;
}  // ExtractFileName

//+--------------------------------------------------------------------------
//
//  Function:   InvokeWinHelp
//
//  Synopsis:   Helper (ahem) function to invoke winhelp.
//
//  Arguments:  [message]                 - WM_CONTEXTMENU or WM_HELP
//              [wParam]                  - depends on [message]
//              [wszHelpFileName]         - filename with or without path
//              [adwControlIdToHelpIdMap] - see WinHelp API
//
//  History:    06-10-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
InvokeWinHelp(
            UINT message,
            WPARAM wParam,
            LPARAM lParam,
    const   CString& rstrHelpFileName,
            DWORD adwControlIdToHelpIdMap[])
{
    
    //TRACE_FUNCTION(InvokeWinHelp);

    ASSERT ( !rstrHelpFileName.IsEmpty() );
    ASSERT ( adwControlIdToHelpIdMap );

    switch (message)
    {
        case WM_CONTEXTMENU:                // Right mouse click - "What's This" context menu
        {
            ASSERT ( wParam );

            if ( 0 != GetDlgCtrlID ( (HWND) wParam ) ) {
                WinHelp(
                    (HWND) wParam,
                    rstrHelpFileName,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)adwControlIdToHelpIdMap);
            }
        }
        break;

    case WM_HELP:                           // Help from the "?" dialog
    {
        const LPHELPINFO pHelpInfo = (LPHELPINFO) lParam;

        if (pHelpInfo ) {
            if ( pHelpInfo->iContextType == HELPINFO_WINDOW ) {
                WinHelp(
                    (HWND) pHelpInfo->hItemHandle,
                    rstrHelpFileName,
                    HELP_WM_HELP,
                    (DWORD_PTR) adwControlIdToHelpIdMap);
            }
        }
        break;
    }

    default:
        //Dbg(DEB_ERROR, "Unexpected message %uL\n", message);
        break;
    }
}

BOOL
FileNameIsValid ( CString* pstrFileName )
{
    LPWSTR pSrc;
    BOOL bRetVal = TRUE;

    if (pstrFileName == NULL) {
        return FALSE;
    }

    pSrc = pstrFileName->GetBuffer(0);

    while (*pSrc != L'\0') {
        if (*pSrc == L'?' ||
            *pSrc == L'\\' ||
            *pSrc == L'*' ||
            *pSrc == L'|' ||
            *pSrc == L'<' ||
            *pSrc == L'>' ||
            *pSrc == L'/' ||
            *pSrc == L':' ||
            *pSrc == L'\"' ) {

            bRetVal = FALSE;
            break;
        }
        pSrc++;
    } 

    return bRetVal;
}

DWORD
FormatSystemMessage (
    DWORD       dwMessageId,
    CString&    rstrSystemMessage )
{
    DWORD dwStatus = ERROR_SUCCESS;
    HINSTANCE hPdh = NULL;
    DWORD dwFlags = 0; 
    LPWSTR  pszMessage = NULL;
    DWORD   dwChars;

    rstrSystemMessage.Empty();

    dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM;

    hPdh = LoadLibrary( L"PDH.DLL" );

    if ( NULL != hPdh ) {
        dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
    }

    dwChars = FormatMessage ( 
                     dwFlags,
                     hPdh,
                     dwMessageId,
                     MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
                     (LPWSTR)&pszMessage,
                     0,
                     NULL );
    if ( NULL != hPdh ) {
        FreeLibrary( hPdh );
    }

    if ( 0 == dwChars ) {
        dwStatus = GetLastError();
    }

    MFC_TRY
        if ( NULL != pszMessage ) {
            if ( L'\0' != pszMessage[0] ) {
                rstrSystemMessage = pszMessage;
            }
        }
    MFC_CATCH_DWSTATUS

    if ( rstrSystemMessage.IsEmpty() ) {
        MFC_TRY
            rstrSystemMessage.Format ( L"0x%08lX", dwMessageId );
        MFC_CATCH_DWSTATUS
    }

    LocalFree ( pszMessage );

    return dwStatus;
}

// The routines below were blatently stolen without remorse from the ole
// sources in \nt\private\ole32\com\class\compapi.cxx. 
//

//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword   (private)
//
//  Synopsis:   scan lpsz for a number of hex digits (at most 8); update lpsz
//              return value in Value; check for chDelim;
//
//  Arguments:  [lpsz]    - the hex string to convert
//              [Value]   - the returned value
//              [cDigits] - count of digits
//
//  Returns:    TRUE for success
//
//--------------------------------------------------------------------------
BOOL HexStringToDword(LPCWSTR lpsz, DWORD * RetValue,
                             int cDigits, WCHAR chDelim)
{
    int Count;
    DWORD Value;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return(FALSE);
    }
    *RetValue = Value;

    if (chDelim != 0)
        return *lpsz++ == chDelim;
    else
        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wUUIDFromString    (internal)
//
//  Synopsis:   Parse UUID such as 00000000-0000-0000-0000-000000000000
//
//  Arguments:  [lpsz]  - Supplies the UUID string to convert
//              [pguid] - Returns the GUID.
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wUUIDFromString(LPCWSTR lpsz, LPGUID pguid)
{
        DWORD dw;

        if (!HexStringToDword(lpsz, &pguid->Data1, sizeof(DWORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(DWORD)*2 + 1;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data2 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data3 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[0] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, '-'))
                return FALSE;
        lpsz += sizeof(BYTE)*2+1;

        pguid->Data4[1] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[2] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[3] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[4] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[5] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[6] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[7] = (BYTE)dw;

        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wGUIDFromString    (internal)
//
//  Synopsis:   Parse GUID such as {00000000-0000-0000-0000-000000000000}
//
//  Arguments:  [lpsz]  - the guid string to convert
//              [pguid] - guid to return
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wGUIDFromString(LPCWSTR lpsz, LPGUID pguid)
{
    if (*lpsz == '{' )
        lpsz++;
    if(wUUIDFromString(lpsz, pguid) != TRUE)
        return FALSE;

    lpsz +=36;

    if (*lpsz == '}' )
        lpsz++;

    if (*lpsz != '\0')   // check for zero terminated string - test bug #18307
    {
       return FALSE;
    }

    return TRUE;
}

void 
KillString( CString& str )
{
    LONG nSize = str.GetLength();
    for( LONG i=0;i<nSize;i++ ){
        str.SetAt( i, '*');
    }
}

ResourceStateManager::ResourceStateManager ()
:   m_hResInstance ( NULL )
{ 
    AFX_MODULE_STATE* pModuleState;
    HINSTANCE hNewResourceHandle;
    pModuleState = AfxGetModuleState();

    if ( NULL != pModuleState ) {
        m_hResInstance = pModuleState->m_hCurrentResourceHandle; 
    
        hNewResourceHandle = (HINSTANCE)GetModuleHandleW (_CONFIG_DLL_NAME_W_);
        pModuleState->m_hCurrentResourceHandle = hNewResourceHandle; 
    }
}

ResourceStateManager::~ResourceStateManager ()
{ 
    AFX_MODULE_STATE* pModuleState;

    pModuleState = AfxGetModuleState();
    if ( NULL != pModuleState ) {
        pModuleState->m_hCurrentResourceHandle = m_hResInstance; 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\newqdlg.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    newqdlg.cpp

Abstract:

    Implementation of the new log/alert creation dialog box.

--*/

#include "stdafx.h"
#include "smlogcfg.h"
#include "smcfghlp.h"
#include "NewQDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("SMLOGCFG(newqdlg.cpp)");

static ULONG
s_aulHelpIds[] =
{
    IDC_NEWQ_NAME_EDIT,     IDH_NEWQ_NAME_EDIT,
    0,0
};

/////////////////////////////////////////////////////////////////////////////
// CNewQueryDlg dialog

void CNewQueryDlg::InitAfxData ()
{
    //{{AFX_DATA_INIT(CNewQueryDlg)
    m_strName = L"";
    //}}AFX_DATA_INIT
}

CNewQueryDlg::CNewQueryDlg(CWnd* pParent /*=NULL*/, BOOL bLogQuery)
    : CDialog(CNewQueryDlg::IDD, pParent)
{
    EnableAutomation();
    InitAfxData ();
    m_bLogQuery = bLogQuery;
}

void CNewQueryDlg::OnFinalRelease()
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CDialog::OnFinalRelease();
}

void CNewQueryDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNewQueryDlg)
    DDX_Text(pDX, IDC_NEWQ_NAME_EDIT, m_strName);
    DDV_MaxChars(pDX, m_strName, (SLQ_MAX_LOG_NAME_LEN));
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewQueryDlg, CDialog)
    //{{AFX_MSG_MAP(CNewQueryDlg)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CNewQueryDlg, CDialog)
    //{{AFX_DISPATCH_MAP(CNewQueryDlg)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_INewQueryDlg to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {4D4C90C3-C5A3-11D1-BF9B-00C04F94A83A}
static const IID IID_INewQueryDlg =
{ 0x4d4c90c3, 0xc5a3, 0x11d1, { 0xbf, 0x9b, 0x0, 0xc0, 0x4f, 0x94, 0xa8, 0x3a } };

BEGIN_INTERFACE_MAP(CNewQueryDlg, CDialog)
    INTERFACE_PART(CNewQueryDlg, IID_INewQueryDlg, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewQueryDlg message handlers

BOOL CNewQueryDlg::OnInitDialog() 
{
    CDialog::OnInitDialog();

    ResourceStateManager    rsm;
    
    if (!m_bLogQuery) {
        CString     csCaption;
        csCaption.LoadString (IDS_CREATE_NEW_ALERT);
        SetWindowText (csCaption);
    }

    // set the focus to the name edit
    GetDlgItem(IDC_NEWQ_NAME_EDIT)->SetFocus();
    SendDlgItemMessage(IDC_NEWQ_NAME_EDIT,EM_SETSEL,0,-1);
    return FALSE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CNewQueryDlg::OnOK() 
{
    INT iPrevLength = 0;
    ResourceStateManager rsm;

    if ( UpdateData (TRUE) ) {
    
        iPrevLength = m_strName.GetLength();
        m_strName.TrimLeft();
        m_strName.TrimRight();

        if ( iPrevLength != m_strName.GetLength() ) {
            SetDlgItemText ( IDC_NEWQ_NAME_EDIT, m_strName );
        }

        if (m_strName.GetLength() == 0) {
            // need a name
            MessageBeep(MB_ICONEXCLAMATION);
            (GetDlgItem(IDC_NEWQ_NAME_EDIT))->SetFocus();
        } else {
            if ( !FileNameIsValid ( &m_strName ) ) {
                CString cstrTitle,cstrMsg;

                cstrTitle.LoadString(IDS_PROJNAME);  
                cstrMsg.LoadString (IDS_ERRMSG_INVALIDCHAR);
                MessageBox(
                   cstrMsg,
                   cstrTitle,
                   MB_OK| MB_ICONERROR);
                (GetDlgItem(IDC_NEWQ_NAME_EDIT))->SetFocus();

            } else {
                CDialog::OnOK();
            }
        }
    }
}

BOOL 
CNewQueryDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if ( pHelpInfo->iCtrlId >= IDC_NEWQ_FIRST_HELP_CTRL_ID ||
         pHelpInfo->iCtrlId == IDOK ||
         pHelpInfo->iCtrlId == IDCANCEL ) {
        
        InvokeWinHelp(WM_HELP, NULL, (LPARAM)pHelpInfo, m_strHelpFilePath, s_aulHelpIds);
    }
    return TRUE;
}

void 
CNewQueryDlg::OnContextMenu(CWnd* pWnd, CPoint /* point */) 
{
    InvokeWinHelp(WM_CONTEXTMENU, (WPARAM)(pWnd->m_hWnd), NULL, m_strHelpFilePath, s_aulHelpIds);

    return;
}

DWORD 
CNewQueryDlg::SetContextHelpFilePath( const CString& rstrPath )
{
    DWORD dwStatus = ERROR_SUCCESS;

    MFC_TRY
        m_strHelpFilePath = rstrPath; 
    MFC_CATCH_DWSTATUS

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\logwarnd.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

     Logwarnd.cpp

Abstract:

    Implementation of the Log Type mismatch warning dialog.

--*/

#include "stdafx.h"
#include <strsafe.h>
#include "smlogcfg.h"
#include "smtraceq.h"
#include "provprop.h"
#include "logwarnd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static ULONG
s_aulHelpIds[] =
{
    IDC_LWARN_CHECK_NO_MORE_LOG_TYPE,  IDH_CHECK_NO_MORE,
    0,0
};

/////////////////////////////////////////////////////////////////////////////
// CLogwarnd dialog


CLogWarnd::CLogWarnd(CWnd* pParent /*=NULL*/)
:   CDialog(CLogWarnd::IDD, pParent)
{
    //{{AFX_DATA_INIT(CLogWarnd)
    m_CheckNoMore = FALSE;
    m_ErrorMsg = 0 ;
    m_dwLogType = 0L;
    //}}AFX_DATA_INIT
}


void CLogWarnd::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CLogWarnd)
    DDX_Check(pDX, IDC_LWARN_CHECK_NO_MORE_LOG_TYPE, m_CheckNoMore);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLogWarnd, CDialog)
    //{{AFX_MSG_MAP(CLogWarnd)
        ON_BN_CLICKED(IDC_LWARN_CHECK_NO_MORE_LOG_TYPE,OnCheckNoMoreLogType)
        ON_WM_HELPINFO()
        ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLogWarnd message handlers
void
CLogWarnd::OnOK()
{
   
    UpdateData(TRUE);
    
    if (m_CheckNoMore)	{
        long nErr;
        HKEY hKey;
        DWORD dwWarnFlag;
        DWORD dwDataSize;
        DWORD dwDisposition;
        WCHAR RegValName[MAX_PATH];

        hKey = m_hKey;

        dwWarnFlag = m_CheckNoMore;
        
        switch (m_dwLogType){
            case SLQ_COUNTER_LOG:
                StringCchPrintf ( RegValName, MAX_PATH,L"NoWarnCounterLog");
                break;
          
            case SLQ_ALERT:
                StringCchPrintf ( RegValName, MAX_PATH,L"NoWarnAlertLog");
                break;
        }

        nErr = RegCreateKeyEx( HKEY_CURRENT_USER,
                               L"Software\\Microsoft\\PerformanceLogsAndAlerts",
                               0,
                               L"REG_DWORD",
                               REG_OPTION_NON_VOLATILE,
                               KEY_READ | KEY_WRITE,
                               NULL,
                               &hKey,
                               &dwDisposition);
        
        if( nErr == ERROR_SUCCESS ) {
            dwDataSize = sizeof(DWORD);
            nErr = RegSetValueEx(hKey,
                          RegValName,
                          NULL,
                          REG_DWORD,
                          (LPBYTE) &dwWarnFlag,
                          dwDataSize
                          );

            if( ERROR_SUCCESS != nErr ) {
               DisplayError( GetLastError(), L"Close PerfLog User Key failed" );
            }
            RegCloseKey(hKey);

       }
    }
    CDialog::OnOK();
}

BOOL 
CLogWarnd::OnInitDialog() 
{
    CString cstrMessage , cstrWrongLog;

    SetWindowText ( m_strTitle );

    switch (m_dwLogType){
       case SLQ_COUNTER_LOG:
          cstrWrongLog.LoadString(IDS_COUNTER_LOG) ;
          break;
       case SLQ_ALERT:
          cstrWrongLog.LoadString(IDS_ALERT_LOG);
          break;
       case SMONCTRL_LOG:
          cstrWrongLog.LoadString( IDS_SMCTRL_LOG );
          break;
       default:
          cstrWrongLog.Format(L"");
          break;
    }

    
    switch(m_ErrorMsg){
        case ID_ERROR_COUNTER_LOG:
         cstrMessage.Format(IDS_ERRMSG_COUNTER_LOG,cstrWrongLog );
         break;

        case ID_ERROR_ALERT_LOG:
          cstrMessage.Format(IDS_ERRMSG_ALERT_LOG,cstrWrongLog);
         break;

        case ID_ERROR_TRACE_LOG:
          cstrMessage.Format(IDS_ERRMSG_TRACE_LOG,cstrWrongLog);    
         break;

        case ID_ERROR_SMONCTRL_LOG:
         cstrMessage.Format(IDS_ERRMSG_SMCTRL_LOG,cstrWrongLog);
         break;

    }
    
    ::SetWindowText((GetDlgItem(IDC_LWARN_MSG_WARN))->m_hWnd, cstrMessage);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}
VOID
CLogWarnd::OnCheckNoMoreLogType()
{
}
BOOL 
CLogWarnd::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    
    if ( pHelpInfo->iCtrlId >= IDC_LWARN_FIRST_HELP_CTRL_ID ) {
        InvokeWinHelp(WM_HELP, NULL, (LPARAM)pHelpInfo, m_strContextHelpFile, s_aulHelpIds);
    }

    return TRUE;
}

void 
CLogWarnd::OnContextMenu(CWnd* pWnd, CPoint /* point */) 
{
    InvokeWinHelp(WM_CONTEXTMENU, (WPARAM)(pWnd->m_hWnd), NULL, m_strContextHelpFile, s_aulHelpIds);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\newqdlg.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    newqdlg.h

Abstract:

    Header file for the create new query dialog.

--*/

#ifndef _NEWQDLG_H_
#define _NEWQDLG_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
                         
// Dialog controls
#define IDD_NEWQUERY                    900

#define IDC_NEWQ_FIRST_HELP_CTRL_ID     901
#define IDC_NEWQ_NAME_EDIT              901

/////////////////////////////////////////////////////////////////////////////
// CNewQueryDlg dialog

class CNewQueryDlg : public CDialog
{
// Construction
public:
    CNewQueryDlg(CWnd* pParent = NULL, BOOL bLogQuery = TRUE);   // alternate constructor

// Dialog Data
    void InitAfxData ( void );
    DWORD SetContextHelpFilePath( const CString& rstrPath );    

    //{{AFX_DATA(CNewQueryDlg)
    enum { IDD = IDD_NEWQUERY };
    CString m_strName;
    //}}AFX_DATA
    BOOL    m_bLogQuery; //if false then it's an alert query

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CNewQueryDlg)
    public:
    virtual void OnFinalRelease();
    protected:
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CNewQueryDlg)
    afx_msg BOOL OnHelpInfo( HELPINFO* );
    afx_msg void OnContextMenu( CWnd*, CPoint );
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CNewQueryDlg)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()

private:

    CString     m_strHelpFilePath;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _NEWQDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\ipropbag.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    ipropbag.cpp

Abstract:

	Implementation of the private IPropertyBag interface used by
	the Performance Logs and Alerts MMC snap-in.

--*/

#include "stdafx.h"
#include <strsafe.h>
#include "smcfgmsg.h"
#include "strnoloc.h"
#include "ipropbag.h"

USE_HANDLE_MACROS("SMLOGCFG(ipropbag.cpp)");

/*
 * CImpIPropertyBag interface implementation
 */

/*
 * CImpIPropertyBag::CImpIPropertyBag
 *
 * Purpose:
 *  Constructor.
 *
 * Return Value:
 */

CImpIPropertyBag::CImpIPropertyBag ()
:   m_cRef ( 0 ),
    m_pszData ( NULL ),
    m_dwCurrentDataLength ( 0 ),
    m_plistData ( NULL )
{
    m_hModule = (HINSTANCE)GetModuleHandleW (_CONFIG_DLL_NAME_W_);  
    return; 
}

/*
 * CImpIPropertyBag::~CImpIPropertyBag
 *
 * Purpose:
 *  Destructor.
 *
 * Return Value:
 */

CImpIPropertyBag::~CImpIPropertyBag ( void ) 
{   
    if ( NULL != m_pszData ) {
        delete [] m_pszData;
    }

    while ( NULL != m_plistData ) {
        PPARAM_DATA pData = DataListRemoveHead();
        VariantClear ( &pData->vValue ); 
        delete pData;
    }

    return; 
}


/*
 * CImpIPropertyBag::Read
 *
 * Purpose:
 *
 *  This function is called to read a property from the property bag.
 *
 * Parameters:
 *  pszPropName     Pointer to name of property to be read
 *  pVar            Pointer to the VARIANT to receive the property value
 *  pIErrorLog      Pointer to the caller's error log
 */

STDMETHODIMP 
CImpIPropertyBag::Read (
    LPCOLESTR pszPropName,  //Pointer to the property to be read
    VARIANT* pVar,          //Pointer to the VARIANT to receive the 
                            //property value
    IErrorLog* pIErrorLog ) //Pointer to the caller's error log    // can be null
{
    HRESULT     hr = S_OK;
    PPARAM_DATA pData;

    if (NULL==pszPropName)
        return ResultFromScode(E_POINTER);

    if (NULL==pVar)
        return ResultFromScode(E_POINTER);

    // Currently don't handle error log.
    ASSERT ( NULL == pIErrorLog );
    pIErrorLog;                             // Avoid compiler warning

    //Read the specified data into the passed variant.
    pData = FindProperty ( pszPropName );

    if ( NULL != pData ) {
        //VARTYPE vtTarget = vValue.vt;
        hr = VariantChangeType ( pVar, &pData->vValue, NULL, pVar->vt );
    } else {
        hr = E_INVALIDARG;
    }

    return hr;
}

/*
 * CImpIPropertyBag::Write
 *
 * Purpose:
 *
 *  This function is called to write a property to the property bag.
 *
 * Parameters:
 *  pszPropName     Pointer to name of property to be written
 *  pVar            Pointer to the VARIANT containing the property value
 */

STDMETHODIMP 
CImpIPropertyBag::Write (
    LPCOLESTR pszPropName,  //Pointer to the property to be written
    VARIANT* pVar )         //Pointer to the VARIANT containing the  
                            //property value and type
{
    HRESULT     hr = S_OK;
    VARIANT     vValueBstr;
    DWORD       dwNameLength;
    DWORD       dwDataLength;
    DWORD       dwDelimiterLength;
    LPWSTR      pszNewBuffer = NULL;
    size_t      cchRemaining = 0;
    LPWSTR      szNext = NULL;
    INT         iCurrentLength = 0;


    ResourceStateManager    rsm;

    if ( NULL != pszPropName && NULL != pVar ) {

        VariantInit ( &vValueBstr );

        hr = VariantChangeType ( &vValueBstr, pVar, NULL, VT_BSTR );

        if ( SUCCEEDED ( hr ) ) {

            MFC_TRY

                dwDelimiterLength = lstrlen ( CGlobalString::m_cszHtmlParamTag )
                                    + lstrlen ( CGlobalString::m_cszHtmlValueTag )
                                    + lstrlen ( CGlobalString::m_cszHtmlValueEolTag );

                dwNameLength = lstrlen ( pszPropName );
                dwDataLength = lstrlen ( vValueBstr.bstrVal );

                // Include 1 for the ending NULL character in the length check.
                iCurrentLength = lstrlen ( m_pszData );
                if ( m_dwCurrentDataLength 
                    < iCurrentLength + dwNameLength + dwDataLength + dwDelimiterLength + 1 ) { 

                    m_dwCurrentDataLength += eDefaultBufferLength;

                    pszNewBuffer = new WCHAR[m_dwCurrentDataLength];
        
                    pszNewBuffer[0] = L'\0';

                    if ( NULL != m_pszData ) {
                        StringCchCopyEx ( pszNewBuffer, m_dwCurrentDataLength, m_pszData, &szNext, &cchRemaining, 0 );
                        delete [] m_pszData;
                    }
                    m_pszData = pszNewBuffer;
                    pszNewBuffer = NULL;
                    szNext = m_pszData + iCurrentLength;
                    
                    if ( ( m_dwCurrentDataLength - iCurrentLength) > 0 ) {
                        cchRemaining = m_dwCurrentDataLength - iCurrentLength - 1;
                    } else {
                        cchRemaining = 0;
                    }

                } else {
                    szNext = m_pszData + iCurrentLength;
                    if ( ( m_dwCurrentDataLength - iCurrentLength) > 0 ) {
                        cchRemaining = m_dwCurrentDataLength - iCurrentLength - 1;
                    } else {
                        cchRemaining = 0;
                    }
                }

                // Build the new string and add it to the current data.

                StringCchCopyEx ( szNext, cchRemaining, CGlobalString::m_cszHtmlParamTag, &szNext, &cchRemaining, 0 );
                StringCchCopyEx ( szNext, cchRemaining, pszPropName, &szNext, &cchRemaining, 0 );
                StringCchCopyEx ( szNext, cchRemaining, CGlobalString::m_cszHtmlValueTag, &szNext, &cchRemaining, 0 );
                StringCchCopyEx ( szNext, cchRemaining, vValueBstr.bstrVal, &szNext, &cchRemaining, 0 );
                StringCchCopyEx ( szNext, cchRemaining, CGlobalString::m_cszHtmlValueEolTag, &szNext, &cchRemaining, 0 );

            MFC_CATCH_HR_RETURN;

            if ( NULL != pszNewBuffer ) {
                delete [] pszNewBuffer;
            }

            VariantClear ( &vValueBstr );
        }
    } else {
        hr = E_POINTER;
    }
    
    return hr;
}

/*
 * CImpIPropertyBag::GetData
 *
 * Purpose:
 *  Return pointer to the data buffer.
 *
 * Return Value:
 *  Pointer to the data buffer.
 */

LPWSTR
CImpIPropertyBag::GetData ( void ) 
{   
    return m_pszData;
}

/*
 * CImpIPropertyBag::LoadData
 *
 * Purpose:
 *  Load data from the supplied buffer into internal data structures.
 *  Return pointer to the next object, or NULL if no more objects.
 *
 * Return Value:
 *  Status.
 */

DWORD
CImpIPropertyBag::LoadData ( LPWSTR pszData, LPWSTR* ppszNextData ) 
{   
    DWORD   dwStatus = ERROR_SUCCESS;
    BOOL    bUnicode = TRUE;
    LPWSTR  pszDataW = NULL;
    LPWSTR  pszDataAllocW = NULL;
    LPWSTR  pszCurrentPos = NULL;        
    INT     iBufLen;

    USES_CONVERSION;
    
    if ( NULL != pszData ) {
        
        // Unicode search:  Begin the search after the first instance 
        // of the System Monitor class id.

        pszCurrentPos = wcsstr(pszData, CGlobalString::m_cszHtmlObjectClassId );

        if ( NULL != pszCurrentPos ) {
            pszDataW = pszData;
            bUnicode = TRUE;
        } else {
            //
            // Check for ANSI version:
            //
            LPSTR   pszGuidA = NULL;
            LPSTR   pszCurrentPosA = NULL;
            LPSTR   pszDataA = (CHAR*) pszData;
             
            MFC_TRY
                pszGuidA = W2A( CGlobalString::m_cszHtmlObjectClassId );

                if ( NULL != pszGuidA ) {

                    pszCurrentPosA = strstr ( pszDataA, pszGuidA );

                    if ( NULL != pszCurrentPosA ) {
                    
                        iBufLen = lstrlenA (pszDataA) + 1;
                        pszDataAllocW = new WCHAR [iBufLen];

                        pszDataAllocW[0] = L'\0';

	                    MultiByteToWideChar(
                            CP_ACP, 
                            0, 
                            pszDataA, 
                            -1,             // Input string is null-terminated. 
                            pszDataAllocW, 
                            iBufLen );

                        pszDataAllocW [iBufLen - 1] = L'\0';
                
                        pszCurrentPos = wcsstr(pszDataAllocW, CGlobalString::m_cszHtmlObjectClassId );
                    }
                }
            MFC_CATCH_DWSTATUS
        }
        
        if ( NULL != pszCurrentPos ) {
            WCHAR   szQuote[2];
            LPWSTR  pszEoo;

            szQuote[0] = L'\"';
            szQuote[1] = L'\0';

            // End of object is the first object footer tag after the first sysmon
            // class id found. If multiple objects in the data block, only parse the first sysmon.
            pszEoo = wcsstr(pszCurrentPos, CGlobalString::m_cszHtmlObjectFooter );

            if ( NULL != pszEoo ) {            
                // Find first parameter tag.
                pszCurrentPos = wcsstr(pszCurrentPos, CGlobalString::m_cszHtmlParamSearchTag );

                while ( NULL != pszCurrentPos && pszCurrentPos < pszEoo ) {

                    LPWSTR      pszNextPos = NULL;
                    INT         lStrLength;
                    PPARAM_DATA pParamData = NULL;
                    LPWSTR      pszTemp = NULL;

                    // Store parameter/property name.
                    // Find one past first quote.
                    pszCurrentPos = wcsstr(pszCurrentPos, szQuote ) + 1;

                    // The param name is between first and second quote.
                    pszNextPos = wcsstr(pszCurrentPos, szQuote );

                    lStrLength = ( (INT)((UINT_PTR)pszNextPos - (UINT_PTR)pszCurrentPos) ) / sizeof ( WCHAR ) ;

                    MFC_TRY
                        pParamData = new PARAM_DATA;

                        pParamData->pNextParam = NULL;
                        VariantInit ( &pParamData->vValue );
                        pParamData->vValue.vt = VT_BSTR;

                        wcsncpy ( pParamData->pszPropertyName, pszCurrentPos, lStrLength );
                        pParamData->pszPropertyName[lStrLength] = L'\0';

                        // Find value tag and store parameter/property value.
                        // Find value tag
                        pszCurrentPos = wcsstr ( pszCurrentPos, CGlobalString::m_cszHtmlValueSearchTag );
                        // Find one past first quote
                        pszCurrentPos = wcsstr ( pszCurrentPos, szQuote ) + 1;
                        // The value is between first and second quote.
                        pszNextPos = wcsstr ( pszCurrentPos, szQuote );
                                
                        lStrLength = ( (INT)((UINT_PTR)pszNextPos - (UINT_PTR)pszCurrentPos) ) / sizeof ( WCHAR );

                        pszTemp = new WCHAR[lStrLength+1];
                        wcsncpy ( pszTemp, pszCurrentPos, lStrLength );
                        pszTemp[lStrLength] = L'\0';

                        pParamData->vValue.bstrVal = 
                                    SysAllocString ( pszTemp );

                        DataListAddHead ( pParamData );
                        pParamData = NULL;

                        //
                        // Find next parameter/property tag.
                        //
                        pszCurrentPos = wcsstr(pszCurrentPos, CGlobalString::m_cszHtmlParamSearchTag );

                    MFC_CATCH_DWSTATUS

                    if ( NULL != pszTemp ) {
                        delete [] pszTemp;
                        pszTemp = NULL;
                    }
                    if ( NULL != pParamData ) {
                        delete pParamData;
                        pParamData = NULL;
                        break;
                    }

                    if ( ERROR_SUCCESS != dwStatus ) {
                        break;
                    }
                } // While parameter tags exist for a single object.

                if ( NULL != ppszNextData ) {
                    LPWSTR pszNextEoo = NULL;
                    
                    pszEoo += lstrlenW ( CGlobalString::m_cszHtmlObjectFooter );

                    pszNextEoo = wcsstr(pszEoo, CGlobalString::m_cszHtmlObjectFooter );
                
                    // Successful. Return pointer to end of the current object, or NULL if all 
                    // objects have been processed.
                    if ( NULL != pszNextEoo ) {
                        if ( bUnicode ) {
                            *ppszNextData = pszEoo;
                        } else {
                            INT lStrLength;
                            lStrLength = ( (INT)((UINT_PTR)pszEoo - (UINT_PTR)pszDataW) ) / sizeof ( WCHAR ) ;
                           
                            *(CHAR**)ppszNextData = (CHAR*)pszData + lStrLength;
                        }
                    } else {
                        *ppszNextData = NULL;
                    }
                }                    
            } else {
                if ( NULL != ppszNextData ) {
                    *ppszNextData = NULL;
                }
                dwStatus = SMCFG_NO_HTML_SYSMON_OBJECT;
            }
        } else {
            if ( NULL != ppszNextData ) {
                *ppszNextData = NULL;
            }
            dwStatus = SMCFG_NO_HTML_SYSMON_OBJECT;
        }
    } else {
        if ( NULL != ppszNextData ) {
            *ppszNextData = NULL;
        }
        dwStatus = SMCFG_NO_HTML_SYSMON_OBJECT;
    }

    if ( NULL != pszDataAllocW ) {
        delete [] pszDataAllocW;
    }

    return dwStatus;
}

void
CImpIPropertyBag::DataListAddHead ( PPARAM_DATA pData ) 
{
    pData->pNextParam = m_plistData;
    m_plistData = pData;
    return;
}

CImpIPropertyBag::PPARAM_DATA
CImpIPropertyBag::DataListRemoveHead ( ) 
{
    PPARAM_DATA pReturnData;

    pReturnData = m_plistData;
    
    if ( NULL != m_plistData )
        m_plistData = m_plistData->pNextParam;
    
    return pReturnData;
}


CImpIPropertyBag::PPARAM_DATA
CImpIPropertyBag::FindProperty ( LPCWSTR pszPropName ) 
{
    PPARAM_DATA pReturnData;

    pReturnData = m_plistData;
    
    while ( NULL != pReturnData ) {
        if ( 0 == lstrcmpi ( pszPropName, pReturnData->pszPropertyName ) )
            break;
        pReturnData = pReturnData->pNextParam;
    }

    return pReturnData;
}

/////////////////////////////////////////////////////////////////////////////
// IUnknown implementation
// 


//---------------------------------------------------------------------------
//  Standard implementation
//
STDMETHODIMP
CImpIPropertyBag::QueryInterface
(
  REFIID  riid,
  LPVOID *ppvObj
)
{
  HRESULT hr = S_OK;

  do
  {
    if( NULL == ppvObj )
    {
      hr = E_INVALIDARG;
      break;
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
      *ppvObj = (IUnknown *)(IDataObject *)this;
    }
    else if (IsEqualIID(riid, IID_IDataObject))
    {
      *ppvObj = (IUnknown *)(IPropertyBag *)this;
    }
    else
    {
      hr = E_NOINTERFACE;
      *ppvObj = NULL;
      break;
    }

    // If we got this far we are handing out a new interface pointer on 
    // this object, so addref it.  
    AddRef();
  } while (0);

  return hr;

} // end QueryInterface()

//---------------------------------------------------------------------------
//  Standard implementation
//
STDMETHODIMP_(ULONG)
CImpIPropertyBag::AddRef()
{
  return InterlockedIncrement((LONG*) &m_cRef);
}

//---------------------------------------------------------------------------
//  Standard implementation
//
STDMETHODIMP_(ULONG)
CImpIPropertyBag::Release()
{
  ULONG cRefTemp;
  cRefTemp = InterlockedDecrement((LONG *)&m_cRef);

  if( 0 == cRefTemp )
  {
    delete this;
  }

  return cRefTemp;

} // end Release()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\provdlg.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    provdlg.cpp

Abstract:

    Implementation of the add providers dialog box.

--*/

#include "stdafx.h"
#include "provprop.h"
#include "smcfghlp.h"
#include "provdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static ULONG
s_aulHelpIds[] =
{
	IDC_PADD_PROVIDER_CAPTION,	IDH_PADD_PROVIDER_LIST,
	IDC_PADD_PROVIDER_LIST,	    IDH_PADD_PROVIDER_LIST,
    0,0
};

/////////////////////////////////////////////////////////////////////////////
// CProviderListDlg dialog


CProviderListDlg::CProviderListDlg(CWnd* pParent)
 : CDialog(CProviderListDlg::IDD, pParent),
      m_pProvidersPage ( NULL ),
      m_dwMaxHorizListExtent ( 0 )
{
//    EnableAutomation();

    //{{AFX_DATA_INIT(CProviderListDlg)
    //}}AFX_DATA_INIT
}

CProviderListDlg::~CProviderListDlg()
{
}

void CProviderListDlg::OnFinalRelease()
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CDialog::OnFinalRelease();
}

void CProviderListDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CProviderListDlg)
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CProviderListDlg, CDialog)
    //{{AFX_MSG_MAP(CProviderListDlg)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProviderListDlg message handlers

BOOL CProviderListDlg::OnInitDialog() 
{
    DWORD dwStatus;
    ResourceStateManager rsm;

    dwStatus = InitProviderListBox();

    CDialog::OnInitDialog();
    // set focus to the provider list box
    GetDlgItem(IDC_PADD_PROVIDER_LIST)->SetFocus();
    
    return FALSE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CProviderListDlg::OnOK() 
{
    CListBox * plbUnusedProviders = (CListBox *)GetDlgItem(IDC_PADD_PROVIDER_LIST);
    long    lNumProviders;
    INT iSelCount;

    UpdateData (TRUE);

    // update the provider array based on list box contents.
    
    iSelCount = plbUnusedProviders->GetSelCount();
    
    if ( 0 != iSelCount && LB_ERR != iSelCount ) {
 
        lNumProviders = plbUnusedProviders->GetCount();
        if (lNumProviders != LB_ERR) {
            long    lThisProvider;
            INT     iProvIndex;
            DWORD   dwStatus;

            // The Providers array has not changed since initialization, so no need to reload it here.

            lThisProvider = 0;
            while (lThisProvider < lNumProviders) {
                if ( 0 != plbUnusedProviders->GetSel( lThisProvider ) ) {
                    // Selected, so set the state to InQuery.
                    iProvIndex = (INT)plbUnusedProviders->GetItemData( lThisProvider );
                    m_arrProviders[iProvIndex] = CSmTraceLogQuery::eInQuery;
                }
                lThisProvider++; 
            }
            // Update the property page.
            ASSERT ( NULL != m_pProvidersPage );
            dwStatus = m_pProvidersPage->SetInQueryProviders ( m_arrProviders );
        }
    }
    
    CDialog::OnOK();
}

BOOL 
CProviderListDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    ASSERT( NULL != m_pProvidersPage );

    if ( pHelpInfo->iCtrlId >= IDC_PADD_FIRST_HELP_CTRL_ID ||
         pHelpInfo->iCtrlId == IDOK ||
         pHelpInfo->iCtrlId == IDCANCEL
        ) {
        InvokeWinHelp(WM_HELP, NULL, (LPARAM)pHelpInfo, m_pProvidersPage->GetContextHelpFilePath(), s_aulHelpIds);
    }

    return TRUE;
}

void 
CProviderListDlg::OnContextMenu(CWnd* pWnd, CPoint /* point */) 
{
    ASSERT( NULL != m_pProvidersPage );

    InvokeWinHelp(WM_CONTEXTMENU, (WPARAM)(pWnd->m_hWnd), NULL, m_pProvidersPage->GetContextHelpFilePath(), s_aulHelpIds);

    return;
}

//
// Helper functions
//

DWORD
CProviderListDlg::InitProviderListBox( void ) 
{
    DWORD dwStatus = ERROR_SUCCESS;
    CString	strProviderName;
    INT iProvIndex;
    DWORD   dwItemExtent;
    CListBox * plbUnusedProviders = (CListBox *)GetDlgItem(IDC_PADD_PROVIDER_LIST);
    CDC*        pCDC = NULL;

    ASSERT( NULL != m_pProvidersPage );

    if ( NULL != plbUnusedProviders ) {

        //load counter list box from string in counter list
        plbUnusedProviders->ResetContent();

        pCDC = plbUnusedProviders->GetDC();
        dwStatus = m_pProvidersPage->GetInQueryProviders ( m_arrProviders );

        if ( ERROR_SUCCESS == dwStatus && NULL != pCDC ) {
            // List unused providers
            for ( iProvIndex = 0; iProvIndex < m_arrProviders.GetSize(); iProvIndex++ ) {
                if ( ( CSmTraceLogQuery::eNotInQuery == m_arrProviders[iProvIndex] )
                    && ( m_pProvidersPage->IsActiveProvider ( iProvIndex ) ) ) {
                    INT iAddIndex;
                    m_pProvidersPage->GetProviderDescription( iProvIndex, strProviderName );
                    iAddIndex = plbUnusedProviders->AddString ( strProviderName );
                    plbUnusedProviders->SetItemData ( iAddIndex, ( DWORD ) iProvIndex );

                    // update list box extent
                    dwItemExtent = (DWORD)(pCDC->GetTextExtent(strProviderName)).cx;
                    if (dwItemExtent > m_dwMaxHorizListExtent) {
                        m_dwMaxHorizListExtent = dwItemExtent;
                        plbUnusedProviders->SetHorizontalExtent(dwItemExtent);
                    }
                }
            }
        }
        if ( NULL != pCDC ) {
            plbUnusedProviders->ReleaseDC(pCDC);
            pCDC = NULL;
        }
    } else {
        dwStatus = ERROR_OUTOFMEMORY;
    }

    return dwStatus;
}

void    
CProviderListDlg::SetProvidersPage( CProvidersProperty* pPage ) 
{ 
    // The providers page is not always the parent, so store a separate pointer
    m_pProvidersPage = pPage; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\provdlg.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    provdlg.h

Abstract:

    Header file for the add trace provider dialog

--*/

#ifndef _PROVDLG_H_
#define _PROVDLG_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "smtraceq.h"   // For provider states

// Dialog controls
#define IDD_PROVIDERS_ADD_DLG          1100

#define IDC_PADD_PROVIDER_CAPTION      1011
#define IDC_PADD_FIRST_HELP_CTRL_ID    1012
#define IDC_PADD_PROVIDER_LIST         1012

class CProvidersProperty;

/////////////////////////////////////////////////////////////////////////////
// CProviderListDlg dialog

class CProviderListDlg : public CDialog
{
// Construction
public:
            CProviderListDlg(CWnd* pParent=NULL);
    virtual ~CProviderListDlg();

    void    SetProvidersPage( CProvidersProperty* pPage );
    // Dialog Data
    //{{AFX_DATA(CProvidersProperty)
    enum { IDD = IDD_PROVIDERS_ADD_DLG };
        // NOTE - ClassWizard will add data members here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CProvidersProperty)
	public:
	virtual void OnFinalRelease();
    protected:
	virtual BOOL OnInitDialog();
	virtual void OnOK();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CProvidersProperty)
    afx_msg BOOL OnHelpInfo( HELPINFO* );
    afx_msg void OnContextMenu( CWnd*, CPoint );
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CProvidersProperty)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH

private:

    DWORD               InitProviderListBox ( void );

    CArray<CSmTraceLogQuery::eProviderState, CSmTraceLogQuery::eProviderState&> m_arrProviders;

    CProvidersProperty* m_pProvidersPage;
    DWORD               m_dwMaxHorizListExtent;
    
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif //  _PROVDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\provprop.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    provprop.cpp

Abstract:

    Implementation of the trace providers general property page.

--*/

#include "stdafx.h"
#include <pdh.h>        // For xxx_TIME_VALUE
#include "smlogs.h"
#include "smcfgmsg.h"
#include "provdlg.h"
#include "warndlg.h"
#include "enabldlg.h"
#include "provprop.h"
#include <pdhp.h>
#include "dialogs.h"
#include "smlogres.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("SMLOGCFG(provprop.cpp)");

static ULONG
s_aulHelpIds[] =
{
    IDC_PROV_FILENAME_DISPLAY,      IDH_PROV_FILENAME_DISPLAY,
    IDC_PROV_PROVIDER_LIST,         IDH_PROV_PROVIDER_LIST,
    IDC_PROV_ADD_BTN,               IDH_PROV_ADD_BTN,
    IDC_PROV_REMOVE_BTN,            IDH_PROV_REMOVE_BTN,
    IDC_PROV_KERNEL_BTN,            IDH_PROV_KERNEL_BTN,
    IDC_PROV_OTHER_BTN,             IDH_PROV_OTHER_BTN,
    IDC_PROV_K_PROCESS_CHK,         IDH_PROV_K_PROCESS_CHK,
    IDC_PROV_K_THREAD_CHK,          IDH_PROV_K_THREAD_CHK,
    IDC_PROV_K_DISK_IO_CHK,         IDH_PROV_K_DISK_IO_CHK,
    IDC_PROV_K_NETWORK_CHK,         IDH_PROV_K_NETWORK_CHK,
    IDC_PROV_K_SOFT_PF_CHK,         IDH_PROV_K_SOFT_PF_CHK,
    IDC_PROV_K_FILE_IO_CHK,         IDH_PROV_K_FILE_IO_CHK,
    IDC_PROV_SHOW_PROVIDERS_BTN,    IDH_PROV_SHOW_PROVIDERS_BTN,
    IDC_RUNAS_EDIT,                 IDH_RUNAS_EDIT,
    IDC_SETPWD_BTN,                 IDH_SETPWD_BTN,
    0,0
};

/////////////////////////////////////////////////////////////////////////////
// CProvidersProperty property page

IMPLEMENT_DYNCREATE(CProvidersProperty, CSmPropertyPage)

CProvidersProperty::CProvidersProperty(MMC_COOKIE   lCookie, LONG_PTR hConsole)
:   CSmPropertyPage ( CProvidersProperty::IDD, hConsole )
// lCookie is really the pointer to the Log Query object
{
//    ::OutputDebugStringA("\nCProvidersProperty::CProvidersProperty");

    // save pointers from arg list
    m_pTraceLogQuery = reinterpret_cast <CSmTraceLogQuery *>(lCookie);
    ASSERT ( m_pTraceLogQuery->CastToTraceLogQuery() );
    m_pQuery = dynamic_cast <CSmLogQuery*>(m_pTraceLogQuery);

    m_dwMaxHorizListExtent = 0;
    m_dwTraceMode = eTraceModeApplication;

//  EnableAutomation();
    //{{AFX_DATA_INIT(CProvidersProperty)
    m_bNonsystemProvidersExist = TRUE;
    m_bEnableProcessTrace = FALSE;
    m_bEnableThreadTrace = FALSE;
    m_bEnableDiskIoTrace = FALSE;
    m_bEnableNetworkTcpipTrace = FALSE;
    m_bEnableMemMgmtTrace = FALSE;
    m_bEnableFileIoTrace = FALSE;
    //}}AFX_DATA_INIT
}

CProvidersProperty::CProvidersProperty() : CSmPropertyPage(CProvidersProperty::IDD)
{
    ASSERT (FALSE); // the constructor w/ args should be used instead

    EnableAutomation();
    //{{AFX_DATA_INIT(CProvidersProperty)
    m_bNonsystemProvidersExist = TRUE;
    m_bEnableProcessTrace = FALSE;
    m_bEnableThreadTrace = FALSE;
    m_bEnableDiskIoTrace = FALSE;
    m_bEnableNetworkTcpipTrace = FALSE;
    m_bEnableMemMgmtTrace = FALSE;
    m_bEnableFileIoTrace = FALSE;
    //}}AFX_DATA_INIT
    m_pTraceLogQuery = NULL;
}

CProvidersProperty::~CProvidersProperty()
{
//    ::OutputDebugStringA("\nCProvidersProperty::~CProvidersProperty");
}

void CProvidersProperty::OnFinalRelease()
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CPropertyPage::OnFinalRelease();
}

void CProvidersProperty::DoDataExchange(CDataExchange* pDX)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    DoProvidersDataExchange ( pDX );
    TraceModeRadioExchange ( pDX );

    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CProvidersProperty)
    DDX_Text(pDX, IDC_PROV_LOG_SCHED_TEXT, m_strStartText);
    DDX_Text(pDX, IDC_RUNAS_EDIT, m_strUserDisplay );
    DDX_Check(pDX, IDC_PROV_K_PROCESS_CHK, m_bEnableProcessTrace);
    DDX_Check(pDX, IDC_PROV_K_THREAD_CHK,  m_bEnableThreadTrace);
    DDX_Check(pDX, IDC_PROV_K_DISK_IO_CHK, m_bEnableDiskIoTrace);
    DDX_Check(pDX, IDC_PROV_K_NETWORK_CHK, m_bEnableNetworkTcpipTrace);
    DDX_Check(pDX, IDC_PROV_K_SOFT_PF_CHK, m_bEnableMemMgmtTrace);
    DDX_Check(pDX, IDC_PROV_K_FILE_IO_CHK, m_bEnableFileIoTrace);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CProvidersProperty, CSmPropertyPage)
    //{{AFX_MSG_MAP(CProvidersProperty)
    ON_BN_CLICKED(IDC_PROV_KERNEL_BTN, OnProvTraceModeRdo)
    ON_BN_CLICKED(IDC_PROV_OTHER_BTN, OnProvTraceModeRdo)
    ON_BN_CLICKED(IDC_PROV_SHOW_PROVIDERS_BTN, OnProvShowProvBtn)
    ON_BN_CLICKED(IDC_PROV_ADD_BTN, OnProvAddBtn)
    ON_BN_CLICKED(IDC_PROV_REMOVE_BTN, OnProvRemoveBtn)
    ON_LBN_DBLCLK(IDC_PROV_PROVIDER_LIST, OnDblclkProvProviderList)
    ON_LBN_SELCANCEL(IDC_PROV_PROVIDER_LIST, OnSelcancelProvProviderList)
    ON_LBN_SELCHANGE(IDC_PROV_PROVIDER_LIST, OnSelchangeProvProviderList)
    ON_BN_CLICKED(IDC_PROV_K_PROCESS_CHK, OnProvKernelEnableCheck)
    ON_BN_CLICKED(IDC_PROV_K_THREAD_CHK, OnProvKernelEnableCheck)
    ON_EN_CHANGE( IDC_RUNAS_EDIT, OnChangeUser )
    ON_BN_CLICKED(IDC_PROV_K_DISK_IO_CHK, OnProvKernelEnableCheck)
    ON_BN_CLICKED(IDC_PROV_K_NETWORK_CHK, OnProvKernelEnableCheck)
    ON_BN_CLICKED(IDC_PROV_K_FILE_IO_CHK, OnProvKernelEnableCheck)
    ON_BN_CLICKED(IDC_PROV_K_SOFT_PF_CHK, OnProvKernelEnableCheck)
    ON_BN_CLICKED(IDC_SETPWD_BTN, OnPwdBtn)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CProvidersProperty, CSmPropertyPage)
    //{{AFX_DISPATCH_MAP(CProvidersProperty)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IProvidersProperty to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {65154EA9-BDBE-11D1-BF99-00C04F94A83A}
static const IID IID_IProvidersProperty =
{ 0x65154ea9, 0xbdbe, 0x11d1, { 0xbf, 0x99, 0x0, 0xc0, 0x4f, 0x94, 0xa8, 0x3a } };

BEGIN_INTERFACE_MAP(CProvidersProperty, CSmPropertyPage)
    INTERFACE_PART(CProvidersProperty, IID_IProvidersProperty, Dispatch)
END_INTERFACE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CProvidersProperty message handlers

void 
CProvidersProperty::OnChangeUser()
{
    //
    // If you can not access remote WBEM, you can not modify RunAs info,
    // changing the user name is not allowed.
    //
    if (m_bCanAccessRemoteWbem) {
        // When the user hits OK in the password dialog,
        // the user name might not have changed.
        UpdateData ( TRUE );

        m_strUserDisplay.TrimLeft();
        m_strUserDisplay.TrimRight();

        if ( 0 != m_strUserSaved.Compare ( m_strUserDisplay ) ) {
            m_pTraceLogQuery->m_fDirtyPassword = PASSWORD_DIRTY;
            SetModifiedPage(TRUE);
        }
        else {
            m_pTraceLogQuery->m_fDirtyPassword &= ~PASSWORD_DIRTY;
        }
        //
        // If default user is typed, never need to set password
        //
        if (m_strUserDisplay.IsEmpty() || m_strUserDisplay.GetAt(0) == L'<') {
            if (m_bPwdButtonEnabled) {
                GetDlgItem(IDC_SETPWD_BTN)->EnableWindow(FALSE);
                m_bPwdButtonEnabled = FALSE;
            }
        }
        else {
            if (!m_bPwdButtonEnabled) {
                GetDlgItem(IDC_SETPWD_BTN)->EnableWindow(TRUE);
                m_bPwdButtonEnabled = TRUE;
            }
        }
    }
    else {
        //
        // We can not modify the RunAs info, then display
        // an error message and retore the original user name in RunAs
        //
        UpdateData(TRUE);
        if (ConnectRemoteWbemFail(m_pTraceLogQuery, FALSE)) {
            GetDlgItem(IDC_RUNAS_EDIT)->SetWindowText(m_strUserSaved);
        }
    }
}

void CProvidersProperty::OnPwdBtn()
{
    CString strTempUser;

    UpdateData();

    if (!m_bCanAccessRemoteWbem) {
        ConnectRemoteWbemFail(m_pTraceLogQuery, TRUE);
        return;
    }

    MFC_TRY
        strTempUser = m_strUserDisplay;

        m_strUserDisplay.TrimLeft();
        m_strUserDisplay.TrimRight();

        m_pTraceLogQuery->m_strUser = m_strUserDisplay;

        SetRunAs(m_pTraceLogQuery);

        m_strUserDisplay = m_pTraceLogQuery->m_strUser;

        if ( 0 != strTempUser.CompareNoCase ( m_strUserDisplay ) ) {
            SetDlgItemText ( IDC_RUNAS_EDIT, m_strUserDisplay );
        }
    MFC_CATCH_MINIMUM;
}

void 
CProvidersProperty::OnProvAddBtn() 
{
    ImplementAdd();
}


void 
CProvidersProperty::OnProvRemoveBtn() 
{
    CListBox    *plbProviderList;
    CDC*        pCDC = NULL;
    LONG        lThisItem;
    BOOL        bDone;
    LONG        lOrigCaret = 0;
    LONG        lItemStatus;
    LONG        lItemCount;
    BOOL        bChanged = FALSE;
    DWORD       dwItemExtent;
    CString     strItemText;

    plbProviderList = (CListBox *)GetDlgItem(IDC_PROV_PROVIDER_LIST);
    // delete all selected items in the list box and
    // set the cursor to the item above the original caret position
    // or the first or last if that is out of the new range

    if ( NULL != plbProviderList ) {
        
        pCDC = plbProviderList->GetDC();
        if ( NULL != pCDC ) {
            lOrigCaret = plbProviderList->GetCaretIndex();
            lThisItem = 0;
            bDone = FALSE;
            // clear the max extent
            m_dwMaxHorizListExtent = 0;
            // clear the value 
            do {
                lItemStatus = plbProviderList->GetSel(lThisItem);
                if (lItemStatus > 0) {
                    // then it's selected so delete it
                    INT iProvIndex = (INT)plbProviderList->GetItemData ( lThisItem );
                    m_arrGenProviders[iProvIndex] = CSmTraceLogQuery::eNotInQuery;
                    plbProviderList->DeleteString ( lThisItem );
                    bChanged = TRUE;
                } else if (lItemStatus == 0) {
                    // get the text length of this item since it will stay
                    plbProviderList->GetText(lThisItem, strItemText);
                    dwItemExtent = (DWORD)(pCDC->GetTextExtent(strItemText)).cx;
                    if (dwItemExtent > m_dwMaxHorizListExtent) {
                        m_dwMaxHorizListExtent = dwItemExtent;
                    }
                    // then it's not selected so go to the next one
                    lThisItem++;
                } else {
                    // we've run out so exit
                    bDone = TRUE;
                }
            } while (!bDone);
        }
        if ( NULL != pCDC ) {
            plbProviderList->ReleaseDC(pCDC);
            pCDC = NULL;
        }

        // update the text extent of the list box
        plbProviderList->SetHorizontalExtent(m_dwMaxHorizListExtent);

        // see how many entries are left and update the
        // caret position and the remove button state
        lItemCount = plbProviderList->GetCount();
        if (lItemCount > 0) {
            // the update the caret
            if (lOrigCaret >= lItemCount) {
                lOrigCaret = lItemCount-1;
            } else {
                // caret should be within the list
            }
            plbProviderList->SetSel(lOrigCaret);
            plbProviderList->SetCaretIndex(lOrigCaret);
        } else {
            // the list is empty so remove caret, selection
            plbProviderList->SetSel(-1);
            if ( eTraceModeApplication == m_dwTraceMode )
                GetDlgItem(IDC_PROV_ADD_BTN)->SetFocus();
        }

        SetTraceModeState();
    
        SetModifiedPage(bChanged);
    }
}

void CProvidersProperty::OnDblclkProvProviderList() 
{
    ImplementAdd();
}

void CProvidersProperty::OnSelcancelProvProviderList() 
{
    SetAddRemoveBtnState();    
}

void CProvidersProperty::OnSelchangeProvProviderList() 
{
    SetAddRemoveBtnState();    
}

void 
CProvidersProperty::DoProvidersDataExchange ( CDataExchange* pDX) 
{
    CListBox*   plbInQueryProviders = (CListBox *)GetDlgItem(IDC_PROV_PROVIDER_LIST);
    long        lNumProviders;
    CDC*        pCDC = NULL;

    if ( m_bNonsystemProvidersExist && NULL != plbInQueryProviders ) {
        pCDC = plbInQueryProviders->GetDC();
        if ( NULL != pCDC ) {
            if ( TRUE == pDX->m_bSaveAndValidate ) {

                // update the provider array based on list box contents.

                lNumProviders = plbInQueryProviders->GetCount();
                if (lNumProviders != LB_ERR) {
                    long    lThisProvider;
                    INT     iProvIndex;

                    // Reset InQuery array, retaining state for eInactive providers.
                    m_pTraceLogQuery->GetInQueryProviders ( m_arrGenProviders );
        
                    // Reset eInQuery to eNotInQuery, in case some were removed from the query.
                    for ( iProvIndex = 0; iProvIndex < m_arrGenProviders.GetSize(); iProvIndex++ ) {
                        if ( CSmTraceLogQuery::eInQuery == m_arrGenProviders[iProvIndex] )
                           m_arrGenProviders[iProvIndex] = CSmTraceLogQuery::eNotInQuery;
                    }

                    lThisProvider = 0;
                    while (lThisProvider < lNumProviders) {
                        iProvIndex = (INT)plbInQueryProviders->GetItemData( lThisProvider );
                        m_arrGenProviders[iProvIndex] = CSmTraceLogQuery::eInQuery;
                        lThisProvider++; 
                    }
                }
            } else {

                // Reset the list box.
                CString  strProviderName;
                INT iProvIndex;
                DWORD dwItemExtent;

                ASSERT( NULL != m_pTraceLogQuery );

                //load nonsystem provider list box from string in provider list
                plbInQueryProviders->ResetContent();

                for ( iProvIndex = 0; iProvIndex < m_arrGenProviders.GetSize(); iProvIndex++ ) {
                    if ( CSmTraceLogQuery::eInQuery == m_arrGenProviders[iProvIndex] ) {
                        INT iAddIndex;
                        GetProviderDescription( iProvIndex, strProviderName );
                        iAddIndex = plbInQueryProviders->AddString ( strProviderName );
                        plbInQueryProviders->SetItemData ( iAddIndex, ( DWORD ) iProvIndex );
                        // update list box extent
                        dwItemExtent = (DWORD)(pCDC->GetTextExtent(strProviderName)).cx;
                        if (dwItemExtent > m_dwMaxHorizListExtent) {
                            m_dwMaxHorizListExtent = dwItemExtent;
                            plbInQueryProviders->SetHorizontalExtent(dwItemExtent);
                        }

                    }
                }
            }
        }
        if ( NULL != pCDC ) {
            plbInQueryProviders->ReleaseDC(pCDC);
            pCDC = NULL;
        }
    }
}

BOOL 
CProvidersProperty::IsValidLocalData( ) 
{
    BOOL bIsValid = TRUE;
    ResourceStateManager    rsm;

    if ( eTraceModeKernel == m_dwTraceMode ) {
        DWORD dwKernelFlags = 0;

        // Ensure that the user has enabled at least one of the 4 basic Kernel traces.
        if ( m_bEnableProcessTrace ) {
            dwKernelFlags |= SLQ_TLI_ENABLE_PROCESS_TRACE;
        }

        if ( m_bEnableThreadTrace ) {
            dwKernelFlags |= SLQ_TLI_ENABLE_THREAD_TRACE;
        }

        if ( m_bEnableDiskIoTrace ) {
            dwKernelFlags |= SLQ_TLI_ENABLE_DISKIO_TRACE;
        }

        if ( m_bEnableNetworkTcpipTrace ) {
            dwKernelFlags |= SLQ_TLI_ENABLE_NETWORK_TCPIP_TRACE;
        }

        if ( 0 == dwKernelFlags ) {
            CString strMsg;

            strMsg.LoadString ( IDS_KERNEL_PROVIDERS_REQUIRED );
    
            MessageBox ( strMsg, m_pTraceLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
            SetFocusAnyPage ( IDC_PROV_KERNEL_BTN );
            bIsValid = FALSE;
        }
    } else {
        CListBox * plbInQueryProviders = (CListBox *)GetDlgItem(IDC_PROV_PROVIDER_LIST);
    
        if ( !m_bNonsystemProvidersExist || 0 == plbInQueryProviders->GetCount() ) {
            CString strMsg;

            strMsg.LoadString ( IDS_APP_PROVIDERS_REQUIRED );
    
            MessageBox ( strMsg, m_pTraceLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
            SetFocusAnyPage ( IDC_PROV_ADD_BTN );
            bIsValid = FALSE;
        }
    }

    return bIsValid;
}    

void 
CProvidersProperty::OnProvTraceModeRdo() 
{
    UpdateData ( TRUE );
    SetModifiedPage ( TRUE );
}

void
CProvidersProperty::OnCancel()
{
    m_pTraceLogQuery->SyncPropPageSharedData();  // clear memory shared between property pages.
}

BOOL 
CProvidersProperty::OnApply() 
{   
    BOOL bContinue = TRUE;

    bContinue = UpdateData ( TRUE );

    if ( bContinue ) {
        bContinue = IsValidData(m_pTraceLogQuery, VALIDATE_APPLY );
    }

    // Write the data to the query.
    if ( bContinue ) {
        if ( eTraceModeKernel == m_dwTraceMode ) {
            DWORD dwKernelFlags = 0;
            INT     iProvIndex;

            if ( m_bEnableProcessTrace ) {
                dwKernelFlags |= SLQ_TLI_ENABLE_PROCESS_TRACE;
            }

            if ( m_bEnableThreadTrace ) {
                dwKernelFlags |= SLQ_TLI_ENABLE_THREAD_TRACE;
            }

            if ( m_bEnableDiskIoTrace ) {
                dwKernelFlags |= SLQ_TLI_ENABLE_DISKIO_TRACE;
            }

            if ( m_bEnableNetworkTcpipTrace ) {
                dwKernelFlags |= SLQ_TLI_ENABLE_NETWORK_TCPIP_TRACE;
            }

            // Ensure that the user has enabled at least one of the 4 basic Kernel traces.
            ASSERT ( 0 != dwKernelFlags );
            
            if ( m_bEnableMemMgmtTrace ) {
                dwKernelFlags |= SLQ_TLI_ENABLE_MEMMAN_TRACE;
            }

            if ( m_bEnableFileIoTrace ) {
                dwKernelFlags |= SLQ_TLI_ENABLE_FILEIO_TRACE;
            }

            m_pTraceLogQuery->SetKernelFlags (dwKernelFlags);
            
            // Erase all InQuery providers.
            for ( iProvIndex = 0; iProvIndex < m_arrGenProviders.GetSize(); iProvIndex++ ) {
                if ( CSmTraceLogQuery::eInQuery == m_arrGenProviders[iProvIndex] )
                   m_arrGenProviders[iProvIndex] = CSmTraceLogQuery::eNotInQuery;
            }
        
            m_pTraceLogQuery->SetInQueryProviders ( m_arrGenProviders );

        } else {
            CListBox * plbInQueryProviders = (CListBox *)GetDlgItem(IDC_PROV_PROVIDER_LIST);
       
            ASSERT ( 0 < plbInQueryProviders->GetCount() );
            m_pTraceLogQuery->SetInQueryProviders ( m_arrGenProviders );
            // Reset kernel flags 
            m_pTraceLogQuery->SetKernelFlags (0);
        }
    }

    if ( bContinue ) {
        // ApplyRunAs must be called before UpdateService
        bContinue = ApplyRunAs(m_pTraceLogQuery); 
    }

    if ( bContinue ){
        bContinue = CSmPropertyPage::OnApply();
    }

    if ( bContinue ) {

        // Save property page shared data.
        m_pTraceLogQuery->UpdatePropPageSharedData();

        bContinue = UpdateService ( m_pTraceLogQuery, TRUE );
    }

    return bContinue;
}

BOOL CProvidersProperty::OnInitDialog() 
{
    DWORD dwStatus;
    DWORD dwKernelFlags;
    CListBox * plbInQueryProviders;
    BOOL    bDeleteInactiveProviders = FALSE;
    INT     iIndex;
    ResourceStateManager    rsm;

    //
    // Here m_pTraceLogQuery should not be NULL, if it is,
    // There must be something wrong.
    //
    if ( NULL == m_pTraceLogQuery ) {
        return TRUE;
    }

    m_bCanAccessRemoteWbem = m_pTraceLogQuery->GetLogService()->CanAccessWbemRemote();
    m_pTraceLogQuery->SetActivePropertyPage( this );

    dwStatus = m_pTraceLogQuery->InitGenProvidersArray();    

    if ( SMCFG_INACTIVE_PROVIDER == dwStatus ) {
        CString strMessage;
        CString strSysMessage;
        INT_PTR iResult;

        FormatSmLogCfgMessage ( 
            strMessage,
            m_hModule, 
            SMCFG_INACTIVE_PROVIDER, 
            m_pTraceLogQuery->GetLogName() );

        iIndex = m_pTraceLogQuery->GetFirstInactiveIndex();

        while ( -1 != iIndex ) {
            CString strNextName;
       
            GetProviderDescription( iIndex, strNextName );

            strMessage += L"\n    ";
            strMessage += strNextName;
            iIndex = m_pTraceLogQuery->GetNextInactiveIndex();
        }

        iResult = MessageBox( 
            (LPCWSTR)strMessage,
            m_pTraceLogQuery->GetLogName(),
            MB_YESNO | MB_ICONWARNING
            );

        if ( IDYES == iResult ) {
            bDeleteInactiveProviders = TRUE;
        }
    }

    // Continue even if no active providers exist.
    plbInQueryProviders = (CListBox *)GetDlgItem(IDC_PROV_PROVIDER_LIST);

    // Initialize from model.
    dwStatus = m_pTraceLogQuery->GetInQueryProviders ( m_arrGenProviders );

    if ( bDeleteInactiveProviders ) {
        // Delete all inactive providers
        iIndex = m_pTraceLogQuery->GetFirstInactiveIndex();
        while ( -1 != iIndex ) {
            m_arrGenProviders[iIndex] = CSmTraceLogQuery::eNotInQuery;

            iIndex = m_pTraceLogQuery->GetNextInactiveIndex();
        }
    }

    m_bNonsystemProvidersExist = FALSE;
    for ( iIndex = 0; iIndex < m_arrGenProviders.GetSize(); iIndex++ ) {
        if ( m_pTraceLogQuery->IsActiveProvider ( iIndex ) ) {
            m_bNonsystemProvidersExist = TRUE;
            break;
        }
    }

    m_pTraceLogQuery->GetKernelFlags (dwKernelFlags);

    if ( (dwKernelFlags & SLQ_TLI_ENABLE_KERNEL_TRACE) != 0) {
        // NT5 Beta2 Kernel trace flag in use to cover all four basic trace.
        m_bEnableProcessTrace = TRUE;
        m_bEnableThreadTrace = TRUE;
        m_bEnableDiskIoTrace = TRUE;
        m_bEnableNetworkTcpipTrace = TRUE;
    } else {
        m_bEnableProcessTrace = (BOOL)((dwKernelFlags & SLQ_TLI_ENABLE_PROCESS_TRACE) != 0);
        m_bEnableThreadTrace = (BOOL)((dwKernelFlags & SLQ_TLI_ENABLE_THREAD_TRACE) != 0);
        m_bEnableDiskIoTrace = (BOOL)((dwKernelFlags & SLQ_TLI_ENABLE_DISKIO_TRACE) != 0);
        m_bEnableNetworkTcpipTrace = (BOOL)((dwKernelFlags & SLQ_TLI_ENABLE_NETWORK_TCPIP_TRACE) != 0);
    }
    m_bEnableMemMgmtTrace = (BOOL)((dwKernelFlags & SLQ_TLI_ENABLE_MEMMAN_TRACE) != 0);
    m_bEnableFileIoTrace = (BOOL)((dwKernelFlags & SLQ_TLI_ENABLE_FILEIO_TRACE) != 0);

    m_dwTraceMode = ( 0 != dwKernelFlags ) ? eTraceModeKernel : eTraceModeApplication;

    if ( eTraceModeApplication == m_dwTraceMode ) {
        // If initial mode is set to Application, initialize the Kernel
        // trace events to the default.
        m_bEnableProcessTrace = TRUE;
        m_bEnableThreadTrace = TRUE;
        m_bEnableDiskIoTrace = TRUE;
        m_bEnableNetworkTcpipTrace = TRUE;
    }

    CSmPropertyPage::OnInitDialog();
    SetHelpIds ( (DWORD*)&s_aulHelpIds );
    Initialize( m_pTraceLogQuery );
    m_strUserDisplay = m_pTraceLogQuery->m_strUser;
    m_strUserSaved = m_strUserDisplay;

    SetDetailsGroupBoxMode();

    SetTraceModeState();

    if ( m_bNonsystemProvidersExist ) {
        if ( 0 < plbInQueryProviders->GetCount() ) {
            // select first entry
            plbInQueryProviders->SetSel (0, TRUE);
            plbInQueryProviders->SetCaretIndex (0, TRUE);
        } else {
            plbInQueryProviders->SetSel (-1, TRUE);
            GetDlgItem(IDC_PROV_ADD_BTN)->SetFocus();
        }
    } else {
        CString strNoProviders;

        strNoProviders.LoadString( IDS_PROV_NO_PROVIDERS );
        plbInQueryProviders->AddString( strNoProviders );
        plbInQueryProviders->EnableWindow(FALSE);

        GetDlgItem(IDC_PROV_REMOVE_BTN)->EnableWindow(FALSE);
        GetDlgItem(IDC_PROV_ADD_BTN)->EnableWindow(FALSE);
    }

    if (m_pTraceLogQuery->GetLogService()->TargetOs() == OS_WIN2K) {
        GetDlgItem(IDC_RUNAS_STATIC)->EnableWindow(FALSE);
        GetDlgItem(IDC_RUNAS_EDIT)->EnableWindow(FALSE);
    }

    if (m_pTraceLogQuery->GetLogService()->TargetOs() == OS_WIN2K ||
        m_strUserDisplay.IsEmpty() || m_strUserDisplay.GetAt(0) == L'<') {

        GetDlgItem(IDC_SETPWD_BTN)->EnableWindow(FALSE);
        m_bPwdButtonEnabled = FALSE;
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CProvidersProperty::PostNcDestroy() 
{
//  delete this;      

    if ( NULL != m_pTraceLogQuery ) {
        m_pTraceLogQuery->SetActivePropertyPage( NULL );
    }

    CPropertyPage::PostNcDestroy();
}

//
// Helper functions.
//
void 
CProvidersProperty::SetAddRemoveBtnState ( void )
{
    if ( m_bNonsystemProvidersExist ) {
        
        if ( eTraceModeKernel == m_dwTraceMode ) {
            GetDlgItem(IDC_PROV_REMOVE_BTN)->EnableWindow(FALSE);
            GetDlgItem(IDC_PROV_ADD_BTN)->EnableWindow(FALSE);
        } else { 
            CListBox * plbInQueryProviders = (CListBox *)GetDlgItem(IDC_PROV_PROVIDER_LIST);
            INT iTotalCount;

            iTotalCount = plbInQueryProviders->GetCount();

            if ( 0 < plbInQueryProviders->GetSelCount() ) {
                GetDlgItem(IDC_PROV_REMOVE_BTN)->EnableWindow(TRUE);
            } else {
                GetDlgItem(IDC_PROV_REMOVE_BTN)->EnableWindow(FALSE);
            }

            if ( iTotalCount < m_arrGenProviders.GetSize() ) {
                GetDlgItem(IDC_PROV_ADD_BTN)->EnableWindow(TRUE);
            } else {
                GetDlgItem(IDC_PROV_ADD_BTN)->EnableWindow(FALSE);
            }

            if ( 0 == iTotalCount ) {
                plbInQueryProviders->SetSel(-1);
            }
        }     
    }
}


//
//  Return the description for the trace provider specified by
//  InQuery array index.
//  
DWORD   
CProvidersProperty::GetProviderDescription ( INT iProvIndex, CString& rstrDesc )
{
    ASSERT ( NULL != m_pTraceLogQuery );

    rstrDesc = m_pTraceLogQuery->GetProviderDescription ( iProvIndex );

    // If the description is empty, build name from guid.
    if ( rstrDesc.IsEmpty() ) {
        CString strGuid;
        ASSERT( !m_pTraceLogQuery->IsActiveProvider( iProvIndex) );
        strGuid = m_pTraceLogQuery->GetProviderGuid( iProvIndex );
        rstrDesc.Format ( IDS_PROV_UNKNOWN, strGuid );
    }

    return ERROR_SUCCESS;
}

BOOL 
CProvidersProperty::IsEnabledProvider( INT iIndex )
{
    ASSERT ( NULL != m_pTraceLogQuery );
    return ( m_pTraceLogQuery->IsEnabledProvider ( iIndex ) );
}

BOOL 
CProvidersProperty::IsActiveProvider( INT iIndex )
{
    ASSERT ( NULL != m_pTraceLogQuery );
    return ( m_pTraceLogQuery->IsActiveProvider ( iIndex ) );
}

LPCWSTR 
CProvidersProperty::GetKernelProviderDescription( void )
{
    ASSERT ( NULL != m_pTraceLogQuery );
    return ( m_pTraceLogQuery->GetKernelProviderDescription ( ) );
}

BOOL 
CProvidersProperty::GetKernelProviderEnabled( void )
{
    ASSERT ( NULL != m_pTraceLogQuery );
    return ( m_pTraceLogQuery->GetKernelProviderEnabled ( ) );
}

//
//  Update the provided InQuery array to match the stored version.
//  
DWORD 
CProvidersProperty::GetInQueryProviders( CArray<CSmTraceLogQuery::eProviderState, CSmTraceLogQuery::eProviderState&>& rarrOut )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    int     iIndex;

    rarrOut.RemoveAll();

    rarrOut.SetSize( m_arrGenProviders.GetSize() );

    for ( iIndex = 0; iIndex < rarrOut.GetSize(); iIndex++ ) {
        rarrOut[iIndex] = m_arrGenProviders[iIndex];
    }

    return dwStatus;
}

//
//  Load the stored InQuery providers array 
//  based on the provided version.
//  
DWORD 
CProvidersProperty::SetInQueryProviders( CArray<CSmTraceLogQuery::eProviderState, CSmTraceLogQuery::eProviderState&>& rarrIn )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    int     iProvIndex;

    m_arrGenProviders.RemoveAll();

    m_arrGenProviders.SetSize( rarrIn.GetSize() );

    for ( iProvIndex = 0; iProvIndex < m_arrGenProviders.GetSize(); iProvIndex++ ) {
        m_arrGenProviders[iProvIndex] = rarrIn[iProvIndex];
    }

    return dwStatus;
}

void 
CProvidersProperty::ImplementAdd( void ) 
{
    INT_PTR iReturn = IDCANCEL;
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        CProviderListDlg dlgAddProviders(this);

        // Workaround for popup to store pointer to this page.
        dlgAddProviders.SetProvidersPage( this );
        
        iReturn = dlgAddProviders.DoModal();
    }

    if ( IDOK == iReturn ) {
        LONG    lBeforeCount;
        LONG    lAfterCount;
        CListBox    *plbProviderList;

        plbProviderList = (CListBox *)GetDlgItem(IDC_PROV_PROVIDER_LIST);

        // Providers array is modified by the add dialog OnOK procedure.
        lBeforeCount = plbProviderList->GetCount();
        UpdateData ( FALSE );
        lAfterCount = plbProviderList->GetCount();

        SetAddRemoveBtnState();

        if ( lAfterCount > lBeforeCount ) {
            SetModifiedPage ( TRUE );
        }
    }
}

void 
CProvidersProperty::UpdateLogStartString ()
{
    eStartType  eCurrentStartType;
    int     nResId = 0;
    ResourceStateManager    rsm;

    eCurrentStartType = DetermineCurrentStartType();

    if ( eStartManually == eCurrentStartType ) {
        nResId = IDS_LOG_START_MANUALLY;
    } else if ( eStartImmediately == eCurrentStartType ) {
        nResId = IDS_LOG_START_IMMED;
    } else if ( eStartSched == eCurrentStartType ) {
        nResId = IDS_LOG_START_SCHED;
    }

    if ( 0 != nResId ) {
        m_strStartText.LoadString(nResId);
    } else {
        m_strStartText.Empty();
    }

    return;
}

void 
CProvidersProperty::UpdateFileNameString ()
{
    m_strFileNameDisplay.Empty();

    CreateSampleFileName (
        m_pTraceLogQuery->GetLogName(),
        m_pTraceLogQuery->GetLogService()->GetMachineName(),
        m_SharedData.strFolderName, 
        m_SharedData.strFileBaseName,
        m_SharedData.strSqlName,
        m_SharedData.dwSuffix, 
        m_SharedData.dwLogFileType,
        m_SharedData.dwSerialNumber,
        m_strFileNameDisplay);

    SetDlgItemText( IDC_PROV_FILENAME_DISPLAY, m_strFileNameDisplay );
    
    // Clear the selection
    ((CEdit*)GetDlgItem( IDC_PROV_FILENAME_DISPLAY ))->SetSel ( -1, 0 );

    return;
}

BOOL 
CProvidersProperty::OnSetActive()
{

    BOOL        bReturn;

    bReturn = CSmPropertyPage::OnSetActive();
    if (!bReturn) return FALSE;

    ResourceStateManager    rsm;

    m_pTraceLogQuery->GetPropPageSharedData ( &m_SharedData );

    UpdateFileNameString();

    UpdateLogStartString();
    m_strUserDisplay = m_pTraceLogQuery->m_strUser;

    UpdateData(FALSE); //to load the edit & combo box

    return TRUE;
}

BOOL 
CProvidersProperty::OnKillActive() 
{
    BOOL bContinue = TRUE;
        
    bContinue = CPropertyPage::OnKillActive();

    if ( bContinue ) {
        m_pTraceLogQuery->m_strUser = m_strUserDisplay;
        bContinue = IsValidData(m_pTraceLogQuery, VALIDATE_FOCUS );
    }

    // The providers page does not modify shared data, so no reason to update it.

    if ( bContinue ) {
        SetIsActive ( FALSE );
    }

    return bContinue;
}

void 
CProvidersProperty::OnProvKernelEnableCheck() 
{
    BOOL bMemFlag = m_bEnableMemMgmtTrace;
    BOOL bFileFlag = m_bEnableFileIoTrace;

    UpdateData(TRUE);
    SetModifiedPage(TRUE);

    bMemFlag  = (!bMemFlag && m_bEnableMemMgmtTrace);
    bFileFlag = (!bFileFlag && m_bEnableFileIoTrace);

    if (bMemFlag || bFileFlag) {
        long nErr;
        HKEY hKey = NULL;
        DWORD dwWarnFlag;
        DWORD dwDataType = 0;
        DWORD dwDataSize = 0;
        DWORD dwDisposition;

        // User has checked expensive file io flag
        // check registry setting to see if we need to pop up warning dialog
        nErr = RegOpenKey( HKEY_CURRENT_USER,
                           L"Software\\Microsoft\\PerformanceLogsandAlerts",
                           &hKey
                         );
        dwWarnFlag = 0;
        if( nErr == ERROR_SUCCESS ) {

            dwDataSize = sizeof(DWORD);
            nErr = RegQueryValueExW(
                        hKey,
                        (bMemFlag ? L"NoWarnPageFault" : L"NoWarnFileIo"),
                        NULL,
                        &dwDataType,
                        (LPBYTE) &dwWarnFlag,
                        (LPDWORD) &dwDataSize
                        );
            if ( (dwDataType != REG_DWORD) || (dwDataSize != sizeof(DWORD)))
                dwWarnFlag = 0;

            nErr = RegCloseKey( hKey );
            hKey = NULL;
            if( ERROR_SUCCESS != nErr ) {
                DisplayError( GetLastError(), L"Close PerfLog user key failed" );
            }
        }
        if (!dwWarnFlag || nErr != ERROR_SUCCESS) {
            // Pop a dialog here. Need to do a RegQuerySetValue dialog is checked to keep quiet
            // bMemFlag & bFileFlag gives a clue about what it is doing

            CWarnDlg    WarnDlg;
            
            AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
            WarnDlg.SetProvidersPage( this );

            if (IDOK == WarnDlg.DoModal()){
                if (WarnDlg.m_CheckNoMore){
                    dwWarnFlag = WarnDlg.m_CheckNoMore;

                    nErr = RegCreateKeyEx( HKEY_CURRENT_USER,
                                       L"Software\\Microsoft\\PerformanceLogsAndAlerts",
                                       0,
                                       L"REG_DWORD",
                                       REG_OPTION_NON_VOLATILE,
                                       KEY_READ | KEY_WRITE,
                                       NULL,
                                       &hKey,
                                       &dwDisposition);
/*                    
                    if(ERROR_SUCCESS == nErr){
                        if (dwDisposition == REG_CREATED_NEW_KEY){
                            //just in case I need this
                        }else if (dwDisposition  == REG_OPENED_EXISTING_KEY){
                            //Just in case I need this 
                        }
                    }
*/
                    if( nErr == ERROR_SUCCESS ) {
                        dwDataSize = sizeof(DWORD);
                        nErr = RegSetValueEx(hKey,
                                    (bMemFlag ? L"NoWarnPageFault" : L"NoWarnFileIo" ),
                                    NULL,
                                    REG_DWORD,
                                    (LPBYTE) &dwWarnFlag,
                                    dwDataSize
                                    );
                        if( ERROR_SUCCESS != nErr ) {
                            DisplayError( GetLastError(), L"Set PerfLog User warn value failed" );
                        }

                        nErr = RegCloseKey( hKey );
                        hKey = NULL;
                        if( ERROR_SUCCESS != nErr ) {
                            DisplayError( GetLastError(), L"Close PerfLog user key failed" );
                        }
                    } 
                }
            }
        }
    }
}

void
CProvidersProperty::OnProvShowProvBtn() 
{
    CActiveProviderDlg ProvLstDlg;
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    ProvLstDlg.SetProvidersPage( this );

    ProvLstDlg.DoModal();

}
/*
void 
CProvidersProperty::OnProvDetailsBtn() 
{
    SetDetailsGroupBoxMode();
}
*/
BOOL    
CProvidersProperty::SetDetailsGroupBoxMode()
{

    UINT    nWindowState;

    ResourceStateManager    rsm;

    nWindowState = SW_SHOW;

    GetDlgItem(IDC_PROV_K_PROCESS_CHK)->ShowWindow(nWindowState);
    GetDlgItem(IDC_PROV_K_THREAD_CHK)->ShowWindow(nWindowState);
    GetDlgItem(IDC_PROV_K_DISK_IO_CHK)->ShowWindow(nWindowState);
    GetDlgItem(IDC_PROV_K_NETWORK_CHK)->ShowWindow(nWindowState);
    GetDlgItem(IDC_PROV_K_SOFT_PF_CHK)->ShowWindow(nWindowState);
    GetDlgItem(IDC_PROV_K_FILE_IO_CHK)->ShowWindow(nWindowState);

    return TRUE;
}

void 
CProvidersProperty::TraceModeRadioExchange(CDataExchange* pDX)
{
    if ( !pDX->m_bSaveAndValidate ) {
        // Load control value from data

        switch ( m_dwTraceMode ) {
            case eTraceModeKernel:
                m_nTraceModeRdo = 0;
                break;
            case eTraceModeApplication:
                m_nTraceModeRdo = 1;
                break;
            default:
                ;
                break;
        }
    }

    DDX_Radio(pDX, IDC_PROV_KERNEL_BTN, m_nTraceModeRdo);

    if ( pDX->m_bSaveAndValidate ) {

        switch ( m_nTraceModeRdo ) {
            case 0:
                m_dwTraceMode = eTraceModeKernel;
                break;
            case 1:
                m_dwTraceMode = eTraceModeApplication;
                break;
            default:
                ;
                break;
        }
        SetTraceModeState();
    }

}

void 
CProvidersProperty::SetTraceModeState ( void )
{
    BOOL bEnable;

    bEnable = (eTraceModeKernel == m_dwTraceMode) ? TRUE : FALSE; 
    // Kernel trace controls    
//    GetDlgItem(IDC_PROV_SHOW_ADV_BTN)->EnableWindow(bEnable);
    GetDlgItem(IDC_PROV_K_PROCESS_CHK)->EnableWindow(bEnable);
    GetDlgItem(IDC_PROV_K_THREAD_CHK)->EnableWindow(bEnable);
    GetDlgItem(IDC_PROV_K_DISK_IO_CHK)->EnableWindow(bEnable);
    GetDlgItem(IDC_PROV_K_NETWORK_CHK)->EnableWindow(bEnable);
    GetDlgItem(IDC_PROV_K_SOFT_PF_CHK)->EnableWindow(bEnable);
    GetDlgItem(IDC_PROV_K_FILE_IO_CHK)->EnableWindow(bEnable);

    if ( m_bNonsystemProvidersExist ) {
        bEnable = !bEnable;
        // Application trace controls
        GetDlgItem(IDC_PROV_PROVIDER_LIST)->EnableWindow(bEnable);
        SetAddRemoveBtnState();
    }

}

DWORD 
CProvidersProperty::GetGenProviderCount ( INT& iCount )
{
    return m_pTraceLogQuery->GetGenProviderCount( iCount );

}

void CProvidersProperty::GetMachineDisplayName ( CString& rstrMachineName )
{
    m_pTraceLogQuery->GetMachineDisplayName( rstrMachineName );
    return;
}

CSmTraceLogQuery* 
CProvidersProperty::GetTraceQuery ( void )
{
    return m_pTraceLogQuery;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smabout.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smabout.cpp

Abstract:

    Implementation of the ISnapinAbout MMC interface.

--*/

#include "stdafx.h"
#include "smabout.h" 
#include <ntverp.h>

CSmLogAbout::CSmLogAbout()
:   m_uIdStrDescription ( IDS_SNAPINABOUT_DESCRIPTION ),
    m_uIdIconImage ( IDI_SMLOGCFG ),
    m_uIdBitmapSmallImage ( IDB_SMLOGCFG_16x16 ),
    m_uIdBitmapSmallImageOpen ( IDB_SMLOGCFG_16x16 ),
    m_uIdBitmapLargeImage ( IDB_SMLOGCFG_32x32 ),
    m_crImageMask ( RGB(255, 0, 255) ),
    refcount(1)    // implicit AddRef
{
    // Initialize Resource IDs.
}

CSmLogAbout::~CSmLogAbout()
{
}


ULONG __stdcall
CSmLogAbout::AddRef()
{
   return InterlockedIncrement(&refcount);
}



ULONG __stdcall
CSmLogAbout::Release()
{
   if (InterlockedDecrement(&refcount) == 0)
   {
      delete this;
      return 0;
   }

   return refcount;
}



HRESULT __stdcall
CSmLogAbout::QueryInterface(
   const IID&  interfaceID,
   void**      interfaceDesired)
{
   ASSERT(interfaceDesired);

   HRESULT hr = 0;

   if (!interfaceDesired)
   {
      hr = E_INVALIDARG;
      return hr;
   }

   if (interfaceID == IID_IUnknown)
   {
      *interfaceDesired =
         static_cast<IUnknown*>(static_cast<ISnapinAbout*>(this));
   }
   else if (interfaceID == IID_ISnapinAbout)
   {
      *interfaceDesired = static_cast<ISnapinAbout*>(this);
   }
   else
   {
      *interfaceDesired = 0;
      hr = E_NOINTERFACE;
      return hr;
   }

   AddRef();
   return S_OK;
}


HRESULT __stdcall  
CSmLogAbout::GetSnapinDescription (
    OUT LPOLESTR __RPC_FAR *lpDescription ) 
{
    return HrLoadOleString(m_uIdStrDescription, lpDescription);
}

HRESULT __stdcall  
CSmLogAbout::GetProvider ( 
    OUT LPOLESTR __RPC_FAR *lpName ) 
{
    return TranslateString(VER_COMPANYNAME_STR, lpName);
}

HRESULT __stdcall  
CSmLogAbout::GetSnapinVersion ( 
    OUT LPOLESTR __RPC_FAR *lpVersion ) 
{
    return TranslateString(VER_PRODUCTVERSION_STR, lpVersion);
}

HRESULT
CSmLogAbout::TranslateString(
    IN  LPSTR lpSrc,
    OUT LPOLESTR __RPC_FAR *lpDst)
{
    int nWChar;

    if ( lpDst == NULL ) {
        return E_POINTER;
    }

    nWChar = MultiByteToWideChar(CP_ACP, 
                                 0, 
                                 lpSrc, 
                                 strlen(lpSrc),
                                 NULL, 
                                 0);
    *lpDst = reinterpret_cast<LPOLESTR>
               (CoTaskMemAlloc((nWChar + 1) * sizeof(wchar_t)));

    if (*lpDst == NULL) {
        return E_OUTOFMEMORY;
    }
    
    MultiByteToWideChar(CP_ACP,
                        0,
                        lpSrc,
                        strlen(lpSrc),
                        *lpDst,
                        nWChar);
    (*lpDst)[nWChar] = L'\0';
    return S_OK;
}

HRESULT __stdcall  
CSmLogAbout::GetSnapinImage (
    OUT HICON __RPC_FAR *hAppIcon )
{
    if (hAppIcon == NULL)
        return E_POINTER;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());    // Required for AfxGetInstanceHandle()
    
    *hAppIcon = ::LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(m_uIdIconImage));
    
    if (*hAppIcon == NULL)
    {
        ASSERT(FALSE && "Unable to load icon");
        return E_FAIL;
    }
    return S_OK;
}

HRESULT __stdcall  
CSmLogAbout::GetStaticFolderImage (
    OUT HBITMAP __RPC_FAR *hSmallImage,
    OUT HBITMAP __RPC_FAR *hSmallImageOpen,
    OUT HBITMAP __RPC_FAR *hLargeImage,
    OUT COLORREF __RPC_FAR *crMask )
{   
    ASSERT(hSmallImage != NULL);
    ASSERT(hSmallImageOpen != NULL);
    ASSERT(hLargeImage != NULL);
    ASSERT(crMask != NULL);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());    // Required for AfxGetInstanceHandle()
    HINSTANCE hInstance = AfxGetInstanceHandle();
    *hSmallImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapSmallImage));
    *hSmallImageOpen = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapSmallImageOpen));
    *hLargeImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapLargeImage));
    *crMask = m_crImageMask;
#ifdef _DEBUG
    if (NULL == *hSmallImage || NULL == *hSmallImageOpen || NULL == *hLargeImage)
    {
        TRACE0("WRN: CSmLogAbout::GetStaticFolderImage() - Unable to load all the bitmaps.\n");
        return E_FAIL;
    }
#endif
    return S_OK;
}

/////////////////////////////////////////////////////////////////////
//  HrLoadOleString()
//
//  Load a string from the resource and return pointer to allocated
//  OLE string.
//
//  HISTORY
//  16-Nov-98   a-kathse    Creation from framewrk\stdutils.cpp
//
HRESULT
CSmLogAbout::HrLoadOleString(
    UINT uStringId,                 // IN: String Id to load from the resource
    OUT LPOLESTR * ppaszOleString)  // OUT: Pointer to pointer to allocated OLE string
{
    CString strT;       // Temporary string
    USES_CONVERSION;

    if ( ppaszOleString == NULL ) {
        TRACE0("HrLoadOleString() - ppaszOleString is NULL.\n");
        return E_POINTER;
    }
    AFX_MANAGE_STATE(AfxGetStaticModuleState());    // Needed for LoadString()
    VERIFY( strT.LoadString(uStringId) );

    *ppaszOleString = reinterpret_cast<LPOLESTR>
            (CoTaskMemAlloc((strT.GetLength() + 1)* sizeof(wchar_t)));
    
    if (*ppaszOleString == NULL)
        return E_OUTOFMEMORY;

    wcscpy(OUT *ppaszOleString, (LPWSTR)(LPCWSTR)strT);
    
    return S_OK;
} // HrLoadOleString()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\schdprop.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    schdprop.h

Abstract:

	Implementation of the schedule property page.

--*/

#ifndef _SCHDPROP_H_
#define _SCHDPROP_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "smlogqry.h"   // For shared property page data structure
#include "smproppg.h"
#include "smcfghlp.h"

// Dialog controls

#define IDD_SCHEDULE_PROP               600

#define IDC_SCHED_START_GROUP           601
#define IDC_SCHED_STOP_GROUP            602
#define IDC_SCHED_START_AT_ON_CAPTION   603
#define IDC_SCHED_STOP_AT_ON_CAPTION    604
#define IDC_SCHED_STOP_AFTER_STATIC     605
#define IDC_SCHED_STOP_WHEN_STATIC      606
#define IDC_SCHED_FIRST_HELP_CTRL_ID    607
#define IDC_SCHED_START_MANUAL_RDO      607
#define IDC_SCHED_START_AT_RDO          608
#define IDC_SCHED_START_AT_TIME_DT      609    
#define IDC_SCHED_START_AT_DATE_DT      610
#define IDC_SCHED_STOP_MANUAL_RDO       611
#define IDC_SCHED_STOP_AT_RDO           612
#define IDC_SCHED_STOP_AFTER_RDO        613
#define IDC_SCHED_STOP_SIZE_RDO         614
#define IDC_SCHED_STOP_AT_TIME_DT       615
#define IDC_SCHED_STOP_AT_DATE_DT       616
#define IDC_SCHED_STOP_AFTER_EDIT       617
#define IDC_SCHED_STOP_AFTER_SPIN       618
#define IDC_SCHED_STOP_AFTER_UNITS_COMBO 619

#define IDC_SCHED_RESTART_CHECK         620
#define IDC_SCHED_EXEC_CHECK            621
#define IDC_SCHED_CMD_EDIT              622
#define IDC_SCHED_CMD_BROWSE_BTN        623


/////////////////////////////////////////////////////////////////////////////
// CScheduleProperty dialog

class CScheduleProperty : public CSmPropertyPage
{
    DECLARE_DYNCREATE(CScheduleProperty)

// Construction
public:
            CScheduleProperty(
                MMC_COOKIE lCookie, 
                LONG_PTR hConsole,
                LPDATAOBJECT pDataObject);
            CScheduleProperty();
    virtual ~CScheduleProperty();

// Dialog Data
    //{{AFX_DATA(CScheduleProperty)
    enum { IDD = IDD_SCHEDULE_PROP };
    INT     m_nStopModeRdo;
    INT     m_nStartModeRdo;
    SYSTEMTIME  m_stStartAt;
    SYSTEMTIME  m_stStopAt;
    DWORD   m_dwStopAfterCount;
    INT     m_nStopAfterUnits;
    BOOL    m_bAutoRestart;
    CString m_strEofCommand;
    BOOL    m_bExecEofCommand;
    //}}AFX_DATA

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CScheduleProperty)
    public:
    protected:
    virtual void OnFinalRelease();
    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL

// Implementation
protected:

    virtual INT GetFirstHelpCtrlId ( void ) { return IDC_SCHED_FIRST_HELP_CTRL_ID; };  // Subclass must override.
    virtual BOOL IsValidLocalData ();

    // Generated message map functions
    //{{AFX_MSG(CScheduleProperty)
    afx_msg void OnSchedCmdBrowseBtn();
    afx_msg void OnSchedRestartCheck();
    afx_msg void OnSchedExecCheck();
    afx_msg void OnSchedStartRdo();
    afx_msg void OnSchedStopRdo();
    afx_msg void OnKillfocusSchedStartAtDt(NMHDR*, LRESULT*);
    afx_msg void OnKillfocusSchedCmdEdit();
    afx_msg void OnKillfocusSchedStopAfterEdit();
    afx_msg void OnKillfocusSchedStopAtDt(NMHDR*, LRESULT*);
    afx_msg void OnDeltaposSchedStopAfterSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSelendokSchedStopAfterUnitsCombo();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CScheduleProperty)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()

// private methods
private:
    void SetStartBtnState ( void );
    void SetStopBtnState ( void );
    void SetCmdBtnState ( void );
    void StartModeRadioExchange ( CDataExchange* ); 
    void StopModeRadioExchange ( CDataExchange* ); 
    
    void StartAtExchange ( CDataExchange* ); 
    void StopAtExchange ( CDataExchange* ); 

    void FillStartTimeStruct ( PSLQ_TIME_INFO );
    void UpdateSharedStopTimeStruct ( void );
    void SetStopDefaultValues ( PSLQ_TIME_INFO );

    BOOL SaveDataToModel ( void );

// public methods
public:

// private member variables
private:
    LONGLONG            m_llManualStartTime;
    LONGLONG            m_llManualStopTime;
    DWORD               m_dwStopAfterUnitsValue;
    DWORD               m_dwCurrentStartMode;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _SCHDPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\schdprop.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    schdprop.cpp

Abstract:

    Implementation of the schedule property page.

--*/

#include "stdafx.h"
#include <pdh.h>        // for MIN_TIME_VALUE, MAX_TIME_VALUE
#include "smcfgmsg.h"
#include "globals.h"
#include "smlogs.h"
#include "schdprop.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


static ULONG
s_aulHelpIds[] =
{
    IDC_SCHED_START_MANUAL_RDO, IDH_SCHED_START_MANUAL_RDO,
    IDC_SCHED_START_AT_RDO,     IDH_SCHED_START_AT_RDO,
    IDC_SCHED_START_AT_TIME_DT, IDH_SCHED_START_AT_TIME_DT,
    IDC_SCHED_START_AT_DATE_DT, IDH_SCHED_START_AT_DATE_DT,
    IDC_SCHED_STOP_MANUAL_RDO,  IDH_SCHED_STOP_MANUAL_RDO,
    IDC_SCHED_STOP_AT_RDO,      IDH_SCHED_STOP_AT_RDO,
    IDC_SCHED_STOP_AFTER_RDO,   IDH_SCHED_STOP_AFTER_RDO,
    IDC_SCHED_STOP_SIZE_RDO,    IDH_SCHED_STOP_SIZE_RDO,
    IDC_SCHED_STOP_AT_TIME_DT,  IDH_SCHED_STOP_AT_TIME_DT,
    IDC_SCHED_STOP_AT_DATE_DT,  IDH_SCHED_STOP_AT_DATE_DT,
    IDC_SCHED_STOP_AFTER_SPIN,  IDH_SCHED_STOP_AFTER_EDIT,
    IDC_SCHED_STOP_AFTER_EDIT,  IDH_SCHED_STOP_AFTER_EDIT,
    IDC_SCHED_STOP_AFTER_UNITS_COMBO,   IDH_SCHED_STOP_AFTER_UNITS_COMBO,
    IDC_SCHED_RESTART_CHECK,    IDH_SCHED_RESTART_CHECK,
    IDC_SCHED_EXEC_CHECK,       IDH_SCHED_EXEC_CHECK,
    IDC_SCHED_CMD_EDIT,         IDH_SCHED_CMD_EDIT,
    IDC_SCHED_CMD_BROWSE_BTN,   IDH_SCHED_CMD_BROWSE_BTN,
    0,0 
};

/////////////////////////////////////////////////////////////////////////////
// CScheduleProperty property page

IMPLEMENT_DYNCREATE(CScheduleProperty, CSmPropertyPage)

CScheduleProperty::CScheduleProperty(
    MMC_COOKIE lCookie, 
    LONG_PTR hConsole,
    LPDATAOBJECT pDataObject ) 
:   CSmPropertyPage ( CScheduleProperty::IDD, hConsole, pDataObject ),
    m_llManualStartTime ( MAX_TIME_VALUE ),
    m_llManualStopTime ( MIN_TIME_VALUE )
{
    // save pointers from arg list
    m_pQuery = reinterpret_cast <CSmLogQuery *>(lCookie);

//  EnableAutomation();
    //{{AFX_DATA_INIT(CScheduleProperty)
    m_dwStopAfterCount = 0;
    m_nStopAfterUnits = -1;
    m_bAutoRestart = FALSE;
    m_strEofCommand = L"";
    m_bExecEofCommand = FALSE;
    //}}AFX_DATA_INIT
    ZeroMemory (&m_stStartAt, sizeof ( m_stStartAt ) );
    ZeroMemory (&m_stStopAt, sizeof ( m_stStopAt ) );
}

CScheduleProperty::CScheduleProperty() : CSmPropertyPage(CScheduleProperty::IDD)
{
    ASSERT (FALSE); // only the constructor w/ args should be called

    EnableAutomation();
//  //{{AFX_DATA_INIT(CScheduleProperty)
    m_dwStopAfterCount = 0;
    m_nStopAfterUnits = -1;
    m_bAutoRestart = FALSE;
    m_strEofCommand = L"";
    m_bExecEofCommand = FALSE;
//  //}}AFX_DATA_INIT
}

CScheduleProperty::~CScheduleProperty()
{
}

void 
CScheduleProperty::OnFinalRelease()
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CPropertyPage::OnFinalRelease();
}

BOOL
CScheduleProperty::IsValidLocalData()
{
    LONGLONG    llStopTime;
    INT         iPrevLength = 0;
    BOOL        bContinue = TRUE;

    ResourceStateManager    rsm;

    // Trim text fields before validation
    iPrevLength = m_strEofCommand.GetLength();
    m_strEofCommand.TrimLeft();
    m_strEofCommand.TrimRight();
    
    if ( iPrevLength != m_strEofCommand.GetLength() ) {
        SetDlgItemText ( IDC_SCHED_CMD_EDIT, m_strEofCommand );  
    }
    
    if ( SLQ_AUTO_MODE_AT == m_SharedData.stiStopTime.dwAutoMode ) {

        SystemTimeToFileTime ( &m_stStopAt, (FILETIME *)&llStopTime );

        if ( SLQ_AUTO_MODE_AT == m_dwCurrentStartMode ) {

            LONGLONG llStartTime;

            SystemTimeToFileTime ( &m_stStartAt, (FILETIME *)&llStartTime );

            if ( llStartTime >= llStopTime ) {
                CString strMessage;

                strMessage.LoadString ( IDS_SCHED_START_PAST_STOP );

                MessageBox ( strMessage, m_pQuery->GetLogName(), MB_OK  | MB_ICONERROR );
                SetFocusAnyPage ( IDC_SCHED_STOP_AT_TIME_DT );
                bContinue = FALSE;
            }
        } else {
            // Start mode is manual.
            // get local time
            SYSTEMTIME  stLocalTime;
            FILETIME    ftLocalTime;
            
            // Milliseconds set to 0 for Schedule times
            ftLocalTime.dwLowDateTime = ftLocalTime.dwHighDateTime = 0;
            GetLocalTime (&stLocalTime);
            stLocalTime.wMilliseconds = 0;
            SystemTimeToFileTime (&stLocalTime, &ftLocalTime);

            if ( *(LONGLONG*)&ftLocalTime >= llStopTime ) {            
                CString strMessage;

                strMessage.LoadString ( IDS_SCHED_NOW_PAST_STOP );                
                
                MessageBox ( strMessage, m_pQuery->GetLogName(), MB_OK  | MB_ICONERROR );
                SetFocusAnyPage ( IDC_SCHED_STOP_AT_TIME_DT );
                bContinue = FALSE;
            }
        }
    } else if ( SLQ_AUTO_MODE_AFTER == m_SharedData.stiStopTime.dwAutoMode ) { 

        bContinue = ValidateDWordInterval(IDC_SCHED_STOP_AFTER_EDIT,
                                          m_pQuery->GetLogName(),
                                          (long) m_dwStopAfterCount,
                                          1,
                                          100000);
    }

    // Validate command file path if logging to local machine.
    if ( bContinue 
            && m_pQuery->GetLogService()->IsLocalMachine()
            && m_bExecEofCommand ) {
        DWORD dwStatus;

        dwStatus = IsCommandFilePathValid ( m_strEofCommand );

        if ( ERROR_SUCCESS != dwStatus ) {
            CString strMessage;

            FormatSmLogCfgMessage ( 
                strMessage,
                m_hModule, 
                dwStatus );
                    
            MessageBox ( strMessage, m_pQuery->GetLogName(), MB_OK  | MB_ICONERROR);
            SetFocusAnyPage ( IDC_SCHED_CMD_EDIT );
            bContinue = FALSE;
        }
    }

    return bContinue;
}

void 
CScheduleProperty::StartModeRadioExchange(CDataExchange* pDX)
{
    if ( !pDX->m_bSaveAndValidate ) {
        // Load control value from data

        switch ( m_dwCurrentStartMode ) {
            case SLQ_AUTO_MODE_NONE:
                m_nStartModeRdo = 0;
                break;
            case SLQ_AUTO_MODE_AT:
                m_nStartModeRdo = 1;
                break;
            default:
                ;
                break;
        }
    }

    DDX_Radio(pDX, IDC_SCHED_START_MANUAL_RDO, m_nStartModeRdo);

    if ( pDX->m_bSaveAndValidate ) {

        switch ( m_nStartModeRdo ) {
            case 0:
                m_dwCurrentStartMode = SLQ_AUTO_MODE_NONE;
                break;
            case 1:
                m_dwCurrentStartMode = SLQ_AUTO_MODE_AT;
                break;
            default:
                ;
                break;
        }
    }
}

void 
CScheduleProperty::StartAtExchange(CDataExchange* pDX)
{
    CWnd* pWndTime = NULL;
    CWnd* pWndDate = NULL;

    pWndTime = GetDlgItem(IDC_SCHED_START_AT_TIME_DT);
    pWndDate = GetDlgItem(IDC_SCHED_START_AT_DATE_DT);
    
    if ( pDX->m_bSaveAndValidate ) {
        DWORD dwStatus;
        SYSTEMTIME stTemp;
        
        dwStatus = DateTime_GetSystemtime ( pWndTime->m_hWnd, &stTemp );

        m_stStartAt.wHour = stTemp.wHour;
        m_stStartAt.wMinute = stTemp.wMinute;
        m_stStartAt.wSecond = stTemp.wSecond;
        m_stStartAt.wMilliseconds = 0;

        dwStatus = DateTime_GetSystemtime ( pWndDate->m_hWnd, &stTemp );

        m_stStartAt.wYear = stTemp.wYear;
        m_stStartAt.wMonth = stTemp.wMonth;
        m_stStartAt.wDayOfWeek = stTemp.wDayOfWeek;
        m_stStartAt.wDay = stTemp.wDay;

        if ( SLQ_AUTO_MODE_AT == m_dwCurrentStartMode 
             && IsModifiedPage() ) {
            // Set manual stop time to MAX so that automatic start will occur.
            // Do this only if the user has modified something on the page.
            m_llManualStopTime = MAX_TIME_VALUE;
        }
    } else {
        BOOL bStatus;
        bStatus = DateTime_SetSystemtime ( pWndTime->m_hWnd, GDT_VALID, &m_stStartAt );
        bStatus = DateTime_SetSystemtime ( pWndDate->m_hWnd, GDT_VALID, &m_stStartAt );
    }
}

void 
CScheduleProperty::StopAtExchange(CDataExchange* pDX)
{
    CWnd* pWndTime = NULL;
    CWnd* pWndDate = NULL;

    pWndTime = GetDlgItem(IDC_SCHED_STOP_AT_TIME_DT);
    pWndDate = GetDlgItem(IDC_SCHED_STOP_AT_DATE_DT);
    
    if ( pDX->m_bSaveAndValidate ) {
        DWORD dwStatus;
        SYSTEMTIME stTemp;
        
        dwStatus = DateTime_GetSystemtime ( pWndTime->m_hWnd, &stTemp );

        m_stStopAt.wHour = stTemp.wHour;
        m_stStopAt.wMinute = stTemp.wMinute;
        m_stStopAt.wSecond = stTemp.wSecond;
        m_stStopAt.wMilliseconds = 0;

        dwStatus = DateTime_GetSystemtime ( pWndDate->m_hWnd, &stTemp );

        m_stStopAt.wYear = stTemp.wYear;
        m_stStopAt.wMonth = stTemp.wMonth;
        m_stStopAt.wDayOfWeek = stTemp.wDayOfWeek;
        m_stStopAt.wDay = stTemp.wDay;

    } else {
        BOOL bStatus;
        bStatus = DateTime_SetSystemtime ( pWndTime->m_hWnd, GDT_VALID, &m_stStopAt );
        bStatus = DateTime_SetSystemtime ( pWndDate->m_hWnd, GDT_VALID, &m_stStopAt );
    }
}

void 
CScheduleProperty::StopModeRadioExchange(CDataExchange* pDX)
{
    // Note:  Load is handled in OnInitDialog, OnSetActive.
    // That handling should be moved here.

    if ( !pDX->m_bSaveAndValidate ) {
        // Load control value from data

        switch ( m_SharedData.stiStopTime.dwAutoMode ) {
            case SLQ_AUTO_MODE_NONE:
                m_nStopModeRdo = 0;
                break;
            case SLQ_AUTO_MODE_AFTER:
                m_nStopModeRdo = 1;
                break;
            case SLQ_AUTO_MODE_AT:
                m_nStopModeRdo = 2;
                break;
            case SLQ_AUTO_MODE_SIZE:
                m_nStopModeRdo = 3;
                break;
            default:
                ;
                break;
        }
    }

    DDX_Radio(pDX, IDC_SCHED_STOP_MANUAL_RDO, m_nStopModeRdo);

    if ( pDX->m_bSaveAndValidate ) {

        switch ( m_nStopModeRdo ) {
            case 0:
                m_SharedData.stiStopTime.dwAutoMode = SLQ_AUTO_MODE_NONE;
                break;
            case 1:
                m_SharedData.stiStopTime.dwAutoMode = SLQ_AUTO_MODE_AFTER;
                break;
            case 2:
                m_SharedData.stiStopTime.dwAutoMode = SLQ_AUTO_MODE_AT;
                break;
            case 3:
                m_SharedData.stiStopTime.dwAutoMode = SLQ_AUTO_MODE_SIZE;
                break;
            default:
                ;
                break;
        }
    }
}

void 
CScheduleProperty::DoDataExchange(CDataExchange* pDX)
{
    CString strTemp;

    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CScheduleProperty)
    DDX_Text(pDX, IDC_SCHED_CMD_EDIT, m_strEofCommand);
    DDX_Check(pDX, IDC_SCHED_EXEC_CHECK, m_bExecEofCommand);
    ValidateTextEdit(pDX, IDC_SCHED_STOP_AFTER_EDIT, 6, & m_dwStopAfterCount, 1, 100000);
    DDX_CBIndex(pDX, IDC_SCHED_STOP_AFTER_UNITS_COMBO, m_nStopAfterUnits);
    DDX_Check(pDX, IDC_SCHED_RESTART_CHECK, m_bAutoRestart);
    //}}AFX_DATA_MAP

    StartAtExchange ( pDX );
    StopAtExchange ( pDX );
    StopModeRadioExchange ( pDX );
    StartModeRadioExchange ( pDX );

    if ( pDX->m_bSaveAndValidate ) {
        m_dwStopAfterUnitsValue = 
            (DWORD)((CComboBox *)GetDlgItem(IDC_SCHED_STOP_AFTER_UNITS_COMBO))->
                    GetItemData(m_nStopAfterUnits);        
    }
}


BEGIN_MESSAGE_MAP(CScheduleProperty, CSmPropertyPage)
    //{{AFX_MSG_MAP(CScheduleProperty)
    ON_BN_CLICKED(IDC_SCHED_CMD_BROWSE_BTN, OnSchedCmdBrowseBtn)
    ON_BN_CLICKED(IDC_SCHED_RESTART_CHECK, OnSchedRestartCheck)
    ON_BN_CLICKED(IDC_SCHED_EXEC_CHECK, OnSchedExecCheck)
    ON_BN_CLICKED(IDC_SCHED_START_MANUAL_RDO, OnSchedStartRdo)
    ON_BN_CLICKED(IDC_SCHED_START_AT_RDO, OnSchedStartRdo)
    ON_BN_CLICKED(IDC_SCHED_STOP_MANUAL_RDO, OnSchedStopRdo)
    ON_BN_CLICKED(IDC_SCHED_STOP_AFTER_RDO, OnSchedStopRdo)
    ON_BN_CLICKED(IDC_SCHED_STOP_AT_RDO, OnSchedStopRdo)
    ON_BN_CLICKED(IDC_SCHED_STOP_SIZE_RDO, OnSchedStopRdo)
    ON_WM_DESTROY()
    ON_NOTIFY ( DTN_DATETIMECHANGE, IDC_SCHED_START_AT_TIME_DT, OnKillfocusSchedStartAtDt)
    ON_NOTIFY ( NM_KILLFOCUS, IDC_SCHED_START_AT_TIME_DT, OnKillfocusSchedStartAtDt)
    ON_NOTIFY ( DTN_DATETIMECHANGE, IDC_SCHED_START_AT_DATE_DT, OnKillfocusSchedStartAtDt)
    ON_NOTIFY ( NM_KILLFOCUS, IDC_SCHED_START_AT_DATE_DT, OnKillfocusSchedStartAtDt)
    ON_NOTIFY ( DTN_DATETIMECHANGE, IDC_SCHED_STOP_AT_TIME_DT, OnKillfocusSchedStopAtDt)
    ON_NOTIFY ( NM_KILLFOCUS, IDC_SCHED_STOP_AT_TIME_DT, OnKillfocusSchedStopAtDt)
    ON_NOTIFY ( DTN_DATETIMECHANGE, IDC_SCHED_STOP_AT_DATE_DT, OnKillfocusSchedStopAtDt)
    ON_NOTIFY ( NM_KILLFOCUS, IDC_SCHED_STOP_AT_DATE_DT, OnKillfocusSchedStopAtDt)
    ON_CBN_SELENDOK(IDC_SCHED_STOP_AFTER_UNITS_COMBO, OnSelendokSchedStopAfterUnitsCombo)
    ON_EN_CHANGE(IDC_SCHED_STOP_AFTER_EDIT, OnKillfocusSchedStopAfterEdit)
    ON_EN_KILLFOCUS(IDC_SCHED_STOP_AFTER_EDIT, OnKillfocusSchedStopAfterEdit)
    ON_NOTIFY(UDN_DELTAPOS, IDC_SCHED_STOP_AFTER_SPIN, OnDeltaposSchedStopAfterSpin)
    ON_EN_CHANGE(IDC_SCHED_CMD_EDIT, OnKillfocusSchedCmdEdit)
    ON_EN_KILLFOCUS(IDC_SCHED_CMD_EDIT, OnKillfocusSchedCmdEdit)
  //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CScheduleProperty, CSmPropertyPage)
    //{{AFX_DISPATCH_MAP(CScheduleProperty)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IScheduleProperty to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {65154EAD-BDBE-11D1-BF99-00C04F94A83A}
static const IID IID_IScheduleProperty =
{ 0x65154ead, 0xbdbe, 0x11d1, { 0xbf, 0x99, 0x0, 0xc0, 0x4f, 0x94, 0xa8, 0x3a } };

BEGIN_INTERFACE_MAP(CScheduleProperty, CSmPropertyPage)
    INTERFACE_PART(CScheduleProperty, IID_IScheduleProperty, Dispatch)
END_INTERFACE_MAP()

void 
CScheduleProperty::SetStopDefaultValues ( PSLQ_TIME_INFO pslqStartTime )
{
    SLQ_TIME_INFO slqLocalTime;

    // Default Stop After values.
    m_dwStopAfterCount = 1;
    m_dwStopAfterUnitsValue = SLQ_TT_UTYPE_DAYS;
    
    // Get default time fields for Stop At mode. 
    // Set default stop time for start time + 24 hrs
    slqLocalTime.llDateTime = 86400; // sec/day
    slqLocalTime.llDateTime *= 10000000; // 100ns /sec
    slqLocalTime.llDateTime += pslqStartTime->llDateTime;

    FileTimeToSystemTime( (CONST FILETIME *)&slqLocalTime.llDateTime, &m_stStopAt );
}

void 
CScheduleProperty::SetCmdBtnState ()
{
    if ( SLQ_ALERT != m_pQuery->GetLogType() ) {
        if ( !m_bExecEofCommand ) {
            m_strEofCommand.Empty();
        }

        GetDlgItem(IDC_SCHED_CMD_EDIT)->EnableWindow (m_bExecEofCommand);
        GetDlgItem(IDC_SCHED_CMD_BROWSE_BTN)->EnableWindow (m_bExecEofCommand);
    }
}

void CScheduleProperty::SetStopBtnState ()
{
    BOOL    bSizeRdo;
    BOOL    bAtRdo;
    BOOL    bAfterRdo;
    BOOL    bManualRdo;

    bAtRdo = bAfterRdo = bSizeRdo = FALSE;

    bManualRdo = ( SLQ_AUTO_MODE_NONE == m_SharedData.stiStopTime.dwAutoMode );

    if (!bManualRdo) {
        // check which button is checked and
        // enable/disable the appropriate edit/combo box
        bSizeRdo = ( SLQ_AUTO_MODE_SIZE == m_SharedData.stiStopTime.dwAutoMode ); 
        bAfterRdo = ( SLQ_AUTO_MODE_AFTER == m_SharedData.stiStopTime.dwAutoMode ); 
        bAtRdo = ( SLQ_AUTO_MODE_AT == m_SharedData.stiStopTime.dwAutoMode );
    }

    GetDlgItem(IDC_SCHED_STOP_AFTER_EDIT)->EnableWindow(bAfterRdo);
    GetDlgItem(IDC_SCHED_STOP_AFTER_SPIN)->EnableWindow(bAfterRdo);
    GetDlgItem(IDC_SCHED_STOP_AFTER_STATIC)->EnableWindow(bAfterRdo);
    GetDlgItem(IDC_SCHED_STOP_AFTER_UNITS_COMBO)->EnableWindow(bAfterRdo);

    GetDlgItem(IDC_SCHED_STOP_AT_TIME_DT)->EnableWindow(bAtRdo);
    GetDlgItem(IDC_SCHED_STOP_AT_ON_CAPTION)->EnableWindow(bAtRdo);
    GetDlgItem(IDC_SCHED_STOP_AT_DATE_DT)->EnableWindow(bAtRdo);

    if ( !(bSizeRdo || bAfterRdo) ) {
        m_bAutoRestart = FALSE;
    }

    GetDlgItem(IDC_SCHED_RESTART_CHECK)->EnableWindow(bSizeRdo || bAfterRdo);
    
    if ( SLQ_ALERT != m_pQuery->GetLogType() ) {
//        GetDlgItem(IDC_SCHED_EXEC_CHECK)->EnableWindow( TRUE );
        SetCmdBtnState();
    }

    // UpdateData updates Eof command and Restart UI.
    UpdateData ( FALSE ); 
}

void CScheduleProperty::SetStartBtnState ()
{
    BOOL    bManualRdo;
    BOOL    bAutoFields;

    bManualRdo = ( SLQ_AUTO_MODE_NONE == m_dwCurrentStartMode );

    bAutoFields = !bManualRdo;
    GetDlgItem(IDC_SCHED_START_AT_TIME_DT)->EnableWindow(bAutoFields);
    GetDlgItem(IDC_SCHED_START_AT_ON_CAPTION)->EnableWindow(bAutoFields);
    GetDlgItem(IDC_SCHED_START_AT_DATE_DT)->EnableWindow(bAutoFields);
}

void
CScheduleProperty::FillStartTimeStruct ( PSLQ_TIME_INFO pslqStartTime )
{
    memset (pslqStartTime, 0, sizeof(SLQ_TIME_INFO));
    pslqStartTime->wTimeType = SLQ_TT_TTYPE_START;
    pslqStartTime->wDataType = SLQ_TT_DTYPE_DATETIME;
    pslqStartTime->dwAutoMode = m_dwCurrentStartMode;

    // Start mode and time 

    if ( SLQ_AUTO_MODE_NONE == m_dwCurrentStartMode ) {
        // Manual start mode
        pslqStartTime->llDateTime = m_llManualStartTime;
    } else {
        SystemTimeToFileTime ( &m_stStartAt, (FILETIME *)&pslqStartTime->llDateTime );
    }
}

void
CScheduleProperty::UpdateSharedStopTimeStruct ( void )
{   
    PSLQ_TIME_INFO pTime;

    // Save changes that this page might have made to the shared stop time structure.

    pTime = &m_SharedData.stiStopTime;

    ASSERT ( SLQ_TT_TTYPE_STOP == pTime->wTimeType ) ;

    // Stop mode and time

    if ( SLQ_AUTO_MODE_NONE == pTime->dwAutoMode 
         || SLQ_AUTO_MODE_SIZE == pTime->dwAutoMode ) {
        // The only change that the file page ever makes is to change the stop
        // mode from Size to Manual (SLQ_AUTO_MODE_NONE).  In this case, set 
        // the stop time to a value consistent with the start mode.
        // Also, for SIZE mode, set the manual stop time as calculated in this
        // dialog.
        pTime->wDataType = SLQ_TT_DTYPE_DATETIME;
        pTime->llDateTime = m_llManualStopTime;
    } else if ( SLQ_AUTO_MODE_AFTER == pTime->dwAutoMode ) {
        pTime->wDataType = SLQ_TT_DTYPE_UNITS;
        pTime->dwValue = m_dwStopAfterCount;
        pTime->dwUnitType = m_dwStopAfterUnitsValue;
    } else if ( SLQ_AUTO_MODE_AT == pTime->dwAutoMode ) {
        pTime->wDataType = SLQ_TT_DTYPE_DATETIME;

        SystemTimeToFileTime ( &m_stStopAt, (FILETIME *)&pTime->llDateTime );
    }
}

BOOL 
CScheduleProperty::SaveDataToModel ( )
{
    SLQ_TIME_INFO   slqTime;
    BOOL bContinue = TRUE;

    ResourceStateManager    rsm;
    
    // Validate StopAt time before saving 

    if ( bContinue ) { 
        bContinue = SampleTimeIsLessThanSessionTime ( m_pQuery );
        if ( !bContinue ) {
            if ( SLQ_AUTO_MODE_AFTER == m_SharedData.stiStopTime.dwAutoMode ) {
                SetFocusAnyPage ( IDC_SCHED_STOP_AFTER_EDIT );
            } else if ( SLQ_AUTO_MODE_AT == m_SharedData.stiStopTime.dwAutoMode ) {
                SetFocusAnyPage ( IDC_SCHED_STOP_AT_TIME_DT );
            }
        }
    }

    if ( bContinue ) {

        FillStartTimeStruct ( &slqTime );

        bContinue = m_pQuery->SetLogTime (&slqTime, (DWORD)slqTime.wTimeType);
        ASSERT (bContinue);

        UpdateSharedStopTimeStruct();

        bContinue = m_pQuery->SetLogTime (&m_SharedData.stiStopTime, (DWORD)m_SharedData.stiStopTime.wTimeType);
        ASSERT (bContinue);

        // Restart mode 
        // Currently only support After 0 minutes.
        memset (&slqTime, 0, sizeof(slqTime));
        slqTime.wTimeType = SLQ_TT_TTYPE_RESTART;
        slqTime.dwAutoMode = (m_bAutoRestart ? SLQ_AUTO_MODE_AFTER : SLQ_AUTO_MODE_NONE );
        slqTime.wDataType = SLQ_TT_DTYPE_UNITS;
        slqTime.dwUnitType = SLQ_TT_UTYPE_MINUTES;
        slqTime.dwValue = 0;

        bContinue = m_pQuery->SetLogTime (&slqTime, (DWORD)slqTime.wTimeType);
        ASSERT (bContinue);

        // For Counter and trace log queries, set command file from page
        if ( SLQ_COUNTER_LOG == m_pQuery->GetLogType()
             || SLQ_TRACE_LOG == m_pQuery->GetLogType() ) {
            if (m_bExecEofCommand) {
                // then send filename
                bContinue = ( ERROR_SUCCESS == m_pQuery->SetEofCommand ( m_strEofCommand ) );
            } else {
                // Empty string
                bContinue = ( ERROR_SUCCESS == m_pQuery->SetEofCommand ( m_pQuery->cstrEmpty ) );
            }
            ASSERT (bContinue);
        } 

        if ( bContinue ) {
            // ApplyRunAs must be called before UpdateService
            bContinue = ApplyRunAs( m_pQuery );
        }

        if ( bContinue ) {
            // Save property page shared data.
            m_pQuery->UpdatePropPageSharedData();

            // Sync the service with changes.
            // Must sync changes made by service to properties not modified by this page.
 
            bContinue = UpdateService ( m_pQuery, TRUE );
        }
    }

    return bContinue;

}

/////////////////////////////////////////////////////////////////////////////
// CScheduleProperty message handlers


void CScheduleProperty::OnSchedCmdBrowseBtn() 
{
    CString strCmdPath;
    
    UpdateData (TRUE);  // to get the current filename
    
    strCmdPath = m_strEofCommand;

    if ( IDOK == BrowseCommandFilename ( this, strCmdPath )) {
        // Update the fields with the new information
        if ( strCmdPath != m_strEofCommand ) {
            m_strEofCommand = strCmdPath;
            // Todo: Set the query PASSWORD_DIRTY flag only when m_bExecEofCommand is TRUE
            // and command has changed.
            //
            // This must be done before the check for SetRunAs in the base class
            // IsValidData() method.
            if( !m_pQuery->m_strUser.IsEmpty() ) {
                if( !( m_pQuery->m_strUser.GetAt(0) == L'<' ) ) {
                    m_pQuery->m_fDirtyPassword |= PASSWORD_DIRTY;
                }
            }
       
            SetModifiedPage ( TRUE );
            UpdateData ( FALSE );
        }
    } // else ignore if they canceled out
}

void CScheduleProperty::OnSchedExecCheck() 
{
    UpdateData(TRUE);
    SetCmdBtnState();
    UpdateData ( FALSE );
    SetModifiedPage(TRUE);
}

void CScheduleProperty::OnSchedRestartCheck() 
{
    UpdateData(TRUE);
    SetModifiedPage(TRUE);
}

void CScheduleProperty::OnSchedStartRdo() 
{
    BOOL bNewStateIsManualStart;

    bNewStateIsManualStart = ( 1 == ((CButton *)(GetDlgItem(IDC_SCHED_START_MANUAL_RDO)))->GetCheck() );

    if ( bNewStateIsManualStart && ( SLQ_AUTO_MODE_AT == m_dwCurrentStartMode ) ) {

        // Switching to Manual start.  Set start time to MAX so that original state 
        // will be stopped.
        m_llManualStartTime = MAX_TIME_VALUE;

        // Set stop time to MIN so that original state will be stopped.
        // This variable is only used/saved if the stop time is set to manual or size.
        // Always set it here, in case the stop mode is changed on the file property
        // page.
        m_llManualStopTime = MIN_TIME_VALUE;

    } else if ( !bNewStateIsManualStart && ( SLQ_AUTO_MODE_NONE == m_dwCurrentStartMode ) ) {
        // Switching to Start At mode.
        // Set manual or size stop time to MAX so that automatic start will occur.
        m_llManualStopTime = MAX_TIME_VALUE;
    }

    UpdateData( TRUE );
    SetStartBtnState();
    SetStopBtnState();
    SetModifiedPage( TRUE );
}

void 
CScheduleProperty::OnSchedStopRdo() 
{
    UpdateData(TRUE);
    SetStopBtnState();  
    SetModifiedPage(TRUE);
}

void 
CScheduleProperty::OnCancel() 
{
    m_pQuery->SyncPropPageSharedData(); // Clear the memory shared between property pages.
}

BOOL 
CScheduleProperty::OnApply() 
{
    BOOL    bContinue;

    bContinue = UpdateData (TRUE); // get data from page

    if ( bContinue ) {
        bContinue = IsValidData( m_pQuery, VALIDATE_APPLY );
    }

    if ( bContinue ) {
        bContinue = SaveDataToModel();
    }

    if ( bContinue ){
        bContinue = CSmPropertyPage::OnApply();
    }

    return bContinue;
}

BOOL 
CScheduleProperty::OnInitDialog() 
{
    SLQ_TIME_INFO   slqTime;
    CComboBox *     pCombo;
    int             nIndex;
    CString         strComboBoxString;
    int             nResult;
    SYSTEMTIME      stLocalTime;
    FILETIME        ftLocalTime;

    ResourceStateManager    rsm;
    
    // get local time
    // Milliseconds set to 0 for Schedule times
    GetLocalTime (&stLocalTime);
    stLocalTime.wMilliseconds = 0;
    SystemTimeToFileTime (&stLocalTime, &ftLocalTime);

    // get log start state
    m_pQuery->GetLogTime (&slqTime, SLQ_TT_TTYPE_START);
    m_dwCurrentStartMode = slqTime.dwAutoMode;

    if (slqTime.dwAutoMode == SLQ_AUTO_MODE_NONE) {
        m_llManualStartTime = slqTime.llDateTime;
        // get default value for start At time to load local member variables
        slqTime.llDateTime = *(LONGLONG *)(&ftLocalTime);
    } 

    // get time fields for Start At controls
    // *** Check status
    FileTimeToSystemTime( (CONST FILETIME *)&slqTime.llDateTime, &m_stStartAt );

    // Stop default values are based on Start At time.
    SetStopDefaultValues( &slqTime );

    // Override default values for the selected stop mode.
    
    m_pQuery->GetLogTime (&slqTime, SLQ_TT_TTYPE_STOP);
    m_SharedData.stiStopTime.dwAutoMode = slqTime.dwAutoMode;

    switch (slqTime.dwAutoMode) {

        case SLQ_AUTO_MODE_AFTER:
            // set edit control & dialog box values
            m_dwStopAfterCount = slqTime.dwValue;
            m_dwStopAfterUnitsValue = slqTime.dwUnitType;

            break;

        case SLQ_AUTO_MODE_AT:

            FileTimeToSystemTime( (CONST FILETIME *)&slqTime.llDateTime, &m_stStopAt );
            
            break;

        default:
        case SLQ_AUTO_MODE_SIZE:
        case SLQ_AUTO_MODE_NONE:
            // Manual is the default case if none is specified
            m_llManualStopTime = slqTime.llDateTime;
            break;
    }

    // Init the Stop After time units combo, and select based on
    // either default values or stop after override.
    pCombo = (CComboBox *)GetDlgItem(IDC_SCHED_STOP_AFTER_UNITS_COMBO);
    pCombo->ResetContent();
    for (nIndex = 0; nIndex < (int)dwTimeUnitComboEntries; nIndex++) {
        strComboBoxString.LoadString ( TimeUnitCombo[nIndex].nResId );
        nResult = pCombo->InsertString (nIndex, (LPCWSTR)strComboBoxString);
        ASSERT (nResult != CB_ERR);
        nResult = pCombo->SetItemData (nIndex, (DWORD)TimeUnitCombo[nIndex].nData);
        ASSERT (nResult != CB_ERR);
        // set selected in combo box here
        if (m_dwStopAfterUnitsValue == (DWORD)(TimeUnitCombo[nIndex].nData)) {
            m_nStopAfterUnits = nIndex;
            nResult = pCombo->SetCurSel(nIndex);
            ASSERT (nResult != CB_ERR);
        }
    }

    // Get restart mode
    m_pQuery->GetLogTime (&slqTime, SLQ_TT_TTYPE_RESTART);

    ASSERT (slqTime.wDataType == SLQ_TT_DTYPE_UNITS);
    ASSERT (slqTime.wTimeType == SLQ_TT_TTYPE_RESTART);

    m_bAutoRestart = ( SLQ_AUTO_MODE_NONE == slqTime.dwAutoMode ? FALSE : TRUE );
    
    // Get EOF command, if not Alert query.

    if ( SLQ_ALERT != m_pQuery->GetLogType() ) {
        CString strLogText;
        
        m_pQuery->GetEofCommand ( m_strEofCommand );

        m_bExecEofCommand = !m_strEofCommand.IsEmpty();


        // Static text
        strLogText.LoadString ( IDS_SCHED_START_LOG_GROUP );
        SetDlgItemText( IDC_SCHED_START_GROUP, strLogText );
        strLogText.LoadString ( IDS_SCHED_STOP_LOG_GROUP );
        SetDlgItemText( IDC_SCHED_STOP_GROUP, strLogText );
        strLogText.LoadString ( IDS_SCHED_RESTART_LOG );
        SetDlgItemText( IDC_SCHED_RESTART_CHECK, strLogText );
        strLogText.LoadString ( IDS_SCHED_STOP_LOG_WHEN );
        SetDlgItemText( IDC_SCHED_STOP_WHEN_STATIC, strLogText );
    } else {
        // Hide the EOF command UI if Alert query.
        GetDlgItem(IDC_SCHED_EXEC_CHECK)->ShowWindow(FALSE);
        GetDlgItem(IDC_SCHED_CMD_EDIT)->ShowWindow(FALSE);
        GetDlgItem(IDC_SCHED_CMD_BROWSE_BTN)->ShowWindow(FALSE);
        m_strEofCommand.Empty();
        m_bExecEofCommand = FALSE;
    }

    // Modify or hide other Dialog elements based on query type.
    if ( SLQ_ALERT == m_pQuery->GetLogType() ) {
        GetDlgItem(IDC_SCHED_STOP_SIZE_RDO)->ShowWindow(FALSE);
    }

    CSmPropertyPage::OnInitDialog();
    SetHelpIds ( (DWORD*)&s_aulHelpIds );

    SetStartBtnState ();
    SetStopBtnState();
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void 
CScheduleProperty::OnKillfocusSchedCmdEdit() 
{   
    CString strOldText;
    strOldText = m_strEofCommand;
    UpdateData ( TRUE );

    if ( 0 != strOldText.Compare ( m_strEofCommand ) ) {
        // Todo: Set the query PASSWORD_DIRTY flag only when m_bExecEofCommand is TRUE
        // and command has changed.
        //
        // This must be done before the check for SetRunAs in the base class
        // IsValidData() method.
        if( !m_pQuery->m_strUser.IsEmpty() ) {
            if( !( m_pQuery->m_strUser.GetAt(0) == L'<' ) ) {
                m_pQuery->m_fDirtyPassword |= PASSWORD_DIRTY;
            }
        }
        SetModifiedPage(TRUE);
    }
}

void CScheduleProperty::OnKillfocusSchedStopAfterEdit() 
{
    DWORD   dwOldValue;
    dwOldValue = m_dwStopAfterCount;
    UpdateData ( TRUE );
    if (dwOldValue != m_dwStopAfterCount) {
        SetModifiedPage(TRUE);
    }
}

void
CScheduleProperty::OnKillfocusSchedStartAtDt(NMHDR* /* pNMHDR */, LRESULT* /*pResult */) 
{
    SYSTEMTIME stOldTime;
    stOldTime = m_stStartAt;
    UpdateData ( TRUE );
    if ( stOldTime.wHour != m_stStartAt.wHour 
            || stOldTime.wDay != m_stStartAt.wDay 
            || stOldTime.wMinute != m_stStartAt.wMinute 
            || stOldTime.wSecond != m_stStartAt.wSecond 
            || stOldTime.wMonth != m_stStartAt.wMonth 
            || stOldTime.wYear != m_stStartAt.wYear ) {
        SetModifiedPage(TRUE);
    }
}

void 
CScheduleProperty::OnKillfocusSchedStopAtDt(NMHDR* /* pNMHDR */, LRESULT* /*pResult */) 
{
    SYSTEMTIME stOldTime;
    stOldTime = m_stStopAt;
    UpdateData ( TRUE );
    if ( stOldTime.wHour != m_stStopAt.wHour 
            || stOldTime.wDay != m_stStopAt.wDay 
            || stOldTime.wMinute != m_stStopAt.wMinute 
            || stOldTime.wSecond != m_stStopAt.wSecond 
            || stOldTime.wMonth != m_stStopAt.wMonth 
            || stOldTime.wYear != m_stStopAt.wYear ) {
        SetModifiedPage(TRUE);
    }
}


void CScheduleProperty::OnDeltaposSchedStopAfterSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
    OnDeltaposSpin(pNMHDR, pResult, & m_dwStopAfterCount, 1, 100000);
}

void 
CScheduleProperty::OnSelendokSchedStopAfterUnitsCombo() 
{
    int nSel;
    
    nSel = ((CComboBox *)GetDlgItem(IDC_SCHED_STOP_AFTER_UNITS_COMBO))->GetCurSel();
    
    if ((nSel != LB_ERR) && (nSel != m_nStopAfterUnits)) {
        UpdateData ( TRUE );
        SetModifiedPage ( TRUE );
    }
}

BOOL 
CScheduleProperty::OnSetActive() 
{
    CString     strTemp;
    BOOL        bEnableSizeRdo;
    BOOL        bReturn;

    bReturn = CSmPropertyPage::OnSetActive();
    if ( bReturn ) {
        ResourceStateManager    rsm;
        m_pQuery->GetPropPageSharedData ( &m_SharedData );

        UpdateData ( FALSE );

        // Set size radio button string and state
        strTemp.Empty();
        if ( SLQ_DISK_MAX_SIZE == m_SharedData.dwMaxFileSize ) {
            strTemp.Format ( IDS_SCHED_FILE_MAX_SIZE_DISPLAY );
        } else {
            if (m_SharedData.dwLogFileType == SLF_SQL_LOG) {
               strTemp.Format ( IDS_SCHED_LOG_SET_DISPLAY, m_SharedData.dwMaxFileSize );
            }
            else {
               strTemp.Format ( IDS_SCHED_FILE_SIZE_DISPLAY, m_SharedData.dwMaxFileSize );
            }
        }
        SetDlgItemText( IDC_SCHED_STOP_SIZE_RDO, strTemp );

        bEnableSizeRdo = ( SLF_BIN_CIRC_FILE != m_SharedData.dwLogFileType )
                      && ( SLF_CIRC_TRACE_FILE != m_SharedData.dwLogFileType )
                      && ( SLQ_DISK_MAX_SIZE != m_SharedData.dwMaxFileSize );
        
        GetDlgItem(IDC_SCHED_STOP_SIZE_RDO)->EnableWindow(bEnableSizeRdo);

        SetStartBtnState();
        SetStopBtnState();
    }

    return bReturn;
}

BOOL CScheduleProperty::OnKillActive() 
{
    BOOL bContinue;

    bContinue = CPropertyPage::OnKillActive();

    if ( bContinue ) {
        bContinue = IsValidData(m_pQuery, VALIDATE_FOCUS );
    }

    if ( bContinue ) {
        FillStartTimeStruct ( &m_SharedData.stiStartTime );

        UpdateSharedStopTimeStruct();

        m_pQuery->SetPropPageSharedData ( &m_SharedData );
    }

    if ( bContinue ) {
        SetIsActive ( FALSE );
    }

    return bContinue;
}

void 
CScheduleProperty::PostNcDestroy() 
{
//  delete this;      
    
    CPropertyPage::PostNcDestroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\provprop.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    provprop.h

Abstract:

    Header file for the trace providers general property page.

--*/

#ifndef _PROVPROP_H_
#define _PROVPROP_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "smproppg.h"   // Base class
#include "smtraceq.h"   // For provider states
#include "smcfghlp.h"

// Dialog controls
#define IDD_PROVIDERS_PROP              1000

#define IDC_PROV_FILENAME_CAPTION       1001
#define IDC_PROV_LOG_SCHED_TEXT         1002
#define IDC_PROV_FIRST_HELP_CTRL_ID     1003
#define IDC_PROV_FILENAME_DISPLAY       1003
#define IDC_PROV_PROVIDER_LIST          1004
#define IDC_PROV_ADD_BTN                1005
#define IDC_PROV_REMOVE_BTN             1006
#define IDC_PROV_KERNEL_BTN             1007
#define IDC_PROV_OTHER_BTN              1008
#define IDC_PROV_K_PROCESS_CHK          1009
#define IDC_PROV_K_THREAD_CHK           1010
#define IDC_PROV_K_DISK_IO_CHK          1011
#define IDC_PROV_K_NETWORK_CHK          1012
#define IDC_PROV_K_SOFT_PF_CHK          1013
#define IDC_PROV_K_FILE_IO_CHK          1014
#define IDC_PROV_SHOW_PROVIDERS_BTN     1015


/////////////////////////////////////////////////////////////////////////////
// CProvidersProperty dialog

class CProvidersProperty : public CSmPropertyPage
{
    DECLARE_DYNCREATE(CProvidersProperty)

// Construction
public:
            CProvidersProperty();
            CProvidersProperty(MMC_COOKIE   lCookie, LONG_PTR hConsole);
    virtual ~CProvidersProperty();

// Dialog Data
    //{{AFX_DATA(CProvidersProperty)
    enum { IDD = IDD_PROVIDERS_PROP };
    INT     m_nTraceModeRdo;
    BOOL    m_bEnableProcessTrace;
    BOOL    m_bEnableThreadTrace;
    BOOL    m_bEnableDiskIoTrace;
    BOOL    m_bEnableNetworkTcpipTrace;
    BOOL    m_bEnableMemMgmtTrace;
    BOOL    m_bEnableFileIoTrace;
    BOOL    m_bNonsystemProvidersExist;
    //}}AFX_DATA

public: 
            DWORD   GetGenProviderCount ( INT& iCount );
            DWORD   GetProviderDescription ( INT iUnusedIndex, CString& rstrDesc );
            BOOL    IsEnabledProvider ( INT iIndex );
            BOOL    IsActiveProvider ( INT iIndex );
            LPCWSTR GetKernelProviderDescription ( void );
            BOOL    GetKernelProviderEnabled ( void );

            DWORD   GetInQueryProviders( CArray<CSmTraceLogQuery::eProviderState, CSmTraceLogQuery::eProviderState&>& );
            DWORD   SetInQueryProviders( CArray<CSmTraceLogQuery::eProviderState, CSmTraceLogQuery::eProviderState&>& );

            void    GetMachineDisplayName( CString& );
            CSmTraceLogQuery*    GetTraceQuery( void );


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CProvidersProperty)
    public:
    protected:
    virtual void OnFinalRelease();
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL

// Implementation
protected:

    virtual INT GetFirstHelpCtrlId ( void ) { return IDC_PROV_FIRST_HELP_CTRL_ID; };  // Subclass must override.
    virtual BOOL    IsValidLocalData();

    // Generated message map functions
    //{{AFX_MSG(CProvidersProperty)
//    afx_msg void OnProvDetailsBtn();
    afx_msg void OnProvShowProvBtn();
    afx_msg void OnProvAddBtn();
    afx_msg void OnProvExplainBtn();
    afx_msg void OnProvRemoveBtn();
    afx_msg void OnDblclkProvProviderList();
    afx_msg void OnSelcancelProvProviderList();
    afx_msg void OnSelchangeProvProviderList();
    afx_msg void OnProvKernelEnableCheck();
    afx_msg void OnProvTraceModeRdo();
   	afx_msg void OnPwdBtn();
    afx_msg void OnChangeUser();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CProvidersProperty)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()

private:

    enum eTraceMode {
        eTraceModeKernel = 1,
        eTraceModeApplication = 2
    };
    
    void    DoProvidersDataExchange ( CDataExchange* pDX );
    void    SetAddRemoveBtnState ( void );
    void    SetTraceModeState ( void );
    void    ImplementAdd ( void );

    void    UpdateFileNameString ( void );
    void    UpdateLogStartString ( void );
    BOOL    SetDetailsGroupBoxMode ( void );
    void    TraceModeRadioExchange ( CDataExchange* ); 

    CSmTraceLogQuery    *m_pTraceLogQuery;
    CArray<CSmTraceLogQuery::eProviderState, CSmTraceLogQuery::eProviderState&> m_arrGenProviders;
    CString             m_strFileNameDisplay;
    CString             m_strStartText;
    DWORD               m_dwTraceMode;

    DWORD           m_dwMaxHorizListExtent;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif //  _PROVPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smabout.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smabout.h

Abstract:

    Implementation of the ISnapinAbout interface.

--*/

#ifndef __SMABOUT_H_INCLUDED__
#define __SMABOUT_H_INCLUDED__

#include "smlogcfg.h"

class ATL_NO_VTABLE CSmLogAbout :
//	public CComObjectRoot,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSmLogAbout, &CLSID_PerformanceAbout>,
	public ISnapinAbout
{
    BEGIN_COM_MAP(CSmLogAbout)
	COM_INTERFACE_ENTRY(ISnapinAbout)
    END_COM_MAP_X()

public:
    CSmLogAbout();
    virtual ~CSmLogAbout();

    DECLARE_REGISTRY_RESOURCEID(IDR_PERFORMANCEABOUT)
    DECLARE_NOT_AGGREGATABLE(CSmLogAbout)

   // IUnknown overrides

   virtual ULONG __stdcall AddRef();
   virtual ULONG __stdcall Release();
   virtual HRESULT __stdcall QueryInterface(const IID& interfaceID, void** interfaceDesired);

// ISnapinAbout
/*
	STDMETHOD(GetSnapinDescription)(OUT LPOLESTR __RPC_FAR *lpDescription);
	STDMETHOD(GetProvider)(OUT LPOLESTR __RPC_FAR *lpName);
	STDMETHOD(GetSnapinVersion)(OUT LPOLESTR __RPC_FAR *lpVersion);
	STDMETHOD(GetSnapinImage)(OUT HICON __RPC_FAR *hAppIcon);
	STDMETHOD(GetStaticFolderImage)(
            OUT HBITMAP __RPC_FAR *hSmallImage,
            OUT HBITMAP __RPC_FAR *hSmallImageOpen,
            OUT HBITMAP __RPC_FAR *hLargeImage,
            OUT COLORREF __RPC_FAR *crMask);

*/  
    virtual HRESULT __stdcall GetSnapinDescription(OUT LPOLESTR __RPC_FAR *lpDescription);
    virtual HRESULT __stdcall GetProvider(OUT LPOLESTR __RPC_FAR *lpName);
    virtual HRESULT __stdcall GetSnapinVersion(OUT LPOLESTR __RPC_FAR *lpVersion);
    virtual HRESULT __stdcall GetSnapinImage(OUT HICON __RPC_FAR *hAppIcon);
    virtual HRESULT __stdcall GetStaticFolderImage(
           OUT HBITMAP __RPC_FAR *hSmallImage,
           OUT HBITMAP __RPC_FAR *hSmallImageOpen,
           OUT HBITMAP __RPC_FAR *hLargeImage,
           OUT COLORREF __RPC_FAR *crMask);

private:
    //
    // The following data members MUST be initialized by the constructor
    // of the derived class.
    UINT m_uIdStrDescription;           // Resource Id of the description
//    UINT m_uIdStrProvider;              // Resource Id of the provider (ie, Microsoft Corporation)
//    UINT m_uIdStrVersion;               // Resource Id of the version of the snapin
    UINT m_uIdIconImage;                // Resource Id for the icon/image of the snapin
    UINT m_uIdBitmapSmallImage;
    UINT m_uIdBitmapSmallImageOpen;
    UINT m_uIdBitmapLargeImage;
    COLORREF m_crImageMask;
    long     refcount;

private:
    HRESULT HrLoadOleString(UINT uStringId, OUT LPOLESTR * ppaszOleString);
    HRESULT TranslateString( IN  LPSTR lpSrc, OUT LPOLESTR __RPC_FAR *lpDst);

}; // CSmLogAbout()

#endif // __SMABOUT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smalrtq.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smalrtq.cpp

Abstract:

    Implementation of the alert query class

--*/

#include "Stdafx.h"
#include <pdhp.h>        // for MIN_TIME_VALUE, MAX_TIME_VALUE
#include <pdhmsg.h>
#include <strsafe.h>
#include "smlogs.h"
#include "common.h"
#include "smalrtq.h"

USE_HANDLE_MACROS("SMLOGCFG(smalrtq.cpp)");

#define  ALRT_DEFAULT_COMMAND_FILE          L""
#define  ALRT_DEFAULT_NETWORK_NAME          L""
#define  ALRT_DEFAULT_USER_TEXT             L""
#define  ALRT_DEFAULT_PERF_LOG_NAME         L""

//
//  Constructor
CSmAlertQuery::CSmAlertQuery( CSmLogService* pLogService )
:   CSmLogQuery( pLogService ),
    m_dwCounterListLength ( 0 ),
    m_szNextCounter ( NULL ),
    mr_szCounterList ( NULL ),
    m_bCounterListInLocale (FALSE),
    mr_dwActionFlags ( ALRT_DEFAULT_ACTION )
{
    memset (&mr_stiSampleInterval, 0, sizeof(mr_stiSampleInterval));
    return;
}

//
//  Destructor
CSmAlertQuery::~CSmAlertQuery()
{
    return;
}

//
//  Open function. either opens an existing log query entry
//  or creates a new one
//
DWORD
CSmAlertQuery::Open ( const CString& rstrName, HKEY hKeyQuery, BOOL bReadOnly)
{
    DWORD   dwStatus = ERROR_SUCCESS;

    ASSERT ( SLQ_ALERT == GetLogType() );
    dwStatus = CSmLogQuery::Open ( rstrName, hKeyQuery, bReadOnly );

    return dwStatus;
}

//
//  Close Function
//      closes registry handles and frees allocated memory
//
DWORD
CSmAlertQuery::Close ()
{
    DWORD dwStatus;
    LOCALTRACE (L"Closing Query\n");

    if (mr_szCounterList != NULL) {
        delete [] mr_szCounterList;
        mr_szCounterList = NULL;
    }

    mr_strNetName.Empty();
	mr_strCmdFileName.Empty();
	mr_strCmdUserText.Empty();
	mr_strCmdUserTextIndirect.Empty();
	mr_strPerfLogName.Empty();

    dwStatus = CSmLogQuery::Close();

    return dwStatus;
}

//
//  UpdateRegistry function.
//      copies the current settings to the registry where they
//      are read by the log service
//
DWORD
CSmAlertQuery::UpdateRegistry() 
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwBufferSize = 0;
    LPWSTR  szNewCounterList = NULL;


    if ( IsModifiable() ) {

        dwBufferSize = 0;
        //
        // Translate the counter list into English
        //
        dwStatus = TranslateMSZAlertCounterList(mr_szCounterList,
                            NULL,
                            &dwBufferSize,
                            FALSE);
        if (dwStatus == ERROR_NOT_ENOUGH_MEMORY) {
            ASSERT ( 0 == dwBufferSize % sizeof(WCHAR) );
            szNewCounterList = new WCHAR[dwBufferSize / sizeof(WCHAR)];
            if (szNewCounterList != NULL) {
                dwStatus = TranslateMSZAlertCounterList(mr_szCounterList,
                                szNewCounterList,
                                &dwBufferSize,
                                FALSE);
            }
        }

        if (dwStatus == ERROR_SUCCESS && szNewCounterList != NULL) {

            dwStatus  = WriteRegistryStringValue (
                                m_hKeyQuery,
                                IDS_REG_COUNTER_LIST,
                                REG_MULTI_SZ,
                                szNewCounterList,
                                &dwBufferSize);
        }
        else {
            dwBufferSize = m_dwCounterListLength * sizeof(WCHAR); 
            dwStatus  = WriteRegistryStringValue (
                                m_hKeyQuery,
                                IDS_REG_COUNTER_LIST,
                                REG_MULTI_SZ,
                                mr_szCounterList,
                                &dwBufferSize);
        }

        // Schedule

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = WriteRegistrySlqTime (
                            m_hKeyQuery,
                            IDS_REG_SAMPLE_INTERVAL,
                            &mr_stiSampleInterval);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            if ( !mr_strCmdFileName.IsEmpty() ) {
                dwBufferSize = mr_strCmdFileName.GetLength() + 1;
                dwBufferSize *= sizeof(WCHAR);
            } else {
                dwBufferSize = 0;
            }

            dwStatus  = WriteRegistryStringValue (
                m_hKeyQuery,
                IDS_REG_COMMAND_FILE,
                REG_SZ,
                mr_strCmdFileName,
                &dwBufferSize);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            if ( !mr_strNetName.IsEmpty() ) {
                dwBufferSize = mr_strNetName.GetLength() + 1;
                dwBufferSize *= sizeof(WCHAR);
            } else {
                dwBufferSize = 0;
            }
            dwStatus  = WriteRegistryStringValue (
                m_hKeyQuery,
                IDS_REG_NETWORK_NAME,
                REG_SZ,
                mr_strNetName,
                &dwBufferSize);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            if ( !mr_strCmdUserText.IsEmpty() ) {
                dwBufferSize = mr_strCmdUserText.GetLength() + 1;
                dwBufferSize *= sizeof(WCHAR);
            } else {
                dwBufferSize = 0;
            }
            dwStatus  = WriteRegistryStringValue (
                m_hKeyQuery,
                IDS_REG_USER_TEXT,
                REG_SZ,
                mr_strCmdUserText,
                &dwBufferSize);
        }

        if ( ERROR_SUCCESS == dwStatus && !mr_strCmdUserTextIndirect.IsEmpty() ) {
            dwBufferSize = mr_strCmdUserTextIndirect.GetLength() + 1;
            dwBufferSize *= sizeof(WCHAR);
            dwStatus  = WriteRegistryStringValue (
                m_hKeyQuery,
                IDS_REG_USER_TEXT,
                REG_SZ,
                mr_strCmdUserTextIndirect,
                &dwBufferSize);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            if ( !mr_strPerfLogName.IsEmpty() ) {
                dwBufferSize = mr_strPerfLogName.GetLength() + 1;
                dwBufferSize *= sizeof(WCHAR);
            } else {
                dwBufferSize = 0;
            }
            dwStatus  = WriteRegistryStringValue (
                m_hKeyQuery,
                IDS_REG_PERF_LOG_NAME,
                REG_SZ,
                mr_strPerfLogName,
                &dwBufferSize);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
           dwStatus  = WriteRegistryDwordValue(
                m_hKeyQuery,
                IDS_REG_ACTION_FLAGS,
                &mr_dwActionFlags,
                REG_DWORD);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = CSmLogQuery::UpdateRegistry ();
        }

    } else {
        dwStatus = ERROR_ACCESS_DENIED;
    }

    return dwStatus;
}

DWORD
CSmAlertQuery::TranslateCounterListToLocale()
{
    DWORD   dwBufferSize = 0;
    DWORD   dwStatus = ERROR_SUCCESS;
    LPWSTR  szNewCounterList = NULL;

    if (m_bCounterListInLocale) {
        return ERROR_SUCCESS;
    }

    CWaitCursor WaitCursor;
    //
    // Translate the counter list into Locale
    //
    dwBufferSize = 0;
    dwStatus = TranslateMSZAlertCounterList(
                            mr_szCounterList,
                            NULL,
                            &dwBufferSize,
                            TRUE);

    if (dwStatus == ERROR_NOT_ENOUGH_MEMORY) {

        ASSERT ( 0 == dwBufferSize % sizeof(WCHAR) );
        szNewCounterList = new WCHAR [dwBufferSize / sizeof(WCHAR)];

        if (szNewCounterList != NULL) {
            //
            // Translate the counter list into Locale
            //
            dwStatus = TranslateMSZAlertCounterList(
                            mr_szCounterList,
                            szNewCounterList,
                            &dwBufferSize,
                            TRUE);

            if (dwStatus == ERROR_SUCCESS) {
                m_dwCounterListLength = dwBufferSize / sizeof(WCHAR);
                //
                // Remove the old
                //
                delete [] mr_szCounterList;
                m_szNextCounter = NULL;
                mr_szCounterList = szNewCounterList;
                m_bCounterListInLocale = TRUE;
            }
        }
    }
    WaitCursor.Restore();

    return dwStatus;
}


//
//  SyncWithRegistry()
//      Reads the current values for this query from the registry
//      and reloads the internal values to match
//
DWORD
CSmAlertQuery::SyncWithRegistry()
{
    DWORD   dwBufferSize = 0;
    DWORD   dwStatus = ERROR_SUCCESS;
    SLQ_TIME_INFO   stiDefault;
    LPWSTR  pszTemp = NULL;
    LPWSTR  szIndTemp = NULL;
    UINT    uiBufferLen = 0;

    ASSERT (m_hKeyQuery != NULL);

    m_bCounterListInLocale = FALSE;

    //
    // Load the counter string list
    //
    dwStatus = ReadRegistryStringValue (
        m_hKeyQuery,
        IDS_REG_COUNTER_LIST,
        NULL,
        &mr_szCounterList,
        &dwBufferSize);
    if (dwStatus != ERROR_SUCCESS) {
        m_szNextCounter = NULL; //re-initialize
        m_dwCounterListLength = 0;
    } else {
        // convert  buffersize to chars from bytes
        m_dwCounterListLength = dwBufferSize / sizeof(WCHAR);
    }

    // Schedule

    stiDefault.wDataType = SLQ_TT_DTYPE_UNITS;
    stiDefault.wTimeType = SLQ_TT_TTYPE_SAMPLE;
    stiDefault.dwAutoMode = SLQ_AUTO_MODE_AFTER;
    stiDefault.dwValue = 5;                         // default interval;
    stiDefault.dwUnitType = SLQ_TT_UTYPE_SECONDS;

    dwStatus = ReadRegistrySlqTime (
        m_hKeyQuery,
        IDS_REG_SAMPLE_INTERVAL,
        &stiDefault,
        &mr_stiSampleInterval);
    ASSERT (dwStatus == ERROR_SUCCESS);

    dwBufferSize = 0;
    dwStatus = ReadRegistryStringValue (
        m_hKeyQuery,
        IDS_REG_COMMAND_FILE,
        ALRT_DEFAULT_COMMAND_FILE,
        &pszTemp,
        &dwBufferSize);
    ASSERT (dwStatus == ERROR_SUCCESS);
    mr_strCmdFileName.Empty();
    if ( dwBufferSize > sizeof(WCHAR) ) {
        ASSERT ( NULL != pszTemp );
        ASSERT ( 0 != *pszTemp );
        mr_strCmdFileName = pszTemp;
    }
    delete [] pszTemp;
    pszTemp = NULL;
    dwBufferSize = 0;

    dwStatus = ReadRegistryStringValue (
        m_hKeyQuery,
        IDS_REG_NETWORK_NAME,
        ALRT_DEFAULT_NETWORK_NAME,
        &pszTemp,
        &dwBufferSize);
    ASSERT (dwStatus == ERROR_SUCCESS);
    mr_strNetName.Empty();
    if ( dwBufferSize > sizeof(WCHAR) ) {
        ASSERT ( NULL != pszTemp );
        ASSERT ( 0 != *pszTemp );
        mr_strNetName = pszTemp;
    }
    delete [] pszTemp ;
    pszTemp = NULL;
    dwBufferSize = 0;

    // User text field can be indirect

    if ( ERROR_SUCCESS == dwStatus ) {
        dwStatus = SmNoLocReadRegIndStrVal (
            m_hKeyQuery,
            IDS_REG_USER_TEXT,
            ALRT_DEFAULT_USER_TEXT,
            &szIndTemp,
            &uiBufferLen );
    }
    mr_strCmdUserText.Empty();

    if ( NULL != szIndTemp ) {
        if ( L'\0' != *szIndTemp ) {
            mr_strCmdUserText = szIndTemp;
        }
    }
    if ( NULL != szIndTemp ) {
        G_FREE ( szIndTemp );
        szIndTemp = NULL;
    }
    uiBufferLen = 0;

    dwStatus = ReadRegistryStringValue (
        m_hKeyQuery,
        IDS_REG_PERF_LOG_NAME,
        ALRT_DEFAULT_PERF_LOG_NAME,
        &pszTemp,
        &dwBufferSize);
    ASSERT (dwStatus == ERROR_SUCCESS);
    mr_strPerfLogName.Empty();
    if ( dwBufferSize > sizeof(WCHAR) ) {
        ASSERT ( NULL != pszTemp );
        ASSERT ( 0 != *pszTemp );
        mr_strPerfLogName = pszTemp;
    }
    delete [] pszTemp ;
    pszTemp = NULL;
    dwBufferSize = 0;

    dwStatus = ReadRegistryDwordValue (
                m_hKeyQuery,
                IDS_REG_ACTION_FLAGS,
                ALRT_DEFAULT_ACTION,
                &mr_dwActionFlags);
    ASSERT ( ERROR_SUCCESS == dwStatus );

    // Call parent class last to update shared values.

    dwStatus = CSmLogQuery::SyncWithRegistry();
    ASSERT (dwStatus == ERROR_SUCCESS);

    return dwStatus;
}

BOOL
CSmAlertQuery::GetLogTime ( PSLQ_TIME_INFO pTimeInfo, DWORD dwFlags )
{
    BOOL bStatus;

    ASSERT ( ( SLQ_TT_TTYPE_START == dwFlags )
            || ( SLQ_TT_TTYPE_STOP == dwFlags )
            || ( SLQ_TT_TTYPE_RESTART == dwFlags )
            || ( SLQ_TT_TTYPE_SAMPLE == dwFlags ) );

    bStatus = CSmLogQuery::GetLogTime( pTimeInfo, dwFlags );

    return bStatus;
}

BOOL
CSmAlertQuery::SetLogTime ( PSLQ_TIME_INFO pTimeInfo, const DWORD dwFlags )
{
    BOOL bStatus;

    ASSERT ( ( SLQ_TT_TTYPE_START == dwFlags )
            || ( SLQ_TT_TTYPE_STOP == dwFlags )
            || ( SLQ_TT_TTYPE_RESTART == dwFlags )
            || ( SLQ_TT_TTYPE_SAMPLE == dwFlags ) );

    bStatus = CSmLogQuery::SetLogTime( pTimeInfo, dwFlags );

    return bStatus;
}

BOOL
CSmAlertQuery::GetDefaultLogTime(SLQ_TIME_INFO&  rTimeInfo,  DWORD dwFlags )
{
    ASSERT ( ( SLQ_TT_TTYPE_START == dwFlags )
            || ( SLQ_TT_TTYPE_STOP == dwFlags ) );

    rTimeInfo.wTimeType = (WORD)dwFlags;
    rTimeInfo.wDataType = SLQ_TT_DTYPE_DATETIME;

    if ( SLQ_TT_TTYPE_START == dwFlags ) {
        SYSTEMTIME  stLocalTime;
        FILETIME    ftLocalTime;

        // Milliseconds set to 0 for Schedule times
        ftLocalTime.dwLowDateTime = ftLocalTime.dwHighDateTime = 0;
        GetLocalTime (&stLocalTime);
        stLocalTime.wMilliseconds = 0;
        SystemTimeToFileTime (&stLocalTime, &ftLocalTime);

        rTimeInfo.dwAutoMode = SLQ_AUTO_MODE_AT;
        rTimeInfo.llDateTime = *(LONGLONG *)&ftLocalTime;
    } else {
        // Default stop values
        rTimeInfo.dwAutoMode = SLQ_AUTO_MODE_NONE;
        rTimeInfo.llDateTime = MAX_TIME_VALUE;
    }

    return TRUE;
}

BOOL
CSmAlertQuery::GetActionInfo( PALERT_ACTION_INFO pInfo, LPDWORD pdwInfoBufSize)
{
    DWORD   dwSizeRequired = sizeof (ALERT_ACTION_INFO);
    BOOL    bReturn = FALSE;
    LPWSTR  szNextString;
    // compute required size

    if (pdwInfoBufSize == NULL) {
        return FALSE;
    }

    if ( !mr_strNetName.IsEmpty() ) {
        dwSizeRequired += ( mr_strNetName.GetLength() + 1 ) * sizeof(WCHAR);
    }

    if ( !mr_strCmdFileName.IsEmpty() ) {
        dwSizeRequired += ( mr_strCmdFileName.GetLength() + 1 ) * sizeof(WCHAR);
    }
    if ( !mr_strCmdUserText.IsEmpty() ) {
        dwSizeRequired += ( mr_strCmdUserText.GetLength() + 1 ) * sizeof(WCHAR);
    }
    if ( !mr_strPerfLogName.IsEmpty() ) {
        dwSizeRequired += ( mr_strPerfLogName.GetLength() + 1 ) * sizeof(WCHAR);
    }

    if (dwSizeRequired <= *pdwInfoBufSize) {
        // clear the caller's buffer before we start filling it
        if (pInfo != NULL) {
            memset (pInfo, 0, *pdwInfoBufSize);
            pInfo->dwSize = dwSizeRequired;
            pInfo->dwActionFlags = mr_dwActionFlags;
            szNextString = (LPWSTR)&pInfo[1];
            if ( !mr_strNetName.IsEmpty() ) {
                pInfo->szNetName = szNextString;
                StringCchCopy ( szNextString, dwSizeRequired, mr_strNetName );
                szNextString += lstrlen(szNextString) + 1;
            }
            if ( !mr_strCmdFileName.IsEmpty() ) {
                pInfo->szCmdFilePath = szNextString;
                StringCchCopy ( szNextString, dwSizeRequired, mr_strCmdFileName );
                szNextString += lstrlen(szNextString) + 1;
            }
            if ( !mr_strCmdUserText.IsEmpty() ) {
                pInfo->szUserText = szNextString;
                StringCchCopy ( szNextString, dwSizeRequired, mr_strCmdUserText );
                szNextString += lstrlen(szNextString) + 1;
            }
            if ( !mr_strPerfLogName.IsEmpty() ) {
                pInfo->szLogName = szNextString;
                StringCchCopy ( szNextString, dwSizeRequired, mr_strPerfLogName );
                szNextString += lstrlen(szNextString) + 1;
            }
            bReturn = TRUE;
        }
    } 

    *pdwInfoBufSize = dwSizeRequired;

    return bReturn;
}

DWORD
CSmAlertQuery::SetActionInfo( PALERT_ACTION_INFO pInfo )
{
    DWORD dwStatus = ERROR_SUCCESS;

    if (pInfo != NULL) {
        // Update action values with those from the structure
        MFC_TRY
            mr_dwActionFlags = pInfo->dwActionFlags;

            mr_strNetName.Empty();
            if ( NULL != pInfo->szNetName ) {
                mr_strNetName = pInfo->szNetName;
            }

            mr_strCmdFileName.Empty();
            if ( NULL != pInfo->szCmdFilePath ) {
                mr_strCmdFileName = pInfo->szCmdFilePath;
            }

            mr_strCmdUserText.Empty();
            if ( NULL != pInfo->szUserText ) {
                mr_strCmdUserText = pInfo->szUserText;
            }

            mr_strPerfLogName.Empty();
            if ( NULL != pInfo->szLogName ) {
                mr_strPerfLogName = pInfo->szLogName;
            }
        MFC_CATCH_DWSTATUS
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }
    // Todo:  Handle return status
    return dwStatus;
}


//
//  Get first counter in counter list
//
LPCWSTR
CSmAlertQuery::GetFirstCounter()
{
    LPWSTR  szReturn;
    szReturn = mr_szCounterList;
    if (szReturn != NULL) {
        if (*szReturn == 0) {
            // then it's an empty string
            szReturn = NULL;
            m_szNextCounter = NULL;
        } else {
            m_szNextCounter = szReturn + lstrlen(szReturn) + 1;
            if (*m_szNextCounter == 0) {
                // end of list reached so set pointer to NULL
                m_szNextCounter = NULL;
            }
        }
    } else {
        // no buffer allocated yet
        m_szNextCounter = NULL;
    }
    return (LPCWSTR)szReturn;
}

//
//  Get next counter in counter list
//  NULL pointer means no more counters in list
//
LPCWSTR
CSmAlertQuery::GetNextCounter()
{
    LPWSTR  szReturn;
    szReturn = m_szNextCounter;

    if (m_szNextCounter != NULL) {
        m_szNextCounter += lstrlen(szReturn) + 1;
        if (*m_szNextCounter == 0) {
            // end of list reached so set pointer to NULL
            m_szNextCounter = NULL;
        }
    } else {
        // already at the end of the list so nothing to do
    }

    return (LPCWSTR)szReturn;
}

//
//  clear out the counter list
//
VOID
CSmAlertQuery::ResetCounterList()
{
    if (mr_szCounterList != NULL) {
        delete [] mr_szCounterList;
        m_szNextCounter = NULL;
        mr_szCounterList = NULL;
    }

    m_dwCounterListLength = sizeof(WCHAR);  // sizeof MSZ Null
    try {
        mr_szCounterList = new WCHAR [m_dwCounterListLength];
        mr_szCounterList[0] = 0;
    } catch ( ... ) {
        m_dwCounterListLength = 0;
    }
}

//
//  Add this counter string to the internal list
//
BOOL
CSmAlertQuery::AddCounter(LPCWSTR szCounterPath)
{
    HRESULT hr = S_OK;
    DWORD   dwNewLen;
    LPWSTR  szNewString;
    LPWSTR  szNextString;

    ASSERT (szCounterPath != NULL);

    if (szCounterPath == NULL) {
        return FALSE;
    }

    dwNewLen = lstrlen(szCounterPath) + 1;

    if (m_dwCounterListLength <= 2) {
        dwNewLen += 1; // add room for the MSZ null
        // then this is the first string to go in the list
        try {
            szNewString = new WCHAR [dwNewLen];
        } catch ( ... ) {
            return FALSE; // leave now
        }
        szNextString = szNewString;
    } else {
        //
        //  Double the list size on each allocation.
        //
        dwNewLen += m_dwCounterListLength;
        // this is the nth string to go in the list
        try {
            szNewString = new WCHAR [dwNewLen];
        } catch ( ... ) {
            return FALSE; // leave now
        }
        // Use memcpy because MSZ string.
        memcpy (szNewString, mr_szCounterList,
            (m_dwCounterListLength * sizeof(WCHAR)));
        szNextString = szNewString;
        szNextString += m_dwCounterListLength - 1;
    }
    hr = StringCchCopy ( szNextString, dwNewLen, szCounterPath );

    if ( SUCCEEDED ( hr) ) {
        szNextString = szNewString;
        szNextString += dwNewLen - 1;
        *szNextString = L'\0';  // MSZ Null

        if (mr_szCounterList != NULL) {
            delete [] mr_szCounterList;
        }
        mr_szCounterList = szNewString;
        m_szNextCounter = szNewString;
        m_dwCounterListLength = dwNewLen;
    } else {
        delete [] szNewString;
        return FALSE;
    }

    return TRUE;
}

DWORD
CSmAlertQuery::GetLogType()
{
    return ( SLQ_ALERT );
}

BOOL
CSmAlertQuery::SetLogFileType ( const DWORD /* dwType */)
{
    // No alert log file type
    return FALSE;
}

//
//  Get log file type and return as a string
//
//
const CString&
CSmAlertQuery::GetLogFileType ( )
{
    return cstrEmpty;
}

void
CSmAlertQuery::GetLogFileType ( DWORD& rdwFileType )
{
    // Log file type should default in property bags.
    ASSERT ( FALSE );
    rdwFileType = ((DWORD)0xFFFFFFFF);
    return;
}

LPCWSTR
CSmAlertQuery::GetCounterList( LPDWORD  pcchListSize)
{
    if (pcchListSize != NULL) *pcchListSize = m_dwCounterListLength;
    return mr_szCounterList;
}

BOOL    CSmAlertQuery::SetCounterList( LPCWSTR mszCounterList, DWORD cchListSize)
{
    BOOL bReturn = TRUE;

    if (mr_szCounterList != NULL) {
        delete [] mr_szCounterList;
        mr_szCounterList = NULL;
        m_dwCounterListLength = 0;
    }

    try {

        mr_szCounterList = new WCHAR [cchListSize];
        memcpy (mr_szCounterList, mszCounterList, (cchListSize * sizeof(WCHAR)));
        m_dwCounterListLength = cchListSize;
    } catch ( ... ) {
        bReturn = FALSE;
    }

    return bReturn;
}

const CString&
CSmAlertQuery::GetLogFileName( BOOL )
{
    // 2000.1 return empty string so that empty string is written to HTML file for alerts.
    return cstrEmpty;
}

HRESULT
CSmAlertQuery::LoadCountersFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog* pIErrorLog )
{
    HRESULT     hr = S_OK;
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwCount;
    DWORD       dwIndex;
    CString     strParamName;
    CString     strNonLocParamName;
    LPWSTR      szLocaleBuf = NULL;
    DWORD       dwLocaleBufLen = 0;
    LPWSTR      pszPath;
    PALERT_INFO_BLOCK   paibInfo = NULL;
    LPWSTR      szString = NULL;
    LPWSTR      szCounterPath = NULL;

    m_bCounterListInLocale = FALSE;

    hr = DwordFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_SYSMON_COUNTERCOUNT,
            0,
            dwCount);

    for ( dwIndex = 1; dwIndex <= dwCount; dwIndex++ ) {

        pdhStatus = ERROR_SUCCESS;
        hr = S_OK;
        pszPath = NULL;

        MFC_TRY 
            DWORD   dwBufLen = 0;
            DWORD   dwCharCount = 0;
            DWORD   dwByteCount = 0;
            DWORD   dwOverUnder;
            DOUBLE  dThreshold;

            strNonLocParamName.Format ( GetNonLocHtmlPropName ( IDS_HTML_SYSMON_COUNTERPATH ), dwIndex );
            strParamName.Format ( IDS_HTML_SYSMON_COUNTERPATH, dwIndex );

            hr = StringFromPropertyBag (
                    pPropBag,
                    pIErrorLog,
                    strParamName,
                    strNonLocParamName,
                    L"",
                    &szCounterPath,
                    &dwBufLen );

            pszPath = szCounterPath;
        
            //
            // 1 for NULL character
            //
            if (dwBufLen > 1) {

                //
                // Initialize the locale path buffer
                //
                if (dwLocaleBufLen == 0) {
                    dwLocaleBufLen = PDH_MAX_COUNTER_PATH + 1;  
                    szLocaleBuf = new WCHAR [dwLocaleBufLen];
                    if (szLocaleBuf == NULL) {
                        dwLocaleBufLen = 0;
                    }
                }

                if (szLocaleBuf != NULL) {
                    //
                    // Translate counter name from English to Locale
                    //
                    dwBufLen = dwLocaleBufLen;

                    pdhStatus = PdhTranslateLocaleCounter(
                                    szCounterPath,
                                    szLocaleBuf,
                                    &dwBufLen);

                    if (pdhStatus == ERROR_SUCCESS) {
                        m_bCounterListInLocale = TRUE;
                        pszPath = szLocaleBuf;
                    } else if ( PDH_MORE_DATA == pdhStatus ) {
                        //
                        // Todo:  Build error message.
                        //
                    } // else build error message.
                }
            }

            if ( NULL != pszPath ) {                
                strNonLocParamName.Format ( GetNonLocHtmlPropName ( IDS_HTML_ALERT_OVER_UNDER ), dwIndex );
                strParamName.Format ( IDS_HTML_ALERT_OVER_UNDER, dwIndex );
                hr = DwordFromPropertyBag (
                        pPropBag,
                        pIErrorLog,
                        strParamName,
                        strNonLocParamName,
                        AIBF_UNDER,
                        dwOverUnder);

                if ( SUCCEEDED ( hr ) ) {

                    strNonLocParamName.Format ( GetNonLocHtmlPropName ( IDS_HTML_ALERT_THRESHOLD ), dwIndex );
                    strParamName.Format ( IDS_HTML_ALERT_THRESHOLD, dwIndex );
                    hr = DoubleFromPropertyBag (
                            pPropBag,
                            pIErrorLog,
                            strParamName,
                            strNonLocParamName,
                            ((DOUBLE)0.0),
                            dThreshold);
                }

                if ( SUCCEEDED ( hr ) ) {

                    // 1 = size of "<"
                    // SLQ_MAX_VALUE_LEN = size of threshold value
                    // 1 = size of null terminator
                    dwCharCount = lstrlen(pszPath) + 1 + SLQ_MAX_VALUE_LEN + 1;
                    dwByteCount = sizeof (ALERT_INFO_BLOCK) + ( dwCharCount * sizeof(WCHAR) ) + MAX_ALIGN_BYTES;
                    paibInfo = (PALERT_INFO_BLOCK) new CHAR[dwByteCount];
                    ZeroMemory ( paibInfo, dwByteCount );
                    szString = new WCHAR[dwCharCount];

                    paibInfo->dwSize = dwByteCount;
                    paibInfo->szCounterPath = pszPath;
                    pszPath = NULL;
                    paibInfo->dwFlags = dwOverUnder;
                    paibInfo->dLimit = dThreshold;

                    if ( MakeStringFromInfo( paibInfo, szString, &dwCharCount ) ) {
                        AddCounter ( szString );
                    }
                }
            }
        MFC_CATCH_MINIMUM 

        if ( NULL != szString ) {
            delete [] szString;
            szString = NULL;
        }
        if ( NULL != szCounterPath ) {
            delete [] szCounterPath;
            szCounterPath = NULL;
        }
        if ( NULL != paibInfo ) {
            delete [] paibInfo;
            paibInfo = NULL;
        }
    }

    if ( NULL != szLocaleBuf ) {
        delete [] szLocaleBuf;
    }

    //
    //  Todo:  Display error message listing unloaded counters.
    //
    // Return good status regardless.

    return S_OK;
}

HRESULT
CSmAlertQuery::LoadFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog* pIErrorLog )
{
    HRESULT     hr = S_OK;

    SLQ_TIME_INFO   stiDefault;
    LPWSTR      pszTemp = NULL;
    DWORD       dwBufSize;

    //
    // Continue even if error, using defaults for missing values.
    //
    hr = LoadCountersFromPropertyBag ( pPropBag, pIErrorLog );

    stiDefault.wTimeType = SLQ_TT_TTYPE_SAMPLE;
    stiDefault.dwAutoMode = SLQ_AUTO_MODE_AFTER;
    stiDefault.wDataType = SLQ_TT_DTYPE_UNITS;
    stiDefault.dwUnitType = SLQ_TT_UTYPE_SECONDS;
    stiDefault.dwValue = 5;

    hr = SlqTimeFromPropertyBag (
            pPropBag,
            pIErrorLog,
            SLQ_TT_TTYPE_SAMPLE,
            &stiDefault,
            &mr_stiSampleInterval );

    mr_strCmdFileName.Empty();
    dwBufSize = 0;
    hr = StringFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_COMMAND_FILE,
            ALRT_DEFAULT_COMMAND_FILE,
            &pszTemp,
            &dwBufSize );

    if ( sizeof(WCHAR) < dwBufSize ) {
        ASSERT ( NULL != pszTemp );
        ASSERT ( 0 != * pszTemp );
        mr_strCmdFileName = pszTemp;
    }
    delete [] pszTemp;
    pszTemp = NULL;

    mr_strNetName.Empty();
    dwBufSize = 0;
    hr = StringFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_NETWORK_NAME,
            ALRT_DEFAULT_NETWORK_NAME,
            &pszTemp,
            &dwBufSize );

    if ( sizeof(WCHAR) < dwBufSize ) {
        ASSERT ( NULL != pszTemp );
        ASSERT ( 0 != * pszTemp );
        mr_strNetName = pszTemp;
    }
    delete [] pszTemp;
    pszTemp = NULL;

    mr_strCmdUserText.Empty();
    dwBufSize = 0;
    hr = StringFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_USER_TEXT,
            ALRT_DEFAULT_USER_TEXT,
            &pszTemp,
            &dwBufSize );

    if ( sizeof(WCHAR) < dwBufSize ) {
        ASSERT ( NULL != pszTemp );
        ASSERT ( 0 != * pszTemp );
        mr_strCmdUserText = pszTemp;
    }
    delete [] pszTemp;
    pszTemp = NULL;

    mr_strPerfLogName.Empty();
    dwBufSize = 0;
    hr = StringFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_PERF_LOG_NAME,
            ALRT_DEFAULT_PERF_LOG_NAME,
            &pszTemp,
            &dwBufSize );

    if ( sizeof(WCHAR) < dwBufSize ) {
        ASSERT ( NULL != pszTemp );
        ASSERT ( 0 != * pszTemp );
        mr_strPerfLogName = pszTemp;
    }
    delete [] pszTemp;
    pszTemp = NULL;

    hr = DwordFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_ACTION_FLAGS,
            ALRT_DEFAULT_ACTION,
            mr_dwActionFlags);

    hr = CSmLogQuery::LoadFromPropertyBag( pPropBag, pIErrorLog );

    return hr;
}


HRESULT
CSmAlertQuery::SaveCountersToPropertyBag (
    IPropertyBag* pPropBag )
{
    HRESULT    hr = S_OK;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    LPCWSTR    szString;
    CString    strNonLocParamName;
    DWORD      dwIndex = 0;
    LPWSTR     szEnglishBuf = NULL;
    DWORD      dwEnglishBufLen = 0;
    LPWSTR     pszPath = NULL;
    PALERT_INFO_BLOCK paibInfo = NULL;
    LPWSTR      pNewBuf = NULL;
    DWORD       dwByteCount;
    DWORD       dwBufLen;

    szString = GetFirstCounter();
    
    //
    //  Todo:  Error message for counters that fail.
    //
    while ( NULL != szString ) {
        pdhStatus = ERROR_SUCCESS;
        hr = S_OK;
        pszPath = NULL;

        MFC_TRY
            if ( NULL == paibInfo ) {
                //
                //  Include space for possibly alignment padding
                //
                dwByteCount = 
                    sizeof (ALERT_INFO_BLOCK) 
                    + ( PDH_MAX_COUNTER_PATH + 1 ) * sizeof(WCHAR)
                    + MAX_ALIGN_BYTES;
                paibInfo = (PALERT_INFO_BLOCK) new CHAR[dwByteCount];
            }

            if ( MakeInfoFromString( szString, paibInfo, &dwByteCount ) ) {

                pszPath = paibInfo->szCounterPath;

                if (m_bCounterListInLocale) {
                    //
                    // Translate counter name from Locale into English
                    //

                    if ( 0 == dwEnglishBufLen ) {
                        dwEnglishBufLen = PDH_MAX_COUNTER_PATH + 1;
                        szEnglishBuf = new WCHAR [dwEnglishBufLen];
                        if ( NULL == szEnglishBuf ) {
                            dwEnglishBufLen = 0;
                        }
                    }

                    dwBufLen = dwEnglishBufLen;

                    pdhStatus = PdhTranslate009Counter(
                                    paibInfo->szCounterPath,
                                    szEnglishBuf,
                                    &dwBufLen);                

                    if (pdhStatus == ERROR_SUCCESS) {
                        pszPath = szEnglishBuf;
                    } else if ( PDH_MORE_DATA == pdhStatus ) {
                        //
                        // Todo:  Build error message.
                        //
                    } // else build error message.
                }

                if ( NULL != pszPath ) {                
                    strNonLocParamName.Format ( GetNonLocHtmlPropName ( IDS_HTML_SYSMON_COUNTERPATH ), ++dwIndex );
                    hr = StringToPropertyBag ( pPropBag, strNonLocParamName, pszPath);

                    strNonLocParamName.Format ( GetNonLocHtmlPropName ( IDS_HTML_ALERT_OVER_UNDER ), dwIndex );
                    hr = DwordToPropertyBag ( pPropBag, strNonLocParamName, paibInfo->dwFlags );

                    strNonLocParamName.Format ( GetNonLocHtmlPropName ( IDS_HTML_ALERT_THRESHOLD ), dwIndex );
                    hr = DoubleToPropertyBag ( pPropBag, strNonLocParamName, paibInfo->dLimit );
                } else {
                    hr = E_UNEXPECTED;
                }
            }
        MFC_CATCH_HR

        szString = GetNextCounter();
    }
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_SYSMON_COUNTERCOUNT, dwIndex );

    if ( NULL != paibInfo ) {
        delete [] (char*)paibInfo;
        paibInfo = NULL;
    }

    if (szEnglishBuf != NULL) {
        delete [] szEnglishBuf;
    }

    //
    //  Todo:  Display error message
    //  Todo:  Caller handle error.  Return count of saved counters.
    //
    return hr;
}

HRESULT
CSmAlertQuery::SaveToPropertyBag (
    IPropertyBag* pPropBag,
    BOOL fSaveAllProps )
{
    HRESULT hr = NOERROR;

    hr = SaveCountersToPropertyBag ( pPropBag );
    hr = SlqTimeToPropertyBag ( pPropBag, SLQ_TT_TTYPE_SAMPLE, &mr_stiSampleInterval );
    hr = StringToPropertyBag ( pPropBag, IDS_HTML_COMMAND_FILE, mr_strCmdFileName );
    hr = StringToPropertyBag ( pPropBag, IDS_HTML_NETWORK_NAME, mr_strNetName );
    hr = StringToPropertyBag ( pPropBag, IDS_HTML_USER_TEXT, mr_strCmdUserText );
    hr = StringToPropertyBag ( pPropBag, IDS_HTML_PERF_LOG_NAME, mr_strPerfLogName );
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_ACTION_FLAGS, mr_dwActionFlags );

    hr = CSmLogQuery::SaveToPropertyBag( pPropBag, fSaveAllProps );

    return hr;
}

DWORD
CSmAlertQuery::TranslateMSZAlertCounterList(
    LPWSTR   pszCounterList,
    LPWSTR   pBuffer,
    LPDWORD  pdwBufferSize,
    BOOL     bFlag
    )
{
    DWORD   dwStatus  = ERROR_SUCCESS;
    HRESULT hr = S_OK;
    LPWSTR  pTmpBuf = NULL;
    DWORD   dwLen = 0;
    LPWSTR  pOriginPath = NULL;
    LPWSTR  pszCounterPathToAdd = NULL;
    LPWSTR  pNextStringPosition = NULL;
    BOOL    bEnoughBuffer = TRUE;
    DWORD   dwNewCounterListLen = 0;
    DWORD   dwCounterPathLen = 0;
    LPWSTR  pData = NULL;
    LPWSTR  pszBackupPath = NULL;
    size_t  cchBackupLen = PDH_MAX_COUNTER_PATH + 1;

    if (pszCounterList == NULL || pdwBufferSize == NULL) {
        dwStatus = ERROR_INVALID_PARAMETER;
        return dwStatus;
    }

    if ( pBuffer == NULL || *pdwBufferSize == 0 ) {
        bEnoughBuffer = FALSE;
    } else {
        pBuffer[0] = L'\0';
    }

    pOriginPath = pszCounterList;
    
    while ( *pOriginPath ) {

        pszCounterPathToAdd = NULL;
        dwStatus = ERROR_SUCCESS;

        MFC_TRY    

            //
            // Locate the position where the data description begins
            //
            pData = pOriginPath;
            while (*pData != L'\0' && *pData != L'<' && *pData != L'>')  {
                pData++;
            }

            //
            // Backup the counter path
            //
            //
            if (pszBackupPath == NULL) {
                //
                // Memory allocation error throws exception
                //
                pszBackupPath = new WCHAR [cchBackupLen] ;        
                pszBackupPath [0] = L'\0';
            }

            //
            //  StringCchCopyN adds null termination
            //
            hr = StringCchCopyN ( pszBackupPath, cchBackupLen, pOriginPath, (INT_PTR)(pData - pOriginPath) );

            if ( SUCCEEDED ( hr ) && L'\0' != pszBackupPath [0] ) {

                pszCounterPathToAdd = pszBackupPath;
                //
                // Initialize the buffer used for translating counter path.
                // This is called only once.
                //
                dwLen = PDH_MAX_COUNTER_PATH + 1;
                if (pTmpBuf == NULL) {
                    pTmpBuf = new WCHAR [ dwLen ] ;
                }

                if (bFlag) {
                    dwStatus = PdhTranslateLocaleCounter(
                                    pszBackupPath,
                                    pTmpBuf,
                                    &dwLen);
                } else {
                   dwStatus = PdhTranslate009Counter(
                                   pszBackupPath,
                                   pTmpBuf,
                                   &dwLen);
                }

                if (dwStatus == ERROR_SUCCESS) {
                    pszCounterPathToAdd = pTmpBuf;
                }

                if ( NULL != pszCounterPathToAdd ) {
                    //
                    // Add the translated counter path to the new counter
                    // path list. The translated path is the original 
                    // counter path if translation failed. 
                    //
                    dwStatus = ERROR_SUCCESS;
                    dwCounterPathLen = lstrlen(pszCounterPathToAdd) + 1;

                    dwNewCounterListLen += dwCounterPathLen;

                    if ( bEnoughBuffer ) {
                        if ( (dwNewCounterListLen + lstrlen(pData) + 1) * sizeof(WCHAR) <= *pdwBufferSize) {
                            //
                            // Set up the copy position
                            //
                            pNextStringPosition = pBuffer + dwNewCounterListLen - dwCounterPathLen;

                            StringCchCopy ( pNextStringPosition, (dwCounterPathLen + lstrlen(pData) + 1), pszCounterPathToAdd );
                            StringCchCat (pNextStringPosition, (dwCounterPathLen + lstrlen(pData) + 1), pData);
                        }
                        else {
                           bEnoughBuffer = FALSE;
                        }
                    }
                    dwNewCounterListLen += lstrlen(pData);

                    pszCounterPathToAdd = NULL;
                }
            } else {

                // 
                //  Todo:  On failure, add path to error list and continue with next counter.
                //
            }
        MFC_CATCH_DWSTATUS    
        //
        // Continue processing next counter path
        //
        pOriginPath += lstrlen(pOriginPath) + 1;
    }

    dwNewCounterListLen ++;

    if ( bEnoughBuffer ) {
        if ( ERROR_SUCCESS == dwStatus ) {
            //
            // Append the terminating 0
            //
            pBuffer[dwNewCounterListLen - 1] = L'\0';
        }
        //
        // Todo:  Display error for unadded counters.
        //
    } else {

        if ( NULL != pBuffer ) {
            pBuffer[0] = L'\0';
        }
       
        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    *pdwBufferSize = dwNewCounterListLen * sizeof(WCHAR);

    if (pszBackupPath != NULL) {
        delete [] pszBackupPath;
    }
    if (pTmpBuf != NULL) {
        delete [] pTmpBuf;
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smalrtq.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smalrtq.h

Abstract:

    This object is used to represent performance alert queries (a.k.a.
    sysmon alert queries).

--*/

#ifndef _CLASS_SMALRTQ_
#define _CLASS_SMALRTQ_

#include "smlogqry.h"

typedef struct _ALERT_ACTION_INFO {
    DWORD   dwSize;
    DWORD   dwActionFlags;
    LPWSTR  szNetName;
    LPWSTR  szCmdFilePath;
    LPWSTR  szUserText;
    LPWSTR  szLogName;
} ALERT_ACTION_INFO, *PALERT_ACTION_INFO;

class CSmLogService;

class CSmAlertQuery : public CSmLogQuery
{
    // constructor/destructor
    public:
        CSmAlertQuery( CSmLogService* );
        virtual ~CSmAlertQuery( void );

    // public methods
    public:

        virtual         DWORD   Open ( const CString& rstrName, HKEY hKeyQuery, BOOL bReadOnly);
        virtual         DWORD   Close ( void );

        virtual         DWORD   UpdateRegistry( void );   // load reg. w/ internal values
        virtual         DWORD   SyncWithRegistry( void );

        virtual         BOOL    GetLogTime(PSLQ_TIME_INFO pTimeInfo, DWORD dwFlags);
        virtual         BOOL    SetLogTime(PSLQ_TIME_INFO pTimeInfo, const DWORD dwFlags);
        virtual         BOOL    GetDefaultLogTime(SLQ_TIME_INFO&  rTimeInfo,  DWORD dwFlags);

        virtual         DWORD   GetLogType( void );

        virtual const   CString& GetLogFileType ( void );
        virtual         void    GetLogFileType ( DWORD& );
        virtual         BOOL    SetLogFileType ( const DWORD );

        virtual const   CString&  GetLogFileName( BOOL bLatestRunning = FALSE );

                        // Methods specific to this query type

                        LPCWSTR GetCounterList( LPDWORD pcchListSize );
                        BOOL    SetCounterList( LPCWSTR mszCounterList, DWORD cchListSize );

                        LPCWSTR GetFirstCounter( void );
                        LPCWSTR GetNextCounter( void );
                        VOID    ResetCounterList( void );
                        BOOL    AddCounter(LPCWSTR szCounterPath);
                        DWORD   TranslateCounterListToLocale();

                        BOOL    GetActionInfo( PALERT_ACTION_INFO pInfo, LPDWORD pdwInfoBufSize);
                        DWORD   SetActionInfo( PALERT_ACTION_INFO pInfo );

        virtual         HRESULT LoadFromPropertyBag ( IPropertyBag*, IErrorLog* );
        virtual         HRESULT SaveToPropertyBag   ( IPropertyBag*, BOOL fSaveAllProps );

        virtual         HRESULT LoadCountersFromPropertyBag ( IPropertyBag*, IErrorLog* );
        virtual         HRESULT SaveCountersToPropertyBag   ( IPropertyBag* );

        virtual         DWORD   TranslateMSZAlertCounterList( 
                                    LPWSTR  pszCounterList,
                                    LPWSTR  pBuffer,
                                    LPDWORD pdwBufferSize,
                                    BOOL    bFlag);

        virtual CSmAlertQuery*      CastToAlertQuery( void ) { return this; };
        // protected methods
    protected:

    // private member variables
    private:

        LPWSTR  m_szNextCounter;
        DWORD   m_dwCounterListLength;  // in chars including MSZ null

        // Registry Values
        LPWSTR  mr_szCounterList;
        BOOL    m_bCounterListInLocale;
        DWORD   mr_dwActionFlags;
        CString mr_strNetName;
        CString mr_strCmdFileName;
        CString mr_strCmdUserText;
        CString mr_strCmdUserTextIndirect;
        CString mr_strPerfLogName;
};


typedef CSmAlertQuery   SLALERTQUERY;
typedef CSmAlertQuery*  PSLALERTQUERY;


#endif //_CLASS_SMALRTQ_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smalrtsv.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smalrtsv.h

Abstract:

	This object is used to represent the alert query components of the
	sysmon log service

--*/

#ifndef _CLASS_SMALERTSERVICE_
#define _CLASS_SMALERTSERVICE_

#include "smlogs.h"

class CSmAlertService : public CSmLogService
{
    // constructor/destructor
    public:

                CSmAlertService();
        virtual ~CSmAlertService();

    // public methods
    public:

        virtual DWORD   Open ( const CString& rstrMachineName );
        virtual DWORD   Close ( void );

        virtual DWORD   SyncWithRegistry ( PSLQUERY* ppActiveQuery = NULL );

        virtual PSLQUERY    CreateQuery ( const CString& rstrName );
        virtual DWORD       DeleteQuery ( PSLQUERY plQuery );

        virtual CSmAlertService* CastToAlertService( void ) { return this; };

    protected:

        virtual DWORD       LoadQueries( void );
};

#endif //_CLASS_SMALERTSERVICE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smalrtsv.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smalrtsv.cpp

Abstract:

	This object is used to represent the alert query components of the
	sysmon log service


--*/

#include "Stdafx.h"
#include "smalrtsv.h"

//
//  Constructor
CSmAlertService::CSmAlertService()
{
    CString                 strTemp;
    ResourceStateManager    rsm;

    // String allocation errors are thrown, to be
    // captured by rootnode alloc exception handler
    strTemp.LoadString ( IDS_SERVICE_NAME_ALERT );
    SetBaseName ( strTemp ); 
    strTemp.LoadString ( IDS_ALERT_NODE_DESCRIPTION );
    SetDescription( strTemp ); 
}

//
//  Destructor
CSmAlertService::~CSmAlertService()
{
    // Make sure Close method was called first!
    ASSERT ( NULL == m_QueryList.GetHeadPosition() );
    return;
}

PSLQUERY    
CSmAlertService::CreateQuery ( const CString& rstrName )
{
    return ( CSmLogService::CreateTypedQuery( rstrName, SLQ_ALERT ) );
}

DWORD   
CSmAlertService::DeleteQuery (PSLQUERY  pQuery)
{
    ASSERT ( SLQ_ALERT == pQuery->GetLogType () );
    return ( CSmLogService::DeleteQuery( pQuery ) );
}

DWORD   
CSmAlertService::LoadQueries ( void )
{
    return ( CSmLogService::LoadQueries( SLQ_ALERT ) );
}

//  
//  Open function. Opens all existing alert entries.
//
DWORD   
CSmAlertService::Open ( const CString& rstrMachineName )
{
    return ( CSmLogService::Open ( rstrMachineName ) );
}

//
//  Close Function
//      closes registry handles and frees allocated memory
//      
DWORD   
CSmAlertService::Close ()
{
    return ( CSmLogService::Close() );
}

//
//  SyncWithRegistry()
//      reads the current values for all queries from the registry
//      and reloads the internal values to match.
//
//  
DWORD   
CSmAlertService::SyncWithRegistry ( PSLQUERY* ppActiveQuery )
{
    DWORD       dwStatus = ERROR_SUCCESS;

    dwStatus = CSmLogService::SyncWithRegistry ( ppActiveQuery );

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smcfghlp.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smcfghlp.h

Abstract:

    Help ID definitions for the Performance Logs and Alerts
    MMC snap-in.

--*/

#ifndef _SMCFGHLP_H_
#define _SMCFGHLP_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// Property pages

#define IDH_PG_SMCFG_FILES      1000200
#define IDH_PG_SMCFG_SCHEDULE   1000201
#define IDH_PG_SMCFG_CTRS_GEN   1000202
#define IDH_PG_SMCFG_TRACE_GEN  1000203
#define IDH_PG_SMCFG_TRACE_BUF  1000204
#define IDH_PG_SMCFG_ALERT_GEN  1000205
#define IDH_PG_SMCFG_ALERT_ACT  1000206

// Dialogs
// New query
#define IDH_NEWQ_NAME_EDIT          1000220

//Expensive Warning
#define IDH_CHECK_NO_MORE           1000230

// Prov status
#define IDH_PACT_PROVIDERS_LIST     1000240
#define IDH_PACT_CHECK_SHOW_ENABLED 1000241

// Prov add
#define IDH_PADD_PROVIDER_LIST      1000250

// Property pages

// Schedule

#define IDH_SCHED_START_MANUAL_RDO          1000300
#define IDH_SCHED_START_AT_RDO              1000301
#define IDH_SCHED_START_AT_TIME_DT          1000302
#define IDH_SCHED_START_AT_DATE_DT          1000303
#define IDH_SCHED_STOP_MANUAL_RDO           1000304
#define IDH_SCHED_STOP_SIZE_RDO             1000305
#define IDH_SCHED_STOP_AFTER_RDO            1000306
#define IDH_SCHED_STOP_AFTER_EDIT           1000307
#define IDH_SCHED_STOP_AFTER_UNITS_COMBO    1000308
#define IDH_SCHED_STOP_AT_RDO               1000309
#define IDH_SCHED_STOP_AT_TIME_DT           1000310
#define IDH_SCHED_STOP_AT_DATE_DT           1000311
#define IDH_SCHED_RESTART_CHECK             1000312
#define IDH_SCHED_EXEC_CHECK                1000313
#define IDH_SCHED_CMD_EDIT                  1000314
#define IDH_SCHED_CMD_BROWSE_BTN            1000315

//Trace buffers
#define IDH_TRACE_BUFFER_SIZE_EDIT      1000330
#define IDH_TRACE_MIN_BUF_EDIT          1000331
#define IDH_TRACE_MAX_BUF_EDIT          1000332
#define IDH_TRACE_BUF_FLUSH_CHECK       1000333
#define IDH_TRACE_FLUSH_INT_EDIT        1000334

// Alert Action
#define  IDH_ACTION_APPLOG_CHK          1000350
#define  IDH_ACTION_NETMSG_CHK          1000351
#define  IDH_ACTION_NETMSG_NAME_EDIT    1000352
#define  IDH_ACTION_START_LOG_CHK       1000353
#define  IDH_ACTION_START_LOG_COMBO     1000354
#define  IDH_ACTION_EXECUTE_CHK         1000355
#define  IDH_ACTION_EXECUTE_EDIT        1000356
#define  IDH_ACTION_EXECUTE_BROWSE_BTN  1000357
#define  IDH_ACTION_CMD_ARGS_DISPLAY    1000358
#define  IDH_ACTION_CMD_ARGS_BTN        1000359
//#define  IDH_ACTION_CAPTION             1000360

// Alert Command Arg
#define  IDH_CMD_ARG_SINGLE_CHK     1000380
#define  IDH_CMD_ARG_DATE_CHK       1000381
#define  IDH_CMD_ARG_VALUE_CHK      1000382
#define  IDH_CMD_ARG_ALERT_CHK      1000383
#define  IDH_CMD_ARG_NAME_CHK       1000384
#define  IDH_CMD_ARG_LIMIT_CHK      1000385
#define  IDH_CMD_USER_TEXT_CHK      1000386
#define  IDH_CMD_USER_TEXT_EDIT     1000387
#define  IDH_CMD_ARG_SAMPLE_DISPLAY 1000388
//#define  IDH_CMD_ARG_SAMPLE_CAPTION 1000389

// Alert General 
#define  IDH_ALRTS_COMMENT_EDIT         1000400
#define  IDH_ALRTS_COUNTER_LIST         1000401
#define  IDH_ALRTS_OVER_UNDER           1000402
#define  IDH_ALRTS_VALUE_EDIT           1000403
#define  IDH_ALRTS_ADD_BTN              1000404
#define  IDH_ALRTS_REMOVE_BTN           1000405
#define  IDH_ALRTS_SAMPLE_EDIT          1000406
#define  IDH_ALRTS_SAMPLE_UNITS_COMBO   1000407

// Counters
#define IDH_CTRS_COUNTER_LIST           1000420
#define IDH_CTRS_FILENAME_DISPLAY       1000421
#define IDH_CTRS_ADD_BTN                1000422
#define IDH_CTRS_ADD_OBJ_BTN            2000100    // added for Whistler
#define IDH_CTRS_REMOVE_BTN             1000423
#define IDH_CTRS_SAMPLE_EDIT            1000424
#define IDH_CTRS_SAMPLE_UNITS_COMBO     1000425

//Prov Prop
#define IDH_PROV_FILENAME_DISPLAY   1000440
#define IDH_PROV_SHOW_PROVIDERS_BTN 1000441
#define IDH_PROV_KERNEL_BTN         1000442
#define IDH_PROV_K_PROCESS_CHK      1000443
#define IDH_PROV_K_NETWORK_CHK      1000444
#define IDH_PROV_K_THREAD_CHK       1000445
#define IDH_PROV_K_SOFT_PF_CHK      1000446
#define IDH_PROV_K_DISK_IO_CHK      1000447
#define IDH_PROV_K_FILE_IO_CHK      1000448
#define IDH_PROV_OTHER_BTN          1000449
#define IDH_PROV_PROVIDER_LIST      1000450
#define IDH_PROV_ADD_BTN            1000451
#define IDH_PROV_REMOVE_BTN         1000452

// Files            called Logs in Whistler
#define IDH_FILES_COMMENT_EDIT          1000460
#define IDH_FILES_LOG_TYPE_COMBO        1000461
#define IDH_FILES_SIZE_LIMIT_UNITS      1000465
#define IDH_FILES_FOLDER_EDIT           1000466
#define IDH_FILES_FILENAME_EDIT         1000467
#define IDH_FILES_AUTO_SUFFIX_CHK       1000468
#define IDH_FILES_FIRST_SERIAL_EDIT     1000469
#define IDH_FILES_SUFFIX_COMBO          1000471
#define IDH_FILES_SAMPLE_DISPLAY        1000472
#define IDH_CFG_BTN                     2000101    // added for Whistler
#define IDH_FILES_OVERWRITE_CHK         2000102    // added for Whistler
#define IDH_RUNAS_EDIT                  2000115    // added for Whistler
#define IDH_SETPWD_BTN                  2000116    // added for Whistler
#define IDH_CTRS_ENTER_PWD              2000117    // added for Whistler
#define IDH_CTRS_REENTER_PWD            2000118    // added for Whistler
#define IDH_USERNAME                    2000119    // added for Whistler

// Log Files Tab  added for Whistler
#define IDH_FILES_FOLDER_CAPTION        2000103 // added for Whistler
#define IDH_FILES_FOLDER_BTN            2000104 // added for Whistler
#define IDH_FILES_FILENAME_CAPTION      2000105 // added for Whistler
#define IDH_FILES_SIZE_MAX_BTN          2000106 // added for Whistler
#define IDH_FILES_SIZE_LIMIT_BTN        2000107 // added for Whistler
#define IDH_FILES_SIZE_LIMIT_EDIT       2000108 // added for Whistler

// SQL Logs Tab added for Whistler
#define IDH_SQL_DSN_COMBO              2000109 // added for Whistler
#define IDH_SQL_FILENAME_EDIT          2000110 // added for Whistler
#define IDH_SQL_SIZE_MAX_BTN           2000111 // added for Whistler
#define IDH_SQL_SIZE_LIMIT_BTN         2000112 // added for Whistler
#define IDH_SQL_SIZE_LIMIT_EDIT        2000113  // added for Whistler
#define IDH_SQL_SIZE_LIMIT_SPIN        2000114  // added for Whistler

////////////////////////////
///
/// LAST ID USED     2000119
///
////////////////////////////

#endif // _SMCFGHLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smctrqry.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smctrqry.cpp

Abstract:

    Implementation of the counter log query class.

--*/

#include "Stdafx.h"
#include <strsafe.h>
#include <pdhp.h>        // for MIN_TIME_VALUE, MAX_TIME_VALUE
#include <pdhmsg.h>
#include "smctrqry.h"

USE_HANDLE_MACROS("SMLOGCFG(smctrqry.cpp)");

//
//  Constructor
CSmCounterLogQuery::CSmCounterLogQuery( CSmLogService* pLogService )
:   CSmLogQuery( pLogService ),
    m_dwCounterListLength ( 0 ),
    m_szNextCounter ( NULL ),
    m_bCounterListInLocale ( FALSE),
    mr_szCounterList ( NULL )
{
    // initialize member variables
    memset (&mr_stiSampleInterval, 0, sizeof(mr_stiSampleInterval));
    return;
}

//
//  Destructor
CSmCounterLogQuery::~CSmCounterLogQuery()
{
    return;
}

//
//  Open function. either opens an existing log query entry
//  or creates a new one
//
DWORD
CSmCounterLogQuery::Open ( const CString& rstrName, HKEY hKeyQuery, BOOL bReadOnly)
{
    DWORD   dwStatus = ERROR_SUCCESS;

    ASSERT ( SLQ_COUNTER_LOG == GetLogType() );

    dwStatus = CSmLogQuery::Open ( rstrName, hKeyQuery, bReadOnly );

    return dwStatus;
}

//
//  Close Function
//      closes registry handles and frees allocated memory
//
DWORD
CSmCounterLogQuery::Close ()
{
    DWORD dwStatus;
    LOCALTRACE (L"Closing Query\n");

    if (mr_szCounterList != NULL) {
        delete [] mr_szCounterList;
        mr_szCounterList = NULL;
    }

    dwStatus = CSmLogQuery::Close();

    return dwStatus;
}


//
//  UpdateRegistry function.
//      copies the current settings to the registry where they
//      are read by the log service
//
DWORD
CSmCounterLogQuery::UpdateRegistry() 
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwBufferSize;
    LPWSTR  szNewCounterList = NULL;

    if ( IsModifiable() ) {

        dwBufferSize = 0;
        //
        // Translate the counter list from Locale into English
        //
        dwStatus = TranslateMSZCounterList(mr_szCounterList,
                            NULL,
                            &dwBufferSize,
                            FALSE);
        if (dwStatus == ERROR_NOT_ENOUGH_MEMORY) {
            szNewCounterList = (LPWSTR) new char [dwBufferSize];
            if (szNewCounterList != NULL) {
                dwStatus = TranslateMSZCounterList(mr_szCounterList,
                                szNewCounterList,
                                &dwBufferSize,
                                FALSE);
            }
        }

        if (dwStatus == ERROR_SUCCESS && szNewCounterList != NULL) {
            dwStatus  = WriteRegistryStringValue (
                                m_hKeyQuery,
                                IDS_REG_COUNTER_LIST,
                                REG_MULTI_SZ,
                                szNewCounterList,
                                &dwBufferSize);
        }
        else {
            dwBufferSize = m_dwCounterListLength * sizeof(WCHAR);
            dwStatus  = WriteRegistryStringValue (
                                m_hKeyQuery,
                                IDS_REG_COUNTER_LIST,
                                REG_MULTI_SZ,
                                mr_szCounterList,
                                &dwBufferSize);
        }

        // Schedule

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = WriteRegistrySlqTime (
                m_hKeyQuery,
                IDS_REG_SAMPLE_INTERVAL,
                &mr_stiSampleInterval);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = CSmLogQuery::UpdateRegistry ();
        }

    } else {
        dwStatus = ERROR_ACCESS_DENIED;
    }

    return dwStatus;
}


DWORD 
CSmCounterLogQuery::TranslateCounterListToLocale()
{
    DWORD   dwBufferSize = 0;
    DWORD   dwStatus = ERROR_SUCCESS;
    LPWSTR  szNewCounterList;

    if (m_bCounterListInLocale) {
        return ERROR_SUCCESS;
    }

    CWaitCursor WaitCursor;

    //
    // Translate the counter list into Locale
    //
    dwBufferSize = 0;
    dwStatus = TranslateMSZCounterList(
                            mr_szCounterList,
                            NULL,
                            &dwBufferSize,
                            TRUE);

    if (dwStatus == ERROR_NOT_ENOUGH_MEMORY) {

        szNewCounterList = (LPWSTR) new char [dwBufferSize];

        if (szNewCounterList != NULL) {
            //
            // Translate the counter list into Locale
            //
            dwStatus = TranslateMSZCounterList(
                            mr_szCounterList,
                            szNewCounterList,
                            &dwBufferSize,
                            TRUE);

            if (dwStatus == ERROR_SUCCESS) {
                m_dwCounterListLength = dwBufferSize / sizeof(WCHAR);
                //
                // Remove the old
                //
                delete [] mr_szCounterList;
                m_szNextCounter = NULL;
                mr_szCounterList = szNewCounterList;
                m_bCounterListInLocale = TRUE;
            }
        }
    }

    WaitCursor.Restore();
    return dwStatus;
}


//
//  SyncWithRegistry()
//      reads the current values for this query from the registry
//      and reloads the internal values to match
//
//
DWORD
CSmCounterLogQuery::SyncWithRegistry()
{
    DWORD   dwBufferSize = 0;
    DWORD   dwStatus = ERROR_SUCCESS;
    SLQ_TIME_INFO   stiDefault;

    ASSERT (m_hKeyQuery != NULL);


    //
    // Delay translating the counter until you open the property dialog
    //
    m_bCounterListInLocale = FALSE;

    //
    // load counter list
    //
    dwStatus = ReadRegistryStringValue (
                    m_hKeyQuery,
                    IDS_REG_COUNTER_LIST,
                    NULL,
                    &mr_szCounterList,
                    &dwBufferSize);

    if (dwStatus != ERROR_SUCCESS) {
        m_szNextCounter = NULL; //re-initialize
        m_dwCounterListLength = 0;
    } 
    else {
        m_dwCounterListLength = dwBufferSize / sizeof(WCHAR);
    }


    // Schedule

    stiDefault.wTimeType = SLQ_TT_TTYPE_SAMPLE;
    stiDefault.dwAutoMode = SLQ_AUTO_MODE_AFTER;
    stiDefault.wDataType = SLQ_TT_DTYPE_UNITS;
    stiDefault.dwUnitType = SLQ_TT_UTYPE_SECONDS;
    stiDefault.dwValue = 15;

    dwStatus = ReadRegistrySlqTime (
                m_hKeyQuery,
                IDS_REG_SAMPLE_INTERVAL,
                &stiDefault,
                &mr_stiSampleInterval);
    ASSERT (dwStatus == ERROR_SUCCESS);

    // Call parent class last to update shared values.

    dwStatus = CSmLogQuery::SyncWithRegistry();
    ASSERT (dwStatus == ERROR_SUCCESS);

    return dwStatus;
}

//
//  Get first counter in counter list
//
LPCWSTR
CSmCounterLogQuery::GetFirstCounter()
{
    LPWSTR  szReturn;

    szReturn = mr_szCounterList;
    if (szReturn != NULL) {
        if (*szReturn == 0) {
            // then it's an empty string
            szReturn = NULL;
            m_szNextCounter = NULL;
        } else {
            m_szNextCounter = szReturn + lstrlen(szReturn) + 1;
            if (*m_szNextCounter == 0) {
                // end of list reached so set pointer to NULL
                m_szNextCounter = NULL;
            }
        }
    } else {
        // no buffer allocated yet
        m_szNextCounter = NULL;
    }
    return (LPCWSTR)szReturn;
}

//
//  Get next counter in counter list
//  NULL pointer means no more counters in list
//
LPCWSTR
CSmCounterLogQuery::GetNextCounter()
{
    LPWSTR  szReturn;
    szReturn = m_szNextCounter;

    if (m_szNextCounter != NULL) {
        m_szNextCounter += lstrlen(szReturn) + 1;
        if (*m_szNextCounter == 0) {
            // end of list reached so set pointer to NULL
            m_szNextCounter = NULL;
        }
    } else {
        // already at the end of the list so nothing to do
    }

    return (LPCWSTR)szReturn;
}

//
//  clear out the counter list
//
VOID
CSmCounterLogQuery::ResetCounterList()
{
    if (mr_szCounterList != NULL) {
        delete [] mr_szCounterList;
        m_szNextCounter = NULL;
        mr_szCounterList = NULL;
    }

    m_dwCounterListLength = sizeof(WCHAR);  // sizeof MSZ Null
    try {
        mr_szCounterList = new WCHAR [m_dwCounterListLength];
        mr_szCounterList[0] = 0;
    } catch ( ... ) {
        m_dwCounterListLength = 0;
    }
}

//
//  Add this counter string to the internal list
//
BOOL
CSmCounterLogQuery::AddCounter(LPCWSTR szCounterPath)
{
    DWORD   dwNewSize;
    LPWSTR  szNewString;
    LPWSTR  szNextString;

    ASSERT (szCounterPath != NULL);

    if (szCounterPath == NULL) {
        return FALSE;
    }

    dwNewSize = lstrlen(szCounterPath) + 1;

    if (m_dwCounterListLength <= 2) {
        dwNewSize += 1; // add room for the MSZ null
        // then this is the first string to go in the list
        try {
            szNewString = new WCHAR [dwNewSize];
        } catch ( ... ) {
            return FALSE; // leave now
        }
        szNextString = szNewString;
    } else {
        dwNewSize += m_dwCounterListLength;
        // this is the nth string to go in the list
        try {
            szNewString = new WCHAR [dwNewSize];
        } catch ( ... ) {
            return FALSE; // leave now
        }
        memcpy (szNewString, mr_szCounterList,
            (m_dwCounterListLength * sizeof(WCHAR)));
        szNextString = szNewString;
        szNextString += m_dwCounterListLength - 1;
    }
    StringCchCopy ( szNextString, dwNewSize, szCounterPath );
    szNextString = szNewString;
    szNextString += dwNewSize - 1;
    *szNextString = 0;  // MSZ Null

    if (mr_szCounterList != NULL) {
        delete [] mr_szCounterList;
    }
    mr_szCounterList = szNewString;
    m_szNextCounter = szNewString;
    m_dwCounterListLength = dwNewSize;

    return TRUE;
}

BOOL
CSmCounterLogQuery::GetLogTime(PSLQ_TIME_INFO pTimeInfo, DWORD dwFlags)
{
    BOOL bStatus;

    ASSERT ( ( SLQ_TT_TTYPE_START == dwFlags )
            || ( SLQ_TT_TTYPE_STOP == dwFlags )
            || ( SLQ_TT_TTYPE_RESTART == dwFlags )
            || ( SLQ_TT_TTYPE_SAMPLE == dwFlags ) );

    bStatus = CSmLogQuery::GetLogTime( pTimeInfo, dwFlags );

    return bStatus;
}

BOOL
CSmCounterLogQuery::SetLogTime(PSLQ_TIME_INFO pTimeInfo, const DWORD dwFlags)
{
    BOOL bStatus;

    ASSERT ( ( SLQ_TT_TTYPE_START == dwFlags )
            || ( SLQ_TT_TTYPE_STOP == dwFlags )
            || ( SLQ_TT_TTYPE_RESTART == dwFlags )
            || ( SLQ_TT_TTYPE_SAMPLE == dwFlags ) );

    bStatus = CSmLogQuery::SetLogTime( pTimeInfo, dwFlags );

    return bStatus;
}

BOOL
CSmCounterLogQuery::GetDefaultLogTime(SLQ_TIME_INFO& rTimeInfo, DWORD dwFlags)
{
    ASSERT ( ( SLQ_TT_TTYPE_START == dwFlags )
            || ( SLQ_TT_TTYPE_STOP == dwFlags ) );

    rTimeInfo.wTimeType = (WORD)dwFlags;
    rTimeInfo.wDataType = SLQ_TT_DTYPE_DATETIME;

    if ( SLQ_TT_TTYPE_START == dwFlags ) {
        SYSTEMTIME  stLocalTime;
        FILETIME    ftLocalTime;

        // Milliseconds set to 0 for Schedule times
        ftLocalTime.dwLowDateTime = ftLocalTime.dwHighDateTime = 0;
        GetLocalTime (&stLocalTime);
        stLocalTime.wMilliseconds = 0;
        SystemTimeToFileTime (&stLocalTime, &ftLocalTime);

        rTimeInfo.dwAutoMode = SLQ_AUTO_MODE_AT;
        rTimeInfo.llDateTime = *(LONGLONG *)&ftLocalTime;
    } else {
        // Default stop values
        rTimeInfo.dwAutoMode = SLQ_AUTO_MODE_NONE;
        rTimeInfo.llDateTime = MAX_TIME_VALUE;
    }

    return TRUE;
}

DWORD
CSmCounterLogQuery::GetLogType()
{
    return ( SLQ_COUNTER_LOG );
}

HRESULT
CSmCounterLogQuery::LoadCountersFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog* pIErrorLog )
{
    HRESULT hr = S_OK;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    CString strParamName;
    CString strNonLocParamName;
    DWORD   dwCount = 0;
    DWORD   dwIndex;
    LPWSTR  szLocaleBuf = NULL;
    DWORD   dwLocaleBufLen = 0;
    LPWSTR  szCounterPath = NULL;
    LPWSTR  pszPath = NULL;
    DWORD   dwBufLen = 0;

    m_bCounterListInLocale = FALSE;
    hr = DwordFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_SYSMON_COUNTERCOUNT,
            0,
            dwCount);

    for ( dwIndex = 1; dwIndex <= dwCount; dwIndex++ ) {

        pdhStatus = ERROR_SUCCESS;
        hr = S_OK;
        pszPath = NULL;

        MFC_TRY 
            strNonLocParamName.Format ( GetNonLocHtmlPropName ( IDS_HTML_SYSMON_COUNTERPATH ), dwIndex );
            strParamName.Format ( IDS_HTML_SYSMON_COUNTERPATH, dwIndex );
            hr = StringFromPropertyBag (
                    pPropBag,
                    pIErrorLog,
                    strParamName,
                    strNonLocParamName,
                    L"",
                    &szCounterPath,
                    &dwBufLen );

            pszPath = szCounterPath;
            
            //
            // 1 for NULL character
            //
            if (dwBufLen > 1) {
                //
                // Initialize the locale path buffer
                //
                if (dwLocaleBufLen == 0) {
                    dwLocaleBufLen = PDH_MAX_COUNTER_PATH + 1;  
                    szLocaleBuf = new WCHAR[dwLocaleBufLen];
                    if (szLocaleBuf == NULL) {
                        dwLocaleBufLen = 0;
                    }
                }

                if (szLocaleBuf != NULL) {
                    //
                    // Translate counter name from English to Localized.
                    //
                    dwBufLen = dwLocaleBufLen;

                    pdhStatus = PdhTranslateLocaleCounter(
                                    szCounterPath,
                                    szLocaleBuf,
                                    &dwBufLen);

                    if (pdhStatus == ERROR_SUCCESS) {
                        m_bCounterListInLocale = TRUE;
                        pszPath = szLocaleBuf;
                    } else if ( PDH_MORE_DATA == pdhStatus ) {
                        //
                        // Todo:  Build error message.
                        //
                    } // else build error message.
                }

                AddCounter ( pszPath );
            }
        MFC_CATCH_MINIMUM 
        
        if ( NULL != szCounterPath ) {
            delete [] szCounterPath;
            szCounterPath = NULL;
        }
    }

    if (szLocaleBuf != NULL) {
        delete [] szLocaleBuf;
    }

    //
    //  Todo:  Display error message listing unloaded counters.
    //
    // Return good status regardless.

    return hr;
}


HRESULT
CSmCounterLogQuery::LoadFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog* pIErrorLog )
{
    HRESULT     hr = S_OK;
    SLQ_TIME_INFO   stiDefault;

    //
    // Continue even if error, using defaults for missing values.
    //
    hr = LoadCountersFromPropertyBag( pPropBag, pIErrorLog );

    stiDefault.wTimeType = SLQ_TT_TTYPE_SAMPLE;
    stiDefault.dwAutoMode = SLQ_AUTO_MODE_AFTER;
    stiDefault.wDataType = SLQ_TT_DTYPE_UNITS;
    stiDefault.dwUnitType = SLQ_TT_UTYPE_SECONDS;
    stiDefault.dwValue = 15;

    hr = SlqTimeFromPropertyBag (
            pPropBag,
            pIErrorLog,
            SLQ_TT_TTYPE_SAMPLE,
            &stiDefault,
            &mr_stiSampleInterval );

    hr = CSmLogQuery::LoadFromPropertyBag( pPropBag, pIErrorLog );
	
	return hr;
}

HRESULT
CSmCounterLogQuery::SaveCountersToPropertyBag (
    IPropertyBag* pPropBag )
{    
    HRESULT     hr = NOERROR;
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    CString     strNonLocParamName;
    LPCWSTR     pszCounterPath;
    LPWSTR      szEnglishBuf = NULL;
    DWORD       dwEnglishBufLen = 0;
    LPCWSTR     pszPath = NULL;
    DWORD       dwBufLen;

    DWORD dwIndex = 0;

    pszCounterPath = GetFirstCounter();

    //
    //  Todo:  Error message for counters that fail.
    //
    while ( NULL != pszCounterPath ) {
        pdhStatus = ERROR_SUCCESS;
        hr = S_OK;
        pszPath = NULL;
 
        MFC_TRY
            pszPath = pszCounterPath;

            if (m_bCounterListInLocale) {
                //
                // Initialize the locale path buffer
                //
                if (dwEnglishBufLen == 0) {
                    dwEnglishBufLen = PDH_MAX_COUNTER_PATH + 1;
                    szEnglishBuf = new WCHAR [ dwEnglishBufLen ];
                    if (szEnglishBuf == NULL) {
                        dwEnglishBufLen = 0;
                    }
                }
                //
                // Translate counter name from Localized into English
                //
                dwBufLen= dwEnglishBufLen;
    
                pdhStatus = PdhTranslate009Counter(
                                (LPWSTR)pszCounterPath,
                                szEnglishBuf,
                                &dwBufLen);

                if (pdhStatus == ERROR_SUCCESS) {
                    pszPath = szEnglishBuf;
                } else if ( PDH_MORE_DATA == pdhStatus ) {
                    //
                    // Todo:  Build error message.
                    //
                } // else build error message.
            }

            if ( NULL != pszPath ) {                
                //
                // Counter path count starts with 1.
                //
                strNonLocParamName.Format ( IDS_HTML_SYSMON_COUNTERPATH, ++dwIndex );
                hr = StringToPropertyBag ( pPropBag, strNonLocParamName, pszPath );
            } else {
                hr = E_UNEXPECTED;
            }
        MFC_CATCH_HR

        pszCounterPath = GetNextCounter();
    }
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_SYSMON_COUNTERCOUNT, dwIndex );

    if (szEnglishBuf != NULL) {
        delete [] szEnglishBuf;
    }

    //
    //  Todo:  Display error message
    //  Todo:  Caller handle error.  Return count of saved counters.
    //

    return hr;
}

HRESULT
CSmCounterLogQuery::SaveToPropertyBag (
    IPropertyBag* pPropBag,
    BOOL fSaveAllProps )
{
    HRESULT hr = NOERROR;

    hr = CSmLogQuery::SaveToPropertyBag( pPropBag, fSaveAllProps );

    hr = SaveCountersToPropertyBag ( pPropBag );

    hr = SlqTimeToPropertyBag ( pPropBag, SLQ_TT_TTYPE_SAMPLE, &mr_stiSampleInterval );

    return hr;
}


DWORD
CSmCounterLogQuery::TranslateMSZCounterList(
    LPWSTR   pszCounterList,
    LPWSTR   pBuffer,
    LPDWORD  pdwBufferSize,
    BOOL     bFlag
    )
{
    DWORD   dwStatus  = ERROR_SUCCESS;
    LPWSTR  pTmpBuf = NULL;
    DWORD   dwLen = 0;
    LPWSTR  pszCounterPath = NULL;
    LPWSTR  pszCounterPathToAdd = NULL;
    LPWSTR  pNextStringPosition = NULL;
    BOOL    bEnoughBuffer = TRUE;
    DWORD   dwNewCounterListLen = 0;
    DWORD   dwCounterPathLen = 0;

    if (pszCounterList == NULL || pdwBufferSize == NULL) {
        dwStatus = ERROR_INVALID_PARAMETER;
        return dwStatus;
    }

    if (pBuffer == NULL || *pdwBufferSize == 0) {
        bEnoughBuffer = FALSE;
    } else {
        pBuffer[0] = L'\0';
    }

    pszCounterPath = pszCounterList;

    while ( *pszCounterPath ) {

        pszCounterPathToAdd = NULL;
        dwStatus = ERROR_SUCCESS;
    
        MFC_TRY    

            pszCounterPathToAdd = pszCounterPath;
            
            //
            // Initialize the buffer used for translating counter path.
            // This is called only once.
            //
            dwLen = PDH_MAX_COUNTER_PATH + 1;
            if (pTmpBuf == NULL) {
                pTmpBuf = new WCHAR [ dwLen ] ;
            }

            if (bFlag) {
                // 
                // Translate counter name from English into Locale
                //
                dwStatus = PdhTranslateLocaleCounter(
                                pszCounterPath,
                                pTmpBuf,
                                &dwLen);
            } else {
                // 
                // Translate counter name from Locale into English
                //
                dwStatus = PdhTranslate009Counter(
                               pszCounterPath,
                               pTmpBuf,
                               &dwLen);
            }

            if (dwStatus == ERROR_SUCCESS) {
                pszCounterPathToAdd = pTmpBuf;
            }

            if ( NULL != pszCounterPathToAdd ) {
                //
                // Add the translated counter path to the new counter
                // path list. The translated path is the original 
                // counter path if translation failed. 
                //
                dwStatus = ERROR_SUCCESS;
                dwCounterPathLen = lstrlen(pszCounterPathToAdd) + 1;

                dwNewCounterListLen += dwCounterPathLen;

                if ( bEnoughBuffer ) {
                    if ( (dwNewCounterListLen + 1) * sizeof(WCHAR) <= *pdwBufferSize) {
                        //
                        // Set up the copy position
                        //
                        pNextStringPosition = pBuffer + dwNewCounterListLen - dwCounterPathLen;
                        StringCchCopy ( pNextStringPosition, (dwCounterPathLen + 1), pszCounterPathToAdd );
                    } else {
                       bEnoughBuffer = FALSE ;
                    }
                }
            }
        MFC_CATCH_DWSTATUS
        //
        // Continue processing next counter path
        //
        pszCounterPath += lstrlen(pszCounterPath) + 1;
    }

    dwNewCounterListLen ++;

    if ( bEnoughBuffer ) {
        if ( ERROR_SUCCESS == dwStatus ) {
            //
            // Append the terminating 0
            //
            pBuffer[dwNewCounterListLen - 1] = L'\0';
        }
        //
        // Todo:  Display error for unadded counters.
        //
    } else {
        if ( NULL != pBuffer ) {
            pBuffer[0] = L'\0';
        }
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
    }
    
    *pdwBufferSize = dwNewCounterListLen * sizeof(WCHAR);

    if (pTmpBuf != NULL) {
       delete [] pTmpBuf;
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smctrqry.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smctrqry.h

Abstract:

    Class definitions for the counter log query.

--*/

#ifndef _CLASS_SMCTRQRY_
#define _CLASS_SMCTRQRY_

#include "smlogqry.h"

class CSmCounterLogQuery : public CSmLogQuery
{
    // constructor/destructor
    public:
                CSmCounterLogQuery( CSmLogService* );
        virtual ~CSmCounterLogQuery( void );

    // public methods
    public:

        virtual DWORD   Open ( const CString& rstrName, HKEY hKeyQuery, BOOL bReadOnly);
        virtual DWORD   Close ( void );

        virtual DWORD   SyncWithRegistry( void );

        virtual BOOL    GetLogTime(PSLQ_TIME_INFO pTimeInfo, DWORD dwFlags);
        virtual BOOL    SetLogTime(PSLQ_TIME_INFO pTimeInfo, const DWORD dwFlags);
        virtual BOOL    GetDefaultLogTime(SLQ_TIME_INFO& rTimeInfo, DWORD dwFlags);

        virtual DWORD   GetLogType( void );

                LPCWSTR GetFirstCounter( void );
                LPCWSTR GetNextCounter( void );
                VOID    ResetCounterList( void );
                BOOL    AddCounter(LPCWSTR szCounterPath);
                DWORD   TranslateCounterListToLocale();

        virtual HRESULT LoadFromPropertyBag ( IPropertyBag*, IErrorLog* );
        virtual HRESULT SaveToPropertyBag   ( IPropertyBag*, BOOL fSaveAllProps );
        virtual HRESULT LoadCountersFromPropertyBag ( IPropertyBag*, IErrorLog* );
        virtual HRESULT SaveCountersToPropertyBag   ( IPropertyBag* );
        virtual DWORD   TranslateMSZCounterList( 
                            LPWSTR  pszCounterList,
                            LPWSTR  pBuffer,
                            LPDWORD pdwBufferSize,
                            BOOL    bFlag);

        virtual CSmCounterLogQuery* CastToCounterLogQuery ( void ) { return this; };
        // protected methods
    protected:
        virtual DWORD   UpdateRegistry();


    // private member variables
    private:

        LPWSTR  m_szNextCounter;
        DWORD   m_dwCounterListLength;  // in chars including MSZ null

        // Registry Values
        LPWSTR  mr_szCounterList;
        BOOL    m_bCounterListInLocale;
};


typedef CSmCounterLogQuery   SLCTRQUERY;
typedef CSmCounterLogQuery*  PSLCTRQUERY;


#endif //_CLASS_SMCTRQRY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smctrsv.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smctrsv.cpp

Abstract:

    Implementation of the counter log service class, representing
    counter logs within the Performance Logs and Alerts service.

--*/

#include "Stdafx.h"
#include "smctrqry.h"
#include "smctrsv.h"

//
//  Constructor
CSmCounterLogService::CSmCounterLogService()
{
    CString                 strTemp;
    ResourceStateManager    rsm;

    // String allocation errors are thrown, to be
    // captured by rootnode alloc exception handler
    strTemp.LoadString ( IDS_SERVICE_NAME_COUNTER );
    SetBaseName ( strTemp ); 
    strTemp.LoadString ( IDS_COUNTER_NODE_DESCRIPTION );
    SetDescription( strTemp ); 
}

//
//  Destructor
CSmCounterLogService::~CSmCounterLogService()
{
    // make sure Close method was called first!
    ASSERT ( NULL == m_QueryList.GetHeadPosition() );
    return;
}

PSLQUERY    
CSmCounterLogService::CreateQuery ( const CString& rstrName )
{
    return ( CreateTypedQuery( rstrName, SLQ_COUNTER_LOG ) );
}

DWORD   
CSmCounterLogService::DeleteQuery ( PSLQUERY pQuery )
{
    ASSERT ( SLQ_COUNTER_LOG == pQuery->GetLogType() );
    return ( CSmLogService::DeleteQuery ( pQuery ) );
}

DWORD   
CSmCounterLogService::LoadQueries ( void )
{
    return ( CSmLogService::LoadQueries( SLQ_COUNTER_LOG ) );
}

//  
//  Open function. Opens all existing log query entries.
//
DWORD   
CSmCounterLogService::Open ( const CString& rstrMachineName)
{
    return ( CSmLogService::Open ( rstrMachineName ) );
}

//
//  Close Function
//      closes registry handles and frees allocated memory
//      
DWORD   
CSmCounterLogService::Close ()
{
    return ( CSmLogService::Close() );
}

//
//  SyncWithRegistry()
//      reads the current values for all queries from the registry
//      and reloads the internal values to match.
//
//  
DWORD   
CSmCounterLogService::SyncWithRegistry( PSLQUERY* ppActiveQuery )
{
    DWORD       dwStatus = ERROR_SUCCESS;

    dwStatus = CSmLogService::SyncWithRegistry ( ppActiveQuery );

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smctrsv.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smctrsv.h

Abstract:

    This object is used to represent the counter log query components of the
    sysmon log service

--*/

#ifndef _CLASS_SMCOUNTERLOGSERVICE_
#define _CLASS_SMCOUNTERLOGSERVICE_

#include "smlogs.h"


class CSmCounterLogService : public CSmLogService
{
    // constructor/destructor
    public:

                CSmCounterLogService();        
        virtual ~CSmCounterLogService();

    // public methods
    public:

        virtual DWORD   Open ( const CString& rstrMachineName );
        virtual DWORD   Close ( void );

        virtual DWORD   SyncWithRegistry ( PSLQUERY* ppActiveQuery = NULL );

        virtual PSLQUERY    CreateQuery ( const CString& rstrName );
        virtual DWORD       DeleteQuery ( PSLQUERY pQuery );

        virtual CSmCounterLogService* CastToCounterLogService( void ) { return this; };

    protected:

        virtual DWORD       LoadQueries( void );

};

#endif //_CLASS_SMCOUNTERLOGSERVICE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smlogres.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smlogres.h

Abstract:

    Resource identifiers for the Performance Logs and Alerts
    MMC snap-in.

--*/

#define IDC_RUNAS_EDIT                  3001
#define IDC_SETPWD_BTN                  3002
#define IDC_RUNAS_STATIC                3003
// Use IDC_STATIC for RunAs caption, to eliminate 
// "No help topic" context help message.

#define IDB_NODES_16x16                 201
#define IDB_NODES_32x32                 202
#define IDB_TOOLBAR_RES                 203
#define IDB_SMLOGCFG_16x16              204
#define IDB_SMLOGCFG_32x32              205
#define IDB_TOOLBAR_RES_RTL             206

#define IDI_SMLOGCFG                    220
#define IDR_COMPONENTDATA               501
#define IDR_COMPONENT                   502
#define IDR_EXTENSION                   503
#define IDR_PERFORMANCEABOUT            504

#define IDS_PROJNAME                    500
#define IDS_ERRMSG_OUTOFMEMORY          501
#define IDS_ERRMSG_UNABLEALLOCDATAOBJECT 502
#define IDS_MMC_DEFAULT_NAME            503
#define IDS_ERRMSG_UNKDATAOBJ           504
#define IDS_MMC_SERVNOTINST             505
#define IDS_FT_TSV                      506
#define IDS_FT_CSV                      507
#define IDS_FT_SQL                      508 
#define IDS_FT_BINARY                   509
#define IDS_FT_BINARY_CIRCULAR          510
#define IDS_FT_CIRCULAR_TRACE           511
#define IDS_FT_SEQUENTIAL_TRACE         512
#define IDS_FT_UNKNOWN                  513
#define IDS_FS_MMDDHH                   514
#define IDS_FS_NNNNNN                   515
#define IDS_FS_YYYYDDD                  516
#define IDS_FS_YYYYMM                   517
#define IDS_FS_YYYYMMDD                 518
#define IDS_FS_YYYYMMDDHH               519
#define IDS_FS_MMDDHHMM                 520
#define IDS_SECONDS                     521
#define IDS_HOURS                       522
#define IDS_MINUTES                     523
#define IDS_DAYS                        524
#define IDS_BROWSE_CMD_FILE_CAPTION     525
#define IDS_BROWSE_CMD_FILE_FILTER1     526
#define IDS_BROWSE_CMD_FILE_FILTER2     527
#define IDS_BROWSE_CMD_FILE_FILTER3     528
#define IDS_BROWSE_CMD_FILE_FILTER4     529
#define IDS_SCHED_FILE_SIZE_DISPLAY     530
#define IDS_SCHED_FILE_MAX_SIZE_DISPLAY 531
#define IDS_SCHED_START_LOG_GROUP       534   
#define IDS_SCHED_STOP_LOG_GROUP        535
#define IDS_SCHED_RESTART_LOG           536
#define IDS_SCHED_STOP_LOG_WHEN         537
#define IDS_FILE_CIRC_SET_MANUAL_STOP   538
#define IDS_FILE_MAX_SET_MANUAL_STOP    539
#define IDS_FILE_DIR_NOT_FOUND          540
#define IDS_FILE_DIR_NOT_MADE           541
#define IDS_DIR_NOT_MADE                542
#define IDS_FILE_DIR_CREATE_CANCEL      543
#define IDS_DIR_CREATE_CANCEL           544
#define IDS_FT_EXT_CSV                  545
#define IDS_FT_EXT_TSV                  547
#define IDS_FT_EXT_BLG                  548
#define IDS_FT_EXT_ETL                  549
#define IDS_LOCAL                       550
#define IDS_ON                          551
#define IDS_SCHED_SESSION_TOO_SHORT     552
#define IDS_ERRMSG_GENERAL              553
#define IDS_SCHED_LOG_SET_DISPLAY       554

#define IDS_MMC_MENU_NEW_PERF_LOG       560
#define IDS_MMC_STATUS_NEW_PERF_LOG     561
#define IDS_MMC_MENU_PERF_LOG_FROM      562
#define IDS_MMC_STATUS_PERF_LOG_FROM    563
#define IDS_MMC_MENU_NEW_TRACE_LOG      564
#define IDS_MMC_STATUS_NEW_TRACE_LOG    565
#define IDS_MMC_MENU_TRACE_LOG_FROM     566
#define IDS_MMC_STATUS_TRACE_LOG_FROM   567
#define IDS_MMC_MENU_NEW_ALERT          568
#define IDS_MMC_STATUS_NEW_ALERT        569
#define IDS_MMC_MENU_ALERT_FROM         570
#define IDS_MMC_STATUS_ALERT_FROM       571
#define IDS_MMC_MENU_START              572
#define IDS_MMC_STATUS_START            573
#define IDS_MMC_MENU_STOP               574
#define IDS_MMC_STATUS_STOP             575
#define IDS_MMC_MENU_SAVE_AS            576
#define IDS_MMC_STATUS_SAVE_AS          577
#define IDS_BUTTON_NEW_LOG              578
#define IDS_BUTTON_START_LOG            579
#define IDS_BUTTON_STOP_LOG             580
#define IDS_BUTTON_NEW_ALERT            581
#define IDS_BUTTON_START_ALERT          582
#define IDS_BUTTON_STOP_ALERT           583
#define IDS_TOOLTIP_NEW_LOG             584
#define IDS_TOOLTIP_START_LOG           585
#define IDS_TOOLTIP_STOP_LOG            586
#define IDS_TOOLTIP_NEW_ALERT           587
#define IDS_TOOLTIP_START_ALERT         588
#define IDS_TOOLTIP_STOP_ALERT          589
#define IDS_SCHED_RESTART_ALERT         590
#define IDS_COUNTER_FILETYPE_FILTER     591
#define IDS_TRACE_FILETYPE_FILTER       592
#define IDS_SELECT_FILE_FOLDER          593

#define IDS_CTRS_REQUIRED               600
#define IDS_ERRMSG_DELETE_RUNNING_QUERY 601
#define IDS_ERRMSG_DELETE_TEMPLATE_QRY  602
#define IDS_ERRMSG_DELETE_OPEN_QUERY    603
#define IDS_ERRMSG_QUERY_DELETED        604
#define IDS_ERRMSG_START_OPEN_QUERY     605
#define IDS_ERRMSG_STOP_OPEN_QUERY      606
#define IDS_TRACE_MAX_BUFF              607
#define IDS_ERRMSG_WBEMERROR            608
#define IDS_ERRMSG_REFRESH_OPEN_QUERY   609
#define IDS_CANCEL_AUTO_RESTART         610 
#define IDS_SCHED_NOW_PAST_STOP         611
#define IDS_SCHED_START_PAST_STOP       612
#define IDS_CTRS_DUPL_PATH_NOT_ADDED    613
#define IDS_CTRS_DUPL_PATH_DELETED      614
#define IDS_CTRS_PDH_ERROR              615
#define IDS_PROV_NAME                   616
#define IDS_PROV_STATUS                 617
#define IDS_PROV_ENABLED                618
#define IDS_PROV_UNKNOWN                619
#define IDS_PROV_NO_PROVIDERS           620
#define IDS_SAMPLE_CMD_PATH             621
#define IDS_SAMPLE_CMD_MEAS_VAL         622
#define IDS_SAMPLE_CMD_LIMIT_VAL        623
#define IDS_DEFAULT_PATH_OBJ_CTR        624
#define IDS_SELECT_COUNTERS             625
#define IDS_FILE_ERR_NAMETOOLONG        626
#define IDS_FILE_ERR_NOFOLDERNAME       627
#define IDS_FILE_ERR_NOFILENAME         628
#define IDS_FILENAMETOOLONG             629
#define IDS_ERRMSG_SERVICE_ERROR        630
#define IDS_ERRMSG_INVALIDDWORD         631
#define IDS_ERRMSG_INVALIDDOUBLE        632
#define IDS_ERRMSG_SAMPLEINTTOOLARGE    633
#define IDS_ADD_COUNTERS                634
#define IDS_ADD_OBJECTS                 635
#define IDS_BAD_PASSWORD_MATCH          636
#define IDS_PASSWORD_TITLE              637
#define IDS_PASSWORD_SET                638
#define IDS_SQL_ERR_NOLOGSETNAME        639
#define IDS_SQL_ERR_NODSN               640
#define IDS_ALERT_DUPL_PATH             641
#define IDS_ERRMSG_PREWIN2000           642
#define IDS_ERRMSG_SETMAXSIZE           643

#define IDS_ALERT_CHECK_LIMITS          701
#define IDS_ACTION_ERR_NOLOGNAME        702
#define IDS_ACTION_ERR_NOCMDFILE        703
#define IDS_ACTION_ERR_NONETNAME        704
#define IDS_OVER                        705
#define IDS_UNDER                       706
#define IDS_ACTION_ERR_NOACTION         707
#define IDS_CREATE_NEW_ALERT            708
#define IDS_ALERT_LOG_TYPE              709
#define IDS_NO_COUNTERS                 710
#define IDS_LOG_START_MANUALLY          711
#define IDS_LOG_START_IMMED             712
#define IDS_LOG_START_SCHED             713
#define IDS_KERNEL_PROVIDERS_REQUIRED   714
#define IDS_APP_PROVIDERS_REQUIRED      715
#define IDS_ALERT_START_MANUALLY        716
#define IDS_ALERT_START_IMMED           717
#define IDS_ALERT_START_SCHED           718
#define IDS_SERVICE_NAME_ALERT          719
#define IDS_SERVICE_NAME_COUNTER        720
#define IDS_SERVICE_NAME_TRACE          721
#define IDS_SNAPINABOUT_DESCRIPTION     724 // 722, 723 obsolete, can be reused
#define IDS_ROOT_NODE_DESCRIPTION       725 
#define IDS_COUNTER_NODE_DESCRIPTION    726
#define IDS_TRACE_NODE_DESCRIPTION      727
#define IDS_ALERT_NODE_DESCRIPTION      728
#define IDS_ALERT_CHECK_LIMIT_VALUE     729

#define IDS_DEFAULT_CTRLOG_QUERY_NAME   731
#define IDS_DEFAULT_CTRLOG_CPU_PATH     732
#define IDS_DEFAULT_CTRLOG_MEMORY_PATH  733
#define IDS_DEFAULT_CTRLOG_DISK_PATH    734
#define IDS_DEFAULT_CTRLOG_COMMENT      735
#define IDS_MMC_DEFAULT_EXT_NAME        736
#define IDS_ROOT_COL_QUERY_NAME         737
#define IDS_ROOT_COL_COMMENT            738
#define IDS_ROOT_COL_LOG_TYPE           739
#define IDS_ROOT_COL_LOG_FILE_NAME      740
#define IDS_MAIN_COL_NODE_NAME          741
#define IDS_MAIN_COL_NODE_DESCRIPTION   742
#define IDS_EXTENSION_COL_TYPE          743
#define IDS_DEFAULT_CTRLOG_FILE_NAME    744
// Copy/Paste
#define IDS_HTML_OBJECT_CLASSID         800
#define IDS_HTML_OBJECT_HEADER          801
#define IDS_HTML_OBJECT_FOOTER          802
#define IDS_HTML_PARAM_TAG              803
#define IDS_HTML_VALUE_TAG              804
#define IDS_HTML_VALUE_EOL_TAG          805
#define IDS_HTML_PARAM_SEARCH_TAG       806
#define IDS_HTML_VALUE_SEARCH_TAG       807
#define IDS_HTML_BOL_SEARCH_TAG         808
#define IDS_HTML_EOL_SEARCH_TAG         809

// Save As
#define IDS_HTML_FILE                   810
#define IDS_HTML_EXTENSION              811
#define IDS_HTML_FILE_HEADER1           812
#define IDS_HTML_FILE_HEADER2           813
#define IDS_HTML_FILE_FOOTER            814
#define IDS_HTML_FILE_OVERWRITE         815

// Property/Parameter names for HTML files and registry
#define IDS_REG_FIRST_VALUE_NAME        816
#define IDS_REG_COMMENT                 816
#define IDS_REG_LOG_TYPE                817
#define IDS_REG_CURRENT_STATE           818
#define IDS_REG_LOG_FILE_MAX_SIZE       819
#define IDS_REG_LOG_FILE_BASE_NAME      820
#define IDS_REG_LOG_FILE_FOLDER         821
#define IDS_REG_LOG_FILE_SERIAL_NUMBER  822
#define IDS_REG_LOG_FILE_AUTO_FORMAT    823
#define IDS_REG_LOG_FILE_TYPE           824
#define IDS_REG_START_TIME              825
#define IDS_REG_STOP_TIME               826
#define IDS_REG_RESTART                 827
#define IDS_REG_LAST_MODIFIED           828
#define IDS_REG_COUNTER_LIST            829
#define IDS_REG_SAMPLE_INTERVAL         830
#define IDS_REG_EOF_COMMAND_FILE        831
#define IDS_REG_COMMAND_FILE            832
#define IDS_REG_NETWORK_NAME            833
#define IDS_REG_USER_TEXT               834
#define IDS_REG_PERF_LOG_NAME           835
#define IDS_REG_ACTION_FLAGS            836
#define IDS_REG_TRACE_BUFFER_SIZE       837
#define IDS_REG_TRACE_BUFFER_MIN_COUNT  838
#define IDS_REG_TRACE_BUFFER_MAX_COUNT  839
#define IDS_REG_TRACE_BUFFER_FLUSH_INT  840
#define IDS_REG_TRACE_FLAGS             841
#define IDS_REG_TRACE_PROVIDER_LIST     842
#define IDS_REG_ALERT_THRESHOLD         843
#define IDS_REG_ALERT_OVER_UNDER        844
#define IDS_REG_TRACE_PROVIDER_COUNT    845
#define IDS_REG_TRACE_PROVIDER_GUID     846
#define IDS_DEFAULT_LOG_FILE_FOLDER     847     // Not a query config value name.  Can be localized. 
#define IDS_REG_COLLECTION_NAME         848
#define IDS_REG_DATA_STORE_ATTRIBUTES   849
#define IDS_REG_REALTIME_DATASOURCE     850
#define IDS_REG_SQL_LOG_BASE_NAME       851
#define IDS_REG_COMMENT_INDIRECT        852
#define IDS_REG_LOG_FILE_BASE_NAME_IND  853
#define IDS_REG_USER_TEXT_INDIRECT      854

// Values stored in registry but not in HTML
#define IDS_REG_EXECUTE_ONLY            890

#define IDS_HTML_FIRST_VALUE_NAME       900
#define IDS_HTML_COMMENT                900
#define IDS_HTML_LOG_TYPE               901
#define IDS_HTML_CURRENT_STATE          902
#define IDS_HTML_LOG_FILE_MAX_SIZE      903
#define IDS_HTML_LOG_FILE_BASE_NAME     904
#define IDS_HTML_LOG_FILE_FOLDER        905
#define IDS_HTML_LOG_FILE_SERIAL_NUMBER 906
#define IDS_HTML_LOG_FILE_AUTO_FORMAT   907
#define IDS_HTML_LOG_FILE_TYPE          908
#define IDS_HTML_EOF_COMMAND_FILE       909
#define IDS_HTML_COMMAND_FILE           910
#define IDS_HTML_NETWORK_NAME           911
#define IDS_HTML_USER_TEXT              912
#define IDS_HTML_PERF_LOG_NAME          913
#define IDS_HTML_ACTION_FLAGS           914
#define IDS_HTML_RESTART                915     // Obsolete.
#define IDS_HTML_TRACE_BUFFER_SIZE      916
#define IDS_HTML_TRACE_BUFFER_MIN_COUNT 917
#define IDS_HTML_TRACE_BUFFER_MAX_COUNT 918
#define IDS_HTML_TRACE_BUFFER_FLUSH_INT 919
#define IDS_HTML_TRACE_FLAGS            920
#define IDS_HTML_SYSMON_LOGFILENAME     921               
#define IDS_HTML_SYSMON_COUNTERCOUNT    922
#define IDS_HTML_SYSMON_SAMPLECOUNT     923
#define IDS_HTML_SYSMON_UPDATEINTERVAL  924
#define IDS_HTML_SYSMON_COUNTERPATH     925
#define IDS_HTML_RESTART_MODE           926                 
#define IDS_HTML_SAMPLE_INT_UNIT_TYPE   927                   
#define IDS_HTML_SAMPLE_INT_VALUE       928                   
#define IDS_HTML_START_MODE             929                   
#define IDS_HTML_START_AT_TIME          930                  
#define IDS_HTML_STOP_MODE              931                   
#define IDS_HTML_STOP_AT_TIME           932                   
#define IDS_HTML_STOP_AFTER_UNIT_TYPE   933                   
#define IDS_HTML_STOP_AFTER_VALUE       934                   
#define IDS_HTML_ALERT_THRESHOLD        935
#define IDS_HTML_ALERT_OVER_UNDER       936
#define IDS_HTML_TRACE_PROVIDER_COUNT   937
#define IDS_HTML_TRACE_PROVIDER_GUID    938
#define IDS_HTML_LOG_NAME               939
#define IDS_HTML_ALERT_NAME             940
#define IDS_HTML_SYSMON_VERSION         941
#define IDS_HTML_DATA_STORE_ATTRIBUTES  942
#define IDS_HTML_REALTIME_DATASOURCE    943
#define IDS_HTML_SQL_LOG_BASE_NAME      944

#define IDS_ERRMSG_COUNTER_LOG          1042
#define IDS_ERRMSG_ALERT_LOG            1043
#define IDS_ERRMSG_TRACE_LOG            1044
#define IDS_ERRMSG_SMCTRL_LOG           1045
#define IDS_COUNTER_LOG                 1046
#define IDS_ALERT_LOG			        1047
#define IDS_SMCTRL_LOG                  1048
#define IDS_ERRMSG_INVALIDCHAR          1049
#define IDS_ERRMSG_INVALID_DSN_NAME     1050

// Command line arguments
#define IDS_CMDARG_SYSMONLOG_SETTINGS   990
#define IDS_CMDARG_SYSMONLOG_WMI        991

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2001
#define _APS_NEXT_COMMAND_VALUE         40010
#define _APS_NEXT_CONTROL_VALUE         2016
#define _APS_NEXT_SYMED_VALUE           2000
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smlogqry.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smlogqry.h

Abstract:

    Class definitions for the CSmLogQuery base class. This object 
    is used to represent performance data log queries (a.k.a.
    sysmon log queries).

--*/

#ifndef _CLASS_SMLOGQRY_
#define _CLASS_SMLOGQRY_

#include "common.h"

// Data shared between property pages before OnApply is executed.
#define PASSWORD_CLEAN      0
#define PASSWORD_SET        1
#define PASSWORD_DIRTY      2

typedef struct _SLQ_PROP_PAGE_SHARED {
    DWORD   dwMaxFileSize;  // in units determined by dwFileSizeUnits - Set by files page
    DWORD   dwLogFileType;  // Set by files page
    SLQ_TIME_INFO   stiStartTime;   // Set by schedule page
    SLQ_TIME_INFO   stiStopTime;    // Set by schedule page.  Auto mode set by schedule and file pages.
    SLQ_TIME_INFO   stiSampleTime;  // Set by counters and alerts general page.  
    CString strFileBaseName;// Set by files page
    CString strFolderName;  // Set by files page
    CString strSqlName;     // Set by files page
    int     dwSuffix;       // Set by files page
    DWORD   dwSerialNumber; // Set by files page
} SLQ_PROP_PAGE_SHARED, *PSLQ_PROP_PAGE_SHARED;

class CSmLogService;
class CSmCounterLogQuery;
class CSmTraceLogQuery;
class CSmAlertQuery;
class CSmPropertyPage;

class CSmLogQuery
{
    // constructor/destructor
    public:
                CSmLogQuery( CSmLogService* );
        virtual ~CSmLogQuery( void );

    // public methods
    public:
        virtual DWORD   Open ( const CString& rstrName, HKEY hKeyQuery, BOOL bReadOnly );
        virtual DWORD   Close ( void );

                DWORD   UpdateService( BOOL& rbRegistryUpdated );
                DWORD   UpdateServiceSchedule( BOOL& rbRegistryUpdated );
        
                DWORD   ManualStart( void );
                DWORD   ManualStop( void );
                DWORD   SaveAs( const CString& );

        virtual DWORD   SyncSerialNumberWithRegistry( void );
        virtual DWORD   SyncWithRegistry( void );

                HKEY    GetQueryKey( void );
                CSmLogService* GetLogService ( void );
                DWORD   GetMachineDisplayName ( CString& );

        virtual BOOL    GetLogTime(PSLQ_TIME_INFO pTimeInfo, DWORD dwFlags);
        virtual BOOL    SetLogTime(PSLQ_TIME_INFO pTimeInfo, const DWORD dwFlags);
        virtual BOOL    GetDefaultLogTime(SLQ_TIME_INFO& rTimeInfo, DWORD dwFlags);

        virtual DWORD   GetLogType( void );

        virtual const   CString&    GetLogFileType ( void );
        virtual         void        GetLogFileType ( DWORD& rdwFileType );
        virtual         BOOL        SetLogFileType ( const DWORD dwType );
                        void  GetDataStoreAppendMode(DWORD &rdwAppend);
                        void  SetDataStoreAppendMode(DWORD dwAppend);

        virtual const   CString&    GetLogFileName ( BOOL bLatestRunning = FALSE );    // 2000.1 GetFileName->GetLogFileName
        virtual         DWORD       GetLogFileName ( CString& );         
                        DWORD       SetLogFileName ( const CString& rstrFileName );
                        DWORD       SetLogFileNameIndirect ( const CString& rstrFileName );

        virtual const   CString&    GetSqlName ( void );    
        virtual         DWORD       GetSqlName ( CString& );         
                        DWORD       SetSqlName ( const CString& rstrSqlName );

                        DWORD       GetFileNameParts ( CString& rstrFolder, CString& rstrName );
                        DWORD       SetFileNameParts (
                                        const CString& rstrFolder, 
                                        const CString& rstrName );

                        DWORD       GetFileNameAutoFormat ( void );
                        BOOL        SetFileNameAutoFormat ( const DWORD );

                        DWORD       GetFileSerialNumber( void );
                        BOOL        SetFileSerialNumber ( const DWORD );

                const   CString&    GetLogName ( void );
                        DWORD       GetLogName ( CString& );
                        DWORD       SetLogName ( const CString& rstrLogName );

                const   CString&    GetLogKeyName ( void );
                        DWORD       GetLogKeyName ( CString& );
                        DWORD       SetLogKeyName ( const CString& rstrLogName );

                const   CString&    GetLogComment ( void );
                        DWORD       GetLogComment ( CString& );
                        DWORD       SetLogComment (const CString& rstrComment);
                        DWORD       SetLogCommentIndirect (const CString& rstrComment);

                        DWORD       GetMaxSize ( void );
                        BOOL        SetMaxSize ( const DWORD dwMaxSize );

                        DWORD       GetDataStoreSizeUnits ( void ){ return mr_dwFileSizeUnits; };

                        DWORD       GetEofCommand ( CString& );
                        DWORD       SetEofCommand ( const CString& rstrCmdString);
        
                        DWORD       GetState ( void );
                        BOOL        SetState ( const DWORD dwNewState );
                
                        void        SetNew ( const BOOL bNew ) { m_bIsNew = bNew; };

                        BOOL    IsRunning( void );
                        BOOL    IsAutoStart( void );
                        BOOL    IsAutoRestart( void );
                        BOOL    IsFirstModification ( void );
                        BOOL    IsReadOnly ( void ) { return m_bReadOnly; };
                        BOOL    IsExecuteOnly( void ) { return m_bExecuteOnly; };
                        BOOL    IsModifiable( void ) { return ( !IsExecuteOnly() && !IsReadOnly() ); };
                        DWORD   UpdateExecuteOnly ( void );

                        BOOL    GetPropPageSharedData ( PSLQ_PROP_PAGE_SHARED );
                        BOOL    SetPropPageSharedData ( PSLQ_PROP_PAGE_SHARED );
                        void    SyncPropPageSharedData ( void );
                        void    UpdatePropPageSharedData ( void );

                        CWnd*   GetActivePropertySheet ();
                        CPropertySheet*   GetInitialPropertySheet ();
                        void    SetInitialPropertySheet ( CPropertySheet* );
                        void    SetActivePropertyPage ( CSmPropertyPage* );
                
        virtual CSmCounterLogQuery* CastToCounterLogQuery( void ) { return NULL; };
        virtual CSmTraceLogQuery*   CastToTraceLogQuery( void ) { return NULL; };
        virtual CSmAlertQuery*      CastToAlertQuery( void ) { return NULL; };

        // Property bag persistence

        static HRESULT StringFromPropertyBag (
                    IPropertyBag* pIPropBag,
                    IErrorLog*  pIErrorLog,
                    UINT uiPropName,
                    const CString& rstrDefault,
                    LPWSTR *pszBuffer, 
                    LPDWORD pdwLength );

        static HRESULT DwordFromPropertyBag (
                    IPropertyBag* pIPropBag,
                    IErrorLog*  pIErrorLog,
                    UINT uiPropName,
                    DWORD  dwDefault,
                    DWORD& rdwData );

        virtual HRESULT LoadFromPropertyBag ( IPropertyBag*, IErrorLog* );

        // Registry persistence
        
        static LONG ReadRegistryStringValue (
                        HKEY hKey, 
                        LPCWSTR szValueName,
                        LPCWSTR szNonLocValueName,
                        LPCWSTR szDefault, 
                        LPWSTR *pszBuffer, 
                        LPDWORD pdwLength );
        

        static DWORD SmNoLocReadRegIndStrVal (
                    HKEY hKey, 
                    UINT uiValueName,
                    LPCWSTR szDefault, 
                    LPWSTR* pszBuffer, 
                    UINT*   puiLength );

        static LONG ReadRegistryDwordValue (
                        HKEY hKey, 
                        UINT uiValueName,
                        DWORD dwDefault, 
                        LPDWORD  pdwValue ); 

        static LPCWSTR GetNonLocRegValueName ( UINT uiValueName );
        static LPCWSTR GetNonLocHtmlPropName ( UINT uiValueName );

        // Public members

        static const    CString cstrEmpty;

        DWORD   m_fDirtyPassword;
        CString m_strUser;
        CString m_strPassword;

    // protected methods
    protected:
        virtual DWORD   UpdateRegistry();

		virtual HRESULT SaveToPropertyBag   ( IPropertyBag*, BOOL fSaveAllProps );

        //
        // Registry persistence
        //
        //
        // Note: Win2k, XP, and XPSP1 were shipped with registry value names as resources.
        // In some languages, these strings were localized.  This causes problem when using MUI
        // to switch languages between systems.  for .Net, read value using the non-localized 
        // value name.  If the value is not found, retry with the possibly localized name.
        //
        // When writing the value to the registry, use the nonlocalized value name.

        LONG    ReadRegistryStringValue (
                    HKEY hKey, 
                    UINT uiValueName,
                    LPCWSTR szDefault, 
                    LPWSTR *pszBuffer, 
                    LPDWORD pdwLength );
        
        LONG    WriteRegistryStringValue (
                    HKEY    hKey, 
                    UINT    uiValueName,
                    DWORD   dwType,     
                    LPCWSTR pszBuffer,
                    LPDWORD pdwLength );

        LONG    WriteRegistryDwordValue (
                    HKEY    hKey,
                    UINT    uiValueName,
                    LPDWORD pdwValue,
                    DWORD   dwType=REG_DWORD);     // Also supports REG_BINARY

        LONG    ReadRegistrySlqTime (
                    HKEY    hKey,
                    UINT    uiValueName,
                    PSLQ_TIME_INFO pSlqDefault,
                    PSLQ_TIME_INFO pSlqValue );

        LONG    WriteRegistrySlqTime (
                    HKEY    hKey,
                    UINT    uiValueName,
                    PSLQ_TIME_INFO    pSlqTime );

        // Property bag persistence

        static HRESULT StringFromPropertyBag (
                    IPropertyBag* pIPropBag,
                    IErrorLog*  pIErrorLog,
                    const CString& rstrPropName,
                    const CString& rstrNonLocPropName,
                    const CString& rstrDefault,
                    LPWSTR *pszBuffer, 
                    LPDWORD pdwLength );

        HRESULT StringToPropertyBag (
                    IPropertyBag* pIPropBag, 
                    UINT uiPropName,
                    const CString& rstrData );

        HRESULT StringToPropertyBag (
                    IPropertyBag* pIPropBag, 
                    const CString& rstrNonLocPropName,
                    const CString& rstrData );

        static HRESULT DwordFromPropertyBag (
                    IPropertyBag* pIPropBag,
                    IErrorLog*  pIErrorLog,
                    const CString& rstrNonLocPropName,
                    const CString& rstrPropName,
                    DWORD  dwDefault,
                    DWORD& rdwData );

        HRESULT DwordToPropertyBag (
                    IPropertyBag* pPropBag, 
                    UINT uiPropName,
                    DWORD dwData );

        HRESULT DwordToPropertyBag (
                    IPropertyBag* pPropBag, 
                    const CString& rstrNonLocPropName,
                    DWORD dwData );

        HRESULT DoubleFromPropertyBag (
                    IPropertyBag* pIPropBag,
                    IErrorLog*  pIErrorLog,
                    UINT uiPropName,
                    DOUBLE  dDefault,
                    DOUBLE& rdData );

        HRESULT DoubleFromPropertyBag (
                    IPropertyBag* pIPropBag,
                    IErrorLog*  pIErrorLog,
                    const CString& rstrPropName,
                    const CString& rstrNonLocPropName,
                    DOUBLE  dDefault,
                    DOUBLE& rdData );

        HRESULT DoubleToPropertyBag (
                    IPropertyBag* pPropBag, 
                    UINT uiPropName,
                    DOUBLE dData );

        HRESULT DoubleToPropertyBag (
                    IPropertyBag* pPropBag, 
                    const CString& rstrNonLocPropName,
                    DOUBLE dData );

        HRESULT FloatFromPropertyBag (
                    IPropertyBag* pIPropBag,
                    IErrorLog*  pIErrorLog,
                    UINT uiPropName,
                    FLOAT  fDefault,
                    FLOAT& rfData );

        HRESULT FloatFromPropertyBag (
                    IPropertyBag* pIPropBag,
                    IErrorLog*  pIErrorLog,
                    const CString& rstrPropName,
                    const CString& rstrNonLocPropName,
                    FLOAT   fDefault,
                    FLOAT& rfData );

        HRESULT FloatToPropertyBag (
                    IPropertyBag* pPropBag, 
                    UINT uiPropName,
                    FLOAT fData );

        HRESULT FloatToPropertyBag (
                    IPropertyBag* pPropBag, 
                    const CString& rstrNonLocPropName,
                    FLOAT fData );

        HRESULT LLTimeFromPropertyBag (
                    IPropertyBag* pIPropBag,
                    IErrorLog*  pIErrorLog,
                    UINT uiPropName,
                    LONGLONG&  rllDefault,
                    LONGLONG& rllData );

        HRESULT LLTimeToPropertyBag (
                    IPropertyBag* pIPropBag, 
                    UINT uiPropName,
                    LONGLONG& rllData );

        HRESULT SlqTimeFromPropertyBag (
                    IPropertyBag* pIPropBag,
                    IErrorLog*  pIErrorLog,
                    DWORD       dwFlags,
                    PSLQ_TIME_INFO pSlqDefault,
                    PSLQ_TIME_INFO pSlqData );

        HRESULT SlqTimeToPropertyBag (
                    IPropertyBag* pPropBag, 
                    DWORD dwFlags,
                    PSLQ_TIME_INFO pSlqData );



    // protected member variables
    protected:
        CString         m_strName;
        CSmLogService*  m_pLogService;        
        
        HKEY    m_hKeyQuery;
        BOOL    m_bReadOnly;
        BOOL    m_bExecuteOnly;
        CString m_strFileName;

        // Registry Values
        // Current state is private to avoid extra service query
        DWORD   mr_dwCurrentState;
        // *** make time protected members private, access via Get, SetLogTime
        DWORD           mr_dwAutoRestartMode;
        SLQ_TIME_INFO   mr_stiSampleInterval;

    private:
        
        HRESULT CopyToBuffer ( LPWSTR& rpszData, DWORD& rdwBufferSize );
        DWORD   UpdateRegistryScheduleValues ( void );
        DWORD   UpdateRegistryLastModified ( void );

        BOOL LLTimeToVariantDate (LONGLONG llTime, DATE *pDate);
        BOOL VariantDateToLLTime (DATE Date, LONGLONG *pllTime);        

        void InitDataStoreAttributesDefault ( const DWORD dwRegLogFileType, DWORD&  rdwDefault );
        void ProcessLoadedDataStoreAttributes ( DWORD dwDataStoreAttributes );

        BOOL    m_bIsModified;
        BOOL    m_bIsNew;
        DWORD   mr_dwRealTimeQuery;

        CString m_strLogFileType;
        // Registry Values
        CString mr_strLogKeyName;
        CString mr_strComment;
        CString mr_strCommentIndirect;
        DWORD   mr_dwMaxSize; // in size determined by mr_dwFileSizeUnits, -1 = grow to disk full
        DWORD   mr_dwFileSizeUnits; 
        DWORD   mr_dwAppendMode; 
        CString mr_strBaseFileName;
        CString mr_strBaseFileNameIndirect;
        CString mr_strSqlName;
        CString mr_strDefaultDirectory;
        DWORD   mr_dwLogAutoFormat;
        DWORD   mr_dwCurrentSerialNumber;
        DWORD   mr_dwLogFileType;
        CString mr_strEofCmdFile;
        SLQ_TIME_INFO   mr_stiStart;
        SLQ_TIME_INFO   mr_stiStop;

        SLQ_PROP_PAGE_SHARED  m_PropData;
        CSmPropertyPage* m_pActivePropPage;
        CPropertySheet* m_pInitialPropertySheet;
};

typedef CSmLogQuery   SLQUERY;
typedef CSmLogQuery*  PSLQUERY;


#endif //_CLASS_SMLOGQRY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smlogqry.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smlogqry.cpp

Abstract:

    Implementation of the CSmLogQuery base class. This object 
    is used to represent performance data log queries (a.k.a.
    sysmon log queries).

--*/

#include "Stdafx.h"
#include <pdh.h>            // for MIN_TIME_VALUE, MAX_TIME_VALUE
#include <pdhmsg.h>         // for PDH status values
#include <pdhp.h>           // for PLA methods
#include <strsafe.h>
#include "ipropbag.h"
#include "smlogs.h"
#include "smcfgmsg.h"
#include "smproppg.h"
#include "strnoloc.h"
#include "smlogqry.h"

USE_HANDLE_MACROS("SMLOGCFG(smlogqry.cpp)");

#define  DEFAULT_LOG_FILE_SERIAL_NUMBER ((DWORD)0x00000001)
#define  DEFAULT_LOG_FILE_MAX_SIZE      ((DWORD)-1)
#define  DEFAULT_CTR_LOG_FILE_TYPE      (SLF_BIN_FILE)
#define  DEFAULT_TRACE_LOG_FILE_TYPE    (SLF_SEQ_TRACE_FILE)
#define  DEFAULT_LOG_FILE_AUTO_FORMAT   SLF_NAME_NNNNNN
#define  DEFAULT_CURRENT_STATE          SLQ_QUERY_STOPPED
#define  DEFAULT_EXECUTE_ONLY           0
#define  DEFAULT_EOF_COMMAND_FILE       L""
#define  DEFAULT_RESTART_VALUE         ((DWORD)0)

#define  DEFAULT_COMMENT            L""
#define  DEFAULT_SQL_LOG_BASE_NAME  L""

#pragma warning ( disable : 4201)

typedef union {                        
    struct {
        SHORT      iMajor;     
        SHORT      iMinor;     
    }; 
    DWORD          dwVersion;      
} SMONCTRL_VERSION_DATA;

#pragma warning ( default : 4201 )


#define SMONCTRL_MAJ_VERSION    3
#define SMONCTRL_MIN_VERSION    3

typedef struct _REG_HTML_VALUE_NAME_MAP {
    UINT    iID;
    LPCWSTR szNonLocValueName;
} REG_HTML_VALUE_NAME_MAP, *PREG_HTML_VALUE_NAME_MAP;

//
// NOTE:  Unless otherwise specified, all registry Resource Id values are contiguous
// beginning with 816, so they can be used as indexes into the map.
//
const REG_HTML_VALUE_NAME_MAP RegValueNameMap[] = 
{
    { IDS_REG_COMMENT                 , CGlobalString::m_cszRegComment },                         
    { IDS_REG_LOG_TYPE                , CGlobalString::m_cszRegLogType },
    { IDS_REG_CURRENT_STATE           , CGlobalString::m_cszRegCurrentState },
    { IDS_REG_LOG_FILE_MAX_SIZE       , CGlobalString::m_cszRegLogFileMaxSize },
    { IDS_REG_LOG_FILE_BASE_NAME      , CGlobalString::m_cszRegLogFileBaseName },      
    { IDS_REG_LOG_FILE_FOLDER         , CGlobalString::m_cszRegLogFileFolder },         
    { IDS_REG_LOG_FILE_SERIAL_NUMBER  , CGlobalString::m_cszRegLogFileSerialNumber },  
    { IDS_REG_LOG_FILE_AUTO_FORMAT    , CGlobalString::m_cszRegLogFileAutoFormat },    
    { IDS_REG_LOG_FILE_TYPE           , CGlobalString::m_cszRegLogFileType },         
    { IDS_REG_START_TIME              , CGlobalString::m_cszRegStartTime },            
    { IDS_REG_STOP_TIME               , CGlobalString::m_cszRegStopTime },                 
    { IDS_REG_RESTART                 , CGlobalString::m_cszRegRestart },              
    { IDS_REG_LAST_MODIFIED           , CGlobalString::m_cszRegLastModified },         
    { IDS_REG_COUNTER_LIST            , CGlobalString::m_cszRegCounterList },          
    { IDS_REG_SAMPLE_INTERVAL         , CGlobalString::m_cszRegSampleInterval },       
    { IDS_REG_EOF_COMMAND_FILE        , CGlobalString::m_cszRegEofCommandFile },       
    { IDS_REG_COMMAND_FILE            , CGlobalString::m_cszRegCommandFile },          
    { IDS_REG_NETWORK_NAME            , CGlobalString::m_cszRegNetworkName },  
    { IDS_REG_USER_TEXT               , CGlobalString::m_cszRegUserText },   
    { IDS_REG_PERF_LOG_NAME           , CGlobalString::m_cszRegPerfLogName },       
    { IDS_REG_ACTION_FLAGS            , CGlobalString::m_cszRegActionFlags },           
    { IDS_REG_TRACE_BUFFER_SIZE       , CGlobalString::m_cszRegTraceBufferSize },      
    { IDS_REG_TRACE_BUFFER_MIN_COUNT  , CGlobalString::m_cszRegTraceBufferMinCount },  
    { IDS_REG_TRACE_BUFFER_MAX_COUNT  , CGlobalString::m_cszRegTraceBufferMaxCount },            
    { IDS_REG_TRACE_BUFFER_FLUSH_INT  , CGlobalString::m_cszRegTraceBufferFlushInterval },         
    { IDS_REG_TRACE_FLAGS             , CGlobalString::m_cszRegTraceFlags },                        
    { IDS_REG_TRACE_PROVIDER_LIST     , CGlobalString::m_cszRegTraceProviderList },     
    { IDS_REG_ALERT_THRESHOLD         , CGlobalString::m_cszRegAlertThreshold },           
    { IDS_REG_ALERT_OVER_UNDER        , CGlobalString::m_cszRegAlertOverUnder },
    { IDS_REG_TRACE_PROVIDER_COUNT    , CGlobalString::m_cszRegTraceProviderCount },
    { IDS_REG_TRACE_PROVIDER_GUID     , CGlobalString::m_cszRegTraceProviderGuid },
    { IDS_DEFAULT_LOG_FILE_FOLDER     , CGlobalString::m_cszRegDefaultLogFileFolder },  // In registry, but not part of query config.
    { IDS_REG_COLLECTION_NAME         , CGlobalString::m_cszRegCollectionName },
    { IDS_REG_DATA_STORE_ATTRIBUTES   , CGlobalString::m_cszRegDataStoreAttributes },         
    { IDS_REG_REALTIME_DATASOURCE     , CGlobalString::m_cszRegRealTimeDataSource },    
    { IDS_REG_SQL_LOG_BASE_NAME       , CGlobalString::m_cszRegSqlLogBaseName },   
    { IDS_REG_COMMENT_INDIRECT        , CGlobalString::m_cszRegCommentIndirect },      
    { IDS_REG_LOG_FILE_BASE_NAME_IND  , CGlobalString::m_cszRegLogFileBaseNameInd },       
    { IDS_REG_USER_TEXT_INDIRECT      , CGlobalString::m_cszRegUserTextIndirect },  
    // NOTE:  IDS_REG_EXECUTE_ONLY is 890, so cannot be indexed.
    { IDS_REG_EXECUTE_ONLY            , CGlobalString::m_cszRegExecuteOnly } 
};    
    
static const DWORD dwRegValueNameMapEntries = sizeof(RegValueNameMap)/sizeof(RegValueNameMap[0]);

//
// NOTE:  Unless otherwise specified, all Html Resource Id values are contiguous
// beginning with 900, so they can be used as indexes into the map.
//
const REG_HTML_VALUE_NAME_MAP HtmlPropNameMap[] = 
{
    { IDS_HTML_COMMENT                , CGlobalString::m_cszHtmlComment },
    { IDS_HTML_LOG_TYPE               , CGlobalString::m_cszHtmlLogType },
    { IDS_HTML_CURRENT_STATE          , CGlobalString::m_cszHtmlCurrentState },
    { IDS_HTML_LOG_FILE_MAX_SIZE      , CGlobalString::m_cszHtmlLogFileMaxSize },
    { IDS_HTML_LOG_FILE_BASE_NAME     , CGlobalString::m_cszHtmlLogFileBaseName },
    { IDS_HTML_LOG_FILE_FOLDER        , CGlobalString::m_cszHtmlLogFileFolder },
    { IDS_HTML_LOG_FILE_SERIAL_NUMBER , CGlobalString::m_cszHtmlLogFileSerialNumber },
    { IDS_HTML_LOG_FILE_AUTO_FORMAT   , CGlobalString::m_cszHtmlLogFileAutoFormat },
    { IDS_HTML_LOG_FILE_TYPE          , CGlobalString::m_cszHtmlLogFileType },
    { IDS_HTML_EOF_COMMAND_FILE       , CGlobalString::m_cszHtmlEOFCommandFile },
    { IDS_HTML_COMMAND_FILE           , CGlobalString::m_cszHtmlCommandFile },
    { IDS_HTML_NETWORK_NAME           , CGlobalString::m_cszHtmlNetworkName },
    { IDS_HTML_USER_TEXT              , CGlobalString::m_cszHtmlUserText },
    { IDS_HTML_PERF_LOG_NAME          , CGlobalString::m_cszHtmlPerfLogName }, 
    { IDS_HTML_ACTION_FLAGS           , CGlobalString::m_cszHtmlActionFlags }, 
    { IDS_HTML_RESTART                , L'\0' },                                      // Obsolete
    { IDS_HTML_TRACE_BUFFER_SIZE      , CGlobalString::m_cszHtmlTraceBufferSize }, 
    { IDS_HTML_TRACE_BUFFER_MIN_COUNT , CGlobalString::m_cszHtmlTraceBufferMinCount }, 
    { IDS_HTML_TRACE_BUFFER_MAX_COUNT , CGlobalString::m_cszHtmlTraceBufferMaxCount }, 
    { IDS_HTML_TRACE_BUFFER_FLUSH_INT , CGlobalString::m_cszHtmlTraceBufferFlushInterval }, 
    { IDS_HTML_TRACE_FLAGS            , CGlobalString::m_cszHtmlTraceFlags }, 
    { IDS_HTML_SYSMON_LOGFILENAME     , CGlobalString::m_cszHtmlLogFileName }, 
    { IDS_HTML_SYSMON_COUNTERCOUNT    , CGlobalString::m_cszHtmlCounterCount }, 
    { IDS_HTML_SYSMON_SAMPLECOUNT     , CGlobalString::m_cszHtmlSampleCount }, 
    { IDS_HTML_SYSMON_UPDATEINTERVAL  , CGlobalString::m_cszHtmlUpdateInterval }, 
    { IDS_HTML_SYSMON_COUNTERPATH     , CGlobalString::m_cszHtmlCounterPath }, 
    { IDS_HTML_RESTART_MODE           , CGlobalString::m_cszHtmlRestartMode }, 
    { IDS_HTML_SAMPLE_INT_UNIT_TYPE   , CGlobalString::m_cszHtmlSampleIntervalUnitType }, 
    { IDS_HTML_SAMPLE_INT_VALUE       , CGlobalString::m_cszHtmlSampleIntervalValue },      
    { IDS_HTML_START_MODE             , CGlobalString::m_cszHtmlStartMode },   
    { IDS_HTML_START_AT_TIME          , CGlobalString::m_cszHtmlStartAtTime },  
    { IDS_HTML_STOP_MODE              , CGlobalString::m_cszHtmlStopMode },   
    { IDS_HTML_STOP_AT_TIME           , CGlobalString::m_cszHtmlStopAtTime },   
    { IDS_HTML_STOP_AFTER_UNIT_TYPE   , CGlobalString::m_cszHtmlStopAfterUnitType },   
    { IDS_HTML_STOP_AFTER_VALUE       , CGlobalString::m_cszHtmlStopAfterValue },       
    { IDS_HTML_ALERT_THRESHOLD        , CGlobalString::m_cszHtmlCounterAlertThreshold }, 
    { IDS_HTML_ALERT_OVER_UNDER       , CGlobalString::m_cszHtmlCounterAlertOverUnder }, 
    { IDS_HTML_TRACE_PROVIDER_COUNT   , CGlobalString::m_cszHtmlTraceProviderCount }, 
    { IDS_HTML_TRACE_PROVIDER_GUID    , CGlobalString::m_cszHtmlTraceProviderGuid }, 
    { IDS_HTML_LOG_NAME               , CGlobalString::m_cszHtmlLogName },                   
    { IDS_HTML_ALERT_NAME             , CGlobalString::m_cszHtmlAlertName }, 
    { IDS_HTML_SYSMON_VERSION         , CGlobalString::m_cszHtml_Version }, 
    { IDS_HTML_DATA_STORE_ATTRIBUTES  , CGlobalString::m_cszHtmlDataStoreAttributes }, 
    { IDS_HTML_REALTIME_DATASOURCE    , CGlobalString::m_cszHtmlRealTimeDataSource }, 
    { IDS_HTML_SQL_LOG_BASE_NAME      , CGlobalString::m_cszHtmlSqlLogBaseName } 
};
    
static const DWORD dwHtmlPropNameMapEntries = sizeof(HtmlPropNameMap)/sizeof(HtmlPropNameMap[0]);

DWORD   g_dwRealTimeQuery = DATA_SOURCE_REGISTRY;
const   CString CSmLogQuery::cstrEmpty;

//
//  Constructor
CSmLogQuery::CSmLogQuery( CSmLogService* pLogService )
:   m_pLogService ( pLogService ),
    m_bReadOnly ( FALSE ),
    m_bIsModified ( FALSE ),
    m_bIsNew ( FALSE ),
    m_bExecuteOnly ( FALSE ),
    m_pActivePropPage ( NULL ),
    mr_dwCurrentState ( SLQ_QUERY_STOPPED ),
    mr_dwMaxSize ( 0 ),
    mr_dwFileSizeUnits ( 0 ),
    mr_dwAppendMode ( 0 ),
    mr_dwLogAutoFormat ( 0 ),
    mr_dwLogFileType ( 0 ), 
    m_pInitialPropertySheet ( NULL )
{
    // initialize member variables
    memset (&mr_stiStart, 0, sizeof(mr_stiStart));
    memset (&mr_stiStop, 0, sizeof(mr_stiStop));
    memset (&m_PropData.stiSampleTime, 0, sizeof(m_PropData.stiSampleTime));
    m_PropData.dwMaxFileSize = 0;
    m_PropData.dwLogFileType = 0;
    m_PropData.dwSuffix = 0;
    m_PropData.dwSerialNumber = 0;
    mr_dwRealTimeQuery = g_dwRealTimeQuery;
    m_fDirtyPassword = PASSWORD_CLEAN;

    // All CString variables are empty on construction

    return;
}

//
//  Destructor
CSmLogQuery::~CSmLogQuery()
{
    // make sure Close method was called first!
    ASSERT ( NULL == m_hKeyQuery );
    ASSERT ( m_strName.IsEmpty() );
    ASSERT ( mr_strComment.IsEmpty() );
    ASSERT ( mr_strCommentIndirect.IsEmpty() );
    ASSERT ( mr_strBaseFileName.IsEmpty() );
    ASSERT ( mr_strBaseFileNameIndirect.IsEmpty() );
    ASSERT ( mr_strSqlName.IsEmpty() );
    ASSERT ( mr_strDefaultDirectory.IsEmpty() );
    return;
}
//
//  helper functions
//
LONG
CSmLogQuery::WriteRegistryStringValue (
    HKEY    hKey,
    UINT    uiValueName,
    DWORD   dwType,
    LPCWSTR pszBuffer,
    LPDWORD pdwBufSize
)
//  writes the contents of pszBuffer to szValue under hKey
{
    LONG    dwStatus = ERROR_SUCCESS;
    DWORD   dwLclSize;
    CONST BYTE *pLclBuffer = NULL;

    ResourceStateManager   rsm;

    if ( NULL != hKey ) {

        ASSERT ((dwType == REG_SZ) || 
                (dwType == REG_MULTI_SZ) ||
                (dwType == REG_EXPAND_SZ));

        if ( NULL == pszBuffer ) {
            // substitute an empty string
            pLclBuffer = (CONST BYTE *)L"\0";
            dwLclSize = sizeof(WCHAR);
        } else {
            // use args passed in
            pLclBuffer = (CONST BYTE *)pszBuffer;

            if ( NULL != pdwBufSize ) {
                if( 0 == *pdwBufSize ){
                    dwLclSize = lstrlen( pszBuffer );
                    if ( 0 < dwLclSize ) {
                        dwLclSize *= sizeof(WCHAR);
                    } else {
                        dwLclSize = sizeof(WCHAR);
                    }
                } else {
                    dwLclSize = *pdwBufSize;
                }
            } else {
                dwLclSize = lstrlen( pszBuffer );
                dwLclSize *= sizeof(WCHAR);
            }
        }

        dwStatus = RegSetValueEx (
            hKey, 
            GetNonLocRegValueName ( uiValueName ), 
            0L,
            dwType,
            (CONST BYTE *)pLclBuffer,
            dwLclSize); 
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}

LONG
CSmLogQuery::WriteRegistryDwordValue (
    HKEY     hKey,
    UINT     uiValueName,
    LPDWORD  pdwValue,
    DWORD    dwType   
)
{
    LONG    dwStatus = ERROR_SUCCESS;
    DWORD   dwSize = sizeof(DWORD);
    ResourceStateManager   rsm;

    if ( NULL != pdwValue && NULL != hKey ) {

        ASSERT ((dwType == REG_DWORD) || 
                (dwType == REG_BINARY));

        dwStatus = RegSetValueEx (
            hKey, 
            GetNonLocRegValueName ( uiValueName ), 
            0L,
            dwType,
            (CONST BYTE *)pdwValue,
            dwSize);

    } else {
        ASSERT ( FALSE );
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}

LONG
CSmLogQuery::WriteRegistrySlqTime (
    HKEY     hKey,
    UINT     uiValueName,
    PSLQ_TIME_INFO  pSlqTime
)
{
    LONG    dwStatus = ERROR_SUCCESS;
    DWORD   dwValue = sizeof(SLQ_TIME_INFO);

    ResourceStateManager   rsm;

    if ( NULL != pSlqTime && NULL != hKey ) {

        dwStatus = RegSetValueEx (
            hKey, 
            GetNonLocRegValueName ( uiValueName ), 
            0L,
            REG_BINARY,
            (CONST BYTE *)pSlqTime,
            dwValue);
    } else {
        ASSERT ( FALSE );
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}

LONG
CSmLogQuery::ReadRegistryStringValue (
    HKEY     hKey,
    LPCWSTR  szValueName,
    LPCWSTR  szNonLocValueName,
    LPCWSTR  szDefault,
    LPWSTR   *pszBuffer,
    LPDWORD  pdwBufferSize
)
//
//  Reads the string value from named value under hKey and
//  frees any existing buffer referenced by szInBuffer, 
//  then allocates a new buffer returning it with the 
//  string value read from the registry and the size of the
//  buffer in bytes.
//  For Win2K and XP through SP1, value names might have been localized. 
//  If a value is not found using the non-localized value name,
//  retry with a localized string.
//  If no value found in the registry, return the default value.
//  The last WCHAR in the buffer is specifically set to NULL.
//
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HRESULT hr = S_OK;
    DWORD   dwType = 0;
    DWORD   dwBufferSize = 0;
    WCHAR*  szNewStringBuffer = NULL;
    size_t  cchBufLen = 0;
    BOOL    bLocalized = FALSE;

    if ( NULL != pdwBufferSize ) {
        *pdwBufferSize = dwBufferSize;
    }

    if ( hKey != NULL) {
        //
        // There should be something to read.
        // Find out the size of the required buffer.
        //
        // Try first with the non-localized name.
        dwStatus = RegQueryValueExW (
            hKey,
            szNonLocValueName,
            NULL,
            &dwType,
            NULL,
            &dwBufferSize);

        if ( ERROR_SUCCESS != dwStatus ) { 
            //
            // Unable to read buffer.
            // If the non-localized value name is different from the possibly
            // localized version, retry with the localized version.
            if ( 0 != lstrcmpi ( szValueName, szNonLocValueName ) ) { 
                dwStatus = RegQueryValueExW (
                    hKey,
                    szValueName,
                    NULL,
                    &dwType,
                    NULL,
                    &dwBufferSize);

                if ( ERROR_SUCCESS == dwStatus ) {
                    bLocalized = TRUE;
                }
            }
        }
        
        if (dwStatus == ERROR_SUCCESS) {
            //
            // NULL character size is 2 bytes
            //
            if (dwBufferSize > sizeof(WCHAR) ) {
                //
                // There's something to read
                //
                MFC_TRY
                    szNewStringBuffer = new WCHAR[dwBufferSize/sizeof(WCHAR)];
                    dwType = 0;
                    dwStatus = RegQueryValueExW (
                        hKey,
                        ( bLocalized ? szValueName : szNonLocValueName),
                        NULL,
                        &dwType,
                        (LPBYTE)szNewStringBuffer,
                        &dwBufferSize);
                MFC_CATCH_DWSTATUS

                if ( ERROR_SUCCESS == dwStatus ) {
                    //
                    // Ensure that the registry string is null terminated.
                    //
                    cchBufLen = dwBufferSize/sizeof(WCHAR);
                    szNewStringBuffer[cchBufLen - 1] = L'\0';

                    if ( 0 == lstrlenW ( szNewStringBuffer ) ) {
                        dwStatus = ERROR_NO_DATA;
                    }
                }
            } else {
                //
                // Nothing to read.
                //
                dwStatus = ERROR_NO_DATA;
            }
        }   // else unable to read buffer.
            // dwStatus has error.
        
    } else {
        //
        // Null key.
        //
        dwStatus = ERROR_BADKEY;
    }

    if (dwStatus != ERROR_SUCCESS) {
        if (szNewStringBuffer != NULL) {
            delete [] szNewStringBuffer;
            szNewStringBuffer = NULL;
        }
        //
        // Apply default.
        //
        if ( szDefault != NULL ) {
            cchBufLen = 0;
            //
            // StringCchLen fails if szDefault is null.
            //
            hr = StringCchLength ( szDefault, STRSAFE_MAX_CCH, &cchBufLen );

            if ( SUCCEEDED (hr) ) {
                // Null terminator.
                cchBufLen++;
            }
            MFC_TRY
                szNewStringBuffer = new WCHAR[cchBufLen];
                StringCchCopy (
                    szNewStringBuffer,
                    cchBufLen,
                    szDefault);
                dwStatus = ERROR_SUCCESS;
                dwBufferSize = (DWORD)(cchBufLen * sizeof(WCHAR));
            MFC_CATCH_DWSTATUS
        } // else no default so no data returned
    }

    if (dwStatus == ERROR_SUCCESS) {
    
        //
        // Delete the old buffer and replace it with 
        // the new one.
        //
        if ( NULL != *pszBuffer ) {
            delete [] (*pszBuffer );
        }
        *pszBuffer = szNewStringBuffer;
        if ( NULL != pdwBufferSize ) {
            *pdwBufferSize = dwBufferSize;
        }
    } else {
        //
        // If error then delete the buffer
        if (szNewStringBuffer != NULL) {
            delete [] szNewStringBuffer;
        }
    }
    return dwStatus;
    
}

LONG
CSmLogQuery::ReadRegistryStringValue (
    HKEY     hKey,
    UINT     uiValueName,
    LPCWSTR  szDefault,
    LPWSTR   *pszBuffer,
    LPDWORD  pdwBufferSize
)
//
//  reads the string value from key (name based on resource 
//  uiValueName) under hKey and
//  frees any existing buffer referenced by szInBuffer, 
//  then allocates a new buffer returning it with the 
//  string value read from the registry and the size of the
//  buffer (in bytes) 
//
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    DWORD   dwBufferSize = 0;
    WCHAR*  szNewStringBuffer = NULL;
    CString strRegValueName;

    ResourceStateManager   rsm;

    MFC_TRY
        strRegValueName.LoadString ( uiValueName );
    MFC_CATCH_DWSTATUS;

    ASSERT (!strRegValueName.IsEmpty());

    if ( ERROR_SUCCESS == dwStatus ) {
        dwStatus = ReadRegistryStringValue (
                        hKey,
                        strRegValueName,
                        GetNonLocRegValueName ( uiValueName ),
                        szDefault,
                        pszBuffer,
                        pdwBufferSize );
    }

    return dwStatus;
}   

DWORD 
CSmLogQuery::SmNoLocReadRegIndStrVal (
    HKEY hKey, 
    UINT uiValueName,
    LPCWSTR szDefault, 
    LPWSTR* pszBuffer, 
    UINT*   puiLength )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    LPCWSTR szNonLocValueName = NULL;
    CString strRegValueName;

    szNonLocValueName = GetNonLocRegValueName ( uiValueName );

    if ( NULL != szNonLocValueName ) {

        //
        // There should be something to read.
        //
        // Try first with the non-localized name.
    
        dwStatus = SmReadRegistryIndirectStringValue (
                        hKey,
                        szNonLocValueName,
                        szDefault,
                        pszBuffer,
                        puiLength );

        if ( ERROR_SUCCESS != dwStatus ) { 
            //
            // Unable to read buffer.
            // If the non-localized value name is different from the possibly
            // localized version, retry with the localized version.
            dwStatus = ERROR_SUCCESS;
            MFC_TRY
                strRegValueName.LoadString ( uiValueName );
            MFC_CATCH_DWSTATUS;

            ASSERT (!strRegValueName.IsEmpty());

            if ( ERROR_SUCCESS == dwStatus 
                &&  ( 0 != lstrcmpi ( strRegValueName, szNonLocValueName ) ) ) {

                dwStatus = SmReadRegistryIndirectStringValue (
                            hKey,
                            strRegValueName,
                            szDefault,
                            pszBuffer,
                            puiLength );
            }
        }
    }

    return dwStatus;
}

LONG
CSmLogQuery::ReadRegistrySlqTime (
    HKEY     hKey,
    UINT     uiValueName,
    PSLQ_TIME_INFO pstiDefault,
    PSLQ_TIME_INFO pSlqValue
)
//
//  reads the time value "szValueName" from under hKey and
//  returns it in the Value buffer
//
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    DWORD   dwBufferSize = 0;

    SLQ_TIME_INFO   slqLocal;
    CString strRegValueName;
    LPCWSTR szNonLocValueName = NULL;
    BOOL    bLocalizedValueName = FALSE;

    ResourceStateManager   rsm;

    if ( NULL != pSlqValue && NULL != hKey ) {

        szNonLocValueName = GetNonLocRegValueName ( uiValueName );

        if ( NULL != szNonLocValueName ) {
            memset (&slqLocal, 0, sizeof(SLQ_TIME_INFO));
            //
            // Find out the size of the required buffer,
            // and whether the value exists in the registry.
            // Try first with the non-localized value name.
            //
            dwStatus = RegQueryValueExW (
                hKey,
                szNonLocValueName,
                NULL,
                &dwType,
                NULL,
                &dwBufferSize);

            if ( ERROR_SUCCESS != dwStatus ) {

                dwStatus = ERROR_SUCCESS;
                MFC_TRY
                    strRegValueName.LoadString ( uiValueName );
                MFC_CATCH_DWSTATUS;

                ASSERT (!strRegValueName.IsEmpty());

                if ( ERROR_SUCCESS == dwStatus 
                    &&  ( 0 != lstrcmpi ( strRegValueName, szNonLocValueName ) ) ) {

                    //
                    // Retry if the value name has been localized.
                    //
                    memset (&slqLocal, 0, sizeof(SLQ_TIME_INFO));
                    dwStatus = RegQueryValueExW (
                        hKey,
                        strRegValueName,
                        NULL,
                        &dwType,
                        NULL,
                        &dwBufferSize);

                    if ( ERROR_SUCCESS == dwStatus ) {
                        bLocalizedValueName = TRUE;
                    }
                }
            }
            if (dwStatus == ERROR_SUCCESS) {
                if ((dwBufferSize == sizeof(SLQ_TIME_INFO)) && (dwType == REG_BINARY)) {
                    // then there's something to read
                    dwType = 0;
                    dwStatus = RegQueryValueExW (
                        hKey,
                        ( bLocalizedValueName? strRegValueName : szNonLocValueName ),
                        NULL,
                        &dwType,
                        (LPBYTE)&slqLocal,
                        &dwBufferSize);
                } else {
                    // nothing to read                
                    dwStatus = ERROR_NO_DATA;
                }
            }   // else 
                // unable to read buffer
                // dwStatus has error
        
            if (dwStatus == ERROR_SUCCESS) {
                *pSlqValue = slqLocal;
            } else {
                // apply default if it exists
                if (pstiDefault != NULL) {
                    *pSlqValue = *pstiDefault;
                    dwStatus = ERROR_SUCCESS;
                }
            }
        } else {
            // Value name Id is out of range.
            ASSERT ( FALSE );
            dwStatus = ERROR_INVALID_PARAMETER;
        }
    } else {
        ASSERT ( FALSE );
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}


LONG
CSmLogQuery::ReadRegistryDwordValue (
    HKEY    hKey,
    UINT    uiValueName,
    DWORD   dwDefault,
    LPDWORD pdwValue
)
//
//  reads the DWORD value "szValueName" from under hKey and
//  returns it in the Value buffer
//
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    DWORD   dwBufferSize = 0;
    DWORD   dwRegValue = 0;
    CString strRegValueName;
    LPCWSTR szNonLocValueName = NULL;
    BOOL    bLocalizedValueName = FALSE;

    ResourceStateManager   rsm;

    if ( NULL != pdwValue && NULL != hKey ) {

        szNonLocValueName = GetNonLocRegValueName ( uiValueName );

        if ( NULL != szNonLocValueName ) {
            //
            // Find out the size of the required buffer,
            // and whether the value exists in the registry.
            // Try first with the non-localized value name.
            //
            dwStatus = RegQueryValueExW (
                hKey,
                szNonLocValueName,
                NULL,
                &dwType,
                NULL,
                &dwBufferSize);

            if ( ERROR_SUCCESS != dwStatus ) {

                dwStatus = ERROR_SUCCESS;
                MFC_TRY
                    strRegValueName.LoadString ( uiValueName );
                MFC_CATCH_DWSTATUS;

                ASSERT (!strRegValueName.IsEmpty());

                if ( ERROR_SUCCESS == dwStatus 
                    &&  ( 0 != lstrcmpi ( strRegValueName, szNonLocValueName ) ) ) {

                    //
                    // Retry if the value name has been localized.
                    //
                    dwStatus = RegQueryValueExW (
                        hKey,
                        strRegValueName,
                        NULL,
                        &dwType,
                        NULL,
                        &dwBufferSize);
                    if ( ERROR_SUCCESS == dwStatus ) {
                        bLocalizedValueName = TRUE;
                    }
                }
            }
            if (dwStatus == ERROR_SUCCESS) {
                if ( (dwBufferSize == sizeof(DWORD)) 
                    && ( (REG_DWORD == dwType) || ( REG_BINARY == dwType) ) ) {
                    // then there's something to read
                    dwType = 0;
                    dwStatus = RegQueryValueExW (
                        hKey,
                        ( bLocalizedValueName ? strRegValueName : szNonLocValueName ),
                        NULL,
                        &dwType,
                        (LPBYTE)&dwRegValue,
                        &dwBufferSize);
                } else {
                    // nothing to read                
                    dwStatus = ERROR_NO_DATA;
                }
                
            }   // else 
                // unable to read buffer
                // dwStatus has error

            if (dwStatus == ERROR_SUCCESS) {
                *pdwValue = dwRegValue;
            } else {
                *pdwValue = dwDefault;
                dwStatus = ERROR_SUCCESS;
            }
        } else {
            // Value name Id is out of range.
            ASSERT ( FALSE );
            dwStatus = ERROR_INVALID_PARAMETER;
        }
    } else {
        ASSERT ( FALSE );
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}


HRESULT 
CSmLogQuery::StringToPropertyBag (
    IPropertyBag* pPropBag, 
    UINT uiPropName, 
    const CString& rstrData )
{
    return StringToPropertyBag ( 
            pPropBag, 
            GetNonLocHtmlPropName ( uiPropName ), 
            rstrData );
}

typedef struct _HTML_ENTITIES {
    LPWSTR szHTML;
    LPWSTR szEntity;
} HTML_ENTITIES;

HTML_ENTITIES g_htmlentities[] = {
    L"&",    L"&amp;",
    L"\"",   L"&quot;",
    L"<",    L"&lt;",
    L">",    L"&gt;",
    NULL, NULL
};

HRESULT 
CSmLogQuery::StringToPropertyBag (
    IPropertyBag* pIPropBag, 
    const CString& rstrPropName, 
    const CString& rstrData )
{
    HRESULT hr = S_OK;
    VARIANT vValue;
    LPWSTR  szTrans = NULL;
    BOOL    bAllocated = FALSE;
    int     i;
    size_t  cchLen = 0;
    LPWSTR  szScan = NULL;


    if ( NULL != pIPropBag ) {
        VariantInit( &vValue );
        vValue.vt = VT_BSTR;
        vValue.bstrVal = NULL;

        if ( !rstrData.IsEmpty() ) {
            MFC_TRY
                for( i=0 ;g_htmlentities[i].szHTML != NULL; i++ ){
                    //
                    // rstrData is const
                    //
                    // Max length of szHTML is 6.  Add 5 because 1 will be added
                    // when add rstrData.GetLength() below.
                    //
                    szScan = ((CString)rstrData).GetBuffer ( rstrData.GetLength() );
                    while( *szScan != L'\0' ){
                        if( *szScan == *g_htmlentities[i].szHTML ){
                            cchLen += 5;
                        }
                        szScan++;
                    }
                    ((CString)rstrData).ReleaseBuffer();
                }
                if( cchLen > 0 ){

                    //
                    // Add space for the original text.
                    //
                    cchLen += rstrData.GetLength() + 1;

                    szTrans = new WCHAR [cchLen];
                    bAllocated = TRUE;
                    ZeroMemory( szTrans, ( cchLen * sizeof(WCHAR) ) );
                    szScan = ((CString)rstrData).GetBuffer ( rstrData.GetLength() );
                    while( *szScan != L'\0' ){
                        BOOL bEntity = FALSE;
                        for( i=0; g_htmlentities[i].szHTML != NULL; i++ ){
                            if( *szScan == *g_htmlentities[i].szHTML ){
                                bEntity = TRUE;
                                StringCchCat ( szTrans, cchLen, g_htmlentities[i].szEntity );
                                break;
                            }
                        }
                        if( !bEntity ){
                            StringCchCatN ( szTrans, cchLen, szScan, 1 );
                        }
                        szScan++;
                    }
                } else {
                    szTrans = ((CString)rstrData).GetBuffer ( rstrData.GetLength() );
                }

                vValue.bstrVal = ::SysAllocString ( szTrans );
                hr = pIPropBag->Write ( rstrPropName, &vValue );    
                VariantClear ( &vValue );
                ((CString)rstrData).ReleaseBuffer();
            MFC_CATCH_HR
        } else {
            hr = pIPropBag->Write(rstrPropName, &vValue );    
        }
    }
    if( NULL != szTrans && bAllocated ){
        delete [] szTrans;
    }
    return hr;
}

HRESULT 
CSmLogQuery::DwordToPropertyBag (
    IPropertyBag* pPropBag, 
    UINT uiPropName, 
    DWORD dwData )
{
    return DwordToPropertyBag (
            pPropBag,
            GetNonLocHtmlPropName ( uiPropName ), 
            dwData );
}
    
HRESULT 
CSmLogQuery::DwordToPropertyBag (
    IPropertyBag* pPropBag, 
    const CString& rstrPropName, 
    DWORD dwData )
{
    VARIANT vValue;
    HRESULT hr;

    VariantInit( &vValue );
    vValue.vt = VT_I4;
    vValue.lVal = (INT)dwData;

    hr = pPropBag->Write(rstrPropName, &vValue );

    VariantClear ( &vValue );

    return hr;
}

HRESULT 
CSmLogQuery::DoubleToPropertyBag (
    IPropertyBag* pPropBag, 
    UINT uiPropName, 
    DOUBLE dData )
{
    return DoubleToPropertyBag (
            pPropBag,
            GetNonLocHtmlPropName ( uiPropName ), 
            dData );
}

HRESULT 
CSmLogQuery::DoubleToPropertyBag (
    IPropertyBag* pPropBag, 
    const CString& rstrPropName, 
    DOUBLE dData )
{
    VARIANT vValue;
    HRESULT hr;

    VariantInit( &vValue );
    vValue.vt = VT_R8;
    vValue.dblVal = dData;

    hr = pPropBag->Write(rstrPropName, &vValue );

    VariantClear ( &vValue );

    return hr;
}

HRESULT 
CSmLogQuery::FloatToPropertyBag (
    IPropertyBag* pPropBag, 
    UINT uiPropName, 
    FLOAT fData )
{
    return FloatToPropertyBag (
            pPropBag,
            GetNonLocHtmlPropName ( uiPropName ), 
            fData );
}

HRESULT 
CSmLogQuery::FloatToPropertyBag (
    IPropertyBag* pPropBag, 
    const CString& rstrPropName, 
    FLOAT fData )
{
    VARIANT vValue;
    HRESULT hr;

    VariantInit( &vValue );
    vValue.vt = VT_R4;
    vValue.fltVal = fData;

    hr = pPropBag->Write(rstrPropName, &vValue );

    VariantClear ( &vValue );

    return hr;
}

HRESULT 
CSmLogQuery::LLTimeToPropertyBag (
    IPropertyBag* pIPropBag, 
    UINT uiPropName,
    LONGLONG& rllData )
{
    HRESULT hr;
    VARIANT vValue;
    CString strPropName;
    
    MFC_TRY
        strPropName = GetNonLocHtmlPropName ( uiPropName ), 

        VariantInit( &vValue );
        vValue.vt = VT_DATE;

        if ( LLTimeToVariantDate ( rllData, &vValue.date ) ) {

            hr = pIPropBag->Write(strPropName, &vValue );

            VariantClear ( &vValue );
    
        } else { 
            hr = E_FAIL;
        }
    MFC_CATCH_HR

    return hr;
}

HRESULT 
CSmLogQuery::SlqTimeToPropertyBag (
    IPropertyBag* pPropBag, 
    DWORD dwFlags, 
    PSLQ_TIME_INFO pSlqData )
{
    HRESULT hr = NOERROR;

    ASSERT ( NULL != pSlqData );

    switch (dwFlags) {
        case SLQ_TT_TTYPE_START:
            ASSERT ( SLQ_TT_TTYPE_START == pSlqData->wTimeType );

            hr = DwordToPropertyBag ( pPropBag, IDS_HTML_START_MODE, pSlqData->dwAutoMode );
            if ( SLQ_AUTO_MODE_AT == pSlqData->dwAutoMode ) {
                ASSERT ( SLQ_TT_DTYPE_DATETIME == pSlqData->wDataType );
                hr = LLTimeToPropertyBag ( pPropBag, IDS_HTML_START_AT_TIME, pSlqData->llDateTime );
            }
            
            break;

        case SLQ_TT_TTYPE_STOP:
            ASSERT ( SLQ_TT_TTYPE_STOP == pSlqData->wTimeType );

            hr = DwordToPropertyBag ( pPropBag, IDS_HTML_STOP_MODE, pSlqData->dwAutoMode );
            if ( SLQ_AUTO_MODE_AT == pSlqData->dwAutoMode ) {
                ASSERT ( SLQ_TT_DTYPE_DATETIME == pSlqData->wDataType );
                hr = LLTimeToPropertyBag ( pPropBag, IDS_HTML_STOP_AT_TIME, pSlqData->llDateTime );
            } else if ( SLQ_AUTO_MODE_AFTER == pSlqData->dwAutoMode ) {
                ASSERT ( SLQ_TT_DTYPE_UNITS == pSlqData->wDataType );
                hr = DwordToPropertyBag ( 
                        pPropBag, 
                        IDS_HTML_STOP_AFTER_UNIT_TYPE, 
                        pSlqData->dwUnitType );
                hr = DwordToPropertyBag ( 
                        pPropBag, 
                        IDS_HTML_STOP_AFTER_VALUE, 
                        pSlqData->dwValue );
            }
            
            break;
            
        case SLQ_TT_TTYPE_SAMPLE:
        {
            LONGLONG    llMillisecondSampleInt;
            FLOAT fSampleIntSeconds;
            
            ASSERT ( SLQ_TT_TTYPE_SAMPLE == pSlqData->wTimeType );
            ASSERT ( SLQ_TT_DTYPE_UNITS == pSlqData->wDataType );
//            ASSERT ( SLQ_AUTO_MODE_AFTER == pSlqData->dwAutoMode );

            // Write best approximation of sample time to Sysmon property.
            TimeInfoToMilliseconds ( pSlqData, &llMillisecondSampleInt );
                
            // Ensure that the millisecond sample interval fits in a DWORD.
            ASSERT ( llMillisecondSampleInt < ULONG_MAX );

            fSampleIntSeconds = (FLOAT)(llMillisecondSampleInt / 1000);
            hr = FloatToPropertyBag ( 
                    pPropBag, 
                    IDS_HTML_SYSMON_UPDATEINTERVAL, 
                    fSampleIntSeconds );

            hr = DwordToPropertyBag ( pPropBag, IDS_HTML_SAMPLE_INT_UNIT_TYPE, pSlqData->dwUnitType );
            hr = DwordToPropertyBag ( pPropBag, IDS_HTML_SAMPLE_INT_VALUE, pSlqData->dwValue );
            break;
        }
        // Restart mode stored as a single DWORD
        case SLQ_TT_TTYPE_RESTART:
        default:
            hr = E_INVALIDARG;
            break;
    }

    return hr;
}

HRESULT 
CSmLogQuery::StringFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog*  pIErrorLog,
    UINT uiPropName, 
    const CString& rstrDefault,
    LPWSTR   *pszBuffer,
    LPDWORD  pdwLength )
{
    HRESULT hr;
    CString strPropName;
    ResourceStateManager rsm;

//
//  reads the string value from property bag and
//  frees any existing buffer referenced by szData, 
//  then allocates a new buffer returning it with the 
//  string value read from the property bag and the size of the
//  buffer (in bytes) 
//

    MFC_TRY
        strPropName.LoadString ( uiPropName );

        hr = StringFromPropertyBag (
                pPropBag,
                pIErrorLog,
                strPropName,
                GetNonLocHtmlPropName ( uiPropName ),
                rstrDefault,
                pszBuffer,
                pdwLength );
    MFC_CATCH_HR
    return hr;
}

HRESULT 
CSmLogQuery::StringFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog*  pIErrorLog,
    const CString& rstrPropName, 
    const CString& rstrNonLocPropName, 
    const CString& rstrDefault,
    LPWSTR   *pszBuffer,
    LPDWORD  pdwLength )
{
    HRESULT hr = E_POINTER;
    VARIANT vValue;
    DWORD   cchNewBufLen = 0;
    LPWSTR  szNewStringBuffer = NULL;
    LPWSTR  szTrans = NULL;
    LPWSTR  szScan = NULL;

//
//  Reads the string value from property bag and
//  frees any existing buffer referenced by szData, 
//  then allocates a new buffer returning it with the 
//  string value read from the property bag and the size of the
//  buffer (in bytes) 
//

    ASSERT (pdwLength!= NULL);
    ASSERT (pszBuffer != NULL);

    if ( NULL == pdwLength || NULL == pszBuffer ) {
        return E_POINTER;
    }

    *pdwLength = 0;

    VariantInit( &vValue );
    vValue.vt = VT_BSTR;
    vValue.bstrVal = NULL;

    MFC_TRY
        hr = pPropBag->Read(rstrNonLocPropName, &vValue, pIErrorLog );

        if ( FAILED(hr) || NULL == vValue.bstrVal ) {
            hr = pPropBag->Read(rstrPropName, &vValue, pIErrorLog );
        }

        if ( SUCCEEDED(hr) && NULL != vValue.bstrVal ) {
            //
            // SysStringLen returns number of characters allocated for BSTR
            // It includes embedded nulls, but not the terminating null.
            //
            cchNewBufLen = SysStringLen(vValue.bstrVal);
            //
            // Ensure that the BSTR is null-terminated.
            //
            vValue.bstrVal[cchNewBufLen] = L'\0';
            
            cchNewBufLen++;    // Add 1 for null character to be allocated.

            if ( cchNewBufLen > 1 ) {
                // then there's something to read
                szTrans = new WCHAR[cchNewBufLen];
                szNewStringBuffer = new WCHAR[cchNewBufLen];    
                StringCchCopy ( szNewStringBuffer, cchNewBufLen, vValue.bstrVal );
                for( int i=0;g_htmlentities[i].szHTML != NULL;i++ ){
                    szScan = NULL;
                    while( szScan = wcsstr( szNewStringBuffer, g_htmlentities[i].szEntity ) ){
                        //
                        // Null the character at szScan, so that the (new) string 
                        // at the beginning of szNewStringBuffer will copied to szTrans.  
                        // Then the NULL character is overwritten with the character
                        // represented by the specified HTML entity.
                        //
                        *szScan = L'\0';
                        StringCchCopy(szTrans, cchNewBufLen, szNewStringBuffer);
                        StringCchCat(szTrans, cchNewBufLen, g_htmlentities[i].szHTML);

                        //
                        // szScan is then set to one character past the HTML entity.
                        //
                        szScan += lstrlen( g_htmlentities[i].szEntity);
                        //
                        // The rest of the original string is concatenated onto
                        // szTrans, and szNewStringBuffer replaced by the string at 
                        // szTrans, so the next loop will start again at the beginning
                        // of the string.
                        //
                        StringCchCat(szTrans, cchNewBufLen, szScan);

                        StringCchCopy(szNewStringBuffer, cchNewBufLen, szTrans);
                    }
                }
                delete [] szTrans;
                szTrans = NULL;
            } else if ( 0 != rstrDefault.GetLength() ) {
                //
                // Missing data in the property bag, so apply the default.
                // Add 1 for null character to be allocated.
                //
                cchNewBufLen = rstrDefault.GetLength() + 1; 

                szNewStringBuffer = new WCHAR[cchNewBufLen];

                StringCchCopy ( szNewStringBuffer, cchNewBufLen, rstrDefault );
                hr = S_OK;
            }
        } else if ( 0 != rstrDefault.GetLength() ) {
            //
            // Missing data in the property bag, so apply the default.
            // Add 1 for null character to be allocated.
            //
            cchNewBufLen = rstrDefault.GetLength() + 1;
        
            szNewStringBuffer = new WCHAR[cchNewBufLen];
            StringCchCopy ( szNewStringBuffer, cchNewBufLen, rstrDefault );
            hr = S_OK;
        }
    MFC_CATCH_HR

    if ( SUCCEEDED(hr)) {
        // then delete the old buffer and replace it with 
        // the new one
        if (*pszBuffer != NULL) {
            delete [] (*pszBuffer );
        }
        *pszBuffer = szNewStringBuffer;
        szNewStringBuffer = NULL;
        *pdwLength = cchNewBufLen;
    }        
    
    // if error then delete the buffer
    if ( NULL != szNewStringBuffer ) {
        delete [] szNewStringBuffer;
    }
    
    if ( NULL != szTrans ) {
        delete [] szTrans;
    }
    return hr;
}

HRESULT 
CSmLogQuery::DwordFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog*  pIErrorLog,
    UINT uiPropName, 
    DWORD  dwDefault,
    DWORD& rdwData )
{
    HRESULT hr;
    CString strPropName;

    ResourceStateManager rsm;

    MFC_TRY
        strPropName.LoadString ( uiPropName );

        hr = DwordFromPropertyBag ( 
                pPropBag,
                pIErrorLog,
                strPropName,
                GetNonLocHtmlPropName ( uiPropName ),
                dwDefault, 
                rdwData );
    MFC_CATCH_HR
    return hr;
}

HRESULT 
CSmLogQuery::DwordFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog*  pIErrorLog,
    const CString& rstrPropName, 
    const CString& rstrNonLocPropName, 
    DWORD  dwDefault,
    DWORD& rdwData )
{
    VARIANT vValue;
    HRESULT hr;

    rdwData = dwDefault;

    VariantInit( &vValue );
    vValue.vt = VT_I4;
    vValue.lVal = 0;

    hr = pPropBag->Read(rstrNonLocPropName, &vValue, pIErrorLog );

    if ( FAILED ( hr ) ) {
        hr = pPropBag->Read(rstrPropName, &vValue, pIErrorLog );
    }

    if ( E_INVALIDARG != hr ) {
        rdwData = (DWORD)vValue.lVal;
    } else {
        hr = S_OK;
    }

    return hr;
}

HRESULT 
CSmLogQuery::DoubleFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog*  pIErrorLog,
    UINT uiPropName, 
    DOUBLE  dDefault,
    DOUBLE& rdData )
{
    HRESULT hr;
    CString strPropName;

    ResourceStateManager rsm;

    MFC_TRY
        strPropName.LoadString ( uiPropName );
    
        hr = DoubleFromPropertyBag ( 
                pPropBag,
                pIErrorLog,
                strPropName,
                GetNonLocHtmlPropName ( uiPropName ), 
                dDefault, 
                rdData );
    MFC_CATCH_HR

    return hr;
}
    
HRESULT 
CSmLogQuery::DoubleFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog*  pIErrorLog,
    const CString& rstrPropName, 
    const CString& rstrNonLocPropName, 
    DOUBLE  dDefault,
    DOUBLE& rdData )
{
    VARIANT vValue;
    HRESULT hr;

    rdData = dDefault;

    VariantInit( &vValue );
    vValue.vt = VT_R8;
    vValue.dblVal = 0;

    hr = pPropBag->Read(rstrNonLocPropName, &vValue, pIErrorLog );

    if ( FAILED ( hr ) ) {
        hr = pPropBag->Read(rstrPropName, &vValue, pIErrorLog );
    }

    if ( E_INVALIDARG != hr ) {
        rdData = vValue.dblVal;
    } else {
        hr = S_OK;
    }

    return hr;
}

HRESULT 
CSmLogQuery::FloatFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog*  pIErrorLog,
    UINT uiPropName, 
    FLOAT  fDefault,
    FLOAT& rfData )
{
    HRESULT hr;
    CString strPropName;

    ResourceStateManager rsm;

    strPropName.LoadString ( uiPropName );
    
    hr = FloatFromPropertyBag ( 
            pPropBag,
            pIErrorLog,
            strPropName,
            GetNonLocHtmlPropName ( uiPropName ),
            fDefault, 
            rfData );

    return hr;
}
    
HRESULT 
CSmLogQuery::FloatFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog*  pIErrorLog,
    const CString& rstrPropName, 
    const CString& rstrNonLocPropName,
    FLOAT  fDefault,
    FLOAT& rfData )
{
    VARIANT vValue;
    HRESULT hr;

    rfData = fDefault;

    VariantInit( &vValue );
    vValue.vt = VT_R4;
    vValue.fltVal = 0;

    hr = pPropBag->Read(rstrNonLocPropName, &vValue, pIErrorLog );

    if ( FAILED ( hr ) ) {
        hr = pPropBag->Read(rstrPropName, &vValue, pIErrorLog );
    }

    if ( E_INVALIDARG != hr ) {
        rfData = vValue.fltVal;
    } else {
        hr = S_OK;
    }

    return hr;
}

HRESULT
CSmLogQuery::LLTimeFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    UINT uiPropName,
    LONGLONG&  rllDefault,
    LONGLONG& rllData )
{
    HRESULT hr = NOERROR;
    CString strPropName;
    VARIANT vValue;
    ResourceStateManager rsm;
    
    MFC_TRY
        strPropName.LoadString ( uiPropName );

        rllData = rllDefault;

        VariantInit( &vValue );
        vValue.vt = VT_DATE;

        hr = pIPropBag->Read(GetNonLocHtmlPropName( uiPropName ), &vValue, pIErrorLog );

        if ( FAILED ( hr ) ) {
            hr = pIPropBag->Read(strPropName, &vValue, pIErrorLog );
        }
        // If parameter not missing, translate and return.  Otherwise,
        // return the default.
        if ( E_INVALIDARG != hr ) {
            if ( !VariantDateToLLTime ( vValue.date, &rllData ) ) {
                hr = E_FAIL;
            }
            VariantClear( &vValue );
        } else {
            hr = S_OK;
        }
    MFC_CATCH_HR

    return hr;
}

HRESULT
CSmLogQuery::SlqTimeFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog*  pIErrorLog,
    DWORD dwFlags, 
    PSLQ_TIME_INFO pSlqDefault,
    PSLQ_TIME_INFO pSlqData )
{
    HRESULT hr = NOERROR;

    ASSERT ( NULL != pSlqData );

    switch (dwFlags) {
        case SLQ_TT_TTYPE_START:

            pSlqData->wTimeType = SLQ_TT_TTYPE_START;
            pSlqData->wDataType = SLQ_TT_DTYPE_DATETIME;

            hr = DwordFromPropertyBag ( 
                    pPropBag, 
                    pIErrorLog, 
                    IDS_HTML_START_MODE, 
                    pSlqDefault->dwAutoMode, 
                    pSlqData->dwAutoMode );
            
            if ( SLQ_AUTO_MODE_AT == pSlqData->dwAutoMode ) {
                hr = LLTimeFromPropertyBag ( 
                        pPropBag, 
                        pIErrorLog, 
                        IDS_HTML_START_AT_TIME, 
                        pSlqDefault->llDateTime, 
                        pSlqData->llDateTime );

            } else {
                // Original state is stopped.
                ASSERT ( SLQ_AUTO_MODE_NONE == pSlqData->dwAutoMode );
                pSlqData->llDateTime = MAX_TIME_VALUE;
            }
            
            break;

        case SLQ_TT_TTYPE_STOP:
            pSlqData->wTimeType = SLQ_TT_TTYPE_STOP;

            hr = DwordFromPropertyBag ( 
                    pPropBag, 
                    pIErrorLog, 
                    IDS_HTML_STOP_MODE, 
                    pSlqDefault->dwAutoMode, 
                    pSlqData->dwAutoMode );
            
            if ( SLQ_AUTO_MODE_AT == pSlqData->dwAutoMode ) {
                pSlqData->wDataType = SLQ_TT_DTYPE_DATETIME;
                hr = LLTimeFromPropertyBag ( 
                        pPropBag, 
                        pIErrorLog, 
                        IDS_HTML_STOP_AT_TIME, 
                        pSlqDefault->llDateTime, 
                        pSlqData->llDateTime );

            } else if ( SLQ_AUTO_MODE_AFTER == pSlqData->dwAutoMode ) {
                pSlqData->wDataType = SLQ_TT_DTYPE_UNITS;

                hr = DwordFromPropertyBag ( 
                        pPropBag, 
                        pIErrorLog, 
                        IDS_HTML_STOP_AFTER_UNIT_TYPE, 
                        pSlqDefault->dwUnitType, 
                        pSlqData->dwUnitType );

                hr = DwordFromPropertyBag ( 
                        pPropBag, 
                        pIErrorLog, 
                        IDS_HTML_STOP_AFTER_VALUE, 
                        pSlqDefault->dwValue, 
                        pSlqData->dwValue );
            } else {
                // Original state is stopped.
                // Mode is NONE or SIZE
                pSlqData->wDataType = SLQ_TT_DTYPE_DATETIME;
                pSlqData->llDateTime = MIN_TIME_VALUE;
            }
            
            break;
            
        case SLQ_TT_TTYPE_SAMPLE:
        {
            DWORD dwNullDefault = (DWORD)(-1);
            BOOL bUnitTypeMissing = FALSE;
            BOOL bUnitValueMissing = FALSE;

            hr = DwordFromPropertyBag ( 
                            pPropBag, 
                            pIErrorLog, 
                            IDS_HTML_SAMPLE_INT_UNIT_TYPE, 
                            dwNullDefault, 
                            pSlqData->dwUnitType );

            if ( (DWORD)(-1) == pSlqData->dwUnitType ) {
                pSlqData->dwUnitType = pSlqDefault->dwUnitType;
                bUnitTypeMissing = TRUE;
            }

            hr = DwordFromPropertyBag ( 
                            pPropBag, 
                            pIErrorLog, 
                            IDS_HTML_SAMPLE_INT_VALUE, 
                            dwNullDefault, 
                            pSlqData->dwValue );

            if ( (DWORD)(-1) == pSlqData->dwValue ) {
                pSlqData->dwValue = pSlqDefault->dwValue;
                bUnitValueMissing = TRUE;
            }

            if ( bUnitTypeMissing || bUnitValueMissing ) {
                FLOAT fDefaultUpdateInterval;
                FLOAT fUpdateInterval;

                // If unit type or unit count missing from the property bag,
                // look for "UpdateInterval" value, from the Sysmon control object,
                // and use it to approximate the sample time.
                fDefaultUpdateInterval = (FLOAT)(pSlqDefault->dwValue);

                hr = FloatFromPropertyBag ( 
                        pPropBag, 
                        pIErrorLog, 
                        IDS_HTML_SYSMON_UPDATEINTERVAL, 
                        fDefaultUpdateInterval, 
                        fUpdateInterval );

                if ( SUCCEEDED ( hr ) ) {
                    pSlqData->dwValue = (DWORD)(fUpdateInterval);
                    pSlqData->dwUnitType = SLQ_TT_UTYPE_SECONDS;
                }
            }
            break;
        }
        
        // Restart mode stored as a single DWORD
        case SLQ_TT_TTYPE_RESTART:
        default:
            hr = E_INVALIDARG;
            break;
    }

    return hr;
}




//  
//  Open function. either opens an existing log query entry
//  or creates a new one
//
DWORD   
CSmLogQuery::Open ( const CString& rstrName, HKEY hKeyQuery, BOOL bReadOnly )
{
    DWORD   dwStatus = ERROR_SUCCESS;

    //open the subkey for this log query
    m_hKeyQuery = hKeyQuery;
    m_bReadOnly = bReadOnly;
    m_bIsModified = FALSE;

    MFC_TRY
        m_strName = rstrName;
        dwStatus = SyncWithRegistry();
    
    MFC_CATCH_DWSTATUS
    return dwStatus;
}

//
//  Close Function
//      closes registry handles and frees allocated memory
//      
DWORD   
CSmLogQuery::Close ()
{
    LOCALTRACE (L"Closing Query\n");

    KillString ( m_strPassword );

    m_strName.Empty();
    mr_strComment.Empty();
    mr_strCommentIndirect.Empty();
    mr_strBaseFileName.Empty();
    mr_strBaseFileNameIndirect.Empty();
    mr_strDefaultDirectory.Empty();
    mr_strSqlName.Empty();
    
    // close any open registry keys
    if (m_hKeyQuery != NULL) {
        RegCloseKey (m_hKeyQuery);
        m_hKeyQuery = NULL;
    }

    return ERROR_SUCCESS;
}

//  
//  ManualStart function. 
//      Sets the start mode to manual and starts the query.
//
DWORD   
CSmLogQuery::ManualStart ()
{
    DWORD           dwStatus = ERROR_SUCCESS;
    SLQ_TIME_INFO   slqTime;
    BOOL            bSetStopToMax;
    BOOL            bStarted = FALSE;
    DWORD           dwTimeout = 10;
    BOOL            bRegistryUpdated;

    memset (&slqTime, 0, sizeof(slqTime));
    slqTime.wTimeType = SLQ_TT_TTYPE_START;
    slqTime.wDataType = SLQ_TT_DTYPE_DATETIME;
    slqTime.dwAutoMode = SLQ_AUTO_MODE_NONE;
    slqTime.llDateTime = MIN_TIME_VALUE;

    SetLogTime ( &slqTime, SLQ_TT_TTYPE_START );

    // If stop time mode set to manual, or StopAt with time before Now,
    // set the mode to Manual, value to MAX_TIME_VALUE
    // For Size mode, just set the stop time to MAX_TIME_VALUE
    bSetStopToMax = FALSE;
    GetLogTime ( &slqTime, SLQ_TT_TTYPE_STOP );
    if ( SLQ_AUTO_MODE_NONE == slqTime.dwAutoMode 
        || SLQ_AUTO_MODE_SIZE == slqTime.dwAutoMode ) {
        bSetStopToMax = TRUE;
    } else if ( SLQ_AUTO_MODE_AT == slqTime.dwAutoMode ) {
        SYSTEMTIME      stLocalTime;
        FILETIME        ftLocalTime;
        LONGLONG        llLocalTime = 0;

        // get local time
        // Milliseconds set to 0 for Schedule times
        ftLocalTime.dwLowDateTime = ftLocalTime.dwHighDateTime = 0;
        GetLocalTime (&stLocalTime);
        stLocalTime.wMilliseconds = 0;
        SystemTimeToFileTime (&stLocalTime, &ftLocalTime);
        
        llLocalTime = *(LONGLONG*)&ftLocalTime;

        if ( llLocalTime >= slqTime.llDateTime ) {
            bSetStopToMax = TRUE;
        }    
    }

    if ( bSetStopToMax ) {    
        ASSERT( SLQ_TT_DTYPE_DATETIME == slqTime.wDataType );
        if ( SLQ_AUTO_MODE_SIZE != slqTime.dwAutoMode ) { 
            slqTime.dwAutoMode = SLQ_AUTO_MODE_NONE;
        }
        slqTime.llDateTime = MAX_TIME_VALUE;
        SetLogTime ( &slqTime, SLQ_TT_TTYPE_STOP );
    }

    // Service needs to distinguish between Running and Start Pending
    // at service startup, so always set state to start pending.
    SetState ( SLQ_QUERY_START_PENDING );
    
    dwStatus = UpdateServiceSchedule( bRegistryUpdated );
    
    if ( bRegistryUpdated ) { 

        while (--dwTimeout && !bStarted ) {    
            bStarted = IsRunning();
        }
    
        if ( !bStarted ) {
            dwStatus = SMCFG_START_TIMED_OUT;
        }
    }

    SyncPropPageSharedData();   // Sync the start time and stop auto mode

    return dwStatus;
}

//  
//  ManualStop function. 
//      
//      Clears the restart bit, sets the stop mode to manual and stops the query.
//
DWORD   
CSmLogQuery::ManualStop ( )
{
    DWORD           dwStatus = ERROR_SUCCESS;
    SLQ_TIME_INFO   slqTime;
    BOOL            bRegistryUpdated;

    if ( IsAutoRestart() ) {
        mr_dwAutoRestartMode = SLQ_AUTO_MODE_NONE;
    }

    memset (&slqTime, 0, sizeof(slqTime));
    slqTime.wTimeType = SLQ_TT_TTYPE_STOP;
    slqTime.wDataType = SLQ_TT_DTYPE_DATETIME;
    slqTime.dwAutoMode = SLQ_AUTO_MODE_NONE;
    slqTime.llDateTime = MIN_TIME_VALUE;

    SetLogTime ( &slqTime, SLQ_TT_TTYPE_STOP );

    // If start time mode set to manual, set the value to MAX_TIME_VALUE
    GetLogTime ( &slqTime, SLQ_TT_TTYPE_START );
    if ( SLQ_AUTO_MODE_NONE == slqTime.dwAutoMode ) {
        ASSERT( SLQ_TT_DTYPE_DATETIME == slqTime.wDataType );
        slqTime.llDateTime = MAX_TIME_VALUE;
        SetLogTime ( &slqTime, SLQ_TT_TTYPE_START );
    }
    
    dwStatus = UpdateServiceSchedule ( bRegistryUpdated );
    
    if ( bRegistryUpdated ) { 
        DWORD   dwTimeout = 25;
        BOOL    bStopped = FALSE;
        
        while ( dwTimeout-- && !bStopped ) {
            // IsRunning implements no delay if the current state is not
            // SLQ_QUERY_START_PENDING, so add a delay for the registry
            // change to be written.
            bStopped = !IsRunning();
            Sleep ( 200 );
        }
    
        if ( !bStopped ) {
            dwStatus = SMCFG_STOP_TIMED_OUT;
        }
    }

    SyncPropPageSharedData();   // Sync the start time and stop auto mode

    return dwStatus;
}

//  
//  SaveAs function. 
//      Saves the query properties as a System Monitor ActiveX object
//      in an HTML file.
//
DWORD   
CSmLogQuery::SaveAs ( const CString& rstrPathName )
{
    DWORD dwStatus = ERROR_SUCCESS;
    CString strNonConstPathName = rstrPathName;
    ResourceStateManager rsm;

    // Create a file.
    HANDLE hFile;
    hFile =  CreateFile (
                strNonConstPathName, 
                GENERIC_READ | GENERIC_WRITE,
                0,              // Not shared
                NULL,           // Security attributes
                CREATE_ALWAYS,  // The user has already decided to override any existing file.
                FILE_ATTRIBUTE_NORMAL,
                NULL );

    if ( INVALID_HANDLE_VALUE != hFile ) {
        // Save the current configuration to the file.
        DWORD   dwTempLength;
        BOOL    bStatus;
        WCHAR   szByteOrderMark[2];

        szByteOrderMark[0] = 0xFEFF;
        szByteOrderMark[1] = 0;
        bStatus = FileWrite ( hFile, szByteOrderMark, sizeof(WCHAR) );

        if ( bStatus ) {
            dwTempLength = lstrlen ( CGlobalString::m_cszHtmlFileHeader1 ) * sizeof(WCHAR);
            bStatus = FileWrite ( hFile, (void *)CGlobalString::m_cszHtmlFileHeader1, dwTempLength );
        }

        if ( bStatus ) {
            dwTempLength = lstrlen ( CGlobalString::m_cszHtmlFileHeader2 ) * sizeof(WCHAR);
            bStatus = FileWrite ( hFile, (void *)CGlobalString::m_cszHtmlFileHeader2, dwTempLength );
        }

        if ( bStatus ) {
            DWORD dwByteCount;
            LPWSTR  pszData = NULL;

            HRESULT hr = CopyToBuffer ( pszData, dwByteCount );
            
            if ( SUCCEEDED ( hr ) ) {
                ASSERT ( NULL != pszData );
                ASSERT ( 0 != dwByteCount );
                bStatus = FileWrite ( hFile, pszData, dwByteCount );
                delete [] pszData;
            } else {
                bStatus = FALSE;
            }
        }

        if ( bStatus ) {
            dwTempLength = lstrlen ( CGlobalString::m_cszHtmlFileFooter ) * sizeof(WCHAR);
            bStatus = FileWrite ( hFile, (void *)CGlobalString::m_cszHtmlFileFooter, dwTempLength );
        }

        bStatus = CloseHandle ( hFile );

    }
    
    return dwStatus;
}

DWORD
CSmLogQuery::UpdateService( BOOL& rbRegistryUpdated ) {

    DWORD dwStatus;

    rbRegistryUpdated = FALSE;

    dwStatus = UpdateRegistry();

    if ( ERROR_SUCCESS == dwStatus ) {
        rbRegistryUpdated = TRUE;
        dwStatus = m_pLogService->Synchronize();    
    }
    
    if ( ERROR_SUCCESS == dwStatus ) {
        m_bIsModified = TRUE;
    }

    return dwStatus;
}

//
//  UpdateServiceSchedule function.
//      copies the current schedule settings to the registry
//      and synchs the log service
//
DWORD
CSmLogQuery::UpdateServiceSchedule( BOOL& rbRegistryUpdated ) {

    LONG    dwStatus = ERROR_SUCCESS;
    
    rbRegistryUpdated = FALSE;

    if (!m_bReadOnly) {

        dwStatus = UpdateRegistryScheduleValues();

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = UpdateRegistryLastModified();
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            rbRegistryUpdated = TRUE;
            dwStatus = m_pLogService->Synchronize();    
        }
    
        if ( ERROR_SUCCESS == dwStatus ) {
            m_bIsModified = TRUE;
        }
    } else {
        dwStatus = ERROR_ACCESS_DENIED;
    }
    return dwStatus;
}

//
//  UpdateRegistryLastModified function.
//      Copies the current "last modified date" to the registry where 
//      it is read by the log service
//
DWORD   
CSmLogQuery::UpdateRegistryLastModified() 
{
    LONG    dwStatus = ERROR_SUCCESS;

    if (!m_bReadOnly) {
        SLQ_TIME_INFO   plqLastModified;
        FILETIME        ftModified;
        SYSTEMTIME      stLocalTime;

        RegFlushKey( m_hKeyQuery );

        ftModified.dwLowDateTime = ftModified.dwHighDateTime = 0;

        dwStatus = RegQueryInfoKey ( 
                    m_hKeyQuery,
                    NULL,           // Class buffer
                    NULL,           // Size of class buffer
                    NULL,           // Reserved
                    NULL,           // Subkey count
                    NULL,           // Length of longest subkey name
                    NULL,           // Longest subkey class
                    NULL,           // Value count
                    NULL,           // Length of longest value name
                    NULL,           // Length of longest value 
                    NULL,           // Security descriptor
                    &ftModified );
        if (ERROR_SUCCESS != dwStatus ) {
            // Get local time for last modified value, if the
            // registry doesn't return the last written time.
            GetLocalTime (&stLocalTime);
            SystemTimeToFileTime (&stLocalTime, &ftModified);
        }

        plqLastModified.wDataType = SLQ_TT_DTYPE_DATETIME;
        plqLastModified.wTimeType = SLQ_TT_TTYPE_LAST_MODIFIED;
        plqLastModified.dwAutoMode = SLQ_AUTO_MODE_NONE;    // not used.
        plqLastModified.llDateTime = *(LONGLONG *)&ftModified;

        dwStatus = WriteRegistrySlqTime (
            m_hKeyQuery, 
            IDS_REG_LAST_MODIFIED,
            &plqLastModified);
    } else {
        dwStatus = ERROR_ACCESS_DENIED;
    }

    return dwStatus;
}

//
//  UpdateRegistryScheduleValues function.
//      copies the current schedule settings to the registry where they
//      are read by the log service
//
DWORD   
CSmLogQuery::UpdateRegistryScheduleValues() 
{
    LONG    dwStatus = ERROR_SUCCESS;
    
    if (!m_bReadOnly) {

        // Stop and start times
    
        if ( ERROR_SUCCESS == dwStatus ) {
            ASSERT (mr_stiStart.wTimeType == SLQ_TT_TTYPE_START);
            dwStatus = WriteRegistrySlqTime (
                m_hKeyQuery, 
                IDS_REG_START_TIME,
                &mr_stiStart);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            ASSERT (mr_stiStop.wTimeType == SLQ_TT_TTYPE_STOP);
            dwStatus = WriteRegistrySlqTime (
                m_hKeyQuery, 
                IDS_REG_STOP_TIME,
                &mr_stiStop);
        }

        // Auto restart value is "immediately on log file close" only.
        // Use binary for future enhancements.
        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = WriteRegistryDwordValue (
                m_hKeyQuery, 
                IDS_REG_RESTART,
                &mr_dwAutoRestartMode,
                REG_BINARY);
        }

        // Only write the state when requesting the service to
        // start a query.
        if ( SLQ_QUERY_START_PENDING == mr_dwCurrentState ) {

            dwStatus = WriteRegistryDwordValue (
                m_hKeyQuery, 
                IDS_REG_CURRENT_STATE,
                &mr_dwCurrentState);
        }

    } else {
        dwStatus = ERROR_ACCESS_DENIED;
    }

    return dwStatus;
}
//
//  UpdateRegistry function.
//      copies the current settings to the registry where they
//      are read by the log service
//
DWORD   
CSmLogQuery::UpdateRegistry() 
{
    LONG    dwStatus = ERROR_SUCCESS;
    DWORD   dwBufferSize = 0;
    DWORD   dwLogType;
	DWORD	dwLogFileType = 0;
    DWORD   dwTempFileSizeUnits;
    DWORD   dwTempDataStoreAttributes = 0;
    DWORD   dwTempMaxFileSize;
    DWORD   dwTempAppendMode;

    if ( IsModifiable() ) {
                
        if ( !mr_strComment.IsEmpty() ) {
            dwBufferSize = mr_strComment.GetLength() + 1;
            dwBufferSize *= sizeof(WCHAR);
        } else {
            dwBufferSize = 0;
        }

        dwStatus = WriteRegistryStringValue (
            m_hKeyQuery,
            IDS_REG_COMMENT,
            REG_SZ,
            (LPCWSTR)mr_strComment,
            &dwBufferSize);

        if ( ERROR_SUCCESS == dwStatus && !mr_strCommentIndirect.IsEmpty() ) {
            dwBufferSize = mr_strCommentIndirect.GetLength() + 1;
            dwBufferSize *= sizeof(WCHAR);

            dwStatus = WriteRegistryStringValue (
                m_hKeyQuery,
                IDS_REG_COMMENT_INDIRECT,
                REG_SZ,
                (LPCWSTR)mr_strCommentIndirect,
                &dwBufferSize);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwLogType = GetLogType();
            dwStatus = WriteRegistryDwordValue (
                m_hKeyQuery, 
                IDS_REG_LOG_TYPE,
                &dwLogType);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = WriteRegistryDwordValue (
                m_hKeyQuery, 
                IDS_REG_REALTIME_DATASOURCE,
                & mr_dwRealTimeQuery);
        }
        
        // Files

        if ( ERROR_SUCCESS == dwStatus ) {
            // Within the app, counter data store size units are in MB.
            // Translate to back to KB when write to registry
            dwTempFileSizeUnits = GetDataStoreSizeUnits();
            dwTempMaxFileSize = mr_dwMaxSize;
			GetLogFileType ( dwLogFileType );
            if ( SLQ_COUNTER_LOG == GetLogType()
                && SLF_SQL_LOG != dwLogFileType ) 
            {
                if ( ONE_MB == dwTempFileSizeUnits ) { 
                    dwTempFileSizeUnits = ONE_KB;
                    // Round up to next MB
                    if ( SLQ_DISK_MAX_SIZE != mr_dwMaxSize ) {
                        dwTempMaxFileSize *= dwTempFileSizeUnits;
                    }
                }
            }

            dwStatus = WriteRegistryDwordValue (
                m_hKeyQuery, 
                IDS_REG_LOG_FILE_MAX_SIZE,
                &dwTempMaxFileSize);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            // Data store size units
            if ( ONE_MB == dwTempFileSizeUnits ) {
                dwTempDataStoreAttributes = SLF_DATA_STORE_SIZE_ONE_MB;
            } else if ( ONE_KB == dwTempFileSizeUnits ) {
                dwTempDataStoreAttributes = SLF_DATA_STORE_SIZE_ONE_KB;
            } else if ( ONE_RECORD == dwTempFileSizeUnits ) {
                dwTempDataStoreAttributes = SLF_DATA_STORE_SIZE_ONE_RECORD;
            }

            // Data store append mode
            GetDataStoreAppendMode( dwTempAppendMode );
            dwTempDataStoreAttributes |= dwTempAppendMode;

            dwStatus = WriteRegistryDwordValue (
                m_hKeyQuery, 
                IDS_REG_DATA_STORE_ATTRIBUTES,
                &dwTempDataStoreAttributes);
        }

        if ( !mr_strBaseFileName.IsEmpty() ) {
            dwBufferSize = mr_strBaseFileName.GetLength() + 1;
            dwBufferSize *= sizeof(WCHAR);
        } else {
            dwBufferSize = 0;
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus  = WriteRegistryStringValue (
                m_hKeyQuery, 
                IDS_REG_LOG_FILE_BASE_NAME,
                REG_SZ,
                (LPCWSTR)mr_strBaseFileName, 
                &dwBufferSize);
        }

        if ( ERROR_SUCCESS == dwStatus && !mr_strBaseFileNameIndirect.IsEmpty() ) {
            dwBufferSize = mr_strBaseFileNameIndirect.GetLength() + 1;
            dwBufferSize *= sizeof(WCHAR);

            dwStatus  = WriteRegistryStringValue (
                m_hKeyQuery, 
                IDS_REG_LOG_FILE_BASE_NAME_IND,
                REG_SZ,
                (LPCWSTR)mr_strBaseFileNameIndirect, 
                &dwBufferSize);
        }

        if ( !mr_strSqlName.IsEmpty() ) {
            dwBufferSize = mr_strSqlName.GetLength() + 1;
            dwBufferSize *= sizeof(WCHAR);
        } else {
            dwBufferSize = 0;
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus  = WriteRegistryStringValue (
                m_hKeyQuery, 
                IDS_REG_SQL_LOG_BASE_NAME,
                REG_SZ,
                (LPCWSTR)mr_strSqlName, 
                &dwBufferSize);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = WriteRegistryDwordValue (
                        m_hKeyQuery, 
                        IDS_REG_LOG_FILE_SERIAL_NUMBER,
                        &mr_dwCurrentSerialNumber );
        }

        if ( !mr_strDefaultDirectory.IsEmpty() ) {
            dwBufferSize = mr_strDefaultDirectory.GetLength() + 1;
            dwBufferSize *= sizeof(WCHAR);
        } else {
            dwBufferSize = 0;
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus  = WriteRegistryStringValue (
                m_hKeyQuery,
                IDS_REG_LOG_FILE_FOLDER,
                REG_SZ,
                (LPCWSTR)mr_strDefaultDirectory,
                &dwBufferSize);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus  = WriteRegistryDwordValue (
                m_hKeyQuery, 
                IDS_REG_LOG_FILE_AUTO_FORMAT,
                &mr_dwLogAutoFormat);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus  = WriteRegistryDwordValue (
                m_hKeyQuery, 
                IDS_REG_LOG_FILE_TYPE,
                &mr_dwLogFileType);
        }

        // Schedule

        // Eof command is used for counter and trace logs only.
        if ( ERROR_SUCCESS == dwStatus ) {
            if ( SLQ_COUNTER_LOG == GetLogType()
                 || SLQ_TRACE_LOG == GetLogType() ) {
                dwBufferSize = mr_strEofCmdFile.GetLength() + 1;
                dwBufferSize *= sizeof(WCHAR);
                dwStatus  = WriteRegistryStringValue (
                    m_hKeyQuery,
                    IDS_REG_EOF_COMMAND_FILE,
                    REG_SZ,
                    (LPCWSTR)mr_strEofCmdFile,
                    &dwBufferSize);
            }
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = UpdateRegistryScheduleValues();
        }

        // This must be the last registry value updated.
        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = UpdateRegistryLastModified();
        }
    } else {
        dwStatus = ERROR_ACCESS_DENIED;
    }

    return dwStatus;
}

//
//  SyncSerialNumberWithRegistry()
//      reads the current value for the serial number 
//      from the registry and reloads the internal value 
//      to match
//  
DWORD   
CSmLogQuery::SyncSerialNumberWithRegistry()
{
    DWORD   dwStatus = ERROR_SUCCESS;

    ASSERT (m_hKeyQuery != NULL);

    // Get starting serial number for serial suffix.

    dwStatus = ReadRegistryDwordValue (
                m_hKeyQuery, 
                IDS_REG_LOG_FILE_SERIAL_NUMBER,
                DEFAULT_LOG_FILE_SERIAL_NUMBER, 
                &mr_dwCurrentSerialNumber );
    ASSERT (dwStatus == ERROR_SUCCESS);

    return dwStatus;
}

//
//  SyncWithRegistry()
//      reads the current values for this query from the registry
//      and reloads the internal values to match
//  
DWORD   
CSmLogQuery::SyncWithRegistry()
{
    DWORD   dwBufferSize = 0;
    DWORD   dwStatus = ERROR_SUCCESS;
    SLQ_TIME_INFO   stiDefault;
    WCHAR   szDefault[MAX_PATH + 1];
    LPWSTR  szTemp = NULL;
    DWORD   dwDefault;
    DWORD   dwTemp;
    LPWSTR  szIndTemp = NULL;
    UINT    uiBufferLen = 0;
    LPWSTR  szEofCmd = NULL;

    ResourceStateManager   rsm;

    ASSERT (m_hKeyQuery != NULL);
    
    MFC_TRY
        // Modify bit
        dwTemp = DEFAULT_EXECUTE_ONLY;
        dwStatus = ReadRegistryDwordValue (
                    m_hKeyQuery, 
                    IDS_REG_EXECUTE_ONLY,
                    DEFAULT_EXECUTE_ONLY, 
                    &dwTemp);
        ASSERT ( ERROR_SUCCESS == dwStatus );

        if ( 0 == dwTemp ) {
            m_bExecuteOnly = FALSE;
        } else {
            m_bExecuteOnly = TRUE;
        }

        // File attributes
    
        // Comment field can be indirect

        dwStatus = SmNoLocReadRegIndStrVal (
            m_hKeyQuery,
            IDS_REG_COMMENT, 
            DEFAULT_COMMENT,
            &szIndTemp,
            &uiBufferLen );

        mr_strComment.Empty();

        if ( NULL != szIndTemp ) {
            if ( L'\0' != *szIndTemp ) {
                mr_strComment = szIndTemp;
            }
        }

        if ( NULL != szIndTemp ) {
            G_FREE ( szIndTemp );
            szIndTemp = NULL;
        }
        uiBufferLen = 0;

        dwStatus = ReadRegistryDwordValue (
                    m_hKeyQuery, 
                    IDS_REG_LOG_FILE_MAX_SIZE,
                    DEFAULT_LOG_FILE_MAX_SIZE, 
                    &mr_dwMaxSize );

        ASSERT ( ERROR_SUCCESS == dwStatus );

        if ( SLQ_TRACE_LOG == GetLogType() ) {

            dwStatus = ReadRegistryDwordValue (
                        m_hKeyQuery, 
                        IDS_REG_LOG_FILE_TYPE,
                        DEFAULT_TRACE_LOG_FILE_TYPE, 
                        &mr_dwLogFileType);
            ASSERT ( ERROR_SUCCESS == dwStatus );

        } else {

            dwStatus = ReadRegistryDwordValue (
                        m_hKeyQuery, 
                        IDS_REG_LOG_FILE_TYPE,
                        DEFAULT_CTR_LOG_FILE_TYPE, 
                        &mr_dwLogFileType);
            ASSERT ( ERROR_SUCCESS == dwStatus );

        }

        // Data store attributes must be read after log file type and log file max size.

        dwDefault = 0;  // Eliminate PREFIX warning
        InitDataStoreAttributesDefault ( mr_dwLogFileType, dwDefault );

        dwStatus = ReadRegistryDwordValue (
                    m_hKeyQuery,
                    IDS_REG_DATA_STORE_ATTRIBUTES,
                    dwDefault, 
                    &dwTemp );
        
        ProcessLoadedDataStoreAttributes ( dwTemp );

        // Log file base name field can be indirect
        StringCchCopy ( ( LPWSTR)szDefault, MAX_PATH+1, m_strName );

        dwStatus = SmNoLocReadRegIndStrVal (
            m_hKeyQuery,
            IDS_REG_LOG_FILE_BASE_NAME, 
            szDefault,              // Default to query name
            &szIndTemp,
            &uiBufferLen );

        ASSERT ( ERROR_SUCCESS == dwStatus );

        mr_strBaseFileName.Empty();
        
        if ( NULL != szIndTemp ) {
            if ( L'\0' != *szIndTemp ) {
                ReplaceBlanksWithUnderscores ( szIndTemp );
                mr_strBaseFileName = szIndTemp;
            }
        }

        if ( NULL != szIndTemp ) {
            G_FREE ( szIndTemp );
            szIndTemp = NULL;
        }
        uiBufferLen = 0;

        dwStatus = ReadRegistryStringValue (
                    m_hKeyQuery,
                    IDS_REG_LOG_FILE_FOLDER,
                    m_pLogService->GetDefaultLogFileFolder(),
                    &szTemp,
                    &dwBufferSize);
        ASSERT ( ERROR_SUCCESS == dwStatus );
        mr_strDefaultDirectory.Empty();
        if ( NULL != szTemp ) {
            if ( dwBufferSize > sizeof(WCHAR) ) {
                if ( L'\0' != szTemp[0] ) {
                    mr_strDefaultDirectory = szTemp;
                }
            }

            delete [] szTemp;
            szTemp = NULL;
            dwBufferSize = 0;
        }

        // Default log set name to log name

        StringCchPrintf (
            szDefault, 
            MAX_PATH+1,
            L"SQL:!%s",
            m_strName.GetBuffer(0));

        dwStatus = ReadRegistryStringValue (
                    m_hKeyQuery,
                    IDS_REG_SQL_LOG_BASE_NAME,
                    szDefault,             
                    &szTemp,
                    &dwBufferSize);
        ASSERT ( ERROR_SUCCESS == dwStatus );
        mr_strSqlName.Empty();
        if ( dwBufferSize > sizeof(WCHAR) ) {
            ASSERT ( NULL != szTemp );
            ASSERT ( 0 != *szTemp );
            mr_strSqlName = szTemp;
        }

        delete [] szTemp;
        szTemp = NULL;
        dwBufferSize = 0;

        dwStatus = ReadRegistryDwordValue(
                    m_hKeyQuery, 
                    IDS_REG_REALTIME_DATASOURCE,
                    g_dwRealTimeQuery, 
                    & mr_dwRealTimeQuery);
        ASSERT ( ERROR_SUCCESS == dwStatus );

        dwStatus = ReadRegistryDwordValue (
                    m_hKeyQuery, 
                    IDS_REG_LOG_FILE_AUTO_FORMAT,
                    DEFAULT_LOG_FILE_AUTO_FORMAT, 
                    &mr_dwLogAutoFormat);
        ASSERT ( ERROR_SUCCESS == dwStatus );

        // Get starting serial number for serial suffix.
        dwStatus = SyncSerialNumberWithRegistry ();
        ASSERT ( ERROR_SUCCESS == dwStatus );

        dwStatus = ReadRegistryDwordValue (
                    m_hKeyQuery, 
                    IDS_REG_CURRENT_STATE,
                    DEFAULT_CURRENT_STATE, 
                    &mr_dwCurrentState);
        ASSERT ( ERROR_SUCCESS == dwStatus );

        //  Start, stop and restart values

        VERIFY ( GetDefaultLogTime (stiDefault, SLQ_TT_TTYPE_START ) );

        dwStatus = ReadRegistrySlqTime (
            m_hKeyQuery, IDS_REG_START_TIME,
            &stiDefault, &mr_stiStart);
        ASSERT ( ERROR_SUCCESS == dwStatus );
        ASSERT (mr_stiStart.wTimeType == SLQ_TT_TTYPE_START);

        VERIFY ( GetDefaultLogTime (stiDefault, SLQ_TT_TTYPE_STOP ) );

        dwStatus = ReadRegistrySlqTime (
            m_hKeyQuery, IDS_REG_STOP_TIME,
            &stiDefault, &mr_stiStop);
        ASSERT ( ERROR_SUCCESS == dwStatus );
        ASSERT (mr_stiStop.wTimeType == SLQ_TT_TTYPE_STOP);

        dwStatus = ReadRegistryDwordValue (
                    m_hKeyQuery, 
                    IDS_REG_RESTART,
                    DEFAULT_RESTART_VALUE, 
                    &mr_dwAutoRestartMode);
        ASSERT ( ERROR_SUCCESS == dwStatus );

        // Eof command is used by Counter and Trace logs only.
        if ( SLQ_COUNTER_LOG == GetLogType()
             || SLQ_TRACE_LOG == GetLogType() ) {

            dwStatus = ReadRegistryStringValue (
                m_hKeyQuery,
                IDS_REG_EOF_COMMAND_FILE,
                DEFAULT_EOF_COMMAND_FILE,
                &szEofCmd,
                &dwBufferSize);
            ASSERT ( ERROR_SUCCESS == dwStatus );
            if (dwBufferSize > sizeof(WCHAR)) {
                mr_strEofCmdFile = szEofCmd;
            } else {
                mr_strEofCmdFile.Empty();
            }
        }

    MFC_CATCH_DWSTATUS;
    if ( NULL != szTemp ) {
        delete [] szTemp;
    }

    if ( NULL != szIndTemp ) {
        G_FREE ( szIndTemp );
    }

    if ( NULL != szEofCmd ) {
        delete [] szEofCmd;
    }
    SyncPropPageSharedData();

    return dwStatus;
}
    
CSmLogService*    
CSmLogQuery::GetLogService ( void )
{
    return m_pLogService;
}

DWORD
CSmLogQuery::GetMachineDisplayName ( CString& rstrMachineName )
{
    DWORD   dwStatus = ERROR_SUCCESS;

    // rstrMachineName is writable.  CString copy-on-write 
    // semantics will support a writable string created from read-only.
    // A new string data buffer is allocated the first time that
    // it is modified.

    MFC_TRY
        rstrMachineName = m_pLogService->GetMachineDisplayName();
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

//
//  Get log file type and return as a string
//
//
const CString&
CSmLogQuery::GetLogFileType( void )
{
    int     nStringIdx;

    ResourceStateManager    rsm;

    m_strLogFileType.Empty();

    switch (LOWORD(mr_dwLogFileType)) {
        case SLF_CSV_FILE:
            nStringIdx = IDS_FT_CSV;
            break;
            
        case SLF_TSV_FILE:
            nStringIdx = IDS_FT_TSV;
            break;
            
        case SLF_BIN_FILE:
            nStringIdx = IDS_FT_BINARY;
            break;

        case SLF_BIN_CIRC_FILE:
            nStringIdx = IDS_FT_BINARY_CIRCULAR;
            break;

        case SLF_SEQ_TRACE_FILE:
            nStringIdx = IDS_FT_SEQUENTIAL_TRACE;
            break;

        case SLF_CIRC_TRACE_FILE:
            nStringIdx = IDS_FT_CIRCULAR_TRACE;
            break;

        case SLF_SQL_LOG:
            nStringIdx = IDS_FT_SQL;
            break;

        default:
            nStringIdx = IDS_FT_UNKNOWN;
            break;
    }

    MFC_TRY
        m_strLogFileType.LoadString ( nStringIdx );
    MFC_CATCH_MINIMUM
    
    return m_strLogFileType;
}

void
CSmLogQuery::GetLogFileType ( DWORD& rdwFileType )
{
    rdwFileType = LOWORD(mr_dwLogFileType);
    return;
}

void
CSmLogQuery::GetDataStoreAppendMode(DWORD &rdwAppend)
{
    rdwAppend = mr_dwAppendMode;

    return;
}

void
CSmLogQuery::SetDataStoreAppendMode(DWORD dwAppend)
{
    mr_dwAppendMode = dwAppend;

    return;
}
//
//  Get log file name currently in use
//
//
const CString&
CSmLogQuery::GetLogFileName ( BOOL bLatestRunning )
{
    HRESULT hr = NOERROR;
    PPDH_PLA_INFO  pInfo = NULL;
    DWORD dwStrBufLen = 0;
    DWORD dwFlags = 0;
    CString strMachineName;

    m_strFileName.Empty();

    MFC_TRY
        strMachineName = m_pLogService->GetMachineName();
    MFC_CATCH_HR;

    // Todo:  dwStatus or hr?

    if ( SUCCEEDED ( hr ) ) {
        if ( bLatestRunning ) {
            dwFlags = PLA_FILENAME_CURRENTLOG;  // Latest running log
        }

        hr = PdhPlaGetLogFileName (
                (LPWSTR)(LPCWSTR)GetLogName(),
                (LPWSTR)(LPCWSTR)strMachineName,
                NULL,  
                dwFlags,
                &dwStrBufLen,
                NULL );

        if ( SUCCEEDED ( hr ) || PDH_INSUFFICIENT_BUFFER == (PDH_STATUS)hr ) {
            if ( bLatestRunning ) {
                dwFlags = PLA_FILENAME_CURRENTLOG;  // Latest running log
            }
            hr = PdhPlaGetLogFileName (
                    (LPWSTR)(LPCWSTR)GetLogName(),
                    (LPWSTR)(LPCWSTR)strMachineName,
                    NULL,
                    dwFlags,
                    &dwStrBufLen,
                    m_strFileName.GetBufferSetLength ( dwStrBufLen ) );
            m_strFileName.ReleaseBuffer();
        }
    }

    SetLastError ( hr );

    return m_strFileName;
}

//
//  Get log file name currently in use
//
//
DWORD
CSmLogQuery::GetLogFileName ( CString& rstrLogFileName )
{
    DWORD   dwStatus = ERROR_SUCCESS;

    MFC_TRY
        rstrLogFileName = GetLogFileName();
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD 
CSmLogQuery::GetLogType ( void )
{
    // Subclass must override
    ASSERT ( FALSE ); 

    return ((DWORD)-1);
}

BOOL    
CSmLogQuery::SetLogFileType ( const DWORD dwType )
{
    DWORD dwLogFileType = LOWORD(dwType);
    if (dwLogFileType < (SLF_FIRST_FILE_TYPE + SLF_NUM_FILE_TYPES)) {
        mr_dwLogFileType = dwLogFileType;
        return TRUE;
    } else {
        return FALSE;
    }
}

const CString&
CSmLogQuery::GetLogName()
{
    return m_strName;
}

DWORD
CSmLogQuery::GetLogName ( CString& rstrLogName )
{
    DWORD   dwStatus = ERROR_SUCCESS;

    MFC_TRY
        rstrLogName = GetLogName();
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD    
CSmLogQuery::SetLogName ( const CString& rstrLogName )
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        m_strName = rstrLogName;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

const CString&
CSmLogQuery::GetLogKeyName()
{
    return mr_strLogKeyName;
}

DWORD
CSmLogQuery::GetLogKeyName ( CString& rstrLogKeyName )
{
    DWORD   dwStatus = ERROR_SUCCESS;

    MFC_TRY
        rstrLogKeyName = GetLogKeyName();
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD    
CSmLogQuery::SetLogKeyName ( const CString& rstrLogKeyName )
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        mr_strLogKeyName = rstrLogKeyName;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD    
CSmLogQuery::GetEofCommand ( CString& rstrCmdString)
{
    DWORD   dwStatus = ERROR_SUCCESS;

    MFC_TRY
        rstrCmdString = mr_strEofCmdFile;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}
                
DWORD  
CSmLogQuery::SetEofCommand ( const CString& rstrCmdString )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        mr_strEofCmdFile = rstrCmdString;
    MFC_CATCH_DWSTATUS
    
    return dwStatus;
}

const CString& 
CSmLogQuery::GetLogComment()
{
    return mr_strComment;
}

DWORD
CSmLogQuery::GetLogComment ( CString& rstrLogComment )
{
    DWORD   dwStatus = ERROR_SUCCESS;

    MFC_TRY
        rstrLogComment = GetLogComment();
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD    
CSmLogQuery::SetLogComment ( const CString& rstrComment )
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        mr_strComment = rstrComment;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD    
CSmLogQuery::SetLogCommentIndirect ( const CString& rstrComment )
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        mr_strCommentIndirect = rstrComment;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD   
CSmLogQuery::SetLogFileName ( const CString& rstrFileName )
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        mr_strBaseFileName = rstrFileName;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD   
CSmLogQuery::SetLogFileNameIndirect ( const CString& rstrFileName )
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        mr_strBaseFileNameIndirect = rstrFileName;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD   
CSmLogQuery::SetFileNameParts ( const CString& rstrFolder, const CString& rstrName )
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        mr_strDefaultDirectory = rstrFolder;
        mr_strBaseFileName = rstrName;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD   
CSmLogQuery::GetMaxSize()
{
    return mr_dwMaxSize;
}

BOOL    
CSmLogQuery::SetMaxSize ( const DWORD dwMaxSize )
{
    mr_dwMaxSize = dwMaxSize;
    return TRUE;
}

HKEY   
CSmLogQuery::GetQueryKey ( void )
{
    return m_hKeyQuery;
}

const CString&
CSmLogQuery::GetSqlName()
{
    return mr_strSqlName;
}

DWORD
CSmLogQuery::GetSqlName ( CString& rstrSqlName )
{
    DWORD   dwStatus = ERROR_SUCCESS;

    MFC_TRY
        rstrSqlName = GetSqlName();
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD    
CSmLogQuery::SetSqlName ( const CString& rstrSqlName )
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        mr_strSqlName = rstrSqlName;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

//
//  return: 1 if the log is currently active or
//          0 if the log is not running
//
BOOL    
CSmLogQuery::IsRunning()
{
    DWORD   dwCurrentState = SLQ_QUERY_START_PENDING;
    DWORD   dwTimeout = 20;
    
    while (--dwTimeout) {
        dwCurrentState = GetState();
        if ( SLQ_QUERY_START_PENDING == dwCurrentState ) {
            Sleep(100);
        } else {
            break;
        }
    }
        
    return ( SLQ_QUERY_RUNNING == dwCurrentState );
}

BOOL    
CSmLogQuery::IsAutoStart()
{
    return ( SLQ_AUTO_MODE_NONE != mr_stiStart.dwAutoMode );
}

BOOL    
CSmLogQuery::IsAutoRestart()
{
    return ( SLQ_AUTO_MODE_AFTER == mr_dwAutoRestartMode );
}

DWORD   
CSmLogQuery::GetFileNameParts( CString& rstrFolder, CString& rstrName)
{
    DWORD dwStatus = ERROR_SUCCESS;

    MFC_TRY
        rstrFolder = mr_strDefaultDirectory;
        rstrName = mr_strBaseFileName;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD   
CSmLogQuery::GetFileNameAutoFormat()
{
    return mr_dwLogAutoFormat;
}

BOOL    
CSmLogQuery::SetFileNameAutoFormat ( const DWORD dwFileSuffix )
{
    if ((dwFileSuffix < ( SLF_NAME_FIRST_AUTO + SLF_NUM_AUTO_NAME_TYPES)) ||
        (dwFileSuffix == SLF_NAME_NONE)) {
        mr_dwLogAutoFormat = dwFileSuffix;
        return TRUE;
    }

    return FALSE;
}

DWORD   
CSmLogQuery::GetFileSerialNumber( void )
{
    SyncSerialNumberWithRegistry();
    return mr_dwCurrentSerialNumber;
}

BOOL    
CSmLogQuery::SetFileSerialNumber ( const DWORD dwSerial )
{
    mr_dwCurrentSerialNumber = dwSerial;
    return TRUE;
}


DWORD   
CSmLogQuery::GetState()
{
    DWORD dwCurrentState = SLQ_QUERY_STOPPED;

    // If the service is running, get the value from the registry.
    if ( m_pLogService->IsRunning() ) {

        DWORD dwStatus;
        dwStatus = ReadRegistryDwordValue (
                    m_hKeyQuery, 
                    IDS_REG_CURRENT_STATE,
                    SLQ_QUERY_STOPPED, 
                    &mr_dwCurrentState);
        ASSERT (dwStatus == ERROR_SUCCESS);
        dwCurrentState = mr_dwCurrentState;

    }

    return dwCurrentState;
}
  
      
BOOL    
CSmLogQuery::SetState ( const DWORD dwNewState )
{
    // Only use this to set the start state.  This is necessary
    // so that the service, at service startup, can differentiate
    // between previously running queries and newly requested query starts.
    ASSERT ( SLQ_QUERY_START_PENDING == dwNewState );

    // Set the local variable if it is different.
    if ( mr_dwCurrentState != dwNewState ) {
        mr_dwCurrentState = dwNewState;
    }
    return TRUE;
}


BOOL    
CSmLogQuery::GetLogTime(PSLQ_TIME_INFO pTimeInfo, DWORD dwFlags)
{
    switch (dwFlags) {
        case SLQ_TT_TTYPE_START:
            *pTimeInfo = mr_stiStart;
            return TRUE;

        case SLQ_TT_TTYPE_STOP:
            *pTimeInfo = mr_stiStop;
            return TRUE;

        case SLQ_TT_TTYPE_RESTART:
            pTimeInfo->wTimeType = SLQ_TT_TTYPE_RESTART;
            pTimeInfo->dwAutoMode = mr_dwAutoRestartMode;
            pTimeInfo->wDataType = SLQ_TT_DTYPE_UNITS;      // not used
            pTimeInfo->dwUnitType = SLQ_TT_UTYPE_MINUTES;   // not used
            pTimeInfo->dwValue = 0;                         // not used
            return TRUE;
            
        case SLQ_TT_TTYPE_SAMPLE:
            *pTimeInfo = mr_stiSampleInterval;
            return TRUE;

        default:
            return FALSE;
    }
}
        
BOOL    
CSmLogQuery::SetLogTime(PSLQ_TIME_INFO pTimeInfo, const DWORD dwFlags)
{
    ASSERT (pTimeInfo->wTimeType == dwFlags);

    switch (dwFlags) {
        case SLQ_TT_TTYPE_START:
            mr_stiStart = *pTimeInfo ;
            return TRUE;

        case SLQ_TT_TTYPE_STOP:
            mr_stiStop = *pTimeInfo;
            return TRUE;

        case SLQ_TT_TTYPE_RESTART:
            mr_dwAutoRestartMode = pTimeInfo->dwAutoMode;
            return TRUE;

        case SLQ_TT_TTYPE_SAMPLE:
            mr_stiSampleInterval = *pTimeInfo;
            return TRUE;
            
        default:
            return FALSE;
    }
}

BOOL    
CSmLogQuery::GetDefaultLogTime(SLQ_TIME_INFO& /*rTimeInfo*/, DWORD /*dwFlags*/)
{
    // Subclass must override
    ASSERT( FALSE );
    return FALSE;
}

void    
CSmLogQuery::SyncPropPageSharedData ( void )
{
    // Sync the data shared between property pages
    // from registry values.
    MFC_TRY
        m_PropData.dwMaxFileSize = mr_dwMaxSize;
        m_PropData.dwLogFileType = LOWORD(mr_dwLogFileType);
        m_PropData.strFolderName = mr_strDefaultDirectory;

        m_PropData.strFileBaseName  = mr_strBaseFileName;
        m_PropData.strSqlName       = mr_strSqlName;
        m_PropData.dwSuffix         = mr_dwLogAutoFormat;
        SyncSerialNumberWithRegistry();
        m_PropData.dwSerialNumber   = mr_dwCurrentSerialNumber;
        m_PropData.stiStartTime     = mr_stiStart;
        m_PropData.stiStopTime      = mr_stiStop;
        m_PropData.stiSampleTime    = mr_stiSampleInterval;
    MFC_CATCH_MINIMUM
    // Todo:  Return and use status
}

void    
CSmLogQuery::UpdatePropPageSharedData ( void )
{
    // Update the registry values for data shared between property pages.
    // Note: This is called by the property page OnApply code.  It is assumed
    // that OnApply is called for all property pages, so the shared data is valid.

    // This method handles the problem where default Start mode and time was
    // written to the registry by the counter page OnApply before the 
    // schedule page OnApply modified the value.
    MFC_TRY
        mr_dwMaxSize                = m_PropData.dwMaxFileSize;   
        mr_dwLogFileType            = m_PropData.dwLogFileType; 

        mr_dwLogAutoFormat          = m_PropData.dwSuffix;       
        mr_dwCurrentSerialNumber    = m_PropData.dwSerialNumber; 
        mr_stiStart                 = m_PropData.stiStartTime;   
        mr_stiStop                  = m_PropData.stiStopTime;   
        mr_stiSampleInterval        = m_PropData.stiSampleTime;   

        mr_strBaseFileName          = m_PropData.strFileBaseName;
        mr_strDefaultDirectory      = m_PropData.strFolderName;
        mr_strSqlName               = m_PropData.strSqlName;
    MFC_CATCH_MINIMUM
    // Todo:  Return and use status
}

BOOL    
CSmLogQuery::GetPropPageSharedData (PSLQ_PROP_PAGE_SHARED pData)
{
    BOOL bReturn = FALSE;

    if ( NULL != pData ) {
        MFC_TRY
            pData->dwLogFileType    = m_PropData.dwLogFileType;
            pData->dwMaxFileSize    = m_PropData.dwMaxFileSize;
            pData->strFileBaseName  = m_PropData.strFileBaseName;
            pData->strFolderName    = m_PropData.strFolderName;
            pData->strSqlName       = m_PropData.strSqlName;
            pData->dwLogFileType    = m_PropData.dwLogFileType;
            pData->dwSuffix         = m_PropData.dwSuffix;
            pData->dwSerialNumber   = m_PropData.dwSerialNumber;
            pData->stiStartTime     = m_PropData.stiStartTime;
            pData->stiStopTime      = m_PropData.stiStopTime;
            pData->stiSampleTime    = m_PropData.stiSampleTime;
            bReturn = TRUE;
        MFC_CATCH_MINIMUM
    } 
    // Todo:  Return and use status
    return bReturn;
}

BOOL    
CSmLogQuery::SetPropPageSharedData (PSLQ_PROP_PAGE_SHARED pData)
{
    BOOL bReturn = FALSE;

    if ( NULL != pData ) {
        MFC_TRY
            m_PropData.dwLogFileType    = pData->dwLogFileType;
            m_PropData.dwMaxFileSize    = pData->dwMaxFileSize;
            m_PropData.strFileBaseName  = pData->strFileBaseName;
            m_PropData.strFolderName    = pData->strFolderName;
            m_PropData.strSqlName       = pData->strSqlName;
            m_PropData.dwLogFileType    = pData->dwLogFileType;
            m_PropData.dwSuffix         = pData->dwSuffix;
            m_PropData.dwSerialNumber   = pData->dwSerialNumber;
            m_PropData.stiStartTime     = pData->stiStartTime;
            m_PropData.stiStopTime      = pData->stiStopTime;
            m_PropData.stiSampleTime    = pData->stiSampleTime;
        MFC_CATCH_MINIMUM
    } 
    // Todo:  Return and use status
    return bReturn;
}

void
CSmLogQuery::InitDataStoreAttributesDefault (
    const	DWORD   dwRegLogFileType,
			DWORD&  rdwDefault )
{
    DWORD   dwBeta1AppendFlags;
	DWORD   dwLogFileType;

    // Append vs. Overwrite
    // Win2000 files defaulted to OVERWRITE. 
    // The Append mode flags did not exist.
    // Convert the settings to use new flags.
    // Whistler Beta 1 append mode was stored in high word of log file type

    dwBeta1AppendFlags = dwRegLogFileType & 0x00FF0000;
    rdwDefault = 0;

	GetLogFileType ( dwLogFileType );

    if ( SLF_FILE_APPEND == dwBeta1AppendFlags ) {
        mr_dwAppendMode = SLF_DATA_STORE_APPEND;
        rdwDefault = SLF_DATA_STORE_APPEND;
    } else if ( SLF_FILE_OVERWRITE == dwBeta1AppendFlags ) {
        mr_dwAppendMode = SLF_DATA_STORE_OVERWRITE;
        rdwDefault = SLF_DATA_STORE_OVERWRITE;
    } else if ( 0 == dwBeta1AppendFlags ) {
        if ( SLF_SQL_LOG == dwLogFileType ) {
            mr_dwAppendMode = SLF_DATA_STORE_APPEND;
        } else {
            // Default for Win2K is overwrite.
            // For Whistler, mode is stored in Data Store Attributes
            mr_dwAppendMode = SLF_DATA_STORE_OVERWRITE;
        }
    }

    // Append vs. overwrite flag

    if ( 0 == rdwDefault ) {
        if ( SLF_BIN_FILE == dwLogFileType
                || SLF_SEQ_TRACE_FILE == dwLogFileType
                || SLF_SQL_LOG == dwLogFileType )
        {
            rdwDefault = SLF_DATA_STORE_APPEND;
        } else {
            rdwDefault = SLF_DATA_STORE_OVERWRITE;
        }
    }

    // File size units flag

    if ( SLQ_COUNTER_LOG == GetLogType() ) {
        if ( SLF_SQL_LOG != dwLogFileType ) {
            rdwDefault |= SLF_DATA_STORE_SIZE_ONE_KB;
        } else {
            rdwDefault |= SLF_DATA_STORE_SIZE_ONE_RECORD;
        }
    } else if ( SLQ_TRACE_LOG == GetLogType() ){
        rdwDefault |= SLF_DATA_STORE_SIZE_ONE_MB;
    }
}

void
CSmLogQuery::ProcessLoadedDataStoreAttributes (
    DWORD   dwDataStoreAttributes )
{
	DWORD	dwLogFileType = 0;
    
    if ( dwDataStoreAttributes & SLF_DATA_STORE_SIZE_ONE_MB ) {
        mr_dwFileSizeUnits = ONE_MB;
    } else if ( dwDataStoreAttributes & SLF_DATA_STORE_SIZE_ONE_KB ) {
        mr_dwFileSizeUnits = ONE_KB;
    } else if ( dwDataStoreAttributes & SLF_DATA_STORE_SIZE_ONE_RECORD ) {
        mr_dwFileSizeUnits = ONE_RECORD;
    }
    // Within the app, counter data store size units are in MB.
    // Translate to MB here, back to KB when write to registry.
	GetLogFileType( dwLogFileType );

    if ( SLQ_COUNTER_LOG == GetLogType()
        && SLF_SQL_LOG != dwLogFileType ) 
    {
        ASSERT ( ONE_KB == GetDataStoreSizeUnits() );
        if ( ONE_KB == GetDataStoreSizeUnits() ) { 
            mr_dwFileSizeUnits = ONE_MB;
            if ( SLQ_DISK_MAX_SIZE != mr_dwMaxSize ) {
                // Round up to next MB
                mr_dwMaxSize = ( mr_dwMaxSize + (ONE_KB - 1) ) / ONE_KB;
            }
        }
    }

    // Data store append mode

    ASSERT ( dwDataStoreAttributes & SLF_DATA_STORE_APPEND_MASK );
    // Todo:  Does defalt value setting overwrite the Whistler Beta 1 setting?

    if ( dwDataStoreAttributes & SLF_DATA_STORE_APPEND ) {
        mr_dwAppendMode = SLF_DATA_STORE_APPEND;
    } else if ( dwDataStoreAttributes & SLF_DATA_STORE_OVERWRITE ) {
        mr_dwAppendMode = SLF_DATA_STORE_OVERWRITE;
    }
}

HRESULT 
CSmLogQuery::LoadFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog* pIErrorLog )
{
    HRESULT hr = S_OK;
    DWORD   cchBufLen;    
    SLQ_TIME_INFO   stiDefault;
    LPWSTR  pszTemp = NULL;
    DWORD   dwTemp;
    DWORD   dwDefault;
    WCHAR   szDefault[MAX_PATH + 1];
    LPWSTR  szEofCmd = NULL;

    // Subclass must call this method at the end of their override, to sync the 
    // property page shared data.

    // Continue even if error, using defaults for missing values.
    mr_strComment.Empty();
    cchBufLen = 0;
    hr = StringFromPropertyBag ( 
            pPropBag, 
            pIErrorLog, 
            IDS_HTML_COMMENT, 
            DEFAULT_COMMENT, 
            &pszTemp, 
            &cchBufLen );
    // 1 for Null
    if ( NULL != pszTemp && cchBufLen > 1 ) {
        if ( L'\0'!= pszTemp[0] ) {
            mr_strComment = pszTemp;
        }
        delete [] pszTemp;
        pszTemp = NULL;
    }

    StringCchCopy ( ( LPWSTR)szDefault, MAX_PATH+1, m_strName );
    ReplaceBlanksWithUnderscores ( szDefault );
    
    mr_strBaseFileName.Empty();
    cchBufLen = 0;
    hr = StringFromPropertyBag ( 
        pPropBag, 
        pIErrorLog, 
        IDS_HTML_LOG_FILE_BASE_NAME, 
        szDefault, 
        &pszTemp, 
        &cchBufLen );
    if ( 1 < cchBufLen ) {
        ASSERT ( NULL != pszTemp );
        ASSERT ( 0 != *pszTemp );
        mr_strBaseFileName = pszTemp;
    }
    delete [] pszTemp;
    pszTemp = NULL;

    mr_strDefaultDirectory.Empty();
    cchBufLen = 0;    
    hr = StringFromPropertyBag ( 
            pPropBag, 
            pIErrorLog, 
            IDS_HTML_LOG_FILE_FOLDER, 
            m_pLogService->GetDefaultLogFileFolder(), 
            &pszTemp, 
            &cchBufLen );

    if ( 1 < cchBufLen ) {
        ASSERT ( NULL != pszTemp );
        ASSERT ( 0 != *pszTemp );
        mr_strDefaultDirectory = pszTemp;
    }
    delete [] pszTemp;
    pszTemp = NULL;    

    mr_strSqlName.Empty();
    cchBufLen = 0;
    hr = StringFromPropertyBag ( 
            pPropBag, 
            pIErrorLog, 
            IDS_HTML_SQL_LOG_BASE_NAME, 
            DEFAULT_SQL_LOG_BASE_NAME, 
            &pszTemp, 
            &cchBufLen );
    if ( 1 < cchBufLen ) {
        ASSERT ( NULL != pszTemp );
        ASSERT ( 0 != *pszTemp );
        mr_strSqlName = pszTemp;
    }
    delete [] pszTemp;
    pszTemp = NULL;


    hr = DwordFromPropertyBag ( pPropBag, pIErrorLog, IDS_HTML_REALTIME_DATASOURCE, g_dwRealTimeQuery, mr_dwRealTimeQuery );
    
    hr = DwordFromPropertyBag ( pPropBag, pIErrorLog, IDS_HTML_LOG_FILE_MAX_SIZE, DEFAULT_LOG_FILE_MAX_SIZE, mr_dwMaxSize );

    if ( SLQ_COUNTER_LOG == GetLogType() ) {
        hr = DwordFromPropertyBag ( pPropBag, pIErrorLog, IDS_HTML_LOG_FILE_TYPE, DEFAULT_CTR_LOG_FILE_TYPE, dwTemp );
    } else {
        // Read only for counter and trace logs, not for alerts?
        hr = DwordFromPropertyBag ( pPropBag, pIErrorLog, IDS_HTML_LOG_FILE_TYPE, DEFAULT_TRACE_LOG_FILE_TYPE, dwTemp );
    }

    SetLogFileType ( dwTemp );

    // Data store attributes must be read after log file type and log file max size.
    InitDataStoreAttributesDefault ( dwTemp, dwDefault );

    // If file size unit value is missing, default to Win2000 values
    hr = DwordFromPropertyBag ( pPropBag, pIErrorLog, IDS_HTML_DATA_STORE_ATTRIBUTES, dwDefault, dwTemp );

    ProcessLoadedDataStoreAttributes ( dwTemp );

    hr = DwordFromPropertyBag ( pPropBag, pIErrorLog, IDS_HTML_LOG_FILE_AUTO_FORMAT, DEFAULT_LOG_FILE_AUTO_FORMAT, mr_dwLogAutoFormat );
    hr = DwordFromPropertyBag ( pPropBag, pIErrorLog, IDS_HTML_LOG_FILE_SERIAL_NUMBER, DEFAULT_LOG_FILE_SERIAL_NUMBER, mr_dwCurrentSerialNumber );
    
    // Do not load "Current State", since a new query is always stopped when created.
    
    // Start and Stop values.
    VERIFY ( GetDefaultLogTime (stiDefault, SLQ_TT_TTYPE_START ) );
    hr = SlqTimeFromPropertyBag ( pPropBag, pIErrorLog, SLQ_TT_TTYPE_START, &stiDefault, &mr_stiStart );
    VERIFY ( GetDefaultLogTime (stiDefault, SLQ_TT_TTYPE_STOP ) );
    hr = SlqTimeFromPropertyBag ( pPropBag, pIErrorLog, SLQ_TT_TTYPE_STOP, &stiDefault, &mr_stiStop );
    hr = DwordFromPropertyBag ( pPropBag, pIErrorLog, IDS_HTML_RESTART_MODE,  DEFAULT_RESTART_VALUE, mr_dwAutoRestartMode);
        
    // Eof command file for counter and trace logs only.
    if ( SLQ_COUNTER_LOG == GetLogType()
         || SLQ_TRACE_LOG == GetLogType() ) {
        
        mr_strEofCmdFile.Empty();
        cchBufLen = 0;

        hr = StringFromPropertyBag ( 
                pPropBag, 
                pIErrorLog, 
                IDS_HTML_EOF_COMMAND_FILE, 
                DEFAULT_EOF_COMMAND_FILE, 
                &szEofCmd, 
                &cchBufLen );

        if ( 1 < cchBufLen ) {
            ASSERT ( NULL != szEofCmd );
            MFC_TRY
                mr_strEofCmdFile = szEofCmd;
            MFC_CATCH_MINIMUM
        }
        
        if ( NULL != szEofCmd ) {
            delete [] szEofCmd;
        }
    }

    SyncPropPageSharedData();

    return hr;
}

HRESULT
CSmLogQuery::SaveToPropertyBag (
    IPropertyBag* pPropBag,
    BOOL /* fSaveAllProps */ )
{
    HRESULT hr = NOERROR;
    SMONCTRL_VERSION_DATA VersData;
    DWORD   dwTemp;
    DWORD   dwTempFileSizeUnits;
    DWORD   dwTempDataStoreAttributes = 0;
    DWORD   dwTempMaxFileSize;
    DWORD   dwTempAppendMode;
	DWORD	dwLogFileType = 0;

    VersData.iMajor = SMONCTRL_MAJ_VERSION;
    VersData.iMinor = SMONCTRL_MIN_VERSION;

    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_SYSMON_VERSION, VersData.dwVersion );
    
    if ( SLQ_ALERT == GetLogType() ) {
        hr = StringToPropertyBag ( pPropBag, IDS_HTML_ALERT_NAME, m_strName );
    } else {
        hr = StringToPropertyBag ( pPropBag, IDS_HTML_LOG_NAME, m_strName );
    }
    hr = StringToPropertyBag ( pPropBag, IDS_HTML_COMMENT, mr_strComment );
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_LOG_TYPE, GetLogType() );
    // Save current state. It can be used to determine the validity of the logfilename.
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_CURRENT_STATE, mr_dwCurrentState );

    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_REALTIME_DATASOURCE, mr_dwRealTimeQuery );
    
    // Within the app, counter data store size units are in MB.
    // Translate to back to KB when write to registry
    dwTempFileSizeUnits = GetDataStoreSizeUnits();
    dwTempMaxFileSize = mr_dwMaxSize;
	GetLogFileType ( dwLogFileType );
    if ( SLQ_COUNTER_LOG == GetLogType()
        && SLF_SQL_LOG != dwLogFileType ) 
    {
        if ( ONE_MB == dwTempFileSizeUnits ) { 
            dwTempFileSizeUnits = ONE_KB;
            // Round up to next MB
            if ( SLQ_DISK_MAX_SIZE != mr_dwMaxSize ) {
                dwTempMaxFileSize *= dwTempFileSizeUnits;
            }
        }
    }

    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_LOG_FILE_MAX_SIZE, dwTempMaxFileSize );

    // Data store size units
    if ( ONE_MB == dwTempFileSizeUnits ) {
        dwTempDataStoreAttributes = SLF_DATA_STORE_SIZE_ONE_MB;
    } else if ( ONE_KB == dwTempFileSizeUnits ) {
        dwTempDataStoreAttributes = SLF_DATA_STORE_SIZE_ONE_KB;
    } else if ( ONE_RECORD == dwTempFileSizeUnits ) {
        dwTempDataStoreAttributes = SLF_DATA_STORE_SIZE_ONE_RECORD;
    }

    // Data store append mode
    GetDataStoreAppendMode( dwTempAppendMode );
    dwTempDataStoreAttributes |= dwTempAppendMode;

    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_DATA_STORE_ATTRIBUTES, dwTempDataStoreAttributes );

    hr = StringToPropertyBag ( pPropBag, IDS_HTML_LOG_FILE_BASE_NAME, mr_strBaseFileName );
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_LOG_FILE_SERIAL_NUMBER, mr_dwCurrentSerialNumber );
    hr = StringToPropertyBag ( pPropBag, IDS_HTML_LOG_FILE_FOLDER, mr_strDefaultDirectory );
    hr = StringToPropertyBag ( pPropBag, IDS_HTML_SQL_LOG_BASE_NAME, mr_strSqlName );
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_LOG_FILE_AUTO_FORMAT, mr_dwLogAutoFormat );

    // Write only for counter and trace logs, not for alerts?
    // Log file type for Alerts is -1, so the new query will keep its default value.
    GetLogFileType ( dwTemp );
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_LOG_FILE_TYPE, dwTemp );
    hr = SlqTimeToPropertyBag ( pPropBag, SLQ_TT_TTYPE_START, &mr_stiStart );
    hr = SlqTimeToPropertyBag ( pPropBag, SLQ_TT_TTYPE_STOP, &mr_stiStop );
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_RESTART_MODE, mr_dwAutoRestartMode );

    hr = StringToPropertyBag ( pPropBag, IDS_HTML_SYSMON_LOGFILENAME, GetLogFileName(TRUE) );

    // Eof command file for counter and trace logs only.
    if ( SLQ_COUNTER_LOG == GetLogType()
         || SLQ_TRACE_LOG == GetLogType() ) {
        hr = StringToPropertyBag ( pPropBag, IDS_HTML_EOF_COMMAND_FILE, mr_strEofCmdFile );
    }
    return hr;
}

HRESULT
CSmLogQuery::CopyToBuffer ( LPWSTR& rpszData, DWORD& rcbBufferSize )
{
    HRESULT hr = S_OK;
    CImpIPropertyBag    IPropBag;
    size_t  cchBufLen = 0;
    LPWSTR  pszConfig = NULL;

    ResourceStateManager rsm;

    ASSERT ( NULL == rpszData );
    rcbBufferSize = 0;

    hr = SaveToPropertyBag (&IPropBag, TRUE );
   
    if ( SUCCEEDED ( hr ) ) {
        MFC_TRY
            pszConfig = IPropBag.GetData();        
            if ( NULL != pszConfig ) {

                cchBufLen = lstrlen ( CGlobalString::m_cszHtmlObjectHeader )
                            + lstrlen ( CGlobalString::m_cszHtmlObjectFooter )
                            + lstrlen ( pszConfig ) + 1;

                rpszData = new WCHAR[cchBufLen];
            } else {
                hr = E_UNEXPECTED;
            }
        MFC_CATCH_HR

        if ( SUCCEEDED ( hr ) ) {

            StringCchCopy ( rpszData, cchBufLen, CGlobalString::m_cszHtmlObjectHeader );
            StringCchCat ( rpszData, cchBufLen, pszConfig );
            StringCchCat ( rpszData, cchBufLen, CGlobalString::m_cszHtmlObjectFooter );

            rcbBufferSize = (DWORD)(cchBufLen * sizeof(WCHAR));
        }
    }

    return hr;
}

BOOL
CSmLogQuery::LLTimeToVariantDate (
    IN  LONGLONG llTime,
    OUT DATE *pdate
    )
{
    SYSTEMTIME SystemTime;

    if (!FileTimeToSystemTime((FILETIME*)&llTime, &SystemTime))
        return FALSE;

    if (FAILED(SystemTimeToVariantTime(&SystemTime, pdate)))
        return FALSE;

    return TRUE;
}

    
BOOL
CSmLogQuery::VariantDateToLLTime (
    IN  DATE date,
    OUT LONGLONG *pllTime
    )
{
    SYSTEMTIME SystemTime;

    if (FAILED(VariantTimeToSystemTime(date, &SystemTime)))
        return FALSE;

    if (!SystemTimeToFileTime(&SystemTime,(FILETIME*)pllTime))
        return FALSE;

    return TRUE;
}

DWORD 
CSmLogQuery::UpdateExecuteOnly( void )
{
    DWORD dwStatus = ERROR_SUCCESS;

    if (!m_bReadOnly) {
    
        DWORD dwExecuteOnly;

        dwExecuteOnly = 1;        // TRUE

        dwStatus = WriteRegistryDwordValue (
            m_hKeyQuery, 
            IDS_REG_EXECUTE_ONLY,
            &dwExecuteOnly);

        ASSERT ( ERROR_SUCCESS == dwStatus );

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = m_pLogService->Synchronize();    
        }
    } else {
        dwStatus = ERROR_ACCESS_DENIED;
    }

    return dwStatus;
}

CWnd* 
CSmLogQuery::GetActivePropertySheet( void )
{
    CWnd* pwndReturn = NULL;

    if ( NULL != m_pActivePropPage ) {
        pwndReturn = m_pActivePropPage->GetParentOwner();
    }
    return pwndReturn;
}

CPropertySheet* 
CSmLogQuery::GetInitialPropertySheet( void )
{
    return m_pInitialPropertySheet;
}

void 
CSmLogQuery::SetInitialPropertySheet( CPropertySheet* pSheet )
{
    m_pInitialPropertySheet = (pSheet);
}

void
CSmLogQuery::SetActivePropertyPage( CSmPropertyPage* pPage)
{
    // The first property page of each property sheet sets 
    // and clears this member variable.
    // It is assumed that the first page is always created.
    m_pActivePropPage = pPage;

    return;
}

BOOL   
CSmLogQuery::IsFirstModification( void ) 
{
    BOOL    bIsFirstModification = FALSE;
    bIsFirstModification = ( m_bIsModified && m_bIsNew );

    if ( bIsFirstModification ) {
        m_bIsNew = FALSE;
    }

    return bIsFirstModification;
}

LPCWSTR 
CSmLogQuery::GetNonLocRegValueName ( UINT uiValueName )
{
    UINT    uiLocalIndex;
    LPCWSTR szReturn = NULL;
//
// NOTE:  Unless otherwise specified, all registry Resource Id values are contiguous
// beginning with 816, so they can be used as indexes into the map.
//
    if ( IDS_REG_EXECUTE_ONLY != uiValueName ) {
        uiLocalIndex = uiValueName - IDS_REG_FIRST_VALUE_NAME;
    } else { 
        uiLocalIndex = dwRegValueNameMapEntries - 1;
    }

    if ( uiLocalIndex < dwRegValueNameMapEntries ) {
        szReturn = RegValueNameMap [ uiLocalIndex ].szNonLocValueName;
    }

    // Programming error if no string found.
    ASSERT ( NULL != szReturn );

    return szReturn;
}

LPCWSTR 
CSmLogQuery::GetNonLocHtmlPropName ( UINT uiValueName )
{
    UINT    uiLocalIndex;
    LPCWSTR szReturn = NULL;
//
// NOTE:  Unless otherwise specified, all Html Resource Id values are contiguous
// beginning with 900, so they can be used as indexes into the map.
//
    
    uiLocalIndex = uiValueName - IDS_HTML_FIRST_VALUE_NAME;

    if ( uiLocalIndex < dwHtmlPropNameMapEntries ) {
        szReturn = HtmlPropNameMap [ uiLocalIndex ].szNonLocValueName;
    }

    // Programming error if no string found.
    ASSERT ( NULL != szReturn );

    return szReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smlogs.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smlogs.cpp

Abstract:

    Implementation of the base class representing the 
    Performance Logs and Alerts service.

--*/

#include "Stdafx.h"

// Define the following to use the minimum of shlwapip.h 

#ifndef NO_SHLWAPI_PATH
#define NO_SHLWAPI_PATH
#endif  

#ifndef NO_SHLWAPI_REG
#define NO_SHLWAPI_REG
#endif  

#ifndef NO_SHLWAPI_UALSTR
#define NO_SHLWAPI_UALSTR
#endif  

#ifndef NO_SHLWAPI_STREAM
#define NO_SHLWAPI_STREAM
#endif  

#ifndef NO_SHLWAPI_HTTP
#define NO_SHLWAPI_HTTP
#endif  

#ifndef NO_SHLWAPI_INTERNAL
#define NO_SHLWAPI_INTERNAL
#endif  

#ifndef NO_SHLWAPI_GDI
#define NO_SHLWAPI_GDI
#endif  

#ifndef NO_SHLWAPI_UNITHUNK
#define NO_SHLWAPI_UNITHUNK
#endif  

#ifndef NO_SHLWAPI_TPS
#define NO_SHLWAPI_TPS
#endif  

#ifndef NO_SHLWAPI_MLUI
#define NO_SHLWAPI_MLUI
#endif  

#include <shlwapi.h>            // For SHLoadIndirectString
#include <shlwapip.h>           // For SHLoadIndirectString
#include <strsafe.h>

#include <pdh.h>        // For MIN_TIME_VALUE, MAX_TIME_VALUE
#include <pdhp.h>       // For pdhi methods
#include <Wbemidl.h>
#include "smlogres.h"
#include "smcfgmsg.h"
#include "smalrtq.h"
#include "smctrqry.h"
#include "smtraceq.h"
#include "strnoloc.h"
#include "smrootnd.h"
#include "smlogs.h"

USE_HANDLE_MACROS("SMLOGCFG(smlogs.cpp)");

#define  DEFAULT_LOG_FILE_FOLDER    L"%SystemDrive%\\PerfLogs"

//
//  Constructor
CSmLogService::CSmLogService()
:   m_hKeyMachine ( NULL ),
    m_hKeyLogService ( NULL ),
    m_hKeyLogServiceRoot ( NULL ),
    m_bIsOpen ( FALSE ),
    m_bReadOnly ( FALSE ),
    m_bRefreshOnShow ( FALSE ),
    m_pRootNode ( NULL )
{
    // String allocation errors are thrown, to be
    // captured by rootnode alloc exception handler
    m_QueryList.RemoveAll();    // initialize the list
    ZeroMemory(&m_OSVersion, sizeof(m_OSVersion));
    return;
}

//
//  Destructor
CSmLogService::~CSmLogService()
{
    // make sure Close method was called first!
    ASSERT ( NULL == m_QueryList.GetHeadPosition() );
    ASSERT ( NULL == m_hKeyMachine );
    ASSERT ( NULL == m_hKeyLogService );
    ASSERT ( NULL == m_hKeyLogServiceRoot );
    return;
}

PSLQUERY    
CSmLogService::CreateTypedQuery ( 
    const CString& rstrName,
    DWORD   dwLogType )
{
    HKEY    hKeyQuery;
    PSLQUERY pNewLogQuery = NULL;
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwDisposition;
    DWORD   dwRegValue;
    UUID    uuidNew;
    RPC_STATUS  rpcStat = RPC_S_OK;
    LPWSTR  pszUuid = NULL;
    INT iBufLen = rstrName.GetLength()+1;
    LPWSTR  pszName = NULL;
    LPWSTR  pStat = NULL;
    BOOL    bDupFound = FALSE;
    CString strNewQueryName;
    CString strCollectionName;

    if (m_bReadOnly) {
        SetLastError (SMCFG_NO_MODIFY_ACCESS);
        return NULL; // unable to create without WRITE access
    } else {
        // Initialize to success status.
        SetLastError( dwStatus );
    }

    if ( OS_WIN2K != TargetOs()) {
        // For servers later than Windows2000, use a GUID as the key name for a query.
        rpcStat = UuidCreate( &uuidNew );

        if ( RPC_S_OK != rpcStat && RPC_S_UUID_LOCAL_ONLY != rpcStat ) {
            rpcStat = UuidCreateSequential ( &uuidNew );
        }

        if ( RPC_S_OK == rpcStat || RPC_S_UUID_LOCAL_ONLY == rpcStat ) {            
   
            rpcStat = UuidToString ( &uuidNew, &pszUuid );

            if ( RPC_S_OK == rpcStat ) {

                ASSERT ( NULL != pszUuid );

                MFC_TRY
                    strNewQueryName.Format ( L"{%s}", pszUuid );
                MFC_CATCH_DWSTATUS

                RpcStringFree ( &pszUuid );
            } else {
                dwStatus = rpcStat; 
            }
        }
        // RPC_STATUS values in rpcnterr.h correspond to appropriate values.
        dwStatus = rpcStat;
    } else {
        // For Windows 2000, use query name as registry key name.

        MFC_TRY
            strNewQueryName = rstrName;
        MFC_CATCH_DWSTATUS

    }

    if ( ERROR_SUCCESS == dwStatus ) {

        // Query key name created
        // Create the query specified, checking for duplicate query by key name.

        dwStatus = RegCreateKeyExW (
            m_hKeyLogService,
            strNewQueryName,
            0,
            NULL, 0,
            KEY_READ | KEY_WRITE,
            NULL,
            &hKeyQuery,
            &dwDisposition);

        if ( REG_OPENED_EXISTING_KEY == dwDisposition ) {
            dwStatus = SMCFG_DUP_QUERY_NAME;
        } 
    } 

    if ( ERROR_SUCCESS == dwStatus ) {

        // Initialize the current state value.  After it is 
        // initialized, it is only modified when:
        //      1) Set to Stopped or Started by the service
        //      2) Set to Start Pending by the config snapin.
        
        dwRegValue = SLQ_QUERY_STOPPED;

        dwStatus = RegSetValueEx (
            hKeyQuery, 
            CGlobalString::m_cszRegCurrentState,
            0L,
            REG_DWORD,
            (CONST BYTE *)&dwRegValue,
            sizeof(DWORD));

        if ( ERROR_SUCCESS == dwStatus ) {
            // Initialize the log type to "new" to indicate partially created logs
            dwRegValue = SLQ_NEW_LOG;

            dwStatus = RegSetValueEx (
                hKeyQuery, 
                CGlobalString::m_cszRegLogType,
                0L,
                REG_DWORD,
                (CONST BYTE *)&dwRegValue,
                sizeof(DWORD));
        }

        if ( ERROR_SUCCESS == dwStatus && (OS_WIN2K != TargetOs()) ) {
            // Initialize the collection name for post Windows 2000 systems
    
            MFC_TRY
                strCollectionName = rstrName;
            MFC_CATCH_DWSTATUS

            if ( ERROR_SUCCESS == dwStatus ) {
                dwStatus = RegSetValueEx (
                    hKeyQuery, 
                    CGlobalString::m_cszRegCollectionName,
                    0L,
                    REG_SZ,
                    (CONST BYTE *)strCollectionName.GetBufferSetLength( strCollectionName.GetLength() ),
                    strCollectionName.GetLength()*sizeof(WCHAR) );

                strCollectionName.ReleaseBuffer();
            }

            // For post Windows 2000 counters, search for duplicate by collection name.
            if ( ERROR_SUCCESS == dwStatus ) {
                dwStatus = FindDuplicateQuery ( rstrName, bDupFound );
            }
        }
        if ( ERROR_SUCCESS == dwStatus && !bDupFound ) {
            // create a new object and add it to the query list
             dwStatus = LoadSingleQuery (
                            &pNewLogQuery,
                            dwLogType,
                            rstrName,
                            strNewQueryName,
                            hKeyQuery,
                            TRUE );
        } else {
            if ( bDupFound ) {
                dwStatus = SMCFG_DUP_QUERY_NAME;
            }
        }
    }

    if ( ERROR_SUCCESS != dwStatus ) {
        // Delete also closes the registry key hKeyQuery.
        if ( !strNewQueryName.IsEmpty() ) {
            RegDeleteKeyW ( m_hKeyLogService, strNewQueryName );
            SetLastError ( dwStatus );
        }
    }

    return pNewLogQuery;
}

DWORD   
CSmLogService::UnloadSingleQuery (PSLQUERY pQuery)
{
    DWORD       dwStatus = ERROR_SUCCESS;
    PSLQUERY    pLogQuery = NULL;
    POSITION    listPos = NULL;
    BOOL        bFoundEntry = FALSE;

    // find matching entry
    if (!m_QueryList.IsEmpty()) {
        listPos = m_QueryList.Find (pQuery, NULL);
        if ( NULL != listPos ) {
            pLogQuery = m_QueryList.GetAt(listPos);
            bFoundEntry = TRUE;
        }
    }

    if (bFoundEntry) {
        ASSERT ( NULL != listPos );

        // remove from list
        m_QueryList.RemoveAt (listPos);
        pLogQuery->Close();
        delete pLogQuery;
    } else {
        // not found
        dwStatus = ERROR_FILE_NOT_FOUND;
    }

    return dwStatus;    
}

DWORD   
CSmLogService::DeleteQuery ( PSLQUERY pQuery )
{
    PSLQUERY    pLogQuery = NULL;
    DWORD       dwStatus = ERROR_SUCCESS;
    POSITION    listPos = NULL;
    BOOL        bFoundEntry = FALSE;
    CString     strLogKeyName;

    if (m_bReadOnly) {
        dwStatus = ERROR_ACCESS_DENIED;
    } else {
        // find matching entry
        if (!m_QueryList.IsEmpty()) {
            listPos = m_QueryList.Find (pQuery, NULL);
            if (listPos != NULL) {
                pLogQuery = m_QueryList.GetAt(listPos);
                bFoundEntry = TRUE;
            }
        }
        
        if (bFoundEntry) {
            ASSERT (listPos != NULL);
        
            MFC_TRY
                pLogQuery->GetLogKeyName( strLogKeyName );
            MFC_CATCH_DWSTATUS;

            if ( ERROR_SUCCESS == dwStatus ) {
                // remove from list
                m_QueryList.RemoveAt (listPos);
                pLogQuery->Close();

                // Delete in the registry
                RegDeleteKeyW ( m_hKeyLogService, strLogKeyName );
                
                delete pLogQuery;


                if ( NULL != GetRootNode() ) {
                    GetRootNode()->UpdateServiceConfig();
                }
            
            }
        } else {
            // not found
            dwStatus = ERROR_FILE_NOT_FOUND;
        }
    }
    return dwStatus;
}

DWORD   
CSmLogService::DeleteQuery ( const CString& rstrName )
{
    PSLQUERY    pLogQuery = NULL;
    DWORD       dwStatus = ERROR_SUCCESS;
    POSITION    listPos;
    BOOL        bFoundEntry = FALSE;


    if (m_bReadOnly) {
        dwStatus = ERROR_ACCESS_DENIED;
    } else {
        // find matching entry
        if (!m_QueryList.IsEmpty()) {
            listPos = m_QueryList.GetHeadPosition();
            while (listPos != NULL) {
                pLogQuery = m_QueryList.GetNext(listPos);
                if ( 0 == rstrName.CompareNoCase ( pLogQuery->GetLogName() ) ) {
                    // match found so bail here
                    bFoundEntry = TRUE;
                    break;
                }
            }
        }
        
        if (bFoundEntry) {
            dwStatus = DeleteQuery ( pLogQuery );
        } else {
            // not found
            dwStatus = ERROR_FILE_NOT_FOUND;
        }
    }
    return dwStatus;
}

DWORD   
CSmLogService::LoadDefaultLogFileFolder ( void )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    LPWSTR  szLocalPath = NULL; 
    WCHAR*  szExpanded = NULL;
    INT     cchLen;
    INT     cchExpandedLen;
    DWORD   dwBufferSize = 0;

    m_strDefaultLogFileFolder.Empty();

    if ( NULL != m_hKeyLogServiceRoot ) {
    
        dwStatus = CSmLogQuery::ReadRegistryStringValue (
                                    m_hKeyLogServiceRoot,
                                    (LPCWSTR)L"DefaultLogFileFolder",
                                    (LPCWSTR)L"DefaultLogFileFolder",
                                    NULL,
                                    &szLocalPath,
                                    &dwBufferSize );
        
        //
        // No message on error.  If error, just load the default.        
        //
        MFC_TRY
            if ( sizeof(WCHAR) >= dwBufferSize ) {
                ResourceStateManager    rsm;
                CString strFolderName;
                strFolderName.LoadString ( IDS_DEFAULT_LOG_FILE_FOLDER );

                if ( NULL != szLocalPath ) {
                    delete [] szLocalPath;
                    szLocalPath = NULL;
                }
                szLocalPath = new WCHAR [strFolderName.GetLength() + 1];

                StringCchCopy ( szLocalPath, (strFolderName.GetLength() + 1), strFolderName );
            }

            if ( IsLocalMachine() ) {
                cchLen = 0;
                cchExpandedLen = 0;

                cchLen = ExpandEnvironmentStrings ( szLocalPath, NULL, 0 );

                if ( 0 < cchLen ) {
                    szExpanded = new WCHAR[cchLen];
        
                    cchExpandedLen = ExpandEnvironmentStrings (
                        szLocalPath, 
                        szExpanded,
                        cchLen );

                    if ( 0 < cchExpandedLen ) {
                        m_strDefaultLogFileFolder = szExpanded;
                    } else {
                        dwStatus = GetLastError();
                        m_strDefaultLogFileFolder.Empty();
                    }
                } else {
                    dwStatus = GetLastError();
                }
            } else {
                m_strDefaultLogFileFolder = szLocalPath;
            }
        MFC_CATCH_DWSTATUS
    }
    
    if ( NULL != szLocalPath ) {
        delete [] szLocalPath;
    }

    if ( NULL != szExpanded ) {
        delete [] szExpanded;
    }

    return dwStatus;
}

DWORD   
CSmLogService::LoadSingleQuery ( 
    PSLQUERY*   ppQuery,
    DWORD       dwLogType, 
    const CString& rstrName,
    const CString& rstrLogKeyName,
    HKEY        hKeyQuery,
    BOOL        bNew )
{
    DWORD dwStatus = ERROR_SUCCESS;
    PSLQUERY    pNewQuery = NULL;

    if ( NULL != ppQuery ) {
        *ppQuery = NULL;

        // create a new query object and add it to the query list
        MFC_TRY
            if ( SLQ_COUNTER_LOG == dwLogType ) {
                pNewQuery = new SLCTRQUERY ( this );
            } else if ( SLQ_TRACE_LOG == dwLogType ) {
                pNewQuery = new SLTRACEQUERY ( this );
            } else if ( SLQ_ALERT == dwLogType ) {
                pNewQuery = new SLALERTQUERY ( this );
            }
        MFC_CATCH_DWSTATUS

        if ( ERROR_SUCCESS == dwStatus && NULL != pNewQuery ) {
        
            pNewQuery->SetNew ( bNew );

            dwStatus = pNewQuery->Open(
                                    rstrName, 
                                    hKeyQuery, 
                                    m_bReadOnly );

            if ( ERROR_SUCCESS == dwStatus ) {
                dwStatus = pNewQuery->SetLogKeyName ( rstrLogKeyName );
            }

            if ( ERROR_SUCCESS == dwStatus ) {
                // then add it to the list
                MFC_TRY
                    m_QueryList.AddHead ( pNewQuery );
                MFC_CATCH_DWSTATUS
            
                if ( ERROR_SUCCESS != dwStatus ) {
                    // close this query object
                    pNewQuery->Close();
                }            
            }

            if ( ERROR_SUCCESS != dwStatus ) {
                // delete this query object
                delete pNewQuery;
            }               
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            *ppQuery = pNewQuery;
        }
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }
    return dwStatus;
}

DWORD   
CSmLogService::LoadQueries ( DWORD dwLogType )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwQueryIndex = 0;
    LONG    lEnumStatus = ERROR_SUCCESS;
    WCHAR   szQueryKeyName[MAX_PATH + 1];
    DWORD   dwQueryKeyNameLen;
    LPWSTR  szCollectionName = NULL;
    UINT    uiCollectionNameLen = 0;
    FILETIME    ftLastWritten;
    HKEY        hKeyQuery;
    PSLQUERY    pNewLogQuery = NULL;
    DWORD       dwType = 0;
    DWORD       dwBufferSize = sizeof(DWORD);
    DWORD       dwRegValue;
    CString     strQueryName;

    
    // Load all queries for the specified registry key.
    // Enumerate the log names and create a new log object
    // for each one found.

    dwQueryKeyNameLen = sizeof ( szQueryKeyName ) / sizeof ( WCHAR );
    memset (szQueryKeyName, 0, sizeof (szQueryKeyName));

    while ( ERROR_SUCCESS == ( lEnumStatus = RegEnumKeyExW (
                                                m_hKeyLogService,
                                                dwQueryIndex, 
                                                szQueryKeyName, 
                                                &dwQueryKeyNameLen,
                                                NULL, 
                                                NULL, 
                                                NULL, 
                                                &ftLastWritten ) ) ) {

        // open the query specified
        dwStatus = RegOpenKeyExW (
            m_hKeyLogService,
            szQueryKeyName,
            0,
            (m_bReadOnly ? KEY_READ : KEY_READ | KEY_WRITE ),
            &hKeyQuery);
        if ( ERROR_SUCCESS == dwStatus ) {
            // create a new object and add it to the query list
            
            // Determine the log type.                
            dwType = 0;
            dwStatus = RegQueryValueExW (
                hKeyQuery,
                CGlobalString::m_cszRegLogType,
                NULL,
                &dwType,
                (LPBYTE)&dwRegValue,
                &dwBufferSize );
            
            if ( ( ERROR_SUCCESS == dwStatus ) 
                && ( dwLogType == dwRegValue ) ) {

                dwStatus = CSmLogQuery::SmNoLocReadRegIndStrVal (
                            hKeyQuery,
                            IDS_REG_COLLECTION_NAME,
                            NULL,
                            &szCollectionName,
                            &uiCollectionNameLen );
                MFC_TRY
                    if ( ERROR_SUCCESS == dwStatus 
                            && NULL != szCollectionName ) {
                        if (  0 < lstrlen ( szCollectionName ) ) {
                            strQueryName = szCollectionName;
                        } else {
                            strQueryName = szQueryKeyName;
                            dwStatus = ERROR_SUCCESS;
                        }
                    } else {
                        strQueryName = szQueryKeyName;
                        dwStatus = ERROR_SUCCESS;
                    }
                MFC_CATCH_DWSTATUS;

                if ( NULL != szCollectionName ) {
                    G_FREE ( szCollectionName );
                    szCollectionName = NULL;
                    uiCollectionNameLen = 0;
                }

                if ( ERROR_SUCCESS == dwStatus ) {
                    dwStatus = LoadSingleQuery (
                                    &pNewLogQuery,
                                    dwRegValue,
                                    strQueryName,
                                    szQueryKeyName,
                                    hKeyQuery,
                                    FALSE );

                    if ( ERROR_SUCCESS != dwStatus ) {
                        // Todo:  Error message
                        dwStatus = ERROR_SUCCESS;
                    }
                }

            } else {
                // Try the next item in the list
		        RegCloseKey (hKeyQuery);
                dwStatus = ERROR_SUCCESS;
            }
        }
        // set up for the next item in the list
        dwQueryKeyNameLen = sizeof (szQueryKeyName) / sizeof (szQueryKeyName[0]);
        memset (szQueryKeyName, 0, sizeof (szQueryKeyName));
        dwQueryIndex++;
    }
    
    return dwStatus;
}

//  
//  Open function. Opens all existing log query entries.
//
DWORD   
CSmLogService::Open ( const CString& rstrMachineName)
{
    DWORD   dwStatus = ERROR_SUCCESS;

    // Initialize strings
    SetMachineName ( rstrMachineName );
    SetDisplayName ( m_strBaseName );

    if ( rstrMachineName.IsEmpty() ) {
        m_hKeyMachine = HKEY_LOCAL_MACHINE;
    } else {
        dwStatus = RegConnectRegistryW (
            rstrMachineName,
            HKEY_LOCAL_MACHINE,
            &m_hKeyMachine);

        if ( ERROR_ACCESS_DENIED == dwStatus ) {
            dwStatus = SMCFG_NO_READ_ACCESS;
        }
    }

    if (dwStatus == ERROR_SUCCESS) {

        // open a read-only key to the registry root key for this service, to obtain
        // root-level values.
        dwStatus = RegOpenKeyExW (
            m_hKeyMachine,
            (LPCWSTR)L"SYSTEM\\CurrentControlSet\\Services\\SysmonLog",
            0,
            KEY_READ,
            &m_hKeyLogServiceRoot);
        // No message on failure.  Currently only affects default log file folder name.
        
        // open a key to the registry log queries key for this service
        dwStatus = RegOpenKeyExW (
            m_hKeyMachine,
            (LPCWSTR)L"SYSTEM\\CurrentControlSet\\Services\\SysmonLog\\Log Queries",
            0,
            KEY_READ | KEY_WRITE,
            &m_hKeyLogService);

        if (dwStatus != ERROR_SUCCESS) {
            // unable to access the key for write access, so try read only
            dwStatus = RegOpenKeyExW (
                m_hKeyMachine,
                (LPCWSTR)L"SYSTEM\\CurrentControlSet\\Services\\SysmonLog\\Log Queries",
                0,
                KEY_READ,
                &m_hKeyLogService);
            if (dwStatus != ERROR_SUCCESS) {
                // unable to open the key for read access so bail out
                // assume the service has not been installed 
                // (though we should probably check first to make sure)
                m_hKeyLogService = NULL;
                if ( ERROR_ACCESS_DENIED == dwStatus ) {
                    dwStatus = SMCFG_NO_READ_ACCESS;
                }
            } else {
                // opened for read access so set the flag
                m_bReadOnly = TRUE;
            }
        }
    }

    // Install the service if necessary.
    if ( ( dwStatus != SMCFG_NO_READ_ACCESS ) ) {
        dwStatus = Install( rstrMachineName );
    }
    
    // Load all queries
    if ( ( dwStatus == ERROR_SUCCESS ) && ( NULL != m_hKeyLogService ) ) {
        dwStatus = LoadQueries();
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        SetOpen ( TRUE );
    }

    return dwStatus;
}

DWORD   
CSmLogService::CheckForActiveQueries (PSLQUERY* ppActiveQuery)
{
    DWORD       dwStatus = ERROR_SUCCESS;
    PSLQUERY    pQuery = NULL;
    POSITION    Pos = m_QueryList.GetHeadPosition();

    while ( Pos != NULL) {
        pQuery = m_QueryList.GetNext( Pos );
        if ( NULL != pQuery->GetActivePropertySheet() ) {
            dwStatus = IDS_ERRMSG_REFRESH_OPEN_QUERY;
            if ( NULL != ppActiveQuery ) {
                *ppActiveQuery = pQuery;
            }
            break;
        }
    }
    return dwStatus;
}

DWORD   
CSmLogService::UnloadQueries (PSLQUERY* ppActiveQuery)
{
    DWORD       dwStatus = ERROR_SUCCESS;
    PSLQUERY    pQuery = NULL;
    POSITION    Pos = m_QueryList.GetHeadPosition();

    // Ensure that all property dialogs are closed before unloading queries.
    dwStatus = CheckForActiveQueries ( ppActiveQuery );

    if ( ERROR_SUCCESS == dwStatus ) {
        Pos = m_QueryList.GetHeadPosition();

        // Update each query in this service by walking down the list.
        while ( Pos != NULL) {
            pQuery = m_QueryList.GetNext( Pos );
            pQuery->Close();
            delete (pQuery);
        }
        // Empty the list now that everything has been closed;
        m_QueryList.RemoveAll();    
    }
    return dwStatus;
}

//
//  Close Function
//      closes registry handles and frees allocated memory
//      
DWORD   
CSmLogService::Close ()
{

    LOCALTRACE (L"Closing SysmonLog Service Object\n");

    UnloadQueries();

    // close any open registry keys
    if (m_hKeyMachine != NULL) {
        RegCloseKey (m_hKeyMachine);
        m_hKeyMachine = NULL;
    }

    if (m_hKeyLogService != NULL) {
        RegCloseKey (m_hKeyLogService);
        m_hKeyLogService = NULL;
    }

    if (m_hKeyLogServiceRoot!= NULL) {
        RegCloseKey (m_hKeyLogServiceRoot);
        m_hKeyLogServiceRoot = NULL;
    }

    SetOpen ( FALSE );

    return ERROR_SUCCESS;
}

BOOL  
CSmLogService::IsAutoStart ( void )
{
    BOOL bAutoStart = FALSE;
    POSITION    listPos = NULL;
    PSLQUERY    pLogQuery = NULL;

    if (!m_QueryList.IsEmpty()) {

        listPos = m_QueryList.GetHeadPosition();
        while (listPos != NULL) {
            pLogQuery = m_QueryList.GetNext(listPos);
            if ( pLogQuery->IsAutoStart() ) {
                bAutoStart = TRUE;
                break;
            }
        }
    }

    return bAutoStart;
}

//
//  SyncWithRegistry()
//      reads the current values for all queries from the registry
//      and reloads the internal values to match
//  
DWORD   CSmLogService::SyncWithRegistry ( PSLQUERY* ppActiveQuery )
{
    DWORD       dwStatus = ERROR_SUCCESS;
    CString     strDesc;
    ResourceStateManager    rsm;

    // Unload queries and reload, to capture new queries.
    // This is necessary for monitoring remote systems,
    // and if multiple users are active on the same system.

    dwStatus = UnloadQueries ( ppActiveQuery );

    if ( ERROR_SUCCESS == dwStatus ) {
        dwStatus = LoadQueries ();
    }
    return dwStatus;
}

DWORD
CSmLogService::GetState( void )
{
    // Check the status of the log service via the service controller.
    // 0 returned in case of error.
    LONG    dwStatus = ERROR_SUCCESS;
    DWORD   dwState = 0;        // Error by default.
    SERVICE_STATUS  ssData;
    SC_HANDLE   hSC;
    SC_HANDLE   hLogService;

    // open SC database
    hSC = OpenSCManager ( GetMachineName(), NULL, SC_MANAGER_CONNECT);

    if (hSC != NULL) {
    
        // open service
        hLogService = OpenService (
                        hSC, 
                        L"SysmonLog",
                        SERVICE_INTERROGATE );
    
        if (hLogService != NULL) {
            if ( ControlService (
                    hLogService, 
                    SERVICE_CONTROL_INTERROGATE,
                    &ssData)) {

                dwState = ssData.dwCurrentState;
            } else {
                dwStatus = GetLastError();
                dwState = SERVICE_STOPPED;
            }

            CloseServiceHandle (hLogService);
        
        } else {
            dwStatus = GetLastError();
        }

        CloseServiceHandle (hSC);
    } else {
        dwStatus = GetLastError();
    } // OpenSCManager

    return dwState;
}

BOOL
CSmLogService::IsRunning( void )
{
    DWORD dwState = GetState();
    BOOL bRunning = FALSE;

    if ( 0 != dwState
            && SERVICE_STOPPED != dwState
            && SERVICE_STOP_PENDING != dwState ) {
        bRunning = TRUE;
    }
    return bRunning;
}

DWORD
CSmLogService::CreateDefaultLogQueries( void )
{
    DWORD       dwStatus = ERROR_SUCCESS;
    PSLQUERY    pQuery = NULL;
    CString     strTemp;
    CString     strModuleName;
    BOOL        bRegistryUpdated;
    BOOL        bDupFound = FALSE;

    ResourceStateManager    rsm;

    // Creates default "System Overview" counter log query

    MFC_TRY
        strTemp.LoadString ( IDS_DEFAULT_CTRLOG_QUERY_NAME );
    MFC_CATCH_DWSTATUS;


    if ( ERROR_SUCCESS == dwStatus ) {    
        pQuery = CreateTypedQuery ( strTemp, SLQ_COUNTER_LOG );

        if ( NULL != pQuery && (OS_WIN2K != TargetOs()) ) {
            // Default query collection name is stored as MUI indirect string after Windows 2000    
            MFC_TRY
                ::GetModuleFileName(
                    AfxGetInstanceHandle(), 
                    strModuleName.GetBufferSetLength(MAX_PATH), 
                    MAX_PATH );

                strTemp.Format (L"@%s,-%d", strModuleName, IDS_DEFAULT_CTRLOG_QUERY_NAME );
                strModuleName.ReleaseBuffer();

            MFC_CATCH_DWSTATUS;

            if ( ERROR_SUCCESS == dwStatus ) {
                dwStatus = RegSetValueEx (
                    pQuery->GetQueryKey(),
                    CGlobalString::m_cszRegCollectionNameInd,
                    0L,
                    REG_SZ,
                    (CONST BYTE *)strTemp.GetBufferSetLength( strTemp.GetLength() ),
                    strTemp.GetLength()*sizeof(WCHAR) );

                strTemp.ReleaseBuffer();
            }
                    
            // CreateTypedQuery checks for the existence of the default query
            // using the the query name.
            // Check for the existence of the default query under the MUI indirect 
            // name as well.  
    
            if ( NULL != pQuery ) {
                if ( ERROR_SUCCESS == dwStatus ) {
                    FindDuplicateQuery ( strTemp, bDupFound );
                    if ( bDupFound ) {
                        DeleteQuery ( pQuery );
                        pQuery = NULL;
                        dwStatus = ERROR_SUCCESS;
                    }
                }
            }
        }

        if ( NULL != pQuery ) {
            SLQ_TIME_INFO slqTime;
            PSLCTRQUERY pCtrQuery = NULL;

            MFC_TRY
                pCtrQuery = pQuery->CastToCounterLogQuery();
        
                pCtrQuery->SetFileNameAutoFormat ( SLF_NAME_NONE );
                pCtrQuery->SetLogFileType ( SLF_BIN_FILE );
                pCtrQuery->SetDataStoreAppendMode ( SLF_DATA_STORE_OVERWRITE );

                strTemp.LoadString ( IDS_DEFAULT_CTRLOG_COMMENT );
                pCtrQuery->SetLogComment ( strTemp );
                
                if ( OS_WIN2K != TargetOs() ) {
                    strTemp.Format (L"@%s,-%d", strModuleName, IDS_DEFAULT_CTRLOG_COMMENT );
                    pCtrQuery->SetLogCommentIndirect ( strTemp );
                }

                strTemp.LoadString ( IDS_DEFAULT_CTRLOG_FILE_NAME );
                pCtrQuery->SetLogFileName ( strTemp );

                if ( OS_WIN2K != TargetOs() ) {
                    strTemp.Format (L"@%s,-%d", strModuleName, IDS_DEFAULT_CTRLOG_FILE_NAME );
                    pCtrQuery->SetLogFileNameIndirect ( strTemp );
                }

                pCtrQuery->AddCounter ( CGlobalString::m_cszDefaultCtrLogCpuPath );
                pCtrQuery->AddCounter ( CGlobalString::m_cszDefaultCtrLogMemoryPath );
                pCtrQuery->AddCounter ( CGlobalString::m_cszDefaultCtrLogDiskPath );

                // Start mode and time 

                memset (&slqTime, 0, sizeof(slqTime));
                slqTime.wTimeType = SLQ_TT_TTYPE_START;
                slqTime.wDataType = SLQ_TT_DTYPE_DATETIME;
                slqTime.dwAutoMode = SLQ_AUTO_MODE_NONE;
                slqTime.llDateTime = MAX_TIME_VALUE;

                pCtrQuery->SetLogTime (&slqTime, (DWORD)slqTime.wTimeType);

                // Stop mode and time
    
                slqTime.wTimeType = SLQ_TT_TTYPE_STOP;
                slqTime.llDateTime = MIN_TIME_VALUE;

                pCtrQuery->SetLogTime (&slqTime, (DWORD)slqTime.wTimeType);

                pCtrQuery->UpdateService( bRegistryUpdated );

                // Set the default log to Execute Only.

                dwStatus = pCtrQuery->UpdateExecuteOnly ();

            MFC_CATCH_DWSTATUS
            
            if ( ERROR_SUCCESS == dwStatus && NULL != pCtrQuery ) {
                VERIFY ( ERROR_SUCCESS == UnloadSingleQuery ( pCtrQuery ) );
            } else if ( NULL != pCtrQuery ) {
                DeleteQuery ( pCtrQuery );
            }
        } else {
            dwStatus = GetLastError();

            if ( SMCFG_DUP_QUERY_NAME == dwStatus ) {
                dwStatus = ERROR_SUCCESS;
            }
        }
    }
    return dwStatus;
}


DWORD
CSmLogService::Install ( 
    const   CString&  rstrMachineName )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwDisposition = 0;
    HKEY    hKeyPerfLog = NULL;
    DWORD   dwType;
    DWORD   dwRegValue;
    DWORD   dwBufferSize;
    BOOL    bReadOnlyPerfLogKey = FALSE;
    BOOL    bReadOnlyLogQueriesKey = FALSE;

    ResourceStateManager   rsm;

    //
    // Get machine OS version
    //
    PdhiPlaGetVersion( rstrMachineName, &m_OSVersion );
    
    if ( NULL == m_hKeyMachine ) {
        if ( rstrMachineName.IsEmpty() ) {
            m_hKeyMachine = HKEY_LOCAL_MACHINE;
        } else {
            dwStatus = RegConnectRegistryW (
                rstrMachineName,
                HKEY_LOCAL_MACHINE,
                &m_hKeyMachine);
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {    
        dwStatus = RegOpenKeyEx (
                        m_hKeyMachine,
                        L"System\\CurrentControlSet\\Services\\SysmonLog",
                        0,
                        KEY_READ | KEY_WRITE,
                        &hKeyPerfLog);
        if (dwStatus != ERROR_SUCCESS) {
            // unable to access the key for write access, so try read only
            dwStatus = RegOpenKeyEx (
                            m_hKeyMachine,
                            L"System\\CurrentControlSet\\Services\\SysmonLog",
                            0,
                            KEY_READ,
                            &hKeyPerfLog);
            if ( ERROR_SUCCESS == dwStatus ) {
                bReadOnlyPerfLogKey = TRUE;
            }
        }
    }

    EnterCriticalSection ( &g_critsectInstallDefaultQueries );

    // In Windows 2000, the Log Queries key is created by the snapin.
    // After Windows 2000, the Log Queries key is created by system setup,
    // along with a "Default Installed" registry flag.
    if ( ERROR_SUCCESS == dwStatus && NULL == m_hKeyLogService ) {

        if ( !bReadOnlyPerfLogKey ) {
            // add registry subkey for Log Queries
            dwStatus = RegCreateKeyEx (
                            hKeyPerfLog,
                            L"Log Queries",
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE,
                            NULL,
                            &m_hKeyLogService,
                            &dwDisposition);
        } else {
            // ReadOnly SysmonLog key.  Still possible to succeed if Log Queries 
            // exists with read/write access.
            dwStatus = RegOpenKeyEx (
                            m_hKeyMachine,
                            L"System\\CurrentControlSet\\Services\\SysmonLog\\Log Queries",
                            0,
                            KEY_READ | KEY_WRITE,
                            &m_hKeyLogService);

            if (dwStatus == ERROR_SUCCESS) {
                bReadOnlyLogQueriesKey = FALSE;
            } else {
                // unable to access the key for write access, so try read only
                dwStatus = RegOpenKeyExW (
                    m_hKeyMachine,
                    (LPCWSTR)L"SYSTEM\\CurrentControlSet\\Services\\SysmonLog\\Log Queries",
                    0,
                    KEY_READ,
                    &m_hKeyLogService);

                if ( ERROR_SUCCESS == dwStatus ) {
                    bReadOnlyLogQueriesKey = TRUE;
                }
            }
        }
    } else if ( m_bReadOnly ) {
        bReadOnlyLogQueriesKey = TRUE;
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        // Log queries key now exists.

        dwType = REG_DWORD;
        dwRegValue = 0;        
        dwBufferSize = sizeof(DWORD);

        dwStatus = RegQueryValueExW (
                    m_hKeyLogService, 
                    CGlobalString::m_cszDefaultsInstalled,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwRegValue,
                    &dwBufferSize );

        if ( ERROR_SUCCESS != dwStatus 
                || 0 == dwRegValue ) 
        { 
            if ( !bReadOnlyLogQueriesKey ) {
                // Create default counter log query.
                // Todo:  Message on error.
                dwStatus = CreateDefaultLogQueries();
            
                if ( ERROR_SUCCESS == dwStatus ) {
    
                   dwRegValue = SLQ_DEFAULT_SYS_QUERY;
                   dwStatus = RegSetValueEx (
                        m_hKeyLogService, 
                        CGlobalString::m_cszDefaultsInstalled, 
                        0L,
                        REG_DWORD,
                        (CONST BYTE *)&dwRegValue,
                        dwBufferSize);
                }
            } else {
                dwStatus = SMCFG_NO_INSTALL_ACCESS;
            }
        }
    }
  
    if ( ERROR_SUCCESS == dwStatus ) {    
        RegFlushKey ( m_hKeyLogService );
        // Ignore status.
    }
    
    LeaveCriticalSection ( &g_critsectInstallDefaultQueries );

    if (NULL != hKeyPerfLog ) {
        RegCloseKey (hKeyPerfLog);
    }

    if ( ERROR_ACCESS_DENIED == dwStatus ) {
        dwStatus = SMCFG_NO_INSTALL_ACCESS;
    }
    return dwStatus;
}

DWORD
CSmLogService::Synchronize( void )
{
    // If the service is running, tell it to synchronize itself,
    // Check the state afterwards to see if it got the message.
    // If stop pending or stopped, wait until the service is
    // stopped and then attempt to start it.  The service 
    // synchronizes itself from the registry when it is started.

    // Return 0 for success, other for failure.

    SC_HANDLE   hSC = NULL;
    SC_HANDLE   hService = NULL;
    SERVICE_STATUS  ssData;
    DWORD       dwCurrentState;
    DWORD       dwTimeout = 50;
    LONG        dwStatus = ERROR_SUCCESS;
    BOOL        bServiceStarted = FALSE;
    
    dwCurrentState = GetState();

    if ( 0 == dwCurrentState ) {
        dwStatus = 1;
    } else {
        // open SC database
        hSC = OpenSCManager ( GetMachineName(), NULL, GENERIC_READ);
        if ( NULL != hSC ) {
            // open service
            hService = OpenService (
                            hSC, 
                            L"SysmonLog",
                            SERVICE_USER_DEFINED_CONTROL 
                            | SERVICE_START );

            if ( NULL != hService ) {
                if ( ( SERVICE_STOPPED != dwCurrentState ) 
                    && ( SERVICE_STOP_PENDING != dwCurrentState ) ) {
                            
                    // Wait 100 milliseconds before synchronizing service,
                    // to ensure that registry values are written.
                    Sleep ( 100 );

                    ControlService ( 
                        hService, 
                        SERVICE_CONTROL_SYNCHRONIZE, 
                        &ssData);
                    
                    dwCurrentState = ssData.dwCurrentState;
                }

                // Make sure that the ControlService call reached the service
                // while it was in run state.
                if ( ( SERVICE_STOPPED == dwCurrentState ) 
                    || ( SERVICE_STOP_PENDING == dwCurrentState ) ) {
                    
                    if ( SERVICE_STOP_PENDING == dwCurrentState ) {
                        // wait for the service to stop before starting it.
                        while (--dwTimeout) {
                            dwCurrentState = GetState();
                            if ( SERVICE_STOP_PENDING == dwCurrentState ) {
                                Sleep(200);
                            } else {
                                break;
                            }
                        }
                    }

                    dwTimeout = 50;
                    if ( SERVICE_STOPPED == dwCurrentState ) {
                        bServiceStarted = StartService (hService, 0, NULL);
                        if ( !bServiceStarted ) {
                            dwStatus = GetLastError();
                            if ( ERROR_SERVICE_ALREADY_RUNNING == dwStatus ) {
                                // Okay if started during the time window since
                                // the last GetState() call.
                                dwStatus = ERROR_SUCCESS;
                                bServiceStarted = TRUE;
                            } // else error
                        }

                        if ( bServiceStarted ) {
                            // wait for the service to start or stop 
                            // before returning
                            while (--dwTimeout) {
                                dwCurrentState = GetState();
                                if ( SERVICE_START_PENDING == dwCurrentState ) {
                                    Sleep(200);
                                } else {
                                    break;
                                }
                            }
                        }
                    } 
                }
                CloseServiceHandle (hService);
            } else {                
                dwStatus = GetLastError();
            }
            CloseServiceHandle (hSC);

        } else {
            dwStatus = GetLastError();
        }
    }    
    
    // Update the service configuration for automatic 
    // vs. manual start
    if ( ERROR_SUCCESS == dwStatus ) {
        // Ignore errors
        if ( NULL != GetRootNode() ) {
            GetRootNode()->UpdateServiceConfig();
        }
    }
    return dwStatus;
}

void
CSmLogService::SetBaseName( const CString& rstrName )
{
    // This method is only called within the service constructor,
    // so throw any errors
    m_strBaseName = rstrName;
    return;
}


const CString&
CSmLogService::GetDefaultLogFileFolder()
{
    if ( m_strDefaultLogFileFolder.IsEmpty() ) {
        LoadDefaultLogFileFolder();
    }
    return m_strDefaultLogFileFolder;
}


INT
CSmLogService::GetQueryCount()
{
    INT iQueryCount = -1;
    
    // The query count is only valid if the service is open.
    if ( IsOpen() ) {
        iQueryCount = (int) m_QueryList.GetCount();
    } else {
        ASSERT ( FALSE );
    }
    return iQueryCount;
}

DWORD
CSmLogService::FindDuplicateQuery (
                    const CString cstrName,
                    BOOL& rbFound )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HRESULT hrLocal = NOERROR;
    DWORD   dwQueryIndex = 0;
    LONG    lEnumStatus = ERROR_SUCCESS;
    WCHAR   szQueryKeyName[MAX_PATH + 1];
    DWORD   dwQueryKeyNameLen;
    LPWSTR  szCollectionName = NULL;
    UINT    uiCollectionNameLen = 0;
    FILETIME    ftLastWritten;
    HKEY    hKeyQuery = NULL;
    BOOL    bFoundFirst = FALSE;
    CString strDirectName;
    CString strLocalName;

    ASSERT ( !cstrName.IsEmpty() );

    rbFound = FALSE;
    if ( !cstrName.IsEmpty() ) {

        MFC_TRY
            strLocalName = cstrName;
        MFC_CATCH_DWSTATUS;

        if ( ERROR_SUCCESS == dwStatus ) {

            // Translate new query name if necessary
            hrLocal = SHLoadIndirectString( 
                strLocalName.GetBufferSetLength ( strLocalName.GetLength() ), 
                strDirectName.GetBufferSetLength ( MAX_PATH ), 
                MAX_PATH, 
                NULL );

            strLocalName.ReleaseBuffer();
            strDirectName.ReleaseBuffer();

            if ( FAILED ( hrLocal ) ) {
                // Query name is not an indirect string
                dwStatus = ERROR_SUCCESS;
                MFC_TRY
                    strDirectName = strLocalName;
                MFC_CATCH_DWSTATUS;
            }
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {

        // Search all queries for the specified query.

        dwQueryKeyNameLen = sizeof ( szQueryKeyName ) / sizeof ( WCHAR );
        memset (szQueryKeyName, 0, sizeof (szQueryKeyName));

        while ( ERROR_SUCCESS == ( lEnumStatus = RegEnumKeyExW (
                                                    m_hKeyLogService,
                                                    dwQueryIndex, 
                                                    szQueryKeyName, 
                                                    &dwQueryKeyNameLen,
                                                    NULL, 
                                                    NULL, 
                                                    NULL, 
                                                    &ftLastWritten ) ) ) {

            // open the query specified
            dwStatus = RegOpenKeyExW (
                m_hKeyLogService,
                szQueryKeyName,
                0,
                KEY_READ,
                &hKeyQuery);

            if ( ERROR_SUCCESS == dwStatus ) {

                // Query key is Guid if written by post Win2000 snapin.
                // Query key is name if written by Win2000 snapin.
                if ( 0 == strDirectName.CompareNoCase ( szQueryKeyName ) ) {
                    if ( TRUE == bFoundFirst ) {
                        rbFound = TRUE;
                        break;
                    } else {
                        bFoundFirst = TRUE;
                    }
                } else { 

                    dwStatus = CSmLogQuery::SmNoLocReadRegIndStrVal (
                                hKeyQuery,
                                IDS_REG_COLLECTION_NAME,
                                NULL,
                                &szCollectionName,
                                &uiCollectionNameLen );

                    ASSERT ( MAX_PATH >= uiCollectionNameLen );

                    if ( ERROR_SUCCESS == dwStatus ) {
                        if ( MAX_PATH >= uiCollectionNameLen ) {
                            if ( NULL != szCollectionName ) {
                                if ( L'\0' == *szCollectionName ) {
                                    G_FREE ( szCollectionName );
                                    szCollectionName = NULL;
                                }
                            }

                            if ( NULL == szCollectionName ) {
                                MFC_TRY
                                    szCollectionName = (LPWSTR)G_ALLOC ( (lstrlen(szQueryKeyName)+1)*sizeof(WCHAR));
                                MFC_CATCH_DWSTATUS;
                                if ( ERROR_SUCCESS == dwStatus && NULL != szCollectionName ) {
                                    StringCchCopy ( szCollectionName, lstrlen(szQueryKeyName)+1, szQueryKeyName );
                                }
                            } 

                            if ( NULL != szCollectionName ) {

                                // Compare found name to input name.
                                if ( 0 == strDirectName.CompareNoCase ( szCollectionName ) ) {
                                    if ( TRUE == bFoundFirst ) {
                                        rbFound = TRUE;
                                        break;
                                    } else {
                                        bFoundFirst = TRUE;
                                    }
                                }
                            } // Todo:  else report message?
                        }
                    } // Todo:  else report message?
                } // Todo:  else report message?
            }

            // set up for the next item in the list
            dwQueryKeyNameLen = sizeof (szQueryKeyName) / sizeof (szQueryKeyName[0]);
            memset (szQueryKeyName, 0, sizeof (szQueryKeyName));
            if ( NULL != hKeyQuery ) {
                RegCloseKey( hKeyQuery );
                hKeyQuery = NULL;
            }

            if ( NULL != szCollectionName ) {
                G_FREE ( szCollectionName );
                szCollectionName = NULL;
                uiCollectionNameLen = 0;
            }
            dwQueryIndex++;
        }
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    if ( NULL != szCollectionName ) {
        G_FREE ( szCollectionName );
        szCollectionName = NULL;
        uiCollectionNameLen = 0;
    }

    if ( NULL != hKeyQuery ) {
        RegCloseKey( hKeyQuery );
        hKeyQuery = NULL;
    }

    return dwStatus;
}

OS_TYPE    
CSmLogService::TargetOs( void )
{
    if ( 5 == m_OSVersion.dwMajorVersion) {
        if (2195 == m_OSVersion.dwBuild ) {
            return OS_WIN2K;
        } else if (2600 == m_OSVersion.dwBuild) {
            return OS_WINXP;
        } else if (OS_DOT_NET(m_OSVersion.dwBuild)) {
            return OS_WINNET;
        }
    }  
 
    return OS_NOT_SUPPORTED;
}

void
CSmLogService::SetRootNode ( CSmRootNode* pRootNode )
{ 
    m_pRootNode = pRootNode; 
}

        
CSmRootNode*    
CSmLogService::GetRootNode ( void )
{ 
    return m_pRootNode; 
}

BOOL
CSmLogService::CanAccessWbemRemote()
{
    HRESULT hr;
    IWbemLocator *pLocator = NULL;
    IWbemServices* pWbemServices = NULL;
    LPCWSTR szRoot[2] = { L"root\\perfmon",
                          L"root\\wmi"
                        };
    LPCWSTR szMask = L"\\\\%s\\%s";
    BSTR bszClass = SysAllocString(L"SysmonLog");
    BSTR bszNamespace = NULL;
    LPWSTR buffer = NULL;
    DWORD  dwBufLen;

    hr = CoCreateInstance(
                CLSID_WbemLocator,
                0,
                CLSCTX_INPROC_SERVER,
                IID_IWbemLocator,
                (LPVOID*)&pLocator );

    if (!SUCCEEDED(hr)) {
        goto Cleanup;
    }

    if ( !GetMachineName().IsEmpty()) {

        dwBufLen = max(wcslen(szRoot[0]), wcslen(szRoot[1])) + 
                   GetMachineName().GetLength() + 
                   wcslen( szMask );

        buffer = new WCHAR[dwBufLen];

        if ( buffer == NULL ){
            hr = ERROR_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    //
    // First try root\\perfmon, then root\\wmi, order matters
    //
    for (int i = 0; i < 2; i++) {
        if (bszNamespace) {
            SysFreeString(bszNamespace);
            bszNamespace = NULL;
        }

        if (buffer) {
            StringCchPrintf( buffer, dwBufLen, szMask, GetMachineName(), szRoot[i] );
            bszNamespace = SysAllocString( buffer );
        } 
        else {
            bszNamespace = SysAllocString(szRoot[i]);
        }

        hr = pLocator->ConnectServer(
                    bszNamespace,
                    NULL,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    NULL,
                    &pWbemServices);
        if (SUCCEEDED(hr)) {
            break;
        }
    }

Cleanup:
    if (buffer) {
        delete [] buffer;
    }

    if (bszNamespace) {
        SysFreeString(bszNamespace);
    }

    if (pLocator) {
        pLocator->Release();
    }

    if (pWbemServices) {
        pWbemServices->Release();
    }

    m_hWbemAccessStatus = hr;
    if (SUCCEEDED(hr)) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smlogs.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smlogs.h

Abstract:

    Base class representing the Performance Logs and Alerts
    service.

--*/

#ifndef _CLASS_SMLOGSERVICE_
#define _CLASS_SMLOGSERVICE_

#include "smnode.h"
#include "smlogqry.h"   // for query objects in the service
#include <pdhp.h>

class CSmRootNode;

//
// Need change the macro when .NET ships
//
#define OS_DOT_NET(buildNumber) ((buildNumber) >= 3500)

typedef enum {
    OS_NOT_SUPPORTED = 0,
    OS_WIN2K  = 1,
    OS_WINXP  = 2,
    OS_WINNET = 3
} OS_TYPE;

class CSmLogService : public CSmNode
{    
    // constructor/destructor
    public:
                CSmLogService();
        virtual ~CSmLogService();

    // public methods
    public:
        virtual DWORD   Open ( const CString& rstrMachineName );
        virtual DWORD   Close ( void );
                
                DWORD   Synchronize( void );
                BOOL    IsRunning( void );
                BOOL    IsOpen( void ){return m_bIsOpen; };
                INT     GetQueryCount( void );
        
                const CString&  GetDefaultLogFileFolder( void );
                DWORD   CreateDefaultLogQueries( void );
                OS_TYPE TargetOs ( void );
                BOOL    CanAccessWbemRemote();
                
        virtual DWORD   SyncWithRegistry( PSLQUERY* ppActiveQuery = NULL );

        virtual PSLQUERY    CreateQuery ( const CString& rstrName ) = 0;
        virtual DWORD       DeleteQuery ( PSLQUERY  plQuery );
        virtual DWORD       DeleteQuery ( const CString& rstrName );        // Unused method

        virtual CSmLogService* CastToLogService( void ) { return this; };

                BOOL    IsAutoStart ( VOID );

                void    SetRootNode ( CSmRootNode* pRootNode ); 
                void    SetRefreshOnShow ( BOOL bRefresh ) { m_bRefreshOnShow = bRefresh; };
                BOOL    GetRefreshOnShow ( void ) { return m_bRefreshOnShow; };

        DWORD   CheckForActiveQueries ( PSLQUERY* ppActiveQuery = NULL );

    // public member variables
    public:
        // list of queries 
        CTypedPtrList<CPtrList, PSLQUERY> m_QueryList;     
        HRESULT       m_hWbemAccessStatus;

    protected:

                void        SetBaseName( const CString& ); // Exception thrown on error
                PSLQUERY    CreateTypedQuery ( const CString& rstrName, DWORD dwLogType );
        virtual DWORD       LoadQueries( void ) = 0;
                DWORD       LoadQueries( DWORD dwLogType );
                HKEY        GetMachineRegistryKey ( void ) 
                                { ASSERT ( m_hKeyMachine ); return m_hKeyMachine; };
                
                void        SetOpen ( BOOL bOpen ) { m_bIsOpen = bOpen; };

    private:

        DWORD   GetState( void );
        DWORD   Install( const CString& rstrMachineName );
        DWORD   UnloadQueries ( PSLQUERY* ppActiveQuery = NULL );
        DWORD   LoadDefaultLogFileFolder( void );
        DWORD   UnloadSingleQuery ( PSLQUERY  pQuery );
        DWORD   LoadSingleQuery ( 
                    PSLQUERY*   ppQuery,
                    DWORD       dwLogType, 
                    const CString& rstrName,
                    const CString& rstrLogKeyName,
                    HKEY        hKeyQuery,
                    BOOL        bNew );

        DWORD   FindDuplicateQuery ( 
                    const CString cstrName,
                    BOOL& rbFound );

        CSmRootNode*    GetRootNode ( void );


        CString m_strBaseName;
        HKEY    m_hKeyMachine;
        HKEY    m_hKeyLogService;
        BOOL    m_bReadOnly;
        BOOL    m_bIsOpen;
        BOOL    m_bRefreshOnShow;

        CSmRootNode* m_pRootNode;

        HKEY    m_hKeyLogServiceRoot;
        CString m_strDefaultLogFileFolder;
        PLA_VERSION m_OSVersion;
};

typedef CSmLogService   SLSVC;
typedef CSmLogService*  PSLSVC;


#endif //_CLASS_SMLOGSERVICE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smlogcfg.cpp ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation

Module Name:

    smlogcfg.cpp

Abstract:

    Implementation of DLL exports.

--*/

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f Smlogcfgps.mk in the project directory.

#include "StdAfx.h"
#include <strsafe.h>
#include "InitGuid.h"
#include "compdata.h"
#include "smabout.h"
#include "smlogcfg.h"       // For CLSID_ComponentData
#include "Smlogcfg_i.c"     // For CLSID_ComponentData
#include <ntverp.h>
#include <wbemidl.h>
#include <Sddl.h>

USE_HANDLE_MACROS("SMLOGCFG(smlogcfg.cpp)")

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_ComponentData, CSmLogSnapin)
    OBJECT_ENTRY(CLSID_ExtensionSnapin, CSmLogExtension)
    OBJECT_ENTRY(CLSID_PerformanceAbout, CSmLogAbout)
END_OBJECT_MAP()


LPCWSTR g_cszAllowedPathKey = L"System\\CurrentControlSet\\Control\\SecurePipeServers\\winreg\\AllowedPaths";
LPCWSTR g_cszSysmonLogPath  = L"System\\CurrentControlSet\\Services\\SysmonLog";
LPCWSTR g_cszPerflibPath  = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
LPCWSTR g_cszMachine      = L"Machine";
LPCWSTR g_cszBasePath   = L"Software\\Microsoft\\MMC\\SnapIns";
LPCWSTR g_cszBaseNodeTypes  = L"Software\\Microsoft\\MMC\\NodeTypes";
LPCWSTR g_cszNameString = L"NameString";
LPCWSTR g_cszNameStringIndirect = L"NameStringIndirect";
LPCWSTR g_cszProvider   = L"Provider";
LPCWSTR g_cszVersion    = L"Version";
LPCWSTR g_cszAbout      = L"About";
LPCWSTR g_cszStandAlone = L"StandAlone";
LPCWSTR g_cszNodeType   = L"NodeType";
LPCWSTR g_cszNodeTypes  = L"NodeTypes";
LPCWSTR g_cszExtensions = L"Extensions";
LPCWSTR g_cszNameSpace  = L"NameSpace";

LPCWSTR g_cszRootNode   = L"Root Node";
LPCWSTR g_cszCounterLogsChild   = L"Performance Data Logs Child Under Root Node";
LPCWSTR g_cszTraceLogsChild = L"System Trace Logs Child Under Root Node";
LPCWSTR g_cszAlertsChild    = L"Alerts Child Under Root Node";

DWORD SetWbemSecurity( );

class CSmLogCfgApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
};

CSmLogCfgApp theApp;

BOOL CSmLogCfgApp::InitInstance()
{
    g_hinst = m_hInstance;               // Store global instance handle
    _Module.Init(ObjectMap, m_hInstance);

    SHFusionInitializeFromModuleID (m_hInstance, 2);
    
    InitializeCriticalSection ( &g_critsectInstallDefaultQueries );
    
    return CWinApp::InitInstance();
}

int CSmLogCfgApp::ExitInstance()
{
    DeleteCriticalSection ( &g_critsectInstallDefaultQueries );
    
    SHFusionUninitialize();
    
    _Module.Term();
    
    return CWinApp::ExitInstance();
}

//
// The function is here because of bug 611310 --hongg
//
DWORD 
LoadPerfUpdateWinRegAllowedPaths()
{
    DWORD   Status           = ERROR_SUCCESS;
    HKEY    hKey             = NULL;
    DWORD   dwType;
    DWORD   dwCurrentSize    = 0;
    DWORD   dwBufSize        = 0;
    DWORD   dwPerflibPath    = lstrlenW(g_cszPerflibPath) + 1;
    DWORD   dwSysmonLogPath  = lstrlenW(g_cszSysmonLogPath) + 1;
    LPWSTR  pBuf             = NULL;
    LPWSTR  pNextPath;
    BOOL    bPerfLibExists   = FALSE;
    BOOL    bSysmonLogExists = FALSE;
    HRESULT hr;

    //
    // Open AllowedPaths key
    //
    Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE, g_cszAllowedPathKey, 0L, KEY_READ | KEY_WRITE, & hKey);
    if (Status == ERROR_SUCCESS) {
        //
        // Read the Machine value under AllowedPaths key
        //
        dwType = REG_MULTI_SZ;
        Status = RegQueryValueExW(hKey, g_cszMachine, NULL, & dwType, NULL, & dwCurrentSize);

        if (Status == ERROR_SUCCESS) {
            if (dwType != REG_MULTI_SZ) {
                Status = ERROR_DATATYPE_MISMATCH;
            }
        }

        if (Status == ERROR_SUCCESS) {
            //
            // In case that PerfLibPath and SysmonLogPath don't exist,
            // preallocate memory for PerfLibPath and SysmonLogPath
            //
            dwBufSize = dwCurrentSize + (dwPerflibPath + dwSysmonLogPath + 1) * sizeof(WCHAR);
            pBuf      = (LPWSTR)malloc(dwBufSize);
            if (pBuf == NULL) {
                Status = ERROR_OUTOFMEMORY;
            }
            else {
                *pBuf = L'\0';
                Status = RegQueryValueExW(hKey, g_cszMachine, NULL, & dwType, (LPBYTE) pBuf, & dwCurrentSize);
            }
        }
    }

    //
    // Scan the AllowedPaths to determine if we need to
    // update it.
    //
    if (Status == ERROR_SUCCESS && pBuf != NULL) {
        pNextPath = pBuf;
        while (* pNextPath != L'\0') {
            if (lstrcmpiW(pNextPath, g_cszPerflibPath) == 0) {
                bPerfLibExists = TRUE;
            }
            if (lstrcmpiW(pNextPath, g_cszSysmonLogPath) == 0) {
                bSysmonLogExists = TRUE;
            }
            pNextPath += lstrlenW(pNextPath) + 1;
        }

        if (! bPerfLibExists) {
            hr = StringCchCopyW(pNextPath, dwPerflibPath, g_cszPerflibPath);
            dwCurrentSize += dwPerflibPath * sizeof(WCHAR);
            pNextPath     += dwPerflibPath;
        }

        if (! bSysmonLogExists) {
            hr = StringCchCopyW(pNextPath, dwSysmonLogPath, g_cszSysmonLogPath);
            dwCurrentSize += dwSysmonLogPath * sizeof(WCHAR);
            pNextPath     += dwSysmonLogPath;
        }

        //
        // Add an extra L'\0' for MULTI_SZ
        //
        * pNextPath = L'\0';

        if (! (bPerfLibExists && bSysmonLogExists)) {
            Status = RegSetValueExW(hKey, g_cszMachine, 0L, dwType, (LPBYTE) pBuf, dwCurrentSize);
        }
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (pBuf) {
        free(pBuf);
    }

    return Status;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    // test for snap-in or extension snap-in guid and differentiate the 
    // returned object here before returning (not implemented yet...)
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry
//
STDAPI DllRegisterServer(void)
{
    HRESULT   hr = S_OK;
    HKEY hMmcSnapinsKey  = NULL;
    HKEY hMmcNodeTypesKey = NULL;
    HKEY hSmLogMgrParentKey = NULL;
    HKEY hStandAloneKey = NULL;
    HKEY hNodeTypesKey  = NULL;
    HKEY hTempNodeKey   = NULL;
    HKEY hNameSpaceKey  = NULL;
    LONG nErr           = 0;
    WCHAR   pBuffer[_MAX_PATH+1];           // NOTE: Use for Provider, Version and module name strings
    size_t  nLen;
    CString strName;
    LPWSTR  szModule = NULL;
    UINT    iModuleLen = 0;
    LPWSTR  szSystemPath = NULL;
    UINT    iSystemPathLen = 0;
    int     iRetry;
    DWORD   dwReturn;

    AFX_MANAGE_STATE (AfxGetStaticModuleState ());

    SetWbemSecurity( );

#ifdef _X86_
    BOOL      bWow64Process;
#endif

    //
    // Get system directory
    //
    iSystemPathLen = MAX_PATH + 14;
    iRetry = 4;
    do {
        // 
        // We also need to append "\smlogcfg.dll" to the system path
        // So allocate an extra 14 characters for it.
        //
        szSystemPath = (LPWSTR)malloc(iSystemPathLen * sizeof(WCHAR));
        if (szSystemPath == NULL) {
            hr = E_OUTOFMEMORY;
            break;
        }

        dwReturn = GetSystemDirectory(szSystemPath, iSystemPathLen);
        if (dwReturn == 0) {
            hr = E_UNEXPECTED;
            break;
        }

        //
        // The buffer is not big enough, try to allocate a biggers one
        // and retry
        //
        if (dwReturn >= iSystemPathLen - 14) {
            iSystemPathLen = dwReturn + 14;
            free(szSystemPath);
            szSystemPath = NULL;
            hr = E_UNEXPECTED;
        }
        else {
            hr = S_OK;
            break;
        }
    } while (iRetry--);

    //
    // Get module file name
    //
    if (SUCCEEDED(hr)) {
        iRetry = 4;

        //
        // The length initialized to iModuleLen must be longer
        // than the length of "%systemroot%\\system32\\smlogcfg.dll"
        //
        iModuleLen = MAX_PATH + 1;
        
        do {
            szModule = (LPWSTR) malloc(iModuleLen * sizeof(WCHAR));
            if (szModule == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            dwReturn = GetModuleFileName(AfxGetInstanceHandle(), szModule, iModuleLen);
            if (dwReturn == 0) {
                hr = E_UNEXPECTED;
                break;
            }
            
            //
            // The buffer is not big enough, try to allocate a biggers one
            // and retry
            //
            if (dwReturn >= iModuleLen) {
                iModuleLen *= 2;
                free(szModule);
                szModule = NULL;
                hr = E_UNEXPECTED;
            }
            else {
                hr = S_OK;
                break;
            }

        } while (iRetry--);
    }

    if (FAILED(hr)) {
        goto CleanUp;
    }

    //
    // Check if we are in system directory, the control can be 
    // registered iff when it is system directory
    //
    StringCchCat(szSystemPath, iSystemPathLen, L"\\smlogcfg.dll");

    if (lstrcmpi(szSystemPath, szModule) != 0) {
#ifdef _X86_

        //
        // Lets try to see if this is a Wow64 process
        //

        if ((IsWow64Process (GetCurrentProcess(), &bWow64Process) == TRUE) &&
            (bWow64Process == TRUE))
        {

            int iLength = GetSystemWow64Directory (szSystemPath, iSystemPathLen);

            if (iLength > 0) {
                
                szSystemPath [iLength] = L'\\';
                if (lstrcmpi(szSystemPath, szModule) == 0) {
                    goto done;
                }
            }
        }
#endif
        hr = E_UNEXPECTED;
        goto CleanUp;
    }

#ifdef _X86_
done:
#endif

    if (ERROR_SUCCESS != LoadPerfUpdateWinRegAllowedPaths()) {
        hr = E_UNEXPECTED;
        goto CleanUp;
    }

    //DebugBreak();                  // Uncomment this to step through registration

    // Open the MMC Parent keys
    nErr = RegOpenKey( HKEY_LOCAL_MACHINE,
                       g_cszBasePath,
                       &hMmcSnapinsKey
                       );
    if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Open MMC Snapins Key Failed" );
  
    // Create the ID for our ICompnentData Interface
    // The ID was generated for us, because we used a Wizard to create the app.
    // Take the ID for CComponentData in the IDL file.
    //
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // Make sure you change this if you use this code as a starting point!
    // Change other IDs as well below!
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    if (hMmcSnapinsKey) {
        nErr = RegCreateKey(  
                        hMmcSnapinsKey,
                        GUIDSTR_ComponentData,
                        &hSmLogMgrParentKey
                        );
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"CComponentData Key Failed" );
      if (hSmLogMgrParentKey) {

        STANDARD_TRY
            strName.LoadString ( IDS_MMC_DEFAULT_NAME );
        MFC_CATCH_MINIMUM

        if ( strName.IsEmpty() ) {
            DisplayError ( ERROR_OUTOFMEMORY,
                L"Unable to load snap-in name string." );
        }

        // This is the name we see when we add the Snap-In to the console
        nErr = RegSetValueEx( hSmLogMgrParentKey,
                          g_cszNameString,
                          0,
                          REG_SZ,
                          (LPBYTE)strName.GetBufferSetLength( strName.GetLength() ),
                          strName.GetLength() * (DWORD)sizeof(WCHAR)
                          );

        if( ERROR_SUCCESS != nErr )
          DisplayError( GetLastError(), L"Set NameString Failed" );

        // This is the indirect name we see when we add the Snap-In to the console.  
        // Added for MUI support.  Use the same name string as for NameString.
        STANDARD_TRY
            strName.Format (L"@%s,-%d", szModule, IDS_MMC_DEFAULT_NAME );
        MFC_CATCH_MINIMUM

        if ( strName.IsEmpty() ) {
            DisplayError ( ERROR_OUTOFMEMORY,
                L"Unable to load snap-in indirect name string." );
        }

        nErr = RegSetValueEx( hSmLogMgrParentKey,
                          g_cszNameStringIndirect,
                          0,
                          REG_SZ,
                          (LPBYTE)strName.GetBufferSetLength( strName.GetLength() ),
                          strName.GetLength() * (DWORD)sizeof(WCHAR)
                          );

        if( ERROR_SUCCESS != nErr )
          DisplayError( GetLastError(), L"Set NameStringIndirect Failed" );

        // This is the primary node, or class which implements CComponentData
        nErr = RegSetValueEx( hSmLogMgrParentKey,
                          g_cszNodeType,
                          0,
                          REG_SZ,
                          (LPBYTE)GUIDSTR_RootNode,
                          (DWORD)((lstrlen(GUIDSTR_RootNode)+1) * sizeof(WCHAR))
                          );
        if( ERROR_SUCCESS != nErr )
          DisplayError( GetLastError(), L"Set NodeType Failed" );

        // This is the About box information
        nErr = RegSetValueEx( hSmLogMgrParentKey,
                          g_cszAbout,
                          0,
                          REG_SZ,
                          (LPBYTE)GUIDSTR_PerformanceAbout,
                          (DWORD)((lstrlen(GUIDSTR_PerformanceAbout)+1) * sizeof(WCHAR))
                          );

        if( ERROR_SUCCESS != nErr )
          DisplayError( GetLastError(), L"Set About Failed" );

        nLen = strlen(VER_COMPANYNAME_STR);
    #ifdef UNICODE
        nLen = mbstowcs(pBuffer, VER_COMPANYNAME_STR, nLen);
        pBuffer[nLen] = UNICODE_NULL;
    #else
        strcpy(pBuffer, VER_COMPANYNAME_STR);
        pBuffer[nLen] = ANSI_NULL;
    #endif
        nErr = RegSetValueEx( hSmLogMgrParentKey,
                        g_cszProvider,
                        0,
                        REG_SZ,
                        (LPBYTE)pBuffer,
                        (DWORD)((nLen+1) * sizeof(WCHAR))
                        );

        if( ERROR_SUCCESS != nErr )
          DisplayError( GetLastError(), L"Set Provider Failed" );

        nLen = strlen(VER_PRODUCTVERSION_STR);
    #ifdef UNICODE
        nLen = mbstowcs(pBuffer, VER_PRODUCTVERSION_STR, nLen);
        pBuffer[nLen] = UNICODE_NULL;
    #else
        strcpy(pBuffer, VER_PRODUCTVERSION_STR);
        pBuffer[nLen] = ANSI_NULL;
    #endif
        nErr = RegSetValueEx( hSmLogMgrParentKey,
                        g_cszVersion,
                        0,
                        REG_SZ,
                        (LPBYTE)pBuffer,
                        (DWORD)((nLen+1) * sizeof(WCHAR))
                        );

        if( ERROR_SUCCESS != nErr )
          DisplayError( GetLastError(), L"Set Version Failed" );

        // We are a stand alone snapin, so set the key for this
        nErr = RegCreateKey( 
                hSmLogMgrParentKey, 
                g_cszStandAlone, 
                &hStandAloneKey);
        if( ERROR_SUCCESS != nErr )
          DisplayError( GetLastError(), L"Create StandAlone Key Failed" );

        if (hStandAloneKey) {
          // StandAlone has no children, so close it
          nErr = RegCloseKey( hStandAloneKey );              
          if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(), L"Close StandAlone Failed" );
        }

        // Set the node types that appear in our snapin
        nErr = RegCreateKey ( 
                hSmLogMgrParentKey, 
                g_cszNodeTypes, 
                &hNodeTypesKey );
        if( ERROR_SUCCESS != nErr )
          DisplayError( GetLastError(), L"Create NodeTypes Key Failed" );

        if (hNodeTypesKey) {
          // Here is our root node.  Used uuidgen to get it
          nErr = RegCreateKey( hNodeTypesKey,
                       GUIDSTR_RootNode,
                       &hTempNodeKey
                       );
          if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(), L"Create RootNode Key Failed" );

          if (hTempNodeKey) {
            nErr = RegSetValueEx(   hTempNodeKey,
                        NULL,
                        0,
                        REG_SZ,
                        (LPBYTE)g_cszRootNode,
                        (DWORD)((lstrlen(g_cszRootNode) + 1) * sizeof(WCHAR))
                            );
            if( ERROR_SUCCESS != nErr )
                DisplayError( GetLastError(), L"Set Root Node String Failed" );

            nErr = RegCloseKey( hTempNodeKey ); // Close it for handle reuse

            if( ERROR_SUCCESS != nErr )
               DisplayError( GetLastError(), L"Close RootNode Failed" );
          }

          // Here are our child nodes under the root node. Used uuidgen
          // to get them for Counter Logs
          hTempNodeKey = NULL;
          nErr = RegCreateKey(  hNodeTypesKey,
                        GUIDSTR_CounterMainNode,
                        &hTempNodeKey
                        );
          if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(),
                L"Create Child Performance Data Logs Node Key Failed" );

            if (hTempNodeKey) {
              nErr = RegSetValueEx( hTempNodeKey,
                          NULL,
                          0,
                          REG_SZ,
                          (LPBYTE)g_cszCounterLogsChild,
                          (DWORD)((lstrlen(g_cszCounterLogsChild) + 1) * sizeof(WCHAR))
                          );
              if( ERROR_SUCCESS != nErr )
                 DisplayError( GetLastError(),
                    L"Set Performance Data Logs Child Node String Failed" );

              nErr = RegCloseKey( hTempNodeKey );  // Close it for handle reuse
              if( ERROR_SUCCESS != nErr )
                DisplayError( GetLastError(),
                    L"Close Performance Data Logs Child Node Key Failed" );
            }

            // System Trace Logs
            hTempNodeKey = NULL;
            nErr = RegCreateKey(    hNodeTypesKey,
                        GUIDSTR_TraceMainNode,
                        &hTempNodeKey
                        );
            if( ERROR_SUCCESS != nErr )
              DisplayError( GetLastError(),
                L"Create Child System Trace Logs Node Key Failed" );

            if (hTempNodeKey) {
              nErr = RegSetValueEx( hTempNodeKey,
                          NULL,
                          0,
                          REG_SZ,
                          (LPBYTE)g_cszTraceLogsChild,
                          (DWORD)((lstrlen(g_cszTraceLogsChild) + 1) * sizeof(WCHAR))
                          );
              if( ERROR_SUCCESS != nErr )
                DisplayError( GetLastError(),
                    L"Set System Trace Logs Child Node String Failed" );

              nErr = RegCloseKey( hTempNodeKey );  // Close it for handle reuse
              if( ERROR_SUCCESS != nErr )
                DisplayError( GetLastError(),
                    L"Close System Trace Logs Child Node Key Failed" );
            }

            // Alerts
            hTempNodeKey = NULL;
            nErr = RegCreateKey(hNodeTypesKey,
                        GUIDSTR_AlertMainNode,
                        &hTempNodeKey
                        );
            if( ERROR_SUCCESS != nErr )
              DisplayError( GetLastError(),
                L"Create Child Alerts Node Key Failed" );

            if (hTempNodeKey) {
              nErr = RegSetValueEx( hTempNodeKey,
                          NULL,
                          0,
                          REG_SZ,
                          (LPBYTE)g_cszAlertsChild,
                          (DWORD)((lstrlen(g_cszAlertsChild) + 1) * sizeof(WCHAR))
                          );
              if( ERROR_SUCCESS != nErr )
                DisplayError( GetLastError(),
                    L"Set Alerts Child Node String Failed" );

              nErr = RegCloseKey( hTempNodeKey );
              if( ERROR_SUCCESS != nErr )
                DisplayError( GetLastError(),
                    L"Close Alerts Child Node Key Failed" );
            }

            nErr = RegCloseKey( hNodeTypesKey  );
            if( ERROR_SUCCESS != nErr )
              DisplayError( GetLastError(), L"Close Node Types Key Failed" );
        }

        // close the standalone snapin GUID key
        nErr = RegCloseKey( hSmLogMgrParentKey );
        if( ERROR_SUCCESS != nErr )
          DisplayError( GetLastError(), L"Close SmLogManager GUID Key Failed" );
      }

      // register the extension snap-in with the MMC
      hSmLogMgrParentKey = NULL;
      nErr = RegCreateKey(  hMmcSnapinsKey,
                        GUIDSTR_SnapInExt,
                        &hSmLogMgrParentKey
                        );
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Snapin Extension Key creation Failed" );

      STANDARD_TRY
          strName.LoadString ( IDS_MMC_DEFAULT_EXT_NAME );
      MFC_CATCH_MINIMUM

      if ( strName.IsEmpty() ) {
          DisplayError ( ERROR_OUTOFMEMORY,
            L"Unable to load snap-in extension name string." );
      }

      if (hSmLogMgrParentKey) {
          // This is the name we see when we add the snap-in extension
          nErr = RegSetValueEx( hSmLogMgrParentKey,
                          g_cszNameString,
                          0,
                          REG_SZ,
                          (LPBYTE)strName.GetBufferSetLength( strName.GetLength() ),
                          strName.GetLength() * (DWORD)sizeof(WCHAR)
                          );
          strName.ReleaseBuffer();
          if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(), L"Set Extension NameString Failed" );

          // This is the name we see when we add the snap-in extension.  MUI support.
          // Use the same name string as for NameString;
            STANDARD_TRY
                strName.Format (L"@%s,-%d", szModule, IDS_MMC_DEFAULT_EXT_NAME );
            MFC_CATCH_MINIMUM

            if ( strName.IsEmpty() ) {
                DisplayError ( ERROR_OUTOFMEMORY,
                    L"Unable to load extension indirect name string." );
            }

            nErr = RegSetValueEx( hSmLogMgrParentKey,
                          g_cszNameStringIndirect,
                          0,
                          REG_SZ,
                          (LPBYTE)strName.GetBufferSetLength( strName.GetLength() ),
                          strName.GetLength() * (DWORD)sizeof(WCHAR)
                          );
            strName.ReleaseBuffer();
            if( ERROR_SUCCESS != nErr )
                DisplayError( GetLastError(), L"Set Extension NameStringIndirect Failed" );

            // This is the Extension About box information

            nErr = RegSetValueEx( 
                    hSmLogMgrParentKey,
                    g_cszAbout,
                    0,
                    REG_SZ,
                    (LPBYTE)GUIDSTR_PerformanceAbout,
                    ((lstrlen(GUIDSTR_PerformanceAbout)+1) * (DWORD)sizeof(WCHAR))
                    );

          if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(), L"Set Extension About Failed" );

          nLen = strlen(VER_COMPANYNAME_STR);
    #ifdef UNICODE
          nLen = mbstowcs(pBuffer, VER_COMPANYNAME_STR, nLen);
          pBuffer[nLen] = UNICODE_NULL;
    #else
          strcpy(pBuffer, VER_COMPANYNAME_STR);
          pBuffer[nLen] = ANSI_NULL;
    #endif
          nErr = RegSetValueEx( hSmLogMgrParentKey,
                        g_cszProvider,
                        0,
                        REG_SZ,
                        (LPBYTE)pBuffer,
                        (DWORD)((nLen+1) * sizeof(WCHAR))
                        );

          if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(), L"Set Provider Failed" );

          nLen = strlen(VER_PRODUCTVERSION_STR);
    #ifdef UNICODE
          nLen = mbstowcs(pBuffer, VER_PRODUCTVERSION_STR, nLen);
          pBuffer[nLen] = UNICODE_NULL;
    #else
          strcpy(pBuffer, VER_PRODUCTVERSION_STR);
          pBuffer[nLen] = ANSI_NULL;
    #endif
          nErr = RegSetValueEx( hSmLogMgrParentKey,
                        g_cszVersion,
                        0,
                        REG_SZ,
                        (LPBYTE)pBuffer,
                        (DWORD)((nLen+1) * sizeof(WCHAR))
                        );

          if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(), L"Set Version Failed" );

    // close the main keys
          nErr = RegCloseKey( hSmLogMgrParentKey );
          if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(), L"Close Snapin Extension Key Failed");
      }

      // register this as a "My Computer"-"System Tools" snapin extension

      nErr = RegOpenKey( HKEY_LOCAL_MACHINE,
                       g_cszBaseNodeTypes,
                       &hMmcNodeTypesKey
                       );
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Open MMC NodeTypes Key Failed" );

      // create/open the GUID of the System Tools Node of the My Computer snap-in

      if (hMmcNodeTypesKey) {
          nErr = RegCreateKey ( hMmcNodeTypesKey,
                       lstruuidNodetypeSystemTools,
                       &hNodeTypesKey
                       );
          if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(),
                L"Create/open System Tools GUID Key Failed" );

          if (hNodeTypesKey) {
              hTempNodeKey = NULL;
              nErr = RegCreateKey ( hNodeTypesKey,
                       g_cszExtensions,
                       &hTempNodeKey
                       );

              if( ERROR_SUCCESS != nErr )
                    DisplayError( 
                        GetLastError(),
                        L"Create/open System Tools Extensions Key Failed" );

              if (hTempNodeKey) {
                    nErr = RegCreateKey ( 
                        hTempNodeKey,
                        g_cszNameSpace,
                        &hNameSpaceKey
                        );

                if( ERROR_SUCCESS != nErr )
                  DisplayError( GetLastError(),
                      L"Create/open System Tools NameSpace Key Failed" );

                if (hNameSpaceKey) {
                    nErr = RegSetValueEx( hNameSpaceKey,
                          GUIDSTR_SnapInExt,
                          0,
                          REG_SZ,
                          (LPBYTE)strName.GetBufferSetLength( strName.GetLength() ),
                          strName.GetLength() * (DWORD)sizeof(WCHAR)
                          );
                    strName.ReleaseBuffer();
                    if( ERROR_SUCCESS != nErr ) {
                      DisplayError( GetLastError(),
                        L"Set Extension NameString Failed" );
                      DisplayError( GetLastError(),
                        L"Set Snapin Extension NameString Failed" );
                    }

                    nErr = RegCloseKey( hNameSpaceKey  );
                    if( ERROR_SUCCESS != nErr )
                      DisplayError( GetLastError(),
                          L"Close NameSpace Key Failed" );
                }

                nErr = RegCloseKey( hTempNodeKey  );
                if( ERROR_SUCCESS != nErr )
                  DisplayError( GetLastError(), L"Close Extension Key Failed" );
              }

              nErr = RegCloseKey( hNodeTypesKey  );
              if( ERROR_SUCCESS != nErr )
                DisplayError( GetLastError(),
                    L"Close My Computer System GUID Key Failed" );
          }

          nErr = RegCloseKey( hMmcNodeTypesKey );
          if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(), L"Close MMC NodeTypes Key Failed" );
      }
      nErr = RegCloseKey( hMmcSnapinsKey );
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Close MMC Snapins Key Failed" );
    }

    // Register extension Snap in
    nErr = _Module.UpdateRegistryFromResource(IDR_EXTENSION, TRUE);
    // Registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);

CleanUp:
    if (szSystemPath) {
        free(szSystemPath);
    }
    if (szModule) {
        free(szModule);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
  HKEY hMmcSnapinsKey  = NULL;          // MMC parent key
  HKEY hSmLogMgrParentKey = NULL;          // Our Snap-In key  - has children
  HKEY hNodeTypesKey  = NULL;          // Our NodeType key - has children
  HKEY hSysToolsNode = NULL;
  HKEY hExtension = NULL;
  HKEY hNameSpace = NULL;
  LONG nErr           = 0;

  // DebugBreak();                       // Uncomment this to step through UnRegister

  // Open the MMC parent key
  nErr = RegOpenKey( HKEY_LOCAL_MACHINE,
                     g_cszBasePath,
                     &hMmcSnapinsKey
                   );
  if( ERROR_SUCCESS != nErr )
    DisplayError( GetLastError(), L"Open MMC Parent Key Failed"  ); 

  // Open our Parent key
  nErr = RegOpenKey( hMmcSnapinsKey,
                     GUIDSTR_ComponentData,
                     &hSmLogMgrParentKey
                   );
  if( ERROR_SUCCESS != nErr )
    DisplayError( GetLastError(), L"Open Disk Parent Key Failed" );
  
  // Now open the NodeTypes key
  nErr = RegOpenKey( hSmLogMgrParentKey,       // Handle of parent key
                     g_cszNodeTypes,         // Name of key to open
                     &hNodeTypesKey        // Handle to newly opened key
                   );
  if( ERROR_SUCCESS != nErr )
     DisplayError( GetLastError(), L"Open NodeTypes Key Failed"  );

  if (hNodeTypesKey) {
      // Delete the root node key 
      nErr = RegDeleteKey( hNodeTypesKey, GUIDSTR_RootNode );  
      if( ERROR_SUCCESS != nErr )
         DisplayError( GetLastError(), L"Delete Root Node Key Failed"  );

      // Delete the child node key
      // *** From Beta 2
      nErr = RegDeleteKey( hNodeTypesKey, GUIDSTR_MainNode );  

      // Delete the child node keys
      // Counter logs
      nErr = RegDeleteKey( hNodeTypesKey, GUIDSTR_CounterMainNode );  
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Delete Performance Logs and Alerts Child Node Key Failed"  );
  
      // System Trace Logs
      nErr = RegDeleteKey( hNodeTypesKey, GUIDSTR_TraceMainNode );  
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Delete System Trace Logs Child Node Key Failed"  );
  
      // Alerts
      nErr = RegDeleteKey( hNodeTypesKey, GUIDSTR_AlertMainNode );  
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Delete Alerts Child Node Key Failed"  );
  
      // Close the node type key so we can delete it
      nErr = RegCloseKey( hNodeTypesKey ); 
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Close NodeTypes Key failed"  );
  }

  // Delete the NodeTypes key
  if (hSmLogMgrParentKey) {
      nErr = RegDeleteKey( hSmLogMgrParentKey, L"NodeTypes" );  
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Delete NodeTypes Key failed"  );
  
      // StandAlone key has no children so we can delete it now
      nErr = RegDeleteKey( 
                hSmLogMgrParentKey, 
                g_cszStandAlone );
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Delete StandAlone Key Failed"  ); 
  
      // Close our Parent Key
      nErr = RegCloseKey( hSmLogMgrParentKey );
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Close Disk Parent Key Failed"  ); 
  }

  if (hMmcSnapinsKey) {
      // Now we can delete our Snap-In key since the children are gone
      nErr = RegDeleteKey( hMmcSnapinsKey, GUIDSTR_ComponentData );  
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Delete Performance Logs and Alerts GUID Key Failed"  ); 

      // Now we can delete our Snap-In Extension key 
      nErr = RegDeleteKey( hMmcSnapinsKey, GUIDSTR_SnapInExt);  
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Delete Performance Logs and Alerts GUID Key Failed"  ); 

      nErr = RegCloseKey( hMmcSnapinsKey );
      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(), L"Close MMC Parent Key Failed"  ); 
  }

  // delete snap-in extension entry

  hNodeTypesKey = NULL;
  // Open the MMC parent key
  nErr = RegOpenKey( HKEY_LOCAL_MACHINE,
                     g_cszBaseNodeTypes,
                     &hNodeTypesKey
                   );
  if( ERROR_SUCCESS != nErr )
    DisplayError( GetLastError(), L"Open of MMC NodeTypes Key Failed"  ); 

  if (hNodeTypesKey) {
      hSysToolsNode = NULL;
      nErr = RegOpenKey (hNodeTypesKey,
                    lstruuidNodetypeSystemTools,
                    &hSysToolsNode
                    );

      if( ERROR_SUCCESS != nErr )
        DisplayError( GetLastError(),
            L"Open of My Computer System Tools Key Failed"  ); 

      if (hSysToolsNode) {
          hExtension = NULL;
          nErr = RegOpenKey (hSysToolsNode,
                    g_cszExtensions,
                    &hExtension
                    );

         if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(), L"Open of Extensions Key Failed"  ); 

         if (hExtension) {
              hNameSpace = NULL;
              nErr = RegOpenKey (hExtension,
                    g_cszNameSpace,
                    &hNameSpace
                    );

              if( ERROR_SUCCESS != nErr )
                  DisplayError( GetLastError(),
                    L"Open of Name Space Key Failed"  ); 

              if (hNameSpace) {
                  nErr = RegDeleteValue (hNameSpace, GUIDSTR_SnapInExt);

                  if( ERROR_SUCCESS != nErr )
                      DisplayError( GetLastError(),
                            L"Unable to remove the Snap-in Ext. GUID"  ); 

                  // close keys
                  nErr = RegCloseKey( hNameSpace );
                  if( ERROR_SUCCESS != nErr )
                      DisplayError( GetLastError(),
                        L"Close NameSpace Key Failed"  ); 
              }

              nErr = RegCloseKey( hExtension);
              if( ERROR_SUCCESS != nErr )
                  DisplayError(GetLastError(), L"Close Extension Key Failed"); 
        }

        nErr = RegCloseKey( hSysToolsNode );
        if( ERROR_SUCCESS != nErr )
            DisplayError( GetLastError(),
                L"Close My Computer System Tools Key Failed"  ); 
      }

      nErr = RegCloseKey( hNodeTypesKey);
      if( ERROR_SUCCESS != nErr )
          DisplayError( GetLastError(), L"Close MMC Node Types Key Failed"  ); 
  }

  _Module.UnregisterServer();
  return S_OK;
}

DWORD
SetWbemSecurity( )
{
    HRESULT hr;
    IWbemLocator *pLocator = NULL;
    BSTR bszNamespace  = SysAllocString( L"\\\\.\\root\\perfmon" );
    BSTR bszClass = SysAllocString( L"__SystemSecurity" );
    BSTR bszClassSingle = SysAllocString( L"__SystemSecurity=@" );
    BSTR bszMethodName = SysAllocString( L"SetSD" );

    IWbemClassObject* pWbemClass = NULL;
    IWbemServices* pWbemServices = NULL;
    IWbemClassObject* pInClass = NULL;
    IWbemClassObject* pInInst = NULL;

    BOOL bResult = TRUE;

    PSECURITY_DESCRIPTOR  SD = NULL;
    DWORD dwAclSize;

    SAFEARRAYBOUND saBound;
    BYTE* pData;
    SAFEARRAY * pSa;
    VARIANT vArray;

    if( NULL == bszNamespace ||
        NULL == bszClass ||
        NULL == bszClassSingle ||
        NULL == bszMethodName ){

        hr = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    VariantInit( &vArray );
     
    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if( S_FALSE == hr ){
        hr = ERROR_SUCCESS;
    }

    hr = CoCreateInstance(
                CLSID_WbemLocator, 
                0, 
                CLSCTX_INPROC_SERVER,
                IID_IWbemLocator, 
                (LPVOID*)&pLocator
            );
    if(FAILED(hr)){ goto cleanup; }

    hr = pLocator->ConnectServer( 
                bszNamespace, 
                NULL, 
                NULL, 
                NULL, 
                0, 
                NULL, 
                NULL, 
                &pWbemServices 
            );
    if(FAILED(hr)){ goto cleanup; }

    hr = pWbemServices->GetObject( bszClass, 0, NULL, &pWbemClass, NULL);
    if(FAILED(hr)){ goto cleanup; }

    hr = pWbemClass->GetMethod( bszMethodName, 0, &pInClass, NULL); 
    if(FAILED(hr)){ goto cleanup; }

    hr = pInClass->SpawnInstance(0, &pInInst);
    if(FAILED(hr)){ goto cleanup; }
    
    LPWSTR pSSDLString = L"O:BAG:BAD:(A;;0x23;;;LU)";
    bResult = ConvertStringSecurityDescriptorToSecurityDescriptorW(
        pSSDLString,
        SDDL_REVISION_1, 
        &SD, 
        &dwAclSize);
    if( !bResult ){ goto cleanup; }

    saBound.lLbound = 0;
    saBound.cElements = dwAclSize;

    pSa = SafeArrayCreate(VT_UI1,1,&saBound);
    if( NULL == pSa ){
        hr = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    SafeArrayAccessData(pSa, (void**)&pData); 
    memcpy(pData,SD,dwAclSize);
    SafeArrayUnaccessData( pSa );
   
    vArray.vt = VT_ARRAY | VT_UI1;
    vArray.parray = pSa;

    hr = pInInst->Put( L"SD", 0, &vArray, 0 );
    if(FAILED(hr)){ goto cleanup; }

    hr = pWbemServices->ExecMethod( 
            bszClassSingle, 
            bszMethodName,
            0, 
            NULL, 
            pInInst,
            NULL, 
            NULL);
    if(FAILED(hr)){ goto cleanup; }


cleanup:
    if( !bResult ){
        hr = GetLastError();
    }
        
    VariantClear( &vArray );
    
    if( pLocator != NULL ){
        pLocator->Release();
    }
    if( pWbemClass != NULL ){
        pWbemClass->Release();
    }
    if( pWbemServices != NULL ){
        pWbemServices->Release();
    }
    if( pInInst != NULL ){
        pInInst->Release();
    }
    if( NULL != SD ){
        LocalFree( SD );
    }
    SysFreeString( bszNamespace );
    SysFreeString( bszClass );
    SysFreeString( bszClassSingle );
    SysFreeString( bszMethodName );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smnode.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smnode.cpp

Abstract:

    Implements the MMC user interface node base class.

--*/

#include "Stdafx.h"
#include "smnode.h"

USE_HANDLE_MACROS("SMLOGCFG(smnode.cpp)");
//
//  Constructor
CSmNode::CSmNode()
: m_pParentNode ( NULL )
{
    return;
}

//
//  Destructor
CSmNode::~CSmNode()
{
    return;
}

const CString&
CSmNode::GetDisplayName()
{
    return m_strName;
}

const CString&
CSmNode::GetMachineName()
{
    return m_strMachineName;
}

const CString&
CSmNode::GetMachineDisplayName()
{
    return m_strMachineDisplayName;
}

const CString&
CSmNode::GetDescription()
{
    return m_strDesc;
}

const CString&
CSmNode::GetType()
{
    return m_strType;
}

DWORD
CSmNode::SetDisplayName( const CString& rstrName )
{
	DWORD dwStatus = ERROR_SUCCESS;

    MFC_TRY
        m_strName = rstrName;
	MFC_CATCH_DWSTATUS

    return dwStatus;
}

DWORD
CSmNode::SetMachineName( const CString& rstrMachineName )
{
	DWORD dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        m_strMachineName = rstrMachineName;

        if ( !rstrMachineName.IsEmpty() ) {
            m_strMachineDisplayName = rstrMachineName;
        } else {
            m_strMachineDisplayName.LoadString ( IDS_LOCAL );
        }
	MFC_CATCH_DWSTATUS

    return dwStatus;
}

void
CSmNode::SetDescription( const CString& rstrDesc )
{
    // This method is only called within the node constructor,
    // so throw any errors
    m_strDesc = rstrDesc;
    
    return;
}

DWORD
CSmNode::SetType( const CString& rstrType )
{
	DWORD dwStatus = ERROR_SUCCESS;
    
    MFC_TRY
        m_strType = rstrType;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}

BOOL
CSmNode::IsLocalMachine( void )
{
    BOOL bLocal = m_strMachineName.IsEmpty();

    return bLocal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smnode.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smnode.h

Abstract:

    Base class representing a node in the MMC user interface.

--*/

#ifndef _CLASS_SMNODE_
#define _CLASS_SMNODE_

class CSmNode;
class CSmRootNode;
class CSmLogService;
class CSmCounterLogService;
class CSmTraceLogService;
class CSmAlertService;

class CSmNode
{
    // constructor/destructor
    public:
                CSmNode();
        virtual ~CSmNode();

    // public methods
    public:

                const CString& GetDisplayName( void );
                const CString& GetMachineName( void );
                const CString& GetMachineDisplayName( void );
                const CString& GetDescription( void );
                const CString& GetType( void );

                DWORD   SetMachineName( const CString& );

                BOOL    IsLocalMachine ( void );

        virtual CSmRootNode* CastToRootNode( void ) { return NULL; };
        virtual CSmLogService* CastToLogService( void ) { return NULL; };
        virtual CSmCounterLogService* CastToCounterLogService( void ) { return NULL; };
        virtual CSmTraceLogService* CastToTraceLogService( void ) { return NULL; };
        virtual CSmAlertService* CastToAlertService( void ) { return NULL; };

    protected:

        DWORD    SetDisplayName( const CString& );
        void     SetDescription( const CString& );  // Throws exception on error
        DWORD    SetType( const CString& );

    private:
        CString     m_strName;
        CString     m_strMachineName;
        CString     m_strMachineDisplayName;
        CString     m_strDesc;
        CString     m_strType;
        CSmNode*    m_pParentNode;
};

typedef CSmNode   SMNODE;
typedef CSmNode*  PSMNODE;


#endif //_CLASS_SMNODE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smrootnd.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smrootnd.h

Abstract:

    This object is used to represent the Performance Logs and Alerts root node

--*/

#ifndef _CLASS_SMROOTNODE_
#define _CLASS_SMROOTNODE_

#include "smnode.h"
#include "smctrsv.h"
#include "smtracsv.h"
#include "smalrtsv.h"


class CSmRootNode : public CSmNode
{
    // constructor/destructor
    public:
                CSmRootNode ();
        virtual ~CSmRootNode();

    // public methods
    public:

        virtual CSmRootNode*    CastToRootNode( void ) { return this; };
                void            Destroy( void );

                HSCOPEITEM      GetScopeItemHandle ( void ) { return m_hRootNode; }; 
                void            SetScopeItemHandle ( HSCOPEITEM hRootNode ) 
                                        { m_hRootNode = hRootNode; }; 
            
                HSCOPEITEM      GetParentScopeItemHandle ( void ) { return m_hParentNode; }; 
                void            SetParentScopeItemHandle ( HSCOPEITEM hParentNode ) 
                                        { m_hParentNode = hParentNode; }; 

                BOOL    IsExpanded(){ return m_bIsExpanded; };
                void    SetExpanded( BOOL bExp){ m_bIsExpanded = bExp; };

                BOOL    IsExtension(){ return m_bIsExtension; };
                void    SetExtension( BOOL bExtension){ m_bIsExtension = bExtension; };

                BOOL    IsLogService ( MMC_COOKIE mmcCookie );
                BOOL    IsAlertService ( MMC_COOKIE mmcCookie );
                
                BOOL    IsLogQuery ( MMC_COOKIE mmcCookie );

                CSmCounterLogService*   GetCounterLogService ( void )
                                            { return &m_CounterLogService; };
                CSmTraceLogService*   GetTraceLogService ( void )
                                            { return &m_TraceLogService; };
                CSmAlertService*   GetAlertService ( void )
                                            { return &m_AlertService; };

                DWORD   UpdateServiceConfig();
    
    private:

        enum ePrivateValue {
            eResetDelaySeconds = 60,
            eRestartDelayMilliseconds = 0
        };
        
        HSCOPEITEM          m_hRootNode;            // Root node handle
        HSCOPEITEM          m_hParentNode;          // Parent node is NULL for standalone
        BOOL                m_bIsExpanded;
        BOOL                m_bIsExtension;

        CSmCounterLogService    m_CounterLogService;    // service object: 1 per component per node type
        CSmTraceLogService      m_TraceLogService;      // service object: 1 per component per node type
        CSmAlertService         m_AlertService;         // service object: 1 per component per node type
};

typedef CSmRootNode   SLROOT;
typedef CSmRootNode*  PSROOT;


#endif //_CLASS_SMROOTNODE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smrootnd.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smrootnd.cpp

Abstract:

    This object is used to represent the Performance Logs and Alerts root node

--*/

#include "Stdafx.h"
#include "smrootnd.h"

USE_HANDLE_MACROS("SMLOGCFG(smrootnd.cpp)");

//
//  Constructor
CSmRootNode::CSmRootNode()
:   m_bIsExpanded ( FALSE ),
    m_hRootNode ( NULL ),
    m_hParentNode ( NULL ),
    m_bIsExtension ( FALSE )
{
    CString                 strTemp;
    ResourceStateManager    rsm;

    // String allocation errors are thrown, to be
    // captured by rootnode alloc exception handler

    strTemp.LoadString ( IDS_MMC_DEFAULT_NAME );
    SetDisplayName ( strTemp ); 
    strTemp.LoadString ( IDS_ROOT_NODE_DESCRIPTION );
    SetDescription ( strTemp ); 
    strTemp.LoadString ( IDS_EXTENSION_COL_TYPE );
    SetType ( strTemp ); 
    return;
}

//
//  Destructor
CSmRootNode::~CSmRootNode()
{
    ASSERT (m_CounterLogService.m_QueryList.GetHeadPosition() == NULL);
    ASSERT (m_TraceLogService.m_QueryList.GetHeadPosition() == NULL);
    ASSERT (m_AlertService.m_QueryList.GetHeadPosition() == NULL);

    return;
}

void
CSmRootNode::Destroy()
{    
    m_CounterLogService.Close();
    m_TraceLogService.Close();
    m_AlertService.Close();

    return;
}

BOOL
CSmRootNode::IsLogService (
	MMC_COOKIE mmcCookie )
{
    BOOL bReturn = FALSE;

    if (mmcCookie == (MMC_COOKIE)&m_CounterLogService) {
        bReturn = TRUE;
    } else if (mmcCookie == (MMC_COOKIE)&m_TraceLogService) {
        bReturn = TRUE;
    } else if (mmcCookie == (MMC_COOKIE)&m_AlertService) {
        bReturn = TRUE;
    } 

    return bReturn;
}

BOOL
CSmRootNode::IsAlertService ( 
    MMC_COOKIE mmcCookie )
{
    BOOL bReturn = FALSE;

    if (mmcCookie == (MMC_COOKIE)&m_AlertService) {
        bReturn = TRUE;
    } 
    return bReturn;
}

BOOL
CSmRootNode::IsLogQuery ( 
    MMC_COOKIE	mmcCookie )
{
    PSLQUERY   pPlQuery = NULL;

    POSITION    Pos;
    
    // Handle multiple query types
    Pos = m_CounterLogService.m_QueryList.GetHeadPosition();
    
    while ( Pos != NULL) {
        pPlQuery = m_CounterLogService.m_QueryList.GetNext( Pos );
        if ((MMC_COOKIE)pPlQuery ==  mmcCookie) return TRUE;
    }

    Pos = m_TraceLogService.m_QueryList.GetHeadPosition();
    
    while ( Pos != NULL) {
        pPlQuery = m_TraceLogService.m_QueryList.GetNext( Pos );
        if ((MMC_COOKIE)pPlQuery == mmcCookie) return TRUE;
    }
    
    Pos = m_AlertService.m_QueryList.GetHeadPosition();
    
    while ( Pos != NULL) {
        pPlQuery = m_AlertService.m_QueryList.GetNext( Pos );
        if ((MMC_COOKIE)pPlQuery == mmcCookie) return TRUE;
    }

    return FALSE;
}

DWORD   
CSmRootNode::UpdateServiceConfig()
{
    // If any queries are (newly) set to auto start, then set the
    // service to auto start.  Otherwise, set to manual start.
    // When setting to auto start, also set failure mode to restart
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL  bStatus = 0;
    SC_HANDLE   hSC = NULL;
    SC_HANDLE   hService = NULL;
    BOOL        bAutoStart = FALSE;
    DWORD       pqsConfigBuff[128];
    QUERY_SERVICE_CONFIG*    pqsConfig;
    SC_ACTION*  parrSingleFailAction = NULL;
    SERVICE_FAILURE_ACTIONS  structFailActions;
    DWORD       dwMoreBytes = 0;
    BOOL        bUpdate = FALSE;


    bAutoStart = ( m_CounterLogService.IsAutoStart()
                    || m_TraceLogService.IsAutoStart()
                    || m_AlertService.IsAutoStart() );

    // open SC database
    hSC = OpenSCManager ( GetMachineName(), NULL, GENERIC_READ );

    if (hSC != NULL) {
        // open service
        hService = OpenService (
                        hSC, 
                        L"SysmonLog",
                        SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG | SERVICE_START );

        if (hService != NULL) {    
            
            // get current config
            memset (pqsConfigBuff, 0, sizeof(pqsConfigBuff));
            pqsConfig = (QUERY_SERVICE_CONFIG*)pqsConfigBuff;

            if ( QueryServiceConfig (
                    hService, 
                    pqsConfig,
                    sizeof(pqsConfigBuff), 
                    &dwMoreBytes)) {
                // See if the current status is different
                // from the selection. If it is, then change
                // the current mode.
                if ( bAutoStart ) {
                    if ( SERVICE_DEMAND_START == pqsConfig->dwStartType ) {
                        bUpdate = TRUE;
                    }
                } else {
                    // Manual start selected
                    if ( SERVICE_AUTO_START == pqsConfig->dwStartType ) {
                        bUpdate = TRUE;
                    }
                }
            } else {
                // else unable to read the current status so update anyway
                bUpdate = TRUE;
            }

            if ( bUpdate ) {
                MFC_TRY
                    parrSingleFailAction = new SC_ACTION[3];
                MFC_CATCH_DWSTATUS;

                if ( NULL != parrSingleFailAction ) {
                    parrSingleFailAction[0].Delay = eRestartDelayMilliseconds;
                    parrSingleFailAction[1].Delay = eRestartDelayMilliseconds;
                    parrSingleFailAction[2].Delay = eRestartDelayMilliseconds;

                    if ( bAutoStart ) {
                        parrSingleFailAction[0].Type = SC_ACTION_RESTART;
                        parrSingleFailAction[1].Type = SC_ACTION_RESTART;
                        parrSingleFailAction[2].Type = SC_ACTION_RESTART;
                    } else {
                        parrSingleFailAction[0].Type = SC_ACTION_NONE;
                        parrSingleFailAction[1].Type = SC_ACTION_NONE;
                        parrSingleFailAction[2].Type = SC_ACTION_NONE;
                    }

                    structFailActions.dwResetPeriod = eResetDelaySeconds;
                    structFailActions.lpRebootMsg = NULL;
                    structFailActions.lpCommand = NULL;
                    structFailActions.cActions = 3;
                    structFailActions.lpsaActions = parrSingleFailAction;

                    bStatus = ChangeServiceConfig (
                        hService,
                        SERVICE_NO_CHANGE,
                        (bAutoStart ? SERVICE_AUTO_START : SERVICE_DEMAND_START),
                        SERVICE_NO_CHANGE,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL );

                    if ( 0 == bStatus ) {
                        dwStatus = GetLastError();
                    } else {
                        bStatus = ChangeServiceConfig2 (
                            hService,
                            SERVICE_CONFIG_FAILURE_ACTIONS,
                            &structFailActions );
                        if ( 0 == bStatus ) {
                            dwStatus = GetLastError();
                        }
                    }
                    delete [] parrSingleFailAction;

                } else {
                    dwStatus = ERROR_OUTOFMEMORY;
                }
            }

            CloseServiceHandle (hService);

        } else {
            dwStatus = GetLastError();
            ASSERT (dwStatus != 0);
        }

        CloseServiceHandle (hSC);

    } else {
         dwStatus = GetLastError();
    } // OpenSCManager

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smproppg.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smproppg.h

Abstract:

    Class definitions for the property page base class.

--*/

#ifndef _SMPROPPG_H_
#define _SMPROPPG_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "smlogqry.h"   // For shared data

#define MAXSTR         32
#define INVALID_DWORD  -2       // SLQ_DISK_MAX_SIZE = -1
#define INVALID_DOUBLE -1.00

/////////////////////////////////////////////////////////////////////////////
// CSmPropertyPage dialog

#define VALIDATE_FOCUS      1
#define VALIDATE_APPLY      2

class CSmPropertyPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CSmPropertyPage)

// Construction
public:

            CSmPropertyPage();

            CSmPropertyPage ( 
                UINT nIDTemplate, 
                LONG_PTR hConsole = NULL,
                LPDATAOBJECT pDataObject = NULL );

    virtual ~CSmPropertyPage();

public:

    static  UINT CALLBACK   PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
            DWORD           SetContextHelpFilePath ( const CString& rstrPath );
            const CString&  GetContextHelpFilePath ( void ) { return m_strContextHelpFilePath; };
            void            SetModifiedPage ( const BOOL bModified = TRUE );

            DWORD   AllocInitCounterPath( 
                        const LPWSTR szCounterPath,
                        PPDH_COUNTER_PATH_ELEMENTS* ppCounter );


            
// Dialog Data
    //{{AFX_DATA(CSmPropertyPage)
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CSmPropertyPage)
public:
protected:
    virtual BOOL OnInitDialog();
    virtual BOOL OnSetActive();
    virtual BOOL OnApply();
    //}}AFX_VIRTUAL

public:
    LPFNPSPCALLBACK     m_pfnOriginalCallback;

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CSmPropertyPage)
    virtual BOOL OnHelpInfo( HELPINFO* );
    virtual void OnContextMenu( CWnd*, CPoint );
    virtual LRESULT OnQuerySiblings (WPARAM wParam, LPARAM lParam) ;

    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CCountersProperty)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH
//    DECLARE_DISPATCH_MAP()
//    DECLARE_INTERFACE_MAP()

protected:

    enum eStartType {
        eStartManually,
        eStartImmediately,
        eStartSched 
    };
    
            void    SetRunAs( CSmLogQuery* pQuery );
            BOOL    Initialize(CSmLogQuery* pQuery);
            eStartType  DetermineCurrentStartType ( void );

   virtual  INT     GetFirstHelpCtrlId ( void ) { ASSERT ( FALSE ); return 0; };  // Subclass must override.
    
            BOOL    IsValidData ( CSmLogQuery* pQuery, DWORD fReason );
   virtual  BOOL    IsValidLocalData() { return TRUE; }

            BOOL    ApplyRunAs ( CSmLogQuery* pQuery );
    
            BOOL    IsActive( void ) { return m_bIsActive; };
            void    SetIsActive( BOOL bIsActive ) { m_bIsActive = bIsActive; };
            BOOL    UpdateService( CSmLogQuery* pQuery, BOOL bSyncSerial = FALSE );
            void    SetHelpIds ( DWORD* pdwHelpIds ) { m_pdwHelpIds = pdwHelpIds; };

            BOOL    IsModifiedPage( void ) { return m_bIsModifiedPage; };

            void    ValidateTextEdit(CDataExchange * pDX,
                                     int             nIDC,
                                     int             nMaxChars,
                                     DWORD         * value,
                                     DWORD           minValue,
                                     DWORD           maxValue);
            BOOL    ValidateDWordInterval(int     nIDC,
                                          LPCWSTR strLogName,
                                          long    lValue,
                                          DWORD   minValue,
                                          DWORD   maxValue);
            void    OnDeltaposSpin(NMHDR   * pNMHDR,
                                   LRESULT * pResult,
                                   DWORD   * pValue,
                                   DWORD     dMinValue,
                                   DWORD     dMaxValue);
            
            BOOL    SampleTimeIsLessThanSessionTime( CSmLogQuery* pQuery );
            BOOL    SampleIntervalIsInRange( SLQ_TIME_INFO&, const CString& );
            BOOL    IsWritableQuery( CSmLogQuery* pQuery );
            DWORD   SetFocusAnyPage ( INT iControlId );
            BOOL    ConnectRemoteWbemFail(CSmLogQuery* pQuery, BOOL bNotTouchRunAs);
            
    SLQ_PROP_PAGE_SHARED    m_SharedData;
    HINSTANCE               m_hModule;
    LPDATAOBJECT            m_pDataObject;
    CString                 m_strUserDisplay;   // For RunAs
    CString                 m_strUserSaved;
    CSmLogQuery*            m_pQuery;
    BOOL                    m_bCanAccessRemoteWbem;
    BOOL                    m_bPwdButtonEnabled;
private:    
    
    LONG_PTR                m_hConsole;
    UINT                    m_uiIdTemplate;
    BOOL                    m_bIsActive;
    CString                 m_strContextHelpFilePath;
    DWORD*                  m_pdwHelpIds;    
    BOOL                    m_bIsModifiedPage;
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif //  _SMPROPPG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smproppg.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smproppg.cpp

Abstract:

    Implementation of the property page base class.

--*/

#include "stdafx.h"
#include <wbemidl.h>
#include "smcfgmsg.h"
#include "smlogs.h"
#include "smproppg.h"
#include "dialogs.h"
#include <pdhp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("SMLOGCFG(smproppg.cpp)");

/////////////////////////////////////////////////////////////////////////////
// CSmPropertyPage property page

IMPLEMENT_DYNCREATE ( CSmPropertyPage, CPropertyPage )

CSmPropertyPage::CSmPropertyPage ( 
    UINT nIDTemplate, 
    LONG_PTR hConsole,
    LPDATAOBJECT pDataObject )  
:   CPropertyPage ( nIDTemplate ),
    m_uiIdTemplate (nIDTemplate ),
    m_bIsActive ( FALSE ),
    m_bIsModifiedPage ( FALSE ),
    m_pdwHelpIds ( NULL ),
    m_hConsole (hConsole ),
    m_pDataObject ( pDataObject ),
    m_bCanAccessRemoteWbem ( TRUE),
    m_pQuery ( NULL ),
    m_bPwdButtonEnabled ( TRUE)
{
    //::OutputDebugStringA("\nCSmProperty::CSmPropertyPage");

    // Need to save the original callback pointer because we are replacing
    // it with our own 
    m_pfnOriginalCallback = m_psp.pfnCallback;

    // This makes sure the MFC module states will work correctly 
    MMCPropPageCallback( &m_psp );

//  EnableAutomation();
    //{{AFX_DATA_INIT(CSmPropertyPage)
    //}}AFX_DATA_INIT

    m_hModule = (HINSTANCE)GetModuleHandleW (_CONFIG_DLL_NAME_W_);  
}

CSmPropertyPage::CSmPropertyPage() : CPropertyPage(0xfff)  // Unused template IDD
{
    ASSERT (FALSE); // the constructor w/ args should be used instead
//  //{{AFX_DATA_INIT(CSmPropertyPage)
//  //}}AFX_DATA_INIT
}

CSmPropertyPage::~CSmPropertyPage()
{
}

BEGIN_MESSAGE_MAP(CSmPropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CSmPropertyPage)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    ON_MESSAGE(PSM_QUERYSIBLINGS, OnQuerySiblings)

    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSmPropertyPage message handlers


UINT CALLBACK  CSmPropertyPage::PropSheetPageProc
(
  HWND hWnd,                     // [in] Window handle - always null
  UINT uMsg,                 // [in,out] Either the create or delete message        
  LPPROPSHEETPAGE pPsp         // [in,out] Pointer to the property sheet struct
)
{
  ASSERT( NULL != pPsp );

  // We need to recover a pointer to the current instance.  We can't just use
  // "this" because we are in a static function
  CSmPropertyPage* pMe   = reinterpret_cast<CSmPropertyPage*>(pPsp->lParam);           
  ASSERT( NULL != pMe );
  
  if (!pMe) return 0;

  switch( uMsg )
  {
    case PSPCB_CREATE:                  
      break;

    case PSPCB_RELEASE:  
      // Since we are deleting ourselves, save a callback on the stack
      // so we can callback the base class
      //LPFNPSPCALLBACK pfnOrig = pMe->m_pfnOriginalCallback;
      delete pMe;      
      return 1; //(pfnOrig)(hWnd, uMsg, pPsp);
  }
  // Must call the base class callback function or none of the MFC
  // message map stuff will work
  return (pMe->m_pfnOriginalCallback)(hWnd, uMsg, pPsp); 

} // end PropSheetPageProc()

BOOL 
CSmPropertyPage::Initialize(CSmLogQuery* pQuery) 
{
    HRESULT hr;
    PPDH_PLA_INFO  pInfo = NULL;
    DWORD dwInfoSize = 0;
    CString strMachineName;
    LPCWSTR pszMachineName = NULL;

    if ( NULL != pQuery ) {

        if (!pQuery->GetLogService()->IsLocalMachine()) {
            pszMachineName = pQuery->GetLogService()->GetMachineName();
        }

        hr = PdhPlaGetInfoW( (LPWSTR)(LPCWSTR)pQuery->GetLogName(), 
                             (LPWSTR)pszMachineName,
                             &dwInfoSize, 
                             pInfo );
        if( ERROR_SUCCESS == hr && 0 != dwInfoSize ){
            pInfo = (PPDH_PLA_INFO)malloc(dwInfoSize);
            if( NULL != pInfo ) {
                if ( sizeof(PDH_PLA_INFO) <= dwInfoSize ) {
                    pInfo->dwMask = PLA_INFO_FLAG_USER;
                    hr = PdhPlaGetInfoW( (LPWSTR)(LPCWSTR)pQuery->GetLogName(), 
                                          (LPWSTR)pszMachineName,
                                          &dwInfoSize, 
                                          pInfo );
                    if( ERROR_SUCCESS == hr ){
                        pQuery->m_strUser = pInfo->strUser;
                    }
                }
                free( pInfo );
            }
            pQuery->m_fDirtyPassword = PASSWORD_CLEAN;
        }
    }
    return TRUE;
}

BOOL 
CSmPropertyPage::OnInitDialog() 
{
    DWORD dwExStyle = 0;
    CWnd* pwndPropSheet;

    pwndPropSheet = GetParentOwner();

    if ( NULL != pwndPropSheet ) {
        dwExStyle = pwndPropSheet->GetExStyle();
        pwndPropSheet->ModifyStyleEx ( NULL, WS_EX_CONTEXTHELP );
    }
    return CPropertyPage::OnInitDialog();
}
    
BOOL
CSmPropertyPage::OnSetActive() 
{
    m_bIsActive = TRUE;
    return CPropertyPage::OnSetActive();
}

BOOL 
CSmPropertyPage::OnApply() 
{
    BOOL bContinue = TRUE;
    
    if ( NULL != m_hConsole 
            && NULL != m_pDataObject 
            && IsModifiedPage() ) {

        // Only changes on the schedule page cause notification,
        // because only schedule changes cause a state change that is
        // visible in the result pane.
        MMCPropertyChangeNotify (
            m_hConsole,                 // handle to a notification
            (LPARAM) m_pDataObject);    // unique identifier
    }

    bContinue = CPropertyPage::OnApply();

    return bContinue;
}

LRESULT 
CSmPropertyPage::OnQuerySiblings( WPARAM wParam, LPARAM /*lParam*/ )
{
    LRESULT lrReturn = (LRESULT)0;

    if ( wParam != m_nIDHelp ) {
        lrReturn = (LRESULT)IsModifiedPage();
    }
    return lrReturn;
}


BOOL 
CSmPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    ASSERT ( NULL != m_pdwHelpIds );

    if ( NULL != pHelpInfo ) {
        if ( pHelpInfo->iCtrlId >= GetFirstHelpCtrlId() ) {
            InvokeWinHelp(
                WM_HELP, 
                NULL, 
                (LPARAM)pHelpInfo, 
                GetContextHelpFilePath(), 
                m_pdwHelpIds ); //s_aulHelpIds);
        }
    } else {
        ASSERT ( FALSE );
    }
    
    return TRUE;
}

void 
CSmPropertyPage::OnContextMenu(CWnd* pWnd, CPoint /* point */) 
{
    ASSERT ( NULL != m_pdwHelpIds );

    if ( NULL != pWnd ) {    
        InvokeWinHelp (
            WM_CONTEXTMENU, 
            (WPARAM)(pWnd->m_hWnd), 
            NULL, 
            GetContextHelpFilePath(), 
            m_pdwHelpIds ); 
    }
    return;
}
/////////////////////////////////////////////////////////////////////////////
// CSmPropertyPage helper methods

BOOL
CSmPropertyPage::UpdateService( CSmLogQuery* pQuery, BOOL bSyncSerial )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    BOOL    bIsValid = FALSE;
    BOOL    bRegistryUpdated;
    CString strMessage;
    CString strMachineName;
    CString strSysMessage;

    AFX_MANAGE_STATE(AfxGetStaticModuleState()); 

    if ( NULL == pQuery ) {
        ASSERT ( FALSE );
        return bIsValid;
    }

    if ( (!QuerySiblings(m_nIDHelp, 0)) && IsModifiedPage() ) {     // Second parameter not used by called method
        { 
            CWaitCursor WaitCursor;
            // Update the service with changes.
            // Sync changes made by service to properties not modified by this page.
            if ( bSyncSerial ) {
                dwStatus = pQuery->SyncSerialNumberWithRegistry();
            }

            if ( ERROR_SUCCESS == dwStatus ) {
                dwStatus = pQuery->UpdateService ( bRegistryUpdated );
            }    
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            bIsValid = TRUE;
        } else {

            bIsValid = FALSE;

            if ( ERROR_KEY_DELETED == dwStatus ) {
                strMessage.LoadString( IDS_ERRMSG_QUERY_DELETED );        
            } else if ( ERROR_ACCESS_DENIED == dwStatus ) {
            
                pQuery->GetMachineDisplayName( strMachineName );

                FormatSmLogCfgMessage ( 
                    strMessage,
                    m_hModule, 
                    SMCFG_NO_MODIFY_ACCESS, 
                    (LPCWSTR)strMachineName);
            } else {

                FormatMessage ( 
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL, 
                    dwStatus,
                    0,
                    strSysMessage.GetBufferSetLength( MAX_PATH ),
                    MAX_PATH,
                    NULL );

                strSysMessage.ReleaseBuffer();

                if ( strSysMessage.IsEmpty() ) {
                    strSysMessage.Format ( L"0x%08lX", dwStatus );
                }

                strMessage.Format( IDS_ERRMSG_SERVICE_ERROR, pQuery->GetLogName() );
                strMessage += strSysMessage;
            }
            
            MessageBox ( strMessage, pQuery->GetLogName(), MB_OK  | MB_ICONERROR );                
        }
    } else {
        bIsValid = TRUE;
    }

    // If valid data, clear the modified page flag because either this page updated 
    // the service or another page is scheduled to update the service.
    if ( bIsValid ) {
        SetModifiedPage ( FALSE );
    }

    return bIsValid;
}


void
CSmPropertyPage::ValidateTextEdit (
    CDataExchange*  pDX,
    int             nIDC,
    int             nMaxChars,
    DWORD*          pValue,
    DWORD           /* minValue */,
    DWORD           /* maxValue */)
{
    HWND    hWndCtrl       = pDX->PrepareEditCtrl(nIDC);
    LONG    currentValue   = INVALID_DWORD;
    WCHAR   szT[MAXSTR];
    CString strTemp;

    if ( NULL != pDX && NULL != pValue ) {
        if (pDX->m_bSaveAndValidate) {

            *pValue = (DWORD) currentValue;

            ::GetWindowText(hWndCtrl, szT, MAXSTR);

            strTemp = szT;
            DDV_MaxChars(pDX, strTemp, nMaxChars);

            if (szT[0] >= L'0' && szT[0] <= L'9')
            {
                currentValue = _wtol(szT);
                *pValue      = (DWORD) currentValue;
            }
        } else {
            if ( INVALID_DWORD != *pValue ) {
                wsprintf(szT, L"%lu", *pValue);
            } else {
                szT[0] = L'\0';
            }
            GetDlgItem(nIDC)->SetWindowText(szT);
        }
    } else {
        ASSERT ( FALSE );
    }
}

BOOL
CSmPropertyPage::ValidateDWordInterval(
    int     nIDC,
    LPCWSTR strLogName,
    long    lValue,
    DWORD   minValue,
    DWORD   maxValue )
{
    CString strMsg;
    BOOL    bResult =  (lValue >= (long) minValue)
                    && (lValue <= (long) maxValue);

    if (! bResult)
    {
        strMsg.Format ( IDS_ERRMSG_INVALIDDWORD, minValue, maxValue );
        MessageBox(strMsg, strLogName, MB_OK  | MB_ICONERROR);
        SetFocusAnyPage ( nIDC );
        strMsg.Empty();
    }
    return (bResult);
}

void
CSmPropertyPage::OnDeltaposSpin(
    NMHDR   *pNMHDR,
    LRESULT *pResult,
    DWORD   *pValue,
    DWORD     dMinValue,
    DWORD     dMaxValue)
{
    NM_UPDOWN* pNMUpDown;
    LONG       lValue;
    BOOL       bResult   = TRUE;

    UpdateData(TRUE);

    ASSERT(dMinValue <= dMaxValue);

    if ( NULL != pNMHDR
        && NULL != pResult
        && NULL != pValue ) 
    {
        pNMUpDown = (NM_UPDOWN *) pNMHDR;
        lValue    = (LONG) (*pValue);

        if (lValue == INVALID_DWORD) {
            lValue = (DWORD) dMinValue;
        }

        if ( ((lValue >= (LONG) dMinValue + 1) && (pNMUpDown->iDelta > 0))
            || ((lValue <= (LONG) dMaxValue - 1) && (pNMUpDown->iDelta < 0)))
        {
            lValue += (pNMUpDown->iDelta * -1);

            if (lValue > (LONG) dMaxValue) {
                lValue = (DWORD) dMaxValue;
            } else if (lValue < (LONG) dMinValue) {
                lValue = (DWORD) dMinValue;
            }
        } else if (lValue > (LONG) dMaxValue) {        
            lValue = (DWORD) dMaxValue;
        } else if (lValue < (LONG) dMinValue) {
            lValue = (DWORD) dMinValue;
        } else {
            bResult = FALSE;
        }

        if (bResult) {
            *pValue = lValue;
            UpdateData(FALSE);
            SetModifiedPage(TRUE);
        }
        *pResult = 0;
    } else {
        ASSERT ( FALSE );
    }

    return;
}

BOOL
CSmPropertyPage::SampleTimeIsLessThanSessionTime( CSmLogQuery* pQuery )
{
    BOOL        bIsValid = TRUE;
    SYSTEMTIME  stLocalTime;
    LONGLONG    llMaxStartTime = 0;
    LONGLONG    llSessionMilliseconds = 0;
    LONGLONG    llSampleMilliseconds = 0;
    CString     strMsg;

    ResourceStateManager    rsm;
    
    if ( NULL != pQuery ) {
        if ( SLQ_TRACE_LOG != pQuery->GetLogType() ) {
            if ( SLQ_AUTO_MODE_AT == m_SharedData.stiStopTime.dwAutoMode ) {
    
                GetLocalTime (&stLocalTime);
                SystemTimeToFileTime (&stLocalTime, (FILETIME *)&llMaxStartTime);

                // For Manual Start mode, Now is used to determine session length.
                // For Start At mode, the later of Now vs. schedule start time
                // is used to determine session length.
                if ( SLQ_AUTO_MODE_AT == m_SharedData.stiStartTime.dwAutoMode ) {
                    if ( m_SharedData.stiStartTime.llDateTime > llMaxStartTime ) {
                        llMaxStartTime = m_SharedData.stiStartTime.llDateTime;
                    }
                }
                // Calc and compare session seconds vs. sample seconds
                TimeInfoToMilliseconds ( &m_SharedData.stiSampleTime, &llSampleMilliseconds );

                llSessionMilliseconds = m_SharedData.stiStopTime.llDateTime - llMaxStartTime;
                llSessionMilliseconds /= FILETIME_TICS_PER_MILLISECOND;

                if ( llSessionMilliseconds < llSampleMilliseconds ) {
                    strMsg.LoadString ( IDS_SCHED_SESSION_TOO_SHORT );
                    MessageBox(strMsg, pQuery->GetLogName(), MB_OK  | MB_ICONERROR);
                    strMsg.Empty();
                    bIsValid = FALSE;
                }
            } else if ( SLQ_AUTO_MODE_AFTER == m_SharedData.stiStopTime.dwAutoMode ) { 
                TimeInfoToMilliseconds ( &m_SharedData.stiStopTime, &llSessionMilliseconds );
                TimeInfoToMilliseconds ( &m_SharedData.stiSampleTime, &llSampleMilliseconds );
        
                if ( llSessionMilliseconds < llSampleMilliseconds ) {
                    strMsg.LoadString ( IDS_SCHED_SESSION_TOO_SHORT );
                    MessageBox(strMsg, pQuery->GetLogName(), MB_OK  | MB_ICONERROR);
                    strMsg.Empty();
                    bIsValid = FALSE;
                }
            }
        }
    } else {
        ASSERT ( FALSE );
        bIsValid = FALSE;
    }
    return bIsValid;
}

BOOL
CSmPropertyPage::ApplyRunAs ( CSmLogQuery* pQuery )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    WCHAR   strComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    CString strComputer;
    DWORD   dwSize = MAX_COMPUTERNAME_LENGTH + 1;
    BOOL    bReturn = TRUE;
    HRESULT hr = NOERROR; 
    
    if ( NULL != pQuery ) {
        if ( !QuerySiblings(m_nIDHelp, 0)) {     // Second parameter not used by called method
            //
            // If RunAs user/password changed, then we must save RunAs information
            //
            if( pQuery->m_fDirtyPassword & (PASSWORD_DIRTY|PASSWORD_SET) ){
                pQuery->m_fDirtyPassword = PASSWORD_CLEAN;
                strComputer =  pQuery->GetLogService()->GetMachineName();
                if( strComputer.IsEmpty() ){
                    strComputerName[0] = L'\0';
                    bReturn = GetComputerName( strComputerName, &dwSize );

                    if ( !bReturn ) {
                        dwStatus = GetLastError();
                    } else {
                        strComputer = strComputerName; 
                    }
                }
            
                pQuery->m_strUser.TrimLeft();
                pQuery->m_strUser.TrimRight();

                if( pQuery->m_strUser.GetLength() ) {
                    dwStatus = PdhPlaSetRunAs( 
                                (LPWSTR)(LPCWSTR)pQuery->GetLogName(), 
                                (LPWSTR)(LPCWSTR)strComputer, 
                                (LPWSTR)(LPCWSTR)pQuery->m_strUser, 
                                (LPWSTR)(LPCWSTR)pQuery->m_strPassword 
                            );
                } else {
                    dwStatus = PdhPlaSetRunAs( 
                                (LPWSTR)(LPCWSTR)pQuery->GetLogName(), 
                                (LPWSTR)(LPCWSTR)strComputer, 
                                L"", 
                                L""
                            );
                }
            }
            if ( ERROR_SUCCESS != dwStatus ) {
                bReturn = FALSE;
            }
        }
    } else {
        ASSERT ( FALSE );
        bReturn = FALSE;
    }

    return bReturn;
}

void
CSmPropertyPage::SetRunAs( CSmLogQuery* pQuery )
{
    CPasswordDlg dlg;

    if ( NULL != pQuery ) {
        dlg.SetContextHelpFilePath( GetContextHelpFilePath() );

        pQuery->m_strUser.TrimLeft();
        pQuery->m_strUser.TrimRight();

        dlg.m_strUserName = pQuery->m_strUser;

        //
        // If we want to reset the RunAs information
        //
        if (pQuery->m_strUser.IsEmpty() || pQuery->m_strUser.GetAt(0) == L'<' ) {
            pQuery->m_strPassword = L"";
            pQuery->m_strUser = L"";
            pQuery->m_fDirtyPassword |= PASSWORD_SET;
        } else { 
            if( dlg.DoModal() != IDCANCEL ){
                pQuery->m_strPassword = dlg.m_strPassword1;

                pQuery->m_strUser = dlg.m_strUserName;
                SetModifiedPage(TRUE);
                pQuery->m_fDirtyPassword |= PASSWORD_SET;
            }
        }
    } else {
        ASSERT ( FALSE );
    }
}

BOOL
CSmPropertyPage::IsValidData( CSmLogQuery* pQuery, DWORD fReason )
{
    BOOL bIsValid = TRUE;
    CString strTestFileName;
    INT iPrevLength = 0;

    if ( NULL != pQuery ) {

        if ( bIsValid ) {
            if ( !IsActive() ) {
                pQuery->GetPropPageSharedData ( &m_SharedData );
            }
        }
    
        if( bIsValid && (fReason & VALIDATE_APPLY ) ){
            bIsValid = IsWritableQuery( pQuery );
        }

        if( bIsValid ){
            bIsValid = IsValidLocalData();
        }
    
        if( bIsValid ){
            //
            // RunAs user name changed, but password not set, set it now
            //
            if( (pQuery->m_fDirtyPassword & PASSWORD_DIRTY) && !(pQuery->m_fDirtyPassword & PASSWORD_SET) ){

                // Note: Trimming can be moved to SetRunAs.  Left outside
                // for clarity.
                iPrevLength = m_strUserDisplay.GetLength();

                m_strUserDisplay.TrimLeft();
                m_strUserDisplay.TrimRight();

                SetRunAs( pQuery );

                if ( iPrevLength != m_strUserDisplay.GetLength() ) {
                    SetDlgItemText ( IDC_RUNAS_EDIT, m_strUserDisplay );
                }

                if( !(pQuery->m_fDirtyPassword & PASSWORD_SET) ){
                    bIsValid = FALSE;
                }
            }
        }

        // Validate log file name and folder for filetypes
        if ( bIsValid 
                && SLQ_ALERT != pQuery->GetLogType() 
                && (fReason & VALIDATE_APPLY ) ) {
            if ( pQuery->GetLogService()->IsLocalMachine() ) {
                if ( SLF_SQL_LOG != m_SharedData.dwLogFileType ) {
                    //  bIsValid is returned as FALSE if the user cancels directory creation.
                    ProcessDirPath (
                        pQuery->GetLogService()->GetDefaultLogFileFolder(),
                        m_SharedData.strFolderName, 
                        pQuery->GetLogName(),
                        this, 
                        bIsValid, 
                        FALSE );
                }
            }

            if ( bIsValid ) {

                CreateSampleFileName (
                    pQuery->GetLogName(),
                    pQuery->GetLogService()->GetMachineName(),
                    m_SharedData.strFolderName, 
                    m_SharedData.strFileBaseName,
                    m_SharedData.strSqlName,
                    m_SharedData.dwSuffix, 
                    m_SharedData.dwLogFileType, 
                    m_SharedData.dwSerialNumber,
                    strTestFileName);

                if ( MAX_PATH <= strTestFileName.GetLength() ) {
                    CString strMessage;
                    strMessage.LoadString ( IDS_FILENAMETOOLONG );
                    MessageBox ( strMessage, pQuery->GetLogName(), MB_OK  | MB_ICONERROR);            
                    bIsValid = FALSE;
                }
            }
        }
    } else {
        ASSERT ( FALSE );
        bIsValid = FALSE;
    }

    return bIsValid;
}

BOOL
CSmPropertyPage::IsWritableQuery( CSmLogQuery* pQuery )
{
    BOOL bIsValid = FALSE;

    if ( NULL != pQuery ) {

        bIsValid = !pQuery->IsExecuteOnly() && !pQuery->IsReadOnly();
        if ( !bIsValid ) {
            CString strMessage;
            CString strMachineName;
            DWORD   dwMessageId;

            pQuery->GetMachineDisplayName( strMachineName );
    
            dwMessageId = pQuery->IsExecuteOnly() ? SMCFG_NO_MODIFY_DEFAULT_LOG : SMCFG_NO_MODIFY_ACCESS;

            FormatSmLogCfgMessage ( 
                strMessage,
                m_hModule, 
                dwMessageId, 
                (LPCWSTR)strMachineName );
                
            MessageBox ( strMessage, pQuery->GetLogName(), MB_OK  | MB_ICONERROR);
        }
    } else {
        ASSERT ( FALSE );
    }
    return bIsValid;
}

BOOL
CSmPropertyPage::SampleIntervalIsInRange(
    SLQ_TIME_INFO& rstiSample,
    const CString&  rstrQueryName )
{
    LONGLONG    llMillisecondSampleInt;
    BOOL bIsValid = TRUE;
// 45 days in milliseconds = 1000*60*60*24*45
#define FORTYFIVE_DAYS (0xE7BE2C00)

    TimeInfoToMilliseconds (&rstiSample, &llMillisecondSampleInt );

    bIsValid = ( FORTYFIVE_DAYS >= llMillisecondSampleInt );

    if ( !bIsValid ) {
        CString strMessage;

        strMessage.LoadString ( IDS_ERRMSG_SAMPLEINTTOOLARGE );
        MessageBox ( strMessage, rstrQueryName, MB_OK  | MB_ICONERROR);            
    }

    return bIsValid;
}

DWORD 
CSmPropertyPage::SetContextHelpFilePath( const CString& rstrPath )
{
    DWORD dwStatus = ERROR_SUCCESS;

    MFC_TRY
        m_strContextHelpFilePath = rstrPath; 
    MFC_CATCH_DWSTATUS

    return dwStatus;
}    

void
CSmPropertyPage::SetModifiedPage( const BOOL bModified )
{
    m_bIsModifiedPage = bModified;
    SetModified ( bModified );
    return;
}    

CSmPropertyPage::eStartType
CSmPropertyPage::DetermineCurrentStartType( void )
{
    eStartType eCurrentStartType;
    SLQ_TIME_INFO*  pstiStart;
    SLQ_TIME_INFO*  pstiStop;
    SYSTEMTIME  stLocalTime;
    FILETIME    ftLocalTime;
    LONGLONG    llLocalTime;
    ResourceStateManager    rsm;

    ftLocalTime.dwLowDateTime = ftLocalTime.dwHighDateTime = 0;

    pstiStart = &m_SharedData.stiStartTime;

    ASSERT ( SLQ_TT_TTYPE_START == pstiStart->wTimeType );

    if ( SLQ_AUTO_MODE_NONE == pstiStart->dwAutoMode ) {
        if ( pstiStart->llDateTime != MIN_TIME_VALUE ) {
            eCurrentStartType = eStartManually;
        } else {
            eCurrentStartType = eStartImmediately;
        }
    } else {
 
        GetLocalTime (&stLocalTime);
        SystemTimeToFileTime (&stLocalTime, &ftLocalTime);
        llLocalTime = *((LONGLONG *)(&ftLocalTime));

        // Test current time to determine most appropriate text
        if (llLocalTime < pstiStart->llDateTime) {
            // then the start time is in the future
            eCurrentStartType = eStartSched;
        } else {
            // Start immediately, unless manual or scheduled stop time is already past.
            pstiStop = &m_SharedData.stiStopTime;

            if ( SLQ_AUTO_MODE_NONE == pstiStop->dwAutoMode 
                    && llLocalTime > pstiStop->llDateTime ) {
                eCurrentStartType = eStartManually;
            } else {
                eCurrentStartType = eStartImmediately;
            }
        }
    }

    return eCurrentStartType;
} 
   
DWORD 
CSmPropertyPage::AllocInitCounterPath( 
    const LPWSTR szCounterPath,
    PPDH_COUNTER_PATH_ELEMENTS* ppCounter )
{
    DWORD dwStatus = ERROR_SUCCESS;
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    PPDH_COUNTER_PATH_ELEMENTS pLocalCounter = NULL;
    ULONG ulBufSize = 0;

    if ( NULL != szCounterPath && NULL != ppCounter ) {
        *ppCounter = NULL;

        pdhStatus = PdhParseCounterPath(
                        szCounterPath, 
                        pLocalCounter, 
                        &ulBufSize, 
                        0 );

        if ( 0 < ulBufSize ) {
            pLocalCounter = (PPDH_COUNTER_PATH_ELEMENTS) G_ALLOC( ulBufSize);

            if ( NULL != pLocalCounter ) {
                ZeroMemory ( pLocalCounter, ulBufSize );
                dwStatus = pdhStatus = PdhParseCounterPath( 
                                        szCounterPath, 
                                        pLocalCounter, 
                                        &ulBufSize, 
                                        0);

                if ( ERROR_SUCCESS != pdhStatus ) {
                    G_FREE(pLocalCounter);
                    pLocalCounter = NULL;
                }

            } else {
                dwStatus = ERROR_OUTOFMEMORY;
            }
        }
        if ( ERROR_SUCCESS == dwStatus && NULL != pLocalCounter ) {
            *ppCounter = pLocalCounter;
        }
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
        ASSERT ( FALSE );
    }
    return dwStatus;
}

DWORD 
CSmPropertyPage::SetFocusAnyPage ( 
    INT iControlId )
{
    DWORD dwStatus = ERROR_SUCCESS;
    UINT  uiIddPropertyPage;
    CSmPropertyPage* pOriginalPage = NULL;
    CSmPropertyPage* pNextPage = NULL;
    CPropertySheet* pPropSheet;
    BOOL bFound = FALSE;
    INT iPageCount;
    INT iPageIndex;
    CWnd* pwndControl = NULL;

    if ( 0 != iControlId ) {

        pPropSheet = m_pQuery->GetInitialPropertySheet();

        if ( NULL == pPropSheet ) {
            GetDlgItem ( iControlId )->SetFocus();
        } else {
            //
            // Special check for Create From... case.
            //
            // Check for the normal case first.
            //
            uiIddPropertyPage = iControlId - (iControlId % 100 ) ;

            pOriginalPage = (CSmPropertyPage*)pPropSheet->GetActivePage();

            if ( NULL != pOriginalPage ) {
                if ( uiIddPropertyPage == pOriginalPage->m_uiIdTemplate ) {
                    bFound = TRUE;
                    GetDlgItem ( iControlId )->SetFocus();
                }
            }

            if ( !bFound ) {
                iPageCount = pPropSheet->GetPageCount();

                for ( iPageIndex = 0; iPageIndex < iPageCount; iPageIndex++ ) {
                    pNextPage = dynamic_cast<CSmPropertyPage*>(pPropSheet->GetPage ( iPageIndex )) ;
                    if ( NULL != pNextPage ) {
                        if ( uiIddPropertyPage == pNextPage->m_uiIdTemplate ) {
                            bFound = TRUE;
                            pPropSheet->SetActivePage ( pNextPage );
                            pwndControl = GetDlgItem ( iControlId );
                            if ( NULL != pwndControl ) {
                                pwndControl->SetFocus();
                            }
                            break;
                        }
                    }
                }
            }
        }
    }
    return dwStatus;
}

BOOL
CSmPropertyPage::ConnectRemoteWbemFail(CSmLogQuery* pQuery, BOOL bNotTouchRunAs)
/*++

Routine Description:

    The function display an error message telling users they can not
    modify the RunAs information. 

Arguments:

    pQuery - Query structure

    bNotTouchRunAs - Don't check/restore RunAs after displaying dialog


Return Value:

    Return TRUE if the RunAs need to be restored to its original one,
    otherwise return FALSE

--*/
{
    CString strMessage;
    CString strSysMessage;
    IWbemStatusCodeText * pStatus = NULL;
    DWORD dwMessageId;
    HRESULT hr;

    //
    // If bNotTouchRunAs is TRUE,  don't try to restore the RunAs info.
    //
    if (!bNotTouchRunAs) {
        if (m_strUserDisplay == m_strUserSaved) {
            return FALSE;
        }
    }

    //
    // If the status code returned when we connect remote WBEM is
    // access denied, that means we are not an admin on the remote box
    // if the remote box is XP, or we are not an admin or performance log 
    // user if the remote box is .NET
    //
    dwMessageId = SMCFG_SYSTEM_MESSAGE;

    if (pQuery->GetLogService()->m_hWbemAccessStatus == WBEM_E_ACCESS_DENIED) {
        if (pQuery->GetLogService()->TargetOs() == OS_WINXP) {
            dwMessageId = SMCFG_ADMIN_ONLY;
        } else if (pQuery->GetLogService()->TargetOs() == OS_WINNET) {
            dwMessageId = SMCFG_NO_MODIFY_ACCESS;
        }
    }

    FormatSmLogCfgMessage (
        strMessage,
        m_hModule,
        dwMessageId,
        (LPCWSTR)pQuery->GetLogName());

    hr = CoCreateInstance(CLSID_WbemStatusCodeText,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemStatusCodeText,
                          (LPVOID *) &pStatus);

    if (hr == S_OK) {
        BSTR bstr = 0;
        hr = pStatus->GetErrorCodeText(pQuery->GetLogService()->m_hWbemAccessStatus, 0, 0, &bstr);

        if (hr == S_OK){
            strSysMessage = bstr;
            SysFreeString(bstr);
            bstr = 0;
        }

        pStatus->Release();
    }

    if ( strSysMessage.IsEmpty() ) {
        strSysMessage.Format ( L"0x%08lX", pQuery->GetLogService()->m_hWbemAccessStatus);
    }
    strMessage += strSysMessage;

    MessageBox(strMessage, pQuery->GetLogName(), MB_OK);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smtprov.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smtprov.h

Abstract:

    This object is used to store the list of all current 
    trace providers in the system.

--*/

#ifndef _CLASS_SMTPROV_
#define _CLASS_SMTPROV_

typedef struct _SLQ_TRACE_PROVIDER {
    CString strDescription;
    CString strGuid;
    INT     iIsEnabled;
    INT     iIsActive;
} SLQ_TRACE_PROVIDER, *PSLQ_TRACE_PROVIDER;

class CSmTraceLogService;
struct IWbemServices;

class CSmTraceProviders : public CObject
{
    public:
                CSmTraceProviders( CSmTraceLogService* );
        virtual ~CSmTraceProviders( void );

                DWORD   Open ( const CString& rstrMachineName );
                DWORD   Close ( void );
        
                HRESULT SyncWithConfiguration( void );
                HRESULT ConnectToServer( void );
                HRESULT GetBootState( INT& );

                SLQ_TRACE_PROVIDER* GetProviderInfo( INT );
                SLQ_TRACE_PROVIDER* GetKernelProviderInfo( void );

                INT     GetGenProvCount ( void );

                INT     IndexFromGuid ( const CString& rstrGuid );

                DWORD   AddProvider ( 
                            const CString& rstrDescription,
                            const CString& rstrGuid,
                            INT iIsEnabled,
                            INT iIsActive);
    private:

        HRESULT LoadGuidArray( PVOID* Storage, PULONG pnGuidCount );

        static LPCWSTR  m_cszBackslash;
        static LPCWSTR  m_cszDefaultNamespace;
        static LPCWSTR  m_cszTraceProviderClass;
        static LPCWSTR  m_cszDescription;
        static LPCWSTR  m_cszGuid;
        static LPCWSTR  m_cszKernelLogger;


        CString             m_strMachineName;
        IWbemServices*      m_pWbemServices;
        INT                 m_iBootState;
        CArray<SLQ_TRACE_PROVIDER, SLQ_TRACE_PROVIDER&> m_arrGenTraceProvider;
        SLQ_TRACE_PROVIDER  m_KernelTraceProvider;
        CSmTraceLogService* m_pTraceLogService;
};


#endif //_CLASS_SMTPROV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smtraceq.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smtraceq.cpp

Abstract:

    Implementation of the trace log query class.

--*/

#include "Stdafx.h"
#include <strsafe.h>
#include <pdh.h>        // for MIN_TIME_VALUE, MAX_TIME_VALUE
#include "smcfgmsg.h"
#include "smtprov.h"
#include "smtracsv.h"
#include "smtraceq.h"

USE_HANDLE_MACROS("SMLOGCFG(smtraceq.cpp)");

#define  TRACE_DEFAULT_BUFFER_SIZE      ((DWORD)0x00000004)
#define  TRACE_DEFAULT_MIN_COUNT        ((DWORD)0x00000003)
#define  TRACE_DEFAULT_MAX_COUNT        ((DWORD)0x00000019)
#define  TRACE_DEFAULT_BUFFER_FLUSH_INT ((DWORD)0)
#define  TRACE_DEFAULT_FLAGS            ((DWORD)0)

//
//  Constructor
CSmTraceLogQuery::CSmTraceLogQuery( CSmLogService* pLogService )
:   CSmLogQuery( pLogService ),
    m_dwInQueryProviderListLength ( 0 ),
    m_szNextInQueryProvider ( NULL ),
    mr_szInQueryProviderList ( NULL ),
    m_iNextInactiveIndex ( -1 ),
    m_dwKernelFlags (0)
{
    // initialize member variables
    memset (&mr_stlInfo, 0, sizeof(mr_stlInfo));
    return;
}

//
//  Destructor
CSmTraceLogQuery::~CSmTraceLogQuery()
{
    return;
}

//
//  Open function. either opens an existing log query entry
//  or creates a new one
//
DWORD
CSmTraceLogQuery::Open ( const CString& rstrName, HKEY hKeyQuery, BOOL bReadOnly)
{
    DWORD   dwStatus = ERROR_SUCCESS;

    ASSERT ( SLQ_TRACE_LOG == GetLogType() );

    dwStatus = CSmLogQuery::Open ( rstrName, hKeyQuery, bReadOnly );

    return dwStatus;
}

//
//  Close Function
//      closes registry handles and frees allocated memory
//
DWORD
CSmTraceLogQuery::Close ()
{
    DWORD dwStatus;
    LOCALTRACE (L"Closing Query\n");

    if (mr_szInQueryProviderList != NULL) {
        delete [] mr_szInQueryProviderList;
        mr_szInQueryProviderList = NULL;
    }

    dwStatus = CSmLogQuery::Close();

    return dwStatus;
}

//
//  UpdateRegistry function.
//      copies the current settings to the registry where they
//      are read by the log service
//
DWORD
CSmTraceLogQuery::UpdateRegistry() {
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwBufferSize = 0;
    DWORD   dwTraceFlags = 0;

    if ( IsModifiable() ) {

        // get trace log values
        dwStatus = WriteRegistryDwordValue (
            m_hKeyQuery,
            IDS_REG_TRACE_BUFFER_SIZE,
            &mr_stlInfo.dwBufferSize);

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = WriteRegistryDwordValue (
                m_hKeyQuery,
                IDS_REG_TRACE_BUFFER_MIN_COUNT,
                &mr_stlInfo.dwMinimumBuffers);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = WriteRegistryDwordValue (
                m_hKeyQuery,
                IDS_REG_TRACE_BUFFER_MAX_COUNT,
                &mr_stlInfo.dwMaximumBuffers);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = WriteRegistryDwordValue (
                m_hKeyQuery,
                IDS_REG_TRACE_BUFFER_FLUSH_INT,
                &mr_stlInfo.dwBufferFlushInterval);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwTraceFlags = m_dwKernelFlags | mr_stlInfo.dwBufferFlags;

            dwStatus = WriteRegistryDwordValue (
                m_hKeyQuery,
                IDS_REG_TRACE_FLAGS,
                &dwTraceFlags);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            LPWSTR pszStringBuffer = NULL;

            pszStringBuffer = mr_szInQueryProviderList;

            dwBufferSize = m_dwInQueryProviderListLength * sizeof (WCHAR);

            if ( NULL != pszStringBuffer ) {
                dwStatus  = WriteRegistryStringValue (
                    m_hKeyQuery,
                    IDS_REG_TRACE_PROVIDER_LIST,
                    REG_MULTI_SZ,
                    pszStringBuffer,
                    &dwBufferSize);
            }
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = CSmLogQuery::UpdateRegistry ();
        }
    } else {
        dwStatus = ERROR_ACCESS_DENIED;
    }

    return dwStatus;
}

//
//  InitGenProvidersArray()
//      reads the current values for this query from the registry
//      and WMI configuration and reloads the internal values to match
//
DWORD
CSmTraceLogQuery::InitGenProvidersArray( void )
{
    DWORD dwStatus = ERROR_SUCCESS;
    CSmTraceProviders* pProvList = NULL;
    int iIndex;
    int iCount;
    LPCWSTR pstrGuid;

    ASSERT ( m_pLogService->CastToTraceLogService() );
    pProvList = ( m_pLogService->CastToTraceLogService())->GetProviders();

    ASSERT ( NULL != pProvList );

    iCount = pProvList->GetGenProvCount();

    m_arrGenProviders.SetSize ( iCount );

    for ( iIndex = 0; iIndex < iCount; iIndex++ ) {
        m_arrGenProviders[iIndex] = eNotInQuery;
    }

    for ( pstrGuid = GetFirstInQueryProvider ( );
            NULL != pstrGuid;
            pstrGuid = GetNextInQueryProvider ( ) ) {

        iIndex = pProvList->IndexFromGuid ( pstrGuid );
        if ( -1 == iIndex ) {
            CString strEmptyDesc;
            CString strNonConstGuid;
            eProviderState eAddInQuery = eInQuery;

            MFC_TRY
                strNonConstGuid = pstrGuid;
            MFC_CATCH_DWSTATUS

            // Todo: handle string alloc error

            // The Guid is probably from another system.
            // Add the unknown Guid to the session-wide provider list.

            dwStatus = pProvList->AddProvider (
                                    strEmptyDesc,
                                    strNonConstGuid,
                                    FALSE,
                                    FALSE );

            // Update the local array to match the session-wide list.
            m_arrGenProviders.SetAtGrow( iCount, eAddInQuery );
            iIndex = iCount;

            VERIFY( ++iCount == pProvList->GetGenProvCount() );
        } else {

            ASSERT ( iIndex < iCount );
            m_arrGenProviders[iIndex] = eInQuery;
        }

        if ( !IsActiveProvider ( iIndex ) ) {
            dwStatus = SMCFG_INACTIVE_PROVIDER;
        }
    }

    // dwStatus is not ERROR_SUCCESS if at least one provider is not currently active on the system.
    return dwStatus;
}

//
//  SyncWithRegistry()
//      reads the current values for this query from the registry
//      and WMI and reloads the internal values to match
//
DWORD
CSmTraceLogQuery::SyncWithRegistry()
{
    DWORD   dwBufferSize = 0;
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwTraceFlags;
    DWORD   dwKernelTraceFlagMask;

    ASSERT (m_hKeyQuery != NULL);

    // load Provider string list

    // Get Provider List
    dwStatus = ReadRegistryStringValue (
        m_hKeyQuery,
        IDS_REG_TRACE_PROVIDER_LIST,
        NULL,
        &mr_szInQueryProviderList,
        &dwBufferSize);
    if (dwStatus != ERROR_SUCCESS) {
        m_szNextInQueryProvider = NULL; //re-initialize
        m_dwInQueryProviderListLength = 0;
    } else {
        // convert  buffersize to chars from bytes
        m_dwInQueryProviderListLength = dwBufferSize / sizeof(WCHAR);
    }

    // get trace log values
    dwStatus = ReadRegistryDwordValue (
        m_hKeyQuery,
        IDS_REG_TRACE_BUFFER_SIZE,
        TRACE_DEFAULT_BUFFER_SIZE,
        &mr_stlInfo.dwBufferSize);
    ASSERT (dwStatus == ERROR_SUCCESS);

    dwStatus = ReadRegistryDwordValue (
        m_hKeyQuery,
        IDS_REG_TRACE_BUFFER_MIN_COUNT,
        TRACE_DEFAULT_MIN_COUNT,
        &mr_stlInfo.dwMinimumBuffers);
    ASSERT (dwStatus == ERROR_SUCCESS);

    // Windows XP the minimum buffer count has changed from 2 to 3.
    if ( TRACE_DEFAULT_MIN_COUNT > mr_stlInfo.dwMinimumBuffers ) {
       mr_stlInfo.dwMinimumBuffers = TRACE_DEFAULT_MIN_COUNT;
    }

    dwStatus = ReadRegistryDwordValue (
        m_hKeyQuery,
        IDS_REG_TRACE_BUFFER_MAX_COUNT,
        TRACE_DEFAULT_MAX_COUNT,
        &mr_stlInfo.dwMaximumBuffers);
    ASSERT (dwStatus == ERROR_SUCCESS);

    // Windows XP the minimum buffer count has changed from 2 to 3.
    if ( TRACE_DEFAULT_MIN_COUNT > mr_stlInfo.dwMaximumBuffers ) {
       mr_stlInfo.dwMaximumBuffers = TRACE_DEFAULT_MIN_COUNT;
    }

    dwStatus = ReadRegistryDwordValue (
        m_hKeyQuery,
        IDS_REG_TRACE_BUFFER_FLUSH_INT,
        TRACE_DEFAULT_BUFFER_FLUSH_INT,
        &mr_stlInfo.dwBufferFlushInterval);
    ASSERT (dwStatus == ERROR_SUCCESS);

    dwTraceFlags = TRACE_DEFAULT_FLAGS; // Eliminate Prefix warning.
    dwStatus = ReadRegistryDwordValue (
        m_hKeyQuery,
        IDS_REG_TRACE_FLAGS,
        TRACE_DEFAULT_FLAGS,
        &dwTraceFlags);
    ASSERT (dwStatus == ERROR_SUCCESS);

    if ( 0 != (dwTraceFlags & SLQ_TLI_ENABLE_BUFFER_FLUSH) ) {
        mr_stlInfo.dwBufferFlags = SLQ_TLI_ENABLE_BUFFER_FLUSH;
    }

    dwKernelTraceFlagMask = SLQ_TLI_ENABLE_KERNEL_TRACE
                            | SLQ_TLI_ENABLE_PROCESS_TRACE
                            | SLQ_TLI_ENABLE_THREAD_TRACE
                            | SLQ_TLI_ENABLE_DISKIO_TRACE
                            | SLQ_TLI_ENABLE_NETWORK_TCPIP_TRACE
                            | SLQ_TLI_ENABLE_MEMMAN_TRACE
                            | SLQ_TLI_ENABLE_FILEIO_TRACE;

    m_dwKernelFlags = dwKernelTraceFlagMask & dwTraceFlags;

    // Call parent class last, to set shared data.
    dwStatus = CSmLogQuery::SyncWithRegistry();

    return dwStatus;
}

//
//  Get first Provider in list of providers in use
//
LPCWSTR
CSmTraceLogQuery::GetFirstInQueryProvider()
{
    LPWSTR  szReturn;
    szReturn = mr_szInQueryProviderList;
    if (szReturn != NULL) {
        if (*szReturn == 0) {
            // then it's an empty string
            szReturn = NULL;
            m_szNextInQueryProvider = NULL;
        } else {
            m_szNextInQueryProvider = szReturn + lstrlen(szReturn) + 1;
            if (*m_szNextInQueryProvider == 0) {
                // end of list reached so set pointer to NULL
                m_szNextInQueryProvider = NULL;
            }
        }
    } else {
        // no buffer allocated yet
        m_szNextInQueryProvider = NULL;
    }
    return (LPCWSTR)szReturn;
}

//
//  Get next Provider in list of providers in use.
//  NULL pointer means no more Providers in list.
//
LPCWSTR
CSmTraceLogQuery::GetNextInQueryProvider()
{
    LPWSTR  szReturn;
    szReturn = m_szNextInQueryProvider;

    if (m_szNextInQueryProvider != NULL) {
        m_szNextInQueryProvider += lstrlen(szReturn) + 1;
        if (*m_szNextInQueryProvider == 0) {
            // end of list reached so set pointer to NULL
            m_szNextInQueryProvider = NULL;
        }
    } else {
        // already at the end of the list so nothing to do
    }

    return (LPCWSTR)szReturn;
}

//
//  clear out the Provider list
//
VOID
CSmTraceLogQuery::ResetInQueryProviderList()
{
    if (mr_szInQueryProviderList != NULL) {
        delete [] mr_szInQueryProviderList;
        m_szNextInQueryProvider = NULL;
        mr_szInQueryProviderList = NULL;
    }

    m_dwInQueryProviderListLength = sizeof(WCHAR);  // sizeof MSZ Null
    try {
        mr_szInQueryProviderList = new WCHAR [m_dwInQueryProviderListLength];
        mr_szInQueryProviderList[0] = 0;
    } catch ( ... ) {
        m_dwInQueryProviderListLength = 0;
    }
}

//
//  Sync the stored provider list with WMI database.
//
HRESULT
CSmTraceLogQuery::SyncGenProviders( void )
{
    HRESULT hr;
    CSmTraceProviders* pProvList;

    ASSERT ( m_pLogService->CastToTraceLogService() );
    pProvList = ( m_pLogService->CastToTraceLogService())->GetProviders();

    hr = pProvList->SyncWithConfiguration();

    return hr;
}



//
//  Update the provided InQuery array to match the stored version.
//
DWORD
CSmTraceLogQuery::GetInQueryProviders( CArray<eProviderState, eProviderState&>& rarrOut )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    int     iIndex;

    rarrOut.RemoveAll();

    rarrOut.SetSize( m_arrGenProviders.GetSize() );

    for ( iIndex = 0; iIndex < (INT)rarrOut.GetSize(); iIndex++ ) {
        rarrOut[iIndex] = m_arrGenProviders[iIndex];
    }

    return dwStatus;
}

//
//  Return the description for the trace provider specified by
//  InQuery array index.
//
LPCWSTR
CSmTraceLogQuery::GetProviderDescription( INT iProvIndex )
{
    LPCWSTR pReturn = NULL;
    ASSERT ( NULL != m_pLogService );

    if ( NULL != m_pLogService ) {
        CSmTraceProviders* pProvList;
        ASSERT ( m_pLogService->CastToTraceLogService() );
        pProvList = ( m_pLogService->CastToTraceLogService())->GetProviders();
        ASSERT ( NULL != pProvList );

        if ( NULL != pProvList ) {
            SLQ_TRACE_PROVIDER*  pslqProvider = pProvList->GetProviderInfo( iProvIndex );
            pReturn = pslqProvider->strDescription;
        }
    }

    return pReturn;
}

LPCWSTR
CSmTraceLogQuery::GetProviderGuid( INT iProvIndex )
{
    LPCWSTR pReturn = NULL;
    ASSERT ( NULL != m_pLogService );

    if ( NULL != m_pLogService ) {
        CSmTraceProviders* pProvList;
        ASSERT ( m_pLogService->CastToTraceLogService() );
        pProvList = ( m_pLogService->CastToTraceLogService())->GetProviders();
        ASSERT ( NULL != pProvList );

        if ( NULL != pProvList ) {
            SLQ_TRACE_PROVIDER*  pslqProvider = pProvList->GetProviderInfo( iProvIndex );
            pReturn = pslqProvider->strGuid;
        }
    }

    return pReturn;
}

BOOL
CSmTraceLogQuery::IsEnabledProvider( INT iIndex )
{
    BOOL bReturn = FALSE;
    ASSERT ( NULL != m_pLogService );

    if ( NULL != m_pLogService ) {
        CSmTraceProviders* pProvList;
        ASSERT ( m_pLogService->CastToTraceLogService() );
        pProvList = ( m_pLogService->CastToTraceLogService())->GetProviders();
        ASSERT ( NULL != pProvList );

        if ( NULL != pProvList ) {
            SLQ_TRACE_PROVIDER*  pslqProvider = pProvList->GetProviderInfo( iIndex );
            bReturn = ( 1 == pslqProvider->iIsEnabled );
        }
    }

    return bReturn;
}

BOOL
CSmTraceLogQuery::IsActiveProvider( INT iIndex )
{
    BOOL bReturn = FALSE;
    ASSERT ( NULL != m_pLogService );

    if ( NULL != m_pLogService ) {
        CSmTraceProviders* pProvList;
        ASSERT ( m_pLogService->CastToTraceLogService() );
        pProvList = ( m_pLogService->CastToTraceLogService())->GetProviders();
        ASSERT ( NULL != pProvList );

        if ( NULL != pProvList ) {
            SLQ_TRACE_PROVIDER*  pslqProvider = pProvList->GetProviderInfo( iIndex );
            bReturn = ( 1 == pslqProvider->iIsActive );
        }
    }

    return bReturn;
}

LPCWSTR
CSmTraceLogQuery::GetKernelProviderDescription( void )
{
    LPCWSTR pReturn = NULL;
    ASSERT ( NULL != m_pLogService );

    if ( NULL != m_pLogService ) {
        CSmTraceProviders* pProvList;
        ASSERT ( m_pLogService->CastToTraceLogService() );
        pProvList = ( m_pLogService->CastToTraceLogService())->GetProviders();
        ASSERT ( NULL != pProvList );

        if ( NULL != pProvList ) {
            SLQ_TRACE_PROVIDER*  pslqProvider = pProvList->GetKernelProviderInfo( );
            pReturn = pslqProvider->strDescription;
        }
    }

    return pReturn;
}

BOOL
CSmTraceLogQuery::GetKernelProviderEnabled( void )
{
    BOOL bReturn = FALSE;
    ASSERT ( NULL != m_pLogService );

    if ( NULL != m_pLogService ) {
        CSmTraceProviders* pProvList;
        ASSERT ( m_pLogService->CastToTraceLogService() );
        pProvList = ( m_pLogService->CastToTraceLogService())->GetProviders();
        ASSERT ( NULL != pProvList );

        if ( NULL != pProvList ) {
            SLQ_TRACE_PROVIDER*  pslqProvider = pProvList->GetKernelProviderInfo();
            bReturn = ( 1 == pslqProvider->iIsEnabled );
        }
    }

    return bReturn;
}

DWORD
CSmTraceLogQuery::GetGenProviderCount( INT& iCount )
{
    DWORD dwStatus = ERROR_SUCCESS;
    ASSERT ( NULL != m_pLogService );

    iCount = 0;

    if ( NULL != m_pLogService ) {
        CSmTraceProviders* pProvList;
        ASSERT ( m_pLogService->CastToTraceLogService() );
        pProvList = ( m_pLogService->CastToTraceLogService())->GetProviders();
        ASSERT ( NULL != pProvList );

        if ( NULL != pProvList ) {
            iCount = pProvList->GetGenProvCount();
        }
    }

    return dwStatus;
}
//
//  Update the stored InQuery providers list and array
//  to match the provided version.
//
DWORD
CSmTraceLogQuery::SetInQueryProviders( CArray<eProviderState, eProviderState&>& rarrIn )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    int     iProvIndex;
    CSmTraceProviders* pProvList;

    m_arrGenProviders.RemoveAll();

    m_arrGenProviders.SetSize( rarrIn.GetSize() );

    for ( iProvIndex = 0; iProvIndex < (INT)m_arrGenProviders.GetSize(); iProvIndex++ ) {
        m_arrGenProviders[iProvIndex] = rarrIn[iProvIndex];
    }

    ResetInQueryProviderList();

    ASSERT ( NULL != m_pLogService );

    ASSERT ( m_pLogService->CastToTraceLogService() );
    pProvList = ( m_pLogService->CastToTraceLogService())->GetProviders();
    ASSERT ( NULL != pProvList );

    for ( iProvIndex = 0; iProvIndex < (INT)m_arrGenProviders.GetSize(); iProvIndex++ ) {
        if ( eInQuery == m_arrGenProviders[iProvIndex] ) {
            SLQ_TRACE_PROVIDER*  pslqProvider = pProvList->GetProviderInfo( iProvIndex );

            AddInQueryProvider ( pslqProvider->strGuid );

        }
    }
    return dwStatus;
}

//
//  Add this Provider string to the internal list
//
BOOL
CSmTraceLogQuery::AddInQueryProvider(LPCWSTR szProviderPath)
{
    DWORD   dwNewSize;
    LPWSTR  szNewString;
    LPWSTR  szNextString;

    ASSERT (szProviderPath != NULL);

    if (szProviderPath == NULL) return FALSE;

    dwNewSize = lstrlen(szProviderPath) + 1;

    if (m_dwInQueryProviderListLength <= 2) {
        dwNewSize += 1; // add room for the MSZ null
        // then this is the first string to go in the list
        try {
            szNewString = new WCHAR [dwNewSize];
        } catch ( ... ) {
            return FALSE; // leave now
        }
        szNextString = szNewString;
    } else {
        dwNewSize += m_dwInQueryProviderListLength;
        // this is the nth string to go in the list
        try {
            szNewString = new WCHAR [dwNewSize];
        } catch ( ... ) {
            return FALSE; // leave now
        }
        memcpy (szNewString, mr_szInQueryProviderList,
            (m_dwInQueryProviderListLength * sizeof(WCHAR)));
        szNextString = szNewString;
        szNextString += m_dwInQueryProviderListLength - 1;
    }
    StringCchCopy ( szNextString, lstrlen ( szProviderPath) + 1, szProviderPath );
    szNextString = szNewString;
    szNextString += dwNewSize - 1;
    *szNextString = 0;  // MSZ Null

    if (mr_szInQueryProviderList != NULL) {
        delete []mr_szInQueryProviderList;
    }
    mr_szInQueryProviderList = szNewString;
    m_szNextInQueryProvider = szNewString;
    m_dwInQueryProviderListLength = dwNewSize;

    return TRUE;
}

//
//  Get index of first inactive provider in list of providers for this query.
//  -1 indicates no inactive providers in the list.
INT
CSmTraceLogQuery::GetFirstInactiveIndex( void )
{
    INT     iIndex;
    INT     iCount;

    iCount = (INT)m_arrGenProviders.GetSize();

    if ( 0 < iCount ) {
        m_iNextInactiveIndex = 0;

        iIndex = GetNextInactiveIndex();

    } else {
        m_iNextInactiveIndex = -1;
        iIndex = -1;
    }

    // szReturn is -1 if no inactive providers.
    return iIndex;
}

//
//  Get next inactive provider in list of providers for this query.
//  -1 indicates no more inactive providers in the list.
//
INT
CSmTraceLogQuery::GetNextInactiveIndex()
{
    INT     iIndex;

    iIndex = m_iNextInactiveIndex;

    if ( -1 != iIndex ) {
        INT     iCount;

        iCount = (INT)m_arrGenProviders.GetSize();

        for ( ; iIndex < iCount; iIndex++ ) {
            if ( !IsActiveProvider ( iIndex ) ) {
                break;
            }
        }

        if ( iIndex >= iCount ) {
            iIndex = -1;
            m_iNextInactiveIndex = -1;
        } else {
            m_iNextInactiveIndex = iIndex + 1;
            ( m_iNextInactiveIndex < iCount ) ? TRUE : m_iNextInactiveIndex = -1;
        }
    } // else already at the end of the list so nothing to do

    return iIndex;
}

//
//  Return TRUE if at least one active provider exists on the system.
//
BOOL
CSmTraceLogQuery::ActiveProviderExists()
{
    BOOL    bActiveExists = FALSE;
    INT     iCount;
    INT     iIndex;

    iCount = (INT)m_arrGenProviders.GetSize();

    for ( iIndex = 0; iIndex < iCount; iIndex++ ) {
        if ( IsActiveProvider ( iIndex ) ) {
            bActiveExists = TRUE;
            break;
        }
    }

    return bActiveExists;
}

BOOL
CSmTraceLogQuery::GetTraceLogInfo (PSLQ_TRACE_LOG_INFO pptlInfo)
{
    if (pptlInfo != NULL) {
        *pptlInfo = mr_stlInfo;
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
CSmTraceLogQuery::SetTraceLogInfo (PSLQ_TRACE_LOG_INFO pptlInfo )
{

    if (pptlInfo != NULL) {
        mr_stlInfo = *pptlInfo;
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
CSmTraceLogQuery::GetKernelFlags ( DWORD& rdwFlags )
{
    rdwFlags = m_dwKernelFlags;
    return TRUE;
}

BOOL
CSmTraceLogQuery::SetKernelFlags ( DWORD dwFlags )
{
    m_dwKernelFlags = dwFlags;
    return TRUE;
}

BOOL
CSmTraceLogQuery::GetLogTime(PSLQ_TIME_INFO pTimeInfo, DWORD dwFlags)
{
    BOOL bStatus;

    ASSERT ( ( SLQ_TT_TTYPE_START == dwFlags )
            || ( SLQ_TT_TTYPE_STOP == dwFlags )
            || ( SLQ_TT_TTYPE_RESTART == dwFlags ));

    bStatus = CSmLogQuery::GetLogTime( pTimeInfo, dwFlags );

    return bStatus;
}

BOOL
CSmTraceLogQuery::SetLogTime(PSLQ_TIME_INFO pTimeInfo, const DWORD dwFlags)
{
    BOOL bStatus;

    ASSERT ( ( SLQ_TT_TTYPE_START == dwFlags )
            || ( SLQ_TT_TTYPE_STOP == dwFlags )
            || ( SLQ_TT_TTYPE_RESTART == dwFlags ));

    bStatus = CSmLogQuery::SetLogTime( pTimeInfo, dwFlags );

    return bStatus;
}

BOOL
CSmTraceLogQuery::GetDefaultLogTime(SLQ_TIME_INFO& rTimeInfo, DWORD dwFlags)
{
    ASSERT ( ( SLQ_TT_TTYPE_START == dwFlags )
            || ( SLQ_TT_TTYPE_STOP == dwFlags ) );

    rTimeInfo.wTimeType = (WORD)dwFlags;
    rTimeInfo.wDataType = SLQ_TT_DTYPE_DATETIME;

    if ( SLQ_TT_TTYPE_START == dwFlags ) {
        SYSTEMTIME  stLocalTime;
        FILETIME    ftLocalTime;

        // Milliseconds set to 0 for Schedule times
        ftLocalTime.dwLowDateTime = ftLocalTime.dwHighDateTime = 0;
        GetLocalTime (&stLocalTime);
        stLocalTime.wMilliseconds = 0;
        SystemTimeToFileTime (&stLocalTime, &ftLocalTime);

        rTimeInfo.dwAutoMode = SLQ_AUTO_MODE_AT;
        rTimeInfo.llDateTime = *(LONGLONG *)&ftLocalTime;
    } else {
        // Default stop values
        rTimeInfo.dwAutoMode = SLQ_AUTO_MODE_NONE;
        rTimeInfo.llDateTime = MAX_TIME_VALUE;
    }

    return TRUE;
}

DWORD
CSmTraceLogQuery::GetLogType()
{
    return ( SLQ_TRACE_LOG );
}


HRESULT
CSmTraceLogQuery::LoadFromPropertyBag (
    IPropertyBag* pPropBag,
    IErrorLog* pIErrorLog )
{
    HRESULT     hr = S_OK;
    CString     strParamName;
    CString     strNonLocParamName;
    DWORD       dwCount = 0;
    DWORD       dwIndex;
    DWORD       dwTraceFlags;
    DWORD       dwKernelTraceFlagMask;

    // Continue even if error, using defaults for missing values.

    // Load trace providers
    hr = DwordFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_TRACE_PROVIDER_COUNT,
            0,
            dwCount);

    for ( dwIndex = 1; dwIndex <= dwCount; dwIndex++ ) {
        LPWSTR  szProviderGuid = NULL;
        DWORD   dwBufSize = 0;

        strNonLocParamName.Format ( GetNonLocHtmlPropName ( IDS_HTML_TRACE_PROVIDER_GUID ), dwIndex );
        strParamName.Format ( IDS_HTML_TRACE_PROVIDER_GUID, dwIndex );
        hr = StringFromPropertyBag (
                pPropBag,
                pIErrorLog,
                strParamName,
                strNonLocParamName,
                L"",
                &szProviderGuid,
                &dwBufSize );

        if ( NULL != szProviderGuid && dwBufSize > sizeof(WCHAR)) {
            AddInQueryProvider ( szProviderGuid );
        }
        delete [] szProviderGuid;
    }

    // Load trace buffer properties
    hr = DwordFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_TRACE_BUFFER_SIZE,
            TRACE_DEFAULT_BUFFER_SIZE,
            mr_stlInfo.dwBufferSize);

    hr = DwordFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_TRACE_BUFFER_MIN_COUNT,
            TRACE_DEFAULT_MIN_COUNT,
            mr_stlInfo.dwMinimumBuffers);

    hr = DwordFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_TRACE_BUFFER_MAX_COUNT,
            TRACE_DEFAULT_MAX_COUNT,
            mr_stlInfo.dwMaximumBuffers);

    hr = DwordFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_TRACE_BUFFER_FLUSH_INT,
            TRACE_DEFAULT_BUFFER_FLUSH_INT,
            mr_stlInfo.dwBufferFlushInterval);

    hr = DwordFromPropertyBag (
            pPropBag,
            pIErrorLog,
            IDS_HTML_TRACE_FLAGS,
            TRACE_DEFAULT_FLAGS,
            dwTraceFlags);

    if ( 0 != (dwTraceFlags & SLQ_TLI_ENABLE_BUFFER_FLUSH) ) {
        mr_stlInfo.dwBufferFlags = SLQ_TLI_ENABLE_BUFFER_FLUSH;
    }

    dwKernelTraceFlagMask = SLQ_TLI_ENABLE_KERNEL_TRACE
                            | SLQ_TLI_ENABLE_PROCESS_TRACE
                            | SLQ_TLI_ENABLE_THREAD_TRACE
                            | SLQ_TLI_ENABLE_DISKIO_TRACE
                            | SLQ_TLI_ENABLE_NETWORK_TCPIP_TRACE
                            | SLQ_TLI_ENABLE_MEMMAN_TRACE
                            | SLQ_TLI_ENABLE_FILEIO_TRACE;

    m_dwKernelFlags = dwKernelTraceFlagMask & dwTraceFlags;

    hr = CSmLogQuery::LoadFromPropertyBag( pPropBag, pIErrorLog );

    // The GenProviders array is synched with the registry when a properties dialog is opened.
    // If no dialog is opened, there is no reason to synchronize it.

    return hr;
}

HRESULT
CSmTraceLogQuery::SaveToPropertyBag (
    IPropertyBag* pPropBag,
    BOOL fSaveAllProps )
{
    HRESULT hr = NOERROR;
    CString strNonLocParamName;
    LPCWSTR pszProviderGuid;
    DWORD   dwTraceFlags;
    DWORD   dwIndex = 0;

    // Save provider Guids
    pszProviderGuid = GetFirstInQueryProvider();

    MFC_TRY
        // Passing sz ( WCHAR[n] ) causes memory alloc, which might throw an exception
        while ( NULL != pszProviderGuid ) {
            // Provider count starts at 1.
            strNonLocParamName.Format ( GetNonLocHtmlPropName ( IDS_HTML_TRACE_PROVIDER_GUID ), ++dwIndex );
            hr = StringToPropertyBag ( pPropBag, strNonLocParamName, pszProviderGuid );
            pszProviderGuid = GetNextInQueryProvider();
        }
        hr = DwordToPropertyBag ( pPropBag, IDS_HTML_TRACE_PROVIDER_COUNT, dwIndex );
    MFC_CATCH_HR
    // Todo: Handle error

    // Save trace buffer properties
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_TRACE_BUFFER_SIZE, mr_stlInfo.dwBufferSize );
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_TRACE_BUFFER_MIN_COUNT, mr_stlInfo.dwMinimumBuffers );
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_TRACE_BUFFER_MAX_COUNT, mr_stlInfo.dwMaximumBuffers );
    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_TRACE_BUFFER_FLUSH_INT, mr_stlInfo.dwBufferFlushInterval );

    dwTraceFlags = m_dwKernelFlags | mr_stlInfo.dwBufferFlags;

    hr = DwordToPropertyBag ( pPropBag, IDS_HTML_TRACE_FLAGS, dwTraceFlags );

    hr = CSmLogQuery::SaveToPropertyBag( pPropBag, fSaveAllProps );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smtprov.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smtprov.cpp

Abstract:

    This object is used to store the list of all current 
    trace providers in the system.

--*/

#include "Stdafx.h"
#include <wbemidl.h>
#include <initguid.h>
#include <wmistr.h>
#include <evntrace.h>
#include "smtracsv.h"
#include "smtprov.h"

USE_HANDLE_MACROS("SMLOGCFG(smtprov.cpp)");

#define WIN32_FROM_HRESULT(x)((x) & 0x0000FFFF)

LPCWSTR CSmTraceProviders::m_cszBackslash = L"\\";
LPCWSTR CSmTraceProviders::m_cszKernelLogger = KERNEL_LOGGER_NAMEW;     // From evntrace.h
LPCWSTR CSmTraceProviders::m_cszDefaultNamespace = L"root\\wmi";
LPCWSTR CSmTraceProviders::m_cszTraceProviderClass = L"EventTrace";
LPCWSTR CSmTraceProviders::m_cszDescription = L"Description";
LPCWSTR CSmTraceProviders::m_cszGuid = L"Guid";

//
//  Constructor
CSmTraceProviders::CSmTraceProviders ( CSmTraceLogService* pSvc )
:   m_pWbemServices ( NULL ),
    m_pTraceLogService ( pSvc ),
    m_iBootState ( -1 )
{
    m_KernelTraceProvider.strDescription = L"";
    m_KernelTraceProvider.strGuid = L"";
    return;
}

//
//  Destructor
CSmTraceProviders::~CSmTraceProviders ( )
{
    ASSERT ( 0 == (INT)m_arrGenTraceProvider.GetSize ( ) );
    m_arrGenTraceProvider.RemoveAll ( );

    return;
}

//
//  Open function. Initialize provider array from Wbem.
//
DWORD
CSmTraceProviders::Open ( const CString& rstrMachineName )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD dwLength;
    CString strTemp;

    MFC_TRY
        if ( !rstrMachineName.IsEmpty ( ) ) {
            m_strMachineName = rstrMachineName;
            if ( 0 != lstrcmpi ( m_cszBackslash, m_strMachineName.Left(1) ) ) {
                strTemp = m_cszBackslash;
                strTemp += m_cszBackslash;
                m_strMachineName = strTemp + m_strMachineName;
            }
        } else {

            // get the local machine name & default name space if the caller
            // has passed in a NULL machine name

            dwLength = MAX_COMPUTERNAME_LENGTH + 1;

            if ( GetComputerName (
                    m_strMachineName.GetBufferSetLength( dwLength ),
                    &dwLength ) ) {
                m_strMachineName.ReleaseBuffer();
                strTemp = m_cszBackslash;
                strTemp += m_cszBackslash;
                m_strMachineName = strTemp + m_strMachineName;
            } else {
                dwStatus = GetLastError();
                m_strMachineName.ReleaseBuffer();
            }
        }
    MFC_CATCH_DWSTATUS

    if ( ERROR_SUCCESS != dwStatus ) {
        m_strMachineName.Empty();
    }

    return dwStatus;
}

//
//  Close Function
//      Frees allocated memory
//
DWORD
CSmTraceProviders::Close ( )
{
    DWORD dwStatus = ERROR_SUCCESS;

    m_arrGenTraceProvider.RemoveAll ( );
    
    if ( NULL != m_pWbemServices ) {
        m_pWbemServices->Release ( );
        m_pWbemServices = NULL;
    }

    return dwStatus;
}

//
//  AddProvider
//      Add the specified provider strings to the array     
//  
DWORD
CSmTraceProviders::AddProvider (
    const CString& rstrDescription,
    const CString& rstrGuid,
    INT iIsEnabled,
    INT iIsActive )
{
    DWORD dwStatus = ERROR_SUCCESS;

    SLQ_TRACE_PROVIDER slqTProv;

    // If inactive, cannot be enabled.
    ASSERT ( ( 0 == iIsActive ) ? ( 0 == iIsEnabled ) : TRUE );

    MFC_TRY
        slqTProv.strDescription = rstrDescription;
        slqTProv.strGuid = rstrGuid;
        slqTProv.iIsEnabled = iIsEnabled;
        slqTProv.iIsActive = iIsActive;

        m_arrGenTraceProvider.Add( slqTProv );
    MFC_CATCH_DWSTATUS

    return dwStatus;
}


//
//  ConnectToServer
//      Connects to the Wbem server.
//  
HRESULT   
CSmTraceProviders::ConnectToServer ( void )
{
    HRESULT hr = NOERROR;

    if ( NULL == m_pWbemServices ) {
        IWbemLocator    *pWbemLocator = NULL;
        IWbemServices   *pWbemServices = NULL;

        // connect to locator
        hr = CoCreateInstance ( 
                CLSID_WbemLocator, 
                0, 
                CLSCTX_INPROC_SERVER,
                IID_IWbemLocator, 
                ( LPVOID * )&pWbemLocator );

        if ( SUCCEEDED (hr) ) {
            BSTR    bstrTemp = NULL;
            CString strNamespace; 

            MFC_TRY
                strNamespace = m_strMachineName;
                strNamespace += m_cszBackslash; 
                strNamespace += m_cszDefaultNamespace;
                bstrTemp = strNamespace.AllocSysString();
            MFC_CATCH_HR  
                
            if ( SUCCEEDED ( hr ) ) {
                // try to connect to the service
                hr = pWbemLocator->ConnectServer ( 
                    bstrTemp,
                    NULL, 
                    NULL, 
                    0, 
                    0L,
                    0,
                    0,
                    &pWbemServices );
        
                ::SysFreeString ( bstrTemp );
            }

            if ( SUCCEEDED ( hr ) ) {
                hr = CoSetProxyBlanket((IUnknown*)pWbemServices,
                            RPC_C_AUTHN_WINNT,
                            RPC_C_AUTHZ_NONE,
                            NULL,
                            RPC_C_AUTHN_LEVEL_PKT,
                            RPC_C_IMP_LEVEL_IMPERSONATE,
                            NULL,
                            EOAC_NONE);
            }
            // free the locator
            pWbemLocator->Release ( );
        }

        if ( SUCCEEDED ( hr ) ) {
            m_pWbemServices = pWbemServices;
        }
    }

    return hr;
}

//
//  GetBootState
//      Connects to the registry.
//  
HRESULT   
CSmTraceProviders::GetBootState ( INT& riBootState )
{
    HRESULT hr = NOERROR;

    if ( -1  == m_iBootState ) {
        HKEY    hKeyMachine;

        ASSERT ( NULL != m_pTraceLogService );

        hKeyMachine = m_pTraceLogService->GetMachineKey ( );

        if ( NULL != hKeyMachine ) {
            HKEY    hKeyOption;
            DWORD   dwStatus = ERROR_SUCCESS;

            dwStatus = RegOpenKeyEx ( 
                            hKeyMachine,
                            (LPCWSTR)L"System\\CurrentControlSet\\Control\\Safeboot\\Option",
                            0,
                            KEY_READ,
                            &hKeyOption );

            // The Option key and OptionValue value only exist if booting in 
            // safe mode, so failure indicates Normal mode (0).
            // Safe mode = 1, Safe mode with network = 2.
            if ( ERROR_SUCCESS == dwStatus  ) {
                DWORD dwType = 0;
                DWORD dwBufSize = sizeof (INT );

                dwStatus = RegQueryValueExW (
                    hKeyOption,
                    L"OptionValue",
                    NULL,
                    &dwType,
                    (LPBYTE)&m_iBootState,
                    &dwBufSize);

                if ( ERROR_SUCCESS != dwStatus ) {
                    // Normal mode
                    m_iBootState = 0;
                }
                RegCloseKey(hKeyOption);
            } else {
                // Normal mode
                m_iBootState = 0;
            }

        } else {
            // Unable to access registry
            hr = E_FAIL;
        }
    
    }

    riBootState = m_iBootState;

    return hr;
}

//
//  SyncWithConfiguration
//      Reads the current list of providers from Wbem
//      and reloads the internal values to match
//
HRESULT
CSmTraceProviders::SyncWithConfiguration ( void )
{
    typedef struct _LOG_INFO {
        EVENT_TRACE_PROPERTIES  Properties;
        WCHAR                   szLoggerName[MAX_PATH+1];   // Must follow Properties
    } LOG_INFO, FAR* PLOG_INFO;
    
    IEnumWbemClassObject    *pEnumProviders = NULL;
    CString strDescription;
    CString strGuid;
    CString strBracketedGuid;
    BSTR    bstrTemp;
    INT     iIndex;
    INT iIsEnabled =0;
    HRESULT hr;

    PTRACE_GUID_PROPERTIES* arrGuidProperties = NULL;
    ULONG  ulGuidCount;
    PVOID pGuidStorage = NULL;
    
    m_arrGenTraceProvider.RemoveAll ( );

    hr = ConnectToServer( );

    if ( SUCCEEDED ( hr ) ) {
        hr = LoadGuidArray( &pGuidStorage, &ulGuidCount );
    }

    if ( SUCCEEDED ( hr ) ) {
        arrGuidProperties = (PTRACE_GUID_PROPERTIES *)pGuidStorage;
        ASSERT ( NULL != arrGuidProperties );
    }

    //If Connection succeeded and registered Guids gathered.
    if ( SUCCEEDED ( hr ) ) {

        // Create an enumerator of the Trace Provider class
        MFC_TRY
            bstrTemp = SysAllocString(m_cszTraceProviderClass);
            hr = m_pWbemServices->CreateClassEnum ( 
                bstrTemp,
                WBEM_FLAG_SHALLOW|WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                NULL,
                &pEnumProviders );
            ::SysFreeString ( bstrTemp );
        MFC_CATCH_HR    

        if ( SUCCEEDED ( hr ) ) {
            BSTR    bsDescription = NULL;
            BSTR    bsGuid = NULL;
            VARIANT vValue;
            DWORD   dwRtnCount;
            IWbemQualifierSet   *pQualSet = NULL;
            IWbemClassObject    *pThisClass = NULL;
            WCHAR   szSystemTraceControlGuid[39];
            ULONG   Status;

            VariantInit ( &vValue );
            ZeroMemory ( szSystemTraceControlGuid, sizeof ( szSystemTraceControlGuid ) );

            ::StringFromGUID2( SystemTraceControlGuid, szSystemTraceControlGuid, 39);

            MFC_TRY
                bsDescription = SysAllocString(m_cszDescription);
                bsGuid = SysAllocString(m_cszGuid);
            MFC_CATCH_HR   
                
            if ( SUCCEEDED ( hr ) ) {

                iIsEnabled = 0; 

                while ( SUCCEEDED ( hr ) ) {
                    hr = pEnumProviders->Next ( 
                        0,      // timeout
                        1,      // return only 1 object
                        &pThisClass,
                        &dwRtnCount );

                    if ( SUCCEEDED ( hr ) ) {
                            // no more classes
                        if ( dwRtnCount == 0 ) break;

                        pThisClass->GetQualifierSet ( &pQualSet );
                        if ( pQualSet != NULL ) {

                            hr = pQualSet->Get ( bsGuid, 0, &vValue, 0 );
                            if ( SUCCEEDED ( hr ) ) {
                                strGuid = ( LPWSTR )V_BSTR ( &vValue );
                                VariantClear ( &vValue );

                                hr = pQualSet->Get ( bsDescription, 0, &vValue, 0 );
                                if ( SUCCEEDED ( hr ) ) {
                                        strDescription = ( LPWSTR )V_BSTR ( &vValue );
                                        VariantClear ( &vValue );
                                } else {
                                    hr = ERROR_SUCCESS;
                                    strDescription = strGuid;
                                }
                            }


                            pQualSet->Release();
                        }

                        // The Win2000 Kernel trace provider is handled separately.
                        if ( SUCCEEDED ( hr ) ) {
                            MFC_TRY
                                if ( L'{' != strGuid[0] ) {
                                    strBracketedGuid.Format ( L"{%s}", strGuid );
                                } else {
                                    strBracketedGuid = strGuid;
                                }
                            MFC_CATCH_HR

                            if ( 0 == strBracketedGuid.CompareNoCase( szSystemTraceControlGuid ) ) {
                                PLOG_INFO  pLoggerInfo = NULL;

                                TRACEHANDLE     LoggerHandle = 0;

                                // Kernel trace provider.  Need to pass GUID as name.
                                MFC_TRY

                                    pLoggerInfo = new LOG_INFO;
                                    ZeroMemory ( pLoggerInfo, sizeof ( LOG_INFO ) );
                                    pLoggerInfo->Properties.LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
                                    pLoggerInfo->Properties.Wnode.BufferSize = sizeof( LOG_INFO );
                                    pLoggerInfo->Properties.Wnode.Flags = WNODE_FLAG_TRACED_GUID;
  
                                    pLoggerInfo->Properties.Wnode.Guid = SystemTraceControlGuid;

                                    Status = QueryTrace(LoggerHandle, m_cszKernelLogger, &(pLoggerInfo->Properties) );
                                    iIsEnabled = (Status == 0) ? 1 : 0;
                                    m_KernelTraceProvider.strDescription = strDescription;
                                    m_KernelTraceProvider.strGuid = strBracketedGuid;
                                    m_KernelTraceProvider.iIsEnabled = iIsEnabled;
                                    m_KernelTraceProvider.iIsActive = 1;
                                MFC_CATCH_HR

                                if ( NULL != pLoggerInfo ) {
                                    delete pLoggerInfo;
                                }

                            } else {
                                //loop on all the registered guids
                                INT iIsActive = 0;
                                GUID    guidTemp;    // Todo:  Init
                                BOOL bSuccess;

                                ZeroMemory ( &guidTemp, sizeof (GUID) );

                                bSuccess = wGUIDFromString (strGuid, &guidTemp );

                                if ( bSuccess ) {

                                    for (iIndex = 0 ; iIndex < (INT)ulGuidCount; iIndex ++){
                                        if ( guidTemp == arrGuidProperties[iIndex]->Guid ) {
                                            DWORD dwStatus;

                                            iIsActive = 1;

                                            dwStatus = AddProvider ( 
                                                        strDescription,
                                                        strBracketedGuid,
                                                        arrGuidProperties[iIndex]->IsEnable,                                          
                                                        iIsActive );

                                            if ( ERROR_OUTOFMEMORY == dwStatus ) {
                                                hr = E_OUTOFMEMORY;
                                            } else if ( ERROR_SUCCESS != dwStatus ) {
                                                hr = E_FAIL;
                                            }

                                            break;
                                        }
                                    }
                                } // Todo:  Error message on invalid Guid string.
                                
                                if ( 0 == iIsActive ) {
                                    DWORD dwStatus;

                                    dwStatus = AddProvider ( 
                                                strDescription,
                                                strBracketedGuid,
                                                0,                                          
                                                iIsActive );
                                
                                    if ( ERROR_OUTOFMEMORY == dwStatus ) {
                                        hr = E_OUTOFMEMORY;
                                    } else if ( ERROR_SUCCESS != dwStatus ) {
                                        hr = E_FAIL;
                                    }
                                }
                            }
                        }

                        pThisClass->Release ( );

                    }
                }
                ::SysFreeString ( bsGuid );
                ::SysFreeString ( bsDescription );
            }
        }
    }


    // Done with these objects.

    if ( NULL != pGuidStorage ) {
        G_FREE ( pGuidStorage );
    }

    if ( NULL != pEnumProviders ) {
        pEnumProviders->Release ( );
    }

    return hr;
}

//
//  Get specified provider in provider list
//
SLQ_TRACE_PROVIDER*
CSmTraceProviders::GetProviderInfo ( INT iIndex )
{
    return &m_arrGenTraceProvider[iIndex];
}

//
//  Return a pointer to the Kernel provider.
//
SLQ_TRACE_PROVIDER*
CSmTraceProviders::GetKernelProviderInfo ( void )
{
    return &m_KernelTraceProvider;
}

//
//  Return the index of the provider specified by Guid
//
INT
CSmTraceProviders::IndexFromGuid ( const CString& rstrGuid )
{
    int iIndex;
    int iCount = (INT)m_arrGenTraceProvider.GetSize ( );

    for ( iIndex = 0; iIndex < iCount; iIndex++ ) {
        if ( 0 == m_arrGenTraceProvider[iIndex].strGuid.CompareNoCase( rstrGuid ) ) {
            break;
        }
    }

    // Signal not found with -1.
    if ( iIndex == iCount ) {
        iIndex = -1;
    }
    return iIndex;
}

//
//  Get provider list count
//
INT
CSmTraceProviders::GetGenProvCount ( )
{
    return (INT)m_arrGenTraceProvider.GetSize ( );
}

//
//   LoadGuidArray copied from evntrprv.cpp 9/12/01
//

HRESULT 
CSmTraceProviders::LoadGuidArray( PVOID* Storage, PULONG pnGuidCount )
{
    ULONG i;
    ULONG nGuidArray = 16;
    ULONG nGuidCount = 0;
    DWORD dwSize;
    PTRACE_GUID_PROPERTIES* GuidPropertiesArray;
    PTRACE_GUID_PROPERTIES pStorage;
    HRESULT hr = ERROR_SUCCESS;

    do {
        dwSize = nGuidArray * (sizeof(TRACE_GUID_PROPERTIES) + sizeof(PTRACE_GUID_PROPERTIES));

        MFC_TRY
            *Storage = G_ALLOC(dwSize);
        MFC_CATCH_HR

        if ( FAILED (hr) || *Storage == NULL) {
            if (*Storage == NULL) {
                hr = E_OUTOFMEMORY;
            }

            break;
        } else {
            RtlZeroMemory(*Storage, dwSize);
            GuidPropertiesArray = (PTRACE_GUID_PROPERTIES *)(*Storage);
            pStorage = (PTRACE_GUID_PROPERTIES)((char*)(*Storage) + nGuidArray * sizeof(PTRACE_GUID_PROPERTIES));
            for (i=0; i < nGuidArray; i++) {
                GuidPropertiesArray[i] = pStorage;
                pStorage = (PTRACE_GUID_PROPERTIES)((char*)pStorage + sizeof(TRACE_GUID_PROPERTIES));
            }

            hr = EnumerateTraceGuids(GuidPropertiesArray,nGuidArray,&nGuidCount);
        
            if ( hr == ERROR_MORE_DATA ) {
                if( nGuidCount <= nGuidArray ){
                    hr = WBEM_E_INVALID_PARAMETER;
                    break;
                }
                nGuidArray = nGuidCount;
                G_FREE(*Storage);
                (*Storage) = NULL;
            }
        }

    }while( hr == ERROR_MORE_DATA );
    
    if( ERROR_SUCCESS == hr ){
        *pnGuidCount = nGuidCount;
    }else{
        *pnGuidCount = 0;
    }
        
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smtraceq.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smtraceq.h

Abstract:

    Class definitions for the trace log query class.

--*/

#ifndef _CLASS_SMTRACEQ_
#define _CLASS_SMTRACEQ_

#include "smlogqry.h"

// open method flags
// only open an existing entry
#define SLQ_OPEN_EXISTING   0
// always create a new and uninitialized entry
#define SLQ_CREATE_NEW      1
// open an existing entry if it exists or create an empty one if not
#define SLQ_OPEN_ALWAYS     2

typedef struct _SLQ_TRACE_LOG_INFO {
    DWORD   dwBufferSize;   // in K bytes
    DWORD   dwMinimumBuffers;
    DWORD   dwMaximumBuffers;
    DWORD   dwBufferFlushInterval; // in seconds
    DWORD   dwBufferFlags; // defined in common.h
} SLQ_TRACE_LOG_INFO, *PSLQ_TRACE_LOG_INFO;

//
//  This object is used to represent trace log queries
//
//

class CSmTraceLogQuery : public CSmLogQuery
{
    // constructor/destructor
    public:
                CSmTraceLogQuery( CSmLogService* );
        virtual ~CSmTraceLogQuery( void );

    // public methods
    public:

        enum eProviderState {
            eNotInQuery = 0,
            eInQuery = 1
        };

        virtual DWORD   Open ( const CString& rstrName, HKEY hKeyQuery, BOOL bReadOnly);
        virtual DWORD   Close ( void );

        virtual DWORD   SyncWithRegistry ( void );
                HRESULT SyncGenProviders ( void );

        virtual BOOL    GetLogTime ( PSLQ_TIME_INFO pTimeInfo, DWORD dwFlags );
        virtual BOOL    SetLogTime ( PSLQ_TIME_INFO pTimeInfo, const DWORD dwFlags );
        virtual BOOL    GetDefaultLogTime ( SLQ_TIME_INFO& rTimeInfo, DWORD dwFlags );

        virtual DWORD   GetLogType ( void );

                BOOL    GetTraceLogInfo ( PSLQ_TRACE_LOG_INFO pptlInfo );
                BOOL    SetTraceLogInfo ( PSLQ_TRACE_LOG_INFO pptlInfo );

                BOOL    GetKernelFlags ( DWORD& rdwFlags );
                BOOL    SetKernelFlags ( DWORD dwFlags );

                DWORD   InitGenProvidersArray ( void );

                LPCWSTR GetProviderDescription ( INT iProvIndex );
                LPCWSTR GetProviderGuid ( INT iProvIndex );
                BOOL    IsEnabledProvider ( INT iProvIndex );
                BOOL    IsActiveProvider ( INT iProvIndex );
                DWORD   GetGenProviderCount ( INT& iCount );

                LPCWSTR GetKernelProviderDescription ( void );
                BOOL    GetKernelProviderEnabled ( void );

                INT     GetFirstInactiveIndex ( void );
                INT     GetNextInactiveIndex ( void );
                BOOL    ActiveProviderExists ( void );

                DWORD   GetInQueryProviders ( CArray<eProviderState, eProviderState&>& );
                DWORD   SetInQueryProviders ( CArray<eProviderState, eProviderState&>& );

        virtual HRESULT LoadFromPropertyBag ( IPropertyBag*, IErrorLog* );
		virtual HRESULT SaveToPropertyBag   ( IPropertyBag*, BOOL fSaveAllProps );

        virtual CSmTraceLogQuery* CastToTraceLogQuery ( void ) { return this; };
    // protected methods
    protected:
        virtual DWORD   UpdateRegistry();

    // private member variables
    private:

                VOID    ResetInQueryProviderList ( void );
                BOOL    AddInQueryProvider ( LPCWSTR szProviderPath);
                LPCWSTR GetFirstInQueryProvider ( void );
                LPCWSTR GetNextInQueryProvider ( void );

        LPWSTR  m_szNextInQueryProvider;
        DWORD   m_dwInQueryProviderListLength;  // in chars including MSZ null

        CArray<eProviderState, eProviderState&> m_arrGenProviders;

        INT     m_iNextInactiveIndex;

        // Registry Values
        LPWSTR  mr_szInQueryProviderList;
        SLQ_TRACE_LOG_INFO  mr_stlInfo;
        DWORD               m_dwKernelFlags; // defined in common.h

};


typedef CSmTraceLogQuery   SLTRACEQUERY;
typedef CSmTraceLogQuery*  PSLTRACEQUERY;


#endif //_CLASS_SMTRACEQ_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smtracsv.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smtracsv.h

Abstract:

	This object is used to represent the trace log query components of the
	sysmon log service

--*/

#ifndef _CLASS_SMTRACELOGSERVICE_
#define _CLASS_SMTRACELOGSERVICE_

#include "smlogs.h"

class CSmTraceProviders;

class CSmTraceLogService : public CSmLogService
{

friend class CSmTraceProviders;

    // constructor/destructor
    public:
        CSmTraceLogService();
        
        virtual ~CSmTraceLogService();

    // public methods
    public:

        virtual DWORD   Open ( const CString& rstrMachineName );
        virtual DWORD   Close ( void );

        virtual DWORD   SyncWithRegistry ( PSLQUERY* ppActiveQuery = NULL );

        virtual PSLQUERY    CreateQuery ( const CString& rstrName );
        virtual DWORD       DeleteQuery ( PSLQUERY pQuery );

        virtual CSmTraceLogService* CastToTraceLogService( void ) { return this; };

        CSmTraceProviders*  GetProviders( void );

    protected:
        
        virtual DWORD       LoadQueries( void );

    private:

        HKEY        GetMachineKey ( void ) 
                        { return GetMachineRegistryKey(); };
        
        CSmTraceProviders* m_pProviders;
};



#endif //_CLASS_SMTRACELOGSERVICE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\smtracsv.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smtracsv.cpp

Abstract:

    This object is used to represent the trace log query components of the
    sysmon log service


--*/

#include "Stdafx.h"
#include "smtprov.h"
#include "smtraceq.h"
#include "smtracsv.h"

USE_HANDLE_MACROS("SMLOGCFG(smalrtq.cpp)");

//
//  Constructor
CSmTraceLogService::CSmTraceLogService()
:   m_pProviders ( NULL )
{
    CString                 strTemp;
    ResourceStateManager    rsm;

    // String allocation errors are thrown, to be
    // captured by rootnode alloc exception handler
    strTemp.LoadString ( IDS_SERVICE_NAME_TRACE );
    SetBaseName ( strTemp ); 
    strTemp.LoadString ( IDS_TRACE_NODE_DESCRIPTION );
    SetDescription( strTemp ); 
}

//
//  Destructor
CSmTraceLogService::~CSmTraceLogService()
{
    // make sure Close method was called first!
    ASSERT ( NULL == m_pProviders );
    return;
}

PSLQUERY    
CSmTraceLogService::CreateQuery ( const CString& rstrName )
{
    return ( CSmLogService::CreateTypedQuery( rstrName, SLQ_TRACE_LOG ) );
}

DWORD   
CSmTraceLogService::DeleteQuery ( PSLQUERY pQuery ) 
{
    ASSERT ( SLQ_TRACE_LOG == pQuery->GetLogType ( ) );
    return ( CSmLogService::DeleteQuery ( pQuery ) );
}

DWORD   
CSmTraceLogService::LoadQueries ( void )
{
    return ( CSmLogService::LoadQueries( SLQ_TRACE_LOG ) );
}

//  
//  Open function. Opens all existing log query entries.
//
DWORD   
CSmTraceLogService::Open ( const CString& rstrMachineName )
{
    DWORD dwStatus = ERROR_SUCCESS;

    // Initialize trace provider list.
    
    MFC_TRY
        m_pProviders = new CSmTraceProviders ( this );

        dwStatus = m_pProviders->Open( rstrMachineName );

    if ( ERROR_SUCCESS == dwStatus ) {
        dwStatus = CSmLogService::Open ( rstrMachineName );
        if ( ERROR_SUCCESS != dwStatus ) {
            m_pProviders->Close();
        }
    }

    MFC_CATCH_DWSTATUS

    if ( ERROR_SUCCESS != dwStatus ) {
        if ( NULL != m_pProviders ) {
            delete m_pProviders;
            m_pProviders = NULL;
        }
    }
    return dwStatus;
}

//
//  Close Function
//      closes registry handles and frees allocated memory
//      
DWORD   
CSmTraceLogService::Close ()
{
    // Close and delete the list of trace providers
    if ( NULL != m_pProviders ) {
        m_pProviders->Close();
        delete m_pProviders;
        m_pProviders = NULL;
    }

    return ( CSmLogService::Close() );
}

//
//  SyncWithRegistry()
//      reads the current values for all queries from the registry
//      and reloads the internal values to match.
//
//      Updates the trace provider list.
//  
DWORD   
CSmTraceLogService::SyncWithRegistry( PSLQUERY* ppActiveQuery )
{
    DWORD       dwStatus = ERROR_SUCCESS;

    dwStatus = CSmLogService::SyncWithRegistry ( ppActiveQuery );

    return dwStatus;
}

CSmTraceProviders* 
CSmTraceLogService::GetProviders()
{
    return m_pProviders;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\sqlprop.cpp ===
// SqlProp.cpp : implementation file
//

#include "stdafx.h"
#include "smlogcfg.h"
#include "smcfgmsg.h"
#include "fileprop.h"
#include "sql.h"
#include "sqlext.h"
#include "odbcinst.h"
#include "smlogs.h"
#include "smlogqry.h"
#include "Fileprop.h"
#include "SqlProp.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

USE_HANDLE_MACROS("SMLOGCFG(sqlprop.cpp)");

static ULONG
s_aulHelpIds[] =
{
    IDC_SQL_DSN_COMBO,      IDH_SQL_DSN_COMBO,
    IDC_SQL_DSN_EDIT,       IDH_SQL_DSN_COMBO,
    IDC_SQL_LOG_SET_EDIT,   IDH_SQL_FILENAME_EDIT,
    IDC_SQL_SIZE_MAX_BTN,   IDH_SQL_SIZE_MAX_BTN,
    IDC_SQL_SIZE_LIMIT_EDIT,IDH_SQL_SIZE_LIMIT_EDIT,
    IDC_SQL_SIZE_LIMIT_BTN, IDH_SQL_SIZE_LIMIT_BTN,
    IDC_SQL_SIZE_LIMIT_SPIN,IDH_SQL_SIZE_LIMIT_SPIN,
    0,0
};
/////////////////////////////////////////////////////////////////////////////
// CSqlProp dialog

CSqlProp::CSqlProp(CWnd* pParent /*=NULL*/)
    : CDialog(CSqlProp::IDD, pParent)
{
    //{{AFX_DATA_INIT(CSqlProp)
    m_dwMaxSize = 0;
    m_nSqlSizeRdo = -1;
    m_dwFocusControl = 0;
    //}}AFX_DATA_INIT

    m_bAutoNameSuffix = FALSE;
    m_dwMaxSizeInternal = 0;
}

void CSqlProp::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);  

    //{{AFX_DATA_MAP(CSqlProp)
    DDX_Control(pDX, IDC_SQL_DSN_COMBO, m_comboDSN);
    DDX_Control(pDX, IDC_SQL_DSN_EDIT, m_editDSN);
    DDX_Text(pDX, IDC_SQL_DSN_EDIT, m_strDSN);
    DDV_MaxChars(pDX, m_strDSN, SQL_MAX_DSN_LENGTH);
    DDX_Text(pDX, IDC_SQL_LOG_SET_EDIT, m_strLogSetName);
    DDV_MaxChars(pDX, m_strLogSetName, SLQ_MAX_LOG_SET_NAME_LEN);
    DDX_Radio(pDX, IDC_SQL_SIZE_MAX_BTN, m_nSqlSizeRdo);
    //}}AFX_DATA_MAP
    
    
    ValidateTextEdit(pDX, 
                     IDC_SQL_SIZE_LIMIT_EDIT, 
                     9, 
                     &m_dwMaxSize, 
                     (DWORD)CFilesProperty::eMinSqlRecordsLimit, 
                     (DWORD)CFilesProperty::eMaxSqlRecordsLimit);

    if ( pDX->m_bSaveAndValidate ) {
        
        if (((CButton *)GetDlgItem(IDC_SQL_SIZE_MAX_BTN))->GetCheck() == 1) {
            m_dwMaxSizeInternal = SLQ_DISK_MAX_SIZE;
        } else {
            m_dwMaxSizeInternal = m_dwMaxSize;
        }    

    }

}

BEGIN_MESSAGE_MAP(CSqlProp, CDialog)
    //{{AFX_MSG_MAP(CSqlProp)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    ON_EN_KILLFOCUS(IDC_SQL_LOG_SET_EDIT, OnKillfocusSqlLogSetEdit)
    ON_EN_CHANGE(IDC_SQL_LOG_SET_EDIT, OnChangeSqlLogSetEdit)
    ON_NOTIFY(UDN_DELTAPOS, IDC_SQL_SIZE_LIMIT_SPIN, OnDeltaposSqlSizeLimitSpin)
    ON_BN_CLICKED(IDC_SQL_SIZE_MAX_BTN, OnSqlSizeMaxBtn)
    ON_BN_CLICKED(IDC_SQL_SIZE_LIMIT_BTN, OnSqlSizeLimitBtn)
    ON_EN_CHANGE(IDC_SQL_SIZE_LIMIT_EDIT, OnChangeSqlSizeLimitEdit)
    ON_EN_KILLFOCUS(IDC_SQL_SIZE_LIMIT_EDIT, OnKillfocusSqlSizeLimitEdit)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSqlProp message handlers

BOOL CSqlProp::OnInitDialog() 
{
    BOOL bLimitBtnSet;
    BOOL bReturn = TRUE;

    // set the buttons 
    m_nSqlSizeRdo = 1;
    if (m_dwMaxSizeInternal == SLQ_DISK_MAX_SIZE) {
        m_nSqlSizeRdo = 0;
        m_dwMaxSize = 1000; // default
    } else {
        m_nSqlSizeRdo = 1;
        m_dwMaxSize = m_dwMaxSizeInternal;
    }    

    CDialog::OnInitDialog();

    ASSERT ( NULL != m_pLogQuery );

    InitDSN();

    bLimitBtnSet = (m_nSqlSizeRdo == 1);
    ((CButton *) GetDlgItem(IDC_SQL_SIZE_LIMIT_BTN))->SetCheck(bLimitBtnSet);
    ((CButton *) GetDlgItem(IDC_SQL_SIZE_MAX_BTN))->SetCheck(! bLimitBtnSet);
    GetDlgItem(IDC_SQL_SIZE_LIMIT_EDIT)->EnableWindow(bLimitBtnSet);
    GetDlgItem(IDC_SQL_SIZE_LIMIT_SPIN)->EnableWindow(bLimitBtnSet);
    GetDlgItem(IDC_SQL_SIZE_LIMIT_UNITS)->EnableWindow(bLimitBtnSet);

    if ( 0 != m_dwFocusControl ) {
        GetDlgItem ( m_dwFocusControl )->SetFocus();  
        bReturn = FALSE;
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

LPWSTR CSqlProp::InitDSN()
{
    HENV    henv;
    RETCODE retcode;
    WCHAR*  szDsnName = NULL;
    INT     iCurSel = CB_ERR;


    //
    // If this is for remote machine, we don't have a way to 
    // scan the DSN on remote machine, so let the user type in
    // the name of DSN. Otherwise, scan the DSNs on local machine 
    // and let the user to select a DSN
    //

    if (m_pLogQuery->GetLogService()->IsLocalMachine()) {
        //
        // Hide the DSN edit used for remote machine
        //
        m_editDSN.ShowWindow(SW_HIDE);
        m_comboDSN.ShowWindow(SW_SHOW);
 
        szDsnName = new WCHAR[SQL_MAX_DSN_LENGTH + 1];
        
        if( NULL != szDsnName ) {
            if ( SQL_SUCCEEDED(SQLAllocHandle(SQL_HANDLE_ENV, NULL, &henv))) {

                // set the ODBC behavior version.
                (void) SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION,
                                    (SQLPOINTER) SQL_OV_ODBC3, SQL_IS_INTEGER);

                // Enumerate the user data sources.
                m_comboDSN.ResetContent();
        
                retcode = SQLDataSources (
                                          henv,
                                          SQL_FETCH_FIRST_SYSTEM,
                                          szDsnName,
                                          SQL_MAX_DSN_LENGTH+1,
                                          NULL,
                                          NULL,
                                          0,
                                          NULL
                                          );
                while(SQL_SUCCEEDED(retcode))
                {
                    iCurSel = m_comboDSN.AddString(szDsnName);
    
                    if ( 0 == m_strDSN.CompareNoCase ( szDsnName ) ) {
                        m_comboDSN.SetCurSel(iCurSel);
                    }
    
                    // Do the next one, if it exists.
                    retcode = SQLDataSources (
                                              henv,
                                              SQL_FETCH_NEXT,
                                              szDsnName,
                                              SQL_MAX_DSN_LENGTH+1,
                                              NULL,
                                              NULL,
                                              0,
                                              NULL
                                              );        
                }

                SQLFreeHandle(SQL_HANDLE_ENV, henv);
            }
            delete [] szDsnName;
        }
    }
    else {
        m_editDSN.ShowWindow(SW_SHOW);
        m_comboDSN.ShowWindow(SW_HIDE);
    }

    return 0;
}


BOOL CSqlProp::IsValidLocalData()
{
    BOOL bIsValid = TRUE;
    INT  iPrevLength = 0;
    CString strMessage;

    ResourceStateManager    rsm;

    // assumes UpdateData has been called

    // Trim log set name before validation
    iPrevLength = m_strLogSetName.GetLength();
    m_strLogSetName.TrimLeft();
    m_strLogSetName.TrimRight();
    
    if ( iPrevLength != m_strLogSetName.GetLength() ) {
        SetDlgItemText ( IDC_SQL_LOG_SET_EDIT, m_strLogSetName );  
    }

    if (m_pLogQuery->GetLogService()->IsLocalMachine()) {
        m_comboDSN.GetLBText(m_comboDSN.GetCurSel(), m_strDSN);
    }
    else {
        iPrevLength = m_strDSN.GetLength();
        m_strDSN.TrimLeft();
        m_strDSN.TrimRight();

        if ( iPrevLength != m_strDSN.GetLength() ) {
            SetDlgItemText ( IDC_SQL_DSN_EDIT, m_strDSN );
        }
    }

    if (m_strDSN.IsEmpty()) {
        strMessage.LoadString ( IDS_SQL_ERR_NODSN );
        MessageBox ( strMessage, m_pLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
        bIsValid = FALSE;
    } else if ( !m_pLogQuery->GetLogService()->IsLocalMachine() ) {
        if (!IsValidDSN(m_strDSN)) {
            strMessage.LoadString ( IDS_ERRMSG_INVALID_DSN_NAME );
            MessageBox ( strMessage, m_pLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
            bIsValid = FALSE;
        }
    }

    if (!bIsValid) {
        if ( m_pLogQuery->GetLogService()->IsLocalMachine()) {
            m_comboDSN.SetFocus();
        } else {
            m_editDSN.SetFocus();
        }
    }

    if (bIsValid) {
        if ( m_strLogSetName.IsEmpty() ) {
            if ( !m_bAutoNameSuffix ) {
                strMessage.LoadString ( IDS_SQL_ERR_NOLOGSETNAME );
                MessageBox ( strMessage, m_pLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
                (GetDlgItem(IDC_SQL_LOG_SET_EDIT))->SetFocus();
                bIsValid = FALSE;
            }
       } else {
            if ( !FileNameIsValid ( &m_strLogSetName ) ){
                strMessage.LoadString (IDS_ERRMSG_INVALIDCHAR);
                MessageBox( strMessage, m_pLogQuery->GetLogName(), MB_OK| MB_ICONERROR );
                (GetDlgItem(IDC_SQL_LOG_SET_EDIT))->SetFocus();
                bIsValid = FALSE;
            }
        }
    }

    if (bIsValid)
    {
        if ( SLQ_DISK_MAX_SIZE != m_dwMaxSizeInternal ) {
            bIsValid = ValidateDWordInterval(IDC_SQL_SIZE_LIMIT_EDIT,
                                             m_pLogQuery->GetLogName(),
                                             m_dwMaxSizeInternal,
                                             (DWORD)CFilesProperty::eMinSqlRecordsLimit,
                                             (DWORD)CFilesProperty::eMaxSqlRecordsLimit);
        }
    }

    return bIsValid;
}

void
CSqlProp::ValidateTextEdit (
    CDataExchange*  pDX,
    int             nIDC,
    int             nMaxChars,
    DWORD*          pValue,
    DWORD           /* minValue */,
    DWORD           /* maxValue */)
{
    HWND    hWndCtrl       = pDX->PrepareEditCtrl(nIDC);
    LONG    currentValue   = INVALID_DWORD;
    TCHAR   szT[MAXSTR];
    CString strTemp;

    if ( NULL != pDX && NULL != pValue ) {
        if (pDX->m_bSaveAndValidate)
        {
            * pValue = (DWORD) currentValue;

            ::GetWindowText(hWndCtrl, szT, MAXSTR);

            strTemp = szT;
            DDV_MaxChars(pDX, strTemp, nMaxChars);

            if (szT[0] >= _T('0') && szT[0] <= _T('9'))
            {
                currentValue = _wtol(szT);
                * pValue      = (DWORD) currentValue;
            }
        } else {
            if ( INVALID_DWORD != *pValue ) {
                wsprintf(szT, _T("%lu"), *pValue);
            } else {
                szT[0] = _T('\0');
            }
            GetDlgItem(nIDC)->SetWindowText(szT);
        }
    } else {
        ASSERT ( FALSE );
    }
}

BOOL
CSqlProp::ValidateDWordInterval ( 
    int     nIDC,
    LPCWSTR strLogName,
    DWORD   dwValue,
    DWORD   minValue,
    DWORD   maxValue)
{
    CString strMsg;
    BOOL    bResult =  (dwValue >= minValue)
                    && (dwValue <= maxValue);

    if (! bResult)
    {
        strMsg.Format ( IDS_ERRMSG_INVALIDDWORD, minValue, maxValue );
        MessageBox(strMsg, strLogName, MB_OK  | MB_ICONERROR);
        GetDlgItem(nIDC)->SetFocus();
        strMsg.Empty();
    }
    return (bResult);
}

CString 
CSqlProp::ComposeSQLLogName()
{
    CString     strDSNName;
    CString     strSQLLogName;
    
    m_comboDSN.GetLBText(m_comboDSN.GetCurSel(),m_strDSN.GetBuffer(m_comboDSN.GetLBTextLen(m_comboDSN.GetCurSel())));
    
    strSQLLogName.Format(L"SQL:%s!%s",m_strDSN,m_strLogSetName);

    m_strDSN.ReleaseBuffer();
    
    return strSQLLogName;

}

void CSqlProp::OnOK() 
{
    // load data from dialog        
    if ( UpdateData (TRUE) ) {
        if ( IsValidLocalData() ) {
            m_SqlFormattedLogName = ComposeSQLLogName();
            CDialog::OnOK();
        }
    }
}

void CSqlProp::OnKillfocusSqlLogSetEdit() 
{
    UpdateData( TRUE );
}

void CSqlProp::OnChangeSqlLogSetEdit() 
{
    UpdateData( TRUE );
}

void CSqlProp::OnSqlSizeLimitBtn() 
{
    FileSizeBtn(FALSE);    
}

void CSqlProp::OnChangeSqlSizeLimitEdit()
{
    UpdateData( TRUE );
}

void CSqlProp::OnKillfocusSqlSizeLimitEdit() 
{
    UpdateData ( TRUE );
}

void CSqlProp::OnDeltaposSqlSizeLimitSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
    OnDeltaposSpin( 
        pNMHDR, 
        pResult, 
        &m_dwMaxSize, 
        (DWORD)CFilesProperty::eMinSqlRecordsLimit, 
        (DWORD)CFilesProperty::eMaxSqlRecordsLimit);
}

void CSqlProp::OnSqlSizeMaxBtn() 
{
    FileSizeBtn(FALSE);
}

void CSqlProp::FileSizeBtnEnable()
{
    GetDlgItem(IDC_SQL_SIZE_MAX_BTN)->EnableWindow ( TRUE );
}

void CSqlProp::FileSizeBtn(BOOL bInit)
{
    INT     m_nRecordSizeOld;
    
    m_nRecordSizeOld = m_nSqlSizeRdo;

    UpdateData ( TRUE );
    
    if (bInit || (m_nRecordSizeOld != m_nSqlSizeRdo)) {
        BOOL    bMaxBtnSet, bLimitBtnSet;
        
        // *** This can be replaced since DDX_Radio implemented.
        // get btn state    
        bMaxBtnSet = ((CButton *)GetDlgItem(IDC_SQL_SIZE_MAX_BTN))->GetCheck() == 1;
        bLimitBtnSet = ((CButton *)GetDlgItem(IDC_SQL_SIZE_LIMIT_BTN))->GetCheck() == 1;
    
        ASSERT (bLimitBtnSet != bMaxBtnSet);

        GetDlgItem(IDC_SQL_SIZE_LIMIT_EDIT)->EnableWindow(bLimitBtnSet);
        GetDlgItem(IDC_SQL_SIZE_LIMIT_SPIN)->EnableWindow(bLimitBtnSet);
        GetDlgItem(IDC_SQL_SIZE_LIMIT_UNITS)->EnableWindow(bLimitBtnSet);
    }
}

void 
CSqlProp::OnDeltaposSpin(
    NMHDR   *pNMHDR, 
    LRESULT *pResult, 
    DWORD   *pValue, 
    DWORD   dMinValue, 
    DWORD   dMaxValue)
{
    NM_UPDOWN* pNMUpDown;
    LONG       lValue;
    BOOL       bResult   = TRUE;

    UpdateData(TRUE);

    ASSERT(dMinValue <= dMaxValue);

    if ( NULL != pNMHDR
        && NULL != pResult
        && NULL != pValue ) 
    {
        pNMUpDown = (NM_UPDOWN *) pNMHDR;
        lValue    = (LONG) (*pValue);

        if (lValue == INVALID_DWORD) {
            lValue = (DWORD) dMinValue;
        } else {

            if ( ((lValue >= (LONG) dMinValue + 1) && (pNMUpDown->iDelta > 0))
                || ((lValue <= (LONG) dMaxValue - 1) && (pNMUpDown->iDelta < 0)))
            {
                lValue += (pNMUpDown->iDelta * -1);

                if (lValue > (LONG) dMaxValue) {
                    lValue = (DWORD) dMaxValue;
                } else if (lValue < (LONG) dMinValue) {
                    lValue = (DWORD) dMinValue;
                }
            } else if (lValue > (LONG) dMaxValue) {        
                lValue = (DWORD) dMaxValue;
            } else if (lValue < (LONG) dMinValue) {
                lValue = (DWORD) dMinValue;
            } else {
                bResult = FALSE;
            }
        }

        if (bResult) {
            *pValue = lValue;
            UpdateData(FALSE);
        }
        *pResult = 0;
    } else {
        ASSERT ( FALSE );
    }

    return;
}

BOOL
CSqlProp::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if ( pHelpInfo->iCtrlId >= IDC_SQL_FIRST_HELP_CTRL_ID ||
        pHelpInfo->iCtrlId == IDOK ||
        pHelpInfo->iCtrlId == IDCANCEL ) {

        InvokeWinHelp(WM_HELP,
                      NULL,
                      (LPARAM) pHelpInfo,
                      m_strHelpFilePath,
                      s_aulHelpIds);
    }
    return TRUE;
}

void 
CSqlProp::OnContextMenu(CWnd* pWnd, CPoint /* point */) 
{
    InvokeWinHelp(WM_CONTEXTMENU, (WPARAM)(pWnd->m_hWnd), NULL, m_strHelpFilePath, s_aulHelpIds);

    return;
}

DWORD
CSqlProp::SetContextHelpFilePath(const CString& rstrPath)
{
    DWORD dwStatus = ERROR_SUCCESS;

    MFC_TRY
        m_strHelpFilePath = rstrPath;
    MFC_CATCH_DWSTATUS

    return dwStatus;
}


BOOL 
CSqlProp::IsValidDSN(CString& strDSN)
{
    int Length;

    Length = strDSN.GetLength();
   
    for (int i = 0; i < Length; i++) {
        if (strDSN[i] == _T('?')  ||
            strDSN[i] == _T('\\') ||
            strDSN[i] == _T('*')  ||
            strDSN[i] == _T('=')  ||
            strDSN[i] == _T('[')  ||
            strDSN[i] == _T(']')  ||
            strDSN[i] == _T('{')  ||
            strDSN[i] == _T('}')  ||
            strDSN[i] == _T('(')  ||
            strDSN[i] == _T(')')  ||
            strDSN[i] == _T(',')  ||
            strDSN[i] == _T(';')  ||
            strDSN[i] == _T('!')  ||
            strDSN[i] == _T('@') 
            )
        {
            return FALSE;
        }
    }

    if (i == 0) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\sqlprop.h ===
#if !defined(AFX_SQLPROP_H__INCLUDED_)
#define AFX_SQLPROP_H__INCLUDED_



#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SqlProp.h : header file
//

#define IDD_SQL_PROP                    2100

#define IDC_SQL_FIRST_HELP_CTRL_ID      2101
#define IDC_SQL_DSN_COMBO               2102
#define IDC_SQL_LOG_SET_EDIT            2103
#define IDC_SQL_SIZE_MAX_BTN            2104
#define IDC_SQL_SIZE_LIMIT_EDIT         2105
#define IDC_SQL_SIZE_LIMIT_BTN          2106
#define IDC_SQL_SIZE_LIMIT_SPIN         2107
#define IDC_SQL_SIZE_LIMIT_UNITS        2108
#define IDC_SQL_DSN_EDIT                2109


/////////////////////////////////////////////////////////////////////////////
// CSqlProp dialog

class CSqlProp : public CDialog
{
public:
    // Construction
            CSqlProp(CWnd* pParent = NULL);   // standard constructor
    virtual ~CSqlProp(){};  

    DWORD SetContextHelpFilePath(const CString & rstrPath);

    //{{AFX_DATA(CSqlProp)
    enum { IDD = IDD_SQL_PROP };
    CComboBox  m_comboDSN;
    CEdit      m_editDSN;
    CString    m_strDSN;
    CString    m_strLogSetName;
    DWORD      m_dwSerialNumber;
    DWORD      m_dwMaxSize;
    int        m_nSqlSizeRdo;
    //}}AFX_DATA

    UINT    m_dwMaxSizeInternal;
    CString m_SqlFormattedLogName;
    BOOL    m_bAutoNameSuffix;

    DWORD   m_dwLogFileTypeValue;
    HINSTANCE m_hModule;
    DWORD   m_dwFocusControl;
    CSmLogQuery* m_pLogQuery;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSqlProp)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL
// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CSqlProp)
    virtual void OnOK();
    afx_msg void OnKillfocusSqlLogSetEdit();
    afx_msg void OnChangeSqlLogSetEdit();
    afx_msg void OnChangeSqlSizeLimitEdit();
    afx_msg void OnDeltaposSqlSizeLimitSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSqlSizeMaxBtn();
    afx_msg void OnSqlSizeLimitBtn();
    afx_msg void OnKillfocusSqlSizeLimitEdit();
    afx_msg BOOL OnHelpInfo(HELPINFO *);
    afx_msg void OnContextMenu( CWnd*, CPoint );
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:

    BOOL IsValidLocalData();
    void FileSizeBtn(BOOL bInit);
    void FileSizeBtnEnable();
    void OnDeltaposSpin(NMHDR *pNMHDR, LRESULT *pResult, DWORD *pValue, DWORD dMinValue, DWORD dMaxValue);
    
    LPWSTR  InitDSN();
    CString ComposeSQLLogName();
        
    void    ValidateTextEdit(CDataExchange * pDX,
                             int             nIDC,
                             int             nMaxChars,
                             DWORD         * value,
                             DWORD           minValue,
                             DWORD           maxValue);
    
    BOOL    ValidateDWordInterval(int     nIDC,
                                  LPCWSTR strLogName,
                                  DWORD   dwValue,
                                  DWORD   minValue,
                                  DWORD   maxValue);

    BOOL    IsValidDSN(CString& strDSN);
    CString m_strHelpFilePath;
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SQLPROP_H__BADE97DF_A969_435A_A348_C9A18F9CE035__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\stdafx.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    StdAfx.h

Abstract:

    Include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently


--*/

#if !defined(AFX_STDAFX_H__698CEE8C_5F56_11D1_97BB_00C04FB9DA75__INCLUDED_)
#define AFX_STDAFX_H__698CEE8C_5F56_11D1_97BB_00C04FB9DA75__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>
#include <afxtempl.h>
#include <afxdlgs.h>
#include <afxcmn.h>

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#if __RPCNDR_H_VERSION__ < 440             // This may be needed when building
#define __RPCNDR_H_VERSION__ 440           // on NT5 (1671) to prevent MIDL errors
#define MIDL_INTERFACE(x) interface
#endif

#include <stdio.h>
#include <commctrl.h>       // Needed for button styles...
#include <mmc.h>
#include "smlogres.h"       // Resources other than dialogs
#include "globals.h"
#include "common.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__698CEE8C_5F56_11D1_97BB_00C04FB9DA75__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\stdafx.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    StdAfx.cpp

Abstract:

    stdafx.cpp : source file that includes just the standard includes
    stdafx.pch will be the pre-compiled header
    stdafx.obj will contain the pre-compiled type information

--*/

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\strnoloc.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Global resource strings which should not be localized

--*/

#include <windows.h>

class CGlobalString {
public:
    CGlobalString() {};
    ~CGlobalString() {};

//    static const    WCHAR   m_chBackslash;

    static          LPCWSTR m_cszDefaultsInstalled;

    static          LPCWSTR m_cszConceptsHTMLHelpFileName;
    static          LPCWSTR m_cszSnapinHTMLHelpFileName;
    static          LPCWSTR m_cszHTMLHelpTopic;
    static          LPCWSTR m_cszContextHelpFileName;

    static          LPCWSTR m_cszDefaultCtrLogCpuPath;
    static          LPCWSTR m_cszDefaultCtrLogMemoryPath;
    static          LPCWSTR m_cszDefaultCtrLogDiskPath;

    static          LPCWSTR m_cszRegComment;
    static          LPCWSTR m_cszRegCommentIndirect;
    static          LPCWSTR m_cszRegLogType;
    static          LPCWSTR m_cszRegCurrentState;
    static          LPCWSTR m_cszRegLogFileMaxSize;
    static          LPCWSTR m_cszRegLogFileBaseName;
    static          LPCWSTR m_cszRegLogFileBaseNameInd;
    static          LPCWSTR m_cszRegLogFileFolder;
    static          LPCWSTR m_cszRegLogFileSerialNumber;
    static          LPCWSTR m_cszRegLogFileAutoFormat;
    static          LPCWSTR m_cszRegLogFileType;
    static          LPCWSTR m_cszRegStartTime;
    static          LPCWSTR m_cszRegStopTime;
    static          LPCWSTR m_cszRegRestart;
    static          LPCWSTR m_cszRegLastModified;
    static          LPCWSTR m_cszRegCounterList;
    static          LPCWSTR m_cszRegSampleInterval;
    static          LPCWSTR m_cszRegEofCommandFile;
    static          LPCWSTR m_cszRegCollectionName;
    static          LPCWSTR m_cszRegCollectionNameInd;
    static          LPCWSTR m_cszRegDataStoreAttributes;
    static          LPCWSTR m_cszRegRealTimeDataSource;
    static          LPCWSTR m_cszRegSqlLogBaseName;

    static          LPCWSTR m_cszRegCommandFile;
    static          LPCWSTR m_cszRegNetworkName;
    static          LPCWSTR m_cszRegUserText;
    static          LPCWSTR m_cszRegUserTextIndirect;
    static          LPCWSTR m_cszRegPerfLogName;
    static          LPCWSTR m_cszRegActionFlags;
    static          LPCWSTR m_cszRegTraceBufferSize;
    static          LPCWSTR m_cszRegTraceBufferMinCount;
    static          LPCWSTR m_cszRegTraceBufferMaxCount;
    static          LPCWSTR m_cszRegTraceBufferFlushInterval;
    static          LPCWSTR m_cszRegTraceFlags;
    static          LPCWSTR m_cszRegTraceProviderList;
    static          LPCWSTR m_cszRegTraceProviderCount;
    static          LPCWSTR m_cszRegTraceProviderGuid;
    static          LPCWSTR m_cszRegAlertThreshold;
    static          LPCWSTR m_cszRegAlertOverUnder;
    static          LPCWSTR m_cszRegDefaultLogFileFolder;
    static          LPCWSTR m_cszRegExecuteOnly;

    static          LPCWSTR m_cszHtmlComment ;
    static          LPCWSTR m_cszHtmlLogType ;
    static          LPCWSTR m_cszHtmlCurrentState ;
    static          LPCWSTR m_cszHtmlLogFileMaxSize ;
    static          LPCWSTR m_cszHtmlLogFileBaseName ;
    static          LPCWSTR m_cszHtmlLogFileFolder ;
    static          LPCWSTR m_cszHtmlLogFileSerialNumber;
    static          LPCWSTR m_cszHtmlLogFileAutoFormat;
    static          LPCWSTR m_cszHtmlLogFileType;
    static          LPCWSTR m_cszHtmlEOFCommandFile;
    static          LPCWSTR m_cszHtmlCommandFile;
    static          LPCWSTR m_cszHtmlNetworkName;
    static          LPCWSTR m_cszHtmlUserText;
    static          LPCWSTR m_cszHtmlPerfLogName; 
    static          LPCWSTR m_cszHtmlActionFlags; 
    static          LPCWSTR m_cszHtmlTraceBufferSize; 
    static          LPCWSTR m_cszHtmlTraceBufferMinCount; 
    static          LPCWSTR m_cszHtmlTraceBufferMaxCount; 
    static          LPCWSTR m_cszHtmlTraceBufferFlushInterval; 
    static          LPCWSTR m_cszHtmlTraceFlags; 
    static          LPCWSTR m_cszHtmlLogFileName; 
    static          LPCWSTR m_cszHtmlCounterCount; 
    static          LPCWSTR m_cszHtmlSampleCount; 
    static          LPCWSTR m_cszHtmlUpdateInterval; 
    static          LPCWSTR m_cszHtmlCounterPath; 
    static          LPCWSTR m_cszHtmlRestartMode; 
    static          LPCWSTR m_cszHtmlSampleIntervalUnitType; 
    static          LPCWSTR m_cszHtmlSampleIntervalValue;      
    static          LPCWSTR m_cszHtmlStartMode;   
    static          LPCWSTR m_cszHtmlStartAtTime;  
    static          LPCWSTR m_cszHtmlStopMode;   
    static          LPCWSTR m_cszHtmlStopAtTime;   
    static          LPCWSTR m_cszHtmlStopAfterUnitType;   
    static          LPCWSTR m_cszHtmlStopAfterValue;       
    static          LPCWSTR m_cszHtmlCounterAlertThreshold; 
    static          LPCWSTR m_cszHtmlCounterAlertOverUnder; 
    static          LPCWSTR m_cszHtmlTraceProviderCount; 
    static          LPCWSTR m_cszHtmlTraceProviderGuid; 
    static          LPCWSTR m_cszHtmlLogName;                   
    static          LPCWSTR m_cszHtmlAlertName; 
    static          LPCWSTR m_cszHtml_Version; 
    static          LPCWSTR m_cszHtmlDataStoreAttributes; 
    static          LPCWSTR m_cszHtmlRealTimeDataSource; 
    static          LPCWSTR m_cszHtmlSqlLogBaseName; 

    static          LPCWSTR m_cszHtmlObjectClassId;
    static          LPCWSTR m_cszHtmlObjectHeader;
    static          LPCWSTR m_cszHtmlObjectFooter;
    static          LPCWSTR m_cszHtmlParamTag;	
    static          LPCWSTR m_cszHtmlValueTag;	
    static          LPCWSTR m_cszHtmlValueEolTag;

    static          LPCWSTR m_cszHtmlFileHeader1;   
    static          LPCWSTR m_cszHtmlFileHeader2;   
    static          LPCWSTR m_cszHtmlFileFooter;    
    static          LPCWSTR m_cszHtmlParamSearchTag;
    static          LPCWSTR m_cszHtmlValueSearchTag;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\tracprop.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    tracprop.cpp

Abstract:

    Implementation of the advanced trace buffer property page.

--*/

#include "stdafx.h"
#include <pdh.h>        // for MIN_TIME_VALUE, MAX_TIME_VALUE
#include "smcfgmsg.h"
#include "smlogs.h"
#include "smtraceq.h"
#include "tracprop.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static ULONG
s_aulHelpIds[] =
{
    IDC_TRACE_BUF_FLUSH_CHECK,  IDH_TRACE_BUF_FLUSH_CHECK,
    IDC_TRACE_BUFFER_SIZE_EDIT, IDH_TRACE_BUFFER_SIZE_EDIT,
    IDC_TRACE_BUFFER_SIZE_SPIN, IDH_TRACE_BUFFER_SIZE_EDIT,
    IDC_TRACE_MIN_BUF_EDIT,     IDH_TRACE_MIN_BUF_EDIT,
    IDC_TRACE_MIN_BUF_SPIN,     IDH_TRACE_MIN_BUF_EDIT,
    IDC_TRACE_MAX_BUF_EDIT,     IDH_TRACE_MAX_BUF_EDIT,
    IDC_TRACE_MAX_BUF_SPIN,     IDH_TRACE_MAX_BUF_EDIT,
    IDC_TRACE_FLUSH_INT_EDIT,   IDH_TRACE_FLUSH_INT_EDIT,
    IDC_TRACE_FLUSH_INT_SPIN,   IDH_TRACE_FLUSH_INT_EDIT,
    0,0
};



/////////////////////////////////////////////////////////////////////////////
// CTraceProperty property page

IMPLEMENT_DYNCREATE(CTraceProperty, CSmPropertyPage)

CTraceProperty::CTraceProperty(MMC_COOKIE   lCookie, LONG_PTR hConsole) 
:   CSmPropertyPage ( CTraceProperty::IDD, hConsole )
{
    // save pointers from arg list
    m_pTraceLogQuery = reinterpret_cast <CSmTraceLogQuery *>(lCookie);
    ASSERT ( m_pTraceLogQuery->CastToTraceLogQuery() );
    m_pQuery = dynamic_cast <CSmLogQuery*>(m_pTraceLogQuery);


//  EnableAutomation();
    //{{AFX_DATA_INIT(CTraceProperty)
    m_dwBufferSize = 0;
    m_dwFlushInterval = 0;
    m_dwMaxBufCount = 0;
    m_dwMinBufCount = 0;
    m_bEnableBufferFlush = FALSE;
    //}}AFX_DATA_INIT
}

CTraceProperty::CTraceProperty() : CSmPropertyPage(CTraceProperty::IDD)
{
    ASSERT (FALSE); // only the constructor w/args should be called

    EnableAutomation();
//  //{{AFX_DATA_INIT(CTraceProperty)
    m_dwBufferSize = 0;
    m_dwFlushInterval = 0;
    m_dwMaxBufCount = 0;
    m_dwMinBufCount = 0;
    m_bEnableBufferFlush = FALSE;
//  //}}AFX_DATA_INIT
}

CTraceProperty::~CTraceProperty()
{
}

void CTraceProperty::OnFinalRelease()
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CPropertyPage::OnFinalRelease();
}

void CTraceProperty::DoDataExchange(CDataExchange* pDX)
{
    CString strTemp;
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CTraceProperty)
    ValidateTextEdit(pDX, IDC_TRACE_BUFFER_SIZE_EDIT, 4, & m_dwBufferSize, eMinBufSize, eMaxBufSize);
    ValidateTextEdit(pDX, IDC_TRACE_FLUSH_INT_EDIT, 3, & m_dwFlushInterval, eMinFlushInt, eMaxFlushInt);
    ValidateTextEdit(pDX, IDC_TRACE_MAX_BUF_EDIT, 3, & m_dwMaxBufCount, eMinBufCount, eMaxBufCount);
    ValidateTextEdit(pDX, IDC_TRACE_MIN_BUF_EDIT, 3, & m_dwMinBufCount, eMinBufCount, eMaxBufCount);
    DDX_Check(pDX, IDC_TRACE_BUF_FLUSH_CHECK, m_bEnableBufferFlush);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTraceProperty, CSmPropertyPage)
    //{{AFX_MSG_MAP(CTraceProperty)
    ON_WM_DESTROY()
    ON_BN_CLICKED(IDC_TRACE_BUF_FLUSH_CHECK, OnTraceBufFlushCheck)
    ON_EN_CHANGE(IDC_TRACE_BUFFER_SIZE_EDIT, OnChangeTraceBufferSizeEdit)
    ON_EN_KILLFOCUS(IDC_TRACE_BUFFER_SIZE_EDIT, OnKillfocusTraceBufferSizeEdit)
    ON_NOTIFY(UDN_DELTAPOS, IDC_TRACE_BUFFER_SIZE_SPIN, OnDeltaposTraceBufferSizeSpin)
    ON_EN_CHANGE(IDC_TRACE_FLUSH_INT_EDIT, OnChangeTraceFlushIntEdit)
    ON_EN_KILLFOCUS(IDC_TRACE_FLUSH_INT_EDIT, OnKillfocusTraceFlushIntEdit)
    ON_NOTIFY(UDN_DELTAPOS, IDC_TRACE_FLUSH_INT_SPIN, OnDeltaposTraceFlushIntSpin)
    ON_EN_CHANGE(IDC_TRACE_MAX_BUF_EDIT, OnChangeTraceMaxBufEdit)
    ON_EN_KILLFOCUS(IDC_TRACE_MAX_BUF_EDIT, OnKillfocusTraceMaxBufEdit)
    ON_NOTIFY(UDN_DELTAPOS, IDC_TRACE_MAX_BUF_SPIN, OnDeltaposTraceMaxBufSpin)
    ON_EN_CHANGE(IDC_TRACE_MIN_BUF_EDIT, OnChangeTraceMinBufEdit)
    ON_EN_KILLFOCUS(IDC_TRACE_MIN_BUF_EDIT, OnKillfocusTraceMinBufEdit)
    ON_NOTIFY(UDN_DELTAPOS, IDC_TRACE_MIN_BUF_SPIN, OnDeltaposTraceMinBufSpin)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CTraceProperty, CSmPropertyPage)
    //{{AFX_DISPATCH_MAP(CTraceProperty)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_ITraceProperty to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {65154EAF-BDBE-11D1-BF99-00C04F94A83A}
static const IID IID_ITraceProperty =
{ 0x65154eaf, 0xbdbe, 0x11d1, { 0xbf, 0x99, 0x0, 0xc0, 0x4f, 0x94, 0xa8, 0x3a } };

BEGIN_INTERFACE_MAP(CTraceProperty, CSmPropertyPage)
    INTERFACE_PART(CTraceProperty, IID_ITraceProperty, Dispatch)
END_INTERFACE_MAP()

BOOL    
CTraceProperty::SetFlushIntervalMode()
{
    BOOL    bShow;
    bShow = ((CButton *)(GetDlgItem(IDC_TRACE_BUF_FLUSH_CHECK)))->GetCheck();
    GetDlgItem(IDC_TRACE_FLUSH_INT_EDIT)->EnableWindow(bShow);
    GetDlgItem(IDC_TRACE_FLUSH_INT_SPIN)->EnableWindow(bShow);
    GetDlgItem(IDC_TRACE_INTERVAL_SECONDS_CAPTION)->EnableWindow(bShow);

    return TRUE;
}

BOOL
CTraceProperty::IsValidLocalData ()
{
    BOOL bIsValid = TRUE;

    if (bIsValid)
    {
        bIsValid = ValidateDWordInterval(IDC_TRACE_BUFFER_SIZE_EDIT,
                                         m_pTraceLogQuery->GetLogName(),
                                         (long) m_dwBufferSize,
                                         eMinBufSize,
                                         eMaxBufSize);
    }
    if (bIsValid && m_bEnableBufferFlush)
    {
        bIsValid = ValidateDWordInterval(IDC_TRACE_FLUSH_INT_EDIT,
                                         m_pTraceLogQuery->GetLogName(),
                                         (long) m_dwFlushInterval,
                                         eMinFlushInt,
                                         eMaxFlushInt);
    }
    if (bIsValid)
    {
        bIsValid = ValidateDWordInterval(IDC_TRACE_MIN_BUF_EDIT,
                                         m_pTraceLogQuery->GetLogName(),
                                         (long) m_dwMinBufCount,
                                         eMinBufCount,
                                         eMaxBufCount);
    }
    if (bIsValid)
    {
        bIsValid = ValidateDWordInterval(IDC_TRACE_MAX_BUF_EDIT,
                                         m_pTraceLogQuery->GetLogName(),
                                         (long) m_dwMaxBufCount,
                                         eMinBufCount,
                                         eMaxBufCount);
    }

    // Extra data validation
    if (bIsValid && m_dwMaxBufCount < m_dwMinBufCount) {
        CString csMessage;

        csMessage.LoadString ( IDS_TRACE_MAX_BUFF );

        MessageBox ( csMessage, m_pTraceLogQuery->GetLogName(), MB_OK  | MB_ICONERROR);
        
        SetFocusAnyPage ( IDC_TRACE_MAX_BUF_EDIT );

        bIsValid = FALSE;

    }

    return bIsValid;
}


BOOL
CTraceProperty::SaveDataToModel ( )
{
    SLQ_TRACE_LOG_INFO  stlInfo;
    BOOL bContinue = TRUE;

    ResourceStateManager    rsm;

    // Write the data to the query.
    if ( bContinue ) {   
        memset (&stlInfo, 0, sizeof(stlInfo));
        stlInfo.dwBufferSize = m_dwBufferSize;
        stlInfo.dwMinimumBuffers = m_dwMinBufCount;
        stlInfo.dwMaximumBuffers = m_dwMaxBufCount;
        stlInfo.dwBufferFlushInterval = m_dwFlushInterval;
        if ( m_bEnableBufferFlush )
            stlInfo.dwBufferFlags |= SLQ_TLI_ENABLE_BUFFER_FLUSH;

        m_pTraceLogQuery->SetTraceLogInfo ( &stlInfo );

        if ( bContinue ) {
            // ApplyRunAs must be called before UpdateService
            bContinue = ApplyRunAs( m_pTraceLogQuery ); 
        }

        // Save property page shared data.
        m_pTraceLogQuery->UpdatePropPageSharedData();

        bContinue = UpdateService ( m_pTraceLogQuery, TRUE );
    }

    return bContinue;
}

/////////////////////////////////////////////////////////////////////////////
// CTraceProperty message handlers

BOOL 
CTraceProperty::OnSetActive()
{
    BOOL        bReturn;

    bReturn = CSmPropertyPage::OnSetActive();

    if (bReturn) {
        m_pTraceLogQuery->GetPropPageSharedData ( &m_SharedData );
    }
    
    return bReturn;
}

BOOL 
CTraceProperty::OnKillActive() 
{
    BOOL bContinue = TRUE;
        
    bContinue = CPropertyPage::OnKillActive();

    if ( bContinue ) {
        bContinue = IsValidData(m_pTraceLogQuery, VALIDATE_FOCUS );
    }

    // The trace advanced page does not modify shared data, so no reason to update it.

    if ( bContinue ) {
        SetIsActive ( FALSE );
    }
    return bContinue;
}

void 
CTraceProperty::OnCancel() 
{
    m_pTraceLogQuery->SyncPropPageSharedData(); // Clear the memory shared between property pages.
}

BOOL 
CTraceProperty::OnApply() 
{
    BOOL bContinue = TRUE;

    bContinue = UpdateData(TRUE);

    if ( bContinue ) {
        bContinue = IsValidData( m_pTraceLogQuery, VALIDATE_APPLY );
    }

    if ( bContinue ) {
        bContinue = SaveDataToModel();
    }

    if ( bContinue )
        bContinue = CSmPropertyPage::OnApply();

    return bContinue;
}

BOOL CTraceProperty::OnInitDialog() 
{
    SLQ_TRACE_LOG_INFO  tlInfo;
    ResourceStateManager rsm;

    memset(&tlInfo, 0, sizeof(tlInfo));
    m_pTraceLogQuery->GetTraceLogInfo (&tlInfo);

    m_dwBufferSize = tlInfo.dwBufferSize;
    m_dwFlushInterval = tlInfo.dwBufferFlushInterval;
    m_dwMaxBufCount = tlInfo.dwMaximumBuffers;
    m_dwMinBufCount = tlInfo.dwMinimumBuffers;

    m_bEnableBufferFlush = (BOOL)((tlInfo.dwBufferFlags & SLQ_TLI_ENABLE_BUFFER_FLUSH) != 0);

    CSmPropertyPage::OnInitDialog();
    SetHelpIds ( (DWORD*)&s_aulHelpIds );

    SetFlushIntervalMode();
        
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CTraceProperty::OnTraceBufFlushCheck() 
{
    UpdateData( TRUE);
    SetFlushIntervalMode();
    SetModifiedPage(TRUE);  
}

void CTraceProperty::OnChangeTraceBufferSizeEdit() 
{
    DWORD dwOldValue;
    dwOldValue = m_dwBufferSize;
    UpdateData ( TRUE );
    if (dwOldValue != m_dwBufferSize) {
        SetModifiedPage(TRUE);
    }
}

void CTraceProperty::OnKillfocusTraceBufferSizeEdit() 
{
    DWORD dwOldValue;
    dwOldValue = m_dwBufferSize;
    UpdateData ( TRUE );
    if (dwOldValue != m_dwBufferSize) {
        SetModifiedPage(TRUE);
    }
}

void CTraceProperty::OnDeltaposTraceBufferSizeSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
    OnDeltaposSpin(pNMHDR, pResult, & m_dwBufferSize, eMinBufSize, eMaxBufSize);
}

void CTraceProperty::OnChangeTraceFlushIntEdit() 
{
    DWORD dwOldValue;
    dwOldValue = m_dwFlushInterval;
    UpdateData ( TRUE );
    if (dwOldValue != m_dwFlushInterval) {
        SetModifiedPage(TRUE);
    }
}

void CTraceProperty::OnKillfocusTraceFlushIntEdit() 
{
    DWORD dwOldValue;
    dwOldValue = m_dwFlushInterval;
    UpdateData ( TRUE );
    if (dwOldValue != m_dwFlushInterval) {
        SetModifiedPage(TRUE);
    }
}

void CTraceProperty::OnDeltaposTraceFlushIntSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
    OnDeltaposSpin(pNMHDR, pResult, & m_dwFlushInterval, eMinFlushInt, eMaxFlushInt);
}

void CTraceProperty::OnChangeTraceMaxBufEdit() 
{
    DWORD dwOldValue;
    dwOldValue = m_dwMaxBufCount;
    UpdateData ( TRUE );
    if (dwOldValue != m_dwMaxBufCount) {
        SetModifiedPage(TRUE);
    }
}

void CTraceProperty::OnKillfocusTraceMaxBufEdit() 
{
    DWORD dwOldValue;
    dwOldValue = m_dwMaxBufCount;
    UpdateData ( TRUE );
    if (dwOldValue != m_dwMaxBufCount) {
        SetModifiedPage(TRUE);
    }
}

void CTraceProperty::OnDeltaposTraceMaxBufSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
    OnDeltaposSpin(pNMHDR, pResult, & m_dwMaxBufCount, eMinBufCount, eMaxBufCount);
}

void CTraceProperty::OnChangeTraceMinBufEdit() 
{
    DWORD dwOldValue;
    dwOldValue = m_dwMinBufCount;
    UpdateData ( TRUE );
    if (dwOldValue != m_dwMinBufCount) {
        SetModifiedPage(TRUE);
    }
}

void CTraceProperty::OnKillfocusTraceMinBufEdit() 
{
    DWORD dwOldValue;
    dwOldValue = m_dwMinBufCount;
    UpdateData ( TRUE );
    if (dwOldValue != m_dwMinBufCount) {
        SetModifiedPage(TRUE);
    }
}

void CTraceProperty::OnDeltaposTraceMinBufSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
    OnDeltaposSpin(pNMHDR, pResult, & m_dwMinBufCount, eMinBufCount, eMaxBufCount);
}

void CTraceProperty::PostNcDestroy() 
{
//  delete this;      
    
    CPropertyPage::PostNcDestroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\strnoloc.cpp ===
#include "stdafx.h"
#include "strnoloc.h"

//const WCHAR CGlobalString::m_chBackslash    = L'\\';

LPCWSTR CGlobalString::m_cszDefaultsInstalled = L"Defaults Installed";

LPCWSTR CGlobalString::m_cszConceptsHTMLHelpFileName = L"\\help\\smlogcfg.chm";
LPCWSTR CGlobalString::m_cszSnapinHTMLHelpFileName = L"\\help\\smlogcfg.chm";
LPCWSTR CGlobalString::m_cszHTMLHelpTopic = L"nt_smlogcfg_topnode.htm";
LPCWSTR CGlobalString::m_cszContextHelpFileName = L"\\help\\sysmon.hlp";

LPCWSTR CGlobalString::m_cszDefaultCtrLogCpuPath = L"\\Processor(_Total)\\% Processor Time";
LPCWSTR CGlobalString::m_cszDefaultCtrLogMemoryPath = L"\\Memory\\Pages/sec";
LPCWSTR CGlobalString::m_cszDefaultCtrLogDiskPath = L"\\PhysicalDisk(_Total)\\Avg. Disk Queue Length";


LPCWSTR CGlobalString::m_cszRegComment              = L"Comment";
LPCWSTR CGlobalString::m_cszRegCommentIndirect      = L"Comment Indirect";
LPCWSTR CGlobalString::m_cszRegLogType              = L"Log Type";
LPCWSTR CGlobalString::m_cszRegCurrentState         = L"Current State";
LPCWSTR CGlobalString::m_cszRegLogFileMaxSize       = L"Log File Max Size";
LPCWSTR CGlobalString::m_cszRegLogFileBaseName      = L"Log File Base Name";
LPCWSTR CGlobalString::m_cszRegLogFileBaseNameInd   = L"Log File Base Name Indirect";
LPCWSTR CGlobalString::m_cszRegLogFileFolder        = L"Log File Folder";
LPCWSTR CGlobalString::m_cszRegLogFileSerialNumber  = L"Log File Serial Number";
LPCWSTR CGlobalString::m_cszRegLogFileAutoFormat    = L"Log File Auto Format";
LPCWSTR CGlobalString::m_cszRegLogFileType          = L"Log File Type";
LPCWSTR CGlobalString::m_cszRegStartTime            = L"Start";
LPCWSTR CGlobalString::m_cszRegStopTime             = L"Stop";
LPCWSTR CGlobalString::m_cszRegRestart              = L"Restart";
LPCWSTR CGlobalString::m_cszRegLastModified         = L"Last Modified";
LPCWSTR CGlobalString::m_cszRegCounterList          = L"Counter List";
LPCWSTR CGlobalString::m_cszRegSampleInterval       = L"Sample Interval";
LPCWSTR CGlobalString::m_cszRegEofCommandFile       = L"EOF Command File";
LPCWSTR CGlobalString::m_cszRegCollectionName       = L"Collection Name";
LPCWSTR CGlobalString::m_cszRegDataStoreAttributes  = L"Data Store Attributes";
LPCWSTR CGlobalString::m_cszRegRealTimeDataSource   = L"RealTime DataSource";
LPCWSTR CGlobalString::m_cszRegSqlLogBaseName       = L"Sql Log Base Name";

LPCWSTR CGlobalString::m_cszRegCommandFile          = L"Command File";
LPCWSTR CGlobalString::m_cszRegNetworkName          = L"Network Name";
LPCWSTR CGlobalString::m_cszRegUserText             = L"User Text";
LPCWSTR CGlobalString::m_cszRegUserTextIndirect     = L"User Text Indirect";
LPCWSTR CGlobalString::m_cszRegPerfLogName          = L"Perf Log Name";
LPCWSTR CGlobalString::m_cszRegActionFlags          = L"Action Flags";
LPCWSTR CGlobalString::m_cszRegTraceBufferSize      = L"Trace Buffer Size";
LPCWSTR CGlobalString::m_cszRegTraceBufferMinCount  = L"Trace Buffer Min Count";
LPCWSTR CGlobalString::m_cszRegTraceBufferMaxCount  = L"Trace Buffer Max Count";
LPCWSTR CGlobalString::m_cszRegTraceBufferFlushInterval = L"Trace Buffer Flush Interval";
LPCWSTR CGlobalString::m_cszRegTraceFlags           = L"Trace Flags";
LPCWSTR CGlobalString::m_cszRegTraceProviderList    = L"Trace Provider List";
LPCWSTR CGlobalString::m_cszRegTraceProviderCount   = L"TraceProviderCount";
LPCWSTR CGlobalString::m_cszRegTraceProviderGuid    = L"TraceProvider%05d.Guid";
LPCWSTR CGlobalString::m_cszRegAlertThreshold       = L"Counter%05d.AlertThreshold";
LPCWSTR CGlobalString::m_cszRegAlertOverUnder       = L"Counter%05d.AlertOverUnder";
LPCWSTR CGlobalString::m_cszRegDefaultLogFileFolder = L"%SystemDrive%\\PerfLogs";
LPCWSTR CGlobalString::m_cszRegExecuteOnly          = L"ExecuteOnly";

LPCWSTR CGlobalString::m_cszRegCollectionNameInd    = L"Collection Name Indirect";

LPCWSTR CGlobalString::m_cszHtmlComment                     = L"Comment";
LPCWSTR CGlobalString::m_cszHtmlLogType                     = L"LogType";
LPCWSTR CGlobalString::m_cszHtmlCurrentState                = L"CurrentState";
LPCWSTR CGlobalString::m_cszHtmlLogFileMaxSize              = L"LogFileMaxSize";
LPCWSTR CGlobalString::m_cszHtmlLogFileBaseName             = L"LogFileBaseName";
LPCWSTR CGlobalString::m_cszHtmlLogFileFolder               = L"LogFileFolder";
LPCWSTR CGlobalString::m_cszHtmlLogFileSerialNumber         = L"LogFileSerialNumber";
LPCWSTR CGlobalString::m_cszHtmlLogFileAutoFormat           = L"LogFileAutoFormat";
LPCWSTR CGlobalString::m_cszHtmlLogFileType                 = L"LogFileType";
LPCWSTR CGlobalString::m_cszHtmlEOFCommandFile              = L"EOFCommandFile";
LPCWSTR CGlobalString::m_cszHtmlCommandFile                 = L"CommandFile";
LPCWSTR CGlobalString::m_cszHtmlNetworkName                 = L"NetworkName";
LPCWSTR CGlobalString::m_cszHtmlUserText                    = L"UserText";
LPCWSTR CGlobalString::m_cszHtmlPerfLogName                 = L"PerfLogName";
LPCWSTR CGlobalString::m_cszHtmlActionFlags                 = L"ActionFlags";
LPCWSTR CGlobalString::m_cszHtmlTraceBufferSize             = L"TraceBufferSize";
LPCWSTR CGlobalString::m_cszHtmlTraceBufferMinCount         = L"TraceBufferMinCount";
LPCWSTR CGlobalString::m_cszHtmlTraceBufferMaxCount         = L"TraceBufferMaxCount";
LPCWSTR CGlobalString::m_cszHtmlTraceBufferFlushInterval    = L"TraceBufferFlushInterval";
LPCWSTR CGlobalString::m_cszHtmlTraceFlags                  = L"TraceFlags";
LPCWSTR CGlobalString::m_cszHtmlLogFileName                 = L"LogFileName";
LPCWSTR CGlobalString::m_cszHtmlCounterCount                = L"CounterCount";
LPCWSTR CGlobalString::m_cszHtmlSampleCount                 = L"SampleCount";
LPCWSTR CGlobalString::m_cszHtmlUpdateInterval              = L"UpdateInterval";
LPCWSTR CGlobalString::m_cszHtmlCounterPath                 = L"Counter%05d.Path";
LPCWSTR CGlobalString::m_cszHtmlRestartMode                 = L"RestartMode";
LPCWSTR CGlobalString::m_cszHtmlSampleIntervalUnitType      = L"SampleIntervalUnitType";
LPCWSTR CGlobalString::m_cszHtmlSampleIntervalValue         = L"SampleIntervalValue";
LPCWSTR CGlobalString::m_cszHtmlStartMode                   = L"StartMode";
LPCWSTR CGlobalString::m_cszHtmlStartAtTime                 = L"StartAtTime";
LPCWSTR CGlobalString::m_cszHtmlStopMode                    = L"StopMode";
LPCWSTR CGlobalString::m_cszHtmlStopAtTime                  = L"StopAtTime";
LPCWSTR CGlobalString::m_cszHtmlStopAfterUnitType           = L"StopAfterUnitType";
LPCWSTR CGlobalString::m_cszHtmlStopAfterValue              = L"StopAfterValue";    
LPCWSTR CGlobalString::m_cszHtmlCounterAlertThreshold       = L"Counter%05d.AlertThreshold";
LPCWSTR CGlobalString::m_cszHtmlCounterAlertOverUnder       = L"Counter%05d.AlertOverUnder";
LPCWSTR CGlobalString::m_cszHtmlTraceProviderCount          = L"TraceProviderCount";
LPCWSTR CGlobalString::m_cszHtmlTraceProviderGuid           = L"TraceProvider%05d.Guid";
LPCWSTR CGlobalString::m_cszHtmlLogName                     = L"LogName";                   
LPCWSTR CGlobalString::m_cszHtmlAlertName                   = L"AlertName";
LPCWSTR CGlobalString::m_cszHtml_Version                    = L"_Version";
LPCWSTR CGlobalString::m_cszHtmlDataStoreAttributes         = L"DataStoreAttributes";
LPCWSTR CGlobalString::m_cszHtmlRealTimeDataSource          = L"RealTimeDataSource";
LPCWSTR CGlobalString::m_cszHtmlSqlLogBaseName              = L"Sql Log Base Name";

LPCWSTR CGlobalString::m_cszHtmlObjectClassId	            = L"C4D2D8E0-D1DD-11CE-940F-008029004347";
LPCWSTR CGlobalString::m_cszHtmlObjectHeader                = L"<OBJECT ID=\"DISystemMonitor1\" WIDTH=\"100%\" HEIGHT=\"100%\"\r\nCLASSID=\"CLSID:C4D2D8E0-D1DD-11CE-940F-008029004347\">\r\n";
LPCWSTR CGlobalString::m_cszHtmlObjectFooter	            = L"</OBJECT>";
LPCWSTR CGlobalString::m_cszHtmlParamTag		            = L"\t<PARAM NAME=\"";
LPCWSTR CGlobalString::m_cszHtmlValueTag		            = L"\" VALUE=\"";
LPCWSTR CGlobalString::m_cszHtmlValueEolTag	                = L"\"/>\r\n";

LPCWSTR CGlobalString::m_cszHtmlFileHeader1                 = L"<HTML>\r\n<HEAD>\r\n<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html;\" />\r\n";

LPCWSTR CGlobalString::m_cszHtmlFileHeader2                 = L"<META NAME=\"GENERATOR\" Content=\"Microsoft System Monitor\" />\r\n</HEAD>\r\n<BODY>\r\n";
LPCWSTR CGlobalString::m_cszHtmlFileFooter                  = L"\r\n</BODY>\r\n</HTML>";
LPCWSTR CGlobalString::m_cszHtmlParamSearchTag              = L"PARAM NAME";
LPCWSTR CGlobalString::m_cszHtmlValueSearchTag              = L"VALUE";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\warndlg.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    warndlg.cpp

Abstract:

    Implementation of the expensive trace data warning dialog.

--*/

#include "stdafx.h"
#include "smlogcfg.h"
#include "smtraceq.h"
#include "provprop.h"
#include "warndlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static ULONG
s_aulHelpIds[] =
{
    IDC_CHECK_NO_MORE,  IDH_CHECK_NO_MORE,
    0,0
};

/////////////////////////////////////////////////////////////////////////////
// CWarnDlg dialog


CWarnDlg::CWarnDlg(CWnd* pParent /*=NULL*/)
:   CDialog(CWarnDlg::IDD, pParent),
    m_pProvidersPage ( NULL )
{
    //{{AFX_DATA_INIT(CWarnDlg)
    m_CheckNoMore = FALSE;
    //}}AFX_DATA_INIT
}


void CWarnDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWarnDlg)
    DDX_Check(pDX, IDC_CHECK_NO_MORE, m_CheckNoMore);
    //}}AFX_DATA_MAP
}

void    
CWarnDlg::SetProvidersPage( CProvidersProperty* pPage ) 
{ 
    // The providers page is not always the parent, so store a separate pointer
    m_pProvidersPage = pPage; 
}

BEGIN_MESSAGE_MAP(CWarnDlg, CDialog)
    //{{AFX_MSG_MAP(CWarnDlg)
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWarnDlg message handlers

BOOL 
CWarnDlg::OnInitDialog() 
{
    CSmTraceLogQuery* pQuery;
    CString strTitle;

    ASSERT ( NULL != m_pProvidersPage );
    pQuery = m_pProvidersPage->GetTraceQuery();

    if ( NULL != pQuery ) {
        pQuery->GetLogName ( strTitle );
        SetWindowText ( strTitle );
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}
BOOL 
CWarnDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    ASSERT( NULL != m_pProvidersPage );

    if ( pHelpInfo->iCtrlId >= IDC_WARN_FIRST_HELP_CTRL_ID ) {
        InvokeWinHelp(WM_HELP, NULL, (LPARAM)pHelpInfo, m_pProvidersPage->GetContextHelpFilePath(), s_aulHelpIds);
    }

    return TRUE;
}

void 
CWarnDlg::OnContextMenu(CWnd* pWnd, CPoint /* point */) 
{
    ASSERT( NULL != m_pProvidersPage );

    InvokeWinHelp(WM_CONTEXTMENU, (WPARAM)(pWnd->m_hWnd), NULL, m_pProvidersPage->GetContextHelpFilePath(), s_aulHelpIds);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\tracprop.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    tracprop.h

Abstract:

    Class definitions for the advanced trace buffer property page.

--*/

#ifndef _TRACPROP_H_
#define _TRACPROP_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "smproppg.h"
#include "smcfghlp.h"

// Dialog controls
#define IDD_TRACE_PROP                      700

#define IDC_TRACE_BUF_SIZE_UNITS_CAPTION    701
#define IDC_TRACE_INTERVAL_SECONDS_CAPTION  702
#define IDC_TRAC_FIRST_HELP_CTRL_ID         703
#define IDC_TRACE_BUF_FLUSH_CHECK           703
#define IDC_TRACE_BUFFER_SIZE_EDIT          704
#define IDC_TRACE_MIN_BUF_EDIT              705
#define IDC_TRACE_MAX_BUF_EDIT              706
#define IDC_TRACE_FLUSH_INT_EDIT            707
#define IDC_TRACE_BUFFER_SIZE_SPIN          708
#define IDC_TRACE_MIN_BUF_SPIN              709
#define IDC_TRACE_MAX_BUF_SPIN              710
#define IDC_TRACE_FLUSH_INT_SPIN            711

class CSmTraceLogQuery;

/////////////////////////////////////////////////////////////////////////////
// CTraceProperty dialog

class CTraceProperty : public CSmPropertyPage
{
    DECLARE_DYNCREATE(CTraceProperty)
        
        // Construction
public:
            CTraceProperty(MMC_COOKIE   Cookie, LONG_PTR hConsole);
            CTraceProperty();
    virtual ~CTraceProperty();
    
    // Dialog Data
    //{{AFX_DATA(CTraceProperty)
    enum { IDD = IDD_TRACE_PROP };
    DWORD   m_dwBufferSize;
    DWORD   m_dwFlushInterval;
    DWORD   m_dwMaxBufCount;
    DWORD   m_dwMinBufCount;
    BOOL    m_bEnableBufferFlush;
    //}}AFX_DATA
    
    
    // Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CTraceProperty)
public:
protected:
    virtual void OnFinalRelease();
    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL
    
    // Implementation
protected:
    
    virtual INT GetFirstHelpCtrlId ( void ) { return IDC_TRAC_FIRST_HELP_CTRL_ID; };  // Subclass must override.
    virtual BOOL    IsValidLocalData ();
    
    // Generated message map functions
    //{{AFX_MSG(CTraceProperty)
    afx_msg void OnTraceBufFlushCheck();
    afx_msg void OnChangeTraceBufferSizeEdit();
    afx_msg void OnKillfocusTraceBufferSizeEdit();
    afx_msg void OnDeltaposTraceBufferSizeSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnChangeTraceFlushIntEdit();
    afx_msg void OnKillfocusTraceFlushIntEdit();
    afx_msg void OnDeltaposTraceFlushIntSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnChangeTraceMaxBufEdit();
    afx_msg void OnKillfocusTraceMaxBufEdit();
    afx_msg void OnDeltaposTraceMaxBufSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnChangeTraceMinBufEdit();
    afx_msg void OnKillfocusTraceMinBufEdit();
    afx_msg void OnDeltaposTraceMinBufSpin(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
        
        // Generated OLE dispatch map functions
        //{{AFX_DISPATCH(CTraceProperty)
        // NOTE - the ClassWizard will add and remove member functions here.
        //}}AFX_DISPATCH
        DECLARE_DISPATCH_MAP()
        DECLARE_INTERFACE_MAP()
        
private:

    enum eValueRange {
        eMinBufCount = 3,
        eMaxBufCount = 400,
        eMinBufSize = 1,
        eMaxBufSize = 1024,
        eMinFlushInt = 0,
        eMaxFlushInt = 300
    };
    
    // local functions
    BOOL    SetFlushIntervalMode ( void );
    BOOL    SaveDataToModel ( void );
    
private:
    CSmTraceLogQuery    *m_pTraceLogQuery;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif //_TRACPROP_H__65154EB0_BDBE_11D1_BF99_00C04F94A83A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogcfg\warndlg.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    warndlg.h

Abstract:

    Class definition for the expensive trace data warning dialog.

--*/

#ifndef _WARNDLG_H_
#define _WARNDLG_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Dialog controls
#define IDD_EXPENSIVEWARN               1200

#define IDC_STATIC_WARN                 1201
#define IDC_WARN_FIRST_HELP_CTRL_ID     1202
#define IDC_CHECK_NO_MORE               1202


class CProvidersProperty;

/////////////////////////////////////////////////////////////////////////////
// CWarnDlg dialog

class CWarnDlg : public CDialog
{
// Construction
public:
                    CWarnDlg(CWnd* pParent = NULL);   // standard constructor
    virtual         ~CWarnDlg(){};

            void    SetProvidersPage( CProvidersProperty* pPage ); 

// Dialog Data
    //{{AFX_DATA(CWarnDlg)
    enum { IDD = IDD_EXPENSIVEWARN };
    BOOL    m_CheckNoMore;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWarnDlg)
    protected:
    virtual BOOL OnInitDialog();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CWarnDlg)
    afx_msg BOOL OnHelpInfo( HELPINFO* );
    afx_msg void OnContextMenu( CWnd*, CPoint );
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CProvidersProperty* m_pProvidersPage;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // _WARNDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogsvc\logthred.c ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    logthred.c

Abstract:

    Performance Logs and Alerts log/scan thread functions.

--*/

#ifndef UNICODE
#define UNICODE     1
#endif
#ifndef _UNICODE
#define _UNICODE    1
#endif

#ifndef _IMPLEMENT_WMI 
#define _IMPLEMENT_WMI 1
#endif

//
//  Windows Include files
//
#pragma warning ( disable : 4201)

#include <assert.h>

// For Trace *** - these are only necessary because of union query data struct.
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wtypes.h>
#include <float.h>
#include <limits.h>

#if _IMPLEMENT_WMI
#include <wmistr.h>
#include <evntrace.h>
#endif

#include <lmcons.h>
#include <lmmsg.h>  // for net message function

#include <pdh.h>
#include <pdhp.h>

#include <pdhmsg.h>
#include <strsafe.h>
#include "smlogsvc.h"
#include "smlogmsg.h"

#define SECONDS_IN_DAY      ((LONGLONG)(86400))

#define LOG_EVENT_ON_ERROR  ((BOOL)(1))

// A collection thread can get backed up behind some long-running PDH
// operations causing it to timeout;
// In the case of opening a query and adding a counter, retry
// a number of times before giving up
#define NUM_PDH_RETRIES 20



DWORD
ProcessLogFileFolder (     
    IN PLOG_QUERY_DATA pQuery )
{
    DWORD       dwStatus = ERROR_SUCCESS;
    LPWSTR      szLocalPath = NULL;
    LPWSTR      szEnd = NULL;
    DWORD       dwBufferLength = 0;
    LPSECURITY_ATTRIBUTES   lpSA = NULL;
    WCHAR       cBackslash = L'\\';
    LONG        lErrorMode;
    BOOL        fDirectoryCreated;

    //
    // Environment strings are already expanded.
    //
    dwBufferLength = GetFullPathName ( pQuery->szLogFileFolder, 0, NULL, NULL);

    szLocalPath = (LPWSTR) G_ALLOC ( (dwBufferLength + 1) * sizeof(WCHAR) );

    if ( szLocalPath ) {

        if ( GetFullPathName (
                pQuery->szLogFileFolder,
                dwBufferLength,
                szLocalPath,
                NULL ) > 0 ) 
        {
            //
            // Check for prefix
            //
            // Go one past the first backslash after the drive or remote machine name
            // N.B. We are assuming the full path name looks like either "\\machine\share\..."
            //      or "C:\xxx". How about "\\?\xxx" style names
            //
            if ( cBackslash == szLocalPath[0] && cBackslash == szLocalPath[1] ) {
                szEnd = &szLocalPath[2];
                while ((*szEnd != cBackslash) && (*szEnd != L'\0') ) szEnd++;

                if ( cBackslash == *szEnd ) {
                    szEnd++;
                }         
            } else {
                szEnd = &szLocalPath[3];
            }

            if (*szEnd != L'\0') {
                int iPathLen;

                //
                // Remove the trailing back slash character if it is there.
                //
                iPathLen = lstrlen(szEnd) - 1;
                while ( iPathLen >= 0 && cBackslash == szEnd[ iPathLen ]) {
                    szEnd[ iPathLen ] = L'\0';
                    iPathLen -= 1;
                }
            
                lErrorMode = SetErrorMode ( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );
                //
                // There are sub dirs to create. 
                //
                while (*szEnd != L'\0') {
                    //
                    // Go to next backslash.
                    //
                    while ((*szEnd != cBackslash) && (*szEnd != L'\0')) szEnd++;
                    if (*szEnd == cBackslash) {
                        //
                        // Terminate path here and create directory.
                        //
                        *szEnd = L'\0';
                        if (!CreateDirectory (szLocalPath, NULL)) {
                            //
                            // See what the error was and "adjust" it if necessary
                            //
                            dwStatus = GetLastError();
                            if ( ERROR_ALREADY_EXISTS == dwStatus ) {
                                //
                                // This is OK
                                //
                                dwStatus = ERROR_SUCCESS;
                            }
                            else {
                                //
                                // Return error code here and don't continue?
                                //
                            }
                        }
                        //
                        // Replace backslash and go to next dir
                        //
                        *szEnd++ = cBackslash;
                    }
                }

                //
                // If the log folder is the default one, put ACLs on it
                // N.B. The gszDefaultLogFileFolder does not contain a back slash char
                //      at the end
                //
                if (lstrcmpi(szLocalPath, gszDefaultLogFileFolder) == 0) {
                    fDirectoryCreated = PerfCreateDirectory (szLocalPath);
                } else {
                    fDirectoryCreated = CreateDirectory (szLocalPath, NULL);
                }

                if ( !fDirectoryCreated ) {
                    //
                    // See what the error was and "adjust" it if necessary
                    //
                    dwStatus = GetLastError();
                    if ( ERROR_ALREADY_EXISTS == dwStatus ) {
                        //
                        // This is OK
                        //
                        dwStatus = ERROR_SUCCESS;
                    }
                }

                SetErrorMode ( lErrorMode );
            } else {
                //
                // Root directory is OK.
                //
                dwStatus = ERROR_SUCCESS;
            }
        } else {
            dwStatus = GetLastError();
        }
        G_FREE ( szLocalPath );
    } else {
        dwStatus = ERROR_OUTOFMEMORY;
    }
    
    // Report event on error
    if ( ERROR_SUCCESS != dwStatus ) {
        DWORD   dwMessageId; 
        LPWSTR szStringArray[3];
        
        szStringArray[0] = pQuery->szLogFileFolder;
        szStringArray[1] = pQuery->szQueryName;
        szStringArray[2] = FormatEventLogMessage(dwStatus);

        if ( pQuery->bReconfiguration ) {
            dwMessageId = SMLOG_INVALID_LOG_FOLDER_STOP;
        } else {
            dwMessageId = SMLOG_INVALID_LOG_FOLDER_START;
        }

        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            dwMessageId,
            NULL,
            3,
            sizeof(DWORD),
            szStringArray,      
            (LPVOID)&dwStatus);

        LocalFree( szStringArray[2] );
    }

    return dwStatus;
}

DWORD
ValidateCommandFilePath ( 
    IN    PLOG_QUERY_DATA pArg )
{
    DWORD dwStatus = ERROR_SUCCESS;

    if ( 0 != lstrlen ( pArg->szCmdFileName ) ) {
    
        HANDLE hOpenFile;
        LONG   lErrorMode;

        lErrorMode = SetErrorMode ( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );

        hOpenFile =  CreateFile (
                        pArg->szCmdFileName,
                        GENERIC_READ,
                        0,              // Not shared
                        NULL,           // Security attributes
                        OPEN_EXISTING,  
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

        if ( ( NULL == hOpenFile ) 
                || INVALID_HANDLE_VALUE == hOpenFile ) {

            LPWSTR  szStringArray[3];

            dwStatus = GetLastError();

            szStringArray[0] = pArg->szCmdFileName;
            szStringArray[1] = pArg->szQueryName;
            szStringArray[2] = FormatEventLogMessage(dwStatus);

            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                SMLOG_CMD_FILE_INVALID,
                NULL,
                3,
                sizeof(DWORD),
                szStringArray,
                (LPVOID)&dwStatus );

            LocalFree( szStringArray[2] );

            pArg->dwCmdFileFailure = dwStatus;

        } else {
            CloseHandle(hOpenFile);
        }

        SetErrorMode ( lErrorMode );
    }
    return dwStatus;
}


DWORD 
AddCounterToCounterLog (                        
    IN      PLOG_QUERY_DATA pArg, 
    IN      LPWSTR  pszThisPath,
    IN      HANDLE  hQuery,
    IN      BOOL    bLogErrorEvent,
    IN OUT  DWORD*  pdwCounterCount )
{
    LPWSTR              szStringArray[3];
    LONG                lWaitStatus;
    INT                 iRetries;
    BOOL                bFirstTimeout;
    DWORD               dwStatus = ERROR_SUCCESS;
    HCOUNTER            hThisCounter = NULL;
    PDH_STATUS          pdhStatus;                
    PLOG_COUNTER_INFO   pCtrInfo = NULL;
    HANDLE              arrEventHandle[2];
    WCHAR               szRetryCount[SLQ_MAX_VALUE_LEN];

    arrEventHandle[0] = pArg->hExitEvent;           // WAIT_OBJECT_0
    arrEventHandle[1] = pArg->hReconfigEvent;
                
    iRetries = NUM_PDH_RETRIES;
    bFirstTimeout = TRUE;
    do {                
        dwStatus = pdhStatus = PdhAdd009Counter (
                                    hQuery,
                                    pszThisPath, 
                                    (*pdwCounterCount), 
                                    &hThisCounter);

        if ( bFirstTimeout && WAIT_TIMEOUT == pdhStatus ) {
            //
            // Write event log warning message
            //
            StringCchPrintf (
                szRetryCount,
                SLQ_MAX_VALUE_LEN,
                L"%d", 
                iRetries );

            szStringArray[0] = pszThisPath;
            szStringArray[1] = pArg->szQueryName;
            szStringArray[2] = szRetryCount;
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                SMLOG_ADD_COUNTER_TIMEOUT,
                NULL,
                3,
                sizeof(DWORD),
                szStringArray,
                (LPVOID)&pdhStatus);

            bFirstTimeout = FALSE;
        }

    } while ( WAIT_TIMEOUT == (lWaitStatus = WaitForMultipleObjects (2, arrEventHandle, FALSE, 0))
              && WAIT_TIMEOUT == pdhStatus
              && iRetries-- > 0 );
    if ( WAIT_TIMEOUT != lWaitStatus ) {
        // the loop was terminated by the Exit/Reconfigure event
        return ERROR_CANCELLED;
    }

    if (dwStatus != ERROR_SUCCESS) {

        iRetries = NUM_PDH_RETRIES;
        do {                
            dwStatus = pdhStatus = PdhAddCounter (
                                        hQuery,
                                        pszThisPath, 
                                        (*pdwCounterCount), 
                                        &hThisCounter);
        } while ( WAIT_TIMEOUT == (lWaitStatus = WaitForMultipleObjects (2, arrEventHandle, FALSE, 0))
                  && WAIT_TIMEOUT == pdhStatus
                  && iRetries-- > 0 );
        if ( WAIT_TIMEOUT != lWaitStatus ) {
            // the loop was terminated by the Exit/Reconfigure event
            return ERROR_CANCELLED;
        }
    }

    if ( !IsErrorSeverity(pdhStatus) ) {
        if ( IsWarningSeverity(pdhStatus) ) {
            //
            // Write event log warning message
            //
            szStringArray[0] = pszThisPath;
            szStringArray[1] = pArg->szQueryName;
            szStringArray[2] = FormatEventLogMessage(pdhStatus);
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                SMLOG_ADD_COUNTER_WARNING,
                NULL,
                3,
                sizeof(DWORD),
                szStringArray,
                (LPVOID)&pdhStatus);
            LocalFree( szStringArray[2] );
        }

        pCtrInfo = G_ALLOC (sizeof (LOG_COUNTER_INFO));
        if (pCtrInfo != NULL) {
            //
            // Add this handle to the list
            //
            // Insert at front of list since the order isn't
            // important and this is simpler than walking the
            // list each time.
            //
            pCtrInfo->hCounter = hThisCounter;
            pCtrInfo->next = pArg->pFirstCounter;
            pArg->pFirstCounter = pCtrInfo;
            pCtrInfo = NULL;
            
            (*pdwCounterCount)++; 
       } else {
            dwStatus = ERROR_OUTOFMEMORY;
        }
    } else {
        //
        // For LogByObject, the call is retried with expanded counter if
        // the first try fails, so don't log error event the first time.
        //
        if ( bLogErrorEvent ) {
            // unable to add the current counter so write event log message
            szStringArray[0] = pszThisPath;
            szStringArray[1] = pArg->szQueryName;
            szStringArray[2] = FormatEventLogMessage(pdhStatus);

            if ( PDH_ACCESS_DENIED == pdhStatus ) {
                ReportEvent (
                    hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    SMLOG_UNABLE_ACCESS_COUNTER,
                    NULL,
                    2,
                    0,
                    szStringArray,
                    NULL);
            } else {

                ReportEvent (
                    hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    SMLOG_UNABLE_ADD_COUNTER,
                    NULL,
                    3,
                    sizeof(DWORD),
                    szStringArray,
                    (LPVOID)&pdhStatus);
            }
            LocalFree( szStringArray[2] );
        }
    }
    return dwStatus;
}
    

BOOL
IsPdhDataCollectSuccess ( PDH_STATUS pdhStatus ) 
{
    BOOL bSuccess = FALSE;

    if ( ERROR_SUCCESS == pdhStatus 
            || PDH_INVALID_DATA == pdhStatus ) {
        bSuccess = TRUE;
    } else if ( 0 < iPdhDataCollectSuccessCount ) {
        INT iIndex;

        for ( iIndex = 0; iIndex < iPdhDataCollectSuccessCount; iIndex++ ) {
            if ( pdhStatus == (PDH_STATUS)arrPdhDataCollectSuccess[iIndex] ) {
                bSuccess = TRUE;
                break;
            }
        }
    }

    return bSuccess;
}

void
ComputeSessionTics(
    IN      PLOG_QUERY_DATA pArg,
    IN OUT  LONGLONG*   pllWaitTics
)
{
    LONGLONG    llLocalTime;

    //
    // Compute total session time based on Stop modes
    // and values.  

    // -1 (NULL_INTERVAL_TICS) signals no session time limit.  This is true for
    // Stop mode SLQ_AUTO_MODE_NONE and SLQ_AUTO_MODE_SIZE.
    //
    // 0 signals that the Stop time is past, so exit immediately.
    //
    // Assume that session is starting, so Start mode isn't relevant.
    //

    //
    // Pointer check is a sanity check.  The calling code is trusted.
    //
    if ( NULL != pArg && NULL != pllWaitTics ) {

        *pllWaitTics = NULL_INTERVAL_TICS;

        if ( SLQ_AUTO_MODE_AFTER == pArg->stiCurrentStop.dwAutoMode 
                || SLQ_AUTO_MODE_AT == pArg->stiCurrentStop.dwAutoMode ) {       

            llLocalTime = (LONGLONG)0;
            GetLocalFileTime (&llLocalTime);

            if ( SLQ_AUTO_MODE_AT == pArg->stiCurrentStop.dwAutoMode ) {
        
                if ( pArg->stiCurrentStop.llDateTime > llLocalTime ) {

                    *pllWaitTics = pArg->stiCurrentStop.llDateTime - llLocalTime;

                } else {
                    //
                    // Session length = 0.  Exit immediately.
                    //
                    *pllWaitTics = ((LONGLONG)(0)); 
                }

            } else if ( SLQ_AUTO_MODE_AFTER == pArg->stiCurrentStop.dwAutoMode ) {
            
                TimeInfoToTics( &pArg->stiCurrentStop, pllWaitTics );
            }
        }
    }

    return;
}

void
ComputeNewFileTics(
    IN      PLOG_QUERY_DATA pArg,
    IN OUT  LONGLONG*   pllWaitTics
)
{

    LONGLONG    llLocalTime;  
    //
    // Compute time until next file creation based on Create New File modes
    // and values.  

    // -1 (NULL_INTERVAL_TICS) signals no time limit.  This is true for
    // mode SLQ_AUTO_MODE_NONE and SLQ_AUTO_MODE_SIZE.
    //
    // 0 signals that the time is past, so exit immediately.
    //
    // Assume that session is starting, so Start mode isn't relevant.
    //

    //
    // Pointer check is a sanity check.  The calling code is trusted.
    //
    if ( NULL != pArg && NULL != pllWaitTics ) {

        *pllWaitTics = NULL_INTERVAL_TICS;

        if ( SLQ_AUTO_MODE_AFTER == pArg->stiCreateNewFile.dwAutoMode ) {       

            GetLocalFileTime (&llLocalTime);

            if ( SLQ_AUTO_MODE_AFTER == pArg->stiCreateNewFile.dwAutoMode ) {
                TimeInfoToTics( &pArg->stiCreateNewFile, pllWaitTics );
                assert ( (LONGLONG)(0) != *pllWaitTics );
            } else if ( SLQ_AUTO_MODE_AT == pArg->stiCreateNewFile.dwAutoMode ) {
                assert ( FALSE );
                *pllWaitTics = (LONGLONG)(0);
            }
        }
    }
    return;
}


void 
ComputeSampleCount(
    IN  PLOG_QUERY_DATA pArg,
    IN  BOOL    bSessionCount,
    OUT LONGLONG*   pllSampleCount
)
{
    LONGLONG    llLocalSampleCount = NULL_INTERVAL_TICS;
    //
    // Compute sample count based on Stop or CreateNewFile modes
    // and values.  Account for the first sample in the log.
    //
    // 0 signals no sample limit in the file.  This is true for
    // Stop modes SLQ_AUTO_MODE_NONE and SLQ_AUTO_MODE_SIZE.
    //
    // -1 signals that the Stop time is past.
    //
    // Sampling is starting now, so Start mode isn't relevant.
    //
    
    //
    // Pointer check is a sanity check.  The calling code is trusted.
    //
    assert ( NULL != pllSampleCount );
    if ( NULL != pllSampleCount ) {

        *pllSampleCount = (LONGLONG)(-1);
    
        if ( bSessionCount ) {
            ComputeSessionTics ( pArg, &llLocalSampleCount );
        } else {
            ComputeNewFileTics ( pArg, &llLocalSampleCount );
        }

        if ( NULL_INTERVAL_TICS == llLocalSampleCount ) {
            //
            // No session/sample limit
            //
            *pllSampleCount = (LONGLONG)(0);
        } else if ( (LONGLONG)(0) == llLocalSampleCount ){
            //
            // Stop time is past
            //
            *pllSampleCount = INFINITE_TICS;
        } else {
            *pllSampleCount = llLocalSampleCount 
                                / (pArg->dwMillisecondSampleInterval * FILETIME_TICS_PER_MILLISECOND);
            //
            // Add in the "zero-th" sample.
            //
            *pllSampleCount += 1;  
        }
    }
    
    return;
}


BOOL
ProcessRepeatOption ( 
    IN OUT PLOG_QUERY_DATA pArg,
    OUT LARGE_INTEGER* pliStartDelayTics )
{
    BOOL            bRepeat = TRUE;

    //
    // Pointer check is a sanity check.  The calling code is trusted.
    //
    assert ( NULL != pliStartDelayTics );
    if ( NULL != pliStartDelayTics ) {
        //
        // If restart not enabled, then exit.
        //
        if ( SLQ_AUTO_MODE_NONE == pArg->stiRepeat.dwAutoMode ) {
            pliStartDelayTics->QuadPart = NULL_INTERVAL_TICS;
            bRepeat = FALSE;
        } else {
            //
            // For SLQ_AUTO_MODE_AFTER, the only value currently supported is 0.
            //
            pliStartDelayTics->QuadPart = (LONGLONG)0;
            //
            // For SLQ_AUTO_MODE_CALENDAR, add n*24 hours to the original start time.
            //    If Stop mode is SLQ_AUTO_MODE_AT, add n*24 hours to stop time.
            //
            if ( SLQ_AUTO_MODE_CALENDAR == pArg->stiRepeat.dwAutoMode ) {
                //
                // Delay of NULL_INTERVAL signals exit immediately.
                //
                pliStartDelayTics->QuadPart = ComputeStartWaitTics ( pArg, TRUE );

                if ( NULL_INTERVAL_TICS == pliStartDelayTics->QuadPart ) {
                    //
                    // This should not occur.
                    //
                    assert ( FALSE );
                    bRepeat = FALSE;
                } else {
                    pArg->dwCurrentState = SLQ_QUERY_START_PENDING;
                    WriteRegistryDwordValue (
                        pArg->hKeyQuery, 
                        (LPCWSTR)L"Current State",
                        &pArg->dwCurrentState,
                        REG_DWORD );
                } 
            } // else for SLQ_AUTO_MODE_AFTER, repeat immediately
        }
    }

    return bRepeat;
}

void
SetPdhOpenOptions ( 
    IN  PLOG_QUERY_DATA   pArg,
    OUT DWORD*  pdwAccess,
    OUT DWORD*  pdwLogFileType )
{

    //
    // Get file type
    //
    switch ( pArg->dwLogFileType ) {
        case SLF_TSV_FILE:
            *pdwLogFileType = PDH_LOG_TYPE_TSV;
            break;

        case SLF_BIN_FILE:
        case SLF_BIN_CIRC_FILE:
            *pdwLogFileType = PDH_LOG_TYPE_BINARY;
            break;

        case SLF_SQL_LOG:
            *pdwLogFileType = PDH_LOG_TYPE_SQL;
            break;

        case SLF_CSV_FILE:
        default:
            *pdwLogFileType = PDH_LOG_TYPE_CSV;
            break;
    }

    *pdwAccess = PDH_LOG_WRITE_ACCESS |
                    PDH_LOG_CREATE_ALWAYS;

    if (SLF_BIN_CIRC_FILE == pArg->dwLogFileType)
        *pdwAccess |= PDH_LOG_OPT_CIRCULAR;

    if ( ( PDH_LOG_TYPE_BINARY != *pdwLogFileType ) 
         && (NULL != pArg->szLogFileComment ) )
        *pdwAccess |= PDH_LOG_OPT_USER_STRING;

    // NOTE:  For all types except sequential binary,
    // the append mode is determined by the file type.
    // All Sql logs are APPEND
    // All text logs are OVERWRITE
    if (   (pArg->dwAppendMode)
        && (*pdwLogFileType == PDH_LOG_TYPE_BINARY) ) {
        *pdwAccess |= PDH_LOG_OPT_APPEND;
    }

}


DWORD
StartLogQuery (
    IN  PLOG_QUERY_DATA pArg
)
{
    DWORD           dwStatus = ERROR_SUCCESS;
    HRESULT         hr = S_OK;
    HKEY            hKeyLogQuery = NULL;
    SLQ_TIME_INFO   slqTime;
    SC_HANDLE       hSC = NULL;
    SC_HANDLE       hService = NULL;
    SERVICE_STATUS  ssData;
    WCHAR           szQueryKeyNameBuf[MAX_PATH + 1];
    WCHAR           szLogPath[2*MAX_PATH];  
    DWORD           dwCurrentState;
    DWORD           dwValue;
    DWORD           dwDefault;
    LONGLONG        llTime;
    LONGLONG        llModifiedTime;

    //
    // Open registry key to the desired service
    //
    dwStatus = GetQueryKeyName ( 
                pArg->szPerfLogName,
                szQueryKeyNameBuf,
                MAX_PATH + 1 );

    if ( ERROR_SUCCESS == dwStatus && 0 < lstrlen (szQueryKeyNameBuf) ) {

        hr = StringCchCopy ( szLogPath, 2*MAX_PATH, L"SYSTEM\\CurrentControlSet\\Services\\SysmonLog\\Log Queries\\" );
        if ( SUCCEEDED ( hr ) ) {
            hr = StringCchCat ( szLogPath, 2*MAX_PATH, szQueryKeyNameBuf );
        }

        if ( SUCCEEDED ( hr ) ) {

            dwStatus = RegOpenKeyEx (
                (HKEY)HKEY_LOCAL_MACHINE,
                szLogPath,
                0L,
                KEY_READ | KEY_WRITE,
                (PHKEY)&hKeyLogQuery);

            if (dwStatus == ERROR_SUCCESS) {
                //
                // If current state is running, then skip the rest.
                //
                dwDefault = SLQ_QUERY_STOPPED;
                dwStatus = ReadRegistryDwordValue (
                    hKeyLogQuery,
                    pArg->szPerfLogName,
                    (LPCWSTR)L"Current State",
                    &dwDefault,
                    &dwCurrentState);

                if (dwCurrentState == SLQ_QUERY_STOPPED) {
                    //
                    // Update the start time to MIN_TIME_VALUE.
                    //
                    GetLocalFileTime ( &llTime );

                    memset (&slqTime, 0, sizeof(slqTime));
                    slqTime.wTimeType = SLQ_TT_TTYPE_START;
                    slqTime.wDataType = SLQ_TT_DTYPE_DATETIME;
                    slqTime.dwAutoMode = SLQ_AUTO_MODE_NONE;
                    slqTime.llDateTime = MIN_TIME_VALUE;

                    dwStatus = WriteRegistrySlqTime (
                        hKeyLogQuery,
                        (LPCWSTR)L"Start",
                        &slqTime);
                    //    
                    // If stop time mode set to manual, or StopAt with time before Now,
                    // set the mode to Manual, value to MAX_TIME_VALUE.
                    //
                    memset (&slqTime, 0, sizeof(slqTime));
                    slqTime.wTimeType = SLQ_TT_TTYPE_STOP;
                    slqTime.wDataType = SLQ_TT_DTYPE_DATETIME;
                    slqTime.dwAutoMode = SLQ_AUTO_MODE_NONE;
                    slqTime.llDateTime = MAX_TIME_VALUE;

                    dwStatus = ReadRegistrySlqTime (
                                hKeyLogQuery, 
                                pArg->szPerfLogName,
                                (LPCWSTR)L"Stop",
                                &slqTime,
                                &slqTime);

                    if ( SLQ_AUTO_MODE_NONE == slqTime.dwAutoMode 
                        || ( SLQ_AUTO_MODE_AT == slqTime.dwAutoMode 
                            && llTime >= slqTime.llDateTime ) ) {

                        slqTime.wTimeType = SLQ_TT_TTYPE_STOP;
                        slqTime.wDataType = SLQ_TT_DTYPE_DATETIME;
                        slqTime.dwAutoMode = SLQ_AUTO_MODE_NONE;
                        slqTime.llDateTime = MAX_TIME_VALUE;
                
                        dwStatus = WriteRegistrySlqTime (
                                        hKeyLogQuery, 
                                        (LPCWSTR)L"Stop",
                                        &slqTime);
                    }

                    //
                    // Set state to start pending.
                    //
                    if (dwStatus == ERROR_SUCCESS) {
                        dwValue = SLQ_QUERY_START_PENDING;
                        dwStatus = WriteRegistryDwordValue (
                            hKeyLogQuery,
                            (LPCWSTR)L"Current State",
                            &dwValue,
                            REG_DWORD);
                    }

                    //
                    // Update the modified time to indicate a change has occurred.
                    //
                    memset (&slqTime, 0, sizeof(slqTime));
                    //
                    // LastModified and LastConfigured values are stored as GMT.
                    //
                    GetSystemTimeAsFileTime ( (LPFILETIME)(&llModifiedTime) );

                    slqTime.wTimeType = SLQ_TT_TTYPE_LAST_MODIFIED;
                    slqTime.wDataType = SLQ_TT_DTYPE_DATETIME;
                    slqTime.dwAutoMode = SLQ_AUTO_MODE_NONE;
                    slqTime.llDateTime = llModifiedTime;

                    dwStatus = WriteRegistrySlqTime (
                        hKeyLogQuery,
                        (LPCWSTR)L"Last Modified",
                        &slqTime);


                    if (dwStatus == ERROR_SUCCESS) {
                        hSC = OpenSCManager ( NULL, NULL, SC_MANAGER_ALL_ACCESS);

                        if (hSC != NULL) {
                            //
                            // Ping the service controller to rescan the entries.
                            //
                            hService = OpenServiceW (
                                            hSC, 
                                            (LPCWSTR)L"SysmonLog",
                                            SERVICE_USER_DEFINED_CONTROL | SERVICE_START );

                            if (hService != NULL) {
                                ControlService ( 
                                    hService, 
                                    SERVICE_CONTROL_SYNCHRONIZE, 
                                    &ssData);
                                CloseServiceHandle (hService);
                            } else {
                                // unable to open log service
                                dwStatus = GetLastError();
                            }
                            CloseServiceHandle (hSC);
                        } else {                
                            // unable to open service controller
                            dwStatus = GetLastError();
                        }
                    } // else unable to set the time

                    if ( ( ERROR_SUCCESS != dwStatus )
                            && ( 1 != pArg->dwAlertLogFailureReported ) ) {
                        LPWSTR  szStringArray[2];

                        szStringArray[0] = pArg->szPerfLogName;
                        szStringArray[1] = pArg->szQueryName;

                        ReportEvent (hEventLog,
                            EVENTLOG_WARNING_TYPE,
                            0,
                            SMLOG_UNABLE_START_ALERT_LOG,
                            NULL,
                            2,
                            sizeof(DWORD),
                            szStringArray,
                            (LPVOID)&dwStatus );
                
                        pArg->dwAlertLogFailureReported = 1;
                    }
                } else {
                    //
                    // The query is either pending or running already.
                    //
                    dwStatus = ERROR_SUCCESS;
                }
            } else { 
                dwStatus = SMLOG_UNABLE_READ_ALERT_LOG;
        
                if ( 1 != pArg->dwAlertLogFailureReported ) {
                    LPWSTR  szStringArray[2];

                    szStringArray[0] = pArg->szPerfLogName;
                    szStringArray[1] = pArg->szQueryName;

                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_UNABLE_READ_ALERT_LOG,
                        NULL,
                        2,
                        0,
                        szStringArray,
                        NULL );
        
                    pArg->dwAlertLogFailureReported = 1;
                }
            }
        } // ToDo: else report StringCchxxx failure.
    } else {

        dwStatus = SMLOG_UNABLE_READ_ALERT_LOG;
        
        if ( 1 != pArg->dwAlertLogFailureReported ) {
            LPWSTR  szStringArray[2];

            szStringArray[0] = pArg->szPerfLogName;
            szStringArray[1] = pArg->szQueryName;

            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                SMLOG_UNABLE_READ_ALERT_LOG,
                NULL,
                2,
                0,
                szStringArray,
                NULL );
        
            pArg->dwAlertLogFailureReported = 1;
        }
    }

    if ( NULL != hKeyLogQuery ) {
        RegCloseKey ( hKeyLogQuery );
    }

    return dwStatus;
}

DWORD
DoAlertCommandFile (
    IN  PLOG_QUERY_DATA     pArg,
    IN  PALERT_COUNTER_INFO pAlertCI,
    IN  LPCWSTR             szTimeStamp,
    IN  LPCWSTR             szMeasuredValue,
    IN  LPCWSTR             szOverUnder,
    IN  LPCWSTR             szLimitValue
)
{
    const   INT ciMaxDelimPerArg = 3;
            DWORD   dwStatus = ERROR_SUCCESS;
            BOOL    bStatus = FALSE;
            LPWSTR  szCommandString = NULL;
            INT     iBufLen = 0;
            LPWSTR  szTempBuffer = NULL;
            LONG    lErrorMode;
            size_t  sizeStrLen;
            DWORD   dwCmdFlags;
            BOOL    bSingleArg = FALSE;
            STARTUPINFO si;
            PROCESS_INFORMATION pi;
            DWORD   dwCreationFlags = NORMAL_PRIORITY_CLASS;
            LPWSTR  szDelim1;
            LPWSTR  szDelim2;
            BOOL    bFirstArgDone = FALSE;

    if ( NULL != pArg 
            && NULL != pAlertCI ) {

        if ( NULL != pArg->szCmdFileName ) {

            dwStatus = pArg->dwCmdFileFailure;

            if ( ERROR_SUCCESS == dwStatus ) { 

                // See if any of the argument flags are set.
                dwCmdFlags = pArg->dwAlertActionFlags & ALRT_CMD_LINE_MASK;

                if ( 0 != dwCmdFlags ) {
                    // Allocate space for all arguments

                    if ( NULL != pArg->szQueryName ) {
                        iBufLen += lstrlen ( pArg->szQueryName ) + ciMaxDelimPerArg;
                    }
                    if ( NULL != szTimeStamp ) {
                        iBufLen += lstrlen ( szTimeStamp ) + ciMaxDelimPerArg;
                    }
                    if ( NULL != pAlertCI->pAlertInfo->szCounterPath) {
                        iBufLen += lstrlen ( pAlertCI->pAlertInfo->szCounterPath ) + ciMaxDelimPerArg;
                    }
                    if ( NULL != szMeasuredValue ) {
                        iBufLen += lstrlen ( szMeasuredValue ) + ciMaxDelimPerArg;
                    }
                    if ( NULL != szOverUnder ) {
                        iBufLen += lstrlen ( szOverUnder ) + ciMaxDelimPerArg;
                    }
                    if ( NULL != szLimitValue ) {
                        iBufLen += lstrlen ( szLimitValue ) + ciMaxDelimPerArg;
                    }
                    if ( NULL != pArg->szUserText ) {
                        iBufLen += lstrlen ( pArg->szUserText ) + ciMaxDelimPerArg;
                    }
                    iBufLen+= 2;    // 1 for possible leading ", 1 for NULL.

                    szCommandString = (LPWSTR)G_ALLOC(iBufLen * sizeof(WCHAR));

                    if ( NULL != szCommandString ) { 

                        szCommandString[0] = L'\0';

                        // build command line arguments
                        if ((pArg->dwAlertActionFlags  & ALRT_CMD_LINE_SINGLE) != 0) {
                            bSingleArg = TRUE;
                            szDelim1 = L",";
                            szDelim2 = L"\0";
                        } else {
                            // multiple arguments enclosed by double quotes and 
                            // separated by a space
                            szDelim1 = L" \"";
                            szDelim2 = L"\"";
                        }

                        if (pArg->dwAlertActionFlags & ALRT_CMD_LINE_A_NAME ) {
                            if ( NULL != pArg->szQueryName ) {
                                if (bFirstArgDone) {
                                    //
                                    // Add leading delimiter
                                    //
                                    StringCchCat ( szCommandString, iBufLen, szDelim1 );
                                } else {
                                    //
                                    // Add leading quote
                                    //
                                    StringCchCat ( szCommandString, iBufLen, L"\"" );
                                    bFirstArgDone = TRUE;
                                }
                                StringCchCat ( szCommandString, iBufLen, pArg->szQueryName );
                                StringCchCat ( szCommandString, iBufLen, szDelim2 );
                            } else {
                                dwStatus = ERROR_INVALID_PARAMETER;
                            }
                        }

                        if ( ERROR_SUCCESS == dwStatus
                                && ( pArg->dwAlertActionFlags  & ALRT_CMD_LINE_D_TIME ) ) 
                        {
                            if ( NULL != szTimeStamp ) {
                                if (bFirstArgDone) {
                                    StringCchCat ( szCommandString, iBufLen, szDelim1 );
                                } else {
                                    StringCchCat ( szCommandString, iBufLen, L"\"" );
                                    bFirstArgDone = TRUE;
                                }

                                StringCchCat ( szCommandString, iBufLen, szTimeStamp );
                                StringCchCat ( szCommandString, iBufLen, szDelim2 );
                            } else {
                                dwStatus = ERROR_INVALID_PARAMETER;
                            }
                        }

                        if ( ERROR_SUCCESS == dwStatus
                                && ( pArg->dwAlertActionFlags  & ALRT_CMD_LINE_C_NAME ) ) 
                        {
                            if ( NULL != pAlertCI->pAlertInfo->szCounterPath ) {
                                if (bFirstArgDone) {
                                    StringCchCat ( szCommandString, iBufLen, szDelim1 );
                                } else {
                                    StringCchCat ( szCommandString, iBufLen, L"\"" );
                                    bFirstArgDone = TRUE;
                                }
                                StringCchCat ( szCommandString, iBufLen, pAlertCI->pAlertInfo->szCounterPath );
                                StringCchCat ( szCommandString, iBufLen, szDelim2 );
                            } else {
                                dwStatus = ERROR_INVALID_PARAMETER;
                            }
                        }

                        if ( ERROR_SUCCESS == dwStatus
                                && ( pArg->dwAlertActionFlags  & ALRT_CMD_LINE_M_VAL ) ) 
                        {
                            if ( NULL != szMeasuredValue ) {
                                if (bFirstArgDone) {
                                    StringCchCat ( szCommandString, iBufLen, szDelim1 );
                                } else {
                                    StringCchCat ( szCommandString, iBufLen, L"\"" );
                                    bFirstArgDone = TRUE;
                                }
                                StringCchCat ( szCommandString, iBufLen, szMeasuredValue );
                                StringCchCat ( szCommandString, iBufLen, szDelim2 );
                            } else {
                                dwStatus = ERROR_INVALID_PARAMETER;
                            }
                        }

                        if ( ERROR_SUCCESS == dwStatus
                                && ( pArg->dwAlertActionFlags  & ALRT_CMD_LINE_L_VAL ) ) 
                        {
                            if ( NULL != szOverUnder && NULL != szLimitValue ) {
                                if (bFirstArgDone) {
                                    StringCchCat ( szCommandString, iBufLen, szDelim1 );
                                } else {
                                    StringCchCat ( szCommandString, iBufLen, L"\"" );
                                    bFirstArgDone = TRUE;
                                }
                                StringCchCat ( szCommandString, iBufLen, szOverUnder );
                                StringCchCat ( szCommandString, iBufLen, L" ");
                                StringCchCat ( szCommandString, iBufLen, szLimitValue );
                                StringCchCat ( szCommandString, iBufLen, szDelim2 );
                            } else {
                                dwStatus = ERROR_INVALID_PARAMETER;
                            }
                        }

                        if ( ERROR_SUCCESS == dwStatus
                                && ( pArg->dwAlertActionFlags  & ALRT_CMD_LINE_U_TEXT ) ) 
                        {
                            if ( NULL != pArg->szUserText ) {
                                if (bFirstArgDone) {
                                    StringCchCat ( szCommandString, iBufLen, szDelim1 );
                                } else {
                                    StringCchCat ( szCommandString, iBufLen, L"\"" );
                                    bFirstArgDone = TRUE;
                                }
                                StringCchCat ( szCommandString, iBufLen, pArg->szUserText );
                                StringCchCat ( szCommandString, iBufLen, szDelim2 );
                            } else {
                                dwStatus = ERROR_INVALID_PARAMETER;
                            }
                        }

                        if (bFirstArgDone && bSingleArg) {
                            // add closing quote if there's at least 1 arg in the command line
                            StringCchCat ( szCommandString, iBufLen, L"\"" );
                        }
                    } else {
                        dwStatus = ERROR_OUTOFMEMORY;
                    }

                    if ( ERROR_SUCCESS == dwStatus )
                    {

                        iBufLen = lstrlen( pArg->szCmdFileName ) + 1;  // 1 for NULL
                        if ( NULL != szCommandString ) {
                            iBufLen += lstrlen ( szCommandString ) + 1;  // 1 for space char
                        }
                        iBufLen += 2;  // 2 for quote characters
                        szTempBuffer = (LPWSTR)G_ALLOC(iBufLen * sizeof(WCHAR));
                    }

                    if ( NULL != szTempBuffer ) {

                        // build command line arguments
                        StringCchCopy ( szTempBuffer, iBufLen, pArg->szCmdFileName );

                        // see if this is a CMD or a BAT file
                        // if it is then create a process with a console window, otherwise
                        // assume it's an executable file that will create it's own window
                        // or console if necessary
                        //
                        _wcslwr (szTempBuffer);
                        if ((wcsstr(szTempBuffer, L".bat") != NULL) ||
                            (wcsstr(szTempBuffer, L".cmd") != NULL)){
                                dwCreationFlags |= CREATE_NEW_CONSOLE;
                        } else {
                                dwCreationFlags |= DETACHED_PROCESS;
                        }
                        // recopy the image name to the temp buffer since it was modified
                        // (i.e. lowercased) for the previous comparison.

                        szTempBuffer[0] = L'\"';

                        StringCchCopy ( (szTempBuffer+1), iBufLen - 1, pArg->szCmdFileName );
                        StringCchLength (szTempBuffer, iBufLen - 1, &sizeStrLen) ;
                        szTempBuffer[sizeStrLen] = L'\"';
                        sizeStrLen++;                        
                        szTempBuffer[sizeStrLen] = L'\0';

                        if ( NULL != szCommandString ) {
                            // now add on the alert text preceded with a space char
                            szTempBuffer [sizeStrLen] = L' ' ;
                            sizeStrLen++ ;

                            StringCchCopy ( &szTempBuffer[sizeStrLen], iBufLen - sizeStrLen, szCommandString );
                        }
                    
                        // initialize Startup Info block
                        memset (&si, 0, sizeof(si));
                        si.cb = sizeof(si);
                        si.dwFlags = STARTF_USESHOWWINDOW ;
                        si.wShowWindow = SW_SHOWNOACTIVATE ;
                        //si.lpDesktop = L"WinSta0\\Default";

                        memset (&pi, 0, sizeof(pi));

                        // supress pop-ups inf the detached process
                        lErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

                        //
                        // The lpApplication name is NULL for CreateProcess 
                        // because the normal use of this function is to launch
                        // batch files which must be the first part of the lpCommandLine.
                        // The quotes around the szCommandFileName prevents the wrong
                        // file from being executed.
                        //

                        if( pArg->hUserToken != NULL ){
                            bStatus = CreateProcessAsUser (
                                        pArg->hUserToken,
                                        NULL,
                                        szTempBuffer,
                                        NULL, NULL, FALSE,
                                        dwCreationFlags,
                                        NULL,
                                        NULL,
                                        &si,
                                        &pi);
                        } else {
                            bStatus = CreateProcess (
                                        NULL,
                                        szTempBuffer,
                                        NULL, NULL, FALSE,
                                        dwCreationFlags,
                                        NULL,
                                        NULL,
                                        &si,
                                        &pi);
                        }

                        SetErrorMode(lErrorMode);

                        if (bStatus) {
                            dwStatus = ERROR_SUCCESS;
                            if ( NULL != pi.hThread && INVALID_HANDLE_VALUE != pi.hThread ) {
                                CloseHandle(pi.hThread);
                                pi.hThread = NULL;
                            }
                            if ( NULL != pi.hProcess && INVALID_HANDLE_VALUE != pi.hProcess ) {
                                CloseHandle(pi.hProcess);
                                pi.hProcess = NULL;
                            }
                        } else {
                            dwStatus = GetLastError();
                        }
                    } else {
                        dwStatus = ERROR_OUTOFMEMORY;
                    }
                    if (szCommandString != NULL) G_FREE(szCommandString);
                    if (szTempBuffer != NULL) G_FREE(szTempBuffer);
                }
            }

            if ( ERROR_SUCCESS != dwStatus ) { 

                LPWSTR  szStringArray[2];

                szStringArray[0] = szTempBuffer;
                szStringArray[1] = pArg->szQueryName;

                ReportEvent (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    SMLOG_ALERT_CMD_FAIL,
                    NULL,
                    2,
                    sizeof(DWORD),
                    szStringArray,
                    (LPVOID)&dwStatus );

                pArg->dwCmdFileFailure = dwStatus;
            }
        } else {
            dwStatus = ERROR_INVALID_PARAMETER;
        }
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }
    return dwStatus;
}

BOOL
ExamineAlertValues (
    IN    PLOG_QUERY_DATA pArg
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwStatus = ERROR_SUCCESS;
    PALERT_COUNTER_INFO     pAlertCI;
    DWORD                   dwType;
    PDH_FMT_COUNTERVALUE    pdhCurrentValue;
    BOOL                    bDoAlertAction;

    //
    // For each counter in query, compare it's formatted
    // value against the alert value and do the desired operation
    // if the alert condition is exceeded.
    //
    for (pAlertCI = (PALERT_COUNTER_INFO)pArg->pFirstCounter;
         pAlertCI != NULL;
         pAlertCI = pAlertCI->next) {

        bDoAlertAction = FALSE;
        
        //
        // get formatted counter value
        //
        pdhStatus = PdhGetFormattedCounterValue (
                        pAlertCI->hCounter,
                        PDH_FMT_DOUBLE | PDH_FMT_NOCAP100,
                        &dwType,
                        &pdhCurrentValue);

        if ((pdhStatus == ERROR_SUCCESS) && 
            ((pdhCurrentValue.CStatus == PDH_CSTATUS_VALID_DATA) || 
             (pdhCurrentValue.CStatus == PDH_CSTATUS_NEW_DATA))) {
            //
            // The value is good so compare it
            //
            if ((pAlertCI->pAlertInfo->dwFlags & AIBF_OVER) == AIBF_OVER) {
                //
                // Test for value > limit.
                //
                if (pdhCurrentValue.doubleValue > pAlertCI->pAlertInfo->dLimit) {
                    bDoAlertAction = TRUE;
                }
            } else {
                //
                // Test for value < limit.
                //
                if (pdhCurrentValue.doubleValue < pAlertCI->pAlertInfo->dLimit) {
                    bDoAlertAction = TRUE;
                }
            }
        }

        if (bDoAlertAction) {
            WCHAR   szValueString[SLQ_MAX_VALUE_LEN];
            WCHAR   szLimitString[SLQ_MAX_VALUE_LEN];
            WCHAR   szOverUnderString[64];
            WCHAR   szTimeStampFmt[2*SLQ_MAX_VALUE_LEN];
            WCHAR   szTimeStamp[2*SLQ_MAX_VALUE_LEN];
            DWORD   dwFmtStringFlags;
            size_t  cchBufLen;
            SYSTEMTIME  st;

            //
            // Build arguments used by event log and net messsage if either 
            // option is enabled
            //
            dwFmtStringFlags = ALRT_ACTION_LOG_EVENT | ALRT_ACTION_SEND_MSG | ALRT_ACTION_EXEC_CMD;

            if ((pArg->dwAlertActionFlags & dwFmtStringFlags) != 0) {
                INT     nResId;
 
                //
                // Report event to event log
                //

                //
                // Format message string elements
                // The following methods truncate and null terminate the string if it is
                // too long for the buffer.  Continue in this case because strings are only
                // used to report data to the user.
                //
                StringCchPrintf (
                        szValueString,
                        SLQ_MAX_VALUE_LEN,
                        L"%.*g", 
                        DBL_DIG, 
                        pdhCurrentValue.doubleValue );

                StringCchPrintf (
                    szLimitString,
                    SLQ_MAX_VALUE_LEN,
                    L"%.*g", 
                    DBL_DIG, 
                    pAlertCI->pAlertInfo->dLimit );

                nResId = pAlertCI->pAlertInfo->dwFlags & AIBF_OVER ? IDS_OVER : IDS_UNDER;
                LoadString (
                    hModule,
                    nResId,
                    szOverUnderString, 
                    (sizeof(szOverUnderString) / sizeof(szOverUnderString[0])));
                
                //
                // Get timestamp format string
                //
                LoadString (
                    hModule,
                    IDS_ALERT_TIMESTAMP_FMT,
                    szTimeStampFmt, 
                    (sizeof(szTimeStampFmt) / sizeof(szTimeStampFmt[0])));

                //
                // Message format string expects the following args:
                //  Timestamp
                //  Counter path string
                //  measured value
                //  over/under
                //  limit value
                GetLocalTime (&st);

                StringCchPrintf (
                    szTimeStamp,
                    2*SLQ_MAX_VALUE_LEN,
                    szTimeStampFmt, 
                    st.wYear, 
                    st.wMonth, 
                    st.wDay,
                    st.wHour, 
                    st.wMinute, 
                    st.wSecond );
            }

            //
            // Do action(s) as defined in flags
            //
            if ((pArg->dwAlertActionFlags & ALRT_ACTION_LOG_EVENT) == ALRT_ACTION_LOG_EVENT) {
                LPWSTR  szStringArray[4];

                szStringArray[0] = pAlertCI->pAlertInfo->szCounterPath;
                szStringArray[1] = szValueString;
                szStringArray[2] = szOverUnderString;
                szStringArray[3] = szLimitString;

                ReportEvent (hEventLog,
                    EVENTLOG_INFORMATION_TYPE,
                    0,
                    SMLOG_ALERT_LIMIT_CROSSED,
                    NULL,
                    4,
                    0,
                    szStringArray,
                    NULL);
            }
            

            if ((pArg->dwAlertActionFlags & ALRT_ACTION_SEND_MSG) == ALRT_ACTION_SEND_MSG) {
               if (pArg->szNetName != NULL) {
                    size_t  sizeCchMessageTextLen = 0;
                    size_t  sizeCchComponentLen = 0;
                    WCHAR   szMessageFormat[MAX_PATH+1];
                    LPWSTR  szMessageText = NULL;
                    //
                    // Get message format string
                    //
                    LoadString (hModule,
                        IDS_ALERT_MSG_FMT,
                        szMessageFormat, 
                        (sizeof(szMessageFormat) / sizeof(szMessageFormat[0])));
                    //
                    // MAX_PATH + 1 - 1
                    //
                    szMessageFormat [MAX_PATH] = L'\0';

                    // message format string expects the following args:
                    //  Timestamp
                    //  Counter path string
                    //  measured value
                    //  over/under
                    //  limit value

                    StringCchLength ( szMessageFormat, STRSAFE_MAX_CCH, &sizeCchComponentLen );
                    sizeCchMessageTextLen += sizeCchComponentLen;
                    
                    StringCchLength ( szTimeStamp, STRSAFE_MAX_CCH, &sizeCchComponentLen );
                    sizeCchMessageTextLen += sizeCchComponentLen;

                    StringCchLength ( pAlertCI->pAlertInfo->szCounterPath, STRSAFE_MAX_CCH, &sizeCchComponentLen );
                    sizeCchMessageTextLen += sizeCchComponentLen;

                    StringCchLength ( szValueString, STRSAFE_MAX_CCH, &sizeCchComponentLen );
                    sizeCchMessageTextLen += sizeCchComponentLen;

                    StringCchLength ( szOverUnderString, STRSAFE_MAX_CCH, &sizeCchComponentLen );
                    sizeCchMessageTextLen += sizeCchComponentLen;
    
                    StringCchLength ( szLimitString, STRSAFE_MAX_CCH, &sizeCchComponentLen );
                    sizeCchMessageTextLen += sizeCchComponentLen;
                    //
                    // Add one for Null.
                    //
                    sizeCchMessageTextLen++;

                    szMessageText = G_ALLOC ( sizeCchMessageTextLen * sizeof(WCHAR) );

                    if ( NULL != szMessageText ) {

                        //
                        // Truncation is okay.
                        //
                        StringCchPrintf (
                                szMessageText,
                                sizeCchMessageTextLen,
                                szMessageFormat, 
                                szTimeStamp,
                                pAlertCI->pAlertInfo->szCounterPath,
                                szValueString,
                                szOverUnderString,
                                szLimitString);

                        //
                        // Send network message to specified computer
                        //
                        dwStatus = NetMessageBufferSend(  
                                        NULL,
                                        pArg->szNetName,    
                                        NULL,      
                                        (LPBYTE)szMessageText,           
                                        (DWORD)(sizeCchMessageTextLen * sizeof(WCHAR)) );

                        G_FREE (szMessageText);
                    } else {
                        dwStatus = ERROR_OUTOFMEMORY;
                    }

                } else {
                   dwStatus = ERROR_OUTOFMEMORY;
                }
                if ( ( ERROR_SUCCESS != dwStatus )
                        && ( 1 != pArg->dwNetMsgFailureReported ) ) {
                    LPWSTR  szStringArray[3];
                    //
                    // Write event log warning message for net message
                    // only one time per session.
                    //
                    szStringArray[0] = pArg->szQueryName;
                    szStringArray[1] = pArg->szNetName;
                    szStringArray[2] = FormatEventLogMessage(dwStatus);
                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_NET_MESSAGE_WARNING,
                        NULL,
                        3,
                        sizeof(DWORD),
                        szStringArray,
                        (LPVOID)&dwStatus);
                    
                    LocalFree( szStringArray[2] );
                    pArg->dwNetMsgFailureReported = 1;
                }
            }

            if ((pArg->dwAlertActionFlags & ALRT_ACTION_EXEC_CMD) == ALRT_ACTION_EXEC_CMD) {
                //
                // Errors logged in DoAlertCommandFile.
                //
                dwStatus = DoAlertCommandFile (
                                pArg,
                                pAlertCI,
                                szTimeStamp,
                                szValueString,
                                szOverUnderString,
                                szLimitString);
            }

            if ((pArg->dwAlertActionFlags & ALRT_ACTION_START_LOG) == ALRT_ACTION_START_LOG) {
                //
                // Start specified perf data log. 
                // Errors logged in StartLogQuery.
                //
                dwStatus = StartLogQuery ( pArg );
                
            }
        }
    }  // end of for each counter in alert loop
    return TRUE;
}

BOOL
AlertProc (
    IN    PLOG_QUERY_DATA pArg
)
{
    DWORD           dwStatus = ERROR_SUCCESS;
    LARGE_INTEGER   liStartDelayTics;
    LARGE_INTEGER   liSampleDelayTics;
    LONGLONG        llSampleCollectionTics;
    LONGLONG        llSampleIntervalTics;
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    DWORD           dwCounterCount;
    INT             iRetries;
    LONG            lWaitStatus;

    LPWSTR          szThisPath;
    BOOL            bRun = FALSE;
    LPWSTR          szStringArray[4];
    WCHAR           szRetryCount[SLQ_MAX_VALUE_LEN];
    
    LONGLONG        llSessionSampleCount=(LONGLONG)-1;
    PALERT_COUNTER_INFO   pCtrInfo = NULL;
    PALERT_INFO_BLOCK   pAlertInfo = NULL;
    DWORD           dwBufSize;

    LONGLONG        llStartTime = 0;
    LONGLONG        llFinishTime = 0;
    HANDLE          arrEventHandle[2];
    BOOL            bFirstTimeout;

    arrEventHandle[0] = pArg->hExitEvent;           // WAIT_OBJECT_0
    arrEventHandle[1] = pArg->hReconfigEvent;

    __try {

        liStartDelayTics.QuadPart = ((LONGLONG)(0));
        liSampleDelayTics.QuadPart = ((LONGLONG)(0));
        llSampleCollectionTics = ((LONGLONG)(0));

        //
        // Read registry values.
        //
        if ( ERROR_SUCCESS == LoadQueryConfig ( pArg ) ) {
            bRun = TRUE;
        }
     
        if ( TRUE == bRun ) {
            // Delay of -1 signals exit immediately.
            liStartDelayTics.QuadPart = ComputeStartWaitTics ( pArg, TRUE );

            if ( NULL_INTERVAL_TICS == liStartDelayTics.QuadPart ) {
                bRun = FALSE;
            }
        }

        if ( TRUE == bRun ) {
        
            ValidateCommandFilePath ( pArg );

            // open query and add counters from info file

            iRetries = NUM_PDH_RETRIES;
            bFirstTimeout = TRUE;
            do {
                if (pArg->dwRealTimeQuery == DATA_SOURCE_WBEM) {
                    pdhStatus = PdhOpenQueryH(
                            H_WBEM_DATASOURCE, 0, & pArg->hQuery); // from current activity
                } else {
                    pdhStatus = PdhOpenQueryH(
                            H_REALTIME_DATASOURCE, 0, & pArg->hQuery);
                }

                if ( bFirstTimeout && WAIT_TIMEOUT == pdhStatus ) {
                    //
                    // Write event log warning message
                    //
                    StringCchPrintf (
                        szRetryCount,
                        SLQ_MAX_VALUE_LEN,
                        L"%d", 
                        iRetries );

                    szStringArray[0] = pArg->szQueryName;
                    szStringArray[1] = szRetryCount;
                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_OPEN_QUERY_TIMEOUT,
                        NULL,
                        2,
                        sizeof(DWORD),
                        szStringArray,
                        (LPVOID)&pdhStatus);

                    bFirstTimeout = FALSE;
                }
            } while ( WAIT_TIMEOUT == (lWaitStatus = WaitForMultipleObjects (2, arrEventHandle, FALSE, 0)) &&
                      WAIT_TIMEOUT == pdhStatus &&
                      iRetries-- > 0);
            if ( WAIT_TIMEOUT != lWaitStatus ) {
                // the loop was terminated by the Exit/Reconfigure event
                if ( ERROR_SUCCESS == pdhStatus ) {
                    PdhCloseQuery(pArg->hQuery);
                }
                bRun = FALSE;
            } else if (pdhStatus != ERROR_SUCCESS) {
                // unable to open query so write event log message and exit
                szStringArray[0] = pArg->szQueryName;
                szStringArray[1] = FormatEventLogMessage(pdhStatus);
                ReportEvent (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    SMLOG_UNABLE_OPEN_PDH_QUERY,
                    NULL,
                    2,
                    sizeof(DWORD),
                    szStringArray,
                    (LPVOID)&pdhStatus);

                LocalFree( szStringArray[1] );

                bRun = FALSE;
            } 
        }

        //
        // Add each counter and associated alert limits.
        //
        if ( TRUE == bRun ) {
            dwCounterCount = 0;
            for (szThisPath = pArg->mszCounterList;
                    *szThisPath != 0;
                    szThisPath += lstrlen(szThisPath) + 1) {
            
                HCOUNTER        hThisCounter;

                //
                // Allocate information block
                //
                dwBufSize = (lstrlenW(szThisPath) + 1) * sizeof(WCHAR);
                dwBufSize += sizeof(ALERT_INFO_BLOCK);
                pAlertInfo = (PALERT_INFO_BLOCK)G_ALLOC(dwBufSize);

                if (pAlertInfo == NULL) {
                    dwStatus = SMLOG_UNABLE_ALLOC_ALERT_MEMORY;
                    break;
                } else {                
                    //
                    // Get alert info from string
                    //
                    if (MakeInfoFromString (szThisPath, pAlertInfo, &dwBufSize)) {

                        iRetries = NUM_PDH_RETRIES;
                        bFirstTimeout = TRUE;
                        do {
                        
                            pdhStatus = PdhAdd009Counter (pArg->hQuery,
                                                   pAlertInfo->szCounterPath, 
                                                   dwCounterCount, 
                                                   &hThisCounter);
                            
                            if ( bFirstTimeout && WAIT_TIMEOUT == pdhStatus ) {
                                //
                                // Write event log warning message
                                //
                                StringCchPrintf (
                                    szRetryCount,
                                    SLQ_MAX_VALUE_LEN,
                                    L"%d", 
                                    iRetries );

                                szStringArray[0] = pAlertInfo->szCounterPath;
                                szStringArray[1] = pArg->szQueryName;
                                szStringArray[2] = szRetryCount;
                                ReportEvent (hEventLog,
                                    EVENTLOG_WARNING_TYPE,
                                    0,
                                    SMLOG_ADD_COUNTER_TIMEOUT,
                                    NULL,
                                    3,
                                    sizeof(DWORD),
                                    szStringArray,
                                    (LPVOID)&pdhStatus);

                                bFirstTimeout = FALSE;
                            }


                        } while ( WAIT_TIMEOUT == (lWaitStatus = WaitForMultipleObjects (2, arrEventHandle, FALSE, 0)) &&
                                  WAIT_TIMEOUT == pdhStatus &&
                                  iRetries-- > 0);

                        if ( WAIT_TIMEOUT != lWaitStatus ) {
                            if ( NULL != pAlertInfo ) {
                                G_FREE (pAlertInfo); // toss unused alert buffer
                                pAlertInfo = NULL;
                            }
                            bRun = FALSE;
                            dwStatus = ERROR_CANCELLED; // don't report an error
                            break;
                        } else {

                            if (pdhStatus != ERROR_SUCCESS) {
                                iRetries = NUM_PDH_RETRIES;
                                do {
                                    pdhStatus = PdhAddCounter (pArg->hQuery,
                                                       pAlertInfo->szCounterPath, 
                                                       dwCounterCount, 
                                                       &hThisCounter);

                                } while ( WAIT_TIMEOUT == (lWaitStatus = WaitForMultipleObjects (2, arrEventHandle, FALSE, 0)) &&
                                          WAIT_TIMEOUT == pdhStatus &&
                                          iRetries-- > 0);

                                if ( WAIT_TIMEOUT != lWaitStatus ) {
                                    if ( NULL != pAlertInfo ) {
                                        G_FREE (pAlertInfo); // toss unused alert buffer
                                        pAlertInfo = NULL;
                                    }
                                    bRun = FALSE;
                                    dwStatus = ERROR_CANCELLED; // don't report an error
                                    break;
                                }
                            }
                        }

                        if ( !IsErrorSeverity(pdhStatus) ) {

                            dwCounterCount++;

                            if ( ERROR_SUCCESS != pdhStatus ) {
                                szStringArray[0] = szThisPath;
                                szStringArray[1] = pArg->szQueryName;
                                szStringArray[2] = FormatEventLogMessage(pdhStatus);
                                ReportEvent (hEventLog,
                                    EVENTLOG_WARNING_TYPE,
                                    0,
                                    SMLOG_ADD_COUNTER_WARNING,
                                    NULL,
                                    3,
                                    sizeof(DWORD),
                                    szStringArray,
                                    (LPVOID)&pdhStatus);
                                LocalFree( szStringArray[2] );
                            }

                            //
                            //  Add this handle to the list
                            //
                            pCtrInfo = G_ALLOC (sizeof (ALERT_COUNTER_INFO));
                    
                            if (pCtrInfo != NULL) {
                                //
                                // Insert at front of list since the order isn't
                                // important.
                                //
                                pCtrInfo->hCounter = hThisCounter;
                                pCtrInfo->pAlertInfo = pAlertInfo;
                                pCtrInfo->next = (PALERT_COUNTER_INFO)pArg->pFirstCounter;
                                pArg->pFirstCounter = (PLOG_COUNTER_INFO)pCtrInfo;
                                pAlertInfo = NULL;
                                pCtrInfo = NULL;
                            } else {
                                dwStatus = SMLOG_UNABLE_ALLOC_ALERT_MEMORY;
                                //
                                // Delete unused alert info structure.
                                //
                                G_FREE (pAlertInfo); 
                                pAlertInfo = NULL;
                                break;
                            }
                        } else {
                            //
                            // Unable to add the current counter.
                            //
                            szStringArray[0] = pAlertInfo->szCounterPath;
                            szStringArray[1] = pArg->szQueryName;
                            szStringArray[2] = FormatEventLogMessage(pdhStatus);

                            if ( PDH_ACCESS_DENIED == pdhStatus ) {
                                ReportEvent (
                                    hEventLog,
                                    EVENTLOG_WARNING_TYPE,
                                    0,
                                    SMLOG_UNABLE_ACCESS_COUNTER,
                                    NULL,
                                    2,
                                    0,
                                    szStringArray,
                                    NULL);
                            } else {

                                ReportEvent (
                                    hEventLog,
                                    EVENTLOG_WARNING_TYPE,
                                    0,
                                    SMLOG_UNABLE_ADD_COUNTER,
                                    NULL,
                                    3,
                                    sizeof(DWORD),
                                    szStringArray,
                                    (LPVOID)&pdhStatus);
                            }
                            LocalFree( szStringArray[2] );

                            //
                            // Delete unused alert info structure.
                            //
                            if ( NULL != pAlertInfo ) {
                                G_FREE (pAlertInfo); 
                                pAlertInfo = NULL;
                            }
                        }
                    } else {
                        //
                        // Unable to parse alert info, or 
                        // unable to add the current counter.
                        //
                        szStringArray[0] = szThisPath;
                        szStringArray[1] = pArg->szQueryName;
                        ReportEvent (hEventLog,
                            EVENTLOG_WARNING_TYPE,
                            0,
                            SMLOG_UNABLE_PARSE_ALERT_INFO,
                            NULL,
                            2,
                            0,
                            szStringArray,
                            NULL);

                        //
                        // Delete unused alert info structure.
                        //
                        if ( NULL != pAlertInfo ) {
                            G_FREE (pAlertInfo); 
                            pAlertInfo = NULL;
                        }
                    }
                }
            }

            if ( ERROR_SUCCESS == dwStatus ) {
            
                if ( 0 < dwCounterCount ) {
                    //
                    // Raise priority to ensure that data is logged.
                    //
                    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
                } else {
                    bRun = FALSE;
                    //
                    // Unable to add any counters.
                    //
                    szStringArray[0] = pArg->szQueryName;
                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_UNABLE_ADD_ANY_COUNTERS,
                        NULL,
                        1,
                        0,
                        szStringArray,
                        NULL);
                }
            } else {

                assert ( ERROR_OUTOFMEMORY == dwStatus );
                //
                // Memory allocation error.
                //
                szStringArray[0] = pArg->szQueryName;
                ReportEvent (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    SMLOG_UNABLE_ALLOC_ALERT_MEMORY,
                    NULL,
                    1,
                    0,
                    szStringArray,
                    NULL);

                bRun = FALSE;
            }

            while (bRun) {

                if ( 0 < liStartDelayTics.QuadPart ) {
                    //
                    // NtWaitForMultipleObjects requires negative Tic value
                    //
                    liStartDelayTics.QuadPart = ((LONGLONG)(0)) - liStartDelayTics.QuadPart;
                    //
                    // Wait until specified start time, or until exit or reconfigure event.
                    //
                    if ( STATUS_TIMEOUT != NtWaitForMultipleObjects ( 
                                                2, 
                                                &arrEventHandle[0], 
                                                WaitAny,
                                                FALSE, 
                                                &liStartDelayTics )) {
                        //
                        // Exit if not running.
                        //
                        bRun = FALSE;
                        break;
                    }
                }

                pArg->dwCurrentState = SLQ_QUERY_RUNNING;
                dwStatus = WriteRegistryDwordValue (
                            pArg->hKeyQuery, 
                            (LPCWSTR)L"Current State",
                            &pArg->dwCurrentState,
                            REG_DWORD );
                assert (dwStatus == ERROR_SUCCESS);
                    
                szStringArray[0] = pArg->szQueryName;
                ReportEvent (hEventLog,
                    EVENTLOG_INFORMATION_TYPE,
                    0,
                    SMLOG_ALERT_SCANNING,
                    NULL,
                    1,
                    0,
                    szStringArray,
                    NULL);
                //
                // Compute session sample count.
                // 0 samples signals no limit.
                // -1 samples signals exit immediately
                //
                ComputeSampleCount( pArg, TRUE, &llSessionSampleCount );
            
                if ( -1 == llSessionSampleCount ) {
                    goto ProcessAlertRepeat;
                }

                //
                // Start sampling immediately. liSampleDelayTics is initialized to 0.
                // Wait until specified sample time, or until exit or reconfigure event.
                //
                while ( STATUS_TIMEOUT == NtWaitForMultipleObjects ( 
                                            2, 
                                            &arrEventHandle[0], 
                                            WaitAny, 
                                            FALSE, 
                                            &liSampleDelayTics)) {
                    //
                    // An event flag will be set when the sampling should exit or reconfigure. if
                    // the wait times out, then that means it's time to collect and
                    // log another sample of data.
                    //
                
                    GetLocalFileTime (&llStartTime);
                    //
                    // Check for reconfig event.
                    //
                    if ( pArg->bLoadNewConfig ) {
                        bRun = FALSE;
                        break;
                    }

                    pdhStatus = PdhCollectQueryData (pArg->hQuery);

                    if ( IsPdhDataCollectSuccess ( pdhStatus )
                            || IsWarningSeverity ( pdhStatus ) ) {
                    
                        if (pdhStatus == ERROR_SUCCESS) {
                            //
                            // Process alert counters.
                            //
                            ExamineAlertValues (pArg);
                        }
                        //
                        // See if it's time to restart or end the alert scan.
                        // 0 samples signals no sample limit.
                        //
                        if ( 0 != llSessionSampleCount ) {
                            if ( !--llSessionSampleCount ) 
                                break;
                        }
                    } else {
                        //
                        // Unable to collect the query data.
                        //
                        szStringArray[0] = pArg->szQueryName;
                        szStringArray[1] = FormatEventLogMessage(pdhStatus);

                        ReportEvent (hEventLog,
                            EVENTLOG_WARNING_TYPE,
                            0,
                            SMLOG_UNABLE_COLLECT_DATA,
                            NULL,
                            2,
                            sizeof(DWORD),
                            szStringArray,
                            (LPVOID)&pdhStatus);

                        LocalFree( szStringArray[1] );

                        bRun = FALSE;
                        break;
                    }

                    //
                    // Compute new timeout value
                    //
                    GetLocalFileTime (&llFinishTime);

                    llSampleCollectionTics = llFinishTime - llStartTime;

                    llSampleIntervalTics = 
                        (LONGLONG)pArg->dwMillisecondSampleInterval*FILETIME_TICS_PER_MILLISECOND;
                    if ( llSampleCollectionTics < llSampleIntervalTics ) {
                        liSampleDelayTics.QuadPart = llSampleIntervalTics - llSampleCollectionTics;
                    } else {
                        liSampleDelayTics.QuadPart = ((LONGLONG)(0));                       
                    }
                    //
                    // NtWaitForMultipleObjects requires negative Tic value
                    //
                    liSampleDelayTics.QuadPart = ((LONGLONG)(0)) - liSampleDelayTics.QuadPart;

                } // end while wait keeps timing out
                
                //
                // Use 0 SampleDelayTics value to check for ExitEvent.
                //
                liSampleDelayTics.QuadPart = ((LONGLONG)(0));

                if ( pArg->bLoadNewConfig ) {
                    bRun = FALSE;
                } else if ( STATUS_TIMEOUT != NtWaitForSingleObject (
                                                pArg->hExitEvent, 
                                                FALSE, 
                                                &liSampleDelayTics ) ) {
                    //
                    // The loop was terminated by the Exit event
                    // so clear the "run" flag to exit the loop & thread.
                    //
                    bRun = FALSE;
                }
                //
                // Exit if restart not enabled.
                //
ProcessAlertRepeat:
                if ( bRun ) {
                    bRun = ProcessRepeatOption ( pArg, &liStartDelayTics );
                }

            } // end while (bRun)
            
            PdhCloseQuery (pArg->hQuery);
            pArg->hQuery = NULL;        
        }

        SetLastError ( ERROR_SUCCESS );
    } __except ( EXCEPTION_EXECUTE_HANDLER ) {

        bRun = FALSE;
        
        if ( NULL != pArg->hQuery ) {
            PdhCloseQuery ( pArg->hQuery );
            pArg->hQuery = NULL;
        }

        SetLastError ( SMLOG_THREAD_FAILED );  
    }
        
    DeallocateQueryBuffers ( pArg );

    while ( NULL != pArg->pFirstCounter ) {
        PALERT_COUNTER_INFO pDelCI = (PALERT_COUNTER_INFO)pArg->pFirstCounter;
        if (pDelCI->pAlertInfo != NULL) G_FREE(pDelCI->pAlertInfo);

        pArg->pFirstCounter = (PLOG_COUNTER_INFO)pDelCI->next;

        G_FREE( pDelCI );
    }

    return bRun;
}

BOOL
CounterLogProc (
    IN    PLOG_QUERY_DATA pArg )
{
#define INSTBUFLEN  (4096)

    DWORD           dwStatus = ERROR_SUCCESS;
    LARGE_INTEGER   liStartDelayTics;
    LARGE_INTEGER   liSampleDelayTics;
    LONGLONG        llSampleCollectionTics;
    LONGLONG        llSampleIntervalTics;
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    DWORD           dwCounterCount;
    INT             iRetries;
    INT             iCnfSerial;
    DWORD           dwSessionSerial;

    LPWSTR          szThisPath;
    DWORD           dwPdhLogFileType;
    DWORD           dwPdhAccessFlags;
    BOOL            bRun = FALSE;
    LONGLONG        llSessionSampleCount=(LONGLONG)-1;
    LONGLONG        llCnfSampleCount=(LONGLONG)-1;
    LONGLONG        llLoopSampleCount=(LONGLONG)-1;
    // Todo:  Enforce log file name length
    WCHAR           szCurrentLogFile[MAX_PATH+1];
    WCHAR           szRetryCount[SLQ_MAX_VALUE_LEN];
    BOOL            bFirstTimeout;
    LPWSTR          szStringArray[4];
    DWORD           dwFileSizeLimit;
    ULONGLONG       ullFileSizeLimit;
    LONGLONG        llFileSize;

    LONGLONG        llStartTime = 0;
    LONGLONG        llFinishTime = 0;
    PLOG_COUNTER_INFO pDelCI;

    // Wildcard processing
    ULONG   ulBufLen = 0;
    ULONG   ulBufSize = 0;
    ULONG   ulLocaleBufLen = 0;
    LPWSTR  szLocaleBuf = NULL;
    LPWSTR  pLocalePath = NULL;
    INT     nCounterBufRetry;
    LPWSTR  pszCounterBuf = NULL;
    LPWSTR  pszCounter;
    DWORD   dwPdhExpandFlags;
    PPDH_COUNTER_PATH_ELEMENTS pPathInfo = NULL;

    LONG            lWaitStatus;
    HANDLE arrEventHandle[2];

    arrEventHandle[0] = pArg->hExitEvent;           // WAIT_OBJECT_0
    arrEventHandle[1] = pArg->hReconfigEvent;

    __try {

        liStartDelayTics.QuadPart = ((LONGLONG)(0));
        liSampleDelayTics.QuadPart = ((LONGLONG)(0));
        llSampleCollectionTics = ((LONGLONG)(0));

        //
        // Read registry values.
        //
        if ( ERROR_SUCCESS == LoadQueryConfig ( pArg ) ) {
            bRun = TRUE;
        }
    
        if ( TRUE == bRun ) {
            //
            // Delay of -1 signals exit immediately.
            //
            liStartDelayTics.QuadPart = ComputeStartWaitTics ( pArg, TRUE );

            if ( NULL_INTERVAL_TICS == liStartDelayTics.QuadPart ) {
                bRun = FALSE;
            }
        }

        if ( TRUE == bRun ) {
            //
            // Stop the query if new log file folder is not valid.
            // ProcessLogFileFolder reports an error event on failure.  Event message content
            // depends on whether this is a reconfiguration or the original configuration.
            //
            bRun = ( ERROR_SUCCESS == ProcessLogFileFolder( pArg ) );
        }

        if ( TRUE == bRun ) {
       
            ValidateCommandFilePath ( pArg );

            //
            // Open query and add counters from info file.
            //

            iRetries = NUM_PDH_RETRIES;
            bFirstTimeout = TRUE;
            do {
                if (pArg->dwRealTimeQuery == DATA_SOURCE_WBEM) {
                    pdhStatus = PdhOpenQueryH(
                            H_WBEM_DATASOURCE, 0, & pArg->hQuery); 
                } else {
                    pdhStatus = PdhOpenQueryH(
                            H_REALTIME_DATASOURCE, 0, & pArg->hQuery);
                }

                if ( bFirstTimeout && WAIT_TIMEOUT == pdhStatus ) {
                    //
                    // Write event log warning message
                    //
                    StringCchPrintf (
                        szRetryCount,
                        SLQ_MAX_VALUE_LEN,
                        L"%d", 
                        iRetries );

                    szStringArray[0] = pArg->szQueryName;
                    szStringArray[1] = szRetryCount;
                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_OPEN_QUERY_TIMEOUT,
                        NULL,
                        2,
                        sizeof(DWORD),
                        szStringArray,
                        (LPVOID)&pdhStatus);

                    bFirstTimeout = FALSE;
                }
            } while ( WAIT_TIMEOUT == (lWaitStatus = WaitForMultipleObjects (2, arrEventHandle, FALSE, 0)) &&
                      WAIT_TIMEOUT == pdhStatus &&
                      iRetries-- > 0 );

            if ( WAIT_TIMEOUT != lWaitStatus ) {
                // the loop was terminated by the Exit/Reconfigure event
                if ( ERROR_SUCCESS == pdhStatus ) {
                    PdhCloseQuery (pArg->hQuery);
                }
                bRun = FALSE;
            } else if (pdhStatus != ERROR_SUCCESS) {
                 //
                // Unable to open query.
                //
                szStringArray[0] = pArg->szQueryName;
                szStringArray[1] = FormatEventLogMessage(pdhStatus);
                ReportEvent (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    SMLOG_UNABLE_OPEN_PDH_QUERY,
                    NULL,
                    2,
                    sizeof(DWORD),
                    szStringArray,
                    (LPVOID)&pdhStatus);
                LocalFree( szStringArray[1] );

                bRun = FALSE;
            }
        }
        //
        // Add each counter to the open query.
        //
        if ( TRUE == bRun ) {
    
            dwStatus = ERROR_SUCCESS;
            dwCounterCount = 0;
            for (szThisPath = pArg->mszCounterList;
                *szThisPath != 0;
                szThisPath += lstrlen(szThisPath) + 1) {

                if (wcschr(szThisPath, L'*') == NULL) {
                    //
                    // No wildcards
                    //
                    dwStatus = AddCounterToCounterLog( pArg, szThisPath, pArg->hQuery, LOG_EVENT_ON_ERROR, &dwCounterCount );
                } else {
                    //
                    // At least one wildcard
                    //
                    dwPdhExpandFlags = 0;
                    pszCounterBuf = NULL;

                    //
                    // Only expand wildcard instances for text log files.
                    //
                    if (pArg->dwLogFileType == SLF_SQL_LOG) {
                        //
                        // No need to expand wildcard instances for SQL log.
                        // SQL log now has the capability to catch dynamic
                        // instances, so we can pass in wildcard-instance
                        // counter names here.
                        //
                        dwPdhExpandFlags |= PDH_NOEXPANDINSTANCES;
                    } else if (   SLF_CSV_FILE != pArg->dwLogFileType
                             && SLF_TSV_FILE != pArg->dwLogFileType) {
                        //
                        // This is the binary counter logfile case.
                        // No need to expand wildcard instances. Also, if
                        // default real-time datasource is from registry (not
                        // WMI), we can handle add-by-object.
                        //
                        dwPdhExpandFlags |= PDH_NOEXPANDINSTANCES;

                        if ( DATA_SOURCE_REGISTRY == pArg->dwRealTimeQuery) {
                            //
                            // If both instance and counter are wildcards, then log by object
                            // rather than expanding the counter path.
                            // This is only true when the actual data source is the registry.
                            //
                            // Parse pathname.
                            //
                            do {
                                if (pPathInfo) {
                                    G_FREE(pPathInfo);
                                    pPathInfo = NULL;
                                }
                                else {
                                    ulBufSize = sizeof(PDH_COUNTER_PATH_ELEMENTS) + (PDH_MAX_COUNTER_PATH + 1) * sizeof(WCHAR);
                                }
    
                                pPathInfo = (PPDH_COUNTER_PATH_ELEMENTS) G_ALLOC(ulBufSize);
    
                                if (pPathInfo == NULL) {
                                    pdhStatus = ERROR_OUTOFMEMORY;
                                    break;
                                }
    
                                pdhStatus = PdhParseCounterPath( szThisPath, pPathInfo, & ulBufSize, 0);
    
                            } while (pdhStatus == PDH_INSUFFICIENT_BUFFER || pdhStatus == PDH_MORE_DATA);
    
                            if (pdhStatus == ERROR_SUCCESS) {
                                if ( 0 == lstrcmpi ( pPathInfo->szCounterName, L"*" ) ) {
                                    if ( NULL != pPathInfo->szInstanceName ) {
                                        if ( 0 == lstrcmpi ( pPathInfo->szInstanceName, L"*" ) ) {
                                            //
                                            // If PdhAddCounter failed,the realtime data source is actually WBEM.
                                            // In this case, expand the counter paths.
                                            //
                                            dwStatus = AddCounterToCounterLog( pArg, szThisPath, pArg->hQuery, !LOG_EVENT_ON_ERROR, &dwCounterCount );
                                            if ( ERROR_SUCCESS == dwStatus ) {
                                                continue;
                                            } else {
                                                //
                                                // Enumerate counter paths below and retry.
                                                //
                                                dwStatus = ERROR_SUCCESS;
                                            }
                                        }
                                    } else {
                                        dwStatus = AddCounterToCounterLog( pArg, szThisPath, pArg->hQuery, !LOG_EVENT_ON_ERROR, &dwCounterCount );
                                        //
                                        // If PdhAddCounter failed,the realtime data source is actually WBEM.
                                        // In this case, expand the counter paths.
                                        //
                                        if ( ERROR_SUCCESS == dwStatus ) {
                                            continue;
                                        } else {
                                            //
                                            // Enumerate counter paths below and retry.
                                            //
                                            dwStatus = ERROR_SUCCESS;
                                        }
                                    }
                                }
                            } else {
                                //
                                // Report event and continue to next counter.
                                //
                                szStringArray[0] = szThisPath;
                                szStringArray[1] = pArg->szQueryName;
                                szStringArray[2] = FormatEventLogMessage(pdhStatus);
                                ReportEvent (
                                    hEventLog,
                                    EVENTLOG_WARNING_TYPE,
                                    0,
                                    SMLOG_UNABLE_PARSE_COUNTER,
                                    NULL,
                                    3,
                                    sizeof(DWORD),
                                    szStringArray,
                                    (LPVOID)&pdhStatus);
                                LocalFree( szStringArray[2] );

                                continue;
                            }
                        }
                    }
                    //
                    // Log by object paths are already processed.  For other paths with at least 
                    // one wildcard, expand the path before adding counters.
                    //

                    //
                    // Initialize the locale path buffer
                    //
                    pLocalePath = NULL;
                    if (ulLocaleBufLen == 0) {
                        ulLocaleBufLen = PDH_MAX_COUNTER_PATH + 1;

                        szLocaleBuf = (LPWSTR) G_ALLOC(ulLocaleBufLen * sizeof(WCHAR));
                        if (szLocaleBuf == NULL) {
                            dwStatus = ERROR_OUTOFMEMORY;
                            ulLocaleBufLen = 0;
                        }
                    }

                    if ( szLocaleBuf != NULL ) {
                        //
                        // Translate counter name from English to Localized.
                        //
                        ulBufSize = ulLocaleBufLen;
        
                        pdhStatus = PdhTranslateLocaleCounter(
                                        szThisPath,
                                        szLocaleBuf,
                                        &ulBufSize);
        
                        if (pdhStatus == PDH_MORE_DATA) {
                            if (szLocaleBuf) {
                                G_FREE(szLocaleBuf);
                                szLocaleBuf = NULL;
                                ulLocaleBufLen = 0;
                            }

                            szLocaleBuf = (LPWSTR) G_ALLOC(ulBufSize * sizeof(WCHAR));
                            if (szLocaleBuf != NULL) {
                                ulLocaleBufLen = ulBufSize;

                                pdhStatus = PdhTranslateLocaleCounter(
                                                szThisPath,
                                                szLocaleBuf,
                                                &ulBufSize);
                            }
                            else {
                                dwStatus = ERROR_OUTOFMEMORY;
                            }
                        }

                        if (pdhStatus == ERROR_SUCCESS) {
                            pLocalePath = szLocaleBuf;
                        }
                    }

                    if (pLocalePath) {
                        ulBufLen          = INSTBUFLEN;
                        nCounterBufRetry  = 10;   // the retry counter

                        do {
                            //
                            // pszCounterBuf is always NULL the first time through.
                            //
                            if ( NULL != pszCounterBuf ) {
                                G_FREE(pszCounterBuf);
                                pszCounterBuf = NULL;
                                ulBufLen *= 2;
                            }

                            pszCounterBuf = (WCHAR*) G_ALLOC(ulBufLen * sizeof(WCHAR));
                            if (pszCounterBuf == NULL) {
                                dwStatus = ERROR_OUTOFMEMORY;
                                break;
                            }
                
                            pdhStatus = PdhExpandWildCardPath (
                                NULL,
                                pLocalePath,
                                pszCounterBuf,
                                &ulBufLen,
                                dwPdhExpandFlags);
                            nCounterBufRetry--;
                        } while ((pdhStatus == PDH_MORE_DATA) && (nCounterBufRetry));
    

                        if (ERROR_SUCCESS == pdhStatus && ERROR_SUCCESS == dwStatus ) {
                            //
                            // Add path. 
                            //
                            for (pszCounter = pszCounterBuf;
                                *pszCounter != 0;
                                pszCounter += lstrlen(pszCounter) + 1) {

                                dwStatus = AddCounterToCounterLog ( pArg, pszCounter, pArg->hQuery, LOG_EVENT_ON_ERROR, &dwCounterCount );
                                if ( ERROR_OUTOFMEMORY == dwStatus ) {
                                    break;
                                }
                            }
                        }
                        if ( NULL != pszCounterBuf ) {
                            G_FREE(pszCounterBuf);
                            pszCounterBuf = NULL;
                        }
                    }
                }

                if ( ERROR_OUTOFMEMORY == dwStatus ) {

                    szStringArray[0] = pArg->szQueryName;
                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_UNABLE_ALLOC_LOG_MEMORY,
                        NULL,
                        1,
                        0,
                        szStringArray,
                        NULL);
                    bRun = FALSE;
                } // Other errors reported within the loop
            }

            if (szLocaleBuf) {
                G_FREE(szLocaleBuf);
                szLocaleBuf = NULL;
            }
            if ( bRun ) {

                if ( 0 < dwCounterCount ) {
                    //
                    // Raise priority to make sure we get to log the data.
                    //
                    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
                } else {
                    //
                    // Unable to add any counters.
                    //
                    bRun = FALSE;

                    szStringArray[0] = pArg->szQueryName;
                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_UNABLE_ADD_ANY_COUNTERS,
                        NULL,
                        1,
                        0,
                        szStringArray,
                        NULL);

                }
            }

            while (bRun) {
                
                //
                // Wait until specified start time, or until exit or reconfig event.
                //
                if ( 0 < liStartDelayTics.QuadPart ) {
                    //
                    // NtWaitForMultipleObjects requires negative Tic value
                    //
                    liStartDelayTics.QuadPart = ((LONGLONG)(0)) - liStartDelayTics.QuadPart;

                    if ( STATUS_TIMEOUT != NtWaitForMultipleObjects ( 
                                                2, 
                                                &arrEventHandle[0], 
                                                WaitAny,
                                                FALSE, 
                                                &liStartDelayTics)) {
                        bRun = FALSE;
                        break;  // if we're not supposed to be running then bail out
                    }
                }
                //
                // Compute session sample count.
                // 0 samples signals no limit.
                // -1 samples signals exit immediately, because stop time is past.
                //
                ComputeSampleCount( pArg, TRUE, &llSessionSampleCount );

                if ( (LONGLONG)(-1) == llSessionSampleCount ) {
                    goto ProcessCounterRepeat;
                }

                //
                // Set session or cnf file size limit.
                //
                if ( SLQ_DISK_MAX_SIZE != pArg->dwMaxFileSize ) {
                    if (pArg->dwLogFileType == SLF_SQL_LOG) {
                        dwFileSizeLimit = pArg->dwMaxFileSize;
                    }
                    else {
                        dwFileSizeLimit = pArg->dwMaxFileSize * pArg->dwLogFileSizeUnit;    
                    }
                }
                else {
                    dwFileSizeLimit = 0;
                }

                //
                // 0 file size signals no limit.
                // Translate from DWORD to ULONGLONG instead of LONGLONG to preserve 
                // positive value, even if high bit of dword is used.
                //
                ullFileSizeLimit = ((ULONGLONG)(dwFileSizeLimit));

                ComputeSampleCount( pArg, FALSE, &llCnfSampleCount );
                if ( (LONGLONG)(-1) == llCnfSampleCount ) {
                    // Todo cnf:  Internal program error, report error and exit.
                    bRun = FALSE;
                    break;
                }

                if ( SLQ_AUTO_MODE_AFTER == pArg->stiCreateNewFile.dwAutoMode 
                    || SLQ_AUTO_MODE_SIZE == pArg->stiCreateNewFile.dwAutoMode ) {
                    iCnfSerial = 1;
                } else {
                    assert ( SLQ_AUTO_MODE_NONE == pArg->stiCreateNewFile.dwAutoMode );
                    iCnfSerial = 0;
                }

                dwSessionSerial = pArg->dwCurrentSerialNumber;

                BuildCurrentLogFileName (
                    pArg->szQueryName,
                    pArg->szBaseFileName,
                    pArg->szLogFileFolder,
                    pArg->szSqlLogName,
                    szCurrentLogFile,
                    &dwSessionSerial,
                    pArg->dwAutoNameFormat,
                    pArg->dwLogFileType,
                    iCnfSerial++ );

                //
                // Update log serial number if modified.
                //
                if (pArg->dwAutoNameFormat == SLF_NAME_NNNNNN) {
                
                    pArg->dwCurrentSerialNumber++;
                    // Todo:  Info event on number wrap.
                    if ( MAXIMUM_SERIAL_NUMBER < pArg->dwCurrentSerialNumber ) {
                        pArg->dwCurrentSerialNumber = MINIMUM_SERIAL_NUMBER;
                    }

                    dwStatus = RegSetValueEx (
                        pArg->hKeyQuery,
                        L"Log File Serial Number",
                        0L,
                        REG_DWORD,
                        (LPBYTE)&pArg->dwCurrentSerialNumber,
                        sizeof(DWORD));

                    assert ( ERROR_SUCCESS == dwStatus );
                }

                SetPdhOpenOptions ( pArg, &dwPdhAccessFlags, &dwPdhLogFileType );

                //
                // Create new file loop.
                //
                while ( bRun && (LONGLONG)(-1) != llSessionSampleCount ) {
                    assert ( (LONGLONG)(-1) != llCnfSampleCount );
                    //
                    // Compute cnf or session loop interval.
                    //
                    if ( (LONGLONG)(0) == llCnfSampleCount 
                            || ( (LONGLONG)(0) != llSessionSampleCount
                                    && llCnfSampleCount > llSessionSampleCount ) ) 
                    {   
                        //
                        // No need to create new file within session.
                        //
                        llLoopSampleCount = llSessionSampleCount;
                        //
                        // Specify exit after first loop if not cnf by size.
                        //
                        if ( SLQ_AUTO_MODE_SIZE != pArg->stiCreateNewFile.dwAutoMode ) {
                            llSessionSampleCount = (LONGLONG)(-1);
                        }
                    } else {
                        //
                        // Create new file by time before session ends.
                        //
                        llLoopSampleCount = llCnfSampleCount;
                        if ( (LONGLONG)(0) != llSessionSampleCount ) {
                            llSessionSampleCount -= llCnfSampleCount;
                            // todo cnf:  The following should be logically impossible,
                            // because session > newfile wait.
                            if ( llSessionSampleCount <= (LONGLONG)(0) ) {
                                llSessionSampleCount = (LONGLONG)(-1);
                            }
                        }
                    }

                    __try {
                        //
                        // Open log file using this query.
                        // For text files, max size is checked after each data collection
                        //
                        pdhStatus = PdhOpenLog (
                            szCurrentLogFile,
                            dwPdhAccessFlags,
                            &dwPdhLogFileType,
                            pArg->hQuery,
                            (   SLF_BIN_CIRC_FILE == pArg->dwLogFileType
                             || SLF_BIN_FILE == pArg->dwLogFileType
                             || SLF_SQL_LOG == pArg->dwLogFileType )
                                    ? dwFileSizeLimit
                                    : 0,                                  
                            ( ( PDH_LOG_TYPE_BINARY != dwPdhLogFileType ) ? pArg->szLogFileComment : NULL ),
                            &pArg->hLog);
                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }

                    if ( ERROR_SUCCESS != pdhStatus ) { 
                        //
                        // Unable to open log file.
                        //
                        dwStatus = GetLastError();
                        szStringArray[0] = szCurrentLogFile;
                        szStringArray[1] = pArg->szQueryName;
                        szStringArray[2] = FormatEventLogMessage(dwStatus);

                        ReportEvent (hEventLog,
                            EVENTLOG_WARNING_TYPE,
                            0,
                            SMLOG_UNABLE_OPEN_LOG_FILE,
                            NULL,
                            3,
                            sizeof(DWORD),
                            szStringArray,
                            (LPVOID)&dwStatus);

                        LocalFree( szStringArray[2] );

                        bRun = FALSE; // exit now
                        break;
                    } else {

                        RegisterCurrentFile( pArg->hKeyQuery, szCurrentLogFile, 0 );

                        pArg->dwCurrentState = SLQ_QUERY_RUNNING;
                        dwStatus = WriteRegistryDwordValue (
                                    pArg->hKeyQuery, 
                                    (LPCWSTR)L"Current State",
                                    &pArg->dwCurrentState,
                                    REG_DWORD );
                        assert (dwStatus == ERROR_SUCCESS);
                
                        szStringArray[0] = pArg->szQueryName;
                        szStringArray[1] = szCurrentLogFile;
                        ReportEvent (hEventLog,
                            EVENTLOG_INFORMATION_TYPE,
                            0,
                            SMLOG_LOGGING_QUERY,
                            NULL,
                            2,
                            0,
                            szStringArray,
                            NULL);
                    } 

                    //
                    // Start sampling immediately. liSampleDelayTics is initialized to 0.
                    //
                    while ( STATUS_TIMEOUT == NtWaitForMultipleObjects ( 
                                                2, 
                                                &arrEventHandle[0], 
                                                WaitAny,
                                                FALSE, 
                                                &liSampleDelayTics)) {
                        //    
                        // An event flag will be set when the sampling should exit or reconfigure. if
                        // the wait times out, then that means it's time to collect and
                        // log another sample of data.
                        //
            
                        GetLocalFileTime (&llStartTime);
                        //
                        // Check for reconfig event.
                        if ( pArg->bLoadNewConfig ) {
                            bRun = FALSE;
                            break;
                        }

                        pdhStatus = PdhUpdateLog (pArg->hLog, pArg->szLogFileComment );

                        if ( IsPdhDataCollectSuccess ( pdhStatus ) 
                            || IsWarningSeverity ( pdhStatus ) ) {
                            //
                            // See if it's time to restart or end the log.
                            // 0 samples signals no sample limit.
                            //
                            if ( ((LONGLONG)0) != llLoopSampleCount ) {
                                if ( !--llLoopSampleCount ) 
                                    break;
                            }

                            if ( ( ((ULONGLONG)0) != ullFileSizeLimit ) 
                                && ( SLF_BIN_CIRC_FILE != pArg->dwLogFileType ) ) {
                                //
                                // See if the file is too big.
                                //
                                pdhStatus = PdhGetLogFileSize (pArg->hLog, &llFileSize);
                                if (pdhStatus == ERROR_SUCCESS) {
                                    if (ullFileSizeLimit <= (ULONGLONG)llFileSize) 
                                        break;
                                }
                            }
            
                        
                        } else {
                            //
                            // Unable to update the log.
                            //
                            szStringArray[0] = pArg->szQueryName;
                            szStringArray[1] = FormatEventLogMessage(pdhStatus);
                            ReportEvent (hEventLog,
                                EVENTLOG_WARNING_TYPE,
                                0,
                                SMLOG_UNABLE_UPDATE_LOG,
                                NULL,
                                2,
                                sizeof(DWORD),
                                szStringArray,
                                (LPVOID)&pdhStatus);

                            LocalFree( szStringArray[1] );

                            bRun = FALSE;
                            break;
                        }

                        //
                        // Compute new timeout value.
                        //
                        GetLocalFileTime (&llFinishTime);
                        //
                        // Compute difference in tics
                        //
                        llSampleCollectionTics = llFinishTime - llStartTime;

                        llSampleIntervalTics = 
                            (LONGLONG)pArg->dwMillisecondSampleInterval*FILETIME_TICS_PER_MILLISECOND;

                        if ( llSampleCollectionTics < llSampleIntervalTics ) {
                            liSampleDelayTics.QuadPart = llSampleIntervalTics - llSampleCollectionTics;
                        } else {
                            liSampleDelayTics.QuadPart = ((LONGLONG)(0));                       
                        }
                        //
                        // NtWaitForMultipleObjects requires negative Tic value.
                        //
                        liSampleDelayTics.QuadPart = ((LONGLONG)(0)) - liSampleDelayTics.QuadPart;
                    } // end while wait keeps timing out
                
                    //
                    // Use 0 SampleDelayTics value to check for ExitEvent.
                    //
                    liSampleDelayTics.QuadPart = ((LONGLONG)(0));

                    if ( pArg->bLoadNewConfig ) {
                        bRun = FALSE;
                    } else if ( STATUS_TIMEOUT != NtWaitForSingleObject (
                                                    pArg->hExitEvent, 
                                                    FALSE, 
                                                    &liSampleDelayTics ) ) {
                        //
                        // The loop was terminated by the Exit event
                        // so clear the "run" flag to exit the loop & thread.
                        //
                        bRun = FALSE;
                    }
                    //
                    // Close log file, but keep query open.
                    //
                    PdhCloseLog (pArg->hLog, 0);
                    pArg->hLog = NULL;
                
                    if ( pArg->bLoadNewConfig )
                        break;

                    if ( pArg->szCmdFileName != NULL )
                        DoLogCommandFile (pArg, szCurrentLogFile, bRun);
            
                    if ( (LONGLONG)(-1) != llSessionSampleCount ) {
                        //
                        // Create new log name
                        //
                        BuildCurrentLogFileName (
                            pArg->szQueryName,
                            pArg->szBaseFileName,
                            pArg->szLogFileFolder,
                            pArg->szSqlLogName,
                            szCurrentLogFile,
                            &dwSessionSerial,
                            pArg->dwAutoNameFormat,
                            pArg->dwLogFileType,
                            iCnfSerial++ );

                        // Todo cnf:  report event on error;
                    }

                } // End of log file creation while loop

                // cnf Todo:  Handle break from sample loop. ?

                //
                // Exit if restart not enabled.
                //
ProcessCounterRepeat:
                if ( bRun ) {
                    bRun = ProcessRepeatOption ( pArg, &liStartDelayTics );
                }

            } // end while (bRun)

            PdhCloseQuery (pArg->hQuery);
            pArg->hQuery = NULL;
        }
        SetLastError ( ERROR_SUCCESS );

    } __except ( EXCEPTION_EXECUTE_HANDLER ) {

        bRun = FALSE;
        
        if ( NULL != pszCounterBuf ) {
            G_FREE(pszCounterBuf);
            pszCounterBuf = NULL;
        }

        if ( NULL != pArg->hLog ) {
            PdhCloseLog ( pArg->hLog, 0 );
            pArg->hLog = NULL;
        }

        if ( NULL != pArg->hQuery ) {
            PdhCloseQuery ( pArg->hQuery );
            pArg->hQuery = NULL;
        }

        SetLastError ( SMLOG_THREAD_FAILED );        
    }

    DeallocateQueryBuffers ( pArg );

    while ( NULL != pArg->pFirstCounter ) {
        pDelCI = pArg->pFirstCounter;
        pArg->pFirstCounter = pDelCI->next;
        G_FREE( pDelCI );
    }

    return bRun;
}

BOOL
TraceLogProc (
    IN    PLOG_QUERY_DATA pArg
)
{
    LARGE_INTEGER   liStartDelayTics;
    LARGE_INTEGER   liWaitTics;
    LONGLONG        llSessionWaitTics = 0;
    LONGLONG        llNewFileWaitTics = INFINITE_TICS;
    DWORD           dwStatus = ERROR_SUCCESS;
    BOOL            bRun = FALSE;
    BOOL            bStarted = FALSE;
    LPWSTR          szStringArray[4];
    INT             iCnfSerial = 0;
    ULONG           ulIndex;
    int             iEnableCount = 0;
    DWORD           dwSessionSerial;
    HANDLE          arrEventHandle[2];

    __try {

        liStartDelayTics.QuadPart = NULL_INTERVAL_TICS;
        liWaitTics.QuadPart = ((LONGLONG)(0));
        
        //
        // Read registry values.
        //
        if ( ERROR_SUCCESS == LoadQueryConfig ( pArg ) ) {
            bRun = TRUE;
        }
     
        if ( TRUE == bRun ) {
            //
            // Delay of -1 signals exit immediately.
            //
            liStartDelayTics.QuadPart = ComputeStartWaitTics ( pArg, TRUE );

            if ( NULL_INTERVAL_TICS == liStartDelayTics.QuadPart ) {
                bRun = FALSE;
            }
        }

        if ( TRUE == bRun ) {
            //
            // Stop the query if new log file folder is not valid.
            //
            bRun = ( ERROR_SUCCESS == ProcessLogFileFolder( pArg ) );
        }

        if ( bRun ) {

            ValidateCommandFilePath ( pArg );
            //
            // Raise priority to ensure that data is logged.
            //
            SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
        }


        pArg->bCallCloseTraceLogger = TRUE;
        pArg->bExitOnTermination = TRUE;
        while (bRun) {
            arrEventHandle[0] = pArg->hExitEvent;           // WAIT_OBJECT_0
            arrEventHandle[1] = pArg->hReconfigEvent;

            if ( 0 < liStartDelayTics.QuadPart ) {
                //
                // NtWaitForMultipleObjects requires negative Tic value.
                //
                liStartDelayTics.QuadPart = ((LONGLONG)(0)) - liStartDelayTics.QuadPart;
                //
                // Wait until specified start time, or until exit or reconfig event.
                //
                if ( STATUS_TIMEOUT != NtWaitForMultipleObjects ( 
                                            2, 
                                            &arrEventHandle[0],
                                            WaitAny,
                                            FALSE, 
                                            &liStartDelayTics)) {
                    //
                    // The loop was terminated by the Exit event
                    // so clear the "run" flag to exit the loop & thread.
                    //
                    bRun = FALSE;   
                    break;
                }
            }

            ComputeSessionTics( pArg, &llSessionWaitTics );
            //
            // 0 signals no session time, so exit.
            //
            if ( ((LONGLONG)(0)) == llSessionWaitTics ) {
                goto ProcessTraceRepeat;
            }

            //
            // llNewFileWaitTics defaults to -1 if no time limit.
            //
            ComputeNewFileTics( pArg, &llNewFileWaitTics );
            
            //
            // InitTraceProperties creates the current file name.
            //
            dwSessionSerial = pArg->dwCurrentSerialNumber;

            InitTraceProperties ( pArg, TRUE, &dwSessionSerial, &iCnfSerial );

            dwStatus = GetTraceQueryStatus ( pArg, NULL );

            //
            // If trace session with this name already started and successful,
            // don't create another session.
            //
        
            if ( ERROR_SUCCESS != dwStatus ) {

                dwStatus = StartTrace(
                            &pArg->LoggerHandle, 
                            pArg->szLoggerName, 
                            &pArg->Properties );
                if (dwStatus == ERROR_SUCCESS) {
                    bStarted = TRUE;
                }
                pArg->bExitOnTermination = TRUE;

                if ( ( ERROR_SUCCESS == dwStatus ) 
                     && !( pArg->Properties.EnableFlags & EVENT_TRACE_FLAG_PROCESS
                            || pArg->Properties.EnableFlags & EVENT_TRACE_FLAG_THREAD
                            || pArg->Properties.EnableFlags & EVENT_TRACE_FLAG_DISK_IO
                            || pArg->Properties.EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP ) ) {
            
                    for ( ulIndex = 0; ulIndex < pArg->ulGuidCount; ulIndex++ ) {
                        //
                        // Enable user mode and special kernel tracing.
                        //
                        dwStatus = EnableTrace (
                                    TRUE,
                                    pArg->arrpGuid[ulIndex].dwFlag,
                                    pArg->arrpGuid[ulIndex].dwLevel,
                                    &pArg->arrpGuid[ulIndex].Guid, 
                                    pArg->LoggerHandle);
                        if ( ERROR_SUCCESS == dwStatus ) {
                            iEnableCount++;
                        } else {
                            szStringArray[0] = pArg->arrpGuid[ulIndex].pszProviderName;
                            szStringArray[1] = pArg->szQueryName;
                    
                            ReportEvent (hEventLog,
                                EVENTLOG_WARNING_TYPE,
                                0,
                                SMLOG_UNABLE_ENABLE_TRACE_PROV,
                                NULL,
                                2,
                                sizeof(DWORD),
                                szStringArray,      
                                (LPVOID)&dwStatus);
                        }
                    }
            
                    if ( 0 < iEnableCount ) {
                        dwStatus = ERROR_SUCCESS;
                    } else {
                        szStringArray[0] = pArg->szQueryName;
                        ReportEvent (hEventLog,
                            EVENTLOG_WARNING_TYPE,
                            0,
                            SMLOG_TRACE_NO_PROVIDERS,
                            NULL,
                            1,
                            0,
                            szStringArray,      
                            NULL);
                        bRun = FALSE;
                    }
                }
            
                if ( bRun && ERROR_SUCCESS == dwStatus ) {

                    pArg->dwCurrentState = SLQ_QUERY_RUNNING;
                    dwStatus = WriteRegistryDwordValue (
                                pArg->hKeyQuery, 
                                (LPCWSTR)L"Current State",
                                &pArg->dwCurrentState,
                                REG_DWORD );
                    

                    szStringArray[0] = pArg->szQueryName;
                    szStringArray[1] = pArg->szLogFileName;
                    ReportEvent (hEventLog,
                        EVENTLOG_INFORMATION_TYPE,
                        0,
                        SMLOG_LOGGING_QUERY,
                        NULL,
                        2,
                        0,
                        szStringArray,
                        NULL);
                } else {
                    //
                    // StartTraceFailed 
                    // dwStatus should be ERROR_ALREADY_EXISTS if logger already started or anything else.
                    //
                    if ( ERROR_ALREADY_EXISTS == dwStatus ) {
                        szStringArray[0] = pArg->szQueryName;
                        ReportEvent (hEventLog,
                            EVENTLOG_WARNING_TYPE,
                            0,
                            SMLOG_TRACE_ALREADY_RUNNING,
                            NULL,
                            1,
                            0,
                            szStringArray,      
                            NULL);
                    } else {
                        szStringArray[0] = pArg->szQueryName;
                        ReportEvent (hEventLog,
                            EVENTLOG_WARNING_TYPE,
                            0,
                            SMLOG_UNABLE_START_TRACE,
                            NULL,
                            1,
                            sizeof(DWORD),
                            szStringArray,      
                            (LPVOID)&dwStatus );
                    }
            
                    bRun = FALSE;
                }
            } else {
                //
                // This means that QueryTrace returned Error Success.
                // The specified logger is already running. 
                //
                szStringArray[0] = pArg->szQueryName;
            
                ReportEvent (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    SMLOG_TRACE_ALREADY_RUNNING,
                    NULL,
                    1,
                    0,
                    szStringArray,      
                    NULL);

                bRun = FALSE;
            }

            if ( TRUE == bRun ) {
                //    
                // Trace logger is now running.
                //
                // Exit when:  
                //  Wait times out,
                //  Exit event signaled, or
                //  Reconfig event signaled.                
                //
                // -1 wait time signals no limit.
                //
                // Loop wait intervals, calculating interval before each wait.
                //
                while ( ((LONGLONG)(0)) != llSessionWaitTics ) {

                    //
                    // Calculate wait interval.
                    //
                    if ( INFINITE_TICS == llNewFileWaitTics 
                            || ( INFINITE_TICS != llSessionWaitTics
                                    && llNewFileWaitTics > llSessionWaitTics ) ) {
                        //
                        // No need to create new file within session.
                        //
                        if ( INFINITE_TICS == llSessionWaitTics ) {
                            liWaitTics.QuadPart = llSessionWaitTics;
                            //
                            // Exit after first loop.
                            //
                            llSessionWaitTics = 0;
                        } else {
                            liWaitTics.QuadPart = llSessionWaitTics;
                            //
                            // Exit after first loop
                            //
                            llSessionWaitTics = 0;
                        }
                    } else {
                        //
                        // Create new file before session ends.
                        //
                        liWaitTics.QuadPart = llNewFileWaitTics;

                        if ( INFINITE_TICS != llSessionWaitTics ) {
                            llSessionWaitTics -= llNewFileWaitTics;
                            
                            // todo cnf:  The following should be logically impossible,
                            // because session > newfile wait.
                            if ( 0 > llSessionWaitTics ) {
                                llSessionWaitTics = 0;
                            }
                        }
                    }
                    //
                    // NtWaitForMultipleObjects requires negative Tic value.
                    //
                    if ( INFINITE_TICS != liWaitTics.QuadPart ) {
                        liWaitTics.QuadPart = ((LONGLONG)(0)) - liWaitTics.QuadPart;
                    }
            
                    if ( STATUS_TIMEOUT != NtWaitForMultipleObjects ( 
                                            2, 
                                            arrEventHandle,
                                            WaitAny,
                                            FALSE, 
                                            ( INFINITE_TICS != liWaitTics.QuadPart ) ? &liWaitTics : NULL )) 
                    {
                        bRun = FALSE;
                        break;
                    } else {
                        //
                        // If cnf by time, llNewFileWaitTics will not be infinite.
                        //
                        if ( INFINITE_TICS != llNewFileWaitTics 
                            && ((LONGLONG)(0)) != llSessionWaitTics ) {
                            //
                            // Time to create a new file. Don't update the autoformat
                            // serial number.  Use the initial autoformat serial number
                            //
                            InitTraceProperties ( pArg, FALSE, &dwSessionSerial, &iCnfSerial );
                            dwStatus = UpdateTrace(
                                        pArg->LoggerHandle, 
                                        pArg->szLoggerName, 
                                        &pArg->Properties );
                            // Todo cnf report event on bad status.
                        }
                    }
                }
            }

            if (bStarted == TRUE) {
                if (bRun) {
                    pArg->bExitOnTermination = FALSE;
                }
                    
                if (pArg->bCallCloseTraceLogger) {
                    //
                    // Stop the query.
                    //
                    CloseTraceLogger ( pArg );
                }
                else {
                    pArg->bCallCloseTraceLogger = TRUE;
                }
            }
                
            if ( pArg->bLoadNewConfig )
                break;

            if ( pArg->szCmdFileName != NULL )
                DoLogCommandFile (pArg, pArg->szLogFileName, bRun);

            //
            // If restart not enabled, then exit.
            //
ProcessTraceRepeat:
            if ( bRun ) {
                bRun = ProcessRepeatOption ( pArg, &liStartDelayTics );
            }

        } // end while (bRun)

        SetLastError ( ERROR_SUCCESS );
   
    } __except ( EXCEPTION_EXECUTE_HANDLER ) {

        CloseTraceLogger ( pArg );
        bRun = FALSE;
        SetLastError ( SMLOG_THREAD_FAILED );
    }

    return bRun;
}


DWORD
LoggingThreadProc (
    IN    LPVOID    lpThreadArg
)
{
    PLOG_QUERY_DATA     pThreadData = (PLOG_QUERY_DATA)lpThreadArg;
    DWORD               dwStatus = ERROR_SUCCESS;
    HRESULT             hr = NOERROR;
    BOOL                bContinue = TRUE;
    LPWSTR              szStringArray[2];

    if (pThreadData != NULL) {

        __try {

            hr = PdhiPlaRunAs( pThreadData->szQueryName, NULL, &pThreadData->hUserToken );

            if( ERROR_SUCCESS != hr ){
                szStringArray[0] = pThreadData->szQueryName;
                ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_INVALID_CREDENTIALS,
                        NULL,
                        1,
                        sizeof(HRESULT),
                        szStringArray,
                        (LPVOID)&hr
                    );

                return hr;
            }

            do {
                if (pThreadData->dwLogType == SLQ_ALERT) {
                    bContinue = AlertProc (pThreadData);
                } else if (pThreadData->dwLogType == SLQ_COUNTER_LOG) {
                    bContinue = CounterLogProc (pThreadData);
                } else if (pThreadData->dwLogType == SLQ_TRACE_LOG) {
                    bContinue = TraceLogProc (pThreadData);
                } else {
                    //
                    // Incorrect log type for this function.
                    //
                    assert (FALSE); 
                }
                //
                // Determine if this thread was paused for reloading
                // or stopped to terminate
                //
                if (pThreadData->bLoadNewConfig) {
                    //
                    // Reset the reconfig flag and event.
                    //
                    bContinue = TRUE;
                    pThreadData->bLoadNewConfig = FALSE;
					ResetEvent ( pThreadData->hReconfigEvent );
                } // else  bContinue is always returned as FALSE
                  // so that will terminate this loop
            } while (bContinue);
            
            dwStatus = GetLastError();

        } __except ( EXCEPTION_EXECUTE_HANDLER ) {
            dwStatus = SMLOG_THREAD_FAILED;
        }

    } else {
        //
        // Unable to find data block so return.
        //
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    if ( ERROR_SUCCESS != dwStatus ) {       
        szStringArray[0] = pThreadData->szQueryName;
        ReportEvent (
            hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            dwStatus,
            NULL,
            1,
            0,
            szStringArray,
            NULL
        );
    }
        
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogsvc\smlogsvc.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    smlogsvc.c

Abstract:

    service to log performance counter and trace data,
    and to scan for alert conditions.
--*/

#ifndef UNICODE
#define UNICODE     1
#endif

#ifndef _UNICODE
#define _UNICODE    1
#endif

#ifndef _IMPLEMENT_WMI 
#define _IMPLEMENT_WMI 1
#endif

//
//  Windows Include files
//
#pragma warning ( disable : 4201)
#pragma warning ( disable : 4127)

// Define the following to use the minimum of shlwapip.h 

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wtypes.h>
#include <limits.h>

#if _IMPLEMENT_WMI
#include <wmistr.h>
#include <objbase.h>
#include <initguid.h>
#include <evntrace.h>
#include <wmiguid.h>
#include <wmium.h>
#include <pdhmsg.h>        // For BuildCurrentLogFileName
#include <pdhp.h>
#endif

#include <assert.h>
#include <limits.h>
#include <strsafe.h>
#include "common.h"
#include "smlogsvc.h"
#include "smlogmsg.h"

#define  DEFAULT_LOG_FILE_FOLDER    L"%SystemDrive%\\PerfLogs"
#define  STATUS_MASK    ((DWORD)0x3FFFFFFF)

// todo:  Move SECONDS_IN_DAY definition
#define SECONDS_IN_DAY      ((LONGLONG)(86400))

// Global variables used by all modules
HANDLE      hEventLog = NULL;
HINSTANCE   hModule = NULL;
DWORD*      arrPdhDataCollectSuccess = NULL;  
INT         iPdhDataCollectSuccessCount = 0;
WCHAR       gszDefaultLogFileFolder[MAX_PATH+1] = L"";

// hNewQueryEvent is signalled when a new query is started.  This tells the main
// thread to reconfigure its array of Wait objects. 
HANDLE      hNewQueryEvent = NULL;    

SERVICE_STATUS_HANDLE   hSmLogStatus;
SERVICE_STATUS          ssSmLogStatus;

// Static variables used by this module only

static PLOG_QUERY_DATA  pFirstQuery = NULL;
static CRITICAL_SECTION QueryDataLock;
static CRITICAL_SECTION ConfigurationLock;

// Active session count should match the number of query data objects.
static DWORD                dwActiveSessionCount = 0;
static DWORD                dwMaxActiveSessionCount = MAXIMUM_WAIT_OBJECTS - 1;
static HANDLE               arrSessionHandle[MAXIMUM_WAIT_OBJECTS];


// Local function prototypes
DWORD
LoadCommonConfig(
    IN  PLOG_QUERY_DATA   pQuery);

void 
LockQueryData ( void );

void 
UnlockQueryData ( void );

PLOG_QUERY_DATA
GetQueryData (
    LPCWSTR  szQueryName );

void 
FreeQueryData (
    IN PLOG_QUERY_DATA pQuery );

void 
RemoveAndFreeQueryData (
    HANDLE hThisQuery );

BOOL
AlertFieldsMatch (
    IN PLOG_QUERY_DATA pFirstQuery,
    IN PLOG_QUERY_DATA pSecondQuery );

BOOL
CommonFieldsMatch (
    IN PLOG_QUERY_DATA pFirstQuery,
    IN PLOG_QUERY_DATA pSecondQuery );

BOOL
FieldsMatch (
    IN PLOG_QUERY_DATA pFirstQuery,
    IN PLOG_QUERY_DATA pSecondQuery );

DWORD 
ConfigureQuery (
    HKEY    hKeyLogQuery,
    WCHAR*  szQueryKeyNameBuffer,
    WCHAR*  szQueryNameBuffer );

void 
ClearTraceProperties (
    IN PLOG_QUERY_DATA pQuery );

BOOL
TraceStopRestartFieldsMatch (
    IN PLOG_QUERY_DATA pOrigQuery,
    IN PLOG_QUERY_DATA pNewQuery );

DWORD
ReconfigureQuery (
    IN PLOG_QUERY_DATA pQuery );

DWORD
StartQuery (
    IN PLOG_QUERY_DATA pQuery );

DWORD
HandleMaxQueriesExceeded (
    IN PLOG_QUERY_DATA pQuery );

DWORD
InitTraceGuids(
    IN PLOG_QUERY_DATA pQuery );

BOOL
IsKernelTraceMode (
    IN DWORD dwTraceFlags );

DWORD
LoadPdhLogUpdateSuccess ( void );

void
LoadDefaultLogFileFolder ( void );


#if _IMPLEMENT_WMI

DWORD
IsCreateNewFile (
    IN  PLOG_QUERY_DATA pQuery,
    OUT BOOL*           pbValidBySize, 
    OUT BOOL*           pbValidByTime ); 

ULONG
TraceNotificationCallback(
    IN PWNODE_HEADER pWnode, 
    IN UINT_PTR LogFileIndex )
{
    UNREFERENCED_PARAMETER(LogFileIndex);

    if ( NULL != pWnode ) {
    
        if (   (IsEqualGUID(& pWnode->Guid, & TraceErrorGuid))
            && (pWnode->BufferSize >= (sizeof(WNODE_HEADER) + sizeof(ULONG))))
        {
            ULONG           LoggerId = (ULONG) pWnode->HistoricalContext;
            PLOG_QUERY_DATA pQuery   = pFirstQuery;
            ULONG           Status   = * ((ULONG *)
                                   (((PUCHAR) pWnode) + sizeof(WNODE_HEADER)));
            LOG_QUERY_DATA lqdTemp;
            HRESULT hr = ERROR_SUCCESS;
            DWORD   dwStatus = ERROR_SUCCESS;
    
            LockQueryData();

            while ( NULL != pQuery ) {
                if (pQuery->Properties.Wnode.HistoricalContext == LoggerId) {
                    break;
                }
                pQuery = pQuery->next;
            }

            if ( NULL != pQuery ) {

                if ( STATUS_LOG_FILE_FULL == Status) {
                    LPWSTR  szStringArray[2];

                    szStringArray[0] = pQuery->szQueryName;
                    szStringArray[1] = FormatEventLogMessage(Status);
                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_UNABLE_UPDATE_LOG,
                        NULL,
                        2,
                        sizeof(DWORD),
                        szStringArray,
                        (LPVOID)&Status);

                    LocalFree( szStringArray[1] );
                } else if (STATUS_THREAD_IS_TERMINATING == Status) {
                    if (pQuery->bExitOnTermination) {
                        pQuery->bCallCloseTraceLogger = FALSE;
                        SetEvent (pQuery->hExitEvent);
                    } else {
                        pQuery->bExitOnTermination = TRUE;
                    }
                } else if ( STATUS_MEDIA_CHANGED == Status ) {
        
                    BOOL bRun = TRUE;

                    if( pQuery->hUserToken == NULL ){
                        // see if we can get a user token
                        hr = PdhiPlaRunAs( pQuery->szQueryName, NULL, &pQuery->hUserToken );

                        if ( ERROR_SUCCESS != hr ){
                            LPWSTR  szStringArray[1];
                            szStringArray[0] = pQuery->szQueryName;
                            ReportEvent (hEventLog,
                                    EVENTLOG_WARNING_TYPE,
                                    0,
                                    SMLOG_INVALID_CREDENTIALS,
                                    NULL,
                                    1,
                                    sizeof(HRESULT),
                                    szStringArray,
                                    (LPVOID)&hr
                                );
                            bRun = FALSE;
                        } 
                    }
                    // Run command file, supplying previous filename
                    if ( bRun && NULL != pQuery->szCmdFileName ) {
                        DoLogCommandFile (pQuery, pQuery->szLogFileName, TRUE);
                    }

                    // Retrieve the current log file name for the next notification.
                    dwStatus = GetTraceQueryStatus ( pQuery, &lqdTemp );

                    if ( ERROR_SUCCESS == dwStatus ) {
                        size_t  cchMaxBufLen;
                        //
                        // Truncation is not an error. Only used to record name
                        // in registry for display 
                        //
                        hr = StringCchLength ( pQuery->szLogFileName, MAX_PATH+1, &cchMaxBufLen );
                        hr = StringCchCopy ( pQuery->szLogFileName, cchMaxBufLen, lqdTemp.szLogFileName );
                        
                        RegisterCurrentFile( pQuery->hKeyQuery, pQuery->szLogFileName, 0 );
                    } // else todo: report error

                    // Query to get the new filename
                } else {
                    // report error
                }
            }
            UnlockQueryData();
        }
    }

    return ERROR_SUCCESS;
}
#endif


// Functions

DWORD
GetSystemWideDefaultNullDataSource()
{
    static BOOLEAN bRead            = FALSE;
    static DWORD   dwNullDataSource = DATA_SOURCE_REGISTRY;

    if (bRead == FALSE) {
        HKEY  hKeyPDH  = NULL;
        DWORD dwStatus;
        DWORD dwType   = 0;
        DWORD dwSize   = sizeof(DWORD);

        // 
        // On failure, default to Registry.
        //
        dwStatus = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\PDH",
                0L,
                KEY_READ,
                & hKeyPDH);
        if (dwStatus == ERROR_SUCCESS) {
            dwStatus = RegQueryValueExW(
                            hKeyPDH,
                            L"DefaultNullDataSource",
                            NULL,
                            & dwType,
                            (LPBYTE) & dwNullDataSource,
                            & dwSize);
            if (   dwStatus == ERROR_SUCCESS
                && dwType == REG_DWORD
                && dwNullDataSource == DATA_SOURCE_WBEM) {
                dwNullDataSource = DATA_SOURCE_WBEM;
            } // else default to DATA_SOURCE_REGISTRY

            RegCloseKey(hKeyPDH);
        }
        bRead = TRUE;
    }
    return dwNullDataSource;
}

DWORD
ScanHexFormat(
    IN const WCHAR* Buffer,
    IN ULONG MaximumLength,
    IN const WCHAR* Format,
    ...)
/*++

Routine Description:

    Scans a source Buffer and places values from that buffer into the parameters
    as specified by Format.

Arguments:

    Buffer -
        Contains the source buffer which is to be scanned.

    MaximumLength -
        Contains the maximum length in characters for which Buffer is searched.
        This implies that Buffer need not be UNICODE_NULL terminated.

    Format -
        Contains the format string which defines both the acceptable string format
        contained in Buffer, and the variable parameters which follow.

    NOTE:  This code is from \ntos\rtl\guid.c

Return Value:

    Returns the number of parameters filled if the end of the Buffer is reached,
    else -1 on an error.

--*/
{
    va_list ArgList;
    int     FormatItems;

    va_start(ArgList, Format);
    for (FormatItems = 0;;) {
        switch (*Format) {
        case 0:
            return (*Buffer && MaximumLength) ? -1 : FormatItems;
        case '%':
            Format++;
            if (*Format != '%') {
                ULONG   Number;
                int     Width;
                int     Long;
                PVOID   Pointer;

                for (Long = 0, Width = 0;; Format++) {
                    if ((*Format >= '0') && (*Format <= '9')) {
                        Width = Width * 10 + *Format - '0';
                    } else if (*Format == 'l') {
                        Long++;
                    } else if ((*Format == 'X') || (*Format == 'x')) {
                        break;
                    }
                }
                Format++;
                for (Number = 0; Width--; Buffer++, MaximumLength--) {
                    if (!MaximumLength)
                        return (DWORD)(-1);
                    Number *= 16;
                    if ((*Buffer >= '0') && (*Buffer <= '9')) {
                        Number += (*Buffer - '0');
                    } else if ((*Buffer >= 'a') && (*Buffer <= 'f')) {
                        Number += (*Buffer - 'a' + 10);
                    } else if ((*Buffer >= 'A') && (*Buffer <= 'F')) {
                        Number += (*Buffer - 'A' + 10);
                    } else {
                        return (DWORD)(-1);
                    }
                }
                Pointer = va_arg(ArgList, PVOID);
                if (Long) {
                    *(PULONG)Pointer = Number;
                } else {
                    *(PUSHORT)Pointer = (USHORT)Number;
                }
                FormatItems++;
                break;
            }
            /* no break */
        default:
            if (!MaximumLength || (*Buffer != *Format)) {
                return (DWORD)(-1);
            }
            Buffer++;
            MaximumLength--;
            Format++;
            break;
        }
    }
}


DWORD
GUIDFromString(
    IN PUNICODE_STRING GuidString,
    OUT GUID* Guid
    )
/*++

Routine Description:

    Retrieves a the binary format of a textual GUID presented in the standard
    string version of a GUID: "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".

Arguments:

    GuidString -
        Place from which to retrieve the textual form of the GUID.

    Guid -
        Place in which to put the binary form of the GUID.

    NOTE:  This code is from \ntos\rtl\guid.c

Return Value:

    Returns ERROR_SUCCESS if the buffer contained a valid GUID, else
    ERROR_INVALID_PARAMETER if the string was invalid.

--*/
{
    USHORT    Data4[8];
    int       Count;

    WCHAR GuidFormat[] = L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}";

    for (Count = 0; Count < sizeof(Data4)/sizeof(Data4[0]); Count++) {
        Data4[Count] = 0;
    }

    if (ScanHexFormat(GuidString->Buffer, GuidString->Length / sizeof(WCHAR), GuidFormat, &Guid->Data1, &Guid->Data2, &Guid->Data3, &Data4[0], &Data4[1], &Data4[2], &Data4[3], &Data4[4], &Data4[5], &Data4[6], &Data4[7]) == -1) {
        return (DWORD)(ERROR_INVALID_PARAMETER);
    }
    for (Count = 0; Count < sizeof(Data4)/sizeof(Data4[0]); Count++) {
        Guid->Data4[Count] = (UCHAR)Data4[Count];
    }

    return ERROR_SUCCESS;
}


LPWSTR
FormatEventLogMessage(DWORD dwStatus)
{

    LPVOID lpMsgBuf = NULL;
    HINSTANCE hPdh = NULL;
    DWORD dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM;
    
    hPdh = LoadLibrary (L"PDH.DLL");    

    if (NULL != hPdh){
        dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;        
    }

    FormatMessage( 
        dwFlags,
        hPdh,
        dwStatus,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPWSTR)&lpMsgBuf,
        MAX_PATH,
        NULL );
    
    if ( NULL != hPdh ) {
        FreeLibrary( hPdh );
    }

    return lpMsgBuf;
}


BOOL
IsKernelTraceMode (
    IN DWORD dwTraceFlags )
{
    BOOL bReturn = FALSE;
    DWORD dwKernelMask = SLQ_TLI_ENABLE_KERNEL_TRACE
                            | SLQ_TLI_ENABLE_KERNEL_TRACE          
                            | SLQ_TLI_ENABLE_MEMMAN_TRACE          
                            | SLQ_TLI_ENABLE_FILEIO_TRACE        
                            | SLQ_TLI_ENABLE_PROCESS_TRACE       
                            | SLQ_TLI_ENABLE_THREAD_TRACE        
                            | SLQ_TLI_ENABLE_DISKIO_TRACE        
                            | SLQ_TLI_ENABLE_NETWORK_TCPIP_TRACE;

    bReturn = ( dwKernelMask & dwTraceFlags ) ? TRUE : FALSE;

    return bReturn;
}

long
JulianDateFromSystemTime(
    SYSTEMTIME *pST )
{
    static WORD wDaysInRegularMonth[] = {
        31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
    };

    static WORD wDaysInLeapYearMonth[] = {
        31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366
    };

    long JDate = 0;

    // Check for leap year.
    if (pST->wMonth > 1) {
        if ( ( pST->wYear % 400 == 0 )
                || ( pST->wYear % 100 != 0 
                        && pST->wYear % 4 == 0 ) ) {
            // this is a leap year
            JDate += wDaysInLeapYearMonth[pST->wMonth - 2];
        } else {
            // this is not a leap year
            JDate += wDaysInRegularMonth[pST->wMonth - 2];
        }
    }
    // Add in days for this month.
    JDate += pST->wDay;

    // Add in year.
    JDate += (pST->wYear) * 1000;

    return JDate;
}


DWORD
ReadRegistrySlqTime (
    HKEY     hKey,
    LPCWSTR  szQueryName,           // For error logging 
    LPCWSTR  szValueName,
    PSLQ_TIME_INFO pPlqtDefault,
    PSLQ_TIME_INFO pPlqtValue
)
//
//  reads the time value "szValueName" from under hKey and
//  returns it in the Value buffer
//
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    DWORD   dwBufferSize = 0;

    SLQ_TIME_INFO   plqLocal;

    assert (pPlqtValue != NULL);
    assert (szValueName != NULL);

    if (hKey != NULL) {
        // then there should be something to read
        // find out the size of the required buffer
        dwStatus = RegQueryValueExW (
            hKey,
            szValueName,
            NULL,
            &dwType,
            NULL,
            &dwBufferSize);
        if (dwStatus == ERROR_SUCCESS) {
            if ((dwBufferSize == sizeof(SLQ_TIME_INFO)) && (dwType == REG_BINARY)) {
                // then there's something to read
                dwType = 0;
                memset (&plqLocal, 0, sizeof(SLQ_TIME_INFO));
                dwStatus = RegQueryValueExW (
                    hKey,
                    szValueName,
                    NULL,
                    &dwType,
                    (LPBYTE)&plqLocal,
                    &dwBufferSize);

                if ( ERROR_SUCCESS == dwStatus ) {
                    *pPlqtValue = plqLocal;
                }
            } else {
                // nothing to read                
                dwStatus = ERROR_NO_DATA;
            }
        } else {
            // unable to read buffer
            // dwStatus has error
        }
    } else {
        // null key
        dwStatus = ERROR_BADKEY;
    }

    if (dwStatus != ERROR_SUCCESS) {
        LPCWSTR  szStringArray[2];
        szStringArray[0] = szValueName;
        szStringArray[1] = szQueryName;

        // apply default if it exists
        if (pPlqtDefault != NULL) {
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                SMLOG_UNABLE_READ_QUERY_VALUE,
                NULL,
                2,
                sizeof(DWORD),
                szStringArray,      
                (LPVOID)&dwStatus);

            *pPlqtValue = *pPlqtDefault;
            dwStatus = ERROR_SUCCESS;
        } 
        // else no default.
        // Leave it to the caller to log event.
    }

    return dwStatus;
}


DWORD
ReadRegistryDwordValue (
    HKEY     hKey,
    LPCWSTR  szQueryName,
    LPCWSTR  szValueName,
    PDWORD   pdwDefault,
    LPDWORD  pdwValue
)
//
//  reads the DWORD value "szValueName" from under hKey and
//  returns it in the Value buffer
//
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    DWORD   dwBufferSize = 0;
    DWORD   dwRegValue;

    assert (pdwValue != NULL);
    assert (szValueName != NULL);

    if (hKey != NULL) {
        // then there should be something to read
        // find out the size of the required buffer
        dwStatus = RegQueryValueExW (
            hKey,
            szValueName,
            NULL,
            &dwType,
            NULL,
            &dwBufferSize);
        if (dwStatus == ERROR_SUCCESS) {
            if ( (dwBufferSize == sizeof(DWORD)) 
                && ( (REG_DWORD == dwType) || ( REG_BINARY == dwType) ) ) {
                // then there's something to read
                dwType = 0;
                dwStatus = RegQueryValueExW (
                    hKey,
                    szValueName,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwRegValue,
                    &dwBufferSize);
                if (dwStatus == ERROR_SUCCESS) {
                    *pdwValue = dwRegValue;
                }
            } else {
                // nothing to read                
                dwStatus = ERROR_NO_DATA;
            }
        } else {
            // unable to read buffer
            // dwStatus has error
        }
    } else {
        // null key
        dwStatus = ERROR_BADKEY;
    }

    if (dwStatus != ERROR_SUCCESS) {
        LPCWSTR  szStringArray[2];
        szStringArray[0] = szValueName;
        szStringArray[1] = szQueryName;

        if (pdwDefault != NULL) {
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                SMLOG_UNABLE_READ_QUERY_VALUE,
                NULL,
                2,
                sizeof(DWORD),
                szStringArray,      
                (LPVOID)&dwStatus);

            *pdwValue = *pdwDefault;
            dwStatus = ERROR_SUCCESS;
        }   // else no default.
            // Leave it to the caller to log event.
    }

    return dwStatus;
}


DWORD
ReadRegistryStringValue (
    HKEY     hKey,
    LPCWSTR  szQueryName,
    LPCWSTR  szValueName,
    LPCWSTR  szDefault,
    LPWSTR   *pszBuffer,
    LPDWORD  pcbSize
)
//
//  Reads the string value "szValueName" from under hKey and
//  frees any existing buffer referenced by pszBuffer, 
//  then allocates a new buffer returning it with the 
//  string value read from the registry and the size of the
//  buffer in bytes. 
//
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwType = 0;
    DWORD   dwBufferSize = 0;
    size_t  cchBufLen = 0;
    WCHAR*  szNewStringBuffer = NULL;

    assert (pcbSize!= NULL);
    assert (szValueName != NULL);

    if ( NULL != pcbSize ) {
        *pcbSize = 0;
    }

    if (hKey != NULL) {
        //
        // There should be something to read.
        // Find out the size of the required buffer.
        //
        dwStatus = RegQueryValueExW (
            hKey,
            szValueName,
            NULL,
            &dwType,
            NULL,
            &dwBufferSize);
        if (dwStatus == ERROR_SUCCESS) {
            //
            // NULL character size is 2 bytes
            //
            if (dwBufferSize > 2) {
                //
                // There's something to read            
                //
                szNewStringBuffer = (WCHAR*) G_ALLOC ( dwBufferSize ); 
                if (szNewStringBuffer != NULL) {
                    dwType = 0;
                    dwStatus = RegQueryValueExW (
                        hKey,
                        szValueName,
                        NULL,
                        &dwType,
                        (LPBYTE)szNewStringBuffer,
                        &dwBufferSize);
                
                    //
                    // Ensure that the registry string is null terminated.
                    //
                    cchBufLen = dwBufferSize/sizeof(WCHAR);
                    szNewStringBuffer[cchBufLen - 1] = L'\0';
                    if ( 0 == lstrlenW ( szNewStringBuffer ) ) {
                        dwStatus = ERROR_NO_DATA;
                    }
                } else {
                    // Todo:  Report event for this case.
                    dwStatus = ERROR_OUTOFMEMORY;
                }
            } else {
                // nothing to read                
                dwStatus = ERROR_NO_DATA;
            }
        } // else unable to read buffer
          // dwStatus has error
    } else {
        // null key
        dwStatus = ERROR_BADKEY;
    }

    if (dwStatus != ERROR_SUCCESS) {
        LPCWSTR  szStringArray[2];
        szStringArray[0] = szValueName;
        szStringArray[1] = szQueryName;

        if (szNewStringBuffer != NULL) {
            G_FREE ( szNewStringBuffer ); 
            szNewStringBuffer = NULL;
            dwBufferSize = 0;
        }
        //
        // Apply default
        //
        if ( szDefault != NULL ) {
            HRESULT hr = S_OK;

            cchBufLen = 0;
            //
            // StringCchLen fails if szDefault is null.
            //
            hr = StringCchLength ( szDefault, STRSAFE_MAX_CCH, &cchBufLen );

            if ( SUCCEEDED (hr) ) {
                // Null terminator.
                cchBufLen++;
            }
            if ( 1 < cchBufLen ) {
                dwBufferSize = cchBufLen * sizeof (WCHAR);             
            
                szNewStringBuffer = (WCHAR*) G_ALLOC ( dwBufferSize );

                if (szNewStringBuffer != NULL) {
                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_UNABLE_READ_QUERY_VALUE,
                        NULL,
                        2,
                        sizeof(DWORD),
                        szStringArray,      
                        (LPVOID)&dwStatus);

                    StringCchCopy ( 
                        szNewStringBuffer,
                        cchBufLen,
                        szDefault);
                    dwStatus = ERROR_SUCCESS;
                } else {
                    dwStatus = ERROR_OUTOFMEMORY;

                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_UNABLE_READ_QUERY_DEF_VAL,
                        NULL,
                        2,
                        sizeof(DWORD),
                        szStringArray,      
                        (LPVOID)&dwStatus);
                }
            }
        } // else no default so no data returned
          // Let the caller log the event if they want to.
    }

    if (dwStatus == ERROR_SUCCESS) {
        //
        // Delete the old buffer and replace it with 
        // the new one.
        //
        if (*pszBuffer != NULL) {
            G_FREE (*pszBuffer );       
        }
        *pszBuffer = szNewStringBuffer;
        if ( NULL != pcbSize ) {
            *pcbSize = dwBufferSize;
        }
    } else {
        // if error then delete the buffer
        if (szNewStringBuffer != NULL) {
            G_FREE ( szNewStringBuffer );   
            if ( NULL != pcbSize ) {
                *pcbSize = dwBufferSize;
            }
        }
    }

    return dwStatus;
}   
        

DWORD
ReadRegistryIndirectStringValue (
    HKEY     hKey,
    LPCWSTR  szQueryName,           // For error logging 
    LPCWSTR  szValueName,
    LPCWSTR  szDefault,
    LPWSTR*  pszBuffer,
    UINT*    puiLength )
{
    DWORD dwStatus = ERROR_SUCCESS; 

    UNREFERENCED_PARAMETER(szQueryName);

    dwStatus = SmReadRegistryIndirectStringValue (
                hKey,
                szValueName,
                szDefault,       
                pszBuffer,
                puiLength );
/*
    Todo:  Report event on failure
    LPCWSTR  szStringArray[2];

    szStringArray[0] = szValueName;
    szStringArray[1] = szQueryName;

    if ( NULL != szDefault ) {

        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            SMLOG_UNABLE_READ_QUERY_VALUE_NODEF,
            NULL,
            2,
            sizeof(DWORD),
            szStringArray,      
            (LPVOID)&dwStatus);
    }
*/
    return dwStatus;
}

DWORD
WriteRegistryDwordValue (
    HKEY     hKey,
    LPCWSTR  szValueName,
    LPDWORD  pdwValue,
    DWORD    dwType   
)
{
    DWORD    dwStatus = ERROR_SUCCESS;
    DWORD   dwValue = sizeof(DWORD);

    assert ((dwType == REG_DWORD) || 
            (dwType == REG_BINARY));
    
    dwStatus = RegSetValueEx (
                hKey, 
                szValueName, 
                0L,
                dwType,
                (CONST BYTE *)pdwValue,
                dwValue);

    return dwStatus;
}


DWORD
WriteRegistrySlqTime (
    HKEY     hKey,
    LPCWSTR  szValueName,
    PSLQ_TIME_INFO  pSlqTime
)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwValue = sizeof(SLQ_TIME_INFO);

    dwStatus = RegSetValueEx (
                    hKey, 
                    szValueName, 
                    0L,
                    REG_BINARY,
                    (CONST BYTE *)pSlqTime,
                    dwValue);

    return dwStatus;
}


DWORD
BuildCurrentLogFileName (
    IN  LPCWSTR     szQueryName,
    IN  LPCWSTR     szBaseFileName,
    IN  LPCWSTR     szDefaultDir,
    IN  LPCWSTR     szSqlLogName,
    IN  LPWSTR      szOutFileBuffer,
    IN  LPDWORD     lpdwSerialNumber,
    IN  DWORD       dwAutoNameFormat,
    IN  DWORD       dwLogFileType,
    IN  INT         iCnfSerial 
)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HRESULT hr = S_OK;
    PPDH_PLA_INFO   pInfo = NULL;
    DWORD cchStrBufLen = 0;
    DWORD dwInfoSize = 0;
    DWORD dwFlags = 0;
    LPWSTR  szFileNameBuffer = NULL;

    // Todo:  Presumes OutFileBuffer is large enough (i.e. >= MAX_PATH+1)
    // Make buf length restriction explicit to calling code

    dwStatus = PdhPlaGetInfo( 
       (LPWSTR)szQueryName, 
       NULL, 
       &dwInfoSize, 
       pInfo );

    if( ERROR_SUCCESS == dwStatus && 0 != dwInfoSize ){
        pInfo = (PPDH_PLA_INFO)G_ALLOC(dwInfoSize);
        if( NULL != pInfo && (sizeof(PDH_PLA_INFO) <= dwInfoSize) ){
            ZeroMemory( pInfo, dwInfoSize );

            pInfo->dwMask = PLA_INFO_FLAG_FORMAT|
                            PLA_INFO_FLAG_FILENAME|
                            PLA_INFO_FLAG_AUTOFORMAT|
                            PLA_INFO_FLAG_TYPE|
                            PLA_INFO_FLAG_DEFAULTDIR|
                            PLA_INFO_FLAG_SRLNUMBER|
                            PLA_INFO_FLAG_SQLNAME|
                            PLA_INFO_FLAG_STATUS;

            dwStatus = PdhPlaGetInfo( 
                        (LPWSTR)szQueryName, 
                        NULL, 
                        &dwInfoSize, 
                        pInfo );
            
            pInfo->dwFileFormat = dwLogFileType;
            pInfo->strBaseFileName = (LPWSTR)szBaseFileName;
            pInfo->dwAutoNameFormat = dwAutoNameFormat;
            // PLA_INFO_FLAG_TYPE is counter log vs trace log vs alert
            
            pInfo->strDefaultDir = (LPWSTR)szDefaultDir;
            pInfo->dwLogFileSerialNumber = *lpdwSerialNumber;
            pInfo->strSqlName = (LPWSTR)szSqlLogName;

            dwFlags = PLA_FILENAME_CREATEONLY;

            // iCnfSerial = 0 - No serial suffix for Create New File
            // iCnfSerial = -1 - Include format string for trace file serial number.
            if ( 0 == iCnfSerial ) {
                pInfo->ptCreateNewFile.dwAutoMode = SLQ_AUTO_MODE_NONE;
            } else {
                dwFlags |= PLA_FILENAME_USE_SUBEXT;
                if ( -1 == iCnfSerial ) {
                    dwFlags |= PLA_FILENAME_GET_SUBFMT;
                    pInfo->ptCreateNewFile.dwAutoMode = SLQ_AUTO_MODE_SIZE;
                } else {
                    pInfo->ptCreateNewFile.dwAutoMode = SLQ_AUTO_MODE_AFTER;
                    pInfo->dwReserved1 = iCnfSerial;
                }
            }

            dwStatus = PdhPlaGetLogFileName (
                    (LPWSTR)szQueryName,
                    NULL, 
                    pInfo,
                    dwFlags,
                    &cchStrBufLen,
                    NULL );

            if ( ERROR_SUCCESS == dwStatus || PDH_INSUFFICIENT_BUFFER == dwStatus ) {
                szFileNameBuffer = G_ALLOC ((cchStrBufLen + 1) * sizeof(WCHAR));

                if (NULL != szFileNameBuffer ) {

                    dwStatus = PdhPlaGetLogFileName (
                            (LPWSTR)szQueryName,
                            NULL, 
                            pInfo,
                            dwFlags,
                            &cchStrBufLen,
                            szFileNameBuffer );

                    // todo:  Make buf length restriction explicit to calling code
                    hr = StringCchCopy ( szOutFileBuffer, (MAX_PATH + 1), szFileNameBuffer );
                    if ( FAILED ( hr ) ) {
                        // Todo: Truncation-specific error code.
                        dwStatus = HRESULT_CODE ( hr ) ;
                    }

                    G_FREE ( szFileNameBuffer );
                } else {
                    dwStatus = ERROR_OUTOFMEMORY;
                }
            }
        }
    }

    if ( NULL != pInfo ) { 
        G_FREE( pInfo );
    }

    return dwStatus;
}


BOOL
FileExists (
    IN LPCWSTR  szFileName )
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bFileExists = FALSE;
    HANDLE hFile = NULL;
    LONG lErrorMode;

    if ( NULL != szFileName ) {
        lErrorMode = SetErrorMode ( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );

        hFile = CreateFile(
                        szFileName,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,
                        NULL
                        );
        
        if (INVALID_HANDLE_VALUE == hFile ) {
            dwStatus = GetLastError();
        }

        if ( NULL != hFile 
            && INVALID_HANDLE_VALUE != hFile
            && ERROR_SUCCESS == dwStatus )
        {
            bFileExists = TRUE;
        }

        CloseHandle(hFile);
    
        SetErrorMode ( lErrorMode );
        
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    return bFileExists;
}

DWORD
LoadCommonConfig(
    IN  PLOG_QUERY_DATA   pQuery)
{
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwBufferSize = 0;
    UINT            uiBufferLen = 0;
    SLQ_TIME_INFO   stiDefault;
    DWORD           dwDefault = 0;
    DWORD           dwTempRestart;
    LONGLONG        ftLocalTime;
    DWORD           dwLocalAttributes = 0;

    // Schedule

    dwDefault = SLQ_QUERY_STOPPED;
    dwStatus = ReadRegistryDwordValue (
                pQuery->hKeyQuery, 
                pQuery->szQueryName,
                L"Current State",
                &dwDefault, 
                &pQuery->dwCurrentState);

    if ( ERROR_SUCCESS == dwStatus ) {
        //
        // Pass NULL default to avoid warning message.
        // A missing value here is normal, converting from Win2000 config.
        //
        dwStatus = ReadRegistryDwordValue (
                    pQuery->hKeyQuery, 
                    pQuery->szQueryName,
                    L"RealTime DataSource",
                    NULL, 
                    &pQuery->dwRealTimeQuery);

        if ( ERROR_NO_DATA == dwStatus 
                || ERROR_FILE_NOT_FOUND == dwStatus
                || ( 0 == pQuery->dwRealTimeQuery ) ) {
            
            pQuery->dwRealTimeQuery = GetSystemWideDefaultNullDataSource();
            dwStatus = ERROR_SUCCESS;
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {

        ftLocalTime = 0;

        GetLocalFileTime ( &ftLocalTime );

        stiDefault.wDataType = SLQ_TT_DTYPE_DATETIME;
        stiDefault.wTimeType = SLQ_TT_TTYPE_START;
        stiDefault.dwAutoMode = SLQ_AUTO_MODE_AT;
        stiDefault.llDateTime = ftLocalTime;

        dwStatus = ReadRegistrySlqTime (
                    pQuery->hKeyQuery, 
                    pQuery->szQueryName,
                    L"Start",
                    &stiDefault,
                    &pQuery->stiRegStart);
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        stiDefault.wDataType = SLQ_TT_DTYPE_DATETIME;
        stiDefault.wTimeType = SLQ_TT_TTYPE_STOP;
        stiDefault.dwAutoMode = SLQ_AUTO_MODE_NONE;
        stiDefault.llDateTime = MIN_TIME_VALUE;

        dwStatus = ReadRegistrySlqTime (
                    pQuery->hKeyQuery, 
                    pQuery->szQueryName,
                    L"Stop",
                    &stiDefault,
                    &pQuery->stiRegStop);
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        //
        // Apply default value outside of Read method, to avoid
        // error message.  This value does not exist in Windows 2000
        //
        dwStatus = ReadRegistrySlqTime (
                    pQuery->hKeyQuery, 
                    pQuery->szQueryName,
                    L"Create New File",
                    NULL,
                    &pQuery->stiCreateNewFile);

        if ( ERROR_NO_DATA == dwStatus || ERROR_FILE_NOT_FOUND == dwStatus ) {
            stiDefault.wDataType = SLQ_TT_DTYPE_UNITS;
            stiDefault.wTimeType = SLQ_TT_TTYPE_CREATE_NEW_FILE;
            stiDefault.dwAutoMode = SLQ_AUTO_MODE_NONE;
            stiDefault.dwUnitType = SLQ_TT_UTYPE_SECONDS;
            stiDefault.dwValue = 0;

            pQuery->stiCreateNewFile = stiDefault;

            dwStatus = ERROR_SUCCESS;
        }
    }
    
    //
    // Restart flag is replaced by the Repeat time structure after Windows 2000.
    //
    if ( ERROR_SUCCESS == dwStatus ) {
        // If autostop, collect Restart value.
        // Apply default value outside of Read method, to avoid
        // error message.  This value does not exist in Windows 2000
        if ( pQuery->stiRegStop.dwAutoMode != SLQ_AUTO_MODE_NONE ) {

            dwStatus = ReadRegistryDwordValue (
                        pQuery->hKeyQuery, 
                        pQuery->szQueryName,
                        L"Restart",
                        NULL, 
                        &dwTempRestart );
            if ( ERROR_NO_DATA == dwStatus || ERROR_FILE_NOT_FOUND == dwStatus ) {
                dwTempRestart = SLQ_AUTO_MODE_NONE;
                dwStatus = ERROR_SUCCESS;
            }
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        // If autostop, collect Repeat value.

        // Apply default value outside of Read method, to avoid
        // error message.  This value does not exist in Windows 2000

        if ( pQuery->stiRegStop.dwAutoMode != SLQ_AUTO_MODE_NONE ) {

            dwStatus = ReadRegistrySlqTime (
                        pQuery->hKeyQuery, 
                        pQuery->szQueryName,
                        L"Repeat Schedule",
                        NULL, 
                        &pQuery->stiRepeat );
    
            if ( ERROR_NO_DATA == dwStatus 
                    || ERROR_FILE_NOT_FOUND == dwStatus
                    || SLQ_AUTO_MODE_NONE == pQuery->stiRepeat.dwAutoMode ) 
            {    
                // If the repeat value doesn't exist or is set to NONE,
                // default to the Restart mode value: NONE or AFTER

                stiDefault.wDataType = SLQ_TT_DTYPE_UNITS;
                stiDefault.wTimeType = SLQ_TT_TTYPE_REPEAT_SCHEDULE;

                stiDefault.dwAutoMode = dwTempRestart;
                stiDefault.dwUnitType = SLQ_TT_UTYPE_MINUTES;
                stiDefault.dwValue = 0;
                
                pQuery->stiRepeat = stiDefault;

                dwStatus = ERROR_SUCCESS;
            }
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {

        ReadRegistryIndirectStringValue (
            pQuery->hKeyQuery,
            pQuery->szQueryName,
            L"Comment",
            NULL,       
            &pQuery->szLogFileComment,
            &uiBufferLen );
        
        // Ignore status, default is empty.
    }

    // Todo:  File attributes only for counter and trace logs       
    //
    // File attributes
    //
    if ( ERROR_SUCCESS == dwStatus ) {

        dwDefault = (DWORD)-1;
        dwStatus = ReadRegistryDwordValue (
                    pQuery->hKeyQuery,
                    pQuery->szQueryName,
                    L"Log File Max Size",
                    &dwDefault, 
                    &pQuery->dwMaxFileSize);    
    }

    if ( ERROR_SUCCESS == dwStatus ) {

        dwDefault = SLF_BIN_FILE; 
        dwStatus = ReadRegistryDwordValue (
                    pQuery->hKeyQuery, 
                    pQuery->szQueryName,
                    L"Log File Type",
                    &dwDefault, 
                    &pQuery->dwLogFileType);
        if (dwStatus == ERROR_SUCCESS) {
            pQuery->dwLogFileType = LOWORD(pQuery->dwLogFileType);

            // For Whistler Beta 1, append mode stored in high word of 
            // the log type registry value
            pQuery->dwAppendMode  =
                    (pQuery->dwLogFileType & 0xFFFF0000) == SLF_FILE_APPEND;
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {

        // Pass NULL default to avoid warning message.
        // A missing value here is normal, converting from Win2000 config.
        dwLocalAttributes = 0;
        dwStatus = ReadRegistryDwordValue (
                    pQuery->hKeyQuery,
                    pQuery->szQueryName,
                    L"Data Store Attributes",
                    NULL, 
                    &dwLocalAttributes );

        // Extract log file size units
        if ( ERROR_NO_DATA == dwStatus 
                || ERROR_FILE_NOT_FOUND == dwStatus
                || ( 0 == ( dwLocalAttributes & SLF_DATA_STORE_SIZE_MASK ) ) ) {
            // If file size unit value is missing, default to Win2000 values
            if ( SLQ_COUNTER_LOG == pQuery->dwLogType ) {
                if ( SLF_SQL_LOG != pQuery->dwLogFileType ) {
                    pQuery->dwLogFileSizeUnit = ONE_KB;
                } else {
                    pQuery->dwLogFileSizeUnit = ONE_RECORD;
                }
            } else if ( SLQ_TRACE_LOG == pQuery->dwLogType ) {
                pQuery->dwLogFileSizeUnit = ONE_MB;
            }
        } else {
            if ( dwLocalAttributes & SLF_DATA_STORE_SIZE_ONE_MB ) {
                pQuery->dwLogFileSizeUnit = ONE_MB;
            } else if ( dwLocalAttributes & SLF_DATA_STORE_SIZE_ONE_KB ) {
                pQuery->dwLogFileSizeUnit = ONE_KB;
            } else if ( dwLocalAttributes & SLF_DATA_STORE_SIZE_ONE_RECORD ) {
                pQuery->dwLogFileSizeUnit = ONE_RECORD;
            }
        }

        // Extract append flag if not already set by Whistler Beta 1 code
        if ( 0 == pQuery->dwAppendMode ) {
            if ( ERROR_NO_DATA == dwStatus 
                    || ERROR_FILE_NOT_FOUND == dwStatus
                    || ( 0 == ( dwLocalAttributes & SLF_DATA_STORE_APPEND_MASK ) ) ) 
            {
                // If file append mode value is missing, default to Win2000 values
                assert ( SLF_SQL_LOG != pQuery->dwLogFileType );
                if ( SLF_SQL_LOG != pQuery->dwLogFileType ) {
                    pQuery->dwAppendMode = 0;
                }
            } else {
                pQuery->dwAppendMode = ( dwLocalAttributes & SLF_DATA_STORE_APPEND );
            }
        }
        dwStatus = ERROR_SUCCESS;
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        dwDefault = SLF_NAME_NNNNNN;
        dwStatus = ReadRegistryDwordValue (
                    pQuery->hKeyQuery, 
                    pQuery->szQueryName,
                    L"Log File Auto Format",
                    &dwDefault, 
                    &pQuery->dwAutoNameFormat );
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        WCHAR   szDefault[MAX_PATH+1];

        // Dependent on AutoNameFormat setting.

        if ( SLF_NAME_NONE == pQuery->dwAutoNameFormat ) {
            //
            // Default log file name is query name, if no autoformat.
            // szDefault and szQueryName both have length MAX_PATH + 1
            //
            StringCchCopy ( szDefault, MAX_PATH + 1, pQuery->szQueryName );
        } else {
            szDefault[0] = L'\0';
        }
        
        dwStatus = ReadRegistryIndirectStringValue (
                        pQuery->hKeyQuery,
                        pQuery->szQueryName,
                        L"Log File Base Name",
                        szDefault,                      
                        &pQuery->szBaseFileName,
                        &uiBufferLen );

        if ( NULL != pQuery->szBaseFileName ) {
            ReplaceBlanksWithUnderscores ( pQuery->szBaseFileName );
        }

        //
        //  szDefault of length 0 indicates that auto format is enabled.
        //
        if ( 0 == lstrlen (szDefault) ) {
            if ( NULL != pQuery->szBaseFileName ) {
                if ( 0 == lstrlen ( pQuery->szBaseFileName ) ) {
                    // Ignore bad status if the base log file name 
                    // is NULL and auto format is enabled.
                    dwStatus = ERROR_SUCCESS;
                } else {
                    dwStatus = ERROR_SUCCESS;
                }
            } else {
                dwStatus = ERROR_SUCCESS;
            }
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        WCHAR*  pszTemp = NULL;
        DWORD   cchLen = 0;
        DWORD   cchExpandedLen = 0;

        dwStatus = ReadRegistryStringValue (
                    pQuery->hKeyQuery,
                    pQuery->szQueryName,
                    L"Log File Folder",
                    gszDefaultLogFileFolder,
                    &pszTemp,
                    &dwBufferSize );

        //    
        // Parse all environment variables
        //
        if (pszTemp != NULL) {
            cchLen = ExpandEnvironmentStrings ( pszTemp, NULL, 0 );
        
            if ( 0 < cchLen ) {
                //
                // cchLen includes NULL.
                //
                if ( NULL != pQuery->szLogFileFolder ) {
                    G_FREE (pQuery->szLogFileFolder );
                    pQuery->szLogFileFolder = NULL;
                }
                pQuery->szLogFileFolder = G_ALLOC ( cchLen * sizeof(WCHAR) );

                if ( NULL != pQuery->szLogFileFolder ) {

                    cchExpandedLen = ExpandEnvironmentStrings ( 
                                        pszTemp, 
                                        pQuery->szLogFileFolder, 
                                        cchLen );

                    if ( 0 == cchExpandedLen ) {
                        dwStatus = GetLastError();
                        pQuery->szLogFileFolder[0] = L'\0';
                    }
                } else {
                    dwStatus = ERROR_OUTOFMEMORY;
                }
            } else {
                dwStatus = GetLastError();
            }
        }
    
        if ( NULL != pszTemp ) {
            G_FREE ( pszTemp );
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        ReadRegistryStringValue (
                    pQuery->hKeyQuery,
                    pQuery->szQueryName,
                    L"Sql Log Base Name",
                    NULL,
                    &pQuery->szSqlLogName,
                    &dwBufferSize );
        // Ignore status, default is empty.
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        dwDefault = 1;
        dwStatus = ReadRegistryDwordValue (
                    pQuery->hKeyQuery, 
                    pQuery->szQueryName,
                    L"Log File Serial Number",
                    &dwDefault, 
                    &pQuery->dwCurrentSerialNumber );
    
    }

    return dwStatus;
}


DWORD
LoadQueryConfig(
    IN  PLOG_QUERY_DATA   pQuery )
{
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwBufferSize;
    UINT            uiBufferLen = 0;
    LPWSTR          szStringArray[2];
    SLQ_TIME_INFO   stiDefault;
    SLQ_TIME_INFO   stiTemp;
    DWORD           dwDefault;
    DWORD           dwType;

    dwType = REG_DWORD;
    dwBufferSize = sizeof(DWORD);
    dwStatus = RegQueryValueExW (
            pQuery->hKeyQuery,
            L"Log Type",
            NULL,
            &dwType,
            (LPBYTE)&pQuery->dwLogType,
            &dwBufferSize);

    if ( SLQ_COUNTER_LOG == pQuery->dwLogType ) {
        //
        // Counters
        //
        dwStatus = ReadRegistryStringValue (
                    pQuery->hKeyQuery,
                    pQuery->szQueryName,
                    L"Counter List", 
                    NULL,
                    &pQuery->mszCounterList,
                    &dwBufferSize );

        if ( (ERROR_SUCCESS != dwStatus ) || ( 0 == dwBufferSize ) ) {
            //
            // No counter list retrieved so there's not much
            // point in continuing
            // 
            szStringArray[0] = pQuery->szQueryName;
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                SMLOG_UNABLE_READ_COUNTER_LIST,
                NULL,
                1,
                sizeof(DWORD),
                szStringArray,      
                (LPVOID)&dwStatus);
        } else {
            //
            // EOF command file name.
            // This is used for both Counter and Trace log files.
            // Alerts use the Command file field for Alert command file.
            //
            if ( ERROR_SUCCESS == dwStatus ) {
                ReadRegistryStringValue (
                            pQuery->hKeyQuery,
                            pQuery->szQueryName,
                            L"EOF Command File",
                            NULL,
                            &pQuery->szCmdFileName,
                            &dwBufferSize );
                // Ignore status, default is empty.
            }
            //
            // Sample interval
            //
            if ( ERROR_SUCCESS == dwStatus ) {
                stiDefault.wDataType = SLQ_TT_DTYPE_UNITS;
                stiDefault.wTimeType = SLQ_TT_TTYPE_SAMPLE;
                stiDefault.dwAutoMode = SLQ_AUTO_MODE_AFTER;
                stiDefault.dwUnitType = SLQ_TT_UTYPE_SECONDS;
                stiDefault.dwValue = 15;

                dwStatus = ReadRegistrySlqTime (
                            pQuery->hKeyQuery,
                            pQuery->szQueryName,
                            L"Sample Interval",
                            &stiDefault, 
                            &stiTemp);
                if ( ERROR_SUCCESS == dwStatus ) {
                    LONGLONG llMillisecInterval;
                    TimeInfoToMilliseconds( &stiTemp, &llMillisecInterval );
                    assert ( ULONG_MAX > llMillisecInterval );
                    if ( ULONG_MAX > llMillisecInterval ) {
                        pQuery->dwMillisecondSampleInterval = (DWORD)(llMillisecInterval);
                    } else {
                        pQuery->dwMillisecondSampleInterval = ULONG_MAX - 1;
                    }
                }
            }
        }
    } else if ( SLQ_ALERT == pQuery->dwLogType) {
        //
        // Counters & alert limits
        //
        dwStatus = ReadRegistryStringValue (
                    pQuery->hKeyQuery,
                    pQuery->szQueryName,
                    L"Counter List", 
                    NULL,
                    &pQuery->mszCounterList,
                    &dwBufferSize );

        if ( (ERROR_SUCCESS != dwStatus ) || ( 0 == dwBufferSize ) ) {
            //
            // No counter list retrieved so there's not much
            // point in continuing
            //
            szStringArray[0] = pQuery->szQueryName;
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                SMLOG_UNABLE_READ_COUNTER_LIST,
                NULL,
                1,
                sizeof(DWORD),
                szStringArray,      
                (LPVOID)&dwStatus);
        } else {
            //
            // Sample interval
            //
            if ( ERROR_SUCCESS == dwStatus ) {
                stiDefault.wDataType = SLQ_TT_DTYPE_UNITS;
                stiDefault.wTimeType = SLQ_TT_TTYPE_SAMPLE;
                stiDefault.dwAutoMode = SLQ_AUTO_MODE_AFTER;
                stiDefault.dwUnitType = SLQ_TT_UTYPE_SECONDS;
                stiDefault.dwValue = 15;

                dwStatus = ReadRegistrySlqTime (
                            pQuery->hKeyQuery,
                            pQuery->szQueryName,
                            L"Sample Interval",
                            &stiDefault, 
                            &stiTemp );

                if ( ERROR_SUCCESS == dwStatus ) {
                    LONGLONG llMillisecInterval;
                    TimeInfoToMilliseconds( &stiTemp, &llMillisecInterval );
                    assert ( ULONG_MAX > llMillisecInterval );
                    if ( ULONG_MAX > llMillisecInterval ) {
                        pQuery->dwMillisecondSampleInterval = (DWORD)(llMillisecInterval);
                    } else {
                        pQuery->dwMillisecondSampleInterval = ULONG_MAX - 1;
                    }
                }
            }

            if ( ERROR_SUCCESS == dwStatus ) {
                //
                // Action flags
                //
                dwDefault = 0;
                dwStatus = ReadRegistryDwordValue (
                            pQuery->hKeyQuery,
                            pQuery->szQueryName,
                            L"Action Flags",
                            &dwDefault, 
                            &pQuery->dwAlertActionFlags);
            }

            if (( ERROR_SUCCESS == dwStatus ) && 
                ((pQuery->dwAlertActionFlags & ALRT_ACTION_SEND_MSG) != 0)) {
                dwStatus = ReadRegistryStringValue (
                            pQuery->hKeyQuery,
                            pQuery->szQueryName,
                            L"Network Name",
                            L"",
                            &pQuery->szNetName,
                            &dwBufferSize );
            }

            if (( ERROR_SUCCESS == dwStatus ) && 
                ((pQuery->dwAlertActionFlags & ALRT_ACTION_EXEC_CMD) != 0)) {
                    ReadRegistryStringValue (
                            pQuery->hKeyQuery,
                            pQuery->szQueryName,
                            L"Command File",
                            NULL,
                            &pQuery->szCmdFileName,
                            &dwBufferSize );

                if (( ERROR_SUCCESS == dwStatus ) && 
                    ((pQuery->dwAlertActionFlags & ALRT_CMD_LINE_U_TEXT) != 0)) {

                    ReadRegistryIndirectStringValue (
                                pQuery->hKeyQuery,
                                pQuery->szQueryName,
                                L"User Text",
                                L"",
                                &pQuery->szUserText,
                                &uiBufferLen );
                }
            }

            if (( ERROR_SUCCESS == dwStatus ) && 
                ((pQuery->dwAlertActionFlags & ALRT_ACTION_START_LOG) != 0)) {
                dwStatus = ReadRegistryStringValue (
                            pQuery->hKeyQuery,
                            pQuery->szQueryName,
                            L"Perf Log Name",
                            L"",
                            &pQuery->szPerfLogName,
                            &dwBufferSize );
            }
        }
    } else if ( SLQ_TRACE_LOG == pQuery->dwLogType ) {

        DWORD dwProviderStatus;
        
        dwDefault = 0;
        dwStatus = ReadRegistryDwordValue (
                        pQuery->hKeyQuery,
                        pQuery->szQueryName,
                        L"Trace Flags",
                        &dwDefault, 
                        &pQuery->dwFlags);

        dwProviderStatus = ReadRegistryStringValue (
                                pQuery->hKeyQuery,
                                pQuery->szQueryName,
                                L"Trace Provider List", 
                                NULL,
                                &pQuery->mszProviderList,
                                &dwBufferSize );

        if ( 0 == dwBufferSize ) {
            if ( (ERROR_SUCCESS != dwProviderStatus ) 
                && ( ! IsKernelTraceMode( pQuery->dwFlags ) ) ) {
                //
                // No provider list retrieved and not kernel trace so there's not much
                // point in continuing
                //
                if ( ERROR_SUCCESS == dwStatus ) {
                    dwStatus = SMLOG_UNABLE_READ_PROVIDER_LIST;
                }
                szStringArray[0] = pQuery->szQueryName;
                ReportEvent (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    SMLOG_UNABLE_READ_PROVIDER_LIST,
                    NULL,
                    1,
                    sizeof(DWORD),
                    szStringArray,      
                    (LPVOID)&dwStatus);
            } else {
                //
                // Allocate a minimal buffer for the NULL character to simplify later logic.
                //
                pQuery->mszProviderList = G_ALLOC ( sizeof(WCHAR) );
                if ( NULL != pQuery->mszProviderList ) {
                    pQuery->mszProviderList[0] = L'\0';
                } else{
                    dwStatus = ERROR_OUTOFMEMORY;
                    szStringArray[0] = pQuery->szQueryName;
                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_UNABLE_READ_PROVIDER_LIST,
                        NULL,
                        1,
                        sizeof(DWORD),
                        szStringArray,      
                        (LPVOID)&dwStatus);
                }
            }
        }

        //
        // It is possible the "Trace Provider Flags" list is not present
        // or has nothing it
        //
        dwProviderStatus = ReadRegistryStringValue (
                                pQuery->hKeyQuery,
                                pQuery->szQueryName,
                                L"Trace Provider Flags", 
                                L"",
                                &pQuery->mszProviderFlags,
                                &dwBufferSize );

        //
        // It is possible the "Trace Provider Levels" list is not present
        // or has nothing it
        //
        dwProviderStatus = ReadRegistryStringValue (
                                pQuery->hKeyQuery,
                                pQuery->szQueryName,
                                L"Trace Provider Levels", 
                                L"",
                                &pQuery->mszProviderLevels,
                                &dwBufferSize );

        if ( ERROR_SUCCESS == dwStatus ) {

            dwDefault = 4;
            dwStatus = ReadRegistryDwordValue (
                            pQuery->hKeyQuery,
                            pQuery->szQueryName,
                            L"Trace Buffer Size",
                            &dwDefault, 
                            &pQuery->dwBufferSize);
        }

        if ( ERROR_SUCCESS == dwStatus ) {

            dwDefault = 2;
            dwStatus = ReadRegistryDwordValue (
                            pQuery->hKeyQuery,
                            pQuery->szQueryName,
                            L"Trace Buffer Min Count",
                            &dwDefault, 
                            &pQuery->dwBufferMinCount);
        }

        if ( ERROR_SUCCESS == dwStatus ) {

            dwDefault = 25;
            dwStatus = ReadRegistryDwordValue (
                            pQuery->hKeyQuery,
                            pQuery->szQueryName,
                            L"Trace Buffer Max Count",
                            &dwDefault, 
                            &pQuery->dwBufferMaxCount);
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            
            dwDefault = 0;
            dwStatus = ReadRegistryDwordValue (
                            pQuery->hKeyQuery,
                            pQuery->szQueryName,
                            L"Trace Buffer Flush Interval",
                            &dwDefault, 
                            &pQuery->dwBufferFlushInterval);
        }

        //
        // EOF Command file.
        // This is used for both Counter and Trace log files.
        // Alerts use the Command file field for Alert command file.
        //

        if ( ERROR_SUCCESS == dwStatus ) {
            ReadRegistryStringValue (
                        pQuery->hKeyQuery,
                        pQuery->szQueryName,
                        L"EOF Command File",
                        NULL,
                        &pQuery->szCmdFileName,
                        &dwBufferSize );
            // Ignore status, default is empty.
        }
    } else {
        //
        // Ignore partly created logs and alerts.
        //
        assert ( SLQ_NEW_LOG == pQuery->dwLogType );
        if ( SLQ_NEW_LOG == pQuery->dwLogType ) {
            dwStatus = SMLOG_LOG_TYPE_NEW;
        } else {
            dwStatus = SMLOG_INVALID_LOG_TYPE;

            szStringArray[0] = pQuery->szQueryName;
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                SMLOG_INVALID_LOG_TYPE,
                NULL,
                1,
                sizeof(DWORD),
                szStringArray,      
                (LPVOID)&pQuery->dwLogType);
        }
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        dwStatus = LoadCommonConfig ( pQuery );
    }

    return dwStatus;
}

void 
LockQueryData ( void )
{
    EnterCriticalSection ( &QueryDataLock );
}

void 
UnlockQueryData ( void )
{
    LeaveCriticalSection ( &QueryDataLock );
}

void 
EnterConfigure ( void )
{
    EnterCriticalSection ( &QueryDataLock );
}

void 
ExitConfigure ( void )
{
    LeaveCriticalSection ( &QueryDataLock );
}

PLOG_QUERY_DATA
GetQueryData (
    LPCWSTR  szQueryName )
{
    PLOG_QUERY_DATA pQuery;

    LockQueryData();

    pQuery = pFirstQuery;

    while ( NULL != pQuery ) {
        if ( !lstrcmpi(pQuery->szQueryName, szQueryName ) ) {
            // If the exit event isn't set, then this query is still active.
            if ((WaitForSingleObject (pQuery->hExitEvent, 0)) != WAIT_OBJECT_0) {
                break;
            } 
        }
        pQuery = pQuery->next;
    }

    UnlockQueryData();

    return pQuery;
}


PLOG_QUERY_DATA 
GetQueryDataPtr (
    HANDLE hThisQuery
)
{
    PLOG_QUERY_DATA pQuery = NULL;

    LockQueryData();
    
    // Find the query data block in the list.

    if ( hThisQuery == pFirstQuery->hThread ) {
        pQuery = pFirstQuery;
    }

    if ( NULL == pQuery ) {

        for ( pQuery = pFirstQuery;
            NULL != pQuery->next;
            pQuery = pQuery->next ) {

            if ( hThisQuery == pQuery->next->hThread ) {
                pQuery = pQuery->next;
                break;
            }
        }
    }

    UnlockQueryData();

    return pQuery;
}


void 
DeallocateQueryBuffers (
    IN PLOG_QUERY_DATA pQuery )
{
    //
    // Deallocate the buffers that can be deleted when the collection
    // thread is reconfigured.
    //
    if (( SLQ_COUNTER_LOG == pQuery->dwLogType ) ||
        ( SLQ_ALERT == pQuery->dwLogType)) {

        if (pQuery->mszCounterList != NULL) {
            G_FREE(pQuery->mszCounterList);
            pQuery->mszCounterList = NULL;
        }
    }

    if ( SLQ_ALERT == pQuery->dwLogType) {
        if (pQuery->szNetName != NULL) {
            G_FREE(pQuery->szNetName);
            pQuery->szNetName = NULL;
        }

        if (pQuery->szPerfLogName != NULL) {
            G_FREE(pQuery->szPerfLogName);
            pQuery->szPerfLogName = NULL;
        }

        if (pQuery->szUserText != NULL) {
            G_FREE (pQuery->szUserText);
            pQuery->szUserText = NULL;
        }
    }

    if ( SLQ_TRACE_LOG == pQuery->dwLogType) {
        if (pQuery->mszProviderList != NULL) {
            G_FREE(pQuery->mszProviderList);
            pQuery->mszProviderList = NULL;
        }
        if (pQuery->mszProviderFlags != NULL) {
            G_FREE(pQuery->mszProviderFlags);
            pQuery->mszProviderFlags = NULL;
        }
        if (pQuery->mszProviderLevels != NULL) {
            G_FREE(pQuery->mszProviderLevels);
            pQuery->mszProviderLevels = NULL;
        }
    }

    if (pQuery->szLogFileComment != NULL) {
        G_FREE(pQuery->szLogFileComment);
        pQuery->szLogFileComment = NULL;
    }

    if (pQuery->szBaseFileName != NULL) {
        G_FREE(pQuery->szBaseFileName);
        pQuery->szBaseFileName = NULL;
    }

    if (pQuery->szLogFileFolder != NULL) {
        G_FREE(pQuery->szLogFileFolder);
        pQuery->szLogFileFolder = NULL;
    }

    if (pQuery->szSqlLogName != NULL) {
        G_FREE(pQuery->szSqlLogName);
        pQuery->szSqlLogName = NULL;
    }

    if (pQuery->szCmdFileName != NULL) {
        G_FREE(pQuery->szCmdFileName);
        pQuery->szCmdFileName = NULL;
    }
}


void 
ClearTraceProperties (
    IN PLOG_QUERY_DATA pQuery )
{
#if _IMPLEMENT_WMI
    G_ZERO (& pQuery->Properties, sizeof(EVENT_TRACE_PROPERTIES));
    G_ZERO (pQuery->szLoggerName, sizeof(pQuery->szLoggerName));
    G_ZERO (pQuery->szLogFileName, sizeof(pQuery->szLogFileName));

    if ( NULL != pQuery->arrpGuid ) {
        ULONG ulIndex;
        
        for ( ulIndex = 0; ulIndex < pQuery->ulGuidCount; ulIndex++ ) {
            if ( NULL != pQuery->arrpGuid[ulIndex].pszProviderName ) {
                G_FREE ( pQuery->arrpGuid[ulIndex].pszProviderName );
                pQuery->arrpGuid[ulIndex].pszProviderName = NULL;
            }
        }

        G_FREE ( pQuery->arrpGuid );
        pQuery->arrpGuid = NULL;
    }

    pQuery->ulGuidCount = 0;

    pQuery->Properties.LoggerNameOffset  = sizeof(EVENT_TRACE_PROPERTIES);
    pQuery->Properties.LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES)
                                         + sizeof(pQuery->szLoggerName);
#endif
}



DWORD
LoadPdhLogUpdateSuccess ( void )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HKEY    hKeySysmonLog = NULL;
    WCHAR*  mszStatusList = NULL;
    DWORD   dwBufferSize = 0;
    DWORD   dwType = 0;

    dwStatus = RegOpenKeyEx (
        (HKEY)HKEY_LOCAL_MACHINE,
        L"SYSTEM\\CurrentControlSet\\Services\\SysmonLog",
        0L,
        KEY_READ,
        (PHKEY)&hKeySysmonLog);

    if (dwStatus == ERROR_SUCCESS) {
        //
        // Find out the size of the required buffer
        //
        dwStatus = RegQueryValueExW (
            hKeySysmonLog,
            L"PdhDataCollectSuccessStatus", 
            NULL,
            &dwType,
            NULL,
            &dwBufferSize);         // In bytes

        // If there is something to read 
        if ( (ERROR_SUCCESS == dwStatus ) && ( 0 < dwBufferSize ) ) {
            mszStatusList = G_ALLOC ( dwBufferSize ); 

            if ( NULL != mszStatusList ) {
                mszStatusList[0] = L'\0';
                dwType = 0;
                dwStatus = RegQueryValueExW (
                    hKeySysmonLog,
                    L"PdhDataCollectSuccessStatus",
                    NULL,
                    &dwType,
                    (UCHAR*)mszStatusList,
                    &dwBufferSize);

                if ( (ERROR_SUCCESS == dwStatus ) 
                        && ( 0 < dwBufferSize ) 
                        && ( L'\0' != mszStatusList[0] ) ) {

                    // Allocate and load Pdh data collection status value array.
                    INT     iStatusCount = 0;
                    WCHAR*  szThisStatus;

                    for (szThisStatus = mszStatusList;
                            *szThisStatus != 0;
                            szThisStatus += lstrlen(szThisStatus) + 1) {
                        iStatusCount++;
                    }
                    
                    arrPdhDataCollectSuccess = G_ALLOC ( iStatusCount * sizeof ( DWORD ) );
                    
                    if ( NULL != arrPdhDataCollectSuccess ) {
                        INT iStatusIndex;

                        szThisStatus = mszStatusList;
                        for ( iStatusIndex = 0; iStatusIndex < iStatusCount; iStatusIndex++ ) {
                            if (0 != *szThisStatus ) {
                                arrPdhDataCollectSuccess[iStatusIndex] = (DWORD)_wtoi( szThisStatus );
                                szThisStatus += lstrlen(szThisStatus) + 1;
                            } else {
                                break;
                            }
                        }
                    }
                    
                    iPdhDataCollectSuccessCount = iStatusCount;
                }
                if ( NULL != mszStatusList ) {
                    G_FREE ( mszStatusList );
                }
            } else {
                dwStatus = ERROR_OUTOFMEMORY;
            }
        }
        RegCloseKey(hKeySysmonLog);
    } 

    return dwStatus;
}

DWORD
InitTraceGuids(
    IN PLOG_QUERY_DATA pQuery )
{
    DWORD   dwStatus = ERROR_SUCCESS;

#if _IMPLEMENT_WMI
#define GUID_BUF_LEN (64)

    LPWSTR  pszThisGuid;
    LPWSTR  pszThisFlag;
    LPWSTR  pszThisLevel;
    LONG    ulGuidIndex;
    LONG    ulGuidCount = 0;
    PTRACE_PROVIDER  arrpGuid = NULL;
    WCHAR   pszThisGuidBuffer[GUID_BUF_LEN];
    UNICODE_STRING ustrGuid;

    //
    // Count the GUIDs
    //
    if ( NULL != pQuery ) {
        if ( NULL != pQuery->mszProviderList ) {
            for (pszThisGuid = pQuery->mszProviderList;
                    *pszThisGuid != 0;
                    pszThisGuid += lstrlen(pszThisGuid) + 1) {
                ulGuidCount += 1;
                if ( NULL == pszThisGuid ) {
                    dwStatus = ERROR_INVALID_PARAMETER;
                    break;
                }
            }
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            arrpGuid = G_ALLOC ( ulGuidCount * sizeof ( TRACE_PROVIDER ) );
            if (NULL == arrpGuid) {
                dwStatus = ERROR_OUTOFMEMORY;
            } else {
                G_ZERO ( arrpGuid, ulGuidCount * sizeof ( TRACE_PROVIDER ) );
            }
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            //
            // Create an array of pointers to individual provider Guids in the
            // mszProviderList.  The provider Guids are used as provider
            // names in error messages, and for comparison with provider list
            //
            for ( ulGuidIndex = 0; ulGuidIndex < ulGuidCount; ulGuidIndex++) {
                arrpGuid[ulGuidIndex].pszProviderName = G_ALLOC ( sizeof(WCHAR[MAX_PATH+1]) );
                if (NULL == arrpGuid[ulGuidIndex].pszProviderName) {
                    dwStatus = ERROR_OUTOFMEMORY;
                    break;
                }
            }

            if (ERROR_SUCCESS == dwStatus) {

                ulGuidIndex = 0;
                pszThisFlag = pQuery->mszProviderFlags;
                pszThisLevel = pQuery->mszProviderLevels;

                for (pszThisGuid = pQuery->mszProviderList;
                        *pszThisGuid != 0;
                        pszThisGuid += lstrlen(pszThisGuid) + 1) {

                    StringCchCopy ( pszThisGuidBuffer, GUID_BUF_LEN, pszThisGuid );
                    //
                    // Size of GUID length << USHORT
                    //
                    ustrGuid.Length = (USHORT)(GUID_BUF_LEN*sizeof(WCHAR)); 
                    ustrGuid.MaximumLength = (USHORT)(GUID_BUF_LEN*sizeof(WCHAR));
                    ustrGuid.Buffer = pszThisGuidBuffer;
        
                    dwStatus = GUIDFromString (&ustrGuid, &arrpGuid[ulGuidIndex].Guid );

                    StringCchCopy ( arrpGuid[ulGuidIndex].pszProviderName, MAX_PATH+1, pszThisGuid );

                    //
                    // Set provider flags
                    //
                    if (pszThisFlag) {
                        if (*pszThisFlag) {
                            arrpGuid[ulGuidIndex].dwFlag = ahextoi(pszThisFlag);
                            pszThisFlag += lstrlen(pszThisFlag) + 1;
                        }
                    }
                    
                    //
                    // Set provider levels
                    //
                    if (pszThisLevel) {
                        if (*pszThisLevel) {
                            arrpGuid[ulGuidIndex].dwLevel = ahextoi(pszThisLevel);
                            pszThisLevel += lstrlen(pszThisLevel) + 1;
                        }
                    }
                    
                    ulGuidIndex++;
                }
        
                pQuery->ulGuidCount = ulGuidCount;
                pQuery->arrpGuid = arrpGuid;
            }
        }

        if (ERROR_SUCCESS != dwStatus) {
            // If failure anywhere, deallocate arrays
            if ( NULL != arrpGuid ) {
                for (ulGuidIndex--; ulGuidIndex>=0; ulGuidIndex--) {
                    if (arrpGuid[ulGuidIndex].pszProviderName) {
                        G_FREE(arrpGuid[ulGuidIndex].pszProviderName);
                    }
                }
                G_FREE(arrpGuid);
            }
        }
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }
#else 
        dwStatus = ERROR_CALL_NOT_IMPLEMENTED;
#endif
    return dwStatus;
}


DWORD
IsCreateNewFile (
    IN  PLOG_QUERY_DATA pQuery,
    OUT BOOL*   pbValidBySize,
    OUT BOOL*   pbValidByTime )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    BOOL    bLocalValidBySize = FALSE;
    BOOL    bLocalValidByTime = FALSE;


    if (  ( NULL != pQuery ) ) {
        if ( SLQ_AUTO_MODE_SIZE == pQuery->stiCreateNewFile.dwAutoMode ) {

            if ( ( SLF_SEQ_TRACE_FILE == pQuery->dwLogFileType )
                && ( -1 != pQuery->dwMaxFileSize )
                && ( 0 != pQuery->dwMaxFileSize ) ) 
            {
                bLocalValidBySize = TRUE;
            }
        } else if ( SLQ_AUTO_MODE_AFTER == pQuery->stiCreateNewFile.dwAutoMode ) {
            bLocalValidByTime = TRUE;
        }
        if  ( NULL != pbValidBySize ) {
            *pbValidBySize = bLocalValidBySize;
        }
        if  ( NULL != pbValidByTime ) {
            *pbValidByTime = bLocalValidByTime;
        }
    } else {
        assert ( FALSE );
        dwStatus = ERROR_INVALID_PARAMETER;
    }
        
    return dwStatus;
}


void 
InitTraceProperties (
    IN PLOG_QUERY_DATA pQuery,
    IN BOOL     bUpdateSerial,
    IN OUT DWORD*  pdwSessionSerial,
    IN OUT INT* piCnfSerial )
{
#if _IMPLEMENT_WMI

    HRESULT hr;
    DWORD   dwStatus = ERROR_SUCCESS;
    PPDH_PLA_INFO  pInfo = NULL;
    DWORD   dwInfoSize = 0;
    BOOL    bBySize = FALSE;
    BOOL    bByTime = FALSE;
    INT     iLocalCnfSerial;
    DWORD   dwLocalSessionSerial = 0;       // Init for Prefix check

    if ( NULL != pQuery && NULL != piCnfSerial ) {

        hr = PdhPlaGetInfoW( pQuery->szQueryName, NULL, &dwInfoSize, pInfo );
        if( ERROR_SUCCESS == hr && 0 != dwInfoSize ) {
            pInfo = (PPDH_PLA_INFO)G_ALLOC(dwInfoSize);
            if( NULL != pInfo && (sizeof(PDH_PLA_INFO) <= dwInfoSize) ){
                ZeroMemory( pInfo, dwInfoSize );

                pInfo->dwMask = PLA_INFO_FLAG_MODE|PLA_INFO_FLAG_LOGGERNAME;
                hr = PdhPlaGetInfoW( pQuery->szQueryName, NULL, &dwInfoSize, pInfo );
            } else {
                hr = E_OUTOFMEMORY;
            }
        }
    
        ClearTraceProperties ( pQuery );
    
        dwStatus = IsCreateNewFile ( pQuery, &bBySize, &bByTime );

        // Create format string, store it in pQuery->szLogFileName

        if ( bBySize ) {
            // In BuildCurrentLogFileName, iCnfSerial of -1 signals code to
            // return the format string for cnf serial number
            iLocalCnfSerial = -1;
        } else {
            if ( bByTime ) {
                *piCnfSerial += 1;
                iLocalCnfSerial = *piCnfSerial;
            } else {
                iLocalCnfSerial = 0;
            }
        }
    
        if ( NULL != pdwSessionSerial ) {
            dwLocalSessionSerial = *pdwSessionSerial;
        } else {        
            dwLocalSessionSerial = pQuery->dwCurrentSerialNumber;
        }

        dwStatus = BuildCurrentLogFileName (
                        pQuery->szQueryName,
                        pQuery->szBaseFileName,
                        pQuery->szLogFileFolder,
                        pQuery->szSqlLogName,
                        pQuery->szLogFileName,
                        &dwLocalSessionSerial,
                        pQuery->dwAutoNameFormat,
                        pQuery->dwLogFileType,
                        iLocalCnfSerial );

        RegisterCurrentFile( pQuery->hKeyQuery, pQuery->szLogFileName, iLocalCnfSerial );

        // Update log serial number if modified.
        if ( bUpdateSerial && SLF_NAME_NNNNNN == pQuery->dwAutoNameFormat ) {
        
            pQuery->dwCurrentSerialNumber++;

            // Todo:  Info event on number wrap - Server Beta 3.
            if ( MAXIMUM_SERIAL_NUMBER < pQuery->dwCurrentSerialNumber ) {
                pQuery->dwCurrentSerialNumber = MINIMUM_SERIAL_NUMBER;
            }

            WriteRegistryDwordValue (
                pQuery->hKeyQuery,
                L"Log File Serial Number",
                &pQuery->dwCurrentSerialNumber,
                REG_DWORD);
            // Todo: log event on error.
        }

        pQuery->Properties.Wnode.BufferSize = sizeof(pQuery->Properties)
                                            + sizeof(pQuery->szLoggerName)
                                            + sizeof(pQuery->szLogFileName);

        if ( TRUE == bBySize ) {
            // Add room for trace code to to return formatted filename string.
            pQuery->Properties.Wnode.BufferSize += 8;
        }
    
        pQuery->Properties.Wnode.Flags = WNODE_FLAG_TRACED_GUID; 

        // Fill out properties block and start.
        pQuery->Properties.BufferSize = pQuery->dwBufferSize;
        pQuery->Properties.MinimumBuffers = pQuery->dwBufferMinCount;
        pQuery->Properties.MaximumBuffers = pQuery->dwBufferMaxCount;

        if ( pInfo ) {
            if ( pInfo->Trace.strLoggerName != NULL ) {
               StringCchCopy ( 
                   pQuery->szLoggerName, 
                   MAX_PATH + 1,                    // Defined in header
                   pInfo->Trace.strLoggerName );
            }
        } else {
            StringCchCopy ( pQuery->szLoggerName, MAX_PATH + 1, pQuery->szQueryName ); 
        }
          
        if ( (BOOL)( 0 == (pQuery->dwFlags & SLQ_TLI_ENABLE_BUFFER_FLUSH)) )
            pQuery->Properties.FlushTimer = 0;
        else
            pQuery->Properties.FlushTimer = pQuery->dwBufferFlushInterval;
    
        if ( IsKernelTraceMode ( pQuery->dwFlags ) ) { 
            pQuery->Properties.Wnode.Guid = SystemTraceControlGuid;
            
            StringCchCopy ( pQuery->szLoggerName, MAX_PATH + 1, KERNEL_LOGGER_NAMEW ); 


            if ( (BOOL)( 0 != (pQuery->dwFlags & SLQ_TLI_ENABLE_KERNEL_TRACE)) ) {
                // NT5 Beta 2 Single Kernel flag
                pQuery->Properties.EnableFlags |= EVENT_TRACE_FLAG_PROCESS |
                                                  EVENT_TRACE_FLAG_THREAD |
                                                  EVENT_TRACE_FLAG_DISK_IO |
                                                  EVENT_TRACE_FLAG_NETWORK_TCPIP;
            } else {
                if ( (BOOL)( 0 != (pQuery->dwFlags & SLQ_TLI_ENABLE_PROCESS_TRACE)) ) 
                    pQuery->Properties.EnableFlags |= EVENT_TRACE_FLAG_PROCESS;

                if ( (BOOL)( 0 != (pQuery->dwFlags & SLQ_TLI_ENABLE_THREAD_TRACE)) ) 
                    pQuery->Properties.EnableFlags |= EVENT_TRACE_FLAG_THREAD;
            
                if ( (BOOL)( 0 != (pQuery->dwFlags & SLQ_TLI_ENABLE_DISKIO_TRACE)) ) 
                    pQuery->Properties.EnableFlags |= EVENT_TRACE_FLAG_DISK_IO;
            
                if ( (BOOL)( 0 != (pQuery->dwFlags & SLQ_TLI_ENABLE_NETWORK_TCPIP_TRACE)) ) 
                    pQuery->Properties.EnableFlags |= EVENT_TRACE_FLAG_NETWORK_TCPIP;
            
            }
                
            if ( (BOOL)( 0 != (pQuery->dwFlags & SLQ_TLI_ENABLE_MEMMAN_TRACE)) ) 
                pQuery->Properties.EnableFlags |= EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS;

            if ( (BOOL)( 0 != (pQuery->dwFlags & SLQ_TLI_ENABLE_FILEIO_TRACE)) ) 
                pQuery->Properties.EnableFlags |= EVENT_TRACE_FLAG_DISK_FILE_IO;
        
        } else {
            InitTraceGuids ( pQuery );
        }
        
        if ( -1 == pQuery->dwMaxFileSize ) {
            pQuery->Properties.MaximumFileSize = 0;
        } else {
            pQuery->Properties.MaximumFileSize = pQuery->dwMaxFileSize;
        }
        
        if ( ERROR_SUCCESS == dwStatus && TRUE == bBySize ) {
            pQuery->Properties.LogFileMode = 
                EVENT_TRACE_FILE_MODE_SEQUENTIAL | EVENT_TRACE_FILE_MODE_NEWFILE;
        } else if ( SLF_SEQ_TRACE_FILE == pQuery->dwLogFileType ) {
            pQuery->Properties.LogFileMode = EVENT_TRACE_FILE_MODE_SEQUENTIAL;

            // Only set Append mode if the file already exists.
            if ( pQuery->dwAppendMode && FileExists ( pQuery->szLogFileName ) ) {
                pQuery->Properties.LogFileMode |= EVENT_TRACE_FILE_MODE_APPEND;
            }

        } else { 
            assert ( SLF_CIRC_TRACE_FILE == pQuery->dwLogFileType );
            pQuery->Properties.LogFileMode = EVENT_TRACE_FILE_MODE_CIRCULAR;
        }

        if ( pInfo ) {
            pQuery->Properties.LogFileMode |= pInfo->Trace.dwMode;
            G_FREE( pInfo );
        }
        if ( NULL != pdwSessionSerial ) {
            *pdwSessionSerial = dwLocalSessionSerial;
        }
    } // Todo: else report error, return error
#endif

}


void 
FreeQueryData (
    IN PLOG_QUERY_DATA pQuery )
{
    // Caller must remove the thread data block from the list.

    // Threads are deleted by only one thread, so this should not
    // be deleted out from under.
    assert ( NULL != pQuery );

    if ( NULL != pQuery ) {
        // Free this entry.

        if (( SLQ_COUNTER_LOG == pQuery->dwLogType ) || 
            ( SLQ_ALERT == pQuery->dwLogType ) ){
        
            while ( NULL != pQuery->pFirstCounter ) {
                PLOG_COUNTER_INFO pDelCI = pQuery->pFirstCounter;
                pQuery->pFirstCounter = pDelCI->next;

                G_FREE( pDelCI );
            }
        } else {
            if ( NULL != pQuery->arrpGuid ) {
                ULONG ulIndex;
            
                for ( ulIndex = 0; ulIndex < pQuery->ulGuidCount; ulIndex++ ) {
                    if ( NULL != pQuery->arrpGuid[ulIndex].pszProviderName ) {
                        G_FREE ( pQuery->arrpGuid[ulIndex].pszProviderName );
                        pQuery->arrpGuid[ulIndex].pszProviderName = NULL;
                    }
                }

                G_FREE ( pQuery->arrpGuid );
                pQuery->arrpGuid = NULL;
            }
        }

        if ( NULL != pQuery->hThread ) {
            CloseHandle ( pQuery->hThread );
            pQuery->hThread = NULL;
        }

        if ( NULL != pQuery->hUserToken ) {
            CloseHandle ( pQuery->hUserToken );
            pQuery->hUserToken = NULL;
        }

        if ( NULL != pQuery->hExitEvent ) {
            CloseHandle ( pQuery->hExitEvent );
            pQuery->hExitEvent = NULL;
        }

        if ( NULL != pQuery->hReconfigEvent ) {
            CloseHandle ( pQuery->hReconfigEvent );
            pQuery->hReconfigEvent = NULL;
        }

        if ( NULL != pQuery->hKeyQuery ) {
            RegCloseKey ( pQuery->hKeyQuery );
            pQuery->hKeyQuery = NULL;
        }

        DeallocateQueryBuffers( pQuery );

        G_FREE (pQuery);
    }
}


void 
RemoveAndFreeQueryData (
    HANDLE hThisQuery
)
{
    PLOG_QUERY_DATA pQuery = NULL;
    BOOL bFound = FALSE;

    LockQueryData();
    
    // Find the query data block and remove it from the list.

    if ( hThisQuery == pFirstQuery->hThread ) {
        bFound = TRUE;
    }

    if ( bFound ) {
        pQuery = pFirstQuery;
        pFirstQuery = pFirstQuery->next;
    } else {

        PLOG_QUERY_DATA pQueryRemaining;
        
        for ( pQuery = pFirstQuery;
            NULL != pQuery->next;
            pQuery = pQuery->next ) {

            if ( hThisQuery == pQuery->next->hThread ) {
                pQueryRemaining = pQuery;
                pQuery = pQuery->next;
                pQueryRemaining->next = pQuery->next;
                bFound = TRUE;
                break;
            }
        }
    }

    assert ( bFound );

    if ( bFound ) {
        dwActiveSessionCount -= 1;
    }
    
    UnlockQueryData();
    
    assert ( NULL != pQuery );

    if ( bFound ) {
        FreeQueryData( pQuery );
    }
}   


LONGLONG      
ComputeStartWaitTics(
    IN  PLOG_QUERY_DATA pQuery,
    IN  BOOL    bWriteToRegistry  
)
{
    LONGLONG    llWaitTics = ((LONGLONG)0);
    LONGLONG    llLocalDateTime = 0;
    LONGLONG    llRptLocalDays = 0;
    LONGLONG    llRptStartTime = 0;
    LONGLONG    llRptStopTime = 0;
    LONGLONG    llRptLocalTime = 0;
    SLQ_TIME_INFO   stiSched;


    // Compute time to wait before logging starts.
    //
    // Time returned is millisecond granularity.
    //
    // Return value:
    //
    // Start time minus Now when At time is in the future.
    //
    // 0 signals no wait.  This is true when:
    //  Start is either Manual or At mode and start time set to before now.
    //      Exceptions for both of these cases are noted below.
    // 
    // NULL_INTERVAL_TICS signals exit immediately.  This is true when:
    //  Start is Manual and Start time is MAX_TIME_VALUE
    //  Stop is At mode and Stop time is past.
    //  Stop is Manual mode and Stop time is MIN_TIME_VALUE or any value <= Now
    //  Stop is Size mode, Stop time is MIN_TIME_VALUE or any value <= Now, and repeat mode is Manual.
    //  Stop is After mode, After value is 0 (UI should protect against this).
    //  Stop is After mode, Start is At mode, stop time is past and repeat mode is Manual.
    //
    
    GetLocalFileTime (&llLocalDateTime);        

    if ( ( MAX_TIME_VALUE == pQuery->stiRegStart.llDateTime )
        && ( SLQ_AUTO_MODE_NONE == pQuery->stiRegStart.dwAutoMode ) ) {
        // Manual Start, start time is MAX_TIME_VALUE
        // Note:  For repeat functionality, manual start time might be > now.
        //    Need to keep the start mode Manual in this case to ensure that 
        //    SetStoppedStatus works.
        // Todo:  Don't allow repeat or restart with Manual mode?
        llWaitTics = NULL_INTERVAL_TICS;
    } else if ( ( SLQ_AUTO_MODE_NONE == pQuery->stiRegStop.dwAutoMode ) 
            && ( pQuery->stiRegStop.llDateTime  <= llLocalDateTime ) ) {
        // Past Stop Manual time. 
        llWaitTics = NULL_INTERVAL_TICS;
    } else if ( ( ( SLQ_AUTO_MODE_AT == pQuery->stiRegStop.dwAutoMode )
                && ( SLQ_AUTO_MODE_CALENDAR != pQuery->stiRepeat.dwAutoMode ) )
            && ( pQuery->stiRegStop.llDateTime  <= llLocalDateTime ) ) {
        // Past Stop At or time and repeat mode not set to calendar. 
        llWaitTics = NULL_INTERVAL_TICS;
    } else if ( ( ( SLQ_AUTO_MODE_SIZE == pQuery->stiRegStop.dwAutoMode )
                && ( SLQ_AUTO_MODE_NONE == pQuery->stiRepeat.dwAutoMode ) )
            && ( pQuery->stiRegStop.llDateTime  <= llLocalDateTime ) ) {
        // Stop time set to 0 if Stop by size has completed and repeat
        // mode not set to calendar.
        llWaitTics = NULL_INTERVAL_TICS;
    } else if ( SLQ_AUTO_MODE_AFTER == pQuery->stiRegStop.dwAutoMode ) {
        if ( 0 == pQuery->stiRegStop.dwValue ) {
            // Stop After mode and value is 0.
            llWaitTics = NULL_INTERVAL_TICS;
        } else if ( ( SLQ_AUTO_MODE_AT == pQuery->stiRegStart.dwAutoMode )
                    && ( SLQ_AUTO_MODE_NONE == pQuery->stiRepeat.dwAutoMode ) ) {
            LONGLONG    llTics;
            
            TimeInfoToTics ( &pQuery->stiRegStop, &llTics );
            
            if ( ( pQuery->stiRegStart.llDateTime + llTics ) < llLocalDateTime ) {
                // Start at, Stop After modes, stop time is past and no restart.
                llWaitTics = NULL_INTERVAL_TICS;
            }
        }
    } 
    
    // This code writes to local start and stop time structures to compute
    // start wait tics.  This avoids excessive log stops and starts, since
    // the original registry data structures are compared when the registry
    // has been modified, to determine if a log config has been changed by the UI.
    if ( NULL_INTERVAL_TICS != llWaitTics ) {

        pQuery->stiCurrentStart = pQuery->stiRegStart;
        pQuery->stiCurrentStop = pQuery->stiRegStop;

        // Handle repeat option separately.
        if ( SLQ_AUTO_MODE_CALENDAR == pQuery->stiRepeat.dwAutoMode ) {

            assert ( SLQ_AUTO_MODE_AT == pQuery->stiCurrentStart.dwAutoMode );
            assert ( SLQ_AUTO_MODE_AT == pQuery->stiCurrentStop.dwAutoMode );
//            assert ( ( pQuery->stiCurrentStop.llDateTime - pQuery->stiCurrentStart.llDateTime )
//                        < (FILETIME_TICS_PER_SECOND * SECONDS_IN_DAY) );
        
            if ( pQuery->stiCurrentStop.llDateTime <= llLocalDateTime ) {

                llRptLocalDays = llLocalDateTime / (FILETIME_TICS_PER_SECOND * SECONDS_IN_DAY); 
                llRptLocalTime = llLocalDateTime - llRptLocalDays;

                llRptStopTime = pQuery->stiCurrentStop.llDateTime 
                                - ( pQuery->stiCurrentStop.llDateTime  
                                        / (FILETIME_TICS_PER_SECOND * SECONDS_IN_DAY) );

                pQuery->stiCurrentStop.llDateTime = llRptLocalDays + llRptStopTime;
                if ( llRptStopTime < llRptLocalTime ) {
                    // Set to stop tomorrow.
                    pQuery->stiCurrentStop.llDateTime += (FILETIME_TICS_PER_SECOND * SECONDS_IN_DAY) ;
                }

                llRptStartTime = pQuery->stiCurrentStart.llDateTime 
                                - ( pQuery->stiCurrentStart.llDateTime  
                                        / (FILETIME_TICS_PER_SECOND * SECONDS_IN_DAY) );

                pQuery->stiCurrentStart.llDateTime = llRptLocalDays + llRptStartTime;

                if ( (pQuery->stiCurrentStop.llDateTime - pQuery->stiCurrentStart.llDateTime)
                    > (FILETIME_TICS_PER_SECOND * SECONDS_IN_DAY) ) {
                    // Set to start tomorrow.
                    pQuery->stiCurrentStart.llDateTime += (FILETIME_TICS_PER_SECOND * SECONDS_IN_DAY);
                }  
            }
                
            if ( bWriteToRegistry ) {
                stiSched.wDataType = SLQ_TT_DTYPE_DATETIME;
                stiSched.wTimeType = SLQ_TT_TTYPE_REPEAT_START;
                stiSched.dwAutoMode = SLQ_AUTO_MODE_AT;
                stiSched.llDateTime = pQuery->stiCurrentStart.llDateTime;
            
                WriteRegistrySlqTime (
                    pQuery->hKeyQuery, 
                    L"Repeat Schedule Start",
                    &stiSched );

                stiSched.wTimeType = SLQ_TT_TTYPE_REPEAT_STOP;
                stiSched.dwAutoMode = SLQ_AUTO_MODE_AT;
                stiSched.llDateTime = pQuery->stiCurrentStop.llDateTime;
                
                WriteRegistrySlqTime (
                    pQuery->hKeyQuery, 
                    L"Repeat Schedule Stop",
                    &stiSched );

            }
        }
        
        if ( pQuery->stiCurrentStart.llDateTime <= llLocalDateTime ) {
            llWaitTics = ((LONGLONG)(0));
        } else {
            llWaitTics = pQuery->stiCurrentStart.llDateTime - llLocalDateTime;
        } 
        
        // If manual mode, set the start time to now, to handle repeat schedule.
        // If any thread other than the log thread accesses this field for a
        // running query, then need to synchronize access to the field.
        if( SLQ_AUTO_MODE_NONE == pQuery->stiCurrentStart.dwAutoMode 
            && MIN_TIME_VALUE == pQuery->stiCurrentStart.llDateTime ) 
        {
            pQuery->stiCurrentStart.llDateTime = llLocalDateTime + llWaitTics;
        }
    }

    return llWaitTics;
}


void
LoadDefaultLogFileFolder ( void )
{
    HKEY    hKeyLogService = NULL;   
    WCHAR   szLocalPath[MAX_PATH+1] = L"";
    DWORD   cchExpandedLen;
    DWORD   dwStatus;

    dwStatus = RegOpenKeyEx (
        (HKEY)HKEY_LOCAL_MACHINE,
        L"SYSTEM\\CurrentControlSet\\Services\\SysmonLog",
        0L,
        KEY_READ,
        (PHKEY)&hKeyLogService);

    // update the service status
    ssSmLogStatus.dwCheckPoint++;
    SetServiceStatus (hSmLogStatus, &ssSmLogStatus);

    if (dwStatus == ERROR_SUCCESS) {
        DWORD dwBufferSize = (MAX_PATH+1) * sizeof(WCHAR);

        RegQueryValueExW (
            hKeyLogService,
            L"DefaultLogFileFolder",
            NULL,
            0L,
            (LPBYTE)szLocalPath,
            &dwBufferSize);

        szLocalPath[dwBufferSize/sizeof(WCHAR) - 1] = L'\0';

        RegCloseKey (hKeyLogService);

    }   // No message on error.  Just use load the local default.        
    
    if ( 0 == lstrlen (szLocalPath ) ) {
        StringCchCopy ( szLocalPath, MAX_PATH + 1, DEFAULT_LOG_FILE_FOLDER );
    }

    // Todo: local and global buffer sizes are fixed.

    cchExpandedLen = ExpandEnvironmentStrings (
                        szLocalPath,
                        gszDefaultLogFileFolder,
                        MAX_PATH+1 );


    if ( 0 == cchExpandedLen ) {
        gszDefaultLogFileFolder[0] = L'\0';
    }
    
    assert ( MAX_PATH >= iTemp );
}


DWORD
OpenLogQueriesKey (
    REGSAM regsamAccess,
    PHKEY phKeyLogQueries )
{

    DWORD dwStatus;

    dwStatus = RegOpenKeyEx (
        (HKEY)HKEY_LOCAL_MACHINE,
        L"SYSTEM\\CurrentControlSet\\Services\\SysmonLog\\Log Queries",
        0L,
        regsamAccess,
        phKeyLogQueries);

    return dwStatus;
}

DWORD
ClearQueryRunStates ( void )
{

    DWORD   dwStatus;            
    HKEY    hKeyLogQueries = NULL;            
    HKEY    hKeyThisLogQuery = NULL;            
    DWORD   dwQueryIndex;            
    WCHAR   szQueryNameBuffer[MAX_PATH+1];            
    DWORD   cchQueryNameBufLen;            
    WCHAR   szQueryClassBuffer[MAX_PATH+1];            
    DWORD   cchQueryClassBufLen;            
    LPWSTR  szCollectionName = NULL;            
    UINT    uiCollectionNameLen = 0;            
    LPWSTR  szStringArray[2];            
    DWORD   dwCurrentState;
    DWORD   dwDefault;
    DWORD   dwLogType;

    // For every query in the registry, if the state is SLQ_QUERY_RUNNING,
    // set it to SLQ_QUERY_STOPPED.
    //
    // This method must be called before starting the query threads.
    //
    // Only the service sets the state to SLQ_QUERY_RUNNING, so there is no 
    // race condition.

    // Open (each) query in the registry
    
    dwStatus = OpenLogQueriesKey (
                    KEY_READ | KEY_SET_VALUE,
                    (PHKEY)&hKeyLogQueries);

    if (dwStatus != ERROR_SUCCESS) {
        if (dwStatus == ERROR_FILE_NOT_FOUND) {
            //
            // There are no logs nor alerts settings, bail out quietly.
            // The error is reported later in the processing.
            //
            dwStatus = ERROR_SUCCESS;
        }
        else {
            // unable to read the log query information from the registry
            dwStatus = GetLastError();
            ReportEvent (hEventLog,
                    EVENTLOG_ERROR_TYPE,
                    0,
                    SMLOG_UNABLE_OPEN_LOG_QUERY,
                    NULL,
                    0,
                    0,
                    NULL,
                    NULL);

            dwStatus = SMLOG_UNABLE_OPEN_LOG_QUERY;
        }
    } else {

        dwQueryIndex = 0;
        *szQueryNameBuffer = L'\0';
        cchQueryNameBufLen = MAX_PATH+1;
        *szQueryClassBuffer = L'\0';
        cchQueryClassBufLen = MAX_PATH+1;

        while ((dwStatus = RegEnumKeyEx (
            hKeyLogQueries,
            dwQueryIndex,
            szQueryNameBuffer,
            &cchQueryNameBufLen,
            NULL,
            szQueryClassBuffer,
            &cchQueryClassBufLen,
            NULL)) != ERROR_NO_MORE_ITEMS) {

            // open this key
            dwStatus = RegOpenKeyEx (
                hKeyLogQueries,
                szQueryNameBuffer,
                0L,
                KEY_READ | KEY_WRITE,
                (PHKEY)&hKeyThisLogQuery);

            if (dwStatus != ERROR_SUCCESS) {
                szStringArray[0] = szQueryNameBuffer;
                ReportEvent (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    SMLOG_UNABLE_READ_LOG_QUERY,
                    NULL,
                    1,
                    sizeof(DWORD),
                    szStringArray,
                       (LPVOID)&dwStatus);
                // skip to next item
                goto CONTINUE_ENUM_LOOP;
            }

            // update the service status
            ssSmLogStatus.dwCheckPoint++;
            SetServiceStatus (hSmLogStatus, &ssSmLogStatus);

            dwStatus = SmReadRegistryIndirectStringValue (
                        hKeyThisLogQuery,
                        L"Collection Name",
                        NULL,
                        &szCollectionName,
                        &uiCollectionNameLen );
            
            if ( NULL != szCollectionName ) {
                if ( 0 < lstrlen ( szCollectionName ) ) {
                    StringCchCopy ( 
                        szQueryNameBuffer,
                        MAX_PATH + 1,
                        szCollectionName ); 
                }

                G_FREE ( szCollectionName );
                szCollectionName = NULL;
                uiCollectionNameLen = 0;
            }

            dwDefault = ((DWORD)-1);
            dwStatus = ReadRegistryDwordValue (
                        hKeyThisLogQuery, 
                        szQueryNameBuffer,
                        L"Log Type",
                        &dwDefault, 
                        &dwLogType );

            if ( ( SLQ_COUNTER_LOG == dwLogType )
                || ( SLQ_TRACE_LOG == dwLogType ) 
                || ( SLQ_ALERT == dwLogType ) ) {
            
                // Check the current state of the query.  If it is SLQ_QUERY_RUNNING,
                // set it to SLQ_QUERY_STOPPED.  If, in addition, the Start mode is 
                // manual, set the start time to MAX, so that the query doesn't 
                // start automatically.

                // If the current state is SLQ_QUERY_START_PENDING, it is assumed to be a new
                // request, so leave the registry as is.
                //

                // Note:  For trace logs, this code only coordinates between trace log 
                // configs that are stored in the registry.

                dwDefault = SLQ_QUERY_STOPPED;
                dwStatus = ReadRegistryDwordValue (
                    hKeyThisLogQuery,
                    szQueryNameBuffer,
                    L"Current State",
                    &dwDefault, 
                    &dwCurrentState );
                assert (dwStatus == ERROR_SUCCESS);
                // Status always success if default provided.

                // If query is in START_PENDING or STOPPED state, then
                // the registry contents are correct. If it is in
                // RUNNING state, then the service was stopped before
                // it could clean up the registry state.
                if ( SLQ_QUERY_RUNNING == dwCurrentState ) {
                    SLQ_TIME_INFO stiDefault;
                    SLQ_TIME_INFO stiActual;
                    LONGLONG      ftLocalTime;

                    dwCurrentState = SLQ_QUERY_STOPPED;
                    dwStatus = WriteRegistryDwordValue (
                                hKeyThisLogQuery, 
                                L"Current State",
                                &dwCurrentState,
                                REG_DWORD );

                    if (dwStatus != ERROR_SUCCESS) {
                        szStringArray[0] = szQueryNameBuffer;
                        ReportEvent (hEventLog,
                            EVENTLOG_WARNING_TYPE,
                            0,
                            SMLOG_UNABLE_WRITE_STOP_STATE,
                            NULL,
                            1,
                            sizeof(DWORD),
                            szStringArray,
                               (LPVOID)&dwStatus);
                        // skip to next item
                        goto CONTINUE_ENUM_LOOP;
                    } 

                    // If Start is manual mode, set start time to MAX, to signal
                    // not started.  
                    GetLocalFileTime ( &ftLocalTime );

                    stiDefault.wTimeType = SLQ_TT_TTYPE_START;
                    stiDefault.dwAutoMode = SLQ_AUTO_MODE_AT;
                    stiDefault.wDataType = SLQ_TT_DTYPE_DATETIME;
                    stiDefault.llDateTime = *(LONGLONG *)&ftLocalTime;

                    dwStatus = ReadRegistrySlqTime (
                                hKeyThisLogQuery, 
                                szQueryNameBuffer,
                                L"Start",
                                &stiDefault,
                                &stiActual );
                    //
                    // Status is always success if default is provided.
                    //
                    assert (dwStatus == ERROR_SUCCESS);
            
                    if ( ( SLQ_AUTO_MODE_NONE == stiActual.dwAutoMode ) 
                        && ( MAX_TIME_VALUE != stiActual.llDateTime ) ) {

                        stiActual.llDateTime = MAX_TIME_VALUE;
                        dwStatus = WriteRegistrySlqTime (
                            hKeyThisLogQuery, 
                            L"Start",
                            &stiActual);

                        if (dwStatus != ERROR_SUCCESS) {
                            szStringArray[0] = szQueryNameBuffer;
                            ReportEvent (hEventLog,
                                EVENTLOG_WARNING_TYPE,
                                0,
                                SMLOG_UNABLE_RESET_START_TIME,
                                NULL,
                                1,
                                sizeof(DWORD),
                                szStringArray,
                                (LPVOID)&dwStatus);
                            // skip to next item
                            goto CONTINUE_ENUM_LOOP;
                        }
                    }             
                    
                    //
                    // If Stop is manual mode, set stop time to MIN, to signal
                    // not started. 
                    //
                    GetLocalFileTime ( &ftLocalTime );

                    stiDefault.wDataType = SLQ_TT_DTYPE_DATETIME;
                    stiDefault.wTimeType = SLQ_TT_TTYPE_STOP;
                    stiDefault.dwAutoMode = SLQ_AUTO_MODE_NONE;
                    stiDefault.llDateTime = MIN_TIME_VALUE;

                    dwStatus = ReadRegistrySlqTime (
                                hKeyThisLogQuery, 
                                szQueryNameBuffer,
                                L"Stop",
                                &stiDefault,
                                &stiActual );
                    //    
                    // Status always success if default provided.
                    //
                    assert (dwStatus == ERROR_SUCCESS);
            
                    if ( ( SLQ_AUTO_MODE_NONE == stiActual.dwAutoMode ) 
                        && ( MIN_TIME_VALUE != stiActual.llDateTime ) ) {

                        stiActual.llDateTime = MIN_TIME_VALUE;
                        dwStatus = WriteRegistrySlqTime (
                            hKeyThisLogQuery, 
                            L"Stop",
                            &stiActual);

                        if (dwStatus != ERROR_SUCCESS) {
                            szStringArray[0] = szQueryNameBuffer;
                            ReportEvent (hEventLog,
                                EVENTLOG_WARNING_TYPE,
                                0,
                                SMLOG_UNABLE_RESET_STOP_TIME,
                                NULL,
                                1,
                                sizeof(DWORD),
                                szStringArray,
                                (LPVOID)&dwStatus);
                            // skip to next item
                            goto CONTINUE_ENUM_LOOP;
                        }
                    }                 
                }
            } // Ignore invalid log types when clearing status. 

CONTINUE_ENUM_LOOP:
            if ( NULL != hKeyThisLogQuery ) {
                RegCloseKey (hKeyThisLogQuery);
                hKeyThisLogQuery = NULL;
            }
            // prepare for next loop
            dwQueryIndex++;
            *szQueryNameBuffer = L'\0';
            cchQueryNameBufLen = MAX_PATH+1;
            *szQueryClassBuffer = L'\0';
            cchQueryClassBufLen = MAX_PATH+1;
        } // end enumeration of log queries
    }

    if ( NULL != hKeyLogQueries ) {
        RegCloseKey (hKeyLogQueries);
    }
    return dwStatus;
}


BOOL
TraceStopRestartFieldsMatch (
    IN PLOG_QUERY_DATA pOrigQuery,
    IN PLOG_QUERY_DATA pNewQuery )
{
#if _IMPLEMENT_WMI
    // These are fields for which trace logging must
    // be stopped and restarted in order to reconfigure.
    BOOL    bRequested;
    BOOL    bCurrent;
    ULONG   ulGuidCount = 0;
    ULONG   ulGuidIndex = 0;
    WCHAR*  pszThisGuid = NULL;
    WCHAR*  pszThisFlag = NULL;
    WCHAR*  pszThisLevel = NULL;
    DWORD   dwFlag;
    DWORD   dwLevel;

    assert ( SLQ_TRACE_LOG == pOrigQuery->dwLogType );
    assert ( SLQ_TRACE_LOG == pNewQuery->dwLogType );

    if ( !CommonFieldsMatch ( pOrigQuery, pNewQuery ) ) 
        return FALSE;

    if ( pOrigQuery->stiCreateNewFile.dwAutoMode != pNewQuery->stiCreateNewFile.dwAutoMode ) {
        return FALSE;
    } else {
        if ( ( SLQ_AUTO_MODE_AFTER == pOrigQuery->stiCreateNewFile.dwAutoMode )
            && ( pOrigQuery->stiCreateNewFile.llDateTime != pNewQuery->stiCreateNewFile.llDateTime ) ) {
            return FALSE;
        }
    }

    // Compare new query fields against the existing properties structure.
    // Compare everything but flush interval, max buffer count and file name.
    if ( pOrigQuery->Properties.BufferSize != pNewQuery->dwBufferSize )
        return FALSE;

    if ( pOrigQuery->Properties.MinimumBuffers != pNewQuery->dwBufferMinCount )
        return FALSE;

    // Not kernel trace, so check query name
    if ((BOOL)( 0 == ( pNewQuery->dwFlags & SLQ_TLI_ENABLE_KERNEL_TRACE ) ) ) {
        if ( 0 != lstrcmpi ( pOrigQuery->szLoggerName, pNewQuery->szQueryName ) ) {
            return FALSE;
        }
    }

    bRequested = (BOOL)( 0 != ( pNewQuery->dwFlags & SLQ_TLI_ENABLE_KERNEL_TRACE ) );
    bCurrent = IsEqualGUID( &pOrigQuery->Properties.Wnode.Guid, &SystemTraceControlGuid );
    
    if ( bRequested != bCurrent ) {
        return FALSE;
    }

    // Extended memory trace

    bRequested = (BOOL)( 0 != ( pNewQuery->dwFlags & SLQ_TLI_ENABLE_MEMMAN_TRACE ) );
    bCurrent = (BOOL)( 0 != ( pOrigQuery->Properties.EnableFlags & EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS ) ); 

    if ( bRequested != bCurrent ) {
        return FALSE;
    }

    // Extended I/O trace

    bRequested = (BOOL)( 0 != ( pNewQuery->dwFlags & SLQ_TLI_ENABLE_FILEIO_TRACE ) );
    bCurrent = (BOOL)( 0 != ( pOrigQuery->Properties.EnableFlags & EVENT_TRACE_FLAG_DISK_FILE_IO ) ); 

    if ( bRequested != bCurrent ) {
        return FALSE;
    }

    if ( -1 == pNewQuery->dwMaxFileSize ) {
        if ( 0 != pOrigQuery->Properties.MaximumFileSize ) {
            return FALSE;
        }
    } else if ( pOrigQuery->Properties.MaximumFileSize != pNewQuery->dwMaxFileSize ) {
        return FALSE;
    }

    if ( ( SLF_SEQ_TRACE_FILE == pNewQuery->dwLogFileType ) 
            && ( EVENT_TRACE_FILE_MODE_SEQUENTIAL != pOrigQuery->Properties.LogFileMode ) ) {
        return FALSE;
    } else if ( ( SLF_CIRC_TRACE_FILE == pNewQuery->dwLogFileType ) 
            && ( EVENT_TRACE_FILE_MODE_CIRCULAR != pOrigQuery->Properties.LogFileMode ) ) {
        return FALSE;        
    }

    // Compare each provider string against array element.
    for (pszThisGuid = pNewQuery->mszProviderList;
            *pszThisGuid != 0;
            pszThisGuid += lstrlen(pszThisGuid) + 1) {
        ulGuidCount += 1;
    }

    if ( pOrigQuery->ulGuidCount != ulGuidCount )
        return FALSE;

    ulGuidIndex = 0;
    pszThisFlag = pNewQuery->mszProviderFlags;
    pszThisLevel = pNewQuery->mszProviderLevels;
    for (pszThisGuid = pNewQuery->mszProviderList;
            *pszThisGuid != 0;
            pszThisGuid += lstrlen(pszThisGuid) + 1) {

        if ( 0 != lstrcmpi ( pOrigQuery->arrpGuid[ulGuidIndex].pszProviderName, pszThisGuid ) )
            return FALSE;

        if (pszThisFlag) {
            if (*pszThisFlag) {
                dwFlag = ahextoi(pszThisFlag);
                pszThisFlag += lstrlen(pszThisFlag) + 1;
            }
        }
        else {
            dwFlag = 0;
        }

        if (pOrigQuery->arrpGuid[ulGuidIndex].dwFlag != dwFlag) {
            return FALSE;
        }

        if (pszThisLevel) {
            if ( *pszThisLevel) {
                dwLevel = ahextoi(pszThisLevel);
                pszThisLevel += lstrlen(pszThisLevel) + 1;
            }
        }
        else {
            dwLevel = 0;
        }

        if (pOrigQuery->arrpGuid[ulGuidIndex].dwLevel != dwLevel) {
            return FALSE;
        }

        ulGuidIndex++;
        assert ( ulGuidIndex <= ulGuidCount );
    }
    return TRUE;
#else 
    return FALSE;
#endif
}


BOOL
AlertFieldsMatch (
    IN PLOG_QUERY_DATA pFirstQuery,
    IN PLOG_QUERY_DATA pSecondQuery )
{
    if ( pFirstQuery->dwAlertActionFlags != pSecondQuery->dwAlertActionFlags )
        return FALSE;

    if ( 0 != (pFirstQuery->dwAlertActionFlags & ALRT_ACTION_SEND_MSG) ) {     
        if ( 0 != lstrcmpi ( pFirstQuery->szNetName, pSecondQuery->szNetName ) ) {
            return FALSE;
        }
    }

    if ( 0 != (pFirstQuery->dwAlertActionFlags & ALRT_ACTION_EXEC_CMD) ) {     
        if ( 0 != lstrcmpi ( pFirstQuery->szCmdFileName, pSecondQuery->szCmdFileName ) ) {
            return FALSE;
        }

        if ( 0 != (pFirstQuery->dwAlertActionFlags & ALRT_CMD_LINE_U_TEXT ) ) {     
            if ( 0 != lstrcmpi ( pFirstQuery->szUserText, pSecondQuery->szUserText ) ) {
                return FALSE;
            }
        }
    }

    if ( 0 != (pFirstQuery->dwAlertActionFlags & ALRT_ACTION_START_LOG) ) {     
        if ( 0 != lstrcmpi ( pFirstQuery->szPerfLogName, pSecondQuery->szPerfLogName ) ) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
CommonFieldsMatch (
    IN PLOG_QUERY_DATA pFirstQuery,
    IN PLOG_QUERY_DATA pSecondQuery )
{
    if ( pFirstQuery->dwCurrentState != pSecondQuery->dwCurrentState )
        return FALSE;

    if ( pFirstQuery->dwLogFileType != pSecondQuery->dwLogFileType )
        return FALSE;

    if ( pFirstQuery->dwAutoNameFormat != pSecondQuery->dwAutoNameFormat )
        return FALSE;

    if ( pFirstQuery->dwMaxFileSize != pSecondQuery->dwMaxFileSize )
        return FALSE;

    if ( pFirstQuery->stiRegStart.dwAutoMode != pSecondQuery->stiRegStart.dwAutoMode )
        return FALSE;

    if ( pFirstQuery->stiRegStop.dwAutoMode != pSecondQuery->stiRegStop.dwAutoMode )
        return FALSE;

    if ( pFirstQuery->stiRepeat.dwAutoMode != pSecondQuery->stiRepeat.dwAutoMode )
        return FALSE;

    if ( pFirstQuery->stiRegStart.llDateTime != pSecondQuery->stiRegStart.llDateTime )
        return FALSE;

    if ( pFirstQuery->stiRegStop.llDateTime != pSecondQuery->stiRegStop.llDateTime )
        return FALSE;

    if ( pFirstQuery->stiRepeat.llDateTime != pSecondQuery->stiRepeat.llDateTime )
        return FALSE;

    if (( SLQ_COUNTER_LOG == pFirstQuery->dwLogType ) || 
        ( SLQ_TRACE_LOG == pFirstQuery->dwLogType)) {

        if ( 0 != lstrcmpi ( pFirstQuery->szBaseFileName, pSecondQuery->szBaseFileName ) )
            return FALSE;

        if ( 0 != lstrcmpi ( pFirstQuery->szLogFileFolder, pSecondQuery->szLogFileFolder ) )
            return FALSE;

        if ( 0 != lstrcmpi ( pFirstQuery->szSqlLogName, pSecondQuery->szSqlLogName ) )
            return FALSE;

        if ( 0 != lstrcmpi ( pFirstQuery->szLogFileComment, pSecondQuery->szLogFileComment ) )
            return FALSE;
    
        if ( pFirstQuery->dwCurrentSerialNumber != pSecondQuery->dwCurrentSerialNumber )
            return FALSE;

        if ( pFirstQuery->dwLogFileSizeUnit != pSecondQuery->dwLogFileSizeUnit )
            return FALSE;

        if ( pFirstQuery->dwAppendMode != pSecondQuery->dwAppendMode      )
            return FALSE;

        if ( pFirstQuery->stiCreateNewFile.dwAutoMode != pSecondQuery->stiCreateNewFile.dwAutoMode )
            return FALSE;

        if ( pFirstQuery->stiCreateNewFile.llDateTime != pSecondQuery->stiCreateNewFile.llDateTime )
            return FALSE;

        if ( 0 != lstrcmpi(pFirstQuery->szCmdFileName, pSecondQuery->szCmdFileName ) )
            return FALSE;
    }

    if (( SLQ_COUNTER_LOG == pFirstQuery->dwLogType ) || 
        ( SLQ_ALERT == pFirstQuery->dwLogType)) {

        LPWSTR          szFirstPath;
        LPWSTR          szSecondPath;

        if ( pFirstQuery->dwMillisecondSampleInterval != pSecondQuery->dwMillisecondSampleInterval ) {
            return FALSE;
        }
        
        // Compare each counter string.  Note:  If counter order has changed, the query is
        // reconfigured.
        // For Alert queries, this code also checks the limit threshold logic and value.
        szSecondPath = pSecondQuery->mszCounterList;
        for ( szFirstPath = pFirstQuery->mszCounterList;
                *szFirstPath != 0;
                szFirstPath += lstrlen(szFirstPath) + 1) {

            if ( 0 != lstrcmpi( szFirstPath, szSecondPath ) ) {
                return FALSE;
            }    
            szSecondPath += lstrlen(szSecondPath) + 1;
        }
    
        if ( 0 != *szSecondPath ) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
FieldsMatch (
    IN PLOG_QUERY_DATA pFirstQuery,
    IN PLOG_QUERY_DATA pSecondQuery )
{
    assert ( pFirstQuery->dwLogType == pSecondQuery->dwLogType );

    if ( !CommonFieldsMatch ( pFirstQuery, pSecondQuery ) ) 
        return FALSE;

    if ( SLQ_ALERT == pFirstQuery->dwLogType ) {
        if ( !AlertFieldsMatch( pFirstQuery, pSecondQuery ) ) {
            return FALSE;
        }
    } else if ( SLQ_TRACE_LOG == pFirstQuery->dwLogType ) {
        LPWSTR  szFirstProv;
        LPWSTR  szSecondProv;

        if ( pFirstQuery->dwBufferSize != pSecondQuery->dwBufferSize )
            return FALSE;

        if ( pFirstQuery->dwBufferMinCount != pSecondQuery->dwBufferMinCount )
            return FALSE;

        if ( pFirstQuery->dwBufferMaxCount != pSecondQuery->dwBufferMaxCount )
            return FALSE;

        if ( pFirstQuery->dwBufferFlushInterval != pSecondQuery->dwBufferFlushInterval )
            return FALSE;

        if ( pFirstQuery->dwFlags != pSecondQuery->dwFlags )
            return FALSE;

        szSecondProv = pSecondQuery->mszProviderList;

        for ( szFirstProv = pFirstQuery->mszProviderList;
            *szFirstProv != 0;
            szFirstProv += lstrlen(szFirstProv) + 1) {

            if ( 0 != lstrcmpi ( szFirstProv, szSecondProv ) )
                return FALSE;

            szSecondProv += lstrlen(szSecondProv) + 1;
        }
    
        if ( 0 != *szSecondProv) {
            return FALSE;
        }
    } else if ( SLQ_COUNTER_LOG == pFirstQuery->dwLogType ) {
        if ( pFirstQuery->stiCreateNewFile.dwAutoMode != pSecondQuery->stiCreateNewFile.dwAutoMode ) {
            return FALSE;
        } else {
            if ( SLQ_AUTO_MODE_AFTER == pFirstQuery->stiCreateNewFile.dwAutoMode 
                && pFirstQuery->stiCreateNewFile.llDateTime != pSecondQuery->stiCreateNewFile.llDateTime ) {
                return FALSE;
            } // else change in max size handled in commmon fields match check.
        }
    }

    return TRUE;
}


DWORD
IsModified (
    IN PLOG_QUERY_DATA pQuery,
    OUT BOOL* pbModified
)
{
    DWORD dwStatus = ERROR_SUCCESS;
    SLQ_TIME_INFO   stiLastModified;
    SLQ_TIME_INFO   stiDefault;

    *pbModified = TRUE;

    // Check the last read date against 'last modified' in
    // the registry.  
    // If it is earlier than the registry, and the data in the
    // registry has changed, return TRUE.
    //
    // The check of thread data against registry data reduces the
    // number of times that the logging thread is interrupted.
    // This is necessary because each property page OnApply 
    // generates this check.
    //
    stiDefault.wDataType = SLQ_TT_DTYPE_DATETIME;
    stiDefault.wTimeType = SLQ_TT_TTYPE_LAST_MODIFIED;
    stiDefault.dwAutoMode = SLQ_AUTO_MODE_AT;
    stiDefault.llDateTime = MAX_TIME_VALUE;

    dwStatus = ReadRegistrySlqTime (
        pQuery->hKeyQuery,
        pQuery->szQueryName,
        L"Last Modified",
        &stiDefault,
        &stiLastModified );

    //
    // Status always success if default provided.
    //
    assert( ERROR_SUCCESS == dwStatus );
    //
    // LastModified and LastConfigured are stored as GMT
    //
    if ( stiLastModified.llDateTime <= pQuery->llLastConfigured ) {
        *pbModified = FALSE;
    } else {
        LOG_QUERY_DATA TempQuery;

        memset (&TempQuery, 0, sizeof(TempQuery));
        StringCchCopy (TempQuery.szQueryName, MAX_PATH + 1, pQuery->szQueryName );
        TempQuery.hKeyQuery = pQuery->hKeyQuery;

        if ( ERROR_SUCCESS != LoadQueryConfig( &TempQuery ) ) {
            // Event has been logged.  Set mod flag to stop the query.
            *pbModified = TRUE;
        } else {
            *pbModified = !FieldsMatch ( pQuery, &TempQuery );
        }

        // Delete memory allocated by registry data load.
        DeallocateQueryBuffers ( &TempQuery );
    }

    return dwStatus;
}



DWORD
ReconfigureQuery (
    IN PLOG_QUERY_DATA pQuery )
{
    DWORD dwStatus = ERROR_SUCCESS;
    LOG_QUERY_DATA TempQuery;
    BOOL bStopQuery = FALSE;

        
    // *** Optimization - perform this check within IsModified, to avoid extra
    // load from the registry.
    memset (&TempQuery, 0, sizeof(TempQuery));
    StringCchCopy (TempQuery.szQueryName, MAX_PATH + 1, pQuery->szQueryName );
    TempQuery.hKeyQuery = pQuery->hKeyQuery;

    if ( ERROR_SUCCESS != LoadQueryConfig( &TempQuery ) ) {
        // Event has been logged.  Stop the query.
        bStopQuery = TRUE;
    } else {
        bStopQuery = ( NULL_INTERVAL_TICS == ComputeStartWaitTics ( &TempQuery, FALSE ) );
    } 

    if ( bStopQuery ) {
        SetEvent (pQuery->hExitEvent);
    } else {

        // Set reconfiguration flag so that the log thread processing knows that
        // this is not the initial configuration.  The ProcessLogFileFolder uses
        // this flag to determine which error event to report.
        pQuery->bReconfiguration = TRUE;

        if (( SLQ_COUNTER_LOG == pQuery->dwLogType ) || 
            ( SLQ_ALERT == pQuery->dwLogType ) ){
        // Signal the logging thread to reconfigure.
            pQuery->bLoadNewConfig= TRUE;
            SetEvent (pQuery->hReconfigEvent);
        } else {
#if _IMPLEMENT_WMI
            BOOL bMustStopRestart;
            
            assert( SLQ_TRACE_LOG == pQuery->dwLogType );
            
            //
            // Change the current query.  For some properties, this
            // means stopping then restarting the query.
            // 
                
            bMustStopRestart = !TraceStopRestartFieldsMatch ( pQuery, &TempQuery );
                
            if ( !bMustStopRestart ) {

                if ( ERROR_SUCCESS != LoadQueryConfig( pQuery ) ) {
                    SetEvent (pQuery->hExitEvent);
                } else {

                    // Update the trace log session.  Do not increment
                    // the file autoformat serial number.
                    // File name serial number is already incremented.
                    InitTraceProperties ( pQuery, FALSE, NULL, NULL );

                    dwStatus = GetTraceQueryStatus ( pQuery, NULL );

                    if ( ERROR_SUCCESS == dwStatus ) {
                        dwStatus = UpdateTrace(
                                    pQuery->LoggerHandle, 
                                    pQuery->szLoggerName, 
                                    &pQuery->Properties );
                    }
                }

            } else {
                // Signal the logging thread to reconfigure.
                pQuery->bLoadNewConfig= TRUE;
                SetEvent (pQuery->hReconfigEvent);

            }
        }
    }
#else
    dwStatus = ERROR_CALL_NOT_IMPLEMENTED;
#endif
    return dwStatus;
}


DWORD
GetTraceQueryStatus (
    IN PLOG_QUERY_DATA pQuery,
    IN OUT PLOG_QUERY_DATA pReturnQuery )
{
    DWORD dwStatus = ERROR_SUCCESS;
#if _IMPLEMENT_WMI
    PLOG_QUERY_DATA pLocalQuery = NULL;

    if ( NULL != pQuery ) {
    
        if ( NULL != pReturnQuery ) {
            pLocalQuery = pReturnQuery;
        } else {
            pLocalQuery = G_ALLOC ( sizeof (LOG_QUERY_DATA) );
        }

        if ( NULL != pLocalQuery ) {
            ClearTraceProperties ( pLocalQuery );
    
            pLocalQuery->Properties.Wnode.BufferSize = sizeof(pQuery->Properties)
                                                  + sizeof(pQuery->szLoggerName)
                                                  + sizeof(pQuery->szLogFileName);

            pLocalQuery->Properties.Wnode.Flags = WNODE_FLAG_TRACED_GUID; 
      
            dwStatus = QueryTrace (
                            pQuery->LoggerHandle, 
                            pQuery->szLoggerName,
                            &pLocalQuery->Properties );

            if ( NULL == pReturnQuery ) {
                G_FREE ( pLocalQuery );
            }
        } else {
            dwStatus = ERROR_OUTOFMEMORY;
        }
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }

#else
     dwStatus = ERROR_CALL_NOT_IMPLEMENTED;
#endif
    return dwStatus;
}

void
CloseTraceLogger ( 
    IN PLOG_QUERY_DATA pQuery )
{

    DWORD dwIndex;
    
    if ( SLQ_TRACE_LOG == pQuery->dwLogType ) {
        if ( !( pQuery->Properties.EnableFlags & EVENT_TRACE_FLAG_PROCESS
                || pQuery->Properties.EnableFlags & EVENT_TRACE_FLAG_THREAD
                || pQuery->Properties.EnableFlags & EVENT_TRACE_FLAG_DISK_IO
                || pQuery->Properties.EnableFlags & EVENT_TRACE_FLAG_NETWORK_TCPIP ) ) 
        {            
            for (dwIndex = 0; dwIndex < pQuery->ulGuidCount; dwIndex++) {

                EnableTrace (
                    FALSE,
                    pQuery->arrpGuid[dwIndex].dwFlag,
                    pQuery->arrpGuid[dwIndex].dwLevel,
                    &pQuery->arrpGuid[dwIndex].Guid, 
                    pQuery->LoggerHandle);
            }
        }

        StopTrace (
            pQuery->LoggerHandle, 
            pQuery->szLoggerName, 
            &pQuery->Properties );
    }
}

DWORD
StartQuery (
    IN PLOG_QUERY_DATA pQuery )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    LPWSTR  szStringArray[2];

    HANDLE  hThread = NULL;
    DWORD   dwThreadId;

    pQuery->bLoadNewConfig= FALSE;
    
    //
    // Create the logging thread.
    //
    hThread = CreateThread (
        NULL, 0, LoggingThreadProc,
        (LPVOID)pQuery, 0, &dwThreadId);

    if ( NULL != hThread ) {
        pQuery->hThread = hThread;
    } else {
        //
        // Unable to start thread.
        //
        dwStatus = GetLastError();
        szStringArray[0] = pQuery->szQueryName;
        ReportEvent (hEventLog,
            EVENTLOG_WARNING_TYPE,
            0,
            SMLOG_UNABLE_START_THREAD,
            NULL,
            1,
            sizeof(DWORD),
            szStringArray,
            (LPVOID)&dwStatus);
    }

    if ( ERROR_SUCCESS != dwStatus ) {
        SetStoppedStatus ( pQuery );
    }

    return dwStatus;
}


DWORD
SetStoppedStatus (
    IN PLOG_QUERY_DATA pQuery )
{
    DWORD           dwStatus;
    LONGLONG        llTime = 0;

    //
    // Ignore bad status
    //
    pQuery->dwCurrentState = SLQ_QUERY_STOPPED;
    dwStatus = WriteRegistryDwordValue (
                    pQuery->hKeyQuery, 
                    L"Current State",
                    &pQuery->dwCurrentState,
                    REG_DWORD );

    if ( SLQ_AUTO_MODE_NONE == pQuery->stiRegStart.dwAutoMode ) {
        pQuery->stiRegStart.llDateTime = MAX_TIME_VALUE;
        dwStatus = WriteRegistrySlqTime (
                        pQuery->hKeyQuery, 
                        L"Start",
                        &pQuery->stiRegStart);
    }

    GetLocalFileTime ( &llTime );

    // If stop is manual or StopAt with time before now (no repeat), set to manual 
    // with MIN_TIME_VALUE
    if ( SLQ_AUTO_MODE_NONE == pQuery->stiRegStop.dwAutoMode ) {
        pQuery->stiRegStop.dwAutoMode = SLQ_AUTO_MODE_NONE;
        pQuery->stiRegStop.llDateTime = MIN_TIME_VALUE;
        dwStatus = WriteRegistrySlqTime (
                        pQuery->hKeyQuery, 
                        L"Stop",
                        &pQuery->stiRegStop);

    } else if ( ( SLQ_AUTO_MODE_AT == pQuery->stiRegStop.dwAutoMode 
                && ( SLQ_AUTO_MODE_CALENDAR != pQuery->stiRepeat.dwAutoMode ) )
                && ( llTime >= pQuery->stiRegStop.llDateTime ) ) {

        pQuery->stiRegStop.dwAutoMode = SLQ_AUTO_MODE_NONE;
        pQuery->stiRegStop.llDateTime = MIN_TIME_VALUE;
        dwStatus = WriteRegistrySlqTime (
                        pQuery->hKeyQuery, 
                        L"Stop",
                        &pQuery->stiRegStop);
    } else if (  SLQ_AUTO_MODE_SIZE == pQuery->stiRegStop.dwAutoMode 
                && SLQ_AUTO_MODE_CALENDAR != pQuery->stiRepeat.dwAutoMode ) {
        // If Size mode and no repeat, set stop time to MIN_TIME_VALUE
        pQuery->stiRegStop.llDateTime = MIN_TIME_VALUE;
        dwStatus = WriteRegistrySlqTime (
                        pQuery->hKeyQuery, 
                        L"Stop",
                        &pQuery->stiRegStop);
    }

    return dwStatus;
}


DWORD
HandleMaxQueriesExceeded (
    IN PLOG_QUERY_DATA pQuery )
{
    DWORD dwStatus = ERROR_SUCCESS;

    //
    // The query has not been started yet, but still in "Start Pending" state.
    //
    SetStoppedStatus ( pQuery );

    return dwStatus;
}
    

DWORD 
ConfigureQuery (
    HKEY    hKeyLogQuery,
    LPWSTR  szQueryKeyNameBuffer,
    LPWSTR  szQueryNameBuffer )
{
    DWORD dwStatus = ERROR_SUCCESS;
    PLOG_QUERY_DATA   pQuery = NULL;

    pQuery = GetQueryData ( szQueryNameBuffer );
    if ( NULL != pQuery ) {
        BOOL    bModified;

        dwStatus = IsModified ( pQuery, &bModified );

        if (dwStatus == ERROR_SUCCESS) {
            if ( bModified ) {
                dwStatus = ReconfigureQuery ( pQuery );
                //
                // LastModified and LastConfigured values are stored as GMT
                //
                GetSystemTimeAsFileTime ( (LPFILETIME)(&pQuery->llLastConfigured) );
            }
        }
    } else {

        // No query data block found.  Create one and insert it into the list.
        BOOL    bStartQuery = FALSE;
        LPWSTR  szStringArray[2];

        // Allocate a thread info block.
        pQuery = G_ALLOC (sizeof(LOG_QUERY_DATA));
    
        if (pQuery != NULL) {
            //
            // Initialize the query data block
            //
            G_ZERO (pQuery, sizeof(LOG_QUERY_DATA));
        
            pQuery->hKeyQuery = hKeyLogQuery;
            StringCchCopy (pQuery->szQueryName, MAX_PATH + 1, szQueryNameBuffer);
            StringCchCopy (pQuery->szQueryKeyName, MAX_PATH + 1, szQueryKeyNameBuffer);

            //
            // Determine whether to continue, based on whether start wait time
            // is 0 or greater.

            // The thread is reinitialized in the logging procedure.
            // This pre-check avoids spurious thread creation.
            //
            dwStatus = LoadQueryConfig( pQuery );

            if ( ERROR_SUCCESS != dwStatus ) {
                //
                // Event already logged.
                //
                bStartQuery = FALSE;
            } else {
                bStartQuery = ( NULL_INTERVAL_TICS != ComputeStartWaitTics ( pQuery, FALSE ) );
            }

            if ( bStartQuery ) {

                LockQueryData();

                if ( dwActiveSessionCount < dwMaxActiveSessionCount ) {
                    pQuery->hExitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

                    if ( NULL != pQuery->hExitEvent ) {
    
                        pQuery->hReconfigEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

                        if ( NULL != pQuery->hReconfigEvent ) {
                            //
                            // LastModified and LastConfigured values are stored as GMT
                            //
                            GetSystemTimeAsFileTime ( (LPFILETIME)(&pQuery->llLastConfigured) );

                            dwStatus = StartQuery( pQuery );

                            if ( ERROR_SUCCESS == dwStatus ) {
                                //
                                // Add the query to the list and continue
                                if (pFirstQuery == NULL) {
                                    //
                                    // This is the first thread so add it
                                    //
                                    pQuery->next = NULL;
                                    pFirstQuery = pQuery;
                                } else {
                                    //
                                    // Insert this at the head of the list since
                                    // that's the easiest and the order isn't
                                    // really important.
                                    //
                                    pQuery->next = pFirstQuery;
                                    pFirstQuery = pQuery;
                                }

                                dwActiveSessionCount += 1;
                                SetEvent (hNewQueryEvent );
                
                            } else {
                                // Unable to start query.
                                // Event has already been logged.
                                FreeQueryData ( pQuery );                                   
                            }
                        } else {
                            // Unable to create reconfig event.
                            dwStatus = GetLastError();
                            szStringArray[0] = szQueryNameBuffer;
                            ReportEvent (hEventLog,
                                EVENTLOG_WARNING_TYPE,
                                0,
                                SMLOG_UNABLE_CREATE_RECONFIG_EVENT,
                                NULL,
                                1,
                                sizeof(DWORD),
                                szStringArray,
                                (LPVOID)&dwStatus);

                            FreeQueryData( pQuery );      
                        }
                    } else {
                        // Unable to create exit event.
                        dwStatus = GetLastError();
                        szStringArray[0] = szQueryNameBuffer;
                        ReportEvent (hEventLog,
                            EVENTLOG_WARNING_TYPE,
                            0,
                            SMLOG_UNABLE_CREATE_EXIT_EVENT,
                            NULL,
                            1,
                            sizeof(DWORD),
                            szStringArray,
                            (LPVOID)&dwStatus);

                        FreeQueryData( pQuery );                
                    }
                        
                } else {

                    szStringArray[0] = szQueryNameBuffer;
                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_MAXIMUM_QUERY_LIMIT,
                        NULL,
                        1,
                        0,
                        szStringArray,
                        NULL);

                    dwStatus = HandleMaxQueriesExceeded ( pQuery );

                    FreeQueryData ( pQuery );                                   
                }

                UnlockQueryData();

            } else {
                // Wait time is -1, or config load error.
                FreeQueryData( pQuery );                
            }
        } else {
            // Memory allocation error.
            dwStatus = GetLastError();
            szStringArray[0] = szQueryNameBuffer;
            ReportEvent (hEventLog,
                EVENTLOG_WARNING_TYPE,
                0,
                SMLOG_UNABLE_ALLOCATE_DATABLOCK,
                NULL,
                1,
                sizeof(DWORD),
                szStringArray,
                (LPVOID)&dwStatus);
        }
    }

    return dwStatus;
}

DWORD
DoLogCommandFile (
    IN  PLOG_QUERY_DATA pArg,
    IN  LPWSTR          szLogFileName,
    IN  BOOL            bStillRunning
)
{
    DWORD   dwStatus;
    BOOL    bStatus = FALSE;
    const   INT ciExtraChars = 4;
    size_t  sizeCmdBufLen = 0;
    size_t  sizeBufLen = 0;
    size_t  sizeStrLen = 0;
    LPWSTR  szCommandString = NULL;
    LPWSTR  szTempBuffer = NULL;
    LONG    lErrorMode;
    LPWSTR  szStringArray[3];
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    DWORD   dwCreationFlags = NORMAL_PRIORITY_CLASS;

    if ( NULL != pArg && NULL != szLogFileName ) {

        if ( NULL != pArg->szCmdFileName ) { 
 
            dwStatus = pArg->dwCmdFileFailure;

            if ( ERROR_SUCCESS == dwStatus ) {

                sizeStrLen = lstrlen ( szLogFileName );
                sizeCmdBufLen = sizeStrLen + ciExtraChars + 1;       // 1 is for NULL
                
                szCommandString = (LPWSTR)G_ALLOC(sizeCmdBufLen * sizeof(WCHAR));

                sizeBufLen = sizeCmdBufLen + lstrlen ( pArg->szCmdFileName ) + 1; // 1 is for space char, 
                                                                // NULL already counted.
        
                szTempBuffer = (LPWSTR)G_ALLOC(sizeBufLen * sizeof(WCHAR));

                if ( NULL != szCommandString && NULL != szTempBuffer ) {
                    // build command line arguments
                    szCommandString[0] = L'\"';
                    StringCchCopy (&szCommandString[1], (sizeCmdBufLen - 1), szLogFileName );
                    StringCchCopy (
                        &szCommandString[sizeStrLen+1], 
                        (sizeCmdBufLen - (sizeStrLen+1)),
                        L"\" ");
                    StringCchCopy (
                        &szCommandString[sizeStrLen+3],
                        (sizeCmdBufLen - (sizeStrLen+3)),                        
                        (bStillRunning ? L"1" : L"0" ) );

                    // initialize Startup Info block
                    memset (&si, 0, sizeof(si));
                    si.cb = sizeof(si);
                    si.dwFlags = STARTF_USESHOWWINDOW ;
                    si.wShowWindow = SW_SHOWNOACTIVATE ;
                    
                    //si.lpDesktop = L"WinSta0\\Default";
                    memset (&pi, 0, sizeof(pi));

                    // supress pop-ups in the detached process
                    lErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

                    StringCchCopy (szTempBuffer, sizeBufLen, pArg->szCmdFileName) ;

                    // see if this is a CMD or a BAT file
                    // if it is then create a process with a console window, otherwise
                    // assume it's an executable file that will create it's own window
                    // or console if necessary
                    //
                    _wcslwr (szTempBuffer);
                    if ((wcsstr(szTempBuffer, L".bat") != NULL)
                        || (wcsstr(szTempBuffer, L".cmd") != NULL))
                    {
                            dwCreationFlags |= CREATE_NEW_CONSOLE;
                    } else {
                            dwCreationFlags |= DETACHED_PROCESS;
                    }
               
                    // recopy the image name to the temp buffer since it was modified
                    // (i.e. lowercased) for the previous comparison.

                    szTempBuffer[0] = L'\"';
                    StringCchCopy (
                        &szTempBuffer[1], 
                        sizeBufLen - 1,
                        pArg->szCmdFileName) ;

                    StringCchLength (
                        szTempBuffer, 
                        sizeBufLen - 1, 
                        &sizeStrLen) ;
                    szTempBuffer[sizeStrLen] = L'\"';
                    sizeStrLen++;

                    // now add on the text args preceded with a space char
                    szTempBuffer [sizeStrLen] = L' ' ;
                    sizeStrLen++ ;
                    StringCchCopy (
                        &szTempBuffer[sizeStrLen], 
                        sizeBufLen - sizeStrLen, 
                        szCommandString) ;

                    //
                    // The lpApplication name is NULL for CreateProcess 
                    // because the normal use of this function is to launch
                    // batch files which must be the first part of the lpCommandLine.
                    // The quotes around the szCommandFileName prevents the wrong
                    // file from being executed.
                    //

                    if( pArg->hUserToken != NULL ){
                        bStatus = CreateProcessAsUser (
                            pArg->hUserToken,
                            NULL,
                            szTempBuffer,
                            NULL, NULL, FALSE,
                            dwCreationFlags,
                            NULL,
                            NULL,
                            &si,
                            &pi);
                    } else {
                        bStatus = CreateProcess (
                            NULL,
                            szTempBuffer,
                            NULL, NULL, FALSE,
                            dwCreationFlags,
                            NULL,
                            NULL,
                            &si,
                            &pi);
                    }

                    SetErrorMode(lErrorMode);
                
                    if (bStatus) {
                        dwStatus = ERROR_SUCCESS;
                        if ( NULL != pi.hThread && INVALID_HANDLE_VALUE != pi.hThread ) {
                            CloseHandle(pi.hThread);
                            pi.hThread = NULL;
                        }
                        if ( NULL != pi.hProcess && INVALID_HANDLE_VALUE != pi.hProcess ) {
                            CloseHandle(pi.hProcess);
                            pi.hProcess = NULL;
                        }
                    
                    } else {
                        dwStatus = GetLastError();
                    }
                } else {
                    dwStatus = ERROR_OUTOFMEMORY;
                }
            
                if ( ERROR_SUCCESS != dwStatus ) { 

                    szStringArray[0] = szTempBuffer;
                    szStringArray[1] = pArg->szQueryName;
                    szStringArray[2] = FormatEventLogMessage(dwStatus);

                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_LOG_CMD_FAIL,
                        NULL,
                        3,
                        sizeof(DWORD),
                        szStringArray,
                        (LPVOID)&dwStatus );
        
                    LocalFree( szStringArray[2] );

                    pArg->dwCmdFileFailure = dwStatus;
                }
                
                if ( szCommandString != NULL ) {
                    G_FREE ( szCommandString );
                }

                if ( szTempBuffer != NULL ) {
                    G_FREE ( szTempBuffer );
                }
            }
        } else {
            dwStatus = ERROR_INVALID_PARAMETER;
        }
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}

DWORD
GetQueryKeyName (
    IN  LPCWSTR  szQueryName,
    OUT LPWSTR   szQueryKeyName,
    IN  DWORD    dwQueryKeyNameLen )
{
    DWORD dwStatus = ERROR_SUCCESS;
    HKEY    hKeyLogQueries = NULL;
    HKEY    hKeyThisLogQuery = NULL;
    DWORD   dwQueryIndex;
    WCHAR   szQueryNameBuffer[MAX_PATH+1];
    DWORD   cchQueryNameBufLen;
    WCHAR   szQueryClassBuffer[MAX_PATH+1];
    DWORD   cchQueryClassBufLen;
    LPWSTR  szCollectionName = NULL;            
    UINT    uiCollectionNameLen = 0;            

    assert ( 0 < lstrlen ( szQueryName ) );

    if ( NULL != szQueryName 
            && NULL != szQueryKeyName ) {
        if ( 0 < lstrlen ( szQueryName ) 
            && 0 < dwQueryKeyNameLen ) {
            //
            // Note:  This method does not reallocate buffer or return
            // actual buffer size required.
            //
            memset ( szQueryKeyName, 0, dwQueryKeyNameLen * sizeof (WCHAR) );

            dwStatus = OpenLogQueriesKey (
                            KEY_READ,
                            (PHKEY)&hKeyLogQueries);

            if (dwStatus != ERROR_SUCCESS) {
                //
                // Unable to read the log query information from the registry.
                //
                dwStatus = GetLastError();
                ReportEvent (hEventLog,
                        EVENTLOG_ERROR_TYPE,
                        0,
                        SMLOG_UNABLE_OPEN_LOG_QUERY,
                        NULL,
                        0,
                        0,
                        NULL,
                        NULL);
            } else {
                //    
                // Enumerate the queries in the registry.
                //
                dwQueryIndex = 0;
                *szQueryNameBuffer = L'\0';
                cchQueryNameBufLen = MAX_PATH+1;
                *szQueryClassBuffer = L'\0';
                cchQueryClassBufLen = MAX_PATH+1;

                while ( (dwStatus = RegEnumKeyEx (
                    hKeyLogQueries,
                    dwQueryIndex,
                    szQueryNameBuffer,
                    &cchQueryNameBufLen,
                    NULL,
                    szQueryClassBuffer,
                    &cchQueryClassBufLen,
                    NULL)) != ERROR_NO_MORE_ITEMS ) 
                {
                    //
                    // Open key for specified log.
                    //
                    dwStatus = RegOpenKeyEx (
                        hKeyLogQueries,
                        szQueryNameBuffer,
                        0L,
                        KEY_READ,
                        (PHKEY)&hKeyThisLogQuery);

                    if (dwStatus == ERROR_SUCCESS) {
                        if ( 0 == lstrcmpi ( szQueryNameBuffer, szQueryName ) ) {
                            // TodoSec:  Fail on truncation?
                            StringCchCopy ( szQueryKeyName, dwQueryKeyNameLen, szQueryName );
                            break;
                        } else {
                            dwStatus = SmReadRegistryIndirectStringValue (
                                        hKeyThisLogQuery,
                                        L"Collection Name",
                                        NULL,
                                        &szCollectionName,
                                        &uiCollectionNameLen );
            
                            if ( NULL != szCollectionName  ) {
                                if ( 0 < lstrlen ( szCollectionName ) ) {
                                    if ( 0 == lstrcmpi ( szCollectionName, szQueryName ) ) {
                                        // TodoSec:  Fail on truncation?
                                        //
                                        // Copy the corresponding query key name to the buffer.
                                        //
                                        StringCchCopy ( 
                                            szQueryKeyName,
                                            dwQueryKeyNameLen,
                                            szQueryNameBuffer );
                                        break;
                                    }
                                }
                                G_FREE ( szCollectionName );
                                szCollectionName = NULL;
                                uiCollectionNameLen = 0;
                            }
                        }
                    }
                    if ( NULL != hKeyThisLogQuery ) {
                        RegCloseKey ( hKeyThisLogQuery );
                        hKeyThisLogQuery = NULL;
                    }
                    // prepare for next loop
                    dwStatus = ERROR_SUCCESS;
                    dwQueryIndex++;
                    *szQueryNameBuffer = L'\0';
                    cchQueryNameBufLen = MAX_PATH+1;
                    *szQueryClassBuffer = L'\0';
                    cchQueryClassBufLen = MAX_PATH+1;
                } // end enumeration of log queries
            }

            if ( ERROR_NO_MORE_ITEMS == dwStatus ) {
                dwStatus = ERROR_SUCCESS;
            }
        } else {
            dwStatus = ERROR_INVALID_PARAMETER;
        }
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }
    
    //
    // Clean up here if break from while loop
    //

    if ( NULL != szCollectionName ) {
        G_FREE ( szCollectionName );
        szCollectionName = NULL;
        uiCollectionNameLen = 0;
    }
    if ( NULL != hKeyThisLogQuery ) {
        RegCloseKey ( hKeyThisLogQuery );
        hKeyThisLogQuery = NULL;
    }

    if ( NULL != hKeyLogQueries ) {
        RegCloseKey (hKeyLogQueries );
    }

    return dwStatus;
}


DWORD 
Configure ( void ) 
{
    DWORD   dwStatus;
    HKEY    hKeyLogQueries = NULL;
    HKEY    hKeyThisLogQuery = NULL;
    DWORD   dwQueryIndex;
    WCHAR   szQueryNameBuffer[MAX_PATH+1];
    DWORD   cchQueryNameBufLen;
    WCHAR   szQueryKeyNameBuffer[MAX_PATH+1];
    WCHAR   szQueryClassBuffer[MAX_PATH+1];
    DWORD   cchQueryClassBufLen;
    LPWSTR  szCollectionName = NULL;            
    UINT    uiCollectionNameLen = 0;            
    LPWSTR  szStringArray[2];

    __try {
        //
        // Open each query in the registry.
        //
        dwStatus = OpenLogQueriesKey (
                        KEY_READ,
                        (PHKEY)&hKeyLogQueries);

        if (dwStatus != ERROR_SUCCESS) {
            if (dwStatus == ERROR_FILE_NOT_FOUND) {
                //
                // No logs nor alerts settings, bail out quietly.
                //
                dwStatus = ERROR_SUCCESS;
            } else {
                //
                // Unable to read the log query information from the registry.
                //
                dwStatus = GetLastError();
                ReportEvent (hEventLog,
                        EVENTLOG_ERROR_TYPE,
                        0,
                        SMLOG_UNABLE_OPEN_LOG_QUERY,
                        NULL,
                        0,
                        0,
                        NULL,
                        NULL);
            }
        } else {
            //
            // Enumerate and restart or start the queries in the registry.
            //
            dwQueryIndex = 0;
            *szQueryNameBuffer = L'\0';
            cchQueryNameBufLen = MAX_PATH+1;
            *szQueryClassBuffer = L'\0';
            cchQueryClassBufLen = MAX_PATH+1;

            while ((dwStatus = RegEnumKeyEx (
                hKeyLogQueries,
                dwQueryIndex,
                szQueryNameBuffer,
                &cchQueryNameBufLen,
                NULL,
                szQueryClassBuffer,
                &cchQueryClassBufLen,
                NULL)) != ERROR_NO_MORE_ITEMS) {

                //
                // Open this key
                //
                dwStatus = RegOpenKeyEx (
                    hKeyLogQueries,
                    szQueryNameBuffer,
                    0L,
                    KEY_READ | KEY_WRITE,
                    (PHKEY)&hKeyThisLogQuery);

                if (dwStatus == ERROR_SUCCESS) {
                    //
                    // Update the service status
                    //
                    ssSmLogStatus.dwCheckPoint++;
                    SetServiceStatus (hSmLogStatus, &ssSmLogStatus);            

                    if ( 0 < lstrlen(szQueryNameBuffer) ) {
                        StringCchCopy ( 
                            szQueryKeyNameBuffer, 
                            MAX_PATH + 1,
                            szQueryNameBuffer );
                    }

                    dwStatus = SmReadRegistryIndirectStringValue (
                                hKeyThisLogQuery,
                                L"Collection Name",
                                NULL,
                                &szCollectionName,
                                &uiCollectionNameLen );
            
                    if ( NULL != szCollectionName ) {
                        if ( 0 < lstrlen ( szCollectionName ) ) {
                            StringCchCopy ( 
                                szQueryNameBuffer,
                                MAX_PATH + 1,
                                szCollectionName );
                        }

                        G_FREE ( szCollectionName );
                        szCollectionName = NULL;
                        uiCollectionNameLen = 0;
                    }

                    dwStatus = ConfigureQuery (
                                hKeyThisLogQuery,
                                szQueryKeyNameBuffer,
                                szQueryNameBuffer );
                    //
                    // hKeyThisLogQuery is stored in the Query data structure.
                    //
            
                } else {
                    szStringArray[0] = szQueryNameBuffer;
                    ReportEvent (hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,
                        SMLOG_UNABLE_READ_LOG_QUERY,
                        NULL,
                        1,
                        sizeof(DWORD),
                        szStringArray,
                        (LPVOID)&dwStatus);
                }
                //
                // Prepare for next loop.
                //
                dwStatus = ERROR_SUCCESS;
                dwQueryIndex++;
                *szQueryNameBuffer = L'\0';
                cchQueryNameBufLen = MAX_PATH+1;
                *szQueryClassBuffer = L'\0';
                cchQueryClassBufLen = MAX_PATH+1;
            } // End enumeration of log queries.
        }

        if ( ERROR_NO_MORE_ITEMS == dwStatus ) {
            dwStatus = ERROR_SUCCESS;
        }

    } __except ( EXCEPTION_EXECUTE_HANDLER ) {
        dwStatus = SMLOG_THREAD_FAILED;  
    }

    if ( NULL != hKeyLogQueries ) {
        RegCloseKey (hKeyLogQueries );
    }

    return dwStatus;
}


void 
SysmonLogServiceControlHandler(
    IN  DWORD dwControl
)
{
    PLOG_QUERY_DATA    pQuery;
    DWORD dwStatus;

    switch (dwControl) {

    case SERVICE_CONTROL_SYNCHRONIZE:
        EnterConfigure();
        dwStatus = Configure ();
        ExitConfigure();
        if ( ERROR_SUCCESS == dwStatus )
            break;
        //
        // If not successful, fall through to shutdown.
        // Errors already logged.
        //

    case SERVICE_CONTROL_SHUTDOWN:
    case SERVICE_CONTROL_STOP:
        
        //
        // Stop logging & close queries and files.
        // Set stop event for all running threads.
        //
        LockQueryData();

        ssSmLogStatus.dwCurrentState    = SERVICE_STOP_PENDING;
        SetServiceStatus (hSmLogStatus, &ssSmLogStatus);
        
        pQuery = pFirstQuery;

        while (pQuery != NULL) {
            SetEvent (pQuery->hExitEvent);
            pQuery = pQuery->next;
        }

        UnlockQueryData();
        break;

    case SERVICE_CONTROL_PAUSE:
        //
        // Stop logging, close queries and files.
        // Not supported.
        //
        break;
    case SERVICE_CONTROL_CONTINUE:
        //
        // Reload ration and restart logging
        // Not supported.
        //
        break;
    case SERVICE_CONTROL_INTERROGATE:
        //
        // Update current status.
        //
    default:
        // report to event log that an unrecognized control
        // request was received.
        SetServiceStatus (hSmLogStatus, &ssSmLogStatus);
    }
}


void
SysmonLogServiceStart (
    IN  DWORD   argc,
    IN  LPWSTR  *argv
)
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwQueryIndex;
    BOOL    bInteractive = FALSE;
    BOOL    bLogQueriesKeyExists = TRUE;
    BOOL    bWmiNotificationRegistered = FALSE;
    PLOG_QUERY_DATA pQuery;

    if ((argc == 1) && (*argv[0] == 'I')) {
        bInteractive = TRUE;
    }

    if (!bInteractive) {
        ssSmLogStatus.dwServiceType       = SERVICE_WIN32_OWN_PROCESS;
        ssSmLogStatus.dwCurrentState      = SERVICE_START_PENDING;
        ssSmLogStatus.dwControlsAccepted  = SERVICE_ACCEPT_STOP 
                                            | SERVICE_ACCEPT_SHUTDOWN;
        ssSmLogStatus.dwWin32ExitCode = 0;
        ssSmLogStatus.dwServiceSpecificExitCode = 0;
        ssSmLogStatus.dwCheckPoint = 0;
        ssSmLogStatus.dwWaitHint = 1000;

        hSmLogStatus = RegisterServiceCtrlHandler (
                            L"SysmonLog", 
                            SysmonLogServiceControlHandler );

        if (hSmLogStatus == (SERVICE_STATUS_HANDLE)0) {
            dwStatus = GetLastError();
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                SMLOG_UNABLE_REGISTER_HANDLER,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&dwStatus);
            //
            // This is fatal so bail out.
            //
        } 
    }

    if ( ERROR_SUCCESS == dwStatus ) {

        InitializeCriticalSection ( &QueryDataLock );
        InitializeCriticalSection ( &ConfigurationLock );

        dwStatus = ClearQueryRunStates();
        //
        // Continue even if query run state error, unless
        // the Log Queries key is missing or not accessible.
        //
        if ( SMLOG_UNABLE_OPEN_LOG_QUERY == dwStatus ) {
            bLogQueriesKeyExists = FALSE;
            //
            // Sleep long enough for event to be written to event log.
            //
            Sleep(500);
            if (!bInteractive) {
                ssSmLogStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
                //
                // Use status mask so that error matches the code in the application log.
                //
                ssSmLogStatus.dwServiceSpecificExitCode = (SMLOG_UNABLE_OPEN_LOG_QUERY & STATUS_MASK);
            }
        } else {
            dwStatus = ERROR_SUCCESS;
            //
            // Continue on error.
            //
            LoadDefaultLogFileFolder();
            
            //
            // Ignore PDH errors.  The only possible error is that the default 
            // data source has already been set for this process.
            // Set the default for the service to DATA_SOURCE_REGISTRY.
            //
            dwStatus = PdhSetDefaultRealTimeDataSource ( DATA_SOURCE_REGISTRY );
            
            //
            // Continue on error.
            //
            LoadPdhLogUpdateSuccess();

            hNewQueryEvent = CreateEvent ( NULL, TRUE, FALSE, NULL );

            if ( NULL == hNewQueryEvent ) {
                //
                // Unable to create new query configuration event.
                //
                dwStatus = GetLastError();
                ReportEvent (hEventLog,
                    EVENTLOG_WARNING_TYPE,
                    0,
                    SMLOG_UNABLE_CREATE_CONFIG_EVENT,
                    NULL,
                    0,
                    sizeof(DWORD),
                    NULL,
                    (LPVOID)&dwStatus);
                //
                // This is fatal so bail out.
                //
                if (!bInteractive) {
                    // Sleep long enough for event to be written to event log.
                    Sleep(500);
                    ssSmLogStatus.dwWin32ExitCode = dwStatus;
                }
            }

            if ( ( ERROR_SUCCESS == dwStatus ) && !bInteractive) {
                //
                // Thread synchronization mechanisms now created,
                // so set status to Running.
                //
                ssSmLogStatus.dwCurrentState = SERVICE_RUNNING;
                ssSmLogStatus.dwCheckPoint   = 0;
                SetServiceStatus (hSmLogStatus, &ssSmLogStatus);
            }

#if _IMPLEMENT_WMI
            if ( ERROR_SUCCESS == dwStatus ) {
// Disable 64-bit warning
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4152 )

                dwStatus = WmiNotificationRegistration (
                        (const LPGUID) & TraceErrorGuid,
                        TRUE,
                        TraceNotificationCallback,
                        0,
                        NOTIFICATION_CALLBACK_DIRECT );

                if ( ERROR_SUCCESS == dwStatus ) {
                    bWmiNotificationRegistered = TRUE;
                } else {
                    //
                    // Unable to create new query configuration event.
                    //
                    dwStatus = SMLOG_UNABLE_REGISTER_WMI;
                    ReportEvent (hEventLog,
                        EVENTLOG_ERROR_TYPE,
                        0,
                        SMLOG_UNABLE_REGISTER_WMI,
                        NULL,
                        0,
                        sizeof(DWORD),
                        NULL,
                        (LPVOID)&dwStatus);
                    //
                    // This is fatal so bail out.
                    //
                    if (!bInteractive) {
                        // Sleep long enough for event to be written to event log.
                        Sleep(500);
                        ssSmLogStatus.dwWin32ExitCode = dwStatus;
                    }
                }
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif
            }
#endif

            // Set up the queries and start threads.    

            __try {
                if ( ERROR_SUCCESS == dwStatus && bLogQueriesKeyExists) {
                    EnterConfigure();
                    dwStatus = Configure ();
                    ExitConfigure();
                }

                if ( NULL == pFirstQuery ) {
                    //
                    // Nothing to do.  Stop the service.
                    //
                    if (!bInteractive) {
                        ssSmLogStatus.dwCurrentState = SERVICE_STOP_PENDING;
                        SetServiceStatus (hSmLogStatus, &ssSmLogStatus);
                    }
                } else if ( ERROR_SUCCESS == dwStatus ) {
                    
                    //
                    // Loop in WaitForMultipleObjects.  When any
                    // query is signaled, deallocate that query data block
                    // and close its handles.  
                    //
                    while ( TRUE ) {
                        BOOL bStatus;

                        LockQueryData();
                        
                        //
                        // About to reconfigure the Wait array, so clear the event.
                        //
                        bStatus = ResetEvent ( hNewQueryEvent );

                        if ( NULL == pFirstQuery ) {

                            if (!bInteractive) {
                                ssSmLogStatus.dwCurrentState    = SERVICE_STOP_PENDING;
                                SetServiceStatus (hSmLogStatus, &ssSmLogStatus);
                            }

                            UnlockQueryData();
                            break;
                        } else {
                            DWORD dwIndex = 0;  
                            DWORD dwWaitStatus;

                            assert ( 0 < dwActiveSessionCount );

                            G_ZERO( arrSessionHandle, sizeof( HANDLE ) * ( dwActiveSessionCount + 1) );
                            
                            //
                            // The first element is the global hNewQueryEvent to signal new sessions.
                            //
                            arrSessionHandle[dwIndex] = hNewQueryEvent;
                            dwIndex++;

                            for ( pQuery = pFirstQuery;
                                    NULL != pQuery;
                                    pQuery = pQuery->next ) {

                                assert ( NULL != pQuery->hThread );
                                if ( NULL != pQuery->hExitEvent && NULL != pQuery->hThread ) {
                                    arrSessionHandle[dwIndex] = pQuery->hThread;
                                    dwIndex++;
                                    assert ( dwIndex <= dwActiveSessionCount + 1 );
                                }
                            }
                
                            UnlockQueryData();
                            dwWaitStatus = WaitForMultipleObjects (
                                            dwIndex,                
                                            arrSessionHandle, 
                                            FALSE,
                                            INFINITE ); 

                            if ( WAIT_FAILED != dwWaitStatus ){

                                //
                                // When here, either a new query has been started, or
                                // at least one logging thread or has terminated so the
                                // memory can be released.
                                //
                                dwQueryIndex = dwWaitStatus - WAIT_OBJECT_0;

                                // release the dynamic memory if the wait object is not the StartQuery event.
                                if ( 0 < dwQueryIndex && dwQueryIndex < dwIndex ) {
                                    SetStoppedStatus( GetQueryDataPtr( arrSessionHandle[dwQueryIndex] ) );
                                    RemoveAndFreeQueryData( arrSessionHandle[dwQueryIndex] );
                                }
                            } else {
                                // Todo: handle error
                                dwStatus = GetLastError();
                            } 
                        }
                    } // End while 
                }
            }
            __finally {

                // Key assumption here is that all logging threads have been terminated by this point,
                // so no need to lock the query data list before freeing the query.
            
                for ( pQuery = pFirstQuery;
                        NULL != pQuery;
                        pQuery = pQuery->next ) 
                {
                    if ( SLQ_TRACE_LOG == pQuery->dwLogType ) {
                        CloseTraceLogger ( pQuery );
                    } else {
                        // Counter log or alert.
                        if ( NULL != pQuery->hLog ) {
                            PdhCloseLog( pQuery->hLog, PDH_FLAGS_CLOSE_QUERY );
                            pQuery->hLog = NULL;
                            pQuery->hQuery = NULL;
                        } else {
                            PdhCloseQuery (pQuery->hQuery);
                            pQuery->hQuery = NULL;        
                        }
                    }

                    SetStoppedStatus( pQuery );
                    RemoveAndFreeQueryData( pQuery );
                }            
            }

#if _IMPLEMENT_WMI
// Disable 64-bit warning
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4152 )

            if ( bWmiNotificationRegistered ) {
                WmiNotificationRegistration(
                        (const LPGUID) & TraceErrorGuid,
                        FALSE,
                        TraceNotificationCallback,
                        0,
                        NOTIFICATION_CALLBACK_DIRECT);
            }
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif
#endif

            if ( NULL != hNewQueryEvent ) {
                CloseHandle ( hNewQueryEvent );
                hNewQueryEvent = NULL;
            }
        }

        DeleteCriticalSection ( &QueryDataLock );
        DeleteCriticalSection ( &ConfigurationLock );
    }

    if (!bInteractive) {
        // Update the service status
        ssSmLogStatus.dwCurrentState    = SERVICE_STOPPED;
        SetServiceStatus (hSmLogStatus, &ssSmLogStatus);
    }

    if ( NULL != arrPdhDataCollectSuccess ) { 
        G_FREE ( arrPdhDataCollectSuccess );
        arrPdhDataCollectSuccess = NULL;
        iPdhDataCollectSuccessCount = 0;
    }

    if (hEventLog != NULL) { 
        DeregisterEventSource ( hEventLog );
        hEventLog = NULL;
    }

    return;
}


int
__cdecl main (
    int argc,
    char *argv[])
/*++

main



Arguments


ReturnValue

    0 (ERROR_SUCCESS) if command was processed
    Non-Zero if command error was detected.

--*/
{
    DWORD    dwStatus = ERROR_SUCCESS;
    BOOL     bInteractive = FALSE;

    SERVICE_TABLE_ENTRY    DispatchTable[] = {
        {L"SysmonLog",    SysmonLogServiceStart },
        {NULL,            NULL                  }
    };

    hEventLog = RegisterEventSource (NULL, L"SysmonLog");

    hModule = (HINSTANCE) GetModuleHandle(NULL);

    if (argc > 1) {
        if ((argv[1][0] == '-') || (argv[1][0] == '/')) {
            if ((argv[1][1] == 'i') || (argv[1][1] == 'I')) {
                bInteractive = TRUE;
            }
        }
    }

    if (bInteractive) {
        DWORD   dwArgs = 1;
        LPWSTR  szArgs[1];
        szArgs[0] = L"I";
        SysmonLogServiceStart (dwArgs, szArgs);      
    } else {
        if (!StartServiceCtrlDispatcher (DispatchTable)) {
            dwStatus = GetLastError();
            // log failure to event log
            ReportEvent (hEventLog,
                EVENTLOG_ERROR_TYPE,
                0,
                SMLOG_UNABLE_START_DISPATCHER,
                NULL,
                0,
                sizeof(DWORD),
                NULL,
                (LPVOID)&dwStatus);
        } 
    }
    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogsvc\smlogsvc.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    smlogsvc.h

Abstract:

    Header file for the Performance Logs and Alerts service

--*/

#ifndef _SMLOGSVC_H_
#define _SMLOGSVC_H_

#include <pdh.h>
#include "common.h"

#if !(_IMPLEMENT_WMI)
#define TRACEHANDLE             HANDLE
#define EVENT_TRACE_PROPERTIES  LPVOID
#endif

#define     IDS_UNDER                       101
#define     IDS_OVER                        102
#define     IDS_ALERT_MSG_FMT               103
#define     IDS_ALERT_TIMESTAMP_FMT         104
#define     IDS_CNF_SERIAL_NUMBER_FMT       105

#define     IDS_ERR_COUNTER_NOT_VALIDATED   150

// Start or sample delay of NULL_INTERVAL = ULONG_MAX = INFINITE signals to stop immediately.
// The largest single wait time is thus ULONG_MAX -1.

#define NULL_INTERVAL ((DWORD)(INFINITE))   // == ULONG_MAX == 0xFFFFFFFF
#define NULL_INTERVAL_TICS ((LONGLONG)(-1)) // == 0xFFFFFFFF'FFFFFFFF
#define INFINITE_TICS ((LONGLONG)(-1))      // == 0xFFFFFFFF'FFFFFFFF
    
// Maximum serial number is 999999 for Windows XP
#define MINIMUM_SERIAL_NUMBER   ((DWORD)(0x00000000))
#define MAXIMUM_SERIAL_NUMBER   ((DWORD)(0x000F423F))       

// definitions of dwAutoNameFormat
typedef struct _LOG_COUNTER_INFO {
    struct _LOG_COUNTER_INFO *next;
    HCOUNTER    hCounter;
} LOG_COUNTER_INFO, * PLOG_COUNTER_INFO;

typedef struct _ALERT_COUNTER_INFO {
    struct _ALERT_COUNTER_INFO *next;
    HCOUNTER    hCounter;
    PALERT_INFO_BLOCK   pAlertInfo;
} ALERT_COUNTER_INFO, * PALERT_COUNTER_INFO;

typedef struct _TRACE_PROVIDER {
    GUID   Guid;
    DWORD  dwFlag;
    DWORD  dwLevel;
    LPWSTR pszProviderName;
} TRACE_PROVIDER, *PTRACE_PROVIDER;

#pragma warning( push )
#pragma warning( disable : 4201 )       // Nameless union

typedef struct _LOG_QUERY_DATA {
    struct _LOG_QUERY_DATA *next;   
    // These fields are written by the main thread
    // and read by the logging thread
    HANDLE      hThread;       
    HKEY        hKeyQuery;
    HANDLE      hExitEvent;
    HANDLE      hReconfigEvent;
    LONGLONG    llLastConfigured;
    // For queries, these fields are written 
    // and read by the logging thread
    SLQ_TIME_INFO   stiRegStart;
    SLQ_TIME_INFO   stiRegStop;
    SLQ_TIME_INFO   stiCreateNewFile;
    SLQ_TIME_INFO   stiRepeat;
    SLQ_TIME_INFO   stiCurrentStart;
    SLQ_TIME_INFO   stiCurrentStop;
    LPWSTR      szBaseFileName;
    LPWSTR      szLogFileFolder;
    LPWSTR      szSqlLogName;
    LPWSTR      szLogFileComment;
    LPWSTR      szCmdFileName;
    HANDLE      hUserToken;
    DWORD       dwLogType;              // Determines union type below
    DWORD       dwCurrentState;
    DWORD       dwLogFileType;
    DWORD       dwAppendMode;
    DWORD       dwCmdFileFailure;
    DWORD       dwAutoNameFormat;
    DWORD       dwCurrentSerialNumber;
    DWORD       dwMaxFileSize;
    DWORD       dwLogFileSizeUnit;
    WCHAR       szQueryName[MAX_PATH+1];
    WCHAR       szQueryKeyName[MAX_PATH+1];
    BOOL        bLoadNewConfig;
    BOOL        bReconfiguration;
    union {
        struct {
            // For trace queries
            // these fields are written and read by the logging thread,
            // or by the main thread when creating a temporary query
            // for comparison.
			// Todo:  Still true?
            TRACEHANDLE             LoggerHandle;
            LPWSTR                  mszProviderList;
            LPWSTR                  mszProviderFlags;
            LPWSTR                  mszProviderLevels;
            PTRACE_PROVIDER         arrpGuid;
            HANDLE                  hNewFileEvent;
            EVENT_TRACE_PROPERTIES  Properties;
            WCHAR                   szLoggerName[MAX_PATH+1];   // Must follow Properties
            WCHAR                   szLogFileName[MAX_PATH+1];  // Must follow szLoggerName
            ULONG                   ulGuidCount;
            DWORD                   dwBufferSize;
            DWORD                   dwBufferMinCount;
            DWORD                   dwBufferMaxCount;
            DWORD                   dwBufferFlushInterval;
            DWORD                   dwFlags;
            BOOL                    bExitOnTermination;
            BOOL                    bCallCloseTraceLogger;
        };
        struct {
            // For counter and alert queries
            // these fields are written and read by the logging thread,
            // or by the main thread when creating a temporary query
            // for comparison.
            LPWSTR              mszCounterList;
            PLOG_COUNTER_INFO   pFirstCounter;    
            LPWSTR              szNetName;
            LPWSTR              szPerfLogName;
            LPWSTR              szUserText;
            HANDLE              hQuery;                 
            HANDLE              hLog;               // counter logs only                   
            DWORD               dwRealTimeQuery;
            DWORD               dwAlertActionFlags; // for alert queries
            DWORD               dwMillisecondSampleInterval;
            DWORD               dwNetMsgFailureReported;
            DWORD               dwAlertLogFailureReported;
        };
    };
} LOG_QUERY_DATA, FAR* PLOG_QUERY_DATA;

#pragma warning( pop ) 

// global variables
extern HANDLE       hEventLog;
extern HINSTANCE    hModule;

extern SERVICE_STATUS_HANDLE    hPerfLogStatus;
extern SERVICE_STATUS           ssPerfLogStatus;

extern DWORD*       arrPdhDataCollectSuccess;  
extern INT          iPdhDataCollectSuccessCount;
extern WCHAR        gszDefaultLogFileFolder[];

// smlogsvc.c
void SysmonLogServiceControlHandler(
    IN  DWORD dwControl );

void 
SysmonLogServiceStart (
    IN  DWORD   argc,
    IN  LPWSTR  *argv );


int
__cdecl main(int argc, char *argv[]);

// Common functions

BOOL
GetLocalFileTime (
    LONGLONG    *pFileTime );

long
JulianDateFromSystemTime(
    SYSTEMTIME *pST );

DWORD    
ReadRegistrySlqTime (
    HKEY     hKey,
    LPCWSTR  szQueryName,           // For error logging 
    LPCWSTR  szValueName, 
    PSLQ_TIME_INFO pSlqDefault,
    PSLQ_TIME_INFO pSlqValue );

DWORD    
ReadRegistryDwordValue (
    HKEY hKey, 
    LPCWSTR szQueryName,           // For error logging 
    LPCWSTR szValueName,
    PDWORD  pdwDefault, 
    LPDWORD pdwValue ); 

DWORD    
ReadRegistryStringValue (
    HKEY hKey, 
    LPCWSTR szQueryName,           // For error logging 
    LPCWSTR szValue,
    LPCWSTR szDefault, 
    LPWSTR *pszBuffer, 
    LPDWORD pdwLength );
        
DWORD
ReadRegistryIndirectStringValue (
    HKEY     hKey,
    LPCWSTR  szQueryName,           // For error logging 
    LPCWSTR  szValueName,
    LPCWSTR  szDefault,
    LPWSTR*  pszBuffer,
    UINT*    puiLength );

DWORD    
WriteRegistryDwordValue (
    HKEY     hKey,
    LPCWSTR  szValueName, 
    LPDWORD  pdwValue,
    DWORD    dwType);     // Also supports REG_BINARY
                          // *** Optional in C++

DWORD    
WriteRegistrySlqTime (
    HKEY     hKey,
    LPCWSTR  szValueName, 
    PSLQ_TIME_INFO    pSlqTime );

LONGLONG
ComputeStartWaitTics (
    IN    PLOG_QUERY_DATA pArg,
    IN    BOOL  bWriteToRegistry );

DWORD
LoadQueryConfig (
    IN  PLOG_QUERY_DATA   pArg );

HRESULT
RegisterCurrentFile( 
    HKEY hkeyQuery, 
    LPWSTR strFileName, 
    DWORD dwSubIndex );

DWORD
BuildCurrentLogFileName (
    IN  LPCWSTR     szQueryName,
    IN  LPCWSTR     szBaseFileName,
    IN  LPCWSTR     szDefaultDir,
    IN  LPCWSTR     szSqlLogName,
    IN  LPWSTR      szOutFileBuffer,
    IN  LPDWORD     lpdwSerialNumber,
    IN  DWORD       dwAutoNameFormat,
    IN  DWORD       dwLogFileType,
    IN  INT         iCnfSerial );

BOOL
FileExists (
    IN LPCWSTR      szFileName );

void 
DeallocateQueryBuffers (
    IN PLOG_QUERY_DATA pThisThread );        

DWORD
SetStoppedStatus (
    IN PLOG_QUERY_DATA pQuery );

// Trace
void 
InitTraceProperties (
    IN PLOG_QUERY_DATA pQuery,
    IN BOOL         bUpdateSerial,
    IN OUT DWORD*   pdwSessionSerial,
    IN OUT INT*     pCnfSerial );

DWORD
GetTraceQueryStatus (
    IN PLOG_QUERY_DATA pQuery,
	IN OUT PLOG_QUERY_DATA pReturnQuery);

LPWSTR
FormatEventLogMessage(DWORD dwStatus);

DWORD
DoLogCommandFile (
    IN  PLOG_QUERY_DATA	pArg,
    IN  LPWSTR              szLogFileName,
    IN  BOOL                bStillRunning );

DWORD
GetQueryKeyName (
    IN  LPCWSTR szQueryName,
    OUT LPWSTR  szQueryKeyName,
    IN  DWORD   dwQueryKeyNameLen );

void
CloseTraceLogger ( 
    IN PLOG_QUERY_DATA pQuery );


// logthred.c

DWORD
LoggingThreadProc (
    IN  LPVOID  lpThreadArg );

#endif //_SMLOGSVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\about.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       about.cpp
//
//  Contents:   implementation of CAbout, CSCEAbout, CSCMAbout, CSSAbout, 
//              CRSOPAbout & CLSAbout
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "resource.h"
#include "about.h"

#include <ntverp.h>
#define OUT_VERSION VER_PRODUCTVERSION_STR
#define OUT_PROVIDER VER_COMPANYNAME_STR
/////////////////////////////////////////////////////////////////////
CSCEAbout::CSCEAbout()
{
   m_uIdStrProvider = IDS_SNAPINABOUT_PROVIDER;
   m_uIdStrVersion = IDS_SNAPINABOUT_VERSION;
   m_uIdStrDescription = IDS_SCEABOUT_DESCRIPTION;
   m_uIdIconImage = IDI_SCE_APP;
   m_uIdBitmapSmallImage = IDB_SCE_SMALL;
   m_uIdBitmapSmallImageOpen = IDB_SCE_SMALL;
   m_uIdBitmapLargeImage = IDB_SCE_LARGE;
   m_crImageMask = RGB(255, 0, 255);
}

CSCMAbout::CSCMAbout()
{
   m_uIdStrProvider = IDS_SNAPINABOUT_PROVIDER;
   m_uIdStrVersion = IDS_SNAPINABOUT_VERSION;
   m_uIdStrDescription = IDS_SCMABOUT_DESCRIPTION;
   m_uIdIconImage = IDI_SCE_APP;
   m_uIdBitmapSmallImage = IDB_SCE_SMALL;
   m_uIdBitmapSmallImageOpen = IDB_SCE_SMALL;
   m_uIdBitmapLargeImage = IDB_SCE_LARGE;
   m_crImageMask = RGB(255, 0, 255);
}

CSSAbout::CSSAbout()
{
   m_uIdStrProvider = IDS_SNAPINABOUT_PROVIDER;
   m_uIdStrVersion = IDS_SNAPINABOUT_VERSION;
   m_uIdStrDescription = IDS_SSABOUT_DESCRIPTION;
   m_uIdIconImage = IDI_SCE_APP;
   m_uIdBitmapSmallImage = IDB_SCE_SMALL;
   m_uIdBitmapSmallImageOpen = IDB_SCE_SMALL;
   m_uIdBitmapLargeImage = IDB_SCE_LARGE;
   m_crImageMask = RGB(255, 0, 255);
}

CRSOPAbout::CRSOPAbout()
{
   m_uIdStrProvider = IDS_SNAPINABOUT_PROVIDER;
   m_uIdStrVersion = IDS_SNAPINABOUT_VERSION;
   m_uIdStrDescription = IDS_RSOPABOUT_DESCRIPTION;
   m_uIdIconImage = IDI_SCE_APP;
   m_uIdBitmapSmallImage = IDB_SCE_SMALL;
   m_uIdBitmapSmallImageOpen = IDB_SCE_SMALL;
   m_uIdBitmapLargeImage = IDB_SCE_LARGE;
   m_crImageMask = RGB(255, 0, 255);
}

CLSAbout::CLSAbout()
{
   m_uIdStrProvider = IDS_SNAPINABOUT_PROVIDER;
   m_uIdStrVersion = IDS_SNAPINABOUT_VERSION;
   m_uIdStrDescription = IDS_LSABOUT_DESCRIPTION;
   m_uIdIconImage = IDI_SCE_APP;
   m_uIdBitmapSmallImage = IDB_SCE_SMALL;
   m_uIdBitmapSmallImageOpen = IDB_SCE_SMALL;
   m_uIdBitmapLargeImage = IDB_SCE_LARGE;
   m_crImageMask = RGB(255, 0, 255);
}


/////////////////////////////////////////////////////////////////////
// HrLoadOleString()
//
// Load a string from the resource and return pointer to allocated
// OLE string.
//
// HISTORY
// 29-Jul-97   t-danm      Creation.
//
HRESULT
HrLoadOleString(
               UINT uStringId,               // IN: String Id to load from the resource
               OUT LPOLESTR * ppaszOleString)   // OUT: Pointer to pointer to allocated OLE string
{
   if (ppaszOleString == NULL) {
      TRACE0("HrLoadOleString() - ppaszOleString is NULL.\n");
      return E_POINTER;
   }
   CString strT;     // Temporary string
   AFX_MANAGE_STATE(AfxGetStaticModuleState()); // Needed for LoadString()

   if( IDS_SNAPINABOUT_VERSION == uStringId ) //Raid #402163
   {
      strT = OUT_VERSION;
   }
   else
   {
      if( IDS_SNAPINABOUT_PROVIDER == uStringId )
      {
          strT = OUT_PROVIDER;
      }
      else
      {
          VERIFY( strT.LoadString(uStringId) );
      }
   }
   *ppaszOleString = reinterpret_cast<LPOLESTR>
                     (CoTaskMemAlloc((strT.GetLength() + 1)* sizeof(wchar_t)));
   if (*ppaszOleString == NULL) {
      return E_OUTOFMEMORY;
   }
   USES_CONVERSION;
   //This is a safe usage. ppaszOleString is just allocated based on the size of strT.
   wcscpy(OUT *ppaszOleString, T2OLE((LPTSTR)(LPCTSTR)strT));
   
   return S_OK;
} // HrLoadOleString()


STDMETHODIMP CAbout::GetSnapinDescription(OUT LPOLESTR __RPC_FAR *lpDescription)
{
   return HrLoadOleString(m_uIdStrDescription, OUT lpDescription);
}

STDMETHODIMP CAbout::GetProvider(OUT LPOLESTR __RPC_FAR *lpName)
{
   return HrLoadOleString(m_uIdStrProvider, OUT lpName);
}

STDMETHODIMP CAbout::GetSnapinVersion(OUT LPOLESTR __RPC_FAR *lpVersion)
{
   return HrLoadOleString(m_uIdStrVersion, OUT lpVersion);
}

STDMETHODIMP CAbout::GetSnapinImage(OUT HICON __RPC_FAR *hAppIcon)
{
   if (hAppIcon == NULL)
      return E_POINTER;
   AFX_MANAGE_STATE(AfxGetStaticModuleState()); // Required for AfxGetInstanceHandle()
   *hAppIcon = ::LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(m_uIdIconImage));
   if (*hAppIcon == NULL) {
      ASSERT(FALSE && "Unable to load icon");
      return E_FAIL;
   }
   return S_OK;
}

STDMETHODIMP CAbout::GetStaticFolderImage(
                                               OUT HBITMAP __RPC_FAR *hSmallImage,
                                               OUT HBITMAP __RPC_FAR *hSmallImageOpen,
                                               OUT HBITMAP __RPC_FAR *hLargeImage,
                                               OUT COLORREF __RPC_FAR *crMask)
{
   //This is not a safe usage. All four pointers should be validated. Raid #550912, yanggao.
   ASSERT(hSmallImage != NULL);
   ASSERT(hSmallImageOpen != NULL);
   ASSERT(hLargeImage != NULL);
   ASSERT(crMask != NULL);
   if( !hSmallImage || !hSmallImageOpen || !hLargeImage || !crMask )
   {
      return E_FAIL;
   }
   AFX_MANAGE_STATE(AfxGetStaticModuleState()); // Required for AfxGetInstanceHandle()
   HINSTANCE hInstance = AfxGetInstanceHandle();

   //Raid #379315, 4/27/2001
   *hSmallImage = (HBITMAP)::LoadImage(
                            hInstance,
                            MAKEINTRESOURCE(m_uIdBitmapSmallImage),
                            IMAGE_BITMAP,
                            0, 0,
                            LR_SHARED
                            );
   *hSmallImageOpen = (HBITMAP)::LoadImage(
                            hInstance,
                            MAKEINTRESOURCE(m_uIdBitmapSmallImageOpen),
                            IMAGE_BITMAP,
                            0, 0,
                            LR_SHARED
                            );
   *hLargeImage = (HBITMAP)::LoadImage(
                            hInstance,
                            MAKEINTRESOURCE(m_uIdBitmapLargeImage),
                            IMAGE_BITMAP,
                            0, 0,
                            LR_SHARED
                            );
   *crMask = m_crImageMask;
   #ifdef _DEBUG
   if (NULL == *hSmallImage || NULL == *hSmallImageOpen || NULL == *hLargeImage) {
      TRACE0("WRN: CAbout::GetStaticFolderImage() - Unable to load all the bitmaps.\n");
      return E_FAIL;
   }
   #endif
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\aaudit.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aaudit.cpp
//
//  Contents:   implementation of CAttrAudit
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "resource.h"
#include "snapmgr.h"
#include "AAudit.h"
#include "util.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAttrAudit dialog


CAttrAudit::CAttrAudit()
   : CAttribute (IDD)
{
    //{{AFX_DATA_INIT(CAttrAudit)
    m_AuditSuccess = FALSE;
    m_AuditFailed = FALSE;
    m_Title = _T("");
    m_strLastInspect = _T("");
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a170HelpIDs;
    m_uTemplateResID = IDD;
}


void CAttrAudit::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAttrAudit)
    DDX_Check(pDX, IDC_CHANGE_SUCCESS, m_AuditSuccess);
    DDX_Check(pDX, IDC_CHANGE_FAILED, m_AuditFailed);
    DDX_Text(pDX, IDC_LAST_INSPECT, m_strLastInspect);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttrAudit, CAttribute)
    //{{AFX_MSG_MAP(CAttrAudit)
        ON_BN_CLICKED(IDC_CHANGE_SUCCESS, OnChangeSuccess)
        ON_BN_CLICKED(IDC_CHANGE_FAILED, OnChangeFailed)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttrAudit message handlers
BOOL CAttrAudit::OnApply()
{
   if ( !m_bReadOnly )
   {
      LONG_PTR dw=0;
      DWORD status = 0;

      UpdateData(TRUE);
      dw = 0;
      if (!m_bConfigure)
         dw = (LONG_PTR)ULongToPtr(SCE_NO_VALUE);
      else 
      {
         if (m_AuditSuccess)
            dw |= AUDIT_SUCCESS;

         if (m_AuditFailed)
            dw |= AUDIT_FAILURE;
      }
      m_pData->SetBase(dw);
      status = m_pSnapin->SetAnalysisInfo(m_pData->GetID(),dw, m_pData);
      m_pData->SetStatus(status);

      m_pData->Update(m_pSnapin);
   }

   return CAttribute::OnApply();
}


void CAttrAudit::Initialize(CResult * pResult)
{
    LONG_PTR dw=0;

    CAttribute::Initialize(pResult);
    dw = pResult->GetBase();
    m_bConfigure = ( dw != (LONG_PTR)ULongToPtr(SCE_NO_VALUE) );
    if (m_bConfigure) {
        SetInitialValue((DWORD_PTR)dw);
    }

    pResult->GetDisplayName( NULL, m_strLastInspect, 2 );
}

void
CAttrAudit::SetInitialValue(DWORD_PTR dw) 
{
    m_AuditSuccess = ( (dw & AUDIT_SUCCESS) != 0 );
    m_AuditFailed = ( (dw & AUDIT_FAILURE) != 0 );
}

BOOL CAttrAudit::OnInitDialog()
{
    CAttribute::OnInitDialog();

    AddUserControl(IDC_CHANGE_SUCCESS);
    AddUserControl(IDC_CHANGE_FAILED);
    EnableUserControls(m_bConfigure);

    return TRUE;  // return TRUE unless you set the focus to a control
}

void CAttrAudit::OnChangeSuccess()
{
    SetModified(TRUE);
}

void CAttrAudit::OnChangeFailed()
{
    SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\aaudit.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aaudit.h
//
//  Contents:   definition of CAttrAudit
//
//----------------------------------------------------------------------------
#if !defined(AFX_ATTRAUDIT_H__76BA1B2D_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_)
#define AFX_ATTRAUDIT_H__76BA1B2D_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CAttrAudit dialog

class CAttrAudit : public CAttribute
{
// Construction
public:
	void Initialize(CResult *pResult);
   virtual void SetInitialValue(DWORD_PTR dw);
	CAttrAudit();   // standard constructor


// Dialog Data
	//{{AFX_DATA(CAttrAudit)
	enum { IDD = IDD_ATTR_AUDIT };
	BOOL	m_AuditSuccess;
	BOOL	m_AuditFailed;
	CString	m_Title;
	CString	m_strLastInspect;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAttrAudit)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAttrAudit)
	virtual BOOL OnApply();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeSuccess();
	afx_msg void OnChangeFailed();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ATTRAUDIT_H__76BA1B2D_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\smonlog\smlogsvc\utils.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    Utils.c

Abstract:

	Contains utility methods which are used throughout the project.

--*/

#ifndef UNICODE
#define UNICODE     1
#endif

#ifndef _UNICODE
#define _UNICODE    1
#endif

// Define the following to use the minimum of shlwapip.h 

#ifndef NO_SHLWAPI_PATH
#define NO_SHLWAPI_PATH
#endif  

#ifndef NO_SHLWAPI_REG
#define NO_SHLWAPI_REG
#endif  

#ifndef NO_SHLWAPI_UALSTR
#define NO_SHLWAPI_UALSTR
#endif  

#ifndef NO_SHLWAPI_STREAM
#define NO_SHLWAPI_STREAM
#endif  

#ifndef NO_SHLWAPI_HTTP
#define NO_SHLWAPI_HTTP
#endif  

#ifndef NO_SHLWAPI_INTERNAL
#define NO_SHLWAPI_INTERNAL
#endif  

#ifndef NO_SHLWAPI_GDI
#define NO_SHLWAPI_GDI
#endif  

#ifndef NO_SHLWAPI_UNITHUNK
#define NO_SHLWAPI_UNITHUNK
#endif  

#ifndef NO_SHLWAPI_TPS
#define NO_SHLWAPI_TPS
#endif  

#ifndef NO_SHLWAPI_MLUI
#define NO_SHLWAPI_MLUI
#endif  


#include <shlwapi.h>            // For PlaReadRegistryIndirectStringValue
#include <shlwapip.h>           // For PlaReadRegistryIndirectStringValue
#include <sddl.h>

#include <assert.h>
#include <stdlib.h>
#include <pdhp.h>

// Disable 64-bit warnings in math.h
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4032 )
#include <math.h>
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#include <strsafe.h>
#include "common.h"

// Time conversion constants

#define SECONDS_IN_DAY      86400
#define SECONDS_IN_HOUR      3600
#define SECONDS_IN_MINUTE      60

#define INDIRECT_STRING_LEN 9

LPCWSTR cszFormatIndirect = L"%s Indirect";

// Forward definitions - to be moved to pdhpla
PDH_FUNCTION    
PlaReadRegistryIndirectStringValue (
    HKEY hKey, 
    LPCWSTR cwszValueName,
    LPWSTR  *pszBuffer, 
    UINT*   pcchBufLen 
);


BOOL __stdcall
GetLocalFileTime (
    LONGLONG    *pFileTime
)
{
    BOOL    bResult;
    SYSTEMTIME  st;

    assert ( NULL != pFileTime );

    GetLocalTime ( &st );
    //
    // The only error for SystemTimeToFileTime is STATUS_INVALID_PARAMETER.
    //
    bResult = SystemTimeToFileTime (&st, (LPFILETIME)pFileTime);

    return bResult;
}

BOOL __stdcall 
MakeStringFromInfo (
    PALERT_INFO_BLOCK pInfo,
    LPWSTR szBuffer,
    LPDWORD pcchBufferLength
)
{
    HRESULT hr = S_OK;
    BOOL    bStatus = FALSE;
    DWORD   dwLenReqd;
    size_t  cchMaxLocalBufLen = 0;
    size_t  cchLocalBufLen = 0;

    dwLenReqd = lstrlen ( pInfo->szCounterPath );
    dwLenReqd += 1; // sizeof inequality char
    dwLenReqd += SLQ_MAX_VALUE_LEN; // max size of value in chars
    dwLenReqd += 1; // term NULL

    if (dwLenReqd <= *pcchBufferLength) {
        //
        // Copy info block contents to a string buffer
        //
        cchMaxLocalBufLen = *pcchBufferLength;

        hr = StringCchPrintf ( 
                szBuffer,
                cchMaxLocalBufLen,
                L"%s%s%0.23g",
                pInfo->szCounterPath,
                (((pInfo->dwFlags & AIBF_OVER) == AIBF_OVER) ? L">" : L"<"),
                pInfo->dLimit );
                
        // Returned buffer length does not include final NULL character.

        if ( SUCCEEDED (hr) ) {
            hr = StringCchLength ( szBuffer, cchMaxLocalBufLen, &cchLocalBufLen );
            if ( SUCCEEDED (hr) ) {
                *pcchBufferLength = (DWORD)cchLocalBufLen + 1;
                bStatus = TRUE;
            }
        }
    }
    return bStatus;
}

BOOL __stdcall 
MakeInfoFromString (
    LPCWSTR szBuffer,
    PALERT_INFO_BLOCK pInfo,
    LPDWORD pdwBufferSize
)
{
    LPCWSTR szSrc;
    LPWSTR  szDst;
    DWORD   dwSizeUsed;
    DWORD   dwSizeLimit = *pdwBufferSize - sizeof(WCHAR);

    dwSizeUsed = sizeof(ALERT_INFO_BLOCK);

    szSrc = szBuffer;
    szDst = (LPWSTR)&pInfo[1];
    pInfo->szCounterPath = szDst;
    // copy the string
    while (dwSizeUsed < dwSizeLimit) {
        if ((*szSrc == L'<') || (*szSrc == L'>')) break;
        *szDst++ = *szSrc++;
        dwSizeUsed += sizeof(WCHAR);
    }

    if (dwSizeUsed < dwSizeLimit) {
        *szDst++ = 0; // NULL term the string
        dwSizeUsed += sizeof(WCHAR);
    }

    pInfo->dwFlags = ((*szSrc == L'>') ? AIBF_OVER : AIBF_UNDER);
    szSrc++;

    //
    // Get limit value
    //
    pInfo->dLimit = _wtof(szSrc);

    // write size of buffer used
    pInfo->dwSize = dwSizeUsed;

    if (dwSizeUsed <= *pdwBufferSize) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

void _stdcall
ReplaceBlanksWithUnderscores(
    LPWSTR  szName )
{
    PdhiPlaFormatBlanksW( NULL, szName );
}

void _stdcall
TimeInfoToMilliseconds (
    SLQ_TIME_INFO* pTimeInfo,
    LONGLONG* pllmsecs)
{
    assert ( SLQ_TT_DTYPE_UNITS == pTimeInfo->wDataType );

    // 
    //  Trusted caller, no check for NULL pointers.
    //

    TimeInfoToTics ( pTimeInfo, pllmsecs );

    *pllmsecs /= FILETIME_TICS_PER_MILLISECOND;

    return;
}

void _stdcall
TimeInfoToTics (
    SLQ_TIME_INFO* pTimeInfo,
    LONGLONG* pllTics)
{
    assert ( SLQ_TT_DTYPE_UNITS == pTimeInfo->wDataType );

    // 
    //  Trusted caller, no check for NULL pointers.
    //
    switch (pTimeInfo->dwUnitType) {
        case SLQ_TT_UTYPE_SECONDS:
            *pllTics = pTimeInfo->dwValue;
            break;
        case SLQ_TT_UTYPE_MINUTES:
            *pllTics = pTimeInfo->dwValue * SECONDS_IN_MINUTE;
            break;

        case SLQ_TT_UTYPE_HOURS:
            *pllTics = pTimeInfo->dwValue * SECONDS_IN_HOUR;
            break;

        case SLQ_TT_UTYPE_DAYS:
            *pllTics = pTimeInfo->dwValue * SECONDS_IN_DAY;
            break;

        default:
            *pllTics = 0;
    }

    *pllTics *= FILETIME_TICS_PER_SECOND;

    return;
}


PDH_FUNCTION
PlaReadRegistryIndirectStringValue (
    HKEY     hKey,
    LPCWSTR  pcszValueName,
    LPWSTR*  pszBuffer,
    UINT*    pcchBufLen
)
{
    //
    //  Reads the indirect string value from under hKey and
    //  frees any existing buffer referenced by pszBuffer, 
    //  then allocates a new buffer returning it with the 
    //  string value read from the registry and the length
    //  of the buffer in characters (string length including 
    //  NULL terminator) 
    //
    PDH_STATUS pdhStatus = ERROR_SUCCESS;
    HRESULT hr = NOERROR;
    LPWSTR  szNewStringBuffer = NULL;
    UINT    cchLocalBufLen = 0;

    const UINT cchLocalBufLenGrow   = MAX_PATH;

    assert ( NULL != hKey );
    assert ( NULL != pcszValueName );
    assert ( NULL != pszBuffer );
    assert ( NULL != pcchBufLen );

    if ( NULL != hKey ) {
        if ( ( NULL != pcszValueName )    
            && ( NULL != pszBuffer )    
            && ( NULL != pcchBufLen ) ) {  
        
            // find out the size of the required buffer

            do {
                /*
                 * allocate a large(r) buffer for the string
                 */
        
                if ( NULL != szNewStringBuffer ) {
                    G_FREE ( szNewStringBuffer );
                    szNewStringBuffer = NULL;
                }
                cchLocalBufLen += cchLocalBufLenGrow;

                szNewStringBuffer = (LPWSTR)G_ALLOC( cchLocalBufLen*sizeof(WCHAR));
                if ( NULL != szNewStringBuffer ) {

                    hr = SHLoadRegUIStringW (
                            hKey,
                            pcszValueName,
                            szNewStringBuffer,
                            cchLocalBufLen);
                    //
                    // Called method might not have set the terminating NULL.
                    //
                    szNewStringBuffer[cchLocalBufLen - 1] = L'\0';
                    /*
                     * If we filled up the buffer, we'll pessimistically assume that
                     * there's more data available.  We'll loop around, grow the buffer,
                     * and try again.
                     */

                } else {
                    pdhStatus = ERROR_OUTOFMEMORY;
                    break;
                }

            } while ( (ULONG)lstrlen( szNewStringBuffer ) == cchLocalBufLen-1 
                        && SUCCEEDED ( hr ) );

            if ( NULL != szNewStringBuffer ) {
                if ( 0 == lstrlen (szNewStringBuffer) ) {
                    // nothing to read                
                    pdhStatus = ERROR_NO_DATA;
                } else {
                    if ( FAILED ( hr ) ) {
                        // Unable to read buffer
                        // Translate hr to pdhStatus
                        assert ( E_INVALIDARG != hr );
                        if ( E_OUTOFMEMORY == hr ) {
                            pdhStatus = ERROR_OUTOFMEMORY; 
                        } else {
                            pdhStatus = ERROR_NO_DATA;
                        }
                    } 
                }
            }
        } else {
            pdhStatus = ERROR_INVALID_PARAMETER;
        }
    } else {
        // null key
        pdhStatus = ERROR_BADKEY;
    }

    if ( ERROR_SUCCESS != pdhStatus ) {
        if ( NULL != szNewStringBuffer ) {
            G_FREE (szNewStringBuffer);
            szNewStringBuffer = NULL;
            cchLocalBufLen = 0;
        }
    } else {
        // then delete the old buffer and replace it with 
        // the new one
        if ( NULL != *pszBuffer ) {
            G_FREE (*pszBuffer );
        }
        *pszBuffer = szNewStringBuffer;
        *pcchBufLen = cchLocalBufLen;
    }

    return pdhStatus;
}   


DWORD
SmReadRegistryIndirectStringValue (
    HKEY     hKey,
    LPCWSTR  szValueName,
    LPCWSTR  szDefault,
    LPWSTR*  pszBuffer,
    UINT*    pcchBufLen
)
//
//  reads the string value "szValueName" from under hKey and
//  frees any existing buffer referenced by pszBuffer, 
//  then allocates a new buffer returning it with the 
//  string value read from the registry and the size of the
//  buffer in characters, including the terminating null. 
//
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HRESULT hr = S_OK;
    LPWSTR  szNewStringBuffer = NULL;
    UINT    cchLocalBufLen = 0;
    LPWSTR  szIndirectValueName = NULL;
    UINT    uiValueNameLen = 0;
    DWORD   dwType;
    DWORD   dwBufferSize = 0;

    if ( NULL == hKey ) {
        assert ( FALSE );
        dwStatus = ERROR_BADKEY;
    }
    else if ( ( NULL == pcchBufLen ) || 
              ( NULL == pszBuffer ) || 
              ( NULL == szValueName ) ) {

        assert ( FALSE );
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    if (dwStatus == ERROR_SUCCESS) {
        uiValueNameLen = lstrlen ( szValueName ) + INDIRECT_STRING_LEN + 1;

        szIndirectValueName = G_ALLOC ( uiValueNameLen * sizeof(WCHAR) );
          
        if ( NULL != szIndirectValueName ) {
            StringCchPrintf ( 
                szIndirectValueName,
                uiValueNameLen,
                cszFormatIndirect, 
                szValueName );

            //
            // PlaReadxxx guarantees NULL terminated return string.
            //
            dwStatus = PlaReadRegistryIndirectStringValue (
                        hKey,
                        szIndirectValueName,
                        &szNewStringBuffer,
                        &cchLocalBufLen );
   
            if ( ERROR_SUCCESS == dwStatus) {
                if ( 0 == lstrlen( szNewStringBuffer ) ) {
                    // nothing to read                
                    dwStatus = ERROR_NO_DATA;
                }
            } // else dwStatus has error
            G_FREE ( szIndirectValueName );
        } else {
            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        if ( ERROR_NO_DATA == dwStatus ) {
            //
            // There might be something to read under the non-indirect field.
            // Find out the size of the required buffer.
            //
            dwStatus = RegQueryValueExW (
                    hKey,
                    szValueName,
                    NULL,
                    &dwType,
                    NULL,
                    &dwBufferSize);
            if (dwStatus == ERROR_SUCCESS) {
                // NULL character size is 2 bytes
                if (dwBufferSize > 2) {
                    // then there's something to read            
                    szNewStringBuffer = (WCHAR*) G_ALLOC ( dwBufferSize ); 
                    if (szNewStringBuffer != NULL) {
                        dwType = 0;
                        dwStatus = RegQueryValueExW (
                                hKey,
                                szValueName,
                                NULL,
                                &dwType,
                                (LPBYTE)szNewStringBuffer,
                                &dwBufferSize);
                    
                        cchLocalBufLen = dwBufferSize/sizeof(WCHAR);
                        szNewStringBuffer[cchLocalBufLen - 1] = L'\0';

                        cchLocalBufLen = lstrlenW ( szNewStringBuffer ) + 1;
                        if ( 1 == cchLocalBufLen ) {
                            dwStatus = ERROR_NO_DATA;
                        }
                    } else {
                        // Todo:  Report event for this case.
                        dwStatus = ERROR_OUTOFMEMORY;
                    }
                } else {
                    // nothing to read                
                    dwStatus = ERROR_NO_DATA;
                }
            }
        }

        if ( ERROR_SUCCESS != dwStatus ) {
            if ( NULL != szNewStringBuffer ) {
                G_FREE ( szNewStringBuffer ); 
                szNewStringBuffer = NULL;
                cchLocalBufLen = 0;
            }
            // apply default
            if ( NULL != szDefault ) {

                cchLocalBufLen = lstrlen(szDefault) + 1;

                if ( 1 < cchLocalBufLen ) {

                    szNewStringBuffer = (WCHAR*) G_ALLOC ( cchLocalBufLen * sizeof (WCHAR) );

                    if ( NULL != szNewStringBuffer ) {                        
                        hr = StringCchCopy ( szNewStringBuffer, cchLocalBufLen, szDefault );
                        dwStatus = HRESULT_CODE( hr );
                    } else {
                        dwStatus = ERROR_OUTOFMEMORY;
                    }
                }
            } // else no default so no data returned
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            // Delete the old buffer and replace it with 
            // the new one.
            if ( NULL != *pszBuffer ) {
                G_FREE (*pszBuffer );       
            }
            *pszBuffer = szNewStringBuffer;
            *pcchBufLen = cchLocalBufLen;
        } else {
            //
            // If error then delete the buffer
            // Leave the original buffer pointer as is.
            //
            if ( NULL != szNewStringBuffer ) {
                G_FREE ( szNewStringBuffer );   
                *pcchBufLen = 0;
            }
        }
    }

    return dwStatus;
}   

DWORD
RegisterCurrentFile( HKEY hkeyQuery, LPWSTR szFileName, DWORD dwSubIndex )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    LPWSTR  szLocalFileName = NULL;
    BOOL    bLocalAlloc = FALSE;
    DWORD   dwSize = 0;
    size_t  cchLocalBufLen = 0;

    if( szFileName != NULL ){
        if( dwSubIndex == (-1) ){
            //
            // The only time this will get called with a (-1) is the first time
            // trace is building the file name.
            //
            
            dwSize = (DWORD)((BYTE*)&szFileName[wcslen( szFileName )] - 
                             (BYTE*)&szFileName[0]);
            
            // 32 is the max size of all formatting and extention characters.
            dwSize += 32 * sizeof(WCHAR);
            szLocalFileName = (LPWSTR)G_ALLOC( dwSize );
            
            if( NULL != szLocalFileName ) {
                
                bLocalAlloc = TRUE;

                cchLocalBufLen = dwSize/(sizeof(WCHAR));

                //
                // No file name length restriction.
                //
                StringCchPrintf (
                    szLocalFileName,
                    cchLocalBufLen,
                    szFileName,
                    1 );
            } else {
                dwStatus =  ERROR_OUTOFMEMORY;
            }
        
        } else {
            szLocalFileName = szFileName;
            //
            // No file name length restriction.
            //
            if ( SUCCEEDED ( StringCchLength ( szLocalFileName, STRSAFE_MAX_CCH, &cchLocalBufLen ) ) ) {
                dwSize = (cchLocalBufLen + 1) * sizeof(WCHAR);
            } else {
                dwStatus = ERROR_INVALID_NAME;
            }
        }

//        dwSize = (DWORD)((BYTE*)&szLocalFileName[wcslen( szLocalFileName )] - 
//                         (BYTE*)&szLocalFileName[0]);
 
        if ( ERROR_SUCCESS == dwStatus ) {
            dwStatus = RegSetValueExW (
                        hkeyQuery,
                        L"Current Log File Name",
                        0L,
                        REG_SZ,
                        (CONST BYTE *)szLocalFileName,
                        dwSize );
        }
    } else { 
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    if( bLocalAlloc && NULL != szLocalFileName ){
        G_FREE( szLocalFileName );
    }

    return dwStatus;
}

ULONG
__stdcall
ahextoi( LPWSTR s )
{
    long len;
    ULONG num, base, hex;

    len = (long) wcslen(s);

    if (len == 0) {
        return 0;
    }

    hex  = 0;
    base = 1;
    num  = 0;

    while (-- len >= 0) {
        if (s[len] >= L'0' && s[len] <= L'9'){
            num = s[len] - L'0';
        }else if (s[len] >= L'a' && s[len] <= L'f'){
            num = (s[len] - L'a') + 10;
        }else if (s[len] >= L'A' && s[len] <= L'F'){
            num = (s[len] - L'A') + 10;
        }else if( s[len] == L'x' || s[len] == L'X'){
            break;
        }else{
            continue;
        }

        hex += num * base;
        base = base * 16;
    }

    return hex;
}


BOOL
PerfCreateDirectory(LPWSTR szDirectory)
/*++

Routine Description:

    The function create a SECURITY_ATTRIBUTES structure used by 
    "Performance Logs and Alerts" when creating a directory to
    hold log files.
    
    The security policy is as following:

    Admin - Full control
    System - Full control
    Performance Logging -
    Performance Monitoring - Read & Execute, List folder contents
    Network 

Arguments:

    None

Return Value:
    Return the newly created SECURITY_ATTRIBUTES if success, 
    otherwise return NULL


--*/

{
    SECURITY_ATTRIBUTES sa;
    WCHAR* szSD = L"D:"
                  L"(A;OICI;GA;;;SY)(A;OICI;GA;;;BA)"
                  L"(A;OICI;FRFWFXSDRC;;;NS)"
                  L"(A;OICI;FRFWFXSDRC;;;LU)"
                  L"(A;OICI;FRFX;;;MU)";

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.bInheritHandle = FALSE;

    if (ConvertStringSecurityDescriptorToSecurityDescriptor(
        szSD,
        SDDL_REVISION_1,
        &(sa.lpSecurityDescriptor),
        NULL)) {

        if (CreateDirectory(szDirectory, &sa)) {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\achoice.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       achoice.cpp
//
//  Contents:   implementation of CAttrChoice
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "AChoice.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAttrChoice dialog


CAttrChoice::CAttrChoice()
: CAttribute(IDD), m_pChoices(NULL)
{
   //{{AFX_DATA_INIT(CAttrChoice)
   m_Current = _T("");
   //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR)a237HelpIDs;
   m_uTemplateResID = IDD;
}


void CAttrChoice::DoDataExchange(CDataExchange* pDX)
{
   CAttribute::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CAttrChoice)
   DDX_Control(pDX, IDC_CHOICES, m_cbChoices);
   DDX_Text(pDX, IDC_CURRENT, m_Current);
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttrChoice, CAttribute)
   //{{AFX_MSG_MAP(CAttrChoice)
   ON_CBN_SELCHANGE(IDC_CHOICES, OnSelchangeChoices)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttrChoice message handlers

void CAttrChoice::OnSelchangeChoices()
{
   CWnd *cwndOK;
   SetModified(TRUE);

/*
   cwndOK = GetDlgItem(IDOK);

   if (cwndOK) {
      cwndOK->EnableWindow( CB_ERR != m_cbChoices.GetCurSel() );
   }
*/
}

void CAttrChoice::Initialize(CResult * pResult)
{
   CAttribute::Initialize(pResult);

   m_pChoices = pResult->GetRegChoices();

   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(pResult->GetBase());

   if ( prv && prv->Value ) {
       m_bConfigure = TRUE;
   } else {
       m_bConfigure = FALSE;
   }

   prv = (PSCE_REGISTRY_VALUE_INFO)(pResult->GetSetting());
   PREGCHOICE pChoice;
   DWORD dwSetting = 0; //Raid #395353, 5/16/2001

   if( m_pChoices ) //Raid #404000
      dwSetting = m_pChoices->dwValue;  
   if( prv->Value )
      dwSetting = (DWORD)_ttoi(prv->Value);

   pChoice = m_pChoices;
   while(pChoice) {
      if (dwSetting == pChoice->dwValue) {
         m_Current = pChoice->szName;
         break;
      }
      pChoice = pChoice->pNext;
   }

   pResult->GetDisplayName( NULL, m_Current, 2 );

}

BOOL CAttrChoice::OnInitDialog()
{
   CAttribute::OnInitDialog();

   PREGCHOICE pChoice = m_pChoices;
   int nIndex = 0;
   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());

   ASSERT(prv);
   ASSERT(pChoice);
   if (!prv || !pChoice) {
      return TRUE;
   }

   AddUserControl(IDC_CHOICES);

   DWORD dwBase = pChoice->dwValue; //Raid #404000
   if (prv->Value) {
      dwBase = (DWORD)_ttoi(prv->Value);
   }
   while(pChoice) {
      m_cbChoices.InsertString(nIndex,pChoice->szName);
      if (dwBase == pChoice->dwValue) {
         m_cbChoices.SetCurSel(nIndex);
      }
      m_cbChoices.SetItemData(nIndex++,pChoice->dwValue);
      pChoice = pChoice->pNext;
   }

   EnableUserControls(m_bConfigure);
   OnSelchangeChoices();

   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CAttrChoice::OnApply()
{
   if ( !m_bReadOnly )
   {
      int nIndex = 0;
      int status = 0;
      DWORD rc=0;

      UpdateData(TRUE);
      DWORD dw = 0;
      if (!m_bConfigure) 
         dw = SCE_NO_VALUE;
      else 
      {
         nIndex = m_cbChoices.GetCurSel();
         if (CB_ERR != nIndex)
            dw = (DWORD) m_cbChoices.GetItemData(nIndex);
      }
      PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());

      //
      // this address should never be NULL
      //
      if ( prv ) 
      {
         PWSTR pTmp=NULL;

         if ( dw != SCE_NO_VALUE ) 
         {
            CString strTmp;
            // allocate buffer
            strTmp.Format(TEXT("%d"), dw);
            pTmp = (PWSTR)LocalAlloc(0, (strTmp.GetLength()+1)*sizeof(TCHAR));

            if ( pTmp )
               //This may not be a safe usage. Using WCHAR instead of TCHAR. Consider Fix.
               wcscpy(pTmp,(LPCTSTR)strTmp);
            else 
            {
               // can't allocate buffer, error!!
               // if this happens, nothing else is probably running so just fail
               rc = ERROR_NOT_ENOUGH_MEMORY;
            }
         }

         if ( rc == ERROR_SUCCESS ) 
         {
             if ( prv->Value )
                LocalFree(prv->Value);
             
             prv->Value = pTmp;

             status = CEditTemplate::ComputeStatus(
                                        (PSCE_REGISTRY_VALUE_INFO)m_pData->GetBase(),
                                        (PSCE_REGISTRY_VALUE_INFO)m_pData->GetSetting());
             if ( m_pData->GetBaseProfile() )
                m_pData->GetBaseProfile()->SetDirty(AREA_SECURITY_POLICY);
             
             m_pData->SetStatus(status);
             m_pData->Update(m_pSnapin);

         } 
         else
            return FALSE;
      }
   }

   return CAttribute::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\about.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       about.h
//
//  Contents:   definition of CAbout, CSCEAbout, CSCMAbout, CSSAbout, 
//              CRSOPAbout & CLSAbout
//
//----------------------------------------------------------------------------

#ifndef __ABOUT_H_INCLUDED__
#define __ABOUT_H_INCLUDED__

// About for "SCE" snapin
class CAbout :
   public ISnapinAbout,
   public CComObjectRoot
{
BEGIN_COM_MAP(CAbout)
   COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()

public:


// ISnapinAbout
   STDMETHOD(GetSnapinDescription)(OUT LPOLESTR __RPC_FAR *lpDescription);
   STDMETHOD(GetProvider)(OUT LPOLESTR __RPC_FAR *lpName);
   STDMETHOD(GetSnapinVersion)(OUT LPOLESTR __RPC_FAR *lpVersion);
   STDMETHOD(GetSnapinImage)(OUT HICON __RPC_FAR *hAppIcon);
   STDMETHOD(GetStaticFolderImage)(
            OUT HBITMAP __RPC_FAR *hSmallImage,
            OUT HBITMAP __RPC_FAR *hSmallImageOpen,
            OUT HBITMAP __RPC_FAR *hLargeImage,
            OUT COLORREF __RPC_FAR *crMask);
protected:
   // The following data members MUST be initialized by the constructor
   // of the derived class.
   UINT m_uIdStrDescription;     // Resource Id of the description
   UINT m_uIdStrProvider;     // Resource Id of the provider (ie, Microsoft Corporation)
   UINT m_uIdStrVersion;         // Resource Id of the version of the snapin
   UINT m_uIdIconImage;       // Resource Id for the icon/image of the snapin
   UINT m_uIdBitmapSmallImage;
   UINT m_uIdBitmapSmallImageOpen;
   UINT m_uIdBitmapLargeImage;
   COLORREF m_crImageMask;

};

// About for "SCE" snapin
class CSCEAbout :
   public CAbout,
   public CComCoClass<CSCEAbout, &CLSID_SCEAbout>

{
   public:
   CSCEAbout();

   DECLARE_REGISTRY(CSCEAbout, _T("Wsecedit.SCEAbout.1"), _T("Wsecedit.SCEAbout.1"), IDS_SCE_DESC, THREADFLAGS_BOTH)
};


// About for "SCM" snapin
class CSCMAbout :
   public CAbout,
   public CComCoClass<CSCMAbout, &CLSID_SCMAbout>

{
   public:
   CSCMAbout();

   DECLARE_REGISTRY(CSCMAbout, _T("Wsecedit.SCMAbout.1"), _T("Wsecedit.SCMAbout.1"), IDS_SAV_DESC, THREADFLAGS_BOTH)
};


// About for "Security Settings" snapin
class CSSAbout :
   public CAbout,
   public CComCoClass<CSSAbout, &CLSID_SSAbout>

{
   public:
   CSSAbout();

   DECLARE_REGISTRY(CSSAbout, _T("Wsecedit.SSAbout.1"), _T("Wsecedit.SSAbout.1"), IDS_SS_DESC, THREADFLAGS_BOTH)
};

// About for "RSOP Security Settings" snapin
class CRSOPAbout :
   public CAbout,
   public CComCoClass<CRSOPAbout, &CLSID_RSOPAbout>

{
   public:
   CRSOPAbout();

   DECLARE_REGISTRY(CRSOPAbout, _T("Wsecedit.RSOPAbout.1"), _T("Wsecedit.RSOPAbout.1"), IDS_RSOP_DESC, THREADFLAGS_BOTH)
};


// About for "Local Security Settings" snapin
class CLSAbout :
   public CAbout,
   public CComCoClass<CLSAbout, &CLSID_LSAbout>

{
   public:
   CLSAbout();

   DECLARE_REGISTRY(CLSAbout, _T("Wsecedit.LSAbout.1"), _T("Wsecedit.LSAbout.1"), IDS_LS_DESC, THREADFLAGS_BOTH)
};


#endif // ~__ABOUT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\achoice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       achoice.h
//
//  Contents:   definition of CAttrChoice
//
//----------------------------------------------------------------------------
#if !defined(AFX_ACHOICE_H__B03DDCAA_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_)
#define AFX_ACHOICE_H__B03DDCAA_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CAttrChoice dialog

class CAttrChoice : public CAttribute
{
// Construction
public:
   CAttrChoice();   // standard constructor
   virtual void Initialize(CResult * pResult);
// Dialog Data
   //{{AFX_DATA(CAttrChoice)
	enum { IDD = IDD_ATTR_REGCHOICES };
   CComboBox   m_cbChoices;
   CString  m_Current;
	//}}AFX_DATA

// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CAttrChoice)
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CAttrChoice)
   afx_msg void OnSelchangeChoices();
   virtual BOOL OnApply();
   virtual BOOL OnInitDialog();
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

   PREGCHOICE m_pChoices;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACHOICE_H__B03DDCAA_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\addobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       addobj.cpp
//
//  Contents:   implementation of CAddObject
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "resource.h"
#include "snapmgr.h"
#include "util.h"
#include <accctrl.h>
#include "servperm.h"
#include "AddObj.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddObject dialog


CAddObject::CAddObject(SE_OBJECT_TYPE SeType, LPTSTR ObjName, BOOL bIsContainer, CWnd* pParent)
    : CHelpDialog(a197HelpIDs, IDD, pParent)
{
    //{{AFX_DATA_INIT(CAddObject)
   m_radConfigPrevent = 0;
   m_radInheritOverwrite = 0;
    //}}AFX_DATA_INIT

   m_pfnCreateDsPage=NULL;
   m_pSI=NULL;
   m_pNewSD=NULL;
   m_NewSeInfo = 0;
   m_Status=0;

   m_SeType=SeType;
   m_ObjName=ObjName;
   m_bIsContainer = bIsContainer;

   m_hwndACL = NULL;
}


void CAddObject::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAddObject)
    DDX_Radio(pDX, IDC_CONFIG, m_radConfigPrevent);
    DDX_Radio(pDX, IDC_INHERIT, m_radInheritOverwrite);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddObject, CHelpDialog)
    //{{AFX_MSG_MAP(CAddObject)
    ON_BN_CLICKED(IDC_SECURITY, OnTemplateSecurity)
    ON_BN_CLICKED(IDC_CONFIG, OnConfig)
    ON_BN_CLICKED(IDC_PREVENT, OnPrevent)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddObject message handlers

void CAddObject::OnTemplateSecurity()
{
    INT_PTR nRet = 0;

   if( ::IsWindow( m_hwndACL ) )
      return;

    if ( SE_DS_OBJECT == m_SeType ) 
    {
        if ( !m_pfnCreateDsPage ) 
        {
            if (!g_hDsSecDll)
                g_hDsSecDll = LoadLibrary(TEXT("dssec.dll")); //This is safe usage.

            if ( g_hDsSecDll) 
            {
                m_pfnCreateDsPage = (PFNDSCREATEISECINFO)GetProcAddress(g_hDsSecDll,
                                                               "DSCreateISecurityInfoObject");
            }
        }

        if ( m_pfnCreateDsPage ) {
            m_hwndACL = (HWND)MyCreateDsSecurityPage(&m_pSI, m_pfnCreateDsPage,
                                         &m_pNewSD, &m_NewSeInfo,
                                         (LPCTSTR)m_ObjName,
                                         CONFIG_SECURITY_PAGE,
                                         GetSafeHwnd()
                               );
        } else
            nRet = -1;

    } else {

        m_hwndACL = (HWND)MyCreateSecurityPage2(m_bIsContainer, &m_pNewSD, &m_NewSeInfo,
                                    (LPCTSTR)m_ObjName,
                                    m_SeType,
                                    CONFIG_SECURITY_PAGE,
                                    GetSafeHwnd(),
                                    FALSE   // not modeless
                                    );
    }

    if ( (HWND)-1 == m_hwndACL ) {
        CString str;
        str.LoadString(IDS_CANT_ASSIGN_SECURITY);
        AfxMessageBox(str);

    } else if ( !m_pNewSD ) {
        //
        // if m_pNewSD is still NULL, create a new one for everyone Full control
        //
        DWORD SDSize;

        if (SE_REGISTRY_KEY == m_SeType) {
           GetDefaultRegKeySecurity(&m_pNewSD,&m_NewSeInfo);
        } else {
           GetDefaultFileSecurity(&m_pNewSD,&m_NewSeInfo);
        }
    }
}

BOOL CAddObject::OnInitDialog()
{
    CDialog::OnInitDialog();


   SetDlgItemText(IDC_TITLE,m_ObjName);
   if (SE_REGISTRY_KEY == m_SeType) {
      CString str;
      str.LoadString(IDS_REGISTRY_CONFIGURE);
      SetDlgItemText(IDC_CONFIG,str);
      str.LoadString(IDS_REGISTRY_APPLY);
      SetDlgItemText(IDC_OVERWRITE,str);
      str.LoadString(IDS_REGISTRY_INHERIT);
      SetDlgItemText(IDC_INHERIT,str);
      str.LoadString(IDS_REGISTRY_PREVENT);
      SetDlgItemText(IDC_PREVENT,str);
   }

    if (1 == m_radConfigPrevent) {
       OnPrevent();
    } else {
       OnConfig();
    }

    UpdateData(FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CAddObject::OnOK()
{
    UpdateData(TRUE);

    if ( !m_pNewSD ) {
        CString str;
        str.LoadString(IDS_SECURITY_REQUIRED);
        AfxMessageBox(str);
        return;
    }

    switch (m_radConfigPrevent) {
       case 0:
          // config
          switch(m_radInheritOverwrite) {
             case 0:
                // inherit
                m_Status = SCE_STATUS_CHECK;
                break;
             case 1:
                // overwrite
                m_Status = SCE_STATUS_OVERWRITE;
                break;
          }
          break;
       case 1:
          // prevent
          m_Status = SCE_STATUS_IGNORE;
          break;
    }

    if ( m_pSI ) {
        m_pSI->Release();
        m_pSI = NULL;
    }
    m_pfnCreateDsPage=NULL;

    CDialog::OnOK();
}

void CAddObject::OnCancel()
{
    if ( m_pNewSD ) {
        LocalFree(m_pNewSD);
        m_pNewSD = NULL;
    }
    m_NewSeInfo = 0;

    if ( m_pSI ) {
        m_pSI->Release();
        m_pSI = NULL;
    }
    m_pfnCreateDsPage=NULL;

    CDialog::OnCancel();
}

void CAddObject::OnConfig()
{
   CWnd *pRadio = GetDlgItem(IDC_INHERIT);
   if (pRadio)
      pRadio->EnableWindow(TRUE);
   
   pRadio = GetDlgItem(IDC_OVERWRITE);
   if (pRadio)
      pRadio->EnableWindow(TRUE);
   pRadio = GetDlgItem(IDC_SECURITY); //Raid #501901, #501891
   if (pRadio) {
      pRadio->EnableWindow(TRUE);
   }
}

void CAddObject::OnPrevent()
{
   CWnd *pRadio = GetDlgItem(IDC_INHERIT);
   if (pRadio) {
      pRadio->EnableWindow(FALSE);
   }
   pRadio = GetDlgItem(IDC_OVERWRITE);
   if (pRadio) {
      pRadio->EnableWindow(FALSE);
   }
   pRadio = GetDlgItem(IDC_SECURITY); //Raid #501901, #501891
   if (pRadio) {
      pRadio->EnableWindow(FALSE);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\addgrp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       addgrp.h
//
//  Contents:   definition of CSCEAddGroup
//
//----------------------------------------------------------------------------
#if !defined(AFX_SCEADDGROUP_H__66CF106B_7057_11D2_A798_00C04FD92F7B__INCLUDED_)
#define AFX_SCEADDGROUP_H__66CF106B_7057_11D2_A798_00C04FD92F7B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HelpDlg.h"

#define IDS_INVALID_USERNAME_CHARS L"\"/[]:|<>+=;,?,*"
/////////////////////////////////////////////////////////////////////////////
// CSCEAddGroup dialog
#ifndef IsSpace
//
// Useful macro for checking to see if a character represents white space
//
#define IsSpace( x ) ((x) == L' ' || ((x) >= 0x09 && (x) <= 0x0D))
#endif

class CSCEAddGroup : public CHelpDialog
{
// Construction
public:
        CSCEAddGroup(CWnd* pParent = NULL);   // standard constructor
    virtual ~CSCEAddGroup();

   //
   // Returns the list of groups/users chosen by the user.
   //
   PSCE_NAME_LIST GetUsers()
        { return m_pnlGroup; };

   //
   // Tell the group box which mode we're running under so we can display
   // appropriate options when browsing.
   //
   void SetModeBits(DWORD dwModeBits) 
   { 
	   m_dwModeBits = dwModeBits; 
   };

// Dialog Data
    //{{AFX_DATA(CSCEAddGroup)
    enum { IDD = IDD_APPLY_CONFIGURATION };
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSCEAddGroup)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
   //
   // If a string is added, then it will be underlined in the display.
   //
   BOOL AddKnownAccount( LPCTSTR pszAccount );
   //
   // Returns TRUE if [pszAccount] was added by a call to AddKnownAccount.
   //
   BOOL IsKnownAccount( LPCTSTR pszAccount );
   //
   // Removes leading and trailing space characters.
   //
   void CleanName( LPTSTR pszAccount );
   //
   // Underlines all names in the KnownAccount list.
   //
   void UnderlineNames();
   //
   // Creates a name list from the text of the edit box.
   //
   int CreateNameList( PSCE_NAME_LIST *pNameList );
   //
   // Verfies the account names.
   //
   BOOL CheckNames();


    // Generated message map functions
    //{{AFX_MSG(CSCEAddGroup)
    afx_msg void OnBrowse();
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeLogFile();
    virtual void OnOK();
    afx_msg void OnEditMsgFilter( NMHDR *pNM, LRESULT *pResult);
    afx_msg void OnChecknames();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

   //
   // Retrieve flags appropriate to our current mode.
   //
   DWORD GetModeFlags();
   DWORD m_dwModeBits;
protected:
   //
   // The users/groups chosen or typed in by the user.
   //
   PSCE_NAME_LIST m_pnlGroup;
   //
   // List of known names which will be underlined in the UI.
   //
   PSCE_NAME_LIST m_pKnownNames;
public:
   //
   // If m_sTitle, is not empty when the dialog is invoked, the string
   // will be used as the title.  m_sDescription is the title for the group
   // box
   //
   CString m_sTitle, m_sDescription;

   //
   // Flags that will be passed to CGetUser.  This is the SCE_SHOW* flags.
   // This class initializes the flag to everything in the constructor
   //
   DWORD m_dwFlags;
   BOOL m_fCheckName; //Raid #404989
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCEADDGROUP_H__66CF106B_7057_11D2_A798_00C04FD92F7B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\addgrp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       addgrp.cpp
//
//  Contents:   implementation of CSCEAddGroup
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "AddGrp.h"
#include "snapmgr.h"
#include "GetUser.h"
#include "resource.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSCEAddGroup dialog


CSCEAddGroup::CSCEAddGroup(CWnd* pParent /*=NULL*/)
    : CHelpDialog(a212HelpIDs, IDD, pParent)
{
   m_dwFlags = SCE_SHOW_GROUPS | SCE_SHOW_ALIASES | SCE_SHOW_SINGLESEL;
   m_pnlGroup = NULL;
   m_pKnownNames = NULL;
   m_fCheckName = TRUE;
   //{{AFX_DATA_INIT(CSCEAddGroup)
   // NOTE: the ClassWizard will add member initialization here
   //}}AFX_DATA_INIT
}

CSCEAddGroup::~CSCEAddGroup()
{
   SceFreeMemory( m_pnlGroup, SCE_STRUCT_NAME_LIST );
   m_pnlGroup = NULL;

   SceFreeMemory( m_pKnownNames, SCE_STRUCT_NAME_LIST );
   m_pKnownNames = NULL;
}

void CSCEAddGroup::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CSCEAddGroup)
   // NOTE: the ClassWizard will add DDX and DDV calls here
   //}}AFX_DATA_MAP
}


DWORD CSCEAddGroup::GetModeFlags() {

   if (m_dwModeBits & MB_GROUP_POLICY) {
      return (SCE_SHOW_SCOPE_DOMAIN | SCE_SHOW_SCOPE_DIRECTORY);
   }
   if (m_dwModeBits & MB_LOCAL_POLICY) {
      return (SCE_SHOW_SCOPE_ALL | SCE_SHOW_DIFF_MODE_OFF_DC);
   }
   if (m_dwModeBits & MB_ANALYSIS_VIEWER) {
      return (SCE_SHOW_SCOPE_ALL | SCE_SHOW_DIFF_MODE_OFF_DC);
   }
   if (m_dwModeBits & MB_TEMPLATE_EDITOR) {
      return (SCE_SHOW_SCOPE_ALL);
   }

   return 0;
}


BEGIN_MESSAGE_MAP(CSCEAddGroup, CHelpDialog)
    //{{AFX_MSG_MAP(CSCEAddGroup)
    ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
    ON_EN_CHANGE(IDC_LOG_FILE, OnChangeLogFile)
    ON_NOTIFY( EN_MSGFILTER, IDC_LOG_FILE, OnEditMsgFilter )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
/////////////////////////////////////////////////////////////////////////////
// CSCEAddGroup message handlers

/*-------------------------------------------------------------------------------------
CSCEAddGroup::IsKnownAccount

Synopsis:   This functions searches throught m_pKnownNames and does a case
            insensitive match on [pszAccount].  If [pszAccount] exists in the
            array then this function returns TRUE.

Arguments:  [pszAccount]   - The account to look for.

Returns:    TRUE if [pszAccount] is in the list false otherwise

-------------------------------------------------------------------------------------*/
BOOL CSCEAddGroup::IsKnownAccount( LPCTSTR pszAccount )
{
   if ( pszAccount == NULL ) return FALSE;

   PSCE_NAME_LIST pNew = m_pKnownNames;
   while(pNew){
      if( !lstrcmpi( pszAccount, pNew->Name ) ){
         return TRUE;
      }
      pNew = pNew->Next;
   }
   return FALSE;
}

/*------------------------------------------------------------------------------------
CSCEAddGroup::CleanName

Synopsis:   Removes leading and trailing spaces from the string.  This function
            places the string into the same buffer as is passed in.

Arguments:  [pszAccount]   - The buffer to clean.

------------------------------------------------------------------------------------*/
void CSCEAddGroup::CleanName( LPTSTR pszAccount )
{
   if ( pszAccount == NULL ) return;

   int i = 0;
   while( IsSpace( pszAccount[i] ) ){
      i++;
   }

   int iLen = lstrlen(pszAccount) - 1;
   while(iLen > i && IsSpace( pszAccount[iLen] ) ){
      iLen--;
   }

   iLen -= i;
   while(iLen >= 0){
      *pszAccount = *(pszAccount + i);
      pszAccount++;
      iLen--;
   }
   *pszAccount = 0;

}

/*------------------------------------------------------------------------------------
CSCEAddGroup::AddKnownAccount

Synopsis:   Adds a string to the Known accounts link list.  This list is later
            used to underline strings that are contained in this list

Arguments:  [pszAccount]   - The account to remeber.

------------------------------------------------------------------------------------*/
BOOL CSCEAddGroup::AddKnownAccount( LPCTSTR pszAccount )
{
   PSCE_NAME_LIST pNew = NULL;

   if ( pszAccount == NULL ) return FALSE;

   if(IsKnownAccount( pszAccount ) ){
      return TRUE;
   }
   pNew = (PSCE_NAME_LIST)LocalAlloc(0, sizeof(SCE_NAME_LIST));
   if(!pNew){
      return FALSE;
   }

   pNew->Name = (LPTSTR)LocalAlloc( 0, sizeof(TCHAR) * (1 + lstrlen(pszAccount)) );
   if(!pNew->Name){
      LocalFree(pNew);
      return FALSE;
   }
   //This may not be a safe usage. Using WCHAR instead of TCHAR for pNew->Name. Consider fix.
   lstrcpy(pNew->Name, pszAccount);

   pNew->Next = m_pKnownNames;
   m_pKnownNames = pNew;

   return TRUE;
}

/*------------------------------------------------------------------------------------
CSCEAddGroup::OnBrowse

Synopsis:   Calls the CGetUser dialog box to create the object picker and display
            real choices.  Since we wan't to underline all names returned by
            object picker, this function also places all names returned by
            CGetUser into the known accounts array.

------------------------------------------------------------------------------------*/
void CSCEAddGroup::OnBrowse()
{
   CGetUser gu;
   BOOL bFailed = TRUE;

   //
   // Get the rich edit control.
   //
   CRichEditCtrl *ed = (CRichEditCtrl *)GetDlgItem(IDC_LOG_FILE);

   if ( ed ) {

       //
       // Always multi select mode.
       //
       m_dwFlags &= ~SCE_SHOW_SINGLESEL;
       if (gu.Create( GetSafeHwnd(), m_dwFlags | GetModeFlags()) ) {
          //
          // Set the dialog text.
          // pAccount is a pointer to a member in getuser.cpp which will be freed there
          //
          PSCE_NAME_LIST pAccount = gu.GetUsers();

          //
          // Set the charformat, because we need to set it not to underline
          // things that we will paste into the edit control.
          //
          CHARFORMAT cf;
          ZeroMemory(&cf, sizeof( CHARFORMAT ));
          cf.cbSize = sizeof(CHARFORMAT);
          cf.dwMask = CFM_UNDERLINE;

          //
          // Enumerate through the account list and past them into the edit control.
          //
          int iLen;
          bFailed = FALSE;

          while (pAccount) {
             if(pAccount->Name){
                iLen = ed->GetTextLength();
                ed->SetSel( iLen, iLen);

                if(iLen){
                   ed->SetSelectionCharFormat( cf );
                   ed->ReplaceSel( L";" );
                   iLen ++;
                }

                if ( AddKnownAccount( pAccount->Name ) ) {

                    ed->ReplaceSel( pAccount->Name );

                } else {
                    bFailed = TRUE;
                }
             }
             pAccount = pAccount->Next;
          }
          //
          // Everything we pasted will be underlined.
          //
          UnderlineNames();

       }
   }

   if ( bFailed ) {
       //
       // something is wrong creating the object picker or pasting the account into the control
       // popup a message
       //

       CString strErr;
       strErr.LoadString( IDS_ERR_INVALIDACCOUNT );

       AfxMessageBox( strErr );
   }
}

/*-------------------------------------------------------------------------------------
CSCEAddGroup::OnInitDialog()

Synopsis:   Change the text for title and group static box.  To "Add Group" and
            "Group"

-------------------------------------------------------------------------------------*/
BOOL CSCEAddGroup::OnInitDialog()
{
   CDialog::OnInitDialog();
   CString str;

   //
   // Set the window title.  If the caller has already set the title then
   // we don't need to load the resource.
   //
   if(m_sTitle.IsEmpty()){
      // Set window text of dialog.
      m_sTitle.LoadString(IDS_ADDGROUP_TITLE);
   }

   if(m_sDescription.IsEmpty()){
      m_sDescription.LoadString(IDS_ADDGROUP_GROUP);
   }

   SetWindowText( m_sTitle );

   // Set group static text.
   CWnd *pWnd = GetDlgItem(IDC_STATIC_FILENAME);
   if (pWnd) {
      pWnd->SetWindowText(m_sDescription);
   }

   pWnd = GetDlgItem(IDC_LOG_FILE);
   if ( pWnd )
   {
       pWnd->SendMessage(EM_SETEVENTMASK, 0, ENM_CHANGE | ENM_KEYEVENTS);
       pWnd->SendMessage(EM_LIMITTEXT, 4096, 0); //Raid #271219
   }

   // disable OK button.
   pWnd = GetDlgItem(IDOK);
   if ( pWnd )
       pWnd->EnableWindow( FALSE );

   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

/*-------------------------------------------------------------------------------------
CSCEAddGroup::OnChangeLogFile()

Synopsis:   Check to see if any text is available in edit control, and disable the
            OK button if no text is available.

-------------------------------------------------------------------------------------*/
void CSCEAddGroup::OnChangeLogFile()
{
   // Enable disable edit OK button depending on edit control content.
   CRichEditCtrl *pWnd = reinterpret_cast<CRichEditCtrl *>(GetDlgItem(IDC_LOG_FILE));
   CString str;

   str.Empty();
   if (pWnd) {
      pWnd->GetWindowText(str);
   }

   CWnd *pControl = GetDlgItem(IDOK);
   if ( pControl )
   {
       //Raid #446391, Yang Gao, 7/30/2001
       if( str.IsEmpty() )
           pControl->EnableWindow( FALSE );
       else
       {
           str.Remove(L' ');
           str.Remove(L';'); 
           pControl->EnableWindow( !str.IsEmpty() );
       }
   }
}

/*-------------------------------------------------------------------------------------
CSCEAddGroup::UnderlineNames

Synopsis:   Underlines all names that are in the KnownAccounts list.

-------------------------------------------------------------------------------------*/
void CSCEAddGroup::UnderlineNames()
{
   LONG nStart, nEnd;

   //
   // Get the edit control.
   //
   CRichEditCtrl *pWnd = reinterpret_cast<CRichEditCtrl *>(GetDlgItem(IDC_LOG_FILE));
   if(!pWnd){
      return;
   }

   LPTSTR pszText = NULL;
   int iPos, iLen, i;

   //
   // Retrieve the edit control text.
   //
   iLen = pWnd->GetWindowTextLength();
    pszText = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * (2 + iLen) );
   if(!pszText){
      return;
   }

   pWnd->GetWindowText(pszText, iLen+1);
   iPos = 0;

   //
   // Get the current selection (the position of the caret)
   //
   pWnd->GetSel(nStart, nEnd );

   //
   // Hide the window so it doesn't flicker.
   //
   pWnd->SetWindowPos( NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_HIDEWINDOW | SWP_NOOWNERZORDER | SWP_NOREDRAW | SWP_NOSENDCHANGING);

   for(i = 0; i < iLen + 1; i++){
      //
      // Simi colon deliminated list.
      //
      if( pszText[i] == L';' ){
         pszText[i] = 0;
      }

      if(!pszText[i]){
         //
         // Format known names with underline.
         //
         CHARFORMAT cf;
         cf.cbSize = sizeof( CHARFORMAT );
         cf.dwMask = CFM_UNDERLINE;

         int isUn, ieUn;

         isUn = iPos;
         while( IsSpace(pszText[isUn]) ){
            isUn++;
         }

         ieUn = lstrlen( &(pszText[isUn]) ) - 1 + isUn;
         while( ieUn > 0 && IsSpace( pszText[ieUn] ) ){
            ieUn--;
         }

         //
         // See if we need to underline the name or not.
         //
         CleanName( &(pszText[isUn]) );
         if( IsKnownAccount( &(pszText[isUn]) ) ){
            cf.dwEffects = CFE_UNDERLINE;
         } else {
            cf.dwEffects &= ~CFE_UNDERLINE;
         }

         //
         // Make sure leading space characters aren't underlined.
         //
         if(isUn != iPos && cf.dwEffects & CFE_UNDERLINE){
            pWnd->SetSel( iPos, isUn);
            cf.dwEffects = 0;
            pWnd->SetSelectionCharFormat( cf );
            cf.dwEffects = CFE_UNDERLINE;
         } else {
            isUn = iPos;
         }

         //
         // trailing space characters are also not underlined.
         //
         if(cf.dwEffects & CFE_UNDERLINE){
            pWnd->SetSel(ieUn, i + 1);
            cf.dwEffects = 0;
            pWnd->SetSelectionCharFormat( cf );
            cf.dwEffects = CFE_UNDERLINE;
         } else {
            ieUn = i;
         }

         pWnd->SetSel( isUn, ieUn + 1);
         pWnd->SetSelectionCharFormat( cf );

         iPos = i + 1;
      }
   }

   //
   // Show the window without redrawing.  We will call RedrawWindow to redraw.
   //
   pWnd->SetWindowPos( NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_SHOWWINDOW | SWP_NOOWNERZORDER | SWP_NOSENDCHANGING | SWP_NOREDRAW);
   pWnd->RedrawWindow(NULL, NULL, RDW_INVALIDATE);

   //
   // Reset selection.
   //
   pWnd->SetSel(nStart, nEnd);
}

/*------------------------------------------------------------------------------------
CSCEAddGroup::OnEditMsgFilter

Synopsis:   Captures input message events from the RichEdit control.  We want,
            to underline things as the user types them.

Arguments:  [pNM]    -  [in] Pointer to a MSGFILTER structure.
            [pResult]-  [out] Pointer to a LRESULT type.  Always set to 0
------------------------------------------------------------------------------------*/
void CSCEAddGroup::OnEditMsgFilter( NMHDR *pNM, LRESULT *pResult)
{
   *pResult = 0;

#define pmf ((MSGFILTER *)pNM)
   switch( pmf->msg ){
   case WM_LBUTTONUP:
   case WM_KEYUP:
      //
      // If the caret is being moved around in the window then we don't want
      // to proccess the string since it isn't being changed.
      //
      if( pmf->msg == WM_KEYUP && pmf->wParam == VK_RIGHT ||
         pmf->wParam == VK_LEFT || pmf->wParam == VK_UP || pmf->wParam == VK_DOWN){
         break;
      }
      UnderlineNames();
      break;
   }
#undef pmf
}

/*-------------------------------------------------------------------------------------
CSCEAddGroup::CSCEAddGroup::OnOK()

Synopsis:   Copy the text the user input into the SCE_NAME_LIST structure.

-------------------------------------------------------------------------------------*/
void CSCEAddGroup::OnOK()
{
   if( !CheckNames() ){
      return;
   }

   CreateNameList( &m_pnlGroup );
   CDialog::OnOK();
}

/*------------------------------------------------------------------------------------
CSCEAddGroup::CreateNameList

Synopsis:   Creates the name list from the edit window.  The function will ensure
            that each name is only in the list once.

Arguments:  [pNameList]   -[out] Pointer a PSCE_NAME_LIST;

Returns:    The number of items added.
------------------------------------------------------------------------------------*/
int CSCEAddGroup::CreateNameList( PSCE_NAME_LIST *pNameList )
{
   if(!pNameList){
      return 0;
   }

   CWnd *pWnd = GetDlgItem(IDC_LOG_FILE);
   LPTSTR pszAccounts = NULL;

   //
   // Retrieve the window text.
   //
   int iLen = 0;
   if (pWnd) {
      iLen = pWnd->GetWindowTextLength();
      if(iLen){
        pszAccounts = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * (iLen + 2));
        if(pszAccounts){
           pWnd->GetWindowText( pszAccounts, iLen+1);
        }
      }
   }

   //
   // Create an account name for each string daliminated by a semi colon.
   //
   int iCount = 0;
   if (pszAccounts) {
      LPTSTR pszCur = pszAccounts;
      int Len=0;

      for(int i = 0; i < iLen + 1; i++){
         if( pszAccounts[i] == L';' ){
            pszAccounts[i] = 0;
         }

         if( !pszAccounts[i] ){
            CleanName(pszCur);

            if((Len = lstrlen(pszCur))){
               //
               // Ensure that we don't already have this string in our link list.
               //
               PSCE_NAME_LIST pNew = NULL;
               pNew = *pNameList;
               while(pNew){
                  if(!lstrcmpi( pNew->Name, pszCur ) ){
                     pszCur[0] = 0;
                     break;
                  }
                  pNew = pNew->Next;
               }

               if(pszCur[0]){
                  //
                  // Create a new link.
                  //
                                 
                  SceAddToNameList( pNameList, pszCur, Len);
               }
            }

            //
            // Next string to check.
            //
            pszCur = pszAccounts + i + 1;
         }
      }
   }

   return TRUE;
}

/*------------------------------------------------------------------------------------
CSCEAddGroup::CheckNames

Synopsis:   Verifies the account the user has added.  This function will display an
            error message box if any accounts are found to be in err. .

Returns:    TRUE if all names are valid, FALSE otherwise.
------------------------------------------------------------------------------------*/
BOOL CSCEAddGroup::CheckNames()
{
   PSCE_NAME_LIST pNameList = NULL;
   PSCE_NAME_LIST pErrList = NULL;

   BOOL bErr = TRUE;
   if( !CreateNameList( &pNameList ) ){
      return TRUE;
   }

   if( pNameList == NULL ) //Raid #446391, Yang Gao, 7/27/2001
   {
      (GetDlgItem(IDC_LOG_FILE))->SetWindowText(L""); 
      (GetDlgItem(IDC_LOG_FILE))->SetFocus();
      return FALSE;
   }

   CString tempstr; //raid #387570, #387739
   int iCount = 0;
   int iFind = -1;
   PSCE_NAME_LIST pNext = pNameList;
   while(pNext)
   {
      tempstr = pNext->Name;
      //Raid #647716, yanggao, 6/28/2002
      if( !pNext->Name )
      {
         pNext = pNext->Next;
         continue;
      }
      int i = 0;
      while( *(pNext->Name+i) ) //count "\" in the name.
      {
         if( *(pNext->Name+i) == L'\\')
         {
            iCount++;
         }
         i++;
      }
      
      BOOL fFullName = FALSE;
      if( iCount == 1 ) //there is only one "\" in the name.
      {
         iFind = tempstr.FindOneOf(L"\\");
         if( iFind != 0 && iFind+1 != tempstr.GetLength() ) //it is a full name.
         {
            iFind = -1;
            fFullName = TRUE;
         }
         iCount = 0;
      }
      
      if( iCount == 0 ) //find invalid characters in the name.
      {
         iFind = tempstr.FindOneOf(IDS_INVALID_USERNAME_CHARS);
      }
      if( iFind >= 0 || iCount > 0 ) //found invalid characters in the name.
      {
        CString charsWithSpaces;
        PCWSTR szInvalidCharSet = IDS_INVALID_USERNAME_CHARS; 

        UINT nIndex = 0;
        while (szInvalidCharSet[nIndex])
        {
           charsWithSpaces += szInvalidCharSet[nIndex];
           charsWithSpaces += L"  ";
           nIndex++;
        }
        if( !fFullName )
        {
           charsWithSpaces = charsWithSpaces + L"\\";
        }

        //This is a safe usage.
        tempstr.FormatMessage (IDS_INVALID_STRING, charsWithSpaces);

        AfxMessageBox(tempstr);
        GetDlgItem(IDC_LOG_FILE)->SetFocus(); 
        return FALSE;
      }
      pNext = pNext->Next;
   }

   if( !m_fCheckName ) //Raid #404989
   {
      return TRUE;
   }

   //Raid #503853, 12/11/2001, yanggao, Only check full name user account.
   pNext = pNameList;                   
   while(pNext){
      LPTSTR pszStr = pNext->Name;
      if(!IsKnownAccount(pNext->Name)){
         while( pszStr && *pszStr ){
            if( *pszStr == L'\\' ){
               SID_NAME_USE su = CGetUser::GetAccountType( pNext->Name );
               if( su == SidTypeInvalid || su == SidTypeUnknown ||
                   !AddKnownAccount(pNext->Name) ){
                  PSCE_NAME_LIST pNew = (PSCE_NAME_LIST)LocalAlloc( 0, sizeof(SCE_NAME_LIST));
                  if(pNew){
                     pNew->Name = pNext->Name;
                     pNew->Next = pErrList;
                     pErrList = pNew;
                  }
               } else {
                  UnderlineNames();
               }
               break;
            }
            pszStr++;
         }
      }
      pNext = pNext->Next;
   }
   if( pErrList ){
      CString strErr;
      strErr.LoadString( IDS_ERR_INVALIDACCOUNT );

      pNext = pErrList;
      while(pNext){
         pErrList = pNext->Next;
         strErr += pNext->Name;
         if(pErrList){
            strErr += L',';
         }
         LocalFree(pNext);
         pNext = pErrList;
      }

      AfxMessageBox( strErr );
      bErr = FALSE;
   }

   SceFreeMemory( pNameList, SCE_STRUCT_NAME_LIST );
   return bErr;
}

void CSCEAddGroup::OnChecknames()
{
   PSCE_NAME_LIST pNameList = NULL;
   if( CreateNameList( &pNameList ) ){
      PSCE_NAME_LIST pNext = pNameList;
      while(pNext){
         SID_NAME_USE su = CGetUser::GetAccountType( pNext->Name );
         if( su != SidTypeInvalid && su != SidTypeUnknown ){
            //
            // Add the name.
            //
            AddKnownAccount( pNext->Name );
         }
         pNext = pNext->Next;
      }

      SceFreeMemory( pNameList, SCE_STRUCT_NAME_LIST );

      UnderlineNames();
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\addobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       addobj.h
//
//  Contents:   definition of CAddObject
//
//----------------------------------------------------------------------------
#if !defined(AFX_ADDOBJ_H__D9D88A12_4AF9_11D1_AB57_00C04FB6C6FA__INCLUDED_)
#define AFX_ADDOBJ_H__D9D88A12_4AF9_11D1_AB57_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "HelpDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CAddObject dialog

class CAddObject : public CHelpDialog
{
// Construction
public:
    CAddObject(SE_OBJECT_TYPE SeType, LPTSTR ObjName, BOOL bIsContainer=TRUE, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CAddObject)
    enum { IDD = IDD_ADD_OBJECT };
    int		m_radConfigPrevent;
    int		m_radInheritOverwrite;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAddObject)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAddObject)
    virtual void OnOK();
    virtual void OnCancel();
    afx_msg void OnTemplateSecurity();
    virtual BOOL OnInitDialog();
    afx_msg void OnConfig();
    afx_msg void OnPrevent();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    PSECURITY_DESCRIPTOR GetSD() { return m_pNewSD; };
    SECURITY_INFORMATION GetSeInfo() { return m_NewSeInfo; };
    void SetSD(PSECURITY_DESCRIPTOR pSD) { m_pNewSD = pSD; }
    void SetSeInfo(SECURITY_INFORMATION SeInfo) { m_NewSeInfo = SeInfo; }
    BYTE GetStatus() { return m_Status; };

private:
    SE_OBJECT_TYPE m_SeType;
    CString m_ObjName;
    BOOL m_bIsContainer;

    PSECURITY_DESCRIPTOR m_pNewSD;
    SECURITY_INFORMATION m_NewSeInfo;
    BYTE m_Status;
    PFNDSCREATEISECINFO m_pfnCreateDsPage;
    LPDSSECINFO m_pSI;

   HWND m_hwndACL;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDOBJ_H__D9D88A12_4AF9_11D1_AB57_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\aenable.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aenable.cpp
//
//  Contents:   implementation of CAttrEnable
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "snapmgr.h"
#include "AEnable.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAttrEnable dialog


CAttrEnable::CAttrEnable(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD)
{
    //{{AFX_DATA_INIT(CAttrEnable)
    m_Current = _T("");
    m_EnabledRadio = -1;
    m_Title = _T("");
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a169HelpIDs;
    m_uTemplateResID = IDD;
}


void CAttrEnable::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAttrEnable)
    DDX_Text(pDX, IDC_CURRENT, m_Current);
    DDX_Radio(pDX, IDC_ENABLED, m_EnabledRadio);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttrEnable, CAttribute)
    //{{AFX_MSG_MAP(CAttrEnable)
    ON_BN_CLICKED(IDC_ENABLED, OnRadio)
    ON_BN_CLICKED(IDC_DISABLED, OnRadio)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttrEnable message handlers

void CAttrEnable::Initialize(CResult * pResult)
{
   CString str;

   CAttribute::Initialize(pResult);

   LONG_PTR dw = pResult->GetBase();
   if ( (LONG_PTR)ULongToPtr(SCE_NO_VALUE) == dw ||
        (BYTE)SCE_NO_VALUE == (BYTE)dw ) 
   {
      m_bConfigure = FALSE;
   } 
   else 
   {
      m_bConfigure = TRUE;
      //
      // BUG 145561 - dw is 0 vs non-0 boolean, not 0 vs 1
      //
      SetInitialValue((DWORD_PTR)(dw != 0));
   }

   pResult->GetDisplayName( NULL, m_Current, 2 );
}

void CAttrEnable::SetInitialValue(DWORD_PTR dw) 
{
   if (-1 == m_EnabledRadio) 
   {
      m_EnabledRadio = dw ? 0 : 1;
   }
}


void CAttrEnable::OnRadio()
{
   UpdateData(TRUE);
   CWnd *bnOK;

   SetModified(TRUE);

   bnOK = GetDlgItem(IDOK);
   if (bnOK ) {
      bnOK->EnableWindow(-1 != m_EnabledRadio);
   }
}

BOOL CAttrEnable::OnApply()
{
   if ( !m_bReadOnly )
   {
      int status = 0;
      UpdateData(TRUE);
      DWORD dw = 0;

      if (!m_bConfigure)
         dw = SCE_NO_VALUE;
      else 
      {
         switch(m_EnabledRadio) 
         {
            // ENABLED
            case 0:
               dw = 1;
               break;
            // DISABLED
            case 1:
               dw = 0;
               break;
            default:
               dw = SCE_NO_VALUE;
               break;
         }
      }

      m_pData->SetBase((LONG_PTR)ULongToPtr(dw));
      status = m_pSnapin->SetAnalysisInfo(m_pData->GetID(),(LONG_PTR)ULongToPtr(dw), m_pData);
      m_pData->SetStatus(status);
      m_pData->Update(m_pSnapin);
   }

   return CAttribute::OnApply();
}

BOOL CAttrEnable::OnInitDialog()
{
    CAttribute::OnInitDialog();

    AddUserControl(IDC_ENABLED);
    AddUserControl(IDC_DISABLED);
    OnConfigure();
    OnRadio();
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\aflags.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aflags.h
//
//  Contents:   definition of CAttrRegFlags
//
//----------------------------------------------------------------------------
#if !defined(AFX_AFLAGS_H__94E730BE_2055_486E_9781_7EBB479CB806__INCLUDED_)
#define AFX_AFLAGS_H__94E730BE_2055_486E_9781_7EBB479CB806__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CAttrRegFlags dialog

class CAttrRegFlags : public CAttribute
{
// Construction
public:
	CAttrRegFlags();   // standard constructor

   virtual void Initialize(CResult * pResult);

// Dialog Data
	//{{AFX_DATA(CAttrRegFlags)
	enum { IDD = IDD_ATTR_REGFLAGS };
   CString  m_Current;
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAttrRegFlags)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	afx_msg void OnClickCheckBox(NMHDR *pNM, LRESULT *pResult);

	// Generated message map functions
	//{{AFX_MSG(CAttrRegFlags)
	virtual BOOL OnApply();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

   PREGFLAGS m_pFlags;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AFLAGS_H__94E730BE_2055_486E_9781_7EBB479CB806__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\aflags.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aflags.cpp
//
//  Contents:   definition of CAttrRegFlags
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "chklist.h"
#include "util.h"
#include "aFlags.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAttrRegFlags dialog


CAttrRegFlags::CAttrRegFlags()
: CAttribute(IDD), m_pFlags(NULL)
{
        //{{AFX_DATA_INIT(CAttrRegFlags)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a236HelpIDs;
    m_uTemplateResID = IDD;
}


void CAttrRegFlags::DoDataExchange(CDataExchange* pDX)
{
        CAttribute::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CAttrRegFlags)
                // NOTE: the ClassWizard will add DDX and DDV calls here
   DDX_Text(pDX, IDC_CURRENT, m_Current);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttrRegFlags, CAttribute)
        //{{AFX_MSG_MAP(CAttrRegFlags)
        //}}AFX_MSG_MAP
        ON_NOTIFY(CLN_CLICK, IDC_CHECKBOX, OnClickCheckBox)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttrRegFlags message handlers
void CAttrRegFlags::Initialize(CResult * pResult)
{
   CAttribute::Initialize(pResult);

   m_pFlags = pResult->GetRegFlags();

   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(pResult->GetBase());

   if ( prv && prv->Value ) {
       m_bConfigure = TRUE;
   } else {
       m_bConfigure = FALSE;
   }

   pResult->GetDisplayName(NULL,m_Current,2);
}

BOOL CAttrRegFlags::OnInitDialog()
{
   CAttribute::OnInitDialog();
   CWnd *wndCL = NULL;
   DWORD fFlags = 0;
   DWORD fFlagsComp = 0;

   PREGFLAGS pFlags = m_pFlags;
   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());
   PSCE_REGISTRY_VALUE_INFO prvComp = (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetSetting());
   if (prv && prv->Value) {
      fFlags = (DWORD)_ttoi(prv->Value);
   }
   if (prvComp && prvComp->Value) {
      fFlagsComp = (DWORD)_ttoi(prvComp->Value);
   }
   int nIndex = 0;

   CString strOut;

   wndCL = GetDlgItem(IDC_CHECKBOX);
   if (!wndCL) {
      //
      // This should never happen
      //
      ASSERT(wndCL);
      return FALSE;
   }
   wndCL->SendMessage(CLM_RESETCONTENT,0,0);

   while(pFlags) {
      nIndex = (int) wndCL->SendMessage(CLM_ADDITEM,
                                        (WPARAM)pFlags->szName,
                                        (LPARAM)pFlags->dwValue);
      if (nIndex != -1) {
         BOOL bSet;
         //
         // Template setting: editable
         //
         bSet = ((fFlags & pFlags->dwValue) == pFlags->dwValue);
         wndCL->SendMessage(CLM_SETSTATE,
                            MAKELONG(nIndex,1),
                            bSet ? CLST_CHECKED : CLST_UNCHECKED);
         //
         // Analyzed setting: always disabled
         //
         bSet = ((fFlagsComp & pFlags->dwValue) == pFlags->dwValue);
         wndCL->SendMessage(CLM_SETSTATE,
                            MAKELONG(nIndex,2),
                            CLST_DISABLED | (bSet ? CLST_CHECKED : CLST_UNCHECKED));
      }
      pFlags = pFlags->pNext;
   }

   AddUserControl(IDC_CHECKBOX);
   EnableUserControls(m_bConfigure);
   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CAttrRegFlags::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;
      CWnd *wndCL = NULL;
      DWORD fFlags = 0;

      UpdateData(TRUE);

      wndCL = GetDlgItem(IDC_CHECKBOX);
      ASSERT(wndCL != NULL);

      if (!m_bConfigure || !wndCL)
         dw = SCE_NO_VALUE;
      else 
      {
         int nItems = (int) wndCL->SendMessage(CLM_GETITEMCOUNT,0,0);
         for (int i=0;i<nItems;i++) 
         {
            dw = (DWORD)wndCL->SendMessage(CLM_GETSTATE,MAKELONG(i,1));
            if (CLST_CHECKED == dw)
               fFlags |= wndCL->SendMessage(CLM_GETITEMDATA,i);
         }
      }
      PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());

      //
      // this address should never be NULL
      //
      ASSERT(prv != NULL);
      if ( prv ) 
      {
         PWSTR pTmp=NULL;

         if ( dw != SCE_NO_VALUE ) 
         {
            CString strTmp;
            // allocate buffer
            strTmp.Format(TEXT("%d"), fFlags);
            pTmp = (PWSTR)LocalAlloc(0, (strTmp.GetLength()+1)*sizeof(TCHAR));

            if ( pTmp )
               //This may not be a safe usage. Using sizeof(WCHAR) instead of sizeof(TCHAR). Consider fix.
               lstrcpy(pTmp,(LPCTSTR)strTmp);
            else 
            {
               // can't allocate buffer, error!!
               return FALSE;
            }
         }

         if ( prv->Value )
            LocalFree(prv->Value);
         
         prv->Value = pTmp;

         m_pData->SetBase((LONG_PTR)prv);
         m_pData->Update(m_pSnapin);
      }
   }

   return CAttribute::OnApply();
}


void CAttrRegFlags::OnClickCheckBox(NMHDR *pNM, LRESULT *pResult) //Raid #389890, 5/11/2001
{
   SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\aenable.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aenable.h
//
//  Contents:   definition of CAttrEnable
//
//----------------------------------------------------------------------------
#if !defined(AFX_ATTRENABLE_H__76BA1B2E_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_)
#define AFX_ATTRENABLE_H__76BA1B2E_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CAttrEnable dialog

class CAttrEnable : public CAttribute
{
// Construction
public:
	virtual void Initialize(CResult *pResult);
   virtual void SetInitialValue(DWORD_PTR dw);
	CAttrEnable(UINT nTemplateID);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAttrEnable)
	enum { IDD = IDD_ATTR_ENABLE };
	CString	m_Current;
	int		m_EnabledRadio;
	CString	m_Title;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAttrEnable)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAttrEnable)
	virtual BOOL OnApply();
	virtual void OnRadio();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ATTRENABLE_H__76BA1B2E_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\amember.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       AMember.h
//
//  Contents:   Definition of CAttrMember
//
//----------------------------------------------------------------------------
#if !defined(AFX_AMEMBER_H__817356C3_4A31_11D1_AB55_00C04FB6C6FA__INCLUDED_)
#define AFX_AMEMBER_H__817356C3_4A31_11D1_AB55_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "SelfDeletingPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CAttrMember dialog

class CAttrMember : public CSelfDeletingPropertyPage
{
    DECLARE_DYNCREATE(CAttrMember)

// Construction
public:
    void SetSnapin(CSnapin *pSnapin);
    void SetMemberType(DWORD nType);
    void Initialize(CResult *pData);
    void SetDefineInDatabase(BOOL fDefineInDatabase);
    void SetSibling(CAttrMember *pAttrMember);
    CAttrMember();
    virtual ~CAttrMember();

// Dialog Data
    //{{AFX_DATA(CAttrMember)
    enum { IDD = IDD_ATTR_GROUP };
    BOOL    m_fDefineInDatabase;
    CString m_strHeader;
    CEdit   m_eNoMembers;
    //}}AFX_DATA

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CAttrMember)
	public:
    virtual void OnCancel();
	virtual BOOL OnApply();
	protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CAttrMember)
    afx_msg void OnAdd();
    virtual BOOL OnInitDialog();
    afx_msg void OnClickMembers(NMHDR *pNM, LRESULT *pResult);
    afx_msg void OnDefineInDatabase();
    //}}AFX_MSG
    afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()

    void DoContextHelp (HWND hWndControl);
    PSCE_GROUP_MEMBERSHIP GetGroupInTemplate();

private: 
    BOOL SwapNoMembersDisplay(BOOL bNoMembers);
    void DeleteGroup(const CString &szGroupName);
    CString m_strPageTitle;
    bool m_bDirty;
    BOOL m_fOriginalDefineInDatabase;
    BOOL m_bAlias;
    BOOL m_bNoMembers;
    CSnapin * m_pSnapin;
    PSCE_NAME_STATUS_LIST m_pMergeList;
    DWORD m_dwType;
    CResult * m_pData;
    CAttrMember *m_pAttrMember;
    BOOL m_fProcessing;
    BOOL m_fInitialized;
    CCriticalSection m_CS;
};


#define GROUP_MEMBER_OF 1
#define GROUP_MEMBERS 2

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AMEMBER_H__817356C3_4A31_11D1_AB55_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\amember.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       AMember.cpp
//
//  Contents:   implementation of CAttrMember
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "resource.h"
#include "chklist.h"
#include "util.h"
#include "getuser.h"
#include "snapmgr.h"
#include "resource.h"
#include "AMember.h"
#include "wrapper.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CAttrMember property page

IMPLEMENT_DYNCREATE(CAttrMember, CSelfDeletingPropertyPage)

CAttrMember::CAttrMember() : CSelfDeletingPropertyPage(CAttrMember::IDD)
{
    //{{AFX_DATA_INIT(CAttrMember)
    m_fDefineInDatabase = FALSE;
    m_strHeader = _T("");
    //}}AFX_DATA_INIT

    m_psp.pszTemplate = MAKEINTRESOURCE(IDD_ATTR_GROUP);
    m_psp.dwFlags |= PSP_PREMATURE;
    m_pMergeList = NULL;
    m_fProcessing = FALSE;
    m_fInitialized = FALSE;
    m_bNoMembers = FALSE;
    m_bDirty=false;
    m_fOriginalDefineInDatabase=FALSE;
    m_bAlias=FALSE;
    m_dwType=0;
    CAttribute::m_nDialogs++;
}

CAttrMember::~CAttrMember()
{
    if ( m_pMergeList ) {
        SceFreeMemory(m_pMergeList, SCE_STRUCT_NAME_STATUS_LIST);
        m_pMergeList = NULL;
    }
    m_pData->Release();
    CAttribute::m_nDialogs--;
}

void CAttrMember::DoDataExchange(CDataExchange* pDX)
{
    CSelfDeletingPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAttrMember)
    DDX_Check(pDX, IDC_DEFINE_GROUP, m_fDefineInDatabase);
    DDX_Text(pDX, IDC_HEADER, m_strHeader);
    DDX_Control(pDX, IDC_NO_MEMBERS,m_eNoMembers);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttrMember, CSelfDeletingPropertyPage)
    //{{AFX_MSG_MAP(CAttrMember)
    ON_BN_CLICKED(IDC_DEFINE_GROUP, OnDefineInDatabase)
    ON_BN_CLICKED(IDC_ADD, OnAdd)
    //}}AFX_MSG_MAP
    ON_NOTIFY(CLN_CLICK, IDC_MEMBERS, OnClickMembers)
    ON_MESSAGE(WM_HELP, OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttrMember message handlers

void CAttrMember::OnDefineInDatabase()
{
    if (m_fProcessing)
        return;

    m_fProcessing = TRUE;

    //
    // for some strange reason the DDX isn't getting this BOOL set, so just do it
    // here which is basically the same thing
    //
    m_fDefineInDatabase = ( ((CButton *)GetDlgItem(IDC_DEFINE_GROUP))->GetCheck() == 1 );

    if (m_fDefineInDatabase) {
        (GetDlgItem(IDC_ADD))->EnableWindow(TRUE);
        //
        // use non CWnd calls for the checklist control
        //
        ::SendMessage(::GetDlgItem(this->m_hWnd, IDC_MEMBERS), WM_ENABLE, (WPARAM) TRUE, (LPARAM) 0);
    } else {
        (GetDlgItem(IDC_ADD))->EnableWindow(FALSE);
        //
        // use non CWnd calls for the checklist control
        //
        ::SendMessage(::GetDlgItem(this->m_hWnd, IDC_MEMBERS), WM_ENABLE, (WPARAM) FALSE, (LPARAM) 0);
    }

    SetModified(TRUE);

    //
    // Tell our siblings the m_fDefineInDatabase has changed
    //
    if (m_pAttrMember) {
        m_pAttrMember->SetDefineInDatabase(m_fDefineInDatabase);
    }

    m_fProcessing = FALSE;
}


void CAttrMember::OnAdd()
{
    CGetUser gu;
    HRESULT hr=S_OK;
    DWORD nFlag;
    BOOL fModify=FALSE; //Raid #497350, yanggao, 11/20/2001, make sure a new item is added this time.

    if ( GROUP_MEMBERS == m_dwType )
       nFlag = SCE_SHOW_USERS | SCE_SHOW_DOMAINGROUPS;
    else {

        nFlag = SCE_SHOW_GROUPS | SCE_SHOW_ALIASES;   // NT5 DS, nested groups
    }

    nFlag |= SCE_SHOW_SCOPE_ALL | SCE_SHOW_DIFF_MODE_OFF_DC;
    if (gu.Create(GetSafeHwnd(),nFlag)) {

        PSCE_NAME_STATUS_LIST pList, pLast=NULL;
        LRESULT iItem;
        bool bFound;

        PSCE_NAME_LIST pName = gu.GetUsers();
        CWnd *pCheckList;
        pCheckList = GetDlgItem(IDC_MEMBERS);

        if (pName && m_bNoMembers) {
           m_bNoMembers = FALSE;
           m_eNoMembers.ShowWindow(SW_HIDE);
           pCheckList->ShowWindow(SW_SHOW);
        }
        while(pName) {
            if ( pName->Name ) {
                // Is the new name in m_pMerged yet?
                pList = m_pMergeList;
                pLast = NULL;
                iItem = 0;

                bFound = false;
                while(pList) {
                    // If so, then make sure its "Template" box is checked
                    if (lstrcmp(pList->Name,pName->Name) == 0) {
                       if (!(pCheckList->SendMessage(CLM_GETSTATE,MAKELONG(iItem,1)) & CLST_CHECKED)) {
                          m_bDirty = true;
                          pCheckList->SendMessage(CLM_SETSTATE,MAKELONG(iItem,1),CLST_CHECKED);
                          fModify = true;
                       }
                       bFound = true;
                       break;
                    }
                    pLast = pList;
                    pList = pList->Next;
                    iItem++;
                }

                // Otherwise add it both to m_pMerged and to the CheckList
                if (!bFound) {

                    PSCE_NAME_STATUS_LIST pNewNode;

                    pNewNode = (PSCE_NAME_STATUS_LIST)LocalAlloc(0,sizeof(SCE_NAME_STATUS_LIST));
                    if ( pNewNode ) {

                        pNewNode->Name = (LPTSTR)LocalAlloc(0, (lstrlen(pName->Name)+1)*sizeof(TCHAR));
                        if ( pNewNode->Name ) {
                            // This may not be a safe usage. pNewNode->Name is PWSTR, using WCHAR instead of TCHAR,
                            // and lstrlen dose not handle not null-terminated pointer. Consider fix
                            lstrcpy(pNewNode->Name, pName->Name);
                            pNewNode->Next = NULL;
                            pNewNode->Status = MERGED_TEMPLATE;
                        } else {
                            LocalFree(pNewNode);
                            pNewNode = NULL;
                        }
                    }
                    if ( pNewNode ) {
                        if ( pLast )
                            pLast->Next = pNewNode;
                        else
                            m_pMergeList = pNewNode;
                        pLast = pNewNode;

                        iItem = pCheckList->SendMessage(CLM_ADDITEM,(WPARAM)pLast->Name,(LPARAM)pLast->Name);
                        pCheckList->SendMessage(CLM_SETSTATE,MAKELONG(iItem,1),CLST_CHECKED);
                        pCheckList->SendMessage(CLM_SETSTATE,MAKELONG(iItem,2),CLST_DISABLED);
                        m_bDirty = true;
                        fModify = true;
                    } else {
                        hr = E_OUTOFMEMORY;
                        ASSERT(FALSE);
                        break;
                    }
                }
            }
            pName = pName->Next;
        }
    }

    if (fModify) {
        SetModified(TRUE);
    }

    if ( FAILED(hr) ) {
        CString str;
        str.LoadString(IDS_CANT_ADD_MEMBER);
        AfxMessageBox(str);
    }

}

/*---------------------------------------------------------------------

    Method:     OnInitDialog

    Synopsis:   Initialize the check list with members/memberof data

    Arguments:  None

    Returns:    TRUE = initialized successfully

----------------------------------------------------------------------*/
BOOL CAttrMember::OnInitDialog()
{
   CSelfDeletingPropertyPage::OnInitDialog();


   PSCE_NAME_STATUS_LIST pItem;
   HWND hCheckList;
   LRESULT nItem;
   PSCE_GROUP_MEMBERSHIP pgmTemplate;
   PSCE_GROUP_MEMBERSHIP pgmInspect;
   PSCE_NAME_LIST pnlTemplate=NULL;
   PSCE_NAME_LIST pnlInspect=NULL;
   PEDITTEMPLATE pet = NULL;
   CString str;

   UpdateData(TRUE);
   if (GROUP_MEMBER_OF == m_dwType) {
      str.LoadString(IDS_NO_MEMBER_OF);
   } else {
      str.LoadString(IDS_NO_MEMBERS);
   }
   m_eNoMembers.SetWindowText(str);

   pgmInspect = (PSCE_GROUP_MEMBERSHIP) m_pData->GetID();   // last inspection saved in ID field

   if ( NULL == pgmInspect ) {  // last inspection can't be NULL
       return TRUE;
   }

   m_fOriginalDefineInDatabase = m_fDefineInDatabase = FALSE;

   //
   // Try to find the base group in the template
   //
   pet = m_pSnapin->GetTemplate(GT_COMPUTER_TEMPLATE);
   if ( NULL == pet ) {
      return TRUE;
   }

   for (pgmTemplate=pet->pTemplate->pGroupMembership;
        pgmTemplate!=NULL;
        pgmTemplate=pgmTemplate->Next) {

      if ( _wcsicmp(pgmTemplate->GroupName, pgmInspect->GroupName) == 0 ) {
         //
         // If the group is in the template that means it is defined.... duh
         //
         m_fOriginalDefineInDatabase = m_fDefineInDatabase = TRUE;
         break;
      }
   }

   //
   // find the name lists to display
   //
   if ( pgmTemplate ) {

       if (GROUP_MEMBER_OF == m_dwType) {
           pnlTemplate = pgmTemplate->pMemberOf;
       } else {
           pnlTemplate = pgmTemplate->pMembers;
       }
   }

   if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) != (LONG_PTR) pgmInspect &&
       pgmInspect ) {

       if (GROUP_MEMBER_OF == m_dwType) {
           pnlInspect = pgmInspect->pMemberOf;
       } else {
           pnlInspect = pgmInspect->pMembers;
       }
   }

   m_pMergeList = MergeNameStatusList(pnlTemplate, pnlInspect);

   pItem = m_pMergeList;
   hCheckList = ::GetDlgItem(m_hWnd,IDC_MEMBERS);

   ::SendMessage(hCheckList, CLM_RESETCONTENT, 0, 0 );
   ::SendMessage(hCheckList,CLM_SETCOLUMNWIDTH,0,60);

   if (!pItem) {
      m_bNoMembers = TRUE;
      m_eNoMembers.ShowWindow(SW_SHOW);
      m_eNoMembers.EnableWindow(FALSE); //Raid #469732, Yanggao
      ::ShowWindow(hCheckList,SW_HIDE);
   }

   while(pItem) {
      //
      // Store the name of the item in the item data so we can retrieve it later
      //
      nItem = ::SendMessage(hCheckList,CLM_ADDITEM,(WPARAM) pItem->Name,(LPARAM) pItem->Name);
      ::SendMessage(hCheckList,CLM_SETSTATE,MAKELONG(nItem,1),
                  ((pItem->Status & MERGED_TEMPLATE) ? CLST_CHECKED : CLST_UNCHECKED));
      ::SendMessage(hCheckList,CLM_SETSTATE,MAKELONG(nItem,2),
                  ((pItem->Status & MERGED_INSPECT) ? CLST_CHECKDISABLED : CLST_DISABLED));
      pItem = pItem->Next;
   }

   if ( GROUP_MEMBER_OF == m_dwType ) {

       m_bAlias = TRUE;

   } else {
       m_bAlias = FALSE;
   }

   CWnd *cwnd = GetDlgItem(IDC_ADD);
   if ( cwnd ) {
       cwnd->EnableWindow(!m_bAlias);
   }

   CButton *pButton = (CButton *) GetDlgItem(IDC_DEFINE_GROUP);
   if (pButton) {
       pButton->SetCheck(m_fDefineInDatabase);
   }

   OnDefineInDatabase();

   SetModified(FALSE);

   m_fInitialized = TRUE;

   return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


/*---------------------------------------------------------------------

    Method:     SetDefineInDatabase

    Synopsis:   Sets the m_fDefineInDatabase member var, and UI accorsingly

    Arguments:  fDefineInDatabase

    Returns:    None

----------------------------------------------------------------------*/
void CAttrMember::SetDefineInDatabase(BOOL fDefineInDatabase)
{
   if (!m_fInitialized)
       return;

   if (m_fProcessing)
       return;

   m_fDefineInDatabase = fDefineInDatabase;

   CButton *pButton = (CButton *) GetDlgItem(IDC_DEFINE_GROUP);
   if (pButton) {
      pButton->SetCheck(fDefineInDatabase);
   }

   OnDefineInDatabase();
}


/*---------------------------------------------------------------------

    Method:     SetSibling

    Synopsis:   Sets the pointer to the Sibling class

    Arguments:  pAttrMember

    Returns:    None

----------------------------------------------------------------------*/
void CAttrMember::SetSibling(CAttrMember *pAttrMember)
{
    m_pAttrMember = pAttrMember;
}


/*---------------------------------------------------------------------

    Method:     Initialize

    Synopsis:   Initialize member data

    Arguments:  pData - the CResult data record

    Returns:    None

----------------------------------------------------------------------*/
void CAttrMember::Initialize(CResult * pData)
{
   m_pData = pData;
   pData->AddRef();

   m_bDirty=false;
}


/*---------------------------------------------------------------------

    Method:     GetGroupInTemplate

    Synopsis:   Returns a pointer to the SCE_GROUP_MEMBERSHIP structure
                that is being changed within the template

    Arguments:  None

    Returns:    Pointer the group being modified.

----------------------------------------------------------------------*/
PSCE_GROUP_MEMBERSHIP CAttrMember::GetGroupInTemplate()
{
   PSCE_GROUP_MEMBERSHIP    pgmTemplate;
   PSCE_GROUP_MEMBERSHIP    pgmInspect;
   PEDITTEMPLATE            pet;

   pgmInspect = (PSCE_GROUP_MEMBERSHIP) m_pData->GetID();   // last inspection saved in ID field

   if ( NULL == pgmInspect ) {  // last inspection can't be NULL
        return NULL;
   }

   pet = m_pSnapin->GetTemplate(GT_COMPUTER_TEMPLATE);
   if ( NULL == pet ) {
        return NULL;
   }

   for (pgmTemplate=pet->pTemplate->pGroupMembership;
        pgmTemplate!=NULL;
        pgmTemplate=pgmTemplate->Next) {

      if ( _wcsicmp(pgmTemplate->GroupName, pgmInspect->GroupName) == 0 ) {
         return pgmTemplate;
      }
   }

   return NULL;
}


/*---------------------------------------------------------------------

    Method:     SetMemberType

    Synopsis:   Initialize page data depending on the type

    Arguments:  nType - the page type for members of memberof

    Returns:    None

----------------------------------------------------------------------*/
void CAttrMember::SetMemberType(DWORD nType)
{
   m_dwType = nType;
   if (GROUP_MEMBERS == nType) {
      m_strHeader.LoadString(IDS_GROUP_MEMBERS_HEADER);
      m_strPageTitle.LoadString(IDS_GROUP_MEMBERS_PAGE_TITLE);
   } else {
      m_strHeader.LoadString(IDS_GROUP_MEMBER_OF_HEADER);
      m_strPageTitle.LoadString(IDS_GROUP_MEMBER_OF_PAGE_TITLE);
   }
   m_psp.dwFlags |= PSP_USETITLE;
   m_psp.pszTitle = (LPCTSTR) m_strPageTitle;

}

void CAttrMember::SetSnapin(CSnapin * pSnapin)
{
   m_pSnapin = pSnapin;
}

void CAttrMember::OnCancel()
{
    if ( m_pMergeList ) {
       SceFreeMemory(m_pMergeList,SCE_STRUCT_NAME_STATUS_LIST);
    }
    m_pMergeList = NULL;
}


void CAttrMember::OnClickMembers(NMHDR *pNM, LRESULT *pResult)
{
   SetModified(TRUE);
   //
   // If no items are checked then show the no members edit box instead
   //
   CWnd *pCheckList;
   int iItem;
   int nItem;
   PNM_CHECKLIST pNMCheckList;

   pNMCheckList = (PNM_CHECKLIST) pNM;
   if (pNMCheckList->dwState & CLST_CHECKED) {
      //
      // They checked something, so obviously something is checked
      //
      return;
   }

   pCheckList = GetDlgItem(IDC_MEMBERS);
   nItem = (int) pCheckList->SendMessage(CLM_GETITEMCOUNT);
   for(iItem=0;iItem<nItem;iItem++) {
      if ((pCheckList->SendMessage(CLM_GETSTATE,MAKELONG(iItem,1)) & CLST_CHECKED) ||
          (pCheckList->SendMessage(CLM_GETSTATE,MAKELONG(iItem,2)) & CLST_CHECKED)) {
         //
         // Something's checked, so abort
         //
         return;
      }
   }
   //
   // Nothing checked.  Swap to the no members edit box
   //
   m_bNoMembers = TRUE;
   m_eNoMembers.ShowWindow(SW_SHOW);
   pCheckList->ShowWindow(SW_HIDE);
}



BOOL CAttrMember::OnApply()
{
   int iItem;
   PEDITTEMPLATE pet=NULL;
   PSCE_PROFILE_INFO pspi=NULL;
   PSCE_NAME_STATUS_LIST pIndex;
   CWnd *pCheckList;
   PSCE_NAME_LIST pTemplate=NULL;
   PSCE_NAME_LIST pInspect=NULL;
   PSCE_NAME_LIST pDeleteNameList = NULL;
   PSCE_GROUP_MEMBERSHIP pSetting = NULL;
   PSCE_GROUP_MEMBERSHIP pBaseGroup = NULL;
   PSCE_GROUP_MEMBERSHIP pFindGroup = NULL;
   PSCE_GROUP_MEMBERSHIP pModifiedGroup = NULL;

   LPCTSTR szGroupName = (LPCTSTR) (m_pData->GetAttr());

   pCheckList = GetDlgItem(IDC_MEMBERS);
   pIndex = m_pMergeList;
   iItem = 0;
   HRESULT hr=S_OK;

   //
   // if the fDefineInDatabase has changed it is definitely dirty
   //
   m_bDirty = ( m_bDirty || (m_fOriginalDefineInDatabase != m_fDefineInDatabase) );

   //
   // only create the name list if the group is going to be defined in the database
   //
   if (m_fDefineInDatabase) {
       while(pIndex) {

          if (pCheckList->SendMessage(CLM_GETSTATE,MAKELONG(iItem,1)) & CLST_CHECKED) {

            if ( !(pIndex->Status & MERGED_TEMPLATE) ) {
                m_bDirty = true;
            }

            if ( SCESTATUS_SUCCESS != SceAddToNameList(&pTemplate, pIndex->Name, lstrlen(pIndex->Name))) {
                hr = E_FAIL;
                break;
            }
          } else if ( pIndex->Status & MERGED_TEMPLATE ) {
             m_bDirty = true;
          }

          pIndex = pIndex->Next;
          iItem++;
       }
   }

   if ( SUCCEEDED(hr) && m_bDirty) {

      pBaseGroup = GetGroupInTemplate();

      //
      // Need to add the group to the template
      //
      if ( (!pBaseGroup || (LONG_PTR)pBaseGroup == (LONG_PTR)ULongToPtr(SCE_NO_VALUE)) &&
           m_fDefineInDatabase) {

         pBaseGroup = (PSCE_GROUP_MEMBERSHIP) LocalAlloc(LMEM_ZEROINIT,sizeof(SCE_GROUP_MEMBERSHIP));

         if ( pBaseGroup && szGroupName ) {
             pBaseGroup->GroupName = (PWSTR)LocalAlloc(0, (lstrlen(szGroupName)+1)*sizeof(TCHAR));

             if ( pBaseGroup->GroupName ) {
                 // This may not be safe usage. Using WCHAR instead of TCHAR. Consider fix.
                 lstrcpy(pBaseGroup->GroupName,szGroupName);
                 //
                 // link the new structure to the pGroupMembership list
                 //
                 pet = m_pSnapin->GetTemplate(GT_COMPUTER_TEMPLATE,AREA_GROUP_MEMBERSHIP);
                 if (pet) {
                    pspi = pet->pTemplate;
                 } else {
                     pspi = NULL;
                 }

                 if ( pspi ) {
                     pBaseGroup->Next = pspi->pGroupMembership;
                     pspi->pGroupMembership = pBaseGroup;

                     pBaseGroup->pMembers = NULL;
                     pBaseGroup->pMemberOf = NULL;

                 } else {
                    //
                    // error
                    ASSERT(FALSE);
                    LocalFree(pBaseGroup->GroupName);
                    hr = E_FAIL;
                 }
             } else {
                //
                // no memory
                //
                hr = E_OUTOFMEMORY;
             }
         } else {
             hr = E_OUTOFMEMORY;
         }

         if ( FAILED(hr) && pBaseGroup ) {
             LocalFree(pBaseGroup);
             pBaseGroup = NULL;
         }

         pModifiedGroup = pBaseGroup;

      //
      // Need to remove the group from the template
      //
      } else if (pBaseGroup && !m_fDefineInDatabase) {

        CString szGroupName;
        szGroupName = pBaseGroup->GroupName;
        pBaseGroup = NULL;
        DeleteGroup(szGroupName);
      //
      // An existing group was modified
      //
      } else {
        pModifiedGroup = pBaseGroup;
      }

      //
      // get group address to change the status field in the last inspection
      //
      pSetting = (PSCE_GROUP_MEMBERSHIP)(m_pData->GetID());

      int status;
      if (GROUP_MEMBERS == m_dwType) {

        if (pModifiedGroup != NULL) {
            pDeleteNameList = pModifiedGroup->pMembers;
            pModifiedGroup->pMembers = pTemplate;
        }

        if (NULL !=  pSetting ) {
            if ( !((pSetting->Status & SCE_GROUP_STATUS_NOT_ANALYZED) ||
                   (pSetting->Status & SCE_GROUP_STATUS_ERROR_ANALYZED))) {

                //
                // set good, not configured, or mismatch
                //
                pSetting->Status &= ~SCE_GROUP_STATUS_NC_MEMBERS;
                pSetting->Status &= ~SCE_GROUP_STATUS_MEMBERS_MISMATCH;
                if (pModifiedGroup == NULL) {
                    pSetting->Status |= SCE_GROUP_STATUS_NC_MEMBERS;
                } else if ( !SceCompareNameList(pTemplate, pSetting->pMembers) ) {
                    pSetting->Status |= SCE_GROUP_STATUS_MEMBERS_MISMATCH;
                }
            }

        } else {
           //
           // else should NEVER occur
           //
           status = SCE_GROUP_STATUS_MEMBERS_MISMATCH;
        }

      } else {
         //
         // memberof
         //

        if (pModifiedGroup != NULL) {
            pDeleteNameList = pModifiedGroup->pMemberOf;
            pModifiedGroup->pMemberOf = pTemplate;
        }

        if ( pSetting ) {
            if ( !((pSetting->Status & SCE_GROUP_STATUS_NOT_ANALYZED) ||
                   (pSetting->Status & SCE_GROUP_STATUS_ERROR_ANALYZED))) {

                //
                // set good, not configured, or mismatch
                //
                pSetting->Status &= ~SCE_GROUP_STATUS_NC_MEMBEROF;
                pSetting->Status &= ~SCE_GROUP_STATUS_MEMBEROF_MISMATCH;
                if (pModifiedGroup == NULL) {
                    pSetting->Status |= SCE_GROUP_STATUS_NC_MEMBEROF;
                } else if ( !SceCompareNameList(pTemplate, pSetting->pMemberOf) ) {
                    pSetting->Status |= SCE_GROUP_STATUS_MEMBEROF_MISMATCH;
                }
            }

        } else {
           // else should NEVER occur
            status = SCE_GROUP_STATUS_MEMBEROF_MISMATCH;
        }
      }
      pTemplate = NULL;

      SceFreeMemory(pDeleteNameList,SCE_STRUCT_NAME_LIST);

      if ( pSetting ) {
          status = pSetting->Status;
      }

      //
      // update current record
      //
      // status
      m_pData->SetStatus(GetGroupStatus(status, STATUS_GROUP_RECORD));
      // members status
      m_pData->SetBase(GetGroupStatus(status, STATUS_GROUP_MEMBERS));
      // memberof status
      m_pData->SetSetting(GetGroupStatus(status, STATUS_GROUP_MEMBEROF));
      m_pData->Update(m_pSnapin);
      //
      // update the dirty flag in the template
      //
      pet = m_pSnapin->GetTemplate(GT_COMPUTER_TEMPLATE,AREA_GROUP_MEMBERSHIP);
      if (pet) {
         pet->SetDirty(AREA_GROUP_MEMBERSHIP);
      }

   } // failed

   SceFreeMemory(pTemplate,SCE_STRUCT_NAME_LIST);

   if ( FAILED(hr) ) {
       CString str;
       str.LoadString(IDS_SAVE_FAILED);
       AfxMessageBox(str);
   } else {
       CancelToClose();
       SetModified(TRUE);
       return TRUE;
   }
   return FALSE;
}

BOOL CAttrMember::OnHelp(WPARAM wParam, LPARAM lParam)
{
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        this->DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    return TRUE;
}

void CAttrMember::DoContextHelp (HWND hWndControl)
{
    // Display context help for a control
    if ( !::WinHelp (
            hWndControl,
            GetSeceditHelpFilename(),
            HELP_WM_HELP,
            (DWORD_PTR) a214HelpIDs) )
    {

    }
}


void CAttrMember::DeleteGroup(const CString &szGroupName)
{
    CSingleLock cSL(&m_CS, FALSE);
    cSL.Lock();

    PEDITTEMPLATE pet = NULL;
    PSCE_PROFILE_INFO pspi = NULL;
    PSCE_GROUP_MEMBERSHIP pFindGroup = NULL;
    PSCE_GROUP_MEMBERSHIP pDeleteGroup = NULL;

    pet = m_pSnapin->GetTemplate(GT_COMPUTER_TEMPLATE,AREA_GROUP_MEMBERSHIP);
    if (pet) {
        pspi = pet->pTemplate;
    } else {
        pspi = NULL;
    }

    if ( pspi ) {

        //
        // find the group in the template and remove it
        //
        pFindGroup = pspi->pGroupMembership;

        if (pFindGroup == NULL)
            return;

        if (pFindGroup->GroupName == szGroupName) {

            pspi->pGroupMembership = pFindGroup->Next;
            pDeleteGroup = pFindGroup;

        } else {

            while (pFindGroup->Next && (pFindGroup->Next->GroupName != szGroupName)) {
                pFindGroup = pFindGroup->Next;
            }

            if (pFindGroup->Next) {

                pDeleteGroup = pFindGroup->Next;
                pFindGroup->Next = pDeleteGroup->Next;
            }
        }

        if (pDeleteGroup) {
            LocalFree(pDeleteGroup->GroupName);
            SceFreeMemory(pDeleteGroup->pMembers,SCE_STRUCT_NAME_LIST);
            SceFreeMemory(pDeleteGroup->pMemberOf,SCE_STRUCT_NAME_LIST);
            LocalFree(pDeleteGroup);
        }

    } else {
        //
        // error
        //
        ASSERT(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\anumber.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       ANumber.cpp
//
//  Contents:   Implementation of CAttrNumber
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "util.h"
#include "ANumber.h"
#include "DDWarn.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/*--------------------------------------------------------------------------------------
The constant values below are used to retrieve the string ID of the description for
a range of values.
    struct {
    int     iMin        - >= The value must be greater than or equal to this value.
    int     iMax        - <= The value must be less than or equale to this value.
    WORD    uResource   - The resource id of the item.
    WORD    uMask       - Flag that describes which memebers are valid.  The Resource
                            ID must always be valid.  If a flag is not set for the
                            coorisponding item, then the point is not checked against
                            the value.

                            RDIF_MIN        - The [iMin] member is valid.
                            RDIF_MAX        - [iMax] member is valid.
                            RDIF_END        - This is the end of the array. The last
                                                item in all declarations must set this
                                                flag.
--------------------------------------------------------------------------------------*/
//
// Minimum password description for number attribute.
//
RANGEDESCRIPTION g_rdMinPassword[] =
{
    { 0,    0,      IDS_CHANGE_IMMEDIATELY,     RDIF_MIN | RDIF_MAX },
    { 1,    0,      IDS_PASSWORD_CHANGE,        RDIF_MIN | RDIF_END }
};


//
// Maximum password description for number attribute.
//
RANGEDESCRIPTION g_rdMaxPassword[] =
{
    { 1,    999,    IDS_PASSWORD_EXPIRE,        RDIF_MIN | RDIF_MAX },
    { 0,    0,      IDS_PASSWORD_FOREVER,       RDIF_MIN | RDIF_END},
};

//
// Password len descriptions.
//
RANGEDESCRIPTION g_rdPasswordLen[] =
{
    {0,     0,      IDS_PERMIT_BLANK,           RDIF_MIN | RDIF_MAX },
    {1,     0,      IDS_PASSWORD_LEN,           RDIF_MIN | RDIF_END }
};


//
// Password histroy description.
//
RANGEDESCRIPTION g_rdPasswordHistory[] =
{
    {0,     0,      IDS_NO_HISTORY,             RDIF_MIN | RDIF_MAX },
    {1,     0,      IDS_PASSWORD_REMEMBER,      RDIF_MIN | RDIF_END }
};

//
// Password lockout descriptions
//
RANGEDESCRIPTION g_rdLockoutAccount[] =
{
    {0,     0,      IDS_NO_LOCKOUT,             RDIF_MIN | RDIF_MAX },
    {1,     0,      IDS_LOCKOUT_AFTER,          RDIF_MIN | RDIF_END }
};

//
// Lockout duration description.
//
RANGEDESCRIPTION g_rdLockoutFor[] =
{
    {1,     0,      IDS_DURATION,               RDIF_MIN },
    {0,     0,      IDS_LOCKOUT_FOREVER,        RDIF_MAX | RDIF_END}
};

RANGEDESCRIPTION g_rdAutoDisconnect[] =
{
   { 1, 0, IDS_RNH_AUTODISCONNECT_STATIC, RDIF_MIN },
   { 0, 0, IDS_RNH_AUTODISCONNECT_SPECIAL, RDIF_MAX | RDIF_END}
};

RANGEDESCRIPTION g_rdPasswordWarnings[] =
{
   { 0, 0, IDS_RNH_PASSWORD_WARNINGS_SPECIAL, RDIF_MIN | RDIF_MAX},
   { 1, 0, IDS_RNH_PASSWORD_WARNINGS_STATIC, RDIF_MIN | RDIF_END}
};

RANGEDESCRIPTION g_rdCachedLogons[] =
{
   { 0, 0, IDS_RNH_CACHED_LOGONS_SPECIAL, RDIF_MIN | RDIF_MAX},
   { 1, 0, IDS_RNH_CACHED_LOGONS_STATIC, RDIF_MIN | RDIF_END}
};



/*--------------------------------------------------------------------------------------
Method:     GetRangeDescription

Synopsis:   This function was specifically created for SCE.  Call this function if the
            Item ID to, and current range value to retrieve the corrisponding string.

Arguments:  [uType]     - [in]  ID of the point you want the description for.
            [i]         - [in]  The point you want the description for.
            [pstrRet]   - [out] The return value.

Returns:    ERROR_SUCCESS       - The operation was successfull.
            ERROR_INVALID_DATA  - The id may not be supported or [pstrRet] is NULL.
            Other Win32 errors if resource loading was not successful.

--------------------------------------------------------------------------------------*/
DWORD
GetRangeDescription(
    IN  UINT uType,
    IN  int i,
    OUT CString *pstrRet
    )
{
    switch(uType){
    case IDS_LOCK_DURATION:
        uType = GetRangeDescription(g_rdLockoutFor, i);
        break;
    case IDS_MAX_PAS_AGE:
        uType = GetRangeDescription(g_rdMaxPassword, i);
        break;
    case IDS_LOCK_COUNT:
        uType = GetRangeDescription(g_rdLockoutAccount, i);
        break;
    case IDS_MIN_PAS_AGE:
        uType = GetRangeDescription(g_rdMinPassword, i);
        break;
    case IDS_MIN_PAS_LEN:
        uType = GetRangeDescription(g_rdPasswordLen, i);
        break;
    case IDS_PAS_UNIQUENESS:
        uType = GetRangeDescription(g_rdPasswordHistory, i);
        break;
    case IDS_LOCK_RESET_COUNT:
       uType = 0;
       break;

    default:
        uType = 0;
    }

    if(uType && pstrRet){
        //
        // Try to load the resource string.
        //
        __try {
            if( pstrRet->LoadString(uType) ){
                return ERROR_SUCCESS;
            }
        } __except(EXCEPTION_CONTINUE_EXECUTION) {
            return (DWORD)E_POINTER;
        }
        return GetLastError();
    }
    return ERROR_INVALID_DATA;
}


/*--------------------------------------------------------------------------------------
Method:     GetRangeDescription

Synopsis:   This function works directly with the RANGEDESCRIPTION structure.  Tests
            to see which string resource ID to return.  This is determined by testing [i]
            with the [iMin] and [iMax] value of a RANGEDESCRIPTION structure. RDIF_MIN
            or/and RDIF_MAX must be set in the [uMask] member for this function to
            perform any comparisons

Arguments:  [pDesc]     - [in]  An array of RANGEDESCRIPTIONS, the last member of this
                                array must set RDIF_END flag in the [uMask] member.
            [i]         - [in]  The point to test.

Returns:    A String resource ID if successfull.  Otherwise 0.

--------------------------------------------------------------------------------------*/
UINT
GetRangeDescription(
    RANGEDESCRIPTION *pDesc,
    int i
    )
{
    RANGEDESCRIPTION *pCur = pDesc;
    if(!pDesc){
        return 0;
    }

    //
    // The uMask member of the description tells us wich members
    // of the structure is valid.
    //
    while( 1 ){
        if( (pCur->uMask & RDIF_MIN) ) {
            //
            // Test the minimum.
            //
            if(i >= pCur->iMin){
                if(pCur->uMask & RDIF_MAX){
                    //
                    // Test the maximum.
                    //
                    if( i <= pCur->iMax) {
                        return pCur->uResource;
                    }
                } else {
                    return pCur->uResource;
                }
            }
        } else if(pCur->uMask & RDIF_MAX) {
            //
            // Test only the maximum.
            //
            if(i <= pCur->iMax){
                return pCur->uResource;
            }
        }

        if(pCur->uMask & RDIF_END){
            //
            // This is the last element of the array, so end the loop.
            //
            break;
        }
        pCur++;
    }
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CAttrNumber dialog
CAttrNumber::CAttrNumber(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD), 
    m_cMinutes(0), 
    m_nLow(0), 
    m_nHigh(999), 
    m_nSave(0), 
    m_pRDescription(NULL)
{
    //{{AFX_DATA_INIT(CAttrNumber)
    m_strUnits = _T("");
    m_strSetting = _T("");
    m_strBase = _T("");
    m_strTemplateTitle = _T("");
    m_strLastInspectTitle = _T("");
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a168HelpIDs;
    m_uTemplateResID = IDD;
}


void CAttrNumber::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAttrNumber)
    DDX_Control(pDX, IDC_SPIN, m_SpinValue);
    DDX_Text(pDX, IDC_UNITS, m_strUnits);
    DDX_Text(pDX, IDC_CURRENT, m_strSetting);
    DDX_Text(pDX, IDC_NEW, m_strBase);
    DDX_Text(pDX, IDC_TEMPLATE_TITLE, m_strTemplateTitle);
    DDX_Text(pDX, IDC_LI_TITLE, m_strLastInspectTitle);
    DDX_Text(pDX, IDC_RANGEERROR,m_strError);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttrNumber, CAttribute)
    //{{AFX_MSG_MAP(CAttrNumber)
    ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN, OnDeltaposSpin)
    ON_EN_KILLFOCUS(IDC_NEW, OnKillFocusNew)
    ON_BN_CLICKED(IDC_CONFIGURE, OnConfigure)
    ON_EN_UPDATE(IDC_NEW, OnUpdateNew)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttrNumber message handlers

void CAttrNumber::OnDeltaposSpin( NMHDR* pNMHDR, LRESULT* pResult )
{
    NM_UPDOWN FAR *pnmud = (NM_UPDOWN FAR *)pNMHDR;

    if ( pnmud ) {

        //
        // get current value
        //
        long lVal = CurrentEditValue();

        if (SCE_FOREVER_VALUE == lVal) {
           if (pnmud->iDelta > 0) {
              if (m_cMinutes & DW_VALUE_OFF) {
                 lVal = SCE_KERBEROS_OFF_VALUE;
              } else {
                 lVal = m_nHigh;
              }
           } else {
              lVal = m_nLow;
           }
        } else if (SCE_KERBEROS_OFF_VALUE == lVal) {
           if (pnmud->iDelta < 0) {
              if (m_cMinutes & DW_VALUE_FOREVER) {
                 lVal = SCE_FOREVER_VALUE;
              } else {
                 lVal = m_nLow;
              }
           } else {
              lVal = m_nHigh;
           }
        } else {
           lVal -= (LONG)(m_iAccRate*pnmud->iDelta);

           if ( lVal > m_nHigh ) {
               // if it is overflow, go back to low
               if ( m_cMinutes & DW_VALUE_OFF ) {
                  lVal = SCE_KERBEROS_OFF_VALUE;

               } else if (m_cMinutes & DW_VALUE_FOREVER) {
                  lVal = SCE_FOREVER_VALUE;
               } else {
                  lVal = m_nLow;
               }
           } else if ( (lVal < m_nLow) &&
                ((lVal != SCE_KERBEROS_OFF_VALUE) || !(m_cMinutes & DW_VALUE_OFF)) &&
                ((lVal != SCE_FOREVER_VALUE) || !(m_cMinutes & DW_VALUE_FOREVER))) {
               // if it is underflow, go back to high
              if ( (m_cMinutes & DW_VALUE_FOREVER) && (lVal != SCE_FOREVER_VALUE)) {
                 lVal = SCE_FOREVER_VALUE;
              } else if ((m_cMinutes & DW_VALUE_OFF) && (lVal != SCE_KERBEROS_OFF_VALUE)) {
                 lVal = SCE_KERBEROS_OFF_VALUE;
              } else {
                 lVal = m_nHigh;
              }
           }


           if ( 0 == lVal && (m_cMinutes & DW_VALUE_NOZERO) ) {
               // zero is not allowed
               if ( m_nLow > 0 ) {
                   lVal = m_nLow;
               } else {
                   lVal = 1;
               }
           }
        }

        SetValueToEdit(lVal);
    }

    *pResult = 0;
}

void CAttrNumber::OnKillFocusNew()
{
   LONG lVal = CurrentEditValue();

   SetValueToEdit(lVal);
}

void CAttrNumber::SetValueToEdit(LONG lVal)
{
    CString strNew;

    if ( m_iStaticId )
        m_strTemplateTitle.LoadString(m_iStaticId);
    else
        m_strTemplateTitle = _T("");

    if ( 0 == lVal ) {
        strNew.Format(TEXT("%d"),lVal);

        if ( m_cMinutes & DW_VALUE_NEVER &&
                  m_iNeverId > 0 ) {
            // change to never
            m_strTemplateTitle.LoadString(m_iNeverId);
        }

    } else if ( SCE_FOREVER_VALUE == lVal ) {

        strNew.LoadString(IDS_FOREVER);
        if ( m_iNeverId )
            m_strTemplateTitle.LoadString(m_iNeverId);

    } else if (SCE_KERBEROS_OFF_VALUE == lVal) {
       strNew.LoadString(IDS_OFF);
       if ( m_iNeverId ) {
           m_strTemplateTitle.LoadString(m_iNeverId);
       }
    } else {

        strNew.Format(TEXT("%d"),lVal);
    }
    m_nSave = lVal;

   SetDlgItemText(IDC_NEW,strNew);
   SetDlgItemText(IDC_TEMPLATE_TITLE,m_strTemplateTitle);
   SetModified(TRUE);
}

LONG CAttrNumber::CurrentEditValue()
{
   UINT uiVal = 0;
   LONG lVal = 0;
   BOOL bTrans = FALSE;

   int length = m_strBase.GetLength(); //Raid 471645, Yang Gao
   while( lVal < length && m_strBase.GetAt(lVal) == L'0' )
   {
      lVal++;
   }
   if( lVal > 0 && lVal < length )
   {
      m_strBase.Delete(0, lVal);
      SetDlgItemText(IDC_NEW, m_strBase);
   }

   uiVal = GetDlgItemInt(IDC_NEW,&bTrans,FALSE);
   lVal = uiVal;
   if (!bTrans ) {
      // if ( 0 == lVal && !bTrans ) {
      // errored, overflow, or nonnumeric

      CString str;
      if(m_cMinutes & DW_VALUE_FOREVER){
         str.LoadString(IDS_FOREVER);
         if(str == m_strBase){
            return SCE_FOREVER_VALUE;
         }
      }

      lVal = _ttol((LPCTSTR)m_strBase);
      if ( lVal == 0 ) {
         //
         // nonnumeric
         //
         lVal = (LONG) m_nSave;
         return lVal;
      }
   }

   if ( m_iAccRate > 1 && lVal > 0 ) {
      //
      // for log max size, make it multiples of m_iAccRate
      //
      int nCount = lVal % m_iAccRate;
      if ( nCount > 0 ) {
         lVal = ((LONG)(lVal/m_iAccRate))*m_iAccRate;
      }
   }
   if ( lVal > m_nHigh ) {
      // if it is overflow, go back to low
      if ( m_cMinutes & DW_VALUE_FOREVER ) {
         lVal = SCE_FOREVER_VALUE;
      } else if (m_cMinutes & DW_VALUE_OFF) {
         lVal = SCE_KERBEROS_OFF_VALUE;
      } else {
         // Leave alone and let the OnKillActive catch it
      }
   }

   if ( (lVal < m_nLow) &&
        (lVal != SCE_KERBEROS_OFF_VALUE) &&
        (lVal != SCE_FOREVER_VALUE) ) {
      // if it is underflow, go back to high
      if (m_cMinutes & DW_VALUE_OFF) {
         lVal = SCE_KERBEROS_OFF_VALUE;
      } else if ( m_cMinutes & DW_VALUE_FOREVER) {
         lVal = SCE_FOREVER_VALUE;
      } else {
         // Leave alone and let the OnKillActive catch it
      }
   }

   if ( 0 == lVal && (m_cMinutes & DW_VALUE_NOZERO) ) {
      // zero is not allowed
      if ( m_nLow > 0 ) {
         lVal = m_nLow;
      } else {
         lVal = 1;
      }
   }

   return lVal;
}


void CAttrNumber::OnConfigure()
{
   CWnd *cwnd;

   CAttribute::OnConfigure();

   //
   // Enable disable OK button depending on the state of the other controls.
   //
   cwnd = GetDlgItem(IDOK);
   if(cwnd){
       if(!m_bConfigure){
          cwnd->EnableWindow(TRUE);
       } else {
          OnUpdateNew();
       }
   }
}

BOOL CAttrNumber::OnInitDialog()
{
   CAttribute::OnInitDialog();

   UpdateData(TRUE);
/*
   if (m_bMinutes) {
      m_SpinValue.SetRange(-1,UD_MAXVAL-1);
   } else {
      m_SpinValue.SetRange(0,UD_MAXVAL);
   }
*/

   AddUserControl(IDC_NEW);
   AddUserControl(IDC_SPIN);

   OnConfigure();

   return TRUE;  // return TRUE unless you set the focus to a control
               // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CAttrNumber::OnApply()
{
   if ( !m_bReadOnly )
   {
      BOOL bUpdateAll = FALSE;
      DWORD dw = 0;
      CString strForever,strOff;
      int status = 0;

      UpdateData(TRUE);
   
      if (!m_bConfigure)
         dw = SCE_NO_VALUE;
      else
         dw = CurrentEditValue();
   

      bUpdateAll = FALSE;


      CEditTemplate *pet = m_pSnapin->GetTemplate(GT_COMPUTER_TEMPLATE,AREA_SECURITY_POLICY);

      //
      // Check the numbers dependencies if a dependency fails then the dialog
      // will return ERROR_MORE_DATA and we can display more information for the user
      // to see.
      //
      if(DDWarn.CheckDependencies( dw ) == ERROR_MORE_DATA )
      {
         //
         // If the user presses cancel then we won't let them set this item's information
         // until they have set the configurion for the other items.
         //
         CThemeContextActivator activator;
         if( DDWarn.DoModal() != IDOK)
            return FALSE;

         //
         // The user pressed Auto set so we can set the other items.  They are automatically set
         // to the correct values.
         //
         for(int i = 0; i < DDWarn.GetFailedCount(); i++)
         {
            PDEPENDENCYFAILED pItem = DDWarn.GetFailedInfo(i);
            if(pItem && pItem->pResult )
            {
               pItem->pResult->SetBase( pItem->dwSuggested );
               status = m_pSnapin->SetAnalysisInfo(
                                       pItem->pResult->GetID(),
                                       pItem->dwSuggested,
                                       pItem->pResult);
               pItem->pResult->SetStatus( status );

               pItem->pResult->Update(m_pSnapin, FALSE);
            }
         }
      }

      //
      // Update the items security profile.
      // and redraw.
      //
      m_pData->SetBase((LONG_PTR)ULongToPtr(dw));
      status = m_pSnapin->SetAnalysisInfo(m_pData->GetID(),(LONG_PTR)ULongToPtr(dw), m_pData);
      m_pData->SetStatus(status);
      m_pData->Update(m_pSnapin, FALSE);
   }

   return CAttribute::OnApply();
}

void CAttrNumber::Initialize(CResult * pResult)
{
    LONG_PTR dw=0;

    CAttribute::Initialize(pResult);

    DDWarn.InitializeDependencies(m_pSnapin,pResult);

    m_strUnits = pResult->GetUnits();

    m_cMinutes = DW_VALUE_NOZERO;
    m_nLow = 0;
    m_nHigh = 999;
    m_nSave = 0;
    m_iNeverId = 0;
    m_iAccRate = 1;
    m_iStaticId = 0;

    CEditTemplate *pTemplate = pResult->GetBaseProfile();
     switch (pResult->GetID()) {
     // below no zero value
     case IDS_LOCK_DURATION:
         m_cMinutes = DW_VALUE_FOREVER | DW_VALUE_NOZERO;
         m_nHigh = 99999;
         m_iStaticId = IDS_DURATION;
         m_iNeverId = IDS_LOCKOUT_FOREVER;
         m_pRDescription = g_rdLockoutAccount;
         break;
     case IDS_MAX_PAS_AGE:
         m_cMinutes = DW_VALUE_FOREVER | DW_VALUE_NOZERO;
         m_iStaticId = IDS_PASSWORD_EXPIRE;
         m_iNeverId = IDS_PASSWORD_FOREVER;
         break;
         // below zero value means differently
     case IDS_LOCK_COUNT:
         m_cMinutes = DW_VALUE_NEVER;
         m_iNeverId = IDS_NO_LOCKOUT;
         m_iStaticId = IDS_LOCKOUT_AFTER;
         break;
     case IDS_MIN_PAS_AGE:
         m_cMinutes = DW_VALUE_NEVER;
         m_iNeverId = IDS_CHANGE_IMMEDIATELY;
         m_iStaticId = IDS_PASSWORD_CHANGE;
         m_nHigh = 998;
         m_pRDescription = g_rdMinPassword;
         break;
     case IDS_MIN_PAS_LEN:
         m_cMinutes = DW_VALUE_NEVER;
         m_nHigh = 14;
         m_iNeverId = IDS_PERMIT_BLANK;
         m_iStaticId = IDS_PASSWORD_LEN;
         m_pRDescription = g_rdPasswordLen;
         break;
     case IDS_PAS_UNIQUENESS:
         m_cMinutes = DW_VALUE_NEVER;
         m_nHigh = 24;
         m_iNeverId = IDS_NO_HISTORY;
         m_iStaticId = IDS_PASSWORD_REMEMBER;
         break;
         // below there is no zero values
     case IDS_LOCK_RESET_COUNT:
         m_nLow = 1;
         m_nHigh = 99999;
         m_iStaticId = IDS_LOCK_RESET_COUNT;
         break;
     case IDS_SYS_LOG_MAX:
     case IDS_SEC_LOG_MAX:
     case IDS_APP_LOG_MAX:
         m_nLow = 64;
         m_nHigh = 4194240;
         m_iAccRate = 64;
         // no static text
         break;
     case IDS_SYS_LOG_DAYS:
     case IDS_SEC_LOG_DAYS:
     case IDS_APP_LOG_DAYS:
         m_nHigh = 365;
         m_nLow = 1;
         m_iStaticId = IDS_OVERWRITE_EVENT;
         break;
    case IDS_KERBEROS_MAX_AGE:
       m_cMinutes = DW_VALUE_FOREVER | DW_VALUE_NOZERO;
       m_nHigh = 99999;
       m_iStaticId = IDS_TICKET_EXPIRE;
       m_iNeverId = IDS_TICKET_FOREVER;
       break;
    case IDS_KERBEROS_RENEWAL:
       m_cMinutes = DW_VALUE_FOREVER | DW_VALUE_NOZERO; // | DW_VALUE_OFF;
       m_nHigh = 99999;
       m_iStaticId = IDS_TICKET_RENEWAL_EXPIRE;
       m_iNeverId = IDS_TICKET_RENEWAL_FOREVER;
       break;
     case IDS_KERBEROS_MAX_SERVICE:
        m_nLow = 10;
        m_cMinutes = DW_VALUE_FOREVER | DW_VALUE_NOZERO;
        m_iStaticId = IDS_TICKET_EXPIRE;
        m_iNeverId = IDS_TICKET_FOREVER;
        m_nHigh = 99999;
        break;
     case IDS_KERBEROS_MAX_CLOCK:
        m_cMinutes = DW_VALUE_FOREVER;
        m_nHigh = 99999;
        m_iStaticId = IDS_MAX_TOLERANCE;
        m_iNeverId = IDS_NO_MAX_TOLERANCE;
        break;
     }

     if ((m_cMinutes & DW_VALUE_NOZERO) && (0 == m_nLow)) {
        m_nLow = 1;
     }

    m_strTemplateTitle = _T("");
    m_strLastInspectTitle = _T("");

    m_strBase.Empty();
    m_strSetting.Empty();

    dw = pResult->GetBase();
    if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) == dw) 
    {
       m_bConfigure = FALSE;
    } 
    else 
    {
       m_bConfigure = TRUE;
       SetInitialValue(PtrToUlong((PVOID)dw));
    }

    pResult->GetDisplayName( NULL, m_strSetting, 2 );
    dw = pResult->GetSetting();
    if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) != dw) {
       if ((LONG_PTR)ULongToPtr(SCE_FOREVER_VALUE) == dw) {
          if ( (m_cMinutes & DW_VALUE_FOREVER) &&
               m_iNeverId > 0 ) {
              m_strLastInspectTitle.LoadString(m_iNeverId);
          }
       } else {
         if ( 0 == dw && (m_cMinutes & DW_VALUE_NEVER) &&
              m_iNeverId > 0 ) {
             // zero means different values
             m_strLastInspectTitle.LoadString(m_iNeverId);
         } else if ( m_iStaticId > 0 ) {
             m_strLastInspectTitle.LoadString(m_iStaticId);
         }
       }
    }

}

void CAttrNumber::SetInitialValue(DWORD_PTR dw) 
{
   //
   // Don't overwrite an already set value.
   //
   if (!m_strBase.IsEmpty()) 
   {
      return;
   }

   if (SCE_FOREVER_VALUE == dw) {
      m_strBase.LoadString(IDS_FOREVER);
      if ( (m_cMinutes & DW_VALUE_FOREVER) &&
           m_iNeverId > 0 ) {
         m_strTemplateTitle.LoadString(m_iNeverId);
      }
      m_nSave = SCE_FOREVER_VALUE;
   } else if (SCE_KERBEROS_OFF_VALUE == dw) {
      m_strBase.LoadString(IDS_OFF);
      if ( (m_cMinutes & DW_VALUE_OFF) &&
           m_iNeverId > 0 ) {
         m_strTemplateTitle.LoadString(m_iNeverId);
      }
      m_nSave = SCE_KERBEROS_OFF_VALUE;
   } 
   else 
   {
      m_nSave = dw;
      if ( 0 == dw && (m_cMinutes & DW_VALUE_NEVER) &&
           m_iNeverId > 0 ) {
         // zero means different values
         m_strTemplateTitle.LoadString(m_iNeverId);
      } else if ( m_iStaticId > 0 ) {
         m_strTemplateTitle.LoadString(m_iStaticId);
      }
      m_strBase.Format(TEXT("%d"),dw);
   }
}

void CAttrNumber::OnUpdateNew()
{
   DWORD dwRes = 0;
   UpdateData(TRUE);
   CString sNum;
   CEdit *pEdit = (CEdit *)GetDlgItem(IDC_NEW);
   CWnd  *pOK  = GetDlgItem(IDOK);

   DWORD dwValue = _ttoi(m_strBase);

   //
   // Don't do anything if the string is equal to predefined strings.
   //
   sNum.LoadString(IDS_FOREVER);

   if (m_strBase.IsEmpty()) {
      if (pOK) {
         pOK->EnableWindow(FALSE);
      }

   } else if (m_strBase == sNum) {
      if (pOK) {
         pOK->EnableWindow(TRUE);
      }

   } else {
      if ((long)dwValue < m_nLow) {
         //
         // Disable the OK button.
         //
         if ( pOK ) {
            pOK->EnableWindow(FALSE);
         }

         if (pEdit) {
            //
            // We will only force a select if edit text length >=
            //  minimum text length
            //
            sNum.Format(TEXT("%d"), m_nLow);
            dwValue = m_nLow;
            if (sNum.GetLength() < m_strBase.GetLength()) {
               pEdit->SetSel(0, -1);
            }
         }
      } else if ( (long)dwValue > m_nHigh ) {
         if (pOK) {
            pOK->EnableWindow(TRUE);
         }
         if (pEdit) {
            if (m_cMinutes & DW_VALUE_FOREVER) {
               sNum.LoadString(IDS_FOREVER);
               dwValue = 0;
            } else {
               sNum.Format(TEXT("%d"), m_nHigh);
               dwValue = m_nHigh;
            }
            m_strBase = sNum;
            UpdateData(FALSE);
            pEdit->SetSel(0, -1);
         }
      } else {

         //
         // Enable the OK button.
         //
         if (pOK) {
            pOK->EnableWindow(TRUE);
         }
      }
   }

   //
   // Load the description for this string.
   //
   if ((dwValue <= 0) && (m_iNeverId != 0)) {
      m_strTemplateTitle.LoadString(m_iNeverId);
   } else {
      m_strTemplateTitle.LoadString(m_iStaticId);
   }
   GetDlgItem(IDC_TEMPLATE_TITLE)->SetWindowText(m_strTemplateTitle);

   SetModified(TRUE); //Raid #404145
}

BOOL CAttrNumber::OnKillActive() 
{
   UINT uiVal = 0;
   LONG lVal = 0;
   BOOL bTrans = FALSE;
   CString strRange;
   int lMin = m_nLow;

   UpdateData(TRUE);

   if (!m_bConfigure) //Raid 472956, Yang Gao
   {
      return TRUE;
   }

   if (m_cMinutes & DW_VALUE_NOZERO &&
       !(m_cMinutes & DW_VALUE_FOREVER) &&
       lMin == 0) {
      lMin = 1;
   }

   CString strFormat;
   strFormat.LoadString(IDS_RANGE);
   strRange.Format(strFormat,lMin,m_nHigh);

   uiVal = GetDlgItemInt(IDC_NEW,&bTrans,TRUE);
   lVal = uiVal;
   if ( !bTrans ) {
      CString str;
      if (m_cMinutes & DW_VALUE_FOREVER) {
         str.LoadString(IDS_FOREVER);
         if (str == m_strBase) {
            return TRUE;;
         }
      }
      lVal = _ttol((LPCTSTR)m_strBase);
      if ( lVal == 0 ) 
      {
         // nonnumeric
         lVal = (LONG) m_nSave;
         m_strError = strRange;
         UpdateData(FALSE);
         return FALSE;
      }
   }

   if ( m_iAccRate > 1 && lVal > 0 ) {
      // for log max size, make it multiples of m_iAccRate
      int nCount = lVal % m_iAccRate;
      if ( nCount > 0 ) {
         lVal = ((LONG)(lVal/m_iAccRate))*m_iAccRate;
      }
   }
   if ( lVal > m_nHigh ) {
      m_strError = strRange;
      UpdateData(FALSE);
      return FALSE;
   }

   if ( (lVal < m_nLow) &&
        (lVal != SCE_KERBEROS_OFF_VALUE) &&
        (lVal != SCE_FOREVER_VALUE) ) {
      // if it is underflow, go back to high
      if (m_cMinutes & DW_VALUE_OFF) {
         lVal = SCE_KERBEROS_OFF_VALUE;
      } else if ( m_cMinutes & DW_VALUE_FOREVER) {
         lVal = SCE_FOREVER_VALUE;
      } else {
         // Leave alone and let the OnKillActive catch it
      }
   }

   if ( (lVal < m_nLow) &&
        (lVal != SCE_KERBEROS_OFF_VALUE) &&
        (lVal != SCE_FOREVER_VALUE) ) {
      // if it is underflow, go back to high
      m_strError = strRange;
      UpdateData(FALSE);
      return FALSE;
   }

   if ( 0 == lVal && (m_cMinutes & DW_VALUE_NOZERO) ) {
      // zero is not allowed
      m_strError = strRange;
      UpdateData(FALSE);
      return FALSE;
   }

   return CAttribute::OnKillActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\anumber.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       ANumber.h
//
//  Contents:   Definition of CAttrNumber
//
//----------------------------------------------------------------------------
#if !defined(AFX_ATTRNUMBER_H__76BA1B2F_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_)
#define AFX_ATTRNUMBER_H__76BA1B2F_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "resource.h"
#include "ddwarn.h"

/////////////////////////////////////////////////////////////////////////////
// CAttrNumber dialog
#define RDIF_MIN            0x0001
#define RDIF_MAX            0x0002
#define RDIF_END            0x0004
#define RDIF_MAXINFINATE    0x0008

typedef struct _tag_RANGEDESCRIPTION
{
    int iMin;
    int iMax;
    WORD uResource;
    WORD uMask;
} RANGEDESCRIPTION, *PRANGEDESCRIPTION;


DWORD
GetRangeDescription(    // Sets [pstrRet] to the string corisponding to [uType] and [i]
    UINT uType,
    int i,
    CString *pstrRet
    );

UINT
GetRangeDescription(    // Returns the string resource described by [pDesc] and [i]
    RANGEDESCRIPTION *pDesc,
    int i
    );


extern RANGEDESCRIPTION g_rdMinPassword[];
extern RANGEDESCRIPTION g_rdMaxPassword[];
extern RANGEDESCRIPTION g_rdLockoutAccount[];
extern RANGEDESCRIPTION g_rdPasswordLen[];

class CAttrNumber : public CAttribute
{
// Construction
public:
    void Initialize(CResult * pResult);
    virtual void SetInitialValue(DWORD_PTR dw);
    CAttrNumber(UINT nTemplateID);   // standard constructor
	

// Dialog Data
    //{{AFX_DATA(CAttrNumber)
    enum { IDD = IDD_ATTR_NUMBER };
    CSpinButtonCtrl m_SpinValue;
    CString m_strUnits;
    CString m_strSetting;
    CString m_strBase;
    CString m_strTemplateTitle;
    CString m_strLastInspectTitle;
    CString m_strError;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAttrNumber)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAttrNumber)
    virtual BOOL OnInitDialog();
    afx_msg void OnDeltaposSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillFocusNew();
    virtual BOOL OnApply();
    afx_msg void OnConfigure();
    afx_msg void OnUpdateNew();
    virtual BOOL OnKillActive();
   //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

protected:
    int m_cMinutes;
    long m_nLow;
    long m_nHigh;
    DWORD_PTR m_nSave;
    int m_iNeverId;
    int m_iAccRate;
    int m_iStaticId;
    RANGEDESCRIPTION *m_pRDescription;
    CDlgDependencyWarn DDWarn;
public:
    LONG CurrentEditValue();
    void SetValueToEdit(LONG lVal);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ATTRNUMBER_H__76BA1B2F_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\aobject.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       AObject.h
//
//  Contents:   Definition of CAttrObject
//
//----------------------------------------------------------------------------
#if !defined(AFX_AOBJECT_H__D9D88A12_4AF9_11D1_AB57_00C04FB6C6FA__INCLUDED_)
#define AFX_AOBJECT_H__D9D88A12_4AF9_11D1_AB57_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CAttrObject dialog

class CAttrObject : public CAttribute
{
// Construction
public:
    void Initialize(CResult *pData);
    void Initialize(CFolder *pScopeData,CComponentDataImpl *pCDI);
    virtual void SetInitialValue(DWORD_PTR dw) { dw; };

    CAttrObject();   // standard constructor
    virtual ~CAttrObject();

// Dialog Data
    //{{AFX_DATA(CAttrObject)
        enum { IDD = IDD_ATTR_OBJECT };
    CString m_strLastInspect;
        int             m_radConfigPrevent;
        int             m_radInheritOverwrite;
        //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAttrObject)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    PSCE_OBJECT_SECURITY posTemplate;
    PSCE_OBJECT_SECURITY posInspect;

    // Generated message map functions
    //{{AFX_MSG(CAttrObject)
    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual BOOL OnQueryCancel();
    afx_msg void OnTemplateSecurity();
    afx_msg void OnInspectedSecurity();
    afx_msg void OnConfigure();
    virtual BOOL OnInitDialog();
        afx_msg void OnConfig();
        afx_msg void OnPrevent();
        afx_msg void OnOverwrite();
        afx_msg void OnInherit();
        //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    PSECURITY_DESCRIPTOR m_pNewSD;
    SECURITY_INFORMATION m_NewSeInfo;
    PSECURITY_DESCRIPTOR m_pAnalSD;
    SECURITY_INFORMATION m_AnalInfo;
    PFNDSCREATEISECINFO m_pfnCreateDsPage;
    LPDSSECINFO m_pSI;

    CString m_strName;
    CString m_strPath;
    HANDLE m_pHandle;
    DWORD m_dwType;
    PSCE_OBJECT_LIST m_pObject;
    CComponentDataImpl *m_pCDI;
    HWND m_hwndInspect;
    HWND m_hwndTemplate;
    BOOL m_bNotAnalyzed;

    CFolder *m_pFolder;
    void Initialize2();

    CModelessSceEditor* m_pSceInspect;
    CModelessSceEditor* m_pSceTemplate;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AOBJECT_H__D9D88A12_4AF9_11D1_AB57_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\applcnfg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       applcnfg.cpp
//
//  Contents:   implementation of CApplyConfiguration
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "wrapper.h"
#include "snapmgr.h"
#include "applcnfg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CApplyConfiguration dialog


CApplyConfiguration::CApplyConfiguration()
: CPerformAnalysis(0, IDD)
{
   //{{AFX_DATA_INIT(CApplyConfiguration)
      // NOTE: the ClassWizard will add member initialization here
   //}}AFX_DATA_INIT
}


void CApplyConfiguration::DoDataExchange(CDataExchange* pDX)
{
   CPerformAnalysis::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CApplyConfiguration)
      // NOTE: the ClassWizard will add DDX and DDV calls here
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CApplyConfiguration, CPerformAnalysis)
   //{{AFX_MSG_MAP(CApplyConfiguration)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CApplyConfiguration message handlers

//+--------------------------------------------------------------------------
//
//  Method:     DoIt
//
//  Synopsis:   Actually configures the system (called from OnOK in the parent
//               class)
//
//---------------------------------------------------------------------------
DWORD CApplyConfiguration::DoIt() {
   //
   // Store the log file we're using for next time
   //
   LPTSTR szLogFile = m_strLogFile.GetBuffer(0);
   m_pComponentData ->GetWorkingDir(GWD_CONFIGURE_LOG,&szLogFile,TRUE,TRUE);
   m_strLogFile.ReleaseBuffer();
   //
   // We don't wan't to pass a pointer to an empty string.
   //
   return ApplyTemplate(
                NULL,
                m_strDataBase.IsEmpty() ? NULL : (LPCTSTR)m_strDataBase,
                m_strLogFile.IsEmpty() ? NULL : (LPCTSTR)m_strLogFile,
                AREA_ALL
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\aobject.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       AObject.cpp
//
//  Contents:   Implementation of CAttrObject
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "resource.h"
#include "snapmgr.h"
#include "util.h"
#include <accctrl.h>
#include "servperm.h"
#include "AObject.h"

#include <aclapi.h>
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAttrObject dialog


CAttrObject::CAttrObject()
: CAttribute(IDD), 
m_pSceInspect(NULL), 
m_pSceTemplate(NULL), 
posInspect(NULL), 
posTemplate(NULL),
  m_bNotAnalyzed(FALSE), m_pfnCreateDsPage(NULL), m_pSI(NULL), m_pNewSD(NULL), m_pAnalSD(NULL),
  m_pCDI(NULL), m_AnalInfo(0), m_NewSeInfo(0), m_hwndTemplate(NULL), m_hwndInspect(NULL), m_pFolder(NULL)

{
   //{{AFX_DATA_INIT(CAttrObject)
   m_strLastInspect = _T("");
        m_radConfigPrevent = 0;
        m_radInheritOverwrite = 0;
        //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR)a198HelpIDs;
   m_uTemplateResID = IDD;
}

CAttrObject::~CAttrObject()
{
    if (::IsWindow(m_hwndInspect))
    {
        m_pSceInspect->Destroy(m_hwndInspect);
        m_hwndInspect = NULL;
    }
    delete m_pSceInspect;
    m_pSceInspect = NULL;

    if (::IsWindow(m_hwndTemplate))
    {
        m_pSceTemplate->Destroy(m_hwndTemplate);
        m_hwndTemplate = NULL;
    }
    delete m_pSceTemplate;
    m_pSceTemplate = NULL;
}

void CAttrObject::DoDataExchange(CDataExchange* pDX)
{
   CAttribute::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CAttrObject)
   DDX_Text(pDX, IDC_INSPECTED, m_strLastInspect);
        DDX_Radio(pDX, IDC_CONFIG, m_radConfigPrevent);
        DDX_Radio(pDX, IDC_INHERIT, m_radInheritOverwrite);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttrObject, CAttribute)
//{{AFX_MSG_MAP(CAttrObject)
ON_BN_CLICKED(IDC_TEMPLATE_SECURITY, OnTemplateSecurity)
ON_BN_CLICKED(IDC_INSPECTED_SECURITY, OnInspectedSecurity)
ON_BN_CLICKED(IDC_CONFIGURE, OnConfigure)
    ON_BN_CLICKED(IDC_CONFIG, OnConfig)
    ON_BN_CLICKED(IDC_PREVENT, OnPrevent)
    ON_BN_CLICKED(IDC_OVERWRITE, OnOverwrite)
    ON_BN_CLICKED(IDC_INHERIT, OnInherit)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttrObject message handlers

void CAttrObject::OnConfigure()
{
   CAttribute::OnConfigure();
   if ( m_bConfigure ) {
      //
      // Ensure that the security descriptor is set.
      //
      if( !m_pNewSD ){
        OnTemplateSecurity();
      }
      UpdateData(FALSE);
   }

   BOOL bEnable = TRUE;
   if(m_pFolder){
      DWORD dwStatus = 0;
      m_pFolder->GetObjectInfo( &dwStatus, NULL );

      switch( dwStatus ){
      case SCE_STATUS_NOT_ANALYZED:
      case SCE_STATUS_ERROR_NOT_AVAILABLE:
      case SCE_STATUS_NOT_CONFIGURED:
         bEnable = FALSE;
         break;
      default:
         bEnable = m_pAnalSD || m_AnalInfo;
      }
   } else {
      bEnable = m_pAnalSD || m_AnalInfo;
   }

   if (m_bConfigure) {
      if (0 == m_radConfigPrevent) {
         OnConfig();
      } else {
         OnPrevent();
      }
   }
}

void CAttrObject::Initialize(CFolder *pFolder,
                             CComponentDataImpl *pCDI) {

   CAttribute::Initialize(NULL);
   m_strName = pFolder->GetName();
   m_strPath = pFolder->GetName();
   m_dwType  = pFolder->GetType();
   switch (pFolder->GetType()) {
      case REG_OBJECTS:
         m_dwType = ITEM_REGSD;
         break;
      case FILE_OBJECTS:
         m_dwType = ITEM_FILESD;
         break;
      default:
         m_dwType = 0;
         break;
   }
   m_pObject = (PSCE_OBJECT_LIST)pFolder->GetData();
   m_pHandle = pCDI->GetSadHandle();
   m_pCDI = pCDI;

   m_pFolder = pFolder;
   Initialize2();
}

void CAttrObject::Initialize(CResult *pResult) {
   CAttribute::Initialize(pResult);

   m_strName = pResult->GetAttr();
   m_strPath = pResult->GetUnits();
   m_pHandle = (HANDLE)pResult->GetID();
   m_dwType  = pResult->GetType();
   m_pObject = (PSCE_OBJECT_LIST)pResult->GetBaseProfile();
   m_pCDI = NULL;

   Initialize2();
}

void CAttrObject::Initialize2()
{
   LPTSTR szPath;
   SCESTATUS status;

   AREA_INFORMATION Area;


   switch (m_dwType) {
      case ITEM_REGSD:
         Area = AREA_REGISTRY_SECURITY;
         break;
      case ITEM_FILESD:
         Area = AREA_FILE_SECURITY;
         break;
      default:
         ASSERT(FALSE);
         return;
   }

   m_pNewSD = NULL;
   m_NewSeInfo = 0;
   if ( m_pSI ) {
      m_pSI->Release();
      m_pSI = NULL;
   }
   m_pfnCreateDsPage=NULL;

   szPath = m_strPath.GetBuffer(1);

   status = SceGetObjectSecurity(m_pHandle,
                                 SCE_ENGINE_SMP,
                                 Area,
                                 szPath,
                                 &posTemplate);
   m_strPath.ReleaseBuffer();

   if (SCESTATUS_SUCCESS == status && posTemplate ) {
      switch (posTemplate-> Status) {
         case SCE_STATUS_IGNORE:
            m_radConfigPrevent = 1;
            m_radInheritOverwrite = 0;
            break;
         case SCE_STATUS_OVERWRITE:
            m_radConfigPrevent = 0;
            m_radInheritOverwrite = 1;
            break;
         case SCE_STATUS_CHECK:
            m_radConfigPrevent = 0;
            m_radInheritOverwrite = 0;
            break;
         default:
         case SCE_STATUS_NO_AUTO_INHERIT:
            m_radConfigPrevent = 1;
            m_radInheritOverwrite = 0;
            break;
      }

      if ( posTemplate->pSecurityDescriptor ) {

         MyMakeSelfRelativeSD(posTemplate->pSecurityDescriptor,
                              &m_pNewSD);
      }
      m_NewSeInfo = posTemplate->SeInfo;

   } else {
      m_bConfigure = FALSE;
   }

   szPath = m_strPath.GetBuffer(1);
   status = SceGetObjectSecurity(m_pHandle,
                                 SCE_ENGINE_SAP,
                                 Area,
                                 szPath,
                                 &posInspect);
   m_strPath.ReleaseBuffer();
   
   //
   // Display the same thing we displayed on the result pane
   //
   if (m_pFolder) {
      m_pFolder->GetDisplayName( m_strLastInspect, 1 );
   } else if (m_pData) {
      m_pData->GetDisplayName(0, m_strLastInspect, 1);
   } else {
      ASSERT(0);
      m_strLastInspect.LoadString(IDS_ERROR_VALUE);
   }

   //
   // if the item is good, there will be no SAP record, but a template record exists.
   //
   if ( posInspect ) {
      m_pAnalSD = posInspect->pSecurityDescriptor;
      m_AnalInfo = posInspect->SeInfo;
      //
      // We don't need to display children not configured in the dialog box.
      // Instead display the actual status of the item.
      //
      if( posInspect->Status == SCE_STATUS_CHILDREN_CONFIGURED) {
         m_strLastInspect.LoadString(IDS_NOT_CONFIGURED);
      }
      switch(posInspect->Status &
             ~(SCE_STATUS_PERMISSION_MISMATCH | SCE_STATUS_AUDIT_MISMATCH)) {
         case SCE_STATUS_CHILDREN_CONFIGURED:
         case SCE_STATUS_NOT_CONFIGURED:
         case SCE_STATUS_ERROR_NOT_AVAILABLE:
         case SCE_STATUS_NEW_SERVICE:
         case SCE_STATUS_NOT_ANALYZED:
            m_bNotAnalyzed = TRUE;
            break;
      }
   } else if ( posTemplate ) {
      m_pAnalSD = posTemplate->pSecurityDescriptor;
      m_AnalInfo = posTemplate->SeInfo;
   } else {
      m_bNotAnalyzed = TRUE;
   }

}

void CAttrObject::OnInspectedSecurity()
{
   SE_OBJECT_TYPE SeType;

   //
   // If we already have the inspected security window up then
   // don't bring up a second.
   //
   if (IsWindow(m_hwndInspect)) {
      ::BringWindowToTop(m_hwndInspect);
      return;
   }

   switch (m_dwType) {
      case ITEM_REGSD:
         SeType = SE_REGISTRY_KEY;
         break;
      case ITEM_FILESD:
         SeType = SE_FILE_OBJECT;
         break;
      default:
         ASSERT(FALSE);
         return;
   }

   if ( m_pAnalSD || m_AnalInfo ) {

      INT_PTR nRet;

      if ( SE_DS_OBJECT == SeType ) {

         if ( !m_pfnCreateDsPage ) {
            if (!g_hDsSecDll)
               g_hDsSecDll = LoadLibrary(TEXT("dssec.dll"));

            if ( g_hDsSecDll) {
               m_pfnCreateDsPage = (PFNDSCREATEISECINFO)GetProcAddress(g_hDsSecDll,
                                                                      "DSCreateISecurityInfoObject");
            }
         }

         if ( m_pfnCreateDsPage ) {
            nRet= MyCreateDsSecurityPage(&m_pSI,
                                         m_pfnCreateDsPage,
                                         &m_pAnalSD,
                                         &m_AnalInfo,
                                         (LPCTSTR)(m_strName),
                                         ANALYSIS_SECURITY_PAGE_READ_ONLY,
                                         GetSafeHwnd());
         } else
            nRet = -1;

      } else {

         BOOL bContainer = TRUE; //Raid #585312, yanggao
         if ( SE_FILE_OBJECT == SeType )
         {
            if ( m_pObject )
            {
               bContainer = m_pObject->IsContainer;
            }
            else
            {
               if( NULL == m_pFolder )
               {
                  bContainer = FALSE;
               }
            }
         }

         if (NULL == m_pSceInspect)
         {
             m_pSceInspect = new CModelessSceEditor(bContainer ? true : false,
                                           ANALYSIS_SECURITY_PAGE_READ_ONLY,
                                           GetSafeHwnd(),
                                           SeType,
                                           m_strName);
         }

         if (NULL != m_pSceInspect)
            m_pSceInspect->Create(&m_pAnalSD, &m_AnalInfo, &m_hwndInspect);
      }
/*
      BUG 147087 - don't display message, since this may have been canceled
      if (NULL == m_hwndInspect) {
         CString str;
         str.LoadString(IDS_CANT_SHOW_SECURITY);
         AfxMessageBox(str);
      }
*/
   }
}

void CAttrObject::OnTemplateSecurity()
{
   SE_OBJECT_TYPE SeType;

   //
   // If we already have the inspected security window up then
   // don't bring up a second.
   //
   if (IsWindow(m_hwndTemplate)) {
      ::BringWindowToTop(m_hwndTemplate);
      return;
   }

   switch (m_dwType) {
      case ITEM_REGSD:
         SeType = SE_REGISTRY_KEY;
         break;
      case ITEM_FILESD:
         SeType = SE_FILE_OBJECT;
         break;
      default:
         ASSERT(FALSE);
         return;
   }

   INT_PTR nRet;

   nRet = -1;

   if ( SE_DS_OBJECT == SeType ) {

      if ( !m_pfnCreateDsPage ) {
         if (!g_hDsSecDll)
            g_hDsSecDll = LoadLibrary(TEXT("dssec.dll"));

         if ( g_hDsSecDll) {
            m_pfnCreateDsPage = (PFNDSCREATEISECINFO)GetProcAddress(g_hDsSecDll,
                                                                   "DSCreateISecurityInfoObject");
         }
      }

      if ( m_pfnCreateDsPage ) {
         nRet= MyCreateDsSecurityPage(&m_pSI,
                                      m_pfnCreateDsPage,
                                      &m_pNewSD,
                                      &m_NewSeInfo,
                                      (LPCTSTR)(m_strName),
                                      CONFIG_SECURITY_PAGE,
                                      GetSafeHwnd());
      } else
         nRet = -1;

   } else {

      BOOL bContainer = TRUE;

        if ( !m_pNewSD ) {

            //
            // if SD is NULL, then inherit is set.
            //
            DWORD SDSize;

            if ( SE_FILE_OBJECT == SeType ) {
               GetDefaultFileSecurity(&m_pNewSD,&m_NewSeInfo);
            } else {
               GetDefaultRegKeySecurity(&m_pNewSD,&m_NewSeInfo);
            }
        }

        // use m_pSceTemplate to create a modeless
        if (NULL == m_pSceTemplate)
        {
            m_pSceTemplate = new CModelessSceEditor(TRUE,
                                           CONFIG_SECURITY_PAGE,
                                           GetSafeHwnd(),
                                           SeType,
                                           m_strName);
        }

        if (NULL != m_pSceTemplate)
            m_pSceTemplate->Create(&m_pNewSD, &m_NewSeInfo, &m_hwndTemplate);
   }

   if (NULL == m_hwndTemplate ) {
/*
      BUG 147098 - don't display message, since this may have been canceled
      CString str;
      str.LoadString(IDS_CANT_ASSIGN_SECURITY);
      AfxMessageBox(str);
*/
   } else {
      SetModified(TRUE);
   }

}

BOOL CAttrObject::OnInitDialog()
{
   CAttribute::OnInitDialog();


   GetDlgItem(IDC_INSPECTED_SECURITY)->EnableWindow(!m_bNotAnalyzed);

   UpdateData(FALSE);
   AddUserControl(IDC_OVERWRITE);
   AddUserControl(IDC_INHERIT);
   AddUserControl(IDC_CONFIG);
   AddUserControl(IDC_PREVENT);
   AddUserControl(IDC_TEMPLATE_SECURITY);
  // AddUserControl(IDC_INSPECTED_SECURITY);

   OnConfigure();

   if (ITEM_REGSD == m_dwType) {
      CString str;
      str.LoadString(IDS_REGISTRY_CONFIGURE);
      SetDlgItemText(IDC_CONFIG,str);
      str.LoadString(IDS_REGISTRY_APPLY);
      SetDlgItemText(IDC_OVERWRITE,str);
      str.LoadString(IDS_REGISTRY_INHERIT);
      SetDlgItemText(IDC_INHERIT,str);
      str.LoadString(IDS_REGISTRY_PREVENT);
      SetDlgItemText(IDC_PREVENT,str);
   }

   if (m_bConfigure) {
      if (0 == m_radConfigPrevent) {
         OnConfig();
      } else {
         OnPrevent();
      }
   }
   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL CAttrObject::OnApply()
{
   // OnQueryCancel does all gestures and returns false if child windows are up
   if (!OnQueryCancel())
       return FALSE;

   if ( !m_bReadOnly )
   {
      LPTSTR szPath;

      UpdateData(TRUE);

      AREA_INFORMATION Area = 0;

      switch (m_dwType) {
         case ITEM_REGSD:
            Area = AREA_REGISTRY_SECURITY;
            break;
         case ITEM_FILESD:
            Area = AREA_FILE_SECURITY;
            break;
         default:
            ASSERT(FALSE);
      }

      if ( (NULL != m_pHandle) && (0 != Area) ) {

         SCESTATUS sceStatus=SCESTATUS_SUCCESS;
         BYTE status;

         if ( (m_pSnapin && m_pSnapin->CheckEngineTransaction()) ||
              (m_pCDI && m_pCDI->EngineTransactionStarted()) ) {


            if (!m_bConfigure ) {

               if ( NULL != posTemplate ) {
                  BOOL bContainer;

                  if ( m_pObject ) {
                     bContainer = m_pObject->IsContainer;
                  } else {
                     bContainer = TRUE;
                  }

                  //
                  // delete the SMP entry
                  //
                  szPath = m_strPath.GetBuffer(1);
                  sceStatus = SceUpdateObjectInfo(
                                                 m_pHandle,
                                                 Area,
                                                 szPath,
                                                 wcslen(szPath),
                                                 (BYTE)SCE_NO_VALUE,
                                                 bContainer,
                                                 NULL,
                                                 0,
                                                 &status
                                                 );
                  m_strPath.ReleaseBuffer();

   /*
                  if ( SCESTATUS_SUCCESS  == sceStatus &&
                       (BYTE)SCE_NO_VALUE != status &&
                       (DWORD)SCE_NO_VALUE != (DWORD)status ) {
   */
                  if (SCESTATUS_SUCCESS == sceStatus) {
                     if ((BYTE) SCE_NO_VALUE == status) {
                        status = SCE_STATUS_NOT_CONFIGURED;
                     }
                     if (m_pData) {
                        m_pData->SetStatus(status);
                     }

                     if ( m_pObject ) {
                        m_pObject->Status = status;
                     }
                  }
               }

            } else {

               BYTE dw;

               switch (m_radConfigPrevent) {
                  case 0:
                     // config
                     switch(m_radInheritOverwrite) {
                        case 0:
                           // inherit
                           dw = SCE_STATUS_CHECK;
                           break;
                        case 1:
                           // overwrite
                           dw = SCE_STATUS_OVERWRITE;
                           break;
                     }
                     break;
                  case 1:
                     // prevent
                     dw = SCE_STATUS_IGNORE;
                     break;
               }

               szPath = m_strPath.GetBuffer(1);

               sceStatus = SceUpdateObjectInfo(
                                              m_pHandle,
                                              Area,
                                              szPath,
                                              wcslen(szPath),
                                              dw,
                                              TRUE, //IsContainer
                                              m_pNewSD,
                                              m_NewSeInfo,
                                              &status
                                              );

               status = SCE_STATUS_NOT_ANALYZED;
               m_strPath.ReleaseBuffer();
               //
               // This should never happen, but does because
               //         of engine bugs
               //
               if ((BYTE) SCE_NO_VALUE == status) {
                  status = SCE_STATUS_NOT_CONFIGURED;
               }

               if (SCESTATUS_SUCCESS == sceStatus) {
                  if (m_pData) {
                     m_pData->SetStatus(status);
                  }

                  if ( m_pObject ) {
                     m_pObject->Status = status;
                  }
               }

            }
            if(m_pFolder){
               //
               // Update status information.
               //
               m_pCDI->UpdateObjectStatus( m_pFolder, TRUE );
            }
         } else {

            sceStatus = SCESTATUS_OTHER_ERROR;
         }

         if ( SCESTATUS_SUCCESS == sceStatus ) {
            PEDITTEMPLATE pet=NULL;
            if (m_pSnapin) {
               pet = m_pSnapin->GetTemplate(GT_COMPUTER_TEMPLATE,Area);
            } else if (m_pCDI) {
               pet = m_pCDI->GetTemplate(GT_COMPUTER_TEMPLATE,Area);
            }

            if ( pet ) {
               pet->SetDirty(Area);
            }
            if (m_pData) {
               m_pData->Update(m_pSnapin);
            }
         } else {
            CString str,strBase; //Raid #494798, yanggao
            strBase.LoadString(IDS_SAVE_FAILED);
            strBase += L"it.";
            MyFormatMessage(sceStatus,strBase,NULL,str);
            AfxMessageBox(str);
            return FALSE;
         }
      }

      SceFreeMemory((PVOID)posTemplate, SCE_STRUCT_OBJECT_SECURITY);
      posTemplate = NULL;

      SceFreeMemory((PVOID)posInspect, SCE_STRUCT_OBJECT_SECURITY);
      posInspect = NULL;

      if ( m_pNewSD ) {
         LocalFree(m_pNewSD);
         m_pNewSD = NULL;
      }

      m_NewSeInfo = 0;

      m_pAnalSD=NULL;
      m_AnalInfo=0;

      m_hwndParent = NULL;
      if ( m_pSI ) {
         m_pSI->Release();
         m_pSI = NULL;
      }
      m_pfnCreateDsPage=NULL;
   }

   return CAttribute::OnApply();
}

void CAttrObject::OnCancel()
{
   SceFreeMemory((PVOID)posTemplate, SCE_STRUCT_OBJECT_SECURITY);
   posTemplate = NULL;

   SceFreeMemory((PVOID)posInspect, SCE_STRUCT_OBJECT_SECURITY);
   posInspect = NULL;

   if ( m_pNewSD ) {
      LocalFree(m_pNewSD);
      m_pNewSD = NULL;
   }
   m_NewSeInfo = 0;

   m_pAnalSD=NULL;
   m_AnalInfo=0;

   m_hwndParent = NULL;
   if ( m_pSI ) {
      m_pSI->Release();
      m_pSI = NULL;
   }
   m_pfnCreateDsPage=NULL;

   CAttribute::OnCancel();
}

void CAttrObject::OnConfig()
{
   CWnd *pRadio;

   pRadio = GetDlgItem(IDC_INHERIT);
   pRadio->EnableWindow(TRUE);
   pRadio = GetDlgItem(IDC_OVERWRITE);
   pRadio->EnableWindow(TRUE);

   int prevValue = m_radConfigPrevent; //Raid #491006, Yanggao
   UpdateData(); 
   if(m_radConfigPrevent != prevValue)
   {
      SetModified(TRUE);
   }

   GetDlgItem(IDC_TEMPLATE_SECURITY)->EnableWindow(TRUE); //Raid #477266, Yanggao
}

void CAttrObject::OnPrevent()
{
   CWnd *pRadio;

   pRadio = GetDlgItem(IDC_INHERIT);
   pRadio->EnableWindow(FALSE);
   pRadio = GetDlgItem(IDC_OVERWRITE);
   pRadio->EnableWindow(FALSE);

   int prevValue = m_radConfigPrevent; //Raid #491006, Yanggao
   UpdateData(); 
   if(m_radConfigPrevent != prevValue)
   {
      SetModified(TRUE);
   }

   GetDlgItem(IDC_TEMPLATE_SECURITY)->EnableWindow(FALSE); //Raid #477266, Yanggao
}


void CAttrObject::OnOverwrite()
{
   int prevValue = m_radInheritOverwrite; //Raid #491006, Yanggao
   UpdateData(); 
   if(m_radInheritOverwrite != prevValue)
   {
      SetModified(TRUE);
   }
}

void CAttrObject::OnInherit()
{
   int prevValue = m_radInheritOverwrite; //Raid #491006, Yanggao
   UpdateData(); 
   if(m_radInheritOverwrite != prevValue)
   {
      SetModified(TRUE);
   }
}

//------------------------------------------------------------------
// override to prevent the sheet from being destroyed when there is
// child dialogs still up and running.
//------------------------------------------------------------------
BOOL CAttrObject::OnQueryCancel()
{
    if (::IsWindow(m_hwndInspect) || ::IsWindow(m_hwndTemplate))
    {
        CString strMsg;
        strMsg.LoadString(IDS_CLOSESUBSHEET_BEFORE_APPLY);
        AfxMessageBox(strMsg);
        return FALSE;
    }
    else
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\applcnfg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       applcnfg.h
//
//  Contents:   definition of CApplyConfiguration
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_APPLCNFG_H__6D0C4D6F_BF71_11D1_AB7E_00C04FB6C6FA__INCLUDED_)
#define AFX_APPLCNFG_H__6D0C4D6F_BF71_11D1_AB7E_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "perfanal.h"

/////////////////////////////////////////////////////////////////////////////
// CApplyConfiguration dialog

class CApplyConfiguration : public CPerformAnalysis
{
// Construction
public:
   CApplyConfiguration();   // standard constructor

// Dialog Data
   //{{AFX_DATA(CApplyConfiguration)
   enum { IDD = IDD_ANALYSIS_GENERATE };
      // NOTE: the ClassWizard will add data members here
   //}}AFX_DATA



// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CApplyConfiguration)
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation
protected:

   virtual DWORD DoIt();

   // Generated message map functions
   //{{AFX_MSG(CApplyConfiguration)
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_APPLCNFG_H__6D0C4D6F_BF71_11D1_AB7E_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\aret.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aret.cpp
//
//  Contents:   implementation of CAttrRet
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "resource.h"
#include "snapmgr.h"
#include "attr.h"
#include "ARet.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAttrRet dialog


CAttrRet::CAttrRet(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD)
{
    //{{AFX_DATA_INIT(CAttrRet)
    m_strAttrName = _T("");
    m_strLastInspect = _T("");
    m_rabRetention = -1;
    //}}AFX_DATA_INIT
    m_StartIds = IDS_AS_NEEDED;
    m_pHelpIDs = (DWORD_PTR)a189HelpIDs;
    m_uTemplateResID = IDD;
}


void CAttrRet::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAttrRet)
//    DDX_Text(pDX, IDC_ATTRIBUTE_NAME, m_strAttrName);
    DDX_Text(pDX, IDC_LAST_INSPECT, m_strLastInspect);
    DDX_Radio(pDX, IDC_RETENTION, m_rabRetention);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttrRet, CAttribute)
    //{{AFX_MSG_MAP(CAttrRet)
        ON_BN_CLICKED(IDC_RETENTION, OnRetention)
        ON_BN_CLICKED(IDC_RADIO2, OnRetention)
        ON_BN_CLICKED(IDC_RADIO3, OnRetention)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttrRet message handlers

BOOL CAttrRet::OnInitDialog()
{

   CAttribute::OnInitDialog();
   AddUserControl(IDC_RETENTION);
   AddUserControl(IDC_RADIO2);
   AddUserControl(IDC_RADIO3);
   EnableUserControls(m_bConfigure);

   return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CAttrRet::OnApply()
{
   if ( !m_bReadOnly )
   {
      LONG_PTR dw = 0;
      int status = 0;

      UpdateData(TRUE);

      if (!m_bConfigure)
         dw = (LONG_PTR)ULongToPtr(SCE_NO_VALUE);
      else 
      {
         switch(m_rabRetention) 
         {
         case RADIO_RETAIN_BY_DAYS:
            dw = SCE_RETAIN_BY_DAYS;
            break;
         case RADIO_RETAIN_AS_NEEDED:
            dw = SCE_RETAIN_AS_NEEDED;
            break;
         case RADIO_RETAIN_MANUALLY:
            dw = SCE_RETAIN_MANUALLY;
            break;
         }
      }


      CEditTemplate *pet = m_pSnapin->GetTemplate(GT_COMPUTER_TEMPLATE,AREA_SECURITY_POLICY);

      //
      // Check dependecies for this item.
      //
      if(DDWarn.CheckDependencies(
               (DWORD)dw
               ) == ERROR_MORE_DATA ){
         //
         // If it fails and the user presses cancel then we will exit and do nothing.
         //
         CThemeContextActivator activator;
         if( DDWarn.DoModal() != IDOK){
            return FALSE;
         }

         //
         // If the user presses autoset then we set the item and update the result panes.
         //
         for(int i = 0; i < DDWarn.GetFailedCount(); i++){
            PDEPENDENCYFAILED pItem = DDWarn.GetFailedInfo(i);
            if(pItem && pItem->pResult ){
               pItem->pResult->SetBase( pItem->dwSuggested );
               status = m_pSnapin->SetAnalysisInfo(pItem->pResult->GetID(),
                                                   pItem->dwSuggested,
                                                   pItem->pResult);
               pItem->pResult->SetStatus(status); //Raid #249167, 4/21/2001
               pItem->pResult->Update(m_pSnapin, FALSE);
            }
         }
      }

      m_pData->SetBase(dw);
      status = m_pSnapin->SetAnalysisInfo(m_pData->GetID(),dw, m_pData);
      m_pData->SetStatus(status);

      m_pData->Update(m_pSnapin, FALSE);
   }

   return CAttribute::OnApply();
}




void CAttrRet::Initialize(CResult * pData)
{
   LONG_PTR dw = 0;
   CAttribute::Initialize(pData);

   DDWarn.InitializeDependencies(m_pSnapin,pData);

   m_StartIds = IDS_AS_NEEDED;

   //
   // Display the last inspected setting in its static box
   //
   pData->GetDisplayName( NULL, m_strLastInspect, 2 );

   // Set the template setting radio button appropriately
//   m_strAttrName = pData->GetAttrPretty();
   dw = pData->GetBase();
   if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) == dw) {
      m_bConfigure = FALSE;
   } else {
      m_bConfigure = TRUE;
      SetInitialValue((DWORD_PTR)dw);
   }
}

void CAttrRet::SetInitialValue(DWORD_PTR dw) {

   switch(dw) {
   case SCE_RETAIN_BY_DAYS:
      m_rabRetention = RADIO_RETAIN_BY_DAYS;
      break;
   case SCE_RETAIN_AS_NEEDED:
      m_rabRetention = RADIO_RETAIN_AS_NEEDED;
      break;
   case SCE_RETAIN_MANUALLY:
      m_rabRetention = RADIO_RETAIN_MANUALLY;
      break;
   }
}

void CAttrRet::OnRetention()
{
   SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\areaprog.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       areaprog.h
//
//  Contents:   definition of AreaProgress
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_AREAPROG_H__38CE6730_56FF_11D1_AB64_00C04FB6C6FA__INCLUDED_)
#define AFX_AREAPROG_H__38CE6730_56FF_11D1_AB64_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "HelpDlg.h"

#define NUM_AREAS 7
/////////////////////////////////////////////////////////////////////////////
// AreaProgress dialog

class AreaProgress : public CHelpDialog
{
// Construction
public:
   void SetArea(AREA_INFORMATION Area);
   void SetCurTicks(DWORD dwTicks);
   void SetMaxTicks(DWORD dwTicks);
   AreaProgress(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
   //{{AFX_DATA(AreaProgress)
   enum { IDD = IDD_ANALYZE_PROGRESS };
   CProgressCtrl  m_ctlProgress;
   //}}AFX_DATA

// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(AreaProgress)
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation
protected:
   int GetAreaIndex(AREA_INFORMATION Area);

   // Generated message map functions
   //{{AFX_MSG(AreaProgress)
   virtual BOOL OnInitDialog();
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

private:
   CBitmap m_bmpChecked;
   CBitmap m_bmpCurrent;
   int m_nLastArea;
   int m_isDC;

   CStatic m_stIcons[NUM_AREAS];
   CStatic m_stLabels[NUM_AREAS];
   CString m_strAreas[NUM_AREAS];
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AREAPROG_H__38CE6730_56FF_11D1_AB64_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\areaprog.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       areaprog.cpp
//
//  Contents:   implementation of AreaProgress
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "resource.h"
#include "wrapper.h"
#include "AreaProg.h"
#include "util.h"

typedef enum {
   INDEX_PRIV =0,
   INDEX_GROUP,
   INDEX_REG,
   INDEX_FILE,
   INDEX_DS,
   INDEX_SERVICE,
   INDEX_POLICY,
} AREA_INDEX;



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// AreaProgress dialog

AreaProgress::AreaProgress(CWnd* pParent /*=NULL*/)
    : CHelpDialog(a199HelpIDs, IDD, pParent)
{
    //{{AFX_DATA_INIT(AreaProgress)
    //}}AFX_DATA_INIT

   m_isDC = IsDomainController();
   m_nLastArea = -1;

   m_bmpChecked.LoadMappedBitmap(IDB_CHECK);
   m_bmpCurrent.LoadMappedBitmap(IDB_ARROW);

}

void AreaProgress::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(AreaProgress)
    DDX_Control(pDX, IDC_PROGRESS1, m_ctlProgress);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(AreaProgress, CHelpDialog)
    //{{AFX_MSG_MAP(AreaProgress)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// AreaProgress message handlers

BOOL AreaProgress::OnInitDialog()
{
    CDialog::OnInitDialog();
    int i,nAreas;
   CString strAreas[NUM_AREAS];


   // Map AREAs to string descriptions of the area
   i = GetAreaIndex(AREA_PRIVILEGES);
   if (i >= 0) {
      strAreas[i].LoadString(IDS_PRIVILEGE);
   }

   i = GetAreaIndex(AREA_GROUP_MEMBERSHIP);
   if (i >= 0) {
      strAreas[i].LoadString(IDS_GROUPS);
   }

   i = GetAreaIndex(AREA_REGISTRY_SECURITY);
   if (i >= 0) {
      strAreas[i].LoadString(IDS_REGISTRY);
   }

   i = GetAreaIndex(AREA_FILE_SECURITY);
   if (i >= 0) {
      strAreas[i].LoadString(IDS_FILESTORE);
   }

   i = GetAreaIndex(AREA_DS_OBJECTS);
   if (i >= 0) {
      strAreas[i].LoadString(IDS_DSOBJECT);
   }

   i = GetAreaIndex(AREA_SYSTEM_SERVICE);
   if (i >= 0) {
      strAreas[i].LoadString(IDS_SERVICE);
   }

   i = GetAreaIndex(AREA_SECURITY_POLICY);
   if (i >= 0) {
      strAreas[i].LoadString(IDS_POLICY);
   }

   // Initialize Control Arrays
   nAreas = NUM_AREAS;
   if (!m_isDC) {
      nAreas--;
   }
   for(i=0;i< nAreas;i++) {
      m_stLabels[i].Attach(::GetDlgItem(GetSafeHwnd(),IDC_AREA1+i));
      m_stLabels[i].SetWindowText(strAreas[i]);
      // Make the label visible
      m_stLabels[i].ShowWindow(SW_SHOW);


      m_stIcons[i].Attach(::GetDlgItem(GetSafeHwnd(),IDC_ICON1+i));
      m_stIcons[i].ShowWindow(SW_SHOW);
   }


   return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


int AreaProgress::GetAreaIndex(AREA_INFORMATION Area)
{
   int dwIndex;
   switch(Area) {
   case AREA_PRIVILEGES:
      dwIndex = INDEX_PRIV;
      break;
   case AREA_GROUP_MEMBERSHIP:
      dwIndex = INDEX_GROUP;
      break;
   case AREA_REGISTRY_SECURITY:
      dwIndex = INDEX_REG;
      break;
   case AREA_FILE_SECURITY:
      dwIndex = INDEX_FILE;
      break;
   case AREA_DS_OBJECTS:
      dwIndex = INDEX_DS;
      break;
   case AREA_SYSTEM_SERVICE:
      dwIndex = INDEX_SERVICE;
      break;
   case AREA_SECURITY_POLICY:
      dwIndex = INDEX_POLICY;
      break;
   default:
      dwIndex = -1;
   }

   if (!m_isDC && (dwIndex == INDEX_DS)) {
      dwIndex = -1;
   }
   if (!m_isDC && (dwIndex > INDEX_DS)) {
      dwIndex--;
   }
   return dwIndex;
}

void AreaProgress::SetMaxTicks(DWORD dwTicks)
{
#if _MFC_VER >= 0x0600
   m_ctlProgress.SetRange32(0,dwTicks);
#else
   m_ctlProgress.SetRange(0,dwTicks);
#endif
}

void AreaProgress::SetCurTicks(DWORD dwTicks)
{
   m_ctlProgress.SetPos(dwTicks);
}

void AreaProgress::SetArea(AREA_INFORMATION Area)
{
   int i,target;

   target = GetAreaIndex(Area);
   if (target <= m_nLastArea) {
      return;
   }
   if (m_nLastArea < 0) {
      m_nLastArea = 0;
   }
   for(i=m_nLastArea;i<target;i++) {
      m_stIcons[i].SetBitmap(m_bmpChecked);
   }
   m_stIcons[target].SetBitmap(m_bmpCurrent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\aret.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aret.h
//
//  Contents:   definition of CAttrRet
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_ARET_H__D4CAC357_3499_11D1_AB4D_00C04FB6C6FA__INCLUDED_)
#define AFX_ARET_H__D4CAC357_3499_11D1_AB4D_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CAttrRet dialog
#define RADIO_RETAIN_BY_DAYS     0
#define RADIO_RETAIN_AS_NEEDED   1
#define RADIO_RETAIN_MANUALLY    2

#include "ddwarn.h"

class CAttrRet : public CAttribute
{
// Construction
public:
    void Initialize(CResult *pData);
    virtual void SetInitialValue(DWORD_PTR dw);
    CAttrRet(UINT nTemplateID);   // standard constructor
	
// Dialog Data
    //{{AFX_DATA(CAttrRet)
	enum { IDD = IDD_ATTR_RET };
    CString m_strAttrName;
    CString m_strLastInspect;
	int		m_rabRetention;
	//}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAttrRet)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAttrRet)
    virtual BOOL OnInitDialog();
    virtual BOOL OnApply();
	afx_msg void OnRetention();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    CDlgDependencyWarn DDWarn;

public:
    UINT m_StartIds;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ARET_H__D4CAC357_3499_11D1_AB4D_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\aservice.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aservice.cpp
//
//  Contents:   implementation of CAnalysisService
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "resource.h"
#include "snapmgr.h"
#include "attr.h"
#include "cservice.h"
#include "Aservice.h"
#include "util.h"
#include "servperm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BYTE
CompareServiceNode(
    PSCE_SERVICES pBaseService,
    PSCE_SERVICES pAnalService
    )
{
    if ( NULL == pBaseService ||
         NULL == pAnalService ) {
        // one or both are not configured
        return SCE_STATUS_NOT_CONFIGURED;
    }

    if ( pBaseService == pAnalService ) {
        // same address
        pAnalService->Status = SCE_STATUS_GOOD;
        return SCE_STATUS_GOOD;
    }

    if ( pBaseService->Startup != pAnalService->Startup ) {
        // startup type is different
        pAnalService->Status = SCE_STATUS_MISMATCH;
        return SCE_STATUS_MISMATCH;
    }

    if ( NULL == pBaseService->General.pSecurityDescriptor &&
         NULL == pAnalService->General.pSecurityDescriptor ) {
        // both do not have SD - everyone full control
        pAnalService->Status = SCE_STATUS_GOOD;
        return SCE_STATUS_GOOD;
    }

    if ( NULL == pBaseService->General.pSecurityDescriptor ||
         NULL == pAnalService->General.pSecurityDescriptor ) {
        // one SD is NULL
        pAnalService->Status = SCE_STATUS_MISMATCH;
        return SCE_STATUS_MISMATCH;
    }

    BOOL bIsDif=FALSE;
    SCESTATUS rc = SceCompareSecurityDescriptors(
                            AREA_SYSTEM_SERVICE,
                            pBaseService->General.pSecurityDescriptor,
                            pAnalService->General.pSecurityDescriptor,
                            pBaseService->SeInfo | pAnalService->SeInfo,
                            &bIsDif
                            );
    if ( SCESTATUS_SUCCESS == rc &&
         bIsDif == FALSE ) {
        pAnalService->Status = SCE_STATUS_GOOD;
        return SCE_STATUS_GOOD;
    }

    pAnalService->Status = SCE_STATUS_MISMATCH;
    return SCE_STATUS_MISMATCH;
}

/////////////////////////////////////////////////////////////////////////////
// CAnalysisService dialog


CAnalysisService::CAnalysisService()
: CAttribute(IDD),
    m_pNewSD(NULL),
    m_NewSeInfo(0),
    m_pAnalSD(NULL),
    m_hwndShow(NULL),
    m_hwndChange(NULL),
    m_SecInfo(DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION),
    m_pEditSec(NULL),
    m_pShowSec(NULL)
{
    //{{AFX_DATA_INIT(CAnalysisService)
    m_nStartupRadio = -1;
    m_CurrentStr = _T("");
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a194HelpIDs;
    m_uTemplateResID = IDD;
}

CAnalysisService::~CAnalysisService()
{
    if (::IsWindow(m_hwndShow))
    {
        m_pShowSec->Destroy(m_hwndShow);
        m_hwndShow = NULL;
    }
    delete m_pShowSec;
    m_pShowSec = NULL;

    if (::IsWindow(m_hwndChange))
    {
        m_pEditSec->Destroy(m_hwndChange);
        m_hwndChange = NULL;
    }
    delete m_pEditSec;
    m_pEditSec = NULL;
}

void CAnalysisService::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAnalysisService)
    DDX_Text(pDX, IDC_CURRENT, m_CurrentStr);
    DDX_Radio(pDX, IDC_ENABLED, m_nStartupRadio);
    DDX_Control(pDX, IDC_BASESD, m_bPermission);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAnalysisService, CAttribute)
    //{{AFX_MSG_MAP(CAnalysisService)
    ON_BN_CLICKED(IDC_BASESD, OnChangeSecurity)
    ON_BN_CLICKED(IDC_CURRENTSD, OnShowSecurity)
    ON_BN_CLICKED(IDC_CONFIGURE, OnConfigure)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAnalysisService message handlers
BOOL CAnalysisService::OnApply()
{
   if ( !m_bReadOnly )
   {
       // OnQueryCancel does all gestures and returns false if child windows are up
       if (!OnQueryCancel())
           return FALSE;

       DWORD dw = 0;
       PEDITTEMPLATE pet = 0;

       UpdateData(TRUE);
       PSCE_SERVICES pNode = (PSCE_SERVICES)(m_pData->GetBase());

       if (!m_bConfigure ) 
       {
           if ( NULL != pNode ) 
           {
               m_pSnapin->SetupLinkServiceNodeToBase(FALSE, m_pData->GetBase());

               if ( m_pData->GetBase() != m_pData->GetSetting() ) 
               {
                   //
                   // analysis is not using the same node, free it
                   //
                   pNode->Next = NULL;
                   SceFreeMemory(pNode, SCE_STRUCT_SERVICES);
               } 
               else 
               {
                   //
                   // add the node to analysis
                   //
                   pNode->Status = SCE_STATUS_NOT_CONFIGURED;
                   m_pSnapin->AddServiceNodeToProfile(pNode);
               }
               m_pData->SetBase(0);
           }

           m_pData->SetStatus(SCE_STATUS_NOT_CONFIGURED);
           if ( m_pNewSD ) 
           {
               LocalFree(m_pNewSD);
               m_pNewSD = NULL;
           }
       } 
       else 
       {
           switch(m_nStartupRadio) 
           {
           case 0:
               // Automatic
               dw = SCE_STARTUP_AUTOMATIC;
               break;

           case 1:
               // Manual
               dw = SCE_STARTUP_MANUAL;
               break;

           default:
               // DISABLED
               dw = SCE_STARTUP_DISABLED;
               break;
           }

           if ( NULL != pNode &&
                m_pData->GetBase() == m_pData->GetSetting() ) 
           {
               //
               // a matched item is changed to mismatch
               // needs to create a new node
               //
               m_pSnapin->SetupLinkServiceNodeToBase(FALSE, m_pData->GetBase());
               m_pData->SetBase(0);
               //
               // add to analysis profile
               //
               pNode->Status = SCE_STATUS_MISMATCH;
               m_pSnapin->AddServiceNodeToProfile(pNode);

               pNode = NULL;
           }

           PSCE_SERVICES pSetting = (PSCE_SERVICES)(m_pData->GetSetting());
           BYTE status = 0;

           if ( NULL == pNode ) 
           {
               //
               // a node is changed from not configured to configured
               // or from match to mismatch
               //
               pNode = CreateServiceNode(m_pData->GetUnits(),
                                           m_pData->GetAttr(),
                                           dw,
                                           m_pNewSD,
                                           m_NewSeInfo);
               if ( pNode != NULL ) 
               {
                   //
                   // add to the service list
                   //
                   m_pSnapin->SetupLinkServiceNodeToBase(TRUE, (LONG_PTR)pNode);

                   m_pData->SetBase((LONG_PTR)pNode);

                   if ( pSetting ) 
                   {
                       status = CompareServiceNode(pNode, pSetting);
                       m_pData->SetStatus(status);
                   } 
                   else 
                   {
                       //
                       // this is a new configured service
                       // should create a "dump" analysis node to indictae
                       // this service is not a "matched" item
                       //
                       pSetting = CreateServiceNode(m_pData->GetUnits(),
                                                   m_pData->GetAttr(),
                                                   0,
                                                   NULL,
                                                   0);
                       if ( pSetting ) 
                       {
                           //
                           // link it to analysis profile
                           //

                           pet = 0;//Raid #prefast
                           PSCE_PROFILE_INFO pInfo=NULL;

                           pet = m_pSnapin->GetTemplate(GT_LAST_INSPECTION, AREA_SYSTEM_SERVICE);

                           if (NULL != pet )
                              pInfo = pet->pTemplate;
                           
                           if ( pInfo ) 
                           {
                              pSetting->Status = SCE_STATUS_NOT_CONFIGURED;
                              pSetting->Next = pInfo->pServices;
                              pInfo->pServices = pSetting;

                              m_pData->SetSetting( (LONG_PTR)pSetting);
                           } 
                           else 
                           {
                              //
                              // free pSetting
                              //
                              LocalFree(pSetting->DisplayName);
                              LocalFree(pSetting->ServiceName);
                              LocalFree(pSetting);
                              pSetting = NULL;
                           }
                       }

                       m_pData->SetStatus(SCE_STATUS_NOT_CONFIGURED);
                   }

               } 
               else 
               {
                   //
                   // no memory, error out
                   //
                   if ( m_pNewSD ) 
                   {
                       LocalFree(m_pNewSD);
                       m_pNewSD = NULL;
                   }
               }
           } 
           else 
           {
               //
               // an existing service
               //
               pNode->Startup = (BYTE)dw;
               if ( m_pNewSD != NULL ) 
               {
                   if ( pNode->General.pSecurityDescriptor != m_pNewSD &&
                        pNode->General.pSecurityDescriptor != NULL ) 
                   {
                       LocalFree(pNode->General.pSecurityDescriptor);
                   }
                   pNode->General.pSecurityDescriptor = m_pNewSD;
                   m_pNewSD = NULL;

                   pNode->SeInfo = m_NewSeInfo;
               }
               //
               // update status field in the analysis node
               //
               if ( pSetting ) 
               {
                   status = CompareServiceNode(pNode, pSetting);
                   m_pData->SetStatus(status);
               } 
               else 
               {
                   // this is a new configured service
                   m_pData->SetStatus(SCE_STATUS_NOT_CONFIGURED);
               }
           }
       }

       pet = m_pData->GetBaseProfile();
       if( NULL != pet ) //Raid #prefast
       {
           pet->SetDirty(AREA_SYSTEM_SERVICE);
       }
       m_pData->Update(m_pSnapin);

       m_NewSeInfo = 0;
       m_hwndParent = NULL;
       m_hwndShow = NULL;
       m_hwndChange = NULL;
   }

    return CAttribute::OnApply();
}

void CAnalysisService::OnCancel()
{
    if ( m_pNewSD ) 
    {
        LocalFree(m_pNewSD);
        m_pNewSD = NULL;
    }
    m_NewSeInfo = 0;
    m_hwndParent = NULL;
    m_pAnalSD = NULL;

    m_hwndShow = NULL;
    m_hwndChange = NULL;
    CAttribute::OnCancel();
}

BOOL CAnalysisService::OnInitDialog()
{
    CAttribute::OnInitDialog();


    if ( 0 == m_pData->GetSetting() ) {

        CButton *rb = (CButton *)GetDlgItem(IDC_CURRENTSD);
        rb->EnableWindow(FALSE);
    }


    AddUserControl(IDC_ENABLED);
    AddUserControl(IDC_DISABLED);
    AddUserControl(IDC_IGNORE);
    AddUserControl(IDC_BASESD);

    OnConfigure();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CAnalysisService::Initialize(CResult * pResult)
{
   CAttribute::Initialize(pResult);

   //
   // initialize setting
   //
   m_pNewSD = NULL;
   m_NewSeInfo = 0;
   m_pAnalSD = NULL;

   //
   // Never start up with do not configure set.  If they're coming 
   // here it is probably to set a value
   //
   m_bConfigure = TRUE;

   if ( 0 != pResult->GetSetting() ) {

       PSCE_SERVICES pServSetting = (PSCE_SERVICES)(pResult->GetSetting());

       switch ( pServSetting->Startup ) {
       case SCE_STARTUP_AUTOMATIC:
           m_CurrentStr.LoadString(IDS_AUTOMATIC);
           break;
       case SCE_STARTUP_MANUAL:
           m_CurrentStr.LoadString(IDS_MANUAL);
           break;
       default: // disabled
           m_CurrentStr.LoadString(IDS_DISABLED);
           break;
       }
       m_pAnalSD = pServSetting->General.pSecurityDescriptor;
   }

   PSCE_SERVICES pService;

   pService = (PSCE_SERVICES)(pResult->GetBase());
   if ( NULL == pService ) {
       m_bConfigure = FALSE;
       pService = (PSCE_SERVICES)(pResult->GetSetting());
   }
   if ( pService != NULL ) {
       switch ( pService->Startup ) {
       case SCE_STARTUP_AUTOMATIC:
           m_nStartupRadio = 0;
           break;
       case SCE_STARTUP_MANUAL:
           m_nStartupRadio = 1;
           break;
       default: // disabled
           m_nStartupRadio = 2;
           break;
       }

       if ( pService->General.pSecurityDescriptor ) {

            MyMakeSelfRelativeSD(pService->General.pSecurityDescriptor,
                                 &m_pNewSD);
       }
       m_NewSeInfo = pService->SeInfo;
   }

}


void CAnalysisService::OnShowSecurity()
{
    if ( IsWindow(m_hwndShow) ) {
       ::BringWindowToTop(m_hwndShow);
       return;
    }

    PSCE_SERVICES pService = (PSCE_SERVICES)(m_pData->GetSetting());

    SECURITY_INFORMATION SeInfo;

    if (pService)
        m_SecInfo = pService->SeInfo;

    // prepare the modeless property page data for the thread to create
    // the property sheet.

    if (NULL == m_pShowSec)
    {
        m_pShowSec = new CModelessSceEditor(false, 
                                            ANALYSIS_SECURITY_PAGE_RO_NP, 
                                            GetSafeHwnd(), 
                                            SE_SERVICE,
                                            m_pData->GetAttr());
    }

    if (NULL != m_pShowSec)
        m_pShowSec->Create(&m_pAnalSD, &m_SecInfo, &m_hwndShow);

}

void CAnalysisService::OnConfigure()
{
   CAttribute::OnConfigure();
   if (m_bConfigure && !m_pNewSD) {
       OnChangeSecurity();
   }
   else if (!m_bConfigure && IsWindow(m_hwndChange))
   {
       m_pEditSec->Destroy(m_hwndChange);
       m_hwndChange = NULL;
   }
}

void CAnalysisService::OnChangeSecurity()
{
   if ( IsWindow(m_hwndChange) ) {
      ::BringWindowToTop(m_hwndChange);
      return;
   }

   if ( !m_pNewSD ) {
      GetDefaultServiceSecurity(&m_pNewSD,&m_NewSeInfo);
   }

   // if it comes to this point, the m_hwndChange must not be a valid Window
   // so the can ask to create a modeless dialog

   if (NULL == m_pEditSec)
   {
       m_pEditSec = new CModelessSceEditor(false, 
                                           CONFIG_SECURITY_PAGE_NO_PROTECT, 
                                           GetSafeHwnd(), 
                                           SE_SERVICE,
                                           m_pData->GetAttr());
   }

   if (NULL != m_pEditSec)
        m_pEditSec->Create(&m_pNewSD, &m_NewSeInfo, &m_hwndChange);

}

//------------------------------------------------------------------
// override to prevent the sheet from being destroyed when there is
// child dialogs still up and running.
//------------------------------------------------------------------
BOOL CAnalysisService::OnQueryCancel()
{
    if (::IsWindow(m_hwndChange) || ::IsWindow(m_hwndShow))
    {
        CString strMsg;
        strMsg.LoadString(IDS_CLOSESUBSHEET_BEFORE_APPLY);
        AfxMessageBox(strMsg);
        return FALSE;
    }
    else
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\aright.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aright.h
//
//  Contents:   definition of CAttrRight
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_ARIGHT_H__B4557B13_44C9_11D1_AB52_00C04FB6C6FA__INCLUDED_)
#define AFX_ARIGHT_H__B4557B13_44C9_11D1_AB52_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CAttrRight dialog

class CAttrRight : public CAttribute
{
// Construction
public:
    virtual void Initialize(CResult *pData);
    virtual void SetInitialValue(DWORD_PTR dw) { dw; };
    CAttrRight();   // standard constructor
    virtual ~CAttrRight();

// Dialog Data
    //{{AFX_DATA(CAttrRight)
	enum { IDD = IDD_ATTR_RIGHT };
	//}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAttrRight)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    bool m_bDirty;

    // Generated message map functions
    //{{AFX_MSG(CAttrRight)
    virtual BOOL OnInitDialog();
    virtual BOOL OnApply();
    virtual void OnCancel();
    afx_msg void OnAdd();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

protected:
    afx_msg void OnClickCheckBox(NMHDR *pNM, LRESULT *pResult);
    PSCE_NAME_STATUS_LIST m_pMergeList;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ARIGHT_H__B4557B13_44C9_11D1_AB52_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\asgncnfg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       asgncnfg.h
//
//  Contents:   definition of CAssignConfiguration
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_ASGNCNFG_H__6D0C4D6E_BF71_11D1_AB7E_00C04FB6C6FA__INCLUDED_)
#define AFX_ASGNCNFG_H__6D0C4D6E_BF71_11D1_AB7E_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CAssignConfiguration dialog

class CAssignConfiguration : public CFileDialog
{
	DECLARE_DYNAMIC(CAssignConfiguration)

public:
	CAssignConfiguration(BOOL bOpenFileDialog, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL);

   BOOL m_bIncremental;
protected:
	//{{AFX_MSG(CAssignConfiguration)
	afx_msg void OnIncremental();
	//}}AFX_MSG
    afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()

    void DoContextHelp (HWND hWndControl);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ASGNCNFG_H__6D0C4D6E_BF71_11D1_AB7E_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\asgncnfg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       asgncnfg.cpp
//
//  Contents:   implementation of CAssignConfiguration
//                              
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "asgncnfg.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAssignConfiguration

IMPLEMENT_DYNAMIC(CAssignConfiguration, CFileDialog)

CAssignConfiguration::CAssignConfiguration(BOOL bOpenFileDialog, LPCTSTR lpszDefExt, LPCTSTR lpszFileName,
      DWORD dwFlags, LPCTSTR lpszFilter, CWnd* pParentWnd) :
      CFileDialog(bOpenFileDialog, lpszDefExt, lpszFileName, dwFlags , lpszFilter, pParentWnd)
{
   m_bIncremental = TRUE;
}


BEGIN_MESSAGE_MAP(CAssignConfiguration, CFileDialog)
   //{{AFX_MSG_MAP(CAssignConfiguration)
   ON_BN_CLICKED(IDC_INCREMENTAL, OnIncremental)
   //}}AFX_MSG_MAP
   ON_MESSAGE(WM_HELP, OnHelp)
END_MESSAGE_MAP()


void CAssignConfiguration::OnIncremental()
{
   CButton *btn = (CButton *)GetDlgItem(IDC_INCREMENTAL);
   if (!btn) {
      return;
   }
   m_bIncremental = !(btn->GetCheck());
}

BOOL CAssignConfiguration::OnHelp(WPARAM wParam, LPARAM lParam)
{
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        this->DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    return TRUE;
}

void CAssignConfiguration::DoContextHelp (HWND hWndControl)
{
    // Display context help for a control
    if ( !::WinHelp (
            hWndControl,
            GetSeceditHelpFilename(),
            HELP_WM_HELP,
            (DWORD_PTR) a217HelpIDs) )
    {
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\aservice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aservice.h
//
//  Contents:   definition of CAnalysisService
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_ATTRSERVICE_H__44850C1C_350B_11D1_AB4F_00C04FB6C6FA__INCLUDED_)
#define AFX_ATTRSERVICE_H__44850C1C_350B_11D1_AB4F_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CAnalysisService dialog

class CAnalysisService : public CAttribute
{
// Construction
public:
    void Initialize(CResult *pResult);
    CAnalysisService();   // standard constructor
    virtual ~CAnalysisService();

// Dialog Data
    //{{AFX_DATA(CAnalysisService)
    enum { IDD = IDD_ANALYSIS_SERVICE };
    int     m_nStartupRadio;
    CButton m_bPermission;
    CString m_CurrentStr;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAnalysisService)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAnalysisService)
    virtual BOOL OnApply();
    virtual void OnCancel();
    virtual BOOL OnQueryCancel();
    virtual BOOL OnInitDialog();
    afx_msg void OnConfigure();
    afx_msg void OnChangeSecurity();
    afx_msg void OnShowSecurity();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:

private:
    PSECURITY_DESCRIPTOR m_pNewSD;
    SECURITY_INFORMATION m_NewSeInfo;
    PSECURITY_DESCRIPTOR m_pAnalSD;

    HWND m_hwndShow;
    HWND m_hwndChange;
    SECURITY_INFORMATION m_SecInfo;

    CModelessSceEditor *m_pEditSec;
    CModelessSceEditor *m_pShowSec;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ATTRSERVICE_H__44850C1C_350B_11D1_AB4F_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\aright.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       aright.cpp
//
//  Contents:   implementation of CAttrRight
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "attr.h"
#include "util.h"
#include "chklist.h"
#include "ARight.h"
#include "getuser.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAttrRight dialog


CAttrRight::CAttrRight()
: CAttribute(IDD), 
m_pMergeList(NULL), 
m_bDirty(false)

{
   //{{AFX_DATA_INIT(CAttrRight)
        //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR)a191HelpIDs;
   m_uTemplateResID = IDD;
}

CAttrRight::~CAttrRight()
{
   if ( m_pMergeList ) {
      SceFreeMemory(m_pMergeList, SCE_STRUCT_NAME_STATUS_LIST);
      m_pMergeList = NULL;
   }
}

void CAttrRight::DoDataExchange(CDataExchange* pDX)
{
   CAttribute::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CAttrRight)
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttrRight, CAttribute)
//{{AFX_MSG_MAP(CAttrRight)
ON_BN_CLICKED(IDC_ADD, OnAdd)
        //}}AFX_MSG_MAP
   ON_NOTIFY(CLN_CLICK, IDC_RIGHTS, OnClickCheckBox)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttrRight message handlers

void CAttrRight::Initialize(CResult * pData)
{
   CAttribute::Initialize(pData);

   //
   // The default for Not configured is false.
   //

   PSCE_PRIVILEGE_ASSIGNMENT pInspect, pTemplate;
   PSCE_NAME_LIST pnlTemplate=NULL,pnlInspect=NULL;

   pTemplate = (PSCE_PRIVILEGE_ASSIGNMENT) m_pData->GetBase();
   pInspect = (PSCE_PRIVILEGE_ASSIGNMENT) m_pData->GetSetting();

   if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) == (LONG_PTR)pTemplate || !pTemplate) {
      m_bConfigure = FALSE;
      pTemplate = NULL;
   }

   if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) == (LONG_PTR)pInspect) {
      pInspect = NULL;
   }

   if ( pTemplate ) {
      pnlTemplate = pTemplate->AssignedTo;
   }
   if ( pInspect ) {
      pnlInspect = pInspect->AssignedTo;
   }

   m_pMergeList = MergeNameStatusList(pnlTemplate, pnlInspect);

   m_bDirty=false;
}

BOOL CAttrRight::OnInitDialog()
{
   CAttribute::OnInitDialog();

   PSCE_NAME_STATUS_LIST pItem;
   HWND hCheckList;
   LRESULT nItem;

   pItem = m_pMergeList;
   hCheckList = ::GetDlgItem(m_hWnd,IDC_RIGHTS);
   ::SendMessage(hCheckList,CLM_RESETCONTENT, 0, 0);
   RECT rAnal;
   LONG lWidth;

   GetDlgItem(IDC_ANALYZED_SETTING_STATIC)->GetWindowRect(&rAnal);
//   lWidth = rAnal.right - rAnal.left / 2;
   lWidth = 64;

   ::SendMessage(hCheckList,CLM_SETCOLUMNWIDTH,0,lWidth);

   while (pItem) {
      // Store the name of the item in the item data so we can retrieve it later
      nItem = ::SendMessage(hCheckList,CLM_ADDITEM,(WPARAM) pItem->Name,(LPARAM) pItem->Name);
      ::SendMessage(hCheckList,CLM_SETSTATE,MAKELONG(nItem,1),
                    ((pItem->Status & MERGED_TEMPLATE) ? CLST_CHECKED : CLST_UNCHECKED));
      ::SendMessage(hCheckList,CLM_SETSTATE,MAKELONG(nItem,2),
                    ((pItem->Status & MERGED_INSPECT) ? CLST_CHECKDISABLED : CLST_DISABLED));
      pItem = pItem->Next;
   }

   AddUserControl( IDC_RIGHTS );
   AddUserControl( IDC_ADD );
   OnConfigure();
   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CAttrRight::OnApply()
{
   if ( !m_bReadOnly ) //Raid #388710, #471660, #471653, Yang Gao
   {
      PEDITTEMPLATE pet = NULL;
      CWnd *pCheckList = GetDlgItem(IDC_RIGHTS);
      if ( !pCheckList ) {
         return FALSE;
      }
      UpdateData(TRUE);

      int iItem;
      PSCE_NAME_STATUS_LIST pIndex;
      PSCE_NAME_LIST pTemplate=NULL;
      PSCE_NAME_LIST pInspect=NULL;
      PSCE_NAME_LIST pTemp = NULL;
      DWORD status;
      DWORD misMatch = SCE_STATUS_GOOD;

      pIndex = m_pMergeList;
      iItem = 0;
      HRESULT hr=S_OK;
      PSCE_PROFILE_INFO pspi = (PSCE_PROFILE_INFO)m_pData->GetBaseProfile();
      //
      // should not change the list for last inspection
      // only change the base
      //
      if( m_bConfigure ){
              while (pIndex) {
                     if (pCheckList->SendMessage(CLM_GETSTATE,MAKELONG(iItem,1)) & CLST_CHECKED) {

                            if ( !(pIndex->Status & MERGED_TEMPLATE) )
                                   m_bDirty = true;

                            if ( SCESTATUS_SUCCESS != SceAddToNameList(&pTemplate, pIndex->Name, lstrlen(pIndex->Name))) {
                                   hr = E_FAIL;
                                   break;
                            }
                     } else if ( pIndex->Status & MERGED_TEMPLATE ) {
                            m_bDirty = true;
                     }
                     pIndex = pIndex->Next;
                     iItem++;
              }
      }

      status = ERROR_SUCCESS;
      if ( SUCCEEDED(hr) ) {

         PSCE_PRIVILEGE_ASSIGNMENT pSetting,pBasePriv;
         LPTSTR szPrivName=NULL;

         //
         // Get privilege rights from the CResult item.
         //
         pBasePriv = (PSCE_PRIVILEGE_ASSIGNMENT) (m_pData->GetBase());
         if(pBasePriv == (PSCE_PRIVILEGE_ASSIGNMENT)ULongToPtr(SCE_NO_VALUE) ){
             pBasePriv = NULL;
         }
         pSetting = (PSCE_PRIVILEGE_ASSIGNMENT) (m_pData->GetSetting());
         if(pSetting == (PSCE_PRIVILEGE_ASSIGNMENT)ULongToPtr(SCE_NO_VALUE) ){
             pSetting = NULL;
         }


         if(!m_bConfigure){
             //
             // If not configured then
            misMatch = SCE_STATUS_NOT_CONFIGURED;
             if(pBasePriv) {
                 status = m_pSnapin->UpdateAnalysisInfo(
                                           m_pData,
                                           TRUE,
                                           &pBasePriv
                                           );
                 if(pSetting){
                    pSetting->Status = SCE_STATUS_NOT_CONFIGURED;
                 }
                 m_bDirty = TRUE;
             }
         } else {
             if ( pSetting ) {
                szPrivName = pSetting->Name;
             }

             if ( !pBasePriv ) {
                 status = m_pSnapin->UpdateAnalysisInfo(
                                           m_pData,
                                           FALSE,
                                           &pBasePriv,
                                           szPrivName
                                           );
             }
             if ( pSetting ) {
                 //
                 // Check mismatch
                 //
                 if ( !SceCompareNameList(pTemplate, pSetting->AssignedTo) ) {
                     pSetting->Status = SCE_STATUS_MISMATCH;
                 } else {
                     pSetting->Status = SCE_STATUS_GOOD;
                 }
                 misMatch = pSetting->Status;
             } else {
                 // else should NEVER occur
                 misMatch = SCE_STATUS_MISMATCH;
             }
         }


         //
         // Set mismatch status of the result item.
         //
         if(misMatch != (DWORD)m_pData->GetStatus()){
            m_pData->SetStatus(misMatch);
            m_bDirty = TRUE;
         }

         if(status != ERROR_SUCCESS){
             hr = E_FAIL;
         } else if ( pBasePriv ) {

            pTemp = pBasePriv->AssignedTo;
            pBasePriv->AssignedTo = pTemplate;
            pTemplate = NULL;
            m_bDirty = TRUE;

            SceFreeMemory(pTemp,SCE_STRUCT_NAME_LIST);
            //
            // update dirty flag
            //
            if(m_pData->GetBaseProfile()){
                m_pData->GetBaseProfile()->SetDirty( AREA_PRIVILEGES );
            }
         }
      } // failed

      SceFreeMemory(pTemplate,SCE_STRUCT_NAME_LIST);

      if ( FAILED(hr) ) {
          CString str;
          str.LoadString(IDS_SAVE_FAILED);
          m_bDirty = FALSE;
          AfxMessageBox(str);
      }
      if (m_bDirty) {
         m_pData->Update(m_pSnapin);
      }
   }

   return CAttribute::OnApply();
}

void CAttrRight::OnCancel()
{
   if ( m_pMergeList )
      SceFreeMemory(m_pMergeList,SCE_STRUCT_NAME_STATUS_LIST);
   m_pMergeList = NULL;

   //
   // Should not call base class
   //
   //CAttribute::OnCancel();
   DestroyWindow();
}

void CAttrRight::OnAdd()
{
   CGetUser gu;
   HRESULT hr=S_OK;

   if (gu.Create(GetSafeHwnd(),SCE_SHOW_SCOPE_ALL|SCE_SHOW_DIFF_MODE_OFF_DC|
                                SCE_SHOW_USERS | SCE_SHOW_LOCALGROUPS | SCE_SHOW_GLOBAL |
                                SCE_SHOW_WELLKNOWN | SCE_SHOW_BUILTIN)) {
      CWnd *pCheckList;
      PSCE_NAME_STATUS_LIST pList,pLast=NULL;
      LRESULT iItem;
      bool bFound;

      pCheckList = GetDlgItem(IDC_RIGHTS);

      PSCE_NAME_LIST pName = gu.GetUsers();
      while (pName) {
         if ( pName->Name ) {
            pList = m_pMergeList;
            pLast = NULL;
            iItem = 0;

            bFound = false;
            while (pList) {
               // If so, then make sure its "Template" box is checked
               if (lstrcmp(pList->Name,pName->Name) == 0) {
                  if (!(pCheckList->SendMessage(CLM_GETSTATE,MAKELONG(iItem,1)) & CLST_CHECKED)) {
                     m_bDirty = true;
                     pCheckList->SendMessage(CLM_SETSTATE,MAKELONG(iItem,1),CLST_CHECKED);
                  }
                  bFound = true;
                  break;
               }
               pLast = pList;
               pList = pList->Next;
               iItem++;
            }

            // Otherwise add it both to m_pMerged and to the CheckList
            if (!bFound) {

               PSCE_NAME_STATUS_LIST pNewNode;

               pNewNode = (PSCE_NAME_STATUS_LIST)LocalAlloc(0,sizeof(SCE_NAME_STATUS_LIST));
               if ( pNewNode ) {

                  pNewNode->Name = (LPTSTR)LocalAlloc(0, (lstrlen(pName->Name)+1)*sizeof(TCHAR));
                  if ( pNewNode->Name ) {
                     // This may not be a safe usage. pNewNode->Name is PWSTR, using WCHAR instead of TCHAR. Consider fix.
                     lstrcpy(pNewNode->Name, pName->Name);
                     pNewNode->Next = NULL;
                     pNewNode->Status = MERGED_TEMPLATE;
                  } else {
                     LocalFree(pNewNode);
                     pNewNode = NULL;
                  }
               }
               if ( pNewNode ) {
                  if ( pLast ) {
                     pLast->Next = pNewNode;
                  } else {
                     m_pMergeList = pNewNode;
                  }
                  pLast = pNewNode;

                  iItem = pCheckList->SendMessage(CLM_ADDITEM,(WPARAM)pLast->Name,(LPARAM)pLast->Name);
                  pCheckList->SendMessage(CLM_SETSTATE,MAKELONG(iItem,1),CLST_CHECKED);
                  pCheckList->SendMessage(CLM_SETSTATE,MAKELONG(iItem,2),CLST_DISABLED);
                  m_bDirty = true;


               } else {
                  hr = E_OUTOFMEMORY;
                  ASSERT(FALSE);
                  break;
               }
            }
         }
         pName = pName->Next;
      }
   }

   if (m_bDirty) {
      SetModified(TRUE);
   }

   if ( FAILED(hr) ) {
       CString str;
       str.LoadString(IDS_CANT_ADD_USER);
       AfxMessageBox(str);
   }
}


void CAttrRight::OnClickCheckBox(NMHDR *pNM, LRESULT *pResult) //Raid #396108, 5/17/2001
{
   SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\astring.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       AString.h
//
//  Contents:   definition of CAttrString
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_ATTRSTRING_H__76BA1B30_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_)
#define AFX_ATTRSTRING_H__76BA1B30_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "resource.h"
#include "attr.h"
#include "snapmgr.h"
/////////////////////////////////////////////////////////////////////////////
// CAttrString dialog

class CAttrString : public CAttribute
{
// Construction
public:
   CAttrString(UINT nTemplateID);   // standard constructor

   virtual void Initialize(CResult * pResult);

// Dialog Data
    //{{AFX_DATA(CAttrString)
    enum { IDD = IDD_ATTR_STRING };
    CString m_strSetting;
    CString m_strBase;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAttrString)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAttrString)
    virtual BOOL OnInitDialog();
    virtual BOOL OnApply();
    virtual BOOL OnKillActive();
    afx_msg void OnConfigure();
	afx_msg void OnChangeNew();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    BOOL m_bNoBlanks;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ATTRSTRING_H__76BA1B30_D221_11D0_9C68_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\astring.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       attrstring.cpp
//
//  Contents:   implementation of CAttrString
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "AString.h"
#include "util.h"
#include "CName.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAttrString dialog


CAttrString::CAttrString(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD), 
    m_bNoBlanks(FALSE)

{
    //{{AFX_DATA_INIT(CAttrString)
    m_strSetting = _T("");
    m_strBase = _T("");
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a167HelpIDs;
    m_uTemplateResID = IDD;
}


void CAttrString::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAttrString)
    DDX_Text(pDX, IDC_CURRENT, m_strSetting);
    DDX_Text(pDX, IDC_NEW, m_strBase);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttrString, CAttribute)
    //{{AFX_MSG_MAP(CAttrString)
    ON_BN_CLICKED(IDC_CONFIGURE, OnConfigure)
    ON_EN_CHANGE(IDC_NEW, OnChangeNew)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttrString message handlers

BOOL CAttrString::OnInitDialog()
{
   CAttribute::OnInitDialog();

   AddUserControl(IDC_NEW);
   OnConfigure();

   if(m_pData && (m_pData->GetID() == IDS_NEW_ADMIN || m_pData->GetID() == IDS_NEW_GUEST)) //Raid #502069, yanggao
   {
      GetDlgItem(IDC_NEW)->SendMessage(EM_LIMITTEXT, MAX_USERNAME, 0);
   } 
   return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CAttrString::OnConfigure()
{
   CAttribute::OnConfigure();

   CWnd *item = 0;

   if (m_bNoBlanks) {
      item = GetDlgItem(IDOK);
      if (item) {
         if (m_bConfigure) {
            item->EnableWindow(!m_strBase.IsEmpty());
         } else  {
            item->EnableWindow(TRUE);
         }
      }
   }
}

void CAttrString::Initialize(CResult * pResult)
{
   CAttribute::Initialize(pResult);

   pResult->GetDisplayName( NULL, m_strSetting, 2 );

   if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) == pResult->GetBase() ||
      NULL == pResult->GetBase() ){
      m_bConfigure = FALSE;
   } else {
      m_bConfigure = TRUE;
      pResult->GetDisplayName( NULL, m_strBase,    1 );
   }
   if (m_pData->GetID() == IDS_NEW_ADMIN ||
       m_pData->GetID() == IDS_NEW_GUEST) {
      m_bNoBlanks = TRUE;
   } else {
      m_bNoBlanks = FALSE;
   }

}

BOOL CAttrString::OnApply()
{
   if ( !m_bReadOnly )
   {
      LONG_PTR dw = 0;
      UpdateData(TRUE);

      BOOL bChanged=TRUE;

      m_strBase.TrimLeft();
      m_strBase.TrimRight();

      if (!m_bConfigure) 
      {
         dw = 0;
         if ( (LONG_PTR)ULongToPtr(SCE_NO_VALUE) == m_pData->GetBase() ||
              0 == m_pData->GetBase() ) 
         {
             bChanged = FALSE;
         }
      } 
      else 
      {
         dw = (LONG_PTR)(LPCTSTR)m_strBase;
         if ( m_pData->GetBase() && dw &&
              (LONG_PTR)ULongToPtr(SCE_NO_VALUE) != m_pData->GetBase() &&
              _wcsicmp((LPTSTR)(m_pData->GetBase()), (LPTSTR)dw) == 0 ) 
         {
             bChanged = FALSE;
         }
      }

      if ( bChanged ) 
      {
          if ( m_pData->GetSetting() == m_pData->GetBase() &&
               m_pData->GetSetting() ) 
          {
              // a good item, need take the base into setting
              m_pSnapin->TransferAnalysisName(m_pData->GetID());
          }

          m_pData->SetBase(dw);

          DWORD dwStatus = m_pSnapin->SetAnalysisInfo(m_pData->GetID(),dw, m_pData);
          m_pData->SetStatus(dwStatus);
          m_pData->Update(m_pSnapin);
      }
   }

   return CAttribute::OnApply();
}


void CAttrString::OnChangeNew()
{
   CWnd *cwnd = 0;
   if (m_bNoBlanks) {
      UpdateData(TRUE);

      cwnd = GetDlgItem(IDOK);
      if (cwnd) {
         cwnd->EnableWindow(!m_strBase.IsEmpty());
      }
   }

   SetModified(TRUE);
}

BOOL CAttrString::OnKillActive() {
   if ( m_bNoBlanks && m_bConfigure ) //Raid #407190
   {
      UpdateData(TRUE);
      m_strBase.TrimLeft();
      m_strBase.TrimRight();
      UpdateData(FALSE);

      PCWSTR szInvalidCharSet = INVALID_ACCOUNT_NAME_CHARS;
      if (m_strBase.IsEmpty() || -1 != m_strBase.FindOneOf(szInvalidCharSet) )
      {
         CString str;
         CString charsWithSpaces;
         int nIndex = 0;
         while (szInvalidCharSet[nIndex])
         {
            charsWithSpaces += szInvalidCharSet[nIndex];
            charsWithSpaces += L"  ";
            nIndex++;
         }
         str.FormatMessage (IDS_EMPTY_NAME_STRING, charsWithSpaces);
         AfxMessageBox(str);
         GetDlgItem(IDC_NEW)->SetFocus();
         return FALSE;
      }
   }
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\attr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       attr.cpp
//
//  Contents:   implementation of CAttribute
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "Attr.h"
#include "snapmgr.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAttribute dialog
void TrimNumber(CString &str)
{
   int i = str.Find( L' ' );
   if( i > 0 ){
      str = str.Left(i);
   }
}

DWORD CAttribute::m_nDialogs = 0;

CAttribute::CAttribute(UINT nTemplateID)
: CSelfDeletingPropertyPage(nTemplateID ? nTemplateID : IDD), 
    m_pSnapin(NULL), 
    m_pData(NULL), 
    m_bConfigure(TRUE), 
    m_uTemplateResID(nTemplateID ? nTemplateID : IDD)
{
    //{{AFX_DATA_INIT(CAttribute)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_nDialogs++;
    m_pHelpIDs = (DWORD_PTR)a173HelpIDs;
}

CAttribute::~CAttribute()
{
   if (m_pData) 
   {
      if( m_pSnapin )
      {
         m_pSnapin->ReleasePropertyPage(m_pData);
      }
      m_pData->Release();
   }
   m_nDialogs--;

   if (m_pSnapin) //Raid #464871, Yanggao, 10/09/2001
   {
      m_pSnapin->Release();
   }
}

void CAttribute::DoDataExchange(CDataExchange* pDX)
{
    CSelfDeletingPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAttribute)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    DDX_Check(pDX,IDC_CONFIGURE,m_bConfigure);
    DDX_Text(pDX,IDC_TITLE,m_strTitle);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAttribute, CSelfDeletingPropertyPage)
    //{{AFX_MSG_MAP(CAttribute)
    ON_WM_LBUTTONDBLCLK()
    ON_BN_CLICKED(IDC_CONFIGURE, OnConfigure)
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp) //Bug 139470, Yanggao
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAttribute message handlers
BOOL CAttribute::OnInitDialog ()
{
    if( m_pData && m_pSnapin) //Raid #482059, Yanggao, 10/16/2001
    {
       m_pSnapin->AddPropertyPageRef(m_pData);
    }

    CSelfDeletingPropertyPage::OnInitDialog ();

    return TRUE;
}

void CAttribute::Initialize(CResult * pResult)
{
   m_pData = pResult;
   if (m_pData) {
      m_pData->AddRef();
   }
}

void CAttribute::SetSnapin(CSnapin * pSnapin)
{
   ASSERT(m_pSnapin==NULL);

   if ( !m_pSnapin )
   {
       m_pSnapin = pSnapin;
       if (m_pSnapin) 
       {
          m_hwndParent = pSnapin->GetParentWindow();
          m_pSnapin->AddRef(); //Raid #464871, Yanggao, 10/09/2001
       }
   }
}

void CAttribute::OnCancel()
{
}


BOOL CAttribute::OnApply()
{
   if ( !m_bReadOnly )
   {
       UpdateData();

       //
       // If we get here we've applied our modifications for this page
       // Since it's possible that we got here via Apply we want to be
       // able to reapply if any further changes are made
       //
       SetModified(FALSE);
       CancelToClose();
   }

   return TRUE;
}

/*----------------------------------------------------------------------------
Method:     CAttribute::EnableUserControls

Synopsis:   Enables or disables this control user control array.

Arugments:  [bEnable]   - If TRUE then enable the controls otherwise, disable
                            them.
----------------------------------------------------------------------------*/
void CAttribute::EnableUserControls (BOOL bEnable)
{
    HWND hwnd = 0;

    if (QueryReadOnly()) 
    {
       bEnable = FALSE;
       hwnd = ::GetDlgItem( this->m_hWnd, IDOK );
       if (hwnd) 
       {
          ::EnableWindow(hwnd, FALSE);
       }
       hwnd = ::GetDlgItem( this->m_hWnd, IDC_CONFIGURE );
       if (hwnd) 
       {
          ::EnableWindow(hwnd, FALSE);
       }
    }

    for( int i = 0; i < m_aUserCtrlIDs.GetSize(); i++)
    {
        hwnd = ::GetDlgItem( this->m_hWnd, m_aUserCtrlIDs[i] );
        if(hwnd)
        {
            //
            // The reason that there are two calls below that apparently
            // do the same thing is that all of the controls in our dialogs
            // respond to the ::EnableWindow() call except the CheckList
            // control, which will respond to the ::SendMessage(WM_ENABLE).
            // And conversley, all the other controls will not respond to
            // the ::SendMessage(WM_ENABLE).  It shouldn't be a problem
            // to make both calls but it is definitely something to watch.
            //
            // The reason the CheckList control has a problem is that when
            // it is told to disable itself, it disables all of its child windows
            // (check boxes) but re-enables its main window within the WM_ENABLE
            // handling so that it can scroll in the disabled state.  Then when we
            // try to call ::EnableWindow on it, Windows or MFC thinks the
            // window is already enabled so it doesn't send it a WM_ENABLE
            // message.  So if we send the WM_ENABLE message directly it
            // circumvents the other processing in ::EnableWindow that results
            // in the WM_ENABLE message not being sent.
            //
            ::SendMessage(hwnd, WM_ENABLE, (WPARAM) bEnable, (LPARAM) 0);
            ::EnableWindow(hwnd, bEnable);
        }
    }
}


/*----------------------------------------------------------------------------
Method:     CAttribute::OnConfigure

Synopsis:   Enable/Disable controls based on new state of the
            "Define this attribute...." checkbox

----------------------------------------------------------------------------*/
void CAttribute::OnConfigure() 
{
   UpdateData(TRUE);

   // If the configure check box isn't visible then don't do anything.
   // Raid #603833, yanggao, 4/17/2002.
   CWnd *pConfigure = GetDlgItem(IDC_CONFIGURE);
   if (!pConfigure || (!pConfigure->IsWindowVisible() && this->IsWindowVisible()))
   {
      return;
   }

   SetModified(TRUE);

   EnableUserControls(m_bConfigure);

   if (m_bConfigure && m_pData) 
   {
      switch(m_pData->GetType()) 
      {
         case ITEM_PROF_REGVALUE:
         case ITEM_REGVALUE:
         case ITEM_LOCALPOL_REGVALUE:
            SetInitialValue(m_pData->GetRegDefault());
            break;

         default:
            SetInitialValue(m_pData->GetProfileDefault());
            break;
      }


      UpdateData(FALSE);
   }
}


/*----------------------------------------------------------------------------
Method:     CAttribute::SetConfigure

Synopsis:   Set the configure state and

Arugments:  [bConfigure] - Configure is TRUE or FALSE.

----------------------------------------------------------------------------*/
void CAttribute::SetConfigure( BOOL bConfigure )
{
   m_bConfigure = bConfigure;
   UpdateData(FALSE);
   OnConfigure();
}

void CAttribute::OnLButtonDblClk(UINT nFlags, CPoint point)
{
    CSelfDeletingPropertyPage::OnLButtonDblClk(nFlags, point);

    //
    // If the configure check box isn't visible then don't do anything
    // This dialog can't be configured
    //
    CWnd *pConfigure = GetDlgItem(IDC_CONFIGURE);
    if (!pConfigure || !pConfigure->IsWindowVisible() 
        || !pConfigure->IsWindowEnabled() ) //Raid #461948, Yang Gao, 8/27/2001
    {
        return;
    }


    for( int i = 0; i < m_aUserCtrlIDs.GetSize(); i++ )
    {
        CWnd *pWnd = GetDlgItem( m_aUserCtrlIDs[i] );
        if(pWnd && pWnd == pConfigure) //Raid #529238, #580052, yanggao
        {
            CRect rect;
            pWnd->GetWindowRect(&rect);
            ScreenToClient(&rect);

            if(rect.PtInRect( point ) && !pWnd->IsWindowEnabled() )
            {
                    SetConfigure( TRUE );
                    break;
            }
            break;
        }
    }

}

BOOL CAttribute::OnHelp(WPARAM wParam, LPARAM lParam)
{
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        //Raid #499556, 12/12/2001, yanggao, turn off help for title.
        if( -1 != pHelpInfo->iCtrlId && IDC_TITLE != pHelpInfo->iCtrlId //Bug 311884, Yanggao
           && IDC_WARNING != pHelpInfo->iCtrlId && IDC_STATIC_DESCRIPTION !=pHelpInfo->iCtrlId //Raid #525153,526450,526422,526477, 2/27/2002, yanggao
           && IDC_NO_MEMBERS != pHelpInfo->iCtrlId && IDC_NO_MEMBER_OF != pHelpInfo->iCtrlId
           && IDC_NAME != pHelpInfo->iCtrlId && IDC_SETTING != pHelpInfo->iCtrlId
           && IDC_LI_TITLE != pHelpInfo->iCtrlId )
            this->DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    return TRUE;
}

void CAttribute::DoContextHelp (HWND hWndControl)
{
    // Display context help for a control
    if ( !::WinHelp (
            hWndControl,
            GetSeceditHelpFilename(),
            HELP_WM_HELP,
            m_pHelpIDs))
    {

    }
}

BOOL CAttribute::OnContextHelp(WPARAM wParam, LPARAM lParam) //Bug 139470, Yanggao
{
    HMENU hMenu = CreatePopupMenu();
    if( hMenu )
    {
        CString str;
        str.LoadString(IDS_WHAT_ISTHIS); 
        if( AppendMenu(hMenu, MF_STRING, IDM_WHAT_ISTHIS, str) )
        {
            int itemID = TrackPopupMenu(hMenu, 
                                TPM_LEFTALIGN|TPM_TOPALIGN|TPM_RETURNCMD|
                                TPM_LEFTBUTTON|TPM_RIGHTBUTTON,
                                LOWORD(lParam), HIWORD(lParam), 0, (HWND)wParam, NULL);
            if( IDM_WHAT_ISTHIS == itemID ) //Raid #139470, 4/11/2001
            {
                itemID = 0;
                if( ((HWND)wParam) != this->m_hWnd )
                {
                    //Raid #499556, 12/12/2001, yanggao, turn off help for title.
                    itemID = ::GetDlgCtrlID((HWND)wParam);
                    if( itemID != 0 && -1 != itemID && IDC_TITLE != itemID )
                    {
                        ::WinHelp((HWND)wParam,
                                    GetSeceditHelpFilename(),
                                    HELP_WM_HELP,
                                    m_pHelpIDs);
                    }
                }
                else
                {
                    POINT pos;
                    pos.x = LOWORD(lParam);
                    pos.y = HIWORD(lParam);
                    ScreenToClient( &pos );
                    CWnd* pWnd = ChildWindowFromPoint(pos, CWP_SKIPINVISIBLE);
                    if( pWnd )
                    {
                        //Raid #499556, 12/12/2001, yanggao, turn off help for title.
                        itemID = ::GetDlgCtrlID((HWND)wParam);
                        if( itemID != 0 && -1 != itemID && IDC_TITLE != itemID )
                        {
				            ::WinHelp(pWnd->m_hWnd,
                                        GetSeceditHelpFilename(),
                                        HELP_WM_HELP,
                                        m_pHelpIDs);
                        }
                    }
                }
            }
        }
    }
    return TRUE;
}

//------------------------------------------------------------
// implementation for CModelessSceEditor

//------------------------------------------------------------
//------------------------------------------------------------
CModelessSceEditor::CModelessSceEditor (bool bIsContainer,
      DWORD flag,
      HWND hParent,
      SE_OBJECT_TYPE seType,
      LPCWSTR lpszObjName) 
: m_pThread(NULL)
{
    m_MLShtData.bIsContainer = bIsContainer;
    m_MLShtData.flag = flag;
    m_MLShtData.hwndParent = hParent;
    m_MLShtData.SeType = seType,
    m_MLShtData.strObjectName = lpszObjName;
}

//------------------------------------------------------------
//------------------------------------------------------------
CModelessSceEditor::~CModelessSceEditor()
{
    m_pThread->PostThreadMessage(WM_QUIT,0,0); //Raid #619921, yanggao, 5/14/2002
}

//------------------------------------------------------------
// will create a modeless sce editor inside its own thread m_pThread
//------------------------------------------------------------
void CModelessSceEditor::Create (PSECURITY_DESCRIPTOR* ppSeDescriptor,
   SECURITY_INFORMATION* pSeInfo,
   HWND* phwndSheet)
{
    *phwndSheet = NULL;     // prepare to fail

    if (NULL == m_pThread)
    {
        m_pThread = (CModelessDlgUIThread*)AfxBeginThread(RUNTIME_CLASS(CModelessDlgUIThread));
        if (NULL == m_pThread)
        {
            CString strMsg;
            strMsg.LoadString(IDS_FAIL_CREATE_UITHREAD);
            AfxMessageBox(strMsg);
            return;
        }
        m_pThread->WaitTillRun();   // will suspend this thread till the m_pThread start running
    }

    m_MLShtData.ppSeDescriptor = ppSeDescriptor;
    m_MLShtData.pSeInfo = pSeInfo;
    m_MLShtData.phwndSheet = phwndSheet;

    m_pThread->PostThreadMessage(SCEM_CREATE_MODELESS_SHEET, (WPARAM)(&m_MLShtData), 0);
}

//------------------------------------------------------------
//------------------------------------------------------------
void CModelessSceEditor::Destroy(HWND hwndSheet)
{
    if (::IsWindow(hwndSheet))
    {
        m_pThread->PostThreadMessage(SCEM_DESTROY_WINDOW, (WPARAM)hwndSheet, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\attr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       Attr.h
//
//  Contents:   definition of CModelessSceEditor & CAttribute
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_ATTR_H__CC37D278_ED8E_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
#define AFX_ATTR_H__CC37D278_ED8E_11D0_9C6E_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "resource.h"
#include "cookie.h"
#include "SelfDeletingPropertyPage.h"

typedef struct tagModelessSheetData
{
    bool bIsContainer;
    DWORD flag;
    HWND hwndParent;
    SE_OBJECT_TYPE SeType;
    CString strObjectName;
    PSECURITY_DESCRIPTOR* ppSeDescriptor;
    SECURITY_INFORMATION* pSeInfo;
    HWND* phwndSheet;
} MLSHEET_DATA, *PMLSHEET_DATA;

// this class is created for displaying modeless security editor dialog.
// under MMC, modeless dialog won't work unless it is running inside its own
// thread. When multiple sce editors can be launched for easy comparsions,
// it is highly preferred that we launch it modeless. We must use this class
// to create such modeless sce editors. It should be able to use one class to create
// multiple modeless dialogs. However, this is not always working because of MMC
// limitations. That is why the function Reset is not implemented at this time.
//************************************************************************************
// Important: this class depends on CUIThread implementations even though it only
// has a CWinThread pointer. That is because of AfxBeginThread's return type
//************************************************************************************
// How to use this class:
// (1) Create an instance when you need to create such a modeless dialog
// (2) Call Create function to display the modeless. Usually the caller provides
//      ppSeDescriptor, pSeInfo, and phwndSheet. The caller wants to have a handle
//      to the dialog because we need to make sure that its parent is not allowed
//      to go away while the modeless is up and running.
// (3) When certain actions should force the modeless dialog to go away, call Destroy
//      function (passing the modeless dialog's handle) to destroy the dialog.
// (4) destruct the instance when no longer in use
// See examples inside aservice.cpp/.h
class CModelessDlgUIThread;
class CModelessSceEditor
{
public:
    CModelessSceEditor(bool fIsContainer, DWORD flag, HWND hParent, SE_OBJECT_TYPE seType, LPCWSTR lpszObjName);
    virtual ~CModelessSceEditor();

    void Reset(bool fIsContainer, DWORD flag, HWND hParent, SE_OBJECT_TYPE seType, LPCWSTR lpszObjName);

    void Create(PSECURITY_DESCRIPTOR* ppSeDescriptor, SECURITY_INFORMATION* pSeInfo, HWND* phwndSheet);
    void Destroy(HWND hwndSheet);

protected:

    MLSHEET_DATA m_MLShtData;

    CModelessDlgUIThread* m_pThread;
};

/////////////////////////////////////////////////////////////////////////////
// CAttribute dialog
void TrimNumber(CString &str);
class CAttribute : public CSelfDeletingPropertyPage
{
// Construction
public:
    CAttribute(UINT nTemplateID);   // standard constructor
    virtual ~CAttribute();

    virtual void EnableUserControls( BOOL bEnable );

    void AddUserControl( UINT uID )
    { 
       m_aUserCtrlIDs.Add(uID); 
    };

// Dialog Data
    //{{AFX_DATA(CAttribute)
    enum { IDD = IDD_ANALYZE_SECURITY };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA

    void SetReadOnly(BOOL bRO) 
    { 
       m_bReadOnly = bRO; 
    }
    BOOL QueryReadOnly() 
    { 
       return m_bReadOnly; 
    }
   

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAttribute)
	protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
   virtual BOOL OnInitDialog ();

   virtual void Initialize(CResult * pResult);
   virtual void SetSnapin(CSnapin * pSnapin);
   virtual void SetTitle(LPCTSTR sz) 
   { 
      m_strTitle = sz; 
   };
   void SetConfigure( BOOL bConfigure );
// Implementation
protected:
    CSnapin * m_pSnapin;

    // Generated message map functions
    //{{AFX_MSG(CAttribute)
        virtual void OnCancel();
        virtual BOOL OnApply();
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
   virtual afx_msg void OnConfigure();
	//}}AFX_MSG
    afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
    afx_msg BOOL OnContextHelp(WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()

    void DoContextHelp (HWND hWndControl);

    virtual void SetInitialValue (DWORD_PTR dw) 
    { 
       dw; 
    };
   CResult *m_pData;
   HWND m_hwndParent;
   CUIntArray m_aUserCtrlIDs;   // User control IDS.
   BOOL m_bConfigure;
   BOOL m_bReadOnly;
   CString m_strTitle;

   // every dialog that wants to handle help, you have to assign appropriately this member
   DWORD_PTR    m_pHelpIDs;
   // every dialog muse in its constructor add this line: m_uTemplateResID = IDD
   UINT         m_uTemplateResID;

public:
   static DWORD m_nDialogs;
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ATTR_H__CC37D278_ED8E_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\caudit.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       caudit.cpp
//
//  Contents:   implementation of CConfigAudit
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "CAudit.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfigAudit dialog


CConfigAudit::CConfigAudit(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD)
{
    //{{AFX_DATA_INIT(CConfigAudit)
    m_fFailed = FALSE;
    m_fSuccessful = FALSE;
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a180HelpIDs;
    m_uTemplateResID = IDD;
}


void CConfigAudit::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfigAudit)
    DDX_Check(pDX, IDC_FAILED, m_fFailed);
    DDX_Check(pDX, IDC_SUCCESSFUL, m_fSuccessful);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigAudit, CAttribute)
    //{{AFX_MSG_MAP(CConfigAudit)
        ON_BN_CLICKED(IDC_FAILED, OnFailed)
        ON_BN_CLICKED(IDC_SUCCESSFUL, OnSuccessful)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigAudit message handlers

BOOL CConfigAudit::OnApply()
{
   if ( !m_bReadOnly )
   {
      LONG_PTR dw = 0;
      UpdateData(TRUE);
      if (!m_bConfigure) 
         dw = (LONG_PTR)ULongToPtr(SCE_NO_VALUE);
      else 
      {
         if (m_fSuccessful)
            dw |= AUDIT_SUCCESS;
         
         if (m_fFailed)
            dw |= AUDIT_FAILURE;
      }
       m_pData->SetBase(dw);
      SetProfileInfo(m_pData->GetID(),dw,m_pData->GetBaseProfile());

      m_pData->Update(m_pSnapin);
   }

   return CAttribute::OnApply();
}


void
CConfigAudit::Initialize(CResult * pResult)
{
   CAttribute::Initialize(pResult);
   LONG_PTR dw = pResult->GetBase();
   m_bConfigure = (dw != (LONG_PTR)ULongToPtr(SCE_NO_VALUE));
   if (m_bConfigure) 
   {
      SetInitialValue((DWORD_PTR)dw);
   }
}

void
CConfigAudit::SetInitialValue(DWORD_PTR dw) 
{
   m_fSuccessful = (dw & AUDIT_SUCCESS) != 0;
   m_fFailed = (dw & AUDIT_FAILURE) != 0;
}

BOOL CConfigAudit::OnInitDialog()
{
    CAttribute::OnInitDialog();

    AddUserControl(IDC_SUCCESSFUL);
    AddUserControl(IDC_FAILED);
    EnableUserControls(m_bConfigure);
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CConfigAudit::OnFailed()
{
        SetModified(TRUE);
}

void CConfigAudit::OnSuccessful()
{
        SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\caudit.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       CAudit.h
//
//  Contents:   definition of CConfigAudit
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_CAUDIT_H__4CF5E61F_E353_11D0_9C6D_00C04FB6C6FA__INCLUDED_)
#define AFX_CAUDIT_H__4CF5E61F_E353_11D0_9C6D_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "resource.h"
#include "attr.h"
/////////////////////////////////////////////////////////////////////////////
// CConfigAudit dialog

class CConfigAudit : public CAttribute
{
// Construction
public:
	virtual void Initialize(CResult *pResult);
   virtual void SetInitialValue(DWORD_PTR dw);
	CConfigAudit(UINT nTemplateID);   // standard constructor
  
// Dialog Data
	//{{AFX_DATA(CConfigAudit)
	enum { IDD = IDD_CONFIG_AUDIT };
	BOOL	m_fFailed;
	BOOL	m_fSuccessful;
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConfigAudit)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConfigAudit)
	virtual BOOL OnApply();
	virtual BOOL OnInitDialog();
	afx_msg void OnFailed();
	afx_msg void OnSuccessful();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CAUDIT_H__4CF5E61F_E353_11D0_9C6D_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\attrprop.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       attrprop.cpp
//
//  Contents:   implementation of code for adding property pages
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "wsecmgr.h"
#include "resource.h"
#include <accctrl.h>
#include "servperm.h"
#include "stdafx.h"
#include "wsecmgr.h"
#include "snapmgr.h"
#include "util.h"
#include "UIThread.h"
#include "attr.h"
#include "aaudit.h"
#include "aenable.h"
#include "AMember.h"
#include "anumber.h"
#include "AObject.h"
#include "ARet.h"
#include "ARight.h"
#include "aservice.h"
#include "astring.h"
#include "CAudit.h"
#include "CEnable.h"
#include "CGroup.h"
#include "CName.h"
#include "CNumber.h"
#include "cobject.h"
#include "CPrivs.h"
#include "CRet.h"
#include "cservice.h"
#include "regvldlg.h"
#include "perfanal.h"
#include "applcnfg.h"
#include "wrapper.h"
#include "locdesc.h"
#include "profdesc.h"
#include "newprof.h"
#include "laudit.h"
#include "lenable.h"
#include "lret.h"
#include "lnumber.h"
#include "lstring.h"
#include "lright.h"
#include "achoice.h"
#include "cchoice.h"
#include "lchoice.h"
#include "dattrs.h"
#include "lflags.h"
#include "aflags.h"
#include "multisz.h"
#include "precpage.h"

//+--------------------------------------------------------------------------
//
//  Function:   CloneAttrDialog
//
//  Synopsis:   Create a new CAttribute object of the appropriate class for
//              the type and pData passed in
//
//  Arguments:  [type]  - The type of data the CAttribute will represent
//              [pData] - More information about the CAttribute
//              [bGP]   - True to use CDomain* instead of CConfig* dialogs
//
//
//---------------------------------------------------------------------------
CAttribute *CloneAttrDialog(CResult *pData, BOOL bGP) 
{
   switch(pData->GetType()) 
   {
      case ITEM_ANAL_SERV:
         return new CAnalysisService;

      case ITEM_B2ON:
         return new CAttrAudit;

      case ITEM_BON:
      case ITEM_BOOL:
         return new CAttrEnable (0);

      case ITEM_FILESD:
      case ITEM_REGSD:
         return new CAttrObject;

      case ITEM_DW:
         return new CAttrNumber (0);

      case ITEM_GROUP:
         // PropertySheet based
         break;

      case ITEM_PRIVS:
         return new CAttrRight;

      case ITEM_PROF_B2ON:
         return bGP ? new CDomainAudit : new CConfigAudit (0);

      case ITEM_PROF_BOOL:
         return bGP ? new CDomainEnable : new CConfigEnable (0);

      case ITEM_PROF_FILESD:
      case ITEM_PROF_REGSD:
         return bGP ? new CDomainObject : new CConfigObject (0);

      case ITEM_PROF_DW:
         return bGP ? new CDomainNumber : new CConfigNumber (0);

      case ITEM_PROF_GROUP:
         return bGP ? new CDomainGroup : new CConfigGroup (0);

      case ITEM_PROF_PRIVS:
         return bGP ? new CDomainPrivs : new CConfigPrivs (0);

      case ITEM_PROF_REGVALUE:
         switch(pData->GetID()) 
         {
            case SCE_REG_DISPLAY_NUMBER:
               return bGP ? new CDomainRegNumber : new CConfigRegNumber (0);

            case SCE_REG_DISPLAY_STRING:
               return bGP ? new CDomainRegString(0) : new CConfigRegString (0); //Raid #381309, 4/31/2001

            case SCE_REG_DISPLAY_FLAGS:
               return bGP ? new CDomainRegFlags : new CConfigRegFlags (0);

            case SCE_REG_DISPLAY_CHOICE:
               return bGP ? new CDomainChoice : new CConfigChoice (0);

            case SCE_REG_DISPLAY_MULTISZ:
                if ( bGP )
                    return new CDomainRegMultiSZ;
                else
                    return new CConfigRegMultiSZ;

            default:
               return bGP ? new CDomainRegEnable : new CConfigRegEnable (0);
         }

      case ITEM_PROF_RET:
         return bGP ? new CDomainRet : new CConfigRet (0);

      case ITEM_PROF_SERV:
         return bGP ? new CDomainService : new CConfigService (0);

      case ITEM_PROF_SZ:
         return bGP ? new CDomainName : new CConfigName (0);

      case ITEM_REGVALUE:
         switch (pData->GetID()) 
         {
            case SCE_REG_DISPLAY_NUMBER:
               return new CAttrRegNumber;

            case SCE_REG_DISPLAY_STRING:
               return new CAttrRegString (0);

            case SCE_REG_DISPLAY_CHOICE:
               return new CAttrChoice;

            case SCE_REG_DISPLAY_FLAGS:
               return new CAttrRegFlags;

            case SCE_REG_DISPLAY_MULTISZ:
               return new CAttrRegMultiSZ;

            default:
               return new CAttrRegEnable;
         }

      case ITEM_RET:
         return new CAttrRet (0);

      case ITEM_SZ:
         return new CAttrString (0);

      case ITEM_LOCALPOL_RET:
         return new CLocalPolRet;

      case ITEM_LOCALPOL_SZ:
         return new CLocalPolString;

      case ITEM_LOCALPOL_B2ON:
         return new CLocalPolAudit;

      case ITEM_LOCALPOL_BON:
      case ITEM_LOCALPOL_BOOL:
         return new CLocalPolEnable;

      case ITEM_LOCALPOL_DW:
         return new CLocalPolNumber;

      case ITEM_LOCALPOL_PRIVS:
         return new CLocalPolRight;

      case ITEM_LOCALPOL_REGVALUE:
         switch (pData->GetID()) 
         {
            case SCE_REG_DISPLAY_NUMBER:
               return new CLocalPolRegNumber;

            case SCE_REG_DISPLAY_STRING:
               return new CLocalPolRegString (0);

            case SCE_REG_DISPLAY_MULTISZ:
               return new CLocalPolRegMultiSZ;

            case SCE_REG_DISPLAY_CHOICE:
               return new CLocalPolChoice;

            case SCE_REG_DISPLAY_FLAGS:
               return new CLocalPolRegFlags;

            default:
               return new CLocalPolRegEnable;
         }
   }

   return 0;
}

BOOL IsPointerType(CResult *pData) 
{
   switch (pData->GetType()) 
   {
      case ITEM_LOCALPOL_PRIVS:
      case ITEM_LOCALPOL_SZ:
         return TRUE;

      case ITEM_REGVALUE:
         switch (pData->GetID()) 
         {
            case SCE_REG_DISPLAY_STRING:
            case SCE_REG_DISPLAY_MULTISZ:
               return TRUE;

            default:
               return FALSE;
         }
         break;

      default:
         break;
   }
   return FALSE;
}

HRESULT CSnapin::AddAttrPropPages(LPPROPERTYSHEETCALLBACK pCallback,
                          CResult *pData,
                          LONG_PTR handle) 
{
   ASSERT(pCallback);
   ASSERT(pData);
   if (!pCallback || !pData) 
   {
      return E_POINTER;
   }

   BOOL           bGP = ( (GetModeBits() & MB_SINGLE_TEMPLATE_ONLY) == MB_SINGLE_TEMPLATE_ONLY );
   BOOL           bReadOnly = ( (GetModeBits() & MB_READ_ONLY) == MB_READ_ONLY );
   RESULT_TYPES   type = pData->GetType();
   CAttribute*    pAttr = NULL;
   HRESULT        hr = S_OK;

   //
   // If the item has an entry from global policy then treat it as read only
   //
   if ((GetModeBits() & MB_LOCALSEC) == MB_LOCALSEC) 
   {
      bGP = FALSE;
      if (type == ITEM_LOCALPOL_REGVALUE) 
      {
         SCE_REGISTRY_VALUE_INFO *pRegValue = NULL;
         pRegValue = (PSCE_REGISTRY_VALUE_INFO)pData->GetSetting();
         if ( pRegValue && pRegValue->Status != SCE_STATUS_NOT_CONFIGURED ) 
         {
            bReadOnly = TRUE;
         }
      } 
	   else if (IsPointerType(pData)) 
	   {
         //
         // If there is a setting it's a pointer; if not, it is NULL
         //
         if (pData->GetSetting()) 
		   {
            bReadOnly = TRUE;
         }
      } 
	   else if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) != pData->GetSetting()) 
	   {
         bReadOnly = TRUE;
      }
   }
   if (type == ITEM_GROUP) 
   {
      CAttrMember *pMemberPage = new CAttrMember;
      CAttrMember *pMemberOfPage = new CAttrMember;


      if ( pMemberPage && pMemberOfPage) 
	   {
         pMemberPage->Initialize(pData);
         pMemberPage->SetMemberType(GROUP_MEMBERS);
         pMemberPage->SetSnapin(this);
         pMemberPage->SetSibling(pMemberOfPage);
         HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pMemberPage->m_psp);
         if (hPage) 
		   {
             hr = pCallback->AddPage (hPage);
             ASSERT (SUCCEEDED (hr)); //This is not safe. hr should be checked in order to do pMemberPage = NULL.
             if( SUCCEEDED (hr) ) //Raid #550912, yanggao.
             {
                 // the pointer is already added to the sheet
                 pMemberPage = NULL;
             }
         } 
		   else 
         {
            // Oops, fail to create the property sheet page
            hr = E_FAIL;
         }

         if ( SUCCEEDED(hr) ) 
         {
            pMemberOfPage->Initialize(pData);
            pMemberOfPage->SetMemberType(GROUP_MEMBER_OF);
            pMemberOfPage->SetSnapin(this);
            pMemberOfPage->SetSibling(pMemberPage);
            hPage = MyCreatePropertySheetPage (&pMemberOfPage->m_psp); //Raid #prefast
            if (hPage) 
			   {
                hr = pCallback->AddPage (hPage);
                ASSERT (SUCCEEDED (hr)); //This is not safe. hr should be checked in order to do pMemberOfPage = NULL.
                if( SUCCEEDED (hr) )//Raid #550912, yanggao.
                {
                    // the pointer is already added to the sheet
                    pMemberOfPage = NULL;
                }
            } 
			   else 
            {
                hr = E_FAIL;
            }
         }
      } 
	   else 
	   {
          hr = E_OUTOFMEMORY;
      }

      if ( pMemberPage ) 
	   {
          delete pMemberPage;
      }

      if ( pMemberOfPage ) 
	   {
          delete pMemberOfPage;
      }
   } 
   else 
   {
      pAttr = CloneAttrDialog(pData,bGP);
      if (pAttr) 
	   {
         pAttr->SetSnapin(this);
         pAttr->Initialize(pData);
         pAttr->SetReadOnly(bReadOnly);
         pAttr->SetTitle(pData->GetAttrPretty());
         HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pAttr->m_psp);
         if (hPage) 
		   {
            hr = pCallback->AddPage (hPage);
            ASSERT (SUCCEEDED (hr)); //This is not safe. hr should be checked in order to delete pAttr.
            if( !SUCCEEDED (hr) ) //Raid #550912, yanggao.
            {
                delete pAttr;
            }
         } 
		   else 
		   {
             //
             // fail to create the property sheet
             //
             delete pAttr;
             hr = E_FAIL;
         }
      } 
	   else 
	   {
         hr = E_OUTOFMEMORY;
      }
   }

   if ( SUCCEEDED(hr) ) 
   {
      //
      // In RSOP mode we need to add a precedence page too
      //
      if ((GetModeBits() & MB_RSOP) == MB_RSOP) 
	   {
         CPrecedencePage *ppp = new CPrecedencePage;
         if (ppp) 
		   {
            ppp->SetTitle(pData->GetAttrPretty());
            ppp->Initialize(pData,GetWMIRsop());
            HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&ppp->m_psp);
            if (hPage) 
			   {
               hr = pCallback->AddPage (hPage);
               ASSERT (SUCCEEDED (hr)); //This is not safe. hr should be checked in order to delete ppp.
               if( !SUCCEEDED (hr) )//Raid #550912, yanggao.
               {
                  delete ppp;
               }
            } 
			   else 
			   {
                //
                // if the property sheet fails to be created, should free the buffer
                //
                delete ppp;
                hr = E_FAIL;
            }
         } 
		   else 
		   {
            hr = E_OUTOFMEMORY;
         }
      }
   }

   return hr;
}


HRESULT CComponentDataImpl::AddAttrPropPages(LPPROPERTYSHEETCALLBACK pCallback,
                                     CFolder *pData,
                                     LONG_PTR handle) 
{
   HRESULT hr=E_FAIL;
   CString strName;

   ASSERT(pCallback);
   ASSERT(pData);
   if (!pCallback || !pData) 
   {
      return E_POINTER;
   }

   BOOL bReadOnly = ((GetModeBits() & MB_READ_ONLY) == MB_READ_ONLY);
   pData->GetDisplayName(strName,0);

   CAttrObject *pAttr = new CAttrObject;
   if (pAttr) 
   {
      pAttr->Initialize(pData,this);
      pAttr->SetTitle(strName);
      pAttr->SetReadOnly(bReadOnly);
      HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pAttr->m_psp);
      if ( hPage ) 
      {
         hr = pCallback->AddPage (hPage);
         ASSERT (SUCCEEDED (hr)); //This is not safe. hr should be checked in order to delete pAttr.
         if( !SUCCEEDED (hr) )//Raid #550912, yanggao.
         {
            delete pAttr;
         }
      } 
	   else 
      {
         delete pAttr;
         hr = E_FAIL;
      }
   } 
   else 
   {
      hr = E_OUTOFMEMORY;
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cchoice.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cchoice.cpp
//
//  Contents:   implementation of CConfigChoice
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "CChoice.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfigChoice dialog


CConfigChoice::CConfigChoice(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD)
{
   //{{AFX_DATA_INIT(CConfigChoice)
   //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR)a236HelpIDs;
   m_uTemplateResID = IDD;
}


void CConfigChoice::DoDataExchange(CDataExchange* pDX)
{
   CAttribute::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CConfigChoice)
   DDX_Control(pDX, IDC_CHOICES, m_cbChoices);
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigChoice, CAttribute)
   //{{AFX_MSG_MAP(CConfigChoice)
   ON_CBN_SELCHANGE(IDC_CHOICES, OnSelchangeChoices)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigChoice message handlers

void CConfigChoice::Initialize(CResult * pResult)
{
   CAttribute::Initialize(pResult);

   m_pChoices = pResult->GetRegChoices();

   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(pResult->GetBase());

   if ( prv && prv->Value) //Raid #372939, 4/20/2001; #395353, #396098, 5/16/2001 
   {
       m_bConfigure = TRUE;
   } else {
       m_bConfigure = FALSE;
   }
}

BOOL CConfigChoice::OnInitDialog()
{
   CAttribute::OnInitDialog();

   PREGCHOICE pChoice = m_pChoices;
   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());
   int nIndex = 0;

   ASSERT(prv);
   ASSERT(pChoice);
   if (!prv || !pChoice) {
      return TRUE;
   }

   CString strOut;
   DWORD dwValue = pChoice->dwValue; //Raid #404000

   if (prv->Value)
   {
      dwValue = (DWORD)_ttoi(prv->Value);
   }

   while(pChoice) {
      m_cbChoices.InsertString(nIndex,pChoice->szName);
      if (dwValue == pChoice->dwValue) {
         m_cbChoices.SetCurSel(nIndex);
      }
      m_cbChoices.SetItemData(nIndex++,pChoice->dwValue);
      pChoice = pChoice->pNext;
   }

   AddUserControl(IDC_CHOICES);
   EnableUserControls(m_bConfigure);
   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CConfigChoice::OnApply()
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;
      int nIndex = 0;

      UpdateData(TRUE);
      if (!m_bConfigure) 
         dw = SCE_NO_VALUE;
      else 
      {
         nIndex = m_cbChoices.GetCurSel();
         if (CB_ERR != nIndex)
            dw = (DWORD)m_cbChoices.GetItemData(nIndex);
      }
      PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());

      //
      // this address should never be NULL
      //
      ASSERT(prv != NULL);
      if ( prv ) 
      {
         PWSTR pTmp=NULL;

         if ( dw != SCE_NO_VALUE ) 
         {
            CString strTmp;
            // allocate buffer
            strTmp.Format(TEXT("%d"), dw);
            pTmp = (PWSTR)LocalAlloc(0, (strTmp.GetLength()+1)*sizeof(TCHAR));

            if ( pTmp )
               //This may not be a safe usage, using sizeof(WCHAR) instead of sizeof(TCHAR). Consider fix.
               wcscpy(pTmp,(LPCTSTR)strTmp);
            else 
            {
               // can't allocate buffer, error!!
               return FALSE;
            }
         }

         if ( prv->Value )
            LocalFree(prv->Value);
         
         prv->Value = pTmp;

         m_pData->SetBase((LONG_PTR)prv);
         m_pData->Update(m_pSnapin);
      }
   }

   return CAttribute::OnApply();
}

void CConfigChoice::OnSelchangeChoices()
{
   SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cchoice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       CChoice.h
//
//  Contents:   definition of CConfigChoice
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_CCHOICE_H__B03DDCA9_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_)
#define AFX_CCHOICE_H__B03DDCA9_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CConfigChoice dialog

class CConfigChoice : public CAttribute
{
// Construction
public:
   virtual void Initialize(CResult * pResult);
//   virtual void SetInitialValue(DWORD_PTR dw) {};
   CConfigChoice(UINT nTemplateID);   // standard constructor

// Dialog Data
   //{{AFX_DATA(CConfigChoice)
	enum { IDD = IDD_CONFIG_REGCHOICES };
	CComboBox	m_cbChoices;
	//}}AFX_DATA


// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CConfigChoice)
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CConfigChoice)
   virtual BOOL OnInitDialog();
   virtual BOOL OnApply();
   afx_msg void OnSelchangeChoices();
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

   PREGCHOICE m_pChoices;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CCHOICE_H__B03DDCA9_7F54_11D2_B136_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cenable.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cenable.cpp
//
//  Contents:   implementation of CConfigEnable
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "CEnable.h"
#include "util.h"
#include "regvldlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfigEnable dialog
CConfigEnable::CConfigEnable(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD)
{
    //{{AFX_DATA_INIT(CConfigEnable)
    m_nEnabledRadio = -1;
    //}}AFX_DATA_INIT
    m_fNotDefine = TRUE;
    m_pHelpIDs = (DWORD_PTR)a182HelpIDs;
    m_uTemplateResID = IDD;
}


void CConfigEnable::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfigEnable)
    DDX_Radio(pDX, IDC_ENABLED, m_nEnabledRadio);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigEnable, CAttribute)
    //{{AFX_MSG_MAP(CConfigEnable)
        ON_BN_CLICKED(IDC_DISABLED, OnDisabled)
        ON_BN_CLICKED(IDC_ENABLED, OnEnabled)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigEnable message handlers

void CConfigEnable::Initialize(CResult *pResult)
{
   CAttribute::Initialize(pResult);

   LONG_PTR dw = pResult->GetBase();
   if ( (LONG_PTR)ULongToPtr(SCE_NO_VALUE) == dw ||
        (BYTE)SCE_NO_VALUE == (BYTE)dw ) 
   {
      m_bConfigure = FALSE;
   } 
   else 
   {
      m_bConfigure = TRUE;
      //
      // BUG 145561 - dw is 0 vs non-0 boolean, not 0 vs 1
      //
      SetInitialValue((DWORD_PTR)(dw != 0));
   }
}

void CConfigEnable::SetInitialValue(DWORD_PTR dw) {
   //
   // Make sure we only set the INITIAL value and
   // don't reset an already-set value.
   //
   if (-1 == m_nEnabledRadio && m_fNotDefine) //Raid #413225, 6/11/2001, Yanggao
   {
      if( (DWORD_PTR)ULongToPtr(SCE_NO_VALUE) == dw ) //Raid #403460
      {
          return;
      }
      m_nEnabledRadio = (dw ? 0 : 1);
   }
}

BOOL CConfigEnable::OnApply()
{
   if ( !m_bReadOnly )
   {
      LONG_PTR dw=0;
      UpdateData(TRUE);

      if (!m_bConfigure)
         dw = (LONG_PTR)ULongToPtr(SCE_NO_VALUE);
      else 
      {
         switch(m_nEnabledRadio) 
         {
         // ENABLED
         case 0:
            dw = 1;
            break;
         // DISABLED
         case 1:
            dw = 0;
            break;
         }
      }

      m_pData->SetBase(dw);
      SetProfileInfo(m_pData->GetID(),dw,m_pData->GetBaseProfile());

      m_pData->Update(m_pSnapin);
   }

   return CAttribute::OnApply();
}


BOOL CConfigEnable::OnInitDialog()
{
   CAttribute::OnInitDialog();

   //Raid #651344, yanggao, 8/9/2002
   long hID = m_pData->GethID();
   if( (hID >= IDS_SYS_LOG_GUEST && hID<= IDS_APP_LOG_GUEST) ||
       (IDS_FORCE_LOGOFF == hID ) )
   {
      CWnd *pWarn = GetDlgItem(IDC_WARNING);
      if (pWarn)
      {
         CString strWarning;
         switch(hID)
         {
         case IDS_SYS_LOG_GUEST:
         case IDS_SEC_LOG_GUEST:
         case IDS_APP_LOG_GUEST:
            strWarning.LoadString(IDS_EVENTLOG_WARNING);
            break;
         case IDS_FORCE_LOGOFF: //Raid #753618, yanggao, 12/23/2002
            strWarning.LoadString(IDS_FORCE_LOGOFF_WARNING);
            break;
         }
         pWarn->SetWindowText(strWarning);
         pWarn->ShowWindow(SW_SHOW);

         pWarn = GetDlgItem(IDC_WARNING_ICON);
         if (pWarn)
         {
            pWarn->ShowWindow(SW_SHOW);
         }
      }
   }

   AddUserControl(IDC_ENABLED);
   AddUserControl(IDC_DISABLED);
   OnConfigure();
   return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CConfigEnable::OnDisabled()
{
   int prevValue = m_nEnabledRadio; //Raid #490995, Yanggao
   UpdateData(); 
   if(m_nEnabledRadio != prevValue)
   {
      SetModified(TRUE);
   }
}

void CConfigEnable::OnEnabled()
{
   int prevValue = m_nEnabledRadio; //Raid #490995, Yanggao
   UpdateData(); 
   if(m_nEnabledRadio != prevValue)
   {
      SetModified(TRUE);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cenable.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       CEnable.h
//
//  Contents:   definition of CConfigEnable
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_CENABLE_H__7F9B3B38_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
#define AFX_CENABLE_H__7F9B3B38_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "attr.h"
/////////////////////////////////////////////////////////////////////////////
// CConfigEnable dialog

class CConfigEnable : public CAttribute
{
// Construction
public:
	CConfigEnable(UINT nTemplateID);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CConfigEnable)
	enum { IDD = IDD_CONFIG_ENABLE };
	int		m_nEnabledRadio;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConfigEnable)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConfigEnable)
	virtual BOOL OnApply();
	virtual BOOL OnInitDialog();
	afx_msg void OnDisabled();
	afx_msg void OnEnabled();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	BOOL m_fNotDefine;
	virtual void Initialize(CResult *pdata);
   virtual void SetInitialValue(DWORD_PTR dw);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CENABLE_H__7F9B3B38_ECEB_11D0_9C6E_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cgroup.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       CGroup.h
//
//  Contents:   definition of CConfigGroup
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_CGROUP_H__8606032F_F7C3_11D0_9C6F_00C04FB6C6FA__INCLUDED_)
#define AFX_CGROUP_H__8606032F_F7C3_11D0_9C6F_00C04FB6C6FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#include "resource.h"
#include "attr.h"

/////////////////////////////////////////////////////////////////////////////
// CConfigGroup dialog

class CConfigGroup : public CAttribute
{
// Construction
public:
    CConfigGroup(UINT nTemplateID);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CConfigGroup)
    enum { IDD = IDD_CONFIG_MEMBERSHIP };
    CButton m_btTitleMembers;
    CButton m_btTitleMemberOf;
    CListBox    m_lbMembers;
    CListBox    m_lbMemberOf;
    CEdit   m_eNoMembers;
    CEdit   m_eNoMemberOf;
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CConfigGroup)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CConfigGroup)
    afx_msg void OnAddMember();
    afx_msg void OnAddMemberof();
    afx_msg void OnRemoveMember();
    afx_msg void OnRemoveMemberof();
    afx_msg void OnSelChangeMem();
    afx_msg void OnSelChangeMemof();
    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    bool m_fDirty;
    BOOL m_bAlias;
    BOOL m_bNoMembers;
    BOOL m_bNoMemberOf;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CGROUP_H__8606032F_F7C3_11D0_9C6F_00C04FB6C6FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cflags.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       CFlags.h
//
//  Contents:   definition of CConfigRegFlags
//                              
//----------------------------------------------------------------------------
#if !defined(AFX_CFLAGS_H__94E730BE_2055_486E_9781_7EBB479CB806__INCLUDED_)
#define AFX_CFLAGS_H__94E730BE_2055_486E_9781_7EBB479CB806__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CConfigRegFlags dialog

class CConfigRegFlags : public CAttribute
{
// Construction
public:
	CConfigRegFlags(UINT nTemplateID);   // standard constructor

   virtual void Initialize(CResult * pResult);

// Dialog Data
	//{{AFX_DATA(CConfigRegFlags)
	enum { IDD = IDD_CONFIG_REGFLAGS };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConfigRegFlags)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	afx_msg void OnClickCheckBox(NMHDR *pNM, LRESULT *pResult);

	// Generated message map functions
	//{{AFX_MSG(CConfigRegFlags)
	virtual BOOL OnApply();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

   PREGFLAGS m_pFlags;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CFLAGS_H__94E730BE_2055_486E_9781_7EBB479CB806__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cflags.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cflags.cpp
//
//  Contents:   implementation of CConfigRegFlags
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "attr.h"
#include "chklist.h"
#include "util.h"
#include "CFlags.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfigRegFlags dialog


CConfigRegFlags::CConfigRegFlags(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD), m_pFlags(NULL)
{
	//{{AFX_DATA_INIT(CConfigRegFlags)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR) a236HelpIDs;
    m_uTemplateResID = IDD;
}


void CConfigRegFlags::DoDataExchange(CDataExchange* pDX)
{
	CAttribute::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConfigRegFlags)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigRegFlags, CAttribute)
	//{{AFX_MSG_MAP(CConfigRegFlags)
	//}}AFX_MSG_MAP
    ON_NOTIFY(CLN_CLICK, IDC_CHECKBOX, OnClickCheckBox)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigRegFlags message handlers
void CConfigRegFlags::Initialize(CResult * pResult)
{
   CAttribute::Initialize(pResult);

   m_pFlags = pResult->GetRegFlags();

   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(pResult->GetBase());

   if ( prv && prv->Value ) {
       m_bConfigure = TRUE;
   } else {
       m_bConfigure = FALSE;
   }
}

BOOL CConfigRegFlags::OnInitDialog()
{
   CAttribute::OnInitDialog();
   CWnd *wndCL = NULL;
   DWORD fFlags = 0;
   PREGFLAGS pFlags = m_pFlags;
   PSCE_REGISTRY_VALUE_INFO prv = (PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());
   if (prv && prv->Value) {
      fFlags = (DWORD)_ttoi(prv->Value);
   }
   int nIndex = 0;

   CString strOut;

   wndCL = GetDlgItem(IDC_CHECKBOX);
   if (!wndCL) {
      //
      // This should never happen
      //
      ASSERT(wndCL);
      return FALSE;
   }
   wndCL->SendMessage(CLM_RESETCONTENT,0,0);

   while(pFlags) {
      nIndex = (int) wndCL->SendMessage(CLM_ADDITEM,
                                        (WPARAM)pFlags->szName,
                                        (LPARAM)pFlags->dwValue);
      if (nIndex != -1) {
         BOOL bSet;
         bSet = ((fFlags & pFlags->dwValue) == pFlags->dwValue);
         wndCL->SendMessage(CLM_SETSTATE,
                            MAKELONG(nIndex,1),
                            bSet ? CLST_CHECKED : CLST_UNCHECKED);
      }
      pFlags = pFlags->pNext;
   }

   AddUserControl(IDC_CHECKBOX);
   EnableUserControls(m_bConfigure);
   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CConfigRegFlags::OnApply() 
{
   if ( !m_bReadOnly )
   {
      DWORD dw = 0;
      CWnd *wndCL = NULL;
      DWORD fFlags = 0;

      UpdateData(TRUE);

      wndCL = GetDlgItem(IDC_CHECKBOX);
      ASSERT(wndCL != NULL);

      if (!m_bConfigure || !wndCL) 
         dw = SCE_NO_VALUE;
      else 
      {
         int nItems = (int) wndCL->SendMessage(CLM_GETITEMCOUNT,0,0);
         for(int i=0;i<nItems;i++) 
         {
            dw = (DWORD) wndCL->SendMessage(CLM_GETSTATE,MAKELONG(i,1)); 
            if (CLST_CHECKED == dw)
               fFlags |= (DWORD)wndCL->SendMessage(CLM_GETITEMDATA,i);
         }
      }
      PSCE_REGISTRY_VALUE_INFO prv=(PSCE_REGISTRY_VALUE_INFO)(m_pData->GetBase());

      //
      // this address should never be NULL
      //
      ASSERT(prv != NULL);
      if ( prv ) 
      {
         if ( prv->Value )
            LocalFree(prv->Value);
         
         prv->Value = NULL;

         if ( dw != SCE_NO_VALUE ) 
         {
            CString strTmp;
            // allocate buffer
            strTmp.Format(TEXT("%d"), fFlags);
            prv->Value = (PWSTR)LocalAlloc(0, (strTmp.GetLength()+1)*sizeof(TCHAR));

            if ( prv->Value )
               //This is a safe usage.
               lstrcpy(prv->Value,(LPCTSTR)strTmp);
            else 
            {
               // can't allocate buffer, error!!
               return FALSE;
            }
         }

         m_pData->SetBase((LONG_PTR)prv);
         m_pData->Update(m_pSnapin);
      }
   }

   return CAttribute::OnApply();	
}


void CConfigRegFlags::OnClickCheckBox(NMHDR *pNM, LRESULT *pResult) //Raid #391172, 5/11/2001
{
   SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cname.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cname.cpp
//
//  Contents:   implementation of CConfigName
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "CName.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

PCWSTR g_pcszNEWLINE = L"\x00d\x00a";

/////////////////////////////////////////////////////////////////////////////
// CConfigName dialog


CConfigName::CConfigName(UINT nTemplateID)
: CAttribute(nTemplateID ? nTemplateID : IDD), 
    m_bNoBlanks(FALSE)

{
    //{{AFX_DATA_INIT(CConfigName)
    m_strName = _T("");
    m_bConfigure = TRUE;
    //}}AFX_DATA_INIT
    m_pHelpIDs = (DWORD_PTR)a183HelpIDs;
    m_uTemplateResID = IDD;
}

CConfigName::~CConfigName ()
{
}

void CConfigName::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfigName)
  //  DDX_Radio(pDX, IDC_ACCEPT, m_nAcceptCurrentRadio);
      DDX_Text(pDX, IDC_NAME, m_strName);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigName, CAttribute)
    //{{AFX_MSG_MAP(CConfigName)
    ON_BN_CLICKED(IDC_CONFIGURE, OnConfigure)
   ON_EN_CHANGE(IDC_NAME, OnChangeName)
   ON_MESSAGE(WM_CLOSE, OnClose)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigName message handlers

void CConfigName::OnClose() //Raid #487527, Yanggao. Add handler for WM_CLOSE.
{
    GetParent()->PostMessage(WM_CLOSE);
    CPropertyPage::OnClose();
}

void CConfigName::Initialize(CResult * pResult)
{
   CAttribute::Initialize(pResult);

   if ((LONG_PTR)ULongToPtr(SCE_NO_VALUE) == pResult->GetBase() ||
       0 == pResult->GetBase() ) 
   {
      m_strName = _T("");
      m_bConfigure = FALSE;
   } 
   else 
   {
      m_bConfigure = TRUE;
      m_strName = (LPTSTR) pResult->GetBase();
   }

   if (m_pData->GetID() == IDS_NEW_ADMIN ||
       m_pData->GetID() == IDS_NEW_GUEST) 
   {
      m_bNoBlanks = TRUE;
   } 
   else
      m_bNoBlanks = FALSE;
}

BOOL CConfigName::OnApply()
{
   if ( !m_bReadOnly )
   {
      LONG_PTR dw = 0;
      CString  szDoubleNewLine (g_pcszNEWLINE);
      szDoubleNewLine += g_pcszNEWLINE;

      UpdateData(TRUE);

      m_strName.TrimLeft();
      m_strName.TrimRight();

      // 249188 SCE UI: allows adding empty lines to REG_MULTI_SZ fields
      // Replace all double newlines with single newlines.  This has the effect
      // of deleting empty lines.
      while (m_strName.Replace (szDoubleNewLine, g_pcszNEWLINE) != 0);

      UpdateData (FALSE);

      if (!m_bConfigure)
         dw = (LONG_PTR)ULongToPtr(SCE_NO_VALUE);
      else
         dw = (LONG_PTR)(LPCTSTR)m_strName;

      if ( SetProfileInfo(m_pData->GetID(),dw,m_pData->GetBaseProfile()) ) 
      {
          switch ( m_pData->GetID() ) 
	      {
          case IDS_NEW_ADMIN:
              dw = (LONG_PTR)(m_pData->GetBaseProfile()->pTemplate->NewAdministratorName);
              break;
          case IDS_NEW_GUEST:
              dw = (LONG_PTR)(m_pData->GetBaseProfile()->pTemplate->NewGuestName);
               break;
          default:
              dw = 0;
              break;
          }

          m_pData->SetBase(dw);
          m_pData->Update(m_pSnapin);
      }
   }

   return CAttribute::OnApply();
}

void CConfigName::OnConfigure()
{
   CAttribute::OnConfigure();

   if(m_bConfigure && m_pData) //Raid #367756, 4/13/2001
   {
      UpdateData(TRUE);  
      if( m_strName.IsEmpty() )
      {
         switch(m_pData->GetType()) 
         {
            case ITEM_PROF_REGVALUE:
                {
                    DWORD_PTR dw = (DWORD_PTR)m_pData->GetRegDefault();
                    LPTSTR sz = SZToMultiSZ((PCWSTR)dw);

                    m_strName = sz;
                    if(sz)
                    {
                        LocalFree(sz);
                    }
                    ((CWnd*)(GetDlgItem(IDC_NAME)))->SetWindowText(m_strName);
                    break;
                }
            default:
                break;
         }
      }
   }

   CWnd *cwnd = 0;

   if (m_bNoBlanks) 
   {
      cwnd = GetDlgItem(IDOK);
      if (cwnd) 
      {
         if (m_bConfigure)
            cwnd->EnableWindow(!m_strName.IsEmpty());
         else
            cwnd->EnableWindow(TRUE);
      }
   }
}

BOOL CConfigName::OnInitDialog()
{
    CAttribute::OnInitDialog();

    AddUserControl(IDC_NAME);
    OnConfigure();

    if(m_pData->GetID() == IDS_NEW_ADMIN || m_pData->GetID() == IDS_NEW_GUEST) //Raid #490548, yanggao
    {
       GetDlgItem(IDC_NAME)->SendMessage(EM_LIMITTEXT, MAX_USERNAME, 0);
    } 
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CConfigName::OnChangeName()
{
   CWnd *cwnd = 0;

   SetModified(TRUE);
   if (m_bNoBlanks) 
   {
      UpdateData(TRUE);

      cwnd = GetDlgItem(IDOK);
      if (cwnd)
         cwnd->EnableWindow(!m_strName.IsEmpty());
   }
}

BOOL CConfigName::OnKillActive() 
{
   if (m_bNoBlanks && !m_bReadOnly && m_bConfigure ) //Raid #406748
   {
      UpdateData(TRUE);
      m_strName.TrimLeft(); //Raid #406738
      m_strName.TrimRight();
      UpdateData(FALSE);

      PCWSTR szInvalidCharSet = INVALID_ACCOUNT_NAME_CHARS; //Raid #498448, yanggao, 11/21/2001
      if (m_strName.IsEmpty() || -1 != m_strName.FindOneOf(szInvalidCharSet) )
      {
         //Raid #313721, Yang Gao, 3/29/2001
         CString str;
         CString charsWithSpaces;
         int nIndex = 0;
         while (szInvalidCharSet[nIndex])
         {
            charsWithSpaces += szInvalidCharSet[nIndex];
            charsWithSpaces += L"  ";
            nIndex++;
         }
         str.FormatMessage (IDS_EMPTY_NAME_STRING, charsWithSpaces);
         AfxMessageBox(str);
         GetDlgItem(IDC_NAME)->SetFocus();
         return FALSE;
      }
   }
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\chklist.h ===
//-----------------------------------------------------------------------------
//
// chklist.h - Definitions and prototypes for the checklist pseudo-control
//
// Copyright 1996-2001, Microsoft Corporation
//
//
//-----------------------------------------------------------------------------

#ifndef _CHKLIST_H_
#define _CHKLIST_H_

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

//
// CheckList window class name
//
#define WC_CHECKLIST        "CHECKLIST_SCE"

//BOOL RegisterCheckListWndClass(void);


//
// CheckList check states
//
#define CLST_UNCHECKED      0   // == BST_UNCHECKED
#define CLST_CHECKED        1   // == BST_CHECKED
#define CLST_DISABLED       2   // == BST_INDETERMINATE
#define CLST_CHECKDISABLED  (CLST_CHECKED | CLST_DISABLED)

//
// CheckList window styles
//
#define CLS_1CHECK          0x0001
#define CLS_2CHECK          0x0002
//#define CLS_3CHECK          0x0003
//#define CLS_4CHECK          0x0004
#define CLS_CHECKMASK       0x000f

//
// CheckList messages
//
// row is 0-based
// column is 1-based
//
#define CLM_SETCOLUMNWIDTH  (WM_USER + 1)   // lParam = width (dlg units) of a check column (default=32)
#define CLM_ADDITEM         (WM_USER + 2)   // wParam = pszName, lParam = item data, return = row
#define CLM_GETITEMCOUNT    (WM_USER + 3)   // no parameters
#define CLM_SETSTATE        (WM_USER + 4)   // wParam = row/column, lParam = state
#define CLM_GETSTATE        (WM_USER + 5)   // wParam = row/column, return = state
#define CLM_SETITEMDATA     (WM_USER + 6)   // wParam = row, lParam = item data
#define CLM_GETITEMDATA     (WM_USER + 7)   // wParam = row, return = item data
#define CLM_RESETCONTENT    (WM_USER + 8)   // no parameters
#define CLM_GETVISIBLECOUNT (WM_USER + 9)   // no parameters, return = # of visible rows
#define CLM_GETTOPINDEX     (WM_USER + 10)  // no parameters, return = index of top row
#define CLM_SETTOPINDEX     (WM_USER + 11)  // wParam = index of new top row
#define CLM_ENSUREVISIBLE   (WM_USER + 12)  // wParam = index of item to make fully visible

//
// CheckList notification messages
//
#define CLN_CLICK           (0U-1000U)      // lparam = PNM_CHECKLIST

typedef struct _NM_CHECKLIST
{
    NMHDR hdr;
    int iItem;                              // row (0-based)
    int iSubItem;                           // column (1-based)
    DWORD dwState;
    DWORD_PTR dwItemData;
} NM_CHECKLIST, *PNM_CHECKLIST;


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _CHKLIST_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cgroup.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-2001.
//
//  File:       cgroup.cpp
//
//  Contents:   implementation of CConfigGroup
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "wsecmgr.h"
#include "CGroup.h"
#include "Addgrp.h"
#include "GetUser.h"
#include "wrapper.h"
#include "util.h"
#include "snapmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define TAB_TITLE_LENGTH	40
/////////////////////////////////////////////////////////////////////////////
// CConfigGroup dialog


CConfigGroup::CConfigGroup(UINT nTemplateID)
: CAttribute (nTemplateID ? nTemplateID : IDD), 
    m_fDirty(false), 
    m_bNoMembers(FALSE), 
    m_bNoMemberOf(FALSE)

{
    //{{AFX_DATA_INIT(CConfigGroup)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
   m_pHelpIDs = (DWORD_PTR)a107HelpIDs;
   m_uTemplateResID = IDD;
}


void CConfigGroup::DoDataExchange(CDataExchange* pDX)
{
    CAttribute::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfigGroup)
    DDX_Control(pDX, IDC_MEMBERS, m_lbMembers);
    DDX_Control(pDX, IDC_MEMBEROF, m_lbMemberOf);
    DDX_Control(pDX, IDC_NO_MEMBERS, m_eNoMembers);
    DDX_Control(pDX, IDC_NO_MEMBER_OF, m_eNoMemberOf);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigGroup, CAttribute)
    //{{AFX_MSG_MAP(CConfigGroup)
    ON_BN_CLICKED(IDC_ADD_MEMBER, OnAddMember)
    ON_BN_CLICKED(IDC_ADD_MEMBEROF, OnAddMemberof)
    ON_BN_CLICKED(IDC_REMOVE_MEMBER, OnRemoveMember)
    ON_BN_CLICKED(IDC_REMOVE_MEMBEROF, OnRemoveMemberof)
    ON_LBN_SELCHANGE(IDC_MEMBERS, OnSelChangeMem)
    ON_LBN_SELCHANGE(IDC_MEMBEROF, OnSelChangeMemof)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigGroup message handlers

void CConfigGroup::OnAddMember()
{
   CSCEAddGroup gu(this);
   gu.m_sTitle.LoadString( IDS_ADDMEMBER );
   gu.m_sDescription.LoadString(IDS_GROUP_MEMBERS_HEADER);

   gu.m_dwFlags = SCE_SHOW_USERS | SCE_SHOW_GLOBAL | SCE_SHOW_WELLKNOWN;
   gu.SetModeBits(m_pSnapin->GetModeBits());

   PSCE_NAME_LIST pName = 0;

   if( IDD_CONFIG_MEMBERSHIP == m_uTemplateResID ) //Raid #475075, Yang Gao
   {
       gu.m_fCheckName = FALSE;
   }

   CThemeContextActivator activator;
   if (gu.DoModal() == IDOK ) 
   {
      pName = gu.GetUsers();
      PWSTR pLongestName = NULL; //Raid #496574, yanggao
      int maxlength = 0;
      int curlength = 0;
      while(pName) 
      {
         if (LB_ERR == m_lbMembers.FindStringExact(-1,pName->Name)) 
         {
             if (LB_ERR == m_lbMemberOf.FindStringExact(-1,pName->Name)) 
             {
                if (m_bNoMembers) 
                {
                   m_bNoMembers = FALSE;
                   m_lbMembers.ShowWindow(SW_SHOW);
                   m_eNoMembers.ShowWindow(SW_HIDE);
                }
                m_lbMembers.AddString(pName->Name);
                m_fDirty = true;
                
                curlength = lstrlen(pName->Name);
                if( curlength > maxlength )
                {
                   maxlength = curlength;
                   pLongestName = pName->Name;
                }
             } else {
                 // already in the Members Of list, shouldn't add to members
             }
         }
         pName = pName->Next;
      }
      if( pLongestName )
      {
         CClientDC hDC(&m_lbMembers);
         HFONT hFontOld = (HFONT)hDC.SelectObject((HFONT)GetStockObject(DEFAULT_GUI_FONT));
         CSize cSize;
         GetTextExtentPoint32(hDC, pLongestName, lstrlen(pLongestName), &cSize);
         hDC.SelectObject(hFontOld);
         if( cSize.cx > m_lbMembers.GetHorizontalExtent() )
         {
            m_lbMembers.SetHorizontalExtent(cSize.cx+10);
         }
      }
      if( m_fDirty ) //Raid #497350, yanggao, 11/20/2001
      {
         SetModified(TRUE);
      }
      m_lbMembers.EnableWindow(TRUE); //Raid 472244, Yang Gao, 10/22/2001
   }
}

void CConfigGroup::OnAddMemberof()
{
   CSCEAddGroup gu;
   PSCE_NAME_LIST pName = 0;
   DWORD nFlag = 0;

    if ( IsDomainController() ) 
    {
        nFlag = SCE_SHOW_GROUPS | SCE_SHOW_ALIASES;
    } else {
        nFlag = SCE_SHOW_ALIASES | SCE_SHOW_BUILTIN | SCE_SHOW_LOCALGROUPS; //Raid #464603
    }

   gu.m_dwFlags = nFlag;
   gu.SetModeBits(m_pSnapin->GetModeBits());
   gu.m_sTitle.LoadString( IDS_GROUP_MEMBER_OF_HEADER );

   if( IDD_CONFIG_MEMBERSHIP == m_uTemplateResID ) //Raid #475075, Yang Gao
   {
       gu.m_fCheckName = FALSE;
   }

   CThemeContextActivator activator;
   if (gu.DoModal() == IDOK ) 
   {
      pName = gu.GetUsers();
      PWSTR pLongestName = NULL; //Raid #496574, yanggao
      int maxlength = 0;
      int curlength = 0;
      while(pName) 
      {
         if (LB_ERR == m_lbMemberOf.FindStringExact(-1,pName->Name)) 
         {
             if (LB_ERR == m_lbMembers.FindStringExact(-1,pName->Name)) 
             {
                if (m_bNoMemberOf) 
                {
                   m_bNoMemberOf = FALSE;
                   m_lbMemberOf.ShowWindow(SW_SHOW);
                   m_eNoMemberOf.ShowWindow(SW_HIDE);
                }
                m_lbMemberOf.AddString(pName->Name);
                m_fDirty = true;

                curlength = lstrlen(pName->Name);
                if( curlength > maxlength )
                {
                   maxlength = curlength;
                   pLongestName = pName->Name;
                }
             } 
             else 
             {
                 // already find in the members list, shouldn't add it
                 // otherwise, it will be in a circle
             }
         }
         pName = pName->Next;
      }
      if( pLongestName )
      {
         CClientDC hDC(&m_lbMemberOf);
         HFONT hFontOld = (HFONT)hDC.SelectObject((HFONT)GetStockObject(DEFAULT_GUI_FONT));
         CSize cSize;
         GetTextExtentPoint32(hDC, pLongestName, lstrlen(pLongestName), &cSize);
         hDC.SelectObject(hFontOld);
         if( cSize.cx > m_lbMemberOf.GetHorizontalExtent() )
         {
            m_lbMemberOf.SetHorizontalExtent(cSize.cx+10);
         }
      }
      if( m_fDirty ) //Raid #497350, yanggao, 11/20/2001
      {
         SetModified(TRUE);
      }
      m_lbMemberOf.EnableWindow(TRUE); //Raid 472244, Yang Gao, 10/22/2001
   }
}

void CConfigGroup::OnRemoveMember()
{
   int cbItems = m_lbMembers.GetSelCount();
   if (cbItems > 0) 
   {
      int* pnItems = new int [cbItems];
      if ( pnItems ) 
      {
          m_lbMembers.GetSelItems(cbItems,pnItems);

          m_fDirty = true;
          SetModified(TRUE);

          while(cbItems--) 
          {
             m_lbMembers.DeleteString(pnItems[cbItems]);
          }

          delete[] pnItems;
      }
   }
   if (0 == m_lbMembers.GetCount()) 
   {
      m_bNoMembers = TRUE;
      m_lbMembers.ShowWindow(SW_HIDE);
      m_eNoMembers.ShowWindow(SW_SHOW);
      m_eNoMembers.EnableWindow(FALSE); 
   }

   CWnd* pCur = GetDlgItem(IDC_REMOVE_MEMBER); //Raid 472244, Yanggao, 10/23/2001
   if( pCur )
   {
      CWnd* pPrev = pCur->GetWindow(GW_HWNDPREV);
      if( pPrev )
      {
         this->GotoDlgCtrl(pPrev); 
         pCur->EnableWindow(FALSE); //Raid 467886, Yang Gao, 9/18/2001
      }
   }
}

void CConfigGroup::OnRemoveMemberof()
{
   int cbItems = m_lbMemberOf.GetSelCount();
   if (cbItems > 0) 
   {
      int* pnItems = new int [cbItems];
      if ( pnItems ) 
      {
          m_lbMemberOf.GetSelItems(cbItems,pnItems);

          m_fDirty = true;
          SetModified(TRUE);
          while(cbItems--) 
          {
             m_lbMemberOf.DeleteString(pnItems[cbItems]);
          }

          delete[] pnItems;
      }
   }
   if (0 == m_lbMemberOf.GetCount()) 
   {
      m_bNoMemberOf = TRUE;
      m_lbMemberOf.ShowWindow(SW_HIDE);
      m_eNoMemberOf.ShowWindow(SW_SHOW);
      m_eNoMemberOf.EnableWindow(FALSE); 
   }

   CWnd* pCur = GetDlgItem(IDC_REMOVE_MEMBEROF); //Raid 472244, Yanggao, 10/23/2001
   if( pCur )
   {
      CWnd* pPrev = pCur->GetWindow(GW_HWNDPREV);
      if( pPrev )
      {
         this->GotoDlgCtrl(pPrev); 
         pCur->EnableWindow(FALSE); //Raid 467886, Yang Gao, 9/18/2001
      }
   }
}
/*//////////////////////////////////////////////////////////////////////////////
    Method:     OnApply

    Synopsis:   Save all changes to for the group

    Arguments:  None

    Returns:    None

////////////////////////////////////////////////////////////////////////////////*/
BOOL CConfigGroup::OnApply()
{
   if ( !m_bReadOnly )
   {
      PSCE_GROUP_MEMBERSHIP pgm = 0;
      PSCE_NAME_LIST pNames = 0;
      CString strItem;
      int cItems = 0;
      int i = 0;

      if (m_fDirty) 
      {
         //
         // the group pointer is saved in the ID field
         //
         pgm = (PSCE_GROUP_MEMBERSHIP) (m_pData->GetID());

         //
         // should not free the old buffer first because
         // creation of the new buffer may fail
         //
         PSCE_NAME_LIST pTemp1=NULL, pTemp2=NULL;
         DWORD err=ERROR_SUCCESS;

         if (!m_bNoMembers) 
         {
            cItems = m_lbMembers.GetCount();
            for(i=0;i<cItems;i++) 
            {
               pNames = (PSCE_NAME_LIST) LocalAlloc(LPTR,sizeof(SCE_NAME_LIST));

               if ( pNames ) 
               {
                   m_lbMembers.GetText(i,strItem);
                   pNames->Name = (PWSTR) LocalAlloc(LPTR,(strItem.GetLength()+1)*sizeof(TCHAR));

                   if ( pNames->Name ) 
                   {
                       // This may not be a safe usage, using WCHAR instead of TCHAR. Consider fix
                       lstrcpy(pNames->Name,(LPCTSTR)strItem);

                       pNames->Next = pTemp1;
                       pTemp1 = pNames;
                   } 
                   else 
                   {
                       //
                       // no memory
                       //
                       LocalFree(pNames);
                       err = ERROR_NOT_ENOUGH_MEMORY;

                       break;
                   }
               } 
               else 
               {
                   err = ERROR_NOT_ENOUGH_MEMORY;
                   break;
               }
            }
         }

         if ( err == ERROR_SUCCESS ) 
         {
            if (!m_bNoMemberOf) 
            {
               cItems = m_lbMemberOf.GetCount();
               for (i=0;i<cItems;i++) 
               {
                  pNames = (PSCE_NAME_LIST) LocalAlloc(LPTR,sizeof(SCE_NAME_LIST));

                  if ( pNames ) 
                  {
                     m_lbMemberOf.GetText(i,strItem);
                     pNames->Name = (PWSTR) LocalAlloc(LPTR,(strItem.GetLength()+1)*sizeof(TCHAR));

                     if ( pNames->Name ) 
                     {
                        // This may not be a safe usage, using WCHAR instead of TCHAR. Consider fix.
                        lstrcpy(pNames->Name,(LPCTSTR)strItem);

                        pNames->Next = pTemp2;
                        pTemp2 = pNames;
                     } 
                     else 
                     {
                        //
                        // no memory
                        //
                        LocalFree(pNames);
                        err = ERROR_NOT_ENOUGH_MEMORY;

                        break;
                     }
                  } 
                  else 
                  {
                     err = ERROR_NOT_ENOUGH_MEMORY;
                     break;
                  }
               }
            }
         }

         if ( err == ERROR_SUCCESS ) 
         {
             SceFreeMemory(pgm->pMembers,SCE_STRUCT_NAME_LIST);
             pgm->pMembers = pTemp1;

             SceFreeMemory(pgm->pMemberOf,SCE_STRUCT_NAME_LIST);
             pgm->pMemberOf = pTemp2;

             m_pData->Update(m_pSnapin);
             m_fDirty = false;

         } 
         else 
         {
             //
             // error occured, can't save data
             // free the temp buffer and return to the dialog
             //
             SceFreeMemory(pTemp1,SCE_STRUCT_NAME_LIST);
             SceFreeMemory(pTemp2,SCE_STRUCT_NAME_LIST);

             return FALSE;
         }

      }
   }

   return CAttribute::OnApply();
}


BOOL CConfigGroup::OnInitDialog()
{
   CAttribute::OnInitDialog();

   CString str;

   UpdateData(TRUE);

   str.LoadString(IDS_NO_MEMBERS);
   m_eNoMembers.SetWindowText(str);
   str.LoadString(IDS_NO_MEMBER_OF);
   m_eNoMemberOf.SetWindowText(str);

   PSCE_GROUP_MEMBERSHIP pgm = (PSCE_GROUP_MEMBERSHIP) (m_pData->GetID());
   if ( pgm ) 
   {
       SCESTATUS rc;

       if( pgm->GroupName )
       {
          CString strCap; //Raid 467420, Yang Gao
          strCap.Format(IDS_GROUP_TITLE, pgm->GroupName);
          if( strCap.GetLength() > TAB_TITLE_LENGTH ) //Raid #495610, yanggao
          {
             strCap.Format(IDS_GROUP_TITLE_WRAP, pgm->GroupName);
          }

          CPropertySheet* pSheet = (CPropertySheet*)GetParent(); //Raid 469026
          if( pSheet )
          {
             CTabCtrl* pTab = pSheet->GetTabControl();
             if( pTab )
             {
                TC_ITEM ti;
                ti.mask = TCIF_TEXT;
                ti.pszText = strCap.GetBuffer(strCap.GetLength());
                int nPage = pSheet->GetActiveIndex(); 
                pTab->SetItem(nPage, &ti);
             }
          }
       }
       
       PSCE_NAME_LIST pNames = pgm->pMembers;
       if (!pNames) 
       {
          m_bNoMembers = TRUE;
          m_lbMembers.ShowWindow(SW_HIDE);
          m_eNoMembers.ShowWindow(SW_SHOW);
          m_eNoMembers.EnableWindow(FALSE); 
       } 
       else
       {
          PWSTR pLongestName = NULL; //Raid #496574, yanggao
          int maxlength = 0;
          int curlength = 0;
          while(pNames) 
          {
             if( pNames->Name )
             {
                curlength = lstrlen(pNames->Name);
                if( curlength )
                {
                   m_lbMembers.AddString(pNames->Name);
                   if( curlength > maxlength )
                   {
                      maxlength = curlength;
                      pLongestName = pNames->Name;
                   }
                }
             }
             pNames = pNames->Next;
          }
          if( pLongestName )
          {
             CClientDC hDC(&m_lbMembers);
             HFONT hFontOld = (HFONT)hDC.SelectObject((HFONT)GetStockObject(DEFAULT_GUI_FONT));
             CSize cSize;
             GetTextExtentPoint32(hDC, pLongestName, lstrlen(pLongestName), &cSize);
             hDC.SelectObject(hFontOld);
             m_lbMembers.SetHorizontalExtent(cSize.cx+10);
          }
       }
       if( m_lbMembers.GetCount() <= 0 ) //Raid 472244, Yang Gao, 9/18/2001
       {
          m_lbMembers.EnableWindow(false); 
       }
       GetDlgItem (IDC_REMOVE_MEMBER)->EnableWindow(FALSE);
       pNames = pgm->pMemberOf;
       if (!pNames) 
       {
          m_bNoMemberOf = TRUE;
          m_lbMemberOf.ShowWindow(SW_HIDE);
          m_eNoMemberOf.ShowWindow(SW_SHOW);
          m_eNoMemberOf.EnableWindow(FALSE); 
       } 
       else
       {
          PWSTR pLongestName = NULL; //Raid #496574, yanggao
          int maxlength = 0;
          int curlength = 0;
          while(pNames) 
          {
             if( pNames->Name )
             {
                curlength = lstrlen(pNames->Name);
                if( curlength )
                {
                   m_lbMemberOf.AddString(pNames->Name);
                   if( curlength > maxlength )
                   {
                      maxlength = curlength;
                      pLongestName = pNames->Name;
                   }
                }
             }
             pNames = pNames->Next;
          }
          if( pLongestName )
          {
             CClientDC hDC(&m_lbMemberOf);
             HFONT hFontOld = (HFONT)hDC.SelectObject((HFONT)GetStockObject(DEFAULT_GUI_FONT));
             CSize cSize;
             GetTextExtentPoint32(hDC, pLongestName, lstrlen(pLongestName), &cSize);
             hDC.SelectObject(hFontOld);
             m_lbMemberOf.SetHorizontalExtent(cSize.cx+10);
          }
       }
       if( m_lbMemberOf.GetCount() <= 0 ) //Raid 472244, Yang Gao, 10/22/2001
       {
          m_lbMemberOf.EnableWindow(false); 
       }
       GetDlgItem (IDC_REMOVE_MEMBEROF)->EnableWindow(FALSE);
   }

  // m_btnTitle.SetWindowText(m_pData->GetAttrPretty());
   if ( m_bReadOnly )
   {
      GetDlgItem (IDC_ADD_MEMBER)->EnableWindow (FALSE);
      GetDlgItem (IDC_REMOVE_MEMBER)->EnableWindow (FALSE);
      GetDlgItem (IDC_ADD_MEMBEROF)->EnableWindow (FALSE);
      GetDlgItem (IDC_REMOVE_MEMBEROF)->EnableWindow (FALSE);
   }

   return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CConfigGroup::OnSelChangeMem() //Raid 467886, Yang Gao, 9/18/2001
{
   CWnd* pwnd = this->GetDlgItem(IDC_REMOVE_MEMBER);
   if( pwnd )
   {
       if( m_lbMembers.GetSelCount() == 0 ) //Raid #490559, Yanggao. For multi-select listbox
       {
           pwnd->EnableWindow(FALSE);
       }
       else
       {
           pwnd->EnableWindow(TRUE);
       }
   }
}

void CConfigGroup::OnSelChangeMemof()
{
   CWnd* pwnd = this->GetDlgItem(IDC_REMOVE_MEMBEROF);
   if( pwnd )
   {
       if( m_lbMemberOf.GetSelCount() == 0 ) //Raid #450559, Yanggao, For multi-select listbox
       {
           pwnd->EnableWindow(FALSE);
       }
       else
       {
           pwnd->EnableWindow(TRUE);
       }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\chklist.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991-2001           **/
/**********************************************************************/

/*

    CHKLIST.CPP

    This file contains the implementation of the CheckList control.

*/

#include "stdafx.h"
#include <windowsx.h>
#include "chklist.h"
#include "debug.h"
#include "util.h"

//
// Text and Background colors
//
#define TEXT_COLOR  COLOR_WINDOWTEXT
#define BK_COLOR    COLOR_WINDOW

//
// Default dimensions for child controls. All are in dialog units.
// Currently only the column width is user-adjustable (via the
// CLM_SETCOLUMNWIDTH message).
//
#define DEFAULT_COLUMN_WIDTH    32
#define DEFAULT_CHECK_WIDTH     9
#define DEFAULT_HORZ_SPACE      7
#define DEFAULT_VERTICAL_SPACE  3
#define DEFAULT_ITEM_HEIGHT     8

//
// 16 bits are used for the control ID's, divided into n bits for
// the subitem (least significant) and 16-n bits for the item index.
//
// ID_SUBITEM_BITS can be adjusted to control the maximum number of
// items and subitems. For example, to allow up to 7 subitems and 8k
// items, set ID_SUBITEM_BITS to 3.
//

// Use the low 2 bits for the subitem index, the rest for the item index.
// (4 subitems max, 16k items max)
#define ID_SUBITEM_BITS         2

#define ID_SUBITEM_MASK         ((1 << ID_SUBITEM_BITS) - 1)
#define GET_ITEM(id)            ((id) >> ID_SUBITEM_BITS)
#define GET_SUBITEM(id)         ((id) & ID_SUBITEM_MASK)

#define MAKE_CTRL_ID(i, s)      (0xffff & (((i) << ID_SUBITEM_BITS) | ((s) & ID_SUBITEM_MASK)))
#define MAKE_LABEL_ID(i)        MAKE_CTRL_ID(i, 0)
// Note that the subitem (column) index is one-based for the checkboxes
// (the zero column is the label).  The item (row) index is zero-based.

#define MAX_CHECK_COLUMNS       ID_SUBITEM_MASK


typedef struct _USERDATA_STRUCT_LABEL
{
    LPARAM      lParam;
    int         nLabelHeight;
    int         itemIndex;
} USERDATA_STRUCT_LABEL, *LPUSERDATA_STRUCT_LABEL;

class CCheckList
{
private:
    LONG m_cItems;
    LONG m_cSubItems;
    RECT m_rcItemLabel;
    LONG m_nCheckPos[MAX_CHECK_COLUMNS];
    LONG m_cxCheckBox;
    LONG m_cxCheckColumn;

    int m_nDefaultVerticalSpace;
    int m_nDefaultItemHeight;
    int m_nNewItemYPos;

    HWND m_hwndCheckFocus;

    BOOL m_fInMessageEnable;

    int m_cWheelDelta;
    static UINT g_ucScrollLines;

private:
    CCheckList(HWND hWnd, LPCREATESTRUCT lpcs);

    LRESULT MsgCommand(HWND hWnd, WORD idCmd, WORD wNotify, HWND hwndCtrl);
    void MsgPaint(HWND hWnd, HDC hdc);
    void MsgVScroll(HWND hWnd, int nCode, int nPos);
    void MsgMouseWheel(HWND hWnd, WORD fwFlags, int zDelta);
    void MsgButtonDown(HWND hWnd, WPARAM fwFlags, int xPos, int yPos);
    void MsgEnable(HWND hWnd, BOOL fEnabled);
    void MsgSize(HWND hWnd, DWORD dwSizeType, LONG nWidth, LONG nHeight);

    LONG AddItem(HWND hWnd, LPCTSTR pszLabel, LPARAM lParam);
    void SetState(HWND hWnd, WORD iItem, WORD iSubItem, LONG lState);
    LONG GetState(HWND hWnd, WORD iItem, WORD iSubItem);
    void SetColumnWidth(HWND hWnd, LONG cxDialog, LONG cxColumn);
    void ResetContent(HWND hWnd);
    LONG GetVisibleCount(HWND hWnd);
    LONG GetTopIndex(HWND hWnd, LONG *pnAmountObscured = NULL);
    void SetTopIndex(HWND hWnd, LONG nIndex);
    void EnsureVisible(HWND hWnd, LONG nIndex);
    void DrawCheckFocusRect(HWND hWnd, HWND hwndCheck, BOOL fDraw);

public:
    HWND m_hWnd;
    static LRESULT CALLBACK WindowProc(HWND hWnd,
                                       UINT uMsg,
                                       WPARAM wParam,
                                       LPARAM lParam);
};

BOOL RegisterCheckListWndClass(void)
{
    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CCheckList::WindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    AFX_MANAGE_STATE(AfxGetStaticModuleState()); // Required for AfxGetInstanceHandle()
    wc.hInstance        = AfxGetInstanceHandle(); //hModule;
    wc.hIcon            = NULL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(BK_COLOR+1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = TEXT(WC_CHECKLIST);

    return (BOOL)RegisterClass(&wc);
}


UINT CCheckList::g_ucScrollLines = (UINT)-1;


CCheckList::CCheckList(HWND hWnd, LPCREATESTRUCT lpcs)
: m_cItems(0), m_hwndCheckFocus(NULL), m_fInMessageEnable(FALSE), m_cWheelDelta(0)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::CCheckList");
    TraceAssert(hWnd != NULL);
    TraceAssert(lpcs != NULL); //Check lpcs before using it.

    m_hWnd = hWnd;
    //
    // Get number of check columns
    //
    if( lpcs ) //Raid #550912, yanggao.
    {
        m_cSubItems = lpcs->style & CLS_CHECKMASK;
    }

    // for wsecedit only
    if ( m_cSubItems > 3 ) {
        m_cSubItems = 3;
    }

    //
    // Convert default coordinates from dialog units to pixels
    //
    RECT rc;
    rc.left = DEFAULT_CHECK_WIDTH;
    rc.right = DEFAULT_COLUMN_WIDTH;
    rc.top = rc.bottom = 0;
    if( lpcs ) //Raid #550912, yanggao.
    {
        MapDialogRect(lpcs->hwndParent, &rc);
    }

    // Save the converted values
    m_cxCheckBox = rc.left;
    m_cxCheckColumn = rc.right;

    rc.left = DEFAULT_HORZ_SPACE;
    rc.top = DEFAULT_VERTICAL_SPACE;
    rc.right = 10;              // bogus (unused)
    rc.bottom = DEFAULT_VERTICAL_SPACE + DEFAULT_ITEM_HEIGHT;
    if( lpcs ) //Raid #550912, yanggao.
    {
        MapDialogRect(lpcs->hwndParent, &rc);
    }

    // Save the converted values
    m_rcItemLabel = rc;

    m_nDefaultVerticalSpace = rc.top;
    m_nDefaultItemHeight = rc.bottom - rc.top;
    m_nNewItemYPos = rc.top;

    //
    // Get info for mouse wheel scrolling
    //
    if ((UINT)-1 == g_ucScrollLines)
    {
        g_ucScrollLines = 3; // default
        SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &g_ucScrollLines, 0);
    }

    TraceLeaveVoid();
}


LRESULT
CCheckList::MsgCommand(HWND hWnd, WORD idCmd, WORD wNotify, HWND hwndCtrl)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::MsgCommand");

    // Should only get notifications from visible, enabled, check boxes
    //Check below expression before enter the message processing body.
    TraceAssert(GET_ITEM(idCmd) < m_cItems);
    TraceAssert(0 < GET_SUBITEM(idCmd) && GET_SUBITEM(idCmd) <= m_cSubItems);
    TraceAssert(hwndCtrl && IsWindowEnabled(hwndCtrl));
    if( !(GET_ITEM(idCmd) < m_cItems) || !(0 < GET_SUBITEM(idCmd) && GET_SUBITEM(idCmd) <= m_cSubItems) ||
         !(hwndCtrl && IsWindowEnabled(hwndCtrl)) ) //Raid #550912, yanggao.
    {
        return 0;
    }

    switch (wNotify)
    {
    case EN_SETFOCUS:
        {
            // Make the focus go to one of the checkboxes
            POINT pt;
            DWORD dwPos = GetMessagePos();
            pt.x = GET_X_LPARAM(dwPos);
            pt.y = GET_Y_LPARAM(dwPos);
            MapWindowPoints(NULL, hWnd, &pt, 1);
            MsgButtonDown(hWnd, 0, pt.x, pt.y);
        }
        break;

    case BN_CLICKED:
        {
            LPUSERDATA_STRUCT_LABEL lpUserData;
            NM_CHECKLIST nmc;
            nmc.hdr.hwndFrom = hWnd;
            nmc.hdr.idFrom = GetDlgCtrlID(hWnd);
            nmc.hdr.code = CLN_CLICK;
            nmc.iItem = GET_ITEM(idCmd);
            nmc.iSubItem = GET_SUBITEM(idCmd);
            nmc.dwState = (DWORD)SendMessage(hwndCtrl, BM_GETCHECK, 0, 0);
            if (!IsWindowEnabled(hwndCtrl))
                nmc.dwState |= CLST_DISABLED;
            lpUserData = (LPUSERDATA_STRUCT_LABEL)
                            GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID(nmc.iItem)),
                                                GWLP_USERDATA);
            nmc.dwItemData = lpUserData->lParam;

            SendMessage(GetParent(hWnd),
                        WM_NOTIFY,
                        nmc.hdr.idFrom,
                        (LPARAM)&nmc);

        }
        break;

    case BN_SETFOCUS:
        if (GetFocus() != hwndCtrl)
        {
            // This causes another BN_SETFOCUS
            SetFocus(hwndCtrl);
        }
        else
        {
            if (m_hwndCheckFocus != hwndCtrl)   // Has the focus moved?
            {
                // Remember where the focus is
                m_hwndCheckFocus = hwndCtrl;

                // Make sure the row is scrolled into view
                EnsureVisible(hWnd, GET_ITEM(idCmd));
            }
            // Always draw the focus rect
            DrawCheckFocusRect(hWnd, hwndCtrl, TRUE);
        }
        break;

    case BN_KILLFOCUS:
        // Remove the focus rect
        m_hwndCheckFocus = NULL;
        DrawCheckFocusRect(hWnd, hwndCtrl, FALSE);
        break;
    }

    TraceLeaveValue(0);
}


void
CCheckList::MsgPaint(HWND hWnd, HDC hdc)
{
    if (hdc == NULL && m_hwndCheckFocus != NULL)
    {
        // This will cause a focus rect to be drawn after the window and
        // all checkboxes have been painted.
        PostMessage(hWnd,
                    WM_COMMAND,
                    GET_WM_COMMAND_MPS(GetDlgCtrlID(m_hwndCheckFocus), m_hwndCheckFocus, BN_SETFOCUS));
    }

    // Default paint
    DefWindowProc(hWnd, WM_PAINT, (WPARAM)hdc, 0);
}


void
CCheckList::MsgVScroll(HWND hWnd, int nCode, int nPos)
{
    UINT cScrollUnitsPerLine;
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;

    if (!GetScrollInfo(hWnd, SB_VERT, &si))
        return;

    cScrollUnitsPerLine = m_rcItemLabel.bottom;

    // One page is always visible, so adjust the range to a more useful value
    si.nMax -= si.nPage - 1;

    switch (nCode)
    {
    case SB_LINEUP:
        // "line" is the height of one item (includes the space in between)
        nPos = si.nPos - cScrollUnitsPerLine;
        break;

    case SB_LINEDOWN:
        nPos = si.nPos + cScrollUnitsPerLine;
        break;

    case SB_PAGEUP:
        nPos = si.nPos - si.nPage;
        break;

    case SB_PAGEDOWN:
        nPos = si.nPos + si.nPage;
        break;

    case SB_TOP:
        nPos = si.nMin;
        break;

    case SB_BOTTOM:
        nPos = si.nMax;
        break;

    case SB_ENDSCROLL:
        nPos = si.nPos;     // don't go anywhere
        break;

    case SB_THUMBTRACK:
        // Do nothing here to allow tracking
        // nPos = si.nPos;    // Do this to prevent tracking
    case SB_THUMBPOSITION:
        // nothing to do here... nPos is passed in
        break;
    }

    // Make sure the new position is within the range
    if (nPos < si.nMin)
        nPos = si.nMin;
    else if (nPos > si.nMax)
        nPos = si.nMax;

    if (nPos != si.nPos)  // are we moving?
    {
        SetScrollPos(hWnd, SB_VERT, nPos, TRUE);
        ScrollWindow(hWnd, 0, si.nPos - nPos, NULL, NULL);
    }
}


void
CCheckList::MsgMouseWheel(HWND hWnd, WORD fwFlags, int iWheelDelta)
{
    int cDetants;

    if ((fwFlags & (MK_SHIFT | MK_CONTROL)) || 0 == g_ucScrollLines)
        return;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::MsgMouseWheel");

    // Update count of scroll amount
    m_cWheelDelta -= iWheelDelta;
    cDetants = m_cWheelDelta / WHEEL_DELTA;
    if (0 == cDetants)
        TraceLeaveVoid();
    m_cWheelDelta %= WHEEL_DELTA;

    if (WS_VSCROLL & GetWindowLong(hWnd, GWL_STYLE))
    {
        SCROLLINFO  si;
        UINT        cScrollUnitsPerLine;
        UINT        cLinesPerPage;
        UINT        cLinesPerDetant;

        // Get the scroll amount of one line
        cScrollUnitsPerLine = m_rcItemLabel.bottom;
        TraceAssert(cScrollUnitsPerLine > 0); //Check this expression.
        if( cScrollUnitsPerLine <= 0 ) //Raid #550912, yanggao.
           return;

        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_PAGE | SIF_POS;
        if (!GetScrollInfo(hWnd, SB_VERT, &si))
            TraceLeaveVoid();

        // The size of a page is at least one line, and
        // leaves one line of overlap
        cLinesPerPage = (si.nPage - cScrollUnitsPerLine) / cScrollUnitsPerLine;
        cLinesPerPage = max(1, cLinesPerPage);

        // Don't scroll more than one page per detant
        cLinesPerDetant = min(cLinesPerPage, g_ucScrollLines);

        si.nPos += cDetants * cLinesPerDetant * cScrollUnitsPerLine;

        MsgVScroll(hWnd, SB_THUMBTRACK, si.nPos);
    }
    TraceLeaveVoid();
}


void
CCheckList::MsgButtonDown(HWND hWnd, WPARAM /*fwFlags*/, int xPos, int yPos)
{
    LONG nItemIndex;
    HWND hwndCheck;
    RECT rc;

    // Get position of the top visible item in client coords
    nItemIndex = GetTopIndex(hWnd);
    if (nItemIndex == -1)
    {
        return;
    }
    hwndCheck = GetDlgItem(hWnd, MAKE_CTRL_ID(nItemIndex, 0));
    GetWindowRect(hwndCheck, &rc);
    MapWindowPoints(NULL, hWnd, (LPPOINT)&rc, 2);

    // Find nearest item
    if( hWnd == m_hWnd ) //Raid #387542, 5/9/2001
    {
        POINT pos = {xPos,yPos};
        HWND ChildhWnd = ::ChildWindowFromPointEx(hWnd, pos, CWP_SKIPINVISIBLE|CWP_SKIPDISABLED);
        if( ChildhWnd )
        {
            LPUSERDATA_STRUCT_LABEL pUserData = (LPUSERDATA_STRUCT_LABEL)GetWindowLongPtr(ChildhWnd, GWLP_USERDATA);
            if( pUserData )
            {
                nItemIndex = pUserData->itemIndex;
            }
            else
            {
                return;
            }
        }
    }

    // Set focus to first subitem that is enabled
    for (LONG j = 1; j <= m_cSubItems; j++)
    {
        int id = MAKE_CTRL_ID(nItemIndex, j);
        hwndCheck = GetDlgItem(hWnd, id); //Raid #prefast
        if (IsWindowEnabled(hwndCheck))
        {
            // Don't just SetFocus here.  We sometimes call this during
            // EN_SETFOCUS, and USER doesn't like it when you mess with
            // focus during a focus change.
            //
            //SetFocus(hwndCheck);
            PostMessage(hWnd,
                        WM_COMMAND,
                        GET_WM_COMMAND_MPS(id, hwndCheck, BN_SETFOCUS));
            break;
        }
    }
}


void
CCheckList::MsgEnable(HWND hWnd, BOOL fEnabled)
{
    HWND hwndCurrentCheck;
    BOOL fCheckEnabled;

    if (!m_fInMessageEnable)
    {
        m_fInMessageEnable = TRUE;
        for (LONG i = 0; i < m_cItems; i++)
        {
            for (LONG j = 1; j <= m_cSubItems; j++)
            {
                hwndCurrentCheck = GetDlgItem(hWnd, MAKE_CTRL_ID(i, j));
                fCheckEnabled =   (BOOL) GetWindowLongPtr(hwndCurrentCheck, GWLP_USERDATA);

                //
                // If the user of the checklist control is disabling the control
                // altogether, or the current checkbox has been disabled singularly
                // then disable the checkbox
                //
                if (!fEnabled || !fCheckEnabled)
                {
                    EnableWindow(hwndCurrentCheck, FALSE);
                }
                else
                {
                    EnableWindow(hwndCurrentCheck, TRUE);
                }
            }
        }
        // Note that the main chklist window must remain enabled
        // for scrolling to work while "disabled".
        if (!fEnabled)
            EnableWindow(hWnd, TRUE);

        m_fInMessageEnable = FALSE;
    }
}


void
CCheckList::MsgSize(HWND hWnd, DWORD dwSizeType, LONG nWidth, LONG nHeight)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::MsgSize");
    TraceAssert(hWnd != NULL); //Validate hWnd.
    if( !hWnd ) //Raid #550912, yanggao.
       return;
    
    if (dwSizeType == SIZE_RESTORED)
    {
        RECT rc;
        SCROLLINFO si;

        si.cbSize = sizeof(si);
        si.fMask = SIF_RANGE | SIF_PAGE;
        si.nMin = 0;
        si.nMax = m_nNewItemYPos - 1;
        si.nPage = nHeight;

        SetScrollInfo(hWnd, SB_VERT, &si, FALSE);

        // Don't trust the width value passed in, since SetScrollInfo may
        // affect it if the scroll bar is turning on or off.
        GetClientRect(hWnd, &rc);
        nWidth = rc.right;

        // If the scrollbar is turned on, artificially bump up the width
        // by the width of the scrollbar, so the boxes don't jump to the left
        // when we have a scrollbar.
        if ((UINT)si.nMax >= si.nPage)
            nWidth += GetSystemMetrics(SM_CYHSCROLL);

        SetColumnWidth(hWnd, nWidth, m_cxCheckColumn);
    }

    TraceLeaveVoid();
}

LONG CCheckList::AddItem(HWND hWnd, LPCTSTR pszLabel, LPARAM lParam)
{
    HWND                    hwndPrev = 0;
    LPUSERDATA_STRUCT_LABEL lpUserData = 0;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::AddItem");
    TraceAssert(hWnd != NULL);
    TraceAssert(pszLabel != NULL && !IsBadStringPtr(pszLabel, MAX_PATH));
    if ( !hWnd || !pszLabel || IsBadStringPtr(pszLabel, MAX_PATH) )
        return -1;

    lpUserData = new (USERDATA_STRUCT_LABEL);
    if ( lpUserData )
    {
        SCROLLINFO  si;
        si.cbSize = sizeof(si);
        si.fMask = SIF_POS;
        si.nPos = 0;
        GetScrollInfo(hWnd, SB_VERT, &si);

        // Set the initial label height extra big so the control can wrap the text,
        // then reset it after creating the control.
        RECT    rc;
        GetClientRect(hWnd, &rc);
        LONG    nLabelHeight = rc.bottom;

        AFX_MANAGE_STATE(AfxGetStaticModuleState()); // Required for AfxGetInstanceHandle()
        HMODULE hModule = AfxGetInstanceHandle();

        // Create a new label control
        HWND hwndNew = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
                                 TEXT("edit"),
                                 pszLabel,
                                 WS_CHILD | WS_VISIBLE | WS_GROUP | ES_MULTILINE | ES_READONLY | ES_LEFT,// | WS_GROUP,
                                 m_rcItemLabel.left,
                                 m_nNewItemYPos - si.nPos,
                                 m_rcItemLabel.right - m_rcItemLabel.left,
                                 nLabelHeight,
                                 hWnd,
                                 (HMENU)IntToPtr(MAKE_LABEL_ID(m_cItems)),
                                 hModule,
                                 NULL);
        if ( hwndNew )
        {
            HWND hwndEdit = hwndNew;
            //
            // Reset window height after word wrap has been done.
            //
            LONG nLineCount = (LONG) SendMessage(hwndNew, EM_GETLINECOUNT, 0, (LPARAM) 0);
            nLabelHeight = nLineCount * m_nDefaultItemHeight;
            SetWindowPos(hwndNew,
                         NULL,
                         0,
                         0,
                         m_rcItemLabel.right - m_rcItemLabel.left,
                         nLabelHeight,
                         SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

            //
            // Save item data
            //
            lpUserData->lParam = lParam;
            lpUserData->nLabelHeight = nLabelHeight;
            lpUserData->itemIndex = m_cItems; //Raid #387542

            SetLastError(0);
            SetWindowLongPtr(hwndNew, GWLP_USERDATA, (LPARAM) lpUserData); //Raid #286697, 4/4/2001
            if( 0 == GetLastError() )
            {
                // Set the font
                SendMessage(hwndNew,
                            WM_SETFONT,
                            SendMessage(GetParent(hWnd), WM_GETFONT, 0, 0),
                            0);

                // Set Z-order position just after the last checkbox. This keeps
                // tab order correct.
                if (m_cItems > 0)
                {
                    hwndPrev = GetDlgItem(hWnd, MAKE_CTRL_ID(m_cItems - 1, m_cSubItems));
                    SetWindowPos(hwndNew,
                                 hwndPrev,
                                 0, 0, 0, 0,
                                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
                }

                // Create new checkboxes
                DWORD dwCheckStyle = WS_CHILD | WS_VISIBLE | WS_GROUP | WS_TABSTOP | BS_NOTIFY | BS_FLAT | BS_AUTOCHECKBOX;
                for (LONG j = 0; j < m_cSubItems; j++)
                {
                    hwndPrev = hwndNew;
                    hwndNew = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
                                             TEXT("BUTTON"),
                                             NULL,
                                             dwCheckStyle,
                                             m_nCheckPos[j],
                                             m_nNewItemYPos - si.nPos,
                                             m_cxCheckBox,
                                             m_rcItemLabel.bottom - m_rcItemLabel.top,
                                             hWnd,
                                             (HMENU)IntToPtr(MAKE_CTRL_ID(m_cItems, j + 1)),
                                             hModule,
                                             NULL);
                    if (!hwndNew)
                    {
                        while (j >= 0)
                        {
                            DestroyWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(m_cItems, j)));
                            j--;
                        }

                        DestroyWindow (hwndEdit);
                        delete lpUserData;
                        TraceLeaveValue(-1);
                    }

                    // Set Z-order position just after the last checkbox. This keeps
                    // tab order correct.
                    SetWindowPos(hwndNew,
                                 hwndPrev,
                                 0, 0, 0, 0,
                                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

                    //
                    // Default "enabled" to TRUE
                    //
                    SetWindowLongPtr(hwndNew, GWLP_USERDATA, (LPARAM) TRUE);

                    // Only want this style on the first checkbox
                    dwCheckStyle &= ~WS_GROUP;
                }

                // We now officially have a new item
                m_cItems++;

                // calculate Y pos for next item to be inserted
                m_nNewItemYPos += nLabelHeight + m_nDefaultVerticalSpace;

                //
                // The last thing is to set the scroll range
                //
                GetClientRect(hWnd, &rc);
                si.cbSize = sizeof(si);
                si.fMask = SIF_PAGE | SIF_RANGE;
                si.nMin = 0;
                si.nMax = m_nNewItemYPos - 1;
                si.nPage = rc.bottom;

                SetScrollInfo(hWnd, SB_VERT, &si, FALSE);
            }
            else
            {
               delete lpUserData;
               DestroyWindow(hwndNew);
            }
        }
        else
            delete lpUserData;
    }

    TraceLeaveValue(m_cItems - 1);  // return the index of the new item
}


void
CCheckList::SetState(HWND hWnd, WORD iItem, WORD iSubItem, LONG lState)
{
    HWND hwndCtrl;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::SetState");
    //Check below expression.
    TraceAssert(hWnd != NULL);
    TraceAssert(iItem < m_cItems);
    TraceAssert(0 < iSubItem && iSubItem <= m_cSubItems);
    if( !hWnd || !(iItem < m_cItems) || !(0 < iSubItem && iSubItem <= m_cSubItems) ) //Raid #550912, yanggao.
       return;

    if (iSubItem > 0)
    {
        hwndCtrl = GetDlgItem(hWnd, MAKE_CTRL_ID(iItem, iSubItem));
        if (hwndCtrl != NULL)
        {
            SetWindowLongPtr(hwndCtrl, GWLP_USERDATA, (LPARAM) !(lState & CLST_DISABLED));
            SendMessage(hwndCtrl, BM_SETCHECK, lState & CLST_CHECKED, 0);
            EnableWindow(hwndCtrl, !(lState & CLST_DISABLED));
        }
    }

    TraceLeaveVoid();
}


LONG
CCheckList::GetState(HWND hWnd, WORD iItem, WORD iSubItem)
{
    LONG lState = 0;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::GetState");
    //Check below expressions.
    TraceAssert(hWnd != NULL);
    TraceAssert(iItem < m_cItems);
    TraceAssert(0 < iSubItem && iSubItem <= m_cSubItems);
    if( !hWnd || !(iItem < m_cItems) || !(0 < iSubItem && iSubItem <= m_cSubItems) )//Raid #550912, yanggao.
       return lState;

    HWND hwndCtrl = GetDlgItem(hWnd, MAKE_CTRL_ID(iItem, iSubItem));

    if (hwndCtrl != NULL)
    {
        lState = (LONG)SendMessage(hwndCtrl, BM_GETCHECK, 0, 0);
        TraceAssert(!(lState & BST_INDETERMINATE)); //Bogus Assert. yanggao

        if (!IsWindowEnabled(hwndCtrl))
            lState |= CLST_DISABLED;
    }

    TraceLeaveValue(lState);
}


void
CCheckList::SetColumnWidth(HWND hWnd, LONG cxDialog, LONG cxColumn)
{
    LONG                    j;
    LPUSERDATA_STRUCT_LABEL pUserData;
    LONG                    nLabelHeight;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::SetColumnWidth");
    //Check below expressions.
    TraceAssert(hWnd != NULL);
    TraceAssert(cxColumn > 10);
    if( !hWnd || !(cxColumn > 10) )//Raid #550912, yanggao.
       return;

    m_cxCheckColumn = cxColumn;

    if (m_cSubItems > 0)
    {
        m_nCheckPos[m_cSubItems-1] = cxDialog                       // dlg width
                                    - m_rcItemLabel.left            // right margin
                                    - (cxColumn + m_cxCheckBox)/2;  // 1/2 col & 1/2 checkbox

        for (j = m_cSubItems - 1; j > 0; j--)
            m_nCheckPos[j-1] = m_nCheckPos[j] - cxColumn;

        //              (leftmost check pos) - (horz margin)
        m_rcItemLabel.right = m_nCheckPos[0] - m_rcItemLabel.left;
    }
    else
        m_rcItemLabel.right = cxDialog - m_rcItemLabel.left;

    LONG nTop = m_rcItemLabel.top;
    LONG nBottom = m_rcItemLabel.bottom;

    for (LONG i = 0; i < m_cItems; i++)
    {
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)i)),
                                        GWLP_USERDATA);
        if (pUserData != NULL)
        {
            nLabelHeight = pUserData->nLabelHeight;
        }
        else
        {
            nLabelHeight = nBottom - nTop;
        }

        MoveWindow(GetDlgItem(hWnd, MAKE_LABEL_ID(i)),
                   m_rcItemLabel.left,
                   nTop,
                   m_rcItemLabel.right - m_rcItemLabel.left,
                   nLabelHeight,
                   FALSE);

        for (j = 0; j < m_cSubItems; j++)
        {
            MoveWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j + 1)),
                       m_nCheckPos[j],
                       nTop,
                       m_cxCheckBox,
                       nBottom - nTop,
                       FALSE);
        }

        nTop += nLabelHeight + m_nDefaultVerticalSpace;
        nBottom += nLabelHeight + m_nDefaultVerticalSpace;
    }

    TraceLeaveVoid();
}


void
CCheckList::ResetContent(HWND hWnd)
{
    LPUSERDATA_STRUCT_LABEL pUserData;
    HWND                    hwndCurrentLabel;

    for (LONG i = 0; i < m_cItems; i++)
    {
        hwndCurrentLabel = GetDlgItem(hWnd, MAKE_LABEL_ID((int)i));
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   hwndCurrentLabel,
                                        GWLP_USERDATA);
        if (pUserData != NULL)
        {
            delete(pUserData);
        }
        DestroyWindow(hwndCurrentLabel);

        for (LONG j = 1; j <= m_cSubItems; j++)
        {
            DestroyWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j)));
        }
    }

    // Hide the scroll bar
    SetScrollRange(hWnd, SB_VERT, 0, 0, FALSE);
    m_cItems = 0;
}


LONG
CCheckList::GetVisibleCount(HWND hWnd)
{
    LONG                    nCount = 0;
    RECT                    rc;
    LONG                    nTopIndex;
    LONG                    nAmountShown = 0;
    LONG                    nAmountObscured = 0;
    LPUSERDATA_STRUCT_LABEL pUserData;

    if (!GetClientRect(hWnd, &rc))
    {
        return 1;
    }

    nTopIndex = GetTopIndex(hWnd, &nAmountObscured);
    if (nTopIndex == -1)
    {
        return 1;
    }

    while ((nTopIndex < m_cItems) && (nAmountShown < rc.bottom))
    {
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nTopIndex)),
                                        GWLP_USERDATA);
        nAmountShown += (m_nDefaultVerticalSpace + pUserData->nLabelHeight - nAmountObscured);
        nAmountObscured = 0;    // nAmountObscured only matters for the first iteration where
                                // the real top index's amount shown is being calculated
        nCount++;
        nTopIndex++;
    }

    //
    // since that last one may be obscured see if we need to adjust nCount
    //
    if (nAmountShown > rc.bottom)
    {
        nCount--;
    }

    return max(1, nCount);
}

LONG
CCheckList::GetTopIndex(HWND hWnd, LONG *pnAmountObscured)
{
    LONG                    nIndex = 0;
    LPUSERDATA_STRUCT_LABEL pUserData;
    SCROLLINFO              si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_POS;

    //
    // initialize
    //
    if (pnAmountObscured != NULL)
    {
        *pnAmountObscured = 0;
    }

    if (GetScrollInfo(hWnd, SB_VERT, &si) && m_rcItemLabel.bottom > 0)
    {
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nIndex)),
                                        GWLP_USERDATA);
        //
        // if there are no items get out
        //
        if (pUserData == NULL)
        {
            return -1;
        }

        while (si.nPos >= (m_nDefaultVerticalSpace + pUserData->nLabelHeight))
        {
            si.nPos -= (m_nDefaultVerticalSpace + pUserData->nLabelHeight);
            nIndex++;
            pUserData = (LPUSERDATA_STRUCT_LABEL)
                        GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nIndex)),
                                            GWLP_USERDATA);
        }

        if (pnAmountObscured != NULL)
        {
            *pnAmountObscured = si.nPos;
        }
    }

    return nIndex;
}

void
CCheckList::SetTopIndex(HWND hWnd, LONG nIndex)
{
    int                     i;
    int                     nPos = 0;
    LPUSERDATA_STRUCT_LABEL pUserData;

    for (i=0; i<nIndex; i++)
    {
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)i)),
                                        GWLP_USERDATA);
        nPos += (m_nDefaultVerticalSpace + pUserData->nLabelHeight);
    }

    m_cWheelDelta = 0;
    MsgVScroll(hWnd, SB_THUMBPOSITION, nPos);
}


void
CCheckList::EnsureVisible(HWND hWnd, LONG nItemIndex)
{
    LONG                    nAmountObscured = 0;
    LONG                    nTopIndex;
    RECT                    rc;
    LPUSERDATA_STRUCT_LABEL pUserData;

    nTopIndex = GetTopIndex(hWnd, &nAmountObscured);
    if (nTopIndex == -1)
    {
        return;
    }

    // Note that the top item may only be partially visible,
    // so we need to test for equality here.  Raid #208449
    if (nItemIndex < nTopIndex)
    {
        SetTopIndex(hWnd, nItemIndex);
    }
    else if (nItemIndex == nTopIndex)
    {
        if (nAmountObscured != 0)
        {
            SetTopIndex(hWnd, nItemIndex);
        }
    }
    else
    {
        LONG nVisible = GetVisibleCount(hWnd);

        if (nItemIndex >= nTopIndex + nVisible)
        {
            if (!GetClientRect(hWnd, &rc))
            {
                //
                // This is just best effort
                //
                SetTopIndex(hWnd, nItemIndex - nVisible + 1);
            }
            else
            {
                //
                // Calculate what the top index should be to allow
                // nItemIndex to be fully visible
                //
                nTopIndex = nItemIndex + 1;
                do
                {
                    nTopIndex--;
                    pUserData = (LPUSERDATA_STRUCT_LABEL)
                                GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nTopIndex)),
                                                    GWLP_USERDATA);
                    if (pUserData != NULL)
                    {
                        rc.bottom -= (pUserData->nLabelHeight + m_nDefaultVerticalSpace);
                        if (rc.bottom < 0)
                        {
                            nTopIndex++;
                        }
                    }
                    else
                    {
                        //
                        // Should not hit this, just added to make things safe
                        //
                        rc.bottom = 0;
                        nTopIndex = 0;
                    }
                } while (rc.bottom > 0);

                SetTopIndex(hWnd, nTopIndex);
            }
        }
    }
}


void
CCheckList::DrawCheckFocusRect(HWND hWnd, HWND hwndCheck, BOOL fDraw)
{
    RECT rcCheck;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::DrawCheckFocusRect");
    //Validate hWnd and hwndCheck.
    TraceAssert(hWnd != NULL);
    TraceAssert(hwndCheck != NULL);
    if( !hWnd || !(hwndCheck != NULL) ) //Raid #550912, yanggao.
       return;

    GetWindowRect(hwndCheck, &rcCheck);
    MapWindowPoints(NULL, hWnd, (LPPOINT)&rcCheck, 2);
    InflateRect(&rcCheck, 2, 2);    // draw *outside* the checkbox

    HDC hdc = GetDC(hWnd);
    if (hdc)
    {
        // Always erase before drawing, since we may already be
        // partially visible and drawing is an XOR operation.
        // (Don't want to leave any turds on the screen.)

        FrameRect(hdc, &rcCheck, GetSysColorBrush(BK_COLOR));

        if (fDraw)
        {
            SetTextColor(hdc, GetSysColor(TEXT_COLOR));
            SetBkColor(hdc, GetSysColor(BK_COLOR));
            DrawFocusRect(hdc, &rcCheck);
        }

        ReleaseDC(hWnd, hdc);
    }

    TraceLeaveVoid();
}

LRESULT
CALLBACK
CCheckList::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT                 lResult = 0;
    LPUSERDATA_STRUCT_LABEL pUserData = NULL;
    CCheckList *pThis = (CCheckList*)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    TraceEnter(TRACE_CHECKLIST, "CCheckList::WindowProc");
    TraceAssert(hWnd != NULL); //Validate hWnd.
    if( !hWnd ) //Raid #550912, yanggao.
       return lResult;

    switch (uMsg)
    {
    case WM_NCCREATE:
        pThis = new CCheckList(hWnd, (LPCREATESTRUCT)lParam);
        if (pThis != NULL)
        {
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pThis);
            lResult = TRUE;
        }
        break;

    case WM_DESTROY:
        if( pThis ) //Raid #550912, yanggao.
        {
            pThis->ResetContent(hWnd);
        }
        break;

    case WM_NCDESTROY:
        if( pThis ) //Raid #550912, yanggao.
        {
            delete pThis;
        }
        break;

    case WM_COMMAND: 
        TraceAssert(pThis != NULL); //Validate pThis.
        if( pThis ) //Raid #550912, yanggao.
        {
            lResult = pThis->MsgCommand(hWnd,
                                    GET_WM_COMMAND_ID(wParam, lParam),
                                    GET_WM_COMMAND_CMD(wParam, lParam),
                                    GET_WM_COMMAND_HWND(wParam, lParam));
        }
        break;

    case WM_CTLCOLORSTATIC:
        TraceAssert(pThis != NULL);
        if( pThis ) //Raid #550912, yanggao.
        {
           break;
        }
        SetBkMode((HDC)wParam, TRANSPARENT);
        SetTextColor((HDC)wParam, GetSysColor(TEXT_COLOR));
        SetBkColor((HDC)wParam, GetSysColor(BK_COLOR));
        lResult = (LRESULT)GetSysColorBrush(BK_COLOR);
        break;

    case WM_PAINT:
        TraceAssert(pThis != NULL); //Validate pThis.
        if( pThis ) //Raid #550912, yanggao.
        {
            pThis->MsgPaint(hWnd, (HDC)wParam);
        }
        break;

    case WM_VSCROLL:
        TraceAssert(pThis != NULL); //Validate pThis.
        if( pThis ) //Raid #550912, yanggao.
        {
            pThis->MsgVScroll(hWnd,
                          (int)(short)GET_WM_VSCROLL_CODE(wParam, lParam),
                          (int)(short)GET_WM_VSCROLL_POS(wParam, lParam));
        }
        break;

    case WM_MOUSEWHEEL:
        TraceAssert(pThis != NULL); //Validate pThis.
        if( pThis ) //Raid #550912, yanggao.
        {
            pThis->MsgMouseWheel(hWnd,
                             LOWORD(wParam),
                             (int)(short)HIWORD(wParam));
        }
        break;

    case WM_LBUTTONDOWN:
        TraceAssert(pThis != NULL); //Validate pThis.
        if( pThis ) //Raid #550912, yanggao.
        {
            pThis->MsgButtonDown(hWnd,
                             wParam,
                             (int)(short)LOWORD(lParam),
                             (int)(short)HIWORD(lParam));
        }
        break;

    case WM_ENABLE:
        TraceAssert(pThis != NULL); //Validate pThis.
        if( pThis ) //Raid #550912, yanggao.
        {
            pThis->MsgEnable(hWnd, (BOOL)wParam);
        }
        break;

    case WM_SETFONT:
        TraceAssert(pThis != NULL); //Validate pThis.
        if( pThis ) //Raid #550912, yanggao.
        {
            for (LONG i = 0; i < pThis->m_cItems; i++)
                SendDlgItemMessage(hWnd,
                                   MAKE_LABEL_ID(i),
                                   WM_SETFONT,
                                   wParam,
                                   lParam);
        }
        break;

    case WM_SIZE: 
        TraceAssert(pThis != NULL); //Validate pThis.
        if( pThis ) //Raid #550912, yanggao.
        {
            pThis->MsgSize(hWnd, (DWORD)wParam, LOWORD(lParam), HIWORD(lParam));
        }
        break;

    case CLM_ADDITEM:
        TraceAssert(pThis != NULL); //Validate pThis.
        if( pThis ) //Raid #550912, yanggao.
        {
            lResult = pThis->AddItem(hWnd, (LPCTSTR)wParam, lParam);
        }
        break;

    case CLM_GETITEMCOUNT:
        TraceAssert(pThis != NULL); //Validate pThis.
        if( pThis ) //Raid #550912, yanggao.
        {
            lResult = pThis->m_cItems;
        }
        break;

    case CLM_SETSTATE:
        TraceAssert(pThis != NULL); //Validate pThis.
        if( pThis ) //Raid #550912, yanggao.
        {
            pThis->SetState(hWnd, LOWORD(wParam), HIWORD(wParam), (LONG)lParam);
        }
        break;

    case CLM_GETSTATE:
        TraceAssert(pThis != NULL); //Validate pThis.
        if( pThis ) //Raid #550912, yanggao.
        {
            lResult = pThis->GetState(hWnd, LOWORD(wParam), HIWORD(wParam));
        }
        break;

    case CLM_SETCOLUMNWIDTH:
        TraceAssert(pThis != NULL); //Validate pThis.
        if( pThis ) //Raid #550912, yanggao.
        {
            RECT rc;
            LONG cxDialog;

            GetClientRect(hWnd, &rc);
            cxDialog = rc.right;

            rc.right = (LONG)lParam;
            MapDialogRect(GetParent(hWnd), &rc);

            pThis->SetColumnWidth(hWnd, cxDialog, rc.right);
        }
        break;

    case CLM_SETITEMDATA:
        TraceAssert(GET_ITEM(wParam) < (ULONG)pThis->m_cItems); //Validate pThis and the expression.
        if( !pThis || !(GET_ITEM(wParam) < (ULONG)pThis->m_cItems) ) //Raid #550912, yanggao.
        {
           break;
        }
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)wParam)),
                                        GWLP_USERDATA);
        if (pUserData != NULL)
            pUserData->lParam = lParam;
        break;

    case CLM_GETITEMDATA:
        TraceAssert(GET_ITEM(wParam) < (ULONG)pThis->m_cItems); //Validate pThis and the expression.
        if( !pThis || !(GET_ITEM(wParam) < (ULONG)pThis->m_cItems) ) //Raid #550912, yanggao.
        {
           break;
        }
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)wParam)),
                                        GWLP_USERDATA);
        if (pUserData != NULL)
            lResult = pUserData->lParam;
        break;

    case CLM_RESETCONTENT: 
        TraceAssert(pThis != NULL); //Validate pThis.
        if( pThis ) //Raid #550912, yanggao.
        {
            pThis->ResetContent(hWnd);
        }
        break;

    case CLM_GETVISIBLECOUNT:
        TraceAssert(pThis != NULL); //Validate pThis.
        if( pThis ) //Raid #550912, yanggao.
        {
            lResult = pThis->GetVisibleCount(hWnd);
        }
        break;

    case CLM_GETTOPINDEX:
        TraceAssert(pThis != NULL); //Validate pThis. 
        if( pThis ) //Raid #550912, yanggao.
        {
            lResult = pThis->GetTopIndex(hWnd);
        }
        break;

    case CLM_SETTOPINDEX: 
        TraceAssert(pThis != NULL); //Validate pThis.
        if( pThis ) //Raid #550912, yanggao.
        {
            pThis->SetTopIndex(hWnd, (LONG)wParam);
        }
        break;

    case CLM_ENSUREVISIBLE:
        TraceAssert(pThis != NULL); //Validate pThis.
        if( pThis ) //Raid #550912, yanggao.
        {
            pThis->EnsureVisible(hWnd, (LONG)wParam);
        }
        break;

    //
    // Always refer to the chklist window for help. Don't pass
    // one of the child window handles here.
    //
    case WM_HELP:
        ((LPHELPINFO)lParam)->hItemHandle = hWnd;
        lResult = SendMessage(GetParent(hWnd), uMsg, wParam, lParam);
        break;
    case WM_CONTEXTMENU:
        lResult = SendMessage(GetParent(hWnd), uMsg, (WPARAM)hWnd, lParam);
        break;

    case WM_SETCURSOR:
        if (LOWORD(lParam) == HTCLIENT)
        {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            lResult = TRUE;
            break;
        }
    // Fall Through
    default:
        lResult = DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    TraceLeaveValue(lResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\wsecmgr\cname.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation 1996-