elCount> repetitions of CHANNEL_CONNECT_DEF follow             */
} CHANNEL_CONNECT_IN, * PCHANNEL_CONNECT_IN;

/****************************************************************************/
/* Structure: CHANNEL_CONNECT_OUT                                           */
/*                                                                          */
/* Description: Data returned by driver on IOCTL_CHANNEL_CONNECT            */
/****************************************************************************/
typedef struct tagCHANNEL_CONNECT_OUT
{
    CHANNEL_IOCTL_OUT hdr;
} CHANNEL_CONNECT_OUT, *PCHANNEL_CONNECT_OUT;

/****************************************************************************/
/* IOCTL_CHANNEL_DISCONNECT                                                 */
/*                                                                          */
/* - data in: CHANNEL_DISCONNECT_IN                                         */
/*                                                                          */
/* - data out: CHANNEL_DISCONNECT_OUT                                       */
/****************************************************************************/
#define IOCTL_CHANNEL_DISCONNECT \
         CTL_CODE(FILE_DEVICE_TERMSRV, 0xA01, METHOD_NEITHER, FILE_WRITE_ACCESS)

/****************************************************************************/
/* Structure: CHANNEL_DISCONNECT_IN                                         */
/*                                                                          */
/* Description: Data sent to driver on IOCTL_CHANNEL_DISCONNECT             */
/****************************************************************************/
typedef struct tagCHANNEL_DISCONNECT_IN
{
    CHANNEL_IOCTL_IN hdr;
} CHANNEL_DISCONNECT_IN, * PCHANNEL_DISCONNECT_IN;

/****************************************************************************/
/* Structure: CHANNEL_DISCONNECT_OUT                                        */
/*                                                                          */
/* Description: Data returned by driver on IOCTL_CHANNEL_DISCONNECT         */
/****************************************************************************/
typedef struct tagCHANNEL_DISCONNECT_OUT
{
    CHANNEL_IOCTL_OUT hdr;
} CHANNEL_DISCONNECT_OUT, *PCHANNEL_DISCONNECT_OUT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\termsrv\inc\verall.h ===
/***************************************************************************
*
*  VERALL.H
*
*  Include this header file for proper resource version where the component
*  consists of all TerminalServer code.  See ctxver.h for details.
*
*  Copyright Microsoft Corporation, 1998
*
*
****************************************************************************/

#define VER_CTXCONTENT      1
//#define VER_CTXALLCONTENT   1
#define VER_CTXSOMECONTENT  1

#include <ctxver.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\termsrv\inc\tserrs.h ===
/***************************************************************************
*
*  TSERRS.H
*
*  This module defines error codes passed from the server to the client
*  via TS_SET_ERROR_INFO_PDU (for RDP)
*
*  Copyright Microsoft Corporation, 2000
*
*
****************************************************************************/

#ifndef _INC_TSERRSH
#define _INC_TSERRSH

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************/
/* Error info values passed through the IOCTL_TSHARE_SET_ERROR_INFO IOCTL   */
/* down to the protocol drivers and then onto the client (for disconnect    */
/* reason reporting                                                         */
/****************************************************************************/

//
// Protocol independent codes
//
#define TS_ERRINFO_NOERROR                                  0x00000000
#define TS_ERRINFO_RPC_INITIATED_DISCONNECT                 0x00000001
#define TS_ERRINFO_RPC_INITIATED_LOGOFF                     0x00000002
#define TS_ERRINFO_IDLE_TIMEOUT                             0x00000003
#define TS_ERRINFO_LOGON_TIMEOUT                            0x00000004
#define TS_ERRINFO_DISCONNECTED_BY_OTHERCONNECTION          0x00000005
#define TS_ERRINFO_OUT_OF_MEMORY                            0x00000006
//
// Error happens when we get disconnected early in the connection sequence
// normal causes are (in priority)
//      1) TS not enabled / policy limiting new connections
//      2) Network error occured at early stage in connection
//
#define TS_ERRINFO_SERVER_DENIED_CONNECTION                 0x00000007
// This one is that client has FIPS set but server doesn't know FIPS
#define TS_ERRINFO_SERVER_DENIED_CONNECTION_FIPS             0x00000008

//
// Protocol independent licensing codes
//
#define TS_ERRINFO_LICENSE_INTERNAL                         0x0000100
#define TS_ERRINFO_LICENSE_NO_LICENSE_SERVER                0x0000101
#define TS_ERRINFO_LICENSE_NO_LICENSE                       0x0000102
#define TS_ERRINFO_LICENSE_BAD_CLIENT_MSG                   0x0000103
#define TS_ERRINFO_LICENSE_HWID_DOESNT_MATCH_LICENSE        0x0000104
#define TS_ERRINFO_LICENSE_BAD_CLIENT_LICENSE               0x0000105
#define TS_ERRINFO_LICENSE_CANT_FINISH_PROTOCOL             0x0000106
#define TS_ERRINFO_LICENSE_CLIENT_ENDED_PROTOCOL            0x0000107
#define TS_ERRINFO_LICENSE_BAD_CLIENT_ENCRYPTION            0x0000108
#define TS_ERRINFO_LICENSE_CANT_UPGRADE_LICENSE             0x0000109
#define TS_ERRINFO_LICENSE_NO_REMOTE_CONNECTIONS            0x000010A

//
// Salem specific error code
//
#define TS_ERRINFO_SALEM_INVALIDHELPSESSION                 0x0000200

//
// Protocol specific codes must be passed in the
// range TS_ERRINFO_PROTOCOL_BASE to TS_ERRINFO_PROTOCOL_END
//
#define TS_ERRINFO_PROTOCOL_BASE                            0x0001000
#define TS_ERRINFO_PROTOCOL_END                             0x0007FFF


#ifdef __cplusplus
}
#endif


#endif  /* !_INC_TSERRSH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\termsrv\inc\utildll.h ===
/*******************************************************************************
*
* utildll.h
*
* UTILDLL WinStation utility support functions header file (export stuff)
*
*
*******************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

/*
 * UTILDLL defines and typedefs
 */
typedef struct _ELAPSEDTIME {
    USHORT days;
    USHORT hours;
    USHORT minutes;
    USHORT seconds;
} ELAPSEDTIME, * PELAPSEDTIME;

#define MAX_PROCESSNAME                 18
#define UTILDLL_NAME                    TEXT("UTILDLL.DLL")
#define SYSTEM_MESSAGE_MAX              528
#define MAX_ELAPSED_TIME_LENGTH         15
#define MAX_DATE_TIME_LENGTH            56
#define NO_ERROR_TEXT_LENGTH		100
#define STANDARD_ERROR_TEXT_LENGTH	100

/*
 * UTILDLL function prototypes
 */
void WINAPIV StandardErrorMessage( LPCTSTR pszAppName,
                           HWND hwndApp,
                           HINSTANCE hinstApp,
                           ULONG LogonId,
                           UINT nId,
                           int nErrorMessageLength,
                           int nArgumentListLength,
                           int nErrorResourceID, ...);
LPWSTR WINAPI GetSystemMessageW( ULONG LogonId, UINT nId /*, LPWSTR chBuffer, int chBuffSize*/ );
LPSTR WINAPI GetSystemMessageA( ULONG LogonId, UINT nId /*, LPSTR chBuffer, int chBuffSize*/ );
#ifdef UNICODE
#define GetSystemMessage GetSystemMessageW
#else
#define GetSystemMessage GetSystemMessageA
#endif

PPDPARAMS WINAPI WinEnumerateDevices( HWND hWnd,
                                      PPDCONFIG3 pPdConfig,
                                      PULONG pEntries,
                                      BOOL bInSetup );
BOOL WINAPI NetworkDeviceEnumerate( PPDCONFIG3, PULONG, PPDPARAMS,
                                    PULONG, BOOL );
BOOL WINAPI QueryCurrentWinStation( PWINSTATIONNAME pWSName, LPTSTR pUserName,
                                    PULONG pLogonId, PULONG pWSFlags );
LONG WINAPI RegGetNetworkDeviceName( HANDLE hServer, PPDCONFIG3 pPdConfig,
                                     PPDPARAMS pPdParams, LPTSTR szDeviceName,
                                     int nDeviceName );
LONG WINAPI RegGetNetworkServiceName( HANDLE hServer,
                                      LPTSTR szServiceKey,
                                      LPTSTR szServiceName,
                                      int nServiceName );
BOOL WINAPI AsyncDeviceEnumerate( PPDCONFIG3, PULONG, PPDPARAMS,
                                  PULONG, BOOL );
BOOL WINAPI NetBIOSDeviceEnumerate( PPDCONFIG3, PULONG, PPDPARAMS,
                                    PULONG, BOOL );
void WINAPI FormDecoratedAsyncDeviceName( LPTSTR pDeviceName,
                                          PASYNCCONFIG pAsyncConfig );
void WINAPI ParseDecoratedAsyncDeviceName( LPCTSTR pDeviceName,
                                           PASYNCCONFIG pAsyncConfig );
void WINAPI SetupAsyncCdConfig( PASYNCCONFIG pAsyncConfig,
                                PCDCONFIG pCdConfig );
BOOL WINAPI InstallModem( HWND hwndOwner );
BOOL WINAPI ConfigureModem( LPCTSTR pModemName, HWND hwndOwner );
BOOL GetAssociatedPortName(char  *szKeyName, WCHAR *wszPortName);
void WINAPI InitializeAnonymousUserCompareList( const WCHAR *pszServer );
BOOL WINAPI HaveAnonymousUsersChanged();
void WINAPI GetUserFromSid( PSID pSid, LPTSTR pUserName, DWORD cbUserName );
void WINAPI CachedGetUserFromSid( PSID pSid, PWCHAR pUserName, PULONG cbUserName );
BOOL WINAPI TestUserForAdmin( BOOL dom );
BOOL WINAPI IsPartOfDomain( VOID );
LPCTSTR WINAPI StrSdClass( SDCLASS SdClass );
LPCTSTR WINAPI StrConnectState( WINSTATIONSTATECLASS ConnectState,
                                BOOL bShortString );
LPCTSTR WINAPI StrProcessState( ULONG State );
LPCTSTR WINAPI StrSystemWaitReason( ULONG WaitReason );
LPCTSTR WINAPI GetUnknownString();
void WINAPI CalculateElapsedTime( LARGE_INTEGER *pTime,
                                  ELAPSEDTIME *pElapsedTime );
int WINAPI CompareElapsedTime( ELAPSEDTIME *pElapsedTime1,
                               ELAPSEDTIME *pElapsedTime2,
                               BOOL bCompareSeconds );
void WINAPI ElapsedTimeString( ELAPSEDTIME *pElapsedTime,
                               BOOL bIncludeSeconds,
                               LPTSTR pString );
void WINAPI DateTimeString( LARGE_INTEGER *pTime, LPTSTR pString );
void WINAPI CurrentDateTimeString( LPTSTR pString );
LARGE_INTEGER WINAPI CalculateDiffTime( LARGE_INTEGER, LARGE_INTEGER );
LPWSTR WINAPI EnumerateMultiUserServers( LPWSTR pDomain );

BOOL CtxGetAnyDCName( PWCHAR pServer, PWCHAR pDomain, PWCHAR pBuffer );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\termsrv\inc\tsperf.h ===
/***************************************************************************
*
* TSPERF.H
*
* Defines performance flags sent up from the client that are used to control
* which server features (typically shell) are disabled to enhance performance
* for slow links
*
* Copyright Microsoft Corporation, 2000
*
****************************************************************************/

#ifndef _INC_TSPERFH
#define _INC_TSPERFH

#ifdef __cplusplus
extern "C" {
#endif

//
// Protocol independent codes must fit in a DWORD for the termsrv
// RPC interface
//

//
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// NOTE (only applies to RDP): If you make a change here update mstsax.idl's
//                             enum values to reflect these.
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//

//
// Define the disable feature codes
//
#define TS_PERF_DISABLE_NOTHING                              0x00000000
#define TS_PERF_DISABLE_WALLPAPER                            0x00000001
#define TS_PERF_DISABLE_FULLWINDOWDRAG                       0x00000002
#define TS_PERF_DISABLE_MENUANIMATIONS                       0x00000004
#define TS_PERF_DISABLE_THEMING                              0x00000008
#define TS_PERF_ENABLE_ENHANCED_GRAPHICS                     0x00000010
#define TS_PERF_DISABLE_CURSOR_SHADOW                        0x00000020
#define TS_PERF_DISABLE_CURSORSETTINGS                       0x00000040

//
// This bit is set internally for non-experience-aware clients (win2k, ica, etc).
// Hence, is reserved
//
#define TS_PERF_DEFAULT_NONPERFCLIENT_SETTING                0x40000000
//
// The high order bit is reserved (the client uses it internally)
//
#define TS_PERF_RESERVED1                                    0x80000000

#define TS_GDIPLUS_NOTIFYMSG_STR                             TEXT("TS_GDIPLUS_NOTIFYMSG")
#ifdef __cplusplus
}
#endif


#endif  /* !_INC_TSPERFH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\termsrv\inc\tsqpublic.h ===
//===================================================
// FILE: TSQPUBLIC.H
// Interface for the generic TS Queue implementation.
//===================================================


// TS Queue flags
#define TSQUEUE_OWN_THREAD      0x01        // This TS queue is going to use its own thread to process the work items.
#define TSQUEUE_CRITICAL        0x02        // The work items on this TS queue are critical. (Delayed if this bit is 0)

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Type definition for TS queue pointer.
//typedef PTSQ (void *);

// Prototype for the callback function: The first parameter is the device object and the second parameter is the context. 
typedef VOID (*PTSQ_CALLBACK) (PDEVICE_OBJECT, PVOID);
                
// Data Structures

// Function prototypes

// Initialize the queue.
void *TSInitQueue( 
        IN ULONG Flags,                 // Flags for the TS queue.
        IN ULONG MaxThreads,            // Maximum number of threads.
        IN PDEVICE_OBJECT pDeviceObject // Device object
        );

// Add a work item to the queue.
NTSTATUS TSAddWorkItemToQueue(
        IN void *pTsQueue,                  // Pointer to the TS Queue.
        IN PVOID pContext,                  // Context.
        IN PTSQ_CALLBACK pCallBack          // Callback function.
        );

// Delete the queue.
NTSTATUS TSDeleteQueue(PVOID pTsQueue);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\termsrv\inc\tscfgex.h ===
/*++

Copyright (C) 1989-1998 Microsoft Corporation, All rights reserved

Module:
    tscfgex.h

Abstract:
    Terminal Server Connection Configuration DLL extension data structures
    and function prototypes.

Author:
    Brad Graziadio (BradG) 4-Feb-98

--*/

#ifndef _TSCFGEX_
#define _TSCFGEX_

#include <winsta.h>

//
// This data structure is used to represent the list of encryption
// levels that a protocol supports.
//
typedef struct _EncLevel {
    WORD    StringID;           // Resource ID to lookup in DLLs resource table
    DWORD   RegistryValue;      // DWORD value to set in registry
    WORD    Flags;              // Flags (see ELF_* values below)
} EncryptionLevel, *PEncryptionLevel;

// Flags for EncryptionLevel.Flags
#define ELF_DEFAULT     0x0001

typedef LONG (WINAPI *LPFNEXTENCRYPTIONLEVELSPROC) (WDNAME *pWdName, EncryptionLevel **);

//
// Flags for ExtGetCapabilities
//
const ULONG WDC_CLIENT_DRIVE_MAPPING            = 0x00000001;
const ULONG WDC_WIN_CLIENT_PRINTER_MAPPING      = 0x00000002;
const ULONG WDC_CLIENT_LPT_PORT_MAPPING         = 0x00000004;
const ULONG WDC_CLIENT_COM_PORT_MAPPING         = 0x00000008;
const ULONG WDC_CLIENT_CLIPBOARD_MAPPING        = 0x00000010;
const ULONG WDC_CLIENT_AUDIO_MAPPING            = 0x00000020;
const ULONG WDC_SHADOWING                       = 0x00000040;
const ULONG WDC_PUBLISHED_APPLICATIONS          = 0x00000080;
const ULONG WDC_RECONNECT_PREVCLIENT			= 0X00000100;

#define WDC_CLIENT_DIALOG_MASK (WDC_CLIENT_DRIVE_MAPPING | \
                                WDC_WIN_CLIENT_PRINTER_MAPPING | \
                                WDC_CLIENT_LPT_PORT_MAPPING | \
                                WDC_CLIENT_COM_PORT_MAPPING | \
                                WDC_CLIENT_CLIPBOARD_MAPPING | \
                                WDC_CLIENT_AUDIO_MAPPING)


#define WDC_CLIENT_CONNECT_MASK = (WDC_CLIENT_DRIVE_MAPPING | \
                                  WDC_WIN_CLIENT_PRINTER_MAPPING | \
                                  WDC_CLIENT_LPT_PORT_MAPPING)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\termsrv\inc\versome.h ===
/***************************************************************************
*
*  VERSOME.H
*
*  Include this header file for proper resource version where some Citrix
*  code has been added to an existing NT component.  See ctxver.h for details.
*
*  Copyright Microsoft Corporation, 1998
*
*
****************************************************************************/

#define VER_CTXCONTENT      1
#define VER_CTXSOMECONTENT  1

#include <ctxver.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\termsrv\inc\winstaw.h ===
/***************************************************************************
*
*  WINSTAW.H   (UNICODE version)
*
*  This module contains external window station defines and structures
*
*  Copyright Microsoft Corporation, 1998
*
*
****************************************************************************/

#ifndef UNICODE
#define _WINSTAW
#define UNICODE
#endif

#include <winsta.h>

#ifdef _WINSTAW
#undef UNICODE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\termsrv\inc\winddits.h ===
/*++

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:

    winddits.h

Abstract:

    Private entry points, defines and types for Windows NT GDI device
    driver interfaces for terminal server.

--*/

#ifndef _WINDDITS_
#define _WINDDITS_

/*
 *  Mouse position
 *
 *  Normal == Primary stack i.e moves sent up from the client
 *  Procedural == Programmatic moves that originate at the server side
 *  Shadow == Moves that orginate at the shadow client
 */

#define MP_NORMAL                               0x00
#define MP_PROCEDURAL                           0x01 
#define MP_TERMSRV_SHADOW                       0x02


#define INDEX_DrvConnect                        INDEX_DrvReserved1
#define INDEX_DrvDisconnect                     INDEX_DrvReserved2
#define INDEX_DrvReconnect                      INDEX_DrvReserved3
#define INDEX_DrvShadowConnect                  INDEX_DrvReserved4
#define INDEX_DrvShadowDisconnect               INDEX_DrvReserved5
#define INDEX_DrvInvalidateRect                 INDEX_DrvReserved6
#define INDEX_DrvSetPointerPos                  INDEX_DrvReserved7
#define INDEX_DrvDisplayIOCtl                   INDEX_DrvReserved8

#define INDEX_DrvMovePointerEx                  INDEX_DrvReserved11

#ifdef __cplusplus
extern "C" {
#endif

BOOL APIENTRY DrvConnect(HANDLE, PVOID, PVOID, PVOID);

BOOL APIENTRY DrvDisconnect(HANDLE, PVOID);

BOOL APIENTRY DrvReconnect(HANDLE, PVOID);

BOOL APIENTRY DrvShadowConnect(PVOID pClientThinwireData, 
                               ULONG ThinwireDataLength);

BOOL APIENTRY DrvShadowDisconnect(PVOID pClientThinwireData, 
                                  ULONG ThinwireDataLength);
                                  
BOOL APIENTRY DrvMovePointerEx(SURFOBJ*, LONG, LONG, ULONG);

DWORD APIENTRY EngGetTickCount();

VOID APIENTRY EngFileWrite(
    HANDLE hFileObject,
    PVOID Buffer,
    ULONG Length,
    PULONG pActualLength
    );

DWORD APIENTRY EngFileIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned
    );

PVOID APIENTRY EngAllocSectionMem(
    PVOID   *pSectionObject,
    ULONG   fl,
    ULONG   cj,
    ULONG   tag
    );
    
BOOL APIENTRY EngFreeSectionMem(
    PVOID SectionObject,
    PVOID pv    
    );     
    
BOOL APIENTRY EngMapSection(
    PVOID SectionObject,
    BOOL bMap,
    HANDLE ProcessHandle,
    PVOID *pMapBase
    );         


#ifdef __cplusplus
}
#endif

#endif //  _WINDDITS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\termsrv\inc\winsta.h ===
/***************************************************************************
*
*  WINSTA.H
*
*  This module contains external window station defines and structures
*
*  Copyright Microsoft Corporation, 1998
*
*
****************************************************************************/

#ifndef _INC_WINSTAH
#define _INC_WINSTAH

#ifdef __cplusplus
extern "C" {
#endif

#ifndef WINAPI
#define WINAPI      __stdcall
#endif

#ifndef BYTE
#define BYTE unsigned char
#endif


#include <hydrix.h>
#include <ctxdef.h>


/***********
 *  Defines
 ***********/

#define PROTOCOL_DISCONNECT      0xffff // disconnected session.
#define PROTOCOL_CONSOLE         0    // local console 
#define PROTOCOL_ICA             1    // ICA Protocol
#define PROTOCOL_TSHARE          2    // RDP Protocol (old name T.Share)
#define PROTOCOL_RDP             2    // RDP protocol

#define PDNAME_LENGTH            32
#define WDNAME_LENGTH            32
#define CDNAME_LENGTH            32
#define DEVICENAME_LENGTH        128
#define MODEMNAME_LENGTH         DEVICENAME_LENGTH
#define CALLBACK_LENGTH          50
#define LICENSE_PASSWORD_LENGTH  16
#define DLLNAME_LENGTH           32
#define PRINTERNAME_LENGTH       32
#define WINSTATIONCOMMENT_LENGTH 60
#define APPSERVERNAME_LENGTH     17
#define WDPREFIX_LENGTH          12
#define CLIENT_PRODUCT_ID_LENGTH 32

#define NASISPECIFICNAME_LENGTH    14
#define NASIUSERNAME_LENGTH        47
#define NASIPASSWORD_LENGTH        24
#define NASISESSIONNAME_LENGTH     16
#define NASIFILESERVER_LENGTH      47

#define LOGONID_CURRENT     ((ULONG)-1)
#define LOGONID_NONE        ((ULONG)-2)
#define SERVERNAME_CURRENT  ((HANDLE)NULL)

#define MAX_PDCONFIG             10  // maximum number of PDs per WinStation
#define MAX_UI_MODULES           5   // maximum client user interface modules
#define PSZ_ANONYMOUS           TEXT("Anonymous")

#define WINFRAME_SOFTKEY_CLASS L"WinFrameSoftkey"
#define WINFRAME_SOFTKEY_APPLICATION L"wfskey.exe"

#define OEM_ID_LENGTH                        3

// TermSrv Counters
#define TERMSRV_TOTAL_SESSIONS     1     // total number of sessions ever connected
#define TERMSRV_DISC_SESSIONS      2     // total number of disconnected sessions
#define TERMSRV_RECON_SESSIONS     3     // total number of reconnected sessions
#define TERMSRV_CURRENT_ACTIVE_SESSIONS 4   // total of currently active sessions
#define TERMSRV_CURRENT_DISC_SESSIONS   5   // total of currently disconnected sessions
#define TERMSRV_PENDING_SESSIONS        6   // total number of Pending Sessions
#define TERMSRV_SUCC_TOTAL_LOGONS       7   // total number of successful logons
#define TERMSRV_SUCC_LOCAL_LOGONS       8   // total number of successful local logons
#define TERMSRV_SUCC_REMOTE_LOGONS      9   // total number of successful remote logons
#define TERMSRV_SUCC_SESSION0_LOGONS   10   // total number of successful session 0 logons

   
// Color depth setting
#define TS_CLIENT_COMPAT_BPP_SUPPORT    0x3e7   // decimal 999
#define TS_24BPP_SUPPORT    0x04
#define TS_16BPP_SUPPORT    0x03
#define TS_15BPP_SUPPORT    0x02
#define TS_8BPP_SUPPORT     0x01


    

/*********************************
 *   WinStationOpen access values
 *********************************/
#define WINSTATION_QUERY        0x00000001  // WinStationQueryInformation()
#define WINSTATION_SET          0x00000002  // WinStationSetInformation()
#define WINSTATION_RESET        0x00000004  // WinStationReset()
#define WINSTATION_VIRTUAL      0x00000008  // read/write direct data
#define WINSTATION_SHADOW       0x00000010  // WinStationShadow()
#define WINSTATION_LOGON        0x00000020  // logon to WinStation
#define WINSTATION_LOGOFF       0x00000040  // WinStationLogoff()
#define WINSTATION_MSG          0x00000080  // WinStationMsg()
#define WINSTATION_CONNECT      0x00000100  // WinStationConnect()
#define WINSTATION_DISCONNECT   0x00000200  // WinStationDisconnect()

#define WINSTATION_GUEST_ACCESS (WINSTATION_LOGON)

#define WINSTATION_CURRENT_GUEST_ACCESS (WINSTATION_VIRTUAL | WINSTATION_LOGOFF)

#define WINSTATION_USER_ACCESS (WINSTATION_GUEST_ACCESS |                      \
                                WINSTATION_QUERY | WINSTATION_CONNECT )

#define WINSTATION_CURRENT_USER_ACCESS (WINSTATION_SET | WINSTATION_RESET      \
                                        WINSTATION_VIRTUAL | WINSTATION_LOGOFF \
                                        WINSTATION_DISCONNECT)

#define WINSTATION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | WINSTATION_QUERY |   \
                                WINSTATION_SET | WINSTATION_RESET |            \
                                WINSTATION_VIRTUAL |    WINSTATION_SHADOW |    \
                                WINSTATION_LOGON |                             \
                                WINSTATION_MSG |                               \
                                WINSTATION_CONNECT | WINSTATION_DISCONNECT)


/************
 *  Typedefs
 ************/

#define LOGONIDW SESSIONIDW      //externalized LogonID as SessionID in ctxapi.h
#define PLOGONIDW PSESSIONIDW
#define LOGONIDA SESSIONIDA
#define PLOGONIDA PSESSIONIDA
#ifdef UNICODE
#define LOGONID LOGONIDW
#define PLOGONID PLOGONIDW
#else
#define LOGONID LOGONIDA
#define PLOGONID PLOGONIDA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef WCHAR PDNAMEW[ PDNAME_LENGTH + 1 ];
typedef WCHAR * PPDNAMEW;

typedef CHAR PDNAMEA[ PDNAME_LENGTH + 1 ];
typedef CHAR * PPDNAMEA;

#ifdef UNICODE
#define PDNAME PDNAMEW
#define PPDNAME PPDNAMEW
#else
#define PDNAME PDNAMEA
#define PPDNAME PPDNAMEA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef WCHAR WDNAMEW[ WDNAME_LENGTH + 1 ];
typedef WCHAR * PWDNAMEW;

typedef CHAR WDNAMEA[ WDNAME_LENGTH + 1 ];
typedef CHAR * PWDNAMEA;

#ifdef UNICODE
#define WDNAME WDNAMEW
#define PWDNAME PWDNAMEW
#else
#define WDNAME WDNAMEA
#define PWDNAME PWDNAMEA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef WCHAR CDNAMEW[ CDNAME_LENGTH + 1 ];
typedef WCHAR * PCDNAMEW;

typedef CHAR CDNAMEA[ CDNAME_LENGTH + 1 ];
typedef CHAR * PCDNAMEA;

#ifdef UNICODE
#define CDNAME CDNAMEW
#define PCDNAME PCDNAMEW
#else
#define CDNAME CDNAMEA
#define PCDNAME PCDNAMEA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef WCHAR DEVICENAMEW[ DEVICENAME_LENGTH + 1 ];
typedef WCHAR * PDEVICENAMEW;

typedef CHAR DEVICENAMEA[ DEVICENAME_LENGTH + 1 ];
typedef CHAR * PDEVICENAMEA;

#ifdef UNICODE
#define DEVICENAME DEVICENAMEW
#define PDEVICENAME PDEVICENAMEW
#else
#define DEVICENAME DEVICENAMEA
#define PDEVICENAME PDEVICENAMEA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef WCHAR MODEMNAMEW[ MODEMNAME_LENGTH + 1 ];
typedef WCHAR * PMODEMNAMEW;

typedef CHAR MODEMNAMEA[ MODEMNAME_LENGTH + 1 ];
typedef CHAR * PMODEMNAMEA;

#ifdef UNICODE
#define MODEMNAME MODEMNAMEW
#define PMODEMNAME PMODEMNAMEW
#else
#define MODEMNAME MODEMNAMEA
#define PMODEMNAME PMODEMNAMEA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef WCHAR DLLNAMEW[ DLLNAME_LENGTH + 1 ];
typedef WCHAR * PDLLNAMEW;

typedef CHAR DLLNAMEA[ DLLNAME_LENGTH + 1 ];
typedef CHAR * PDLLNAMEA;

#ifdef UNICODE
#define DLLNAME DLLNAMEW
#define PDLLNAME PDLLNAMEW
#else
#define DLLNAME DLLNAMEA
#define PDLLNAME PDLLNAMEA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef WCHAR PRINTERNAMEW[ PRINTERNAME_LENGTH + 1 ];
typedef WCHAR * PPRINTERNAMEW;

typedef CHAR PRINTERNAMEA[ PRINTERNAME_LENGTH + 1 ];
typedef CHAR * PPRINTERNAMEA;

#ifdef UNICODE
#define PRINTERNAME PRINTERNAMEW
#define PPRINTERNAME PPRINTERNAMEW
#else
#define PRINTERNAME PRINTERNAMEA
#define PPRINTERNAME PPRINTERNAMEA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef WCHAR WDPREFIXW[ WDPREFIX_LENGTH + 1 ];
typedef WCHAR * PWDPREFIXW;

typedef CHAR WDPREFIXA[ WDPREFIX_LENGTH + 1 ];
typedef CHAR * PWDPREFIXA;

#ifdef UNICODE
#define WDPREFIX WDPREFIXW
#define PWDPREFIX PWDPREFIXW
#else
#define WDPREFIX WDPREFIXA
#define PWDPREFIX PWDPREFIXA
#endif /* UNICODE */

/*------------------------------------------------*/

#ifdef UNICODE
#define NASISPECIFICNAME NASISPECIFICNAMEW
#define PNASISPECIFICNAME PNASISPECIFICNAMEW
#define NASIUSERNAME NASIUSERNAMEW
#define PNASIUSERNAME PNASIUSERNAMEW
#define NASIPASSWORD NASIPASSWORDW
#define PNASIPASSWORD PNASIPASSWORDW
#define NASISESSIONNAME NASISESSIONNAMEW
#define PNASISESSIONNAME PNASISESSIONNAMEW
#define NASIFILESERVER NASIFILESERVERW
#define PNASIFILESERVER PNASIFILESERVERW
#else
#define NASISPECIFICNAME NASISPECIFICNAMEA
#define PNASISPECIFICNAME PNASISPECIFICNAMEA
#define NASIUSERNAME NASIUSERNAMEA
#define PNASIUSERNAME PNASIUSERNAMEA
#define NASIPASSWORD NASIPASSWORDA
#define PNASIPASSWORD PNASIPASSWORDA
#define NASISESSIONNAME NASISESSIONNAMEA
#define PNASISESSIONNAME PNASISESSIONNAMEA
#define NASIFILESERVER NASIFILESERVERA
#define PNASIFILESERVER PNASIFILESERVERA
#endif /* UNICODE */

typedef WCHAR   NASISPECIFICNAMEW[ NASISPECIFICNAME_LENGTH + 1 ];
typedef WCHAR   NASIUSERNAMEW[ NASIUSERNAME_LENGTH + 1 ];
typedef WCHAR   NASIPASSWORDW[ NASIPASSWORD_LENGTH + 1 ];
typedef WCHAR   NASISESIONNAMEW[ NASISESSIONNAME_LENGTH + 1 ];
typedef WCHAR   NASIFILESERVERW[ NASIFILESERVER_LENGTH + 1 ];

typedef CHAR    NASISPECIFICNAMEA[ NASISPECIFICNAME_LENGTH + 1 ];
typedef CHAR    NASIUSERNAMEA[ NASIUSERNAME_LENGTH + 1 ];
typedef CHAR    NASIPASSWORDA[ NASIPASSWORD_LENGTH + 1 ];
typedef CHAR    NASISESIONNAMEA[ NASISESSIONNAME_LENGTH + 1 ];
typedef CHAR    NASIFILESERVERA[ NASIFILESERVER_LENGTH + 1 ];

/*------------------------------------------------*/

#define STACK_ADDRESS_LENGTH 128

/*
 *  Stack address structure
 */
typedef struct _ICA_STACK_ADDRESS {
    BYTE Address[ STACK_ADDRESS_LENGTH ];   // bytes 0,1 family, 2-n address
} ICA_STACK_ADDRESS, *PICA_STACK_ADDRESS;

// Support for long Username, Password and Domain during autologon
#define EXTENDED_USERNAME_LEN 255
#define EXTENDED_PASSWORD_LEN 255
#define EXTENDED_DOMAIN_LEN 255

/*
 * Structure to hold the longer UserName and Password
 */
typedef struct _ExtendedClientCredentials { 
    WCHAR UserName[EXTENDED_USERNAME_LEN + 1];
    WCHAR Password[EXTENDED_PASSWORD_LEN + 1];
    WCHAR Domain[EXTENDED_DOMAIN_LEN + 1] ; 
}ExtendedClientCredentials, *pExtendedClientCredentials; 

// Type of info queried from TermSrv to RdpWsx via WlxEscape
// add more to this INFO_TYPE as need arises later on
typedef enum
{
   GET_LONG_USERNAME,
   GET_CLIENT_RANDOM,
   GET_CS_AUTORECONNECT_INFO,  //arc verifier
   GET_SC_AUTORECONNECT_INFO,  //arc random
} INFO_TYPE ; 

/*********************************
 *  User Configuration structures
 *********************************/

/*------------------------------------------------*/

typedef WCHAR APPLICATIONNAMEW[ MAX_BR_NAME ];
typedef WCHAR *PAPPLICATIONNAMEW;

typedef CHAR APPLICATIONNAMEA[ MAX_BR_NAME ];
typedef CHAR *PAPPLICATIONNAMEA;

#ifdef UNICODE
#define APPLICATIONNAME APPLICATIONNAMEW
#define PAPPLICATIONNAME PAPPLICATIONNAMEW
#else
#define APPLICATIONNAME APPLICATIONNAMEA
#define PAPPLICATIONNAME PAPPLICATIONNAMEA
#endif /* UNICODE */

/*------------------------------------------------*/

/*
 *  Shadow options
 */
typedef enum _SHADOWCLASS {
    Shadow_Disable,
    Shadow_EnableInputNotify,
    Shadow_EnableInputNoNotify,
    Shadow_EnableNoInputNotify,
    Shadow_EnableNoInputNoNotify,
} SHADOWCLASS;

/*------------------------------------------------*/

/*
 *  Callback options
 */
typedef enum _CALLBACKCLASS {
    Callback_Disable,
    Callback_Roving,
    Callback_Fixed,
} CALLBACKCLASS;

/*------------------------------------------------*/

//
// These are flags that if set, then data from the policy tree is avalible.
// If flag is not set, then there was no corresponding data item from the policy tree.
//
// At this time, the actual data is stored in a copy of userconfigw used as a scrath pad
// for the values found under group policy. The debate of what belongs to group policy has not
// been fully settled, and once that is resolved, I will probably move the data into this struct too.
// AraBern, March 29, 2000 (2 days away from code complete !)
//
//
typedef struct _POLICY_TS_USER {

    // ------------------------------------------------------------------------------
    // Some notes, March 11, 2000
    //
    //
    // fInheritAutoLogon 
    // fPromptForPassword 
    // UserName 
    // Domain
    // Password
    //      Used in WsxInitializeClientData()
    //      of \\index1\src\newnt\termsrv\rdpwsx\rdpex\tsrvwsx.c
    //      This is NOT exposed thru Group Policy
    
    // fInheritAutoClient
    //      There are 3 items which are individually being set thru Group Policy
    
    // fDisableEncryption 
    // MinEncryptionLevel;
    //      The policy for these is set thru fPolicyInheritSecurity, but no UI for these...
    
    // fWorkDirectory
    // fInitialProgram
    //       fPolicyInheritInitialProgram 
    //       will take care of these:
   
    // These seem to be used without being overriden by machine wide data
    // KeyboardLayout
   
    // fMaximize
    // fHideTitleBar 
    //      used in
    //      \\index1\src\newnt\termsrv\rdpwsx\rdpex\tsrvwsx.c 
    
   
    // These seem to be used by RDP, but are not overriden by any
    // Potentially stale WTS API stuff:
    // PublishedName
    //      used by WTSQuerySessionInformationW(), in response to
    //      request of WTSApplicationName. It's not used elsewhere!
    
     
    // These are set and retrieved, but play no meaningful roles.
    // fUseDefaultGina
    // fRequireEncryption
    
    // These are probably meaningless
    // fHomeDirectoryMapRoot
    // NWLogonServer
    //    \\index1\src\newnt\termsrv\tsuserex\tsusrsht.cpp
    //    and NETWARE ifdef'd in \\index1\src\newnt\termsrv\wtsapi\config.c
    
    
    // These are not used AT ALL, are only present in .w or .h files
    // fPublishedApp
    
      
    //
    //     ULONG   fPolicyDisableCpm : 1;                      // Printer, exposed thru TSCC
    //                                                         // Equivalent to ClientLptDef
    //
    //     ULONG   fPolicyDisableCdm : 1;                      // Drive, exposed thru TSCC
    //                                                         // Equivalent to ClientDrives.
    //
    //     ULONG   fPolicyDisableLPT : 1;                      // LPTPort, exposed thru TSCC
    //                                                         // Equivalent to ClientLPT
    //
    //     Protocol wide in NT2195 for Ccm, Clip, and Cam
    //     Make these machine policy
    //     ULONG   fPolicyDisableCcm : 1;                      // ComPort, exposed thru TSCC
    //
    //     ULONG   fPolicyDisableClip: 1;                      // Clipboad, exposed thru TSCC
    //
    //     ULONG   fPolicyDisableCam : 1;                      // Audio, exposed thru TSCC
    //
    //     OLD.....................................
    //     ULONG   fPolicyDisableExe : 1;                      //         not exposed thru TSCC, OLD tsCFG had it
    //     ........................................
    
    ULONG fPolicyResetBroken : 1 ;               
    ULONG fPolicyReconnectSame : 1 ;            
    ULONG fPolicyInitialProgram : 1 ;           
    
   
    ULONG fPolicyCallback : 1 ;                 
    ULONG fPolicyCallbackNumber : 1 ;            
    
    ULONG fPolicyShadow : 1 ;                    
    ULONG fPolicyMaxSessionTime : 1 ;            
    ULONG fPolicyMaxDisconnectionTime:1;         
    ULONG fPolicyMaxIdleTime : 1 ;               

    ULONG fPolicyAutoClientDrives : 1 ;          
    ULONG fPolicyAutoClientLpts : 1 ;           
    ULONG fPolicyForceClientLptDef : 1 ;       
    

} POLICY_TS_USER, * PPOLICY_TS_USER;

//
// 
// The USERCONFIGW struct contained both machine and user config data. We have split the
// data into two kinds of policies, a user policy and a machine policy.
//
// The below struct is the machine policy, which includes both a flag to indicate the policy is 
// present, and a value for that policy. 
// 
// 
// And finally, why am I not using arays? Well I should have, but, originally, the design was
// to user winstation->Config->User->User as the central repository for all data, which meant that all
// I needed here were policy-present bits, not the policy data. However, the Product "feature" has 
// gone thru 3 mutations, and when it finally got to this point, I had very little time to make
// any changes.
//
// I will consider to create a class that encapsulates all policy related bits.
// AraBern, March 29, 2000 (2 days away from code complete !
//
typedef struct _POLICY_TS_MACHINE
{
   
    ULONG   fPolicyDisableClip : 1 ;           
    ULONG   fPolicyDisableCam : 1 ;                          
    ULONG   fPolicyDisableCcm : 1 ;
    ULONG   fPolicyDisableLPT : 1;
    ULONG   fPolicyDisableCpm : 1;
    ULONG   fPolicyPromptForPassword : 1 ;
    ULONG   fPolicyMaxInstanceCount : 1;
    ULONG   fPolicyMinEncryptionLevel : 1 ;
    ULONG   fPolicyFipsEnabled : 1;
    ULONG   fPolicyDisableAutoReconnect : 1;
     
    // These are new and used as machine-wide, so in a sense they are machine config data 
    //       especially that USERCONFIGW has entries for these     
    ULONG   fPolicyWFProfilePath: 1 ;
    ULONG   fPolicyWFHomeDir: 1 ;
    ULONG   fPolicyWFHomeDirDrive: 1 ;
    
    // this is new, and is present in here for the sake of consistancey. However, there is a special
    // func that is used by th's main connection loop to just look for this single item, in order
    // to save time.
    ULONG   fPolicyDenyTSConnections      : 1;              // if set, TS is basically OFF in the sense that nobody can connect.
    
    // these are not part of TS machine config data struct, but winlogn does use these and treats
    // them as per machine type of a policy
    ULONG   fPolicyTempFoldersPerSession  : 1;        // Use tmp folder per each session, instead of one common tmp folder
    ULONG   fPolicyDeleteTempFoldersOnExit: 1;       // on exit, do a cleanup of tmp folders
    
    ULONG   fPolicyColorDepth  : 1;

    ULONG   fPolicySessionDirectoryActive  : 1;
    ULONG   fPolicySessionDirectoryLocation  : 1;
    ULONG   fPolicySessionDirectoryClusterName  : 1;
    ULONG   fPolicySessionDirectoryAdditionalParams  : 1;
    ULONG   fPolicySessionDirectoryExposeServerIP  : 1;

    ULONG   fPolicyPreventLicenseUpgrade  : 1;
	ULONG   fPolicySecureLicensing : 1;
    
    ULONG   fPolicyWritableTSCCPermissionsTAB : 1;
    
    ULONG   fPolicyDisableCdm : 1;
    ULONG   fPolicyForceClientLptDef : 1;
    ULONG   fPolicyShadow : 1 ;                    
    ULONG   fPolicyResetBroken : 1 ;               
    ULONG   fPolicyReconnectSame : 1 ;            
    ULONG   fPolicyMaxSessionTime : 1 ;            
    ULONG   fPolicyMaxDisconnectionTime:1;         
    ULONG   fPolicyMaxIdleTime : 1 ;               
    ULONG   fPolicyInitialProgram : 1 ;           
    ULONG   fPolicySingleSessionPerUser : 1;
    ULONG   fPolicyDisableWallpaper : 1;
    ULONG   fPolicyKeepAlive   : 1;
    ULONG   fPolicyEnableTimeZoneRedirection : 1;
    ULONG   fPolicyDisableForcibleLogoff : 1;
	
    //ULONG   fPolicyProtectAgainstDOSAttack : 1;  //This policy isn't currently used but may be added at some point
    //ULONG   fPolicyRequireCredentialsDuringConnection : 1; //This policy isn't currently used but may be added at some point
    
    //
    // And now the data if policy is set. Not all items get data, some are just flags.
    //
    // Bit-fields first.
    //
    //
    
    ULONG   fDisableClip : 1 ;           
    ULONG   fDisableCam : 1 ;                          
    ULONG   fDisableCcm : 1 ;
    ULONG   fDisableLPT : 1;
    ULONG   fDisableCpm : 1;
    ULONG   fPromptForPassword : 1 ;
    
    ULONG   ColorDepth : 3;
    
    ULONG   fDenyTSConnections      : 1;              // if set, TS is basically OFF in the sense that nobody can connect.
    
    // these are not part of TS machine config data struct, but winlogn does use these and treats
    // them as per machine type of a policy
    ULONG   fTempFoldersPerSession  : 1;        // Use tmp folder per each session, instead of one common tmp folder
    ULONG   fDeleteTempFoldersOnExit: 1;       // on exit, do a cleanup of tmp folders
    
    ULONG   fWritableTSCCPermissionsTAB : 1;      // if set, then admins can change the per connection security descriptor.
   
    ULONG   fDisableCdm  : 1;
    ULONG   fForceClientLptDef : 1; 
    ULONG   fResetBroken : 1 ;               
    ULONG   fReconnectSame : 1 ;            
    ULONG   fSingleSessionPerUser:1;
    ULONG   fDisableWallpaper : 1;
    ULONG   fKeepAliveEnable : 1;
    ULONG   fPreventLicenseUpgrade:1;
	ULONG   fSecureLicensing:1;
    ULONG   fEnableTimeZoneRedirection : 1;
    ULONG   fDisableAutoReconnect : 1;
    ULONG   fDisableForcibleLogoff : 1;
    
    //ULONG   fProtectAgainstDOSAttack : 1;  //This policy isn't currently used but may be added at some point
    //ULONG   fRequireCredentialsDuringConnection : 1;
    ULONG   fPolicyEncryptRPCTraffic : 1;
    ULONG   fEncryptRPCTraffic : 1;
    //
    //Different error flags
    //
    ULONG   fErrorInvalidProfile : 1; //Set if WFProfilePath, WFHomeDir, or WFHomeDirDrive are invalid (too long).

    //
    // Non bit-fields next
    // 
    
    ULONG   MaxInstanceCount;
    
    BYTE    MinEncryptionLevel;
    
    WCHAR   WFProfilePath[ DIRECTORY_LENGTH + 1 ];

    WCHAR   WFHomeDir[ DIRECTORY_LENGTH + 1 ];

    WCHAR   WFHomeDirDrive[ 4 ];
    
    ULONG   SessionDirectoryActive;
    WCHAR   SessionDirectoryLocation[DIRECTORY_LENGTH+1];
    WCHAR   SessionDirectoryClusterName[DIRECTORY_LENGTH+1];
    WCHAR   SessionDirectoryAdditionalParams[DIRECTORY_LENGTH+1];
    ULONG   SessionDirectoryExposeServerIP;
    ULONG   KeepAliveInterval;
    
    SHADOWCLASS     Shadow;
    ULONG           MaxConnectionTime;            
    ULONG           MaxDisconnectionTime;         
    ULONG           MaxIdleTime;               
  
    // Start program Policy
    WCHAR WorkDirectory[ DIRECTORY_LENGTH + 1 ];
    WCHAR InitialProgram[ INITIALPROGRAM_LENGTH + 1 ];

  
    
    // these have nothing to do with the USERCONFIGW data structure , not sure if I will keep them here.
    //    ULONG   fHideUserTabInTaskMan   : 1;        // When set, the new Users TAB in task man is hidden.
    //    ULONG   fDenyTSCCUsage          : 1;        // When set, you can't use TSCC
    //    ULONG   fHideTSCCPermissionsTAB : 1;        // allow TSCC to surface the permissions dialog, so that each connection
                                                    // gets it's own permissions list
                                                    
    // No UI for setting these in NT2195. Do we want to make these policies?
        //     ULONG fPolicyInheritSecurity : 1 ;
        //     ULONG fDisableEncryption    : 1;
        //
} POLICY_TS_MACHINE, *PPOLICY_TS_MACHINE;

/*
 *  User Configuration data
 */
typedef struct _USERCONFIGW {

    /* if flag is set inherit parameter from user or client configuration */
    ULONG fInheritAutoLogon : 1;
    ULONG fInheritResetBroken : 1;
    ULONG fInheritReconnectSame : 1;
    ULONG fInheritInitialProgram : 1;
    ULONG fInheritCallback : 1;
    ULONG fInheritCallbackNumber : 1;
    ULONG fInheritShadow : 1;
    ULONG fInheritMaxSessionTime : 1;
    ULONG fInheritMaxDisconnectionTime : 1;
    ULONG fInheritMaxIdleTime : 1;
    ULONG fInheritAutoClient : 1;
    ULONG fInheritSecurity : 1;

    ULONG fPromptForPassword : 1;      // fInheritAutoLogon
    ULONG fResetBroken : 1;
    ULONG fReconnectSame : 1;
    ULONG fLogonDisabled : 1;
    ULONG fWallPaperDisabled : 1;
    ULONG fAutoClientDrives : 1;
    ULONG fAutoClientLpts : 1;
    ULONG fForceClientLptDef : 1;
    ULONG fRequireEncryption : 1;
    ULONG fDisableEncryption : 1;
    ULONG fUnused1 : 1;                 // old fDisableIniFileMapping
    ULONG fHomeDirectoryMapRoot : 1;
    ULONG fUseDefaultGina : 1;
    ULONG fCursorBlinkDisabled : 1;

    ULONG fPublishedApp : 1;
    ULONG fHideTitleBar : 1;
    ULONG fMaximize : 1;

    ULONG fDisableCpm : 1;
    ULONG fDisableCdm : 1;
    ULONG fDisableCcm : 1;
    ULONG fDisableLPT : 1;
    ULONG fDisableClip : 1;
    ULONG fDisableExe : 1;
    ULONG fDisableCam : 1;
    
    ULONG fDisableAutoReconnect : 1;

    /* fInheritColorDepth */
    ULONG ColorDepth : 3;

    //NA 2/19/01
    ULONG fInheritColorDepth: 1;
    
    //
    //Different error flags
    //
    ULONG   fErrorInvalidProfile : 1; //Set if WFProfilePath, WFHomeDir, or WFHomeDirDrive are invalid (too long).

    /* fInheritAutoLogon */
    WCHAR UserName[ USERNAME_LENGTH + 1 ];
    WCHAR Domain[ DOMAIN_LENGTH + 1 ];
    WCHAR Password[ PASSWORD_LENGTH + 1 ];

    /* fInheritInitialProgram */
    WCHAR WorkDirectory[ DIRECTORY_LENGTH + 1 ];
    WCHAR InitialProgram[ INITIALPROGRAM_LENGTH + 1 ];

    /* fInheritCallback */
    WCHAR CallbackNumber[ CALLBACK_LENGTH + 1 ];
    CALLBACKCLASS Callback;

    /* fInheritShadow */
    SHADOWCLASS Shadow;

    ULONG MaxConnectionTime;
    ULONG MaxDisconnectionTime;
    ULONG MaxIdleTime;

    ULONG KeyboardLayout;               // 0 = inherit

    /* fInheritSecurity */
    BYTE MinEncryptionLevel;

    WCHAR NWLogonServer[ NASIFILESERVER_LENGTH + 1 ];

    APPLICATIONNAMEW PublishedName;

    /* WinFrame Profile Path - Overrides standard profile path */
    WCHAR WFProfilePath[ DIRECTORY_LENGTH + 1 ];

    /* WinFrame Home Directory - Overrides standard Home Directory */
    WCHAR WFHomeDir[ DIRECTORY_LENGTH + 1 ];

    /* WinFrame Home Directory Drive - Overrides standard Home Directory Drive*/
    WCHAR WFHomeDirDrive[ 4 ];

} USERCONFIGW, * PUSERCONFIGW;

typedef struct _USERCONFIGA {

    /* if flag is set inherit parameter from user or client configuration */
    ULONG fInheritAutoLogon : 1;
    ULONG fInheritResetBroken : 1;
    ULONG fInheritReconnectSame : 1;
    ULONG fInheritInitialProgram : 1;
    ULONG fInheritCallback : 1;
    ULONG fInheritCallbackNumber : 1;
    ULONG fInheritShadow : 1;
    ULONG fInheritMaxSessionTime : 1;
    ULONG fInheritMaxDisconnectionTime : 1;
    ULONG fInheritMaxIdleTime : 1;
    ULONG fInheritAutoClient : 1;
    ULONG fInheritSecurity : 1;

    ULONG fPromptForPassword : 1;      // fInheritAutoLogon
    ULONG fResetBroken : 1;
    ULONG fReconnectSame : 1;
    ULONG fLogonDisabled : 1;
    ULONG fWallPaperDisabled : 1;
    ULONG fAutoClientDrives : 1;
    ULONG fAutoClientLpts : 1;
    ULONG fForceClientLptDef : 1;
    ULONG fRequireEncryption : 1;
    ULONG fDisableEncryption : 1;
    ULONG fUnused1 : 1;                 // old fDisableIniFileMapping
    ULONG fHomeDirectoryMapRoot : 1;
    ULONG fUseDefaultGina : 1;
    ULONG fCursorBlinkDisabled : 1;

    ULONG fPublishedApp : 1;
    ULONG fHideTitleBar : 1;
    ULONG fMaximize : 1;

    ULONG fDisableCpm : 1;
    ULONG fDisableCdm : 1;
    ULONG fDisableCcm : 1;
    ULONG fDisableLPT : 1;
    ULONG fDisableClip : 1;
    ULONG fDisableExe : 1;
    ULONG fDisableCam : 1;
    
    ULONG fDisableAutoReconnect : 1;
    
    //
    //Different error flags
    //
    ULONG   fErrorInvalidProfile : 1; //Set if WFProfilePath, WFHomeDir, or WFHomeDirDrive are invalid (too long).

    /* fInheritAutoLogon */
    CHAR UserName[ USERNAME_LENGTH + 1 ];
    CHAR Domain[ DOMAIN_LENGTH + 1 ];
    CHAR Password[ PASSWORD_LENGTH + 1 ];

    /* fInheritInitialProgram */
    CHAR WorkDirectory[ DIRECTORY_LENGTH + 1 ];
    CHAR InitialProgram[ INITIALPROGRAM_LENGTH + 1 ];

    /* fInheritCallback */
    CHAR CallbackNumber[ CALLBACK_LENGTH + 1 ];
    CALLBACKCLASS Callback;

    /* fInheritShadow */
    SHADOWCLASS Shadow;

    ULONG MaxConnectionTime;
    ULONG MaxDisconnectionTime;
    ULONG MaxIdleTime;

    ULONG KeyboardLayout;               // 0 = inherit

    /* fInheritSecurity */
    BYTE MinEncryptionLevel;

    CHAR NWLogonServer[ NASIFILESERVER_LENGTH + 1 ];

    APPLICATIONNAMEA PublishedName;

    /* WinFrame Profile Path - Overrides standard profile path */
    CHAR WFProfilePath[ DIRECTORY_LENGTH + 1 ];

    /* WinFrame Home Directory - Overrides standard Home Directory */
    CHAR WFHomeDir[ DIRECTORY_LENGTH + 1 ];

    /* WinFrame Home Directory Drive - Overrides standard Home Directory Drive*/
    CHAR WFHomeDirDrive[ 4 ];

} USERCONFIGA, * PUSERCONFIGA;

#ifdef UNICODE
#define USERCONFIG USERCONFIGW
#define PUSERCONFIG PUSERCONFIGW
#else
#define USERCONFIG USERCONFIGA
#define PUSERCONFIG PUSERCONFIGA
#endif /* UNICODE */

/*------------------------------------------------*/

/******************
 *  PD structures
 ******************/

typedef struct _PDCONFIG2W{
    PDNAMEW PdName;                     // descriptive name of PD
    SDCLASS SdClass;                    // type of PD
    DLLNAMEW PdDLL;                     // name of PD dll
    ULONG    PdFlag;                    // PD flags
    ULONG OutBufLength;                 // optimal output buffer length
    ULONG OutBufCount;                  // optimal number of output buffers
    ULONG OutBufDelay;                  // write delay in msecs
    ULONG InteractiveDelay;             // write delay during active input
    ULONG PortNumber;                   // network listen port number
    ULONG KeepAliveTimeout;             // network watchdog frequence
} PDCONFIG2W, * PPDCONFIG2W;

typedef struct _PDCONFIG2A {
    PDNAMEA PdName;
    SDCLASS SdClass;
    DLLNAMEA PdDLL;
    ULONG    PdFlag;
    ULONG OutBufLength;
    ULONG OutBufCount;
    ULONG OutBufDelay;
    ULONG InteractiveDelay;
    ULONG PortNumber;
    ULONG KeepAliveTimeout;
} PDCONFIG2A, * PPDCONFIG2A;

/*
 *  PdFlag defines
 */
#define PD_UNUSED      0x00000001       // <unused>
#define PD_RELIABLE    0x00000002       // error free protocol already
#define PD_FRAME       0x00000004       // frame orientated protocol
#define PD_CONNECTION  0x00000008       // connection orientated protocol
#define PD_CONSOLE     0x00000010       // directly connected console
#define PD_LANA        0x00000020       // Network class uses LANAs (ie NetBIOS)
#define PD_TRANSPORT   0x00000040       // transport driver (lowest level)
#define PD_SINGLE_INST 0x00000080       // single instance only (async)
#define PD_NOLOW_WATERMARK 0x00000100	//low water mark to resume transmission

#ifdef UNICODE
#define PDCONFIG2 PDCONFIG2W
#define PPDCONFIG2 PPDCONFIG2W
#else
#define PDCONFIG2 PDCONFIG2A
#define PPDCONFIG2 PPDCONFIG2A
#endif /* UNICODE */

/*------------------------------------------------*/

typedef struct _PDCONFIG3W {
    PDCONFIG2W Data;
    PDNAMEW ServiceName;               // Needed for non-LANA PdNetwork enum
    DLLNAMEW ConfigDLL;                // helper dll for WinStation configuration
    ULONG RequiredPdCount;
    PDNAMEW RequiredPds[ MAX_PDCONFIG ];
} PDCONFIG3W, * PPDCONFIG3W;

typedef struct _PDCONFIG3A {
    PDCONFIG2A Data;
    PDNAMEA ServiceName;               // Needed for non-LANA PdNetwork enum
    DLLNAMEA ConfigDLL;                // helper dll for WinStation configuration
    ULONG RequiredPdCount;
    PDNAMEA RequiredPds[ MAX_PDCONFIG ];
} PDCONFIG3A, * PPDCONFIG3A;

#ifdef UNICODE
#define PDCONFIG3 PDCONFIG3W
#define PPDCONFIG3 PPDCONFIG3W
#else
#define PDCONFIG3 PDCONFIG3A
#define PPDCONFIG3 PPDCONFIG3A
#endif /* UNICODE */

/*------------------------------------------------*/

typedef enum _FLOWCONTROLCLASS {
    FlowControl_None,
    FlowControl_Hardware,
    FlowControl_Software,
} FLOWCONTROLCLASS;

typedef enum _RECEIVEFLOWCONTROLCLASS {
    ReceiveFlowControl_None,
    ReceiveFlowControl_RTS,
    ReceiveFlowControl_DTR,
} RECEIVEFLOWCONTROLCLASS;

typedef enum _TRANSMITFLOWCONTROLCLASS {
    TransmitFlowControl_None,
    TransmitFlowControl_CTS,
    TransmitFlowControl_DSR,
} TRANSMITFLOWCONTROLCLASS;

typedef struct _FLOWCONTROLCONFIG {
    ULONG fEnableSoftwareTx: 1;
    ULONG fEnableSoftwareRx: 1;
    ULONG fEnableDTR: 1;
    ULONG fEnableRTS: 1;
    CHAR XonChar;
    CHAR XoffChar;
    FLOWCONTROLCLASS Type;
    RECEIVEFLOWCONTROLCLASS HardwareReceive;
    TRANSMITFLOWCONTROLCLASS HardwareTransmit;
} FLOWCONTROLCONFIG, * PFLOWCONTROLCONFIG;

typedef enum _ASYNCCONNECTCLASS {
    Connect_CTS,
    Connect_DSR,
    Connect_RI,
    Connect_DCD,
    Connect_FirstChar,
    Connect_Perm,
} ASYNCCONNECTCLASS;

typedef struct _CONNECTCONFIG {
    ASYNCCONNECTCLASS Type;
    ULONG fEnableBreakDisconnect: 1;
} CONNECTCONFIG, * PCONNECTCONFIG;

/*------------------------------------------------*/

typedef struct _ASYNCCONFIGW {
    DEVICENAMEW DeviceName;
    MODEMNAMEW ModemName;
    ULONG BaudRate;
    ULONG Parity;
    ULONG StopBits;
    ULONG ByteSize;
    ULONG fEnableDsrSensitivity: 1;
    ULONG fConnectionDriver: 1;
    FLOWCONTROLCONFIG FlowControl;
    CONNECTCONFIG Connect;
} ASYNCCONFIGW, * PASYNCCONFIGW;

typedef struct _ASYNCCONFIGA {
    DEVICENAMEA DeviceName;
    MODEMNAMEA ModemName;
    ULONG BaudRate;
    ULONG Parity;
    ULONG StopBits;
    ULONG ByteSize;
    ULONG fEnableDsrSensitivity: 1;
    ULONG fConnectionDriver: 1;
    FLOWCONTROLCONFIG FlowControl;
    CONNECTCONFIG Connect;
} ASYNCCONFIGA, * PASYNCCONFIGA;

#ifdef UNICODE
#define ASYNCCONFIG ASYNCCONFIGW
#define PASYNCCONFIG PASYNCCONFIGW
#else
#define ASYNCCONFIG ASYNCCONFIGA
#define PASYNCCONFIG PASYNCCONFIGA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef struct _NETWORKCONFIGW {
    LONG LanAdapter;
    DEVICENAMEW NetworkName;
    ULONG Flags;
} NETWORKCONFIGW, * PNETWORKCONFIGW;

typedef struct _NETWORKCONFIGA {
    LONG LanAdapter;
    DEVICENAMEA NetworkName;
    ULONG Flags;
} NETWORKCONFIGA, * PNETWORKCONFIGA;

#define NETWORK_CLIENT  0x00000001

#ifdef UNICODE
#define NETWORKCONFIG NETWORKCONFIGW
#define PNETWORKCONFIG PNETWORKCONFIGW
#else
#define NETWORKCONFIG NETWORKCONFIGA
#define PNETWORKCONFIG PNETWORKCONFIGA
#endif /* UNICODE */

/*------------------------------------------------*/

#ifdef UNICODE
#define NASICONFIG NASICONFIGW
#define PNASICONFIG PNASICONFIGW
#else
#define NASICONFIG NASICONFIGA
#define PNASICONFIG PNASICONFIGA
#endif /* UNICODE */
typedef struct _NASICONFIGW {
    NASISPECIFICNAMEW    SpecificName;
    NASIUSERNAMEW        UserName;
    NASIPASSWORDW        PassWord;
    NASISESIONNAMEW      SessionName;
    NASIFILESERVERW      FileServer;
    BOOLEAN              GlobalSession;
} NASICONFIGW, * PNASICONFIGW;

typedef struct _NASICONFIGA {
    NASISPECIFICNAMEA    SpecificName;
    NASIUSERNAMEA        UserName;
    NASIPASSWORDA        PassWord;
    NASISESIONNAMEA      SessionName;
    NASIFILESERVERA      FileServer;
    BOOLEAN              GlobalSession;
} NASICONFIGA, * PNASICONFIGA;

/*------------------------------------------------*/

typedef struct _OEMTDCONFIGW {
    LONG Adapter;
    DEVICENAMEW DeviceName;
    ULONG Flags;
} OEMTDCONFIGW, * POEMTDCONFIGW;

typedef struct _OEMTDCONFIGA {
    LONG Adapter;
    DEVICENAMEA DeviceName;
    ULONG Flags;
} OEMTDCONFIGA, * POEMTDCONFIGA;

#ifdef UNICODE
#define OEMTDCONFIG OEMTDCONFIGW
#define POEMTDCONFIG POEMTDCONFIGW
#else
#define OEMTDCONFIG OEMTDCONFIGA
#define POEMTDCONFIG POEMTDCONFIGA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef struct _PDPARAMSW {
    SDCLASS SdClass;
    union {
        NETWORKCONFIGW Network;
        ASYNCCONFIGW Async;
        NASICONFIGW Nasi;
        OEMTDCONFIGW OemTd;
    };
} PDPARAMSW, * PPDPARAMSW;

typedef struct _PDPARAMSA {
    SDCLASS SdClass;
    union {
        NETWORKCONFIGA Network;
        ASYNCCONFIGA Async;
        NASICONFIGA Nasi;
        OEMTDCONFIGA OemTd;
    };
} PDPARAMSA, * PPDPARAMSA;

#ifdef UNICODE
#define PDPARAMS PDPARAMSW
#define PPDPARAMS PPDPARAMSW
#else
#define PDPARAMS PDPARAMSA
#define PPDPARAMS PPDPARAMSA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef struct _PDCONFIGW {
    PDCONFIG2W Create;
    PDPARAMSW Params;
} PDCONFIGW, * PPDCONFIGW;

typedef struct _PDCONFIGA {
    PDCONFIG2A Create;
    PDPARAMSA Params;
} PDCONFIGA, * PPDCONFIGA;

#ifdef UNICODE
#define PDCONFIG PDCONFIGW
#define PPDCONFIG PPDCONFIGW
#else
#define PDCONFIG PDCONFIGA
#define PPDCONFIG PPDCONFIGA
#endif /* UNICODE */

/*------------------------------------------------*/


 /***********************
  *  Wd structures
  ***********************/


typedef struct _WDCONFIGW {
    WDNAMEW WdName;
    DLLNAMEW WdDLL;
    DLLNAMEW WsxDLL;
    ULONG WdFlag;
    ULONG WdInputBufferLength;
    DLLNAMEW CfgDLL;
    WDPREFIXW WdPrefix;
} WDCONFIGW, * PWDCONFIGW;

typedef struct _WDCONFIGA {
    WDNAMEA WdName;
    DLLNAMEA WdDLL;
    DLLNAMEA WsxDLL;
    ULONG WdFlag;
    ULONG WdInputBufferLength;
    DLLNAMEA CfgDLL;
    WDPREFIXA WdPrefix;
} WDCONFIGA, * PWDCONFIGA;

/*
 *  WdFlag defines
 */
#define WDF_UNUSED            0x00000001   // <unused>
#define WDF_SHADOW_SOURCE     0x00000002   // valid shadow source
#define WDF_SHADOW_TARGET     0x00000004   // valid shadow target
#define WDF_ICA               0x00000008   // WD is Citrix ICA class
#define WDF_TSHARE            0x00000010   // WD is Microsoft TSHARE class
#define WDF_DYNAMIC_RECONNECT 0x00000020   // Session can resize Display at reconnect
#define WDF_USER_VCIOCTL	  0x00000040   // User mode apps can send IOCTL to VC

#ifdef UNICODE
#define WDCONFIG WDCONFIGW
#define PWDCONFIG PWDCONFIGW
#else
#define WDCONFIG WDCONFIGA
#define PWDCONFIG PWDCONFIGA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef struct _WDCONFIG2W {
    WDCONFIGW Wd;
    ASYNCCONFIGW Async;
    USERCONFIGW User;
} WDCONFIG2W, * PWDCONFIG2W;

typedef struct _WDCONFIG2A {
    WDCONFIGA Wd;
    ASYNCCONFIGA Async;
    USERCONFIGA User;
} WDCONFIG2A, * PWDCONFIG2A;

#ifdef UNICODE
#define WDCONFIG2 WDCONFIG2W
#define PWDCONFIG2 PWDCONFIG2W
#else
#define WDCONFIG2 WDCONFIG2A
#define PWDCONFIG2 PWDCONFIG2A
#endif /* UNICODE */

/*------------------------------------------------*/

 /**************************************
  *  Connection Driver structures (CD)
  **************************************/

/*
 *  connection driver classes
 */
typedef enum _CDCLASS {
    CdNone,            // 0
    CdModem,           // 1  cdmodem.dll
    CdClass_Maximum,   // 2  -- must be last
} CDCLASS;

/*------------------------------------------------*/


typedef struct _CDCONFIGW {
    CDCLASS CdClass;
    CDNAMEW CdName;
    DLLNAMEW CdDLL;
    ULONG CdFlag;
} CDCONFIGW, * PCDCONFIGW;

typedef struct _CDCONFIGA {
    CDCLASS CdClass;
    CDNAMEA CdName;
    DLLNAMEA CdDLL;
    ULONG CdFlag;
} CDCONFIGA, * PCDCONFIGA;

#ifdef UNICODE
#define CDCONFIG CDCONFIGW
#define PCDCONFIG PCDCONFIGW
#else
#define CDCONFIG CDCONFIGA
#define PCDCONFIG PCDCONFIGA
#endif /* UNICODE */

/*------------------------------------------------*/


/*****************************
 *  Window Station structures
 *****************************/

typedef struct _WINSTATIONCREATEW {
    ULONG fEnableWinStation : 1;
    ULONG MaxInstanceCount;
} WINSTATIONCREATEW, * PWINSTATIONCREATEW;

typedef struct _WINSTATIONCREATEA {
    ULONG fEnableWinStation : 1;
    ULONG MaxInstanceCount;
} WINSTATIONCREATEA, * PWINSTATIONCREATEA;

#ifdef UNICODE
#define WINSTATIONCREATE WINSTATIONCREATEW
#define PWINSTATIONCREATE PWINSTATIONCREATEW
#else
#define WINSTATIONCREATE WINSTATIONCREATEA
#define PWINSTATIONCREATE PWINSTATIONCREATEA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef struct _WINSTATIONCONFIGW {
    WCHAR Comment[ WINSTATIONCOMMENT_LENGTH + 1 ];
    USERCONFIGW User;
    char OEMId[4];                // WinFrame Server OEM Id
} WINSTATIONCONFIGW, * PWINSTATIONCONFIGW;

typedef struct _WINSTATIONCONFIGA {
    CHAR Comment[ WINSTATIONCOMMENT_LENGTH + 1 ];
    USERCONFIGA User;
    char OEMId[4];                // WinFrame Server OEM Id
} WINSTATIONCONFIGA, * PWINSTATIONCONFIGA;

#ifdef UNICODE
#define WINSTATIONCONFIG WINSTATIONCONFIGW
#define PWINSTATIONCONFIG PWINSTATIONCONFIGW
#else
#define WINSTATIONCONFIG WINSTATIONCONFIGA
#define PWINSTATIONCONFIG PWINSTATIONCONFIGA
#endif /* UNICODE */

/*------------------------------------------------*/

#define EXECSRVPIPENAMELEN 48

typedef enum _WINSTATIONINFOCLASS {
    WinStationCreateData,         // query WinStation create data
    WinStationConfiguration,      // query/set WinStation parameters
    WinStationPdParams,           // query/set PD parameters
    WinStationWd,                 // query WD config (only one can be loaded)
    WinStationPd,                 // query PD config (many can be loaded)
    WinStationPrinter,            // query/set LPT mapping to printer queues
    WinStationClient,             // query information about client
    WinStationModules,            // query information about all client modules
    WinStationInformation,        // query information about WinStation
    WinStationTrace,              // enable/disable winstation tracing
    WinStationBeep,               // beep the WinStation
    WinStationEncryptionOff,      // turn off encryption
    WinStationEncryptionPerm,     // encryption is permanent on
    WinStationNtSecurity,         // select winlogon security desktop
    WinStationUserToken,          // User token
    WinStationUnused1,            // *** AVAILABLE *** (old IniMapping)
    WinStationVideoData,          // query hres, vres, color depth
    WinStationInitialProgram,     // Identify Initial Program
    WinStationCd,                 // query CD config (only one can be loaded)
    WinStationSystemTrace,        // enable/disable system tracing
    WinStationVirtualData,        // query client virtual data
    WinStationClientData,         // send data to client
    WinStationSecureDesktopEnter, // turn encryption on, if enabled
    WinStationSecureDesktopExit,  // turn encryption off, if enabled
    WinStationLoadBalanceSessionTarget,  // Load balance info from redirected client.
    WinStationLoadIndicator,      // query load capacity information
    WinStationShadowInfo,         // query/set Shadow state & parameters
    WinStationDigProductId,       // get the outermost digital product id, the client's product id, and the current product id
    WinStationLockedState,        // winlogon sets this for notifing apps/services.
    WinStationRemoteAddress,      // Query client IP address
    WinStationIdleTime,           // Query for how much time the winstation is idle
    WinStationLastReconnectType,  // If last reconnect for this winstation was manual or auto reconnect.      
    WinStationDisallowAutoReconnect,     // Allow/Disallow AutoReconnect for this WinStation
    WinStationMprNotifyInfo,      // Mprnotify info from Winlogon for notifying 3rd party network providers
    WinStationExecSrvSystemPipe,   // Exec Srv System Pipe name
    WinStationSDRedirectedSmartCardLogon,       // Was this a Session Directory redirected SmartCard logon
    WinStationIsAdminLoggedOn      // Is the currently logged on user an administrator ?
} WINSTATIONINFOCLASS;

/*------------------------------------------------*/

typedef struct _WINSTATIONCLIENTDATA {
    CLIENTDATANAME DataName;
    BOOLEAN fUnicodeData;
    /* BYTE   Data[1]; Variable length data follows */
} WINSTATIONCLIENTDATA, * PWINSTATIONCLIENTDATA;

/*------------------------------------------------*/

typedef struct _WINSTATIONUSERTOKEN {
    HANDLE ProcessId;
    HANDLE ThreadId;
    HANDLE UserToken;
} WINSTATIONUSERTOKEN, * PWINSTATIONUSERTOKEN;

/*------------------------------------------------*/

typedef struct _WINSTATIONVIDEODATA {
    USHORT  HResolution;
    USHORT  VResolution;
    USHORT  fColorDepth;
} WINSTATIONVIDEODATA, *PWINSTATIONVIDEODATA;

/*----------------------------------------------*/

typedef struct _WINSTATIONCONFIG2W {
    WINSTATIONCREATEW Create;
    PDCONFIGW Pd[ MAX_PDCONFIG ];
    WDCONFIGW Wd;
    CDCONFIGW Cd;
    WINSTATIONCONFIGW   Config;
} WINSTATIONCONFIG2W, * PWINSTATIONCONFIG2W;

typedef struct _WINSTATIONCONFIG2A {
    WINSTATIONCREATEA Create;
    PDCONFIGA Pd[ MAX_PDCONFIG ];
    WDCONFIGA Wd;
    CDCONFIGA Cd;
    WINSTATIONCONFIGA Config;
} WINSTATIONCONFIG2A, * PWINSTATIONCONFIG2A;

#ifdef UNICODE
#define WINSTATIONCONFIG2 WINSTATIONCONFIG2W
#define PWINSTATIONCONFIG2 PWINSTATIONCONFIG2W
#else
#define WINSTATIONCONFIG2 WINSTATIONCONFIG2A
#define PWINSTATIONCONFIG2 PWINSTATIONCONFIG2A
#endif /* UNICODE */

/*------------------------------------------------*/

typedef struct _WINSTATIONPRINTERW {
    PRINTERNAMEW Lpt1;
    PRINTERNAMEW Lpt2;
    PRINTERNAMEW Lpt3;
    PRINTERNAMEW Lpt4;
} WINSTATIONPRINTERW, * PWINSTATIONPRINTERW;

typedef struct _WINSTATIONPRINTERA {
    PRINTERNAMEA Lpt1;
    PRINTERNAMEA Lpt2;
    PRINTERNAMEA Lpt3;
    PRINTERNAMEA Lpt4;
} WINSTATIONPRINTERA, * PWINSTATIONPRINTERA;

#ifdef UNICODE
#define WINSTATIONPRINTER WINSTATIONPRINTERW
#define PWINSTATIONPRINTER PWINSTATIONPRINTERW
#else
#define WINSTATIONPRINTER WINSTATIONPRINTERA
#define PWINSTATIONPRINTER PWINSTATIONPRINTERA
#endif /* UNICODE */

#ifndef _TS_TIME_ZONE_INFORMATION_
#define _TS_TIME_ZONE_INFORMATION_
typedef struct _TS_SYSTEMTIME {
    USHORT wYear;
    USHORT wMonth;
    USHORT wDayOfWeek;
    USHORT wDay;
    USHORT wHour;
    USHORT wMinute;
    USHORT wSecond;
    USHORT wMilliseconds;
} TS_SYSTEMTIME;

typedef struct _TS_TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    TS_SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    TS_SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TS_TIME_ZONE_INFORMATION;
#endif //_TS_TIME_ZONE_INFORMATION_

/*------------------------------------------------*/

/*
 *  WinStation client data structure
 */
typedef struct _WINSTATIONCLIENTW {
    ULONG fTextOnly: 1;
    ULONG fDisableCtrlAltDel: 1;
    ULONG fMouse: 1;
    ULONG fDoubleClickDetect: 1;
    ULONG fINetClient: 1;
    ULONG fPromptForPassword : 1;
    ULONG fMaximizeShell: 1;
    ULONG fEnableWindowsKey: 1;
    ULONG fRemoteConsoleAudio: 1;
    WCHAR ClientName[ CLIENTNAME_LENGTH + 1 ];
    WCHAR Domain[ DOMAIN_LENGTH + 1 ];
    WCHAR UserName[ USERNAME_LENGTH + 1 ];
    WCHAR Password[ PASSWORD_LENGTH + 1 ];
    WCHAR WorkDirectory[ DIRECTORY_LENGTH + 1 ];
    WCHAR InitialProgram[ INITIALPROGRAM_LENGTH + 1 ];
    ULONG SerialNumber;         // client computer unique serial number
    BYTE EncryptionLevel;       // security level of encryption pd
    ULONG ClientAddressFamily;
    WCHAR ClientAddress[ CLIENTADDRESS_LENGTH + 1 ];
    USHORT HRes;
    USHORT VRes;
    USHORT ColorDepth;
    USHORT ProtocolType;   // PROTOCOL_ICA or PROTOCOL_RDP
    ULONG KeyboardLayout;
    ULONG KeyboardType;
    ULONG KeyboardSubType;
    ULONG KeyboardFunctionKey;
    WCHAR imeFileName[ IMEFILENAME_LENGTH + 1 ];
    WCHAR ClientDirectory[ DIRECTORY_LENGTH + 1 ];
    WCHAR ClientLicense[ CLIENTLICENSE_LENGTH + 1 ];
    WCHAR ClientModem[ CLIENTMODEM_LENGTH + 1 ];
    ULONG ClientBuildNumber;
    ULONG ClientHardwareId;    // client software serial number
    USHORT ClientProductId;     // client software product id
    USHORT OutBufCountHost;     // number of outbufs on host
    USHORT OutBufCountClient;   // number of outbufs on client
    USHORT OutBufLength;        // length of outbufs in bytes
    WCHAR AudioDriverName[9];
    //client time zone information
    TS_TIME_ZONE_INFORMATION ClientTimeZone;
    ULONG ClientSessionId;
    WCHAR clientDigProductId[CLIENT_PRODUCT_ID_LENGTH];
    ULONG PerformanceFlags;  // List of features to disable for perf
    ULONG ActiveInputLocale; // Client's active input locale HKL
} WINSTATIONCLIENTW, * PWINSTATIONCLIENTW;

/*
 *  WinStation client data structure
 */
typedef struct _WINSTATIONCLIENTA {
    ULONG fTextOnly: 1;
    ULONG fDisableCtrlAltDel: 1;
    ULONG fMouse: 1;
    ULONG fDoubleClickDetect: 1;
    ULONG fINetClient: 1;
    ULONG fPromptForPassword : 1;
    ULONG fMaximizeShell: 1;
    ULONG fEnableWindowsKey: 1;
    char ClientName[ CLIENTNAME_LENGTH + 1 ];
    char Domain[ DOMAIN_LENGTH + 1 ];
    char UserName[ USERNAME_LENGTH + 1 ];
    char Password[ PASSWORD_LENGTH + 1 ];
    char WorkDirectory[ DIRECTORY_LENGTH + 1 ];
    char InitialProgram[ INITIALPROGRAM_LENGTH + 1 ];
    ULONG SerialNumber;         // client computer unique serial number
    BYTE EncryptionLevel;       // security level of encryption pd
    ULONG ClientAddressFamily;
    char ClientAddress[ CLIENTADDRESS_LENGTH + 1 ];
    USHORT HRes;
    USHORT VRes;
    USHORT ColorDepth;
    USHORT ProtocolType;   // PROTOCOL_ICA or PROTOCOL_RDP
    ULONG KeyboardLayout;
    ULONG KeyboardType;
    ULONG KeyboardSubType;
    ULONG KeyboardFunctionKey;
    char imeFileName[ IMEFILENAME_LENGTH + 1 ];
    char ClientDirectory[ DIRECTORY_LENGTH + 1 ];
    char ClientLicense[ CLIENTLICENSE_LENGTH + 1 ];
    char ClientModem[ CLIENTMODEM_LENGTH + 1 ];
    ULONG ClientBuildNumber;
    ULONG ClientHardwareId;    // client software serial number
    USHORT ClientProductId;     // client software product id
    USHORT OutBufCountHost;     // number of outbufs on host
    USHORT OutBufCountClient;   // number of outbufs on client
    USHORT OutBufLength;        // length of outbufs in bytes
    char AudioDriverName[9];
    //client time zone information
    TS_TIME_ZONE_INFORMATION ClientTimeZone;
    ULONG ClientSessionId;
    char clientDigProductId[CLIENT_PRODUCT_ID_LENGTH];
    ULONG PerformanceFlags;  // List of features to disable for perf
    ULONG ActiveInputLocale; // Client's active input locale HKL
} WINSTATIONCLIENTA, * PWINSTATIONCLIENTA;

#ifdef UNICODE
#define WINSTATIONCLIENT WINSTATIONCLIENTW
#define PWINSTATIONCLIENT PWINSTATIONCLIENTW
#else
#define WINSTATIONCLIENT WINSTATIONCLIENTA
#define PWINSTATIONCLIENT PWINSTATIONCLIENTA
#endif /* UNICODE */

/*
 *  Autoreconnect information passed up from the stack
 */
#define MAX_TS_AUTORECONNECTINFO_LEN    128 
typedef struct _TS_AUTORECONNECTINFO {
    USHORT cbAutoReconnectInfo;
    BYTE AutoReconnectInfo[MAX_TS_AUTORECONNECTINFO_LEN];
} TS_AUTORECONNECTINFO, *PTS_AUTORECONNECTINFO;


/*------------------------------------------------*/

/*
 *  ICA specific protocol performance counters
 */
typedef struct _ICA_COUNTERS {
    ULONG Reserved;
} ICA_COUNTERS, * PICA_COUNTERS;

/*
 *  T.Share specific protocol performance counters
 */
typedef struct _TSHARE_COUNTERS {
    ULONG Reserved;
} TSHARE_COUNTERS, * PTSHARE_COUNTERS;

/*
 *  WinStation protocol performance counters
 */
typedef struct _PROTOCOLCOUNTERS {
    ULONG WdBytes;              // wd common
    ULONG WdFrames;             // wd common
    ULONG WaitForOutBuf;        // wd common
    ULONG Frames;               // td common
    ULONG Bytes;                // td common
    ULONG CompressedBytes;      // pdcomp
    ULONG CompressFlushes;      // pdcomp
    ULONG Errors;               // pdreli
    ULONG Timeouts;             // pdreli
    ULONG AsyncFramingError;    // pdasync
    ULONG AsyncOverrunError;    // pdasync
    ULONG AsyncOverflowError;   // pdasync
    ULONG AsyncParityError;     // pdasync
    ULONG TdErrors;             // td common
    USHORT ProtocolType;        // PROTOCOL_ICA or PROTOCOL_RDP
    USHORT Length;              // length of data in protocol-specific space
    union {
        ICA_COUNTERS    IcaCounters;
        TSHARE_COUNTERS TShareCounters;
        ULONG           Reserved[100];
    } Specific;
} PROTOCOLCOUNTERS, * PPROTOCOLCOUNTERS;

/*
 * ThinWire cache statistics
 */
typedef struct _THINWIRECACHE {
    ULONG CacheReads;
    ULONG CacheHits;
} THINWIRECACHE, * PTHINWIRECACHE;

#define MAX_THINWIRECACHE   4

/*
 *  ICA specific cache statistics
 */
typedef struct _ICA_CACHE {
    THINWIRECACHE ThinWireCache[ MAX_THINWIRECACHE ];
} ICA_CACHE, * PICA_CACHE;

/*
 *  T.Share specific cache statistics
 */
typedef struct _TSHARE_CACHE {
    ULONG Reserved;
} TSHARE_CACHE, * PTSHARE_CACHE;

/*
 *  WinStation cache statistics
 */
typedef struct CACHE_STATISTICS {
    USHORT ProtocolType;        // PROTOCOL_ICA or PROTOCOL_RDP
    USHORT Length;              // length of data in protocol-specific space
    union {
        ICA_CACHE    IcaCacheStats;
        TSHARE_CACHE TShareCacheStats;
        ULONG        Reserved[20];
    } Specific;
} CACHE_STATISTICS, * PCACHE_STATISTICS;

/*
 *  WinStation protocol status
 */
typedef struct _PROTOCOLSTATUS {
    PROTOCOLCOUNTERS Output;
    PROTOCOLCOUNTERS Input;
    CACHE_STATISTICS Cache;
    ULONG AsyncSignal;                  // MS_CTS_ON, MS_DSR_ON, etc...
    ULONG AsyncSignalMask;              // EV_CTS, EV_DSR, etc...
} PROTOCOLSTATUS, * PPROTOCOLSTATUS;

/*
 *  Protocol extension info struct
 */
typedef struct _WSX_INFO {
    ULONG Version;
    HANDLE hIca;
    HANDLE hStack;
    ULONG SessionId;
    PWCHAR pUserName;
    PWCHAR pDomain;
#define WSX_INFO_VERSION_1 0x1
} WSX_INFO, * PWSX_INFO;

/*
 *  AsyncSignal defines
 */
// #define MS_CTS_ON            0x0010
// #define MS_DSR_ON            0x0020
// #define MS_RING_ON           0x0040
// #define MS_RLSD_ON           0x0080
#define MS_DTR_ON           0x00010000
#define MS_RTS_ON           0x00020000

/*
 *  AsyncSignalMask defines
 */
// #define EV_CTS              0x0008  // CTS changed state
// #define EV_DSR              0x0010  // DSR changed state
// #define EV_RLSD             0x0020  // RLSD changed state
// #define EV_RING             0x0100  // Ring signal detected
#define EV_DTR             0x00010000  // DTR changed state
#define EV_RTS             0x00020000  // DTR changed state

/*------------------------------------------------*/

/*
 *  WinStation query information
 */
typedef struct _WINSTATIONINFORMATIONW {
    WINSTATIONSTATECLASS ConnectState;
    WINSTATIONNAMEW WinStationName;
    ULONG LogonId;
    LARGE_INTEGER ConnectTime;
    LARGE_INTEGER DisconnectTime;
    LARGE_INTEGER LastInputTime;
    LARGE_INTEGER LogonTime;
    PROTOCOLSTATUS Status;
    WCHAR Domain[ DOMAIN_LENGTH + 1 ];
    WCHAR UserName[USERNAME_LENGTH + 1];
    LARGE_INTEGER CurrentTime;
} WINSTATIONINFORMATIONW, * PWINSTATIONINFORMATIONW;

typedef struct _WINSTATIONINFORMATIONA {
    WINSTATIONSTATECLASS ConnectState;
    WINSTATIONNAMEA WinStationName;
    ULONG LogonId;
    LARGE_INTEGER ConnectTime;
    LARGE_INTEGER DisconnectTime;
    LARGE_INTEGER LastInputTime;
    LARGE_INTEGER LogonTime;
    PROTOCOLSTATUS Status;
    CHAR Domain[ DOMAIN_LENGTH + 1 ];
    CHAR UserName[USERNAME_LENGTH + 1];
    LARGE_INTEGER CurrentTime;
} WINSTATIONINFORMATIONA, * PWINSTATIONINFORMATIONA;

#ifdef UNICODE
#define WINSTATIONINFORMATION WINSTATIONINFORMATIONW
#define PWINSTATIONINFORMATION PWINSTATIONINFORMATIONW
#else
#define WINSTATIONINFORMATION WINSTATIONINFORMATIONA
#define PWINSTATIONINFORMATION PWINSTATIONINFORMATIONA
#endif /* UNICODE */

/*
 * Load balancing data types
 */
typedef enum _LOADFACTORTYPE {
    ErrorConstraint,
    PagedPoolConstraint,
    NonPagedPoolConstraint,
    AvailablePagesConstraint,
    SystemPtesConstraint,
    CPUConstraint 
} LOADFACTORTYPE;

typedef struct _WINSTATIONLOADINDICATORDATA {
    ULONG RemainingSessionCapacity;
    LOADFACTORTYPE LoadFactor;
    ULONG TotalSessions;
    ULONG DisconnectedSessions;
    LARGE_INTEGER IdleCPU;
    LARGE_INTEGER TotalCPU;
    ULONG RawSessionCapacity;
    ULONG reserved[9];    
} WINSTATIONLOADINDICATORDATA, * PWINSTATIONLOADINDICATORDATA;

/*------------------------------------------------*/

/*
 *  WinStation shadow states
 */
typedef enum _SHADOWSTATECLASS {
    State_NoShadow,                    // No shadow operations on this session
    State_Shadowing,                   // The session is a Shadow client (viewer)
    State_Shadowed,                    // The session is a Shadow target 
} SHADOWSTATECLASS;


/*
 *  Shadow query/set information
 */
typedef struct _WINSTATIONSHADOW {
    SHADOWSTATECLASS    ShadowState;
    SHADOWCLASS         ShadowClass;
    ULONG               SessionId;
    ULONG               ProtocolType;   // ignored in a set operation
} WINSTATIONSHADOW, * PWINSTATIONSHADOW;

//get the outermost product id, client product id, and current product id
//and corresponding session ids for use in checking shadow loop
typedef struct _WINSTATIONPRODIDW {
  WCHAR DigProductId[CLIENT_PRODUCT_ID_LENGTH];
  WCHAR ClientDigProductId[CLIENT_PRODUCT_ID_LENGTH ];
  WCHAR OuterMostDigProductId[CLIENT_PRODUCT_ID_LENGTH ];
  ULONG curentSessionId;
  ULONG ClientSessionId;
  ULONG OuterMostSessionId;
}WINSTATIONPRODIDW, *PWINSTATIONPRODIDW;

typedef struct _WINSTATIONPRODIDA {
  CHAR DigProductId[CLIENT_PRODUCT_ID_LENGTH];
  CHAR ClientDigProductId[CLIENT_PRODUCT_ID_LENGTH ];
  CHAR OuterMostDigProductId[CLIENT_PRODUCT_ID_LENGTH ];
  ULONG curentSessionId;
  ULONG ClientSessionId;
  ULONG OuterMostSessionId;
}WINSTATIONPRODIDA, *PWINSTATIONPRODIDA;

#ifdef UNICODE
#define WINSTATIONPRODID WINSTATIONPRODIDW
#define PWINSTATIONPRODID PWINSTATIONPRODIDW
#else
#define WINSTATIONPRODID WINSTATIONPRODIDA
#define PWINSTATIONPRODID PWINSTATIONPRODIDA
#endif /* UNICODE */


typedef struct {
	unsigned short sin_family;		// Socket address family.
									// AF_INET or AF_INET6

	union {
		// structure identical to TDI_ADDRESS_IP
		struct {
			USHORT sin_port;
			ULONG  in_addr;
			UCHAR  sin_zero[8];
		} ipv4;

		// structure identical to TDI_ADDRESS_IP6
		struct {
			USHORT sin6_port;
			ULONG  sin6_flowinfo;
			USHORT sin6_addr[8];
			ULONG  sin6_scope_id;
		} ipv6;
	};
} WINSTATIONREMOTEADDRESS, *PWINSTATIONREMOTEADDRESS;
    
/*------------------------------------------------*/

/*
 *  Licensing Policy information struct
 */

#define LCPOLICYINFOTYPE_V1 (1)

#define LCPOLICYINFOTYPE_CURRENT LCPOLICYINFOTYPE_V1

typedef struct {
    ULONG ulVersion;
    LPWSTR lpPolicyName;
    LPWSTR lpPolicyDescription;
} LCPOLICYINFO_V1W, *LPLCPOLICYINFO_V1W;

typedef struct {
    ULONG ulVersion;
    LPSTR lpPolicyName;
    LPSTR lpPolicyDescription;
} LCPOLICYINFO_V1A, *LPLCPOLICYINFO_V1A;

#ifdef UNICODE
#define LCPOLICYINFO_V1 LCPOLICYINFO_V1W
#define LPLCPOLICYINFO_V1 LPLCPOLICYINFO_V1W
#else
#define LCPOLICYINFO_V1 LCPOLICYINFO_V1A
#define LPLCPOLICYINFO_V1 LPLCPOLICYINFO_V1A
#endif

//
//  The generic type is for the API. This will help callers realize that while
//  this API can correctly handle several types of input, they are all based
//  on the LCPOLICYINFO series.
//

typedef struct {
    ULONG ulVersion;
} LCPOLICYINFOGENERIC, *LPLCPOLICYINFOGENERIC;

/*------------------------------------------------*/

/*
 * Types of settings that termsrv can update.  Callers to 
 * _WinStationUpdateSettings choose one, therefore we need not update
 * everything because one type of setting has changed.
 *
 * What used to be contained in ReadRegistry is now covered by
 * WINSTACFG_LEGACY.
 */

typedef enum _WINSTATIONUPDATECFGCLASS {
    WINSTACFG_LEGACY,
    WINSTACFG_SESSDIR
} WINSTATIONUPDATECFGCLASS;

/*------------------------------------------------*/

typedef struct _BEEPINPUT {
    ULONG uType;
} BEEPINPUT, * PBEEPINPUT;

/*------------------------------------------------*/


/**********************
 *  NWLogon Structure
 **********************/


typedef struct _NWLOGONADMIN {
    WCHAR Username[ USERNAME_LENGTH + 1 ];
    WCHAR Password[ PASSWORD_LENGTH + 1 ];
    WCHAR Domain[ DOMAIN_LENGTH + 1 ];
} NWLOGONADMIN, * PNWLOGONADMIN;


/*------------------------------------------------*/
/**********************************************
 *  Registry APIs for Connection Drivers (Cds)
 **********************************************/


LONG WINAPI
RegCdEnumerateW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    PULONG  pIndex,
    PULONG  pEntries,
    PCDNAMEW pCdName,
    PULONG  pByteCount
    );

LONG WINAPI
RegCdEnumerateA(
    HANDLE hServer,
    PWDNAMEA pWdName,
    PULONG  pIndex,
    PULONG  pEntries,
    PCDNAMEA pCdName,
    PULONG  pByteCount
    );

#ifdef UNICODE
#define RegCdEnumerate RegCdEnumerateW
#else
#define RegCdEnumerate RegCdEnumerateA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegCdCreateW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    PCDNAMEW pCdName,
    BOOLEAN bCreate,
    PCDCONFIGW pCdConfig,
    ULONG CdConfigLength
    );

LONG WINAPI
RegCdCreateA(
    HANDLE hServer,
    PWDNAMEA pWdName,
    PCDNAMEA pCdName,
    BOOLEAN bCreate,
    PCDCONFIGA pCdConfig,
    ULONG CdConfigLength
    );

#ifdef UNICODE
#define RegCdCreate RegCdCreateW
#else
#define RegCdCreate RegCdCreateA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegCdQueryW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    PCDNAMEW pCdName,
    PCDCONFIGW pCdConfig,
    ULONG CdConfigLength,
    PULONG pReturnLength
    );

LONG WINAPI
RegCdQueryA(
    HANDLE hServer,
    PWDNAMEA pWdName,
    PCDNAMEA pCdName,
    PCDCONFIGA pCdConfig,
    ULONG CdConfigLength,
    PULONG pReturnLength
    );

#ifdef UNICODE
#define RegCdQuery RegCdQueryW
#else
#define RegCdQuery RegCdQueryA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegCdDeleteW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    PCDNAMEW pCdName
    );

LONG WINAPI
RegCdDeleteA(
    HANDLE hServer,
    PWDNAMEA pWdName,
    PCDNAMEA pCdName
    );

#ifdef UNICODE
#define RegCdDelete RegCdDeleteW
#else
#define RegCdDelete RegCdDeleteA
#endif /* UNICODE */

/*------------------------------------------------*/


/**********************************************
 *  Registry APIs for WinStation Drivers (Wds)
 **********************************************/


LONG WINAPI
RegWdEnumerateW(
    HANDLE hServer,
    PULONG  pIndex,
    PULONG  pEntries,
    PWDNAMEW pWdName,
    PULONG  pByteCount
    );

LONG WINAPI
RegWdEnumerateA(
    HANDLE hServer,
    PULONG  pIndex,
    PULONG  pEntries,
    PWDNAMEA pWdName,
    PULONG  pByteCount
    );

#ifdef UNICODE
#define RegWdEnumerate RegWdEnumerateW
#else
#define RegWdEnumerate RegWdEnumerateA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWdCreateW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    BOOLEAN bCreate,
    PWDCONFIG2W pWdConfig,
    ULONG WdConfigLength
    );

LONG WINAPI
RegWdCreateA(
    HANDLE hServer,
    PWDNAMEA pWdName,
    BOOLEAN bCreate,
    PWDCONFIG2A pWdConfig,
    ULONG WdConfigLength
    );

#ifdef UNICODE
#define RegWdCreate RegWdCreateW
#else
#define RegWdCreate RegWdCreateA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWdQueryW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    PWDCONFIG2W pWdConfig,
    ULONG WdConfigLength,
    PULONG pReturnLength
    );

LONG WINAPI
RegWdQueryA(
    HANDLE hServer,
    PWDNAMEA pWdName,
    PWDCONFIG2A pWdConfig,
    ULONG WdConfigLength,
    PULONG pReturnLength
    );

#ifdef UNICODE
#define RegWdQuery RegWdQueryW
#else
#define RegWdQuery RegWdQueryA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWdDeleteW(
    HANDLE hServer,
    PWDNAMEW pWdName
    );

LONG WINAPI
RegWdDeleteA(
    HANDLE hServer,
    PWDNAMEA pWdName
    );

#ifdef UNICODE
#define RegWdDelete RegWdDeleteW
#else
#define RegWdDelete RegWdDeleteA
#endif /* UNICODE */

/*------------------------------------------------*/


/******************************************************************
 *  Registry APIs for Transport and Protocol Drivers (Tds and Pds)
 ******************************************************************/


HANDLE WINAPI
RegOpenServerW(
    LPWSTR hServerName
    );

HANDLE WINAPI
RegOpenServerA(
    LPSTR hServerName
    );

#ifdef UNICODE
#define RegOpenServer RegOpenServerW
#else
#define RegOpenServer RegOpenServerA
#endif /* UNICODE */

/*------------------------------------------------*/
LONG WINAPI
RegCloseServer(
        HANDLE hServer
        );

/*------------------------------------------------*/
LONG WINAPI
RegPdEnumerateW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    BOOLEAN bTd,
    PULONG  pIndex,
    PULONG  pEntries,
    PPDNAMEW  pPdName,
    PULONG  pByteCount
    );

LONG WINAPI
RegPdEnumerateA(
    HANDLE hServer,
    PWDNAMEA pWdName,
    BOOLEAN bTd,
    PULONG  pIndex,
    PULONG  pEntries,
    PPDNAMEA  pPdName,
    PULONG  pByteCount
    );

#ifdef UNICODE
#define RegPdEnumerate RegPdEnumerateW
#else
#define RegPdEnumerate RegPdEnumerateA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegPdCreateW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    BOOLEAN bTd,
    PPDNAMEW pPdName,
    BOOLEAN bCreate,
    PPDCONFIG3W pPdConfig,
    ULONG PdConfigLength
    );

LONG WINAPI
RegPdCreateA(
    HANDLE hServer,
    PWDNAMEA pWdName,
    BOOLEAN bTd,
    PPDNAMEA pPdName,
    BOOLEAN bCreate,
    PPDCONFIG3A pPdConfig,
    ULONG PdConfigLength
    );

#ifdef UNICODE
#define RegPdCreate RegPdCreateW
#else
#define RegPdCreate RegPdCreateA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegPdQueryW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    BOOLEAN bTd,
    PPDNAMEW pPdName,
    PPDCONFIG3W pPdConfig,
    ULONG PdConfigLength,
    PULONG pReturnLength
    );

LONG WINAPI
RegPdQueryA(
    HANDLE hServer,
    PWDNAMEA pWdName,
    BOOLEAN bTd,
    PPDNAMEA pPdName,
    PPDCONFIG3A pPdConfig,
    ULONG PdConfigLength,
    PULONG pReturnLength
    );

#ifdef UNICODE
#define RegPdQuery RegPdQueryW
#else
#define RegPdQuery RegPdQueryA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegPdDeleteW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    BOOLEAN bTd,
    PPDNAMEW pPdName
    );

LONG WINAPI
RegPdDeleteA(
    HANDLE hServer,
    PWDNAMEA pWdName,
    BOOLEAN bTd,
    PPDNAMEA pPdName
    );

#ifdef UNICODE
#define RegPdDelete RegPdDeleteW
#else
#define RegPdDelete RegPdDeleteA
#endif /* UNICODE */

/*------------------------------------------------*/


/*************************************
 *  Registry APIs for Window Stations
 *************************************/


LONG WINAPI
RegWinStationAccessCheck(
    HANDLE hServer,
    ACCESS_MASK samDesired
    );

/*------------------------------------------------*/

LONG WINAPI
RegWinStationEnumerateW(
    HANDLE hServer,
    PULONG  pIndex,
    PULONG  pEntries,
    PWINSTATIONNAMEW pWinStationName,
    PULONG  pByteCount
    );

/*------------------------------------------------*/

LONG WINAPI
RegWinStationEnumerateA(
    HANDLE hServer,
    PULONG  pIndex,
    PULONG  pEntries,
    PWINSTATIONNAMEA pWinStationName,
    PULONG  pByteCount
    );

#ifdef UNICODE
#define RegWinStationEnumerate RegWinStationEnumerateW
#else
#define RegWinStationEnumerate RegWinStationEnumerateA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWinStationCreateW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    BOOLEAN bCreate,
    PWINSTATIONCONFIG2W pWinStationConfig,
    ULONG WinStationConfigLength
    );

LONG WINAPI
RegWinStationCreateA(
    HANDLE hServer,
    PWINSTATIONNAMEA pWinStationName,
    BOOLEAN bCreate,
    PWINSTATIONCONFIG2A pWinStationConfig,
    ULONG WinStationConfigLength
    );

LONG WINAPI
RegCreateUserConfigW( 
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    PUSERCONFIG pUser
    );

#ifdef UNICODE
#define RegWinStationCreate RegWinStationCreateW
#define RegCreateUserConfig RegCreateUserConfigW
#else
#define RegWinStationCreate RegWinStationCreateA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWinStationQueryW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    PWINSTATIONCONFIG2W pWinStationConfig,
    ULONG WinStationConfigLength,
    PULONG pReturnLength
    );

LONG WINAPI
RegWinStationQueryEx(
    HANDLE hServer,
    PPOLICY_TS_MACHINE   pMachinePolicy,
    PWINSTATIONNAMEW pWinStationName,
    PWINSTATIONCONFIG2W pWinStationConfig,
    ULONG WinStationConfigLength,
    PULONG pReturnLength,
    BOOLEAN bPerformMerger
    );



LONG WINAPI
RegWinStationQueryA(
    HANDLE hServer,
    PWINSTATIONNAMEA pWinStationName,
    PWINSTATIONCONFIG2A pWinStationConfig,
    ULONG WinStationConfigLength,
    PULONG pReturnLength
    );

#ifdef UNICODE
#define RegWinStationQuery RegWinStationQueryW
#else
#define RegWinStationQuery RegWinStationQueryA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegConsoleShadowQueryA( HANDLE hServer,
                     PWINSTATIONNAMEA pWinStationName,
                     PWDPREFIXA pWdPrefixName,
                     PWINSTATIONCONFIG2A pWinStationConfig,
                     ULONG WinStationConfigLength,
                     PULONG pReturnLength );

LONG WINAPI
RegConsoleShadowQueryW( HANDLE hServer,
                     PWINSTATIONNAMEW pWinStationName,
                     PWDPREFIXW pWdPrefixName,
                     PWINSTATIONCONFIG2W pWinStationConfig,
                     ULONG WinStationConfigLength,
                     PULONG pReturnLength );

#ifdef UNICODE
#define RegConsoleShadowQuery RegConsoleShadowQueryW
#else
#define RegConsoleShadowQuery RegConsoleShadowQueryA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWinStationDeleteW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName
    );

LONG WINAPI
RegWinStationDeleteA(
    HANDLE hServer,
    PWINSTATIONNAMEA pWinStationName
    );

#ifdef UNICODE
#define RegWinStationDelete RegWinStationDeleteW
#else
#define RegWinStationDelete RegWinStationDeleteA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWinStationSetSecurityW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    ULONG SecurityDescriptorLength
    );

LONG WINAPI
RegWinStationSetSecurityA(
    HANDLE hServer,
    PWINSTATIONNAMEA pWinStationName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    ULONG SecurityDescriptorLength
    );

#ifdef UNICODE
#define RegWinStationSetSecurity RegWinStationSetSecurityW
#else
#define RegWinStationSetSecurity RegWinStationSetSecurityA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWinStationQuerySecurityW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    ULONG SecurityDescriptorLength,
    PULONG SecurityDescriptorLengthRequired
    );

LONG WINAPI
RegWinStationQuerySecurityA(
    HANDLE hServer,
    PWINSTATIONNAMEA pWinStationName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    ULONG SecurityDescriptorLength,
    PULONG SecurityDescriptorLengthRequired
    );

#ifdef UNICODE
#define RegWinStationQuerySecurity RegWinStationQuerySecurityW
#else
#define RegWinStationQuerySecurity RegWinStationQuerySecurityA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWinStationQueryDefaultSecurity(
    HANDLE hServer,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    ULONG SecurityDescriptorLength,
    PULONG SecurityDescriptorLengthRequired
    );

/*------------------------------------------------*/

LONG WINAPI
RegWinStationSetNumValueW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    LPWSTR pValueName,
    ULONG ValueData
    );

#ifdef UNICODE
#define RegWinStationSetNumValue RegWinStationSetNumValueW
#else
#define RegWinStationSetNumValue
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWinStationQueryNumValueW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    LPWSTR pValueName,
    PULONG pValueData );

#ifdef UNICODE
#define RegWinStationQueryNumValue RegWinStationQueryNumValueW
#else
#define RegWinStationQueryNumValue
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWinStationQueryValueW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    LPWSTR pValueName,
    PVOID pValueData,
    ULONG ValueSize,
    PULONG pValueSize );

#ifdef UNICODE
#define RegWinStationQueryValue RegWinStationQueryValueW
#else
#define RegWinStationQueryValue
#endif /* UNICODE */

/*------------------------------------------------*/


/*********************************************
 *  Registry APIs for User Configuration Data
 *********************************************/

/*------------------------------------------------*/

BOOLEAN     RegGetUserPolicy( LPWSTR userSID, PPOLICY_TS_USER pPolicy , PUSERCONFIGW pData );
void        RegGetMachinePolicy( PPOLICY_TS_MACHINE pPolicy );

void        RegMergeMachinePolicy( PPOLICY_TS_MACHINE pPolicy, USERCONFIGW *pMachineConfigData ,
                PWINSTATIONCREATE   pCreate  );

/*------------------------------------------------*/

LONG WINAPI
RegUserConfigSet(
    WCHAR * pServerName,
    WCHAR * pUserName,
    PUSERCONFIGW pUserConfig,
    ULONG UserConfigLength
    );

/*------------------------------------------------*/

LONG WINAPI
RegUserConfigQuery(
    WCHAR * pServerName,
    WCHAR * pUserName,
    PUSERCONFIGW pUserConfig,
    ULONG UserConfigLength,
    PULONG pReturnLength
    );

/*------------------------------------------------*/

LONG WINAPI
RegUserConfigDelete(
    WCHAR * pServerName,
    WCHAR * pUserName
    );

/*------------------------------------------------*/

LONG WINAPI
RegUserConfigRename(
    WCHAR * pServerName,
    WCHAR * pUserOldName,
    WCHAR * pUserNewName
    );

/*------------------------------------------------*/

LONG WINAPI
RegDefaultUserConfigQueryW(
    WCHAR * pServerName,
    PUSERCONFIGW pUserConfig,
    ULONG UserConfigLength,
    PULONG pReturnLength
    );

LONG WINAPI
RegDefaultUserConfigQueryA(
    CHAR * pServerName,
    PUSERCONFIGA pUserConfig,
    ULONG UserConfigLength,
    PULONG pReturnLength
    );

#ifdef UNICODE
#define RegDefaultUserConfigQuery RegDefaultUserConfigQueryW
#else
#define RegDefaultUserConfigQuery RegDefaultUserConfigQueryA
#endif /* UNICODE */


/*------------------------------------------------*/


/*********************************************
 *  Additional Support Registry APIs
 *********************************************/

BOOLEAN WINAPI
RegIsTServer(
    WCHAR * pServerName
    );

BOOLEAN WINAPI
RegBuildNumberQuery(
    PULONG pBuildNum
    );

BOOLEAN WINAPI
RegGetTServerVersion(
    WCHAR * pServerName,
    PULONG  pVersionNumber
    );


BOOLEAN WINAPI
RegQueryOEMId(
    BYTE *,
    ULONG
    );

typedef struct _PROGRAMCALL {
    struct _PROGRAMCALL *pFirst;        /* Points to first item in sorted list */
    struct _PROGRAMCALL *pNext;         /* Points to next item in sorted list */
    BOOLEAN  fAlias;                    /* TRUE if commmand is an alias (hidden) */
    LPWSTR   pRegistryMultiString;      /* Command info from registry */
    USHORT   CommandLen;                /* min chars needed for command */
    PWCHAR   Command;                   /* command string */
    PWCHAR   Program;                   /* name of program to execute */
    PWCHAR   Args;                      /* extra args to put on command line */
} PROGRAMCALL, /*FAR*/ *PPROGRAMCALL;

LONG WINAPI
RegQueryUtilityCommandList(
    LPWSTR pUtilityKey,
    PPROGRAMCALL * ppProgramCall
    );

LONG WINAPI
RegFreeUtilityCommandList(
    PPROGRAMCALL pProgramCall
    );

BOOLEAN WINAPI
RegIsMachinePolicyAllowHelp();

/*------------------------------------------------*/


/***********************************
 *  APIs for Window Station Objects
 ***********************************/

/*------------------------------------------------*/

HANDLE WINAPI
WinStationOpenServerW(
    LPWSTR  pServerName
    );

HANDLE WINAPI
WinStationOpenServerA(
    LPSTR  pServerName
    );

#ifdef UNICODE
#define WinStationOpenServer WinStationOpenServerW
#else
#define WinStationOpenServer WinStationOpenServerA
#endif /* UNICODE */

/*------------------------------------------------*/

BOOLEAN WINAPI
WinStationCloseServer(
    HANDLE  hServer
    );

/*------------------------------------------------*/

BOOLEAN WINAPI
WinStationServerPing(
    HANDLE  hServer
    );

/*------------------------------------------------*/

typedef BOOLEAN (WINAPI * PWINSTATIONENUMERATEW)(HANDLE,PLOGONIDW *,PULONG);
typedef BOOLEAN (WINAPI * PWINSTATIONENUMERATEA)(HANDLE,PLOGONIDA *,PULONG);

BOOLEAN WINAPI
WinStationEnumerateW(
    HANDLE  hServer,
    PLOGONIDW *ppLogonId,
    PULONG  pEntries
    );

BOOLEAN WINAPI
WinStationEnumerateA(
    HANDLE  hServer,
    PLOGONIDA *ppLogonId,
    PULONG  pEntries
    );

#ifdef UNICODE
#define WinStationEnumerate WinStationEnumerateW
#else
#define WinStationEnumerate WinStationEnumerateA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef BOOLEAN (WINAPI * PWINSTATIONENUMERATE_INDEXEDW)(HANDLE,PULONG,PLOGONIDW,PULONG,PULONG);
typedef BOOLEAN (WINAPI * PWINSTATIONENUMERATE_INDEXEDA)(HANDLE,PULONG,PLOGONIDA,PULONG,PULONG);

BOOLEAN WINAPI
WinStationEnumerate_IndexedW(
    HANDLE  hServer,
    PULONG  pEntries,
    PLOGONIDW pLogonId,
    PULONG  pByteCount,
    PULONG  pIndex
    );

BOOLEAN WINAPI
WinStationEnumerate_IndexedA(
    HANDLE  hServer,
    PULONG  pEntries,
    PLOGONIDA pLogonId,
    PULONG  pByteCount,
    PULONG  pIndex
    );

#ifdef UNICODE
#define WinStationEnumerate_Indexed WinStationEnumerate_IndexedW
#else
#define WinStationEnumerate_Indexed WinStationEnumerate_IndexedA
#endif /* UNICODE */

/*------------------------------------------------*/

BOOLEAN WINAPI
WinStationEnumerateProcesses(
    HANDLE  hServer,
    PVOID *ppProcessBuffer
    );

/*------------------------------------------------*/

BOOLEAN WINAPI
WinStationGetAllProcesses(
                          HANDLE    hServer,
                          ULONG     Level,
                          ULONG    *pNumberOfProcesses,
                          PVOID    *ppProcessArray
                          );

/*------------------------------------------------*/

#ifdef _WINBASE_
BOOLEAN WINAPI
WinStationGetProcessSid(
        HANDLE   hServer,
        DWORD    ProcessId,
        FILETIME ProcessStartTime,
        PBYTE    pProcessUserSid,
        DWORD    *pdwSidSize
        );
#else
BOOLEAN WINAPI
WinStationGetProcessSid(
        HANDLE   hServer,
        ULONG    ProcessId,
        LARGE_INTEGER   ProcessStartTime,
        PUCHAR    pProcessUserSid,
        ULONG    *pdwSidSize
        );
#endif

BOOLEAN WINAPI
WinStationRenameW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationNameOld,
    PWINSTATIONNAMEW pWinStationNameNew
    );

BOOLEAN WINAPI
WinStationRenameA(
    HANDLE hServer,
    PWINSTATIONNAMEA pWinStationNameOld,
    PWINSTATIONNAMEA pWinStationNameNew
    );

#ifdef UNICODE
#define WinStationRename WinStationRenameW
#else
#define WinStationRename WinStationRenameA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef BOOLEAN (WINAPI * PWINSTATIONQUERYINFORMATIONW)(HANDLE,ULONG,WINSTATIONINFOCLASS,PVOID,ULONG,PULONG);
typedef BOOLEAN (WINAPI * PWINSTATIONQUERYINFORMATIONA)(HANDLE,ULONG,WINSTATIONINFOCLASS,PVOID,ULONG,PULONG);

BOOLEAN WINAPI
WinStationQueryInformationW(
    HANDLE hServer,
    ULONG LogonId,
    WINSTATIONINFOCLASS WinStationInformationClass,
    PVOID  pWinStationInformation,
    ULONG WinStationInformationLength,
    PULONG  pReturnLength
    );

BOOLEAN WINAPI
WinStationQueryInformationA(
    HANDLE hServer,
    ULONG LogonId,
    WINSTATIONINFOCLASS WinStationInformationClass,
    PVOID  pWinStationInformation,
    ULONG WinStationInformationLength,
    PULONG  pReturnLength
    );

#ifdef UNICODE
#define WinStationQueryInformation WinStationQueryInformationW
#else
#define WinStationQueryInformation WinStationQueryInformationA
#endif /* UNICODE */

/*------------------------------------------------*/

BOOLEAN WINAPI
WinStationSetInformationW(
    HANDLE hServer,
    ULONG LogonId,
    WINSTATIONINFOCLASS WinStationInformationClass,
    PVOID pWinStationInformation,
    ULONG WinStationInformationLength
    );

BOOLEAN WINAPI
WinStationSetInformationA(
    HANDLE hServer,
    ULONG LogonId,
    WINSTATIONINFOCLASS WinStationInformationClass,
    PVOID pWinStationInformation,
    ULONG WinStationInformationLength
    );

#ifdef UNICODE
#define WinStationSetInformation WinStationSetInformationW
#else
#define WinStationSetInformation WinStationSetInformationA
#endif /* UNICODE */

/*------------------------------------------------*/

BOOLEAN WINAPI
WinStationGetLanAdapterNameW(
    HANDLE hServer,
    ULONG LanAdapter,
    ULONG pdNameLength,
    PWCHAR pPdName,
    ULONG *pLength,
    PWCHAR *ppLanAdapter
    );

BOOLEAN WINAPI
WinStationGetLanAdapterNameA(
    HANDLE hServer,
    ULONG LanAdapter,
    ULONG pdNameLength,
    PCHAR pPdName,
    ULONG *pLength,
    PCHAR *ppLanAdapter
    );

#ifdef UNICODE
#define WinStationGetLanAdapterName WinStationGetLanAdapterNameW
#else
#define WinStationGetLanAdapterName WinStationGetLanAdapterNameA
#endif /* UNICODE */


/*------------------------------------------------*/

BOOLEAN WINAPI
WinStationSendMessageW(
    HANDLE hServer,
    ULONG LogonId,
    LPWSTR  pTitle,
    ULONG TitleLength,
    LPWSTR  pMessage,
    ULONG MessageLength,
    ULONG Style,
    ULONG Timeout,
    PULONG pResponse,
    BOOLEAN DoNotWait
    );

BOOLEAN WINAPI
WinStationSendMessageA(
    HANDLE hServer,
    ULONG LogonId,
    LPSTR  pTitle,
    ULONG TitleLength,
    LPSTR  pMessage,
    ULONG MessageLength,
    ULONG Style,
    ULONG Timeout,
    PULONG pResponse,
    BOOLEAN DoNotWait
    );

#ifdef UNICODE
#define WinStationSendMessage WinStationSendMessageW
#else
#define WinStationSendMessage WinStationSendMessageA
#endif /* UNICODE */


/*
 *  These are new pResponse values
 */
#define IDTIMEOUT        32000  // The MsgBox timed out before a user response
#define IDASYNC          32001  // The request was for an Async message box, no return
#define IDERROR          32002  // an error occured that resulted in not displaying
#define IDCOUNTEXCEEDED  32003  // to many in queue for winstation already
#define IDDESKTOPERROR   32004  // current desktop is not default


/*------------------------------------------------*/

BOOLEAN WINAPI
LogonIdFromWinStationNameW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    PULONG pLogonId
    );

BOOLEAN WINAPI
LogonIdFromWinStationNameA(
    HANDLE hServer,
    PWINSTATIONNAMEA pWinStationName,
    PULONG pLogonId
    );

#ifdef UNICODE
#define LogonIdFromWinStationName LogonIdFromWinStationNameW
#else
#define LogonIdFromWinStationName LogonIdFromWinStationNameA
#endif /* UNICODE */

/*------------------------------------------------*/

BOOLEAN WINAPI
WinStationNameFromLogonIdW(
    HANDLE hServer,
    ULONG LogonId,
    PWINSTATIONNAMEW pWinStationName
    );

BOOLEAN WINAPI
WinStationNameFromLogonIdA(
    HANDLE hServer,
    ULONG LogonId,
    PWINSTATIONNAMEA pWinStationName
    );

#ifdef UNICODE
#define WinStationNameFromLogonId WinStationNameFromLogonIdW
#else
#define WinStationNameFromLogonId WinStationNameFromLogonIdA
#endif /* UNICODE */

/*------------------------------------------------*/

BOOLEAN WINAPI
WinStationConnectW(
    HANDLE hServer,
    ULONG LogonId,
    ULONG TargetLogonId,
    PWCHAR pPassword,
    BOOLEAN bWait
    );

BOOLEAN WINAPI
WinStationConnectA(
    HANDLE hServer,
    ULONG LogonId,
    ULONG TargetLogonId,
    PCHAR pPassword,
    BOOLEAN bWait
    );

#ifdef UNICODE
#define WinStationConnect WinStationConnectW
#else
#define WinStationConnect WinStationConnectA
#endif /* UNICODE */

/*------------------------------------------------*/


HANDLE WINAPI
WinStationVirtualOpen(
    HANDLE hServer,
    ULONG LogonId,
    PVIRTUALCHANNELNAME pVirtualChannelName    /* ascii name */
    );

typedef HANDLE (WINAPI * PWINSTATIONBEEPOPEN)(ULONG);
HANDLE WINAPI
_WinStationBeepOpen(
    ULONG LogonId
    );

BOOLEAN WINAPI
WinStationDisconnect(
    HANDLE hServer,
    ULONG LogonId,
    BOOLEAN bWait
    );


BOOLEAN WINAPI
WinStationReset(
    HANDLE hServer,
    ULONG LogonId,
    BOOLEAN bWait
    );

BOOLEAN WINAPI
WinStationShadowStop(
    HANDLE hServer,
    ULONG LogonId,
    BOOLEAN bWait
    );

BOOLEAN WINAPI
WinStationShutdownSystem(
    HANDLE hServer,
    ULONG ShutdownFlags
    );

#define WSD_LOGOFF      0x00000001  // force WinStations to logoff
#define WSD_SHUTDOWN    0x00000002  // shutdown system
#define WSD_REBOOT      0x00000004  // reboot after shutdown
#define WSD_POWEROFF    0x00000008  // reboot after shutdown
#define WSD_FASTREBOOT  0x00000010  // CTRL-SHIFT-ALT-DEL fast reboot


typedef BOOLEAN (WINAPI * PWINSTATIONWAITSYSTEMEVENT)(HANDLE,ULONG,PULONG);

BOOLEAN WINAPI
WinStationWaitSystemEvent(
    HANDLE hServer,
    ULONG EventMask,
    PULONG pEventFlags
    );


BOOLEAN WINAPI
WinStationShadow(
    HANDLE hServer,
    PWSTR pTargetServerName,
    ULONG TargetLogonId,
    BYTE HotkeyVk,
    USHORT HotkeyModifiers
    );


typedef BOOLEAN (WINAPI * PWINSTATIONFREEMEMORY)( PVOID );

BOOLEAN WINAPI
WinStationFreeMemory(
    PVOID  pBuffer
    );

BOOLEAN WINAPI
WinStationFreeGAPMemory(
    ULONG   Level,
    PVOID   ProcessArray,
    ULONG   NbProcesses
    );

BOOLEAN WINAPI
WinStationTerminateProcess(
    HANDLE hServer,
    ULONG ProcessId,
    ULONG ExitCode
    );

BOOLEAN WINAPI
WinStationNtsdDebug(
    ULONG LogonId,
    LONG  ProcessId,
    ULONG DbgProcessId,
    ULONG DbgThreadId,
    PVOID AttachCompletionRoutine
    );

BOOLEAN WINAPI
_WinStationCallback(
    HANDLE hServer,
    ULONG LogonId,
    LPWSTR pPhoneNumber
    );

BOOLEAN WINAPI
_WinStationBreakPoint(
    HANDLE hServer,
    ULONG LogonId,
    BOOLEAN KernelFlag
    );

BOOLEAN WINAPI
_WinStationReadRegistry(
    HANDLE  hServer
    );

BOOLEAN WINAPI
_WinStationUpdateSettings(
    HANDLE hServer,
    WINSTATIONUPDATECFGCLASS SettingsClass,
    ULONG SettingsParameters
    );

BOOLEAN WINAPI
_WinStationWaitForConnect(
    VOID
    );


BOOLEAN WINAPI
_WinStationNotifyLogon(
    BOOLEAN fUserIsAdmin,
    HANDLE UserToken,
    PWCHAR pDomain,
    PWCHAR pUserName,
    PWCHAR pPassword,
    UCHAR Seed,
    PUSERCONFIGW pUserConfig,
    BOOLEAN *pfIsRedirected
    );


BOOLEAN WINAPI
_WinStationNotifyLogoff(
    VOID
    );

BOOLEAN WINAPI
_WinStationNotifyNewSession(
    HANDLE hServer,
    ULONG  LogonId
    );

BOOLEAN WINAPI
_WinStationGetApplicationInfo(
    HANDLE hServer,
    ULONG  LogonId,
    PBOOLEAN pfPublished,
    PBOOLEAN pfAnonymous
    );

BOOLEAN WINAPI
_WinStationCheckForApplicationName(
    HANDLE hServer,
    ULONG  LogonId,
    PWCHAR pUserName,
    ULONG  UserNameSize,
    PWCHAR pDomain,
    ULONG  DomainSize,
    PWCHAR pPassword,
    ULONG  *pPasswordSize,
    ULONG  MaxPasswordSize,
    PCHAR  pSeed,
    PBOOLEAN pfPublished,
    PBOOLEAN pfAnonymous
    );

BOOLEAN WINAPI
_WinStationReInitializeSecurity(
    HANDLE  hServer
    );

BOOLEAN WINAPI
_WinStationUpdateClientCachedCredentials(
    PWCHAR pDomain,
    PWCHAR pUserName,
    BOOLEAN fSmartCard
    );
    
BOOLEAN WINAPI
_WinStationFUSCanRemoteUserDisconnect(
    ULONG  LogonId,
    PWCHAR pDomain,
    PWCHAR pUserName
    );
    
BOOLEAN WINAPI
WinStationCheckLoopBack(
    HANDLE hServer,
    ULONG ClientSessionId,
    ULONG TargetLogonId,
    LPWSTR pTargetServerName
    );

BOOLEAN WINAPI
_WinStationNotifyDisconnectPipe(
    VOID
    );
        
BOOLEAN WINAPI
_WinStationSessionInitialized(
    VOID
    );

BOOLEAN WINAPI
WinStationCheckAccess(
    HANDLE UserToken,
    ULONG TargetLogonId,
    ULONG DesiredAccess
    );


/*******************************************************************
 *  WinStation APIs for Generic Licensing
 *  (The WinStation extension DLL determines actual implementation)
 *******************************************************************/

BOOLEAN WINAPI
WinStationGenerateLicense(
    HANDLE hServer,
    PWCHAR pSerialNumberString,
    PVOID pLicense,
    ULONG LicenseSize
    );

BOOLEAN WINAPI
WinStationInstallLicense(
    HANDLE hServer,
    PVOID pLicense,
    ULONG LicenseSize
    );

typedef BOOLEAN (WINAPI * PWINSTATIONENUMERATELICENSES)( HANDLE, PCHAR *, ULONG * );

BOOLEAN WINAPI
WinStationEnumerateLicenses(
    HANDLE hServer,
    PVOID *ppLicense,
    ULONG  *pEntries
    );

BOOLEAN WINAPI
WinStationActivateLicense(
    HANDLE hServer,
    PVOID pLicense,
    ULONG  LicenseSize,
    PWCHAR pActivationCode
    );

BOOLEAN WINAPI
WinStationRemoveLicense(
    HANDLE hServer,
    PVOID pLicense,
    ULONG  LicenseSize
    );

BOOLEAN WINAPI
WinStationSetPoolCount(
    HANDLE hServer,
    PVOID pLicense,
    ULONG  LicenseSize
    );


BOOLEAN WINAPI
WinStationQueryLicense(
    HANDLE hServer,
    PVOID pLicenseCounts,
    ULONG ByteCount
    );

BOOLEAN WINAPI
WinStationQueryUpdateRequired(
    HANDLE hServer,
    PULONG pUpdateFlag
    );

BOOLEAN WINAPI
_WinStationAnnoyancePopup(
    HANDLE hServer,
    ULONG LogonId
    );

BOOLEAN WINAPI
WinStationGetTermSrvCountersValue(
    HANDLE hServer,
    ULONG  dwEntries,
    PVOID  pCounter
    );

#ifdef _WINBASE_
LONG WINAPI
WinStationBroadcastSystemMessage( 
        HANDLE  hServer,
        BOOL    sendToAllWinstations,
        ULONG   sessionID,     
        ULONG   timeOut,
        DWORD   dwFlags,            
        DWORD   *lpdwRecipients,   
        ULONG   uiMessage,           
        WPARAM  wParam,            
        LPARAM  lParam, 
        LONG    *pResponse        
    );

LONG WINAPI
WinStationSendWindowMessage(
        HANDLE  hServer,
        ULONG   sessionID,
        ULONG   timeOut,
        ULONG   hWnd,        
        ULONG   Msg,         
        WPARAM  wParam,      
        LPARAM  lParam,      
        LONG    *pResponse
  );
  
  
BOOLEAN    WinStationGetMachinePolicy (
        HANDLE              hServer,
        POLICY_TS_MACHINE   *pPolicy
    );
#endif

//
//  This API consolidates the previous two APIs used by Winlogon to retrieve
//  auto-logon credentials. It is hardcoded to use the local server only, for
//  the caller's session only. Is is UNICODE only, as well. The parameter is
//  actually a PWLX_CLIENT_CREDENTIALS_INFO of at least version 2.
//

#ifdef _WINBASE_

#include <winwlx.h>

BOOLEAN WINAPI
WinStationQueryLogonCredentialsW(
    PWLX_CLIENT_CREDENTIALS_INFO_V2_0 pCredentials
    );


/* __CONSOLE_NOTIFY__ */

// notification masks.


#define CREATE_MASK(__bit)   (1 << (__bit -1) )



#define WTS_CONSOLE_CONNECT_MASK             CREATE_MASK( WTS_CONSOLE_CONNECT )
#define WTS_CONSOLE_DISCONNECT_MASK          CREATE_MASK( WTS_CONSOLE_DISCONNECT )
#define WTS_REMOTE_CONNECT_MASK              CREATE_MASK( WTS_REMOTE_CONNECT )
#define WTS_REMOTE_DISCONNECT_MASK           CREATE_MASK( WTS_REMOTE_DISCONNECT )
#define WTS_SESSION_LOGON_MASK               CREATE_MASK( WTS_SESSION_LOGON )
#define WTS_SESSION_LOGOFF_MASK              CREATE_MASK( WTS_SESSION_LOGOFF )
#define WTS_SESSION_LOCK_MASK                CREATE_MASK( WTS_SESSION_LOCK )
#define WTS_SESSION_UNLOCK_MASK              CREATE_MASK( WTS_SESSION_UNLOCK )
#define WTS_SESSION_REMOTE_CONTROL_MASK      CREATE_MASK( WTS_SESSION_REMOTE_CONTROL )

#define WTS_ALL_NOTIFICATION_MASK           0xFFFFFFFF


BOOL WINAPI
WinStationRegisterConsoleNotification (
                HANDLE  hServer,
                HWND    hWnd,
                DWORD   dwFlags
                );

BOOL WINAPI 
WinStationRegisterConsoleNotificationEx (
                HANDLE  hServer,
                HWND    hWnd,
                DWORD   dwFlags,
                DWORD   dwMask
                );

BOOL WINAPI
WinStationUnRegisterConsoleNotification (
                HANDLE  hServer,
                HWND    hWnd
                );

BOOL WINAPI 
WinStationRegisterNotificationEvent (
                HANDLE hEventHandle,
                ULONG_PTR *pNotificationId,
                DWORD   dwFlags,
                DWORD   dwMask
                );

BOOL WINAPI 
WinStationUnRegisterNotificationEvent (
                ULONG_PTR   NotificationId
                );


/* __CONSOLE_NOTIFY__ */
#endif // _WINBASE_        // handle rdpwd including this

//-----------------------------------------------------------------------------
//
// The following APIs are only for supporting a 5.1 client to 5.0 server
// connection. On a 5.1 server, ERROR_INVALID_FUNCTION will be returned.
//
//-----------------------------------------------------------------------------

BOOLEAN WINAPI
ServerGetInternetConnectorStatus(
    HANDLE   hServer,
    ULONG *pResult,
    PBOOLEAN pfEnabled
    );


BOOLEAN WINAPI
ServerSetInternetConnectorStatus(
    HANDLE   hServer,
    ULONG *pResult,
    BOOLEAN  fEnabled
    );

/*-ServerQueryInetConnectorInformation-------------*/

BOOLEAN WINAPI
ServerQueryInetConnectorInformationW(
    HANDLE hServer,
    PVOID  pWinStationInformation,
    ULONG WinStationInformationLength,
    PULONG  pReturnLength
    );

BOOLEAN WINAPI
ServerQueryInetConnectorInformationA(
    HANDLE hServer,
    PVOID  pWinStationInformation,
    ULONG WinStationInformationLength,
    PULONG  pReturnLength
    );

#ifdef UNICODE
#define ServerQueryInetConnectorInformation ServerQueryInetConnectorInformationW
#else
#define ServerQueryInetConnectorInformation ServerQueryInetConnectorInformationA
#endif /* UNICODE */

/*-------------------------------------------------*/

//
//  Surround these APIs with a check for winbase.h. Termdd is including this
//  file, but doesn't understand winbase types (DWORD).
//

#ifdef _WINBASE_

HANDLE WINAPI
ServerLicensingOpenW(
    LPWSTR pszServerName
    );

HANDLE WINAPI
ServerLicensingOpenA(
    LPSTR pszServerName
    );

#ifdef UNICODE
#define ServerLicensingOpen ServerLicensingOpenW
#else
#define ServerLicensingOpen ServerLicensingOpenA
#endif

VOID WINAPI
ServerLicensingClose(
    HANDLE hServer
    );

BOOLEAN WINAPI
ServerLicensingLoadPolicy(
    HANDLE hServer,
    ULONG ulPolicyId
    );

BOOLEAN WINAPI
ServerLicensingUnloadPolicy(
    HANDLE hServer,
    ULONG ulPolicyId
    );

DWORD WINAPI
ServerLicensingSetPolicy(
    HANDLE hServer,
    ULONG ulPolicyId,
    LPDWORD lpNewPolicyStatus
    );

BOOLEAN WINAPI
ServerLicensingGetAvailablePolicyIds(
    HANDLE hServer,
    PULONG *ppulPolicyIds,
    PULONG pcPolicies
    );

BOOLEAN WINAPI
ServerLicensingGetPolicy(
    HANDLE hServer,
    PULONG pulPolicyId
    );

BOOLEAN WINAPI
ServerLicensingGetPolicyInformationW(
    HANDLE hServer,
    ULONG ulPolicyId,
    PULONG pulVersion,
    LPLCPOLICYINFOGENERIC *ppPolicyInfo
    );

BOOLEAN WINAPI
ServerLicensingGetPolicyInformationA(
    HANDLE hServer,
    ULONG ulPolicyId,
    PULONG pulVersion,
    LPLCPOLICYINFOGENERIC *ppPolicyInfo
    );

VOID
ServerLicensingFreePolicyInformation(
    LPLCPOLICYINFOGENERIC *ppPolicyInfo
    );

BOOLEAN
WinStationConnectCallback(
    HANDLE hServer,
    DWORD  Timeout,
    ULONG  AddressType,
    PBYTE  pAddress,
    ULONG  AddressSize
    );

#ifdef UNICODE
#define ServerLicensingGetPolicyInformation ServerLicensingGetPolicyInformationW
#else
#define ServerLicensingGetPolicyInformation ServerLicensingGetPolicyInformationA
#endif

BOOLEAN WINAPI
ServerLicensingDeactivateCurrentPolicy(
    HANDLE hServer
    );

#endif  // _WINBASE_

BOOLEAN WINAPI
WinStationIsHelpAssistantSession(
    HANDLE hServer,
    ULONG SessionId
);

BOOLEAN WINAPI
RemoteAssistancePrepareSystemRestore(
	HANDLE hServer
);

ULONG WINAPI
WinStationAutoReconnect(
    ULONG flags
    );
    
BOOLEAN WINAPI
_WinStationOpenSessionDirectory(
    HANDLE hServer,
    LPWSTR pszServerName
    );


#ifdef __cplusplus
}
#endif

#endif  /* !_INC_WINSTAH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\termsrv\inc\wfregupg.h ===
/*************************************************************************
*
* wfregupg.h
*
* Includes for Terminal Server registry keys - used by Hydra to upgrade
* existing WinFrame installations to Hydra
*
* copyright notice: Copyright 1998, Microsoft
*
*
*************************************************************************/

#ifndef __WFREGUPG__
#define __WFREGUPG_H__

// @@BEGIN_DDKSPLIT

#include <regapi.h>

/*
 * partial key strings used to build larger key strings
 */
#define  REG_CITRIX                         L"Citrix"
#define  REG_CITRIX_A                       "Citrix"

/*
 *  CONTROL defines
 */
#define  REG_CONTROL_CITRIX                     REG_CONTROL L"\\" REG_CITRIX
#define  REG_CONTROL_CITRIX_A               REG_CONTROL_A "\\" REG_CITRIX_A
#define  USERCONFIG_REG_NAME_CITRIX         REG_CONTROL_CITRIX L"\\" REG_USERCONFIG L"\\"
#define  DEFCONFIG_REG_NAME_CITRIX          REG_CONTROL_CITRIX L"\\" REG_DEFAULTUSERCONFIG
#define  AUTHORIZEDAPPS_REG_NAME_CITRIX     REG_CONTROL_CITRIX L"\\" REG_AUTHORIZEDAPPLICATIONS
#define  DOS_REG_NAME_CITRIX                REG_CONTROL_CITRIX L"\\" REG_DOS

/*
 * SOFTWARE defines
 */

// @@END_DDKSPLIT
#define  REG_SOFTWARE_CITRIX                L"Software\\Citrix"
// @@BEGIN_DDKSPLIT

#define  REG_SOFTWARE_CITRIX_A              "Software\\Citrix"
#define  CHANGEUSER_OPTION_REG_NAME_CITRIX  REG_SOFTWARE_CITRIX L"\\" REG_INSTALL L"\\" REG_CHANGEUSER_OPTION
#define  COMPAT_REG_NAME_CITRIX             REG_SOFTWARE_CITRIX L"\\" REG_COMPATIBILITY
#define  INSTALL_REG_NAME_CITRIX            REG_SOFTWARE_CITRIX L"\\" REG_INSTALL
#define  SECURITY_REG_NAME_CITRIX           REG_SOFTWARE_CITRIX L"\\" REG_SECURITY
#define  WINDOWS_REG_NAME_CITRIX            REG_SOFTWARE_CITRIX L"\\" REG_WINDOWS

/*
 * REG_CONTROL_CITRIX values
 */
#define REG_CITRIX_HYDRAUPGRADEDWINFRAME    L"HydraUpgradedWinFrame"

// @@END_DDKSPLIT

#endif //__WFREGUPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\termsrv\inc\wstmsg.h ===
/*************************************************************************
*
* wstmsg.h
*
* Session Manager Window Station API Messages
*
* copyright notice: Copyright 1998, Microsoft Corporation
*
*
*************************************************************************/

#ifndef WINAPI
#define WINAPI      __stdcall
#endif

#define CITRIX_WINSTATIONAPI_VERSION  1

#define WINSTATIONAPI_PORT_MEMORY_SIZE 0x2000 // 8K will hold everything

/*
 * Define WinStation control port name
 */
#define WINSTATION_CTRL_PORT_NAME L"\\WinStationCtrlPort"


#define DR_RECONNECT_DEVICE_NAMEW L"\\Device\\Video0"
#define DR_RECONNECT_DEVICE_NAMEA "\\Device\\Video0"

//
// This is the ConnectInfo structure passed at NtConnectPort() time
// so that the server can verify our access rights.
//
typedef struct _WINSTATIONAPI_CONNECT_INFO {
    ULONG    Version;
    ULONG    RequestedAccess;
    NTSTATUS AcceptStatus;
} WINSTATIONAPI_CONNECT_INFO, *PWINSTATIONAPI_CONNECT_INFO;


/*
 * WinStation APIs
 * The following APIs are processed by ICASRV or WIN32
 * depending on the API.  If you make any changes to this
 * table, be sure to update the corresponding API dispatch table
 * in both ICASRV and in Win32.
 */
typedef enum _WINSTATION_APINUMBER {
    SMWinStationCreate,
    SMWinStationReset,
    SMWinStationDisconnect,
    SMWinStationWCharLog,
    SMWinStationGetSMCommand,
    SMWinStationBrokenConnection,
    SMWinStationIcaReplyMessage,
    SMWinStationIcaShadowHotkey,
    SMWinStationDoConnect,
    SMWinStationDoDisconnect,
    SMWinStationDoReconnect,
    SMWinStationExitWindows,
    SMWinStationTerminate,
    SMWinStationNtSecurity,
    SMWinStationDoMessage,
    SMWinStationDoBreakPoint,
    SMWinStationThinwireStats,
    SMWinStationShadowSetup,
    SMWinStationShadowStart,
    SMWinStationShadowStop,
    SMWinStationShadowCleanup,
    SMWinStationPassthruEnable,
    SMWinStationPassthruDisable,
    SMWinStationSetTimeZone,
    SMWinStationInitialProgram,
    SMWinStationNtsdDebug,
    SMWinStationBroadcastSystemMessage,             // API for using Window's BroadcastSystemMessage()
    SMWinStationSendWindowMessage,                  // API for using WIndows's SendMessage()
    SMWinStationNotify,
    SMWinStationDoLoadStringNMessage,               // Similar to SMWinStationDoMessage except that CSRSS loads the string
    SMWinStationWindowInvalid,
    SMWinStationMaxApiNumber
} WINSTATION_APINUMBER;

/*
 * API function specific messages for WinStations
 */
typedef struct _WINSTATIONCREATEMSG {
    WINSTATIONNAME WinStationName;
    ULONG LogonId;
} WINSTATIONCREATEMSG;

typedef struct _WINSTATIONRESETMSG {
    ULONG LogonId;
} WINSTATIONRESETMSG;

typedef struct _WINSTATIONDISCONNECTMSG {
    ULONG LogonId;
} WINSTATIONDISCONNECTMSG;

typedef struct _WINSTATIONDODISCONNECTMSG {
    BOOLEAN ConsoleShadowFlag;
    ULONG NotUsed;
} WINSTATIONDODISCONNECTMSG;

typedef struct _WINSTATIONDOCONNECTMSG {
    BOOLEAN ConsoleShadowFlag;
    BOOLEAN fMouse;
    BOOLEAN fINetClient;
    BOOLEAN fInitialProgram;
    BOOLEAN fHideTitleBar;
    BOOLEAN fMaximize;
    HANDLE  hIcaVideoChannel;
    HANDLE  hIcaMouseChannel;
    HANDLE  hIcaKeyboardChannel;
    HANDLE  hIcaBeepChannel;
    HANDLE  hIcaCommandChannel;
    HANDLE  hIcaThinwireChannel;
    HANDLE  hDisplayChangeEvent;
    WINSTATIONNAME WinStationName;

    WCHAR   DisplayDriverName[9];
    WCHAR   ProtocolName[9];
    WCHAR   AudioDriverName[9];

    USHORT HRes;                   // are for dynamically changing
    USHORT VRes;                   // display resolution at reconnection.
    USHORT ColorDepth;
    USHORT ProtocolType;   // PROTOCOL_ICA or PROTOCOL_RDP
    BOOLEAN fClientDoubleClickSupport;
    BOOLEAN fEnableWindowsKey;

    ULONG KeyboardType;
    ULONG KeyboardSubType;
    ULONG KeyboardFunctionKey;
} WINSTATIONDOCONNECTMSG;

typedef struct _WINSTATIONDORECONNECTMSG {
    BOOLEAN fMouse;
    BOOLEAN fINetClient;
    BOOLEAN fClientDoubleClickSupport;
    BOOLEAN fEnableWindowsKey;
    BOOLEAN fDynamicReconnect;      // Session can resize Display at reconnect
    WINSTATIONNAME WinStationName;
    WCHAR AudioDriverName[9];
    WCHAR   DisplayDriverName[9];
    WCHAR   ProtocolName[9];
    USHORT HRes;                    // are for dynamically changing
    USHORT VRes;                    // display resolution at reconnection.
    USHORT ColorDepth;
    USHORT ProtocolType;            // PROTOCOL_ICA or PROTOCOL_RDP

    ULONG KeyboardType;
    ULONG KeyboardSubType;
    ULONG KeyboardFunctionKey;
} WINSTATIONDORECONNECTMSG;


typedef enum _WINSTATIONNOTIFYEVENT {
    WinStation_Notify_Disconnect,
    WinStation_Notify_Reconnect,
    WinStation_Notify_PreReconnect,
    WinStation_Notify_SyncDisconnect,
    WinStation_Notify_DisableScrnSaver,
    WinStation_Notify_EnableScrnSaver,
    WinStation_Notify_PreReconnectDesktopSwitch,
    WinStation_Notify_HelpAssistantShadowStart,
    WinStation_Notify_HelpAssistantShadowFinish,
    WinStation_Notify_DisconnectPipe
} WINSTATIONNOTIFYEVENT;

typedef struct _WINSTATIONWINDOWINVALIDMSG {
    ULONG hWnd;
    ULONG SessionId;
} WINSTATIONWINDOWINVALIDMSG;

typedef struct _WINSTATIONDONOTIFYMSG {
    WINSTATIONNOTIFYEVENT NotifyEvent;
} WINSTATIONDONOTIFYMSG;

typedef struct _WINSTATIONTHINWIRESTATSMSG {
    CACHE_STATISTICS Stats;
} WINSTATIONTHINWIRESTATSMSG;

typedef struct _WINSTATIONEXITWINDOWSMSG {
    ULONG Flags;
} WINSTATIONEXITWINDOWSMSG;

typedef struct _WINSTATIONSENDMESSAGEMSG {
    LPWSTR pTitle;
    ULONG  TitleLength;
    LPWSTR pMessage;
    ULONG  MessageLength;
    ULONG  Style;
    ULONG  Timeout;
    ULONG  Response;
    PULONG pResponse;
    BOOLEAN DoNotWait;
    BOOLEAN DoNotWaitForCorrectDesktop;
    PNTSTATUS pStatus;
    HANDLE hEvent;
} WINSTATIONSENDMESSAGEMSG;

typedef struct _WINSTATIONLOADSTRINGMSG {
    ULONG   TitleId;
    ULONG   MessageId;
    ULONG   Style;
    ULONG   Timeout;
    ULONG   Response;
    PULONG  pResponse;
    PNTSTATUS pStatus;
    BOOLEAN DoNotWait;
    HANDLE  hEvent;
    LPWSTR  pDomain;
    ULONG   DomainSize;
    LPWSTR  pUserName;
    ULONG   UserNameSize;
} WINSTATIONLOADSTRINGMSG;

typedef struct _WINSTATIONREPLYMESSAGEMSG {
    ULONG  Response;
    PULONG pResponse;
    HANDLE hEvent;
    NTSTATUS Status;
    PNTSTATUS pStatus;
} WINSTATIONREPLYMESSAGEMSG;

typedef struct _WINSTATIONTERMINATEMSG {
    ULONG NotUsed;
} WINSTATIONTERMINATEMSG;

typedef struct _WINSTATIONNTSDDEBUGMSG {
    ULONG LogonId;
    LONG ProcessId;
    CLIENT_ID ClientId;
    PVOID AttachCompletionRoutine;
} WINSTATIONNTSDDEBUGMSG, *PWINSTATIONNTSDDEBUGMSG;

typedef struct _WINSTATIONBREAKPOINTMSG {
    BOOLEAN KernelFlag;
} WINSTATIONBREAKPOINTMSG;

typedef struct _WINSTATIONSHADOWSETUPMSG {
    ULONG NotUsed;
} WINSTATIONSHADOWSETUPMSG;

typedef struct _WINSTATIONSHADOWSTARTMSG {
    PVOID pThinwireData;
    ULONG ThinwireDataLength;
} WINSTATIONSHADOWSTARTMSG;

typedef struct _WINSTATIONSHADOWSTOPMSG {
    ULONG NotUsed;
} WINSTATIONSHADOWSTOPMSG;

typedef struct _WINSTATIONSHADOWCLEANUPMSG {
    PVOID pThinwireData;
    ULONG ThinwireDataLength;
} WINSTATIONSHADOWCLEANUPMSG;

typedef struct _WINSTATIONBROKENCONNECTIONMSG {
    ULONG Reason;  // reason for broken connection (BROKENCLASS)
    ULONG Source;  // source for broken connection (BROKENSOURCECLASS)
} WINSTATIONBROKENCONNECTIONMSG;

typedef struct _WINSTATIONWCHARLOG {
    WCHAR Buffer[100];
} WINSTATIONWCHARLOG;

// This data structure included all params used by window's BroadcastSystemMessage
// Use this APIto send a message to all windows of a winstation.
typedef struct _WINSTATIONBROADCASTSYSTEMMSG {
  DWORD     dwFlags;
  DWORD     dwRecipients;   
  UINT      uiMessage;           
  WPARAM    wParam;            
  LPARAM    lParam;            
  PVOID     dataBuffer;
  ULONG     bufferSize;
  HANDLE    hEvent;
  ULONG     Response;
} WINSTATIONBROADCASTSYSTEMMSG;

// This data structure has all the params used by window's standard SendMessage()API.
// Use this API to send a message to a specific hwnd of a winstation ( you need to know that the appropriate hwnd was)
typedef struct _WINSTATIONSENDWINDOWMSG {
  HWND      hWnd;           // handle of destination window
  UINT      Msg;            // message to send
  WPARAM    wParam;         // first message parameter
  LPARAM    lParam;         // second message parameter
  PCHAR     dataBuffer;
  ULONG     bufferSize;
  HANDLE    hEvent;
  ULONG     Response;
} WINSTATIONSENDWINDOWMSG;

typedef struct _WINSTATIONSETTIMEZONE {
    TS_TIME_ZONE_INFORMATION TimeZone;
} WINSTATIONSETTIMEZONE;

typedef struct _WINSTATION_APIMSG {
    PORT_MESSAGE h;
    ULONG MessageId;
    WINSTATION_APINUMBER ApiNumber;
    BOOLEAN WaitForReply;
    NTSTATUS ReturnedStatus;
    union {
        WINSTATIONCREATEMSG Create;
        WINSTATIONRESETMSG Reset;
        WINSTATIONDISCONNECTMSG Disconnect;
        WINSTATIONWCHARLOG WCharLog;
        WINSTATIONREPLYMESSAGEMSG ReplyMessage;
        WINSTATIONDODISCONNECTMSG DoDisconnect;
        WINSTATIONDOCONNECTMSG DoConnect;
        WINSTATIONEXITWINDOWSMSG ExitWindows;
        WINSTATIONTERMINATEMSG Terminate;
        WINSTATIONSENDMESSAGEMSG SendMessage;
        WINSTATIONBREAKPOINTMSG BreakPoint;
        WINSTATIONDORECONNECTMSG DoReconnect;
        WINSTATIONTHINWIRESTATSMSG ThinwireStats;
        WINSTATIONSHADOWSETUPMSG ShadowSetup;
        WINSTATIONSHADOWSTARTMSG ShadowStart;
        WINSTATIONSHADOWSTOPMSG ShadowStop;
        WINSTATIONSHADOWCLEANUPMSG ShadowCleanup;
        WINSTATIONBROKENCONNECTIONMSG Broken;
        WINSTATIONNTSDDEBUGMSG NtsdDebug;
        WINSTATIONBROADCASTSYSTEMMSG        bMsg; // API for Window's BroadcastSystemMessage()
        WINSTATIONSENDWINDOWMSG             sMsg; // API  for WIndows's SendMessage()
        WINSTATIONSETTIMEZONE SetTimeZone;
        WINSTATIONDONOTIFYMSG DoNotify;
        WINSTATIONLOADSTRINGMSG LoadStringMessage;
        WINSTATIONWINDOWINVALIDMSG WindowInvalid;
    } u;
} WINSTATION_APIMSG, *PWINSTATION_APIMSG;


/*
 * WinStation Kernel object interface routines. These provide a common
 * interface to the Nt* API's for the object that can be used by the
 * Session manager, the WinStation client DLL, and the CSRSS subsystem.
 */

/*
 * WinStation kernel object root directory name
 */

#define CITRIX_WINSTATION_OBJECT_DIRECTORY L"\\WinStations"

/*
 * OpenWinStationObject
 *
 *   Open the WinStation Kernel Object of the given Name.
 *
 *  ENTRY:
 *    Id
 *      Id of the WinStation Kernel Object to open. It will be under the path
 *      of "\WinStations\xxx" in the kernel object name space when
 *      created.
 *
 *    pHandle (output)
 *      Pointer to variable to place the handle if the object was created.
 *
 *  EXIT:
 *    Returns the NTSTATUS code from the operation.
 */
NTSTATUS
OpenWinStationObject( ULONG,
                      PHANDLE,
                      ULONG );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\aclapip.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993-1999, Microsoft Corporation

Module Name:

    aclapip.h

Abstract:

    Private
    Structure/constant definitions and typedefines for the Win32 Access
    Control APIs

--*/
#ifndef __ACCESS_CONTROL_API_P__
#define __ACCESS_CONTROL_API_P__

#ifdef __cplusplus
extern "C" {
#endif
#if(_WIN32_WINNT >= 0x0500)

WINADVAPI
DWORD
WINAPI
GetNamedSecurityInfoExA(
    IN   LPCSTR                lpObject,
    IN   SE_OBJECT_TYPE          ObjectType,
    IN   SECURITY_INFORMATION    SecurityInfo,
    IN   LPCSTR                lpProvider,
    IN   LPCSTR                lpProperty,
    OUT  PACTRL_ACCESSA         *ppAccessList,
    OUT  PACTRL_AUDITA          *ppAuditList,
    OUT  LPSTR                *lppOwner,
    OUT  LPSTR                *lppGroup
    );
WINADVAPI
DWORD
WINAPI
GetNamedSecurityInfoExW(
    IN   LPCWSTR                lpObject,
    IN   SE_OBJECT_TYPE          ObjectType,
    IN   SECURITY_INFORMATION    SecurityInfo,
    IN   LPCWSTR                lpProvider,
    IN   LPCWSTR                lpProperty,
    OUT  PACTRL_ACCESSW         *ppAccessList,
    OUT  PACTRL_AUDITW          *ppAuditList,
    OUT  LPWSTR                *lppOwner,
    OUT  LPWSTR                *lppGroup
    );
#ifdef UNICODE
#define GetNamedSecurityInfoEx  GetNamedSecurityInfoExW
#else
#define GetNamedSecurityInfoEx  GetNamedSecurityInfoExA
#endif // !UNICODE

WINADVAPI
DWORD
WINAPI
SetNamedSecurityInfoExA(
    IN    LPCSTR               lpObject,
    IN    SE_OBJECT_TYPE         ObjectType,
    IN    SECURITY_INFORMATION   SecurityInfo,
    IN    LPCSTR               lpProvider,
    IN    PACTRL_ACCESSA         pAccessList,
    IN    PACTRL_AUDITA          pAuditList,
    IN    LPSTR                lpOwner,
    IN    LPSTR                lpGroup,
    IN    PACTRL_OVERLAPPED      pOverlapped
    );
WINADVAPI
DWORD
WINAPI
SetNamedSecurityInfoExW(
    IN    LPCWSTR               lpObject,
    IN    SE_OBJECT_TYPE         ObjectType,
    IN    SECURITY_INFORMATION   SecurityInfo,
    IN    LPCWSTR               lpProvider,
    IN    PACTRL_ACCESSW         pAccessList,
    IN    PACTRL_AUDITW          pAuditList,
    IN    LPWSTR                lpOwner,
    IN    LPWSTR                lpGroup,
    IN    PACTRL_OVERLAPPED      pOverlapped
    );
#ifdef UNICODE
#define SetNamedSecurityInfoEx  SetNamedSecurityInfoExW
#else
#define SetNamedSecurityInfoEx  SetNamedSecurityInfoExA
#endif // !UNICODE

WINADVAPI
DWORD
WINAPI
GetSecurityInfoExA(
    IN    HANDLE                  hObject,
    IN    SE_OBJECT_TYPE          ObjectType,
    IN    SECURITY_INFORMATION    SecurityInfo,
    IN    LPCSTR                lpProvider,
    IN    LPCSTR                lpProperty,
    OUT   PACTRL_ACCESSA         *ppAccessList,
    OUT   PACTRL_AUDITA          *ppAuditList,
    OUT   LPSTR                *lppOwner,
    OUT   LPSTR                *lppGroup
    );
WINADVAPI
DWORD
WINAPI
GetSecurityInfoExW(
    IN    HANDLE                  hObject,
    IN    SE_OBJECT_TYPE          ObjectType,
    IN    SECURITY_INFORMATION    SecurityInfo,
    IN    LPCWSTR                lpProvider,
    IN    LPCWSTR                lpProperty,
    OUT   PACTRL_ACCESSW         *ppAccessList,
    OUT   PACTRL_AUDITW          *ppAuditList,
    OUT   LPWSTR                *lppOwner,
    OUT   LPWSTR                *lppGroup
    );
#ifdef UNICODE
#define GetSecurityInfoEx  GetSecurityInfoExW
#else
#define GetSecurityInfoEx  GetSecurityInfoExA
#endif // !UNICODE

WINADVAPI
DWORD
WINAPI
SetSecurityInfoExA(
    IN    HANDLE                 hObject,
    IN    SE_OBJECT_TYPE         ObjectType,
    IN    SECURITY_INFORMATION   SecurityInfo,
    IN    LPCSTR               lpProvider,
    IN    PACTRL_ACCESSA         pAccessList,
    IN    PACTRL_AUDITA          pAuditList,
    IN    LPSTR                lpOwner,
    IN    LPSTR                lpGroup,
    OUT   PACTRL_OVERLAPPED      pOverlapped
    );
WINADVAPI
DWORD
WINAPI
SetSecurityInfoExW(
    IN    HANDLE                 hObject,
    IN    SE_OBJECT_TYPE         ObjectType,
    IN    SECURITY_INFORMATION   SecurityInfo,
    IN    LPCWSTR               lpProvider,
    IN    PACTRL_ACCESSW         pAccessList,
    IN    PACTRL_AUDITW          pAuditList,
    IN    LPWSTR                lpOwner,
    IN    LPWSTR                lpGroup,
    OUT   PACTRL_OVERLAPPED      pOverlapped
    );
#ifdef UNICODE
#define SetSecurityInfoEx  SetSecurityInfoExW
#else
#define SetSecurityInfoEx  SetSecurityInfoExA
#endif // !UNICODE

WINADVAPI
DWORD
WINAPI
ConvertAccessToSecurityDescriptorA(
    IN  PACTRL_ACCESSA        pAccessList,
    IN  PACTRL_AUDITA         pAuditList,
    IN  LPCSTR              lpOwner,
    IN  LPCSTR              lpGroup,
    OUT PSECURITY_DESCRIPTOR *ppSecDescriptor
    );
WINADVAPI
DWORD
WINAPI
ConvertAccessToSecurityDescriptorW(
    IN  PACTRL_ACCESSW        pAccessList,
    IN  PACTRL_AUDITW         pAuditList,
    IN  LPCWSTR              lpOwner,
    IN  LPCWSTR              lpGroup,
    OUT PSECURITY_DESCRIPTOR *ppSecDescriptor
    );
#ifdef UNICODE
#define ConvertAccessToSecurityDescriptor  ConvertAccessToSecurityDescriptorW
#else
#define ConvertAccessToSecurityDescriptor  ConvertAccessToSecurityDescriptorA
#endif // !UNICODE

WINADVAPI
DWORD
WINAPI
ConvertSecurityDescriptorToAccessA(
    IN  HANDLE               hObject,
    IN  SE_OBJECT_TYPE       ObjectType,
    IN  PSECURITY_DESCRIPTOR pSecDescriptor,
    OUT PACTRL_ACCESSA      *ppAccessList,
    OUT PACTRL_AUDITA       *ppAuditList,
    OUT LPSTR             *lppOwner,
    OUT LPSTR             *lppGroup
    );
WINADVAPI
DWORD
WINAPI
ConvertSecurityDescriptorToAccessW(
    IN  HANDLE               hObject,
    IN  SE_OBJECT_TYPE       ObjectType,
    IN  PSECURITY_DESCRIPTOR pSecDescriptor,
    OUT PACTRL_ACCESSW      *ppAccessList,
    OUT PACTRL_AUDITW       *ppAuditList,
    OUT LPWSTR             *lppOwner,
    OUT LPWSTR             *lppGroup
    );
#ifdef UNICODE
#define ConvertSecurityDescriptorToAccess  ConvertSecurityDescriptorToAccessW
#else
#define ConvertSecurityDescriptorToAccess  ConvertSecurityDescriptorToAccessA
#endif // !UNICODE

WINADVAPI
DWORD
WINAPI
ConvertSecurityDescriptorToAccessNamedA(
    IN  LPCSTR             lpObject,
    IN  SE_OBJECT_TYPE       ObjectType,
    IN  PSECURITY_DESCRIPTOR pSecDescriptor,
    OUT PACTRL_ACCESSA      *ppAccessList,
    OUT PACTRL_AUDITA       *ppAuditList,
    OUT LPSTR             *lppOwner,
    OUT LPSTR             *lppGroup
    );
WINADVAPI
DWORD
WINAPI
ConvertSecurityDescriptorToAccessNamedW(
    IN  LPCWSTR             lpObject,
    IN  SE_OBJECT_TYPE       ObjectType,
    IN  PSECURITY_DESCRIPTOR pSecDescriptor,
    OUT PACTRL_ACCESSW      *ppAccessList,
    OUT PACTRL_AUDITW       *ppAuditList,
    OUT LPWSTR             *lppOwner,
    OUT LPWSTR             *lppGroup
    );
#ifdef UNICODE
#define ConvertSecurityDescriptorToAccessNamed  ConvertSecurityDescriptorToAccessNamedW
#else
#define ConvertSecurityDescriptorToAccessNamed  ConvertSecurityDescriptorToAccessNamedA
#endif // !UNICODE


WINADVAPI
DWORD
WINAPI
SetEntriesInAccessListA(
    IN  ULONG                cEntries,
    IN  PACTRL_ACCESS_ENTRYA pAccessEntryList,
    IN  ACCESS_MODE          AccessMode,
    IN  LPCSTR             lpProperty,
    IN  PACTRL_ACCESSA       pOldList,
    OUT PACTRL_ACCESSA      *ppNewList
    );
WINADVAPI
DWORD
WINAPI
SetEntriesInAccessListW(
    IN  ULONG                cEntries,
    IN  PACTRL_ACCESS_ENTRYW pAccessEntryList,
    IN  ACCESS_MODE          AccessMode,
    IN  LPCWSTR             lpProperty,
    IN  PACTRL_ACCESSW       pOldList,
    OUT PACTRL_ACCESSW      *ppNewList
    );
#ifdef UNICODE
#define SetEntriesInAccessList  SetEntriesInAccessListW
#else
#define SetEntriesInAccessList  SetEntriesInAccessListA
#endif // !UNICODE

WINADVAPI
DWORD
WINAPI
SetEntriesInAuditListA(
    IN  ULONG                 cEntries,
    IN  PACTRL_ACCESS_ENTRYA  pAccessEntryList,
    IN  ACCESS_MODE           AccessMode,
    IN  LPCSTR              lpProperty,
    IN  PACTRL_AUDITA         pOldList,
    OUT PACTRL_AUDITA        *ppNewList
    );
WINADVAPI
DWORD
WINAPI
SetEntriesInAuditListW(
    IN  ULONG                 cEntries,
    IN  PACTRL_ACCESS_ENTRYW  pAccessEntryList,
    IN  ACCESS_MODE           AccessMode,
    IN  LPCWSTR              lpProperty,
    IN  PACTRL_AUDITW         pOldList,
    OUT PACTRL_AUDITW        *ppNewList
    );
#ifdef UNICODE
#define SetEntriesInAuditList  SetEntriesInAuditListW
#else
#define SetEntriesInAuditList  SetEntriesInAuditListA
#endif // !UNICODE

WINADVAPI
DWORD
WINAPI
TrusteeAccessToObjectA(
    IN        LPCSTR           lpObject,
    IN        SE_OBJECT_TYPE     ObjectType,
    IN        LPCSTR           lpProvider,
    IN        PTRUSTEE_A         pTrustee,
    IN        ULONG              cEntries,
    IN OUT    PTRUSTEE_ACCESSA   pTrusteeAccess
    );
WINADVAPI
DWORD
WINAPI
TrusteeAccessToObjectW(
    IN        LPCWSTR           lpObject,
    IN        SE_OBJECT_TYPE     ObjectType,
    IN        LPCWSTR           lpProvider,
    IN        PTRUSTEE_W         pTrustee,
    IN        ULONG              cEntries,
    IN OUT    PTRUSTEE_ACCESSW   pTrusteeAccess
    );
#ifdef UNICODE
#define TrusteeAccessToObject  TrusteeAccessToObjectW
#else
#define TrusteeAccessToObject  TrusteeAccessToObjectA
#endif // !UNICODE

WINADVAPI
DWORD
WINAPI
GetOverlappedAccessResults(
    IN  PACTRL_OVERLAPPED   pOverlapped,
    IN  BOOL                fWaitForCompletion,
    OUT PDWORD              pResult,
    OUT PULONG              pcItemsProcessed OPTIONAL
    );

WINADVAPI
DWORD
WINAPI
CancelOverlappedAccess(
    IN  PACTRL_OVERLAPPED   pOverlapped
    );

WINADVAPI
DWORD
WINAPI
GetAccessPermissionsForObjectA(
    IN   LPCSTR             lpObject,
    IN   SE_OBJECT_TYPE       ObjectType,
    IN   LPCSTR             lpObjType,
    IN   LPCSTR             lpProvider,
    OUT  PULONG               pcEntries,
    OUT  PACTRL_ACCESS_INFOA *ppAccessInfoList,
    OUT  PULONG               pcRights,
    OUT  PACTRL_CONTROL_INFOA *ppRightsList,
    OUT  PULONG               pfAccessFlags
    );
WINADVAPI
DWORD
WINAPI
GetAccessPermissionsForObjectW(
    IN   LPCWSTR             lpObject,
    IN   SE_OBJECT_TYPE       ObjectType,
    IN   LPCWSTR             lpObjType,
    IN   LPCWSTR             lpProvider,
    OUT  PULONG               pcEntries,
    OUT  PACTRL_ACCESS_INFOW *ppAccessInfoList,
    OUT  PULONG               pcRights,
    OUT  PACTRL_CONTROL_INFOW *ppRightsList,
    OUT  PULONG               pfAccessFlags
    );
#ifdef UNICODE
#define GetAccessPermissionsForObject  GetAccessPermissionsForObjectW
#else
#define GetAccessPermissionsForObject  GetAccessPermissionsForObjectA
#endif // !UNICODE

#endif /* _WIN32_WINNT >=  0x0500 */

#ifdef __cplusplus
}
#endif
#endif  // endif __ACCESS_CONTROL_API_P__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\aimm12.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for aimm12.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __aimm12_h__
#define __aimm12_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumRegisterWordA_FWD_DEFINED__
#define __IEnumRegisterWordA_FWD_DEFINED__
typedef interface IEnumRegisterWordA IEnumRegisterWordA;
#endif 	/* __IEnumRegisterWordA_FWD_DEFINED__ */


#ifndef __IEnumRegisterWordW_FWD_DEFINED__
#define __IEnumRegisterWordW_FWD_DEFINED__
typedef interface IEnumRegisterWordW IEnumRegisterWordW;
#endif 	/* __IEnumRegisterWordW_FWD_DEFINED__ */


#ifndef __IEnumInputContext_FWD_DEFINED__
#define __IEnumInputContext_FWD_DEFINED__
typedef interface IEnumInputContext IEnumInputContext;
#endif 	/* __IEnumInputContext_FWD_DEFINED__ */


#ifndef __IActiveIMMMessagePumpOwner_FWD_DEFINED__
#define __IActiveIMMMessagePumpOwner_FWD_DEFINED__
typedef interface IActiveIMMMessagePumpOwner IActiveIMMMessagePumpOwner;
#endif 	/* __IActiveIMMMessagePumpOwner_FWD_DEFINED__ */


#ifndef __IActiveIMMApp_FWD_DEFINED__
#define __IActiveIMMApp_FWD_DEFINED__
typedef interface IActiveIMMApp IActiveIMMApp;
#endif 	/* __IActiveIMMApp_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_aimm12_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// aimm12.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// IActiveIMM 1.2 Interfaces.

EXTERN_C const CLSID CLSID_CActiveIMM12;
EXTERN_C const CLSID CLSID_CActiveIMM12_Trident;
#define AIMM12_PROCESS_ATOM     TEXT("_AIMM12_PROCESS_ATOM_")
#if 0
typedef WORD LANGID;

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0001
    {
    LPSTR lpReading;
    LPSTR lpWord;
    } 	REGISTERWORDA;

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0002
    {
    LPWSTR lpReading;
    LPWSTR lpWord;
    } 	REGISTERWORDW;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0003
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[ 32 ];
    } 	LOGFONTA;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0004
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[ 32 ];
    } 	LOGFONTW;

typedef DWORD HIMC;

typedef DWORD HIMCC;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0005
    {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
    } 	CANDIDATEFORM;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0006
    {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
    } 	COMPOSITIONFORM;

typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0007
    {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[ 1 ];
    } 	CANDIDATELIST;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0008
    {
    DWORD dwStyle;
    CHAR szDescription[ 32 ];
    } 	STYLEBUFA;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0009
    {
    DWORD dwStyle;
    WCHAR szDescription[ 32 ];
    } 	STYLEBUFW;

typedef WORD ATOM;

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0010
    {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    CHAR szString[ 80 ];
    HBITMAP hbmpItem;
    } 	IMEMENUITEMINFOA;

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0011
    {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    WCHAR szString[ 80 ];
    HBITMAP hbmpItem;
    } 	IMEMENUITEMINFOW;

#endif
#if !defined(_DDKIMM_H_) && !defined(_IMM_DDK_DEFINED_)
typedef /* [public] */ struct __MIDL___MIDL_itf_aimm12_0000_0012
    {
    HWND hWnd;
    BOOL fOpen;
    POINT ptStatusWndPos;
    POINT ptSoftKbdPos;
    DWORD fdwConversion;
    DWORD fdwSentence;
    union 
        {
        LOGFONTA A;
        LOGFONTW W;
        } 	lfFont;
    COMPOSITIONFORM cfCompForm;
    CANDIDATEFORM cfCandForm[ 4 ];
    HIMCC hCompStr;
    HIMCC hCandInfo;
    HIMCC hGuideLine;
    HIMCC hPrivate;
    DWORD dwNumMsgBuf;
    HIMCC hMsgBuf;
    DWORD fdwInit;
    DWORD dwReserve[ 3 ];
    } 	INPUTCONTEXT;

typedef /* [public] */ struct __MIDL___MIDL_itf_aimm12_0000_0014
    {
    DWORD dwPrivateDataSize;
    DWORD fdwProperty;
    DWORD fdwConversionCaps;
    DWORD fdwSentenceCaps;
    DWORD fdwUICaps;
    DWORD fdwSCSCaps;
    DWORD fdwSelectCaps;
    } 	IMEINFO;

#endif


extern RPC_IF_HANDLE __MIDL_itf_aimm12_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_aimm12_0000_v0_0_s_ifspec;

#ifndef __IEnumRegisterWordA_INTERFACE_DEFINED__
#define __IEnumRegisterWordA_INTERFACE_DEFINED__

/* interface IEnumRegisterWordA */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumRegisterWordA;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08C03412-F96B-11d0-A475-00AA006BCC59")
    IEnumRegisterWordA : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRegisterWordA **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDA *rgRegisterWord,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegisterWordAVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumRegisterWordA * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumRegisterWordA * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumRegisterWordA * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumRegisterWordA * This,
            /* [out] */ IEnumRegisterWordA **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumRegisterWordA * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDA *rgRegisterWord,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumRegisterWordA * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumRegisterWordA * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumRegisterWordAVtbl;

    interface IEnumRegisterWordA
    {
        CONST_VTBL struct IEnumRegisterWordAVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegisterWordA_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRegisterWordA_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRegisterWordA_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRegisterWordA_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRegisterWordA_Next(This,ulCount,rgRegisterWord,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgRegisterWord,pcFetched)

#define IEnumRegisterWordA_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRegisterWordA_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Clone_Proxy( 
    IEnumRegisterWordA * This,
    /* [out] */ IEnumRegisterWordA **ppEnum);


void __RPC_STUB IEnumRegisterWordA_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Next_Proxy( 
    IEnumRegisterWordA * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ REGISTERWORDA *rgRegisterWord,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumRegisterWordA_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Reset_Proxy( 
    IEnumRegisterWordA * This);


void __RPC_STUB IEnumRegisterWordA_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Skip_Proxy( 
    IEnumRegisterWordA * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumRegisterWordA_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRegisterWordA_INTERFACE_DEFINED__ */


#ifndef __IEnumRegisterWordW_INTERFACE_DEFINED__
#define __IEnumRegisterWordW_INTERFACE_DEFINED__

/* interface IEnumRegisterWordW */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumRegisterWordW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4955DD31-B159-11d0-8FCF-00AA006BCC59")
    IEnumRegisterWordW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRegisterWordW **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDW *rgRegisterWord,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegisterWordWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumRegisterWordW * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumRegisterWordW * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumRegisterWordW * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumRegisterWordW * This,
            /* [out] */ IEnumRegisterWordW **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumRegisterWordW * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDW *rgRegisterWord,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumRegisterWordW * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumRegisterWordW * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumRegisterWordWVtbl;

    interface IEnumRegisterWordW
    {
        CONST_VTBL struct IEnumRegisterWordWVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegisterWordW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRegisterWordW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRegisterWordW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRegisterWordW_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRegisterWordW_Next(This,ulCount,rgRegisterWord,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgRegisterWord,pcFetched)

#define IEnumRegisterWordW_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRegisterWordW_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Clone_Proxy( 
    IEnumRegisterWordW * This,
    /* [out] */ IEnumRegisterWordW **ppEnum);


void __RPC_STUB IEnumRegisterWordW_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Next_Proxy( 
    IEnumRegisterWordW * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ REGISTERWORDW *rgRegisterWord,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumRegisterWordW_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Reset_Proxy( 
    IEnumRegisterWordW * This);


void __RPC_STUB IEnumRegisterWordW_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Skip_Proxy( 
    IEnumRegisterWordW * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumRegisterWordW_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRegisterWordW_INTERFACE_DEFINED__ */


#ifndef __IEnumInputContext_INTERFACE_DEFINED__
#define __IEnumInputContext_INTERFACE_DEFINED__

/* interface IEnumInputContext */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumInputContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("09b5eab0-f997-11d1-93d4-0060b067b86e")
    IEnumInputContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumInputContext **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ HIMC *rgInputContext,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumInputContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumInputContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumInputContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumInputContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumInputContext * This,
            /* [out] */ IEnumInputContext **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumInputContext * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ HIMC *rgInputContext,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumInputContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumInputContext * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumInputContextVtbl;

    interface IEnumInputContext
    {
        CONST_VTBL struct IEnumInputContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumInputContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumInputContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumInputContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumInputContext_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumInputContext_Next(This,ulCount,rgInputContext,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgInputContext,pcFetched)

#define IEnumInputContext_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumInputContext_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumInputContext_Clone_Proxy( 
    IEnumInputContext * This,
    /* [out] */ IEnumInputContext **ppEnum);


void __RPC_STUB IEnumInputContext_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInputContext_Next_Proxy( 
    IEnumInputContext * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ HIMC *rgInputContext,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumInputContext_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInputContext_Reset_Proxy( 
    IEnumInputContext * This);


void __RPC_STUB IEnumInputContext_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInputContext_Skip_Proxy( 
    IEnumInputContext * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumInputContext_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumInputContext_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__
#define __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__

/* interface IActiveIMMMessagePumpOwner */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMMessagePumpOwner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b5cf2cfa-8aeb-11d1-9364-0060b067b86e")
    IActiveIMMMessagePumpOwner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE End( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTranslateMessage( 
            /* [in] */ const MSG *pMsg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( 
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMMessagePumpOwnerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMMessagePumpOwner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMMessagePumpOwner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMMessagePumpOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IActiveIMMMessagePumpOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *End )( 
            IActiveIMMMessagePumpOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnTranslateMessage )( 
            IActiveIMMMessagePumpOwner * This,
            /* [in] */ const MSG *pMsg);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IActiveIMMMessagePumpOwner * This,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IActiveIMMMessagePumpOwner * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IActiveIMMMessagePumpOwnerVtbl;

    interface IActiveIMMMessagePumpOwner
    {
        CONST_VTBL struct IActiveIMMMessagePumpOwnerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMMessagePumpOwner_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMMessagePumpOwner_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMMessagePumpOwner_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMMessagePumpOwner_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IActiveIMMMessagePumpOwner_End(This)	\
    (This)->lpVtbl -> End(This)

#define IActiveIMMMessagePumpOwner_OnTranslateMessage(This,pMsg)	\
    (This)->lpVtbl -> OnTranslateMessage(This,pMsg)

#define IActiveIMMMessagePumpOwner_Pause(This,pdwCookie)	\
    (This)->lpVtbl -> Pause(This,pdwCookie)

#define IActiveIMMMessagePumpOwner_Resume(This,dwCookie)	\
    (This)->lpVtbl -> Resume(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_Start_Proxy( 
    IActiveIMMMessagePumpOwner * This);


void __RPC_STUB IActiveIMMMessagePumpOwner_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_End_Proxy( 
    IActiveIMMMessagePumpOwner * This);


void __RPC_STUB IActiveIMMMessagePumpOwner_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_OnTranslateMessage_Proxy( 
    IActiveIMMMessagePumpOwner * This,
    /* [in] */ const MSG *pMsg);


void __RPC_STUB IActiveIMMMessagePumpOwner_OnTranslateMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_Pause_Proxy( 
    IActiveIMMMessagePumpOwner * This,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB IActiveIMMMessagePumpOwner_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_Resume_Proxy( 
    IActiveIMMMessagePumpOwner * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IActiveIMMMessagePumpOwner_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMApp_INTERFACE_DEFINED__
#define __IActiveIMMApp_INTERFACE_DEFINED__

/* interface IActiveIMMApp */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IActiveIMMApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08c0e040-62d1-11d1-9326-0060b067b86e")
    IActiveIMMApp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AssociateContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC *phPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEA( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEW( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateContext( 
            /* [out] */ HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyContext( 
            /* [in] */ HIMC hIME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pfdwConversion,
            /* [out] */ DWORD *pfdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultIMEWnd( 
            /* [in] */ HWND hWnd,
            /* [out] */ HWND *phDefWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpenStatus( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD *pdwProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA *pStyleBuf,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualKey( 
            /* [in] */ HWND hWnd,
            /* [out] */ UINT *puVirtualKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEA( 
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEW( 
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsIME( 
            /* [in] */ HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageA( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageW( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyIME( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpenStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimulateHotKey( 
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ BOOL fRestoreLayout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDefWindowProc( 
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterClientWindows( 
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [in] */ HKL hKL,
            /* [out] */ UINT *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [in] */ HKL hKL,
            /* [out] */ LANGID *plid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssociateContextEx( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableIME( 
            /* [in] */ DWORD idThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumInputContext( 
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMAppVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMApp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMApp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMApp * This);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContext )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA *pData);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pData);
        
        HRESULT ( STDMETHODCALLTYPE *CreateContext )( 
            IActiveIMMApp * This,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyContext )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pfdwConversion,
            /* [out] */ DWORD *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultIMEWnd )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HWND *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpenStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatusWindowPos )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualKey )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [out] */ UINT *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEA )( 
            IActiveIMMApp * This,
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEW )( 
            IActiveIMMApp * This,
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsIME )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageA )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageW )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyIME )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseContext )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *SetCandidateWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *SetConversionStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpenStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusWindowPos )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *SimulateHotKey )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            IActiveIMMApp * This,
            /* [in] */ BOOL fRestoreLayout);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            IActiveIMMApp * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnDefWindowProc )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *FilterClientWindows )( 
            IActiveIMMApp * This,
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [out] */ UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [out] */ LANGID *plid);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContextEx )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DisableIME )( 
            IActiveIMMApp * This,
            /* [in] */ DWORD idThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *EnumInputContext )( 
            IActiveIMMApp * This,
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext **ppEnum);
        
        END_INTERFACE
    } IActiveIMMAppVtbl;

    interface IActiveIMMApp
    {
        CONST_VTBL struct IActiveIMMAppVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMApp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMApp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMApp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMApp_AssociateContext(This,hWnd,hIME,phPrev)	\
    (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev)

#define IActiveIMMApp_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMApp_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMApp_CreateContext(This,phIMC)	\
    (This)->lpVtbl -> CreateContext(This,phIMC)

#define IActiveIMMApp_DestroyContext(This,hIME)	\
    (This)->lpVtbl -> DestroyContext(This,hIME)

#define IActiveIMMApp_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMApp_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMApp_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMApp_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMApp_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMApp_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMApp_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMApp_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMApp_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate)

#define IActiveIMMApp_GetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf)

#define IActiveIMMApp_GetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf)

#define IActiveIMMApp_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMApp_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMApp_GetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMApp_GetContext(This,hWnd,phIMC)	\
    (This)->lpVtbl -> GetContext(This,hWnd,phIMC)

#define IActiveIMMApp_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMApp_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMApp_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)

#define IActiveIMMApp_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd)

#define IActiveIMMApp_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMApp_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMApp_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMApp_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMApp_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMApp_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMApp_GetOpenStatus(This,hIMC)	\
    (This)->lpVtbl -> GetOpenStatus(This,hIMC)

#define IActiveIMMApp_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty)

#define IActiveIMMApp_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMApp_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMApp_GetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMApp_GetVirtualKey(This,hWnd,puVirtualKey)	\
    (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey)

#define IActiveIMMApp_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMApp_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMApp_IsIME(This,hKL)	\
    (This)->lpVtbl -> IsIME(This,hKL)

#define IActiveIMMApp_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMApp_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMApp_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIMMApp_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMApp_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMApp_ReleaseContext(This,hWnd,hIMC)	\
    (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC)

#define IActiveIMMApp_SetCandidateWindow(This,hIMC,pCandidate)	\
    (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate)

#define IActiveIMMApp_SetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf)

#define IActiveIMMApp_SetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf)

#define IActiveIMMApp_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMApp_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMApp_SetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMApp_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)

#define IActiveIMMApp_SetOpenStatus(This,hIMC,fOpen)	\
    (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen)

#define IActiveIMMApp_SetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMApp_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID)

#define IActiveIMMApp_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMApp_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMApp_Activate(This,fRestoreLayout)	\
    (This)->lpVtbl -> Activate(This,fRestoreLayout)

#define IActiveIMMApp_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define IActiveIMMApp_OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)

#define IActiveIMMApp_FilterClientWindows(This,aaClassList,uSize)	\
    (This)->lpVtbl -> FilterClientWindows(This,aaClassList,uSize)

#define IActiveIMMApp_GetCodePageA(This,hKL,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage)

#define IActiveIMMApp_GetLangId(This,hKL,plid)	\
    (This)->lpVtbl -> GetLangId(This,hKL,plid)

#define IActiveIMMApp_AssociateContextEx(This,hWnd,hIMC,dwFlags)	\
    (This)->lpVtbl -> AssociateContextEx(This,hWnd,hIMC,dwFlags)

#define IActiveIMMApp_DisableIME(This,idThread)	\
    (This)->lpVtbl -> DisableIME(This,idThread)

#define IActiveIMMApp_GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMApp_GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMApp_EnumInputContext(This,idThread,ppEnum)	\
    (This)->lpVtbl -> EnumInputContext(This,idThread,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMApp_AssociateContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIME,
    /* [out] */ HIMC *phPrev);


void __RPC_STUB IActiveIMMApp_AssociateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ConfigureIMEA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDA *pData);


void __RPC_STUB IActiveIMMApp_ConfigureIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ConfigureIMEW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDW *pData);


void __RPC_STUB IActiveIMMApp_ConfigureIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_CreateContext_Proxy( 
    IActiveIMMApp * This,
    /* [out] */ HIMC *phIMC);


void __RPC_STUB IActiveIMMApp_CreateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_DestroyContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIME);


void __RPC_STUB IActiveIMMApp_DestroyContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumRegisterWordA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordA **pEnum);


void __RPC_STUB IActiveIMMApp_EnumRegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumRegisterWordW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordW **pEnum);


void __RPC_STUB IActiveIMMApp_EnumRegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EscapeA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMApp_EscapeA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EscapeW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMApp_EscapeW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST *pCandList,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetCandidateListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST *pCandList,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetCandidateListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListCountA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwListSize,
    /* [out] */ DWORD *pdwBufLen);


void __RPC_STUB IActiveIMMApp_GetCandidateListCountA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListCountW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwListSize,
    /* [out] */ DWORD *pdwBufLen);


void __RPC_STUB IActiveIMMApp_GetCandidateListCountW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateWindow_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [out] */ CANDIDATEFORM *pCandidate);


void __RPC_STUB IActiveIMMApp_GetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionFontA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTA *plf);


void __RPC_STUB IActiveIMMApp_GetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionFontW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTW *plf);


void __RPC_STUB IActiveIMMApp_GetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionStringA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMApp_GetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionStringW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMApp_GetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionWindow_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ COMPOSITIONFORM *pCompForm);


void __RPC_STUB IActiveIMMApp_GetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HIMC *phIMC);


void __RPC_STUB IActiveIMMApp_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionListA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST *pDst,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetConversionListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionListW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPWSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST *pDst,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetConversionListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionStatus_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pfdwConversion,
    /* [out] */ DWORD *pfdwSentence);


void __RPC_STUB IActiveIMMApp_GetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDefaultIMEWnd_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HWND *phDefWnd);


void __RPC_STUB IActiveIMMApp_GetDefaultIMEWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDescriptionA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szDescription,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetDescriptionA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDescriptionW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szDescription,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetDescriptionW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetGuideLineA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPSTR pBuf,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMApp_GetGuideLineA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetGuideLineW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPWSTR pBuf,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMApp_GetGuideLineW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetIMEFileNameA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szFileName,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetIMEFileNameA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetIMEFileNameW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szFileName,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetIMEFileNameW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetOpenStatus_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMApp_GetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetProperty_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ DWORD fdwIndex,
    /* [out] */ DWORD *pdwProperty);


void __RPC_STUB IActiveIMMApp_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetRegisterWordStyleA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFA *pStyleBuf,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetRegisterWordStyleA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetRegisterWordStyleW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFW *pStyleBuf,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetRegisterWordStyleW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetStatusWindowPos_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ POINT *pptPos);


void __RPC_STUB IActiveIMMApp_GetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetVirtualKey_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [out] */ UINT *puVirtualKey);


void __RPC_STUB IActiveIMMApp_GetVirtualKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_InstallIMEA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ LPSTR szIMEFileName,
    /* [in] */ LPSTR szLayoutText,
    /* [out] */ HKL *phKL);


void __RPC_STUB IActiveIMMApp_InstallIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_InstallIMEW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ LPWSTR szIMEFileName,
    /* [in] */ LPWSTR szLayoutText,
    /* [out] */ HKL *phKL);


void __RPC_STUB IActiveIMMApp_InstallIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsIME_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL);


void __RPC_STUB IActiveIMMApp_IsIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsUIMessageA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMApp_IsUIMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsUIMessageW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMApp_IsUIMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_NotifyIME_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwAction,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IActiveIMMApp_NotifyIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_RegisterWordA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister);


void __RPC_STUB IActiveIMMApp_RegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_RegisterWordW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister);


void __RPC_STUB IActiveIMMApp_RegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ReleaseContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMApp_ReleaseContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCandidateWindow_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ CANDIDATEFORM *pCandidate);


void __RPC_STUB IActiveIMMApp_SetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionFontA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTA *plf);


void __RPC_STUB IActiveIMMApp_SetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionFontW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTW *plf);


void __RPC_STUB IActiveIMMApp_SetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionStringA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMApp_SetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionStringW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMApp_SetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionWindow_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ COMPOSITIONFORM *pCompForm);


void __RPC_STUB IActiveIMMApp_SetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetConversionStatus_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD fdwConversion,
    /* [in] */ DWORD fdwSentence);


void __RPC_STUB IActiveIMMApp_SetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetOpenStatus_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fOpen);


void __RPC_STUB IActiveIMMApp_SetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetStatusWindowPos_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ POINT *pptPos);


void __RPC_STUB IActiveIMMApp_SetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SimulateHotKey_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwHotKeyID);


void __RPC_STUB IActiveIMMApp_SimulateHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_UnregisterWordA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szUnregister);


void __RPC_STUB IActiveIMMApp_UnregisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_UnregisterWordW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szUnregister);


void __RPC_STUB IActiveIMMApp_UnregisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_Activate_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ BOOL fRestoreLayout);


void __RPC_STUB IActiveIMMApp_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_Deactivate_Proxy( 
    IActiveIMMApp * This);


void __RPC_STUB IActiveIMMApp_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_OnDefWindowProc_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ UINT Msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMApp_OnDefWindowProc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_FilterClientWindows_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ ATOM *aaClassList,
    /* [in] */ UINT uSize);


void __RPC_STUB IActiveIMMApp_FilterClientWindows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCodePageA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [out] */ UINT *uCodePage);


void __RPC_STUB IActiveIMMApp_GetCodePageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetLangId_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [out] */ LANGID *plid);


void __RPC_STUB IActiveIMMApp_GetLangId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_AssociateContextEx_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IActiveIMMApp_AssociateContextEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_DisableIME_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ DWORD idThread);


void __RPC_STUB IActiveIMMApp_DisableIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetImeMenuItemsA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwType,
    /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
    /* [out] */ IMEMENUITEMINFOA *pImeMenu,
    /* [in] */ DWORD dwSize,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMApp_GetImeMenuItemsA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetImeMenuItemsW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwType,
    /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
    /* [out] */ IMEMENUITEMINFOW *pImeMenu,
    /* [in] */ DWORD dwSize,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMApp_GetImeMenuItemsW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumInputContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ DWORD idThread,
    /* [out] */ IEnumInputContext **ppEnum);


void __RPC_STUB IActiveIMMApp_EnumInputContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMApp_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\aimmex.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for aimmex.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __aimmex_h__
#define __aimmex_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IActiveIMMAppEx_FWD_DEFINED__
#define __IActiveIMMAppEx_FWD_DEFINED__
typedef interface IActiveIMMAppEx IActiveIMMAppEx;
#endif 	/* __IActiveIMMAppEx_FWD_DEFINED__ */


#ifndef __IAImmFnDocFeed_FWD_DEFINED__
#define __IAImmFnDocFeed_FWD_DEFINED__
typedef interface IAImmFnDocFeed IAImmFnDocFeed;
#endif 	/* __IAImmFnDocFeed_FWD_DEFINED__ */


#ifndef __IAImmThreadCompartment_FWD_DEFINED__
#define __IAImmThreadCompartment_FWD_DEFINED__
typedef interface IAImmThreadCompartment IAImmThreadCompartment;
#endif 	/* __IAImmThreadCompartment_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"
#include "aimm12.h"
#include "msctf.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_aimmex_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// aimmex.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// IActiveIMMEx Interfaces.



extern RPC_IF_HANDLE __MIDL_itf_aimmex_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_aimmex_0000_v0_0_s_ifspec;

#ifndef __IActiveIMMAppEx_INTERFACE_DEFINED__
#define __IActiveIMMAppEx_INTERFACE_DEFINED__

/* interface IActiveIMMAppEx */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IActiveIMMAppEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D7A6F58A-D478-44ab-86C9-591C23A26534")
    IActiveIMMAppEx : public IActiveIMMApp
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FilterClientWindowsEx( 
            /* [in] */ HWND hWnd,
            /* [in] */ BOOL fGuidMap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterClientWindowsGUIDMap( 
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize,
            /* [in] */ BOOL *aaGildMap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuidAtom( 
            /* [in] */ HIMC hImc,
            /* [in] */ BYTE bAttr,
            /* [out] */ TfGuidAtom *pGuidAtom) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnfilterClientWindowsEx( 
            /* [in] */ HWND hWnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMAppExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMAppEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMAppEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMAppEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContext )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA *pData);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pData);
        
        HRESULT ( STDMETHODCALLTYPE *CreateContext )( 
            IActiveIMMAppEx * This,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyContext )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateWindow )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionWindow )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionStatus )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pfdwConversion,
            /* [out] */ DWORD *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultIMEWnd )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HWND *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpenStatus )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatusWindowPos )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualKey )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [out] */ UINT *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEA )( 
            IActiveIMMAppEx * This,
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEW )( 
            IActiveIMMAppEx * This,
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsIME )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyIME )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseContext )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *SetCandidateWindow )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionWindow )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *SetConversionStatus )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpenStatus )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusWindowPos )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *SimulateHotKey )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            IActiveIMMAppEx * This,
            /* [in] */ BOOL fRestoreLayout);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            IActiveIMMAppEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnDefWindowProc )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *FilterClientWindows )( 
            IActiveIMMAppEx * This,
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [out] */ UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [out] */ LANGID *plid);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContextEx )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DisableIME )( 
            IActiveIMMAppEx * This,
            /* [in] */ DWORD idThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *EnumInputContext )( 
            IActiveIMMAppEx * This,
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FilterClientWindowsEx )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ BOOL fGuidMap);
        
        HRESULT ( STDMETHODCALLTYPE *FilterClientWindowsGUIDMap )( 
            IActiveIMMAppEx * This,
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize,
            /* [in] */ BOOL *aaGildMap);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuidAtom )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hImc,
            /* [in] */ BYTE bAttr,
            /* [out] */ TfGuidAtom *pGuidAtom);
        
        HRESULT ( STDMETHODCALLTYPE *UnfilterClientWindowsEx )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd);
        
        END_INTERFACE
    } IActiveIMMAppExVtbl;

    interface IActiveIMMAppEx
    {
        CONST_VTBL struct IActiveIMMAppExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMAppEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMAppEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMAppEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMAppEx_AssociateContext(This,hWnd,hIME,phPrev)	\
    (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev)

#define IActiveIMMAppEx_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMAppEx_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMAppEx_CreateContext(This,phIMC)	\
    (This)->lpVtbl -> CreateContext(This,phIMC)

#define IActiveIMMAppEx_DestroyContext(This,hIME)	\
    (This)->lpVtbl -> DestroyContext(This,hIME)

#define IActiveIMMAppEx_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMAppEx_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMAppEx_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMAppEx_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMAppEx_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMAppEx_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMAppEx_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMAppEx_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMAppEx_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate)

#define IActiveIMMAppEx_GetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf)

#define IActiveIMMAppEx_GetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf)

#define IActiveIMMAppEx_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMAppEx_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMAppEx_GetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMAppEx_GetContext(This,hWnd,phIMC)	\
    (This)->lpVtbl -> GetContext(This,hWnd,phIMC)

#define IActiveIMMAppEx_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMAppEx_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMAppEx_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)

#define IActiveIMMAppEx_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd)

#define IActiveIMMAppEx_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMAppEx_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMAppEx_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMAppEx_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMAppEx_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMAppEx_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMAppEx_GetOpenStatus(This,hIMC)	\
    (This)->lpVtbl -> GetOpenStatus(This,hIMC)

#define IActiveIMMAppEx_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty)

#define IActiveIMMAppEx_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMAppEx_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMAppEx_GetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMAppEx_GetVirtualKey(This,hWnd,puVirtualKey)	\
    (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey)

#define IActiveIMMAppEx_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMAppEx_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMAppEx_IsIME(This,hKL)	\
    (This)->lpVtbl -> IsIME(This,hKL)

#define IActiveIMMAppEx_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMAppEx_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMAppEx_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIMMAppEx_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMAppEx_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMAppEx_ReleaseContext(This,hWnd,hIMC)	\
    (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC)

#define IActiveIMMAppEx_SetCandidateWindow(This,hIMC,pCandidate)	\
    (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate)

#define IActiveIMMAppEx_SetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf)

#define IActiveIMMAppEx_SetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf)

#define IActiveIMMAppEx_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMAppEx_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMAppEx_SetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMAppEx_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)

#define IActiveIMMAppEx_SetOpenStatus(This,hIMC,fOpen)	\
    (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen)

#define IActiveIMMAppEx_SetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMAppEx_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID)

#define IActiveIMMAppEx_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMAppEx_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMAppEx_Activate(This,fRestoreLayout)	\
    (This)->lpVtbl -> Activate(This,fRestoreLayout)

#define IActiveIMMAppEx_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define IActiveIMMAppEx_OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)

#define IActiveIMMAppEx_FilterClientWindows(This,aaClassList,uSize)	\
    (This)->lpVtbl -> FilterClientWindows(This,aaClassList,uSize)

#define IActiveIMMAppEx_GetCodePageA(This,hKL,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage)

#define IActiveIMMAppEx_GetLangId(This,hKL,plid)	\
    (This)->lpVtbl -> GetLangId(This,hKL,plid)

#define IActiveIMMAppEx_AssociateContextEx(This,hWnd,hIMC,dwFlags)	\
    (This)->lpVtbl -> AssociateContextEx(This,hWnd,hIMC,dwFlags)

#define IActiveIMMAppEx_DisableIME(This,idThread)	\
    (This)->lpVtbl -> DisableIME(This,idThread)

#define IActiveIMMAppEx_GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMAppEx_GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMAppEx_EnumInputContext(This,idThread,ppEnum)	\
    (This)->lpVtbl -> EnumInputContext(This,idThread,ppEnum)


#define IActiveIMMAppEx_FilterClientWindowsEx(This,hWnd,fGuidMap)	\
    (This)->lpVtbl -> FilterClientWindowsEx(This,hWnd,fGuidMap)

#define IActiveIMMAppEx_FilterClientWindowsGUIDMap(This,aaClassList,uSize,aaGildMap)	\
    (This)->lpVtbl -> FilterClientWindowsGUIDMap(This,aaClassList,uSize,aaGildMap)

#define IActiveIMMAppEx_GetGuidAtom(This,hImc,bAttr,pGuidAtom)	\
    (This)->lpVtbl -> GetGuidAtom(This,hImc,bAttr,pGuidAtom)

#define IActiveIMMAppEx_UnfilterClientWindowsEx(This,hWnd)	\
    (This)->lpVtbl -> UnfilterClientWindowsEx(This,hWnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMAppEx_FilterClientWindowsEx_Proxy( 
    IActiveIMMAppEx * This,
    /* [in] */ HWND hWnd,
    /* [in] */ BOOL fGuidMap);


void __RPC_STUB IActiveIMMAppEx_FilterClientWindowsEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMAppEx_FilterClientWindowsGUIDMap_Proxy( 
    IActiveIMMAppEx * This,
    /* [in] */ ATOM *aaClassList,
    /* [in] */ UINT uSize,
    /* [in] */ BOOL *aaGildMap);


void __RPC_STUB IActiveIMMAppEx_FilterClientWindowsGUIDMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMAppEx_GetGuidAtom_Proxy( 
    IActiveIMMAppEx * This,
    /* [in] */ HIMC hImc,
    /* [in] */ BYTE bAttr,
    /* [out] */ TfGuidAtom *pGuidAtom);


void __RPC_STUB IActiveIMMAppEx_GetGuidAtom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMAppEx_UnfilterClientWindowsEx_Proxy( 
    IActiveIMMAppEx * This,
    /* [in] */ HWND hWnd);


void __RPC_STUB IActiveIMMAppEx_UnfilterClientWindowsEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMAppEx_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_aimmex_0228 */
/* [local] */ 

EXTERN_C const CLSID CLSID_CAImmLayer;


extern RPC_IF_HANDLE __MIDL_itf_aimmex_0228_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_aimmex_0228_v0_0_s_ifspec;

#ifndef __IAImmFnDocFeed_INTERFACE_DEFINED__
#define __IAImmFnDocFeed_INTERFACE_DEFINED__

/* interface IAImmFnDocFeed */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAImmFnDocFeed;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6e098993-9577-499a-a830-52344f3e200d")
    IAImmFnDocFeed : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DocFeed( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearDocFeedBuffer( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartReconvert( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartUndoCompositionString( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAImmFnDocFeedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAImmFnDocFeed * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAImmFnDocFeed * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAImmFnDocFeed * This);
        
        HRESULT ( STDMETHODCALLTYPE *DocFeed )( 
            IAImmFnDocFeed * This);
        
        HRESULT ( STDMETHODCALLTYPE *ClearDocFeedBuffer )( 
            IAImmFnDocFeed * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartReconvert )( 
            IAImmFnDocFeed * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartUndoCompositionString )( 
            IAImmFnDocFeed * This);
        
        END_INTERFACE
    } IAImmFnDocFeedVtbl;

    interface IAImmFnDocFeed
    {
        CONST_VTBL struct IAImmFnDocFeedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAImmFnDocFeed_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAImmFnDocFeed_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAImmFnDocFeed_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAImmFnDocFeed_DocFeed(This)	\
    (This)->lpVtbl -> DocFeed(This)

#define IAImmFnDocFeed_ClearDocFeedBuffer(This)	\
    (This)->lpVtbl -> ClearDocFeedBuffer(This)

#define IAImmFnDocFeed_StartReconvert(This)	\
    (This)->lpVtbl -> StartReconvert(This)

#define IAImmFnDocFeed_StartUndoCompositionString(This)	\
    (This)->lpVtbl -> StartUndoCompositionString(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAImmFnDocFeed_DocFeed_Proxy( 
    IAImmFnDocFeed * This);


void __RPC_STUB IAImmFnDocFeed_DocFeed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAImmFnDocFeed_ClearDocFeedBuffer_Proxy( 
    IAImmFnDocFeed * This);


void __RPC_STUB IAImmFnDocFeed_ClearDocFeedBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAImmFnDocFeed_StartReconvert_Proxy( 
    IAImmFnDocFeed * This);


void __RPC_STUB IAImmFnDocFeed_StartReconvert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAImmFnDocFeed_StartUndoCompositionString_Proxy( 
    IAImmFnDocFeed * This);


void __RPC_STUB IAImmFnDocFeed_StartUndoCompositionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAImmFnDocFeed_INTERFACE_DEFINED__ */


#ifndef __IAImmThreadCompartment_INTERFACE_DEFINED__
#define __IAImmThreadCompartment_INTERFACE_DEFINED__

/* interface IAImmThreadCompartment */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAImmThreadCompartment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d251a968-2b44-4da5-a549-c1249ef01711")
    IAImmThreadCompartment : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetThreadCompartmentValue( 
            /* [in] */ REFGUID rguid,
            /* [in] */ VARIANT *pvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadCompartmentValue( 
            /* [in] */ REFGUID rguid,
            /* [out] */ VARIANT *pvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAImmThreadCompartmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAImmThreadCompartment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAImmThreadCompartment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAImmThreadCompartment * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadCompartmentValue )( 
            IAImmThreadCompartment * This,
            /* [in] */ REFGUID rguid,
            /* [in] */ VARIANT *pvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadCompartmentValue )( 
            IAImmThreadCompartment * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ VARIANT *pvar);
        
        END_INTERFACE
    } IAImmThreadCompartmentVtbl;

    interface IAImmThreadCompartment
    {
        CONST_VTBL struct IAImmThreadCompartmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAImmThreadCompartment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAImmThreadCompartment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAImmThreadCompartment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAImmThreadCompartment_SetThreadCompartmentValue(This,rguid,pvar)	\
    (This)->lpVtbl -> SetThreadCompartmentValue(This,rguid,pvar)

#define IAImmThreadCompartment_GetThreadCompartmentValue(This,rguid,pvar)	\
    (This)->lpVtbl -> GetThreadCompartmentValue(This,rguid,pvar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAImmThreadCompartment_SetThreadCompartmentValue_Proxy( 
    IAImmThreadCompartment * This,
    /* [in] */ REFGUID rguid,
    /* [in] */ VARIANT *pvar);


void __RPC_STUB IAImmThreadCompartment_SetThreadCompartmentValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAImmThreadCompartment_GetThreadCompartmentValue_Proxy( 
    IAImmThreadCompartment * This,
    /* [in] */ REFGUID rguid,
    /* [out] */ VARIANT *pvar);


void __RPC_STUB IAImmThreadCompartment_GetThreadCompartmentValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAImmThreadCompartment_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\cicsthkl.h ===
//
// cicsthkl.h
//
// Cicero Library to retreive the substitute keyboard layout of the 
// current active keyboard TIP.
//

//
// CicSubstGetKeyboardLayout
//
// If the current focus is on Cicero aware (including AIMM1.2
// or CUAS), This function returns the substitute HKL of
// the current active keyboard TIP. And the keyboard layout
// name of the hKL that is returned in pszKLID.
// If the current focus is not on Cicero aware, it just returns
// the current keyboard layout and keyboard layout name in 
// pszKLID.
// pszKLID can be NULL.
//
extern "C" HKL WINAPI CicSubstGetKeyboardLayout(char *pszKLID);

//
// CicSubstGetDefaultKeyboardLayout
//
// This function returns the substitute hKL of the default item
// of the given langage.
//
extern "C" HKL WINAPI CicSubstGetDefaultKeyboardLayout(LANGID langid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\conapi.h ===
#ifndef NOGDI

typedef struct _CONSOLE_GRAPHICS_BUFFER_INFO {
    DWORD dwBitMapInfoLength;
    LPBITMAPINFO lpBitMapInfo;
    DWORD dwUsage;
    HANDLE hMutex;
    PVOID lpBitMap;
} CONSOLE_GRAPHICS_BUFFER_INFO, *PCONSOLE_GRAPHICS_BUFFER_INFO;

#endif // NOGDI

#define CONSOLE_GRAPHICS_BUFFER  2

BOOL
WINAPI
InvalidateConsoleDIBits(
    IN HANDLE hConsoleOutput,
    IN PSMALL_RECT lpRect
    );

#define SYSTEM_ROOT_CONSOLE_EVENT 3

VOID
WINAPI
SetLastConsoleEventActive( VOID );

#define VDM_HIDE_WINDOW         1
#define VDM_IS_ICONIC           2
#define VDM_CLIENT_RECT         3
#define VDM_CLIENT_TO_SCREEN    4
#define VDM_SCREEN_TO_CLIENT    5
#define VDM_IS_HIDDEN           6
#define VDM_FULLSCREEN_NOPAINT  7
#if defined(FE_SB)
#define VDM_SET_VIDEO_MODE      8
#endif /* FE_SB */

BOOL
WINAPI
VDMConsoleOperation(
    IN DWORD iFunction,
    IN OUT LPVOID lpData
    );


BOOL
WINAPI
SetConsoleIcon(
    IN HICON hIcon
    );

//
// These console font APIs don't appear to be used anywhere. Maybe they
// should be removed.
//

BOOL
WINAPI
SetConsoleFont(
    IN HANDLE hConsoleOutput,
    IN DWORD nFont
    );

DWORD
WINAPI
GetConsoleFontInfo(
    IN HANDLE hConsoleOutput,
    IN BOOL bMaximumWindow,
    IN DWORD nLength,
    OUT PCONSOLE_FONT_INFO lpConsoleFontInfo
    );

DWORD
WINAPI
GetNumberOfConsoleFonts(
    VOID
    );

BOOL
WINAPI
SetConsoleCursor(
    IN HANDLE hConsoleOutput,
    IN HCURSOR hCursor
    );

int
WINAPI
ShowConsoleCursor(
    IN HANDLE hConsoleOutput,
    IN BOOL bShow
    );

HMENU
APIENTRY
ConsoleMenuControl(
    IN HANDLE hConsoleOutput,
    IN UINT dwCommandIdLow,
    IN UINT dwCommandIdHigh
    );

BOOL
SetConsolePalette(
    IN HANDLE hConsoleOutput,
    IN HPALETTE hPalette,
    IN UINT dwUsage
    );

#define CONSOLE_FULLSCREEN_MODE 1
#define CONSOLE_WINDOWED_MODE 2

BOOL
APIENTRY
SetConsoleDisplayMode(
    IN HANDLE hConsoleOutput,
    IN DWORD dwFlags,
    OUT PCOORD lpNewScreenBufferDimensions
    );

#define CONSOLE_UNREGISTER_VDM 0
#define CONSOLE_REGISTER_VDM   1
#define CONSOLE_REGISTER_WOW   2

BOOL
APIENTRY
RegisterConsoleVDM(
    IN DWORD dwRegisterFlags,
    IN HANDLE hStartHardwareEvent,
    IN HANDLE hEndHardwareEvent,
    IN HANDLE hErrorhardwareEvent,
    IN DWORD Reserved,
    OUT LPDWORD lpStateLength,
    OUT PVOID *lpState,
    IN LPWSTR lpVDMBufferSectionName,
    IN DWORD dwVDMBufferSectionNameLength,
    IN COORD VDMBufferSize OPTIONAL,
    OUT PVOID *lpVDMBuffer
    );

BOOL
APIENTRY
GetConsoleHardwareState(
    IN HANDLE hConsoleOutput,
    OUT PCOORD lpResolution,
    OUT PCOORD lpFontSize
    );

BOOL
APIENTRY
SetConsoleHardwareState(
    IN HANDLE hConsoleOutput,
    IN COORD dwResolution,
    IN COORD dwFontSize
    );


VOID
ExpungeConsoleCommandHistoryA(
    IN LPSTR ExeName);
VOID
ExpungeConsoleCommandHistoryW(
    IN LPWSTR ExeName);
#ifdef UNICODE
#define ExpungeConsoleCommandHistory  ExpungeConsoleCommandHistoryW
#else
#define ExpungeConsoleCommandHistory  ExpungeConsoleCommandHistoryA
#endif // !UNICODE

BOOL
SetConsoleNumberOfCommandsA(
    IN DWORD Number,
    IN LPSTR ExeName);
BOOL
SetConsoleNumberOfCommandsW(
    IN DWORD Number,
    IN LPWSTR ExeName);
#ifdef UNICODE
#define SetConsoleNumberOfCommands  SetConsoleNumberOfCommandsW
#else
#define SetConsoleNumberOfCommands  SetConsoleNumberOfCommandsA
#endif // !UNICODE

DWORD
GetConsoleCommandHistoryLengthA(
    IN LPSTR ExeName);
DWORD
GetConsoleCommandHistoryLengthW(
    IN LPWSTR ExeName);
#ifdef UNICODE
#define GetConsoleCommandHistoryLength  GetConsoleCommandHistoryLengthW
#else
#define GetConsoleCommandHistoryLength  GetConsoleCommandHistoryLengthA
#endif // !UNICODE

DWORD
GetConsoleCommandHistoryA(
    OUT LPSTR Commands,
    IN DWORD CommandBufferLength,
    IN LPSTR ExeName);
DWORD
GetConsoleCommandHistoryW(
    OUT LPWSTR Commands,
    IN DWORD CommandBufferLength,
    IN LPWSTR ExeName);
#ifdef UNICODE
#define GetConsoleCommandHistory  GetConsoleCommandHistoryW
#else
#define GetConsoleCommandHistory  GetConsoleCommandHistoryA
#endif // !UNICODE

#define CONSOLE_OVERSTRIKE 1

BOOL
APIENTRY
SetConsoleCommandHistoryMode(
    IN DWORD Flags
    );

#define CONSOLE_NOSHORTCUTKEY   0               /* no shortcut key  */
#define CONSOLE_ALTTAB          1               /* Alt + Tab        */
#define CONSOLE_ALTESC          (1 << 1)        /* Alt + Escape     */
#define CONSOLE_ALTSPACE        (1 << 2)        /* Alt + Space      */
#define CONSOLE_ALTENTER        (1 << 3)        /* Alt + Enter      */
#define CONSOLE_ALTPRTSC        (1 << 4)        /* Alt Print screen */
#define CONSOLE_PRTSC           (1 << 5)        /* Print screen     */
#define CONSOLE_CTRLESC         (1 << 6)        /* Ctrl + Escape    */

typedef struct _APPKEY {
    WORD Modifier;
    WORD ScanCode;
} APPKEY, *LPAPPKEY;

#define CONSOLE_MODIFIER_SHIFT      0x0003   // Left shift key
#define CONSOLE_MODIFIER_CONTROL    0x0004   // Either Control shift key
#define CONSOLE_MODIFIER_ALT        0x0008   // Either Alt shift key

BOOL
APIENTRY
SetConsoleKeyShortcuts(
    IN BOOL bSet,
    IN BYTE bReserveKeys,
    IN LPAPPKEY lpAppKeys,
    IN DWORD dwNumAppKeys
    );

BOOL
APIENTRY
SetConsoleMenuClose(
    IN BOOL bEnable
    );

DWORD
GetConsoleInputExeNameA(
    IN DWORD nBufferLength,
    OUT LPSTR lpBuffer
    );
DWORD
GetConsoleInputExeNameW(
    IN DWORD nBufferLength,
    OUT LPWSTR lpBuffer
    );
#ifdef UNICODE
#define GetConsoleInputExeName  GetConsoleInputExeNameW
#else
#define GetConsoleInputExeName  GetConsoleInputExeNameA
#endif // !UNICODE

BOOL
SetConsoleInputExeNameA(
    IN LPSTR lpExeName
    );
BOOL
SetConsoleInputExeNameW(
    IN LPWSTR lpExeName
    );
#ifdef UNICODE
#define SetConsoleInputExeName  SetConsoleInputExeNameW
#else
#define SetConsoleInputExeName  SetConsoleInputExeNameA
#endif // !UNICODE

typedef struct _CONSOLE_READCONSOLE_CONTROL {
    IN ULONG nLength;           // sizeof( CONSOLE_READCONSOLE_CONTROL )
    IN ULONG nInitialChars;
    IN ULONG dwCtrlWakeupMask;
    OUT ULONG dwControlKeyState;
} CONSOLE_READCONSOLE_CONTROL, *PCONSOLE_READCONSOLE_CONTROL;


#define CONSOLE_ADD_SUBST 1
#define CONSOLE_REMOVE_SUBST 2
#define CONSOLE_QUERY_SUBST 3

BOOL
ConsoleSubst(
    IN DWORD dwDriveNumber,
    IN DWORD dwFlag,
    IN OUT LPWSTR lpPhysicalDriveBuffer,
    IN DWORD dwPhysicalDriveBufferLength
    );

#define CONSOLE_READ_NOREMOVE   0x0001
#define CONSOLE_READ_NOWAIT     0x0002

#define CONSOLE_READ_VALID      (CONSOLE_READ_NOREMOVE | CONSOLE_READ_NOWAIT)

BOOL
WINAPI
ReadConsoleInputExA(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead,
    USHORT wFlags
    );
BOOL
WINAPI
ReadConsoleInputExW(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead,
    USHORT wFlags
    );
#ifdef UNICODE
#define ReadConsoleInputEx  ReadConsoleInputExW
#else
#define ReadConsoleInputEx  ReadConsoleInputExA
#endif // !UNICODE

BOOL
WINAPI
WriteConsoleInputVDMA(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsWritten
    );
BOOL
WINAPI
WriteConsoleInputVDMW(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsWritten
    );
#ifdef UNICODE
#define WriteConsoleInputVDM  WriteConsoleInputVDMW
#else
#define WriteConsoleInputVDM  WriteConsoleInputVDMA
#endif // !UNICODE


#if defined(FE_SB)
BOOL
APIENTRY
GetConsoleNlsMode(
    IN HANDLE hConsole,
    OUT PDWORD lpdwNlsMode
    );

BOOL
APIENTRY
SetConsoleNlsMode(
    IN HANDLE hConsole,
    IN DWORD fdwNlsMode
    );

BOOL
APIENTRY
GetConsoleCharType(
    IN HANDLE hConsole,
    IN COORD coordCheck,
    OUT PDWORD pdwType
    );

#define CHAR_TYPE_SBCS     0   // Displayed SBCS character
#define CHAR_TYPE_LEADING  2   // Displayed leading byte of DBCS
#define CHAR_TYPE_TRAILING 3   // Displayed trailing byte of DBCS

BOOL
APIENTRY
SetConsoleLocalEUDC(
    IN HANDLE hConsoleHandle,
    IN WORD   wCodePoint,
    IN COORD  cFontSize,
    IN PCHAR  lpSB
    );

BOOL
APIENTRY
SetConsoleCursorMode(
    IN HANDLE hConsoleHandle,
    IN BOOL   Blink,
    IN BOOL   DBEnable
    );

BOOL
APIENTRY
GetConsoleCursorMode(
    IN HANDLE hConsoleHandle,
    OUT PBOOL  pbBlink,
    OUT PBOOL  pbDBEnable
    );

BOOL
APIENTRY
RegisterConsoleOS2(
    IN BOOL fOs2Register
    );

BOOL
APIENTRY
SetConsoleOS2OemFormat(
    IN BOOL fOs2OemFormat
    );

BOOL
IsConsoleFullWidth(
    IN HDC hDC,
    IN DWORD CodePage,
    IN WCHAR wch
    );

#if defined(FE_IME)
BOOL
APIENTRY
RegisterConsoleIME(
    IN HWND  hWndConsoleIME,
    OUT DWORD *dwConsoleThreadId
    );

BOOL
APIENTRY
UnregisterConsoleIME(
    );
#endif // FE_IME
#endif // FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\avrfutil.h ===
/*++

    Copyright (c) 2001  Microsoft Corporation

    Module Name:

        avrfutil.h

    Abstract:

        Common headers for app verifier utility functions - used by the exe as well as the shims

    Revision History:

    08/26/2001  dmunsil     Created.


--*/

#pragma once

#ifndef _AVRFUTIL_H_
#define _AVRFUTIL_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntldr.h>

#include <windows.h>
#include <prsht.h>
#include "shimdb.h"

namespace ShimLib
{
//
// Registry key path where we store our settings.
// See shimdb.w for define of APPCOMPAT_KEY_PATH_MACHINE.
//
#define AV_KEY APPCOMPAT_KEY_PATH_MACHINE   L"\\AppVerifier"

//
// Used to indicate whether we should call DbgBreakPoint
// when VLOG gets called.
//
#define AV_BREAKIN                          L"BreakOnLog"
    
//
// Used to indicate if we're running in internal mode
// or not. This value is stored under the AV_KEY
// defined above. This affects the tests that are displayed
// in the UI and how we filter the log files.
//
#define AV_INTERNALMODE                     L"InternalMode"

BOOL SaveShimSettingDWORD(
    LPCWSTR     szShim,
    LPCWSTR     szExe,
    LPCWSTR     szSetting,
    DWORD       dwSetting
    );

DWORD GetShimSettingDWORD(
    LPCWSTR     szShim,
    LPCWSTR     szExe,
    LPCWSTR     szSetting,
    DWORD       dwDefault
    );

BOOL SaveShimSettingString(
    LPCWSTR     szShim,
    LPCWSTR     szExe,
    LPCWSTR     szSetting,
    LPCWSTR     szValue
    );

BOOL GetShimSettingString(
    LPCWSTR     szShim,
    LPCWSTR     szExe,
    LPCWSTR     szSetting,
    LPWSTR      szResult,
    DWORD       dwBufferLen     // in WCHARs
    );

DWORD GetAppVerifierLogPath(
    LPWSTR pwszBuffer,
    DWORD  cchBufferSize
    );

BOOL
IsInternalModeEnabled(
    void
    );

BOOL
EnableDisableInternalMode(
    DWORD dwSetting
    );


//
// Handy macro-like name extraction utility for property sheets
// NOTE: only works during WM_INITDIALOG!!!
//
inline LPCWSTR ExeNameFromLParam(LPARAM lParam)
{
    if (lParam) {
        LPCWSTR szRet = (LPCWSTR)(((LPPROPSHEETPAGE)lParam)->lParam);
        if (szRet) {
            return szRet;
        }
    }

    return AVRF_DEFAULT_SETTINGS_NAME_W;
}

//
// useful utility function for getting the current exe name during shim
// startup (so it extracts the correct settings)
//
inline LPWSTR GetCurrentExeName(LPWSTR szName, DWORD dwChars)
{
    HMODULE hMod = GetModuleHandle(NULL);
    if (!hMod) {
        return NULL;
    }

    WCHAR  szModule[MAX_PATH];

    DWORD dwC = GetModuleFileNameW(hMod, szModule, MAX_PATH);

    if (!dwC) {
        return NULL;
    }

    int nLen = (int)wcslen(szModule);
    for (int i = nLen - 1; i != -1; --i) {
        if (szModule[i] == L'\\') {
            break;
        }
    }
    ++i;
    wcsncpy(szName, &szModule[i], dwChars);
    szName[dwChars - 1] = 0;

    return szName;
}

}; // end of namespace ShimLib

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\gdispool.h ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation


Module Name:

    gdispool.h


Abstract:

    This module contains private gdi spool definition to the Drvxxxx calls


Author:

    04-Jun-1996 Tue 10:50:56 updated -by-  Daniel Chou (danielc)


[Environment:]

    spooler


[Notes:]


Revision History:

    Move most stuff to the winddiui.h in the public\oak\inc directory, this
    file only used by the gdi printer device drivers


--*/

#ifndef _GDISPOOL_
#define _GDISPOOL_

#include <winddiui.h>


#if DBG
#ifdef DEF_DRV_DOCUMENT_EVENT_DBG_STR
TCHAR *szDrvDocumentEventDbgStrings[] =
{
    L"UNKNOWN ESCAPE",
    L"CREATEDCPRE",
    L"CREATEDCPOST",
    L"RESETDCPRE",
    L"RESETDCPOST",
    L"STARTDOC",
    L"STARTPAGE",
    L"ENDPAGE",
    L"ENDDOC",
    L"ABORTDOC",
    L"DELETEDC",
    L"ESCAPE",
    L"ENDDOCPOST",
    L"STARTDOCPOST"
};
#endif
#endif // #define(DEBUG)


typedef int (WINAPI * PFNDOCUMENTEVENT)(
    HANDLE  hPrinter,
    HDC     hdc,
    int     iEsc,
    ULONG   cbIn,
    PVOID   pbIn,
    ULONG   cbOut,
    PVOID   pbOut
);


#endif  // _GDISPOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\ddmc.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddmc.h
 *  Content:	DirectDrawMotionComp include file
 *
 ***************************************************************************/

#ifndef __DDVA_INCLUDED__
#define __DDVA_INCLUDED__
#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#undef  CO_E_NOTINITIALIZED
#define CO_E_NOTINITIALIZED 0x800401F0L
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by DirectDrawVideoAccelerator objects
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
DEFINE_GUID( IID_IDDVideoAcceleratorContainer,	0xACA12120,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
DEFINE_GUID( IID_IDirectDrawVideoAccelerator,   0xC9B2D740,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDDVideoAcceleratorContainer		FAR *LPDDVIDEOACCELERATORCONTAINER;
typedef struct IDirectDrawVideoAccelerator		FAR *LPDIRECTDRAWVIDEOACCELERATOR;

typedef struct IDDVideoAcceleratorContainerVtbl DDVIDEOACCELERATORCONTAINERCALLBACKS;
typedef struct IDirectDrawVideoAcceleratorVtbl  DIRECTDRAWVIDEOACCELERATORCALLBACKS;


typedef struct _tag_DDVAUncompDataInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwUncompWidth;              // [in]     width of uncompressed data
    DWORD                   dwUncompHeight;             // [in]     height of uncompressed data
    DDPIXELFORMAT           ddUncompPixelFormat;        // [in]     pixel-format of uncompressed data
} DDVAUncompDataInfo, *LPDDVAUncompDataInfo;

typedef struct _tag_DDVAInternalMemInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwScratchMemAlloc;          // [out]    amount of scratch memory will the hal allocate for its private use
} DDVAInternalMemInfo, *LPDDVAInternalMemInfo;


typedef struct _tag_DDVACompBufferInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwNumCompBuffers;           // [out]    number of buffers reqd for compressed data
    DWORD                   dwWidthToCreate;            // [out]    Width of surface to create
    DWORD                   dwHeightToCreate;           // [out]    Height of surface to create
    DWORD                   dwBytesToAllocate;          // [out]    Total number of bytes used by each surface
    DDSCAPS2                ddCompCaps;                 // [out]    caps to create surfaces to store compressed data
    DDPIXELFORMAT           ddPixelFormat;              // [out]    fourcc to create surfaces to store compressed data
} DDVACompBufferInfo, *LPDDVACompBufferInfo;


// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDVABeginFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    LPDIRECTDRAWSURFACE7    pddDestSurface;             // [in]     destination buffer in which to decoding this frame
    DWORD                   dwSizeInputData;            // [in]     size of other misc data to begin frame
    LPVOID                  pInputData;                 // [in]     pointer to misc data
    DWORD                   dwSizeOutputData;           // [in/out] size of other misc data to begin frame
    LPVOID                  pOutputData;                // [out]    pointer to misc data
} DDVABeginFrameInfo, *LPDDVABeginFrameInfo;

// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDVAEndFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwSizeMiscData;             // [in]     size of other misc data to begin frame
    LPVOID                  pMiscData;                  // [in]     pointer to misc data
} DDVAEndFrameInfo, *LPDDVAEndFrameInfo;

typedef struct _tag_DDVABUFFERINFO
{
    DWORD                   dwSize;                     // [in]    size of the struct
    LPDIRECTDRAWSURFACE7    pddCompSurface;             // [in]    pointer to buffer containing compressed data
    DWORD                   dwDataOffset;               // [in]    offset of relevant data from the beginning of buffer
    DWORD                   dwDataSize;                 // [in]    size of relevant data
} DDVABUFFERINFO, *LPDDVABUFFERINFO;


/*
 * INTERACES FOLLOW:
 *	IDDVideoAcceleratorContainer
 *	IDirectDrawVideoAccelerator
 */

/*
 * IDDVideoAcceleratorContainer
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDDVideoAcceleratorContainer
DECLARE_INTERFACE_( IDDVideoAcceleratorContainer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDDVideoAcceleratorContainer methods ***/
    STDMETHOD(CreateVideoAccelerator)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPVOID, DWORD, LPDIRECTDRAWVIDEOACCELERATOR FAR *, IUnknown FAR *) PURE;
    STDMETHOD(GetCompBufferInfo)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPDWORD, LPDDVACompBufferInfo ) PURE;
    STDMETHOD(GetInternalMemInfo)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPDDVAInternalMemInfo ) PURE;
    STDMETHOD(GetVideoAcceleratorGUIDs)(THIS_ LPDWORD, LPGUID ) PURE;
    STDMETHOD(GetUncompFormatsSupported)(THIS_ LPGUID, LPDWORD, LPDDPIXELFORMAT ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoAcceleratorContainer_QueryInterface(p, a, b)            (p)->lpVtbl->QueryInterface(p, a, b)
#define IVideoAcceleratorContainer_AddRef(p)                          (p)->lpVtbl->AddRef(p)
#define IVideoAcceleratorContainer_Release(p)                         (p)->lpVtbl->Release(p)
#define IVideoAcceleratorContainer_CreateVideoAccelerator(p,a,b,c,d,e,f)    (p)->lpVtbl->CreateVideoAccelerator(p, a, b, c, d, e, f)
#define IVideoAcceleratorContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->lpVtbl->GetCompBufferInfo(p, a, b, c, d)
#define IVideoAcceleratorContainer_GetInternalMemInfo(p, a, b, c)     (p)->lpVtbl->GetInternalMemInfo(p, a, b, c)
#define IVideoAcceleratorContainer_GetVideoAcceleratorGUIDs(p, a, b)        (p)->lpVtbl->GetVideoAcceleratorGUIDs(p, a, b)
#define IVideoAcceleratorContainer_GetUncompFormatsSupported(p,a,b,c) (p)->lpVtbl->GetUncompFormatsSupported(p, a, b, c)
#else
#define IVideoAcceleratorContainer_QueryInterface(p, a, b)            (p)->QueryInterface(a, b)
#define IVideoAcceleratorContainer_AddRef(p)                          (p)->AddRef()
#define IVideoAcceleratorContainer_Release(p)                         (p)->Release()
#define IVideoAcceleratorContainer_CreateVideoAccelerator(p, a, b, c,d,e,f) (p)->CreateVideoAccelerator(a, b, c, d, e, f)
#define IVideoAcceleratorContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->GetCompBufferInfo(a, b, c, d)
#define IVideoAcceleratorContainer_GetInternalMemInfo(p, a, b, c)     (p)->GetInternalMemInfo(a, b, c)
#define IVideoAcceleratorContainer_GetVideoAcceleratorGUIDs(p, a, b)        (p)->GetVideoAcceleratorGUIDs(a, b)
#define IVideoAcceleratorContainer_GetUncompFormatsSupported(p,a,b,c) (p)->GetUncompFormatsSupported(a, b, c)
#endif

#endif


/*
 * IDirectDrawVideoAccelerator
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoAccelerator
DECLARE_INTERFACE_( IDirectDrawVideoAccelerator, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirecytDrawVideoAccelerator methods ***/
    STDMETHOD(BeginFrame)(THIS_ LPDDVABeginFrameInfo) PURE;
    STDMETHOD(EndFrame)(THIS_ LPDDVAEndFrameInfo) PURE;
    STDMETHOD(QueryRenderStatus)(THIS_ LPDIRECTDRAWSURFACE7, DWORD)PURE;
    STDMETHOD(Execute)(THIS_ 
                       DWORD,            // Function
                       LPVOID,           // Input data
                       DWORD,            // Input data length
                       LPVOID,           // Output data
                       DWORD,            // Output data length
                       DWORD,            // Number of buffers
                       LPDDVABUFFERINFO  // Buffer info array
                       ) PURE;
};

//  Flags for QueryRenderStatus
#define DDVA_QUERYRENDERSTATUSF_READ     0x00000001  // Query for read
                                                     // set this bit to 0 
                                                     // if query for update

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoAccelerator_QueryInterface(p,a,b)      (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoAccelerator_AddRef(p)                  (p)->lpVtbl->AddRef(p)
#define IVideoAccelerator_Release(p)                 (p)->lpVtbl->Release(p)
#define IVideoAccelerator_BeginFrame(p,a)            (p)->lpVtbl->BeginFrame(p,a)
#define IVideoAccelerator_EndFrame(p,a)              (p)->lpVtbl->EndFrame(p,a)
#define IVideoAccelerator_QueryRenderStatus(p,a,b)   (p)->lpVtbl->QueryRenderStatus(p,a,b)
#define IVideoAccelerator_RenderMacroBlocks(p,a,b)   (p)->lpVtbl->RenderMacroBlocks(p,a,b)
#else
#define IVideoAccelerator_QueryInterface(p,a,b)      (p)->QueryInterface(a,b)
#define IVideoAccelerator_AddRef(p)                  (p)->AddRef()
#define IVideoAccelerator_Release(p)                 (p)->Release()
#define IVideoAccelerator_BeginFrame(p,a)            (p)->BeginFrame(a)
#define IVideoAccelerator_EndFrame(p,a)              (p)->EndFrame(a)
#define IVideoAccelerator_QueryRenderStatus(p,a,b)   (p)->QueryRenderStatus(a,b)
#define IVideoAccelerator_RenderMacroBlocks(p,a,b)   (p)->RenderMacroBlocks(a,b)
#endif

#endif


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\conroute.h ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    conroute.h

Abstract:

    This include file contains all the type and constant definitions that are
    shared by the BASE and CONSOLE components of the Windows Subsystem.

Author:

    Therese Stowell (thereses) 3-Jan-1991

Revision History:

--*/

//
// These bits are always on for console handles and are used for routing
// by windows.
//

#define CONSOLE_HANDLE_SIGNATURE 0x00000003
#define CONSOLE_HANDLE_NEVERSET  0x10000000
#define CONSOLE_HANDLE_MASK      (CONSOLE_HANDLE_SIGNATURE | CONSOLE_HANDLE_NEVERSET)

#define CONSOLE_HANDLE(HANDLE) (((ULONG_PTR)(HANDLE) & CONSOLE_HANDLE_MASK) == CONSOLE_HANDLE_SIGNATURE)


#define CONSOLE_DETACHED_PROCESS ((HANDLE)-1)
#define CONSOLE_NEW_CONSOLE ((HANDLE)-2)
#define CONSOLE_CREATE_NO_WINDOW ((HANDLE)-3)

//
// These are flags stored in PEB::ProcessParameters::ConsoleFlags.
//
#define CONSOLE_IGNORE_CTRL_C 0x1

//
// These strings are used to open console input or output.
//

#define CONSOLE_INPUT_STRING  L"CONIN$"
#define CONSOLE_OUTPUT_STRING L"CONOUT$"
#define CONSOLE_GENERIC       L"CON"

//
// this string is used to call RegisterWindowMessage to get
// progman's handle.
//

#define CONSOLE_PROGMAN_HANDLE_MESSAGE "ConsoleProgmanHandle"


//
// stream API definitions.  these API are only supposed to be used by
// subsystems (i.e. OpenFile routes to OpenConsoleW).
//

HANDLE
APIENTRY
OpenConsoleW(
    IN LPWSTR lpConsoleDevice,
    IN DWORD dwDesiredAccess,
    IN BOOL bInheritHandle,
    IN DWORD dwShareMode
    );

HANDLE
APIENTRY
DuplicateConsoleHandle(
    IN HANDLE hSourceHandle,
    IN DWORD dwDesiredAccess,
    IN BOOL bInheritHandle,
    IN DWORD dwOptions
    );

BOOL
APIENTRY
GetConsoleHandleInformation(
    IN HANDLE hObject,
    OUT LPDWORD lpdwFlags
    );

BOOL
APIENTRY
SetConsoleHandleInformation(
    IN HANDLE hObject,
    IN DWORD dwMask,
    IN DWORD dwFlags
    );

BOOL
APIENTRY
CloseConsoleHandle(
    IN HANDLE hConsole
    );

BOOL
APIENTRY
VerifyConsoleIoHandle(
    IN HANDLE hIoHandle
    );

HANDLE
APIENTRY
GetConsoleInputWaitHandle( VOID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\ddemlp.h ===
/*++ BUILD Version: 0001 // Increment this if a change has global effects --*/
/****************************** Module Header ******************************\
* Module Name: ddemlp.h
*
* Copyright (c) Microsoft Corporation. All rights reserved.
*
* This header file contains stuff used by all parts of USER DDEML code.
*
* History:
* 10-28-91 Sanfords     Created
* 4-21-92  Sanfords     Merged into ddeml.w
\***************************************************************************/
#ifndef _INC_DDEMLPH
#define _INC_DDEMLPH
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#define     ST_TERMINATE_RECEIVED   0x0200
#define     ST_FREE_CONV_RES_NOW    0x0800  // See FreeConversationResources()
#define     ST_INTRA_PROCESS        0x8000
#define     ST_UNICODE_EXECUTE      0x4000
#define     ST_BLOCKALLNEXT         0x2000
#define     ST_PROCESSING           0x1000   // See CheckForQueuedMessages()
#define     CBF_MASK                     0x003ff000L
#define     CBF_MONMASK                  0x0027f000L
#define     APPCMD_UNINIT_ASAP           0x00000800L
#define     APPCLASS_UNICODE             0x00000001L
BOOL WINAPI DdeGetQualityOfService(HWND hwndClient, HWND hwndServer,
        PSECURITY_QUALITY_OF_SERVICE pqos);
#define EC_ENABLEONEOFALL       0x2000
#define EC_CHECKQUEUEONCE       0x1000
#define EC_CHECKQUEUE           0x0800
#define UM_REGISTER         (WM_USER + 200)
#define UM_UNREGISTER       (WM_USER + 201)
#define     HDATA_READONLY          0x8000
#define     HDATA_NOAPPFREE         0x4000
#define     HDATA_EXECUTE           0x0100
#define     HDATA_INITIALIZED       0x0200

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* _INC_DDEMLPH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\ddetrack.h ===
/****************************** Module Header ******************************\
* Module Name: ddetrack.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Stuff for dde tracking
*
* History:
* 9-3-91    sanfords    Created
\***************************************************************************/

typedef struct tagDDEPACK {
    UINT_PTR uiLo;
    UINT_PTR uiHi;
} DDEPACK, *PDDEPACK;


#if defined(BUILD_WOW6432)
//
// This structure has the same layout as the DDEDATA when allocated by 32-bit 
// clients running on Win64. It's used only by USER to apply correct structure-size
// validation.
//
typedef struct _DDEDATA_WOW6432
{
    WORD wStatus;
    WORD wFmt;
    ULONG_PTR Data; 
} DDEDATA_WOW6432, *PDDEDATA_WOW6432;
#endif

// Packing set to 1 on 64 bits to prevent compiler from generating extra
// packing for DDE_DATA that will later corrupt data when we attempt to cast
// a pointer to a DDEDATA structure as a DDE_DATA pointer.  DDEDATA is not 
// packed and uses __unaligned directive to assign pointer values to Value 
// field.  To make sure those pointer values are extracted properly, DDE_DATA 
// must be packed to 1.

#if defined(_WIN64) || defined(BUILD_WOW6432)
#pragma pack(1)                 
#endif
typedef struct tagDDE_DATA {    // useful for sanely manipulating DDE data
    WORD wStatus;
    WORD wFmt;
    KERNEL_PVOID Data;          // often cast to a HANDLE so has to scale 32 and 64 bits.
} DDE_DATA, *PDDE_DATA;
#if defined(_WIN64) || defined(BUILD_WOW6432)
#pragma pack()
#endif

//
// This structure heads the single server side object used to hold DDE Data.
// Its complexity derives from the fact that we may need to copy huge and
// complex DDE data across the CSR barrier. (TYPE_DDEDATA object)
//
typedef struct tagINTDDEINFO {
    DDEPACK     DdePack;            // original dde pack struct
    DWORD       flags;              // XS_ flags describing the data
    HANDLE      hDirect;            // handle to direct DDE data
    PBYTE       pDirect;            // pointer to source buffer for direct data
    int         cbDirect;           // size of direct data total
    HANDLE      hIndirect;          // handle referenced by direct data
    PBYTE       pIndirect;          // pointer to source of indirect data - if being copied
    int         cbIndirect;         // amount of indirect data total
                                    // Directly following this struct is the
                                    // raw DDE data being copied between processes
} INTDDEINFO, *PINTDDEINFO;

// values for flags fields

#define XS_PACKED         0x0001  // this transaction has a packed lParam
#define XS_DATA           0x0002  // this transaction has data w/status-format info.
#define XS_METAFILEPICT   0x0004  // the data in this transaction has a METAFILEPICT
#define XS_BITMAP         0x0008  // the data in this transaction has a HBITMAP
#define XS_DIB            0x0010  // the data in this transaction has a DIB
#define XS_ENHMETAFILE    0x0020  // the data in this transaction has a HMF
#define XS_PALETTE        0x0040  // the data in this transaction has a HPALETTE
#define XS_LOHANDLE       0x0080  // the uiLo part has the data handle
#define XS_HIHANDLE       0x0100  // the uiHi part has the data handle
#define XS_FREEPXS        0x0200  // DDETrackGetMessageHook() should free pxs.
#define XS_FRELEASE       0x0400  // DDE_FRELEASE bit was set in the data msg.
#define XS_EXECUTE        0x0800  // execute data handle
#define XS_FREESRC        0x1000  // free source after copy.
#define XS_PUBLICOBJ      0x2000  // object being shared is public - cleanup if needed.
#define XS_GIVEBACKONNACK 0x4000  // object was given and may need to be returned.
#define XS_DUMPMSG        0x8000  // used for backing out PostMessages.
#define XS_UNICODE       0x10000  // execute string is expected to be UNICODE

#define FAIL_POST       0       // return values from DDETrackPostHook()
#define FAKE_POST       1
#define DO_POST         2
#define FAILNOFREE_POST 3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\indicmlp.h ===
#ifdef __cplusplus
extern "C" {
#endif
//------------------------------------------------------------------//
//                                                                  //
// Internal ID for WM_COMMAND  of Indicator Window.                 //
//                                                                  //
//------------------------------------------------------------------//
#define CMDINDIC_REFRESHINDIC           249                         //
//                                                                  //
// defined in internat\exe\resource.h                               //
// #define IDM_RMENU_WHATSTHIS		250                         //
// #define IDM_RMENU_HELPFINDER		251                         //
// #define IDM_RMENU_PROPERTIES		252                         //
// #define IDM_EXIT			253                         //
// #define IDM_RMENU_IMEHELP		254                         //
//                                                                  //
#define CMDINDIC_EXIT                   259                         //
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\icmpriv.h ===
/****************************Module*Header******************************\
* Module Name: ICMPRIV.H
*
* Module Descripton: Internal data structures and constants for ICM
*
* Warnings:
*
* Issues:
*
* Created:  8 January 1996
* Author:   Srinivasan Chandrasekar    [srinivac]
*
* Copyright (c) Microsoft Corporation. All rights reserved.
\***********************************************************************/

#ifndef _ICMPRIV_H_
#define _ICMPRIV_H_

#include "icm.h"          // include external stuff first

#ifdef __cplusplus
extern "C" {
#endif

//
// External (but OS internal) functional declarations
//

BOOL    InternalGetPS2ColorSpaceArray (PBYTE, DWORD, DWORD, PBYTE, PDWORD, PBOOL);
BOOL    InternalGetPS2ColorRenderingIntent(PBYTE, DWORD, PBYTE, PDWORD);
BOOL    InternalGetPS2ColorRenderingDictionary(PBYTE, DWORD, PBYTE, PDWORD, PBOOL);
BOOL    InternalGetPS2PreviewCRD(PBYTE, PBYTE, DWORD, PBYTE, PDWORD, PBOOL);
BOOL    InternalGetPS2CSAFromLCS(LPLOGCOLORSPACE, PBYTE, PDWORD, PBOOL);
BOOL    InternalGetDeviceConfig(LPCTSTR,DWORD,DWORD,PVOID,PDWORD);
BOOL    InternalSetDeviceConfig(LPCTSTR,DWORD,DWORD,PVOID,DWORD);

//
// Function ID for InternalGet/SetDeviceConfig
//

#define MSCMS_PROFILE_ENUM_MODE     1

#if !defined(_GDI32_)  // not include from here if gdi32.

//
// Useful macros
//

#define ABS(x)                      ((x) > 0 ? (x) : -(x))
#define DWORD_ALIGN(x)              (((x) + 3) & ~3)

#ifdef LITTLE_ENDIAN
#define FIX_ENDIAN(x)               (((x) & 0xff000000) >> 24 | \
                                     ((x) & 0xff0000)   >> 8  | \
                                     ((x) & 0xff00)     << 8  | \
                                     ((x) & 0xff)       << 24 )

#define FIX_ENDIAN16(x)             (((x) & 0xff00) >> 8 | ((x) & 0xff) << 8)
#else
#define FIX_ENDIAN(x)               (x)
#define FIX_ENDIAN16(x)             (x)
#endif

#if !defined(FROM_PS) // not include from here if postscript driver.

//
// MSCMS Internal definition
//

typedef struct tagTAGDATA {
    TAGTYPE tagType;
    DWORD   dwOffset;
    DWORD   cbSize;
} TAGDATA;
typedef TAGDATA *PTAGDATA;

//
// ICM supports the following  objects:
// 1. Profile object: This is created when an application requsts a handle
//      to a profile.
// 2. Color transform object: This is created when an application creates
//      a color transform.
// 3. CMM object: This is created when ICM loads a CMM into memory to
//      perform color matching.
//

typedef enum {
    OBJ_PROFILE             = 'PRFL',
    OBJ_TRANSFORM           = 'XFRM',
    OBJ_CMM                 = ' CMM',
} OBJECTTYPE;

typedef struct tagOBJHEAD {
    OBJECTTYPE  objType;
    DWORD       dwUseCount;
} OBJHEAD;
typedef OBJHEAD *POBJHEAD;

//
// Profile object:
// Memory for profile objects is allocated from ICM's per process heap.
// These objects use handles from ICM's per process handle table.
//

typedef struct tagPROFOBJ {
    OBJHEAD   objHdr;           // common object header info
    DWORD     dwType;           // type (from profile structure)
    PVOID     pProfileData;     // data (from profile structure)
    DWORD     cbDataSize;       // size of data (from profile structure)
    DWORD     dwFlags;          // miscellaneous flags
    HANDLE    hFile;            // handle to open profile
    HANDLE    hMap;             // handle to profile mapping
    DWORD     dwMapSize;        // size of the file mapping object
    PBYTE     pView;            // pointer to mapped view of profile
} PROFOBJ;
typedef PROFOBJ *PPROFOBJ;

//
// Flags for ((PPROFOBJ)0)->dwFlags
//

#define MEMORY_MAPPED       1   // memory mapped profile
#define PROFILE_TEMP        2   // temporary profile has been created
#define READWRITE_ACCESS    4   // if this bit is set, app has read & write
                                // access to profile, else it has only read
                                // read access.

//
// Transform returned by CMM
//

typedef HANDLE  HCMTRANSFORM;

//
// For internal use, compiler doesn't accept PBYTE* below
//

typedef PBYTE*  PPBYTE;

//
// CMM function calltable
//

typedef struct tagCMMFNS {

    //
    // Required functions
    //

    DWORD          (WINAPI *pCMGetInfo)(DWORD);
    HCMTRANSFORM   (WINAPI *pCMCreateTransform)(LPLOGCOLORSPACE, PVOID, PVOID);
    HCMTRANSFORM   (WINAPI *pCMCreateTransformExt)(LPLOGCOLORSPACE, PVOID, PVOID, DWORD);
    BOOL           (WINAPI *pCMDeleteTransform)(HCMTRANSFORM);
    BOOL           (WINAPI *pCMTranslateRGBs)(HCMTRANSFORM, PVOID, BMFORMAT,
                       DWORD, DWORD, DWORD, PVOID, BMFORMAT, DWORD);
    BOOL           (WINAPI *pCMTranslateRGBsExt)(HCMTRANSFORM, PVOID, BMFORMAT,
                       DWORD, DWORD, DWORD, PVOID, BMFORMAT, DWORD, PBMCALLBACKFN, LPARAM);
    BOOL           (WINAPI *pCMCheckRGBs)(HCMTRANSFORM, PVOID, BMFORMAT,
                       DWORD, DWORD, DWORD, PBYTE, PBMCALLBACKFN, LPARAM);
    HCMTRANSFORM   (WINAPI *pCMCreateMultiProfileTransform)(PHPROFILE, DWORD, PDWORD, DWORD, DWORD);
    BOOL           (WINAPI *pCMTranslateColors)(HCMTRANSFORM, PCOLOR, DWORD,
                       COLORTYPE, PCOLOR, COLORTYPE);
    BOOL           (WINAPI *pCMCheckColors)(HCMTRANSFORM, PCOLOR, DWORD,
                       COLORTYPE, PBYTE);
    //
    // Optional functions
    //

    BOOL           (WINAPI *pCMCreateProfile)(LPLOGCOLORSPACE, PPBYTE);
    BOOL           (WINAPI *pCMGetNamedProfileInfo)(HPROFILE, PNAMED_PROFILE_INFO);
    BOOL           (WINAPI *pCMConvertColorNameToIndex)(HPROFILE, LPCOLOR_NAME, LPDWORD, DWORD);
    BOOL           (WINAPI *pCMConvertIndexToColorName)(HPROFILE, LPDWORD, LPCOLOR_NAME, DWORD);
    BOOL           (WINAPI *pCMCreateDeviceLinkProfile)(PHPROFILE, DWORD, PDWORD, DWORD, DWORD, PPBYTE);
    BOOL           (WINAPI *pCMIsProfileValid)(HPROFILE, PBOOL);
    BOOL           (WINAPI *pCMGetPS2ColorSpaceArray)(HPROFILE, DWORD, DWORD, PBYTE, PDWORD, PBOOL);
    BOOL           (WINAPI *pCMGetPS2ColorRenderingIntent)(HPROFILE, DWORD, PBYTE, PDWORD);
    BOOL           (WINAPI *pCMGetPS2ColorRenderingDictionary)(HPROFILE, DWORD,
                       PBYTE, PDWORD, PBOOL);
} CMMFNS;
typedef CMMFNS *PCMMFNS;

//
// CMM object:
// Memory for CMM objects is allocated from ICM's per process heap.
// They are maintained in a linked list.
//

typedef struct tagCMMOBJ {
    OBJHEAD           objHdr;
    DWORD             dwFlags;  // miscellaneous flags
    DWORD             dwCMMID;  // ICC identifier
    DWORD             dwTaskID; // process ID of current task
    HINSTANCE         hCMM;     // handle to instance of CMM dll
    CMMFNS            fns;      // function calltable
    struct tagCMMOBJ* pNext;    // pointer to next object
} CMMOBJ;
typedef CMMOBJ *PCMMOBJ;

//
//  dwFlags for CMMOBJ
//

#define CMM_DONT_USE_PS2_FNS        0x00001

//
// Color transform object
//

typedef struct tagTRANSFORMOBJ {
    OBJHEAD      objHdr;
    PCMMOBJ      pCMMObj;       // pointer to CMM object
    HCMTRANSFORM hcmxform;      // transform returned by CMM
} TRANSFORMOBJ;
typedef TRANSFORMOBJ *PTRANSFORMOBJ;

//
// Parameter to InternalHandleColorProfile
//

typedef enum {
    ADDPROFILES,
    REMOVEPROFILES,
    ENUMPROFILES,
} PROFILEOP;

//
// CMM returned transform should be larger than this value
//

#define TRANSFORM_ERROR    (HTRANSFORM)255

#define PROFILE_SIGNATURE          'psca'

#define HEADER(pProfObj)           ((PPROFILEHEADER)pProfObj->pView)
#define VIEW(pProfObj)             (pProfObj->pView)
#define PROFILE_SIZE(pProfObj)     (FIX_ENDIAN(HEADER(pProfObj)->phSize))
#define TAG_COUNT(pProfObj)        (*((DWORD *)(VIEW(pProfObj) + \
                                   sizeof(PROFILEHEADER))))
#define TAG_DATA(pProfObj)         ((PTAGDATA)(VIEW(pProfObj) + \
                                   sizeof(PROFILEHEADER) + sizeof(DWORD)))

#define MAGIC                      'ICM '
#define PTRTOHDL(x)                ((HANDLE)((ULONG_PTR)(x) ^ MAGIC))
#define HDLTOPTR(x)                ((ULONG_PTR)(x) ^ MAGIC)

PVOID   MemAlloc(DWORD);
PVOID   MemReAlloc(PVOID, DWORD);
VOID    MemFree(PVOID);
VOID    MyCopyMemory(PBYTE, PBYTE, DWORD);
PVOID   AllocateHeapObject(OBJECTTYPE);
VOID    FreeHeapObject(HANDLE);
BOOL    ValidHandle(HANDLE, OBJECTTYPE);
PCMMOBJ GetColorMatchingModule(DWORD);
BOOL    ValidColorMatchingModule(DWORD,PTSTR);
PCMMOBJ GetPreferredCMM();
VOID    ReleaseColorMatchingModule(PCMMOBJ);
BOOL    ValidProfile(PPROFOBJ);
BOOL    ConvertToAnsi(PCWSTR, PSTR*, BOOL);
BOOL    ConvertToUnicode(PCSTR, PWSTR*, BOOL);
PTSTR   GetFilenameFromPath(PTSTR);

//
// For use with the new Device Settings tag
//

typedef struct _SETTINGS {
    DWORD         dwSettingType;     // 'rsln', 'mdia' etc.
    DWORD         dwSizePerValue;    // number of bytes per value
    DWORD         nValues;           // number of values
    DWORD         Value[1];          // array of value entries
} SETTINGS, *PSETTINGS;

typedef struct _SETTINGCOMBOS {
    DWORD         dwSize;           // size of this structure, including sub structures
    DWORD         nSettings;        // number of setting structures
    SETTINGS      Settings[1];      // array of setting entries
} SETTINGCOMBOS, *PSETTINGCOMBOS;

typedef struct _PERPLATFORMENTRY {
    DWORD         PlatformID;        // platform signature ('msft', 'appl' etc.)
    DWORD         dwSize;            // size of this structure, including sub structures
    DWORD         nSettingCombos;    // number of setting combo structures
    SETTINGCOMBOS SettingCombos[1];  // array of setting combos entries
} PLATFORMENTRY, *PPLATFORMENTRY;

typedef struct _DEVICESETTINGS {
    DWORD         dwTagID;           // 'devs'
    DWORD         dwReserved;        // must be 0
    DWORD         nPlatforms;        // number of platform structures
    PLATFORMENTRY PlatformEntry[1];  // array of platform entries
} DEVICESETTINGS, *PDEVICESETTINGS;

#endif  // ifndef FROM_PS

#endif  // ifndef _GDI32_

#ifdef __cplusplus
}
#endif

#endif  // ifndef _ICMPRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\imep.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    imep.h

Abstract:

    Private
    Procedure declarations, constant definitions and macros for the IME
    component.

--*/
#ifndef _IMEP_
#define _IMEP_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

// IMESTRUCT structure for SendIMEMessage(Ex)
#if !defined(VK_DBE_IME_WORDREGISTER)
#define VK_DBE_IME_WORDREGISTER          VK_DBE_ENTERWORDREGISTERMODE
#define VK_DBE_IME_DIALOG                VK_DBE_ENTERIMECONFIGMODE
#define VK_DBE_FLUSH                     VK_DBE_FLUSHSTRING
#endif

#define VK_OEM_SEMICLN          0x0ba  //   ;  ** :
#define VK_OEM_EQUAL            0x0bb  //   =  ** +
#define VK_OEM_SLASH            0x0bf  //   /  ** ?
#define VK_OEM_LBRACKET         0x0db  //   [  ** {
#define VK_OEM_BSLASH           0x0dc  //   \  ** |
#define VK_OEM_RBRACKET         0x0dd  //   ]  ** |
#define VK_OEM_QUOTE            0x0de  //   '  ** "
//     switch for wParam of IME_MOVECONVERTWINDOW
#define MCW_CMD                 0x16        // command mask
#define MCW_CONSOLE_IME         0x8000
//    switch for wParam of IME_SET_MODE(IME_SETCONVERSIONMODE)
//       and IME_GET_MODE(IME_GETCONVERSIONMODE)
#define KOREA_IME_MODE_SBCSCHAR 0x0002
#define JAPAN_IME_MODE_SBCSCHAR 0x0008
// ;internal is added by JAPAN, CWIN user should ignore it
// 0x1, 0x2, 0x4, 0x20, 0x40, 0x80, 0x100 is not for CWIN
// 0x8, 0x10, and below IME_MODE_??? will be use by CWIN
#define IME_MODE_LHS                0x00200
#define IME_MODE_NOLHS              0x00400
#define IME_MODE_SK                 0x00800
#define IME_MODE_NOSK               0x01000
#define IME_MODE_XSPACE             0x02000
#define IME_MODE_NOXSPACE           0x04000
//     Subfunctions for WM_CONVERTREQUEST or WM_CONVERTREQUESTEX
#define IME_QUERY                 IME_GETIMECAPS
#define IME_ENABLEDOSIME          0x06
#define IME_ENABLE                IME_ENABLEDOSIME
#define IME_MOVECONVERTWINDOW     IME_SETCONVERSIONWINDOW
#define IME_GET_MODE              IME_GETCONVERSIONMODE
#define IME_SETCONVERSIONFONT     0x12
#define IME_SETFONT               IME_SETCONVERSIONFONT
#define IME_SENDKEY               IME_SENDVKEY
#define IME_DESTROYIME            0x14
#define IME_DESTROY               IME_DESTROYIME
#define IME_PRIVATE               0x15
#define IME_WINDOWUPDATE          0x16
#define IME_SELECT                0x17
#define IME_WORDREGISTER          IME_ENTERWORDREGISTERMODE
#define IME_DBCSNAME              0x1A
#define IME_MAXKEY                0x1B
#define IME_WINNLS_SK             0x1C
#define IME_CODECONVERT           0x20
#define IME_SETUSRFONT            0x20
#define IME_CONVERTLIST           0x21
#define IME_QUERYUSRFONT          0x21
#define IME_INPUTKEYTOSEQUENCE    0x22
#define IME_SEQUENCETOINTERNAL    0x23
#define IME_QUERYIMEINFO          0x24
#define IME_DIALOG                0x25
#define IME_AUTOMATA              0x30
#define IME_HANJAMODE             0x31
#define IME_GETLEVEL              0x40
#define IME_SETLEVEL              0x41
#define IME_GETMNTABLE            0x42  // reserved for HWIN

//#ifdef PEN
#define IME_SETUNDETERMINESTRING  0x50
#define IME_SETCAPTURE            0x51
//#endif
#define IME_CONSOLE_GET_PROCESSID     0x80                  // Win32
#define IME_CONSOLE_CREATE            0x81                  // Win32
#define IME_CONSOLE_DESTROY           0x82                  // Win32
#define IME_CONSOLE_SETFOCUS          0x83                  // Win32
#define IME_CONSOLE_KILLFOCUS         0x84                  // Win32
#define IME_CONSOLE_BUFFER_SIZE       0x85                  // Win32
#define IME_CONSOLE_WINDOW_SIZE       0x86                  // Win32
#define IME_CONSOLE_SET_IME_ON_WINDOW 0x87                  // Win32
#define IME_CONSOLE_MODEINFO          0x88
#define IME_PRIVATEFIRST          0x0100
#define IME_PRIVATELAST           0x04FF
#define IME_RS_CAPTURED         0x10    // IME is captured
#define IR_MOREROOM             0x110
#define IR_IMERELEASED          0x150
#define IMEVER_31               0x0a03
#ifdef __cplusplus
}
#endif  /* __cplusplus */
#endif  /* !_IMEP_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\intlshar.h ===
/**********************************************************************/
/*      INTLSHAR.H - SHARED HEADER FOR INTERNAT.EXE                   */
/*                                                                    */
/*      Copyright (c) Microsoft Corporation. All rights reserved.     */
/**********************************************************************/

#ifndef _INTLSHAR_
#define _INTLSHAR_

/*
 * Ordinal exports in indicdll.dll
 */
#define ORD_REGISTERHOOK          1
#define ORD_STARTSHELL            2
#define ORD_STOPSHELL             3
#define ORD_GETLASTACTIVE         4
#define ORD_GETLASTFOCUS          5
#define ORD_SETNOTIFYWND          6
#define ORD_GETLAYOUT             7
#define ORD_GETIMESTAT            8
#define ORD_GETIMEMENU            9
#define ORD_BUILDIMEMENU          10
#define ORD_GETIMEMENUITEMID      11
#define ORD_GETIMEMENUITEMDATA    12
#define ORD_DESTROYIMEMENU        13
#define ORD_SETIMEMENUITEMDATA    14
#define ORD_GETCONSOLEIMEWND      15
#define ORD_GETDEFAULTIMEMENUITEM 16

#if !defined(NEED_ORDINAL_ONLY)

struct NotifyWindows {
    DWORD cbSize;
    HWND hwndNotify;
    HWND hwndTaskBar;
};

typedef int        (CALLBACK* REGHOOKPROC)(LPVOID, LPARAM);
typedef int        (CALLBACK* FPGETIMESTAT)(void);
typedef BOOL       (CALLBACK* FPGETIMEMENU)(HWND, BOOL);
typedef HKL        (CALLBACK* FPGETLAYOUT)(void);
typedef BOOL       (CALLBACK* FPBUILDIMEMENU)(HMENU, BOOL);
typedef UINT       (CALLBACK* FPGETIMEMENUITEMID)(int);
typedef int        (CALLBACK* FPDESTROYIMEMENU)(void);
typedef void       (CALLBACK* FPSETNOTIFYWND)(const struct NotifyWindows*);
typedef HWND       (CALLBACK* FPGETLASTACTIVE)(void);
typedef HWND       (CALLBACK* FPGETLASTFOCUS)(void);
typedef void       (CALLBACK* FPSETIMEMENUITEMDATA)(DWORD);
typedef BOOL       (CALLBACK* FPGETIMEMENUITEMDATA)(PUINT, PDWORD);
typedef HWND       (CALLBACK* FPGETCONSOLEIMEWND)(void);
typedef int        (CALLBACK* FPGETDEFAULTIMEMENUITEM)(void);

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\mcdesc.h ===
/******************************Module*Header*******************************\
*
* Module Name: mcdesc.h
*
* Defines the enhanced ExtEscape functionality used for MCD support.
*
* Copyright (c) Microsoft Corporation. All rights reserved.
*
\**************************************************************************/

#ifndef __MCDESC_H__
#define __MCDESC_H__

// Escape through which all MCD functionality is accessed.

#ifndef MCDFUNCS
#define MCDFUNCS 3076
#endif

// Video memory surface description, for DDraw surface rendering.

typedef struct _MCDESC_SURFACE
{
    HANDLE hSurf;
    LONG lOffset;
    LONG lStride;
    RECTL rclPos;
} MCDESC_SURFACE;

// Data header for every escape.

typedef struct _MCDESC_HEADER
{
    ULONG flags;
    HANDLE hRC;
    HANDLE hSharedMem;
    VOID *pSharedMem;
    ULONG sharedMemSize;
    ULONG_PTR dwWindow;
    MCDESC_SURFACE msrfColor;
    MCDESC_SURFACE msrfDepth;
    ULONG cLockSurfaces;
    ULONG cExtraWndobj;
} MCDESC_HEADER;

// Data header used only on NT.

typedef struct _MCDESC_HEADER_NTPRIVATE
{
    struct _WNDOBJ *pwo;
    VOID *pBuffer;
    ULONG bufferSize;
    HANDLE *pLockSurfaces;
    HDC *pExtraWndobj;
} MCDESC_HEADER_NTPRIVATE;

// MCDESC_HEADER flags.

#define MCDESC_FL_CREATE_CONTEXT        0x00000001
#define MCDESC_FL_SURFACES              0x00000002
#define MCDESC_FL_LOCK_SURFACES         0x00000004
#define MCDESC_FL_EXTRA_WNDOBJ          0x00000008
#define MCDESC_FL_DISPLAY_LOCK          0x00000010
#define MCDESC_FL_BATCH                 0x00000020
// Used only for Win95.
#define MCDESC_FL_SWAPBUFFER            0x00000040

#define MCDESC_MAX_LOCK_SURFACES        12
#define MCDESC_MAX_EXTRA_WNDOBJ         16

// MCDSURFACE_HWND alias, used when creating contexts.
#define MCDESC_SURFACE_HWND             0x00000001

// Context creation information.
typedef struct _MCDESC_CREATE_CONTEXT
{
    ULONG flags;
    HWND hwnd;
} MCDESC_CREATE_CONTEXT;

#endif // __MCDESC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\immp.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects
 *
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *
 * Module Name:
 *
 *    immp.h
 *
 * Abstract:
 *
 *    Private
 *    Procedure declarations, constant definitions and macros for IMM.
 *
 */
#ifndef _IMMP_
#define _IMMP_

#ifdef __cplusplus
extern "C" {
#endif


#ifndef _IMM_SDK_DEFINED_
#define _IMM_SDK_DEFINED_

#if (WINVER >= 0x040A)
DECLARE_HANDLE(HIMC);
DECLARE_HANDLE(HIMCC);
#else
typedef DWORD   HIMC;
typedef DWORD   HIMCC;
#endif /* WINVER >= 0x040A */

typedef HKL FAR  *LPHKL;
typedef UINT FAR *LPUINT;

typedef struct tagCOMPOSITIONFORM {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} COMPOSITIONFORM, *PCOMPOSITIONFORM, NEAR *NPCOMPOSITIONFORM, FAR *LPCOMPOSITIONFORM;


typedef struct tagCANDIDATEFORM {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} CANDIDATEFORM, *PCANDIDATEFORM, NEAR *NPCANDIDATEFORM, FAR *LPCANDIDATEFORM;


typedef struct tagCANDIDATELIST {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[1];
} CANDIDATELIST, *PCANDIDATELIST, NEAR *NPCANDIDATELIST, FAR *LPCANDIDATELIST;

typedef struct tagREGISTERWORDA {
    LPSTR   lpReading;
    LPSTR   lpWord;
} REGISTERWORDA, *PREGISTERWORDA, NEAR *NPREGISTERWORDA, FAR *LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
    LPWSTR  lpReading;
    LPWSTR  lpWord;
} REGISTERWORDW, *PREGISTERWORDW, NEAR *NPREGISTERWORDW, FAR *LPREGISTERWORDW;
#ifdef UNICODE
typedef REGISTERWORDW REGISTERWORD;
typedef PREGISTERWORDW PREGISTERWORD;
typedef NPREGISTERWORDW NPREGISTERWORD;
typedef LPREGISTERWORDW LPREGISTERWORD;
#else
typedef REGISTERWORDA REGISTERWORD;
typedef PREGISTERWORDA PREGISTERWORD;
typedef NPREGISTERWORDA NPREGISTERWORD;
typedef LPREGISTERWORDA LPREGISTERWORD;
#endif // UNICODE

#if (WINVER >= 0x040A)

typedef struct tagRECONVERTSTRING {
    DWORD dwSize;
    DWORD dwVersion;
    DWORD dwStrLen;
    DWORD dwStrOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwTargetStrLen;
    DWORD dwTargetStrOffset;
} RECONVERTSTRING, *PRECONVERTSTRING, NEAR *NPRECONVERTSTRING, FAR *LPRECONVERTSTRING;

#endif /* WINVER >= 0x040A */

#define STYLE_DESCRIPTION_SIZE  32

typedef struct tagSTYLEBUFA {
    DWORD       dwStyle;
    CHAR        szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFA, *PSTYLEBUFA, NEAR *NPSTYLEBUFA, FAR *LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
    DWORD       dwStyle;
    WCHAR       szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFW, *PSTYLEBUFW, NEAR *NPSTYLEBUFW, FAR *LPSTYLEBUFW;
#ifdef UNICODE
typedef STYLEBUFW STYLEBUF;
typedef PSTYLEBUFW PSTYLEBUF;
typedef NPSTYLEBUFW NPSTYLEBUF;
typedef LPSTYLEBUFW LPSTYLEBUF;
#else
typedef STYLEBUFA STYLEBUF;
typedef PSTYLEBUFA PSTYLEBUF;
typedef NPSTYLEBUFA NPSTYLEBUF;
typedef LPSTYLEBUFA LPSTYLEBUF;
#endif // UNICODE


#if (WINVER >= 0x040A)

#define IMEMENUITEM_STRING_SIZE 80

typedef struct tagIMEMENUITEMINFOA {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    CHAR        szString[IMEMENUITEM_STRING_SIZE];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOA, *PIMEMENUITEMINFOA, NEAR *NPIMEMENUITEMINFOA, FAR *LPIMEMENUITEMINFOA;
typedef struct tagIMEMENUITEMINFOW {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    WCHAR       szString[IMEMENUITEM_STRING_SIZE];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOW, *PIMEMENUITEMINFOW, NEAR *NPIMEMENUITEMINFOW, FAR *LPIMEMENUITEMINFOW;
#ifdef UNICODE
typedef IMEMENUITEMINFOW IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOW PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOW NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOW LPIMEMENUITEMINFO;
#else
typedef IMEMENUITEMINFOA IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOA PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOA NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOA LPIMEMENUITEMINFO;
#endif // UNICODE

typedef struct tagIMECHARPOSITION {
    DWORD       dwSize;
    DWORD       dwCharPos;
    POINT       pt;
    UINT        cLineHeight;
    RECT        rcDocument;
} IMECHARPOSITION, *PIMECHARPOSITION, NEAR *NPIMECHARPOSITION, FAR *LPIMECHARPOSITION;

typedef BOOL    (CALLBACK* IMCENUMPROC)(HIMC, LPARAM);

#endif /* WINVER >= 0x040A */



// prototype of IMM API

HKL  WINAPI ImmInstallIMEA(IN LPCSTR lpszIMEFileName, IN LPCSTR lpszLayoutText);
HKL  WINAPI ImmInstallIMEW(IN LPCWSTR lpszIMEFileName, IN LPCWSTR lpszLayoutText);
#ifdef UNICODE
#define ImmInstallIME  ImmInstallIMEW
#else
#define ImmInstallIME  ImmInstallIMEA
#endif // !UNICODE

HWND WINAPI ImmGetDefaultIMEWnd(IN HWND);

UINT WINAPI ImmGetDescriptionA(IN HKL, OUT LPSTR, IN UINT uBufLen);
UINT WINAPI ImmGetDescriptionW(IN HKL, OUT LPWSTR, IN UINT uBufLen);
#ifdef UNICODE
#define ImmGetDescription  ImmGetDescriptionW
#else
#define ImmGetDescription  ImmGetDescriptionA
#endif // !UNICODE

UINT WINAPI ImmGetIMEFileNameA(IN HKL, OUT LPSTR, IN UINT uBufLen);
UINT WINAPI ImmGetIMEFileNameW(IN HKL, OUT LPWSTR, IN UINT uBufLen);
#ifdef UNICODE
#define ImmGetIMEFileName  ImmGetIMEFileNameW
#else
#define ImmGetIMEFileName  ImmGetIMEFileNameA
#endif // !UNICODE

DWORD WINAPI ImmGetProperty(IN HKL, IN DWORD);

BOOL WINAPI ImmIsIME(IN HKL);

BOOL WINAPI ImmSimulateHotKey(IN HWND, IN DWORD);

HIMC WINAPI ImmCreateContext(void);
BOOL WINAPI ImmDestroyContext(IN HIMC);
HIMC WINAPI ImmGetContext(IN HWND);
BOOL WINAPI ImmReleaseContext(IN HWND, IN HIMC);
HIMC WINAPI ImmAssociateContext(IN HWND, IN HIMC);
#if (WINVER >= 0x040A)
BOOL WINAPI ImmAssociateContextEx(IN HWND, IN HIMC, IN DWORD);
#endif /* WINVER >= 0x040A */

LONG  WINAPI ImmGetCompositionStringA(IN HIMC, IN DWORD, OUT LPVOID, IN DWORD);
LONG  WINAPI ImmGetCompositionStringW(IN HIMC, IN DWORD, OUT LPVOID, IN DWORD);
#ifdef UNICODE
#define ImmGetCompositionString  ImmGetCompositionStringW
#else
#define ImmGetCompositionString  ImmGetCompositionStringA
#endif // !UNICODE

BOOL  WINAPI ImmSetCompositionStringA(IN HIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD, IN LPVOID lpRead, IN DWORD);
BOOL  WINAPI ImmSetCompositionStringW(IN HIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD, IN LPVOID lpRead, IN DWORD);
#ifdef UNICODE
#define ImmSetCompositionString  ImmSetCompositionStringW
#else
#define ImmSetCompositionString  ImmSetCompositionStringA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListCountA(IN HIMC, OUT LPDWORD lpdwListCount);
DWORD WINAPI ImmGetCandidateListCountW(IN HIMC, OUT LPDWORD lpdwListCount);
#ifdef UNICODE
#define ImmGetCandidateListCount  ImmGetCandidateListCountW
#else
#define ImmGetCandidateListCount  ImmGetCandidateListCountA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListA(IN HIMC, IN DWORD deIndex, OUT LPCANDIDATELIST, IN DWORD dwBufLen);
DWORD WINAPI ImmGetCandidateListW(IN HIMC, IN DWORD deIndex, OUT LPCANDIDATELIST, IN DWORD dwBufLen);
#ifdef UNICODE
#define ImmGetCandidateList  ImmGetCandidateListW
#else
#define ImmGetCandidateList  ImmGetCandidateListA
#endif // !UNICODE

DWORD WINAPI ImmGetGuideLineA(IN HIMC, IN DWORD dwIndex, OUT LPSTR, IN DWORD dwBufLen);
DWORD WINAPI ImmGetGuideLineW(IN HIMC, IN DWORD dwIndex, OUT LPWSTR, IN DWORD dwBufLen);
#ifdef UNICODE
#define ImmGetGuideLine  ImmGetGuideLineW
#else
#define ImmGetGuideLine  ImmGetGuideLineA
#endif // !UNICODE

BOOL WINAPI ImmGetConversionStatus(IN HIMC, OUT LPDWORD, OUT LPDWORD);
BOOL WINAPI ImmSetConversionStatus(IN HIMC, IN DWORD, IN DWORD);
BOOL WINAPI ImmGetOpenStatus(IN HIMC);
BOOL WINAPI ImmSetOpenStatus(IN HIMC, IN BOOL);

#if defined(_WINGDI_) && !defined(NOGDI)
BOOL WINAPI ImmGetCompositionFontA(IN HIMC, OUT LPLOGFONTA);
BOOL WINAPI ImmGetCompositionFontW(IN HIMC, OUT LPLOGFONTW);
#ifdef UNICODE
#define ImmGetCompositionFont  ImmGetCompositionFontW
#else
#define ImmGetCompositionFont  ImmGetCompositionFontA
#endif // !UNICODE

BOOL WINAPI ImmSetCompositionFontA(IN HIMC, IN LPLOGFONTA);
BOOL WINAPI ImmSetCompositionFontW(IN HIMC, IN LPLOGFONTW);
#ifdef UNICODE
#define ImmSetCompositionFont  ImmSetCompositionFontW
#else
#define ImmSetCompositionFont  ImmSetCompositionFontA
#endif // !UNICODE
#endif  // defined(_WINGDI_) && !defined(NOGDI)

BOOL    WINAPI ImmConfigureIMEA(IN HKL, IN HWND, IN DWORD, IN LPVOID);
BOOL    WINAPI ImmConfigureIMEW(IN HKL, IN HWND, IN DWORD, IN LPVOID);
#ifdef UNICODE
#define ImmConfigureIME  ImmConfigureIMEW
#else
#define ImmConfigureIME  ImmConfigureIMEA
#endif // !UNICODE

LRESULT WINAPI ImmEscapeA(IN HKL, IN HIMC, IN UINT, IN LPVOID);
LRESULT WINAPI ImmEscapeW(IN HKL, IN HIMC, IN UINT, IN LPVOID);
#ifdef UNICODE
#define ImmEscape  ImmEscapeW
#else
#define ImmEscape  ImmEscapeA
#endif // !UNICODE

DWORD   WINAPI ImmGetConversionListA(IN HKL, IN HIMC, IN LPCSTR, OUT LPCANDIDATELIST, IN DWORD dwBufLen, IN UINT uFlag);
DWORD   WINAPI ImmGetConversionListW(IN HKL, IN HIMC, IN LPCWSTR, OUT LPCANDIDATELIST, IN DWORD dwBufLen, IN UINT uFlag);
#ifdef UNICODE
#define ImmGetConversionList  ImmGetConversionListW
#else
#define ImmGetConversionList  ImmGetConversionListA
#endif // !UNICODE

BOOL    WINAPI ImmNotifyIME(IN HIMC, IN DWORD dwAction, IN DWORD dwIndex, IN DWORD dwValue);

BOOL WINAPI ImmGetStatusWindowPos(IN HIMC, OUT LPPOINT);
BOOL WINAPI ImmSetStatusWindowPos(IN HIMC, IN LPPOINT);
BOOL WINAPI ImmGetCompositionWindow(IN HIMC, OUT LPCOMPOSITIONFORM);
BOOL WINAPI ImmSetCompositionWindow(IN HIMC, IN LPCOMPOSITIONFORM);
BOOL WINAPI ImmGetCandidateWindow(IN HIMC, IN DWORD, OUT LPCANDIDATEFORM);
BOOL WINAPI ImmSetCandidateWindow(IN HIMC, IN LPCANDIDATEFORM);

BOOL WINAPI ImmIsUIMessageA(IN HWND, IN UINT, IN WPARAM, IN LPARAM);
BOOL WINAPI ImmIsUIMessageW(IN HWND, IN UINT, IN WPARAM, IN LPARAM);
#ifdef UNICODE
#define ImmIsUIMessage  ImmIsUIMessageW
#else
#define ImmIsUIMessage  ImmIsUIMessageA
#endif // !UNICODE


UINT WINAPI ImmGetVirtualKey(IN HWND);

typedef int (CALLBACK *REGISTERWORDENUMPROCA)(LPCSTR, DWORD, LPCSTR, LPVOID);
typedef int (CALLBACK *REGISTERWORDENUMPROCW)(LPCWSTR, DWORD, LPCWSTR, LPVOID);
#ifdef UNICODE
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCW
#else
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCA
#endif // !UNICODE

BOOL WINAPI ImmRegisterWordA(IN HKL, IN LPCSTR lpszReading, IN DWORD, IN LPCSTR lpszRegister);
BOOL WINAPI ImmRegisterWordW(IN HKL, IN LPCWSTR lpszReading, IN DWORD, IN LPCWSTR lpszRegister);
#ifdef UNICODE
#define ImmRegisterWord  ImmRegisterWordW
#else
#define ImmRegisterWord  ImmRegisterWordA
#endif // !UNICODE

BOOL WINAPI ImmUnregisterWordA(IN HKL, IN LPCSTR lpszReading, IN DWORD, IN LPCSTR lpszUnregister);
BOOL WINAPI ImmUnregisterWordW(IN HKL, IN LPCWSTR lpszReading, IN DWORD, IN LPCWSTR lpszUnregister);
#ifdef UNICODE
#define ImmUnregisterWord  ImmUnregisterWordW
#else
#define ImmUnregisterWord  ImmUnregisterWordA
#endif // !UNICODE

UINT WINAPI ImmGetRegisterWordStyleA(IN HKL, IN UINT nItem, OUT LPSTYLEBUFA);
UINT WINAPI ImmGetRegisterWordStyleW(IN HKL, IN UINT nItem, OUT LPSTYLEBUFW);
#ifdef UNICODE
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleW
#else
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleA
#endif // !UNICODE

UINT WINAPI ImmEnumRegisterWordA(IN HKL, IN REGISTERWORDENUMPROCA, IN LPCSTR lpszReading, IN DWORD, IN LPCSTR lpszRegister, IN LPVOID);
UINT WINAPI ImmEnumRegisterWordW(IN HKL, IN REGISTERWORDENUMPROCW, IN LPCWSTR lpszReading, IN DWORD, IN LPCWSTR lpszRegister, IN LPVOID);
#ifdef UNICODE
#define ImmEnumRegisterWord  ImmEnumRegisterWordW
#else
#define ImmEnumRegisterWord  ImmEnumRegisterWordA
#endif // !UNICODE

#if (WINVER >= 0x040A)
BOOL WINAPI ImmDisableIME(IN DWORD);
BOOL WINAPI ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);
DWORD WINAPI ImmGetImeMenuItemsA(IN HIMC, IN DWORD, IN DWORD, OUT LPIMEMENUITEMINFOA, OUT LPIMEMENUITEMINFOA, IN DWORD);
DWORD WINAPI ImmGetImeMenuItemsW(IN HIMC, IN DWORD, IN DWORD, OUT LPIMEMENUITEMINFOW, OUT LPIMEMENUITEMINFOW, IN DWORD);
#ifdef UNICODE
#define ImmGetImeMenuItems  ImmGetImeMenuItemsW
#else
#define ImmGetImeMenuItems  ImmGetImeMenuItemsA
#endif // !UNICODE

BOOL WINAPI ImmDisableTextFrameService(DWORD idThread);
#endif /* WINVER >= 0x040A */

// wParam for WM_IME_CONTROL
#define IMC_GETCANDIDATEPOS             0x0007
#define IMC_SETCANDIDATEPOS             0x0008
#define IMC_GETCOMPOSITIONFONT          0x0009
#define IMC_SETCOMPOSITIONFONT          0x000A
#define IMC_GETCOMPOSITIONWINDOW        0x000B
#define IMC_SETCOMPOSITIONWINDOW        0x000C
#define IMC_GETSTATUSWINDOWPOS          0x000F
#define IMC_SETSTATUSWINDOWPOS          0x0010
#define IMC_CLOSESTATUSWINDOW           0x0021
#define IMC_OPENSTATUSWINDOW            0x0022


// dwAction for ImmNotifyIME
#define NI_OPENCANDIDATE                0x0010
#define NI_CLOSECANDIDATE               0x0011
#define NI_SELECTCANDIDATESTR           0x0012
#define NI_CHANGECANDIDATELIST          0x0013
#define NI_FINALIZECONVERSIONRESULT     0x0014
#define NI_COMPOSITIONSTR               0x0015
#define NI_SETCANDIDATE_PAGESTART       0x0016
#define NI_SETCANDIDATE_PAGESIZE        0x0017
#define NI_IMEMENUSELECTED              0x0018

// lParam for WM_IME_SETCONTEXT
#define ISC_SHOWUICANDIDATEWINDOW       0x00000001
#define ISC_SHOWUICOMPOSITIONWINDOW     0x80000000
#define ISC_SHOWUIGUIDELINE             0x40000000
#define ISC_SHOWUIALLCANDIDATEWINDOW    0x0000000F
#define ISC_SHOWUIALL                   0xC000000F


// dwIndex for ImmNotifyIME/NI_COMPOSITIONSTR
#define CPS_COMPLETE                    0x0001
#define CPS_CONVERT                     0x0002
#define CPS_REVERT                      0x0003
#define CPS_CANCEL                      0x0004

// the modifiers of hot key
#define MOD_ALT                         0x0001
#define MOD_CONTROL                     0x0002
#define MOD_SHIFT                       0x0004

#define MOD_LEFT                        0x8000
#define MOD_RIGHT                       0x4000

#define MOD_ON_KEYUP                    0x0800
#define MOD_IGNORE_ALL_MODIFIER         0x0400

// Windows for Simplified Chinese Edition hot key ID from 0x10 - 0x2F
#define IME_CHOTKEY_IME_NONIME_TOGGLE           0x10
#define IME_CHOTKEY_SHAPE_TOGGLE                0x11
#define IME_CHOTKEY_SYMBOL_TOGGLE               0x12

// Windows for Japanese Edition hot key ID from 0x30 - 0x4F
#define IME_JHOTKEY_CLOSE_OPEN                  0x30

// Windows for Korean Edition hot key ID from 0x50 - 0x6F
#define IME_KHOTKEY_SHAPE_TOGGLE                0x50
#define IME_KHOTKEY_HANJACONVERT                0x51
#define IME_KHOTKEY_ENGLISH                     0x52

// Windows for Traditional Chinese Edition hot key ID from 0x70 - 0x8F
#define IME_THOTKEY_IME_NONIME_TOGGLE           0x70
#define IME_THOTKEY_SHAPE_TOGGLE                0x71
#define IME_THOTKEY_SYMBOL_TOGGLE               0x72

// direct switch hot key ID from 0x100 - 0x11F
#define IME_HOTKEY_DSWITCH_FIRST                0x100
#define IME_HOTKEY_DSWITCH_LAST                 0x11F

// IME private hot key from 0x200 - 0x21F
#define IME_HOTKEY_PRIVATE_FIRST                0x200
#define IME_ITHOTKEY_RESEND_RESULTSTR           0x200
#define IME_ITHOTKEY_PREVIOUS_COMPOSITION       0x201
#define IME_ITHOTKEY_UISTYLE_TOGGLE             0x202
#define IME_ITHOTKEY_RECONVERTSTRING            0x203
#define IME_HOTKEY_PRIVATE_LAST                 0x21F


// parameter of ImmGetCompositionString
#define GCS_COMPREADSTR                 0x0001
#define GCS_COMPREADATTR                0x0002
#define GCS_COMPREADCLAUSE              0x0004
#define GCS_COMPSTR                     0x0008
#define GCS_COMPATTR                    0x0010
#define GCS_COMPCLAUSE                  0x0020
#define GCS_CURSORPOS                   0x0080
#define GCS_DELTASTART                  0x0100
#define GCS_RESULTREADSTR               0x0200
#define GCS_RESULTREADCLAUSE            0x0400
#define GCS_RESULTSTR                   0x0800
#define GCS_RESULTCLAUSE                0x1000

// style bit flags for WM_IME_COMPOSITION
#define CS_INSERTCHAR                   0x2000
#define CS_NOMOVECARET                  0x4000


// IME version constants
#define IMEVER_0310                     0x0003000A
#define IMEVER_0400                     0x00040000


// IME property bits
#define IME_PROP_AT_CARET               0x00010000
#define IME_PROP_SPECIAL_UI             0x00020000
#define IME_PROP_CANDLIST_START_FROM_1  0x00040000
#define IME_PROP_UNICODE                0x00080000
#define IME_PROP_COMPLETE_ON_UNSELECT   0x00100000


// IME UICapability bits
#define UI_CAP_2700                     0x00000001
#define UI_CAP_ROT90                    0x00000002
#define UI_CAP_ROTANY                   0x00000004

// ImmSetCompositionString Capability bits
#define SCS_CAP_COMPSTR                 0x00000001
#define SCS_CAP_MAKEREAD                0x00000002
#define SCS_CAP_SETRECONVERTSTRING      0x00000004


// IME WM_IME_SELECT inheritance Capability bits
#define SELECT_CAP_CONVERSION           0x00000001
#define SELECT_CAP_SENTENCE             0x00000002


// ID for deIndex of ImmGetGuideLine
#define GGL_LEVEL                       0x00000001
#define GGL_INDEX                       0x00000002
#define GGL_STRING                      0x00000003
#define GGL_PRIVATE                     0x00000004


// ID for dwLevel of GUIDELINE Structure
#define GL_LEVEL_NOGUIDELINE            0x00000000
#define GL_LEVEL_FATAL                  0x00000001
#define GL_LEVEL_ERROR                  0x00000002
#define GL_LEVEL_WARNING                0x00000003
#define GL_LEVEL_INFORMATION            0x00000004


// ID for dwIndex of GUIDELINE Structure
#define GL_ID_UNKNOWN                   0x00000000
#define GL_ID_NOMODULE                  0x00000001
#define GL_ID_NODICTIONARY              0x00000010
#define GL_ID_CANNOTSAVE                0x00000011
#define GL_ID_NOCONVERT                 0x00000020
#define GL_ID_TYPINGERROR               0x00000021
#define GL_ID_TOOMANYSTROKE             0x00000022
#define GL_ID_READINGCONFLICT           0x00000023
#define GL_ID_INPUTREADING              0x00000024
#define GL_ID_INPUTRADICAL              0x00000025
#define GL_ID_INPUTCODE                 0x00000026
#define GL_ID_INPUTSYMBOL               0x00000027
#define GL_ID_CHOOSECANDIDATE           0x00000028
#define GL_ID_REVERSECONVERSION         0x00000029
#define GL_ID_PRIVATE_FIRST             0x00008000
#define GL_ID_PRIVATE_LAST              0x0000FFFF


// ID for dwIndex of ImmGetProperty
#define IGP_GETIMEVERSION               (DWORD)(-4)
#define IGP_PROPERTY                    0x00000004
#define IGP_CONVERSION                  0x00000008
#define IGP_SENTENCE                    0x0000000c
#define IGP_UI                          0x00000010
#define IGP_SETCOMPSTR                  0x00000014
#define IGP_SELECT                      0x00000018

// dwIndex for ImmSetCompositionString API
#define SCS_SETSTR                      (GCS_COMPREADSTR|GCS_COMPSTR)
#define SCS_CHANGEATTR                  (GCS_COMPREADATTR|GCS_COMPATTR)
#define SCS_CHANGECLAUSE                (GCS_COMPREADCLAUSE|GCS_COMPCLAUSE)
#define SCS_SETRECONVERTSTRING          0x00010000
#define SCS_QUERYRECONVERTSTRING        0x00020000

// attribute for COMPOSITIONSTRING Structure
#define ATTR_INPUT                      0x00
#define ATTR_TARGET_CONVERTED           0x01
#define ATTR_CONVERTED                  0x02
#define ATTR_TARGET_NOTCONVERTED        0x03
#define ATTR_INPUT_ERROR                0x04
#define ATTR_FIXEDCONVERTED             0x05

// bit field for IMC_SETCOMPOSITIONWINDOW, IMC_SETCANDIDATEWINDOW
#define CFS_DEFAULT                     0x0000
#define CFS_RECT                        0x0001
#define CFS_POINT                       0x0002
#define CFS_FORCE_POSITION              0x0020
#define CFS_CANDIDATEPOS                0x0040
#define CFS_EXCLUDE                     0x0080

// conversion direction for ImmGetConversionList
#define GCL_CONVERSION                  0x0001
#define GCL_REVERSECONVERSION           0x0002
#define GCL_REVERSE_LENGTH              0x0003

// bit field for conversion mode
#define IME_CMODE_ALPHANUMERIC          0x0000
#define IME_CMODE_NATIVE                0x0001
#define IME_CMODE_CHINESE               IME_CMODE_NATIVE
// IME_CMODE_HANGEUL is old name of IME_CMODE_HANGUL. It will be gone eventually.
#define IME_CMODE_HANGEUL               IME_CMODE_NATIVE
#define IME_CMODE_HANGUL                IME_CMODE_NATIVE
#define IME_CMODE_JAPANESE              IME_CMODE_NATIVE
#define IME_CMODE_KATAKANA              0x0002  // only effect under IME_CMODE_NATIVE
#define IME_CMODE_LANGUAGE              0x0003
#define IME_CMODE_FULLSHAPE             0x0008
#define IME_CMODE_ROMAN                 0x0010
#define IME_CMODE_CHARCODE              0x0020
#define IME_CMODE_HANJACONVERT          0x0040
#define IME_CMODE_SOFTKBD               0x0080
#define IME_CMODE_NOCONVERSION          0x0100
#define IME_CMODE_EUDC                  0x0200
#define IME_CMODE_SYMBOL                0x0400
#define IME_CMODE_FIXED                 0x0800
#define IME_CMODE_RESERVED          0xF0000000

// bit field for sentence mode
#define IME_SMODE_NONE                  0x0000
#define IME_SMODE_PLAURALCLAUSE         0x0001
#define IME_SMODE_SINGLECONVERT         0x0002
#define IME_SMODE_AUTOMATIC             0x0004
#define IME_SMODE_PHRASEPREDICT         0x0008
#define IME_SMODE_CONVERSATION          0x0010
#define IME_SMODE_RESERVED          0x0000F000


// style of candidate
#define IME_CAND_UNKNOWN                0x0000
#define IME_CAND_READ                   0x0001
#define IME_CAND_CODE                   0x0002
#define IME_CAND_MEANING                0x0003
#define IME_CAND_RADICAL                0x0004
#define IME_CAND_STROKE                 0x0005

// wParam of report message WM_IME_NOTIFY
#define IMN_CLOSESTATUSWINDOW           0x0001
#define IMN_OPENSTATUSWINDOW            0x0002
#define IMN_CHANGECANDIDATE             0x0003
#define IMN_CLOSECANDIDATE              0x0004
#define IMN_OPENCANDIDATE               0x0005
#define IMN_SETCONVERSIONMODE           0x0006
#define IMN_SETSENTENCEMODE             0x0007
#define IMN_SETOPENSTATUS               0x0008
#define IMN_SETCANDIDATEPOS             0x0009
#define IMN_SETCOMPOSITIONFONT          0x000A
#define IMN_SETCOMPOSITIONWINDOW        0x000B
#define IMN_SETSTATUSWINDOWPOS          0x000C
#define IMN_GUIDELINE                   0x000D
#define IMN_PRIVATE                     0x000E

#if (WINVER >= 0x040A)
// wParam of report message WM_IME_REQUEST
#define IMR_COMPOSITIONWINDOW           0x0001
#define IMR_CANDIDATEWINDOW             0x0002
#define IMR_COMPOSITIONFONT             0x0003
#define IMR_RECONVERTSTRING             0x0004
#define IMR_CONFIRMRECONVERTSTRING      0x0005
#define IMR_QUERYCHARPOSITION           0x0006
#define IMR_DOCUMENTFEED                0x0007
#endif /* WINVER >= 0x040A */

// error code of ImmGetCompositionString
#define IMM_ERROR_NODATA                (-1)
#define IMM_ERROR_GENERAL               (-2)


// dialog mode of ImmConfigureIME
#define IME_CONFIG_GENERAL              1
#define IME_CONFIG_REGISTERWORD         2
#define IME_CONFIG_SELECTDICTIONARY     3


// flags for ImmEscape
#define IME_ESC_QUERY_SUPPORT           0x0003
#define IME_ESC_RESERVED_FIRST          0x0004
#define IME_ESC_RESERVED_LAST           0x07FF
#define IME_ESC_PRIVATE_FIRST           0x0800
#define IME_ESC_PRIVATE_LAST            0x0FFF

#define IME_ESC_SEQUENCE_TO_INTERNAL    0x1001
#define IME_ESC_GET_EUDC_DICTIONARY     0x1003
#define IME_ESC_SET_EUDC_DICTIONARY     0x1004
#define IME_ESC_MAX_KEY                 0x1005
#define IME_ESC_IME_NAME                0x1006
#define IME_ESC_SYNC_HOTKEY             0x1007
#define IME_ESC_HANJA_MODE              0x1008
#define IME_ESC_AUTOMATA                0x1009
#define IME_ESC_PRIVATE_HOTKEY          0x100a
#define IME_ESC_GETHELPFILENAME         0x100b

// style of word registration
#define IME_REGWORD_STYLE_EUDC          0x00000001
#define IME_REGWORD_STYLE_USER_FIRST    0x80000000
#define IME_REGWORD_STYLE_USER_LAST     0xFFFFFFFF


#if (WINVER >= 0x040A)

// dwFlags for ImmAssociateContextEx
#define IACE_CHILDREN                   0x0001
#define IACE_DEFAULT                    0x0010
#define IACE_IGNORENOCONTEXT            0x0020

// dwFlags for ImmGetImeMenuItems
#define IGIMIF_RIGHTMENU                0x0001

// dwType for ImmGetImeMenuItems
#define IGIMII_CMODE                    0x0001
#define IGIMII_SMODE                    0x0002
#define IGIMII_CONFIGURE                0x0004
#define IGIMII_TOOLS                    0x0008
#define IGIMII_HELP                     0x0010
#define IGIMII_OTHER                    0x0020
#define IGIMII_INPUTTOOLS               0x0040

// fType of IMEMENUITEMINFO structure
#define IMFT_RADIOCHECK 0x00001
#define IMFT_SEPARATOR  0x00002
#define IMFT_SUBMENU    0x00004

// fState of IMEMENUITEMINFO structure
#define IMFS_GRAYED          MFS_GRAYED
#define IMFS_DISABLED        MFS_DISABLED
#define IMFS_CHECKED         MFS_CHECKED
#define IMFS_HILITE          MFS_HILITE
#define IMFS_ENABLED         MFS_ENABLED
#define IMFS_UNCHECKED       MFS_UNCHECKED
#define IMFS_UNHILITE        MFS_UNHILITE
#define IMFS_DEFAULT         MFS_DEFAULT

#endif /* WINVER >= 0x040A */

// type of soft keyboard
// for Windows Tranditional Chinese Edition
#define SOFTKEYBOARD_TYPE_T1            0x0001
// for Windows Simplified Chinese Edition
#define SOFTKEYBOARD_TYPE_C1            0x0002


#endif  // _IMM_SDK_DEFINED_

#ifndef _IMM_DDK_DEFINED_
#define _IMM_DDK_DEFINED_

typedef struct tagCOMPOSITIONSTRING {
    DWORD dwSize;
    DWORD dwCompReadAttrLen;
    DWORD dwCompReadAttrOffset;
    DWORD dwCompReadClauseLen;
    DWORD dwCompReadClauseOffset;
    DWORD dwCompReadStrLen;
    DWORD dwCompReadStrOffset;
    DWORD dwCompAttrLen;
    DWORD dwCompAttrOffset;
    DWORD dwCompClauseLen;
    DWORD dwCompClauseOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwCursorPos;
    DWORD dwDeltaStart;
    DWORD dwResultReadClauseLen;
    DWORD dwResultReadClauseOffset;
    DWORD dwResultReadStrLen;
    DWORD dwResultReadStrOffset;
    DWORD dwResultClauseLen;
    DWORD dwResultClauseOffset;
    DWORD dwResultStrLen;
    DWORD dwResultStrOffset;
    DWORD dwPrivateSize;
    DWORD dwPrivateOffset;
} COMPOSITIONSTRING, *PCOMPOSITIONSTRING, NEAR *NPCOMPOSITIONSTRING, FAR  *LPCOMPOSITIONSTRING;

typedef struct tagGUIDELINE {
    DWORD dwSize;
    DWORD dwLevel;
    DWORD dwIndex;
    DWORD dwStrLen;
    DWORD dwStrOffset;
    DWORD dwPrivateSize;
    DWORD dwPrivateOffset;
} GUIDELINE, *PGUIDELINE, NEAR *NPGUIDELINE, FAR *LPGUIDELINE;

#if (WINVER >= 0x040A)

typedef struct tagTRANSMSG {
    UINT   message;
    WPARAM wParam;
    LPARAM lParam;
} TRANSMSG, *PTRANSMSG, NEAR *NPTRANSMSG, FAR *LPTRANSMSG;

typedef struct tagTRANSMSGLIST {
    UINT     uMsgCount;
    TRANSMSG TransMsg[1];
} TRANSMSGLIST, *PTRANSMSGLIST, NEAR *NPTRANSMSGLIST, FAR *LPTRANSMSGLIST;

#endif /* WINVER >= 0x040A */

typedef struct tagCANDIDATEINFO {
    DWORD               dwSize;
    DWORD               dwCount;
    DWORD               dwOffset[32];
    DWORD               dwPrivateSize;
    DWORD               dwPrivateOffset;
} CANDIDATEINFO, *PCANDIDATEINFO, NEAR *NPCANDIDATEINFO, FAR *LPCANDIDATEINFO;



typedef struct tagIMEINFO {
    DWORD       dwPrivateDataSize;
    DWORD       fdwProperty;
    DWORD       fdwConversionCaps;
    DWORD       fdwSentenceCaps;
    DWORD       fdwUICaps;
    DWORD       fdwSCSCaps;
    DWORD       fdwSelectCaps;
} IMEINFO, *PIMEINFO, NEAR *NPIMEINFO, FAR *LPIMEINFO;

typedef struct tagSOFTKBDDATA {
    UINT        uCount;
    WORD        wCode[1][256];
} SOFTKBDDATA, *PSOFTKBDDATA, NEAR *NPSOFTKBDDATA, FAR * LPSOFTKBDDATA;


BOOL WINAPI ImmGetHotKey(IN DWORD, OUT LPUINT lpuModifiers, OUT LPUINT lpuVKey, OUT LPHKL);
BOOL WINAPI ImmSetHotKey(IN DWORD, IN UINT, IN UINT, IN HKL);
BOOL WINAPI ImmGenerateMessage(IN HIMC);
#if (WINVER >= 0x040A)
LRESULT WINAPI ImmRequestMessageA(IN HIMC, IN WPARAM, IN LPARAM);
LRESULT WINAPI ImmRequestMessageW(IN HIMC, IN WPARAM, IN LPARAM);
#ifdef UNICODE
#define ImmRequestMessage  ImmRequestMessageW
#else
#define ImmRequestMessage  ImmRequestMessageA
#endif // !UNICODE
#endif /* WINVER >= 0x040A */

//
// Prototype of soft keyboard APIs
//

HWND WINAPI ImmCreateSoftKeyboard(IN UINT, IN HWND, IN int, IN int);
BOOL WINAPI ImmDestroySoftKeyboard(IN HWND);
BOOL WINAPI ImmShowSoftKeyboard(IN HWND, IN int);

BOOL  WINAPI ImmUnlockIMC(IN HIMC);
DWORD WINAPI ImmGetIMCLockCount(IN HIMC);

HIMCC  WINAPI ImmCreateIMCC(IN DWORD);
HIMCC  WINAPI ImmDestroyIMCC(IN HIMCC);
LPVOID WINAPI ImmLockIMCC(IN HIMCC);
BOOL   WINAPI ImmUnlockIMCC(IN HIMCC);
DWORD  WINAPI ImmGetIMCCLockCount(IN HIMCC);
HIMCC  WINAPI ImmReSizeIMCC(IN HIMCC, IN DWORD);
DWORD  WINAPI ImmGetIMCCSize(IN HIMCC);

// the window extra offset
#define IMMGWL_IMC                      0
#define IMMGWL_PRIVATE                  (sizeof(LONG))

#ifdef _WIN64
#undef IMMGWL_IMC
#undef IMMGWL_PRIVATE
#endif /* _WIN64 */

#define IMMGWLP_IMC                     0
#define IMMGWLP_PRIVATE                 (sizeof(LONG_PTR))


// for NI_CONTEXTUPDATED
#define IMC_SETCONVERSIONMODE           0x0002
#define IMC_SETSENTENCEMODE             0x0004
#define IMC_SETOPENSTATUS               0x0006

// wParam for WM_IME_CONTROL to the soft keyboard
#define IMC_GETSOFTKBDFONT              0x0011
#define IMC_SETSOFTKBDFONT              0x0012
#define IMC_GETSOFTKBDPOS               0x0013
#define IMC_SETSOFTKBDPOS               0x0014
#define IMC_GETSOFTKBDSUBTYPE           0x0015
#define IMC_SETSOFTKBDSUBTYPE           0x0016
#define IMC_SETSOFTKBDDATA              0x0018


// dwAction for ImmNotifyIME
#define NI_CONTEXTUPDATED               0x0003
// dwSystemInfoFlags bits
#define IME_SYSINFO_WINLOGON            0x0001
#define IME_SYSINFO_WOW16               0x0002

#define GCS_COMP                        (GCS_COMPSTR|GCS_COMPATTR|GCS_COMPCLAUSE)
#define GCS_COMPREAD                    (GCS_COMPREADSTR|GCS_COMPREADATTR |GCS_COMPREADCLAUSE)
#define GCS_RESULT                      (GCS_RESULTSTR|GCS_RESULTCLAUSE)
#define GCS_RESULTREAD                  (GCS_RESULTREADSTR|GCS_RESULTREADCLAUSE)


// bits of fdwInit of INPUTCONTEXT
#define INIT_STATUSWNDPOS               0x00000001
#define INIT_CONVERSION                 0x00000002
#define INIT_SENTENCE                   0x00000004
#define INIT_LOGFONT                    0x00000008
#define INIT_COMPFORM                   0x00000010
#define INIT_SOFTKBDPOS                 0x00000020


// IME property bits
#define IME_PROP_END_UNLOAD             0x00000001
#define IME_PROP_KBD_CHAR_FIRST         0x00000002
#define IME_PROP_IGNORE_UPKEYS          0x00000004
#define IME_PROP_NEED_ALTKEY            0x00000008
#define IME_PROP_NO_KEYS_ON_CLOSE       0x00000010
#define IME_PROP_ACCEPT_WIDE_VKEY       0x00000020

// IME UICapability bits
#define UI_CAP_SOFTKBD                  0x00010000

#define IMN_SOFTKBDDESTROYED            0x0011


// flags for ImmEscape
// prototype of IME APIs
BOOL    WINAPI ImeInquire(IN LPIMEINFO, OUT LPTSTR lpszUIClass, IN DWORD dwSystemInfoFlags);
BOOL    WINAPI ImeConfigure(IN HKL, IN HWND, IN DWORD, IN LPVOID);
DWORD   WINAPI ImeConversionList(HIMC, LPCTSTR, LPCANDIDATELIST, DWORD dwBufLen, UINT uFlag);
BOOL    WINAPI ImeDestroy(UINT);
LRESULT WINAPI ImeEscape(HIMC, UINT, LPVOID);
BOOL    WINAPI ImeProcessKey(IN HIMC, IN UINT, IN LPARAM, IN CONST LPBYTE);
BOOL    WINAPI ImeSelect(IN HIMC, IN BOOL);
BOOL    WINAPI ImeSetActiveContext(IN HIMC, IN BOOL);
#if (WINVER >= 0x040A)
UINT    WINAPI ImeToAsciiEx(IN UINT uVirtKey, IN UINT uScaCode, IN CONST LPBYTE lpbKeyState, OUT LPTRANSMSGLIST lpTransBuf, IN UINT fuState, IN HIMC);
#else
UINT    WINAPI ImeToAsciiEx(IN UINT uVirtKey, IN UINT uScaCode, IN CONST LPBYTE lpbKeyState, OUT LPDWORD lpdwTransBuf, IN UINT fuState, IN HIMC);
#endif /* WINVER >= 0x040A */
BOOL    WINAPI NotifyIME(IN HIMC, IN DWORD, IN DWORD, IN DWORD);
BOOL    WINAPI ImeRegisterWord(IN LPCTSTR, IN DWORD, IN LPCTSTR);
BOOL    WINAPI ImeUnregisterWord(IN LPCTSTR, IN DWORD, IN LPCTSTR);
UINT    WINAPI ImeGetRegisterWordStyle(IN UINT nItem, OUT LPSTYLEBUF);
UINT    WINAPI ImeEnumRegisterWord(IN REGISTERWORDENUMPROC, IN LPCTSTR, IN DWORD, IN LPCTSTR, IN LPVOID);
BOOL    WINAPI ImeSetCompositionString(IN HIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD, IN LPVOID lpRead, IN DWORD);

#endif  // _IMM_DDK_DEFINED_


#if defined(_WINGDI_) && !defined(NOGDI)
typedef struct tagINPUTCONTEXT {
    HWND                hWnd;
    BOOL                fOpen;
    POINT               ptStatusWndPos;
    POINT               ptSoftKbdPos;
    DWORD               fdwConversion;
    DWORD               fdwSentence;
    union   {
        LOGFONTA        A;
        LOGFONTW        W;
    } lfFont;
    COMPOSITIONFORM     cfCompForm;
    CANDIDATEFORM       cfCandForm[4];
    HIMCC               hCompStr;
    HIMCC               hCandInfo;
    HIMCC               hGuideLine;
    HIMCC               hPrivate;
    DWORD               dwNumMsgBuf;
    HIMCC               hMsgBuf;
    DWORD               fdwInit;
    DWORD               dwReserve[3];
    UINT                uSavedVKey;
    BOOL                fChgMsg;
    DWORD               fdwFlags;
    DWORD               fdw31Compat;
    DWORD               dwRefCount;
    PVOID               pImeModeSaver;
    DWORD               fdwDirty;
#ifdef CUAS_ENABLE
    HIMCC               hCtfImeContext;
#endif // CUAS_ENABLE
} INPUTCONTEXT, *PINPUTCONTEXT, NEAR *NPINPUTCONTEXT, FAR *LPINPUTCONTEXT;
#endif
#ifdef CUAS_ENABLE
/////////////////////////////////////////////////////////////////////////////
// GUID attribute (IME share)
//     COMPOSITIONSTRING->dwPrivateSize = sizeof(GUIDMAPATTRIBUTE) + actual data array.
//     GUIDMAPATTRIBUTE* = GetOffset(COMPOSITIONSTRING->dwPrivateOffset)

typedef struct tagGUIDMAPATTRIBUTE {
    //
    // IME share of GUID map attribute.
    //
    DWORD               dwTfGuidAtomLen;
    DWORD               dwTfGuidAtomOffset;        // Offset based on GUIDMAPATTRIBUTE struct.
    //
    DWORD               dwGuidMapAttrLen;
    DWORD               dwGuidMapAttrOffset;       // Offset based on GUIDMAPATTRIBUTE struct.
} GUIDMAPATTRIBUTE, *PGUIDMAPATTRIBUTE;
#endif // CUAS_ENABLE



#if defined(_WINGDI_) && !defined(NOGDI)
LPINPUTCONTEXT WINAPI ImmLockIMC(IN HIMC);
#endif
#if (WINVER >= 0x040A)
#ifdef CUAS_ENABLE
//
// Prototype of Cicero Unaware
//
HRESULT WINAPI CtfImmGetGuidAtom(IN HIMC, IN BYTE, OUT DWORD*);
BOOL    WINAPI CtfImmIsGuidMapEnable(IN HIMC);

BOOL    WINAPI CtfImmIsCiceroEnabled();
BOOL    WINAPI CtfImmIsTextFrameServiceDisabled();

BOOL    WINAPI CtfImmIsCiceroStartedInThread();
HRESULT WINAPI CtfImmSetCiceroStartInThread(BOOL fSet);

UINT    WINAPI GetKeyboardLayoutCP(HKL hKL);

DWORD   WINAPI ImmGetAppCompatFlags(HIMC hIMC);
VOID    WINAPI CtfImmSetAppCompatFlags(DWORD dwFlag);

HRESULT WINAPI CtfAImmActivate(HMODULE* phMod);
HRESULT WINAPI CtfAImmDeactivate(HMODULE hMod);

BOOL    WINAPI CtfImmGenerateMessage(IN HIMC, BOOL fSendMsg);
#endif // CUAS_ENABLE
#endif /* WINVER >= 0x040A */



// wParam for WM_IME_CONTROL
#define IMC_FIRST                       0x0000

// 0x11 - 0x20 is reserved for soft keyboard

#define IMC_LAST                        0x0022

// wParam for WM_IME_SYSTEM
#define IMS_DESTROYWINDOW               0x0001
#define IMS_IME31COMPATIBLE             0x0002
#define IMS_SETOPENSTATUS               0x0003
#define IMS_SETACTIVECONTEXT            0x0004
#define IMS_CHANGE_SHOWSTAT             0x0005
#define IMS_WINDOWPOS                   0x0006


#define IMS_SENDIMEMSG                  0x0007
#define IMS_SENDIMEMSGEX                0x0008
#define IMS_SETCANDIDATEPOS             0x0009
#define IMS_SETCOMPOSITIONFONT          0x000A
#define IMS_SETCOMPOSITIONWINDOW        0x000B
#define IMS_CHECKENABLE                 0x000C
#define IMS_CONFIGUREIME                0x000D
#define IMS_CONTROLIMEMSG               0x000E
#define IMS_SETOPENCLOSE                0x000F
#define IMS_ISACTIVATED                 0x0010
#define IMS_UNLOADTHREADLAYOUT          0x0011
#define IMS_LCHGREQUEST                 0x0012
#define IMS_SETSOFTKBDONOFF             0x0013
#define IMS_GETCONVERSIONMODE           0x0014
#define IMS_IMEHELP                     0x0015

#define IMS_IMENT35SENDAPPMSG           0x0016
#define IMS_ACTIVATECONTEXT             0x0017
#define IMS_DEACTIVATECONTEXT           0x0018
#define IMS_ACTIVATETHREADLAYOUT        0x0019
#define IMS_CLOSEPROPERTYWINDOW         0x001a
#define IMS_OPENPROPERTYWINDOW          0x001b

#define IMS_GETIMEMENU                  0x001c
#define IMS_ENDIMEMENU                  0x001d

#define IMS_GETCONTEXT                  0x001e

#define IMS_SENDNOTIFICATION            0x001f
// IMS_SENDNOTIFICATION dirty bits for INPUTCONTEXT
 #define IMSS_UPDATE_OPEN               0x0001
 #define IMSS_UPDATE_CONVERSION         0x0002
 #define IMSS_UPDATE_SENTENCE           0x0004
 #define IMSS_INIT_OPEN                 0x0100

#define IMS_FINALIZE_COMPSTR            0x0020
#ifdef CUAS_ENABLE
#define IMS_LOADTHREADLAYOUT            0x0021
#define IMS_SETLANGBAND                 0x0023
#define IMS_RESETLANGBAND               0x0024
#endif // CUAS_ENABLE

// for NI_CONTEXTUPDATED
#define IMC_GETCONVERSIONMODE           0x0001
#define IMC_GETSENTENCEMODE             0x0003
#define IMC_GETOPENSTATUS               0x0005
// the return bits of ImmProcessHotKey
#define IPHK_HOTKEY                     0x0001
#define IPHK_PROCESSBYIME               0x0002
#define IPHK_CHECKCTRL                  0x0004
// NT only
#define IPHK_SKIPTHISKEY                0x0010

// the modifiers of hot key
#define MOD_WIN                         0x0008

// IME Hotkeys internal definitions
#define IME_CHOTKEY_FIRST                       0x10
#define IME_CHOTKEY_LAST                        0x2f
#define IME_JHOTKEY_FIRST                       0x30
#define IME_JHOTKEY_LAST                        0x4f
#define IME_KHOTKEY_FIRST                       0x50
#define IME_KHOTKEY_LAST                        0x6f
#define IME_THOTKEY_FIRST                       0x70
#define IME_THOTKEY_LAST                        0x8f
#define IME_INVALID_HOTKEY                      0xffffffff
#ifdef CUAS_ENABLE
#define GCS_COMPGUIDATTR                0x8000
#endif // CUAS_ENABLE
#ifdef CUAS_ENABLE
// bits of fdwInit of INPUTCONTEXT
#define INIT_GUID_ATOM                  0x00000040
#endif // CUAS_ENABLE

// fdw31Compat of INPUTCONTEXT
#define F31COMPAT_NOKEYTOIME     0x00000001
#define F31COMPAT_MCWHIDDEN      0x00000002
#define F31COMPAT_MCWVERTICAL    0x00000004
#define F31COMPAT_CALLFROMWINNLS 0x00000008
#define F31COMPAT_SAVECTRL       0x00010000
#define F31COMPAT_PROCESSEVENT   0x00020000
#define F31COMPAT_ECSETCFS       0x00040000

// the return value of ImmGetAppIMECompatFlags
#define IMECOMPAT_UNSYNC31IMEMSG 0x00000001
// the meaning of this bit depend on the same bit in
// IMELinkHdr.ctCountry.fdFlags
#define IMECOMPAT_DUMMYTASK      0x00000002
// For Japanese and Hangeul versions, this bit on
// indicates no dummy task is needed
#define IMECOMPAT_NODUMMYTASK    IMECOMPAT_DUMMYTASK
// For Chinese and PRC versions, this bit on indicates
// a dummy tasked is needed
#define IMECOMPAT_NEEDDUMMYTASK  IMECOMPAT_DUMMYTASK
#define IMECOMPAT_POSTDUMMY      0x00000004
#define IMECOMPAT_ECNOFLUSH      0x00000008
#define IMECOMPAT_NOINPUTLANGCHGTODLG   0x00000010
#define IMECOMPAT_ECREDRAWPARENT        0x00000020
#define IMECOMPAT_SENDOLDSBM            0x00000040
#define IMECOMPAT_UNSYNC31IMEMSG2       0x00000080
#define IMECOMPAT_NOIMEMSGINTERTASK     0x00000100
#define IMECOMPAT_USEXWANSUNG           0x00000200
#define IMECOMPAT_JXWFORATOK            0x00000400
#define IMECOMPAT_NOIME                 0x00000800
#define IMECOMPAT_NOKBDHOOK             0x00001000
#define IMECOMPAT_APPWNDREMOVEIMEMSGS   0x00002000
#define IMECOMPAT_LSTRCMP31COMPATIBLE   0x00004000
#define IMECOMPAT_USEALTSTKFORSHLEXEC   0x00008000
#define IMECOMPAT_NOVKPROCESSKEY        0x00010000
#define IMECOMPAT_NOYIELDWMCHAR         0x00020000
#define IMECOMPAT_SENDSC_RESTORE        0x00040000
#define IMECOMPAT_NOSENDLANGCHG         0x00080000
#define IMECOMPAT_FORCEUNSYNC31IMEMSG   0x00100000
#define IMECOMPAT_CONSOLEIMEPROCESS     0x00200000

//
// KOR only: do not finalize the composition
// string on mouse click
//
#define IMECOMPAT_NOFINALIZECOMPSTR     0x00400000

//
// Terminal Server Client (MSTSC.EXE) only:
//  If client machine connected Fujitsu Oasys keyboard, disable NlsKbdSendIMENotification call
//
#define IMECOMPAT_HYDRACLIENT           0x00800000

#ifdef CUAS_ENABLE
//
// Cicero Unaware Support
//    per process information
//
#define IMECOMPAT_AIMM_LEGACY_CLSID     0x01000000
#define IMECOMPAT_AIMM_TRIDENT55        0x02000000
#define IMECOMPAT_AIMM12_TRIDENT        0x04000000
#define IMECOMPAT_AIMM12                0x08000000
#endif // CUAS_ENABLE




#define IMGTF_CANT_SWITCH_LAYOUT        0x00000001
#define IMGTF_CANT_UNLOAD_IME           0x00000002

// all IME property bits, anyone add a new bit must update this !!!
#define IME_PROP_ALL                    0x001F003F
// all IME UICapability bits, anyone add a new bit must update this !!!
#define UI_CAP_ALL                      0x00010007
// ImmSetCompositionString Capability bits
// all ImmSetCompositionString Capability bits !!!
#define SCS_CAP_ALL                     0x00000007
// all IME WM_IME_SELECT inheritance Capability bits !!!
#define SELECT_CAP_ALL                  0x00000003
// ID for dwIndex of ImmGetProperty
// The value is the offset of IMEINFO structure
// last property index, anyone add a new property index must update this !!!
#define IGP_LAST                        IGP_SELECT
// bit field for IMC_SETCOMPOSITIONWINDOW, IMC_SETCANDIDATEWINDOW
#define CFS_SCREEN                      0x0004
#define CFS_VERTICAL                    0x0008
#define CFS_HIDDEN                      0x0010
// all conversion mode bits, anyone add a new bit must update this !!!
#define IME_CMODE_ALL                   0x0FFF
//
// This is extended NLS mode for console and console IME
//
#define IME_CMODE_OPEN              0x20000000
#define IME_CMODE_DISABLE           0x40000000

#ifdef CUAS_ENABLE
// bit field for extended conversion mode
#define IME_CMODE_GUID_NULL         0x80000000
#endif // CUAS_ENABLE
// all sentence mode bits, anyone add a new bit must update this !!!
#define IME_SMODE_ALL                   0x001F
#ifdef CUAS_ENABLE
// bit field for extended conversion mode
#define IME_SMODE_GUID_NULL         0x00008000
#endif // CUAS_ENABLE
#if (WINVER >= 0x040A)
#ifdef CUAS_ENABLE
// prototype of IME APIs for Cicero Bridge
HRESULT WINAPI CtfImeInquireEx(IN LPIMEINFO, OUT LPTSTR lpszUIClass, IN DWORD dwSystemInfoFlags, HKL hKL);
HRESULT WINAPI CtfImeCreateThreadMgr();
HRESULT WINAPI CtfImeDestroyThreadMgr();
HRESULT WINAPI CtfImeCreateInputContext(HIMC hImc);
HRESULT WINAPI CtfImeDestroyInputContext(HIMC hImc);
HRESULT WINAPI CtfImeSelectEx(HIMC hIMC, BOOL fSelect, HKL hKL);
HRESULT WINAPI CtfImeSetActiveContextAlways(HIMC hIMC, BOOL fOn, HWND hWnd, HKL hkl);
LRESULT WINAPI CtfImeEscapeEx(HIMC hIMC, UINT uSubFunc, LPVOID lpData, HKL hKL);
HRESULT WINAPI CtfImeGetGuidAtom(HIMC hIMC, BYTE bAttr, DWORD* pAtom);
BOOL    WINAPI CtfImeIsGuidMapEnable(HIMC hIMC);
BOOL    WINAPI CtfImeProcessCicHotkey(HIMC hIMC, UINT uVKey, LPARAM lParam);
#endif // CUAS_ENABLE
#endif /* WINVER >= 0x040A */

//
// nCode for MsctfCicNotify
//

#define CICN_LANGCHANGEHOTKEY 0x0001


#ifdef __cplusplus
}
#endif

#endif  // _IMMP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\msctfp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for msctfp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __msctfp_h__
#define __msctfp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITfThreadMgr_P_old_FWD_DEFINED__
#define __ITfThreadMgr_P_old_FWD_DEFINED__
typedef interface ITfThreadMgr_P_old ITfThreadMgr_P_old;
#endif 	/* __ITfThreadMgr_P_old_FWD_DEFINED__ */


#ifndef __ITfThreadMgr_P_FWD_DEFINED__
#define __ITfThreadMgr_P_FWD_DEFINED__
typedef interface ITfThreadMgr_P ITfThreadMgr_P;
#endif 	/* __ITfThreadMgr_P_FWD_DEFINED__ */


#ifndef __ITfKeystrokeMgr_P_FWD_DEFINED__
#define __ITfKeystrokeMgr_P_FWD_DEFINED__
typedef interface ITfKeystrokeMgr_P ITfKeystrokeMgr_P;
#endif 	/* __ITfKeystrokeMgr_P_FWD_DEFINED__ */


#ifndef __ITfSysHookSink_FWD_DEFINED__
#define __ITfSysHookSink_FWD_DEFINED__
typedef interface ITfSysHookSink ITfSysHookSink;
#endif 	/* __ITfSysHookSink_FWD_DEFINED__ */


#ifndef __ITfStartReconversionNotifySink_FWD_DEFINED__
#define __ITfStartReconversionNotifySink_FWD_DEFINED__
typedef interface ITfStartReconversionNotifySink ITfStartReconversionNotifySink;
#endif 	/* __ITfStartReconversionNotifySink_FWD_DEFINED__ */


#ifndef __ITfLangBarEventSink_P_FWD_DEFINED__
#define __ITfLangBarEventSink_P_FWD_DEFINED__
typedef interface ITfLangBarEventSink_P ITfLangBarEventSink_P;
#endif 	/* __ITfLangBarEventSink_P_FWD_DEFINED__ */


#ifndef __ITfLangBarMgr_P_FWD_DEFINED__
#define __ITfLangBarMgr_P_FWD_DEFINED__
typedef interface ITfLangBarMgr_P ITfLangBarMgr_P;
#endif 	/* __ITfLangBarMgr_P_FWD_DEFINED__ */


#ifndef __ITfContext_P_FWD_DEFINED__
#define __ITfContext_P_FWD_DEFINED__
typedef interface ITfContext_P ITfContext_P;
#endif 	/* __ITfContext_P_FWD_DEFINED__ */


#ifndef __ITfRangeChangeSink_FWD_DEFINED__
#define __ITfRangeChangeSink_FWD_DEFINED__
typedef interface ITfRangeChangeSink ITfRangeChangeSink;
#endif 	/* __ITfRangeChangeSink_FWD_DEFINED__ */


#ifndef __ITfFnAbort_FWD_DEFINED__
#define __ITfFnAbort_FWD_DEFINED__
typedef interface ITfFnAbort ITfFnAbort;
#endif 	/* __ITfFnAbort_FWD_DEFINED__ */


#ifndef __ITfMouseTrackerAnchor_FWD_DEFINED__
#define __ITfMouseTrackerAnchor_FWD_DEFINED__
typedef interface ITfMouseTrackerAnchor ITfMouseTrackerAnchor;
#endif 	/* __ITfMouseTrackerAnchor_FWD_DEFINED__ */


#ifndef __ITfRangeAnchor_FWD_DEFINED__
#define __ITfRangeAnchor_FWD_DEFINED__
typedef interface ITfRangeAnchor ITfRangeAnchor;
#endif 	/* __ITfRangeAnchor_FWD_DEFINED__ */


#ifndef __ITfPersistentPropertyLoaderAnchor_FWD_DEFINED__
#define __ITfPersistentPropertyLoaderAnchor_FWD_DEFINED__
typedef interface ITfPersistentPropertyLoaderAnchor ITfPersistentPropertyLoaderAnchor;
#endif 	/* __ITfPersistentPropertyLoaderAnchor_FWD_DEFINED__ */


#ifndef __ITextStoreAnchorServices_FWD_DEFINED__
#define __ITextStoreAnchorServices_FWD_DEFINED__
typedef interface ITextStoreAnchorServices ITextStoreAnchorServices;
#endif 	/* __ITextStoreAnchorServices_FWD_DEFINED__ */


#ifndef __ITfProperty2_FWD_DEFINED__
#define __ITfProperty2_FWD_DEFINED__
typedef interface ITfProperty2 ITfProperty2;
#endif 	/* __ITfProperty2_FWD_DEFINED__ */


#ifndef __IEnumTfCollection_FWD_DEFINED__
#define __IEnumTfCollection_FWD_DEFINED__
typedef interface IEnumTfCollection IEnumTfCollection;
#endif 	/* __IEnumTfCollection_FWD_DEFINED__ */


#ifndef __ITfDisplayAttributeCollectionMgr_FWD_DEFINED__
#define __ITfDisplayAttributeCollectionMgr_FWD_DEFINED__
typedef interface ITfDisplayAttributeCollectionMgr ITfDisplayAttributeCollectionMgr;
#endif 	/* __ITfDisplayAttributeCollectionMgr_FWD_DEFINED__ */


#ifndef __ITfDisplayAttributeCollectionProvider_FWD_DEFINED__
#define __ITfDisplayAttributeCollectionProvider_FWD_DEFINED__
typedef interface ITfDisplayAttributeCollectionProvider ITfDisplayAttributeCollectionProvider;
#endif 	/* __ITfDisplayAttributeCollectionProvider_FWD_DEFINED__ */


#ifndef __IEnumTfRenderingMarkup_FWD_DEFINED__
#define __IEnumTfRenderingMarkup_FWD_DEFINED__
typedef interface IEnumTfRenderingMarkup IEnumTfRenderingMarkup;
#endif 	/* __IEnumTfRenderingMarkup_FWD_DEFINED__ */


#ifndef __ITfContextRenderingMarkup_FWD_DEFINED__
#define __ITfContextRenderingMarkup_FWD_DEFINED__
typedef interface ITfContextRenderingMarkup ITfContextRenderingMarkup;
#endif 	/* __ITfContextRenderingMarkup_FWD_DEFINED__ */


#ifndef __ITfBackgroundThreadMgr_FWD_DEFINED__
#define __ITfBackgroundThreadMgr_FWD_DEFINED__
typedef interface ITfBackgroundThreadMgr ITfBackgroundThreadMgr;
#endif 	/* __ITfBackgroundThreadMgr_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "msctf.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_msctfp_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// msctfp.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-2000 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// MSCTF Private Interfaces.

#ifndef MSCTFP_DEFINED
#define MSCTFP_DEFINED

#include <windows.h>

EXTERN_C const GUID GUID_TFCAT_TIP_REFERENCE;
EXTERN_C const GUID GUID_TFCAT_TIP_PROOFING;
EXTERN_C const GUID GUID_TFCAT_TIP_SMARTTAG;
EXTERN_C const GUID GUID_TFCAT_PROPSTYLE_CUSTOM_COMPACT;
EXTERN_C const GUID GUID_SERVICE_TEXTSTORE;
EXTERN_C const GUID GUID_SERVICE_TF;
EXTERN_C const GUID GUID_COMPARTMENT_MSCANDIDATEUI_WINDOW;

#define TF_LBU_CAPSKANAKEY               1
#define TF_LBU_NTCONSOLELANGCHANGE       2
EXTERN_C const GUID GUID_MODEBIAS_DEFAULT;
#define TF_LBUF_CAPS        0x0001
#define TF_LBUF_KANA        0x0002
#define	TF_ES_READ_PROPERTY_WRITE	( 0x12 )

#define TF_PKEX_SYSHOTKEY    0x0001
#define TF_PKEX_NONEEDDIM    0x0002
#define TF_TMAE_NOACTIVATETIP   0x0001
#define TF_KEY_MSCTFIME      0x0001
#define TF_KEY_TEST          0x0002
#define TF_KEY_INTERNAL      0x0004


extern RPC_IF_HANDLE __MIDL_itf_msctfp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctfp_0000_v0_0_s_ifspec;

#ifndef __ITfThreadMgr_P_old_INTERFACE_DEFINED__
#define __ITfThreadMgr_P_old_INTERFACE_DEFINED__

/* interface ITfThreadMgr_P_old */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfThreadMgr_P_old;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f65567a7-34a1-46f4-b5dd-8804aeb06ff7")
    ITfThreadMgr_P_old : public ITfThreadMgr
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAssociated( 
            /* [in] */ HWND hWnd,
            /* [out] */ ITfDocumentMgr **ppdim) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSysHookSink( 
            /* [in] */ ITfSysHookSink *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestPostponedLock( 
            /* [in] */ ITfContext *pic) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsKeystrokeFeedEnabled( 
            /* [out] */ BOOL *pfEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfThreadMgr_P_oldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfThreadMgr_P_old * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfThreadMgr_P_old * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfThreadMgr_P_old * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ITfThreadMgr_P_old * This,
            /* [out] */ TfClientId *ptid);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            ITfThreadMgr_P_old * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDocumentMgr )( 
            ITfThreadMgr_P_old * This,
            /* [out] */ ITfDocumentMgr **ppdim);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDocumentMgrs )( 
            ITfThreadMgr_P_old * This,
            /* [out] */ IEnumTfDocumentMgrs **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetFocus )( 
            ITfThreadMgr_P_old * This,
            /* [out] */ ITfDocumentMgr **ppdimFocus);
        
        HRESULT ( STDMETHODCALLTYPE *SetFocus )( 
            ITfThreadMgr_P_old * This,
            /* [in] */ ITfDocumentMgr *pdimFocus);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateFocus )( 
            ITfThreadMgr_P_old * This,
            /* [in] */ HWND hwnd,
            /* [unique][in] */ ITfDocumentMgr *pdimNew,
            /* [out] */ ITfDocumentMgr **ppdimPrev);
        
        HRESULT ( STDMETHODCALLTYPE *IsThreadFocus )( 
            ITfThreadMgr_P_old * This,
            /* [out] */ BOOL *pfThreadFocus);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionProvider )( 
            ITfThreadMgr_P_old * This,
            /* [in] */ REFCLSID clsid,
            /* [out] */ ITfFunctionProvider **ppFuncProv);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFunctionProviders )( 
            ITfThreadMgr_P_old * This,
            /* [out] */ IEnumTfFunctionProviders **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlobalCompartment )( 
            ITfThreadMgr_P_old * This,
            /* [out] */ ITfCompartmentMgr **ppCompMgr);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssociated )( 
            ITfThreadMgr_P_old * This,
            /* [in] */ HWND hWnd,
            /* [out] */ ITfDocumentMgr **ppdim);
        
        HRESULT ( STDMETHODCALLTYPE *SetSysHookSink )( 
            ITfThreadMgr_P_old * This,
            /* [in] */ ITfSysHookSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *RequestPostponedLock )( 
            ITfThreadMgr_P_old * This,
            /* [in] */ ITfContext *pic);
        
        HRESULT ( STDMETHODCALLTYPE *IsKeystrokeFeedEnabled )( 
            ITfThreadMgr_P_old * This,
            /* [out] */ BOOL *pfEnabled);
        
        END_INTERFACE
    } ITfThreadMgr_P_oldVtbl;

    interface ITfThreadMgr_P_old
    {
        CONST_VTBL struct ITfThreadMgr_P_oldVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfThreadMgr_P_old_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfThreadMgr_P_old_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfThreadMgr_P_old_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfThreadMgr_P_old_Activate(This,ptid)	\
    (This)->lpVtbl -> Activate(This,ptid)

#define ITfThreadMgr_P_old_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define ITfThreadMgr_P_old_CreateDocumentMgr(This,ppdim)	\
    (This)->lpVtbl -> CreateDocumentMgr(This,ppdim)

#define ITfThreadMgr_P_old_EnumDocumentMgrs(This,ppEnum)	\
    (This)->lpVtbl -> EnumDocumentMgrs(This,ppEnum)

#define ITfThreadMgr_P_old_GetFocus(This,ppdimFocus)	\
    (This)->lpVtbl -> GetFocus(This,ppdimFocus)

#define ITfThreadMgr_P_old_SetFocus(This,pdimFocus)	\
    (This)->lpVtbl -> SetFocus(This,pdimFocus)

#define ITfThreadMgr_P_old_AssociateFocus(This,hwnd,pdimNew,ppdimPrev)	\
    (This)->lpVtbl -> AssociateFocus(This,hwnd,pdimNew,ppdimPrev)

#define ITfThreadMgr_P_old_IsThreadFocus(This,pfThreadFocus)	\
    (This)->lpVtbl -> IsThreadFocus(This,pfThreadFocus)

#define ITfThreadMgr_P_old_GetFunctionProvider(This,clsid,ppFuncProv)	\
    (This)->lpVtbl -> GetFunctionProvider(This,clsid,ppFuncProv)

#define ITfThreadMgr_P_old_EnumFunctionProviders(This,ppEnum)	\
    (This)->lpVtbl -> EnumFunctionProviders(This,ppEnum)

#define ITfThreadMgr_P_old_GetGlobalCompartment(This,ppCompMgr)	\
    (This)->lpVtbl -> GetGlobalCompartment(This,ppCompMgr)


#define ITfThreadMgr_P_old_GetAssociated(This,hWnd,ppdim)	\
    (This)->lpVtbl -> GetAssociated(This,hWnd,ppdim)

#define ITfThreadMgr_P_old_SetSysHookSink(This,pSink)	\
    (This)->lpVtbl -> SetSysHookSink(This,pSink)

#define ITfThreadMgr_P_old_RequestPostponedLock(This,pic)	\
    (This)->lpVtbl -> RequestPostponedLock(This,pic)

#define ITfThreadMgr_P_old_IsKeystrokeFeedEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> IsKeystrokeFeedEnabled(This,pfEnabled)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfThreadMgr_P_old_GetAssociated_Proxy( 
    ITfThreadMgr_P_old * This,
    /* [in] */ HWND hWnd,
    /* [out] */ ITfDocumentMgr **ppdim);


void __RPC_STUB ITfThreadMgr_P_old_GetAssociated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_P_old_SetSysHookSink_Proxy( 
    ITfThreadMgr_P_old * This,
    /* [in] */ ITfSysHookSink *pSink);


void __RPC_STUB ITfThreadMgr_P_old_SetSysHookSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_P_old_RequestPostponedLock_Proxy( 
    ITfThreadMgr_P_old * This,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfThreadMgr_P_old_RequestPostponedLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_P_old_IsKeystrokeFeedEnabled_Proxy( 
    ITfThreadMgr_P_old * This,
    /* [out] */ BOOL *pfEnabled);


void __RPC_STUB ITfThreadMgr_P_old_IsKeystrokeFeedEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfThreadMgr_P_old_INTERFACE_DEFINED__ */


#ifndef __ITfThreadMgr_P_INTERFACE_DEFINED__
#define __ITfThreadMgr_P_INTERFACE_DEFINED__

/* interface ITfThreadMgr_P */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfThreadMgr_P;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7c6247a1-2884-4b7c-af24-f198047aa728")
    ITfThreadMgr_P : public ITfThreadMgr_P_old
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CallImm32HotkeyHanlder( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pbHandled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ActivateEx( 
            /* [out] */ TfClientId *ptid,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfThreadMgr_PVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfThreadMgr_P * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfThreadMgr_P * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfThreadMgr_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ITfThreadMgr_P * This,
            /* [out] */ TfClientId *ptid);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            ITfThreadMgr_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDocumentMgr )( 
            ITfThreadMgr_P * This,
            /* [out] */ ITfDocumentMgr **ppdim);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDocumentMgrs )( 
            ITfThreadMgr_P * This,
            /* [out] */ IEnumTfDocumentMgrs **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetFocus )( 
            ITfThreadMgr_P * This,
            /* [out] */ ITfDocumentMgr **ppdimFocus);
        
        HRESULT ( STDMETHODCALLTYPE *SetFocus )( 
            ITfThreadMgr_P * This,
            /* [in] */ ITfDocumentMgr *pdimFocus);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateFocus )( 
            ITfThreadMgr_P * This,
            /* [in] */ HWND hwnd,
            /* [unique][in] */ ITfDocumentMgr *pdimNew,
            /* [out] */ ITfDocumentMgr **ppdimPrev);
        
        HRESULT ( STDMETHODCALLTYPE *IsThreadFocus )( 
            ITfThreadMgr_P * This,
            /* [out] */ BOOL *pfThreadFocus);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionProvider )( 
            ITfThreadMgr_P * This,
            /* [in] */ REFCLSID clsid,
            /* [out] */ ITfFunctionProvider **ppFuncProv);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFunctionProviders )( 
            ITfThreadMgr_P * This,
            /* [out] */ IEnumTfFunctionProviders **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlobalCompartment )( 
            ITfThreadMgr_P * This,
            /* [out] */ ITfCompartmentMgr **ppCompMgr);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssociated )( 
            ITfThreadMgr_P * This,
            /* [in] */ HWND hWnd,
            /* [out] */ ITfDocumentMgr **ppdim);
        
        HRESULT ( STDMETHODCALLTYPE *SetSysHookSink )( 
            ITfThreadMgr_P * This,
            /* [in] */ ITfSysHookSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *RequestPostponedLock )( 
            ITfThreadMgr_P * This,
            /* [in] */ ITfContext *pic);
        
        HRESULT ( STDMETHODCALLTYPE *IsKeystrokeFeedEnabled )( 
            ITfThreadMgr_P * This,
            /* [out] */ BOOL *pfEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *CallImm32HotkeyHanlder )( 
            ITfThreadMgr_P * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pbHandled);
        
        HRESULT ( STDMETHODCALLTYPE *ActivateEx )( 
            ITfThreadMgr_P * This,
            /* [out] */ TfClientId *ptid,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } ITfThreadMgr_PVtbl;

    interface ITfThreadMgr_P
    {
        CONST_VTBL struct ITfThreadMgr_PVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfThreadMgr_P_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfThreadMgr_P_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfThreadMgr_P_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfThreadMgr_P_Activate(This,ptid)	\
    (This)->lpVtbl -> Activate(This,ptid)

#define ITfThreadMgr_P_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define ITfThreadMgr_P_CreateDocumentMgr(This,ppdim)	\
    (This)->lpVtbl -> CreateDocumentMgr(This,ppdim)

#define ITfThreadMgr_P_EnumDocumentMgrs(This,ppEnum)	\
    (This)->lpVtbl -> EnumDocumentMgrs(This,ppEnum)

#define ITfThreadMgr_P_GetFocus(This,ppdimFocus)	\
    (This)->lpVtbl -> GetFocus(This,ppdimFocus)

#define ITfThreadMgr_P_SetFocus(This,pdimFocus)	\
    (This)->lpVtbl -> SetFocus(This,pdimFocus)

#define ITfThreadMgr_P_AssociateFocus(This,hwnd,pdimNew,ppdimPrev)	\
    (This)->lpVtbl -> AssociateFocus(This,hwnd,pdimNew,ppdimPrev)

#define ITfThreadMgr_P_IsThreadFocus(This,pfThreadFocus)	\
    (This)->lpVtbl -> IsThreadFocus(This,pfThreadFocus)

#define ITfThreadMgr_P_GetFunctionProvider(This,clsid,ppFuncProv)	\
    (This)->lpVtbl -> GetFunctionProvider(This,clsid,ppFuncProv)

#define ITfThreadMgr_P_EnumFunctionProviders(This,ppEnum)	\
    (This)->lpVtbl -> EnumFunctionProviders(This,ppEnum)

#define ITfThreadMgr_P_GetGlobalCompartment(This,ppCompMgr)	\
    (This)->lpVtbl -> GetGlobalCompartment(This,ppCompMgr)


#define ITfThreadMgr_P_GetAssociated(This,hWnd,ppdim)	\
    (This)->lpVtbl -> GetAssociated(This,hWnd,ppdim)

#define ITfThreadMgr_P_SetSysHookSink(This,pSink)	\
    (This)->lpVtbl -> SetSysHookSink(This,pSink)

#define ITfThreadMgr_P_RequestPostponedLock(This,pic)	\
    (This)->lpVtbl -> RequestPostponedLock(This,pic)

#define ITfThreadMgr_P_IsKeystrokeFeedEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> IsKeystrokeFeedEnabled(This,pfEnabled)


#define ITfThreadMgr_P_CallImm32HotkeyHanlder(This,wParam,lParam,pbHandled)	\
    (This)->lpVtbl -> CallImm32HotkeyHanlder(This,wParam,lParam,pbHandled)

#define ITfThreadMgr_P_ActivateEx(This,ptid,dwFlags)	\
    (This)->lpVtbl -> ActivateEx(This,ptid,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfThreadMgr_P_CallImm32HotkeyHanlder_Proxy( 
    ITfThreadMgr_P * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pbHandled);


void __RPC_STUB ITfThreadMgr_P_CallImm32HotkeyHanlder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_P_ActivateEx_Proxy( 
    ITfThreadMgr_P * This,
    /* [out] */ TfClientId *ptid,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITfThreadMgr_P_ActivateEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfThreadMgr_P_INTERFACE_DEFINED__ */


#ifndef __ITfKeystrokeMgr_P_INTERFACE_DEFINED__
#define __ITfKeystrokeMgr_P_INTERFACE_DEFINED__

/* interface ITfKeystrokeMgr_P */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfKeystrokeMgr_P;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("53fa1bec-5be1-458e-ae70-a9f1dc843e81")
    ITfKeystrokeMgr_P : public ITfKeystrokeMgr
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PreserveKeyEx( 
            /* [in] */ TfClientId tid,
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *prekey,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cchDesc,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeyDownUpEx( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BOOL *pfEaten) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfKeystrokeMgr_PVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfKeystrokeMgr_P * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfKeystrokeMgr_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseKeyEventSink )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ TfClientId tid,
            /* [in] */ ITfKeyEventSink *pSink,
            /* [in] */ BOOL fForeground);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseKeyEventSink )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ TfClientId tid);
        
        HRESULT ( STDMETHODCALLTYPE *GetForeground )( 
            ITfKeystrokeMgr_P * This,
            /* [out] */ CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *TestKeyDown )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *TestKeyUp )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *KeyDown )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *KeyUp )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreservedKey )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ const TF_PRESERVEDKEY *pprekey,
            /* [out] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *IsPreservedKey )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *pprekey,
            /* [out] */ BOOL *pfRegistered);
        
        HRESULT ( STDMETHODCALLTYPE *PreserveKey )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ TfClientId tid,
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *prekey,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cchDesc);
        
        HRESULT ( STDMETHODCALLTYPE *UnpreserveKey )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *pprekey);
        
        HRESULT ( STDMETHODCALLTYPE *SetPreservedKeyDescription )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ REFGUID rguid,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cchDesc);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreservedKeyDescription )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ BSTR *pbstrDesc);
        
        HRESULT ( STDMETHODCALLTYPE *SimulatePreservedKey )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ REFGUID rguid,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *PreserveKeyEx )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ TfClientId tid,
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *prekey,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cchDesc,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *KeyDownUpEx )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BOOL *pfEaten);
        
        END_INTERFACE
    } ITfKeystrokeMgr_PVtbl;

    interface ITfKeystrokeMgr_P
    {
        CONST_VTBL struct ITfKeystrokeMgr_PVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfKeystrokeMgr_P_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfKeystrokeMgr_P_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfKeystrokeMgr_P_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfKeystrokeMgr_P_AdviseKeyEventSink(This,tid,pSink,fForeground)	\
    (This)->lpVtbl -> AdviseKeyEventSink(This,tid,pSink,fForeground)

#define ITfKeystrokeMgr_P_UnadviseKeyEventSink(This,tid)	\
    (This)->lpVtbl -> UnadviseKeyEventSink(This,tid)

#define ITfKeystrokeMgr_P_GetForeground(This,pclsid)	\
    (This)->lpVtbl -> GetForeground(This,pclsid)

#define ITfKeystrokeMgr_P_TestKeyDown(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> TestKeyDown(This,wParam,lParam,pfEaten)

#define ITfKeystrokeMgr_P_TestKeyUp(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> TestKeyUp(This,wParam,lParam,pfEaten)

#define ITfKeystrokeMgr_P_KeyDown(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> KeyDown(This,wParam,lParam,pfEaten)

#define ITfKeystrokeMgr_P_KeyUp(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> KeyUp(This,wParam,lParam,pfEaten)

#define ITfKeystrokeMgr_P_GetPreservedKey(This,pic,pprekey,pguid)	\
    (This)->lpVtbl -> GetPreservedKey(This,pic,pprekey,pguid)

#define ITfKeystrokeMgr_P_IsPreservedKey(This,rguid,pprekey,pfRegistered)	\
    (This)->lpVtbl -> IsPreservedKey(This,rguid,pprekey,pfRegistered)

#define ITfKeystrokeMgr_P_PreserveKey(This,tid,rguid,prekey,pchDesc,cchDesc)	\
    (This)->lpVtbl -> PreserveKey(This,tid,rguid,prekey,pchDesc,cchDesc)

#define ITfKeystrokeMgr_P_UnpreserveKey(This,rguid,pprekey)	\
    (This)->lpVtbl -> UnpreserveKey(This,rguid,pprekey)

#define ITfKeystrokeMgr_P_SetPreservedKeyDescription(This,rguid,pchDesc,cchDesc)	\
    (This)->lpVtbl -> SetPreservedKeyDescription(This,rguid,pchDesc,cchDesc)

#define ITfKeystrokeMgr_P_GetPreservedKeyDescription(This,rguid,pbstrDesc)	\
    (This)->lpVtbl -> GetPreservedKeyDescription(This,rguid,pbstrDesc)

#define ITfKeystrokeMgr_P_SimulatePreservedKey(This,pic,rguid,pfEaten)	\
    (This)->lpVtbl -> SimulatePreservedKey(This,pic,rguid,pfEaten)


#define ITfKeystrokeMgr_P_PreserveKeyEx(This,tid,rguid,prekey,pchDesc,cchDesc,dwFlags)	\
    (This)->lpVtbl -> PreserveKeyEx(This,tid,rguid,prekey,pchDesc,cchDesc,dwFlags)

#define ITfKeystrokeMgr_P_KeyDownUpEx(This,wParam,lParam,dwFlags,pfEaten)	\
    (This)->lpVtbl -> KeyDownUpEx(This,wParam,lParam,dwFlags,pfEaten)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_P_PreserveKeyEx_Proxy( 
    ITfKeystrokeMgr_P * This,
    /* [in] */ TfClientId tid,
    /* [in] */ REFGUID rguid,
    /* [in] */ const TF_PRESERVEDKEY *prekey,
    /* [size_is][in] */ const WCHAR *pchDesc,
    /* [in] */ ULONG cchDesc,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITfKeystrokeMgr_P_PreserveKeyEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_P_KeyDownUpEx_Proxy( 
    ITfKeystrokeMgr_P * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [in] */ DWORD dwFlags,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeystrokeMgr_P_KeyDownUpEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfKeystrokeMgr_P_INTERFACE_DEFINED__ */


#ifndef __ITfSysHookSink_INTERFACE_DEFINED__
#define __ITfSysHookSink_INTERFACE_DEFINED__

/* interface ITfSysHookSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfSysHookSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("495388DA-21A5-4852-8BB1-ED2F29DA8D60")
    ITfSysHookSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnPreFocusDIM( 
            /* [in] */ HWND hWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSysKeyboardProc( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSysShellProc( 
            /* [in] */ int nCode,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfSysHookSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfSysHookSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfSysHookSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfSysHookSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnPreFocusDIM )( 
            ITfSysHookSink * This,
            /* [in] */ HWND hWnd);
        
        HRESULT ( STDMETHODCALLTYPE *OnSysKeyboardProc )( 
            ITfSysHookSink * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *OnSysShellProc )( 
            ITfSysHookSink * This,
            /* [in] */ int nCode,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        END_INTERFACE
    } ITfSysHookSinkVtbl;

    interface ITfSysHookSink
    {
        CONST_VTBL struct ITfSysHookSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfSysHookSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfSysHookSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfSysHookSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfSysHookSink_OnPreFocusDIM(This,hWnd)	\
    (This)->lpVtbl -> OnPreFocusDIM(This,hWnd)

#define ITfSysHookSink_OnSysKeyboardProc(This,wParam,lParam)	\
    (This)->lpVtbl -> OnSysKeyboardProc(This,wParam,lParam)

#define ITfSysHookSink_OnSysShellProc(This,nCode,wParam,lParam)	\
    (This)->lpVtbl -> OnSysShellProc(This,nCode,wParam,lParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfSysHookSink_OnPreFocusDIM_Proxy( 
    ITfSysHookSink * This,
    /* [in] */ HWND hWnd);


void __RPC_STUB ITfSysHookSink_OnPreFocusDIM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfSysHookSink_OnSysKeyboardProc_Proxy( 
    ITfSysHookSink * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ITfSysHookSink_OnSysKeyboardProc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfSysHookSink_OnSysShellProc_Proxy( 
    ITfSysHookSink * This,
    /* [in] */ int nCode,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ITfSysHookSink_OnSysShellProc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfSysHookSink_INTERFACE_DEFINED__ */


#ifndef __ITfStartReconversionNotifySink_INTERFACE_DEFINED__
#define __ITfStartReconversionNotifySink_INTERFACE_DEFINED__

/* interface ITfStartReconversionNotifySink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfStartReconversionNotifySink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b9cd19cb-2919-4935-8768-ef30bae9a0cc")
    ITfStartReconversionNotifySink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartReconversion( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndReconversion( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfStartReconversionNotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfStartReconversionNotifySink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfStartReconversionNotifySink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfStartReconversionNotifySink * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartReconversion )( 
            ITfStartReconversionNotifySink * This);
        
        HRESULT ( STDMETHODCALLTYPE *EndReconversion )( 
            ITfStartReconversionNotifySink * This);
        
        END_INTERFACE
    } ITfStartReconversionNotifySinkVtbl;

    interface ITfStartReconversionNotifySink
    {
        CONST_VTBL struct ITfStartReconversionNotifySinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfStartReconversionNotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfStartReconversionNotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfStartReconversionNotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfStartReconversionNotifySink_StartReconversion(This)	\
    (This)->lpVtbl -> StartReconversion(This)

#define ITfStartReconversionNotifySink_EndReconversion(This)	\
    (This)->lpVtbl -> EndReconversion(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfStartReconversionNotifySink_StartReconversion_Proxy( 
    ITfStartReconversionNotifySink * This);


void __RPC_STUB ITfStartReconversionNotifySink_StartReconversion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfStartReconversionNotifySink_EndReconversion_Proxy( 
    ITfStartReconversionNotifySink * This);


void __RPC_STUB ITfStartReconversionNotifySink_EndReconversion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfStartReconversionNotifySink_INTERFACE_DEFINED__ */


#ifndef __ITfLangBarEventSink_P_INTERFACE_DEFINED__
#define __ITfLangBarEventSink_P_INTERFACE_DEFINED__

/* interface ITfLangBarEventSink_P */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLangBarEventSink_P;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7a460360-da21-4b09-a8a0-8a69e728d893")
    ITfLangBarEventSink_P : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnLangBarUpdate( 
            /* [in] */ UINT uPdate,
            /* [in] */ LPARAM lParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarEventSink_PVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarEventSink_P * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarEventSink_P * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarEventSink_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnLangBarUpdate )( 
            ITfLangBarEventSink_P * This,
            /* [in] */ UINT uPdate,
            /* [in] */ LPARAM lParam);
        
        END_INTERFACE
    } ITfLangBarEventSink_PVtbl;

    interface ITfLangBarEventSink_P
    {
        CONST_VTBL struct ITfLangBarEventSink_PVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarEventSink_P_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarEventSink_P_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarEventSink_P_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarEventSink_P_OnLangBarUpdate(This,uPdate,lParam)	\
    (This)->lpVtbl -> OnLangBarUpdate(This,uPdate,lParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarEventSink_P_OnLangBarUpdate_Proxy( 
    ITfLangBarEventSink_P * This,
    /* [in] */ UINT uPdate,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ITfLangBarEventSink_P_OnLangBarUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarEventSink_P_INTERFACE_DEFINED__ */


#ifndef __ITfLangBarMgr_P_INTERFACE_DEFINED__
#define __ITfLangBarMgr_P_INTERFACE_DEFINED__

/* interface ITfLangBarMgr_P */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLangBarMgr_P;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d72c0fa9-add5-4af0-8706-4fa9ae3e2eff")
    ITfLangBarMgr_P : public ITfLangBarMgr
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPrevShowFloatingStatus( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarMgr_PVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarMgr_P * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarMgr_P * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarMgr_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseEventSink )( 
            ITfLangBarMgr_P * This,
            /* [in] */ ITfLangBarEventSink *pSink,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseEventSink )( 
            ITfLangBarMgr_P * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadMarshalInterface )( 
            ITfLangBarMgr_P * This,
            /* [in] */ DWORD dwThreadId,
            /* [in] */ DWORD dwType,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadLangBarItemMgr )( 
            ITfLangBarMgr_P * This,
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ITfLangBarItemMgr **pplbi,
            /* [out] */ DWORD *pdwThreadid);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputProcessorProfiles )( 
            ITfLangBarMgr_P * This,
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ITfInputProcessorProfiles **ppaip,
            /* [out] */ DWORD *pdwThreadid);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreLastFocus )( 
            ITfLangBarMgr_P * This,
            /* [out] */ DWORD *pdwThreadId,
            /* [in] */ BOOL fPrev);
        
        HRESULT ( STDMETHODCALLTYPE *SetModalInput )( 
            ITfLangBarMgr_P * This,
            /* [in] */ ITfLangBarEventSink *pSink,
            /* [in] */ DWORD dwThreadId,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ShowFloating )( 
            ITfLangBarMgr_P * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetShowFloatingStatus )( 
            ITfLangBarMgr_P * This,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrevShowFloatingStatus )( 
            ITfLangBarMgr_P * This,
            /* [out] */ DWORD *pdwFlags);
        
        END_INTERFACE
    } ITfLangBarMgr_PVtbl;

    interface ITfLangBarMgr_P
    {
        CONST_VTBL struct ITfLangBarMgr_PVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarMgr_P_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarMgr_P_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarMgr_P_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarMgr_P_AdviseEventSink(This,pSink,hwnd,dwFlags,pdwCookie)	\
    (This)->lpVtbl -> AdviseEventSink(This,pSink,hwnd,dwFlags,pdwCookie)

#define ITfLangBarMgr_P_UnadviseEventSink(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseEventSink(This,dwCookie)

#define ITfLangBarMgr_P_GetThreadMarshalInterface(This,dwThreadId,dwType,riid,ppunk)	\
    (This)->lpVtbl -> GetThreadMarshalInterface(This,dwThreadId,dwType,riid,ppunk)

#define ITfLangBarMgr_P_GetThreadLangBarItemMgr(This,dwThreadId,pplbi,pdwThreadid)	\
    (This)->lpVtbl -> GetThreadLangBarItemMgr(This,dwThreadId,pplbi,pdwThreadid)

#define ITfLangBarMgr_P_GetInputProcessorProfiles(This,dwThreadId,ppaip,pdwThreadid)	\
    (This)->lpVtbl -> GetInputProcessorProfiles(This,dwThreadId,ppaip,pdwThreadid)

#define ITfLangBarMgr_P_RestoreLastFocus(This,pdwThreadId,fPrev)	\
    (This)->lpVtbl -> RestoreLastFocus(This,pdwThreadId,fPrev)

#define ITfLangBarMgr_P_SetModalInput(This,pSink,dwThreadId,dwFlags)	\
    (This)->lpVtbl -> SetModalInput(This,pSink,dwThreadId,dwFlags)

#define ITfLangBarMgr_P_ShowFloating(This,dwFlags)	\
    (This)->lpVtbl -> ShowFloating(This,dwFlags)

#define ITfLangBarMgr_P_GetShowFloatingStatus(This,pdwFlags)	\
    (This)->lpVtbl -> GetShowFloatingStatus(This,pdwFlags)


#define ITfLangBarMgr_P_GetPrevShowFloatingStatus(This,pdwFlags)	\
    (This)->lpVtbl -> GetPrevShowFloatingStatus(This,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarMgr_P_GetPrevShowFloatingStatus_Proxy( 
    ITfLangBarMgr_P * This,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB ITfLangBarMgr_P_GetPrevShowFloatingStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarMgr_P_INTERFACE_DEFINED__ */


#ifndef __ITfContext_P_INTERFACE_DEFINED__
#define __ITfContext_P_INTERFACE_DEFINED__

/* interface ITfContext_P */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfContext_P;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2dee47c8-704d-42a0-9983-ffeed659b64d")
    ITfContext_P : public ITfContext
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MapAppProperty( 
            /* [in] */ REFGUID guidAppProp,
            /* [in] */ REFGUID guidProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableLockRequestPosting( 
            /* [in] */ BOOL fEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContext_PVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContext_P * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContext_P * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContext_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestEditSession )( 
            ITfContext_P * This,
            /* [in] */ TfClientId tid,
            /* [in] */ ITfEditSession *pes,
            /* [in] */ DWORD dwFlags,
            /* [out] */ HRESULT *phrSession);
        
        HRESULT ( STDMETHODCALLTYPE *InWriteSession )( 
            ITfContext_P * This,
            /* [in] */ TfClientId tid,
            /* [out] */ BOOL *pfWriteSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            ITfContext_P * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG ulIndex,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_SELECTION *pSelection,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *SetSelection )( 
            ITfContext_P * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const TF_SELECTION *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE *GetStart )( 
            ITfContext_P * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ ITfRange **ppStart);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnd )( 
            ITfContext_P * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ ITfRange **ppEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveView )( 
            ITfContext_P * This,
            /* [out] */ ITfContextView **ppView);
        
        HRESULT ( STDMETHODCALLTYPE *EnumViews )( 
            ITfContext_P * This,
            /* [out] */ IEnumTfContextViews **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITfContext_P * This,
            /* [out] */ TF_STATUS *pdcs);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            ITfContext_P * This,
            /* [in] */ REFGUID guidProp,
            /* [out] */ ITfProperty **ppProp);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppProperty )( 
            ITfContext_P * This,
            /* [in] */ REFGUID guidProp,
            /* [out] */ ITfReadOnlyProperty **ppProp);
        
        HRESULT ( STDMETHODCALLTYPE *TrackProperties )( 
            ITfContext_P * This,
            /* [size_is][in] */ const GUID **prgProp,
            /* [in] */ ULONG cProp,
            /* [size_is][in] */ const GUID **prgAppProp,
            /* [in] */ ULONG cAppProp,
            /* [out] */ ITfReadOnlyProperty **ppProperty);
        
        HRESULT ( STDMETHODCALLTYPE *EnumProperties )( 
            ITfContext_P * This,
            /* [out] */ IEnumTfProperties **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentMgr )( 
            ITfContext_P * This,
            /* [out] */ ITfDocumentMgr **ppDm);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRangeBackup )( 
            ITfContext_P * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRangeBackup **ppBackup);
        
        HRESULT ( STDMETHODCALLTYPE *MapAppProperty )( 
            ITfContext_P * This,
            /* [in] */ REFGUID guidAppProp,
            /* [in] */ REFGUID guidProp);
        
        HRESULT ( STDMETHODCALLTYPE *EnableLockRequestPosting )( 
            ITfContext_P * This,
            /* [in] */ BOOL fEnable);
        
        END_INTERFACE
    } ITfContext_PVtbl;

    interface ITfContext_P
    {
        CONST_VTBL struct ITfContext_PVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContext_P_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContext_P_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContext_P_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContext_P_RequestEditSession(This,tid,pes,dwFlags,phrSession)	\
    (This)->lpVtbl -> RequestEditSession(This,tid,pes,dwFlags,phrSession)

#define ITfContext_P_InWriteSession(This,tid,pfWriteSession)	\
    (This)->lpVtbl -> InWriteSession(This,tid,pfWriteSession)

#define ITfContext_P_GetSelection(This,ec,ulIndex,ulCount,pSelection,pcFetched)	\
    (This)->lpVtbl -> GetSelection(This,ec,ulIndex,ulCount,pSelection,pcFetched)

#define ITfContext_P_SetSelection(This,ec,ulCount,pSelection)	\
    (This)->lpVtbl -> SetSelection(This,ec,ulCount,pSelection)

#define ITfContext_P_GetStart(This,ec,ppStart)	\
    (This)->lpVtbl -> GetStart(This,ec,ppStart)

#define ITfContext_P_GetEnd(This,ec,ppEnd)	\
    (This)->lpVtbl -> GetEnd(This,ec,ppEnd)

#define ITfContext_P_GetActiveView(This,ppView)	\
    (This)->lpVtbl -> GetActiveView(This,ppView)

#define ITfContext_P_EnumViews(This,ppEnum)	\
    (This)->lpVtbl -> EnumViews(This,ppEnum)

#define ITfContext_P_GetStatus(This,pdcs)	\
    (This)->lpVtbl -> GetStatus(This,pdcs)

#define ITfContext_P_GetProperty(This,guidProp,ppProp)	\
    (This)->lpVtbl -> GetProperty(This,guidProp,ppProp)

#define ITfContext_P_GetAppProperty(This,guidProp,ppProp)	\
    (This)->lpVtbl -> GetAppProperty(This,guidProp,ppProp)

#define ITfContext_P_TrackProperties(This,prgProp,cProp,prgAppProp,cAppProp,ppProperty)	\
    (This)->lpVtbl -> TrackProperties(This,prgProp,cProp,prgAppProp,cAppProp,ppProperty)

#define ITfContext_P_EnumProperties(This,ppEnum)	\
    (This)->lpVtbl -> EnumProperties(This,ppEnum)

#define ITfContext_P_GetDocumentMgr(This,ppDm)	\
    (This)->lpVtbl -> GetDocumentMgr(This,ppDm)

#define ITfContext_P_CreateRangeBackup(This,ec,pRange,ppBackup)	\
    (This)->lpVtbl -> CreateRangeBackup(This,ec,pRange,ppBackup)


#define ITfContext_P_MapAppProperty(This,guidAppProp,guidProp)	\
    (This)->lpVtbl -> MapAppProperty(This,guidAppProp,guidProp)

#define ITfContext_P_EnableLockRequestPosting(This,fEnable)	\
    (This)->lpVtbl -> EnableLockRequestPosting(This,fEnable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContext_P_MapAppProperty_Proxy( 
    ITfContext_P * This,
    /* [in] */ REFGUID guidAppProp,
    /* [in] */ REFGUID guidProp);


void __RPC_STUB ITfContext_P_MapAppProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_P_EnableLockRequestPosting_Proxy( 
    ITfContext_P * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB ITfContext_P_EnableLockRequestPosting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContext_P_INTERFACE_DEFINED__ */


#ifndef __ITfRangeChangeSink_INTERFACE_DEFINED__
#define __ITfRangeChangeSink_INTERFACE_DEFINED__

/* interface ITfRangeChangeSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfRangeChangeSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c1a0e6af-0d60-4800-9796-1fe8e85c0cca")
    ITfRangeChangeSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnChange( 
            /* [in] */ ITfRange *pRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfRangeChangeSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfRangeChangeSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfRangeChangeSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfRangeChangeSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnChange )( 
            ITfRangeChangeSink * This,
            /* [in] */ ITfRange *pRange);
        
        END_INTERFACE
    } ITfRangeChangeSinkVtbl;

    interface ITfRangeChangeSink
    {
        CONST_VTBL struct ITfRangeChangeSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfRangeChangeSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfRangeChangeSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfRangeChangeSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfRangeChangeSink_OnChange(This,pRange)	\
    (This)->lpVtbl -> OnChange(This,pRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfRangeChangeSink_OnChange_Proxy( 
    ITfRangeChangeSink * This,
    /* [in] */ ITfRange *pRange);


void __RPC_STUB ITfRangeChangeSink_OnChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfRangeChangeSink_INTERFACE_DEFINED__ */


#ifndef __ITfFnAbort_INTERFACE_DEFINED__
#define __ITfFnAbort_INTERFACE_DEFINED__

/* interface ITfFnAbort */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnAbort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17f2317f-addb-49df-870e-66227bc51d1a")
    ITfFnAbort : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ ITfContext *pic) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnAbortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnAbort * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnAbort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnAbort * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnAbort * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            ITfFnAbort * This,
            /* [in] */ ITfContext *pic);
        
        END_INTERFACE
    } ITfFnAbortVtbl;

    interface ITfFnAbort
    {
        CONST_VTBL struct ITfFnAbortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnAbort_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnAbort_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnAbort_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnAbort_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnAbort_Abort(This,pic)	\
    (This)->lpVtbl -> Abort(This,pic)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnAbort_Abort_Proxy( 
    ITfFnAbort * This,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfFnAbort_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnAbort_INTERFACE_DEFINED__ */


#ifndef __ITfMouseTrackerAnchor_INTERFACE_DEFINED__
#define __ITfMouseTrackerAnchor_INTERFACE_DEFINED__

/* interface ITfMouseTrackerAnchor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfMouseTrackerAnchor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f9f4e0f2-d600-4a4c-b144-77e201ebd1b0")
    ITfMouseTrackerAnchor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseMouseSink( 
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [in] */ ITfMouseSink *pSink,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseMouseSink( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfMouseTrackerAnchorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfMouseTrackerAnchor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfMouseTrackerAnchor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfMouseTrackerAnchor * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseMouseSink )( 
            ITfMouseTrackerAnchor * This,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [in] */ ITfMouseSink *pSink,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseMouseSink )( 
            ITfMouseTrackerAnchor * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } ITfMouseTrackerAnchorVtbl;

    interface ITfMouseTrackerAnchor
    {
        CONST_VTBL struct ITfMouseTrackerAnchorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfMouseTrackerAnchor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfMouseTrackerAnchor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfMouseTrackerAnchor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfMouseTrackerAnchor_AdviseMouseSink(This,paStart,paEnd,pSink,pdwCookie)	\
    (This)->lpVtbl -> AdviseMouseSink(This,paStart,paEnd,pSink,pdwCookie)

#define ITfMouseTrackerAnchor_UnadviseMouseSink(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseMouseSink(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfMouseTrackerAnchor_AdviseMouseSink_Proxy( 
    ITfMouseTrackerAnchor * This,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd,
    /* [in] */ ITfMouseSink *pSink,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB ITfMouseTrackerAnchor_AdviseMouseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfMouseTrackerAnchor_UnadviseMouseSink_Proxy( 
    ITfMouseTrackerAnchor * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITfMouseTrackerAnchor_UnadviseMouseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfMouseTrackerAnchor_INTERFACE_DEFINED__ */


#ifndef __ITfRangeAnchor_INTERFACE_DEFINED__
#define __ITfRangeAnchor_INTERFACE_DEFINED__

/* interface ITfRangeAnchor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfRangeAnchor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8b99712b-5815-4bcc-b9a9-53db1c8d6755")
    ITfRangeAnchor : public ITfRange
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExtent( 
            /* [out] */ IAnchor **ppaStart,
            /* [out] */ IAnchor **ppaEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExtent( 
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfRangeAnchorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfRangeAnchor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfRangeAnchor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfRangeAnchor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [length_is][size_is][out] */ WCHAR *pchText,
            /* [in] */ ULONG cchMax,
            /* [out] */ ULONG *pcch);
        
        HRESULT ( STDMETHODCALLTYPE *SetText )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [unique][size_is][in] */ const WCHAR *pchText,
            /* [in] */ LONG cch);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormattedText )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ IDataObject **ppDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetEmbedded )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ REFGUID rguidService,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk);
        
        HRESULT ( STDMETHODCALLTYPE *InsertEmbedded )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDataObject *pDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStart )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEnd )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStartToRange )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEndToRange )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStartRegion )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEndRegion )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion);
        
        HRESULT ( STDMETHODCALLTYPE *IsEmpty )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ BOOL *pfEmpty);
        
        HRESULT ( STDMETHODCALLTYPE *Collapse )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualStart )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualEnd )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *CompareStart )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *CompareEnd )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *AdjustForInsert )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG cchInsert,
            /* [out] */ BOOL *pfInsertOk);
        
        HRESULT ( STDMETHODCALLTYPE *GetGravity )( 
            ITfRangeAnchor * This,
            /* [out] */ TfGravity *pgStart,
            /* [out] */ TfGravity *pgEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetGravity )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfGravity gStart,
            /* [in] */ TfGravity gEnd);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ITfRangeAnchor * This,
            /* [out] */ ITfRange **ppClone);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ITfRangeAnchor * This,
            /* [out] */ ITfContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtent )( 
            ITfRangeAnchor * This,
            /* [out] */ IAnchor **ppaStart,
            /* [out] */ IAnchor **ppaEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetExtent )( 
            ITfRangeAnchor * This,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd);
        
        END_INTERFACE
    } ITfRangeAnchorVtbl;

    interface ITfRangeAnchor
    {
        CONST_VTBL struct ITfRangeAnchorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfRangeAnchor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfRangeAnchor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfRangeAnchor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfRangeAnchor_GetText(This,ec,dwFlags,pchText,cchMax,pcch)	\
    (This)->lpVtbl -> GetText(This,ec,dwFlags,pchText,cchMax,pcch)

#define ITfRangeAnchor_SetText(This,ec,dwFlags,pchText,cch)	\
    (This)->lpVtbl -> SetText(This,ec,dwFlags,pchText,cch)

#define ITfRangeAnchor_GetFormattedText(This,ec,ppDataObject)	\
    (This)->lpVtbl -> GetFormattedText(This,ec,ppDataObject)

#define ITfRangeAnchor_GetEmbedded(This,ec,rguidService,riid,ppunk)	\
    (This)->lpVtbl -> GetEmbedded(This,ec,rguidService,riid,ppunk)

#define ITfRangeAnchor_InsertEmbedded(This,ec,dwFlags,pDataObject)	\
    (This)->lpVtbl -> InsertEmbedded(This,ec,dwFlags,pDataObject)

#define ITfRangeAnchor_ShiftStart(This,ec,cchReq,pcch,pHalt)	\
    (This)->lpVtbl -> ShiftStart(This,ec,cchReq,pcch,pHalt)

#define ITfRangeAnchor_ShiftEnd(This,ec,cchReq,pcch,pHalt)	\
    (This)->lpVtbl -> ShiftEnd(This,ec,cchReq,pcch,pHalt)

#define ITfRangeAnchor_ShiftStartToRange(This,ec,pRange,aPos)	\
    (This)->lpVtbl -> ShiftStartToRange(This,ec,pRange,aPos)

#define ITfRangeAnchor_ShiftEndToRange(This,ec,pRange,aPos)	\
    (This)->lpVtbl -> ShiftEndToRange(This,ec,pRange,aPos)

#define ITfRangeAnchor_ShiftStartRegion(This,ec,dir,pfNoRegion)	\
    (This)->lpVtbl -> ShiftStartRegion(This,ec,dir,pfNoRegion)

#define ITfRangeAnchor_ShiftEndRegion(This,ec,dir,pfNoRegion)	\
    (This)->lpVtbl -> ShiftEndRegion(This,ec,dir,pfNoRegion)

#define ITfRangeAnchor_IsEmpty(This,ec,pfEmpty)	\
    (This)->lpVtbl -> IsEmpty(This,ec,pfEmpty)

#define ITfRangeAnchor_Collapse(This,ec,aPos)	\
    (This)->lpVtbl -> Collapse(This,ec,aPos)

#define ITfRangeAnchor_IsEqualStart(This,ec,pWith,aPos,pfEqual)	\
    (This)->lpVtbl -> IsEqualStart(This,ec,pWith,aPos,pfEqual)

#define ITfRangeAnchor_IsEqualEnd(This,ec,pWith,aPos,pfEqual)	\
    (This)->lpVtbl -> IsEqualEnd(This,ec,pWith,aPos,pfEqual)

#define ITfRangeAnchor_CompareStart(This,ec,pWith,aPos,plResult)	\
    (This)->lpVtbl -> CompareStart(This,ec,pWith,aPos,plResult)

#define ITfRangeAnchor_CompareEnd(This,ec,pWith,aPos,plResult)	\
    (This)->lpVtbl -> CompareEnd(This,ec,pWith,aPos,plResult)

#define ITfRangeAnchor_AdjustForInsert(This,ec,cchInsert,pfInsertOk)	\
    (This)->lpVtbl -> AdjustForInsert(This,ec,cchInsert,pfInsertOk)

#define ITfRangeAnchor_GetGravity(This,pgStart,pgEnd)	\
    (This)->lpVtbl -> GetGravity(This,pgStart,pgEnd)

#define ITfRangeAnchor_SetGravity(This,ec,gStart,gEnd)	\
    (This)->lpVtbl -> SetGravity(This,ec,gStart,gEnd)

#define ITfRangeAnchor_Clone(This,ppClone)	\
    (This)->lpVtbl -> Clone(This,ppClone)

#define ITfRangeAnchor_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)


#define ITfRangeAnchor_GetExtent(This,ppaStart,ppaEnd)	\
    (This)->lpVtbl -> GetExtent(This,ppaStart,ppaEnd)

#define ITfRangeAnchor_SetExtent(This,paStart,paEnd)	\
    (This)->lpVtbl -> SetExtent(This,paStart,paEnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfRangeAnchor_GetExtent_Proxy( 
    ITfRangeAnchor * This,
    /* [out] */ IAnchor **ppaStart,
    /* [out] */ IAnchor **ppaEnd);


void __RPC_STUB ITfRangeAnchor_GetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRangeAnchor_SetExtent_Proxy( 
    ITfRangeAnchor * This,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd);


void __RPC_STUB ITfRangeAnchor_SetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfRangeAnchor_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctfp_0230 */
/* [local] */ 

typedef /* [uuid] */  DECLSPEC_UUID("af9f076f-4937-4285-8600-81dca5c31eb6") struct TF_PERSISTENT_PROPERTY_HEADER_ANCHOR
    {
    GUID guidType;
    IAnchor *paStart;
    IAnchor *paEnd;
    ULONG cb;
    DWORD dwPrivate;
    CLSID clsidTIP;
    } 	TF_PERSISTENT_PROPERTY_HEADER_ANCHOR;



extern RPC_IF_HANDLE __MIDL_itf_msctfp_0230_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctfp_0230_v0_0_s_ifspec;

#ifndef __ITfPersistentPropertyLoaderAnchor_INTERFACE_DEFINED__
#define __ITfPersistentPropertyLoaderAnchor_INTERFACE_DEFINED__

/* interface ITfPersistentPropertyLoaderAnchor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfPersistentPropertyLoaderAnchor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2133f790-34c2-11d3-a745-0050040ab407")
    ITfPersistentPropertyLoaderAnchor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LoadProperty( 
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [out] */ IStream **ppStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfPersistentPropertyLoaderAnchorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfPersistentPropertyLoaderAnchor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfPersistentPropertyLoaderAnchor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfPersistentPropertyLoaderAnchor * This);
        
        HRESULT ( STDMETHODCALLTYPE *LoadProperty )( 
            ITfPersistentPropertyLoaderAnchor * This,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [out] */ IStream **ppStream);
        
        END_INTERFACE
    } ITfPersistentPropertyLoaderAnchorVtbl;

    interface ITfPersistentPropertyLoaderAnchor
    {
        CONST_VTBL struct ITfPersistentPropertyLoaderAnchorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfPersistentPropertyLoaderAnchor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfPersistentPropertyLoaderAnchor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfPersistentPropertyLoaderAnchor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfPersistentPropertyLoaderAnchor_LoadProperty(This,pHdr,ppStream)	\
    (This)->lpVtbl -> LoadProperty(This,pHdr,ppStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfPersistentPropertyLoaderAnchor_LoadProperty_Proxy( 
    ITfPersistentPropertyLoaderAnchor * This,
    /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
    /* [out] */ IStream **ppStream);


void __RPC_STUB ITfPersistentPropertyLoaderAnchor_LoadProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfPersistentPropertyLoaderAnchor_INTERFACE_DEFINED__ */


#ifndef __ITextStoreAnchorServices_INTERFACE_DEFINED__
#define __ITextStoreAnchorServices_INTERFACE_DEFINED__

/* interface ITextStoreAnchorServices */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITextStoreAnchorServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e9fe-2021-11d2-93e0-0060b067b86e")
    ITextStoreAnchorServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Serialize( 
            /* [in] */ ITfProperty *pProp,
            /* [in] */ ITfRange *pRange,
            /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unserialize( 
            /* [in] */ ITfProperty *pProp,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream,
            /* [in] */ ITfPersistentPropertyLoaderAnchor *pLoader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForceLoadProperty( 
            /* [in] */ ITfProperty *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRange( 
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [out] */ ITfRangeAnchor **ppRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextStoreAnchorServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITextStoreAnchorServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITextStoreAnchorServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITextStoreAnchorServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ITextStoreAnchorServices * This,
            /* [in] */ ITfProperty *pProp,
            /* [in] */ ITfRange *pRange,
            /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream);
        
        HRESULT ( STDMETHODCALLTYPE *Unserialize )( 
            ITextStoreAnchorServices * This,
            /* [in] */ ITfProperty *pProp,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream,
            /* [in] */ ITfPersistentPropertyLoaderAnchor *pLoader);
        
        HRESULT ( STDMETHODCALLTYPE *ForceLoadProperty )( 
            ITextStoreAnchorServices * This,
            /* [in] */ ITfProperty *pProp);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRange )( 
            ITextStoreAnchorServices * This,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [out] */ ITfRangeAnchor **ppRange);
        
        END_INTERFACE
    } ITextStoreAnchorServicesVtbl;

    interface ITextStoreAnchorServices
    {
        CONST_VTBL struct ITextStoreAnchorServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextStoreAnchorServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextStoreAnchorServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextStoreAnchorServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextStoreAnchorServices_Serialize(This,pProp,pRange,pHdr,pStream)	\
    (This)->lpVtbl -> Serialize(This,pProp,pRange,pHdr,pStream)

#define ITextStoreAnchorServices_Unserialize(This,pProp,pHdr,pStream,pLoader)	\
    (This)->lpVtbl -> Unserialize(This,pProp,pHdr,pStream,pLoader)

#define ITextStoreAnchorServices_ForceLoadProperty(This,pProp)	\
    (This)->lpVtbl -> ForceLoadProperty(This,pProp)

#define ITextStoreAnchorServices_CreateRange(This,paStart,paEnd,ppRange)	\
    (This)->lpVtbl -> CreateRange(This,paStart,paEnd,ppRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_Serialize_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ ITfProperty *pProp,
    /* [in] */ ITfRange *pRange,
    /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
    /* [in] */ IStream *pStream);


void __RPC_STUB ITextStoreAnchorServices_Serialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_Unserialize_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ ITfProperty *pProp,
    /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
    /* [in] */ IStream *pStream,
    /* [in] */ ITfPersistentPropertyLoaderAnchor *pLoader);


void __RPC_STUB ITextStoreAnchorServices_Unserialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_ForceLoadProperty_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ ITfProperty *pProp);


void __RPC_STUB ITextStoreAnchorServices_ForceLoadProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_CreateRange_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd,
    /* [out] */ ITfRangeAnchor **ppRange);


void __RPC_STUB ITextStoreAnchorServices_CreateRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextStoreAnchorServices_INTERFACE_DEFINED__ */


#ifndef __ITfProperty2_INTERFACE_DEFINED__
#define __ITfProperty2_INTERFACE_DEFINED__

/* interface ITfProperty2 */
/* [unique][uuid][object] */ 

#define	TF_FNV_BACKWARD	( 0x1 )

#define	TF_FNV_NO_CONTAINED	( 0x2 )


EXTERN_C const IID IID_ITfProperty2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("db261faa-2142-486a-b5c6-d2101bc03d2e")
    ITfProperty2 : public ITfProperty
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindNextValue( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRangeQuery,
            /* [in] */ TfAnchor tfAnchorQuery,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BOOL *pfContained,
            /* [out] */ ITfRange **ppRangeNextValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfProperty2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfProperty2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfProperty2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfProperty2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ITfProperty2 * This,
            /* [out] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRanges )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ IEnumTfRanges **ppEnum,
            /* [in] */ ITfRange *pTargetRange);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ITfProperty2 * This,
            /* [out] */ ITfContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *FindRange )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRange **ppRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueStore )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ ITfPropertyStore *pPropStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ const VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange);
        
        HRESULT ( STDMETHODCALLTYPE *FindNextValue )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRangeQuery,
            /* [in] */ TfAnchor tfAnchorQuery,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BOOL *pfContained,
            /* [out] */ ITfRange **ppRangeNextValue);
        
        END_INTERFACE
    } ITfProperty2Vtbl;

    interface ITfProperty2
    {
        CONST_VTBL struct ITfProperty2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfProperty2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfProperty2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfProperty2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfProperty2_GetType(This,pguid)	\
    (This)->lpVtbl -> GetType(This,pguid)

#define ITfProperty2_EnumRanges(This,ec,ppEnum,pTargetRange)	\
    (This)->lpVtbl -> EnumRanges(This,ec,ppEnum,pTargetRange)

#define ITfProperty2_GetValue(This,ec,pRange,pvarValue)	\
    (This)->lpVtbl -> GetValue(This,ec,pRange,pvarValue)

#define ITfProperty2_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)


#define ITfProperty2_FindRange(This,ec,pRange,ppRange,aPos)	\
    (This)->lpVtbl -> FindRange(This,ec,pRange,ppRange,aPos)

#define ITfProperty2_SetValueStore(This,ec,pRange,pPropStore)	\
    (This)->lpVtbl -> SetValueStore(This,ec,pRange,pPropStore)

#define ITfProperty2_SetValue(This,ec,pRange,pvarValue)	\
    (This)->lpVtbl -> SetValue(This,ec,pRange,pvarValue)

#define ITfProperty2_Clear(This,ec,pRange)	\
    (This)->lpVtbl -> Clear(This,ec,pRange)


#define ITfProperty2_FindNextValue(This,ec,pRangeQuery,tfAnchorQuery,dwFlags,pfContained,ppRangeNextValue)	\
    (This)->lpVtbl -> FindNextValue(This,ec,pRangeQuery,tfAnchorQuery,dwFlags,pfContained,ppRangeNextValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfProperty2_FindNextValue_Proxy( 
    ITfProperty2 * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRangeQuery,
    /* [in] */ TfAnchor tfAnchorQuery,
    /* [in] */ DWORD dwFlags,
    /* [out] */ BOOL *pfContained,
    /* [out] */ ITfRange **ppRangeNextValue);


void __RPC_STUB ITfProperty2_FindNextValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfProperty2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctfp_0233 */
/* [local] */ 

#define	TF_DA_PRIORITY_HIGHEST	( 0 )

#define	TF_DA_PRIORITY_DEFAULT_SPELLING	( 8 )

#define	TF_DA_PRIORITY_DEFAULT_GRAMMAR	( 16 )

#define	TF_DA_PRIORITY_DEFAULT	( 24 )

#define	TF_DA_PRIORITY_LOWEST	( 31 )

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_msctfp_0233_0001
    {
    ULONG uPriority;
    GUID guidProperty;
    } 	TF_DA_PROPERTY;



extern RPC_IF_HANDLE __MIDL_itf_msctfp_0233_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctfp_0233_v0_0_s_ifspec;

#ifndef __IEnumTfCollection_INTERFACE_DEFINED__
#define __IEnumTfCollection_INTERFACE_DEFINED__

/* interface IEnumTfCollection */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1c760b20-ed66-4dbd-9ff1-68fc21c02922")
    IEnumTfCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfCollection **ppClone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_DA_PROPERTY *rgCollection,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfCollection * This,
            /* [out] */ IEnumTfCollection **ppClone);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfCollection * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_DA_PROPERTY *rgCollection,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfCollection * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfCollectionVtbl;

    interface IEnumTfCollection
    {
        CONST_VTBL struct IEnumTfCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfCollection_Clone(This,ppClone)	\
    (This)->lpVtbl -> Clone(This,ppClone)

#define IEnumTfCollection_Next(This,ulCount,rgCollection,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgCollection,pcFetched)

#define IEnumTfCollection_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfCollection_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfCollection_Clone_Proxy( 
    IEnumTfCollection * This,
    /* [out] */ IEnumTfCollection **ppClone);


void __RPC_STUB IEnumTfCollection_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfCollection_Next_Proxy( 
    IEnumTfCollection * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TF_DA_PROPERTY *rgCollection,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfCollection_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfCollection_Reset_Proxy( 
    IEnumTfCollection * This);


void __RPC_STUB IEnumTfCollection_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfCollection_Skip_Proxy( 
    IEnumTfCollection * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfCollection_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfCollection_INTERFACE_DEFINED__ */


#ifndef __ITfDisplayAttributeCollectionMgr_INTERFACE_DEFINED__
#define __ITfDisplayAttributeCollectionMgr_INTERFACE_DEFINED__

/* interface ITfDisplayAttributeCollectionMgr */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfDisplayAttributeCollectionMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4e3d2d48-3c17-457d-84a1-f209476de897")
    ITfDisplayAttributeCollectionMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumCollections( 
            /* [out] */ IEnumTfCollection **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfDisplayAttributeCollectionMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfDisplayAttributeCollectionMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfDisplayAttributeCollectionMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfDisplayAttributeCollectionMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCollections )( 
            ITfDisplayAttributeCollectionMgr * This,
            /* [out] */ IEnumTfCollection **ppEnum);
        
        END_INTERFACE
    } ITfDisplayAttributeCollectionMgrVtbl;

    interface ITfDisplayAttributeCollectionMgr
    {
        CONST_VTBL struct ITfDisplayAttributeCollectionMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfDisplayAttributeCollectionMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfDisplayAttributeCollectionMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfDisplayAttributeCollectionMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfDisplayAttributeCollectionMgr_EnumCollections(This,ppEnum)	\
    (This)->lpVtbl -> EnumCollections(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfDisplayAttributeCollectionMgr_EnumCollections_Proxy( 
    ITfDisplayAttributeCollectionMgr * This,
    /* [out] */ IEnumTfCollection **ppEnum);


void __RPC_STUB ITfDisplayAttributeCollectionMgr_EnumCollections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfDisplayAttributeCollectionMgr_INTERFACE_DEFINED__ */


#ifndef __ITfDisplayAttributeCollectionProvider_INTERFACE_DEFINED__
#define __ITfDisplayAttributeCollectionProvider_INTERFACE_DEFINED__

/* interface ITfDisplayAttributeCollectionProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfDisplayAttributeCollectionProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3977526d-1a0a-435a-8d06-ecc9516b484f")
    ITfDisplayAttributeCollectionProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCollectionCount( 
            /* [out] */ ULONG *puCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCollection( 
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ TF_DA_PROPERTY *prgProperty,
            /* [out] */ ULONG *pcGUIDsOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfDisplayAttributeCollectionProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfDisplayAttributeCollectionProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfDisplayAttributeCollectionProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfDisplayAttributeCollectionProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCollectionCount )( 
            ITfDisplayAttributeCollectionProvider * This,
            /* [out] */ ULONG *puCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetCollection )( 
            ITfDisplayAttributeCollectionProvider * This,
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ TF_DA_PROPERTY *prgProperty,
            /* [out] */ ULONG *pcGUIDsOut);
        
        END_INTERFACE
    } ITfDisplayAttributeCollectionProviderVtbl;

    interface ITfDisplayAttributeCollectionProvider
    {
        CONST_VTBL struct ITfDisplayAttributeCollectionProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfDisplayAttributeCollectionProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfDisplayAttributeCollectionProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfDisplayAttributeCollectionProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfDisplayAttributeCollectionProvider_GetCollectionCount(This,puCount)	\
    (This)->lpVtbl -> GetCollectionCount(This,puCount)

#define ITfDisplayAttributeCollectionProvider_GetCollection(This,uCount,prgProperty,pcGUIDsOut)	\
    (This)->lpVtbl -> GetCollection(This,uCount,prgProperty,pcGUIDsOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfDisplayAttributeCollectionProvider_GetCollectionCount_Proxy( 
    ITfDisplayAttributeCollectionProvider * This,
    /* [out] */ ULONG *puCount);


void __RPC_STUB ITfDisplayAttributeCollectionProvider_GetCollectionCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDisplayAttributeCollectionProvider_GetCollection_Proxy( 
    ITfDisplayAttributeCollectionProvider * This,
    /* [in] */ ULONG uCount,
    /* [length_is][size_is][out] */ TF_DA_PROPERTY *prgProperty,
    /* [out] */ ULONG *pcGUIDsOut);


void __RPC_STUB ITfDisplayAttributeCollectionProvider_GetCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfDisplayAttributeCollectionProvider_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctfp_0236 */
/* [local] */ 

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_msctfp_0236_0001
    {
    ITfRange *pRange;
    TF_DISPLAYATTRIBUTE tfDisplayAttr;
    } 	TF_RENDERINGMARKUP;



extern RPC_IF_HANDLE __MIDL_itf_msctfp_0236_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctfp_0236_v0_0_s_ifspec;

#ifndef __IEnumTfRenderingMarkup_INTERFACE_DEFINED__
#define __IEnumTfRenderingMarkup_INTERFACE_DEFINED__

/* interface IEnumTfRenderingMarkup */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfRenderingMarkup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8c03d21b-95a7-4ba0-ae1b-7fce12a72930")
    IEnumTfRenderingMarkup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfRenderingMarkup **ppClone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_RENDERINGMARKUP *rgMarkup,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfRenderingMarkupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfRenderingMarkup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfRenderingMarkup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfRenderingMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfRenderingMarkup * This,
            /* [out] */ IEnumTfRenderingMarkup **ppClone);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfRenderingMarkup * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_RENDERINGMARKUP *rgMarkup,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfRenderingMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfRenderingMarkup * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfRenderingMarkupVtbl;

    interface IEnumTfRenderingMarkup
    {
        CONST_VTBL struct IEnumTfRenderingMarkupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfRenderingMarkup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfRenderingMarkup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfRenderingMarkup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfRenderingMarkup_Clone(This,ppClone)	\
    (This)->lpVtbl -> Clone(This,ppClone)

#define IEnumTfRenderingMarkup_Next(This,ulCount,rgMarkup,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgMarkup,pcFetched)

#define IEnumTfRenderingMarkup_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfRenderingMarkup_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfRenderingMarkup_Clone_Proxy( 
    IEnumTfRenderingMarkup * This,
    /* [out] */ IEnumTfRenderingMarkup **ppClone);


void __RPC_STUB IEnumTfRenderingMarkup_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfRenderingMarkup_Next_Proxy( 
    IEnumTfRenderingMarkup * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TF_RENDERINGMARKUP *rgMarkup,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfRenderingMarkup_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfRenderingMarkup_Reset_Proxy( 
    IEnumTfRenderingMarkup * This);


void __RPC_STUB IEnumTfRenderingMarkup_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfRenderingMarkup_Skip_Proxy( 
    IEnumTfRenderingMarkup * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfRenderingMarkup_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfRenderingMarkup_INTERFACE_DEFINED__ */


#ifndef __ITfContextRenderingMarkup_INTERFACE_DEFINED__
#define __ITfContextRenderingMarkup_INTERFACE_DEFINED__

/* interface ITfContextRenderingMarkup */
/* [unique][uuid][object] */ 

#define	TF_GRM_INCLUDE_PROPERTY	( 0x1 )

#define	TF_FRM_INCLUDE_PROPERTY	( 0x1 )

#define	TF_FRM_BACKWARD	( 0x2 )

#define	TF_FRM_NO_CONTAINED	( 0x4 )

#define	TF_FRM_NO_RANGE	( 0x8 )


EXTERN_C const IID IID_ITfContextRenderingMarkup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a305b1c0-c776-4523-bda0-7c5a2e0fef10")
    ITfContextRenderingMarkup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRenderingMarkup( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITfRange *pRangeCover,
            /* [out] */ IEnumTfRenderingMarkup **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindNextRenderingMarkup( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITfRange *pRangeQuery,
            /* [in] */ TfAnchor tfAnchorQuery,
            /* [out] */ ITfRange **ppRangeFound,
            /* [out] */ TF_RENDERINGMARKUP *ptfRenderingMarkup) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContextRenderingMarkupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContextRenderingMarkup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContextRenderingMarkup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContextRenderingMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderingMarkup )( 
            ITfContextRenderingMarkup * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITfRange *pRangeCover,
            /* [out] */ IEnumTfRenderingMarkup **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindNextRenderingMarkup )( 
            ITfContextRenderingMarkup * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITfRange *pRangeQuery,
            /* [in] */ TfAnchor tfAnchorQuery,
            /* [out] */ ITfRange **ppRangeFound,
            /* [out] */ TF_RENDERINGMARKUP *ptfRenderingMarkup);
        
        END_INTERFACE
    } ITfContextRenderingMarkupVtbl;

    interface ITfContextRenderingMarkup
    {
        CONST_VTBL struct ITfContextRenderingMarkupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContextRenderingMarkup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContextRenderingMarkup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContextRenderingMarkup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContextRenderingMarkup_GetRenderingMarkup(This,ec,dwFlags,pRangeCover,ppEnum)	\
    (This)->lpVtbl -> GetRenderingMarkup(This,ec,dwFlags,pRangeCover,ppEnum)

#define ITfContextRenderingMarkup_FindNextRenderingMarkup(This,ec,dwFlags,pRangeQuery,tfAnchorQuery,ppRangeFound,ptfRenderingMarkup)	\
    (This)->lpVtbl -> FindNextRenderingMarkup(This,ec,dwFlags,pRangeQuery,tfAnchorQuery,ppRangeFound,ptfRenderingMarkup)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContextRenderingMarkup_GetRenderingMarkup_Proxy( 
    ITfContextRenderingMarkup * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ITfRange *pRangeCover,
    /* [out] */ IEnumTfRenderingMarkup **ppEnum);


void __RPC_STUB ITfContextRenderingMarkup_GetRenderingMarkup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextRenderingMarkup_FindNextRenderingMarkup_Proxy( 
    ITfContextRenderingMarkup * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ITfRange *pRangeQuery,
    /* [in] */ TfAnchor tfAnchorQuery,
    /* [out] */ ITfRange **ppRangeFound,
    /* [out] */ TF_RENDERINGMARKUP *ptfRenderingMarkup);


void __RPC_STUB ITfContextRenderingMarkup_FindNextRenderingMarkup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContextRenderingMarkup_INTERFACE_DEFINED__ */


#ifndef __ITfBackgroundThreadMgr_INTERFACE_DEFINED__
#define __ITfBackgroundThreadMgr_INTERFACE_DEFINED__

/* interface ITfBackgroundThreadMgr */
/* [unique][uuid][local][object] */ 

typedef BOOL ( *TfBackgroundThreadCallback )( 
    /* [in] */ BOOL fCleanup,
    /* [in] */ void *pvPrivate);

typedef BOOL ( *TfWakeAppBackgroundThreadProc )( void);


EXTERN_C const IID IID_ITfBackgroundThreadMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("38462b47-6127-4464-bd2f-46957c31ad0e")
    ITfBackgroundThreadMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AppInitBackgroundThread( 
            /* [in] */ TfWakeAppBackgroundThreadProc pfnWakeThread,
            /* [out] */ TfBackgroundThreadCallback *ppfnCallback,
            /* [out] */ void **ppvPrivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppUninitBackgroundThread( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdviseBackgroundCallback( 
            /* [in] */ TfBackgroundThreadCallback pfnCallback,
            /* [in] */ void *pvPrivate,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseBackgroundCallback( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WakeBackgroundThread( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfBackgroundThreadMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfBackgroundThreadMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfBackgroundThreadMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfBackgroundThreadMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *AppInitBackgroundThread )( 
            ITfBackgroundThreadMgr * This,
            /* [in] */ TfWakeAppBackgroundThreadProc pfnWakeThread,
            /* [out] */ TfBackgroundThreadCallback *ppfnCallback,
            /* [out] */ void **ppvPrivate);
        
        HRESULT ( STDMETHODCALLTYPE *AppUninitBackgroundThread )( 
            ITfBackgroundThreadMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseBackgroundCallback )( 
            ITfBackgroundThreadMgr * This,
            /* [in] */ TfBackgroundThreadCallback pfnCallback,
            /* [in] */ void *pvPrivate,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseBackgroundCallback )( 
            ITfBackgroundThreadMgr * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *WakeBackgroundThread )( 
            ITfBackgroundThreadMgr * This);
        
        END_INTERFACE
    } ITfBackgroundThreadMgrVtbl;

    interface ITfBackgroundThreadMgr
    {
        CONST_VTBL struct ITfBackgroundThreadMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfBackgroundThreadMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfBackgroundThreadMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfBackgroundThreadMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfBackgroundThreadMgr_AppInitBackgroundThread(This,pfnWakeThread,ppfnCallback,ppvPrivate)	\
    (This)->lpVtbl -> AppInitBackgroundThread(This,pfnWakeThread,ppfnCallback,ppvPrivate)

#define ITfBackgroundThreadMgr_AppUninitBackgroundThread(This)	\
    (This)->lpVtbl -> AppUninitBackgroundThread(This)

#define ITfBackgroundThreadMgr_AdviseBackgroundCallback(This,pfnCallback,pvPrivate,pdwCookie)	\
    (This)->lpVtbl -> AdviseBackgroundCallback(This,pfnCallback,pvPrivate,pdwCookie)

#define ITfBackgroundThreadMgr_UnadviseBackgroundCallback(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseBackgroundCallback(This,dwCookie)

#define ITfBackgroundThreadMgr_WakeBackgroundThread(This)	\
    (This)->lpVtbl -> WakeBackgroundThread(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfBackgroundThreadMgr_AppInitBackgroundThread_Proxy( 
    ITfBackgroundThreadMgr * This,
    /* [in] */ TfWakeAppBackgroundThreadProc pfnWakeThread,
    /* [out] */ TfBackgroundThreadCallback *ppfnCallback,
    /* [out] */ void **ppvPrivate);


void __RPC_STUB ITfBackgroundThreadMgr_AppInitBackgroundThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfBackgroundThreadMgr_AppUninitBackgroundThread_Proxy( 
    ITfBackgroundThreadMgr * This);


void __RPC_STUB ITfBackgroundThreadMgr_AppUninitBackgroundThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfBackgroundThreadMgr_AdviseBackgroundCallback_Proxy( 
    ITfBackgroundThreadMgr * This,
    /* [in] */ TfBackgroundThreadCallback pfnCallback,
    /* [in] */ void *pvPrivate,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB ITfBackgroundThreadMgr_AdviseBackgroundCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfBackgroundThreadMgr_UnadviseBackgroundCallback_Proxy( 
    ITfBackgroundThreadMgr * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITfBackgroundThreadMgr_UnadviseBackgroundCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfBackgroundThreadMgr_WakeBackgroundThread_Proxy( 
    ITfBackgroundThreadMgr * This);


void __RPC_STUB ITfBackgroundThreadMgr_WakeBackgroundThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfBackgroundThreadMgr_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctfp_0239 */
/* [local] */ 

#endif // MSCTFP_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_msctfp_0239_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctfp_0239_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\nddeagnt.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Private interface definition for having the NetDDE agent application
start the NetDDE services on the fly.

Created 11/5/93     SanfordS

--*/


#include <dde.h>
#define SZ_NDDEAGNT_SERVICE    TEXT("NDDEAgnt")
#define SZ_NDDEAGNT_TOPIC      TEXT("Start NetDDE Services")
#define SZ_NDDEAGNT_TITLE      TEXT("NetDDE Agent")
#define SZ_NDDEAGNT_CLASS      TEXT("NDDEAgnt")

#define START_NETDDE_SERVICES(hwnd)    {                                \
        ATOM aService, aTopic;                                          \
                                                                        \
        aService = GlobalAddAtom(SZ_NDDEAGNT_SERVICE);                  \
        aTopic = GlobalAddAtom(SZ_NDDEAGNT_TOPIC);                      \
        SendMessage(FindWindow(SZ_NDDEAGNT_CLASS, SZ_NDDEAGNT_TITLE),   \
                WM_DDE_INITIATE,                                        \
                (WPARAM)hwnd, MAKELPARAM(aService, aTopic));            \
        GlobalDeleteAtom(aService);                                     \
        GlobalDeleteAtom(aTopic);                                       \
    }

#define NETDDE_PIPE     L"\\\\.\\pipe\\NetDDE"

typedef struct {
    DWORD dwOffsetDesktop;
    WCHAR awchNames[64];
} NETDDE_PIPE_MESSAGE, *PNETDDE_PIPE_MESSAGE;


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\pbt.h ===
/*++ BUILD Version: 0000     Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    pbt.h

Abstract:

    Definitions for the Virtual Power Management Device.

Revision History:

    DATE        REV DESCRIPTION
    ----------- --- ----------------------------------------
    15 Jan 1994 TCS Original implementation.

--*/

#ifndef _INC_PBT
#define _INC_PBT


#define WM_POWERBROADCAST               0x0218

#ifndef _WIN32_WCE
#define PBT_APMQUERYSUSPEND             0x0000
#define PBT_APMQUERYSTANDBY             0x0001

#define PBT_APMQUERYSUSPENDFAILED       0x0002
#define PBT_APMQUERYSTANDBYFAILED       0x0003

#define PBT_APMSUSPEND                  0x0004
#define PBT_APMSTANDBY                  0x0005

#define PBT_APMRESUMECRITICAL           0x0006
#define PBT_APMRESUMESUSPEND            0x0007
#define PBT_APMRESUMESTANDBY            0x0008

#define PBTF_APMRESUMEFROMFAILURE       0x00000001

#define PBT_APMBATTERYLOW               0x0009
#define PBT_APMPOWERSTATUSCHANGE        0x000A

#define PBT_APMOEMEVENT                 0x000B
#define PBT_APMRESUMEAUTOMATIC          0x0012
#endif
#endif // _INC_PBT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\ntgdistr.h ===
/******************************Module*Header*******************************\
* Module Name: ntgdistr.h
*
* Copyright (c) Microsoft Corporation. All rights reserved.
\**************************************************************************/

// PUBLIC Structures and constants

typedef enum _ARCTYPE
{
    ARCTYPE_ARC = 0,
    ARCTYPE_ARCTO,
    ARCTYPE_CHORD,
    ARCTYPE_PIE,
    ARCTYPE_MAX
} ARCTYPE;


//
// Font Types
//

typedef enum _LFTYPE {
    LF_TYPE_USER,                // user (defined by APP)
    LF_TYPE_SYSTEM,              // system stock font
    LF_TYPE_SYSTEM_FIXED,        // system fixed pitch stock font
    LF_TYPE_OEM,                 // oem (terminal) stock font
    LF_TYPE_DEVICE_DEFAULT,      // device default stock font
    LF_TYPE_ANSI_VARIABLE,       // ANSI variable pitch stock font
    LF_TYPE_ANSI_FIXED,          // ANSI fixed pitch stock font
    LF_TYPE_DEFAULT_GUI          // default GUI stock font
} LFTYPE;


// for GetDCDWord

#define DDW_JOURNAL             0
#define DDW_RELABS              1
#define DDW_BREAKEXTRA          2
#define DDW_CBREAK              3
#define DDW_ARCDIRECTION        4
#define DDW_SAVEDEPTH           5
#define DDW_FONTLANGUAGEINFO    6
#define DDW_ISMEMDC             7
#define DDW_MAPMODE             8
#define DDW_TEXTCHARACTEREXTRA  9
#define DDW_MAX                 10  // must equal highest DDW_XXXXX plus one

// for GetAndSetDCDword
#define GASDDW_EPSPRINTESCCALLED   1
#define GASDDW_COPYCOUNT           2
#define GASDDW_TEXTALIGN           3
#define GASDDW_RELABS              4
#define GASDDW_TEXTCHARACTEREXTRA  5
#define GASDDW_SELECTFONT          6
#define GASDDW_MAPPERFLAGS         7
#define GASDDW_MAPMODE             8
#define GASDDW_ARCDIRECTION        9
#define GASDDW_MAX                10  // must equal highest GASDDW_XXXXX plus one

// for GetDCPoint
#define DCPT_VPEXT                 1
#define DCPT_WNDEXT                2
#define DCPT_VPORG                 3
#define DCPT_WNDORG                4
#define DCPT_ASPECTRATIOFILTER     5
#define DCPT_DCORG                 6
#define DCPT_MAX                   7 // must equal highest DCPT_XXXXX plus one

// for GetAndSetDCPoint
#define GASDCPT_CURRENTPOSITION    1
#define GASDCPT_MAX                2 // must equal highest GASDCPT_XXXXX plus one


// private ModifyWorldTransform modes

#define MWT_SET     (MWT_MAX+1)

// modes from converting points

#define XFP_DPTOLP                 0
#define XFP_LPTODP                 1
#define XFP_LPTODPFX               2

//BUGBUG private devcaps for client side xform's

#define HORZSIZEM (int)0x80000000
#define VERTSIZEM (int)0x80000002

//
// Object identifiers
//

#define MFEN_IDENTIFIER     0x5845464D  /* 'MFEN' */
#define MFPICT_IDENTIFIER   0x5F50464D  /* 'MFP_' */

//
// Object types, used for handles.
//
// Note: When modifying this list, also please modify list in hmgrapi.cxx!
//

#define DEF_TYPE            0
#define DC_TYPE             1
#define UNUSED1_TYPE        2   // Unused
#define UNUSED2_TYPE        3   // Unused
#define RGN_TYPE            4
#define SURF_TYPE           5
#define CLIENTOBJ_TYPE      6
#define PATH_TYPE           7
#define PAL_TYPE            8
#define ICMLCS_TYPE         9
#define LFONT_TYPE          10
#define RFONT_TYPE          11
#define PFE_TYPE            12
#define PFT_TYPE            13
#define ICMCXF_TYPE         14
#define SPRITE_TYPE         15
#define BRUSH_TYPE          16
#define UMPD_TYPE           17
#define UNUSED4_TYPE        18  // Unused
#define SPACE_TYPE          19
#define UNUSED5_TYPE        20  // Unused
#define META_TYPE           21
#define EFSTATE_TYPE        22
#define BMFD_TYPE           23  // Unused
#define VTFD_TYPE           24  // Unused
#define TTFD_TYPE           25  // Unused
#define RC_TYPE             26  // Unused
#define TEMP_TYPE           27  // Unused
#define DRVOBJ_TYPE         28
#define DCIOBJ_TYPE         29  // Unused
#define SPOOL_TYPE          30
#define MAX_TYPE            30  // Don't go over 31 -- limited by TYPE_BITS

// SAMEHANDLE/DIFFHANDLE macros
//
// These macros should be used to compare engine handles (such as HDCs, etc),
// when insensitivity to the user defined bits are needed.

// BUGBUG - this should be accessible to USER

#define SAMEHANDLE(H,K) (H == K)
#define DIFFHANDLE(H,K) (H != K)


// the following define the format of GDI handles.  Any information that is needed
// for the type is here.  All other handle information is in gre\hmgr.h.

#define INDEX_BITS         16
#define TYPE_BITS           5
#define ALTTYPE_BITS        2
#define STOCK_BITS          1
#define UNIQUE_BITS         8

#define TYPE_SHIFT          (INDEX_BITS)
#define ALTTYPE_SHIFT       (TYPE_SHIFT + TYPE_BITS)
#define STOCK_SHIFT         (ALTTYPE_SHIFT + ALTTYPE_BITS)

#define MAX_HANDLE_COUNT     0x10000
#define DEFAULT_HANDLE_QUOTA 0x02710

#define MAKE_HMGR_HANDLE(Index,Unique) LongToHandle(((((LONG) Unique) << INDEX_BITS) | ((LONG) Index)))
#define FULLUNIQUE_MASK     0xffff0000
#define FULLUNIQUE_STOCK_MASK (1 << (TYPE_BITS+ALTTYPE_BITS))

// if the GDISTOCKOBJ bit is set in a handle, it is a stock object.

#define GDISTOCKOBJ         (1 << STOCK_SHIFT)
#define IS_STOCKOBJ(h)      ((ULONG_PTR)(h) & GDISTOCKOBJ)

// LO_TYPE(h)  returns the client side type given a GRE handle.
// GRE_TYPE(h) returns the gre side type given a client type

#define LO_TYPE(h)          (DWORD)((ULONG_PTR)(h) & (((1 << (TYPE_BITS + ALTTYPE_BITS)) - 1) << TYPE_SHIFT))
#define GRE_TYPE(h)         (DWORD)(((ULONG_PTR)(h) >> INDEX_BITS) & ((1 << TYPE_BITS) - 1))

// ALTTYPEx are modifiers to distinguish client side object types that all map to
// a single server side type.  BRUSH_TYPE maps to LO_BRUSH_TYPE, LO_PEN_TYPE and LO_EXTPEN_TYPE

#define ALTTYPE1            (1 << ALTTYPE_SHIFT)
#define ALTTYPE2            (2 << ALTTYPE_SHIFT)
#define ALTTYPE3            (3 << ALTTYPE_SHIFT)

#define LO_BRUSH_TYPE       (BRUSH_TYPE     << TYPE_SHIFT)
#define LO_DC_TYPE          (DC_TYPE        << TYPE_SHIFT)
#define LO_BITMAP_TYPE      (SURF_TYPE      << TYPE_SHIFT)
#define LO_PALETTE_TYPE     (PAL_TYPE       << TYPE_SHIFT)
#define LO_FONT_TYPE        (LFONT_TYPE     << TYPE_SHIFT)
#define LO_REGION_TYPE      (RGN_TYPE       << TYPE_SHIFT)
#define LO_ICMLCS_TYPE      (ICMLCS_TYPE    << TYPE_SHIFT)
#define LO_CLIENTOBJ_TYPE   (CLIENTOBJ_TYPE << TYPE_SHIFT)

#define LO_ALTDC_TYPE       (LO_DC_TYPE        | ALTTYPE1)
#define LO_PEN_TYPE         (LO_BRUSH_TYPE     | ALTTYPE1)
#define LO_EXTPEN_TYPE      (LO_BRUSH_TYPE     | ALTTYPE2)
#define LO_DIBSECTION_TYPE  (LO_BITMAP_TYPE    | ALTTYPE1)
#define LO_METAFILE16_TYPE  (LO_CLIENTOBJ_TYPE | ALTTYPE1)
#define LO_METAFILE_TYPE    (LO_CLIENTOBJ_TYPE | ALTTYPE2)
#define LO_METADC16_TYPE    (LO_CLIENTOBJ_TYPE | ALTTYPE3)


//
// Format of HGDIOBJ typedef'ed so it
//  is available in the symbol file.
//
typedef struct {
    ULONG_PTR Index:INDEX_BITS;
    ULONG_PTR Type:TYPE_BITS;
    ULONG_PTR AltType:ALTTYPE_BITS;
    ULONG_PTR Stock:STOCK_BITS;
    ULONG_PTR Unique:UNIQUE_BITS;
} GDIHandleBitFields;


//
// Enum of object types so the values
//  are available in the symbol file.
//
#define ENUMObjType(type)   GDIObjType_##type = type
typedef enum {
    ENUMObjType(DEF_TYPE),
    ENUMObjType(DC_TYPE),
    ENUMObjType(UNUSED1_TYPE),
    ENUMObjType(UNUSED2_TYPE),
    ENUMObjType(RGN_TYPE),
    ENUMObjType(SURF_TYPE),
    ENUMObjType(CLIENTOBJ_TYPE),
    ENUMObjType(PATH_TYPE),
    ENUMObjType(PAL_TYPE),
    ENUMObjType(ICMLCS_TYPE),
    ENUMObjType(LFONT_TYPE),
    ENUMObjType(RFONT_TYPE),
    ENUMObjType(PFE_TYPE),
    ENUMObjType(PFT_TYPE),
    ENUMObjType(ICMCXF_TYPE),
    ENUMObjType(SPRITE_TYPE),
    ENUMObjType(BRUSH_TYPE),
    ENUMObjType(UMPD_TYPE),
    ENUMObjType(UNUSED4_TYPE),
    ENUMObjType(SPACE_TYPE),
    ENUMObjType(UNUSED5_TYPE),
    ENUMObjType(META_TYPE),
    ENUMObjType(EFSTATE_TYPE),
    ENUMObjType(BMFD_TYPE),
    ENUMObjType(VTFD_TYPE),
    ENUMObjType(TTFD_TYPE),
    ENUMObjType(RC_TYPE),
    ENUMObjType(TEMP_TYPE),
    ENUMObjType(DRVOBJ_TYPE),
    ENUMObjType(DCIOBJ_TYPE),
    ENUMObjType(SPOOL_TYPE),
    ENUMObjType(MAX_TYPE),

    GDIObjTypeTotal
} GDIObjType;

#define ENUMLoObjType(type)   GDILoObjType_##type = type
typedef enum {
    ENUMLoObjType(LO_BRUSH_TYPE),
    ENUMLoObjType(LO_DC_TYPE),
    ENUMLoObjType(LO_BITMAP_TYPE),
    ENUMLoObjType(LO_PALETTE_TYPE),
    ENUMLoObjType(LO_FONT_TYPE),
    ENUMLoObjType(LO_REGION_TYPE),
    ENUMLoObjType(LO_ICMLCS_TYPE),
    ENUMLoObjType(LO_CLIENTOBJ_TYPE),

    ENUMLoObjType(LO_ALTDC_TYPE),
    ENUMLoObjType(LO_PEN_TYPE),
    ENUMLoObjType(LO_EXTPEN_TYPE),
    ENUMLoObjType(LO_DIBSECTION_TYPE),
    ENUMLoObjType(LO_METAFILE16_TYPE),
    ENUMLoObjType(LO_METAFILE_TYPE),
    ENUMLoObjType(LO_METADC16_TYPE),
} GDILoObjType;


// fl values for CreateDIBitmapInternal

#define CDBI_INTERNAL           0x0001
#define CDBI_DIBSECTION         0x0002
#define CDBI_NOPALETTE          0x0004


// The UFI allows us to identify four different items:
//
// Device Fonts: CheckSum = 0 and Index identifies the printer driver index of font to
//               use.  Since we assume drivers are identical on both machines we can
//               rely on Index being enough to identify the font.
//
// Type1 Device Fonts: This refers to a Type1 font that has been installed on
//                     the client machine and is enumerated by the postcript driver
//                     as a device font.  In this case CheckSum = 1 and Index
//                     is the checksum of the Type 1 font file.
//
// Type1 Rasterizer: This item identifies not a font, but a Type1 rasterizer.
//                   Here CheckSum = 2 and Index is the version number of the
//                   Type1 rasterizer.  A rasterizer with version number N supports
//                   fonts used by a rasterizers with versions 0-N.  If a rasterizer
//                   exists on a server, this UFI MUST appear FIRST in the list of
//                   UFI's returned to the client.
//
// Engine Font: This includes bitmap, vector, TT, and Type1 fonts rasterized by
//              a Type1 rasterizer.  Here CheckSum is a checksum of the font file
//              and Index is the index of the face in the font file.

#define DEVICE_FONT_TYPE             0
#define TYPE1_FONT_TYPE              1
#define TYPE1_RASTERIZER             2
#define A_VALID_ENGINE_CHECKSUM      3

#define UFI_DEVICE_FONT(pufi) ((pufi)->CheckSum == DEVICE_FONT_TYPE)
#define UFI_TYPE1_FONT(pufi) ((pufi)->CheckSum == TYPE1_FONT_TYPE)
#define UFI_TYPE1_RASTERIZER(pufi) ((pufi)->CheckSum == TYPE1_RASTERIZER)
#define UFI_ENGINE_FONT(pufi) ((pufi)->CheckSum > TYPE1_RASTERIZER)

#define UFI_HASH_VALUE(pufi) (((pufi)->CheckSum==TYPE1_FONT_TYPE) ?                   \
                              (pufi)->Index : (pufi)->CheckSum )

#define UFI_SAME_FACE(pufi1,pufi2)                                                    \
    (((pufi1)->CheckSum == (pufi2)->CheckSum) && ((pufi1)->Index == (pufi2)->Index))

#define UFI_SAME_FILE(pufi1,pufi2) ((((pufi1)->CheckSum==TYPE1_FONT_TYPE)  && ((pufi2)->CheckSum==TYPE1_FONT_TYPE)) ?  \
                                    ((pufi1)->Index == (pufi2)->Index)  :             \
                                    ((pufi1)->CheckSum == (pufi2)->CheckSum))

#define UFI_SAME_RASTERIZER_VERSION(pufiClient,pufiServer)                            \
    (((pufiClient)->CheckSum == (pufiServer)->CheckSum) &&                            \
     ((pufiClient)->Index <= (pufiServer)->Index))

#define UFI_CLEAR_ID(pufi) {(pufi)->CheckSum = (pufi)->Index = 0;}


/*


/**************************************************************************\
 *
 *  // The pointer arithmetic for ENUMFONTDATAW is as follows:
 *
 *  sizeof(ENUMLOGFONTEXW)+sizeof(data appended to logfont) =
 *      dpNtmi - offsetof(ENUMFONTDATAW,u);
 *
 *  sizeof(NTMW_INTERNAL) + sizeof(data appended to NTMW_INTERNAL) =
 *      cjEfdw - dpNtmi;
 *
 *  // typically, if we are talking about mm font we will have:
 *
 *  data appended to logfont       = design vector
 *  data appended to NTMW_INTERNAL = full axes information
 *
\**************************************************************************/

#if (_WIN32_WINNT >= 0x0500)
typedef struct _ENUMFONTDATAW {  // efdw
    ULONG              cjEfdw;   // size of this structure
    ULONG              dpNtmi;   // offset to NTMW_INTERNAL from the top of efdw
    FLONG              flType;
    ENUMLOGFONTEXDVW   elfexw;
// here follows NTMW_INTERNAL at the offset of dpNtmi
} ENUMFONTDATAW, *PENUMFONTDATAW;
#endif

#define ALIGN4(X) (((X) + 3) & ~3)
#define ALIGN8(X) (((X) + 7) & ~7)

// here we define dpNtmi and cjEfdw for "regular", non multiple master fonts:

#if (_WIN32_WINNT >= 0x0500)
#define DP_NTMI0 ALIGN4(offsetof(ENUMFONTDATAW,elfexw) + offsetof(ENUMLOGFONTEXDVW,elfDesignVector) + offsetof(DESIGNVECTOR,dvValues))
#endif
#define CJ_NTMI0 ALIGN4(offsetof(NTMW_INTERNAL,entmw)  + offsetof(ENUMTEXTMETRICW,etmAxesList) + offsetof(AXESLISTW,axlAxisInfo))
#define CJ_EFDW0 (DP_NTMI0 + CJ_NTMI0)


// ENUMFONTDATAW.flType internal values:
//
// ENUMFONT_SCALE_HACK          [Win95 compat] Enumerate font back in several
//                              sizes; mask out before doing callback to app.

#define ENUMFONT_SCALE_HACK  0x80000000
#define ENUMFONT_FLTYPE_MASK ( DEVICE_FONTTYPE | RASTER_FONTTYPE | TRUETYPE_FONTTYPE )

// GreGetTextExtentW flags

#define GGTE_WIN3_EXTENT        0x0001
#define GGTE_GLYPH_INDEX        0x0002

/******************************************************************************
 * stuff for client side text extents and charwidths
 ******************************************************************************/

#define GCW_WIN3          0x00000001    // win3 bold simulation off-by-1 hack
#define GCW_INT           0x00000002    // integer or float
#define GCW_16BIT         0x00000004    // 16-bit or 32-bit widths
#define GCW_GLYPH_INDEX   0x00000008    // input are glyph indices

// stuff for GetCharABCWidths

#define GCABCW_INT            0x00000001
#define GCABCW_GLYPH_INDEX    0x00000002

// stuff for GetTextExtentEx

#define GTEEX_GLYPH_INDEX        0x0001


/**************************************************************************\
 *
 * stuff from csgdi.h
 *
\**************************************************************************/

#define CJSCAN(width,planes,bits) ((((width)*(planes)*(bits)+31) & ~31) / 8)
#define CJSCANW(width,planes,bits) ((((width)*(planes)*(bits)+15) & ~15) / 8)

#define I_ANIMATEPALETTE            0
#define I_SETPALETTEENTRIES         1
#define I_GETPALETTEENTRIES         2
#define I_GETSYSTEMPALETTEENTRIES   3
#define I_GETDIBCOLORTABLE          4
#define I_SETDIBCOLORTABLE          5

#define I_POLYPOLYGON   1
#define I_POLYPOLYLINE  2
#define I_POLYBEZIER    3
#define I_POLYLINETO    4
#define I_POLYBEZIERTO  5
#define I_POLYPOLYRGN   6


HANDLE WINAPI SetObjectOwner(HGDIOBJ, HANDLE);

// BUGBUG
// RANDOM floating point stuff - try to cleanup later.
// BUGBUG
// We littered modules with __CPLUSPLUS to not conflict with efloat.hxx
// efloat.hxx should more or less disappear.
//

#if defined(_AMD64_) || defined(_IA64_) || defined(BUILD_WOW6432)

  typedef FLOAT EFLOAT_S;

  #define EFLOAT_0        ((FLOAT) 0)
  #define EFLOAT_1Over16  ((FLOAT) 1/16)
  #define EFLOAT_1        ((FLOAT) 1)
  #define EFLOAT_16       ((FLOAT) 16)

  #ifndef __CPLUSPLUS

    extern LONG lCvtWithRound( FLOAT f, LONG l );

    #define efDivEFLOAT(x,y,z) (x=y/z)
    #define vAbsEFLOAT(x)      {if (x<0.0f) x=-x;}
    #define vFxToEf(fx,ef)     {ef = ((FLOAT) fx) / 16.0f;}
    #define vMulEFLOAT(x,y,z)  {x=y*z;}
    #define lEfToF(x)          (*(LONG *)(&x))  // Warning: FLOAT typed as LONG!

    #define bIsOneEFLOAT(x)   (x==1.0f)
    #define bIsOneSixteenthEFLOAT(x)   (x==0.0625f)
    #define bEqualEFLOAT(x,y) (x==y)

    #define lCvt(ef,ll) (lCvtWithRound(ef,ll))
  #endif

#else

  typedef struct _EFLOAT_S
  {
      LONG    lMant;
      LONG    lExp;
  } EFLOAT_S;

  #define EFLOAT_0        {0, 0}
  #define EFLOAT_1Over16  {0x040000000, -2}
  #define EFLOAT_1        {0x040000000, 2}
  #define EFLOAT_16       {0x040000000, 6}


  #ifndef __CPLUSPLUS

    EFLOAT_S *mulff3_c(EFLOAT_S *,const EFLOAT_S *,const EFLOAT_S *);
    EFLOAT_S *divff3_c(EFLOAT_S *,const EFLOAT_S *,const EFLOAT_S *);
    VOID      fxtoef_c(LONG,EFLOAT_S *);
    LONG      eftof_c(EFLOAT_S *);

    #define efDivEFLOAT(x,y,z) (*divff3_c(&x,&y,&z))
    #define vAbsEFLOAT(x)      {if (x.lMant<0) x.lMant=-x.lMant;}
    #define vFxToEf(fx,ef)     (fxtoef_c(fx,&ef))
    #define vMulEFLOAT(x,y,z)  {mulff3_c(&x,&y,&z);}
    #define lEfToF(x)          (eftof_c(&x))  // Warning: FLOAT typed as LONG!

    #define bEqualEFLOAT(x,y) ((x.lMant==y.lMant)&&(x.lExp==y.lExp))
    #define bIsOneEFLOAT(x)   ((x.lMant==0x40000000L)&&(x.lExp==2))
    #define bIsOneSixteenthEFLOAT(x)   ((x.lMant==0x40000000L)&&(x.lExp==-2))

    LONG lCvt(EFLOAT_S,LONG);
  #endif

#endif





typedef struct _WIDTHDATA
{
    USHORT      sOverhang;
    USHORT      sHeight;
    USHORT      sCharInc;
    USHORT      sBreak;
    BYTE        iFirst;
    BYTE        iLast;
    BYTE        iBreak;
    BYTE        iDefault;
    USHORT      sDBCSInc;
    USHORT      sDefaultInc;
} WIDTHDATA;

#define NO_WIDTH 0xFFFF

typedef struct _DEVCAPS
{
    ULONG ulVersion;
    ULONG ulTechnology;
    ULONG ulHorzSizeM;
    ULONG ulVertSizeM;
    ULONG ulHorzSize;
    ULONG ulVertSize;
    ULONG ulHorzRes;
    ULONG ulVertRes;
    ULONG ulBitsPixel;
    ULONG ulPlanes;
    ULONG ulNumPens;
    ULONG ulNumFonts;
    ULONG ulNumColors;
    ULONG ulRasterCaps;
    ULONG ulAspectX;
    ULONG ulAspectY;
    ULONG ulAspectXY;
    ULONG ulLogPixelsX;
    ULONG ulLogPixelsY;
    ULONG ulSizePalette;
    ULONG ulColorRes;
    ULONG ulPhysicalWidth;
    ULONG ulPhysicalHeight;
    ULONG ulPhysicalOffsetX;
    ULONG ulPhysicalOffsetY;
    ULONG ulTextCaps;
    ULONG ulVRefresh;
    ULONG ulDesktopHorzRes;
    ULONG ulDesktopVertRes;
    ULONG ulBltAlignment;
    ULONG ulPanningHorzRes;
    ULONG ulPanningVertRes;
    ULONG xPanningAlignment;
    ULONG yPanningAlignment;
    ULONG ulShadeBlendCaps;
    ULONG ulColorManagementCaps;
} DEVCAPS, *PDEVCAPS;

// This structure is a copy from d3dhal.h. We need it here to have exactly
// the same offset for pvBuffer in D3DNTHAL_CONTEXTCREATEI
typedef struct _D3DHAL_CONTEXTCREATEDATA_DUMMY
{
    LPVOID  lpDDGbl;
    LPVOID  lpDDS;
    LPVOID  lpDDSZ;
    LPVOID  dwrstates;
    LPVOID  dwhContext;
    HRESULT ddrval;     
} D3DHAL_CONTEXTCREATEDATA_DUMMY;

// For D3D context creation information.
typedef struct _D3DNTHAL_CONTEXTCREATEI
{
    // Space for a D3DNTHAL_CONTEXTCREATE record.
    // The structure isn't directly declared here to
    // avoid header inclusion problems.  This field
    // is asserted to be the same size as the actual type.
    D3DHAL_CONTEXTCREATEDATA_DUMMY ContextCreateData;

    // Private buffer information.
    PVOID pvBuffer;
    ULONG cjBuffer;
} D3DNTHAL_CONTEXTCREATEI;

//
// D3D execute buffer batching declarations.
//

#define D3DEX_BATCH_SURFACE_MAX 4

typedef struct _D3DEX_BATCH_HEADER
{
    DWORD nSurfaces;
    DWORD pdds[D3DEX_BATCH_SURFACE_MAX];
} D3DEX_BATCH_HEADER;

#define D3DEX_BATCH_STATE          0
#define D3DEX_BATCH_PRIMITIVE      1
#define D3DEX_BATCH_PRIMITIVE_EXE  2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\profmapp.h ===
//=============================================================================
//  profmapp.h  -   Header file for user remap API.
//
//  Copyright (c) Microsoft Corporation 1995-1999
//  All rights reserved
//
//=============================================================================

//=============================================================================
//
// RemapUserProfile
//
// Changes the security of a user profile from one user to another.
//
// pComputer    - Specifies the computer to run the API on
// dwFlags      - Specifies zero or more REMAP_PROFILE_* flags
// pCurrentSid  - Specifies the existing user's SID
// pNewSid      - Specifies the new SID for the profile
//
// Returns:  TRUE if successful
//           FALSE if not.
//
//=============================================================================

#define REMAP_PROFILE_NOOVERWRITE           0x0001
#define REMAP_PROFILE_NOUSERNAMECHANGE      0x0002
#define REMAP_PROFILE_KEEPLOCALACCOUNT      0x0004

USERENVAPI
BOOL
WINAPI
RemapUserProfileA(
    LPCSTR pComputer,
    DWORD dwFlags,
    PSID pSidCurrent,
    PSID pSidNew
    );
USERENVAPI
BOOL
WINAPI
RemapUserProfileW(
    LPCWSTR pComputer,
    DWORD dwFlags,
    PSID pSidCurrent,
    PSID pSidNew
    );
#ifdef UNICODE
#define RemapUserProfile  RemapUserProfileW
#else
#define RemapUserProfile  RemapUserProfileA
#endif // !UNICODE

BOOL
WINAPI
InitializeProfileMappingApi (
    VOID
    );


//=============================================================================
//
// RemapAndMoveUser
//
// Transfers security settings and the user profile for one user to
// another.
//
// pComputer    - Specifies the computer to run the API on
// dwFlags      - Specifies zero or mor REMAP_PROFILE_* flags
// pCurrentUser - Specifies the existing user's SID
// pNewUser     - Specifies the new SID for the profile
//
// Returns:  TRUE if successful
//           FALSE if not.
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
RemapAndMoveUserA(
    LPCSTR pComputer,
    DWORD dwFlags,
    LPCSTR pCurrentUser,
    LPCSTR pNewUser
    );
USERENVAPI
BOOL
WINAPI
RemapAndMoveUserW(
    LPCWSTR pComputer,
    DWORD dwFlags,
    LPCWSTR pCurrentUser,
    LPCWSTR pNewUser
    );
#ifdef UNICODE
#define RemapAndMoveUser  RemapAndMoveUserW
#else
#define RemapAndMoveUser  RemapAndMoveUserA
#endif // !UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\setup_netdde.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    setup_netdde.c

Abstract:

    This is used by syssetup to enable netdde.  It's generated from various files under
    windows\netdde.  Do not edit by hand.

Revision History:

--*/

#ifndef H__shrtrust
#define H__shrtrust

/*
    NetDDE will fill in the following structure and pass it to NetDDE
    Agent whenever it wants to have an app started in the user's
    context.  The reason for the sharename and modifyId is to that
    a user must explicitly permit NetDDE to start an app on behalf of
    other users.
 */

#define NDDEAGT_CMD_REV         1
#define NDDEAGT_CMD_MAGIC       0xDDE1DDE1

/*      commands        */
#define NDDEAGT_CMD_WINEXEC     0x1
#define NDDEAGT_CMD_WININIT     0x2

/*      return status   */
#define NDDEAGT_START_NO        0x0

#define NDDEAGT_INIT_NO         0x0
#define NDDEAGT_INIT_OK         0x1

typedef struct {
    DWORD       dwMagic;        // must be NDDEAGT_CMD_MAGIC
    DWORD       dwRev;          // must be 1
    DWORD       dwCmd;          // one of above NDDEAGT_CMD_*
    DWORD       qwModifyId[2];  // modify Id of the share
    UINT        fuCmdShow;      // fuCmdShow to use with WinExec()
    char        szData[1];      // sharename\0 cmdline\0
} NDDEAGTCMD;
typedef NDDEAGTCMD *PNDDEAGTCMD;

#define DDE_SHARE_KEY_MAX           512
#define TRUSTED_SHARES_KEY_MAX      512
#define TRUSTED_SHARES_KEY_SIZE     15
#define KEY_MODIFY_ID_SIZE          8

#define DDE_SHARES_KEY_A                "SOFTWARE\\Microsoft\\NetDDE\\DDE Shares"
#define TRUSTED_SHARES_KEY_A            "SOFTWARE\\Microsoft\\NetDDE\\DDE Trusted Shares"
#define DEFAULT_TRUSTED_SHARES_KEY_A    "DEFAULT\\"##TRUSTED_SHARES_KEY_A
#define TRUSTED_SHARES_KEY_PREFIX_A     "DDEDBi"
#define TRUSTED_SHARES_KEY_DEFAULT_A    "DDEDBi12345678"
#define KEY_MODIFY_ID_A                 "SerialNumber"
#define KEY_DB_INSTANCE_A               "ShareDBInstance"
#define KEY_CMDSHOW_A                   "CmdShow"
#define KEY_START_APP_A                 "StartApp"
#define KEY_INIT_ALLOWED_A              "InitAllowed"

#define DDE_SHARES_KEY_W                L"SOFTWARE\\Microsoft\\NetDDE\\DDE Shares"
#define TRUSTED_SHARES_KEY_W            L"SOFTWARE\\Microsoft\\NetDDE\\DDE Trusted Shares"
#define DEFAULT_TRUSTED_SHARES_KEY_W    L"DEFAULT\\"##TRUSTED_SHARES_KEY_W
#define TRUSTED_SHARES_KEY_PREFIX_W     L"DDEDBi"
#define TRUSTED_SHARES_KEY_DEFAULT_W    L"DDEDBi12345678"
#define KEY_MODIFY_ID_W                 L"SerialNumber"
#define KEY_DB_INSTANCE_W               L"ShareDBInstance"
#define KEY_CMDSHOW_W                   L"CmdShow"
#define KEY_START_APP_W                 L"StartApp"
#define KEY_INIT_ALLOWED_W              L"InitAllowed"

#define DDE_SHARES_KEY                  TEXT(DDE_SHARES_KEY_A)
#define TRUSTED_SHARES_KEY              TEXT(TRUSTED_SHARES_KEY_A)
#define DEFAULT_TRUSTED_SHARES_KEY      TEXT(DEFAULT_TRUSTED_SHARES_KEY_A)
#define TRUSTED_SHARES_KEY_PREFIX       TEXT(TRUSTED_SHARES_KEY_PREFIX_A)
#define TRUSTED_SHARES_KEY_DEFAULT      TEXT(TRUSTED_SHARES_KEY_DEFAULT_A)
#define KEY_MODIFY_ID                   TEXT(KEY_MODIFY_ID_A)
#define KEY_DB_INSTANCE                 TEXT(KEY_DB_INSTANCE_A)
#define KEY_CMDSHOW                     TEXT(KEY_CMDSHOW_A)
#define KEY_START_APP                   TEXT(KEY_START_APP_A)
#define KEY_INIT_ALLOWED                TEXT(KEY_INIT_ALLOWED_A)

#endif

#include    <strsafe.h>

#if DBG
#define KdPrint(_x_) DbgPrint _x_
#else
#define KdPrint(_x_)
#endif

ULONG DbgPrint(PCH Format, ...);

BOOL GetDBSerialNumber(DWORD *lpdwId);
BOOL GetDBInstance(char *lpszBuf);

TCHAR    szShareKey[] = DDE_SHARES_KEY;
CHAR    szSetup[] = "NetDDE Setup";

#define	SHARES_TO_INIT 3

CHAR *szShareNames[SHARES_TO_INIT] = {
    "Chat$"     ,
    "Hearts$"   ,
    "CLPBK$"
};

BOOL
CreateShareDBInstance()
{
    HKEY            hKey;
    LONG            lRtn;
    BOOL            bOK = TRUE;
    DWORD           InstanceId;
    time_t          time_tmp;

    /*  Create the DDE Share database in the registry if it does not exist. */
    lRtn = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
		  szShareKey,
		  0,
		  KEY_SET_VALUE,
		  &hKey );

    if( lRtn == ERROR_SUCCESS ) {
        /*
         * create data base instance value
         */
        srand((int) time(&time_tmp));
        InstanceId = rand() * rand();
        lRtn = RegSetValueEx( hKey,
            KEY_DB_INSTANCE, 0,
            REG_DWORD,
            (LPBYTE)&InstanceId,
            sizeof( DWORD ) );
        if( lRtn == ERROR_SUCCESS ) {
        } else {
            KdPrint(("SETUPDLL: CreateShareDBInstnace: RegSetValueEx %x failed (%u)\n",InstanceId,lRtn));
            bOK = FALSE;
        }
        RegCloseKey( hKey );
    } else {
    /* Share DB key should have been created from default hives */
        KdPrint(("SETUPDLL: CreateShareDBInstnace: RegOpenKey %s failed (%u)\n",szShareKey,lRtn));
        bOK = FALSE;
    }
    return(bOK);
}

BOOL
CreateDefaultTrust(
HKEY hKeyUserRoot)
{
    HKEY    hKey;
    DWORD   dwDisp;
    DWORD   ret;
    BOOL    bOK;
    char    szTrustedShareKey[TRUSTED_SHARES_KEY_MAX];
    char    szShareKey[DDE_SHARE_KEY_MAX];
    char    szDBInstance[TRUSTED_SHARES_KEY_SIZE + 1];
    DWORD   dwId[2];
    DWORD   dwFlag;
    int	    nLoop;


    if (!GetDBInstance(szDBInstance)) {
        return(FALSE);
    }

    if (!GetDBSerialNumber(dwId)) {
        KdPrint(("SETUPDLL: CreateDefaultTrust: GetDBSerialNumber failed.\n"));
        return(FALSE);
    }

    for (nLoop = 0, bOK = TRUE;
        (nLoop < SHARES_TO_INIT) && bOK ;
            nLoop++) {
        /*
         * For each share to init...
         */

        KdPrint(("Shareing %s\n", szShareNames[nLoop]));

        /*
         * Build up szTrustedSharesKey IAW the DBInstance sring.
         */
        StringCchPrintfA( szTrustedShareKey,
                TRUSTED_SHARES_KEY_MAX,
                "%s\\%s\\%s",
                TRUSTED_SHARES_KEY_A,
                szDBInstance,
                szShareNames[nLoop] );

        /*
         * Create the trusted share key (hKey)
         */
        ret = RegCreateKeyExA( hKeyUserRoot, szTrustedShareKey,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_WRITE,
                NULL,
                &hKey,
                &dwDisp );

        if( ret != ERROR_SUCCESS )  {
            KdPrint(("SETUPDLL: CreateDefaultTrust: RegCreateKeyEx failed on HKEY_CURRENT_USER\\%s. (%u)\n",
                    szTrustedShareKey, ret));
            return(FALSE);
        }

        /*
         * Get the serial number of the database.  Note that the SN of each
         * trust share must == the SN of the database.  Since the non-trusted
         * shares may not have the latest database SN, update all of them to
         * the current database SN as well.  This allows apps like winchat to
         * work when they are called from outside the machine even though they
         * have never been run - which would fix the SNs of their trusts because
         * they automatically set up their trusts.
         */

        /*
         * Set the SN of the trusted share
         */
        ret = RegSetValueEx( hKey,
		       KEY_MODIFY_ID,
		       0,
		       REG_BINARY,
		       (LPBYTE)&dwId,
		       KEY_MODIFY_ID_SIZE );

        if (ret == ERROR_SUCCESS) {
            /*
             * set the StartApp flag to 1
             */
            dwFlag = 1;
            ret = RegSetValueEx( hKey,
                KEY_START_APP,
                0,
                REG_DWORD,
                (LPBYTE)&dwFlag,
                sizeof( DWORD ) );

            if (ret == ERROR_SUCCESS) {
                /*
                 * Set the InitAllowed flag to 1 too.
                 */
   	            ret = RegSetValueEx( hKey,
                    KEY_INIT_ALLOWED,
                    0,
                    REG_DWORD,
                    (LPBYTE)&dwFlag,
                    sizeof( DWORD ) );
            }
        }

        RegCloseKey(hKey);

        if (ret != ERROR_SUCCESS) {
            KdPrint(("SETUPDLL: CreateDefaultTrust: RegSetValueEx failed (%u)\n",ret));
            return(FALSE);
        }

        /*
         * Build up szShareKey
         */
        StringCchPrintfA( szShareKey,
            DDE_SHARE_KEY_MAX,
            "%s\\%s",
            DDE_SHARES_KEY_A,
            szShareNames[nLoop] );

        /*
         * Now open up the base share
         */
        ret = RegOpenKeyExA(
                HKEY_LOCAL_MACHINE,
                szShareKey,
                REG_OPTION_NON_VOLATILE,
                KEY_WRITE,
                &hKey);

        if (ret != ERROR_SUCCESS) {
            KdPrint(("SETUPDLL: CreateDefaultTrust: RegOpenKeyEx failed on HKEY_LOCAL_MACHINE\\%s. (%u)\n",
                    szShareKey, ret));
            if (ret != ERROR_ACCESS_DENIED) {
                return(FALSE);
            }
        }

        if (ret == ERROR_SUCCESS) {
            ret = RegSetValueEx( hKey,
    		       KEY_MODIFY_ID,
    		       0,
    		       REG_BINARY,
    		       (LPBYTE)&dwId,
    		       KEY_MODIFY_ID_SIZE );

            RegCloseKey(hKey);

            if (ret != ERROR_SUCCESS) {
                KdPrint(("SETUPDLL: CreateDefaultTrust: RegSetValueEx on HKEY_LOCAL_MACHINE\\%s failed (%u)\n",
                        KEY_MODIFY_ID, ret));
                return(FALSE);
            }
        }

    } // end for

    return(TRUE);
}



BOOL
GetDBInstance(char *lpszBuf)
{
    LONG    lRtn;
    HKEY    hKey;
    DWORD   dwInstance;
    DWORD   dwType = REG_DWORD;
    DWORD   cbData = sizeof(DWORD);

    lRtn = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                szShareKey,
                0,
                KEY_QUERY_VALUE,
                &hKey );
    if (lRtn != ERROR_SUCCESS) {        /* unable to open DB key */
        KdPrint(("SETUPDLL: GetDBInstance: RegOpenKeyEx %s failed (%u)\n",szShareKey,lRtn));
        return(FALSE);
    }
    lRtn = RegQueryValueEx( hKey,
                KEY_DB_INSTANCE,
                NULL,
                &dwType,
                (LPBYTE)&dwInstance, &cbData );
    RegCloseKey(hKey);
    if (lRtn != ERROR_SUCCESS) {        /* unable to open DB key */
        KdPrint(("SETUPDLL: GetDBInstance: RegQueryValueEx failed (%u)\n",lRtn));
        return(FALSE);
    }
    StringCchPrintfA(lpszBuf, TRUSTED_SHARES_KEY_SIZE + 1, "%s%08X", TRUSTED_SHARES_KEY_PREFIX, dwInstance);
    return(TRUE);
}


BOOL
GetDBSerialNumber(
DWORD *lpdwId)
{
    LONG    lRtn;
    HKEY    hKey;
    DWORD   dwType = REG_BINARY;
    DWORD   cbData = KEY_MODIFY_ID_SIZE;

    lRtn = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                szShareKey,
                0,
                KEY_QUERY_VALUE,
                &hKey );
    if (lRtn != ERROR_SUCCESS) {        /* unable to open DB key */
        return(FALSE);
    }
    lRtn = RegQueryValueEx( hKey,
                KEY_MODIFY_ID,
                NULL,
                &dwType,
                (LPBYTE)lpdwId, &cbData );
    RegCloseKey(hKey);
    if (lRtn != ERROR_SUCCESS) {        /* unable to open DB key */
        return(FALSE);
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\ntgdispl.h ===
/******************************Module*Header*******************************\
* Module Name: ntgdispl.h
*
* Created: 21-Feb-1995 10:05:31
* Author:  Eric Kutter [erick]
*
* Copyright (c) Microsoft Corporation. All rights reserved.
*
\**************************************************************************/

#define GDISPOOL_API                0x80000000

#ifndef W32KAPI
#define W32KAPI  DECLSPEC_ADDRSAFE
#endif

// NON-API GDISPOOL calls must NOT have MSB set
#define GDISPOOL_TERMINATETHREAD       0x00000000
#define GDISPOOL_INPUT2SMALL           0x00000001
#define GDISPOOL_GETPATHNAME           0x00000002
#define GDISPOOL_UNLOADDRIVER_COMPLETE 0x00000003

// API GDISPOOL messages MUST have MSB set
#define GDISPOOL_WRITE              0x80000000
#define GDISPOOL_OPENPRINTER        0x80000001
#define GDISPOOL_CLOSEPRINTER       0x80000002
#define GDISPOOL_ABORTPRINTER       0x80000003
#define GDISPOOL_STARTDOCPRINTER    0x80000004
#define GDISPOOL_STARTPAGEPRINTER   0x80000005
#define GDISPOOL_ENDPAGEPRINTER     0x80000006
#define GDISPOOL_ENDDOCPRINTER      0x80000007
#define GDISPOOL_GETPRINTERDRIVER   0x80000008
#define GDISPOOL_GETPRINTERDATA     0x80000009
#define GDISPOOL_SETPRINTERDATA     0x8000000a
#define GDISPOOL_ENUMFORMS          0x8000000b
#define GDISPOOL_GETFORM            0x8000000c
#define GDISPOOL_GETPRINTER         0x8000000d

DECLARE_HANDLE(HSPOOLOBJ);

/*********************************Class************************************\
* SPOOLESC
*
*   structure used to communicate between the kernel and spooler process
*
*
* History:
*  27-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

typedef struct _SPOOLESC
{
    ULONG  cj;          // size of this structure including ajData[]
    ULONG  iMsg;        // message index GDISPOOL_...
    HANDLE hSpool;      // spoolss spooler handle
    ULONG  cjOut;       // required size of output buffer

    HSPOOLOBJ hso;      // kernel spool obj

    ULONG  ulRet;       // return value from spooler API

    BYTE  ajData[1];
} SPOOLESC, *PSPOOLESC;

/****************************************************************************
*  GREOPENPRINTER
*  GRESTARTDOCPRINTER
*  GREWRITEPRINTER
*  GREGETPRINTERDATA
*
*  The following structures are used package up the data unique to each
* spooler API
*
*
*  History:
*   5/1/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

typedef struct _GREOPENPRINTER
{
    LONG              cj;
    LONG              cjName;
    LONG              cjDatatype;
    LONG              cjDevMode;
    PRINTER_DEFAULTSW pd;
    LONG              alData[1];

} GREOPENPRINTER;

typedef struct _GREGETPRINTERDRIVER
{
    LONG            cj;
    LONG            cjEnv;
    DWORD           dwLevel;
    LONG            cjData;
    LONG            alData[1];
} GREGETPRINTERDRIVER;


typedef struct _GRESTARTDOCPRINTER
{
    LONG            cj;
    LONG            cjDocName;
    LONG            cjOutputFile;
    HANDLE          hFile;
    DWORD           TargetProcessID;
    LONG            cjDatatype;
    LONG            cjData;
    LONG            alData[1];
} GRESTARTDOCPRINTER;


typedef struct _GREWRITEPRINTER
{
    LONG            cj;
    PULONG          pUserModeData;
    ULONG           cjUserModeData;
    LONG            cjData;
    LONG            alData[1];
} GREWRITEPRINTER;


typedef struct _GREGETPRINTERDATA
{
    LONG            cj;
    LONG            cjValueName;
    DWORD           dwType;
    DWORD           dwNeeded;
    LONG            cjData;
    LONG            alData[1];
} GREGETPRINTERDATA;


typedef struct _GRESETPRINTERDATA
{
    LONG            cj;
    LONG            cjType;
    LONG            cjPrinterData;
    DWORD           dwType;
    LONG            alData[1];
} GRESETPRINTERDATA;


typedef struct _GREENUMFORMS
{
    LONG            cj;
    DWORD           dwLevel;
    LONG            cjData;
    LONG            nForms;
    LONG            alData[1];
} GREENUMFORMS;


typedef struct _GREGETPRINTER
{
    LONG            cj;
    DWORD           dwLevel;
    LONG            cjData;
    LONG            alData[1];
} GREGETPRINTER;


typedef struct _GREGETFORM
{
    LONG            cj;
    LONG            cjFormName;
    DWORD           dwLevel;
    LONG            cjData;
    LONG            alData[1];
} GREGETFORM;


typedef struct _GREINPUT2SMALL
{
    LONG            cj;
    DWORD            dwNeeded;
    BYTE            *pjPsm;
} GREINPUT2SMALL;


typedef struct _GETPATHNAME
{
    LONG            cj;
    WCHAR           awcPath[MAX_PATH+1];
} GREGETPATHNAME;

/**************************************************************************\
 *
 * gre internal spooler entry points
 *
\**************************************************************************/

ULONG GreGetSpoolMessage(PSPOOLESC, PBYTE, ULONG, PULONG, ULONG);

BOOL WINAPI
GreEnumFormsW(
   HANDLE hSpool,
   GREENUMFORMS *pEnumForms,
   GREENUMFORMS *pEnumFormsReturn,
   LONG cjOut );

BOOL
GreGenericW(
    HANDLE hSpool,
    PULONG pX,
    PULONG pXReturn,
    LONG   cjOut,
    LONG   MessageID,
    ULONG  ulFlag );

BOOL WINAPI
GreGetPrinterDriverW(
   HANDLE hSpool,
   GREGETPRINTERDRIVER *pGetPrinterDriver,
   GREGETPRINTERDRIVER *pGetPrinterDriverReturn,
   LONG cjOut );

DWORD
GreStartDocPrinterW(
    HANDLE hSpool,
    GRESTARTDOCPRINTER *pStartDocPrinter,
    GRESTARTDOCPRINTER *pStartDocPrinterReturn
);

BOOL
WINAPI
GreOpenPrinterW(
   GREOPENPRINTER *pOpenPrinter,
   LPHANDLE  phPrinter);


ULONG
GreWritePrinter(
    HANDLE hSpool,
    GREWRITEPRINTER  *pWritePrinter);

BOOL
GrePrinterDriverUnloadW(
    LPWSTR pDriverName);

W32KAPI
BOOL APIENTRY
NtGdiInitSpool();

W32KAPI
ULONG APIENTRY
NtGdiGetSpoolMessage(
    PSPOOLESC psesc,
    ULONG cjMsg,
    PULONG pulOut,
    ULONG cjOut);

ULONG APIENTRY
SendSimpleMessage(
    HANDLE hSpool,
    ULONG iMsg,
    DWORD dwSpoolInstance);

BOOL APIENTRY
GdiInitSpool();

ULONG APIENTRY
GdiGetSpoolMessage(
    PSPOOLESC psesc,
    ULONG cjMsg,
    PULONG pulOut,
    ULONG cjOut);

ULONG APIENTRY
GdiSpoolEsc(
    HANDLE hSpool,
    ULONG iMsg,
    PBYTE pjIn,
    ULONG cjIn,
    PBYTE pjOut,
    ULONG cjOut);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\shimhapi.h ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    shim.h
//
// History:    May-99   clupu       Created.
//             Aug-99   v-johnwh    Various bug fixes.
//          23-Nov-99   markder     Support for multiple shim DLLs, chaining
//                                  of hooks. General clean-up.
//          11-Feb-00   markder     Reverted to W2K shipped shim structures.
// 
// Desc:    Contains all structure and function definitions for the shim mechanism.
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef __SHIM_H__
#define __SHIM_H__

struct tagHOOKAPI;

typedef struct tagHOOKAPIEX {
    DWORD               dwShimID;
    struct tagHOOKAPI   *pTopOfChain;
    struct tagHOOKAPI   *pNext;
} HOOKAPIEX, *PHOOKAPIEX;

typedef struct tagHOOKAPI {
    
    char*   pszModule;                  // the name of the module
    char*   pszFunctionName;            // the name of the API in the module
    PVOID   pfnNew;                     // pointer to the new stub API
    PVOID   pfnOld;                     // pointer to the old API
    DWORD   dwFlags;                    // used internally - important info about status
    union {
        struct tagHOOKAPI *pNextHook;   // used internally - (obsolete -- old mechanism)
        PHOOKAPIEX pHookEx;             // used internally - pointer to an internal extended info struct
    };
} HOOKAPI, *PHOOKAPI;

/*
 * If the hook DLL ever patches LoadLibraryA/W it must call PatchNewModules
 * so that the shim knows to patch any new loaded DLLs
 */
typedef VOID (*PFNPATCHNEWMODULES)(VOID);

typedef PHOOKAPI (*PFNGETHOOKAPIS)(LPSTR pszCmdLine,
                                   PFNPATCHNEWMODULES pfnPatchNewModules,
                                   DWORD* pdwHooksCount);

#define SHIM_COMMAND_LINE_MAX_BUFFER 1024

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\shimdb.h ===
/*--

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    shimdb.h

Abstract:

    header for the database file access functions used by the App Compat shimming system

Author:

    dmunsil 02/02/2000

Revision History:

Notes:

    This "database" is more of a tagged file, designed to mimic the structure of an XML
    file. An XML file can be converted into this packed data format easily, and all strings
    will by default be packed into a stringtable and referenced by a DWORD identifier, so files
    that contain a lot of common strings (like the XML used by the App Compat tema) will not
    bloat.

    To see the actual tags used by the shimdb, look in shimtags.h.

    For the high-level interface used by the loader in NTDLL, look at ntbaseapi.c

--*/

#ifndef _SHIMDB_H_
#define _SHIMDB_H_

/*++

    Supported configurations:

        UNICODE with NT apis
        ANSI    with WIN32 apis

    By default the library is UNICODE
    To use (and link) Win32 library


--*/

#ifdef SDB_ANSI_LIB

    #define LPCTSTR LPCSTR
    #define LPTSTR  LPSTR
    #define TCHAR   CHAR

#else

    #define LPCTSTR LPCWSTR
    #define LPTSTR  LPWSTR
    #define TCHAR   WCHAR

#endif

#define SDBAPI          STDAPICALLTYPE


typedef WORD            TAG;
typedef WORD            TAG_TYPE;

typedef DWORD           TAGID;
typedef DWORD           TAG_OFFSET;
typedef DWORD           STRINGREF;
typedef DWORD           INDEXID;

#define TAGID_NULL      0
#define STRINGREF_NULL  0
#define INDEXID_NULL    ((INDEXID)-1)
#define TAG_NULL        0

#define TAGID_ROOT      0 // implied root list tag that can be passed in as a parent

#define TAG_SIZE_UNFINISHED 0xFFFFFFFF

//
// define TAGREF so we can use tags accross databases
//
typedef DWORD           TAGREF;

///////////////////////////////////////////////////////////////////////////////
//
// TAG TYPES
//

//
// The most significant 4 bits tell you the basic type and size of data,
// and the lower 12 are the specific tag.
//
// In this way, even if we add more tags to the db, older readers can read
// the data because the type is either implied (for the first 5 types)
// or supplied (for all other types).
//
// WARNING: it is important that only the first 5 types have implied sizes.
// any future types should use a size or backwards compatibility will not be
// maintained.

//
// The following tags have an implied size.
//
#define TAG_TYPE_NULL           0x1000  // implied size 0
#define TAG_TYPE_BYTE           0x2000  // implied size 1
#define TAG_TYPE_WORD           0x3000  // implied size 2
#define TAG_TYPE_DWORD          0x4000  // implied size 4
#define TAG_TYPE_QWORD          0x5000  // implied size 8
#define TAG_TYPE_STRINGREF      0x6000  // implied size 4, for strings that should be tokenized

//
// These tags have a size after them (the size is type TAG_OFFSET)
//
#define TAG_TYPE_LIST           0x7000
#define TAG_TYPE_STRING         0x8000
#define TAG_TYPE_BINARY         0x9000


#define TAGREF_NULL 0
#define TAGREF_ROOT 0


//
// Special define for stripping out just the type from a tag.
//
#define TAG_STRIP_TYPE          0xF000

//
// This macro strips off the lower bits of the TAG and returns the upper bits, which
// give the basic type of tag. All the tag types are defined above.
//
// The type info is purely used internally by the DB to tell whether the tag has
// an implied size, or if the DB needs to do something special with the data before
// handing it back to the caller.
//

#define GETTAGTYPE(tag)         ((tag) & TAG_STRIP_TYPE)


typedef PVOID HSDB;


struct tagHOOKAPI;


typedef struct tagHOOKAPIEX {
    DWORD               dwShimID;
    struct tagHOOKAPI*  pTopOfChain;
    struct tagHOOKAPI*  pNext;

} HOOKAPIEX, *PHOOKAPIEX;

typedef struct tagHOOKAPI {

    char*   pszModule;                  // the name of the module
    char*   pszFunctionName;            // the name of the API in the module
    PVOID   pfnNew;                     // pointer to the new stub API
    PVOID   pfnOld;                     // pointer to the old API
    DWORD   dwFlags;                    // used internally - important info about status
    union {
        struct tagHOOKAPI* pNextHook;   // used internally - (obsolete -- old mechanism)
        PHOOKAPIEX pHookEx;             // used internally - pointer to an internal extended
                                        //                   info struct
    };
} HOOKAPI, *PHOOKAPI;

//
// OBSOLETE !
//
// If the hook DLL ever patches LoadLibraryA/W it must call PatchNewModules
// so that the shim knows to patch any new loaded DLLs
//
typedef VOID (*PFNPATCHNEWMODULES)(VOID);

typedef PHOOKAPI (*PFNGETHOOKAPIS)(LPSTR   pszCmdLine,
                                   LPWSTR  pwszShim,
                                   DWORD*  pdwHooksCount);

//
// These structures are part of the protocol between NTVDM and the shim engine
// for patching task "import tables"
//
typedef struct tagAPIDESC {

    char*   pszModule;
    char*   pszApi;

} APIDESC, *PAPIDESC;


typedef struct tagVDMTABLE {

    int         nApiCount;

    PVOID*      ppfnOrig;
    APIDESC*    pApiDesc;

} VDMTABLE, *PVDMTABLE;



//
// Shim engine notification events
//
#define SN_STATIC_DLLS_INITIALIZED      1
#define SN_PROCESS_DYING                2
#define SN_DLL_LOADING                  3

//
// This is the prototype for the notification function
// that the shim engine calls into the shim DLLs for various
// reasons (defined above).
//
typedef void (*PFNNOTIFYSHIMS)(int nReason, UINT_PTR extraInfo);


#define SHIM_COMMAND_LINE_MAX_BUFFER    1024

///////////////////////////////////////////////////////////////////////////////
//
// PATCH STRUCTURES
//

typedef struct _PATCHOP {

    DWORD   dwOpcode;               // Opcode to be performed
    DWORD   dwNextOpcode;           // Relative offset to next opcode
    #pragma warning( disable : 4200 )
    BYTE    data[];                 // Data for this operation type is dependent
                                    // on the op-code.
    #pragma warning( default : 4200 )

} PATCHOP, *PPATCHOP;

typedef struct _RELATIVE_MODULE_ADDRESS {

    DWORD address;           // Relative address from beginning of loaded module
    BYTE  reserved[3];       // Reserved for system use
    WCHAR moduleName[32];    // Module name for this address.

} RELATIVE_MODULE_ADDRESS, *PRELATIVE_MODULE_ADDRESS;

typedef struct _PATCHWRITEDATA {

    DWORD                   dwSizeData;     // Size of patch data in bytes
    RELATIVE_MODULE_ADDRESS rva;            // Relative address where this patch data is
                                            // to be applied.
    #pragma warning( disable : 4200 )
    BYTE                    data[];         // Patch data bytes.
    #pragma warning( default : 4200 )

} PATCHWRITEDATA, *PPATCHWRITEDATA;

typedef struct _PATCHMATCHDATA {

    DWORD                   dwSizeData;     // Size of matching data data in bytes
    RELATIVE_MODULE_ADDRESS rva;            // Relative address where this patch data is
                                            // to be verified.
    #pragma warning( disable : 4200 )
    BYTE                    data[];         // Matching data bytes.
    #pragma warning( default : 4200 )

} PATCHMATCHDATA, *PPATCHMATCHDATA;


typedef enum _PATCHOPCODES {

    PEND = 0, // no more opcodes
    PSAA,     // Set Activate Address, SETACTIVATEADDRESS
    PWD,      // Patch Write Data, PATCHWRITEDATA
    PNOP,     // No Operation
    PMAT,     // Patch match the matching bytes but do not replace the bytes.

} PATCHOPCODES;


//
// HEADER STRUCTURE
//
#define SHIMDB_MAGIC            0x66626473  // 'sdbf' (reversed because of little-endian ordering)
#define SHIMDB_MAJOR_VERSION    2           // Don't change this unless fundamentals
                                            // change (like TAG size, etc.)

#define SHIMDB_MINOR_VERSION    0           // This is for info only -- ignored on read

typedef struct _DB_HEADER {
    DWORD       dwMajorVersion;
    DWORD       dwMinorVersion;
    DWORD       dwMagic;
} DB_HEADER, *PDB_HEADER;

//
// INDEX_RECORD STRUCTURE
//

#pragma pack (push, 4)
typedef struct _INDEX_RECORD {
    ULONGLONG   ullKey;
    TAGID       tiRef;
} INDEX_RECORD;

typedef INDEX_RECORD UNALIGNED *PINDEX_RECORD;

#pragma pack (pop)



//
// Forward declaration.
//
struct _DB;
typedef struct _DB* PDB;


//
// This flag is used in apphelp entries.
// When set, it denotes entries that only have apphelp information.
//
#define SHIMDB_APPHELP_ONLY     0x00000001


typedef enum _PATH_TYPE {
    DOS_PATH,
    NT_PATH
} PATH_TYPE;

typedef struct _FIND_INFO {
    TAGID       tiIndex;
    TAGID       tiCurrent;
    TAGID       tiEndIndex; // last record after FindFirst if index is UNIQUE
    TAG         tName;

    DWORD       dwIndexRec;
    DWORD       dwFlags;
    ULONGLONG   ullKey;      // calculated key for this entry

    union {
        LPCTSTR     szName;
        DWORD       dwName;  // for dword search
        GUID*       pguidName;
    };

} FIND_INFO, *PFIND_INFO;

#define SDB_MAX_LAYERS  8
#define SDB_MAX_EXES    4
#define SDB_MAX_SDBS    16

typedef struct tagSDBQUERYRESULT {

    TAGREF atrExes[SDB_MAX_EXES];
    TAGREF atrLayers[SDB_MAX_LAYERS];
    DWORD  dwLayerFlags;
    TAGREF trAppHelp;                   // If there is an apphelp to display, the EXE
                                        // entry will be here.

    DWORD  dwExeCount;                  // number of elements in atrexes
    DWORD  dwLayerCount;                // number of elements in atrLayers

    GUID   guidID;                      // last exe's GUID
    DWORD  dwFlags;                     // last exe's flags

    //
    // New entries are here to preserve compatibility.
    // Only some entries will be valid in this map.
    //
    DWORD  dwCustomSDBMap;              // entry map, technically not needed
    GUID   rgGuidDB[SDB_MAX_SDBS];

} SDBQUERYRESULT, *PSDBQUERYRESULT;


//
// Information related to TAG_DRIVER tag in the db.
// Use SdbReadDriverInformation to retrieve this struct.
//
typedef struct tagENTRYINFO {

    GUID     guidID;                   // guid ID for this entry
    DWORD    dwFlags;                  // registry flags for this exe
    TAGID    tiData;                   // optional id for a TAG_DATA tag
    GUID     guidDB;                   // optional guid for the database where
                                       // this entry is located
} SDBENTRYINFO, *PSDBENTRYINFO;


//
// Flags used by SDBDATABASEINFO.dwFlags
//
#define DBINFO_GUID_VALID   0x00000001
#define DBINFO_SDBALLOC     0x10000000

typedef struct tagSDBDATABASEINFO {

    DWORD    dwFlags;         // flags -- which struct members are valid (and
                              // perhaps flags relevant to db content in the future
    DWORD    dwVersionMajor;  // major version
    DWORD    dwVersionMinor;  // minor version (time stamp)
    LPTSTR   pszDescription;  // description, optional
    GUID     guidDB;          // database id

} SDBDATABASEINFO, *PSDBDATABASEINFO;


#if defined(_WIN64)
    #define DEFAULT_IMAGE IMAGE_FILE_MACHINE_IA64
#else
    #define DEFAULT_IMAGE IMAGE_FILE_MACHINE_I386
#endif

//
// special image type -- which represents a mixture of image types
// depending on the component. It is used (as name implies) by MSI
// this value is not used by any of the IMAGE_FILE_MACHINE_* constants
//
#define IMAGE_FILE_MSI 0x7FFF


///////////////////////////////////////////////////////////////////////////////
//
// APIs to read/write/access the shim database
//


//
// READ functions
//

BYTE
SDBAPI
SdbReadBYTETag(
    IN  PDB   pdb,
    IN  TAGID tiWhich,
    IN  BYTE  jDefault
    );

WORD
SDBAPI
SdbReadWORDTag(
    IN  PDB   pdb,
    IN  TAGID tiWhich,
    IN  WORD  wDefault
    );

DWORD
SDBAPI
SdbReadDWORDTag(
    IN  PDB   pdb,
    IN  TAGID tiWhich,
    IN  DWORD dwDefault
    );

ULONGLONG
SDBAPI
SdbReadQWORDTag(
    IN  PDB       pdb,
    IN  TAGID     tiWhich,
    IN  ULONGLONG qwDefault
    );

BOOL
SDBAPI
SdbReadBinaryTag(
    IN  PDB   pdb,
    IN  TAGID tiWhich,
    OUT PBYTE pBuffer,
    IN  DWORD dwBufferSize
    );

BOOL
SDBAPI
SdbReadStringTag(
    IN  PDB    pdb,
    IN  TAGID  tiWhich,
    OUT LPTSTR pwszBuffer,
    IN  DWORD  cchBufferSize
    );

LPTSTR
SDBAPI
SdbGetStringTagPtr(
    IN  PDB   pdb,
    IN  TAGID tiWhich
    );


BYTE
SDBAPI
SdbReadBYTETagRef(
    IN  HSDB   hSDB,
    IN  TAGREF trWhich,
    IN  BYTE   jDefault
    );

WORD
SDBAPI
SdbReadWORDTagRef(
    IN  HSDB   hSDB,
    IN  TAGREF trWhich,
    IN  WORD   wDefault
    );

DWORD
SDBAPI
SdbReadDWORDTagRef(
    IN  HSDB   hSDB,
    IN  TAGREF trWhich,
    IN  DWORD  dwDefault
    );

ULONGLONG
SDBAPI
SdbReadQWORDTagRef(
    IN  HSDB      hSDB,
    IN  TAGREF    trWhich,
    IN  ULONGLONG qwDefault
    );

BOOL
SDBAPI
SdbReadStringTagRef(
    IN  HSDB   hSDB,
    IN  TAGREF trWhich,
    OUT LPTSTR pwszBuffer,
    IN  DWORD  cchBufferSize
    );


//
// GENERAL ACCESS FUNCTIONS
//

TAGID
SDBAPI
SdbGetFirstChild(
    IN  PDB   pdb,
    IN  TAGID tiParent
    );

TAGID
SDBAPI
SdbGetNextChild(
    IN  PDB   pdb,
    IN  TAGID tiParent,
    IN  TAGID tiPrev
    );

TAG
SDBAPI
SdbGetTagFromTagID(
    IN  PDB   pdb,
    IN  TAGID tiWhich
    );

DWORD
SDBAPI
SdbGetTagDataSize(
    IN  PDB   pdb,
    IN  TAGID tiWhich
    );

PVOID
SDBAPI
SdbGetBinaryTagData(
    IN  PDB   pdb,
    IN  TAGID tiWhich
    );


BOOL
SDBAPI
SdbIsTagrefFromMainDB(
    TAGREF trWhich
    );

BOOL
SDBAPI
SdbIsTagrefFromLocalDB(
    TAGREF trWhich
    );

typedef struct tagATTRINFO *PATTRINFO;

//////////////////////////////////////////////////////////////////////////
// Grab Matching Information Function Declaration
//

//
// Filters available for SdbGrabMatchingInfo
//
#define GRABMI_FILTER_NORMAL        0
#define GRABMI_FILTER_PRIVACY       1
#define GRABMI_FILTER_DRIVERS       2
#define GRABMI_FILTER_VERBOSE       3
#define GRABMI_FILTER_SYSTEM        4
#define GRABMI_FILTER_THISFILEONLY  5
#define GRABMI_FILTER_NOCLOSE       0x10000000
#define GRABMI_FILTER_APPEND        0x20000000
#define GRABMI_FILTER_LIMITFILES    0x40000000
#define GRABMI_FILTER_NORECURSE     0x80000000

#define GRABMI_IMPOSED_FILE_LIMIT   25

typedef enum GMI_RESULT {

    GMI_FAILED    = FALSE,
    GMI_SUCCESS   = TRUE,
    GMI_CANCELLED = -1

} GMI_RESULT;


BOOL
SDBAPI
SdbGrabMatchingInfo(
    LPCTSTR szMatchingPath,
    DWORD   dwFilter,
    LPCTSTR szFile
    );


typedef BOOL (CALLBACK* PFNGMIProgressCallback)(
    LPVOID    lpvCallbackParam, // application-defined parameter
    LPCTSTR   lpszRoot,         // root directory path
    LPCTSTR   lpszRelative,     // relative path
    PATTRINFO pAttrInfo,        // attributes
    LPCWSTR   pwszXML           // resulting xml
    );

GMI_RESULT
SDBAPI
SdbGrabMatchingInfoEx(
    LPCTSTR                 szMatchingPath,
    DWORD                   dwFilter,
    LPCTSTR                 szFile,
    PFNGMIProgressCallback  pfnCallback,
    LPVOID                  lpvCallbackParam
    );

//
// Module-type constants
//
#define MT_UNKNOWN_MODULE 0
#define MT_DOS_MODULE 1
#define MT_W16_MODULE 2
#define MT_W32_MODULE 3


//////////////////////////////////////////////////////////////////////////
//
// TAGREF functions
//
//////////////////////////////////////////////////////////////////////////

BOOL
SDBAPI
SdbTagIDToTagRef(
    IN  HSDB    hSDB,
    IN  PDB     pdb,
    IN  TAGID   tiWhich,
    OUT TAGREF* ptrWhich
    );

BOOL
SDBAPI
SdbTagRefToTagID(
    IN  HSDB   hSDB,
    IN  TAGREF trWhich,
    OUT PDB*   ppdb,
    OUT TAGID* ptiWhich
    );


//
// SEARCH functions
//

TAGID
SDBAPI
SdbFindFirstTag(
    IN  PDB   pdb,
    IN  TAGID tiParent,
    IN  TAG   tTag
    );

TAGID
SDBAPI
SdbFindNextTag(
    IN  PDB   pdb,
    IN  TAGID tiParent,
    IN  TAGID tiPrev
    );

TAGID
SDBAPI
SdbFindFirstNamedTag(
    IN  PDB     pdb,
    IN  TAGID   tiParent,
    IN  TAG     tToFind,
    IN  TAG     tName,
    IN  LPCTSTR pszName
    );

TAGREF
SDBAPI
SdbFindFirstTagRef(
    IN  HSDB   hSDB,
    IN  TAGREF trParent,
    IN  TAG    tTag
    );

TAGREF
SDBAPI
SdbFindNextTagRef(
    IN  HSDB   hSDB,
    IN  TAGREF trParent,
    IN  TAGREF trPrev
    );

//
// DB access APIs
//

//
// Flags for SdbInitDatabase.
//
#define HID_DOS_PATHS          0x00000001       // use DOS paths
#define HID_DATABASE_FULLPATH  0x00000002       // pszDatabasePath is a full path to the main db
#define HID_NO_DATABASE        0x00000004       // do not open database at this time

#define HID_DATABASE_TYPE_MASK 0xF00F0000       // mask that shows whether we have any
                                                // database type-related bits
//
// The flags could be OR'd with SDB_DATABASE_* bits
//


HSDB
SDBAPI
SdbInitDatabase(
    IN DWORD   dwFlags,
    IN LPCTSTR pszDatabasePath
    );

HSDB
SDBAPI
SdbInitDatabaseEx(
    IN DWORD   dwFlags,
    IN LPCTSTR pszDatabasePath,
    IN USHORT  uExeType
    );

VOID
SDBAPI
SdbSetImageType(
    IN HSDB   hSDB,
    IN USHORT uExeType
    );

HSDB
SDBAPI
SdbInitDatabaseInMemory(
    IN LPVOID  pDatabaseImage,
    IN DWORD   dwImageSize
    );

VOID
SDBAPI
SdbReleaseDatabase(
    IN HSDB hSDB
    );

//
// Information - retrieval functions
//

BOOL
SDBAPI
SdbGetDatabaseVersion(
    IN  LPCTSTR pwszFileName,
    OUT LPDWORD lpdwMajor,
    OUT LPDWORD lpdwMinor
    );

BOOL
SDBAPI
SdbGetDatabaseInformation(
    IN  PDB pdb,
    OUT PSDBDATABASEINFO pSdbInfo
    );

BOOL
SDBAPI
SdbGetDatabaseID(
    IN  PDB   pdb,
    OUT GUID* pguidDB
    );

DWORD
SDBAPI
SdbGetDatabaseDescription(
    IN  PDB pdb,
    OUT LPTSTR pszDatabaseDescription,
    IN  DWORD BufferSize
    );

VOID
SDBAPI
SdbFreeDatabaseInformation(
    IN PSDBDATABASEINFO pDBInfo
    );

BOOL
SDBAPI
SdbGetDatabaseInformationByName(
    IN LPCTSTR pszDatabase,
    OUT PSDBDATABASEINFO* ppdbInfo
    );

#define SDBTYPE_SYSMAIN 0x00000001
#define SDBTYPE_SYSTEST 0x00000002
#define SDBTYPE_MSI     0x00000003
#define SDBTYPE_SHIM    0x00000004  // primarily shim db
#define SDBTYPE_APPHELP 0x00000005  // primarily type apphelp
#define SDBTYPE_CUSTOM  0x00010000  // this is an "OR" bit


//
// The function below exists only in user mode on win32 platform
//
BOOL
SDBAPI
SdbUnregisterDatabase(
    IN GUID* pguidDB
    );

BOOL
SDBAPI
SdbGetDatabaseRegPath(
    IN  GUID*  pguidDB,
    OUT LPTSTR pszDatabasePath,
    IN  DWORD  dwBufferSize      // size (in tchars) of the buffer
    );

/////////////////////////////////////////////////////////////////

//
// Database types
// for SdbResolveDatabase and SdbRegisterDatabase
//

//
// flag that indicates that the database is the default one
// WILL NOT be set for custom databases
//
#define SDB_DATABASE_MAIN      0x80000000
#define SDB_DATABASE_TEST      0x40000000  // systest.sdb will have 0xc00000000

//
// types - one or more apply depending on the contents of the database
// (see HID_DATABASE_TYPE values, they should match database types 1:1)

#define SDB_DATABASE_SHIM      0x00010000 // set when database contains apps to be fixed by shimming
#define SDB_DATABASE_MSI       0x00020000 // set when database contains msi entries
#define SDB_DATABASE_DRIVERS   0x00040000 // set when database contains drivers to be blocked
#define SDB_DATABASE_DETAILS   0x00080000 // set when the db contains apphelp details
#define SDB_DATABASE_TYPE_MASK 0xF00F0000

//
// These constants should be used when derefencing "main" databases
//

#define SDB_DATABASE_MAIN_SHIM    (SDB_DATABASE_SHIM    | SDB_DATABASE_MSI | SDB_DATABASE_MAIN)
#define SDB_DATABASE_MAIN_MSI     (SDB_DATABASE_MSI     | SDB_DATABASE_MAIN)
#define SDB_DATABASE_MAIN_DRIVERS (SDB_DATABASE_DRIVERS | SDB_DATABASE_MAIN)
#define SDB_DATABASE_MAIN_TEST    (SDB_DATABASE_TEST    | SDB_DATABASE_MAIN | SDB_DATABASE_SHIM | SDB_DATABASE_MSI)
#define SDB_DATABASE_MAIN_DETAILS (SDB_DATABASE_DETAILS | SDB_DATABASE_MAIN)

//
// These are internal GUIDs that always reference certain global databases
//
#define GUID_SZ_SYSMAIN_SDB _T("{11111111-1111-1111-1111-111111111111}");
#define GUID_SZ_APPHELP_SDB _T("{22222222-2222-2222-2222-222222222222}");
#define GUID_SZ_SYSTEST_SDB _T("{33333333-3333-3333-3333-333333333333}");
#define GUID_SZ_DRVMAIN_SDB _T("{F9AB2228-3312-4A73-B6F9-936D70E112EF}"};
//
// the following GUIDs are actually declared in sdbapi.c
//
EXTERN_C const GUID FAR GUID_SYSMAIN_SDB;
EXTERN_C const GUID FAR GUID_APPHELP_SDB;
EXTERN_C const GUID FAR GUID_SYSTEST_SDB;
EXTERN_C const GUID FAR GUID_DRVMAIN_SDB;
EXTERN_C const GUID FAR GUID_MSIMAIN_SDB;

BOOL
SDBAPI
SdbGetStandardDatabaseGUID(
    IN  DWORD  dwDatabaseType,
    OUT GUID*  pGuidDB
    );

BOOL
SDBAPI
SdbRegisterDatabase(
    IN LPCTSTR pszDatabasePath,
    IN DWORD   dwDatabaseType
    );

BOOL
SDBAPI
SdbRegisterDatabaseEx(
    IN LPCTSTR    pszDatabasePath,
    IN DWORD      dwDatabaseType,
    IN PULONGLONG pTimeStamp
    );

DWORD
SDBAPI
SdbResolveDatabase(
    IN  HSDB    hSDB,
    IN  GUID*   pguidDB,            // pointer to the database guid to resolve
    OUT LPDWORD lpdwDatabaseType,   // optional pointer to the database type
    OUT LPTSTR  pszDatabasePath,    // optional pointer to the database path
    IN  DWORD   dwBufferSize        // size of the buffer pszDatabasePath in tchars
    );


PDB
SdbGetPDBFromGUID(
    IN  HSDB    hSDB,               // HSDB
    IN  GUID*   pguidDB             // the guid of the DB
    );

BOOL
SdbGetDatabaseGUID(
    IN  HSDB    hSDB,               // HSDB of the sdbContext (optional)
    IN  PDB     pdb,                // PDB of the database in question
    OUT GUID*   pguidDB             // the guid of the DB
    );

TAGREF
SDBAPI
SdbFindMsiPackageByID(
    IN HSDB  hSDB,
    IN GUID* pguidID
    );

void
SdbpGetAppPatchDir(
    IN HSDB   hSDB,
    IN LPTSTR szAppPatchPath,
    IN DWORD  cchSize
    );

//
// GUID manipulation apis - not platform dependent
//

BOOL
SDBAPI
SdbGUIDFromString(
    IN  LPCTSTR lpszGuid,
    OUT GUID*   pGuid
    );

BOOL
SDBAPI
SdbGUIDToString(
    IN  GUID*  pGuid,
    OUT LPTSTR pszGuid,
    IN  DWORD  cchSize
    );

BOOL
SDBAPI
SdbIsNullGUID(
    IN GUID* pGuid
    );


//
// open/create and close database.
//

PDB
SDBAPI
SdbOpenDatabase(
    IN  LPCTSTR   pwszPath,
    IN  PATH_TYPE eType
    );

BOOL
SDBAPI
SdbOpenLocalDatabase(
    IN  HSDB    hSDB,
    IN  LPCTSTR pwszLocalDatabase
    );


BOOL
SDBAPI
SdbCloseLocalDatabase(
    IN  HSDB    hSDB
    );

PDB
SDBAPI
SdbCreateDatabase(
    IN  LPCWSTR   pwszPath,
    IN  PATH_TYPE eType
    );

void
SDBAPI
SdbCloseDatabase(
    IN  PDB pdb
    );


//
// Search the database looking for an entry for the specified exe.
//

//
// Flags for SdbGetMatchingExe dwFlags
//
#define SDBGMEF_IGNORE_ENVIRONMENT  0x00000001

BOOL
SdbGetMatchingExe(
    IN  HSDB            hSDB  OPTIONAL,
    IN  LPCTSTR         pwszPath,
    IN  LPCTSTR         szModuleName,
    IN  LPCTSTR         pwszEnvironment,
    IN  DWORD           dwFlags,
    OUT PSDBQUERYRESULT pQueryResult
    );

void
SdbReleaseMatchingExe(
    IN  HSDB   hSDB,
    IN  TAGREF trExe
    );

TAGREF
SDBAPI
SdbGetDatabaseMatch(
    IN HSDB    hSDB,
    IN LPCTSTR szPath,
    IN HANDLE  FileHandle  OPTIONAL,
    IN LPVOID  pImageBase  OPTIONAL,
    IN DWORD   dwImageSize OPTIONAL
    );

TAGREF
SdbGetLayerTagReg(
    IN  HSDB    hSDB,
    IN  LPCTSTR szLayer
    );


PDB
SDBAPI
SdbGetLocalPDB(
    IN HSDB hSDB
    );

LPTSTR
SDBAPI
SdbGetLayerName(
    IN  HSDB   hSDB,
    IN  TAGREF trLayer
    );

TAGREF
SDBAPI
SdbGetNamedLayer(
    IN HSDB hSDB,               // database context
    IN TAGREF trLayerRef        // tagref of a record referencing a layer
    );

#define SBCE_ADDITIVE           0x00000001
#define SBCE_INCLUDESYSTEMEXES  0x00000002
#define SBCE_INHERITENV         0x00000004

DWORD
SdbBuildCompatEnvVariables(
    IN  HSDB            hSDB,
    IN  SDBQUERYRESULT* psdbQuery,
    IN  DWORD           dwFlags,
    IN  LPCWSTR         pwszParentEnv OPTIONAL, // Environment which contains vars we
                                                // shall inherit from
    OUT LPWSTR          pBuffer,
    IN  DWORD           cbSize,                 // size of the buffer in tchars
    OUT LPDWORD         lpdwShimsCount OPTIONAL
    );

//
// MSI-specific functionality
//

typedef enum tagSDBMSILOOKUPSTATE {
    LOOKUP_NONE = 0,    // this should be the first state
    LOOKUP_LOCAL,
    LOOKUP_CUSTOM,
    LOOKUP_TEST,
    LOOKUP_MAIN,
    LOOKUP_DONE         // this should be the last state

} SDBMSILOOKUPSTATE;

typedef struct tagSDBMSIFINDINFO {

    TAGREF    trMatch;              // tagref of the matching package
    GUID      guidID;               // guid of this current package
    FIND_INFO sdbFindInfo;          // standard sdb find info

    // this is used to persist the state of the current search
    //
    SDBMSILOOKUPSTATE sdbLookupState;
    DWORD             dwCustomIndex;

} SDBMSIFINDINFO, *PSDBMSIFINDINFO;

typedef struct tagSDBMSITRANSFORMINFO {

    LPCTSTR   lpszTransformName;    // name of the transform
    TAGREF    trTransform;          // tagref of this transform
    TAGREF    trFile;               // tagref of file for this transform (bits)

} SDBMSITRANSFORMINFO, *PSDBMSITRANSFORMINFO;

//
// Information for any individual MSI package
//
typedef struct tagMSIPACKAGEINFO {

    GUID  guidID;                   // unique guid for this entry
    GUID  guidMsiPackageID;         // guid (non-unique, for this entry)
    GUID  guidDatabaseID;           // guid of the database where this had been found
    DWORD dwPackageFlags;           // Package flags (see below)

} MSIPACKAGEINFO, *PMSIPACKAGEINFO;

#define MSI_PACKAGE_HAS_APPHELP 0x00000001
#define MSI_PACKAGE_HAS_SHIMS   0x00000002

TAGREF
SDBAPI
SdbFindFirstMsiPackage_Str(
    IN  HSDB            hSDB,
    IN  LPCTSTR         lpszGuid,
    IN  LPCTSTR         lpszLocalDB,
    OUT PSDBMSIFINDINFO pFindInfo
    );

TAGREF
SDBAPI
SdbFindFirstMsiPackage(
    IN  HSDB            hSDB,           // in HSDB context
    IN  GUID*           pGuidID,        // in GUID that we're looking for
    IN  LPCTSTR         lpszLocalDB,    // in optional path to local db, dos path style
    OUT PSDBMSIFINDINFO pFindInfo       // pointer to our search context
    );

TAGREF
SDBAPI
SdbFindNextMsiPackage(
    IN     HSDB hSDB,
    IN OUT PSDBMSIFINDINFO pFindInfo
    );

BOOL
SDBAPI
SdbGetMsiPackageInformation(
    IN  HSDB hSDB,
    IN  TAGREF trMatch,
    OUT PMSIPACKAGEINFO pPackageInfo
    );

DWORD
SDBAPI
SdbEnumMsiTransforms(
    IN     HSDB    hSDB,            // in HSDB context
    IN     TAGREF  trMatch,         // matched entry
    OUT    TAGREF* ptrBuffer,       // array of tagrefs to fill with msi transform "fixes"
    IN OUT DWORD*  pdwBufferSize    // pointer to the buffer size, receives the number of
                                    // bytes written
    );


BOOL
SDBAPI
SdbReadMsiTransformInfo(
    IN  HSDB   hSDB,                            // HSDB context
    IN  TAGREF trTransformRef,                  // reference to a transform, returned
                                                //   by SdbEnumMsiTransforms
    OUT PSDBMSITRANSFORMINFO pTransformInfo     // information structure
    );

BOOL
SDBAPI
SdbCreateMsiTransformFile(
    IN  HSDB hSDB,                              // context
    IN  LPCTSTR lpszFileName,                   // filename to write data to
    IN  PSDBMSITRANSFORMINFO pTransformInfo     // pointer to the transform structure
    );

TAGREF
SDBAPI
SdbFindCustomActionForPackage(
    IN HSDB hSDB,
    IN TAGREF trPackage,
    IN LPCTSTR lpszCustomAction);

#define SdbGetFirstMsiTransformForPackage(hSDB, trPackage) \
    (SdbFindFirstTagRef((hSDB), (trPackage), TAG_MSI_TRANSFORM_REF))

#define SdbGetNextMsiTransformForPackage(hSDB, trPackage, trPrevMatch) \
    (SdbFindNextTagRef((hSDB), (trPackage), (trPrevMatch)))


//
// "disable" registry entry masks
//
#define SHIMREG_DISABLE_SHIM    0x00000001
#define SHIMREG_DISABLE_APPHELP 0x00000002 // disables apphelp
#define SHIMREG_APPHELP_NOUI    0x00000004 // suppress apphelp ui
#define SHIMREG_APPHELP_CANCEL  0x10000000 // returns CANCEL as a default action

#define SHIMREG_DISABLE_SXS     0x00000010
#define SHIMREG_DISABLE_LAYER   0x00000020
#define SHIMREG_DISABLE_DRIVER  0x00000040

BOOL
SDBAPI
SdbSetEntryFlags(
    IN  GUID* pGuidID,
    IN  DWORD dwFlags
    );

BOOL
SDBAPI
SdbGetEntryFlags(
    IN  GUID*   pGuid,
    OUT LPDWORD lpdwFlags
    );


//
// Flags used by Get/SetPermLayerKeys
//
#define GPLK_USER               0x00000001
#define GPLK_MACHINE            0x00000002

#define GPLK_ALL                (GPLK_USER | GPLK_MACHINE)


BOOL
SDBAPI
SdbGetPermLayerKeys(
    LPCTSTR szPath,
    LPTSTR  szLayers,
    LPDWORD pdwBytes,
    DWORD   dwFlags
    );

BOOL
SDBAPI
SdbSetPermLayerKeys(
    LPCTSTR  szPath,
    LPCTSTR  szLayers,
    BOOL     bMachine
    );

BOOL
SDBAPI
SdbDeletePermLayerKeys(
    LPCTSTR  szPath,
    BOOL     bMachine
    );

BOOL
SdbGetNthUserSdb(
    IN HSDB        hSDB,        // context
    IN LPCTSTR     wszItemName, // item name (foo.exe or layer name)
    IN BOOL        bLayer,      // true if layer name
    IN OUT LPDWORD pdwIndex,    // (0-based)
    OUT GUID*      pGuidDB      // database guid
    );


//
// APIs to pack/unpack appcompat data package.
//

BOOL
SdbPackAppCompatData(
    IN  HSDB            hSDB,
    IN  PSDBQUERYRESULT pSdbQuery,
    OUT PVOID*          ppData,
    OUT LPDWORD         pdwSize
    );

BOOL
SdbUnpackAppCompatData(
    IN  HSDB            hSDB,
    IN  LPCWSTR         pwszExeName,
    IN  PVOID           pAppCompatData,
    OUT PSDBQUERYRESULT pSdbQuery
    );

DWORD
SdbGetAppCompatDataSize(
    IN  PVOID pAppCompatData
    );


//
// DLL functions
//

BOOL
SdbGetDllPath(
    IN  HSDB   hSDB,
    IN  TAGREF trDllRef,
    OUT LPTSTR pwszBuffer,
    IN  DWORD  cchBufferSize
    );

//
// PATCH functions
//

BOOL
SdbReadPatchBits(
    IN  HSDB    hSDB,
    IN  TAGREF  trPatchRef,
    OUT PVOID   pBuffer,
    OUT LPDWORD lpdwBufferSize
    );


//
// SDBDRIVERINFO query function
//

BOOL
SDBAPI
SdbReadEntryInformation(
    IN  HSDB           hSDB,
    IN  TAGREF         trDriver,
    OUT PSDBENTRYINFO  pEntryInfo
    );


DWORD
SDBAPI
SdbQueryData(
    IN     HSDB    hSDB,
    IN     TAGREF  trExe,
    IN     LPCTSTR lpszPolicyName,    // if this is null, will try to return all the policy names
    OUT    LPDWORD lpdwDataType,
    OUT    LPVOID  lpBuffer,          // buffer to fill with information
    IN OUT LPDWORD lpdwBufferSize
    );

DWORD
SDBAPI
SdbQueryDataEx(
    IN     HSDB    hSDB,              // database handle
    IN     TAGREF  trExe,             // tagref of the matching exe
    IN     LPCTSTR lpszDataName,      // if this is null, will try to return all the policy names
    OUT    LPDWORD lpdwDataType,      // pointer to data type (REG_SZ, REG_BINARY, etc)
    OUT    LPVOID  lpBuffer,          // buffer to fill with information
    IN OUT LPDWORD lpdwBufferSize,    // pointer to buffer size
    OUT    TAGREF* ptrData            // optional pointer to the retrieved data tag
    );

DWORD
SdbQueryDataExTagID(
    IN     PDB     pdb,               // database handle
    IN     TAGID   tiExe,             // tagref of the matching exe
    IN     LPCTSTR lpszDataName,      // if this is null, will try to return all the policy names
    OUT    LPDWORD lpdwDataType,      // pointer to data type (REG_SZ, REG_BINARY, etc)
    OUT    LPVOID  lpBuffer,          // buffer to fill with information
    IN OUT LPDWORD lpcbBufferSize,    // pointer to buffer size (in bytes)
    OUT    TAGID*  ptiData            // optional pointer to the retrieved data tag
    );


//
// Defines to keep kernel-mode code more readable
//
#define SdbQueryDriverInformation SdbQueryData
#define SdbReadDriverInformation  SdbReadEntryInformation

#define SDBDRIVERINFO             SDBENTRYINFO;
#define PSDBDRIVERINFO            PSDBENTRYINFO;

//
// Query attribute APIs
//

PVOID
SdbGetFileInfo(
    IN  HSDB    hSDB,
    IN  LPCTSTR pwszFilePath,
    IN  HANDLE  hFile OPTIONAL,
    IN  LPVOID  pImageBase OPTIONAL,
    IN  DWORD   dwImageSize OPTIONAL,
    IN  BOOL    bNoCache
    );

VOID
SdbFreeFileInfo(
    IN  PVOID pFileInfo
    );


//
// Get item from item ref
//

TAGREF
SdbGetItemFromItemRef(
    IN  HSDB   hSDB,
    IN  TAGREF trItemRef,
    IN  TAG    tagItemKey,
    IN  TAG    tagItemTAGID,
    IN  TAG    tagItem
    );

#define SdbGetShimFromShimRef(hSDB, trShimRef)     \
        (SdbGetItemFromItemRef(hSDB, trShimRef, TAG_NAME, TAG_SHIM_TAGID, TAG_SHIM))

#define SdbGetPatchFromPatchRef(hSDB, trPatchRef)     \
        (SdbGetItemFromItemRef(hSDB, trPatchRef, TAG_NAME, TAG_PATCH_TAGID, TAG_PATCH))

#define SdbGetFlagFromFlagRef(hSDB, trFlagRef)     \
        (SdbGetItemFromItemRef(hSDB, trFlagRef, TAG_NAME, TAG_FLAG_TAGID, TAG_FLAG))

// INDEX functions

BOOL SdbDeclareIndex(
    IN  PDB      pdb,
    IN  TAG      tWhich,
    IN  TAG      tKey,
    IN  DWORD    dwEntries,
    IN  BOOL     bUniqueKey,
    OUT INDEXID* piiIndex
    );

BOOL
SdbStartIndexing(
    IN  PDB pdb,
    IN  INDEXID iiWhich
    );

BOOL
SdbStopIndexing(
    IN  PDB pdb,
    IN  INDEXID iiWhich
    );

BOOL
SdbCommitIndexes(
    IN  PDB pdb
    );

TAGID
SdbFindFirstDWORDIndexedTag(
    IN  PDB         pdb,
    IN  TAG         tWhich,
    IN  TAG         tKey,
    IN  DWORD       dwName,
    OUT FIND_INFO*  pFindInfo
    );

TAGID
SdbFindNextDWORDIndexedTag(
    IN  PDB        pdb,
    OUT FIND_INFO* pFindInfo
    );

TAGID
SdbFindFirstStringIndexedTag(
    IN  PDB        pdb,
    IN  TAG        tWhich,
    IN  TAG        tKey,
    IN  LPCTSTR    pwszName,
    OUT FIND_INFO* pFindInfo
    );

TAGID
SdbFindNextStringIndexedTag(
    IN  PDB        pdb,
    OUT FIND_INFO* pFindInfo
    );

TAGID
SdbFindFirstGUIDIndexedTag(
    IN  PDB         pdb,
    IN  TAG         tWhich,
    IN  TAG         tKey,
    IN  GUID*       pGuidName,
    OUT FIND_INFO*  pFindInfo
    );

TAGID
SdbFindNextGUIDIndexedTag(
    IN  PDB        pdb,
    OUT FIND_INFO* pFindInfo
    );


ULONGLONG
SdbMakeIndexKeyFromString(
    IN  LPCTSTR pwszKey
    );

//
// These macros allow to make a key from dword or a guid
//

#define MAKEKEYFROMDWORD(dwValue) \
    ((ULONGLONG)(dwValue))


#if defined(_WIN64)
ULONGLONG
SdbMakeIndexKeyFromGUID(
    IN GUID* pGuid
    );
#define MAKEKEYFROMGUID(pGuid) SdbMakeIndexKeyFromGUID(pGuid)

#else /* ! WIN64 */

#define MAKEKEYFROMGUID(pGuid) \
    ((ULONGLONG)((*(PULONGLONG)(pGuid)) ^ (*((PULONGLONG)(pGuid) + 1))))

#endif /* WIN64 */


TAGID
SdbGetIndex(
    IN  PDB     pdb,
    IN  TAG     tWhich,
    IN  TAG     tKey,
    OUT LPDWORD lpdwFlags OPTIONAL
    );

#define SdbIsIndexAvailable(pdb, tWhich, tKey)  \
                (SdbGetIndex(pdb, tWhich, tKey, NULL))

//
// WRITE FUNCTIONS
//

TAGID
SdbBeginWriteListTag(
    IN  PDB pdb,
    IN  TAG tTag
    );

BOOL
SdbEndWriteListTag(
    IN  PDB   pdb,
    IN  TAGID tiList
    );

BOOL
SdbWriteStringTagDirect(
    IN  PDB     pdb,
    IN  TAG     tTag,
    IN  LPCWSTR pwszData
    );

BOOL
SdbWriteStringRefTag(
    IN  PDB       pdb,
    IN  TAG       tTag,
    IN  STRINGREF srData
    );

BOOL
SdbWriteNULLTag(
    IN  PDB pdb,
    IN  TAG tTag
    );

BOOL
SdbWriteBYTETag(
    IN  PDB  pdb,
    IN  TAG  tTag,
    IN  BYTE jData
    );

BOOL
SdbWriteWORDTag(
    IN  PDB  pdb,
    IN  TAG  tTag,
    IN  WORD wData
    );

BOOL
SdbWriteDWORDTag(
    IN  PDB   pdb,
    IN  TAG   tTag,
    IN  DWORD dwData
    );

BOOL
SdbWriteQWORDTag(
    IN  PDB       pdb,
    IN  TAG       tTag,
    IN  ULONGLONG qwData
    );

BOOL
SdbWriteStringTag(
    IN  PDB     pdb,
    IN  TAG     tTag,
    IN  LPCWSTR pwszData
    );

BOOL
SdbWriteBinaryTag(
    IN  PDB   pdb,
    IN  TAG   tTag,
    IN  PBYTE pBuffer,
    IN  DWORD dwSize
    );

BOOL
SdbWriteBinaryTagFromFile(
    IN  PDB     pdb,
    IN  TAG     tTag,
    IN  LPCWSTR pwszPath
    );


////////////////////////////////////////////////////////////////////////////////////////////
//
//  Attribute retrieval
//
//

//
//  Attribute Information
//  identified by a tag
//
//
typedef struct tagATTRINFO {

    TAG      tAttrID;        // tag for this attribute (includes type)
    DWORD    dwFlags;        // flags : such as "not avail" or "not there yet"

    union {     // anonymous union with values
        ULONGLONG   ullAttr; // QWORD  value (TAG_TYPE_QWORD)
        DWORD       dwAttr;  // DWORD  value (TAG_TYPE_DWORD)
        TCHAR*      lpAttr;  // WCHAR* value (TAG_TYPE_STRINGREF)
    };

} ATTRINFO, *PATTRINFO;

//
// Flags that go into ATTRINFO's dwFlags field
//
//

#define ATTRIBUTE_AVAILABLE 0x00000001  // this will be set if attribute was obtained
#define ATTRIBUTE_FAILED    0x00000002  // this will be set if we tried to get it
                                        // and failed
BOOL
SDBAPI
SdbGetFileAttributes(
    IN  LPCTSTR    lpwszFileName,
    OUT PATTRINFO* ppAttrInfo,
    OUT LPDWORD    lpdwAttrCount);

BOOL
SDBAPI
SdbFreeFileAttributes(
    IN PATTRINFO pFileAttributes);

BOOL
SDBAPI
SdbFormatAttribute(
    IN  PATTRINFO pAttrInfo,
    OUT LPTSTR    pchBuffer,
    IN  DWORD     dwBufferSize);

////////////////////////////////////////////////////////////////////////////////////////////
//
//
// High-level functions to extract information related to apphelp
//
//

typedef struct tagAPPHELP_DATA {
   DWORD  dwFlags;      // flags (if any)
   DWORD  dwSeverity;   // can be none APPTYPE_NONE (0)
   DWORD  dwHTMLHelpID; // help id
   LPTSTR szAppName;

   TAGREF trExe;        // matched on this exe (in apphelp section)

   LPTSTR szURL;        // URL
   LPTSTR szLink;       // link text

   LPTSTR szAppTitle;   // title
   LPTSTR szContact;    // contact info
   LPTSTR szDetails;    // details

//
// non-apphelp data (this is managed by the host app
//
   DWORD  dwData;

} APPHELP_DATA, *PAPPHELP_DATA;


BOOL
SdbReadApphelpData(
    IN  HSDB          hSDB,
    IN  TAGREF        trExe,
    OUT PAPPHELP_DATA pData
    );


BOOL
SdbReadApphelpDetailsData(
    IN  PDB           pdbDetails,
    OUT PAPPHELP_DATA pData
    );

////////////////////////////////////////////////////////////////////////////////////////////
//
//
// A few functions from apphelp.dll
//
//

BOOL
SDBAPI
SetPermLayers(
    IN  LPCWSTR pwszPath,   // path to the file to set a permanent layer on
    IN  LPCWSTR pwszLayers, // layers to apply to the file, separated by spaces
    IN  BOOL    bMachine    // TRUE if the layers should be persisted per machine
    );

BOOL
SDBAPI
GetPermLayers(
    IN  LPCWSTR pwszPath,   // path to the file to set a permanent layer on
    OUT LPWSTR  pwszLayers, // layers to apply to the file, separated by spaces
    OUT DWORD*  pdwBytes,   // input: number of bytes available; output is number of bytes needed
    IN  DWORD   dwFlags
    );

BOOL
SDBAPI
AllowPermLayer(
    IN  LPCWSTR pwszPath   // path to the file to check whether you can set a permanent layer on
    );

typedef struct _NTVDM_FLAGS {

    DWORD   dwWOWCompatFlags;
    DWORD   dwWOWCompatFlagsEx;
    DWORD   dwUserWOWCompatFlags;
    DWORD   dwWOWCompatFlags2;
    DWORD   dwWOWCompatFlagsFE;
    DWORD   dwFlagsInfoSize;        // size of the memory area pointed to by pFlagsInfo
    PVOID   pFlagsInfo;             // pointer that is used to store flags-related information

} NTVDM_FLAGS, *PNTVDM_FLAGS;

//
// Macros we use to obtain flags command lines
//

#define MAKEQWORD(dwLow, dwHigh) \
    ( ((ULONGLONG)(dwLow)) | ( ((ULONGLONG)(dwHigh)) << 32) )

#define GET_WOWCOMPATFLAGS_CMDLINE(pFlagInfo, dwFlag, ppCmdLine) \
    SdbQueryFlagInfo(pFlagInfo, TAG_FLAGS_NTVDM1, MAKEQWORD(dwFlag, 0), ppCmdLine)

#define GET_WOWCOMPATFLAGSEX_CMDLINE(pFlagInfo, dwFlag, ppCmdLine) \
    SdbQueryFlagInfo(pFlagInfo, TAG_FLAGS_NTVDM1, MAKEQWORD(0, dwFlag), ppCmdLine)

#define GET_USERWOWCOMPATFLAGS_CMDLINE(pFlagInfo, dwFlag, ppCmdLine) \
    SdbQueryFlagInfo(pFlagInfo, TAG_FLAGS_NTVDM2, MAKEQWORD(dwFlag, 0), ppCmdLine)

#define GET_WOWCOMPATFLAGS2_CMDLINE(pFlagInfo, dwFlag, ppCmdLine) \
    SdbQueryFlagInfo(pFlagInfo, TAG_FLAGS_NTVDM2, MAKEQWORD(0, dwFlag), ppCmdLine)

#define GET_WOWCOMPATFLAGSFE_CMDLINE(pFlagInfo, dwFlag, ppCmdLine) \
    SdbQueryFlagInfo(pFlagInfo, TAG_FLAGS_NTVDM3, MAKEQWORD(dwFlag, 0), ppCmdLine)



typedef struct _APPHELP_INFO {

    //
    //  html help id mode
    //
    DWORD   dwHtmlHelpID;       // html help id
    DWORD   dwSeverity;         // must have
    LPCTSTR lpszAppName;
    GUID    guidID;             // entry guid

    //
    //  Conventional mode
    //
    TAGID   tiExe;              // the TAGID of the exe entry within the DB
    GUID    guidDB;             // the guid of the DB that has the EXE entry

    BOOL    bOfflineContent;
    BOOL    bUseHTMLHelp;
    LPCTSTR lpszChmFile;
    LPCTSTR lpszDetailsFile;

    //
    // preserve users choice on the dialog if user chooses to persist settings
    //
    BOOL    bPreserveChoice;

    //
    // TRUE if msi mode (matters for ia64 platform)
    //
    BOOL    bMSI;

} APPHELP_INFO, *PAPPHELP_INFO;


////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Functions to access apphelp functionality
//
//

// prototypes which are exported for ntvdm shim support
typedef void (*LPFNSE_REMOVENTVDM)(HANDLE);
typedef BOOL (*LPFNSE_SHIMNTVDM)(LPCWSTR, HSDB, SDBQUERYRESULT*, PVDMTABLE);

// Max size of compat layer buffer
#define COMPATLAYERMAXLEN 256

BOOL
ApphelpGetNTVDMInfo(
    IN  LPCWSTR pwszPath,       // path to the app in NT format
    IN  LPCWSTR pwszModule,     // module name
    IN  LPCWSTR pEnvironment,   // pointer to the environment of the task that is
                                // being created or NULL if we are to use the main NTVDM
                                // environment block.
    OUT LPWSTR pszCompatLayer,  // The new compat layer variable. with format:
                                // "Alpha Bravo Charlie" -- allow COMPATLAYERMAXLEN chars for this.
    OUT PNTVDM_FLAGS pFlags,    // The flags
    OUT PAPPHELP_INFO pAHInfo,  // If there is apphelp to display, this will be filled
                                // in with non-null values
    OUT HSDB*  phSDB,          // The handle to the database.
    OUT PSDBQUERYRESULT pQueryResult // The query result.
    );

BOOL
ApphelpShowDialog(
    IN  PAPPHELP_INFO   pAHInfo,    // the info necessary to find the apphelp data
    IN  PHANDLE         phProcess   // [optional] returns the process handle of
                                    // the process displaying the apphelp.
                                    // When the process completes, the return value
                                    // (from GetExitCodeProcess()) will be zero
                                    // if the app should not run, or non-zero
                                    // if it should run.
    );


typedef PVOID HAPPHELPINFOCONTEXT;

typedef enum tagAPPHELPINFORMATIONCLASS {
    ApphelpFlags,
    ApphelpExeName,
    ApphelpAppName,
    ApphelpVendorName,
    ApphelpHtmlHelpID,
    ApphelpProblemSeverity,
    ApphelpLinkURL,
    ApphelpLinkText,
    ApphelpTitle,
    ApphelpDetails,
    ApphelpContact,
    ApphelpHelpCenterURL,
    ApphelpExeTagID,
    ApphelpDatabaseGUID  // this is guid of a database containing the match
} APPHELPINFORMATIONCLASS;

PDB
SDBAPI
SdbOpenApphelpDetailsDatabase(
    IN LPCWSTR pwsDetailsDatabasePath OPTIONAL
    );

HAPPHELPINFOCONTEXT
SDBAPI
SdbOpenApphelpInformation(
    IN GUID* pguidDB,
    IN GUID* pguidID
    );

HAPPHELPINFOCONTEXT
SDBAPI
SdbOpenApphelpInformationByID(
    IN HSDB   hSDB,
    IN TAGREF trEntry,
    IN DWORD  dwDatabaseType                // pass the type of db you are using
    );

BOOL
SDBAPI
SdbCloseApphelpInformation(
    IN HAPPHELPINFOCONTEXT hctx
    );

DWORD
SDBAPI
SdbQueryApphelpInformation(
    IN  HAPPHELPINFOCONTEXT hctx,
    IN  APPHELPINFORMATIONCLASS InfoClass,
    OUT LPVOID pBuffer,                     // may be NULL
    IN  DWORD  cbSize                       // may be 0 if pBuffer is NULL
    );

BOOL
SDBAPI
SdbQueryFlagMask(
    IN  HSDB hSDB,
    IN  SDBQUERYRESULT* pQueryResult,
    IN  TAG tMaskType,
    OUT ULONGLONG* pullFlags,
    IN OUT PVOID* ppFlagInfo OPTIONAL
    );

BOOL
SDBAPI
SdbEscapeApphelpURL(
    OUT    LPWSTR    szResult,      // escaped string (output)
    IN OUT LPDWORD   pdwCount,      // count of tchars in the buffer pointed to by szResult
    IN     LPCWSTR   szToEscape     // string to escape
    );

BOOL
SDBAPI
SdbSetApphelpDebugParameters(
    IN HAPPHELPINFOCONTEXT hctx,
    IN LPCWSTR pszDetailsDatabase OPTIONAL,
    IN BOOL    bOfflineContent OPTIONAL, // pass FALSE
    IN BOOL    bUseHtmlHelp    OPTIONAL, // pass FALSE
    IN LPCWSTR pszChmFile      OPTIONAL  // pass NULL
    );

BOOL
SdbShowApphelpDialog(               // returns TRUE if success, whether we should run the app is in pRunApp
    IN  PAPPHELP_INFO   pAHInfo,    // the info necessary to find the apphelp data
    OUT PHANDLE         phProcess,  // [optional] returns the process handle of
                                    // the process displaying the apphelp.
                                    // When the process completes, the return value
                                    // (from GetExitCodeProcess()) will be zero
                                    // if the app should not run, or non-zero
                                    // if it should run.
    IN OUT BOOL*        pRunApp
    );


//
// WOW cmd line for flags interface
// instead of calling SdbQueryFlagInfo the macros above should be used
//

BOOL
SDBAPI
SdbQueryFlagInfo(
    IN PVOID pvFlagInfo,
    IN TAG tFlagType,
    IN ULONGLONG ullFlagMask,
    OUT LPCTSTR * ppCmdLine
    );

BOOL
SDBAPI
SdbFreeFlagInfo(
    IN PVOID pvFlagInfo
    );


////////////////////////////////////////////////////////////////////////////////////////////
//
//  App Verifier macros/defs
//
//

typedef enum _VLOG_LEVEL {
    VLOG_LEVEL_INFO,
    VLOG_LEVEL_WARNING,
    VLOG_LEVEL_ERROR
} VLOG_LEVEL, *PVLOG_LEVEL;

typedef enum _AVRF_INFO_ID {
    // INFO ID                     type actually being passed in PVOID param
    // -------                     -----------------------------------------
    AVRF_INFO_NUM_SHIMS,        // LPDWORD (preallocated) (szName should be NULL)
    AVRF_INFO_SHIM_NAMES,       // LPWSTR * (array of same size as value of AVRF_INFO_NUM_SHIMS)
                                //     (array is preallocated, strings are allocated by shim)
                                //     (szName should be NULL)
    AVRF_INFO_DESCRIPTION,      // LPWSTR (allocated by shim)
    AVRF_INFO_FRIENDLY_NAME,    // LPWSTR (allocated by shim)
    AVRF_INFO_INCLUDE_EXCLUDE,  // LPWSTR (allocated by shim)
    AVRF_INFO_FLAGS,            // LPDWORD (preallocated)
    AVRF_INFO_OPTIONS_PAGE,     // LPPROPSHEETPAGE (preallocated)
    AVRF_INFO_VERSION,          // LPDWORD (preallocated), HIWORD=major version, LOWORD=minor version
    AVRF_INFO_GROUPS            // LPDWORD (preallocated)
} AVRF_INFO_ID, *PAVRF_INFO_ID;


//
// FLAGS for verifier shims (all flags default to FALSE)
//

#define AVRF_FLAG_NO_DEFAULT    0x00000001      // this shim should not be turned on by default
#define AVRF_FLAG_NO_WIN2K      0x00000002      // this shim should not be used on win2K
#define AVRF_FLAG_NO_SHIM       0x00000004      // this "shim" is a placeholder and shouldn't actually
                                                // be applied to an app
#define AVRF_FLAG_NO_TEST       0x00000008      // this "shim" is not a test, and is purely for adding
                                                // a page to the options dialog
#define AVRF_FLAG_NOT_SETUP     0x00000010      // this shim is not appropriate for setup apps
#define AVRF_FLAG_ONLY_SETUP    0x00000020      // this shim is only appropriate for setup apps
#define AVRF_FLAG_RUN_ALONE     0x00000040      // this shim should be run by itself with no other shims applied
#define AVRF_FLAG_INTERNAL_ONLY 0x00000080      // this shim is for Microsoft internal use only
#define AVRF_FLAG_EXTERNAL_ONLY 0x00000100      // this shim if for external use only - not for MS users

//
// GROUPS for verifier shims (by default, shims are in no groups)
//

#define AVRF_GROUP_SETUP        0x00000001      // suitable for checking setup programs
#define AVRF_GROUP_NON_SETUP    0x00000002      // suitable for checking non-setup programs (can be both)
#define AVRF_GROUP_LOGO         0x00000004      // shims that are useful for logo testing

//
// magic number tells us if we're using the same shim interface
//
#define VERIFIER_SHIMS_MAGIC  'avfr'

typedef DWORD (*_pfnGetVerifierMagic)(void);
typedef BOOL (*_pfnQueryShimInfo)(LPCWSTR szName, AVRF_INFO_ID eInfo, PVOID pInfo);

//
// special callback, so a shim can be notified when it is activated or deactivated for a
// specific application.
//
typedef BOOL (*_pfnActivateCallback)(LPCWSTR szAppName, BOOL bActivate);

//
// Where we store default verifier shim settings
//
#define AVRF_DEFAULT_SETTINGS_NAME  TEXT("{default}")
#define AVRF_DEFAULT_SETTINGS_NAME_W  L"{default}"
#define AVRF_DEFAULT_SETTINGS_NAME_A  "{default}"

typedef struct _SHIM_DESCRIPTION {

    LPWSTR  szName;
    LPWSTR  szDescription;
    LPWSTR  szExcludes;         // comma separated module names
    LPWSTR  szIncludes;         // comma separated module names
    DWORD   dwFlags;

} SHIM_DESCRIPTION, *PSHIM_DESCRIPTION;

#define ENUM_SHIMS_MAGIC  'enum'

typedef DWORD (*_pfnEnumShims)(PSHIM_DESCRIPTION pShims, DWORD dwMagic);
typedef BOOL  (*_pfnIsVerifierDLL)(void);


////////////////////////////////////////////////////////////////////////////////////////////
//
//  Miscelaneous macros/defs
//
//


//
// Apphelp types
//
#define APPHELP_TYPE_MASK     0x000000FF

#define APPHELP_NONE          0x00000000

#define APPHELP_NOBLOCK       0x00000001
#define APPHELP_HARDBLOCK     0x00000002
#define APPHELP_MINORPROBLEM  0x00000003
#define APPHELP_REINSTALL     0x00000004
#define APPHELP_VERSIONSUB    0x00000005
#define APPHELP_SHIM          0x00000006


//
// Match modes for EXEs
//
#define MATCH_NORMAL    0
#define MATCH_EXCLUSIVE 1
#define MATCH_ADDITIVE  2

//
// the struct below packs into a WORD
// older compilers won't like this union
// (because of nameless members)
//

// Tell compiler to be quite about the nameless member.
#pragma warning (disable : 4201 )
typedef union tagMATCHMODE {
    struct {
        USHORT Type : 4; // type of match
        USHORT Flags: 4; // flags for matching

        // future expansion here

    };

    WORD  wMatchMode;         // we use this to init from the database

    DWORD dwMatchMode;        // this is the "whole" match mode

} MATCHMODE, *PMATCHMODE;

#pragma warning (default : 4201 )

//
// match modes:
//
// normal    -- find a match, we're done
// additive  -- keep the match, then keep matching according to flags
// exclusive -- keep the match, throw away all other matches
//

static const MATCHMODE MatchModeDefaultMain   = { { MATCH_NORMAL,   0 } };
#define MATCHMODE_DEFAULT_MAIN (MatchModeDefaultMain.wMatchMode)

static const MATCHMODE MatchModeDefaultCustom = { { MATCH_ADDITIVE, 0 } };
#define MATCHMODE_DEFAULT_CUSTOM (MatchModeDefaultCustom.wMatchMode)


#define MAKE_MATCHMODE(dwMatchMode, Type, Flags) \
        {   \
            ((PMATCHMODE)&(dwMatchMode))->Type  = Type;  \
            ((PMATCHMODE)&(dwMatchMode))->Flags = Flags; \
        }

//
// Pre-defined match modes for shimdbc
//

static const MATCHMODE MatchModeNormal    = { { MATCH_NORMAL,    0   } };
static const MATCHMODE MatchModeAdditive  = { { MATCH_ADDITIVE,  0   } };
static const MATCHMODE MatchModeExclusive = { { MATCH_EXCLUSIVE, 0   } };

#define MATCHMODE_NORMAL_SHIMDBC     (MatchModeNormal.wMatchMode)
#define MATCHMODE_ADDITIVE_SHIMDBC   (MatchModeAdditive.wMatchMode)
#define MATCHMODE_EXCLUSIVE_SHIMDBC  (MatchModeExclusive.wMatchMode)

//
// Layer flags
//
#define LAYER_FLAG_NONE                    0x00000000 // None
#define LAYER_APPLY_TO_SYSTEM_EXES         0x00000001 // Apply to exes in system32 (including sub dir) and windir
#define LAYER_USE_NO_EXE_ENTRIES           0x00000002 // Do not use any EXE entries

//
// Runtime platform flags
//
#define RUNTIME_PLATFORM_FLAG_NOT          0x80000000
#define RUNTIME_PLATFORM_FLAG_NOT_ELEMENT  0x00000080
#define RUNTIME_PLATFORM_FLAG_VALID        0x00000040
#define RUNTIME_PLATFORM_MASK_ELEMENT      0x000000FF
#define RUNTIME_PLATFORM_MASK_VALUE        0x0000003F
#define RUNTIME_PLATFORM_ANY               0xC0000000 // no valid bits + NOT + flag

//
// Shimdbc compile-time platform (OS_PLATFORM) flags
//
#define OS_PLATFORM_NONE                   0x00000000
#define OS_PLATFORM_I386                   0x00000001
#define OS_PLATFORM_IA64                   0x00000002
#define OS_PLATFORM_ALL                    0xFFFFFFFF

//
// These definitions are used for OS SKU attribute tags on EXE entries
//
#define OS_SKU_NONE                        0x00000000 // None
#define OS_SKU_PER                         0x00000001 // Personal
#define OS_SKU_PRO                         0x00000002 // Professional
#define OS_SKU_SRV                         0x00000004 // Server
#define OS_SKU_ADS                         0x00000008 // Advanced Server
#define OS_SKU_DTC                         0x00000010 // Datacenter
#define OS_SKU_BLA                         0x00000020 // Blade Server
#define OS_SKU_TAB                         0x00000040 // TabletPC
#define OS_SKU_MED                         0x00000080 // eHome
#define OS_SKU_SBS                         0x00000100 // Small business server
#define OS_SKU_ALL                         0xFFFFFFFF

#ifndef ARRAYSIZE
#define ARRAYSIZE(rg) (sizeof(rg)/sizeof((rg)[0]))
#endif

#ifndef OFFSETOF
#define OFFSETOF offsetof
#endif

#define CHARCOUNT(sz) (sizeof(sz) / sizeof(sz[0]))

//
// our reg key locations
//
#define APPCOMPAT_LOCATION              TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags")

#define APPCOMPAT_KEY_PATH              APPCOMPAT_LOCATION
#define APPCOMPAT_KEY_PATH_CUSTOM       APPCOMPAT_LOCATION TEXT("\\Custom")
#define APPCOMPAT_KEY_PATH_INSTALLEDSDB APPCOMPAT_LOCATION TEXT("\\InstalledSDB")

#define POLICY_KEY_APPCOMPAT            TEXT("Software\\Policies\\Microsoft\\Windows\\AppCompat")
#define POLICY_VALUE_DISABLE_ENGINE     TEXT("DisableEngine")
#define POLICY_VALUE_DISABLE_WIZARD     TEXT("DisableWizard")
#define POLICY_VALUE_DISABLE_PROPPAGE   TEXT("DisablePropPage")
#define POLICY_VALUE_APPHELP_LOG        TEXT("LogAppHelpEvents")

// NT API versions
#define APPCOMPAT_KEY_PATH_MACHINE      TEXT("\\Registry\\Machine\\") APPCOMPAT_LOCATION

#define APPCOMPAT_KEY_PATH_NT           TEXT("\\") APPCOMPAT_LOCATION
#define APPCOMPAT_PERM_LAYER_PATH       TEXT("\\") APPCOMPAT_LOCATION TEXT("\\Layers")
#define APPCOMPAT_KEY_PATH_MACHINE_CUSTOM  APPCOMPAT_KEY_PATH_MACHINE TEXT("\\Custom")

#define APPCOMPAT_KEY_PATH_MACHINE_INSTALLEDSDB APPCOMPAT_KEY_PATH_MACHINE TEXT("\\InstalledSDB")


//
// our reg key locations
//

#define POLICY_VALUE_APPHELP_LOG_A      "LogAppHelpEvents"


//
// our reg key locations
//
#define APPCOMPAT_LOCATION_W                L"Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags"

#define APPCOMPAT_KEY_PATH_W                APPCOMPAT_LOCATION_W
#define APPCOMPAT_KEY_PATH_CUSTOM_W         APPCOMPAT_LOCATION_W L"\\Custom"
#define APPCOMPAT_KEY_PATH_INSTALLEDSDB_W   APPCOMPAT_LOCATION_W L"\\InstalledSDB"

#define POLICY_KEY_APPCOMPAT_W              L"Software\\Policies\\Microsoft\\Windows\\AppCompat"
#define POLICY_VALUE_DISABLE_ENGINE_W       L"DisableEngine"
#define POLICY_VALUE_DISABLE_WIZARD_W       L"DisableWizard"
#define POLICY_VALUE_DISABLE_PROPPAGE_W     L"DisablePropPage"
#define POLICY_VALUE_APPHELP_LOG_W          L"LogAppHelpEvents"

//
// LUA all-users redirection location
//
#define LUA_REDIR       ("%ALLUSERSPROFILE%\\Application Data\\Redirected")
#define LUA_REDIR_W     TEXT("%ALLUSERSPROFILE%\\Application Data\\Redirected")

//
// debug output support
//
typedef enum tagSHIMDBGLEVEL {
    sdlError   = 1,
    sdlWarning = 2,
    sdlFail    = 1,  // this means we have failed some api, not necessarily fatal
    sdlInfo    = 3,
    sdlUser    = 4
} SHIMDBGLEVEL;

typedef enum _SHIMVIEWER_OPTION {
    SHIMVIEWER_OPTION_UNINITIAZED,
    SHIMVIEWER_OPTION_NO,
    SHIMVIEWER_OPTION_YES
} SHIMVIEWER_OPTION;

//
// This flag marks the debug out for shimviewer
//
#define sdlLogShimViewer 0x00000080UL
#define sdlMask          0x0000007FUL

#define SHIMVIEWER_DATA_SIZE       1024
#define SHIMVIEWER_DATA_PREFIX     L"SHIMVIEW:"
#define SHIMVIEWER_DATA_PREFIX_LEN (sizeof(SHIMVIEWER_DATA_PREFIX)/sizeof(WCHAR) - 1)

#define FILTER_DBG_LEVEL(level) ((int)((level) & sdlMask))


extern int __cdecl ShimDbgPrint(INT iDebugLevel, PCH FunctionName, PCH Format, ...);

#if DBG // Define _DEBUG_SPEW when compiling checked

    #ifndef _DEBUG_SPEW
        #define _DEBUG_SPEW
    #endif

#endif // DBG


#ifdef _DEBUG_SPEW

//
// This value is a large number (initiallly)
// We will initialize it from the environment upon the first call
// to ShimDbgPrint
//
extern int g_iShimDebugLevel;

#define DBGPRINT( _x_ ) \
    {                                 \
        if (g_iShimDebugLevel) {      \
            ShimDbgPrint _x_;         \
        }                             \
    }

#else

#define DBGPRINT(_x_)

#endif // _DEBUG_SPEW

//
// This is an option controlled by the ShowDebugInfo value under
// HKCU\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags.
//
#define APPCOMPAT_KEY_PATH_W_WITH_SLASH L"\\" APPCOMPAT_LOCATION_W
#define SHIMENG_SHOW_DEBUG_INFO         L"ShowDebugInfo"

extern SHIMVIEWER_OPTION g_eShimViewerOption;

SHIMVIEWER_OPTION
SdbGetShowDebugInfoOption(
    void
    );


///////////////////////////////////////////////////////////////////////////////
//
// SHIM TAGS
//

//
// Function to get the tag names given a tag ID.
//
// WARNING !!! : If you add new tags make sure you update SdbApi\attributes.c
//               with the name of the tag in the global gaTagInfo.
//
LPCTSTR
SDBAPI
SdbTagToString(
    TAG tag
    );


//
// LIST types for shimdb
//
#define TAG_DATABASE            (0x1 | TAG_TYPE_LIST)
#define TAG_LIBRARY             (0x2 | TAG_TYPE_LIST)
#define TAG_INEXCLUDE           (0x3 | TAG_TYPE_LIST)
#define TAG_SHIM                (0x4 | TAG_TYPE_LIST)
#define TAG_PATCH               (0x5 | TAG_TYPE_LIST)
#define TAG_APP                 (0x6 | TAG_TYPE_LIST)
#define TAG_EXE                 (0x7 | TAG_TYPE_LIST)
#define TAG_MATCHING_FILE       (0x8 | TAG_TYPE_LIST)
#define TAG_SHIM_REF            (0x9 | TAG_TYPE_LIST)
#define TAG_PATCH_REF           (0xA | TAG_TYPE_LIST)
#define TAG_LAYER               (0xB | TAG_TYPE_LIST)
#define TAG_FILE                (0xC | TAG_TYPE_LIST)
#define TAG_APPHELP             (0xD | TAG_TYPE_LIST)
#define TAG_LINK                (0xE | TAG_TYPE_LIST)   // Description list w/lang ids and urls
#define TAG_DATA                (0xF | TAG_TYPE_LIST)
#define TAG_MSI_TRANSFORM       (0x10| TAG_TYPE_LIST)
#define TAG_MSI_TRANSFORM_REF   (0x11| TAG_TYPE_LIST)
#define TAG_MSI_PACKAGE         (0x12| TAG_TYPE_LIST)
#define TAG_FLAG                (0x13| TAG_TYPE_LIST)
#define TAG_MSI_CUSTOM_ACTION   (0x14| TAG_TYPE_LIST)
#define TAG_FLAG_REF            (0x15| TAG_TYPE_LIST)
#define TAG_ACTION              (0x16| TAG_TYPE_LIST)


//
// STRINGREF types for shimdb
//

#define TAG_NAME                (0x1  | TAG_TYPE_STRINGREF)
#define TAG_DESCRIPTION         (0x2  | TAG_TYPE_STRINGREF)
#define TAG_MODULE              (0x3  | TAG_TYPE_STRINGREF)
#define TAG_API                 (0x4  | TAG_TYPE_STRINGREF)
#define TAG_VENDOR              (0x5  | TAG_TYPE_STRINGREF)
#define TAG_APP_NAME            (0x6  | TAG_TYPE_STRINGREF)
#define TAG_COMMAND_LINE        (0x8  | TAG_TYPE_STRINGREF)
#define TAG_COMPANY_NAME        (0x9  | TAG_TYPE_STRINGREF)
#define TAG_DLLFILE             (0xA  | TAG_TYPE_STRINGREF)
#define TAG_WILDCARD_NAME       (0xB  | TAG_TYPE_STRINGREF)
#define TAG_PRODUCT_NAME        (0x10 | TAG_TYPE_STRINGREF)
#define TAG_PRODUCT_VERSION     (0x11 | TAG_TYPE_STRINGREF)
#define TAG_FILE_DESCRIPTION    (0x12 | TAG_TYPE_STRINGREF)
#define TAG_FILE_VERSION        (0x13 | TAG_TYPE_STRINGREF)
#define TAG_ORIGINAL_FILENAME   (0x14 | TAG_TYPE_STRINGREF)
#define TAG_INTERNAL_NAME       (0x15 | TAG_TYPE_STRINGREF)
#define TAG_LEGAL_COPYRIGHT     (0x16 | TAG_TYPE_STRINGREF)
#define TAG_16BIT_DESCRIPTION   (0x17 | TAG_TYPE_STRINGREF)
#define TAG_APPHELP_DETAILS     (0x18 | TAG_TYPE_STRINGREF) // Details in single language
#define TAG_LINK_URL            (0x19 | TAG_TYPE_STRINGREF)
#define TAG_LINK_TEXT           (0x1A | TAG_TYPE_STRINGREF)
#define TAG_APPHELP_TITLE       (0x1B | TAG_TYPE_STRINGREF)
#define TAG_APPHELP_CONTACT     (0x1C | TAG_TYPE_STRINGREF)
#define TAG_SXS_MANIFEST        (0x1D | TAG_TYPE_STRINGREF)
#define TAG_DATA_STRING         (0x1E | TAG_TYPE_STRINGREF)
#define TAG_MSI_TRANSFORM_FILE  (0x1F | TAG_TYPE_STRINGREF)
#define TAG_16BIT_MODULE_NAME   (0x20 | TAG_TYPE_STRINGREF)
#define TAG_LAYER_DISPLAYNAME   (0x21 | TAG_TYPE_STRINGREF)
#define TAG_COMPILER_VERSION    (0x22 | TAG_TYPE_STRINGREF)
#define TAG_ACTION_TYPE         (0x23 | TAG_TYPE_STRINGREF)

#define TAG_STRINGTABLE         (0x801 | TAG_TYPE_LIST)


//
// DWORD types for shimdb
//
#define TAG_SIZE                (0x1  | TAG_TYPE_DWORD)
#define TAG_OFFSET              (0x2  | TAG_TYPE_DWORD)
#define TAG_CHECKSUM            (0x3  | TAG_TYPE_DWORD)
#define TAG_SHIM_TAGID          (0x4  | TAG_TYPE_DWORD)
#define TAG_PATCH_TAGID         (0x5  | TAG_TYPE_DWORD)
#define TAG_MODULE_TYPE         (0x6  | TAG_TYPE_DWORD)
#define TAG_VERDATEHI           (0x7  | TAG_TYPE_DWORD)
#define TAG_VERDATELO           (0x8  | TAG_TYPE_DWORD)
#define TAG_VERFILEOS           (0x9  | TAG_TYPE_DWORD)
#define TAG_VERFILETYPE         (0xA  | TAG_TYPE_DWORD)
#define TAG_PE_CHECKSUM         (0xB  | TAG_TYPE_DWORD)
#define TAG_PREVOSMAJORVER      (0xC  | TAG_TYPE_DWORD)
#define TAG_PREVOSMINORVER      (0xD  | TAG_TYPE_DWORD)
#define TAG_PREVOSPLATFORMID    (0xE  | TAG_TYPE_DWORD)
#define TAG_PREVOSBUILDNO       (0xF  | TAG_TYPE_DWORD)
#define TAG_PROBLEMSEVERITY     (0x10 | TAG_TYPE_DWORD)
#define TAG_LANGID              (0x11 | TAG_TYPE_DWORD)
#define TAG_VER_LANGUAGE        (0x12 | TAG_TYPE_DWORD)

#define TAG_ENGINE              (0x14 | TAG_TYPE_DWORD)
#define TAG_HTMLHELPID          (0x15 | TAG_TYPE_DWORD)
#define TAG_INDEX_FLAGS         (0x16 | TAG_TYPE_DWORD)
#define TAG_FLAGS               (0x17 | TAG_TYPE_DWORD)
#define TAG_DATA_VALUETYPE      (0x18 | TAG_TYPE_DWORD)
#define TAG_DATA_DWORD          (0x19 | TAG_TYPE_DWORD)
#define TAG_LAYER_TAGID         (0x1A | TAG_TYPE_DWORD)
#define TAG_MSI_TRANSFORM_TAGID (0x1B | TAG_TYPE_DWORD)
#define TAG_LINKER_VERSION      (0x1C | TAG_TYPE_DWORD)
#define TAG_LINK_DATE           (0x1D | TAG_TYPE_DWORD)
#define TAG_UPTO_LINK_DATE      (0x1E | TAG_TYPE_DWORD)
#define TAG_OS_SERVICE_PACK     (0x1F | TAG_TYPE_DWORD)


#define TAG_FLAG_TAGID          (0x20 | TAG_TYPE_DWORD)
#define TAG_RUNTIME_PLATFORM    (0x21 | TAG_TYPE_DWORD)
#define TAG_OS_SKU              (0x22 | TAG_TYPE_DWORD)

#define TAG_TAGID               (0x801| TAG_TYPE_DWORD)

//
// STRING types
//
#define TAG_STRINGTABLE_ITEM    (0x801 | TAG_TYPE_STRING)

//
// NULL types for shimdb (existence/nonexistence is treated like a BOOL)
//
#define TAG_INCLUDE                  (0x1 | TAG_TYPE_NULL)
#define TAG_GENERAL                  (0x2 | TAG_TYPE_NULL)
#define TAG_MATCH_LOGIC_NOT          (0x3 | TAG_TYPE_NULL)
#define TAG_APPLY_ALL_SHIMS          (0x4 | TAG_TYPE_NULL)
#define TAG_USE_SERVICE_PACK_FILES   (0x5 | TAG_TYPE_NULL)

//
// QWORD types for shimdb
//
#define TAG_TIME                     (0x1 | TAG_TYPE_QWORD)
#define TAG_BIN_FILE_VERSION         (0x2 | TAG_TYPE_QWORD)
#define TAG_BIN_PRODUCT_VERSION      (0x3 | TAG_TYPE_QWORD)
#define TAG_MODTIME                  (0x4 | TAG_TYPE_QWORD)
#define TAG_FLAG_MASK_KERNEL         (0x5 | TAG_TYPE_QWORD)
#define TAG_UPTO_BIN_PRODUCT_VERSION (0x6 | TAG_TYPE_QWORD)
#define TAG_DATA_QWORD               (0x7 | TAG_TYPE_QWORD)
#define TAG_FLAG_MASK_USER           (0x8 | TAG_TYPE_QWORD)
#define TAG_FLAGS_NTVDM1             (0x9 | TAG_TYPE_QWORD)
#define TAG_FLAGS_NTVDM2             (0xA | TAG_TYPE_QWORD)
#define TAG_FLAGS_NTVDM3             (0xB | TAG_TYPE_QWORD)
#define TAG_FLAG_MASK_SHELL          (0xC | TAG_TYPE_QWORD)
#define TAG_UPTO_BIN_FILE_VERSION    (0xD | TAG_TYPE_QWORD)
#define TAG_FLAG_MASK_FUSION         (0xE | TAG_TYPE_QWORD)



//
// BINARY types for shimdb
//
#define TAG_PATCH_BITS               (0x2 | TAG_TYPE_BINARY)
#define TAG_FILE_BITS                (0x3 | TAG_TYPE_BINARY)
#define TAG_EXE_ID                   (0x4 | TAG_TYPE_BINARY)
#define TAG_DATA_BITS                (0x5 | TAG_TYPE_BINARY)
#define TAG_MSI_PACKAGE_ID           (0x6 | TAG_TYPE_BINARY)  // msi package id is a guid
#define TAG_DATABASE_ID              (0x7 | TAG_TYPE_BINARY)  // database guid

#define TAG_INDEX_BITS               (0x801 | TAG_TYPE_BINARY)

//
// INDEX types for shimdb
//
#define TAG_INDEXES             (0x802 | TAG_TYPE_LIST)
#define TAG_INDEX               (0x803 | TAG_TYPE_LIST)

//
// WORD types
//
#define TAG_MATCH_MODE          (0x1 | TAG_TYPE_WORD)

#define TAG_TAG                 (0x801 | TAG_TYPE_WORD)
#define TAG_INDEX_TAG           (0x802 | TAG_TYPE_WORD)
#define TAG_INDEX_KEY           (0x803 | TAG_TYPE_WORD)

//
// let the typedefs take the course..
//

#undef LPCTSTR
#undef LPTSTR
#undef TCHAR


#endif // _SHIMDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\shimhookmacro.h ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    ShimHookMacro.h

 Abstract:

    Shim hooking macros for version 2

 Notes:

    None

 History:

    10/29/2000 markder  Created
    12/06/2000 robkenny Converted to use namespaces
    09/11/2001 mnikkel Modified DPFN and LOGN to retain LastError

--*/

#pragma once

#ifndef _ShimHookMacro_h_
#define _ShimHookMacro_h_

//
// These are dwReason values that the shim notification functions
// can be called with.
//

//
// This means that all the static linked DLLs have run their init routines.
//
#define SHIM_STATIC_DLLS_INITIALIZED                100

//
// This means that the current process is about to die.
// This gives the shims a chance to do cleanup work while all the modules
// are still loaded.
//
#define SHIM_PROCESS_DYING                          101

//
// This notification is sent to notify the shims that a DLL is unloading
//
#define SHIM_DLL_LOADING                            102

extern PLDR_DATA_TABLE_ENTRY g_DllLoadingEntry;
#define GETDLLLOADINGHANDLE()   (g_DllLoadingEntry)


//
// This debug macro needs to be in this file because it needs access
// to g_szModuleName which is only defined inside the namespace.
//
inline void DPFN(ShimLib::DEBUGLEVEL dwDetail, LPCSTR pszFmt, ...)
{
#if DBG
    // This must be the first line of this routine to preserve LastError.
    DWORD dwLastError = GetLastError();

    extern const CHAR * g_szModuleName; // created by the DECLARE_SHIM macro, inside of the shim's namespace
    
    va_list vaArgList;
    va_start(vaArgList, pszFmt);

    ShimLib::DebugPrintfList(g_szModuleName, dwDetail, pszFmt, vaArgList);

    va_end(vaArgList);
    
    // This must be the last line of this routine to preserve LastError.
    SetLastError(dwLastError); 
#else
    dwDetail; 
    pszFmt;
#endif

}

inline void LOGN(ShimLib::DEBUGLEVEL dwDetail, LPCSTR pszFmt, ...)
{
    // This must be the first line of this routine to preserve LastError.
    DWORD dwLastError = GetLastError();

    extern const CHAR * g_szModuleName;

    if (ShimLib::g_bFileLogEnabled)
    {
        va_list vaArgList;
        va_start(vaArgList, pszFmt);

        ShimLib::ShimLogList(g_szModuleName, dwDetail, pszFmt, vaArgList);

        va_end(vaArgList);
    }
#if DBG
    // If logging isn't enabled, dump to the debugger
    else
    {
        va_list vaArgList;
        va_start(vaArgList, pszFmt);

        ShimLib::DebugPrintfList(g_szModuleName, dwDetail, pszFmt, vaArgList);

        va_end(vaArgList);
    }   
#endif

    // This must be the last line of this routine to preserve LastError.
    SetLastError(dwLastError); 
}


#define APIHOOK(hook) APIHook_##hook
#define COMHOOK(iface, hook) COMHook_##iface##_##hook

#define APIHOOK_ENUM_BEGIN                          enum {
#define APIHOOK_ENUM_ENTRY(hook)                    APIHOOK_##hook##,
#define APIHOOK_ENUM_ENTRY_COMSERVER(module)        APIHOOK_##module##_DllGetClassObject,
#define APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()                                             \
                                                    APIHOOK_ENUM_ENTRY_COMSERVER(DDRAW)    \
                                                    APIHOOK_ENUM_ENTRY_COMSERVER(DSOUND)   \
                                                    APIHOOK_ENUM_ENTRY_COMSERVER(DPLAYX)   \
                                                    APIHOOK_ENUM_ENTRY_COMSERVER(DINPUT)   \
                                                    APIHOOK_ENUM_ENTRY(DirectDrawCreate)   \
                                                    APIHOOK_ENUM_ENTRY(DirectDrawCreateEx) \
                                                    APIHOOK_ENUM_ENTRY(DirectSoundCreate)  \
                                                    APIHOOK_ENUM_ENTRY(DirectPlayCreate)   \
                                                    APIHOOK_ENUM_ENTRY(DirectInputCreateA) \
                                                    APIHOOK_ENUM_ENTRY(DirectInputCreateW) \
                                                    APIHOOK_ENUM_ENTRY(DirectInputCreateEx)

#define APIHOOK_ENUM_END                            APIHOOK_Count };

#define HOOK_BEGIN                                                                  \
PHOOKAPI                                                                            \
InitializeHooksMulti(                                                               \
    DWORD fdwReason,                                                                \
    LPSTR pszCmdLine,                                                               \
    DWORD* pdwHookCount                                                             \
    )                                                                               \
{                                                                                   \
    DPFN(eDbgLevelSpew,                                                             \
        "[InitializeHooksMulti] fdwReason(%d) pszCmdLine(%s)\n",                    \
        fdwReason, pszCmdLine);                                                     \
                                                                                    \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                          \
        g_szCommandLine = StringDuplicateA(pszCmdLine);                             \
        if (pszCmdLine != NULL && g_szCommandLine == NULL) {                        \
            return NULL;                                                            \
        }                                                                           \
                                                                                    \
        g_pAPIHooks =                                                               \
            (PHOOKAPI) ShimMalloc(sizeof(HOOKAPI)*APIHOOK_Count);                   \
        if (g_pAPIHooks == NULL) {                                                  \
            return NULL;                                                            \
        }                                                                           \
        *pdwHookCount = APIHOOK_Count;                                              \
    }

#define HOOK_END                                                                    \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                          \
        DPFN(eDbgLevelSpew,                                                         \
            "[InitializeHooksMulti] pdwHookCount(%d)\n",                            \
            pdwHookCount ? *pdwHookCount : 0);                                      \
    }                                                                               \
    return g_pAPIHooks;                                                             \
}

#define APIHOOK_ENTRY(module, hook)                                                 \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                          \
        g_pAPIHooks[APIHOOK_##hook##].pszModule = #module;                          \
        g_pAPIHooks[APIHOOK_##hook##].pszFunctionName = #hook;                      \
        g_pAPIHooks[APIHOOK_##hook##].pfnNew = APIHOOK(hook);                       \
    }

#define APIHOOK_ENTRY_NAME(module, hook, hookname)                                  \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                          \
        g_pAPIHooks[APIHOOK_##hook##].pszModule = #module;                          \
        g_pAPIHooks[APIHOOK_##hook##].pszFunctionName = #hookname;                  \
        g_pAPIHooks[APIHOOK_##hook##].pfnNew = APIHOOK(hook);                       \
    }

#define APIHOOK_ENTRY_ORD(module, hook, hookord)                                    \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                          \
        g_pAPIHooks[APIHOOK_##hook##].pszModule = #module;                          \
        g_pAPIHooks[APIHOOK_##hook##].pszFunctionName = (char *)IntToPtr(hookord);  \
        g_pAPIHooks[APIHOOK_##hook##].pfnNew = APIHOOK(hook);                       \
    }

#define APIHOOK_ENTRY_COMSERVER(module)                                                                 \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                                              \
        g_pAPIHooks[APIHOOK_##module##_DllGetClassObject].pszModule = #module ".DLL";                   \
        g_pAPIHooks[APIHOOK_##module##_DllGetClassObject].pszFunctionName = "DllGetClassObject";        \
        g_pAPIHooks[APIHOOK_##module##_DllGetClassObject].pfnNew = APIHOOK(module##_DllGetClassObject); \
    }

#define APIHOOK_ENTRY_DIRECTX_COMSERVER()                                           \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                          \
        APIHOOK_ENTRY_COMSERVER(DDRAW)                                              \
        APIHOOK_ENTRY_COMSERVER(DSOUND)                                             \
        APIHOOK_ENTRY_COMSERVER(DPLAYX)                                             \
        APIHOOK_ENTRY_COMSERVER(DINPUT)                                             \
        APIHOOK_ENTRY(DDRAW.DLL, DirectDrawCreate)                                  \
        APIHOOK_ENTRY(DDRAW.DLL, DirectDrawCreateEx)                                \
        APIHOOK_ENTRY(DSOUND.DLL, DirectSoundCreate)                                \
        APIHOOK_ENTRY(DPLAYX.DLL, DirectPlayCreate)                                 \
        APIHOOK_ENTRY(DINPUT.DLL, DirectInputCreateA)                               \
        APIHOOK_ENTRY(DINPUT.DLL, DirectInputCreateW)                               \
        APIHOOK_ENTRY(DINPUT.DLL, DirectInputCreateEx)                              \
    }

#define COMHOOK_ENTRY(obj, iface, hook, vtblndx)                                    \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                          \
        AddComHook(CLSID_##obj, IID_##iface, COMHOOK(iface, hook), vtblndx);        \
    }

#define DECLARE_SHIM(shim)                                                          \
    namespace NS_##shim                                                             \
    {                                                                               \
        const CHAR *    g_szModuleName = #shim;                                     \
        CHAR *          g_szCommandLine = "";                                       \
        PHOOKAPI        g_pAPIHooks = NULL;                                         \
        BOOL            g_bSubshimUsed = FALSE;                                     \
        extern PHOOKAPI InitializeHooksMulti(DWORD, LPSTR, DWORD*);                 \
    };

#define MULTISHIM_BEGIN()                                                                                    \
VOID ShimLib::InitializeHooks(DWORD)                                                                         \
{                                                                                                            \
    g_dwShimVersion = 2;                                                                                     \
}                                                                                                            \
PHOOKAPI ShimLib::InitializeHooksEx(DWORD fdwReason, LPWSTR pwszShim, LPSTR pszCmdLine, DWORD* pdwHookCount) \
{                                                                                                            \
    PHOOKAPI pAPIHooks = NULL;                                                                               \
    g_bMultiShim = TRUE;


#define MULTISHIM_ENTRY(shim)                                                                         \
    if ((fdwReason == DLL_PROCESS_ATTACH && pwszShim != NULL && 0 == _wcsicmp( pwszShim, L#shim )) || \
        (fdwReason == DLL_PROCESS_DETACH && NS_##shim::g_bSubshimUsed) ||                             \
        (fdwReason == SHIM_PROCESS_DYING && NS_##shim::g_bSubshimUsed) ||                             \
        (fdwReason == SHIM_DLL_LOADING && NS_##shim::g_bSubshimUsed) ||                               \
        (fdwReason == SHIM_STATIC_DLLS_INITIALIZED && NS_##shim::g_bSubshimUsed)) {                   \
        NS_##shim::g_bSubshimUsed = TRUE;                                                             \
        pAPIHooks = NS_##shim::InitializeHooksMulti( fdwReason, pszCmdLine, pdwHookCount );           \
    }

#define MULTISHIM_END()                                                         \
    return pAPIHooks;                                                           \
}

#define MULTISHIM_NOTIFY_FUNCTION() NotifyFn
#define NOTIFY_FUNCTION       NotifyFn

#define CALL_MULTISHIM_NOTIFY_FUNCTION()   NotifyFn(fdwReason);
#define CALL_NOTIFY_FUNCTION                                                    \
    if (FALSE == NotifyFn(fdwReason) &&                                         \
        fdwReason == DLL_PROCESS_ATTACH) {                                      \
        *pdwHookCount = 0;                                                      \
        DPFN(eDbgLevelSpew,                                                     \
            "[InitializeHooksMulti] NotifyFn returned FALSE, fail load shim\n", \
            g_pAPIHooks);                                                       \
        return NULL;                                                            \
    }

#define ORIGINAL_API(hook)                                                      \
    (*(_pfn_##hook##)(g_pAPIHooks[APIHOOK_##hook##].pfnOld))

#define _ORIGINAL_API(hook, proto)                                              \
    (*(_pfn_##proto##)(g_pAPIHooks[APIHOOK_##hook##].pfnOld))

#define ORIGINAL_COM(iface, hook, pThis)                                        \
    (*(_pfn_##iface##_##hook##)(LookupOriginalCOMFunction(*((PVOID *) pThis), COMHOOK(iface, hook), TRUE )))

#define COMMAND_LINE \
    (g_szCommandLine)

#define IMPLEMENT_COMSERVER_HOOK(module)                                         \
HRESULT                                                                          \
APIHOOK(##module##_DllGetClassObject)(                                           \
    REFCLSID rclsid,                                                             \
    REFIID riid,                                                                 \
    LPVOID * ppv                                                                 \
    )                                                                            \
{                                                                                \
    HRESULT hrReturn = E_FAIL;                                                   \
                                                                                 \
    hrReturn = _ORIGINAL_API(module##_DllGetClassObject, DllGetClassObject)(     \
                                rclsid, riid,  ppv);                             \
                                                                                 \
    if (S_OK ==  hrReturn) {                                                     \
        HookCOMInterface(rclsid, riid, ppv, TRUE);                               \
    }                                                                            \
                                                                                 \
    return hrReturn;                                                             \
}

#define IMPLEMENT_DIRECTX_COMSERVER_HOOKS()                                      \
IMPLEMENT_COMSERVER_HOOK(DDRAW)                                                  \
IMPLEMENT_COMSERVER_HOOK(DSOUND)                                                 \
IMPLEMENT_COMSERVER_HOOK(DPLAYX)                                                 \
IMPLEMENT_COMSERVER_HOOK(DINPUT)                                                 \
                                                                                 \
HRESULT                                                                          \
APIHOOK(DirectDrawCreate)(                                                       \
    IN GUID FAR *lpGUID,                                                         \
    OUT LPVOID *lplpDD,                                                          \
    OUT IUnknown* pUnkOuter                                                      \
    )                                                                            \
{                                                                                \
    HRESULT hrReturn = E_FAIL;                                                   \
                                                                                 \
    hrReturn = ORIGINAL_API(DirectDrawCreate)(lpGUID, lplpDD, pUnkOuter);        \
                                                                                 \
    if (S_OK == hrReturn) {                                                      \
        HookCOMInterface(CLSID_DirectDraw, IID_IDirectDraw, lplpDD, FALSE);      \
    }                                                                            \
                                                                                 \
    return hrReturn;                                                             \
}                                                                                \
                                                                                 \
HRESULT                                                                          \
APIHOOK(DirectDrawCreateEx)(                                                     \
    GUID FAR *lpGUID,                                                            \
    LPVOID *lplpDD,                                                              \
    REFIID iid,                                                                  \
    IUnknown* pUnkOuter                                                          \
    )                                                                            \
{                                                                                \
    HRESULT hrReturn = E_FAIL;                                                   \
                                                                                 \
    hrReturn = ORIGINAL_API(DirectDrawCreateEx)(                                 \
        lpGUID,                                                                  \
        lplpDD,                                                                  \
        iid,                                                                     \
        pUnkOuter);                                                              \
                                                                                 \
    if (S_OK ==  hrReturn) {                                                     \
        HookCOMInterface(CLSID_DirectDraw, iid, lplpDD, FALSE);                  \
    }                                                                            \
                                                                                 \
    return hrReturn;                                                             \
}                                                                                \
                                                                                 \
HRESULT                                                                          \
APIHOOK(DirectSoundCreate)(                                                      \
    LPCGUID lpcGuid,                                                             \
    LPDIRECTSOUND *ppDS,                                                         \
    LPUNKNOWN pUnkOuter)                                                         \
{                                                                                \
                                                                                 \
    HRESULT hrReturn = E_FAIL;                                                   \
                                                                                 \
    hrReturn = ORIGINAL_API(DirectSoundCreate)(                                  \
        lpcGuid,                                                                 \
        ppDS,                                                                    \
        pUnkOuter);                                                              \
                                                                                 \
    if (S_OK == hrReturn) {                                                      \
        HookCOMInterface(CLSID_DirectSound,                                      \
                         IID_IDirectSound,                                       \
                         (LPVOID*) ppDS,                                         \
                         FALSE);                                                 \
    }                                                                            \
                                                                                 \
    return hrReturn;                                                             \
}                                                                                \
                                                                                 \
HRESULT                                                                          \
APIHOOK(DirectPlayCreate)(                                                       \
    LPGUID lpGUIDSP,                                                             \
    LPDIRECTPLAY FAR *lplpDP,                                                    \
    IUnknown *lpUnk)                                                             \
{                                                                                \
                                                                                 \
    HRESULT hrReturn = E_FAIL;                                                   \
                                                                                 \
    hrReturn = ORIGINAL_API(DirectPlayCreate)(                                   \
        lpGUIDSP,                                                                \
        lplpDP,                                                                  \
        lpUnk);                                                                  \
                                                                                 \
    if (S_OK == hrReturn) {                                                      \
        HookCOMInterface(CLSID_DirectPlay,                                       \
                         IID_IDirectPlay,                                        \
                         (LPVOID*) lplpDP,                                       \
                         FALSE);                                                 \
    }                                                                            \
                                                                                 \
    return hrReturn;                                                             \
}                                                                                \
                                                                                 \
HRESULT                                                                          \
APIHOOK(DirectInputCreateA)(                                                     \
    HINSTANCE hinst,                                                             \
    DWORD dwVersion,                                                             \
    LPDIRECTINPUTA * lplpDirectInput,                                            \
    LPUNKNOWN punkOuter)                                                         \
{                                                                                \
                                                                                 \
    HRESULT hrReturn = E_FAIL;                                                   \
                                                                                 \
    hrReturn = ORIGINAL_API(DirectInputCreateA)(                                 \
        hinst,                                                                   \
        dwVersion,                                                               \
        lplpDirectInput,                                                         \
        punkOuter);                                                              \
                                                                                 \
    if (S_OK == hrReturn) {                                                      \
        HookCOMInterface(CLSID_DirectInput,                                      \
                         IID_IDirectInputA,                                      \
                         (LPVOID*) lplpDirectInput,                              \
                         FALSE);                                                 \
    }                                                                            \
                                                                                 \
    return hrReturn;                                                             \
}                                                                                \
                                                                                 \
HRESULT                                                                          \
APIHOOK(DirectInputCreateW)(                                                     \
    HINSTANCE hinst,                                                             \
    DWORD dwVersion,                                                             \
    LPDIRECTINPUTW * lplpDirectInput,                                            \
    LPUNKNOWN punkOuter)                                                         \
{                                                                                \
                                                                                 \
    HRESULT hrReturn = E_FAIL;                                                   \
                                                                                 \
    hrReturn = ORIGINAL_API(DirectInputCreateW)(                                 \
        hinst,                                                                   \
        dwVersion,                                                               \
        lplpDirectInput,                                                         \
        punkOuter);                                                              \
                                                                                 \
    if (S_OK == hrReturn) {                                                      \
        HookCOMInterface(CLSID_DirectInput,                                      \
                         IID_IDirectInputW,                                      \
                         (LPVOID*) lplpDirectInput,                              \
                         FALSE);                                                 \
    }                                                                            \
                                                                                 \
    return hrReturn;                                                             \
}                                                                                \
                                                                                 \
HRESULT                                                                          \
APIHOOK(DirectInputCreateEx)(                                                    \
    HINSTANCE hinst,                                                             \
    DWORD dwVersion,                                                             \
    REFIID riidltf,                                                              \
    LPVOID * ppvOut,                                                             \
    LPUNKNOWN punkOuter)                                                         \
{                                                                                \
                                                                                 \
    HRESULT hrReturn = E_FAIL;                                                   \
                                                                                 \
    hrReturn = ORIGINAL_API(DirectInputCreateEx)(                                \
        hinst,                                                                   \
        dwVersion,                                                               \
        riidltf,                                                                 \
        ppvOut,                                                                  \
        punkOuter);                                                              \
                                                                                 \
    if (S_OK == hrReturn) {                                                      \
        HookCOMInterface(CLSID_DirectInput,                                      \
                         riidltf,                                                \
                         (LPVOID*) ppvOut,                                       \
                         FALSE);                                                 \
    }                                                                            \
                                                                                 \
    return hrReturn;                                                             \
}                                                                                

// Only add this hook to the list if bDeclare is TRUE
// otherwise a blank entry is added.
#define APIHOOK_ENTRY_OR_NOT(bDeclare, module, hook)                                \
    if (bDeclare) {                                                                 \
        APIHOOK_ENTRY(module, hook)                                                 \
    }

// Only add this hook to the list if bDeclare is TRUE
// otherwise a blank entry is added.
#define APIHOOK_ENTRY_COMSERVER_OR_NOT(bDeclare, module)                            \
    if (bDeclare) {                                                                 \
        APIHOOK_ENTRY_COMSERVER(module)                                             \
    } else {                                                                        \
        APIHOOK_ENTRY_COMSERVER_BLANK(module)                                       \
    }


#define APIHOOK_ENTRY_COMSERVER_BLANK(module)                                       \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                          \
        g_pAPIHooks[APIHOOK_##module##_DllGetClassObject].pszModule = "";           \
        g_pAPIHooks[APIHOOK_##module##_DllGetClassObject].pszFunctionName = "";     \
        g_pAPIHooks[APIHOOK_##module##_DllGetClassObject].pfnNew = NULL;            \
    }


#endif // _SHIMHOOKMACRO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\shimcstring.h ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    CString.h

 Abstract:
    A CString class, pure UNICODE internally.

 History:

    02/22/2001   robkenny     Ported from MFC
    08/14/2001  robkenny    Inserted inside the ShimLib namespace.
    
--*/


#pragma once

#include <limits.h>


namespace ShimLib
{

// Use the standard exception handler, if this is not defined
// the C++ exception handler will be used instead.
//#define USE_SEH

#ifndef AFXAPI
#define AFXAPI              __stdcall
#endif

#ifndef AFXISAPI
#define AFXISAPI            __stdcall
#endif

#ifndef AFXISAPI_CDECL
#define AFXISAPI_CDECL      __cdecl
#endif

#ifndef AFX_CDECL
#define AFX_CDECL           __cdecl
#endif

#ifndef AFX_INLINE
#define AFX_INLINE          __inline
#endif

#ifndef AFX_CORE_DATA
#define AFX_CORE_DATA
#endif

#ifndef AFX_DATA
#define AFX_DATA
#endif

#ifndef AFX_DATADEF
#define AFX_DATADEF
#endif

#ifndef AFX_API
#define AFX_API
#endif

#ifndef AFX_COMDAT
#define AFX_COMDAT
#endif

#ifndef AFX_STATIC
#define AFX_STATIC          static
#endif


BOOL AFXAPI AfxIsValidString(LPCWSTR lpsz, int nLength = -1);
BOOL AFXAPI AfxIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite = TRUE);

inline size_t strlenChars(const char* s1)                                
{
    const char * send = s1;
    while (*send)
    {
        // Can't use CharNextA, since User32 might not be initialized
        if (IsDBCSLeadByte(*send))
        {
            ++send;
        }
        ++send;
    }
    return send - s1;
}

// Prototype for a string comparison routine.
typedef WCHAR *  (__cdecl *_pfn_wcsstr)(const WCHAR * s1, const WCHAR * s2);

template <class CharType> class CStringData
{
public:
    long nRefs;             // reference count
    int nDataLength;        // length of data (including terminator)                                      re
    int nAllocLength;       // length of allocation
    // CharType data[nAllocLength]

    CharType* data()           // CharType* to managed data
        { return (CharType*)(this+1); }
};


class CString
{
public:
#ifdef USE_SEH
    // SEH Exception information
    enum
    {
        eCStringNoMemoryException   = STATUS_NO_MEMORY,
        eCStringExceptionValue      = 0x12345678,
    };
    static int              ExceptionFilter(PEXCEPTION_POINTERS pexi);
    static const ULONG_PTR  m_CStringExceptionValue;

#else

    // A class used only for throwing C++ exceptions
    class CStringError
    {
    public:
        CStringError() {};
        ~CStringError() {};
    };
#endif

public:
    static WCHAR ChNil;

public:
// Constructors

    // constructs empty CString
    CString();
    // copy constructor
    CString(const CString & stringSrc);
    // from a single character
    CString(WCHAR ch, int nRepeat = 1);
    // allocate nLen WCHARs space.
    CString(int nLength);
    CString(const WCHAR * lpsz);
    // subset of characters from an ANSI string (converts to WCHAR)
    CString(const WCHAR * lpch, int nLength);

    // Create from an ANSI string
    CString(LPCSTR lpsz);
    CString(LPCSTR lpsz, int nCharacters);


// Attributes & Operations

    // get data length, number of characters
    int GetLength() const;
    // TRUE if zero length
    BOOL IsEmpty() const;
    // clear contents to empty
    void Empty();

    // return pointer to const string
    operator const WCHAR * () const;
    const WCHAR * Get() const;
    // Get, return NULL if string is empty
    const WCHAR * GetNIE() const;
    char * GetAnsi() const;
    // Get ANSI string: caller is responsible for freeing the string
    char * ReleaseAnsi() const;
    // Get, return NULL if string is empty
    char * GetAnsiNIE() const;

    // return single character at zero-based index
    WCHAR GetAt(int nIndex) const;
    // return single character at zero-based index
    WCHAR operator[](int nIndex) const;
    // set a single character at zero-based index
    void SetAt(int nIndex, WCHAR ch);

    // overloaded assignment

    // copy string content from UNICODE string
    const CString & operator=(const WCHAR * lpsz);
    // ref-counted copy from another CString
    const CString & operator=(const CString & stringSrc);
    // set string content to single character
    const CString & operator=(WCHAR ch);
    // copy string content from unsigned chars
    //const CString & operator=(const unsigned WCHAR* psz);

    const CString& CString::operator=(LPCSTR lpsz);

    // string concatenation

    // concatenate from another CString
    const CString & operator+=(const CString & string);

    // concatenate a single character
    const CString & operator+=(WCHAR ch);
    // concatenate a string
    const CString & operator+=(const WCHAR * lpsz);

    friend CString AFXAPI operator+(const CString & string1, const CString & string2);
    friend CString AFXAPI operator+(const CString & string, WCHAR ch);
    friend CString AFXAPI operator+(WCHAR ch, const CString & string);
    friend CString AFXAPI operator+(const CString & string, const WCHAR * lpsz);
    friend CString AFXAPI operator+(const WCHAR * lpsz, const CString & string);

    // string comparison

    // straight character comparison
    int Compare(const WCHAR * lpsz) const;
    // compare ignoring case
    int CompareNoCase(const WCHAR * lpsz) const;
    // NLS aware comparison, case sensitive
    int Collate(const WCHAR * lpsz) const;
    // NLS aware comparison, case insensitive
    int CollateNoCase(const WCHAR * lpsz) const;

    int ComparePart(const WCHAR * lpsz, int start, int nChars) const;
    int ComparePartNoCase(const WCHAR * lpsz, int start, int nChars) const;

    int EndsWith(const WCHAR * lpsz) const;
    int EndsWithNoCase(const WCHAR * lpsz) const;

    // simple sub-string extraction

    // return nCount characters starting at zero-based nFirst
    CString Mid(int nFirst, int nCount) const;
    // return all characters starting at zero-based nFirst
    CString Mid(int nFirst) const;
    // return first nCount characters in string
    CString Left(int nCount) const;
    // return nCount characters from end of string
    CString Right(int nCount) const;

    //  characters from beginning that are also in passed string
    CString SpanIncluding(const WCHAR * lpszCharSet) const;
    // characters from beginning that are not also in passed string
    CString SpanExcluding(const WCHAR * lpszCharSet) const;


    // upper/lower/reverse conversion

    // NLS aware conversion to uppercase
    void MakeUpper();
    // NLS aware conversion to lowercase
    void MakeLower();
    // reverse string right-to-left
    void MakeReverse();

    // trimming whitespace (either side)

    // remove whitespace starting from right edge
    void TrimRight();
    // remove whitespace starting from left side
    void TrimLeft();

    // trimming anything (either side)

    // remove continuous occurrences of chTarget starting from right
    void TrimRight(WCHAR chTarget);
    // remove continuous occcurrences of characters in passed string,
    // starting from right
    void TrimRight(const WCHAR * lpszTargets);
    // remove continuous occurrences of chTarget starting from left
    void TrimLeft(WCHAR chTarget);
    // remove continuous occcurrences of characters in
    // passed string, starting from left
    void TrimLeft(const WCHAR * lpszTargets);

    // advanced manipulation

    // replace occurrences of chOld with chNew
    int Replace(WCHAR chOld, WCHAR chNew);

    // replace occurrences of substring lpszOld with lpszNew;
    // empty lpszNew removes instances of lpszOld
    int Replace(const WCHAR * lpszOld, const WCHAR * lpszNew);
    // Case insensitive version of Replace
    int ReplaceI(const WCHAR * lpszOld, const WCHAR * lpszNew);

    // remove occurrences of chRemove
    int Remove(WCHAR chRemove);
    // insert character at zero-based index; concatenates
    // if index is past end of string
    int Insert(int nIndex, WCHAR ch);
    // insert substring at zero-based index; concatenates
    // if index is past end of string
    int Insert(int nIndex, const WCHAR * pstr);
    // delete nCount characters starting at zero-based index
    int Delete(int nIndex, int nCount = 1);
    // delete all characters to the right of nIndex
    void Truncate(int nIndex);

    // searching

    // find character starting at left, -1 if not found
    int Find(WCHAR ch) const;
    // find character starting at right
    int ReverseFind(WCHAR ch) const;
    // find character starting at zero-based index and going right
    int Find(WCHAR ch, int nStart) const;
    // find first instance of any character in passed string
    int FindOneOf(const WCHAR * lpszCharSet) const;
    // find first instance of any character in passed string starting at zero-based index
    int FindOneOf(const WCHAR * lpszCharSet, int nCount) const;
    // find first instance of substring
    int Find(const WCHAR * lpszSub) const;
    // find first instance of substring starting at zero-based index
    int Find(const WCHAR * lpszSub, int nStart) const;

    // find first instance of any character *not* in passed string starting at zero-based index
    int FindOneNotOf(const WCHAR * lpszCharSet, int nCount) const;

    // simple formatting

    // printf-like formatting using passed string
    void AFX_CDECL Format(const WCHAR * lpszFormat, ...);
    // printf-like formatting using referenced string resource
    //void AFX_CDECL Format(UINT nFormatID, ...);
    // printf-like formatting using variable arguments parameter
    void FormatV(const WCHAR * lpszFormat, va_list argList);

    // Format routines that accept ANSI args
    void AFX_CDECL Format(const char * lpszFormat, ...);
    void FormatV(const char * lpszFormat, va_list argList);

    // formatting for localization (uses FormatMessage API)

    // format using FormatMessage API on passed string
    void AFX_CDECL FormatMessage(const WCHAR * lpszFormat, ...);

    // input and output
#ifdef _DEBUG
    friend CDumpContext& AFXAPI operator<<(CDumpContext& dc,
                const CString & string);
#endif
//  friend CArchive& AFXAPI operator<<(CArchive& ar, const CString & string);
//  friend CArchive& AFXAPI operator>>(CArchive& ar, CString & string);

//    friend const CString & AFXAPI AfxGetEmptyString();


    // Access to string implementation buffer as "C" character array

    // get pointer to modifiable buffer at least as long as nMinBufLength
    WCHAR * GetBuffer(int nMinBufLength);
    // release buffer, setting length to nNewLength (or to first nul if -1)
    void ReleaseBuffer(int nNewLength = -1);
    // get pointer to modifiable buffer exactly as long as nNewLength
    WCHAR * GetBufferSetLength(int nNewLength);
    // release memory allocated to but unused by string
    void FreeExtra();

    // Use LockBuffer/UnlockBuffer to turn refcounting off

    // turn refcounting back on
    WCHAR * LockBuffer();
    // turn refcounting off
    void UnlockBuffer();

    // ======================================================================
    // CString extensions: making life easier.
    //
    // Win32 API
    // NOTE: The return values are different from Win32
    //       Return 0 for failure or number of chars for success
    DWORD       GetModuleFileNameW(HMODULE hModule);
    DWORD       GetShortPathNameW(void);
    DWORD       GetLongPathNameW(void);
    DWORD       GetFullPathNameW(void);
    DWORD       GetSystemDirectoryW(void); 
    DWORD       GetSystemWindowsDirectoryW(void); 
    DWORD       GetWindowsDirectoryW(void); 
    DWORD       GetTempPathW(void);
    DWORD       GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique );
    DWORD       ExpandEnvironmentStringsW(void);
    DWORD       GetCurrentDirectoryW(void);
    DWORD       GetLocaleInfoW(LCID Locale, LCTYPE LCType);

    // Returns NtStatus
    DWORD       NtReqQueryValueExW(const WCHAR * lpszKey, const WCHAR * lpszValue);


    // Split this into the seperate path components
    void SplitPath(CString * csDrive, CString * csDir, CString * csName, CString * csExt) const;
    void MakePath(const CString * csDrive, const CString * csDir, const CString * csName, const CString * csExt);
    // Properly append csPath onto the end of this path
    void AppendPath(const WCHAR * lpszPath);
    // Find the trailing path component
    // Return index of the last path seperator or -1 if none found
    int FindLastPathComponent() const;
    // Get the "file" portion of this path
    void GetLastPathComponent(CString & pathComponent) const;
    // Get what's not the "file" portion of this path
    void GetNotLastPathComponent(CString & pathComponent) const;
    // Remove the trailing path component
    void StripPath();
    // Get the drive portion either c:\ or \\machine\
    // Note this is different from SplitPath
    void GetDrivePortion(CString & csDrivePortion) const;

    // Does this string match the pattern
    BOOL PatternMatch(const WCHAR * lpszPattern) const;

    BOOL IsPathSep(int index) const;

    // More efficient versions of above
    void Mid(int nFirst, int nCount, CString & csMid) const;
    void Mid(int nFirst, CString & csMid) const;
    void Left(int nCount, CString & csLeft) const;
    void Right(int nCount, CString & csRight) const;
    void SpanIncluding(const WCHAR * lpszCharSet, CString & csSpanInc) const;
    void SpanExcluding(const WCHAR * lpszCharSet, CString & csSpanExc) const;

    //
    // End of extensions
    //
    // ======================================================================

// Implementation
public:
    ~CString();
    int GetAllocLength() const;

protected:
    WCHAR * m_pchData;   // pointer to ref counted string data
    mutable char  * m_pchDataAnsi; // pointer to non-UNICODE version of string

    // implementation helpers
    CStringData<WCHAR> * GetData() const;
    void Init();
    void AllocCopy(CString & dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
    void AllocBuffer(int nLen);
    void AssignCopy(int nSrcLen, const WCHAR * lpszSrcData);
    void ConcatCopy(int nSrc1Len, const WCHAR * lpszSrc1Data, int nSrc2Len, const WCHAR * lpszSrc2Data);
    void ConcatInPlace(int nSrcLen, const WCHAR * lpszSrcData);
    void CopyBeforeWrite();
    void AllocBeforeWrite(int nLen);
    void Release();

    //============================================================

    // Used by Replace and ReplaceI
    int ReplaceRoutine(LPCWSTR lpszOld, LPCWSTR lpszNew, _pfn_wcsstr tcsstr);

    static void     Release(CStringData<WCHAR>* pData);
    static int      SafeStrlen(const WCHAR * lpsz);
    static void     FreeData(CStringData<WCHAR>* pData);

    static int                   _afxInitData[];
    static CStringData<WCHAR>*   _afxDataNil;
    static const WCHAR *         _afxPchNil;
};

/*
    End of class definitions.

    Below are routines that are candidates for inlining.

*/
#ifdef afxEmptyString
#undef afxEmptyString
#endif
#define afxEmptyString ((CString &)*(CString*)&CString::_afxPchNil)
inline BOOL    IsPathSep(WCHAR ch)
{ 
    return ch ==  L'\\' || ch ==  L'/'; 
}

// Compare helpers
AFX_INLINE bool AFXAPI operator==(const CString & s1, const CString & s2)       { return s1.Compare(s2) == 0; }
AFX_INLINE bool AFXAPI operator==(const CString & s1, const WCHAR * s2)         { return s1.Compare(s2) == 0; }
AFX_INLINE bool AFXAPI operator==(const WCHAR * s1, const CString & s2)         { return s2.Compare(s1) == 0; }
AFX_INLINE bool AFXAPI operator!=(const CString & s1, const CString & s2)       { return s1.Compare(s2) != 0; }
AFX_INLINE bool AFXAPI operator!=(const CString & s1, const WCHAR * s2)         { return s1.Compare(s2) != 0; }
AFX_INLINE bool AFXAPI operator!=(const WCHAR * s1, const CString & s2)         { return s2.Compare(s1) != 0; }
AFX_INLINE bool AFXAPI operator<(const CString & s1, const CString & s2)        { return s1.Compare(s2) < 0; }
AFX_INLINE bool AFXAPI operator<(const CString & s1, const WCHAR * s2)          { return s1.Compare(s2) < 0; }
AFX_INLINE bool AFXAPI operator<(const WCHAR * s1, const CString & s2)          { return s2.Compare(s1) > 0; }
AFX_INLINE bool AFXAPI operator>(const CString & s1, const CString & s2)        { return s1.Compare(s2) > 0; }
AFX_INLINE bool AFXAPI operator>(const CString & s1, const WCHAR * s2)          { return s1.Compare(s2) > 0; }
AFX_INLINE bool AFXAPI operator>(const WCHAR * s1, const CString & s2)          { return s2.Compare(s1) < 0; }
AFX_INLINE bool AFXAPI operator<=(const CString & s1, const CString & s2)       { return s1.Compare(s2) <= 0; }
AFX_INLINE bool AFXAPI operator<=(const CString & s1, const WCHAR * s2)         { return s1.Compare(s2) <= 0; }
AFX_INLINE bool AFXAPI operator<=(const WCHAR * s1, const CString & s2)         { return s2.Compare(s1) >= 0; }
AFX_INLINE bool AFXAPI operator>=(const CString & s1, const CString & s2)       { return s1.Compare(s2) >= 0; }
AFX_INLINE bool AFXAPI operator>=(const CString & s1, const WCHAR * s2)         { return s1.Compare(s2) >= 0; }
AFX_INLINE bool AFXAPI operator>=(const WCHAR * s1, const CString & s2)         { return s2.Compare(s1) <= 0; }

// CString
AFX_INLINE CStringData<WCHAR>* CString::GetData() const            { ASSERT(m_pchData != NULL, "CString::GetData: NULL m_pchData"); return ((CStringData<WCHAR>*)m_pchData)-1; }
AFX_INLINE void CString::Init()                                    { m_pchData = afxEmptyString.m_pchData; m_pchDataAnsi = NULL; }
AFX_INLINE CString::CString()                                      { Init(); }
//AFX_INLINE CString::CString(const unsigned WCHAR* lpsz)          { Init(); *this = (LPCSTR)lpsz; }
//AFX_INLINE const CString & CString::operator=(const unsigned WCHAR* lpsz) { *this = (LPCSTR)lpsz; return *this; }
AFX_INLINE int CString::GetLength() const                          { return GetData()->nDataLength; }
AFX_INLINE int CString::GetAllocLength() const                     { return GetData()->nAllocLength; }
AFX_INLINE BOOL CString::IsEmpty() const                           { return GetData()->nDataLength == 0; }
AFX_INLINE CString::operator const WCHAR *() const                 { return m_pchData; }
AFX_INLINE const WCHAR * CString::Get() const                      { return m_pchData; }
AFX_INLINE const WCHAR * CString::GetNIE() const                   { return IsEmpty() ? NULL : m_pchData; }
AFX_INLINE char  * CString::GetAnsiNIE() const                     { return IsEmpty() ? NULL : GetAnsi(); }
AFX_INLINE char  * CString::ReleaseAnsi() const                    { char * lpsz = GetAnsi(); m_pchDataAnsi = NULL; return lpsz; }
AFX_INLINE int CString::SafeStrlen(const WCHAR * lpsz)             { if ( lpsz == NULL ) return 0; else { SIZE_T ilen = wcslen(lpsz); if ( ilen <= INT_MAX ) return (int) ilen; return 0; } }
AFX_INLINE void CString::FreeData(CStringData<WCHAR>* pData)       { delete [] ((BYTE *)pData); }
AFX_INLINE int CString::Compare(const WCHAR * lpsz) const          { ASSERT(AfxIsValidString(lpsz), "CString::Compare: Invalid string"); return wcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
AFX_INLINE int CString::CompareNoCase(const WCHAR * lpsz) const    { ASSERT(AfxIsValidString(lpsz), "CString::CompareNoCase: Invalid string"); return _wcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
AFX_INLINE int CString::Collate(const WCHAR * lpsz) const          { ASSERT(AfxIsValidString(lpsz), "CString::Collate: Invalid string"); return wcscoll(m_pchData, lpsz); }   // locale sensitive
AFX_INLINE int CString::CollateNoCase(const WCHAR * lpsz) const    { ASSERT(AfxIsValidString(lpsz), "CString::CollateNoCase: Invalid string"); return _wcsicoll(m_pchData, lpsz); }   // locale sensitive
AFX_INLINE int CString::ComparePart(const WCHAR * lpsz, int start, int nChars) const    { ASSERT(AfxIsValidString(lpsz), "CString::CompareNoCase: Invalid string"); return wcsncmp(m_pchData+start, lpsz, nChars); }   // MBCS/Unicode aware
AFX_INLINE int CString::ComparePartNoCase(const WCHAR * lpsz, int start, int nChars) const    { ASSERT(AfxIsValidString(lpsz), "CString::CompareNoCase: Invalid string"); return _wcsnicmp(m_pchData+start, lpsz, nChars); }   // MBCS/Unicode aware
AFX_INLINE int CString::EndsWith(const WCHAR * lpsz) const
{
    int ilen = SafeStrlen(lpsz);
    int start = GetLength() - ilen;
    if (start < 0)
    {
        start = 0;
    }
    return ComparePart(lpsz, start, ilen);
}
AFX_INLINE int CString::EndsWithNoCase(const WCHAR * lpsz) const 
{
    int ilen = SafeStrlen(lpsz);
    int start = GetLength() - ilen;
    if (start < 0)
    {
        start = 0;
    }
    return ComparePartNoCase(lpsz, start, ilen);
}


AFX_INLINE WCHAR CString::GetAt(int nIndex) const
{
    ASSERT(nIndex >= 0, "CString::GetAt: negative index");
    ASSERT(nIndex < GetData()->nDataLength, "CString::GetData: index larger than string");
    return m_pchData[nIndex];
}
AFX_INLINE WCHAR CString::operator[](int nIndex) const
{
    // same as GetAt
    ASSERT(nIndex >= 0, "CString::operator[]: negative index");
    ASSERT(nIndex < GetData()->nDataLength, "CString::GetData: index larger than string");
    return m_pchData[nIndex];
}

AFX_INLINE BOOL CString::IsPathSep(int index) const
{
    return ShimLib::IsPathSep(GetAt(index));
}


#undef afxEmptyString

// ************************************************************************************


// Exception filter for CString __try/__except blocks
// Return EXCEPTION_EXECUTE_HANDLER if this is a CString exception
// otherwise return EXCEPTION_CONTINUE_SEARCH
extern int CStringExceptionFilter(PEXCEPTION_POINTERS pexi);

#if defined(USE_SEH)
#define CSTRING_THROW_EXCEPTION       RaiseException((DWORD)ShimLib::CString::eCStringNoMemoryException, 0, 1, &ShimLib::CString::m_CStringExceptionValue); // Continuable, CString specific memory exception
#define CSTRING_TRY                 __try
#define CSTRING_CATCH               __except( ShimLib::CString::ExceptionFilter(GetExceptionInformation()) )
#else
// If we use the C++ exception handler, we need to make sure we have the /GX compile flag
#define CSTRING_THROW_EXCEPTION     throw ShimLib::CString::CStringError();
#define CSTRING_TRY                 try
#define CSTRING_CATCH               catch( ShimLib::CString::CStringError & /* cse */ )
#endif


};  // end of namespace ShimLib




// ************************************************************************************


namespace ShimLib
{

/*++

    Read a registry value into this CString.
    REG_EXPAND_SZ is automatically expanded and the type is changed to REG_SZ
    If the type is not REG_SZ or REG_EXPAND_SZ, then csRegValue.GetLength()
    is the number of *bytes* in the string.
    
    This is typically used to only read REG_SZ/REG_EXPAND_SZ registry values.
    
    Note: This API may only be called after SHIM_STATIC_DLLS_INITIALIZED
    
--*/

LONG RegQueryValueExW(
        CString & csValue,
        HKEY hKeyRoot,
        const WCHAR * lpszKey,
        const WCHAR * lpszValue);

/*++

    Get the ShSpecial folder name.
    
    Note: This API may only be called after SHIM_STATIC_DLLS_INITIALIZED
    
--*/

BOOL SHGetSpecialFolderPathW(
    CString & csFolder,
    int nFolder,
    HWND hwndOwner = NULL
);


// ************************************************************************************
/*++

    A tokenizer--a replacement for strtok.

    Init the class with the string and token delimiter.
    Call GetToken to peel off the next token.

++*/

class CStringToken
{
public:
    CStringToken(const CString & csToken, const CString & csDelimit);

    // Get the next token
    BOOL            GetToken(CString & csNextToken);

    // Count the number of remaining tokens.
    int             GetCount() const;

protected:
    int             m_nPos;
    CString         m_csToken;
    CString         m_csDelimit;

    BOOL            GetToken(CString & csNextToken, int & nPos) const;
};

// ************************************************************************************

/*++

    A simple class to assist in command line parsing

--*/

class CStringParser
{
public:
    CStringParser(const WCHAR * lpszCl, const WCHAR * lpszSeperators);
    ~CStringParser();

    int         GetCount() const;                   // Return the current number of args
    CString &   Get(int nIndex);
    CString &   operator[](int nIndex);

    // Give ownership of the CString array to the caller
    // Caller must call delete [] cstring
    CString *           ReleaseArgv();

protected:
    int                 m_ncsArgList;
    CString *           m_csArgList;

    void                SplitSeperator(const CString & csCl, const CString & csSeperator);
    void                SplitWhite(const CString & csCl);
};


inline int  CStringParser::GetCount() const
{
    return m_ncsArgList;
}

inline CString & CStringParser::Get(int nIndex)
{
    return m_csArgList[nIndex];
}

inline CString & CStringParser::operator[](int nIndex)
{
    return m_csArgList[nIndex];
}

inline CString * CStringParser::ReleaseArgv()
{
    CString * argv = m_csArgList;

    m_csArgList     = NULL;
    m_ncsArgList    = 0;

    return argv;
}



};  // end of namespace ShimLib


// ************************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\shimpatch.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1993-1998
//
// File:        ldrpatch.h
//
// Contents:    Patch data structures
//
// History:     13-Oct-99   v-johnwh        created
//              15-Feb-00   markder         Changed CHARs to WCHARs
//
//---------------------------------------------------------------------------

#ifndef _LDRPATCH_H_
#define _LDRPATCH_H_

typedef struct _PATCHOP
{
   DWORD dwOpcode;        // opcode to be performed
   DWORD dwNextOpcode;    // relative offset to next opcode
   #pragma warning( disable : 4200 )
      BYTE data[];        //data for this operation type is dependent on the operation code
   #pragma warning( default : 4200 )
} PATCHOP, *PPATCHOP;

typedef struct _RELATIVE_MODULE_ADDRESS
{
   DWORD address;        //relative address from beginning of loaded module
   BYTE  reserved[3];    //reserved for system use
   WCHAR moduleName[32]; //module name for this address.
} RELATIVE_MODULE_ADDRESS, *PRELATIVE_MODULE_ADDRESS;

typedef struct _PATCHWRITEDATA
{
   DWORD dwSizeData;     //size of patch data in bytes
   RELATIVE_MODULE_ADDRESS rva; //relative address where this patch data is to be applied.
   #pragma warning( disable : 4200 )
      BYTE data[];     //patch data bytes.
   #pragma warning( default : 4200 )
} PATCHWRITEDATA, *PPATCHWRITEDATA;

typedef struct _PATCHMATCHDATA
{
   DWORD dwSizeData;     //size of matching data data in bytes
   RELATIVE_MODULE_ADDRESS rva; //relative address where this patch data is to be verified.
   #pragma warning( disable : 4200 )
      BYTE data[];     //Matching data bytes.
   #pragma warning( default : 4200 )
} PATCHMATCHDATA, *PPATCHMATCHDATA;

typedef struct _SETACTIVATEADDRESS
{
   RELATIVE_MODULE_ADDRESS rva; //relative address where this patch data is to be applied.
} SETACTIVATEADDRESS, *PSETACTIVATEADDRESS;

typedef struct _HOOKPATCHINFO
{
   DWORD dwHookAddress;                // Address of a hooked function
   PSETACTIVATEADDRESS pData;          // Pointer to the real patch data
   PVOID pThunkAddress;                // Pointer to the call thunk
   struct _HOOKPATCHINFO *pNextHook;      
} HOOKPATCHINFO, *PHOOKPATCHINFO;

typedef enum _PATCHOPCODES
{
   PEND = 0, //no more opcodes
   PSAA,     //Set Activate Address, SETACTIVATEADDRESS
   PWD,      //Patch Write Data, PATCHWRITEDATA
   PNOP,     //No Operation
   PMAT,     //Patch match the matching bytes but do not replace the bytes.
} PATCHOPCODES;

#endif //_LDRPATCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\shimhook.h ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    ShimHook.h

 Abstract:

    Main header for shim DLLs

 Notes:

    None

 History:

    10/29/1999 markder      Created
    07/16/2001 clupu        Merged multiple headers into ShimHook.h
    08/13/2001 robkenny     Cleaned up, readied for publishing.

--*/

#pragma once

#ifndef _SHIM_HOOK_H_
#define _SHIM_HOOK_H_


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntldr.h>
#include <ntddscsi.h>

#include <windows.h>
// Disable warning C4201: nonstandard extension used : nameless struct/union
// Allows shims to be compiled at Warning Level 4
#pragma warning ( disable : 4201 ) 
#include <mmsystem.h>
#pragma warning ( default : 4201 ) 
#include <WinDef.h>

#ifdef __cplusplus
extern "C" {
#endif
    #include <shimdb.h>
#ifdef __cplusplus
}
#endif



namespace ShimLib
{
/*++

  Globals
  
--*/

extern HINSTANCE    g_hinstDll;         // The Shim's dll handle
extern BOOL         g_bMultiShim;       // Does this dll handle multiple shims?
extern DWORD        g_dwShimVersion;    //



/*++

  Typedefs and enums
  
--*/

typedef struct tagSHIM_COM_HOOK
{
    CLSID*              pCLSID;
    IID*                pIID;
    DWORD               dwVtblIndex;
    PVOID               pfnNew;
    PVOID               pfnOld;
} SHIM_COM_HOOK, *PSHIM_COM_HOOK;

typedef struct tagSHIM_IFACE_FN_MAP
{
    PVOID               pVtbl;
    PVOID               pfnNew;
    PVOID               pfnOld;
    PVOID               pNext;
} SHIM_IFACE_FN_MAP, *PSHIM_IFACE_FN_MAP;

typedef struct tagSHIM_HOOKED_OBJECT
{
    PVOID               pThis;
    CLSID*              pCLSID;
    DWORD               dwRef;
    BOOL                bAddRefTrip;
    BOOL                bClassFactory;
    PVOID               pNext;
} SHIM_HOOKED_OBJECT, *PSHIM_HOOKED_OBJECT;


/*++

  Prototypes
  
--*/


//  These declarations are needed to hook all known exported APIs that return a COM object.
PVOID       LookupOriginalCOMFunction( PVOID pVtbl, PVOID pfnNew, BOOL bThrowExceptionIfNull );
void        DumpCOMHooks();
void        InitializeHooks(DWORD fdwReason);
PHOOKAPI    InitializeHooksEx(DWORD, LPWSTR, LPSTR, DWORD*);
VOID        HookObject(IN CLSID *pCLSID, IN REFIID riid, OUT LPVOID *ppv, OUT PSHIM_HOOKED_OBJECT pOb, IN BOOL bClassFactory );
VOID        HookCOMInterface(REFCLSID rclsid, REFIID riid, LPVOID * ppv, BOOL bClassFactory);
VOID        AddComHook(REFCLSID clsid, REFIID iid, PVOID hook, DWORD vtblndx);


};  // end of namespace ShimLib



/*++

  Defines
  
--*/

#define IMPLEMENT_SHIM_BEGIN(shim)                                              \
namespace NS_##shim                                                             \
{                                                                               \
    extern const CHAR * g_szModuleName;                                         \
    extern CHAR *       g_szCommandLine;                                        \
    extern PHOOKAPI     g_pAPIHooks;

#define IMPLEMENT_SHIM_STANDALONE(shim)                                         \
namespace NS_##shim                                                             \
{                                                                               \
    const CHAR * g_szModuleName;                                                \
    CHAR *       g_szCommandLine = "";                                          \
    PHOOKAPI     g_pAPIHooks;                                                   \
                                                                                \
extern PHOOKAPI InitializeHooksMulti(                                           \
    DWORD fdwReason,                                                            \
    LPSTR pszCmdLine,                                                           \
    DWORD* pdwHookCount                                                         \
    );                                                                          \
}                                                                               \
                                                                                \
namespace ShimLib {                                                             \
VOID                                                                            \
InitializeHooks(DWORD fdwReason)                                                \
{                                                                               \
    g_dwShimVersion = 2;                                                        \
}                                                                               \
                                                                                \
PHOOKAPI                                                                        \
InitializeHooksEx(                                                              \
    DWORD fdwReason,                                                            \
    LPWSTR pwszShim,                                                            \
    LPSTR pszCmdLine,                                                           \
    DWORD* pdwHookCount                                                         \
    )                                                                           \
{                                                                               \
    using namespace NS_##shim;                                                  \
    return InitializeHooksMulti(                                                \
                fdwReason,                                                      \
                pszCmdLine,                                                     \
                pdwHookCount );                                                 \
}                                                                               \
}                                                                               \
namespace NS_##shim                                                             \
{                                                                               \

#define IMPLEMENT_SHIM_END                                                      \
};


/*++

  ShimLib specific include files
  
--*/

#include "ShimProto.h"
#include "ShimLib.h"


#endif // _SHIM_HOOK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\stdexts.c ===
/****************************** Module Header ******************************\
* Module Name: stdexts.c
*
* Copyright (c) Microsoft Corporation. All rights reserved.
*
* This module contains standard routines for creating sane debuging extensions.
* It is meant to be included after stdexts.h in one of the files comprising
* the debug extsnsions for a given product or module.
*
* History:
* 11-Apr-1995 Sanfords  Created
\***************************************************************************/

HANDLE                  hCurrentProcess;
HANDLE                  hCurrentThread;
DWORD                   dwCurrentPc;
WINDBG_EXTENSION_APIS  *lpExtensionApis;
#ifdef KERNEL
DWORD                   dwProcessor;
#endif // KERNEL

PSTR pszAccessViolation = "%s: Access violation on \"%s\".\n";
PSTR pszMoveException   = "%s: exception in moveBlock()\n";
PSTR pszReadFailure     = "%s: lpReadProcessMemoryRoutine failed!\n";
PSTR pszCantContinue    = "%s: Non-continuable exception.\n";
BOOL fCtrlCHit = FALSE;


/*
 * This function returns TRUE once the user has hit a Ctrl-C.
 * This allows proper operation of nested SAFEWHILE loops so
 * that all levels exit.
 *
 * The globall fCtrlCHit flag needs to be reset manually and
 * is done so in the CommandEP function.
 */
BOOL IsCtrlCHit()
{
    if ((lpExtensionApis->lpCheckControlCRoutine)()) {
        fCtrlCHit = TRUE;
    }
    return fCtrlCHit;
}



VOID moveBlock(
PVOID pdst,
PVOID src,
DWORD size)
{
    BOOL fSuccess = TRUE;
    ULONG Result;

    try {
        if (IsWinDbg()) {
            if (!ReadMem((DWORD_PTR)src, pdst, size, &Result)) {
                fSuccess = FALSE;
             }
        } else {
            if (!NT_SUCCESS(NtReadVirtualMemory(hCurrentProcess,
                    src, pdst, size, NULL))) {
                fSuccess = FALSE;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Print(pszMoveException, pszExtName);
        fSuccess = FALSE;
    }
    if (!fSuccess) {
        DEBUGPRINT("%s: moveBlock(%p, %p, %x) failed.\n",
                pszExtName, pdst, src, size);
        OUTAHERE();
    }
}



BOOL tryMoveBlock(
PVOID pdst,
PVOID src,
DWORD size)
{
    BOOL fSuccess = TRUE;
    ULONG Result;

    try {
        if (IsWinDbg()) {
            if (!ReadMem((DWORD_PTR)src, pdst, size, &Result)) {
                DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) failed.\n", pszExtName, pdst, src, size);
                fSuccess = FALSE;
             }
        } else {
            if (!NT_SUCCESS(NtReadVirtualMemory(hCurrentProcess, src, pdst, size, NULL))) {
                DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) failed.\n", pszExtName, pdst, src, size);
                fSuccess = FALSE;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) faulted.\n", pszExtName, pdst, src, size);
        fSuccess = FALSE;
    }
    return(fSuccess);
}



VOID moveExp(
PVOID pdst,
LPSTR pszExp)
{
    DWORD_PTR dwGlobal;
    BOOL fSuccess = TRUE;

    try {
        dwGlobal = (DWORD_PTR)EvalExp(pszExp);
#ifndef KERNEL
        if (IsWinDbg()) {
            fSuccess = tryMoveBlock(&dwGlobal, (PVOID)dwGlobal, sizeof(DWORD));
        }
#endif // !KERNEL
        *((PDWORD_PTR)pdst) = dwGlobal;
    } except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        fSuccess = FALSE;
    }
    if (!fSuccess) {
        Print("%s: moveExp failed on %s.\n", pszExtName, pszExp);
        OUTAHERE();
    }
}


BOOL tryMoveExp(
PVOID pdst,
LPSTR pszExp)
{
    DWORD_PTR dwGlobal;
    BOOL fSuccess = TRUE;

    try {
        dwGlobal = (DWORD_PTR)EvalExp(pszExp);
#ifndef KERNEL
        if (IsWinDbg()) {
            if (!tryMove(dwGlobal, (PVOID)dwGlobal)) {
                DEBUGPRINT("%s: tryMoveExp(%p, %s) failed.\n", pszExtName, pdst, pszExp);
                fSuccess = FALSE;
            }
        }
#endif // !KERNEL
        *((PDWORD_PTR)pdst) = dwGlobal;
    } except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        DEBUGPRINT("%s: tryMoveExp(%p, %s) faulted.\n", pszExtName, pdst, pszExp);
        fSuccess = FALSE;
    }
    return(fSuccess);
}


VOID moveExpValue(
PVOID pdst,
LPSTR pszExp)
{
    DWORD dw;
    DWORD_PTR addr;

    if (tryMoveExp(&addr, pszExp)) {
        if (tryMoveBlock(&dw, (PVOID)addr, sizeof(DWORD))) {
            *((PDWORD)pdst) = dw;
            return;
        }
    }
    Print("%s: moveExpValue failed on %s.\n", pszExtName, pszExp);
    OUTAHERE();
}


BOOL tryMoveExpValue(
PVOID pdst,
LPSTR pszExp)
{
    DWORD dw;
    DWORD_PTR addr;

    if (tryMoveExp(&addr, pszExp)) {
        if (tryMove(dw, (PVOID)addr)) {
            *((PDWORD)pdst) = dw;
            return(TRUE);
        }
    }
    DEBUGPRINT("%s: tryMoveExpValue failed on %s.\n", pszExtName, pszExp);
    return(FALSE);
}


BOOL tryMoveExpPtr(
PVOID pdst,
LPSTR pszExp)
{
    DWORD_PTR dwGlobal;
    BOOL fSuccess = TRUE;

    try {
        dwGlobal = (DWORD_PTR)EvalExp(pszExp);
#ifndef KERNEL
        if (IsWinDbg()) {
            if (!tryMove(dwGlobal, (PVOID)dwGlobal)) {
                DEBUGPRINT("%s: tryMoveExpPtr(%p, %s) failed.\n", pszExtName, pdst, pszExp);
                fSuccess = FALSE;
            }
        }
#endif // !KERNEL
        *((PDWORD_PTR)pdst) = dwGlobal;
    } except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        DEBUGPRINT("%s: tryMoveExpPtr(%p, %s) faulted.\n", pszExtName, pdst, pszExp);
        fSuccess = FALSE;
    }
    return(fSuccess);
}


VOID moveExpValuePtr(
PVOID pdst,
LPSTR pszExp)
{
    DWORD_PTR dw;

    if (tryMoveExpPtr(&dw, pszExp)) {
        if (tryMoveBlock(&dw, (PVOID)dw, sizeof(dw))) {
            *((PDWORD_PTR)pdst) = dw;
            return;
        }
    }
    Print("%s: moveExpValue failed on %s.\n", pszExtName, pszExp);
    OUTAHERE();
}


/***************************************************************************
 * Common command parsing stuff                                            *
 ***************************************************************************/
PVOID EvalExp(
LPSTR psz)
{
    PVOID p;

    p = (PVOID)(lpExtensionApis->lpGetExpressionRoutine)(psz);
    if (p == NULL) {
        Print("%s: EvalExp failed to evaluate %s.\n", pszExtName, psz);
    }
    return p;
}



PVOID OptEvalExp(
LPSTR psz)
{
    while (*psz == ' ')
        psz++;
    if (*psz == '\0') {
        return(NULL);
    }
    return(EvalExp(psz));
}



PVOID OptEvalExp2(
LPSTR *ppsz)
{
    LPSTR psz = *ppsz;
    PVOID dwRet = NULL;

    while (*psz == ' ')
        psz++;
    if (*psz != '\0') {
        dwRet = EvalExp(psz);
        while (*psz != '\0' && *psz != ' ') {
            psz++;
        }
    }
    *ppsz = psz;
    return(dwRet);
}



DWORD StringToOpts(
LPSTR psz)
{
    DWORD opts = 0;

    while (*psz != '\0' && *psz != ' ') {
        if (*psz >= 'a' && *psz <= 'z') {
            opts |= 1 << (*psz - 'a');
        } else if (*psz >= 'A' && *psz <= 'Z') {
            opts |= 1 << (*psz - 'A');
        } else {
            return(OPTS_ERROR);     // any non-letter option is an error.
        }
        psz++;
    }
    return(opts);
}


/*
 * Function to convert an option string to a DWORD of flags.  pszLegalArgs
 * is used to allow option validation at the same time.
 *
 * *ppszArgs is set to point to after the options on exit.
 * On error, returns OPTS_ERROR.
 */
DWORD GetOpts(
LPSTR *ppszArgs,
LPSTR pszLegalArgs) // OPTIONAL
{
    DWORD Opts = 0;
    LPSTR pszArgs = *ppszArgs;

    /*
     * Skip whitespace
     */
    while (*pszArgs == ' ') {
        pszArgs++;
    }
    /*
     * process '-' prepended options.
     */
    while (*pszArgs == '-') {
        pszArgs++;
        Opts = StringToOpts(pszArgs);
        /*
         * skip to whitespace or end.
         */
        while (*pszArgs != '\0' && *pszArgs != ' ') {
            pszArgs++;
        }
        /*
         * skip trailing whitespace.
         */
        while (*pszArgs == ' ') {
            pszArgs++;
        }
        *ppszArgs = pszArgs;

        /*
         * optionally validate against LegalArgs
         */
        if (pszLegalArgs != NULL && ((Opts & StringToOpts(pszLegalArgs)) != Opts)) {
            Opts = OPTS_ERROR;
            Print("Bad options.\n");
            return(Opts);
        }
    }
    return(Opts);
}



VOID PrintHuge(
LPSTR psz)
{
    /*
     * Looks like this is faulting these days - Print seems to be fixed
     * so I'm leaving this entry point for compatibility. (SAS)
     */
#ifdef ITWORKS
#define HUNK_SIZE   400
    int cch;
    CHAR chSave;

    /*
     * since dorky Print extension can't handle very long strings,
     * break it up into peices for it to chew.
     */
    cch = strlen(psz);
    while (cch > HUNK_SIZE) {
        chSave = psz[HUNK_SIZE];
        psz[HUNK_SIZE] = '\0';
        Print(psz);
        psz[HUNK_SIZE] = chSave;
        psz += HUNK_SIZE;
        cch -= HUNK_SIZE;
    }
#endif
    Print(psz);
}



/*
 * Dispatcher function used by generated entrypoint functions.
 */
VOID CommonEP(
PVOID pFunction,
LPSTR pszName,
int type,
LPSTR pszLegalOpts,
HANDLE hcp,
HANDLE hct,
DWORD dwcp,
#ifdef KERNEL
DWORD dwp,
#else // !KERNEL
PWINDBG_EXTENSION_APIS lpea,
#endif // !KERNEL
LPSTR lpas)
{
    BOOL dwOptions, fSuccess;
    PVOID param1, param2, param3;

    hCurrentProcess = hcp;
    hCurrentThread = hct;
    dwCurrentPc = dwcp;
#ifdef KERNEL
    dwProcessor = dwp;
    lpExtensionApis = &ExtensionApis;
#else // !KERNEL
    lpExtensionApis = lpea;
#endif // !KERNLE

#if 0
    DEBUGPRINT("CommonEP(%x, \"%s\", %d, \"%s\", %x, %x, %x, %x, \"%s\")\n",
            pFunction,
            pszName,
            type,
            pszLegalOpts,
            hcp,
            hct,
            dwcp,
#ifdef KERNEL
            dwp,
#else // !KERNLE
            lpea,
#endif // !KERNEL
            lpas);
#endif

    fCtrlCHit = FALSE;  // reset this with each command. (SAFEWHILE fix)
    switch (type) {
    case NOARGS:
        fSuccess = ((TYPE_NOARGS)pFunction)();
        goto Exit;
    }

    dwOptions = GetOpts(&lpas, pszLegalOpts);
    if (dwOptions == OPTS_ERROR) {
        fSuccess = Ihelp(0, pszName);
        goto Exit;
    }

    try {
        switch (type) {
        case CUSTOM:
            fSuccess = ((TYPE_CUSTOM)pFunction)(dwOptions, lpas);
            break;

        case STDARGS0:
            fSuccess = ((TYPE_STDARGS0)pFunction)(dwOptions);
            break;

        case STDARGS1:
            fSuccess = ((TYPE_STDARGS1)pFunction)(dwOptions, OptEvalExp(lpas));
            break;

        case STDARGS2:
            param1 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS2)pFunction)(dwOptions, param1, OptEvalExp(lpas));
            break;

        case STDARGS3:
            param1 = OptEvalExp2(&lpas);
            param2 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS3)pFunction)(dwOptions, param1, param2, OptEvalExp(lpas));
            break;

        case STDARGS4:
            param1 = OptEvalExp2(&lpas);
            param2 = OptEvalExp2(&lpas);
            param3 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS4)pFunction)(dwOptions, param1, param2, param3, OptEvalExp(lpas));
            break;

        default:
            Print("CommonEP: Don't recognize function type %d.\n", type);
            break;
        }
    } except (GetExceptionCode() == STATUS_NONCONTINUABLE_EXCEPTION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszCantContinue, pszExtName);
    }

Exit:
    if (!fSuccess) {
        Print("%s failed.\n", pszName);
        Ihelp(0, pszName);
    }
}

/*
 * Entrypoint functions (generated from exts.h)
 */
#ifdef KERNEL
#define DOIT(name, h1, h2, opts, type)                  \
VOID name##(                                            \
    HANDLE hcp,                                         \
    HANDLE hct,                                         \
    DWORD dwcp,                                         \
    DWORD dwp,                                          \
    LPSTR lpas)                                         \
{                                                       \
    CommonEP(I##name, #name, type, opts, hcp, hct, dwcp, dwp, lpas); \
}
#else // !KERNEL
#define DOIT(name, h1, h2, opts, type)                  \
VOID name##(                                            \
    HANDLE hcp,                                         \
    HANDLE hct,                                         \
    DWORD dwcp,                                         \
    PWINDBG_EXTENSION_APIS lpea,                        \
    LPSTR lpas)                                         \
{                                                       \
    CommonEP(I##name, #name, type, opts, hcp, hct, dwcp, lpea, lpas); \
}
#endif // !KERNEL
#include "exts.h"
#undef DOIT


/*
 * Standard help extension - present in all standard extensions.
 */
BOOL Ihelp(
    DWORD opts,
    LPSTR lpas)
{
#define DOIT(name, help1, help2, opts, type)  { #name, help1, help2 },

    static struct {
        LPSTR pszCmdName;
        LPSTR pszHelp1;
        LPSTR pszHelp2;
    } he[] = {
#include "exts.h"
    };
#undef DOIT
    int i;

    while (*lpas == ' ')
        lpas++;

    if (*lpas == '\0') {
        Print("-------------- %s Debug Extension help:--------------\n\n", pszExtName);
        for (i = 0; i < sizeof(he) / sizeof(he[0]); i++) {
            if (IsCtrlCHit()) {
                break;
            }
            Print(he[i].pszHelp1);
            if (opts & OFLAG(v)) {
                PrintHuge(he[i].pszHelp2);
            }
        }
        return(TRUE);
    } else {
        for (i = 0; i < sizeof(he) / sizeof(he[0]); i++) {
            if (IsCtrlCHit()) {
                break;
            }
            if (strcmp(lpas, he[i].pszCmdName) == 0) {
                Print(he[i].pszHelp1);
                PrintHuge(he[i].pszHelp2);
                return(TRUE);
            }
        }
        Print("%s is not supported.\n", lpas);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\shimlib.h ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    ShimLib.h

 Abstract:

    Routines available in ShimLib.lib

 Notes:

    None

 History:

    08/13/2001  robkenny    Created.
    08/14/2001  robkenny    Inserted inside the ShimLib namespace.
    08/15/2001  robkenny    Merged several include files.
    09/11/2001  mnikkel     Modified DPFN and LOGN to retain LastError

--*/

#pragma once


#include <Windows.h>

// ***************************************************************************
// ***************************************************************************


namespace ShimLib
{


// Debug levels
typedef enum 
{    
    eDbgLevelBase  = 0,
    eDbgLevelError,
    eDbgLevelWarning,
    eDbgLevelInfo,
    eDbgLevelSpew = 9,
} DEBUGLEVEL;


extern BOOL         g_bFileLogEnabled;  // Is the LOG() routine logging to a file.



// Environment variable with the name of the log file
#define szFileLogEnvironmentVariable "SHIM_FILE_LOG"
#define wszFileLogEnvironmentVariable L"SHIM_FILE_LOG"

// Debug environment variable, values = 0 -> 9
#define szDebugEnvironmentVariable "SHIM_DEBUG_LEVEL"    


void        APPBreakPoint(void);
VOID        ShimLogList(LPCSTR szShimName, DEBUGLEVEL dwDbgLevel, LPCSTR pszFmt, va_list arglist);
VOID        ShimLog(    LPCSTR szShimName, DEBUGLEVEL dwDbgLevel, LPCSTR pszFmt, ...);

BOOL        InitFileLogSupport();
VOID        __cdecl FileLog(DWORD dwDetail, LPSTR pszFmt, ...);

VOID        DebugPrintfList(LPCSTR szShimName, DEBUGLEVEL dwDetail, LPCSTR szFmt, va_list vaArgList);
VOID        DebugPrintf(    LPCSTR szShimName, DEBUGLEVEL dwDetail, LPCSTR szFmt, ...);


// ***************************************************************************
// ***************************************************************************

/*++

  Shim debug routines.
  
--*/

// Our own version of ASSERT

#ifdef ASSERT
#undef ASSERT
#endif

#if DBG
    VOID DebugAssert(LPCSTR szFile, DWORD dwLine, BOOL bAssert, LPCSTR szHelpString);

    #define ASSERT(a, b) DebugAssert(__FILE__, __LINE__, a, b)
#else
    #pragma warning(disable : 4002)
    #define ASSERT(a, b)
    #pragma warning(default : 4002)
#endif

inline void DPF(LPCSTR szShimName, DEBUGLEVEL dwDetail, LPCSTR pszFmt, ...)
{
#if DBG
    // This must be the first line of this routine to preserve LastError.
    DWORD dwLastError = GetLastError();
    
    va_list vaArgList;
    va_start(vaArgList, pszFmt);

    DebugPrintfList(szShimName, dwDetail, pszFmt, vaArgList);

    va_end(vaArgList);

    // This must be the last line of this routine to preserve LastError.
    SetLastError(dwLastError); 
#else
    szShimName;
    dwDetail;
    pszFmt;
#endif
}

inline void LOG(LPCSTR szShimName, DEBUGLEVEL dwDetail, LPCSTR pszFmt, ...)
{
    if (g_bFileLogEnabled)
    {
        // This must be the first line of this routine to preserve LastError.
        DWORD dwLastError = GetLastError();
        
        va_list vaArgList;
        va_start(vaArgList, pszFmt);

        ShimLogList(szShimName, dwDetail, pszFmt, vaArgList);

        va_end(vaArgList);
        
        // This must be the last line of this routine to preserve LastError.
        SetLastError(dwLastError);
    }
}

};  // end of namespace ShimLib


// ***************************************************************************
// ***************************************************************************
/*++

  The shim system uses its own heap.
  Malloc, free, new and delete are redirected to these routines:
  
--*/

namespace ShimLib
{
void *      __cdecl ShimMalloc(size_t size);
void        __cdecl ShimFree(void * memory);
void *      __cdecl ShimCalloc(size_t num, size_t size);
void *      __cdecl ShimRealloc(void * memory, size_t size);

};  // end of namespace ShimLib

// We override malloc/free with our own versions using a private heap.
#define malloc(size)            ShimLib::ShimMalloc(size)
#define free(memory)            ShimLib::ShimFree(memory)
#define calloc(num, size)       ShimLib::ShimCalloc(num, size)
#define realloc(memory, size)   ShimLib::ShimRealloc(memory, size)


inline void * __cdecl operator new(size_t size)
{
    return ShimLib::ShimMalloc(size);
}

inline void * operator new[]( size_t size )
{
    return ShimLib::ShimMalloc(size);
}

inline void __cdecl operator delete(void * memory)
{
    ShimLib::ShimFree(memory);
}

inline void operator delete[]( void * memory )
{
    ShimLib::ShimFree(memory);
}




#include "ShimCString.h"


// ***************************************************************************
// ***************************************************************************
/*++

  ShimLib routines
  
--*/
namespace ShimLib
{

/*++

  Prototypes for various helper routines.
  
--*/

PVOID       HookCallback( PVOID pfnOld, PVOID pfnNew );

UINT        GetDriveTypeFromHandle(HANDLE hFile);
UINT        GetDriveTypeFromFileNameA(LPCSTR lpFileName, char *lpDriveLetter = NULL);
UINT        GetDriveTypeFromFileNameW(LPCWSTR lpFileName, WCHAR *lpDriveLetter = NULL);
inline BOOL IsOnCDRom(HANDLE hFile) { return GetDriveTypeFromHandle(hFile) == DRIVE_CDROM; }
inline BOOL IsOnCDRomA(LPCSTR lpFileName) { return GetDriveTypeFromFileNameA(lpFileName) == DRIVE_CDROM; }
inline BOOL IsOnCDRomW(LPCWSTR lpFileName) { return GetDriveTypeFromFileNameW(lpFileName) == DRIVE_CDROM; }

BOOL        IsImage16BitA(LPCSTR lpFileName);
BOOL        IsImage16BitW(LPCWSTR lpFileName);

WCHAR *     ToUnicode(const char * lpszAnsi);
char *      ToAnsi(const WCHAR * lpszUnicode);

LPWSTR *    _CommandLineToArgvW(LPCWSTR lpCmdLine, int * pNumArgs);
LPSTR *     _CommandLineToArgvA(LPCSTR lpCmdLine,  int * pNumArgs);

char *      StringDuplicateA(const char * strToCopy);
WCHAR *     StringDuplicateW(const WCHAR * wstrToCopy);
char *      StringNDuplicateA(const char * strToCopy, int stringLength);
WCHAR *     StringNDuplicateW(const WCHAR * wstrToCopy, int stringLength);

VOID        SkipBlanksW(const WCHAR *& str);

BOOL        PatternMatchW(LPCWSTR szPattern, LPCWSTR szTestString);


// stristr is *not* DBCS safe
char *      __cdecl stristr(const char* string, const char * strCharSet);

WCHAR *     __cdecl wcsistr(const WCHAR* string, const WCHAR * strCharSet);
char *      __cdecl _strtok(char *strToken, const char *strDelimit);


BOOL        bIsSafeDisc1();
BOOL        bIsSafeDisc2();

BOOL        IsNTVDM(void);


WCHAR *     W9xPathMassageW(const WCHAR * uncorrect);

BOOL        MakeShimUnloadLast(HMODULE hMod);

DEBUGLEVEL  GetDebugLevel(void);

};  // end of namespace ShimLib



// ***************************************************************************
// ***************************************************************************
/*++

  AppAndCommandLine is a class used to parse lpApplicationName and lpCommandline
  exactly as it would be by CreateProcess().

--*/

namespace ShimLib
{

class AppAndCommandLine
{
protected:
    CString          csApplicationName;
    CString          csCommandLine;
    CString          csCommandLineNoAppName;
    CString          csShortCommandLine;

    BOOL             GetAppnameAndCommandline(const WCHAR * lpcApp, const WCHAR * lpcCl);

public:
    AppAndCommandLine(const char * lpcApplicationName, const char * lpcCommandLine);
    AppAndCommandLine(const WCHAR * lpcApplicationName, const WCHAR * lpcCommandLine);

    inline const CString &     GetApplicationName() const;
    inline const CString &     GetCommandline() const;
    inline const CString &     GetCommandlineNoAppName() const;

    const CString &            GetShortCommandLine();
};


inline const CString & AppAndCommandLine::GetApplicationName() const
{
    return csApplicationName;
}

inline const CString & AppAndCommandLine::GetCommandline() const
{
    return csCommandLine;
}

inline const CString & AppAndCommandLine::GetCommandlineNoAppName() const
{
    return csCommandLineNoAppName;
}



};  // end of namespace ShimLib


// ***************************************************************************
// ***************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\shimproto.h ===
/*++

 Copyright (c) 1999 Microsoft Corporation

 Module Name:

    ShimProto.h

 Abstract:

    Definitions for use by all modules

 Notes:

    None

 History:

    12/09/1999 robkenny Created
    01/10/2000 linstev  Format to new style
    08/16/2000 prashkud Added VFW header file.
    08/22/2000 a-brienw Added winmm.h, mciSendCommand,
                        and mciSendString    
    11/17/2000 mnikkel  Added GetObjectA
    11/29/2000 andyseti Added DirectPlay
    02/02/2001 a-leelat Added ScreenToClient
    03/07/2001 mnikkel  Added GetLastError
    03/19/2001 a-leelat Added PdhAddCounter
    05/17/2001 prashkud Added MsiGetProperty
    05/21/2001 mnikkel  Added PrintDlgA
    12/14/2001 hioh     Added ImmAssociateContext

--*/

#ifndef _SHIMPROTO_H_
#define _SHIMPROTO_H_

#include <tapi.h>
#include <dinput.h>
#include <dplay.h>
#include <vfw.h>
#include <winmm.h>
#include <pdh.h>
#include <ras.h>
#include <Softpub.h>
#include <WinCrypt.h>
#include <WinTrust.h>
#include <ImageHlp.h>
#include <iphlpapi.h>
#include <winerror.h>
#include <shellapi.h>
#include <shlobj.h>
#include <ole2.h>
#include <ddraw.h>
#include <dsound.h>
#include <commdlg.h>
#include <winspool.h>
#include <msi.h>
#include <aclapi.h>
#include <ntmsapi.h>
#include <winsock2.h>

typedef SOCKET      (WINAPI *_pfn_socket)(int af, int type, int protocol);

typedef BOOL        (WINAPI *_pfn_DeviceIoControl)(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
typedef BOOL        (WINAPI *_pfn_CloseHandle)( HANDLE hObject );
typedef UINT        (WINAPI *_pfn_SetHandleCount)(UINT uNewCount);
typedef NTSTATUS    (WINAPI *_pfn_NtClose)(HANDLE Handle);
typedef BOOL        (WINAPI *_pfn_DuplicateHandle)( HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions );
typedef BOOL        (WINAPI *_pfn_CreateProcessA)(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
typedef BOOL        (WINAPI *_pfn_CreateProcessW)(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
typedef BOOL        (WINAPI *_pfn_CreateProcessAsUserA)(HANDLE hToken, LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
typedef BOOL        (WINAPI *_pfn_CreateProcessAsUserW)(HANDLE hToken, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
typedef NTSTATUS    (WINAPI *_pfn_NtCreateProcessEx)(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, ULONG Flags, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort, ULONG JobMemberLevel);
typedef HANDLE      (WINAPI *_pfn_CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
typedef VOID        (WINAPI *_pfn_ExitThread)(DWORD dwExitCode);
typedef BOOL        (WINAPI *_pfn_TerminateThread)(HANDLE hThread, DWORD dwExitCode);
typedef BOOL        (WINAPI *_pfn_SetThreadPriority)(HANDLE hThread, int nPriority);
typedef BOOL        (WINAPI *_pfn_SetPriorityClass)(HANDLE hProcess, DWORD dwPriorityClass);
typedef HANDLE      (WINAPI *_pfn_CreateSemaphoreA)(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName);
typedef HANDLE      (WINAPI *_pfn_CreateSemaphoreW)(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName);
typedef HWND        (WINAPI *_pfn_CreateWindowA)(LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
typedef HWND        (WINAPI *_pfn_CreateWindowW)(LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
typedef HWND        (WINAPI *_pfn_CreateWindowExA)(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
typedef HWND        (WINAPI *_pfn_CreateWindowExW)(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
typedef BOOL        (WINAPI *_pfn_DestroyWindow)(HWND hWnd);
typedef HWND        (WINAPI *_pfn_GetFocus)(VOID);
typedef BOOL        (WINAPI *_pfn_EnumChildWindows)(HWND hWndParent, WNDENUMPROC lpEnumFunc, LPARAM lParam);
typedef ATOM        (WINAPI *_pfn_RegisterClassA)(CONST WNDCLASSA *lpWndClass);
typedef ATOM        (WINAPI *_pfn_RegisterClassW)(CONST WNDCLASSW *lpWndClass);
typedef ATOM        (WINAPI *_pfn_RegisterClassExA)(CONST WNDCLASSEXA *lpWndClass);
typedef ATOM        (WINAPI *_pfn_RegisterClassExW)(CONST WNDCLASSEXW *lpWndClass);
typedef BOOL        (WINAPI *_pfn_GetClassInfoA)(HINSTANCE hInstance, LPCSTR lpClassName, LPWNDCLASSA lpWndClass);
typedef UINT        (WINAPI *_pfn_GetDlgItemTextA)(HWND hDlg, int nIDDlgItem, LPSTR lpString, int nMaxCount);
typedef BOOL        (WINAPI *_pfn_SetDlgItemTextA)(HWND hWnd, int nIDDlgItem, LPCSTR lpString);
typedef INT_PTR     (WINAPI *_pfn_DialogBoxParamA)(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
typedef INT_PTR     (WINAPI *_pfn_DialogBoxParamW)(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
typedef INT_PTR     (WINAPI *_pfn_DialogBoxIndirectParamA)(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM lInitParam);
typedef INT_PTR     (WINAPI *_pfn_DialogBoxIndirectParamW)(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM lInitParam);
typedef HWND        (WINAPI *_pfn_CreateDialogParamA)(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
typedef HWND        (WINAPI *_pfn_CreateDialogParamW)(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
typedef HWND        (WINAPI *_pfn_CreateDialogIndirectParamA)(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM lInitParam);
typedef HWND        (WINAPI *_pfn_CreateDialogIndirectParamW)(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM lInitParam);
typedef HWND        (WINAPI *_pfn_CreateDialogIndirectParamAorW)(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM lInitParam);
typedef BOOL        (WINAPI *_pfn_EndDialog)(HWND hDlg, int nResult);
typedef HWND        (WINAPI *_pfn_SetFocus)(HWND hwnd);
typedef DWORD       (WINAPI *_pfn_GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
typedef WORD        (WINAPI *_pfn_GetClassWord)(HWND hWnd, int nIndex);
typedef WORD        (WINAPI *_pfn_GetWindowWord)(HWND hWnd, int nUnknown);
typedef WORD        (WINAPI *_pfn_SetWindowWord)(HWND hWnd, int nUnknown, WORD wUnknown);
typedef HWND        (WINAPI *_pfn_GetSysModalWindow)(void);
typedef HWND        (WINAPI *_pfn_SetSysModalWindow)(HWND hWnd);
                    
typedef BOOL        (WINAPI *_pfn_GetMenuItemInfoA)(HMENU hMenu, UINT uItem, BOOL fByPosition, LPMENUITEMINFO lpmii);
typedef BOOL        (WINAPI *_pfn_GetMenuItemInfoW)(HMENU hMenu, UINT uItem, BOOL fByPosition, LPMENUITEMINFO lpmii);
                    
typedef BOOL        (WINAPI *_pfn_CopyFileA)( LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists);
typedef BOOL        (WINAPI *_pfn_CopyFileW)( LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists);
typedef BOOL        (WINAPI *_pfn_CopyFileExA)( LPCSTR lpExistingFileName,LPCSTR lpNewFileName,LPPROGRESS_ROUTINE lpProgressRoutine,LPVOID lpData,LPBOOL pbCancel,DWORD dwCopyFlags );
typedef BOOL        (WINAPI *_pfn_CopyFileExW)( LPCWSTR lpExistingFileName,LPCWSTR lpNewFileName,LPPROGRESS_ROUTINE lpProgressRoutine,LPVOID lpData,LPBOOL pbCancel,DWORD dwCopyFlags );
typedef BOOL        (WINAPI *_pfn_CreateDirectoryA)( LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef BOOL        (WINAPI *_pfn_CreateDirectoryW)( LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef BOOL        (WINAPI *_pfn_CreateDirectoryExA)( LPCSTR lpTemplateDirectory,LPCSTR lpNewDirectory,LPSECURITY_ATTRIBUTES lpSecurityAttributes );
typedef BOOL        (WINAPI *_pfn_CreateDirectoryExW)( LPCWSTR lpTemplateDirectory,LPCWSTR lpNewDirectory,LPSECURITY_ATTRIBUTES lpSecurityAttributes );
typedef DWORD       (WINAPI *_pfn_GetCurrentDirectoryA)(DWORD nBufferLength, LPSTR lpBuffer);
typedef DWORD       (WINAPI *_pfn_GetCurrentDirectoryW)(DWORD nBufferLength, LPWSTR lpBuffer);
typedef BOOL        (WINAPI *_pfn_DeleteFileA)( LPCSTR lpFileName );
typedef BOOL        (WINAPI *_pfn_DeleteFileW)( LPCWSTR lpFileName );
typedef NTSTATUS    (WINAPI *_pfn_NtDeleteFile)(POBJECT_ATTRIBUTES ObjectAttributes);
typedef BOOL        (WINAPI *_pfn_FreeLibrary)( HMODULE hModule );
typedef BOOL        (WINAPI *_pfn_FreeResource)(HGLOBAL hMem);
typedef BOOL        (WINAPI *_pfn_GetBinaryTypeA)( LPCSTR lpApplicationName, LPDWORD lpBinaryType);
typedef BOOL        (WINAPI *_pfn_GetBinaryTypeW)( LPCWSTR lpApplicationName, LPDWORD lpBinaryType);
typedef DWORD       (WINAPI *_pfn_GetFullPathNameA)( LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart);
typedef DWORD       (WINAPI *_pfn_GetFullPathNameW)( LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
typedef DWORD       (WINAPI *_pfn_GetShortPathNameA)(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer );
typedef DWORD       (WINAPI *_pfn_GetShortPathNameW)(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer );
typedef BOOL        (WINAPI *_pfn_MoveFileA)(LPCSTR lpExistingFileName,  LPCSTR lpNewFileName);
typedef BOOL        (WINAPI *_pfn_MoveFileW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
typedef BOOL        (WINAPI *_pfn_MoveFileExA)(LPCSTR lpExistingFileName, LPCSTR lpNewNewFileName, DWORD dwFlags);
typedef BOOL        (WINAPI *_pfn_MoveFileExW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewNewFileName, DWORD dwFlags);
typedef BOOL        (WINAPI *_pfn_MoveFileWithProgressA)(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags);
typedef BOOL        (WINAPI *_pfn_MoveFileWithProgressW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags);
typedef BOOL        (WINAPI *_pfn_ReplaceFileA)(LPCSTR lpReplacedFileName, LPCSTR lpReplacementFileName, LPCSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved);
typedef BOOL        (WINAPI *_pfn_ReplaceFileW)(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved);
                    
typedef DWORD       (WINAPI *_pfn_WNetAddConnectionA)(LPCSTR lpRemoteName, LPCSTR lpPassword, LPCSTR lpLocalName);
typedef DWORD       (WINAPI *_pfn_WNetAddConnectionW)(LPCWSTR lpRemoteName, LPCWSTR lpPassword, LPCWSTR lpLocalName);
                    
typedef BOOL        (WINAPI *_pfn_SetCurrentDirectoryA)(LPCSTR lpPathName);
typedef BOOL        (WINAPI *_pfn_SetCurrentDirectoryW)(LPCWSTR lpPathName);
typedef HFILE       (WINAPI *_pfn_OpenFile)(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle);
typedef NTSTATUS    (WINAPI *_pfn_NtOpenFile)(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);
                    
typedef HFILE       (WINAPI *_pfn__lopen)(LPCSTR, int);
typedef HFILE       (WINAPI *_pfn__lcreat)(LPCSTR, int);
typedef LONG        (WINAPI *_pfn__hwrite)(HFILE hFile, LPCSTR lpBuffer, LONG lBytes);
typedef HFILE       (WINAPI *_pfn__lclose)(HFILE hFile);
typedef LONG        (WINAPI *_pfn__llseek)(HFILE hFile, LONG lOffset, int iOrigin);
typedef UINT        (WINAPI *_pfn__lread)(HFILE hFile, LPVOID lpBuffer, UINT uBytes);
typedef UINT        (WINAPI *_pfn__lwrite)(HFILE hFile, LPCSTR lpBuffer, UINT uBytes);
                    
typedef HANDLE      (WINAPI *_pfn_CreateFileA)( LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
typedef HANDLE      (WINAPI *_pfn_CreateFileW)( LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
typedef NTSTATUS    (WINAPI *_pfn_NtCreateFile)(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);
typedef HANDLE      (WINAPI *_pfn_CreateFileMappingA)(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
typedef HANDLE      (WINAPI *_pfn_CreateFileMappingW)(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName);
typedef HANDLE      (WINAPI *_pfn_OpenFileMappingA)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
typedef HANDLE      (WINAPI *_pfn_OpenFileMappingW)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
typedef PVOID       (WINAPI *_pfn_MapViewOfFile)(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, DWORD dwNumberOfBytesToMap);
typedef PVOID       (WINAPI *_pfn_MapViewOfFileEx)(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, DWORD dwNumberOfBytesToMap, LPVOID lpBaseAddress);
typedef BOOL        (WINAPI *_pfn_UnMapViewOfFile)(LPCVOID lpBaseAddress);
                    
typedef NTSTATUS    (WINAPI *_pfn_NtSetInformationFile)(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);
                    
typedef VOID        (WINAPI *_pfn_LZClose)(INT hFile);
typedef LONG        (WINAPI *_pfn_LZCopy)(INT hSource, INT hDest);
typedef void        (WINAPI *_pfn_LZDone)(void);
typedef INT         (WINAPI *_pfn_LZInit)(INT hfSource);
typedef INT         (WINAPI *_pfn_LZOpenFile)(LPSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle);
typedef INT         (WINAPI *_pfn_LZRead)(INT hFile, LPSTR lpBuffer, INT cbRead);
typedef LONG        (WINAPI *_pfn_LZSeek)(INT hFile, LONG lOffset, INT iOrigin);
typedef int         (WINAPI *_pfn_LZStart)(void);
typedef LONG        (WINAPI *_pfn_CopyLZFile)(int nUnknown1, int nUnknown2);
                    
typedef BOOL        (WINAPI *_pfn_DeleteFileA)( LPCSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_DeleteFileW)( LPCWSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_DeleteObject)(HGDIOBJ hObject);
                    
typedef BOOL        (WINAPI *_pfn_ExitWindowsEx)( UINT uFlags, DWORD dwReserved );
typedef UINT_PTR    (WINAPI *_pfn_SetTimer)(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc);
typedef BOOL        (WINAPI *_pfn_FreeLibrary)(HMODULE hLibModule);
                    
typedef HANDLE      (WINAPI *_pfn_FindFirstFileA)     (LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
typedef HANDLE      (WINAPI *_pfn_FindFirstFileW)     (LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
typedef HANDLE      (WINAPI *_pfn_FindFirstFileExA)   (LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags);
typedef HANDLE      (WINAPI *_pfn_FindFirstFileExW)   (LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags);
typedef BOOL        (WINAPI *_pfn_FindNextFileA)      (HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
typedef BOOL        (WINAPI *_pfn_FindNextFileW)      (HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
typedef BOOL        (WINAPI *_pfn_FindClose)          (HANDLE hFindFile);
                    
typedef LPSTR       (WINAPI *_pfn_GetCommandLineA)(VOID);
typedef LPWSTR      (WINAPI *_pfn_GetCommandLineW)(VOID);
typedef BOOL        (WINAPI *_pfn_ReadProcessMemory)(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesRead);
typedef BOOL        (WINAPI *_pfn_WriteProcessMemory)(HANDLE hProcess, LPVOID lpBaseAddress, LPVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesWritten);
typedef HMODULE     (WINAPI *_pfn_GetModuleHandleA)(LPCSTR lpModuleName);
typedef HMODULE     (WINAPI *_pfn_GetModuleHandleW)(LPCWSTR lpModuleName);
typedef DWORD       (WINAPI *_pfn_GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
typedef DWORD       (WINAPI *_pfn_GetModuleFileNameW)(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
typedef DWORD       (WINAPI *_pfn_GetModuleFileNameExA)(HANDLE hProcess, HMODULE hModule, LPSTR lpFilename, DWORD nSize);
typedef DWORD       (WINAPI *_pfn_GetModuleFileNameExW)(HANDLE hProcess, HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
                    
typedef HRESULT     (WINAPI *_pfn_DllGetClassObject)( REFCLSID rclsid, REFIID riid, PVOID * ppv );
typedef HRESULT     (WINAPI *_pfn_DirectDrawCreate)(GUID FAR *lpGUID, LPVOID *lplpDD, IUnknown* pUnkOuter ); 
typedef HRESULT     (WINAPI *_pfn_DirectDrawCreateEx)(GUID FAR *lpGUID, LPVOID *lplpDD, REFIID iid, IUnknown* pUnkOuter );
typedef HRESULT     (WINAPI *_pfn_DirectInputCreateA)(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTA *lplpDirectInput, LPUNKNOWN punkOuter);
typedef HRESULT     (WINAPI *_pfn_DirectInputCreateW)(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTW *lplpDirectInput, LPUNKNOWN punkOuter);
typedef HRESULT     (WINAPI *_pfn_DirectInputCreateEx)(HINSTANCE hinst, DWORD dwVersion, REFIID riidltf, LPVOID * ppvOut, LPUNKNOWN punkOuter);
typedef HRESULT     (WINAPI *_pfn_DirectSoundCreate)(LPCGUID lpcGuid, LPDIRECTSOUND *ppDS, LPUNKNOWN pUnkOuter);
typedef HRESULT     (WINAPI *_pfn_DirectPlayCreate)(LPGUID lpGUIDSP, LPDIRECTPLAY *lplpDP, IUnknown *lpUnk);
                    
typedef BOOL        (WINAPI *_pfn_GetDiskFreeSpaceA)(LPCSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters);
typedef BOOL        (WINAPI *_pfn_GetDiskFreeSpaceW)(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters);
typedef DWORD       (WINAPI *_pfn_GetFileAttributesA)(LPCSTR lpFileName);
typedef DWORD       (WINAPI *_pfn_GetFileAttributesW)(LPCWSTR wcsFileName);
typedef BOOL        (WINAPI *_pfn_GetFileAttributesExA)(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);
typedef BOOL        (WINAPI *_pfn_GetFileAttributesExW)(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);
typedef NTSTATUS    (WINAPI *_pfn_NtQueryAttributesFile)(POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation);
typedef NTSTATUS    (WINAPI *_pfn_NtQueryFullAttributesFile)(POBJECT_ATTRIBUTES ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION FileInformation);
typedef BOOL        (WINAPI *_pfn_GetFileInformationByHandle)(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION);
typedef DWORD       (WINAPI *_pfn_GetFileVersionInfoSizeA)( LPSTR lptstrFilename, LPDWORD lpdwHandle );
typedef DWORD       (WINAPI *_pfn_GetFileVersionInfoSizeW)( LPWSTR lptstrFilename, LPDWORD lpdwHandle );
typedef BOOL        (WINAPI *_pfn_GetFileVersionInfoA)( LPSTR lpstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
typedef BOOL        (WINAPI *_pfn_GetFileVersionInfoW)( LPWSTR lpstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
typedef BOOL        (WINAPI *_pfn_SetFileAttributesA)(LPCSTR lpFileName, DWORD dwFileAttributes);
typedef BOOL        (WINAPI *_pfn_SetFileAttributesW)(LPCWSTR lpFileName, DWORD dwFileAttributes);
                    
typedef DWORD       (WINAPI *_pfn_GetProfileStringA)(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize);
typedef DWORD       (WINAPI *_pfn_GetProfileStringW)(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize);
typedef BOOL        (WINAPI *_pfn_WriteProfileStringA)(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString);
typedef BOOL        (WINAPI *_pfn_WriteProfileStringW)(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString);
typedef BOOL        (WINAPI *_pfn_WriteProfileSectionA)(LPCSTR lpAppName, LPCSTR lpString);
typedef BOOL        (WINAPI *_pfn_WriteProfileSectionW)(LPCWSTR lpAppName, LPCWSTR lpString);
typedef UINT        (WINAPI *_pfn_GetProfileIntA)(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault);
typedef UINT        (WINAPI *_pfn_GetProfileIntW)(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault);
typedef UINT        (WINAPI *_pfn_GetPrivateProfileIntA)(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName);
typedef UINT        (WINAPI *_pfn_GetPrivateProfileIntW)(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName);
typedef DWORD       (WINAPI *_pfn_GetProfileSectionA)(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize);
typedef DWORD       (WINAPI *_pfn_GetProfileSectionW)(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize);
typedef DWORD       (WINAPI *_pfn_GetPrivateProfileSectionA)(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName);
typedef DWORD       (WINAPI *_pfn_GetPrivateProfileSectionW)(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
typedef DWORD       (WINAPI *_pfn_GetPrivateProfileSectionNamesA)(LPSTR lpszReturnBuffer, DWORD nSize, LPCSTR lpFileName);
typedef DWORD       (WINAPI *_pfn_GetPrivateProfileSectionNamesW)(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName);
typedef DWORD       (WINAPI *_pfn_GetPrivateProfileStringA)( LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR  lpReturnedString, DWORD  nSize, LPCSTR lpFileName);
typedef DWORD       (WINAPI *_pfn_GetPrivateProfileStringW)( LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR  lpReturnedString, DWORD  nSize, LPCWSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_GetPrivateProfileStructA)(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_GetPrivateProfileStructW)(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_WritePrivateProfileSectionA)(LPCSTR lpAppName, LPCSTR lpString, LPCSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_WritePrivateProfileSectionW)(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_WritePrivateProfileStringA)(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_WritePrivateProfileStringW)(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_WritePrivateProfileStructA)(LPCSTR lpAppName, LPCSTR lpKeyName, LPVOID lpStruct, UINT uSizeStruct, LPCSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_WritePrivateProfileStructW)(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR lpFileName);
                    
typedef FARPROC     (WINAPI *_pfn_GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
typedef VOID        (WINAPI *_pfn_GetProcessorSpeed)(VOID);
typedef HANDLE      (WINAPI *_pfn_GetStdHandle)(DWORD nStdHandle);
                    
typedef DWORD       (WINAPI *_pfn_GetEnvironmentVariableA)(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize);
typedef LPVOID      (WINAPI *_pfn_GetEnvironmentStrings)();
typedef LPVOID      (WINAPI *_pfn_GetEnvironmentStringsA)();
typedef LPVOID      (WINAPI *_pfn_GetEnvironmentStringsW)();
typedef BOOL        (WINAPI *_pfn_FreeEnvironmentStringsA)(LPSTR lpszEnvironmentBlock);
typedef BOOL        (WINAPI *_pfn_FreeEnvironmentStringsW)(LPWSTR lpszEnvironmentBlock);
typedef DWORD       (WINAPI *_pfn_ExpandEnvironmentStringsA)(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize);
typedef DWORD       (WINAPI *_pfn_ExpandEnvironmentStringsW)(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize);
                    
typedef HPALETTE    (WINAPI *_pfn_CreatePalette)(CONST LOGPALETTE *lplgpl);
typedef UINT        (WINAPI *_pfn_SetPaletteEntries)(HPALETTE hpal, UINT iStart, UINT cEntries, CONST PALETTEENTRY *lppe);
typedef BOOL        (WINAPI *_pfn_AnimatePalette)(HPALETTE hpal, UINT iStartIndex, UINT cEntries, CONST PALETTEENTRY *ppe);
typedef BOOL        (WINAPI *_pfn_ResizePalette)(HPALETTE hpal, UINT nEntries);
typedef HDC         (WINAPI *_pfn_GetDC)(HWND hWnd);
typedef HDC         (WINAPI *_pfn_GetWindowDC)(HWND hWnd);
typedef HPALETTE    (WINAPI *_pfn_SelectPalette)(HDC hdc, HPALETTE hpal, BOOL bForceBackground);
typedef UINT        (WINAPI *_pfn_RealizePalette)(HDC hdc);
typedef UINT        (WINAPI *_pfn_SetSystemPaletteUse)(HDC hdc, UINT uUsage);
                    
typedef UINT        (WINAPI *_pfn_GetSystemPaletteEntries)( HDC hdc, UINT iStartIndex, UINT nEntries, LPPALETTEENTRY lppe);
typedef DWORD       (WINAPI *_pfn_GetVersion)();
typedef BOOL        (WINAPI *_pfn_GetVersionExA)(LPOSVERSIONINFOA lpVersionInformation);
typedef BOOL        (WINAPI *_pfn_GetVersionExW)(LPOSVERSIONINFOW lpVersionInformation);
                    
typedef BOOL        (WINAPI *_pfn_InitializeSecurityDescriptor)( PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision);
typedef HRESULT     (WINAPI *_pfn_SafeArrayAccessData)(SAFEARRAY*, void HUGEP**);

typedef BOOL        (WINAPI *_pfn_GetVolumeInformationA)(LPCSTR, LPSTR, DWORD, LPDWORD, LPDWORD, LPDWORD, LPSTR, DWORD);
typedef BOOL        (WINAPI *_pfn_GetVolumeInformationW)(LPCWSTR, LPWSTR, DWORD, LPDWORD, LPDWORD, LPDWORD, LPWSTR, DWORD);
                    
typedef HINSTANCE   (WINAPI *_pfn_LoadLibraryA)(LPCSTR lpLibFileName);
typedef HINSTANCE   (WINAPI *_pfn_LoadLibraryW)(LPCWSTR lpLibFileName);
typedef HINSTANCE   (WINAPI *_pfn_LoadLibraryExA)(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
typedef HINSTANCE   (WINAPI *_pfn_LoadLibraryExW)(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
typedef DWORD       (WINAPI *_pfn_LoadModule)(LPCSTR lpModuleName, LPVOID lpParameterBlock);
typedef BOOL        (WINAPI *_pfn_LookupPrivilegeValueA)( LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid );
typedef BOOL        (WINAPI *_pfn_LookupPrivilegeValueW)( LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid );
                    
typedef int         (WINAPI *_pfn_MessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
typedef int         (WINAPI *_pfn_MessageBoxW)(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
typedef int         (WINAPI *_pfn_MessageBoxExA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType, WORD wLanguageId);
typedef int         (WINAPI *_pfn_MessageBoxExW)(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType, WORD wLanguageId);
typedef BOOL        (WINAPI *_pfn_SetMessageQueue)(int nUnknown);
                    
typedef VOID        (WINAPI *_pfn_OutputDebugStringA)(LPCSTR lpOutputString);
typedef VOID        (WINAPI *_pfn_OutputDebugStringW)(LPCWSTR lpOutputString);
typedef void        (WINAPI *_pfn_SetDebugErrorLevel)(DWORD dwLevel);
                    
typedef LONG        (WINAPI *_pfn_RegConnectRegistryA)(LPCSTR lpMachineName, HKEY hKey, PHKEY phkResult); 
typedef LONG        (WINAPI *_pfn_RegConnectRegistryW)(LPCWSTR lpMachineName, HKEY hKey, PHKEY phkResult); 
typedef LONG        (WINAPI *_pfn_RegCreateKeyA)(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult); 
typedef LONG        (WINAPI *_pfn_RegCreateKeyW)(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult); 
typedef LONG        (WINAPI *_pfn_RegCreateKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
typedef LONG        (WINAPI *_pfn_RegCreateKeyExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
typedef LONG        (WINAPI *_pfn_RegOpenKeyA)(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult); 
typedef LONG        (WINAPI *_pfn_RegOpenKeyW)(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult); 
typedef LONG        (WINAPI *_pfn_RegOpenKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult); 
typedef LONG        (WINAPI *_pfn_RegOpenKeyExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult); 
typedef LONG        (WINAPI *_pfn_RegOpenCurrentUser)(REGSAM samDesired, PHKEY phkResult);
typedef LONG        (WINAPI *_pfn_RegOpenUserClassesRoot)(HANDLE hToken, DWORD dwOptions, REGSAM samDesired, PHKEY phkResult);
typedef LONG        (WINAPI *_pfn_RegQueryValueA)(HKEY hkey, LPCSTR lpSubKey, LPSTR lpData, PLONG lpcbData);
typedef LONG        (WINAPI *_pfn_RegQueryValueW)(HKEY hkey, LPCWSTR lpSubKey, LPWSTR lpData, PLONG lpcbData);
typedef LONG        (WINAPI *_pfn_RegQueryValueExA)(HKEY hkey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
typedef LONG        (WINAPI *_pfn_RegQueryValueExW)(HKEY hkey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
typedef LONG        (WINAPI *_pfn_RegEnumValueA)(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
typedef LONG        (WINAPI *_pfn_RegEnumValueW)(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
typedef LONG        (WINAPI *_pfn_RegEnumKeyA)(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cbName);
typedef LONG        (WINAPI *_pfn_RegEnumKeyW)(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cbName);
typedef LONG        (WINAPI *_pfn_RegEnumKeyExA)(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcbName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcbClass, PFILETIME lpftLastWriteTime);
typedef LONG        (WINAPI *_pfn_RegEnumKeyExW)(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcbClass, PFILETIME lpftLastWriteTime);
typedef LONG        (WINAPI *_pfn_RegQueryInfoKeyA)(HKEY hKey, LPSTR lpClass, LPDWORD lpcbClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);
typedef LONG        (WINAPI *_pfn_RegQueryInfoKeyW)(HKEY hKey, LPWSTR lpClass, LPDWORD lpcbClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime); 
typedef LONG        (WINAPI *_pfn_RegCloseKey)(HKEY hkey);
typedef LONG        (WINAPI *_pfn_RegSetValueA)(HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData);
typedef LONG        (WINAPI *_pfn_RegSetValueW)(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData);
typedef LONG        (WINAPI *_pfn_RegSetValueExA)(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, DWORD dwType, CONST BYTE *lpData, DWORD cbData);
typedef LONG        (WINAPI *_pfn_RegSetValueExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, DWORD dwType, CONST BYTE * lpData, DWORD cbData);
typedef NTSTATUS    (WINAPI *_pfn_NtSetValueKey)(HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize);
typedef NTSTATUS    (WINAPI *_pfn_NtQueryValueKey)(HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);
typedef LONG        (WINAPI *_pfn_RegDeleteKeyA)(HKEY hKey,LPCSTR lpSubKey);
typedef LONG        (WINAPI *_pfn_RegDeleteKeyW)(HKEY hKey,LPCWSTR lpSubKey);
typedef LONG        (WINAPI *_pfn_RegDeleteValueA)(HKEY hKey, LPCSTR lpValueName);
typedef LONG        (WINAPI *_pfn_RegDeleteValueW)(HKEY hKey, LPCWSTR lpValueName);
                    
typedef SC_HANDLE   (WINAPI *_pfn_CreateServiceA)(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPCSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword);
typedef SC_HANDLE   (WINAPI *_pfn_CreateServiceW)(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPCWSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword);
typedef SC_HANDLE   (WINAPI *_pfn_OpenServiceA)(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess);
typedef SC_HANDLE   (WINAPI *_pfn_OpenServiceW)(SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess);
typedef BOOL        (WINAPI *_pfn_QueryServiceStatus)(SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus);
typedef BOOL        (WINAPI *_pfn_QueryServiceConfigA)(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGA lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded);
typedef BOOL        (WINAPI *_pfn_ChangeServiceConfigA)(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword, LPCSTR lpDisplayName);
typedef BOOL        (WINAPI *_pfn_CloseServiceHandle)(SC_HANDLE hSCObject);
                    
typedef int         (WINAPI *_pfn_ReleaseDC)(HWND hWnd, HDC hdc);
                    
typedef DWORD       (WINAPI *_pfn_GetEnvironmentVariableA)(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize);
typedef DWORD       (WINAPI *_pfn_GetEnvironmentVariableW)(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
                    
typedef BOOL        (WINAPI *_pfn_RemoveDirectoryA)(LPCSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_RemoveDirectoryW)(LPCWSTR lpFileName);
                    
typedef LPVOID      (WINAPI *_pfn_VirtualAlloc)(LPVOID lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect);
typedef BOOL        (WINAPI *_pfn_VirtualFree)(LPVOID lpAddress, DWORD dwSize, DWORD dwFreeType);
typedef BOOL        (WINAPI *_pfn_VirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
                    
typedef DWORD       (WINAPI *_pfn_CreateIpForwardEntry)(PMIB_IPFORWARDROW pRoute);
typedef DWORD       (WINAPI *_pfn_GetIpForwardTable)(PMIB_IPFORWARDTABLE pIpForwardTable, PULONG pdwSize, BOOL bOrder);
                    
typedef PVOID       (WINAPI *_pfn_RtlAllocateHeap)(PVOID HeapHandle, ULONG Flags, SIZE_T Size);
typedef BOOLEAN     (WINAPI *_pfn_RtlFreeHeap)(HANDLE HeapHandle, DWORD Flags, LPVOID lpMem);
typedef DWORD       (WINAPI *_pfn_RtlSizeHeap)(HANDLE HeapHandle, DWORD Flags, LPCVOID lpMem);
typedef PVOID       (WINAPI *_pfn_RtlReAllocateHeap)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, DWORD dwBytes);
typedef HANDLE      (WINAPI *_pfn_HeapCreate)(DWORD flOptions, DWORD dwInitialSize, DWORD dwMaximumSize);
typedef BOOL        (WINAPI *_pfn_HeapDestroy)(HANDLE hHeap);
typedef UINT        (WINAPI *_pfn_HeapCompact)(HANDLE hHeap, DWORD dwFlags);
typedef HGLOBAL     (WINAPI *_pfn_GlobalAlloc)(UINT uFlags, SIZE_T uBytes);
typedef HLOCAL      (WINAPI *_pfn_LocalAlloc)(UINT uFlags, SIZE_T uBytes);
typedef UINT        (WINAPI *_pfn_LocalCompact)(UINT uUnknown);
typedef HLOCAL      (WINAPI *_pfn_LocalDiscard)(HLOCAL hlocMem);
typedef HLOCAL      (WINAPI *_pfn_LocalReAlloc)(HLOCAL,SIZE_T,UINT);
typedef UINT        (WINAPI *_pfn_LocalShrink)(HLOCAL hMem, UINT uUnknown);
typedef HGLOBAL     (WINAPI *_pfn_GlobalReAlloc)(HGLOBAL,SIZE_T,UINT);
typedef DWORD       (WINAPI *_pfn_GlobalCompact)(DWORD);
typedef void        (WINAPI *_pfn_GlobalFix)(HGLOBAL hMem);
typedef UINT        (WINAPI *_pfn_GlobalFlags)(HGLOBAL hMem);
typedef HGLOBAL     (WINAPI *_pfn_GlobalFree)(HGLOBAL hMem);
typedef void        (WINAPI *_pfn_GlobalUnfix)(HGLOBAL hMem);
typedef BOOL        (WINAPI *_pfn_GlobalUnWire)(HGLOBAL hMem);
typedef char FAR*   (WINAPI *_pfn_GlobalWire)(HGLOBAL hMem);
                    
typedef HLOCAL      (WINAPI *_pfn_LocalFree)(HLOCAL hMem);
typedef LPVOID      (WINAPI *_pfn_VirtualAlloc)(LPVOID, DWORD ,DWORD, DWORD);
typedef BOOL        (WINAPI *_pfn_VirtualFree)(LPVOID, DWORD, DWORD);
                    
typedef BOOL        (WINAPI *_pfn_HeapValidate)(HANDLE, DWORD, LPCVOID);
typedef BOOL        (WINAPI *_pfn_HeapWalk)(HANDLE, LPPROCESS_HEAP_ENTRY);
typedef BOOL        (WINAPI *_pfn_HeapLock)(HANDLE);
typedef BOOL        (WINAPI *_pfn_HeapUnlock)(HANDLE);
typedef LPVOID      (WINAPI *_pfn_LocalLock)(HLOCAL);
typedef BOOL        (WINAPI *_pfn_LocalUnlock)(HLOCAL);
typedef HANDLE      (WINAPI *_pfn_LocalHandle)(LPCVOID);
typedef UINT        (WINAPI *_pfn_LocalSize)(HLOCAL);
typedef UINT        (WINAPI *_pfn_LocalFlags)(HLOCAL);
typedef HGLOBAL     (WINAPI *_pfn_GlobalFree)(HGLOBAL hMem);
typedef LPVOID      (WINAPI *_pfn_GlobalLock)(HGLOBAL);
typedef BOOL        (WINAPI *_pfn_GlobalUnlock)(HGLOBAL);
typedef HANDLE      (WINAPI *_pfn_GlobalHandle)(LPCVOID);
typedef UINT        (WINAPI *_pfn_GlobalSize)(HGLOBAL);
typedef UINT        (WINAPI *_pfn_GlobalFlags)(HGLOBAL);
typedef VOID        (__cdecl *_pfn_free)(VOID* pMem);
typedef COLORREF    (WINAPI *_pfn_SetBkColor)(HDC hdc, COLORREF crColor);
typedef LONG        (WINAPI *_pfn_SetClassLongA)(HWND hWnd, int nIndex, LONG dwnewLong);
typedef WORD        (WINAPI *_pfn_SetClassWord)(HWND hWnd, int nIndex, WORD wNewWord);
typedef COLORREF    (WINAPI *_pfn_SetTextColor)(HDC hdc, COLORREF crColor);
typedef LONG        (WINAPI *_pfn_SetWindowLongA)(HWND hWnd, int nIndex, LONG dwnewLong);
typedef LONG        (WINAPI *_pfn_SetWindowLongW)(HWND hWnd, int nIndex, LONG dwnewLong);
typedef BOOL        (WINAPI *_pfn_MoveWindow)(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint);
typedef BOOL        (WINAPI *_pfn_SetWindowPos)( HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags );
                    
typedef HINSTANCE   (WINAPI *_pfn_ShellExecuteA)(HWND hwnd, LPCSTR lpVerb, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);
typedef HINSTANCE   (WINAPI *_pfn_ShellExecuteW)(HWND hwnd, LPCWSTR lpVerb, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);
typedef BOOL        (WINAPI *_pfn_ShellExecuteExA)(LPSHELLEXECUTEINFOA lpExecInfo);
typedef BOOL        (WINAPI *_pfn_ShellExecuteExW)(LPSHELLEXECUTEINFOW lpExecInfo);
                    
typedef BOOL        (WINAPI *_pfn_SHGetPathFromIDListA)(LPCITEMIDLIST pidl, LPSTR pszPath);
typedef BOOL        (WINAPI *_pfn_SHGetPathFromIDListW)(LPCITEMIDLIST pidl, LPWSTR pszPath);
typedef int         (WINAPI *_pfn_SHFileOperationA)(LPSHFILEOPSTRUCTA lpFileOp);
typedef int         (WINAPI *_pfn_SHFileOperationW)(LPSHFILEOPSTRUCTW lpFileOp);
typedef HRESULT     (WINAPI *_pfn_SHGetSpecialFolderLocation)( HWND hwndOwner, int nFolder, LPITEMIDLIST *ppidl );
typedef HRESULT     (WINAPI *_pfn_SHGetFolderLocation)( HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwReserved,  LPITEMIDLIST *ppidl );
typedef HRESULT     (WINAPI *_pfn_SHGetFolderPathA)( HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwFlags, LPSTR pszPath );
typedef HRESULT     (WINAPI *_pfn_SHGetFolderPathW)( HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath );
typedef BOOL        (WINAPI *_pfn_SHGetSpecialFolderPathA)( HWND hwndOwner, LPSTR lpszPath, int nFolder, BOOL fCreate );
typedef BOOL        (WINAPI *_pfn_SHGetSpecialFolderPathW)( HWND hwndOwner, LPWSTR lpszPath, int nFolder, BOOL fCreate );
typedef HRESULT     (WINAPI *_pfn_SHGetFileInfoA)(LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA *psfi, UINT cbFileInfo, UINT uFlags);
typedef BOOL        (WINAPI *_pfn_SetForegroundWindow)(HWND hWnd);
typedef BOOL        (WINAPI *_pfn_ShowWindow)( HWND hWnd, INT nCmdShow );
                    
typedef BOOL        (WINAPI *_pfn_VerQueryValueA)( const LPVOID pBlock, LPSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen);
typedef BOOL        (WINAPI *_pfn_VerQueryValueW)( const LPVOID pBlock, LPWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen);
                    
typedef int         (WINAPI *_pfn_vsnprintf)(char *buffer, size_t count, const char *format, va_list argptr);
                    
typedef MCIERROR    (WINAPI *_pfn_mciSendCommandA)(MCIDEVICEID IDDevice, UINT uMsg, DWORD fdwCommand, DWORD dwParam);
typedef MCIERROR    (WINAPI *_pfn_mciSendStringA)(LPCSTR lpszCommand, LPSTR lpszReturnString, UINT cchReturn, HANDLE hwndCallback);
typedef MMRESULT    (WINAPI *_pfn_waveOutOpen)(LPHWAVEOUT phwo, UINT uDeviceID, LPWAVEFORMATEX pwfx, DWORD dwCallback, DWORD dwCallbackInstance, DWORD fdwOpen);
typedef MMRESULT    (WINAPI *_pfn_waveOutClose)(HWAVEOUT hwo);
typedef MMRESULT    (WINAPI *_pfn_waveOutReset)(HWAVEOUT hwo);
typedef MMRESULT    (WINAPI *_pfn_waveOutPause)(HWAVEOUT hwo);
typedef MMRESULT    (WINAPI *_pfn_waveOutUnprepareHeader)(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
                    
typedef MMRESULT    (WINAPI *_pfn_waveOutGetDevCapsA)(UINT uDeviceID, LPWAVEOUTCAPSA pwoc, UINT cbwoc);
typedef MMRESULT    (WINAPI *_pfn_waveOutGetDevCapsW)(UINT uDeviceID, LPWAVEOUTCAPSW pwoc, UINT cbwoc);
typedef MMRESULT    (WINAPI *_pfn_wod32Message)(UINT uDeviceID, UINT uMessage, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2);

typedef MMRESULT    (*_pfn_midiOutGetDevCapsA)(UINT_PTR uDeviceID, LPMIDIOUTCAPSA pmoc, UINT cbmoc);
typedef MMRESULT    (*_pfn_midiOutOpen)(LPHMIDIOUT phmo, UINT uDeviceID, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen);

typedef UINT        (WINAPI *_pfn_WinExec)(LPCSTR lpCmdLine, UINT uCmdShow);
typedef BOOL        (WINAPI *_pfn_IsBadHugeReadPtr)(const void _huge* lp, DWORD cb);
typedef BOOL        (WINAPI *_pfn_IsBadHugeWritePtr)(const void _huge* lp, DWORD cb);
                    
typedef BOOL        (WINAPI *_pfn_SetTimeZoneInformation)(CONST TIME_ZONE_INFORMATION *lpTimeZoneInformation);
                    
typedef HRESULT     (*_pfn_IXMLDOMDocument_load)(PVOID pThis, VARIANT xmlSource, VARIANT_BOOL *isSuccessful);
                    
typedef ULONG       (*_pfn_AddRef)( PVOID pThis );
typedef ULONG       (*_pfn_Release)( PVOID pThis );
typedef HRESULT     (*_pfn_QueryInterface)( PVOID pThis, REFIID iid, PVOID* ppvObject );
typedef HRESULT     (*_pfn_CreateInstance)( PVOID pThis, IUnknown * pUnkOuter, REFIID riid, void ** ppvObject );
typedef HRESULT     (*_pfn_IPersistFile_Save)(PVOID pThis, LPCOLESTR pszFileName,  BOOL fRemember);
typedef HRESULT     (*_pfn_IShellLinkA_SetPath)( PVOID pThis, LPCSTR pszFile );
typedef HRESULT     (*_pfn_IShellLinkW_SetPath)( PVOID pThis, LPCWSTR pszFile );
typedef HRESULT     (*_pfn_IShellLinkA_SetWorkingDirectory)( PVOID pThis, LPCSTR pszDir );
typedef HRESULT     (*_pfn_IShellLinkW_SetWorkingDirectory)( PVOID pThis, LPCWSTR pszDir );
typedef HRESULT     (*_pfn_IShellLinkA_GetWorkingDirectory)( PVOID pThis, LPCSTR pszDir, int cchMaxPath );
typedef HRESULT     (*_pfn_IShellLinkW_GetWorkingDirectory)( PVOID pThis, LPCWSTR pszDir, int cchMaxPath );
typedef HRESULT     (*_pfn_IShellLinkA_SetArguments)( PVOID pThis, LPCSTR pszFile );
typedef HRESULT     (*_pfn_IShellLinkW_SetArguments)( PVOID pThis, LPCWSTR pszFile );
typedef HRESULT     (*_pfn_IShellLinkA_SetIconLocation)( PVOID pThis, LPCSTR pszIconLocation, int nIcon );
typedef HRESULT     (*_pfn_IShellLinkW_SetIconLocation)( PVOID pThis, LPCWSTR pszIconLocation, int nIcon );
typedef HRESULT     (*_pfn_IShellLinkA_Resolve)( PVOID pThis, HWND hwnd, DWORD fFlags );
typedef HRESULT     (*_pfn_IShellLinkW_Resolve)( PVOID pThis, HWND hwnd, DWORD fFlags );
typedef HRESULT     (*_pfn_IDirectDraw_CreateSurface)(PVOID pThis, LPDDSURFACEDESC lpDDSurfaceDesc, LPDIRECTDRAWSURFACE* lplpDDSurface, IUnknown* pUnkOuter);
typedef HRESULT     (*_pfn_IDirectDraw2_CreateSurface)(PVOID pThis, LPDDSURFACEDESC lpDDSurfaceDesc, LPDIRECTDRAWSURFACE* lplpDDSurface, IUnknown* pUnkOuter);
typedef HRESULT     (*_pfn_IDirectDraw4_CreateSurface)(PVOID pThis, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPDIRECTDRAWSURFACE* lplpDDSurface, IUnknown* pUnkOuter);
typedef HRESULT     (*_pfn_IDirectDraw7_CreateSurface)(PVOID pThis, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPDIRECTDRAWSURFACE* lplpDDSurface, IUnknown* pUnkOuter);
typedef HRESULT     (*_pfn_IDirectDraw7_GetDeviceIdentifier)(PVOID pThis, LPDDDEVICEIDENTIFIER2 lpDeviceIdentifier, DWORD dwFlags);
typedef HRESULT     (*_pfn_IDirectDraw_SetCooperativeLevel)(PVOID pThis, HWND hWnd,DWORD dwFlags);
typedef HRESULT     (*_pfn_IDirectDraw2_SetCooperativeLevel)(PVOID pThis, HWND hWnd,DWORD dwFlags);
typedef HRESULT     (*_pfn_IDirectDraw4_SetCooperativeLevel)(PVOID pThis, HWND hWnd,DWORD dwFlags);
typedef HRESULT     (*_pfn_IDirectDraw7_SetCooperativeLevel)(PVOID pThis, HWND hWnd,DWORD dwFlags);
typedef HRESULT     (*_pfn_IDirectDraw_SetDisplayMode)(PVOID pThis, DWORD dwWidth, DWORD dwHeight, DWORD dwBPP);
typedef HRESULT     (*_pfn_IDirectDraw2_SetDisplayMode)(PVOID pThis, DWORD dwWidth, DWORD dwHeight, DWORD dwBPP, DWORD dwRefreshRate, DWORD dwFlags);
typedef HRESULT     (*_pfn_IDirectDraw4_SetDisplayMode)(PVOID pThis, DWORD dwWidth, DWORD dwHeight, DWORD dwBPP, DWORD dwRefreshRate, DWORD dwFlags);
typedef HRESULT     (*_pfn_IDirectDraw7_SetDisplayMode)(PVOID pThis, DWORD dwWidth, DWORD dwHeight, DWORD dwBPP, DWORD dwRefreshRate, DWORD dwFlags);
typedef HRESULT     (*_pfn_IDirectDrawSurface_GetDC)(LPDIRECTDRAWSURFACE lpDDSurface, HDC FAR *lphDC);
typedef HRESULT     (*_pfn_IDirectDrawSurface2_GetDC)(LPDIRECTDRAWSURFACE lpDDSurface, HDC FAR *lphDC);
typedef HRESULT     (*_pfn_IDirectDrawSurface4_GetDC)(LPDIRECTDRAWSURFACE lpDDSurface, HDC FAR *lphDC);
typedef HRESULT     (*_pfn_IDirectDrawSurface7_GetDC)(LPDIRECTDRAWSURFACE lpDDSurface, HDC FAR *lphDC);
typedef HRESULT     (*_pfn_IDirectDrawSurface_ReleaseDC)(LPDIRECTDRAWSURFACE lpDDSurface, HDC hDC);
typedef HRESULT     (*_pfn_IDirectDrawSurface2_ReleaseDC)(LPDIRECTDRAWSURFACE lpDDSurface, HDC hDC);
typedef HRESULT     (*_pfn_IDirectDrawSurface4_ReleaseDC)(LPDIRECTDRAWSURFACE lpDDSurface, HDC hDC);
typedef HRESULT     (*_pfn_IDirectDrawSurface7_ReleaseDC)(LPDIRECTDRAWSURFACE lpDDSurface, HDC hDC);
typedef HRESULT     (*_pfn_IDirectDrawSurface_Lock)(LPDIRECTDRAWSURFACE lpDDSurface, LPRECT lpDestRect, LPDDSURFACEDESC lpDDSurfaceDesc, DWORD dwFlags, HANDLE hEvent);
typedef HRESULT     (*_pfn_IDirectDrawSurface2_Lock)(LPDIRECTDRAWSURFACE lpDDSurface, LPRECT lpDestRect, LPDDSURFACEDESC lpDDSurfaceDesc, DWORD dwFlags, HANDLE hEvent);
typedef HRESULT     (*_pfn_IDirectDrawSurface4_Lock)(LPDIRECTDRAWSURFACE lpDDSurface, LPRECT lpDestRect, LPDDSURFACEDESC lpDDSurfaceDesc, DWORD dwFlags, HANDLE hEvent);
typedef HRESULT     (*_pfn_IDirectDrawSurface_Unlock)(LPDIRECTDRAWSURFACE lpDDSurface, LPVOID lpSurfaceData);
typedef HRESULT     (*_pfn_IDirectDrawSurface_Restore)(LPDIRECTDRAWSURFACE lpDDSurface);
typedef HRESULT     (*_pfn_IDirectDrawSurface_Blt)(LPDIRECTDRAWSURFACE lpDDDestSurface, LPRECT lpDestRect, LPDIRECTDRAWSURFACE lpDDSrcSurface, LPRECT lpSrcRect, DWORD dwFlags, LPDDBLTFX lpDDBltFX);
typedef HRESULT     (*_pfn_IDirectDrawSurface2_Blt)(LPDIRECTDRAWSURFACE lpDDDestSurface, LPRECT lpDestRect, LPDIRECTDRAWSURFACE lpDDSrcSurface, LPRECT lpSrcRect, DWORD dwFlags, LPDDBLTFX lpDDBltFX);
typedef HRESULT     (*_pfn_IDirectDrawSurface4_Blt)(LPDIRECTDRAWSURFACE lpDDDestSurface, LPRECT lpDestRect, LPDIRECTDRAWSURFACE lpDDSrcSurface, LPRECT lpSrcRect, DWORD dwFlags, LPDDBLTFX lpDDBltFX);
typedef HRESULT     (*_pfn_IDirectDrawSurface_Flip)(LPDIRECTDRAWSURFACE lpDDSurface, LPDIRECTDRAWSURFACE lpDDSurfaceDest, DWORD dwFlags);
typedef HRESULT     (*_pfn_IDirectDrawSurface_Release)(PVOID pThis);
typedef HRESULT     (*_pfn_IDirectDrawSurface_SetPalette)(PVOID pThis, LPDIRECTDRAWPALETTE lpDDPalette);
typedef HRESULT     (*_pfn_IDirectDrawGammaControl_SetGammaRamp)(PVOID pThis, DWORD  dwFlags, LPDDGAMMARAMP lpRampData);
typedef HRESULT     (*_pfn_IDirectPlay3A_EnumConnections)(PVOID pThis, LPCGUID lpguidApplication, LPDPENUMCONNECTIONSCALLBACK lpEnumCallback, LPVOID lpContext, DWORD dwFlags);
typedef HRESULT     (*_pfn_IDirectPlay4A_EnumConnections)(PVOID pThis, LPCGUID lpguidApplication, LPDPENUMCONNECTIONSCALLBACK lpEnumCallback, LPVOID lpContext, DWORD dwFlags);
typedef HRESULT     (*_pfn_IShellFolder_GetDisplayNameOf)( PVOID pThis, LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName );
typedef HRESULT     (*_pfn_SHGetDesktopFolder)(IShellFolder **ppshf);

typedef HRESULT     (*_pfn_IDirectInput_CreateDevice)(PVOID pThis, REFGUID rguid, LPDIRECTINPUTDEVICE *lplpDirectInputDevice, LPUNKNOWN pUnkOuter);
typedef HRESULT     (*_pfn_IDirectInputDevice_Acquire)(PVOID pThis);
typedef HRESULT     (*_pfn_IDirectInputDevice_GetDeviceData)(PVOID pThis, DWORD cbObjectData, LPDIDEVICEOBJECTDATA rgdod, LPDWORD pdwInOut, DWORD dwFlags);
                    
typedef HRESULT     (*_pfn_IDirectSound_Release)(PVOID pThis);
                    
typedef LONG        (*_pfn_ChangeDisplaySettingsA)(LPDEVMODEA lpDevMode, DWORD dwflags);
typedef LONG        (*_pfn_ChangeDisplaySettingsW)(LPDEVMODEW lpDevMode, DWORD dwflags);
typedef LONG        (*_pfn_ChangeDisplaySettingsExA)(LPCSTR lpszDeviceName, LPDEVMODEA lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam);
typedef LONG        (*_pfn_ChangeDisplaySettingsExW)(LPCWSTR lpszDeviceName, LPDEVMODEW lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam);
typedef BOOL        (*_pfn_EnumDisplaySettingsA)(LPCSTR lpszDeviceName, DWORD iModeNum, LPDEVMODEA lpDevMode);
typedef BOOL        (*_pfn_EnumDisplaySettingsW)(LPCWSTR lpszDeviceName, DWORD iModeNum, LPDEVMODEW lpDevMode); 
typedef HBITMAP     (*_pfn_CreateDIBSection)(HDC hdc, CONST BITMAPINFO *pbmi, UINT iUsage, VOID *ppvBits, HANDLE hSection, DWORD dwOffset);
typedef HFONT       (*_pfn_CreateFontIndirectA)(CONST LOGFONTA *lplf);
typedef HFONT       (*_pfn_CreateFontIndirectW)(CONST LOGFONTW *lplf);
typedef BOOL        (*_pfn_Ellipse)(HDC hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect);
typedef BOOL        (*_pfn_Rectangle)(HDC hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect);
typedef UINT        (*_pfn_SetDIBColorTable)(HDC hdc, UINT uStartIndex, UINT cEntries, CONST RGBQUAD *pColors);
typedef int         (*_pfn_SetStretchBltMode)(HDC hdc, int iStretchMode);
typedef BOOL        (*_pfn_StretchBlt)(HDC hdcDest, int nXOriginDest, int nYOriginDest, int nWidthDest, int nHeightDest, HDC hdcSrc, int nXOriginSrc, int nYOriginSrc, int nWidthSrc, int nHeightSrc, DWORD dwRop);
typedef int         (*_pfn_StretchDIBits)(HDC hdc, int XDest, int YDest, int nDestWidth, int nDestHeight, int XSrc, int YSrc, int nSrcWidth, int nSrcHeight, CONST VOID *lpBits, CONST BITMAPINFO *lpBitsInfo, UINT iUsage, DWORD dwRop);
                    
typedef HGDIOBJ     (*_pfn_GetCurrentObject)(HDC hdc, UINT uObjectType);
typedef COLORREF    (*_pfn_GetPixel)(HDC hdc, int XPos, int nYPos);
typedef COLORREF    (*_pfn_SetPixel)(HDC hdc, int XPos, int nYPos, COLORREF crColor);
typedef BOOL        (*_pfn_GetTextExtentPointA)(HDC hdc, LPCSTR lpString, int cbString, LPSIZE lpSize);
typedef BOOL        (*_pfn_GetTextExtentPointW)(HDC hdc, LPCWSTR lpString, int cbString, LPSIZE lpSize);
typedef BOOL        (*_pfn_GetTextExtentPoint32A)(HDC hdc, LPCSTR lpString, int cbString, LPSIZE lpSize);
typedef int         (*_pfn_GetTextFaceA)(HDC hdc, int nCount, LPSTR lpFaceName);
typedef BOOL        (*_pfn_GetTextMetricsA)(HDC hdc, LPTEXTMETRICA lptm);
typedef BOOL        (*_pfn_LineTo)(HDC hdc, int nXEnd, int nYEnd);
typedef BOOL        (*_pfn_MoveToEx)(HDC hdc, int X, int Y, LPPOINT lpPoint);
typedef BOOL        (*_pfn_TextOutA)(HDC hdc, int nXStart, int nYStart, LPCSTR lpString, int cbString);
                    
typedef VOID        (*_pfn_GetStartupInfoA)(LPSTARTUPINFOA lpStartupInfo);
typedef VOID        (*_pfn_GetStartupInfoW)(LPSTARTUPINFOW lpStartupInfo);
                    
typedef DWORD       (*_pfn_SetFilePointer)(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
typedef DWORD       (*_pfn_ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
typedef DWORD       (*_pfn_WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
typedef NTSTATUS    (WINAPI *_pfn_NtWriteFile)(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);
typedef NTSTATUS    (WINAPI *_pfn_NtWriteFileGather)(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);
                    
typedef HANDLE      (*_pfn_CreateMutexA)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
typedef HANDLE      (*_pfn_CreateMutexW)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName);
typedef BOOL        (*_pfn_ReleaseMutex)(HANDLE hMutex);
typedef DWORD       (*_pfn_WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
                    
typedef VOID        (*_pfn_Sleep)(DWORD dwMilliseconds);
typedef DWORD       (*_pfn_SleepEx)(DWORD dwMilliseconds, BOOL bAlertable);
typedef HRESULT     (*_pfn_CoCreateInstance)(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID *ppv);
typedef HRESULT     (*_pfn_CoCreateInstanceEx)(REFCLSID rclsid, IUnknown *punkOuter, DWORD dwClsCtx, COSERVERINFO *pServerInfo, ULONG cmq, MULTI_QI *pResults );
typedef HRESULT     (*_pfn_ShCoCreateInstance)(LPCTSTR pszCLSID, const CLSID * pclsid, IUnknown *punkOuter, REFIID riid, void **ppv);
typedef HRESULT     (*_pfn_CoQueryProxyBlanket)(IUnknown * pProxy,DWORD * pAuthnSvc,DWORD * pAuthzSvc,OLECHAR ** pServerPrincName,DWORD * pAuthnLevel,DWORD * pImpLevel,RPC_AUTH_IDENTITY_HANDLE * ppAuthInfo,DWORD * pCapabilities);
typedef HRESULT     (*_pfn_CoSetProxyBlanket)(IUnknown * pProxy,DWORD dwAuthnSvc,DWORD dwAuthzSvc,WCHAR * pServerPrincName,DWORD dwAuthnLevel,DWORD dwImpLevel,RPC_AUTH_IDENTITY_HANDLE   pAuthInfo,DWORD dwCapabilities);
                    
                    
typedef BOOL        (*_pfn_AppendMenuA)(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPSTR lpNewItem);
typedef BOOL        (*_pfn_AppendMenuW)(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPWSTR lpNewItem);
                    
typedef BOOL        (*_pfn_ResumeThread)(HANDLE hThread);
                    
typedef DWORD       (*_pfn_NetUserAdd)(LPCWSTR servername, DWORD level, LPBYTE buf, LPDWORD parm_err);
typedef LONG        (*_pfn_LsaStorePrivateData)(PVOID PolicyHandle, PVOID KeyName, PVOID PrivateData);
                    
typedef void        (*_pfn_exit)(int status);
                    
typedef BOOL        (*_pfn_EnumPrintersA)(DWORD Flags, LPSTR Name, DWORD Level, LPBYTE pPrinterEnum, DWORD cbBuf, LPDWORD pcbNeeded, LPDWORD pcReturned);
typedef BOOL        (*_pfn_EnumPrintersW)(DWORD Flags, LPWSTR Name, DWORD Level, LPBYTE pPrinterEnum, DWORD cbBuf, LPDWORD pcbNeeded, LPDWORD pcReturned);
typedef DWORD       (*_pfn_PrinterMessageBoxA)(HANDLE hPrinter, DWORD Error, HWND hWnd, LPSTR pText, LPSTR pCaption, DWORD dwType);
typedef DWORD       (*_pfn_PrinterMessageBoxW)(HANDLE hPrinter, DWORD Error, HWND hWnd, LPWSTR pText, LPWSTR pCaption, DWORD dwType);
typedef DWORD       (*_pfn_WaitForPrinterChange)(HANDLE hPrinter, DWORD Flags);
                    
typedef int         (*_pfn_OpenIndex)(HANDLE hsrch, LPCSTR pszIndexFile, PBYTE pbSourceName, PUINT pcbSourceNameLimit, PUINT pTime1, PUINT pTime2);
typedef BOOL        (*_pfn_GetMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
typedef BOOL        (*_pfn_GetMessageW)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
typedef BOOL        (*_pfn_PeekMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
typedef BOOL        (*_pfn_PeekMessageW)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
typedef LRESULT     (*_pfn_SendMessageA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
typedef LRESULT     (*_pfn_SendMessageW)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
typedef LONG        (*_pfn_DispatchMessageA)(LPMSG lpmsg);
typedef LONG        (*_pfn_DispatchMessageW)(LPMSG lpmsg);
typedef BOOL        (*_pfn_Module32First)(HANDLE SnapSection, PVOID lpme);
typedef BOOL        (*_pfn_GetSaveFileNameA)(LPOPENFILENAMEA lpofn);
typedef BOOL        (*_pfn_GetSaveFileNameW)(LPOPENFILENAMEW lpofn);
typedef BOOL        (*_pfn_GetOpenFileNameA)(LPOPENFILENAMEA lpofn);
typedef BOOL        (*_pfn_GetOpenFileNameW)(LPOPENFILENAMEW lpofn);
typedef UINT        (*_pfn_GetTempFileNameA)(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName);
typedef UINT        (*_pfn_GetTempFileNameW)(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);
typedef LRESULT     (*_pfn_CallWindowProcA)(WNDPROC pfn, HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
typedef BOOL        (*_pfn_ControlService)(SC_HANDLE hService, DWORD dwControl, PVOID lpServiceStatus);
typedef UINT        (*_pfn_GetEnhMetaFileHeader)(HENHMETAFILE hemf, UINT nSize, LPENHMETAHEADER lpEnhMetaHeader);
typedef HMETAFILE   (*_pfn_GetMetaFileA)(LPCSTR lpszString);
typedef HMETAFILE   (*_pfn_GetMetaFileW)(LPCWSTR lpszString);
typedef UINT        (*_pfn_GetMetaFileBitsEx)(HMETAFILE hmf, UINT nSize, LPVOID lpvData);
typedef BOOL        (*_pfn_PlayMetaFile)(HDC hdc, HMETAFILE hmf);
typedef BOOL        (*_pfn_PlayMetaFileRecord)(HDC hdc, LPHANDLETABLE lpHandletable, LPMETARECORD lpMetaRecord, UINT nHandles);
typedef HMETAFILE   (*_pfn_CopyMetaFileA)(HMETAFILE hmfSrc, LPCSTR lpszFile);
typedef HMETAFILE   (*_pfn_CopyMetaFileW)(HMETAFILE hmfSrc, LPCWSTR lpszFile);
typedef HMETAFILE   (*_pfn_SetMetaFileBitsEx)(UINT nSize, CONST BYTE *lpData);
typedef BOOL        (*_pfn_PostMessageW)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
typedef BOOL        (*_pfn_PostMessageA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
typedef DWORD       (*_pfn_timeGetTime)(VOID);  
typedef int         (*_pfn_GetDeviceCaps)(HDC hdc, int nIndex);
typedef int         (*_pfn_GetSystemMetrics)(int nIndex);
typedef DWORD       (*_pfn_GetSysColor)(int nIndex);
typedef int         (*_pfn_ToAscii)(UINT uVirtKey, UINT uScanCode, PBYTE lpKeyState, LPWORD lpChar, UINT uFlags);
typedef int         (*_pfn_ToAsciiEx)(UINT uVirtKey, UINT uScanCode, PBYTE lpKeyState, LPWORD lpChar, UINT uFlags, HKL dwhkl);
typedef SHORT       (*_pfn_GetAsyncKeyState)(int vKey);
typedef BOOL        (*_pfn_CloseProfileUserMapping)();
typedef BOOL        (*_pfn_BackupSeek)(HANDLE  hFile, DWORD dwLowBytesToSeek, DWORD dwHighBytesToSeek, LPDWORD lpdwLowBytesSeeked, LPDWORD lpdwHighBytesSeeked, LPVOID *lpContext);
typedef HANDLE      (*_pfn_CreateEventA)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
typedef HANDLE      (*_pfn_CreateEventW)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
typedef BOOL        (*_pfn_SetEvent)(HANDLE hEvent);
typedef BOOL        (*_pfn_ResetEvent)(HANDLE hEvent);
typedef DWORD       (*_pfn_SearchPathA)(LPCSTR lpPath, LPCSTR lpFileName, LPCSTR lpExtension, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart);
typedef DWORD       (*_pfn_SearchPathW)(LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
typedef DWORD       (*_pfn_GetWindowsDirectoryA)(LPSTR lpPath,DWORD Size);
typedef DWORD       (*_pfn_GetWindowsDirectoryW)(LPWSTR lpPath,DWORD Size);
typedef DWORD       (*_pfn_GetSystemDirectoryA)(LPSTR lpPath,DWORD Size);
typedef DWORD       (*_pfn_GetSystemDirectoryW)(LPWSTR lpPath,DWORD Size);
typedef BOOL        (*_pfn_SystemParametersInfoA)(UINT wFlag, UINT wParam, PVOID lParam, UINT flags);
typedef BOOL        (*_pfn_SystemParametersInfoW)(UINT wFlag, UINT wParam, PVOID lParam, UINT flags);

typedef LPTOP_LEVEL_EXCEPTION_FILTER (WINAPI *_pfn_SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
typedef PVOID       (*_pfn_RtlAddVectoredExceptionHandler)(ULONG FirstHandler, PVOID VectoredHandler);
typedef VOID        (*_pfn__endthread)(VOID);
typedef long        (*_pfn__hread)( HFILE hFile, LPVOID lpBuffer, long lBytes );
typedef long        (*_pfn__lseek)( int handle, long offset, int origin );
                    
typedef BOOL        (*_pfn_PlaySoundA)(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound);
typedef BOOL        (*_pfn_PlaySoundW)(LPCWSTR pszSound, HMODULE hmod, DWORD fdwSound);
typedef BOOL        (*_pfn_sndPlaySoundA)(LPCSTR lpszSound, UINT fuSound);
typedef BOOL        (*_pfn_sndPlaySoundW)(LPCWSTR lpszSound, UINT fuSound);
                    
typedef HCURSOR     (*_pfn_SetCursor)(HCURSOR hCursor);
typedef int         (*_pfn_ShowCursor)(BOOL bShow);
typedef BOOL        (*_pfn_EnumProcessModules)(HANDLE,HMODULE *,DWORD,LPDWORD);
typedef BOOL        (*_pfn_ClipCursor)(CONST RECT *lpRect);
typedef BOOL        (*_pfn_GetCursorPos)(LPPOINT lpPoint);
typedef BOOL        (*_pfn_SetCursorPos)(int X, int Y);
typedef BOOL        (*_pfn_SetSysColors)(int cElements, CONST INT *lpaElements, CONST COLORREF *lpaRgbValues);
                    
typedef HWND        (*_pfn_GetDesktopWindow)();
typedef LONG        (*_pfn_GetWindowLongA)(HWND, INT);
typedef int         (*_pfn_GetWindowTextA)(HWND hWnd, LPSTR lpString, int nMaxCount);
typedef int         (*_pfn_GetWindowTextW)(HWND hWnd, LPWSTR lpString, int nMaxCount);
typedef BOOL        (*_pfn_SetWindowTextA)(HWND hWnd, LPCSTR lpString);
typedef BOOL        (*_pfn_SetWindowTextW)(HWND hWnd, LPCWSTR lpString);
typedef int         (*_pfn_DrawTextA)( HDC hDC, LPCSTR lpString, int nCount, LPRECT lpRect, UINT uFormat );
typedef int         (*_pfn_DrawTextW)( HDC hDC, LPCWSTR lpString,int nCount, LPRECT lpRect, UINT uFormat );
typedef BOOL        (*_pfn_IsRectEmpty)( CONST RECT *lprc );
                    
typedef LONG        (*_pfn_DocumentPropertiesA)(HWND hWnd, HANDLE hPrinter, LPSTR pDeviceName,  PDEVMODEA pDevModeOutput, PDEVMODEA pDevModeInput, DWORD fMode);
typedef LONG        (*_pfn_DocumentPropertiesW)(HWND hWnd, HANDLE hPrinter, LPWSTR pDeviceName, PDEVMODEW pDevModeOutput, PDEVMODEW pDevModeInput, DWORD fMode);
typedef BOOL        (*_pfn_OpenPrinterA)(LPSTR pPrinterName, LPHANDLE phPrinter, LPPRINTER_DEFAULTSA pDefault);
typedef BOOL        (*_pfn_OpenPrinterW)(LPWSTR pPrinterName, LPHANDLE phPrinter, LPPRINTER_DEFAULTSW pDefault);
typedef BOOL        (*_pfn_SetPrinterA)(HANDLE hPrinter, DWORD Level, LPBYTE pPrinter, DWORD Command);
typedef BOOL        (*_pfn_SetPrinterW)(HANDLE hPrinter, DWORD Level, LPBYTE pPrinter, DWORD Command);
typedef DWORD       (*_pfn_DeviceCapabilitiesA)(LPCSTR pDevice, LPCSTR pPort, WORD fwCapability, LPSTR pOutput, CONST DEVMODE *pDevMode);
typedef BOOL        (*_pfn_AddPrinterConnectionA)(LPSTR pName);
typedef BOOL        (*_pfn_DeletePrinterConnectionA)(LPSTR pName);
                    
typedef HDC         (*_pfn_CreateDCA)(LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, CONST DEVMODEA *pdm);
typedef HDC         (*_pfn_CreateDCW)(LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, CONST DEVMODEW *pdm);
typedef HDC         (*_pfn_ResetDCA)(HDC hdc, CONST DEVMODEA *lpInitData );
typedef HDC         (*_pfn_CreateCompatibleDC)(HDC hdc);
typedef BOOL        (*_pfn_DeleteDC)(HDC hdc);
typedef HGDIOBJ     (*_pfn_SelectObject)(HDC hdc, HGDIOBJ hgdiobj);
                    
typedef BOOL        (*_pfn_StartPage)(HDC hdc);
typedef HHOOK       (*_pfn_SetWindowsHookExA)(int idHook, HOOKPROC lpfn, HINSTANCE hMod, DWORD dwThreadId);
typedef HHOOK       (*_pfn_SetWindowsHookExW)(int idHook, HOOKPROC lpfn, HINSTANCE hMod, DWORD dwThreadId);
typedef BOOL        (*_pfn_UnhookWindowsHookEx)(HHOOK hhk);
typedef HHOOK       (*_pfn_SetWindowsHookA)(int idHook, HOOKPROC lpfn);
typedef HHOOK       (*_pfn_SetWindowsHookW)(int idHook, HOOKPROC lpfn);
typedef BOOL        (*_pfn_UnhookWindowsHook)(int idHook, HOOKPROC lpfn);
                    
typedef BOOL        (*_pfn_BitBlt)(HDC hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, HDC hdcSrc, int nXSrc, int nYSrc, DWORD dwRop);
typedef DWORD       (*_pfn_SuspendThread)(HANDLE hThread);
                    
typedef LONG        (WINAPI *_pfn_lineNegotiateAPIVersion)( HLINEAPP hLineApp, DWORD dwDeviceID, DWORD dwAPILowVersion, DWORD dwAPIHighVersion, LPDWORD lpdwAPIVersion, LPLINEEXTENSIONID lpExtensionID );
typedef LONG        (WINAPI *_pfn_lineInitialize)( LPHLINEAPP lphLineApp, HINSTANCE hInstance, LINECALLBACK lpfnCallback, LPCSTR lpszAppName, LPDWORD lpdwNumDevs );
typedef LONG        (WINAPI *_pfn_lineInitializeExA)( LPHLINEAPP lphLineApp, HINSTANCE hInstance, LINECALLBACK lpfnCallback, LPCSTR lpszFriendlyAppName, LPDWORD lpdwNumDevs, LPDWORD lpdwAPIVersion, LPLINEINITIALIZEEXPARAMS lpLineInitializeExParams );
typedef LONG        (WINAPI *_pfn_lineInitializeExW)( LPHLINEAPP lphLineApp, HINSTANCE hInstance, LINECALLBACK lpfnCallback, LPCWSTR lpszFriendlyAppName, LPDWORD lpdwNumDevs, LPDWORD lpdwAPIVersion, LPLINEINITIALIZEEXPARAMS lpLineInitializeExParams );
                    
typedef HANDLE      (*_pfn_LoadImageA)(HINSTANCE hinst, LPCSTR lpszName, UINT uType, int cxDesired, int cyDesired, UINT fuLoad);
                    
typedef int         (WINAPI *_pfn_GetDIBits)( HDC hdc, HBITMAP hbmp, UINT uStartScan, UINT cScanLines, LPVOID lpvBits, LPBITMAPINFO lpbi, UINT uUsage);
                    
typedef HRESULT     (*_pfn_CoInitialize)(LPVOID pReserved);
typedef HRESULT     (*_pfn_CoInitializeSecurity)(PSECURITY_DESCRIPTOR pVoid, LONG cAuthSvc, SOLE_AUTHENTICATION_SERVICE *asAuthSvc, void *pReserved1, DWORD dwAuthnLevel, DWORD dwImpLevel, SOLE_AUTHENTICATION_LIST *pAuthList, DWORD dwCapabilities, void *pReserved3);
typedef HIC         (*_pfn_ICLocate)(DWORD, DWORD, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER, WORD);
                    
typedef MMRESULT    (WINAPI *_pfn_joyGetDevCapsA)( UINT uJoyID, LPJOYCAPS pjc, UINT cbjc );
typedef MMRESULT    (WINAPI *_pfn_joyGetPos)( UINT uJoyID, LPJOYINFO pji );
typedef MMRESULT    (WINAPI *_pfn_mmioSetInfo)(HMMIO hmmio, LPMMIOINFO lpmmioinfo, UINT wFlags);
                    
typedef int         (*_pfn_wvsprintfA)(LPSTR, LPCSTR, va_list);
                    
typedef int         (*_pfn_GetObjectA)(HGDIOBJ hgdiobj, int cbBuffer, LPVOID lpvObject);

typedef int         (WINAPI *_pfn_wglDescribePixelFormat)(HDC, int, UINT, LPPIXELFORMATDESCRIPTOR);
                    
typedef BOOL        (WINAPI *_pfn_CheckTokenMembership)(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember);
                    
typedef int         (*_pfn_LdrAccessResource)(PVOID DllHandle,const IMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry,PVOID *Address,PULONG Size);
                    
typedef HICON       (WINAPI *_pfn_CreateIcon)(HINSTANCE hInstance, int nWidth, int nHeight, BYTE cPlanes, BYTE cBitsPixel, CONST BYTE *lpbANDbits, CONST BYTE *lpbXORbits);
                    
typedef BOOL        (WINAPI *_pfn_ScreenToClient)(HWND hWnd, LPPOINT lpPoint);
typedef HRESULT     (WINAPI *_pfn_SafeArrayAccessData)(SAFEARRAY *, void HUGEP **);
                    
typedef DWORD       (WINAPI *_pfn_GetTempPathA)(DWORD nBufferLength, LPSTR lpBuffer);
typedef DWORD       (WINAPI *_pfn_GetTempPathW)(DWORD nBufferLength, LPWSTR lpBuffer);
typedef DWORD       (WINAPI *_pfn_GetLastError)(VOID);
                    
typedef BOOL        (WINAPI *_pfn_WinHelpA)(HWND hWndMain, LPCSTR lpszHelp, UINT uCommand, DWORD dwData);

typedef PDH_STATUS  (__stdcall *_pfn_PdhAddCounterA)(IN HQUERY hQuery, IN LPCSTR szFullCounterPath, IN DWORD_PTR dwUserData, IN HCOUNTER *phCounter);
typedef HWND        (WINAPI *_pfn_GetDlgItem)(HWND, int);
typedef DWORD       (WINAPI *_pfn_VerInstallFileW)(DWORD, LPWSTR,LPWSTR,LPWSTR,LPWSTR,LPWSTR,LPWSTR,PUINT);
typedef DWORD       (WINAPI *_pfn_VerInstallFileA)(DWORD, LPSTR,LPSTR,LPSTR,LPSTR,LPSTR,LPSTR,PUINT);
typedef LONG        (WINAPI *_pfn_lstrcmpiA)(LPCSTR, LPCSTR);
typedef DWORD       (WINAPI *_pfn_RasSetEntryPropertiesA)(LPCSTR, LPCSTR, LPRASENTRYA, DWORD, LPBYTE, DWORD);
typedef DWORD       (WINAPI *_pfn_RasSetEntryPropertiesW)(LPCWSTR, LPCWSTR, LPRASENTRYW, DWORD, LPBYTE, DWORD);
                    
typedef BOOL        (WINAPI *_pfn_GlobalMemoryStatus)(LPMEMORYSTATUS);
typedef LANGID      (WINAPI *_pfn_GetUserDefaultUILanguage)();
typedef HANDLE      (WINAPI *_pfn_SetClipboardData)(UINT, HANDLE);
                    
typedef int         (WINAPI *_pfn_MultiByteToWideChar)(UINT, DWORD, LPCSTR, int, LPWSTR, int);
typedef BOOL        (WINAPI *_pfn_GetCharWidthA)(HDC hdc, UINT iFirstChar, UINT iLastChar, LPINT lpBuffer);
typedef BOOL        (WINAPI *_pfn_GetCharWidthW)(HDC hdc, UINT iFirstChar, UINT iLastChar, LPINT lpBuffer);
typedef UINT        (WINAPI *_pfn_GetKBCodePage)(void);
                    
typedef int         (WINAPI *_pfn_WideCharToMultiByte)(UINT, DWORD, LPCWSTR, int, LPSTR, int, LPCSTR, LPBOOL);
typedef UINT        (WINAPI *_pfn_MsiGetPropertyA)(MSIHANDLE, LPCSTR, LPSTR, DWORD*);
typedef UINT        (WINAPI *_pfn_MsiGetPropertyW)(MSIHANDLE, LPCWSTR, LPWSTR, DWORD*);
                    
typedef BOOL        (WINAPI *_pfn_PrintDlgA)(LPPRINTDLG lppd);
                    
typedef MCIERROR    (WINAPI *_pfn_mciSendCommandA)(MCIDEVICEID, UINT, DWORD, DWORD);
                    
typedef BOOL        (WINAPI *_pfn_CertCloseStore)(HCERTSTORE, DWORD);
typedef BOOL        (WINAPI *_pfn_CryptVerifyMessageSignature)(PCRYPT_VERIFY_MESSAGE_PARA,DWORD ,const BYTE *,DWORD ,BYTE *,DWORD *,PCCERT_CONTEXT *);
typedef BOOL        (WINAPI *_pfn_ImageGetCertificateData)(HANDLE,DWORD,LPWIN_CERTIFICATE,PDWORD);
typedef BOOL        (WINAPI *_pfn_ImageGetCertificateHeader)(HANDLE,DWORD,LPWIN_CERTIFICATE);
typedef PCCERT_CONTEXT (WINAPI *_pfn_CertGetSubjectCertificateFromStore)(HCERTSTORE,DWORD,PCERT_INFO);
typedef HCERTSTORE  (WINAPI *_pfn_CertDuplicateStore)(HCERTSTORE);
typedef PCCERT_CONTEXT (WINAPI *_pfn_CertEnumCertificatesInStore)(HCERTSTORE, PCCERT_CONTEXT);
typedef DWORD       (WINAPI *_pfn_CertRDNValueToStrA)(DWORD,PCERT_RDN_VALUE_BLOB,LPSTR,DWORD);
typedef PCERT_RDN_ATTR (WINAPI *_pfn_CertFindRDNAttr)(LPCSTR,PCERT_NAME_INFO);
typedef BOOL        (WINAPI *_pfn_CryptDecodeObject)(DWORD,LPCSTR,const BYTE *,DWORD,DWORD,void *,DWORD *);
typedef HRESULT     (WINAPI *_pfn_WinVerifyTrust)(HWND, GUID *, WINTRUST_DATA *);
                    
typedef DWORD       (WINAPI *_pfn_CreateIpForwardEntry)(PMIB_IPFORWARDROW pRoute);
typedef DWORD       (WINAPI *_pfn_GetIpForwardTable)(PMIB_IPFORWARDTABLE pIpForwardTable, PULONG pdwSize, BOOL bOrder);

typedef BOOL        (WINAPI *_pfn_StartServiceA)(SC_HANDLE hService, DWORD, LPCSTR *);

typedef BOOL        (__stdcall *_pfn_AngleArc)(HDC hdc, int X, int Y, DWORD dwRadius, FLOAT eStartAngle, FLOAT eSweepAngle );
typedef BOOL        (__stdcall *_pfn_Arc)( HDC hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nXStartArc, int nYStartArc, int nXEndArc, int nYEndArc );
typedef BOOL        (__stdcall *_pfn_ArcTo)( HDC hdc,int nLeftRect,int nTopRect,int nRightRect,int nBottomRect,int nXRadial1,int nYRadial1,int nXRadial2,int nYRadial2);
typedef BOOL        (__stdcall *_pfn_ChoosePixelFormat)( HDC  hdc,CONST PIXELFORMATDESCRIPTOR *  ppfd );
typedef BOOL        (__stdcall *_pfn_Chord)( HDC hdc,int nLeftRect,int nTopRect,int nRightRect,int nBottomRect,int nXRadial1,int nYRadial1,int nXRadial2,int nYRadial2 );
typedef int         (_stdcall *_pfn_CombineRgn)(HRGN hrgnDest,HRGN hrgnSrc1,HRGN hrgnSrc2,int fnCombineMode );
typedef HENHMETAFILE (_stdcall *_pfn_CloseEnhMetaFile)(HDC hdc);
typedef HMETAFILE   (_stdcall *_pfn_CloseMetaFile)(HDC hdc);
typedef HBITMAP     (_stdcall *_pfn_CreateBitmap)(int nWidthIn, int nHeightIn, UINT cPlanesIn, UINT cBitPerPixelIn, CONST VOID * pvBitsIn);
typedef HBITMAP     (_stdcall *_pfn_CreateBitmapIndirect)(CONST BITMAP * lpbmIn);
typedef HBRUSH      (_stdcall *_pfn_CreateBrushIndirect)(CONST LOGBRUSH * lplbIn);
typedef HCOLORSPACE (_stdcall *_pfn_CreateColorSpaceA)(LPLOGCOLORSPACEA lpLogColorSpace);
typedef HCOLORSPACE (_stdcall *_pfn_CreateColorSpaceW)(LPLOGCOLORSPACEW lpLogColorSpace);
typedef BOOL        (_stdcall *_pfn_DPtoLP)(HDC hdc,LPPOINT lpPoints,int nCount);
typedef BOOL        (_stdcall *_pfn_DeleteColorSpace)(HCOLORSPACE hColorSpaceIn);
typedef HBITMAP     (_stdcall *_pfn_CreateCompatibleBitmap)(HDC hdc,int nWidth,int nHeight);
typedef HBRUSH      (_stdcall *_pfn_CreateDIBPatternBrush)(HGLOBAL hglbDIBPacked,UINT fuColorSpec);
typedef HBRUSH      (_stdcall *_pfn_CreateDIBPatternBrushPt)(CONST VOID *lpPackedDIB,UINT iUsage);
typedef HBITMAP     (_stdcall *_pfn_CreateDIBitmap)(HDC hdc,CONST BITMAPINFOHEADER *lpbmih,DWORD fdwInit,CONST VOID *lpbInit,CONST BITMAPINFO *lpbmi,UINT fuUsage);
typedef HBITMAP     (_stdcall *_pfn_CreateDiscardableBitmap)(HDC hdc,int nWidth,int nHeight);
typedef HRGN        (_stdcall *_pfn_CreateEllipticRgn)(int nLeftRect,int nTopRect,int nRightRect,int nBottomRect);
typedef HRGN        (_stdcall *_pfn_CreateEllipticRgnIndirect)(CONST RECT * lprc);
typedef HDC         (_stdcall *_pfn_CreateEnhMetaFileA)(HDC hdcRef,LPCSTR lpFilename,CONST RECT* lpRect,LPCSTR lpDescription);
typedef HDC         (_stdcall *_pfn_CreateEnhMetaFileW)(HDC hdcRef,LPCWSTR lpFilename,CONST RECT* lpRect,LPCWSTR lpDescription);
typedef HFONT       (_stdcall *_pfn_CreateFontA)(int nHeight,int nWidth,int nEscapement,int nOrientation,int fnWeight,DWORD fdwItalic,DWORD fdwUnderline,DWORD fdwStrikeOut,DWORD fdwCharSet,DWORD fdwOutputPrecision,DWORD fdwClipPrecision,DWORD fdwQuality,DWORD fdwPitchAndFamily,LPCSTR lpszFace);
typedef HFONT       (_stdcall *_pfn_CreateFontIndirectA)(CONST LOGFONTA * lplf);
typedef HFONT       (_stdcall *_pfn_CreateFontIndirectW)(CONST LOGFONTW * lplf);
typedef HFONT       (_stdcall *_pfn_CreateFontIndirectExA)(CONST ENUMLOGFONTEXDVA *penumlfex);
typedef HFONT       (_stdcall *_pfn_CreateFontIndirectExW)(CONST ENUMLOGFONTEXDVW *penumlfex);
typedef HFONT       (_stdcall *_pfn_CreateFontW)(int nHeight,int nWidth,int nEscapement,int nOrientation,int fnWeight,DWORD fdwItalic,DWORD fdwUnderline,DWORD fdwStrikeOut,DWORD fdwCharSet,DWORD fdwOutputPrecision,DWORD fdwClipPrecision,DWORD fdwQuality,DWORD fdwPitchAndFamily,LPCWSTR lpszFace);
typedef HPALETTE    (_stdcall *_pfn_CreateHalftonePalette)(HDC hdc);
typedef HBRUSH      (_stdcall *_pfn_CreateHatchBrush)(int fnStyle,COLORREF clrref);
typedef HDC         (_stdcall *_pfn_CreateICA)(LPCSTR lpszDriver,LPCSTR lpszDevice,LPCSTR lpszOutput,CONST DEVMODE *lpdvmInit);
typedef HDC         (_stdcall *_pfn_CreateICW)(LPCWSTR lpszDriver,LPCWSTR lpszDevice,LPCWSTR lpszOutput,CONST DEVMODE *lpdvmInit);
typedef HDC         (_stdcall *_pfn_CreateMetaFileA)(LPCSTR lpszFile);
typedef HDC         (_stdcall *_pfn_CreateMetaFileW)(LPCWSTR lpszFile);
typedef HPALETTE    (_stdcall *_pfn_CreatePalette)(CONST LOGPALETTE *lplgpl);
typedef HBRUSH      (_stdcall *_pfn_CreatePatternBrush)(HBITMAP hbmp);
typedef HPEN        (_stdcall *_pfn_CreatePen)(int fnPenStyle,int nWidth,COLORREF crColor);
typedef HPEN        (_stdcall *_pfn_CreatePenIndirect)(CONST LOGPEN *lplgpn);
typedef HRGN        (_stdcall *_pfn_CreatePolyPolygonRgn)(CONST POINT *lppt,CONST INT *lpPolyCounts,int nCount,int fnPolyFillMode);
typedef HRGN        (_stdcall *_pfn_CreatePolygonRgn)(CONST POINT *lppt,int cPoints,int fnPolyFillMode);
typedef HRGN        (_stdcall *_pfn_CreateRectRgn)(int nLeftRect,int nTopRect,int nRightRect,int nBottomRect);
typedef HRGN        (_stdcall *_pfn_CreateRectRgnIndirect)(CONST RECT * lprc);
typedef HRGN        (_stdcall *_pfn_CreateRoundRectRgn)(int nLeftRect,int nTopRect,int nRightRect,int nBottomRect,int nWidthEllipse,int nHeightEllipse);
typedef BOOL        (_stdcall *_pfn_CreateScalableFontResourceA)(DWORD fdwHidden,LPCSTR lpszFontRes,LPCSTR lpszFontFile,LPCSTR lpszCurrentPath);
typedef BOOL        (_stdcall *_pfn_CreateScalableFontResourceW)(DWORD fdwHidden,LPCWSTR lpszFontRes,LPCWSTR lpszFontFile,LPCWSTR lpszCurrentPath);
typedef HBRUSH      (_stdcall *_pfn_CreateSolidBrush)(COLORREF crColor);
typedef BOOL        (_stdcall *_pfn_DeleteEnhMetaFile)(HENHMETAFILE hemf);
typedef BOOL        (_stdcall *_pfn_DeleteMetaFile)(HMETAFILE hmf);
typedef BOOL        (_stdcall *_pfn_DeleteObject)(HGDIOBJ hObjectIn);
typedef BOOL        (_stdcall *_pfn_DeleteDC)(HDC hdc);
typedef HPEN        (_stdcall *_pfn_ExtCreatePen)(DWORD dwPenStyle,DWORD dwWidth,CONST LOGBRUSH *lplb,DWORD dwStyleCount,CONST DWORD *lpStyle);
typedef HRGN        (_stdcall *_pfn_ExtCreateRegion)(CONST XFORM *lpXform,DWORD nCount,CONST RGNDATA *lpRgnData);
typedef BOOL        (_stdcall *_pfn_ExtTextOutA)(HDC hdc,int X,int Y,UINT fuOptions,CONST RECT* lprc,LPCSTR lpString,UINT cbCount,CONST INT* lpDx);
typedef BOOL        (_stdcall *_pfn_ExtTextOutW)(HDC hdc,int X,int Y,UINT fuOptions,CONST RECT* lprc,LPCWSTR lpString,UINT cbCount,CONST INT* lpDx);
typedef BOOL        (_stdcall *_pfn_FixBrushOrgEx)(HDC hdc, int nUnknown1, int nUnknown2, LPPOINT lpPoint);
typedef BOOL        (_stdcall *_pfn_FloodFill)(HDC hdc, int nXStart, int nYStart, COLORREF crFill);
typedef LONG        (_stdcall *_pfn_GetBitmapBits)(HBITMAP hbmp,LONG cbBuffer,LPVOID lpvBits);
typedef HGDIOBJ     (_stdcall *_pfn_GetStockObject)(int fnObjectIn);
typedef HDC         (_stdcall *_pfn_BeginPaint)( HWND, LPPAINTSTRUCT );
typedef HICON       (_stdcall *_pfn_CopyIcon)(HICON);
typedef BOOL        (_stdcall *_pfn_DestroyIcon)(HICON);
typedef BOOL        (_stdcall *_pfn_DestroyCursor)(HCURSOR);
typedef BOOL        (_stdcall *_pfn_DestroyAcceleratorTable)(HACCEL);
typedef BOOL        (_stdcall *_pfn_DestroyMenu)(HMENU);
typedef BOOL        (_stdcall *_pfn_EndPaint)(HWND, CONST PAINTSTRUCT * );
typedef HCURSOR     (_stdcall *_pfn_GetCursor)( void );
typedef BOOL        (_stdcall *_pfn_GetIconInfo)( HICON, PICONINFO );
typedef HDC         (_stdcall *_pfn_GetDCEx)(HWND, HRGN, DWORD );
typedef HACCEL      (_stdcall *_pfn_LoadAcceleratorsA)(HINSTANCE, LPCSTR );
typedef HACCEL      (_stdcall *_pfn_LoadAcceleratorsW)(HINSTANCE, LPCWSTR );
typedef HBITMAP     (_stdcall *_pfn_LoadBitmapA)(HINSTANCE, LPCSTR );
typedef HBITMAP     (_stdcall *_pfn_LoadBitmapW)(HINSTANCE, LPCWSTR );
typedef HCURSOR     (_stdcall *_pfn_LoadCursorA)(HINSTANCE, LPCSTR );
typedef HCURSOR     (_stdcall *_pfn_LoadCursorFromFileA)(LPCSTR);
typedef HCURSOR     (_stdcall *_pfn_LoadCursorFromFileW)(LPCWSTR);
typedef HCURSOR     (_stdcall *_pfn_LoadCursorW)(HINSTANCE, LPCWSTR );
typedef HICON       (_stdcall *_pfn_LoadIconA)(HINSTANCE, LPCSTR );
typedef HICON       (_stdcall *_pfn_LoadIconW)(HINSTANCE, LPCWSTR );
typedef HANDLE      (_stdcall *_pfn_LoadImageA)(HINSTANCE, LPCSTR, UINT, int, int, UINT );
typedef HANDLE      (_stdcall *_pfn_LoadImageW)(HINSTANCE, LPCWSTR, UINT, int, int, UINT );
typedef HMENU       (_stdcall *_pfn_LoadMenuA)(HINSTANCE, LPCSTR );
typedef HMENU       (_stdcall *_pfn_LoadMenuIndirectA)(CONST MENUTEMPLATEA *);
typedef HMENU       (_stdcall *_pfn_LoadMenuIndirectW)(CONST MENUTEMPLATEW *);
typedef HMENU       (_stdcall *_pfn_LoadMenuW)(HINSTANCE, LPCWSTR );
typedef BOOL        (_stdcall *_pfn_ReleaseDC)(HWND, HDC );
typedef BOOL        (_stdcall *_pfn_UnregisterClassA)(LPCSTR, HINSTANCE);
typedef BOOL        (_stdcall *_pfn_UnregisterClassW)(LPCWSTR, HINSTANCE);
typedef int         (_stdcall *_pfn_SetWindowRgn)(HWND,HRGN,BOOL);
typedef HMENU       (_stdcall *_pfn_CreateMenu)( VOID );
typedef HACCEL      (_stdcall *_pfn_CreateAcceleratorTableA)( LPACCEL lpaccl, int cEntries );
typedef HACCEL      (_stdcall *_pfn_CreateAcceleratorTableW)( LPACCEL lpaccl, int cEntries );
typedef HCURSOR     (_stdcall *_pfn_CreateCursor)(HINSTANCE hInst,int xHotSpot,int yHotSpot,int nWidth,int nHeight,CONST VOID *pvANDPlane,CONST VOID *pvXORPlane);
typedef HICON       (_stdcall *_pfn_CreateIconFromResource)(PBYTE presbits,DWORD dwResSize,BOOL fIcon,DWORD dwVer);
typedef HICON       (_stdcall *_pfn_CreateIconFromResourceEx)(PBYTE pbIconBits,DWORD cbIconBits,BOOL fIcon,DWORD dwVersion,int cxDesired,int cyDesired,UINT uFlags);
typedef HANDLE      (_stdcall *_pfn_CopyImage)(HANDLE hImage,UINT uType,int cxDesired,int cyDesired,UINT fuFlags);
typedef HMENU       (_stdcall *_pfn_CreatePopupMenu)( VOID );
typedef BOOL        (_stdcall *_pfn_InsertMenuItemA)(HMENU hMenu,UINT uItem,BOOL fByPosition,LPCMENUITEMINFOA lpmii);
typedef BOOL        (_stdcall *_pfn_InsertMenuItemW)(HMENU hMenu,UINT uItem,BOOL fByPosition,LPCMENUITEMINFOW lpmii);
typedef HICON       (_stdcall *_pfn_CreateIconIndirect)(PICONINFO piconinfo);
typedef BOOL        (_stdcall *_pfn_GetBitmapDimensionEx)(HBITMAP hBitmap,LPSIZE lpDimension);
typedef BOOL        (_stdcall *_pfn_MaskBlt)(HDC hdcDest,int nXDest,int nYDest,int nWidth,int nHeight,HDC hdcSrc,int nXSrc,int nYSrc,HBITMAP hbmMask,int xMask,int yMask,DWORD dwRop);
typedef LONG        (_stdcall *_pfn_SetBitmapBits)(HBITMAP hbmp,DWORD cBytes,CONST VOID *lpBits);
typedef int         (_stdcall *_pfn_SetDIBits)(HDC hdc,HBITMAP hbmp,UINT uStartScan,UINT cScanLines,CONST VOID *lpvBits,CONST BITMAPINFO *lpbmi,UINT fuColorUse);
typedef BOOL        (_stdcall *_pfn_SetBitmapDimensionEx)(HBITMAP hBitmap,int nWidth,int nHeight,LPSIZE lpSize);
typedef HBRUSH      (_stdcall *_pfn_GetSysColorBrush)(int nIndex);
typedef HICON       (_stdcall *_pfn_ExtractAssociatedIconA)(HINSTANCE hInst, LPSTR lpIconPath, LPWORD lpiIcon);
typedef HICON       (_stdcall *_pfn_ExtractAssociatedIconW)(HINSTANCE hInst, LPWSTR lpIconPath, LPWORD lpiIcon);
typedef BOOL        (_stdcall *_pfn_DrawIcon)(HDC hDC, int X, int Y, HICON hIcon);
typedef BOOL        (_stdcall *_pfn_DrawIconEx)(HDC hDC, int X, int Y, HICON hIcon, int cxWidth, int cyHeight, UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags);
typedef BOOL        (_stdcall *_pfn_AnyPopup)(void);
typedef int         (_stdcall *_pfn_EnumFontFamiliesA)(HDC hdc, LPCSTR lpszFamily, FONTENUMPROC lpEnumFontFamProc, LPARAM lParam);
typedef int         (_stdcall *_pfn_EnumFontFamiliesW)(HDC hdc, LPCWSTR lpszFamily, FONTENUMPROC lpEnumFontFamProc, LPARAM lParam);
typedef int         (_stdcall *_pfn_EnumFontFamProc)(ENUMLOGFONT *lpelf, NEWTEXTMETRIC *lpntm, DWORD FontType, LPARAM lParam);
typedef int         (_stdcall *_pfn_EnumFontsA)(HDC hdc, LPCSTR lpFaceName, FONTENUMPROC lpFontFunc, LPARAM lParam);
typedef int         (_stdcall *_pfn_EnumFontsW)(HDC hdc, LPCWSTR lpFaceName, FONTENUMPROC lpFontFunc, LPARAM lParam);
typedef int         (_stdcall *_pfn_EnumFontsProc)(CONST LOGFONT *lplf, CONST TEXTMETRIC *lptm, DWORD dwType, LPARAM lpData);
typedef BOOL        (_stdcall *_pfn_EnumMetaFile)(HDC hdc, HMETAFILE hmf, MFENUMPROC lpMetaFunc, LPARAM lParam);
typedef int         (_stdcall *_pfn_EnumMetaFileProc)(HDC hDC, HANDLETABLE *lpHTable, METARECORD *lpMFR, int nObj, LPARAM lpClientData);

typedef BOOL        (__stdcall *_pfn_AngleArc)(HDC hdc, int X, int Y, DWORD dwRadius, FLOAT eStartAngle, FLOAT eSweepAngle );
typedef BOOL        (__stdcall *_pfn_Arc)( HDC hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nXStartArc, int nYStartArc, int nXEndArc, int nYEndArc );
typedef BOOL        (__stdcall *_pfn_ArcTo)( HDC hdc,int nLeftRect,int nTopRect,int nRightRect,int nBottomRect,int nXRadial1,int nYRadial1,int nXRadial2,int nYRadial2);
typedef BOOL        (__stdcall *_pfn_ChoosePixelFormat)( HDC  hdc,CONST PIXELFORMATDESCRIPTOR *  ppfd );
typedef BOOL        (__stdcall *_pfn_Chord)( HDC hdc,int nLeftRect,int nTopRect,int nRightRect,int nBottomRect,int nXRadial1,int nYRadial1,int nXRadial2,int nYRadial2 );
typedef int         (_stdcall *_pfn_CombineRgn)(HRGN hrgnDest,HRGN hrgnSrc1,HRGN hrgnSrc2,int fnCombineMode );
typedef HENHMETAFILE (_stdcall *_pfn_CloseEnhMetaFile)(HDC hdc);
typedef HMETAFILE   (_stdcall *_pfn_CloseMetaFile)(HDC hdc);
typedef HBITMAP     (_stdcall *_pfn_CreateBitmap)(int nWidthIn, int nHeightIn, UINT cPlanesIn, UINT cBitPerPixelIn, CONST VOID * pvBitsIn);
typedef HBITMAP     (_stdcall *_pfn_CreateBitmapIndirect)(CONST BITMAP * lpbmIn);
typedef HBRUSH      (_stdcall *_pfn_CreateBrushIndirect)(CONST LOGBRUSH * lplbIn);
typedef HCOLORSPACE (_stdcall *_pfn_CreateColorSpaceA)(LPLOGCOLORSPACEA lpLogColorSpace);
typedef HCOLORSPACE (_stdcall *_pfn_CreateColorSpaceW)(LPLOGCOLORSPACEW lpLogColorSpace);
typedef BOOL        (_stdcall *_pfn_DPtoLP)(HDC hdc,LPPOINT lpPoints,int nCount);
typedef BOOL        (_stdcall *_pfn_DeleteColorSpace)(HCOLORSPACE hColorSpaceIn);
typedef HBITMAP     (_stdcall *_pfn_CreateCompatibleBitmap)(HDC hdc,int nWidth,int nHeight);
typedef HBRUSH      (_stdcall *_pfn_CreateDIBPatternBrush)(HGLOBAL hglbDIBPacked,UINT fuColorSpec);
typedef HBRUSH      (_stdcall *_pfn_CreateDIBPatternBrushPt)(CONST VOID *lpPackedDIB,UINT iUsage);
typedef HBITMAP     (_stdcall *_pfn_CreateDIBitmap)(HDC hdc,CONST BITMAPINFOHEADER *lpbmih,DWORD fdwInit,CONST VOID *lpbInit,CONST BITMAPINFO *lpbmi,UINT fuUsage);
typedef HBITMAP     (_stdcall *_pfn_CreateDiscardableBitmap)(HDC hdc,int nWidth,int nHeight);
typedef HRGN        (_stdcall *_pfn_CreateEllipticRgn)(int nLeftRect,int nTopRect,int nRightRect,int nBottomRect);
typedef HRGN        (_stdcall *_pfn_CreateEllipticRgnIndirect)(CONST RECT * lprc);
typedef HDC         (_stdcall *_pfn_CreateEnhMetaFileA)(HDC hdcRef,LPCSTR lpFilename,CONST RECT* lpRect,LPCSTR lpDescription);
typedef HDC         (_stdcall *_pfn_CreateEnhMetaFileW)(HDC hdcRef,LPCWSTR lpFilename,CONST RECT* lpRect,LPCWSTR lpDescription);
typedef HFONT       (_stdcall *_pfn_CreateFontA)(int nHeight,int nWidth,int nEscapement,int nOrientation,int fnWeight,DWORD fdwItalic,DWORD fdwUnderline,DWORD fdwStrikeOut,DWORD fdwCharSet,DWORD fdwOutputPrecision,DWORD fdwClipPrecision,DWORD fdwQuality,DWORD fdwPitchAndFamily,LPCSTR lpszFace);
typedef HFONT       (_stdcall *_pfn_CreateFontIndirectA)(CONST LOGFONTA * lplf);
typedef HFONT       (_stdcall *_pfn_CreateFontIndirectW)(CONST LOGFONTW * lplf);
typedef HFONT       (_stdcall *_pfn_CreateFontIndirectExA)(CONST ENUMLOGFONTEXDVA *penumlfex);
typedef HFONT       (_stdcall *_pfn_CreateFontIndirectExW)(CONST ENUMLOGFONTEXDVW *penumlfex);
typedef HFONT       (_stdcall *_pfn_CreateFontW)(int nHeight,int nWidth,int nEscapement,int nOrientation,int fnWeight,DWORD fdwItalic,DWORD fdwUnderline,DWORD fdwStrikeOut,DWORD fdwCharSet,DWORD fdwOutputPrecision,DWORD fdwClipPrecision,DWORD fdwQuality,DWORD fdwPitchAndFamily,LPCWSTR lpszFace);
typedef HPALETTE    (_stdcall *_pfn_CreateHalftonePalette)(HDC hdc);
typedef HBRUSH      (_stdcall *_pfn_CreateHatchBrush)(int fnStyle,COLORREF clrref);
typedef HDC         (_stdcall *_pfn_CreateICA)(LPCSTR lpszDriver,LPCSTR lpszDevice,LPCSTR lpszOutput,CONST DEVMODE *lpdvmInit);
typedef HDC         (_stdcall *_pfn_CreateICW)(LPCWSTR lpszDriver,LPCWSTR lpszDevice,LPCWSTR lpszOutput,CONST DEVMODE *lpdvmInit);
typedef HDC         (_stdcall *_pfn_CreateMetaFileA)(LPCSTR lpszFile);
typedef HDC         (_stdcall *_pfn_CreateMetaFileW)(LPCWSTR lpszFile);
typedef HPALETTE    (_stdcall *_pfn_CreatePalette)(CONST LOGPALETTE *lplgpl);
typedef HBRUSH      (_stdcall *_pfn_CreatePatternBrush)(HBITMAP hbmp);
typedef HPEN        (_stdcall *_pfn_CreatePen)(int fnPenStyle,int nWidth,COLORREF crColor);
typedef HPEN        (_stdcall *_pfn_CreatePenIndirect)(CONST LOGPEN *lplgpn);
typedef HRGN        (_stdcall *_pfn_CreatePolyPolygonRgn)(CONST POINT *lppt,CONST INT *lpPolyCounts,int nCount,int fnPolyFillMode);
typedef HRGN        (_stdcall *_pfn_CreatePolygonRgn)(CONST POINT *lppt,int cPoints,int fnPolyFillMode);
typedef HRGN        (_stdcall *_pfn_CreateRectRgn)(int nLeftRect,int nTopRect,int nRightRect,int nBottomRect);
typedef HRGN        (_stdcall *_pfn_CreateRectRgnIndirect)(CONST RECT * lprc);
typedef HRGN        (_stdcall *_pfn_CreateRoundRectRgn)(int nLeftRect,int nTopRect,int nRightRect,int nBottomRect,int nWidthEllipse,int nHeightEllipse);
typedef BOOL        (_stdcall *_pfn_CreateScalableFontResourceA)(DWORD fdwHidden,LPCSTR lpszFontRes,LPCSTR lpszFontFile,LPCSTR lpszCurrentPath);
typedef BOOL        (_stdcall *_pfn_CreateScalableFontResourceW)(DWORD fdwHidden,LPCWSTR lpszFontRes,LPCWSTR lpszFontFile,LPCWSTR lpszCurrentPath);
typedef HBRUSH      (_stdcall *_pfn_CreateSolidBrush)(COLORREF crColor);
typedef BOOL        (_stdcall *_pfn_DeleteEnhMetaFile)(HENHMETAFILE hemf);
typedef BOOL        (_stdcall *_pfn_DeleteMetaFile)(HMETAFILE hmf);
typedef BOOL        (_stdcall *_pfn_DeleteObject)(HGDIOBJ hObjectIn);
typedef BOOL        (_stdcall *_pfn_DeleteDC)(HDC hdc);
typedef HPEN        (_stdcall *_pfn_ExtCreatePen)(DWORD dwPenStyle,DWORD dwWidth,CONST LOGBRUSH *lplb,DWORD dwStyleCount,CONST DWORD *lpStyle);
typedef HRGN        (_stdcall *_pfn_ExtCreateRegion)(CONST XFORM *lpXform,DWORD nCount,CONST RGNDATA *lpRgnData);
typedef BOOL        (_stdcall *_pfn_ExtTextOutA)(HDC hdc,int X,int Y,UINT fuOptions,CONST RECT* lprc,LPCSTR lpString,UINT cbCount,CONST INT* lpDx);
typedef BOOL        (_stdcall *_pfn_ExtTextOutW)(HDC hdc,int X,int Y,UINT fuOptions,CONST RECT* lprc,LPCWSTR lpString,UINT cbCount,CONST INT* lpDx);
typedef LONG        (_stdcall *_pfn_GetBitmapBits)(HBITMAP hbmp,LONG cbBuffer,LPVOID lpvBits);
typedef HGDIOBJ     (_stdcall *_pfn_GetStockObject)(int fnObjectIn);

typedef HDC         (_stdcall *_pfn_BeginPaint)( HWND, LPPAINTSTRUCT );
typedef HICON       (_stdcall *_pfn_CopyIcon)(HICON);
typedef BOOL        (_stdcall *_pfn_DestroyIcon)(HICON);
typedef BOOL        (_stdcall *_pfn_DestroyCursor)(HCURSOR);
typedef BOOL        (_stdcall *_pfn_DestroyAcceleratorTable)(HACCEL);
typedef BOOL        (_stdcall *_pfn_DestroyMenu)(HMENU);
typedef BOOL        (_stdcall *_pfn_EndPaint)(HWND, CONST PAINTSTRUCT * );
typedef HCURSOR     (_stdcall *_pfn_GetCursor)( void );
typedef BOOL        (_stdcall *_pfn_GetIconInfo)( HICON, PICONINFO );
typedef HDC         (_stdcall *_pfn_GetDCEx)(HWND, HRGN, DWORD );
typedef HACCEL      (_stdcall *_pfn_LoadAcceleratorsA)(HINSTANCE, LPCSTR );
typedef HACCEL      (_stdcall *_pfn_LoadAcceleratorsW)(HINSTANCE, LPCWSTR );
typedef HBITMAP     (_stdcall *_pfn_LoadBitmapA)(HINSTANCE, LPCSTR );
typedef HBITMAP     (_stdcall *_pfn_LoadBitmapW)(HINSTANCE, LPCWSTR );
typedef HCURSOR     (_stdcall *_pfn_LoadCursorA)(HINSTANCE, LPCSTR );
typedef HCURSOR     (_stdcall *_pfn_LoadCursorFromFileA)(LPCSTR);
typedef HCURSOR     (_stdcall *_pfn_LoadCursorFromFileW)(LPCWSTR);
typedef HCURSOR     (_stdcall *_pfn_LoadCursorW)(HINSTANCE, LPCWSTR );
typedef HICON       (_stdcall *_pfn_LoadIconA)(HINSTANCE, LPCSTR );
typedef HICON       (_stdcall *_pfn_LoadIconW)(HINSTANCE, LPCWSTR );
typedef HANDLE      (_stdcall *_pfn_LoadImageA)(HINSTANCE, LPCSTR, UINT, int, int, UINT );
typedef HANDLE      (_stdcall *_pfn_LoadImageW)(HINSTANCE, LPCWSTR, UINT, int, int, UINT );
typedef HMENU       (_stdcall *_pfn_LoadMenuA)(HINSTANCE, LPCSTR );
typedef HMENU       (_stdcall *_pfn_LoadMenuIndirectA)(CONST MENUTEMPLATEA *);
typedef HMENU       (_stdcall *_pfn_LoadMenuIndirectW)(CONST MENUTEMPLATEW *);
typedef HMENU       (_stdcall *_pfn_LoadMenuW)(HINSTANCE, LPCWSTR );
typedef BOOL        (_stdcall *_pfn_ReleaseDC)(HWND, HDC );
typedef BOOL        (_stdcall *_pfn_UnregisterClassA)(LPCSTR, HINSTANCE);
typedef BOOL        (_stdcall *_pfn_UnregisterClassW)(LPCWSTR, HINSTANCE);
typedef int         (_stdcall *_pfn_SetWindowRgn)(HWND,HRGN,BOOL);
typedef HMENU       (_stdcall *_pfn_CreateMenu)( VOID );
typedef HACCEL      (_stdcall *_pfn_CreateAcceleratorTableA)( LPACCEL lpaccl, int cEntries );
typedef HACCEL      (_stdcall *_pfn_CreateAcceleratorTableW)( LPACCEL lpaccl, int cEntries );
typedef HCURSOR     (_stdcall *_pfn_CreateCursor)(HINSTANCE hInst,int xHotSpot,int yHotSpot,int nWidth,int nHeight,CONST VOID *pvANDPlane,CONST VOID *pvXORPlane);
typedef HICON       (_stdcall *_pfn_CreateIconFromResource)(PBYTE presbits,DWORD dwResSize,BOOL fIcon,DWORD dwVer);
typedef HICON       (_stdcall *_pfn_CreateIconFromResourceEx)(PBYTE pbIconBits,DWORD cbIconBits,BOOL fIcon,DWORD dwVersion,int cxDesired,int cyDesired,UINT uFlags);
typedef HANDLE      (_stdcall *_pfn_CopyImage)(HANDLE hImage,UINT uType,int cxDesired,int cyDesired,UINT fuFlags);
typedef HMENU       (_stdcall *_pfn_CreatePopupMenu)( VOID );
typedef BOOL        (_stdcall *_pfn_InsertMenuItemA)(HMENU hMenu,UINT uItem,BOOL fByPosition,LPCMENUITEMINFOA lpmii);
typedef BOOL        (_stdcall *_pfn_InsertMenuItemW)(HMENU hMenu,UINT uItem,BOOL fByPosition,LPCMENUITEMINFOW lpmii);
typedef HICON       (_stdcall *_pfn_CreateIconIndirect)(PICONINFO piconinfo);
typedef BOOL        (_stdcall *_pfn_GetBitmapDimensionEx)(HBITMAP hBitmap,LPSIZE lpDimension);
typedef BOOL        (_stdcall *_pfn_MaskBlt)(HDC hdcDest,int nXDest,int nYDest,int nWidth,int nHeight,HDC hdcSrc,int nXSrc,int nYSrc,HBITMAP hbmMask,int xMask,int yMask,DWORD dwRop);
typedef BOOL        (_stdcall *_pfn_PlgBlt)(HDC hdcDest,CONST POINT *lpPoint,HDC hdcSrc,int nXSrc,int nYSrc,int nWidth,int nHeight,HBITMAP hbmMask,int xMask,int yMask);
typedef LONG        (_stdcall *_pfn_SetBitmapBits)(HBITMAP hbmp,DWORD cBytes,CONST VOID *lpBits);
typedef int         (_stdcall *_pfn_SetDIBits)(HDC hdc,HBITMAP hbmp,UINT uStartScan,UINT cScanLines,CONST VOID *lpvBits,CONST BITMAPINFO *lpbmi,UINT fuColorUse);
typedef BOOL        (_stdcall *_pfn_SetBitmapDimensionEx)(HBITMAP hBitmap,int nWidth,int nHeight,LPSIZE lpSize);
typedef HBRUSH      (_stdcall *_pfn_GetSysColorBrush)(int nIndex);

typedef DWORD       (WINAPI *_pfn_WNetEnumResourceA)(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize);
typedef DWORD       (WINAPI *_pfn_WNetEnumResourceW)(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize);
typedef HIMC        (WINAPI *_pfn_ImmAssociateContext)(HWND hWnd, HIMC hIMC);

typedef BOOL        (*_pfn_GetPrinterA)(HANDLE hPrinter, DWORD Level, LPBYTE pPrinter, DWORD cbBuf, LPDWORD pcbNeeded);
typedef BOOL        (*_pfn_GetPrinterW)(HANDLE hPrinter, DWORD Level, LPBYTE pPrinter, DWORD cbBuf, LPDWORD pcbNeeded);

typedef HDESK       (WINAPI *_pfn_CreateDesktopA)(LPCSTR lpszDesktop, LPCSTR lpszDevice, LPDEVMODEA pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa);
typedef HDESK       (WINAPI *_pfn_CreateDesktopW)(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, LPDEVMODEW pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa);
typedef HWINSTA     (WINAPI *_pfn_CreateWindowStationA)(LPSTR lpwinsta, DWORD dwReserved, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa);
typedef HWINSTA     (WINAPI *_pfn_CreateWindowStationW)(LPWSTR lpwinsta, DWORD dwReserved, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa);
typedef LONG        (WINAPI *_pfn_RegSaveKeyA)(HKEY hKey, LPCSTR lpFile, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef LONG        (WINAPI *_pfn_RegSaveKeyW)(HKEY hKey, LPCWSTR lpFile, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef LONG        (WINAPI *_pfn_RegSaveKeyExA)(HKEY hKey, LPCSTR lpFile, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags);
typedef LONG        (WINAPI *_pfn_RegSaveKeyExW)(HKEY hKey, LPCWSTR lpFile, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags);
typedef HANDLE      (WINAPI *_pfn_CreateRemoteThread)(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
typedef HANDLE      (WINAPI *_pfn_CreateJobObjectA)(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName);
typedef HANDLE      (WINAPI *_pfn_CreateJobObjectW)(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCWSTR lpName);
typedef BOOL        (WINAPI *_pfn_CreateHardLinkA)(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef BOOL        (WINAPI *_pfn_CreateHardLinkW)(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef HANDLE      (WINAPI *_pfn_CreateMailslotA)(LPCSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef HANDLE      (WINAPI *_pfn_CreateMailslotW)(LPCWSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef HANDLE      (WINAPI *_pfn_CreateNamedPipeA)(LPCSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef HANDLE      (WINAPI *_pfn_CreateNamedPipeW)(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef BOOL        (WINAPI *_pfn_CreatePipe)(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize);
typedef HANDLE      (WINAPI *_pfn_CreateWaitableTimerA)(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCSTR lpTimerName);
typedef HANDLE      (WINAPI *_pfn_CreateWaitableTimerW)(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName);
typedef BOOL        (WINAPI *_pfn_SetFileSecurityA) (LPCSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor);
typedef BOOL        (WINAPI *_pfn_SetFileSecurityW) (LPCWSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor);
typedef BOOL        (WINAPI *_pfn_SetKernelObjectSecurity) (HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor);
typedef DWORD       (WINAPI *_pfn_SetNamedSecurityInfoA)(LPSTR pObjectName, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID psidOwner, PSID psidGroup, PACL pDacl, PACL pSacl);
typedef DWORD       (WINAPI *_pfn_SetNamedSecurityInfoW)(LPWSTR pObjectName, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID psidOwner, PSID psidGroup, PACL pDacl, PACL pSacl);
typedef DWORD       (WINAPI *_pfn_SetSecurityInfo)(HANDLE handle, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID psidOwner, PSID psidGroup, PACL pDacl, PACL pSacl);
typedef int         (WINAPI *_pfn_SetTextCharacterExtra)(HDC hdc, int nCharExtra);
typedef LONG        (WINAPI *_pfn_RegSetKeySecurity) (HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor);
typedef BOOL        (WINAPI *_pfn_SetUserObjectSecurity)(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID);
typedef BOOL        (WINAPI *_pfn_SetServiceObjectSecurity)(SC_HANDLE hService, SECURITY_INFORMATION dwSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor);
typedef DWORD       (WINAPI *_pfn_SetNtmsObjectSecurity)(HANDLE hSession, LPNTMS_GUID lpObjectId, DWORD dwType, SECURITY_INFORMATION lpSecurityInformation, PSECURITY_DESCRIPTOR lpSecurityDescriptor);
typedef LONG        (WINAPI *_pfn_ClusterRegCreateKey)(HKEY hKey, LPCWSTR lpszSubKey, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
typedef DWORD       (WINAPI *_pfn_CreateNtmsMediaPoolA)(HANDLE hSession, LPCSTR lpPoolName, LPNTMS_GUID lpMediaType, DWORD dwAction, LPSECURITY_ATTRIBUTES lpSecurityAttributes, LPNTMS_GUID lpPoolId);
typedef DWORD       (WINAPI *_pfn_CreateNtmsMediaPoolW)(HANDLE hSession, LPCWSTR lpPoolName, LPNTMS_GUID lpMediaType, DWORD dwAction, LPSECURITY_ATTRIBUTES lpSecurityAttributes, LPNTMS_GUID lpPoolId);
typedef DWORD       (WINAPI *_pfn_DuplicateEncryptionInfoFile)(LPCWSTR SrcFileName, LPCWSTR DstFileName, DWORD dwCreationDistribution, DWORD dwAttributes, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef void        (WINAPI *_pfn_ReleaseStgMedium)(STGMEDIUM *pmedium);
typedef LONG        (WINAPI *_pfn_ClusterRegSetKeySecurity)(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor);

#endif // _SHIMPROTO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\shimtags.h ===
/*--

Copyright (c) 1999  Microsoft Corporation

Module Name:

    shimtags.h

Abstract:

    tag definitions for the shim db

Author:

    dmunsil 02/02/2000

Revision History:

Notes:

    These are the tag definitions used by the shim db to pack/unpack shimming info from an XML file,

--*/

#ifndef _SHIMTAGS_H_
#define _SHIMTAGS_H_

//
// LIST types for shimdb
//
#define TAG_DATABASE        (0x1 | TAG_TYPE_LIST)
#define TAG_LIBRARY         (0x2 | TAG_TYPE_LIST)
#define TAG_INEXCLUDE       (0x3 | TAG_TYPE_LIST)
#define TAG_DLL             (0x4 | TAG_TYPE_LIST)
#define TAG_PATCH           (0x5 | TAG_TYPE_LIST)
#define TAG_APP             (0x6 | TAG_TYPE_LIST)     // hopefully never used
#define TAG_EXE             (0x7 | TAG_TYPE_LIST)
#define TAG_MATCHING_FILE   (0x8 | TAG_TYPE_LIST)
#define TAG_DLL_REF         (0x9 | TAG_TYPE_LIST)
#define TAG_PATCH_REF       (0xA | TAG_TYPE_LIST)
#define TAG_LAYER           (0xB | TAG_TYPE_LIST)
#define TAG_FILE            (0xC | TAG_TYPE_LIST)
#define TAG_APPHELP         (0xD | TAG_TYPE_LIST)
#define TAG_LINK            (0xE | TAG_TYPE_LIST) // description list w/lang ids and urls

//
// STRINGREF types for shimdb
//

#define TAG_NAME              (0x1  | TAG_TYPE_STRINGREF)
#define TAG_DESCRIPTION       (0x2  | TAG_TYPE_STRINGREF)
#define TAG_MODULE            (0x3  | TAG_TYPE_STRINGREF)
#define TAG_API               (0x4  | TAG_TYPE_STRINGREF)
#define TAG_VENDOR            (0x5  | TAG_TYPE_STRINGREF)   // hopefully never used
#define TAG_APP_NAME          (0x6  | TAG_TYPE_STRINGREF)
#define TAG_SHORTNAME         (0x7  | TAG_TYPE_STRINGREF)
#define TAG_COMMAND_LINE      (0x8  | TAG_TYPE_STRINGREF)
#define TAG_COMPANY_NAME      (0x9  | TAG_TYPE_STRINGREF)
#define TAG_WILDCARD_NAME     (0xA  | TAG_TYPE_STRINGREF)
#define TAG_PRODUCT_NAME      (0x10 | TAG_TYPE_STRINGREF)
#define TAG_PRODUCT_VERSION   (0x11 | TAG_TYPE_STRINGREF)
#define TAG_FILE_DESCRIPTION  (0x12 | TAG_TYPE_STRINGREF)
#define TAG_FILE_VERSION      (0x13 | TAG_TYPE_STRINGREF)
#define TAG_ORIGINAL_FILENAME (0x14 | TAG_TYPE_STRINGREF)
#define TAG_INTERNALNAME      (0x15 | TAG_TYPE_STRINGREF)
#define TAG_LEGALCOPYRIGHT    (0x16 | TAG_TYPE_STRINGREF)
#define TAG_16BITDESCRIPTION  (0x17 | TAG_TYPE_STRINGREF)

#define TAG_APPHELP_DETAILS   (0x18 | TAG_TYPE_STRINGREF) // details in single language
#define TAG_LINK_URL          (0x19 | TAG_TYPE_STRINGREF)
#define TAG_LINK_TEXT         (0x1A | TAG_TYPE_STRINGREF)
#define TAG_APPHELP_TITLE     (0x1B | TAG_TYPE_STRINGREF)
#define TAG_APPHELP_CONTACT   (0x1C | TAG_TYPE_STRINGREF)

#define TAG_SXS_MANIFEST      (0x1D | TAG_TYPE_STRINGREF)

#define TAG_STRINGTABLE       (0x801 | TAG_TYPE_LIST)


//
// DWORD types for shimdb
//
#define TAG_SIZE             (0x1 | TAG_TYPE_DWORD)
#define TAG_OFFSET           (0x2 | TAG_TYPE_DWORD)
#define TAG_CHECKSUM         (0x3 | TAG_TYPE_DWORD)
#define TAG_DLL_TAGID        (0x4 | TAG_TYPE_DWORD)
#define TAG_PATCH_TAGID      (0x5 | TAG_TYPE_DWORD)
#define TAG_MODULETYPE       (0x6 | TAG_TYPE_DWORD)
#define TAG_VERDATEHI        (0x7 | TAG_TYPE_DWORD)
#define TAG_VERDATELO        (0x8 | TAG_TYPE_DWORD)
#define TAG_VERFILEOS        (0x9 | TAG_TYPE_DWORD)
#define TAG_VERFILETYPE      (0xA | TAG_TYPE_DWORD)
#define TAG_PECHECKSUM       (0xB | TAG_TYPE_DWORD)
#define TAG_PREVOSMAJORVER   (0xC | TAG_TYPE_DWORD)
#define TAG_PREVOSMINORVER   (0xD | TAG_TYPE_DWORD)
#define TAG_PREVOSPLATFORMID (0xE | TAG_TYPE_DWORD)
#define TAG_PREVOSBUILDNO    (0xF | TAG_TYPE_DWORD)
#define TAG_PROBLEMSEVERITY  (0x10| TAG_TYPE_DWORD)
#define TAG_LANGID           (0x11| TAG_TYPE_DWORD)

#define TAG_ENGINE           (0x14| TAG_TYPE_DWORD)
#define TAG_HTMLHELPID       (0x15| TAG_TYPE_DWORD)
#define TAG_INDEX_FLAGS      (0x16| TAG_TYPE_DWORD)
#define TAG_FLAGS            (0x17| TAG_TYPE_DWORD)

#define TAG_TAGID            (0x801| TAG_TYPE_DWORD)

//
// STRING types
//
#define TAG_STRINGTABLE_ITEM (0x801 | TAG_TYPE_STRING)

//
// NULL types for shimdb (existence/nonexistence is treated like a BOOL)
//
#define TAG_INCLUDE         (0x1 | TAG_TYPE_NULL)
#define TAG_SAFE            (0x2 | TAG_TYPE_NULL)
#define TAG_GENERAL         (0x3 | TAG_TYPE_NULL)

//
// QWORD types for shimdb
//
#define TAG_TIME                     (0x1 | TAG_TYPE_QWORD)
#define TAG_BIN_FILE_VERSION         (0x2 | TAG_TYPE_QWORD)
#define TAG_BIN_PRODUCT_VERSION      (0x3 | TAG_TYPE_QWORD)
#define TAG_MODTIME                  (0x4 | TAG_TYPE_QWORD)
#define TAG_KERNEL_FLAGS             (0x5 | TAG_TYPE_QWORD)
#define TAG_UPTO_BIN_PRODUCT_VERSION (0x6 | TAG_TYPE_QWORD)

//
// BINARY types for shimdb
//
#define TAG_DLL_BITS        (0x1 | TAG_TYPE_BINARY)
#define TAG_PATCH_BITS      (0x2 | TAG_TYPE_BINARY)
#define TAG_FILE_BITS       (0x3 | TAG_TYPE_BINARY)
#define TAG_EXE_ID          (0x4 | TAG_TYPE_BINARY)

#define TAG_INDEX_BITS      (0x801 | TAG_TYPE_BINARY)

//
// INDEX types for shimdb
//
#define TAG_INDEXES         (0x802 | TAG_TYPE_LIST)
#define TAG_INDEX           (0x803 | TAG_TYPE_LIST)

//
// WORD types
//
#define TAG_TAG             (0x801 | TAG_TYPE_WORD)
#define TAG_INDEX_TAG       (0x802 | TAG_TYPE_WORD)
#define TAG_INDEX_KEY       (0x803 | TAG_TYPE_WORD)

//
// Apps that want to be able to display a text representation
// of the tags can define _WANT_TAG_INFO, and this
// handy static data will be included.
//
#ifdef _WANT_TAG_INFO

typedef struct _TAG_INFO {
    TAG         tWhich;
    WCHAR*      szName;
} TAG_INFO, *PTAG_INFO;

static TAG_INFO gaTagInfo[] = {
    {TAG_DATABASE           ,L"DATABASE"},
    {TAG_LIBRARY            ,L"LIBRARY"},
    {TAG_INEXCLUDE          ,L"INEXCLUDE"},
    {TAG_DLL                ,L"DLL"},
    {TAG_PATCH              ,L"PATCH"},
    {TAG_APP                ,L"APP"},
    {TAG_EXE                ,L"EXE"},
    {TAG_MATCHING_FILE      ,L"MATCHING_FILE"},
    {TAG_DLL_REF            ,L"DLL_REF"},
    {TAG_PATCH_REF          ,L"PATCH_REF"},
    {TAG_LAYER              ,L"LAYER"},
    {TAG_FILE               ,L"FILE"},
    {TAG_APPHELP            ,L"APPHELP"},
    {TAG_LINK               ,L"LINK"},
  
    {TAG_NAME               ,L"NAME"},
    {TAG_DESCRIPTION        ,L"DESCRIPTION"},
    {TAG_MODULE             ,L"MODULE"},
    {TAG_API                ,L"API"},
    {TAG_VENDOR             ,L"VENDOR"},
    {TAG_APP_NAME           ,L"APP_NAME"},
    {TAG_SHORTNAME          ,L"SHORTNAME"},
    {TAG_COMMAND_LINE       ,L"COMMAND_LINE"},
    {TAG_COMPANY_NAME       ,L"COMPANY_NAME"},
    {TAG_WILDCARD_NAME      ,L"WILDCARD_NAME"},
    {TAG_PRODUCT_NAME       ,L"PRODUCT_NAME"},
    {TAG_PRODUCT_VERSION    ,L"PRODUCT_VERSION"},
    {TAG_FILE_DESCRIPTION   ,L"FILE_DESC"},
    {TAG_FILE_VERSION       ,L"FILEVERSION"},
    {TAG_ORIGINAL_FILENAME  ,L"ORIGINALFILENAME"},
    {TAG_INTERNALNAME       ,L"INTERNALNAME"},
    {TAG_LEGALCOPYRIGHT     ,L"LEGALCOPYRIGHT"},
    {TAG_16BITDESCRIPTION   ,L"16BITDESCRIPTION"},
    {TAG_APPHELP_DETAILS    ,L"PROBLEM_DETAILS"},
    {TAG_LINK_URL           ,L"LINK_URL"},
    {TAG_LINK_TEXT          ,L"LINK_TEXT"},
    {TAG_APPHELP_TITLE      ,L"APPHELP_TITLE"},
    {TAG_APPHELP_CONTACT    ,L"APPHELP_CONTACT"},
    {TAG_SXS_MANIFEST       ,L"SXS_MANIFEST"},

    {TAG_SIZE               ,L"SIZE"},
    {TAG_OFFSET             ,L"OFFSET"},
    {TAG_CHECKSUM           ,L"CHECKSUM"},
    {TAG_DLL_TAGID          ,L"DLL_TAGID"},
    {TAG_PATCH_TAGID        ,L"PATCH_TAGID"},
    {TAG_MODULETYPE         ,L"MODULETYPE"},
    {TAG_VERDATEHI          ,L"VERFILEDATEHI"},
    {TAG_VERDATELO          ,L"VERFILEDATELO"},
    {TAG_VERFILEOS          ,L"VERFILEOS"},
    {TAG_VERFILETYPE        ,L"VERFILETYPE"},
    {TAG_PECHECKSUM         ,L"PECHECKSUM"},
    {TAG_PREVOSMAJORVER     ,L"PREVOSMAJORVERSION"},
    {TAG_PREVOSMINORVER     ,L"PREVOSMINORVERSION"},
    {TAG_PREVOSPLATFORMID   ,L"PREVOSPLATFORMID"},
    {TAG_PREVOSBUILDNO      ,L"PREVOSBUILDNO"},
    {TAG_PROBLEMSEVERITY    ,L"PROBLEM_SEVERITY"},
    {TAG_HTMLHELPID         ,L"HTMLHELPID"},
    {TAG_INDEX_FLAGS        ,L"INDEXFLAGS"},
    {TAG_LANGID             ,L"APPHELP_LANGID"},
    {TAG_ENGINE             ,L"ENGINE"},
    {TAG_FLAGS              ,L"FLAGS" },
    
    {TAG_INCLUDE            ,L"INCLUDE"},
    {TAG_SAFE               ,L"SAFE"},
    {TAG_GENERAL            ,L"GENERAL"},

    {TAG_TIME               ,L"TIME"},
    {TAG_BIN_FILE_VERSION   ,L"BIN_FILE_VERSION"},
    {TAG_BIN_PRODUCT_VERSION,L"BIN_PRODUCT_VERSION"},
    {TAG_MODTIME            ,L"MODTIME"},
    {TAG_KERNEL_FLAGS       ,L"KERNEL_FLAGS"},
    {TAG_UPTO_BIN_PRODUCT_VERSION, L"UPTO_BIN_PRODUCT_VERSION"},


    {TAG_DLL_BITS           ,L"DLL_BITS"},
    {TAG_PATCH_BITS         ,L"PATCH_BITS"},
    {TAG_FILE_BITS          ,L"FILE_BITS"},
    {TAG_EXE_ID             ,L"EXE_ID(GUID)"},

    // internal types defined in shimdb.h
    {TAG_STRINGTABLE        ,L"STRINGTABLE"},
    {TAG_INDEXES            ,L"INDEXES"},
    {TAG_INDEX              ,L"INDEX"},
    {TAG_INDEX_TAG          ,L"INDEX_TAG"},
    {TAG_INDEX_KEY          ,L"INDEX_KEY"},
    {TAG_INDEX_BITS         ,L"INDEX_BITS"},
    {TAG_STRINGTABLE_ITEM   ,L"STRTAB_ITEM"},
    {TAG_TAG                ,L"TAG"},
    {TAG_TAGID              ,L"TAGID"},
    

    {TAG_NULL               ,L""} // always needs to be last item
};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\vkoem.h ===
/****************************** Module Header ******************************\
* Module Name: vkoem.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This header file OEM Virtual Key definitions
*
* History:
* 04-26-91 IanJa      Created.
\***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\veriflog.h ===
/*++

    Copyright (c) 2001  Microsoft Corporation

    Module Name:

        VerifLog.h

    Abstract:

        Headers for the AppVerifier log file.

    Revision History:

    04/26/2001  dmunsil     Created.
    08/14/2001  robkenny    Inserted inside the ShimLib namespace.


--*/

#pragma once

#include <stdio.h>
#include "ShimCString.h"
#include "shimdb.h"
#include "avrfutil.h"

namespace ShimLib
{


extern BOOL g_bVerifierLogEnabled;   // enable/disable file logging

class CVerifierLog {
public:
    CString m_strShimName;
    DWORD   m_dwEntries;
    BOOL    m_bHeaderDumped;


    CVerifierLog(LPCSTR szShimName, DWORD dwEntries) {
        m_strShimName = szShimName;
        m_dwEntries = dwEntries;
        m_bHeaderDumped = FALSE;
    }
 
    void __cdecl 
    VLog(
        VLOG_LEVEL eLevel,
        DWORD dwLogNum, 
        LPCSTR pszFmt, 
        ...
        );


    void
    DumpLogEntry(
        DWORD   dwLogNum,
        UINT    unResTitle,
        UINT    unResDescription,
        UINT    unResURL
        );

    void
    DumpShimHeader(void);

};

//
// helper functions
//
BOOL 
InitVerifierLogSupport(
    void);

void
ReleaseVerifierLogSupport(
    void);

void 
WriteToSessionLog(
    LPCSTR szLine
    );

void 
WriteToProcessLog(
    LPCSTR szLine
    );

int 
VLogLoadString(
    HMODULE   hModule,
    UINT      wID,
    LPWSTR    lpBuffer,            // Unicode buffer
    int       cchBufferMax);

//
// Goes at top of shim cpp file, or in shared header file for shim
//
#define BEGIN_DEFINE_VERIFIER_LOG(shim) enum {

#define VERIFIER_LOG_ENTRY(entry) entry,

#define END_DEFINE_VERIFIER_LOG(shim)     VLOG_ENTRIES_##shim };                    


//
// goes at top of shim file, after includes and above defines and before any code
//
#define INIT_VERIFIER_LOG(shim) static CVerifierLog g_VLog(#shim, VLOG_ENTRIES_##shim)

//
// goes in shim init section
//
// once for each log entry
#define DUMP_VERIFIER_LOG_ENTRY(entry, title, desc, url)                            \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                          \
        g_VLog.DumpLogEntry(entry, title, desc, url);                               \
    }
    
//
// for each log entry required
//
#define VLOG g_VLog.VLog

#define VLOG_MAX_DESC 4096
#define VLOG_MAX_FRIENDLY_NAME 256

//
// goes in each shim module
//
#define SHIM_INFO_BEGIN()                                                           \
BOOL                                                                                \
QueryShimInfo(AVRF_INFO_ID eInfo, PVOID pInfo)                                      \
{

#define SHIM_INFO_DESCRIPTION(res_desc)                                             \
    if (eInfo == AVRF_INFO_DESCRIPTION) {                                           \
        LPWSTR *pszTemp = (LPWSTR*)pInfo;                                           \
        *pszTemp =                                                                  \
            (LPWSTR)ShimMalloc(VLOG_MAX_DESC * sizeof(WCHAR));                      \
        if (*pszTemp) {                                                             \
            VLogLoadString(g_hinstDll,                                              \
                       res_desc,                                                    \
                       (LPWSTR)*pszTemp,                                            \
                       VLOG_MAX_DESC);                                              \
            return TRUE;                                                            \
        }                                                                           \
    }
    
#define SHIM_INFO_FRIENDLY_NAME(res_name)                                           \
    if (eInfo == AVRF_INFO_FRIENDLY_NAME) {                                         \
        LPWSTR *pszTemp = (LPWSTR*)pInfo;                                           \
        *pszTemp =                                                                  \
            (LPWSTR)ShimMalloc(VLOG_MAX_FRIENDLY_NAME * sizeof(WCHAR));             \
        if (*pszTemp) {                                                             \
            VLogLoadString(g_hinstDll,                                              \
                       res_name,                                                    \
                       (LPWSTR)*pszTemp,                                            \
                       VLOG_MAX_FRIENDLY_NAME);                                     \
            return TRUE;                                                            \
        }                                                                           \
    }

#define SHIM_INFO_FLAGS(flags)                                                      \
    if (eInfo == AVRF_INFO_FLAGS) {                                                 \
        *((DWORD*)pInfo) = flags;                                                   \
        return TRUE;                                                                \
    }
    
#define SHIM_INFO_GROUPS(groups)                                                    \
    if (eInfo == AVRF_INFO_GROUPS) {                                                \
        *((DWORD*)pInfo) = groups;                                                  \
        return TRUE;                                                                \
    }
    
#define SHIM_INFO_VERSION(major, minor)                                             \
    if (eInfo == AVRF_INFO_VERSION) {                                               \
        *((DWORD*)pInfo) = (((DWORD)major) << 16) | minor;                          \
        return TRUE;                                                                \
    }
    
#define SHIM_INFO_INCLUDE_EXCLUDE(string)                                           \
    if (eInfo == AVRF_INFO_INCLUDE_EXCLUDE) {                                       \
        *((LPWSTR*)pInfo) = L##string;                                              \
        return TRUE;                                                                \
    }
    
#define SHIM_INFO_OPTIONS_PAGE(res_template, dlgproc)                               \
    if (eInfo == AVRF_INFO_OPTIONS_PAGE) {                                          \
        LPPROPSHEETPAGE lpSheet = (LPPROPSHEETPAGE)pInfo;                           \
                                                                                    \
        lpSheet->hInstance = g_hinstDll;                                            \
        lpSheet->pszTemplate = (LPCWSTR)res_template;                               \
        lpSheet->pfnDlgProc = dlgproc;                                     \
                                                                                    \
        return TRUE;                                                                \
    }


#define SHIM_INFO_END()                                                             \
    return FALSE;                                                                   \
}                                                                                   

//
// goes in Main.cpp
//
#define DECLARE_VERIFIER_SHIM(name)                                                 \
    namespace NS_##name                                                             \
    {                                                                               \
        extern BOOL QueryShimInfo(AVRF_INFO_ID eInfo, PVOID pInfo);                 \
    };

// in multi-shim init
#define INIT_VLOG_SUPPORT()                                                         \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                          \
        InitVerifierLogSupport();                                                   \
    }
    

#define DECLARE_VERIFIER_DLL()                                                      \
extern "C" DWORD                                                                    \
GetVerifierMagic(void)                                                              \
{                                                                                   \
    return VERIFIER_SHIMS_MAGIC;                                                    \
}                                                                                   \
/*                                                                                  \
 *  Cause a compile error if the prototype in shimdb.w is out of sync with call     \
 */                                                                                 \
static _pfnGetVerifierMagic __TEST_GetVerifierMagic_PROTO = GetVerifierMagic;
 


#define ENUM_VERIFIER_SHIMS_BEGIN()                                                 \
extern "C" BOOL                                                                     \
QueryShimInfo(LPCWSTR szName, AVRF_INFO_ID eInfo, PVOID pInfo)                      \
{                                                                                   \
    DWORD dwCount = 0;

#define ENUM_VERIFIER_SHIMS_ENTRY(name)                                             \
    if (eInfo == AVRF_INFO_NUM_SHIMS) {                                             \
        dwCount++;                                                                  \
    } else if (eInfo == AVRF_INFO_SHIM_NAMES) {                                     \
        ((LPWSTR*)pInfo)[dwCount] = L#name;                                         \
        dwCount++;                                                                  \
    } else if (szName && _wcsicmp(szName, L#name) == 0) {                           \
        return NS_##name::QueryShimInfo(eInfo, pInfo);                              \
    }
    

#define ENUM_VERIFIER_SHIMS_END()                                                   \
    if (eInfo == AVRF_INFO_NUM_SHIMS) {                                             \
        *((DWORD*)pInfo) = dwCount;                                                 \
        return TRUE;                                                                \
    }                                                                               \
    if (eInfo == AVRF_INFO_SHIM_NAMES) {                                            \
        return TRUE;                                                                \
    }                                                                               \
                                                                                    \
    return FALSE;                                                                   \
}                                                                                   \
/*                                                                                  \
 *  Cause a compile error if the prototype in shimdb.w is out of sync with call     \
 */                                                                                 \
static _pfnQueryShimInfo __TEST_QueryShimInfo_PROTO = QueryShimInfo;



};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\stdexts.h ===
/****************************** Module Header ******************************\
* Module Name: stdexts.h
*
* Copyright (c) Microsoft Corporation. All rights reserved.
*
* This module contains standard routines for creating sane debuging extensions.
*
* History:
* 11-Apr-1995 Sanfords  Created
\***************************************************************************/

#ifdef NOEXTAPI
#undef NOEXTAPI
#endif // !NOEXTAPI

#define NOEXTAPI
#include <wdbgexts.h>

/*
 * Preceeding this header the following must have been defined:
 * PSTR pszExtName;
 *
 * This module includes "exts.h" which defines what exported functions are
 * supported by each extension and contains all help text and legal option
 * information.  At a minimum exts.h must have:

DOIT(   help
        ,"help -v [cmd]                 - Displays this list or gives details on command\n"
        ,"  help      - To dump short help text on all commands.\n"
         "  help -v   - To dump long help text on all commands.\n"
         "  help cmd  - To dump long help on given command.\n"
        ,"v"
        ,CUSTOM)

 */


extern HANDLE                  hCurrentProcess;
extern HANDLE                  hCurrentThread;
extern DWORD                   dwCurrentPc;
extern WINDBG_EXTENSION_APIS  *lpExtensionApis;
#ifdef KERNEL
extern DWORD                   dwProcessor;
extern WINDBG_EXTENSION_APIS   ExtensionApis;
#endif // KERNEL

#define Print           (lpExtensionApis->lpOutputRoutine)
#define OUTAHERE()      RtlRaiseStatus(STATUS_NONCONTINUABLE_EXCEPTION);
#define GetSym          (lpExtensionApis->lpGetSymbolRoutine)
#define ReadMem         (lpExtensionApis->lpReadProcessMemoryRoutine)
#define IsWinDbg()      (lpExtensionApis->nSize >= sizeof(WINDBG_EXTENSION_APIS))
#define SAFEWHILE(exp)  while (!IsCtrlCHit() && (exp))

extern PSTR pszAccessViolation;
extern PSTR pszMoveException;
extern PSTR pszReadFailure;

#define OPTS_ERROR 0xFFFFFFFF

#define OFLAG(l)        (1L << ((DWORD)#@l - (DWORD)'a'))
#define move(dst, src)  moveBlock(&(dst), src, sizeof(dst))
#define tryMove(dst, src)  tryMoveBlock(&(dst), src, sizeof(dst))
#define tryDword(pdst, src) tryMoveBlock(pdst, src, sizeof(DWORD))
//#define DEBUGPRINT      Print       // set this when debuging your extensions
#define DEBUGPRINT

VOID moveBlock(PVOID pdst, PVOID src, DWORD size);
BOOL tryMoveBlock(PVOID pdst, PVOID src, DWORD size);
VOID moveExp(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExp(PVOID pdst, LPSTR pszExp);
VOID moveExpValue(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExpValue(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExpPtr(PVOID pdst, LPSTR pszExp);
VOID moveExpValuePtr(PVOID pdst, LPSTR pszExp);
BOOL IsCtrlCHit(VOID);

PVOID OptEvalExp(LPSTR psz);
PVOID OptEvalExp2(LPSTR *ppsz);
DWORD StringToOpts(LPSTR psz);
DWORD GetOpts(LPSTR *ppszArgs, LPSTR pszLegalArgs);
VOID PrintHuge(LPSTR psz);
PVOID EvalExp(LPSTR psz);

/*
 * entrypoint function type values
 */
#define NOARGS      0
#define STDARGS0    1
#define STDARGS1    2
#define STDARGS2    3
#define STDARGS3    4
#define STDARGS4    5
#define CUSTOM      9

/*
 * worker function prototype types
 */
typedef BOOL (* TYPE_NOARGS)(VOID);
typedef BOOL (* TYPE_STDARGS0)(DWORD);
typedef BOOL (* TYPE_STDARGS1)(DWORD, PVOID);
typedef BOOL (* TYPE_STDARGS2)(DWORD, PVOID, PVOID);
typedef BOOL (* TYPE_STDARGS3)(DWORD, PVOID, PVOID, PVOID);
typedef BOOL (* TYPE_STDARGS4)(DWORD, PVOID, PVOID, PVOID, PVOID);
typedef BOOL (* TYPE_CUSTOM)(DWORD, LPSTR);

/*
 * worker function proto-prototypes
 */
#define PROTO_NOARGS(name, opts)   BOOL I##name(VOID)
#define PROTO_STDARGS0(name, opts) BOOL I##name(DWORD options)
#define PROTO_STDARGS1(name, opts) BOOL I##name(DWORD options, PVOID param1)
#define PROTO_STDARGS2(name, opts) BOOL I##name(DWORD options, PVOID param1, PVOID param2)
#define PROTO_STDARGS3(name, opts) BOOL I##name(DWORD options, PVOID param1, PVOID param2, PVOID param3)
#define PROTO_STDARGS4(name, opts) BOOL I##name(DWORD options, PVOID param1, PVOID param2, PVOID param3, PVOID param4)
#define PROTO_CUSTOM(name, opts)   BOOL I##name(DWORD options, LPSTR pszArg)

/*
 * worker function prototypes (generated from exts.h)
 */
#define DOIT(name, h1, h2, opts, type) PROTO_##type(name, opts);
#include "exts.h"
#undef DOIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\usp10p.h ===
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//

#ifndef __uspp__
#define __uspp__
#ifdef __cplusplus
extern "C" {
#endif


////    USP10P.H
//
//      Private additions to USP header for use within USP and by the
//      NT5 complex script language pack only.



#if DBG
    #define USPALLOC(a,b)      (DG.psFile=__FILE__, DG.iLine=__LINE__, UspAllocCache(a, b))
    #define USPALLOCTEMP(a, b) (DG.psFile=__FILE__, DG.iLine=__LINE__, UspAllocTemp(a, b))
    #define USPFREE(a)         (DG.psFile=__FILE__, DG.iLine=__LINE__, UspFreeMem(a))
#else
    #define USPALLOC(a,b)      UspAllocCache(a, b)
    #define USPALLOCTEMP(a, b) UspAllocTemp(a, b)
    #define USPFREE(a)         UspFreeMem (a)
#endif



/////   LPK entry point serialisation
//
//      Since it is not possible to guarantee that Uniscribe and the
//      LPK receive process deatachment after all their clients, we
//      need to track Uniscribe shutdown.
//
//      At each LPK entrypoint, the LPK calls EnterLpk, and after each exit
//      it calls ExitLpk.
//
//      If Uniscribe is detached, or being detatched, EnterLpk fails. In this
//      case, the LPK entrypoint must do something safe and return directly.
//
//      Uniscribe maintains an LPK nesting level. If a process detach occurs
//      during LPK execution, a detachPending flag is set and will be processed
//      at the ExitLpk that pops all the nesting.


void LpkPresent();  // Used by LPK to disable cleanup at PROCESS_DETACH time




/////   UspAllocCache
//
//      Allocate long term memory for use caching font tables


HRESULT WINAPI UspAllocCache(
    int     iSize,              // In   required size in bytes
    void  **ppv);               // Out  Allocated address




/////   UspAllocTemp
//
//      Allocate short term memory with lifetime no more than an API call


HRESULT WINAPI UspAllocTemp(
    int     iSize,              // In   required size in bytes
    void  **ppv);               // Out  Allocated address




/////   UspFreeMem
//
//


HRESULT WINAPI UspFreeMem(
    void  *pv);                 // In   memory to be freed






/////   SCRIPT_STRING_ANALYSIS
//
//      This structure provides all parameters required for script analysis.
//
//

#define MAX_PLANE_0_FONT   13       // max number of non-surrogate fallback fonts
#define MAX_SURROGATE_FONT 16       // max number of the surrogate fallback fonts

// Max fallback fonts including user font (Cannot exceed 31 because usage is recorded in a bitset) 
// and Microsoft Sans Serif and surrogate fallback fonts.
#define MAX_FONT           MAX_PLANE_0_FONT + MAX_SURROGATE_FONT // 29 fonts
                                    
#define DUMMY_MAX_FONT  7           // dummy one for dummy entries

typedef struct tag_STRING_ANALYSIS {

// Input variables - Initialised by the caller

    HDC             hdc;            // Only required for shaping (GCP_Ligate && lpOrder or lpGlyphs arrays specified)

    DWORD           dwFlags;        // See ScriptStringAnalyse
    CHARSETINFO     csi;            // As returned by TranslateCharsetInfo

    // Input buffers

    WCHAR          *pwInChars;      // Unicode input string
    int             cInChars;       // String length
    int             iHotkeyPos;     // Derived from '&' positions if SSA_HOTKEY set

    int             iMaxExtent;     // Required maximum pixel width (used if clipping or fitting)
    const int      *piDx;           // Logical advance width array

    SCRIPT_CONTROL  sControl;
    SCRIPT_STATE    sState;

    SCRIPT_TABDEF  *pTabdef;        // Tabstop definition

    int             cMaxItems;      // Number of entries in pItems
    SCRIPT_ITEM    *pItems;

    // Low cost analysis output buffers
    // No shaping required when fLigate=FALSE
    // Must be at least as long as the input string

    BYTE           *pbLevel;        // Array of item level
    int            *piVisToLog;     // Visual to Logical mapping
    WORD           *pwLeftGlyph;    // Leftmost glyph of each logical item
    WORD           *pwcGlyphs;      // Count of glyphs in each logical item

    SCRIPT_LOGATTR *pLogAttr;       // Cursor points, word and line breaking (indexed in logical order)

    // High cost analysis output buffers
    // Require hDC to be set
    // Must be at least nGlyphs long.

    int             cMaxGlyphs;     // Max glyphs to create
    WORD           *pwGlyphs;       // Output glyph array
    WORD           *pwLogClust;     // logical to visual mapping
    SCRIPT_VISATTR *pVisAttr;       // Justification insertion points (visual order) and other flags
    int            *piAdvance;      // Advance widths
    int            *piJustify;      // Justified advance widths
    GOFFSET        *pGoffset;       // x,y combining character offsets


    // Font fallback

    DWORD           dwFallbacksUsed;// Bitmap of fallback fonts used
    BYTE           *pbFont;         // Font index per item, 0 means original user font

    
    // Obsolete - have to leave them here so the subsequent layout
    // remains unchanged for old LPK to use (wchao, 12/14/2000).
    // we used the first two slots in hf_dummy array for some needed flags
    // take a look to isAssociated and isPrinting
    
    SCRIPT_CACHE    sc_dummy[DUMMY_MAX_FONT];   
    HFONT           isAssociated;               // used as flag to indicate if the user selected font is associated
    HFONT           hf_dummy[DUMMY_MAX_FONT-1]; 

    int             iCurFont;       // 0 For users font
    LOGFONTA        lfA;            // Logfont from the original DC - only set if font fallback happens

// Output variables


    // Item analysis

    int             cItems;        // Number of items analysed == Index of terminal (sentinel) item in pItem


    // Generated glyphs and character measurements
    // Note that
    //  1) nOutGlyphs may be more or less than nInChars.
    //  2) nOutChars may be less than nInChars if fClip was requested.

    int             cOutGlyphs;     // Number of glyphs generated
    int             cOutChars;      // Number of characters generated
    ABC             abc;
    SIZE            size;           // Size of whole line (pixel width and height)

    // For client use

    void           *pvClient;

    
    // fallback font store

    // we store in the items sc[MAX_PLANE_0_FONT-1] and hf[MAX_PLANE_0_FONT-1] the data for Microsoft Sans Serif
    // font which has hight same as the selected user font height.
    // note that hf[1] will have the font data for Microsoft Sans Serif font too but
    // with adjusted height.
    // the items in sc and hf arrays which have index greater than or equal MAX_PLANE_0_FONT will be used 
    // for surrogate fallback fonts.
    
    SCRIPT_CACHE    sc[MAX_FONT];   // Script cache for each fallback, [0] is users font
    HFONT           hf[MAX_FONT];   // Handles to fallback fonts, [0] is users font

} STRING_ANALYSIS;


#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\winconp.h ===
#ifndef _WINCONP_
#define _WINCONP_

#ifdef __cplusplus
extern "C" {
#endif
#define ALTNUMPAD_BIT         0x04000000 // AltNumpad OEM char (copied from ntuser\inc\kbd.h)
#define CONSOLE_SELECTION_INVERTED      0x0010   // selection is inverted (turned off)
#define CONSOLE_SELECTION_VALID         (CONSOLE_SELECTION_IN_PROGRESS | \
                                         CONSOLE_SELECTION_NOT_EMPTY | \
                                         CONSOLE_MOUSE_SELECTION | \
                                         CONSOLE_MOUSE_DOWN)

#define ENABLE_INSERT_MODE     0x0020
#define ENABLE_QUICK_EDIT_MODE 0x0040
#define ENABLE_PRIVATE_FLAGS   0x0080

WINBASEAPI
BOOL
WINAPI
GetConsoleKeyboardLayoutNameA( OUT LPSTR );
WINBASEAPI
BOOL
WINAPI
GetConsoleKeyboardLayoutNameW( OUT LPWSTR );
#ifdef UNICODE
#define GetConsoleKeyboardLayoutName  GetConsoleKeyboardLayoutNameW
#else
#define GetConsoleKeyboardLayoutName  GetConsoleKeyboardLayoutNameA
#endif // !UNICODE

//
// Registry strings
//

#define CONSOLE_REGISTRY_STRING      (L"Console")
#define CONSOLE_REGISTRY_FONTSIZE    (L"FontSize")
#define CONSOLE_REGISTRY_FONTFAMILY  (L"FontFamily")
#define CONSOLE_REGISTRY_BUFFERSIZE  (L"ScreenBufferSize")
#define CONSOLE_REGISTRY_CURSORSIZE  (L"CursorSize")
#define CONSOLE_REGISTRY_WINDOWSIZE  (L"WindowSize")
#define CONSOLE_REGISTRY_WINDOWPOS   (L"WindowPosition")
#define CONSOLE_REGISTRY_FILLATTR    (L"ScreenColors")
#define CONSOLE_REGISTRY_POPUPATTR   (L"PopupColors")
#define CONSOLE_REGISTRY_FULLSCR     (L"FullScreen")
#define CONSOLE_REGISTRY_QUICKEDIT   (L"QuickEdit")
#define CONSOLE_REGISTRY_FACENAME    (L"FaceName")
#define CONSOLE_REGISTRY_FONTWEIGHT  (L"FontWeight")
#define CONSOLE_REGISTRY_INSERTMODE  (L"InsertMode")
#define CONSOLE_REGISTRY_HISTORYSIZE (L"HistoryBufferSize")
#define CONSOLE_REGISTRY_HISTORYBUFS (L"NumberOfHistoryBuffers")
#define CONSOLE_REGISTRY_HISTORYNODUP (L"HistoryNoDup")
#define CONSOLE_REGISTRY_COLORTABLE  (L"ColorTable%02u")
#define CONSOLE_REGISTRY_EXTENDEDEDITKEY                L"ExtendedEditKey"
#define CONSOLE_REGISTRY_EXTENDEDEDITKEY_CUSTOM         L"ExtendedEditkeyCustom"
#define CONSOLE_REGISTRY_WORD_DELIM                     L"WordDelimiters"
#define CONSOLE_REGISTRY_TRIMZEROHEADINGS               L"TrimLeadingZeros"
#define CONSOLE_REGISTRY_LOAD_CONIME                    L"LoadConIme"
#define CONSOLE_REGISTRY_ENABLE_COLOR_SELECTION			L"EnableColorSelection"


#if defined(FE_SB) // scotthsu
    /*
     * Starting code page
     */
#define CONSOLE_REGISTRY_CODEPAGE    (L"CodePage")
#endif

#if defined(FE_SB)
//
// registry strings on HKEY_LOCAL_MACHINE
//
#define MACHINE_REGISTRY_CONSOLE        (L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Console")
#define MACHINE_REGISTRY_CONSOLEIME     (L"ConsoleIME")


#define MACHINE_REGISTRY_CONSOLE_TTFONT (L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Console\\TrueTypeFont")


#define MACHINE_REGISTRY_CONSOLE_NLS    (L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Console\\Nls")


#define MACHINE_REGISTRY_CONSOLE_FULLSCREEN (L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Console\\FullScreen")
#define MACHINE_REGISTRY_INITIAL_PALETTE           (L"InitialPalette")
#define MACHINE_REGISTRY_COLOR_BUFFER              (L"ColorBuffer")
#define MACHINE_REGISTRY_COLOR_BUFFER_NO_TRANSLATE (L"ColorBufferNoTranslate")
#define MACHINE_REGISTRY_MODE_FONT_PAIRS           (L"ModeFontPairs")
#define MACHINE_REGISTRY_FS_CODEPAGE               (L"CodePage")


#define MACHINE_REGISTRY_EUDC    (L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\CodePage\\EUDCCodeRange")


//
// TrueType font list
//

// doesn't available bold when add BOLD_MARK on first of face name.
#define BOLD_MARK    (L'*')

typedef struct _TT_FONT_LIST {
    SINGLE_LIST_ENTRY List;
    UINT  CodePage;
    BOOL  fDisableBold;
    TCHAR FaceName1[LF_FACESIZE];
    TCHAR FaceName2[LF_FACESIZE];
} TTFONTLIST, *LPTTFONTLIST;
#endif // FE_SB



//
// State information structure
//

typedef struct _CONSOLE_STATE_INFO {
    UINT      Length;
    COORD     ScreenBufferSize;
    COORD     WindowSize;
    INT       WindowPosX;
    INT       WindowPosY;
    COORD     FontSize;
    UINT      FontFamily;
    UINT      FontWeight;
    WCHAR     FaceName[LF_FACESIZE];
    UINT      CursorSize;
    BOOL      FullScreen;
    BOOL      QuickEdit;
    BOOL      AutoPosition;
    BOOL      InsertMode;
    WORD      ScreenAttributes;
    WORD      PopupAttributes;
    BOOL      HistoryNoDup;
    UINT      HistoryBufferSize;
    UINT      NumberOfHistoryBuffers;
    COLORREF  ColorTable[ 16 ];
#if defined(FE_SB)
    /*
     * Startting code page
     */
    UINT      CodePage;
#endif // FE_SB
    HWND      hWnd;
    WCHAR     ConsoleTitle[1];
} CONSOLE_STATE_INFO, *PCONSOLE_STATE_INFO;


//
// Messages sent from properties applet to console server
//

#define CM_PROPERTIES_START          (WM_USER+200)
#define CM_PROPERTIES_UPDATE         (WM_USER+201)
#define CM_PROPERTIES_END            (WM_USER+202)


//
// Extended Line Edit
//

#define EK_INVALID  ' '

//
// Special key for previous word erase
//
#define EXTKEY_ERASE_PREV_WORD  (0x7f)


//
// Ensure the alignment is WORD boundary
//

#include <pshpack2.h>

typedef struct {
    WORD wMod;
    WORD wVirKey;
    WCHAR wUnicodeChar;
} ExtKeySubst;

typedef struct {
    ExtKeySubst keys[3];    // 0: Ctrl
                            // 1: Alt
                            // 2: Ctrl+Alt
} ExtKeyDef;

typedef ExtKeyDef ExtKeyDefTable['Z' - 'A' + 1];

typedef struct {
    DWORD dwVersion;
    DWORD dwCheckSum;
    ExtKeyDefTable table;
} ExtKeyDefBuf;

//
// Restore the previous alignment
//

#include <poppack.h>


#ifdef __cplusplus
}
#endif

#endif // _WINCONP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\w32w64.h ===
/****************************** Module Header ******************************\
* Module Name: w32w64.h
*
* Copyright (c) Microsoft Corporation. All rights reserved.
*
* This header file contains macros used to access kernel mode data
* from user mode for wow64.
*
* History:
* 08-18-98 PeterHal     Created.
\***************************************************************************/

#ifndef _W32W64_
#define _W32W64_


/*
 * Kernel32 includes this structure, but we don't want to use _ptr64 in it yet.
 * Kernel32 does not use any shared memory itself.
 */
#if defined(BUILD_WOW6432) && !defined(_KERNEL32_)

    #define KPTR_MODIFIER __ptr64

    typedef VOID * __ptr64          KERNEL_PVOID;
    typedef unsigned __int64        KERNEL_UINT_PTR;
    typedef __int64                 KERNEL_INT_PTR;
    typedef unsigned __int64        KERNEL_ULONG_PTR;
    typedef __int64                 KERNEL_LONG_PTR;

    #define KHANDLE_NULL            0

    #ifdef STRICT
    typedef void * KPTR_MODIFIER KHANDLE;
    #define DECLARE_KHANDLE(name) typedef struct name##__ * KPTR_MODIFIER K ## name
    #else
    typedef KERNEL_PVOID KHANDLE;
    #define DECLARE_KHANDLE(name) typedef KHANDLE K ## name
    #endif

#else

    #define KPTR_MODIFIER

    typedef PVOID                   KERNEL_PVOID;
    typedef UINT_PTR                KERNEL_UINT_PTR;
    typedef INT_PTR                 KERNEL_INT_PTR;
    typedef ULONG_PTR               KERNEL_ULONG_PTR;
    typedef LONG_PTR                KERNEL_LONG_PTR;

    #define KHANDLE_NULL            NULL

    #define DECLARE_KHANDLE(name) typedef name K ## name
    typedef HANDLE KHANDLE;

#endif



#endif // _W32W64_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\windowsp.h ===
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    windowsp.h
Abstract:

    Master include file for Windows applications.

--*/
#ifndef _WINDOWSP_
#define _WINDOWSP_
#endif /* _WINDOWSP_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\wingdip.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wingdi.h

Abstract:

    Procedure declarations, constant definitions and macros for the GDI
    component.

--*/
#ifndef _WINGDIP_
#define _WINGDIP_
#ifdef __cplusplus
extern "C" {
#endif
// BitBlt RTL mirroring rop (RTL_MIRRORING)
// RTL Layout Constants (RTL_MIRRORING)
// SetLayout Metafile call (RTL_MIRRORING)
#define LCS_DEVICE_RGB                  0x00000001L
#define LCS_DEVICE_CMYK                 0x00000002L
#define BI_CMYK      10L
#define BI_CMYKRLE8  11L
#define BI_CMYKRLE4  12L
#define CAPS1         94    /* Extra Caps */

/* CAPS1 (Win 9x internal) */
#define C1_TRANSPARENT      0x0001
#define TC_TT_ABLE          0x0002
#define C1_TT_CR_ANY        0x0004
#define C1_EMF_COMPLIANT    0x0008
#define C1_DIBENGINE        0x0010
#define C1_GAMMA_RAMP       0x0020 /* CM_GAMMA_RAMP for NT */
#define C1_DIC              0x0040 /* CM_DEVICE_ICM for NT */
#define C1_REINIT_ABLE      0x0080
#define C1_GLYPH_INDEX      0x0100
#define C1_BIT_PACKED       0x0200
#define C1_BYTE_PACKED      0x0400
#define C1_COLORCURSOR      0x0800
#define C1_CMYK_ABLE        0x1000 /* CM_CMYK_COLOR for NT */
#define C1_SLOW_CARD        0x2000

/* CAPS1 (NT 5 internal) */
#define C1_MIRROR_DEVICE    0x4000

#define CBM_CREATEDIB   0x02L   /* create DIB bitmap */
#define DMDUP_LAST      DMDUP_HORIZONTAL
#define DMTT_LAST             DMTT_DOWNLOAD_OUTLINE
#define DMDO_LAST       DMDO_270
#define DMDFO_LAST      DMDFO_CENTER
#define DMDISPLAYFLAGS_VALID    0x00000004
#define DMICMMETHOD_LAST    DMICMMETHOD_DEVICE
#define DMICM_LAST          DMICM_ABS_COLORIMETRIC
#define DMMEDIA_LAST          DMMEDIA_GLOSSY
#define DMDITHER_LAST       DMDITHER_GRAYSCALE

/* EnumDisplayDevices */

#if (_WIN32_WINNT >= 0x0501)
#define EDD_DISPLAY_DEVICE_PRUNED       0x00000001
#endif /* _WIN32_WINNT >= 0x0501 */
#define DISPLAY_DEVICE_POWERED_OFF         0x80000000
#define DISPLAY_DEVICE_ACPI                0x40000000
#define DISPLAY_DEVICE_DUALVIEW            0x20000000
#define DISPLAY_DEVICE_PRUNE_FREQ          0x80000000
#define DISPLAY_DEVICE_PRUNE_RESOLUTION    0x40000000

WINGDIAPI int  WINAPI GetTextFaceAliasW(HDC hdc,int c,LPWSTR pwsz);
WINGDIAPI HBITMAP SetBitmapAttributes(HBITMAP hbm, DWORD dwFlags);
WINGDIAPI HBITMAP ClearBitmapAttributes(HBITMAP hbm, DWORD dwFlags);
WINGDIAPI DWORD   GetBitmapAttributes(HBITMAP hbm);
#define SBA_STOCK 0x00000001
WINGDIAPI HBRUSH SetBrushAttributes(HBRUSH hbr, DWORD dwFlags);
WINGDIAPI HBRUSH ClearBrushAttributes(HBRUSH hbr, DWORD dwFlags);
WINGDIAPI DWORD  GetBrushAttributes(HBRUSH hbr);
/* DC_MANUFACTURER is DC_ICC_MANUFACTURER in 16 bit PRINT.H */
/* DC_MODEL is DC_ICC_MODEL in 16 bit PRINT.H               */
HANDLE WINAPI SetObjectOwner( IN HGDIOBJ, IN HANDLE);
// Mirroring APIs (RTL_MIRRORING)
#if(WINVER >= 0x0500)
WINGDIAPI BOOL  WINAPI MirrorRgn(IN HWND, IN HRGN);
WINGDIAPI DWORD WINAPI SetLayoutWidth(IN HDC, IN LONG, IN DWORD);
#endif /* WINVER >= 0x0500 */

#if (_WIN32_WINNT >= 0x0500)

//
// alpha blend flags
//

#define AC_USE_HIGHQUALITYFILTER             0x01
#define AC_MIRRORBITMAP                      0x80

WINGDIAPI BOOL  WINAPI GdiAlphaBlend( IN HDC, IN int, IN int, IN int, IN int, IN HDC, IN int, IN int, IN int, IN int, IN BLENDFUNCTION);

WINGDIAPI BOOL  WINAPI GdiTransparentBlt(IN HDC,IN int,IN int,IN int,IN int,IN HDC,IN int,IN int,IN int,IN int,IN UINT);

WINGDIAPI BOOL  WINAPI GdiGradientFill( IN HDC, IN PTRIVERTEX, IN ULONG, IN PVOID, IN ULONG, IN ULONG);

#endif



#if (_WIN32_WINNT >= 0x0501)

#ifndef DS_ENABLE_BLT
#define DS_ENABLE_BLT 0
#endif

#define DS_MAGIC                'DrwS'
#define DS_SETTARGETID          0
#define DS_SETSOURCEID          1

#define DS_NINEGRIDID           9

#if DS_ENABLE_BLT
#define DS_BLTID                10
#define DS_SETBLENDID           11
#define DS_SETCOLORKEYID        12
#endif

typedef struct _DS_HEADER
{
    ULONG   magic;
} DS_HEADER;

typedef struct _DS_SETTARGET
{
    ULONG   ulCmdID;
    ULONG   hdc;
    RECTL   rclDstClip;
} DS_SETTARGET;

typedef struct _DS_SETSOURCE
{
    ULONG   ulCmdID;
    ULONG   hbm;
} DS_SETSOURCE;

#define DSDNG_STRETCH         0x01
#define DSDNG_TILE            0x02
#define DSDNG_PERPIXELALPHA   0x04
#define DSDNG_TRANSPARENT     0x08
#define DSDNG_MUSTFLIP        0x10
#define DSDNG_TRUESIZE        0x20

typedef struct _DS_NINEGRIDINFO
{
    ULONG            flFlags;
    LONG             ulLeftWidth;
    LONG             ulRightWidth;
    LONG             ulTopHeight;
    LONG             ulBottomHeight;
    COLORREF         crTransparent;
} DS_NINEGRIDINFO;

typedef struct _DS_NINEGRID
{
    ULONG            ulCmdID;
    RECTL            rclDst;
    RECTL            rclSrc;
    DS_NINEGRIDINFO  ngi;
} DS_NINEGRID;

#if DS_EANBLE_BLT

#define DSBLT_HTILE           0x01
#define DSBLT_VTILE           0x02
#define DSBLT_ALPHABLEND      0x04
#define DSBLT_TRANSPARENT     0x08

typedef struct _DS_BLT
{
    ULONG            ulCmdID;
    RECTL            rclDst;
    RECTL            rclSrc;
    FLONG            flFlags;
} DS_BLT;

typedef struct _DS_SETBLEND
{
    BLENDFUNCTION   blendFunction;
} DS_SETBLEND;

typedef struct _DS_SETCOLORKEY
{
    COLORREF         crColorKey;
} DS_SETCOLORKEY;
#endif

WINGDIAPI BOOL  WINAPI GdiDrawStream( IN HDC, IN ULONG, IN VOID *);

#endif
// Ansi version of CreateColorSpace
// (Windows 98 comaptible record)
// Unicode version of StartDoc record
// SetLayout Metafile Record (RTL_MIRRORING)
#ifdef __cplusplus
}
#endif

#define CCB_NOVIDEOMEMORY       0x01000000

// Old fields that Chicago won't support that we can't publically
// support anymore

#define HS_SOLIDCLR         6
#define HS_DITHEREDCLR      7
#define HS_SOLIDTEXTCLR     8
#define HS_DITHEREDTEXTCLR  9
#define HS_SOLIDBKCLR       10
#define HS_DITHEREDBKCLR    11
#define HS_API_MAX          12

#define DIB_PAL_INDICES     2 /* No color table indices into surf palette */

// Private indicies for GetStockObject over the CS interface.

#define PRIV_STOCK_COLORSPACE   (STOCK_LAST +  1)
#define PRIV_STOCK_BITMAP       (STOCK_LAST +  2)
#define PRIV_STOCK_LAST         PRIV_STOCK_BITMAP

#define DCB_WINDOWMGR   0x00008000L

// GetTransform flags.

#define XFORM_WORLD_TO_PAGE       0x0203
#define XFORM_WORLD_TO_DEVICE     0x0204
#define XFORM_PAGE_TO_DEVICE      0x0304
#define XFORM_PAGE_TO_WORLD       0x0302
#define XFORM_DEVICE_TO_WORLD     0x0402
#define XFORM_DEVICE_TO_PAGE      0x0403


#if(WINVER >= 0x0500)
#define EMR_DRAWESCAPE                 105
#define EMR_EXTESCAPE                  106
// Unicode version of StartDoc record
#define EMR_STARTDOC                   107
#define EMR_SMALLTEXTOUT               108
#define EMR_FORCEUFIMAPPING            109
#define EMR_NAMEDESCAPE                110
#define EMR_SETLINKEDUFIS              119
#define EMR_SETTEXTJUSTIFICATION       120
#endif /* WINVER >= 0x0500 */

enum DCTYPE {
    DCTYPE_DIRECT,
    DCTYPE_MEMORY,
    DCTYPE_INFO};

// the following structure is only used for GetETM postscript escape

typedef struct _EXTTEXTMETRIC {
    SHORT  etmSize;
    SHORT  etmPointSize;
    SHORT  etmOrientation;
    SHORT  etmMasterHeight;
    SHORT  etmMinScale;
    SHORT  etmMaxScale;
    SHORT  etmMasterUnits;
    SHORT  etmCapHeight;
    SHORT  etmXHeight;
    SHORT  etmLowerCaseAscent;
    SHORT  etmLowerCaseDescent;
    SHORT  etmSlant;
    SHORT  etmSuperScript;
    SHORT  etmSubScript;
    SHORT  etmSuperScriptSize;
    SHORT  etmSubScriptSize;
    SHORT  etmUnderlineOffset;
    SHORT  etmUnderlineWidth;
    SHORT  etmDoubleUpperUnderlineOffset;
    SHORT  etmDoubleLowerUnderlineOffset;
    SHORT  etmDoubleUpperUnderlineWidth;
    SHORT  etmDoubleLowerUnderlineWidth;
    SHORT  etmStrikeOutOffset;
    SHORT  etmStrikeOutWidth;
    WORD   etmNKernPairs;
    WORD   etmNKernTracks;
} EXTTEXTMETRIC;

// the following structure is only used for GETPAIRKERNTABLE escape

#pragma pack(1)
typedef struct _KERNPAIR
{
    WORD  wBoth;
    SHORT sAmount;
} KERNPAIR, *LPKERNPAIR;
#pragma pack()

BOOL
GetETM(
    HDC hdc,
    EXTTEXTMETRIC *petm);


HFONT
APIENTRY
GetHFONT(
    HDC);


HANDLE         GdiCreateLocalMetaFilePict(HANDLE hRemote);
HENHMETAFILE   GdiCreateLocalEnhMetaFile(HANDLE hRemote);
HANDLE         GdiConvertBitmapV5(LPBYTE,int,HPALETTE,UINT);
HANDLE         GdiConvertMetaFilePict(HANDLE hmfp);
HANDLE         GdiConvertEnhMetaFile(HENHMETAFILE hmf);
HDC            GdiConvertAndCheckDC(HDC hdc);
HBRUSH         GdiConvertBrush(HBRUSH hbrush);
HDC            GdiConvertDC(HDC hdc);
HRGN           GdiConvertRegion(HRGN hrgn);
BOOL           GdiValidateHandle(HANDLE hObj);
BOOL           GdiReleaseDC(HDC hdc);
HANDLE         GdiFixUpHandle(HANDLE h);
int            GdiGetCharDimensions(HDC hdc,TEXTMETRICW *lptm,LPINT lpcy);
DWORD          GdiGetCodePage(HDC hdc);

// Driver-specific pixel format support in GDI
int  APIENTRY GdiDescribePixelFormat(HDC, int, UINT, LPPIXELFORMATDESCRIPTOR);
BOOL APIENTRY GdiSetPixelFormat(HDC, int);
BOOL APIENTRY GdiSwapBuffers(HDC);

// OpenGL metafile support in GDI
BOOL APIENTRY GdiAddGlsRecord(HDC hdc, DWORD cb, BYTE *pb, LPRECTL prclBounds);
BOOL APIENTRY GdiAddGlsBounds(HDC hdc, LPRECTL prclBounds);
BOOL APIENTRY GdiIsMetaPrintDC(HDC hdc);

// OpenGL metafile support in OpenGL
BOOL APIENTRY GlmfInitPlayback(HDC hdc, ENHMETAHEADER *pemh,
                               LPRECTL prclDest);
BOOL APIENTRY GlmfBeginGlsBlock(HDC hdc);
BOOL APIENTRY GlmfPlayGlsRecord(HDC hdc, DWORD cb, BYTE *pb,
                                LPRECTL prclBounds);
BOOL APIENTRY GlmfEndGlsBlock(HDC hdc);
BOOL APIENTRY GlmfEndPlayback(HDC hdc);
BOOL APIENTRY GlmfCloseMetaFile(HDC hdc);

BOOL  APIENTRY GdiPlayJournal(HDC,LPWSTR,DWORD,DWORD,int);

typedef int (CALLBACK* EMFPLAYPROC)( HDC, INT, HANDLE );

// User Mode Driver Unload

BOOL WINAPI GdiArtificialDecrementDriver(
    LPWSTR       pDriverDllName,
    DWORD        dwDriverAttributes
);

// Print processor interfaces and definitions

#define  EMF_PP_NORMAL      0x01
#define  EMF_PP_FORM        0x02

#define  EMF_PP_COLOR_OPTIMIZATION  0x01

BOOL WINAPI GdiPlayEMF(
    LPWSTR      pwszPrinterName,
    LPDEVMODEW  pDevmode,
    LPWSTR      pwszDocName,
    EMFPLAYPROC pfnPageQueryFn,
    HANDLE      hPageQuery
);

HANDLE WINAPI GdiGetSpoolFileHandle(
    LPWSTR     pwszPrinterName,
    LPDEVMODEW pDevmode,
    LPWSTR     pwszDocName);

BOOL WINAPI GdiDeleteSpoolFileHandle(
    HANDLE     SpoolFileHandle);

DWORD WINAPI GdiGetPageCount(
    HANDLE     SpoolFileHandle);

HDC WINAPI GdiGetDC(
    HANDLE     SpoolFileHandle);

HANDLE WINAPI GdiGetPageHandle(
    HANDLE     SpoolFileHandle,
    DWORD      Page,
    LPDWORD    pdwPageType);

BOOL WINAPI GdiStartDocEMF(
    HANDLE     SpoolFileHandle,
    DOCINFOW   *pDocInfo);

BOOL WINAPI GdiStartPageEMF(
    HANDLE     SpoolFileHandle);

BOOL WINAPI GdiPlayPageEMF(
    HANDLE     SpoolFileHandle,
    HANDLE     hemf,
    RECT       *prectDocument,
    RECT       *prectBorder,
    RECT       *prectClip);

BOOL WINAPI GdiPlayPrivatePageEMF(
    HANDLE       SpoolFileHandle,
    HENHMETAFILE hEnhMetaFile,
    RECT         *prectDocument);

BOOL WINAPI GdiEndPageEMF(
    HANDLE     SpoolFileHandle,
    DWORD      dwOptimization);

BOOL WINAPI GdiEndDocEMF(
    HANDLE     SpoolFileHandle);

BOOL WINAPI GdiGetDevmodeForPage(
    HANDLE     SpoolFileHandle,
    DWORD      dwPageNumber,
    PDEVMODEW  *pCurrDM,
    PDEVMODEW  *pLastDM);

BOOL WINAPI GdiResetDCEMF(
    HANDLE     SpoolFileHandle,
    PDEVMODEW  pCurrDM);


ULONG cGetTTFFromFOT(WCHAR *,ULONG,WCHAR *,FLONG *,FLONG *, DWORD *, BOOL);
BOOL bMakePathNameW (WCHAR *, WCHAR *, WCHAR **, FLONG *);
BOOL bInitSystemAndFontsDirectoriesW(WCHAR **, WCHAR **);
#define FONT_IN_FONTS_DIR     1
#define FONT_IN_SYSTEM_DIR    2
#define FONT_RELATIVE_PATH    4
#define FONT_ISNOT_FOT        8

#ifdef LANGPACK
BOOL LpkInitialize();
VOID APIENTRY GdiSetLastError(ULONG iError);

#define FRINFO_BITMAP   1
#define FRINFO_VECTOR   2
#define FRINFO_OTHER    3

typedef struct tagREALIZATION_INFO {
    UINT uFontTechnology;
    UINT uRealizationID;
    UINT uFontFileID;
} REALIZATION_INFO, *PREALIZATION_INFO;

BOOL APIENTRY GdiRealizationInfo(HDC, PREALIZATION_INFO);
WINGDIAPI BOOL  WINAPI GetTextExtentExPointWPri(HDC, LPCWSTR, int, int, LPINT, LPINT, LPSIZE);
BOOL APIENTRY GdiIsPlayMetafileDC(HDC hdc);
#endif

//
// Font Enumeration defines
//

#define FE_FILTER_NONE        0L
#define FE_FILTER_TRUETYPE    1L
#define FE_AA_ON              2L      // force antialiased text
#define FE_SET_AA             4L
#define FE_AA_ANY_SIZE        8L
#define FE_CT_ON             16L      // set antialiazing type to ClearType
#define FE_SET_CT            32L
#define FE_CT_BGR            64L      // set color stripes order RGB vs BGR
#define FE_SET_RGB_BGR      128L
#define FE_CT_HORSTRIPES    256L      // set color stripes direction VERTICAL vs HORIZINTAL
#define FE_SET_STRIPES_DIR  512L
#define FE_SET_CONTRAST    1024L

#define DEFAULT_CT_CONTRAST 1400

ULONG
WINAPI SetFontEnumeration (
    ULONG   ulType);


//
// Private Control Panel entry point to enumerate fonts by file.
//

#define GFRI_NUMFONTS       0L
#define GFRI_DESCRIPTION    1L
#define GFRI_LOGFONTS       2L
#define GFRI_ISTRUETYPE     3L
#define GFRI_TTFILENAME     4L
#define GFRI_ISREMOVED      5L
#if defined(FE_SB) // for GetFontResourceInfo()
#define GFRI_FONTMETRICS    6L
#endif // FE_SB

// file path separator for Add/RemoveFontResourceA/W

#define PATH_SEPARATOR L'|'


WINGDIAPI BOOL
WINAPI
GetFontResourceInfoW(
    LPWSTR  lpPathname,
    LPDWORD lpBytes,
    LPVOID  lpBuffer,
    DWORD   iType);

BOOL WINAPI GdiGetMessage(VOID *pv);


typedef enum _GdiCallId {
    MapFontFile_        = 1
  , UnmapFontFile_      = 2
  , GetFilePath_        = 3
  , LpkInstalled_       = 4
  , ComputeGlyphSet_    = 5
  , LoadModuleForWrite_ = 6
  , FreeModule_         = 7
  , GetFileChangeTime_  = 8
  , GetCurrentCodePage_ = 9
} GdiCallId;

typedef struct _GDICALL {
    GdiCallId Id;
    union {
        struct {
            ULONG iFile;
            PVOID pvUser;
            ULONG ByteCount;
        } MapFontFileArgs;
        struct {
            ULONG iFile;
        } UnmapFontFileArgs;
        struct {
            BOOL ReturnValue;
            HANDLE h;
            WCHAR (*pDest)[MAX_PATH+1];
        } GetFilePathArgs;
        struct {
            BOOL ReturnValue;
        } LpkInstalledArgs;
        struct {
                           BOOL   ReturnValue;
            struct _FD_GLYPHSET **ppGlyphSet;
            union {
                          ULONG   ByteCount;
            struct _FD_GLYPHSET  *pGlyphSet;
                                           };
                            INT   nCodePage;
                            INT   nFirstChar;
                            INT   cChars;
        } ComputeGlyphSetArgs;
        struct {
                    HANDLE ReturnValue;
                     WCHAR *pwsz;       // pointer to string
                     ULONG cj;
        } LoadModuleForWriteArgs;
        struct {
            HANDLE h;
        } FreeModuleArgs;
        struct {
            BOOL ReturnValue;
            HANDLE h;
            LARGE_INTEGER Time;
        } GetFileChangeTimeArgs;
        struct {
            USHORT OemCodePage;
            USHORT AnsiCodePage;
        } GetCurrentCodePageArgs;
    };
} GDICALL;

BOOL WINAPI GdiCall(GDICALL *pCall);

typedef struct  _CHWIDTHINFO
{
    LONG    lMaxNegA;
    LONG    lMaxNegC;
    LONG    lMinWidthD;
} CHWIDTHINFO,  *PCHWIDTHINFO;

BOOL
APIENTRY
GetCharWidthInfo(
    HDC            hdc,
    PCHWIDTHINFO   pChWidthInfo
);


/**************************************************************************\
*
*   tmdiff struc, contains the fields that are possibly different
*   between ansi and unicode versions of TEXTMETRICA and TEXTMETRICW
*
*   ONLY independent quantities are put into the strucure. Dependent ones,
*   such as tmDescent and maybe tmOverhang should be computed on the fly
*
*   tmDesc = tmHt - tmAsc
*   tmOverhang = tt ? 0 : ((tmHt - 1)/2 + (BOLD ? 1 : 0))
*
\**************************************************************************/

// this is a font with nonnegative a and c spaces, good for console

#if (_WIN32_WINNT >= 0x0500)

typedef struct _TMDIFF
{
    ULONG       cjotma;     // size of OUTLINETEXTMETRICSA
    BYTE        chFirst;
    BYTE        chLast;
    BYTE        chDefault;
    BYTE        chBreak;
} TMDIFF; // DIFF between TEXTMETRICA and TEXTMETRICW

#else

typedef struct _TMDIFF
{
    ULONG       cjotma;     // size of OUTLINETEXTMETRICSA
    FLONG       fl;         // flags, for now only TMD_NONNEGATIVE_AC
    BYTE        chFirst;
    BYTE        chLast;
    BYTE        chDefault;
    BYTE        chBreak;
} TMDIFF; // DIFF between TEXTMETRICA and TEXTMETRICW

#endif // (_WIN32_WINNT >= 0x0500)

// used to return correct GetTextMetricsA/W

typedef struct _TMW_INTERNAL
{
    TEXTMETRICW tmw;
    TMDIFF      tmdTmw;
} TMW_INTERNAL;

#if (_WIN32_WINNT >= 0x0500)

// this one is only used in enumeration,
// new textmetricsex returned by EnumFontFamiliesEx, fontsignature is returned

typedef struct _NTMW_INTERNAL
{
    TMDIFF           tmdNtmw;
    ENUMTEXTMETRICW  entmw;
} NTMW_INTERNAL;

#else

#define TMD_NONNEGATIVE_AC 1

typedef struct _NTMW_INTERNAL
{
    NEWTEXTMETRICEXW ntmw;
    TMDIFF           tmd;
} NTMW_INTERNAL;

#endif // (_WIN32_WINNT >= 0x0500)

// flags for AddFontResourceW
// AFRW_ADD_LOCAL_FONT : add ONLY if it is a local font
// AFRW_ADD_REMOTE_FONT: add ONLY if it is NOT local font
// if neither one LOCAL or REMOTE bit is set, just add the font

#define AFRW_ADD_LOCAL_FONT  0X01
#define AFRW_ADD_REMOTE_FONT 0X02
#define FRW_EMB_TID        0x04
#define FRW_EMB_PID        0x08
#define FRW_PVT_CLEANUP    0x80

#if (_WIN32_WINNT >= 0x0500)
int GdiAddFontResourceW( LPWSTR, DWORD, DESIGNVECTOR *);
#endif

// Win31 compatibility stuff
// GetAppCompatFlags flag values

#define GACF_IGNORENODISCARD        0x00000001
#define GACF_FORCETEXTBAND          0x00000002
#define GACF_ONELANDGRXBAND         0x00000004
#define GACF_IGNORETOPMOST          0x00000008
#define GACF_CALLTTDEVICE           0x00000010
#define GACF_MULTIPLEBANDS          0x00000020
#define GACF_ALWAYSSENDNCPAINT      0x00000040
#define GACF_EDITSETTEXTMUNGE       0x00000080
#define GACF_MOREEXTRAWNDWORDS      0x00000100
#define GACF_TTIGNORERASTERDUPE     0x00000200
#define GACF_HACKWINFLAGS           0x00000400
#define GACF_DELAYHWHNDSHAKECHK     0x00000800
#define GACF_ENUMHELVNTMSRMN        0x00001000
#define GACF_ENUMTTNOTDEVICE        0x00002000
#define GACF_SUBTRACTCLIPSIBS       0x00004000
#define GACF_FORCETTGRAPHICS        0x00008000
#define GACF_NOHRGN1                0x00010000
#define GACF_NCCALCSIZEONMOVE       0x00020000
#define GACF_SENDMENUDBLCLK         0x00040000
#define GACF_30AVGWIDTH             0x00080000
#define GACF_GETDEVCAPSNUMLIE       0x00100000

#define GACF_WINVER31               0x00200000      //
#define GACF_INCREASESTACK          0x00400000      //
#define GACF_HEAPSLACK              0x00400000      //
#define GACF_FORCEWIN31DEVMODESIZE  0x00800000      // (replaces PEEKMESSAGEIDLE)
#define GACF_31VALIDMASK            0xFFE4800C      //
#define GACF_DISABLEFONTASSOC       0x01000000      // Used in FE only
#define GACF_JAPANESCAPEMENT        0x01000000      // Used in FE only
#define GACF_IGNOREFAULTS           0x02000000      //
#define GACF_NOEMFSPOOLING          0x04000000      //
#define GACF_RANDOM3XUI             0x08000000      //
#define GACF_USEPRINTINGESCAPES     0x00000004      // re-use GACF_ONELANDGRXBAND
#define GACF_FORCERASTERMODE        0x00008000      // re-use GACF_FORCETTGRAPHICS
#define GACF_DONTJOURNALATTACH      0x10000000      //
#define GACF_DISABLEDBCSPROPTT      0x20000000      // Used in FE only
#define GACF_NOBRUSHCACHE           0x20000000      // re-use GACF_DISABLEDBCSPROPTT
#define GACF_MIRRORREGFONTS         0x40000000      //
#define GACF_NOSMOOTHSCROLLING      0x40000000      // re-use GACF_MIRRORREGFONTS
#define GACF_TTIGNOREDDEVICE        0x80000000      // Used in Word97-J only
#define GACF_NOSCROLLBARCTXMENU     0x80000000      // re-use GACF_TTIGNOREDDEVICE #119380


LPDEVMODEW
WINAPI
GdiConvertToDevmodeW(
    LPDEVMODEA pdma
    );




typedef struct _UNIVERSAL_FONT_ID {
    ULONG   CheckSum;
    ULONG   Index;
} UNIVERSAL_FONT_ID, *PUNIVERSAL_FONT_ID;

WINGDIAPI
INT
WINAPI
GdiQueryFonts(
    PUNIVERSAL_FONT_ID,
    ULONG,
    PLARGE_INTEGER
    );


WINGDIAPI
BOOL
WINAPI
GdiConsoleTextOut(
    HDC hdc,
    POLYTEXTW *lpto,
    UINT nStrings,
    RECTL *prclBounds
    );

typedef enum _FULLSCREENCONTROL {
    FullscreenControlEnable,               // 0
    FullscreenControlDisable,              // 1
    FullscreenControlSetCursorPosition,    // 2
    FullscreenControlSetCursorAttributes,  // 3
    FullscreenControlRegisterVdm,          // 4
    FullscreenControlSetPalette,           // 5
    FullscreenControlSetColors,            // 6
    FullscreenControlLoadFont,             // 7
    FullscreenControlRestoreHardwareState, // 8
    FullscreenControlSaveHardwareState,    // 9
    FullscreenControlCopyFrameBuffer,      // a
    FullscreenControlReadFromFrameBuffer,  // b
    FullscreenControlWriteToFrameBuffer,   // c
    FullscreenControlReverseMousePointer,  // d
    FullscreenControlSetMode,              // e
    FullscreenControlSetScreenInformation, // f
    FullscreenControlSpecificVideoControl, // 10 (for specific NEC PC-98)
    FullscreenControlCopyFrameBufferDB,    // 11
    FullscreenControlWriteToFrameBufferDB, // 12
    FullscreenControlReverseMousePointerDB // 13
} FULLSCREENCONTROL;

WINGDIAPI
BOOL
WINAPI
GdiFullscreenControl(
    FULLSCREENCONTROL FullscreenCommand,
    PVOID  FullscreenInuut,
    DWORD  FullscreenInputLength,
    PVOID  FullscreenOutput,
    PULONG FullscreenOutputLength
    );



#define IS_ANY_DBCS_CHARSET( CharSet )                              \
                   ( ((CharSet) == SHIFTJIS_CHARSET)    ? TRUE :    \
                     ((CharSet) == HANGEUL_CHARSET)     ? TRUE :    \
                     ((CharSet) == CHINESEBIG5_CHARSET) ? TRUE :    \
                     ((CharSet) == GB2312_CHARSET)      ? TRUE : FALSE )


typedef struct _UMTHDR {
    ULONG cjSize;
    ULONG ulType;
    ULONG ulReserved1;
    ULONG ulReserved2;
} UMTHDR;

WINGDIAPI
ULONG
WINAPI
GdiPrinterThunk(
    UMTHDR *pumth,
    PVOID pvOut,
    ULONG cjOut
    );

#define GPT_ERROR   0xffffffff

#endif /* _WINGDIP_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\winsprlp.h ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    WinSpolp.h

Abstract:

    Header file for Print APIs

Revision History:

--*/
#ifndef _WINSPOLP_
#define _WINSPOLP_
#ifdef __cplusplus
extern "C" {
#endif
#define PRINTER_ATTRIBUTE_UPDATEWININI      0x80000000
typedef struct _ADDJOB_INFO_2W {
    LPWSTR    pData;
    DWORD     JobId;
} ADDJOB_INFO_2W, *PADDJOB_INFO_2W, *LPADDJOB_INFO_2W;

#define DRIVER_INFO_PRIVATE_LEVEL         100
#define DRIVER_INFO_VERSION_LEVEL         DRIVER_INFO_PRIVATE_LEVEL + 1
//
// You must change RPC_DRIVER_INFCAT_INFO_1 in winspl.idl if you
// want to change structure DRIVER_INFCAT_INFO_1
//
typedef struct _DRIVER_FINFCAT_INFO_1 {
    PCWSTR  pszCatPath;         // full path to the dirver cat file
    PCWSTR  pszCatNameOnSystem; // new cat name used under CatRoot
} DRIVER_INFCAT_INFO_1;

//
// You must change RPC_DRIVER_INFCAT_INFO_2 in winspl.idl if you
// want to change structure DRIVER_INFCAT_INFO_2
//
typedef struct _DRIVER_INFCAT_INFO_2 {
    PCWSTR  pszCatPath;       // full path to the dirver cat file
    PCWSTR  pszInfPath;       // full path to the dirver INF file
    PCWSTR  pszSrcLoc;        // Information abou the Source Inf
    DWORD   dwMediaType;      // Source Media Type
    DWORD   dwCopyStyle;      // Copy Style
} DRIVER_INFCAT_INFO_2;

typedef enum {
    DRIVER_FILE     = 0,
    CONFIG_FILE     = 1,
    DATA_FILE       = 2,
    HELP_FILE       = 3,
    DEPENDENT_FILE  = 4
} DRIVER_FILE_TYPE;

typedef struct _DRIVER_FILE_INFO    {
    DWORD               FileNameOffset;
    DRIVER_FILE_TYPE    FileType;
    DWORD               FileVersion;
} DRIVER_FILE_INFO, *PDRIVER_FILE_INFO, *LPDRIVER_FILE_INFO;

typedef struct _DRIVER_INFO_VERSION {
    DWORD                   cVersion;
    LPWSTR                  pName;
    LPWSTR                  pEnvironment;
    LPDRIVER_FILE_INFO      pFileInfo;
    DWORD                   dwFileCount;
    LPWSTR                  pMonitorName;
    LPWSTR                  pDefaultDataType;
    LPWSTR                  pszzPreviousNames;
    FILETIME                ftDriverDate;
    DWORDLONG               dwlDriverVersion;
    LPWSTR                  pszMfgName;
    LPWSTR                  pszOEMUrl;
    LPWSTR                  pszHardwareID;
    LPWSTR                  pszProvider;
} DRIVER_INFO_VERSION, *PDRIVER_INFO_VERSION, *LPDRIVER_INFO_VERSION;
#define APD_DONT_COPY_FILES_TO_CLUSTER   0x00001000
#define APD_COPY_TO_ALL_SPOOLERS         0x00002000
#define APD_NO_UI                        0x00004000
#define APD_INSTALL_WARNED_DRIVER        0x00008000
#define APD_RETURN_BLOCKING_STATUS_CODE  0x00010000
#define APD_DONT_SET_CHECKPOINT          0x00020000

// FLAGS for AddDriverCatalog
#define APDC_NONE                        0x00000000
#define APDC_USE_ORIGINAL_CAT_NAME       0x00000001
#define EPD_ALL_LOCAL_AND_CLUSTER        TEXT("AllCluster")
//Internal for printprocessor interface
#define DI_CHANNEL_WRITE        2    // Direct write only - background read thread ok
#define PRINTER_ENUM_CLUSTER     0x00000800
typedef struct _SPOOL_FILE_INFO_1 {
    DWORD       dwVersion;
    HANDLE      hSpoolFile;
    DWORD       dwAttributes;
} SPOOL_FILE_INFO_1, *PSPOOL_FILE_INFO_1;
HANDLE
WINAPI
GetSpoolFileHandle(
    HANDLE  hPrinter
);

HANDLE
WINAPI
CommitSpoolData(
    HANDLE  hPrinter,
    HANDLE  hSpoolFile,
    DWORD   cbCommit
);

BOOL
WINAPI
CloseSpoolFileHandle(
    HANDLE  hPrinter,
    HANDLE  hSpoolFile
);
BOOL
WINAPI
AddDriverCatalog(
    IN HANDLE    hPrinter,
    IN DWORD     Level,
    IN VOID      *pvDriverInfCatInfo,
    IN DWORD     dwCatalogCopyFiles
);
BOOL
WINAPI
AddPerMachineConnectionA(
   IN LPCSTR    pServer,
   IN LPCSTR    pPrinterName,
   IN LPCSTR    pPrintServer,
   IN LPCSTR    pProvider
);
BOOL
WINAPI
AddPerMachineConnectionW(
   IN LPCWSTR    pServer,
   IN LPCWSTR    pPrinterName,
   IN LPCWSTR    pPrintServer,
   IN LPCWSTR    pProvider
);
#ifdef UNICODE
#define AddPerMachineConnection  AddPerMachineConnectionW
#else
#define AddPerMachineConnection  AddPerMachineConnectionA
#endif // !UNICODE

BOOL
WINAPI
DeletePerMachineConnectionA(
   IN LPCSTR    pServer,
   IN LPCSTR    pPrinterName
);
BOOL
WINAPI
DeletePerMachineConnectionW(
   IN LPCWSTR    pServer,
   IN LPCWSTR    pPrinterName
);
#ifdef UNICODE
#define DeletePerMachineConnection  DeletePerMachineConnectionW
#else
#define DeletePerMachineConnection  DeletePerMachineConnectionA
#endif // !UNICODE

BOOL
WINAPI
EnumPerMachineConnectionsA(
    IN LPCSTR   pServer,
    OUT LPBYTE  pPrinterEnum,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
);
BOOL
WINAPI
EnumPerMachineConnectionsW(
    IN LPCWSTR   pServer,
    OUT LPBYTE  pPrinterEnum,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
);
#ifdef UNICODE
#define EnumPerMachineConnections  EnumPerMachineConnectionsW
#else
#define EnumPerMachineConnections  EnumPerMachineConnectionsA
#endif // !UNICODE
BOOL
WINAPI
SeekPrinter(
    IN HANDLE hPrinter,
    IN LARGE_INTEGER liDistanceToMove,
    OUT PLARGE_INTEGER pliNewPointer,
    IN DWORD dwMoveMethod,
    IN BOOL bWrite
);
BOOL
WINAPI
SplReadPrinter(
    HANDLE  hPrinter,
    LPBYTE  *pBuf,
    DWORD   cbBuf
);
BOOL
WINAPI
EnumPrinterPropertySheets(
    IN HANDLE  hPrinter,
    IN HWND    hWnd,
    IN LPFNADDPROPSHEETPAGE    lpfnAdd,
    IN LPARAM  lParam
);

#define ENUMPRINTERPROPERTYSHEETS_ORD     100
BOOL
WINAPI
PublishPrinterA(
    IN HWND       hwnd,
    IN LPCSTR     pszUNCName,
    IN LPCSTR     pszDN,
    IN LPCSTR     pszCN,
    OUT LPSTR     *ppszDN,
    IN DWORD      dwAction
);

BOOL
WINAPI
PublishPrinterW(
    IN HWND       hwnd,
    IN LPCWSTR    pszUNCName,
    IN LPCWSTR    pszDN,
    IN LPCWSTR    pszCN,
    OUT LPWSTR    *ppszDN,
    IN DWORD      dwAction
);

#define PUBLISHPRINTER_QUERY                1
#define PUBLISHPRINTER_DELETE_DUPLICATES    2
#define PUBLISHPRINTER_FAIL_ON_DUPLICATE    3
#define PUBLISHPRINTER_IGNORE_DUPLICATES    4
BOOL
ClusterSplOpen(
    IN LPCTSTR pszServer,
    IN LPCTSTR pszResource,
    OUT PHANDLE phSpooler,
    IN LPCTSTR pszName,
    IN LPCTSTR pszAddress
);

BOOL
ClusterSplClose(
    IN HANDLE hSpooler
);

BOOL
ClusterSplIsAlive(
    IN HANDLE hSpooler
);
#define    SPLREG_NO_REMOTE_PRINTER_DRIVERS           TEXT("NoRemotePrinterDrivers")
#define    SPLREG_NON_RAW_TO_MASQ_PRINTERS            TEXT("NonRawToMasqPrinters")
#define    SPLREG_CHANGE_ID                           TEXT("ChangeId")
#define    SPLREG_CLUSTER_LOCAL_ROOT_KEY              TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Print\\Cluster")
#define    SPLREG_CLUSTER_UPGRADE_KEY                 TEXT("ClusterUpgrade")
#define    SPLREG_CLUSTER_DRIVER_DIRECTORY            TEXT("ClusterDriverDirectory")
BOOL
SpoolerInit(
    VOID
    );
#ifdef __cplusplus
}
#endif
#endif // _WINSPOLP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\winfaxp.h ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    winfax.h

Abstract:

    This module contains the WIN32 FAX APIs.

--*/

#ifndef _FAXAPIP_
#define _FAXAPIP_

#ifdef __cplusplus
extern "C" {
#endif

#define FPF_OBSOLETE      0x00000008
#define FPF_NEW           0x00000010
#define FPF_SELECTED      0x00000020

//
// the reserved fields are private data used
// by the fax monitor and winfax.
//
//
// Reserved[0] == 0xffffffff
// Reserved[1] == Print job id
//
// Reserved[0] == 0xfffffffe   start of a broadcast job
//

typedef struct _FAX_TAPI_LOCATIONSA {
    DWORD               PermanentLocationID;
    LPCSTR              LocationName;
    DWORD               CountryCode;
    DWORD               AreaCode;
    DWORD               NumTollPrefixes;
    LPCSTR              TollPrefixes;
} FAX_TAPI_LOCATIONSA, *PFAX_TAPI_LOCATIONSA;
typedef struct _FAX_TAPI_LOCATIONSW {
    DWORD               PermanentLocationID;
    LPCWSTR             LocationName;
    DWORD               CountryCode;
    DWORD               AreaCode;
    DWORD               NumTollPrefixes;
    LPCWSTR             TollPrefixes;
} FAX_TAPI_LOCATIONSW, *PFAX_TAPI_LOCATIONSW;
#ifdef UNICODE
typedef FAX_TAPI_LOCATIONSW FAX_TAPI_LOCATIONS;
typedef PFAX_TAPI_LOCATIONSW PFAX_TAPI_LOCATIONS;
#else
typedef FAX_TAPI_LOCATIONSA FAX_TAPI_LOCATIONS;
typedef PFAX_TAPI_LOCATIONSA PFAX_TAPI_LOCATIONS;
#endif // UNICODE


typedef struct _FAX_TAPI_LOCATION_INFOA {
    DWORD                   CurrentLocationID;
    DWORD                   NumLocations;
    PFAX_TAPI_LOCATIONSA    TapiLocations;
} FAX_TAPI_LOCATION_INFOA, *PFAX_TAPI_LOCATION_INFOA;
typedef struct _FAX_TAPI_LOCATION_INFOW {
    DWORD                   CurrentLocationID;
    DWORD                   NumLocations;
    PFAX_TAPI_LOCATIONSW    TapiLocations;
} FAX_TAPI_LOCATION_INFOW, *PFAX_TAPI_LOCATION_INFOW;
#ifdef UNICODE
typedef FAX_TAPI_LOCATION_INFOW FAX_TAPI_LOCATION_INFO;
typedef PFAX_TAPI_LOCATION_INFOW PFAX_TAPI_LOCATION_INFO;
#else
typedef FAX_TAPI_LOCATION_INFOA FAX_TAPI_LOCATION_INFO;
typedef PFAX_TAPI_LOCATION_INFOA PFAX_TAPI_LOCATION_INFO;
#endif // UNICODE


WINFAXAPI
BOOL
WINAPI
FaxGetVersion(
    IN  HANDLE FaxHandle,
    OUT LPDWORD Version
    );

typedef BOOL
(WINAPI *PFAXGETVERSION)(
    IN  HANDLE FaxHandle,
    OUT LPDWORD Version
    );

WINFAXAPI
BOOL
WINAPI
FaxGetTapiLocationsA(
    IN  HANDLE FaxHandle,
    OUT PFAX_TAPI_LOCATION_INFOA *TapiLocationInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxGetTapiLocationsW(
    IN  HANDLE FaxHandle,
    OUT PFAX_TAPI_LOCATION_INFOW *TapiLocationInfo
    );
#ifdef UNICODE
#define FaxGetTapiLocations  FaxGetTapiLocationsW
#else
#define FaxGetTapiLocations  FaxGetTapiLocationsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETTAPILOCATIONSA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_TAPI_LOCATION_INFOA *TapiLocationInfo
    );
typedef BOOL
(WINAPI *PFAXGETTAPILOCATIONSW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_TAPI_LOCATION_INFOW *TapiLocationInfo
    );
#ifdef UNICODE
#define PFAXGETTAPILOCATIONS  PFAXGETTAPILOCATIONSW
#else
#define PFAXGETTAPILOCATIONS  PFAXGETTAPILOCATIONSA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxSetTapiLocationsA(
    IN  HANDLE FaxHandle,
    IN  PFAX_TAPI_LOCATION_INFOA TapiLocationInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxSetTapiLocationsW(
    IN  HANDLE FaxHandle,
    IN  PFAX_TAPI_LOCATION_INFOW TapiLocationInfo
    );
#ifdef UNICODE
#define FaxSetTapiLocations  FaxSetTapiLocationsW
#else
#define FaxSetTapiLocations  FaxSetTapiLocationsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETTAPILOCATIONSA)(
    IN  HANDLE FaxHandle,
    IN  PFAX_TAPI_LOCATION_INFOA TapiLocationInfo
    );
typedef BOOL
(WINAPI *PFAXSETTAPILOCATIONSW)(
    IN  HANDLE FaxHandle,
    IN  PFAX_TAPI_LOCATION_INFOW TapiLocationInfo
    );
#ifdef UNICODE
#define PFAXSETTAPILOCATIONS  PFAXSETTAPILOCATIONSW
#else
#define PFAXSETTAPILOCATIONS  PFAXSETTAPILOCATIONSA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxGetMapiProfilesA(
    IN  HANDLE FaxHandle,
    OUT LPBYTE *MapiProfiles
    );
WINFAXAPI
BOOL
WINAPI
FaxGetMapiProfilesW(
    IN  HANDLE FaxHandle,
    OUT LPBYTE *MapiProfiles
    );
#ifdef UNICODE
#define FaxGetMapiProfiles  FaxGetMapiProfilesW
#else
#define FaxGetMapiProfiles  FaxGetMapiProfilesA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETMAPIPROFILESA)(
    IN  HANDLE FaxHandle,
    OUT LPBYTE *MapiProfiles
    );
typedef BOOL
(WINAPI *PFAXGETMAPIPROFILESW)(
    IN  HANDLE FaxHandle,
    OUT LPBYTE *MapiProfiles
    );
#ifdef UNICODE
#define PFAXGETMAPIPROFILES  PFAXGETMAPIPROFILESW
#else
#define PFAXGETMAPIPROFILES  PFAXGETMAPIPROFILESA
#endif // !UNICODE

typedef struct FaxSecurityDescriptor {
    DWORD   Id;
    LPWSTR  FriendlyName;
    LPBYTE  SecurityDescriptor;
} FAX_SECURITY_DESCRIPTOR, * PFAX_SECURITY_DESCRIPTOR;


WINFAXAPI
BOOL
WINAPI
FaxGetSecurityDescriptorCount(
    IN HANDLE FaxHandle,
    OUT LPDWORD Count
    );

WINFAXAPI
BOOL
WINAPI
FaxGetSecurityDescriptor(
    IN HANDLE FaxHandle,
    IN DWORD Id,
    OUT PFAX_SECURITY_DESCRIPTOR * FaxSecurityDescriptor
    );

WINFAXAPI
BOOL
WINAPI
FaxSetSecurityDescriptor(
    IN HANDLE FaxHandle,
    IN PFAX_SECURITY_DESCRIPTOR FaxSecurityDescriptor
    );

WINFAXAPI
BOOL
WINAPI
FaxGetInstallType(
    IN  HANDLE FaxHandle,
    OUT LPDWORD InstallType,
    OUT LPDWORD InstalledPlatforms,
    OUT LPDWORD ProductType
    );

typedef BOOL
(WINAPI *PFAXGETINSTALLTYPE)(
    IN  HANDLE FaxHandle,
    OUT LPDWORD InstallType,
    OUT LPDWORD InstalledPlatforms,
    OUT LPDWORD ProductType
    );


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\winuserp.h ===
/*++
Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    winuserp.h

Abstract:

    Private
    Procedure declarations, constant definitions and macros for the User
    component.

--*/
#ifndef _WINUSERP_
#define _WINUSERP_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
#ifdef STRICT
#else /* !STRICT */
#endif /* !STRICT */
#ifdef STRICT
#else /* !STRICT */
#endif /* !STRICT */
#ifdef UNICODE
#else  /* !UNICODE */
#endif /* UNICODE */
#define RT_MENUEX       MAKEINTRESOURCE(13)     // RT_MENU subtype
#define RT_NAMETABLE    MAKEINTRESOURCE(15)     // removed in 3.1
#define RT_DIALOGEX     MAKEINTRESOURCE(18)     // RT_DIALOG subtype
#define RT_LAST         MAKEINTRESOURCE(24)
#define RT_AFXFIRST     MAKEINTRESOURCE(0xF0)   // reserved: AFX
#define RT_AFXLAST      MAKEINTRESOURCE(0xFF)   // reserved: AFX
/* Max number of characters. Doesn't include termination character */
#define WSPRINTF_LIMIT 1024
#define SETWALLPAPER_METRICS    ((LPWSTR)-2)
#define SB_MAX              3
#define SB_CMD_MAX          8
#define AW_VALID                    (AW_HOR_POSITIVE |\
                                     AW_HOR_NEGATIVE |\
                                     AW_VER_POSITIVE |\
                                     AW_VER_NEGATIVE |\
                                     AW_CENTER       |\
                                     AW_HIDE         |\
                                     AW_ACTIVATE     |\
                                     AW_BLEND        |\
                                     AW_SLIDE)
/*
 * GetAppCompatFlags2 flags
 */
#define GACF2_ANIMATIONOFF        0x00000001  // do not animate menus and listboxes
#define GACF2_KCOFF               0x00000002  // do not send Keyboard Cues messages
#define GACF2_NO50EXSTYLEBITS     0x00000004  // mask out post-4.0 extended style bits for SetWindowLong
#define GACF2_NODRAWPATRECT       0x00000008  // disable DRAWPATTERNRECT accel via ExtEscape()
#define GACF2_MSSHELLDLG          0x00000010  // if there is a request for MS Shell Dlg (which
                                              // usually maps to MS Sans Serif (bitmap) on NT 4 and
                                              // Microsoft Sans Serif (TrueType) on NT 5), then
                                              // behave as though we are using the bitmap
                                              // font (MS Sans Serif).
#define GACF2_NODDETRKDYING       0x00000020  // Be like Win9x: don't post WM_DDE_TERMINATE if
                                              // the window is destroyed while in a conversation
#define GACF2_GIVEUPFOREGROUND    0x00000040  // In W2k, we have changed foreground semantics to stop
                                              // foreground focus stealing by one app if another app
                                              // is active. However, this has caused  a few app compat
                                              // bugs. This appcompat flag is used to enable the old foreground
                                              // focus behaviour for these bugs.
#define GACF2_ACTIVEMENUS         0x00000080  // In W2k, we set the inactive look on menus that belong
                                              // to non-rofeground windows.  Some applications get in trouble
                                              // see #58227
#define GACF2_EDITNOMOUSEHIDE     0x00000100  // Typing in edit controls hides the cursor.
                                              // Some apps are surprised by that: #307615
#define GACF2_NOBATCHING          0X00000200  // Turn GDI batching off
#define GACF2_FONTSUB             0X00000400  // Only for Notes R5
#define GACF2_NO50EXSTYLEBITSCW   0x00000800  // mask out post-4.0 extended style bits for CreateWindow
#define GACF2_NOCUSTOMPAPERSIZES  0x00001000  // PostScript driver bit for Harvard Graphics
#define GACF2_DDE                 0x00002000  // all the DDE hacks
#define GACF2_DEFAULTCHARSET      0x00004000  // LOGFONT bit for QuickBook OCR-A font
#define GACF2_NOCHAR_DEADKEY      0x00008000  // No character composition on dead key on dead key (NT4 behavior)
#define GACF2_NO_TRYEXCEPT_CALLWNDPROC \
                                  0x00010000  // No try ~ except clause around WndProc call, let the app's handler
                                              // handle it even though it skips some API stacks.
                                              // See #359866
#define GACF2_NO_INIT_ECFLAGS_ON_SETFOCUS \
                                  0x00020000  // Do not initialize insert & replace flags (Korean specific)
                                              // in PED on WM_SETFOCUS, if this appcompat flag is set.
                                              // To workaround a bogus app bug who send input messages before setting
                                              // the focus to the edit control. See NtRaid #411686.

#define GACF2_DDENOSYNC           0x00040000  // Do not reject sent dde messages even if there is
                                              // an unprocessed message in the queue.
                                              // see WhistlerRaid #95367 (Check COMPATFLAGS2_FORWOW
                                              // below also)

#define GACF2_FORCEFUSION         0x00800000  // Set this flag to enable fusion in 16bit apps


/*
 * zzzInitTask masks out pti->dwCompatFlags2
 * If you need to add bits for 16bit apps include
 * that bit in this mask
 *
 */
#define COMPATFLAGS2_FORWOW       GACF2_DDENOSYNC | GACF2_GIVEUPFOREGROUND | GACF2_FORCEFUSION


#define GACF2_NOGHOST             0x00080000  // No window ghosting for this application. See bug #268100.
#define GACF2_DDENOASYNCREG       0x00100000  // Use Sendmessage instead of PostMessage in DDE RegisterService(). See bug# 156088.
#define GACF2_STRICTLLHOOK        0x00200000  // Apply strict timeout rule for LL hook. See WindowsBug 307738.
#define GACF2_NOSHADOW            0x00400000  // don't apply window shadow. see bug# 364717
#define GACF2_NOTIMERCBPROTECTION 0x01000000  // don't protect from unregistered WM_TIMER with lParam (callback pfn).

/*
 * Version macros
 */
#define VERMAX          0x9900  // ignore the version

#define VER51           0x0501
#define VER50           0x0500
#define VER40           0x0400
#define VER31           0x030A
#define VER30           0x0300

#define Is510Compat(dwExpWinVer)  (LOWORD(dwExpWinVer) >= VER51)
#define Is500Compat(dwExpWinVer)  (LOWORD(dwExpWinVer) >= VER50)
#define Is400Compat(dwExpWinVer)  (LOWORD(dwExpWinVer) >= VER40)
#define Is310Compat(dwExpWinVer)  (LOWORD(dwExpWinVer) >= VER31)
#define Is300Compat(dwExpWinVer)  (LOWORD(dwExpWinVer) >= VER30)

#define VK_NONE           0x00
/*
 * NEC PC-9800 Series definitions
 */
#define VK_OEM_NEC_SEPARATE 0x6C
#define VK_APPCOMMAND_FIRST    0xA6
#define VK_APPCOMMAND_LAST     0xB7
/*
 * Fujitsu/OASYS definitions - clash with SpeedRacer etc.
 */
#define VK_OEM_OAS_1      0xB4
#define VK_OEM_OAS_2      0xB5
#define VK_OEM_OAS_3      0xB6
#define VK_OEM_OAS_4      0xB7
#define VK_OEM_OAS_5      0xB8
#define VK_OEM_OAS_6      0xB9
#define VK_OEM_OAS_7      0xC1
#define VK_OEM_OAS_8      0xC2
#define VK_OEM_OAS_9      0xC3
#define VK_OEM_OAS_10     0xC4
#define VK_OEM_OAS_11     0xC5
#define VK_OEM_OAS_12     0xC6
#define VK_OEM_OAS_13     0xC7
#define VK_OEM_OAS_14     0xC8
#define VK_OEM_OAS_15     0xC9
#define VK_OEM_OAS_16     0xCA
#define VK_OEM_OAS_17     0xCB
#define VK_OEM_OAS_18     0xCC
#define VK_OEM_OAS_19     0xCD
#define VK_OEM_OAS_20     0xCE
#define VK_OEM_OAS_21     0xCF
#define VK_OEM_OAS_22     0xD0
#define VK_OEM_OAS_23     0xD1
#define VK_OEM_OAS_24     0xD2
#define VK_OEM_OAS_25     0xD3
#define VK_OEM_OAS_26     0xD4
#define VK_OEM_OAS_27     0xD5
#define VK_OEM_OAS_28     0xD6
#define VK_OEM_OAS_29     0xD7
#define VK_OEM_FJ_DUMMY   0xEF

#define VK_UNKNOWN        0xFF
/*
 * Additional modifier keys.
 * Used for ISO9995 "Information technology - Keyboard layouts for text and
 * office systems" (French Canadian keyboard,
 */
#define VK_GROUPSHIFT     0xE5
#define VK_RGROUPSHIFT    0xE6
#if !defined(_WIN32_WINDOWS)
#define WH_HARDWARE         8
#endif
#ifdef REDIRECTION
#define  WH_HITTEST         15
#endif // REDIRECTION
#define WH_CHOOKS          (WH_MAXHOOK - WH_MINHOOK + 1)
#ifdef REDIRECTION
#define HCBT_GETCURSORPOS  10
#endif // REDIRECTION
#define MSGF_MOVE           3
#define MSGF_SIZE           4
#define MSGF_CBTHOSEBAGSUSEDTHIS  7
#define MSGF_MAINLOOP       8
#define APPCOMMAND_FIRST                  1
#define APPCOMMAND_LAST                   52
#ifdef REDIRECTION
typedef struct tagHTHOOKSTRUCT {
    POINT pt;
    HWND hwndHit;
} HTHOOKSTRUCT, FAR *LPHTHOOKSTRUCT, *PHTHOOKSTRUCT;
#endif // REDIRECTION
#define KLF_UNLOADPREVIOUS  0x00000004
#define KLF_FAILSAFE        0x00000200

/*
 * Keyboard Layout Attributes
 * These are specified in the layout DLL itself, or in the registry under
 * MACHINE\System\CurrentControlSet\Control\Keyboard Layouts\*\Attributes
 * as KLF_ values between 0x00010000 and 0x00800000.  Any attributes specified
 * by the layout DLL are ORed with the attributes obtained from the registry.
 */
#define KLF_LRM_RLM         0x00020000
#define KLF_ATTRIBUTE2      0x00040000
#define KLF_ATTRIBUTE3      0x00080000
#define KLF_ATTRIBUTE4      0x00100000
#define KLF_ATTRIBUTE5      0x00200000
#define KLF_ATTRIBUTE6      0x00400000
#define KLF_ATTRIBUTE7      0x00800000
#define KLF_ATTRMASK        0x00FF0000
#define KLF_INITTIME        0x80000000
#define KLF_VALID           0xC000039F | KLF_ATTRMASK

WINUSERAPI
HKL
WINAPI
LoadKeyboardLayoutEx(
    IN HKL hkl,
    IN LPCWSTR pwszKLID,
    IN UINT Flags);

#ifdef REDIRECTION
#define DESKTOP_QUERY_INFORMATION   0x0101L
#define DESKTOP_REDIRECT            0x0102L
#endif // REDIRECTION
#ifndef NOWINDOWSTATION
#endif  /* !NOWINDOWSTATION */

WINUSERAPI
DWORD
WINAPI
CreateSystemThreads(
    IN LPVOID pUnused);

BOOL WowWaitForMsgAndEvent(IN HANDLE hevent);
WINUSERAPI VOID WINAPI RegisterSystemThread(IN DWORD flags, IN DWORD reserved);
#define RST_DONTATTACHQUEUE       0x00000001
#define RST_DONTJOURNALATTACH     0x00000002
#define RST_ALWAYSFOREGROUNDABLE  0x00000004
#define RST_FAULTTHREAD           0x00000008
#define GWL_WOWWORDS        (-1)
#ifdef _WIN64
#undef GWL_WOWWORDS
#endif /* _WIN64 */
#define GWLP_WOWWORDS       (-1)
#define GCL_WOWWORDS        (-27)
#define GCL_WOWMENUNAME     (-29)
#ifdef _WIN64
#undef GCL_WOWWORDS
#endif /* _WIN64 */
#define GCLP_WOWWORDS       (-27)
#define WM_SIZEWAIT                     0x0004
#define WM_SETVISIBLE                   0x0009
#define WM_SYSTEMERROR                  0x0017
/*
 * This is used by DefWindowProc() and DefDlgProc(), it's the 16-bit version
 * of the WM_CTLCOLORBTN, WM_CTLCOLORDLG, ... messages.
 */
#define WM_CTLCOLOR                     0x0019
#define WM_LOGOFF                       0x0025
#define WM_ALTTABACTIVE                 0x0029
#define WM_FILESYSCHANGE                0x0034

#define WM_SHELLNOTIFY                  0x0034
#define SHELLNOTIFY_DISKFULL            0x0001
#define SHELLNOTIFY_OLELOADED           0x0002
#define SHELLNOTIFY_OLEUNLOADED         0x0003
#define SHELLNOTIFY_WALLPAPERCHANGED    0x0004

#define WM_ISACTIVEICON                 0x0035
#define WM_QUERYPARKICON                0x0036
#define WM_WINHELP                      0x0038
#define WM_FULLSCREEN                   0x003A
#define WM_CLIENTSHUTDOWN               0x003B
#define WM_DDEMLEVENT                   0x003C
#define MM_CALCSCROLL                   0x003F
#define WM_TESTING                      0x0040
#define WM_OTHERWINDOWCREATED           0x0042
#define WM_OTHERWINDOWDESTROYED         0x0043
#define WM_COPYGLOBALDATA               0x0049
#define WM_LOGONNOTIFY                  0x004C
#define WM_KEYF1                        0x004D
#define WM_ACCESS_WINDOW                0x004F
#define WM_FINALDESTROY                 0x0070  /* really destroy (window not locked) */
#define WM_MEASUREITEM_CLIENTDATA       0x0071  /* WM_MEASUREITEM bug clientdata thunked already */
#define WM_SYNCTASK                     0x0089

#define WM_KLUDGEMINRECT                0x008B
#define WM_LPKDRAWSWITCHWND             0x008C
#define WM_NCMOUSEFIRST                 0x00A0

/*
 * Skip value 0x00AA, which would correspond to the non-client
 * mouse wheel message if there were such a message.
 * We do that in order to maintain a constant value for
 * the difference between the client and nonclient version of
 * a mouse message, e.g.
 *     WM_LBUTTONDOWN - WM_NCLBUTTONDOWN == WM_XBUTTONDOWN - WM_NCXBUTTONDOWN
 */

#define WM_NCXBUTTONFIRST               0x00AB
#define WM_NCXBUTTONLAST                0X00AD
#define WM_NCMOUSELAST                  0x00AD

#if(_WIN32_WINNT >= 0x0501)
#define WM_NCUAHDRAWCAPTION             0x00AE
#define WM_NCUAHDRAWFRAME               0x00AF
#endif /* _WIN32_WINNT >= 0x0501 */
#define WM_CONVERTREQUESTEX             0x0108
#define WM_YOMICHAR                     0x0108
#define WM_CONVERTREQUEST               0x010A
#define WM_CONVERTRESULT                0x010B
#define WM_INTERIM                      0x010C
#define WM_SYSTIMER                     0x0118
#define UIS_LASTVALID                   UIS_INITIALIZE
#define UISF_VALID                     (UISF_HIDEFOCUS | \
                                        UISF_HIDEACCEL | \
                                        UISF_ACTIVE)
#define WM_LBTRACKPOINT                 0x0131

#define WM_CTLCOLORFIRST                0x0132
#define WM_CTLCOLORLAST                 0x0138

#define MN_FIRST                        0x01E0
#define MN_SETHMENU                     (MN_FIRST + 0)
    // We need to expose this message for compliance.
    // Make sure this remains equal to (MN_FIRST + 1)
#define MN_SIZEWINDOW                   (MN_FIRST + 2)
#define MN_OPENHIERARCHY                (MN_FIRST + 3)
#define MN_CLOSEHIERARCHY               (MN_FIRST + 4)
#define MN_SELECTITEM                   (MN_FIRST + 5)
#define MN_CANCELMENUS                  (MN_FIRST + 6)
#define MN_SELECTFIRSTVALIDITEM         (MN_FIRST + 7)

#define MN_GETPPOPUPMENU                (MN_FIRST + 10)
#define MN_FINDMENUWINDOWFROMPOINT      (MN_FIRST + 11)
#define MN_SHOWPOPUPWINDOW              (MN_FIRST + 12)
#define MN_BUTTONDOWN                   (MN_FIRST + 13)
#define MN_MOUSEMOVE                    (MN_FIRST + 14)
#define MN_BUTTONUP                     (MN_FIRST + 15)
#define MN_SETTIMERTOOPENHIERARCHY      (MN_FIRST + 16)
#define MN_DBLCLK                       (MN_FIRST + 17)
#define MN_ACTIVATEPOPUP                (MN_FIRST + 18)
#define MN_ENDMENU                      (MN_FIRST + 19)
#define MN_DODRAGDROP                   (MN_FIRST + 20)
#define MN_LASTPOSSIBLE                 (MN_FIRST + 31)
#define WM_XBUTTONFIRST                 0x020B
#define WM_XBUTTONLAST                  0X020D
#define XBUTTON_MASK  (XBUTTON1 | XBUTTON2)
#define WM_DROPOBJECT                   0x022A
#define WM_QUERYDROPOBJECT              0x022B

#define WM_BEGINDRAG                    0x022C
#define WM_DRAGLOOP                     0x022D
#define WM_DRAGSELECT                   0x022E
#define WM_DRAGMOVE                     0x022F
#define WM_KANJIFIRST                   0x0280
#define WM_IME_SYSTEM                   0x0287
#define WM_KANJILAST                    0x029F

#define WM_TRACKMOUSEEVENT_FIRST        0x02A0
#define WM_TRACKMOUSEEVENT_LAST         0x02AF
#define WM_PALETTEGONNACHANGE           0x0310
#define WM_CHANGEPALETTE                0x0311
#define WM_SYSMENU                      0x0313
#define WM_HOOKMSG                      0x0314
#define WM_EXITPROCESS                  0x0315
#define WM_WAKETHREAD                   0x0316
#define WM_UAHINIT                      0x031B
#define WM_DESKTOPNOTIFY                0x031C
#define WM_NOTIFYWOW                    0x0340
#define WM_COALESCE_FIRST               0x0390
#define WM_COALESCE_LAST                0x039F

#define WM_INTERNAL_DDE_FIRST           0x03E0
#define WM_INTERNAL_DDE_LAST            0x03EF
#define WM_COALESCE_FIRST               0x0390
#define WM_COALESCE_LAST                0x039F

#define WM_MM_RESERVED_FIRST            0x03A0
#define WM_MM_RESERVED_LAST             0x03DF

#define WM_CBT_RESERVED_FIRST           0x03F0
#define WM_CBT_RESERVED_LAST            0x03FF
/* wParam for WM_NOTIFYWOW message  */
#define WMNW_UPDATEFINDREPLACE  0
#define WMSZ_KEYSIZE        0
#define WMSZ_MOVE           9
#define WMSZ_KEYMOVE        10
#define WMSZ_SIZEFIRST      WMSZ_LEFT
#define HTLAMEBUTTON        22

/*
 * The prototype of the function to call when the user clicks
 * on the Lame button in the caption
 */

typedef VOID (*PLAMEBTNPROC)(HWND, PVOID);
#define SMTO_BROADCAST      0x0004
#define SMTO_VALID          0x000F
#define ICON_RECREATE       3
#define WVR_MINVALID        WVR_ALIGNTOP
#define WVR_MAXVALID        WVR_VALIDRECTS
#if(WINVER >= 0x0500)
#define TME_VALID (TME_HOVER | TME_LEAVE | TME_NONCLIENT | TME_QUERY | TME_CANCEL)
#else
#define TME_VALID (TME_HOVER | TME_LEAVE | TME_QUERY | TME_CANCEL)
#endif
#define WS_VALID            (WS_OVERLAPPED     | \
                             WS_POPUP          | \
                             WS_CHILD          | \
                             WS_MINIMIZE       | \
                             WS_VISIBLE        | \
                             WS_DISABLED       | \
                             WS_CLIPSIBLINGS   | \
                             WS_CLIPCHILDREN   | \
                             WS_MAXIMIZE       | \
                             WS_CAPTION        | \
                             WS_BORDER         | \
                             WS_DLGFRAME       | \
                             WS_VSCROLL        | \
                             WS_HSCROLL        | \
                             WS_SYSMENU        | \
                             WS_THICKFRAME     | \
                             WS_GROUP          | \
                             WS_TABSTOP        | \
                             WS_MINIMIZEBOX    | \
                             WS_MAXIMIZEBOX)
#define WS_EX_DRAGOBJECT        0x00000002L
#if(WINVER >= 0x0501)
#define WS_EXP_GHOSTMAKEVISIBLE 0x00000800L
#endif /* WINVER >= 0x0501 */
#define WS_EX_ANSICREATOR       0x80000000L
#ifdef REDIRECTION
#define WS_EX_EXTREDIRECTED     0x01000000L
#endif // REDIRECTION

/*
 * These are not extended styles but rather state bits.
 * We use these bit positions to delay the addition of a new
 * state DWORD in the window structure.
 */
#define WS_EXP_UIFOCUSHIDDEN    0x80000000
#define WS_EXP_UIACCELHIDDEN    0x40000000
#define WS_EXP_REDIRECTED       0x20000000
#define WS_EXP_COMPOSITING      0x10000000
#define WS_EXP_UIACTIVE         0x04000000L

#define WS_EXP_UIVALID         (WS_EXP_UIFOCUSHIDDEN | \
                                WS_EXP_UIACCELHIDDEN | \
                                WS_EXP_UIACTIVE)

#define WS_EXP_PRIVATE         (WS_EXP_UIFOCUSHIDDEN | \
                                WS_EXP_UIACCELHIDDEN | \
                                WS_EXP_REDIRECTED    | \
                                WS_EXP_COMPOSITING   | \
                                WS_EXP_UIACTIVE      | \
                                WS_EXP_GHOSTMAKEVISIBLE)

/*
 * RTL Mirroring Extended Styles (RTL_MIRRORING)
 */
#define WS_EX_LAYOUTVBHRESERVED 0x00200000L
#define WS_EX_LAYOUTBTTRESERVED 0x00800000L
#define WS_EX_ALLEXSTYLES    (WS_EX_TRANSPARENT | WS_EX_DLGMODALFRAME | WS_EX_DRAGOBJECT | WS_EX_NOPARENTNOTIFY | WS_EX_TOPMOST | WS_EX_ACCEPTFILES | WS_EX_COMPOSITED)

#define WS_EX_VALID          (WS_EX_DLGMODALFRAME  | \
                              WS_EX_DRAGOBJECT     | \
                              WS_EX_NOPARENTNOTIFY | \
                              WS_EX_TOPMOST        | \
                              WS_EX_ACCEPTFILES    | \
                              WS_EX_TRANSPARENT    | \
                              WS_EX_ALLEXSTYLES)

#define WS_EX_VALID40        (WS_EX_VALID          | \
                              WS_EX_MDICHILD       | \
                              WS_EX_WINDOWEDGE     | \
                              WS_EX_CLIENTEDGE     | \
                              WS_EX_CONTEXTHELP    | \
                              WS_EX_TOOLWINDOW     | \
                              WS_EX_RIGHT          | \
                              WS_EX_LEFT           | \
                              WS_EX_RTLREADING     | \
                              WS_EX_LEFTSCROLLBAR  | \
                              WS_EX_CONTROLPARENT  | \
                              WS_EX_STATICEDGE     | \
                              WS_EX_APPWINDOW)

#ifdef REDIRECTION
#define WS_EX_VALID50        (WS_EX_VALID40        | \
                              WS_EX_LAYERED        | \
                              WS_EX_NOINHERITLAYOUT| \
                              WS_EX_LAYOUTRTL      | \
                              WS_EX_COMPOSITED     | \
                              WS_EX_NOACTIVATE     | \
                              WS_EX_EXTREDIRECTED)
#else
#define WS_EX_VALID50        (WS_EX_VALID40        | \
                              WS_EX_LAYERED        | \
                              WS_EX_NOINHERITLAYOUT| \
                              WS_EX_LAYOUTRTL      | \
                              WS_EX_COMPOSITED     | \
                              WS_EX_NOACTIVATE)
#endif // REDIRECTION

#define WS_EX_INTERNAL       (WS_EX_DRAGOBJECT     | \
                              WS_EX_ANSICREATOR)

/*
 * We currently return to applications only the valid Ex_Style bits.
 * If declaring another macro i.e. WS_EX_VALID60, make sure to change WS_EX_ALLVALID
 */
#define WS_EX_ALLVALID        WS_EX_VALID50


#define WF_DIALOG_WINDOW      0x00010000     // used in WOW32 -- this is a state flag, not a style flag
#define CS_KEYCVTWINDOW     0x0004
#define CS_OEMCHARS         0x0010  /* reserved (see user\server\usersrv.h) */
#define CS_NOKEYCVT         0x0100
#define CS_LVB              0x0400
#define CS_SYSTEM           0x8000
#define CS_VALID            (CS_VREDRAW           | \
                             CS_HREDRAW           | \
                             CS_KEYCVTWINDOW      | \
                             CS_DBLCLKS           | \
                             CS_OEMCHARS          | \
                             CS_OWNDC             | \
                             CS_CLASSDC           | \
                             CS_PARENTDC          | \
                             CS_NOKEYCVT          | \
                             CS_NOCLOSE           | \
                             CS_SAVEBITS          | \
                             CS_BYTEALIGNCLIENT   | \
                             CS_BYTEALIGNWINDOW   | \
                             CS_GLOBALCLASS       | \
                             CS_DROPSHADOW        | \
                             CS_IME)
#define CS_VALID31            0x0800ffef
#define CS_VALID40            0x0803feeb
#define BDR_VALID       0x000F
#define BF_VALID       (BF_MIDDLE |  \
                        BF_SOFT   |  \
                        BF_ADJUST |  \
                        BF_FLAT   |  \
                        BF_MONO   |  \
                        BF_LEFT   |  \
                        BF_TOP    |  \
                        BF_RIGHT  |  \
                        BF_BOTTOM |  \
                        BF_DIAGONAL)
#define DFC_CACHE               0xFFFF
#define DFCS_CAPTIONALL         0x000F
#define DFCS_INMENU             0x0040
#define DFCS_INSMALL            0x0080
#define DFCS_MENUARROWUP        0x0008
#define DFCS_MENUARROWDOWN      0x0010

#define DFCS_SCROLLMIN          0x0000
#define DFCS_SCROLLVERT         0x0000
#define DFCS_SCROLLMAX          0x0001
#define DFCS_SCROLLHORZ         0x0002
#define DFCS_SCROLLLINE         0x0004

#define DFCS_CACHEICON          0x0000
#define DFCS_CACHEBUTTONS       0x0001

#if(_WIN32_WINNT >= 0x0501)
typedef BOOL (CALLBACK* DRAWFRAMECONTROLPROC)(
    IN     HDC,
    IN OUT LPRECT,
    IN     UINT,
    IN     UINT);
#endif /* _WIN32_WINNT >= 0x0501 */
#define DC_LAMEBUTTON       0x0400
#define DC_NOVISIBLE        0x0800
#define DC_NOSENDMSG        0x2000
#define DC_CENTER           0x4000
#define DC_FRAME            0x8000
#define DC_CAPTION          (DC_ICON | DC_TEXT | DC_BUTTONS)
#define DC_NC               (DC_CAPTION | DC_FRAME)

/* flags for WM_NCUAHDRAWFRAME */
#if(_WIN32_WINNT >= 0x0501)
#define DF_ACTIVE           0x0001
#define DF_HUNGREDRAW       0x2000
#endif /* _WIN32_WINNT >= 0x0501 */
#if(_WIN32_WINNT >= 0x0501)
typedef BOOL (CALLBACK* DRAWCAPTIONPROC)(
    IN HWND,
    IN HDC,
    IN CONST RECT *,
    IN UINT);
#endif /* _WIN32_WINNT >= 0x0501 */

WINUSERAPI
BOOL
WINAPI
DrawCaptionTempA(
    IN HWND,
    IN HDC,
    IN LPCRECT,
    IN HFONT,
    IN HICON,
    IN LPCSTR,
    IN UINT);
WINUSERAPI
BOOL
WINAPI
DrawCaptionTempW(
    IN HWND,
    IN HDC,
    IN LPCRECT,
    IN HFONT,
    IN HICON,
    IN LPCWSTR,
    IN UINT);
#ifdef UNICODE
#define DrawCaptionTemp  DrawCaptionTempW
#else
#define DrawCaptionTemp  DrawCaptionTempA
#endif // !UNICODE
#define IDANI_CLOSE         2
#define CF_FIRST            0
#define WPF_VALID              (WPF_SETMINPOSITION     | \
                                WPF_RESTORETOMAXIMIZED)
/*
 * MEASUREITEMSTRUCT_EX for ownerdraw
 * used when server initiates a WM_MEASUREITEM and adds the additional info
 * of whether the itemData needs to be thunked when the message is sent to
 * the client (see also WM_MEASUREITEM_CLIENTDATA
 */
typedef struct tagMEASUREITEMSTRUCT_EX {
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    UINT       itemWidth;
    UINT       itemHeight;
    ULONG_PTR  itemData;
    BOOL       bThunkClientData;
} MEASUREITEMSTRUCT_EX, NEAR *PMEASUREITEMSTRUCT_EX, FAR *LPMEASUREITEMSTRUCT_EX;
typedef BOOL (CALLBACK* INTERNALGETMESSAGEPROC)(OUT LPMSG lpMsg, IN HWND hwnd,
        IN UINT wMsgFilterMin, IN UINT wMsgFilterMax, IN UINT flags, IN BOOL fGetMessage);
#define PM_VALID           (PM_NOREMOVE | \
                            PM_REMOVE   | \
                            PM_NOYIELD  | \
                            PM_QS_INPUT | \
                            PM_QS_POSTMESSAGE | \
                            PM_QS_PAINT | \
                            PM_QS_SENDMESSAGE)
#define MOD_SAS         0x8000

#define MOD_VALID           (MOD_ALT|MOD_CONTROL|MOD_SHIFT|MOD_WIN|MOD_SAS)
#define EW_RESTARTWINDOWS    0x0042L
#define EW_REBOOTSYSTEM      0x0043L
#define EWX_REALLYLOGOFF     ENDSESSION_LOGOFF

#define EWX_CANCELED                0x00000080
#define EWX_SYSTEM_CALLER           0x00000100
#define EWX_WINLOGON_CALLER         0x00000200
#define EWX_WINLOGON_OLD_SYSTEM     0x00000400
#define EWX_WINLOGON_OLD_SHUTDOWN   0x00000800
#define EWX_WINLOGON_OLD_REBOOT     0x00001000
#define EWX_WINLOGON_API_SHUTDOWN   0x00002000
#define EWX_WINLOGON_OLD_POWEROFF   0x00004000
#define EWX_NOTIFY                  0x00008000
#define EWX_NONOTIFY                0x00010000
#define EWX_WINLOGON_INITIATED      0x00020000
#define EWX_TERMSRV_INITIATED       0x00040000
#define EWX_VALID                   (EWX_LOGOFF            | \
                                     EWX_SHUTDOWN          | \
                                     EWX_REBOOT            | \
                                     EWX_FORCE             | \
                                     EWX_POWEROFF          | \
                                     EWX_FORCEIFHUNG       | \
                                     EWX_NOTIFY            | \
                                     EWX_TERMSRV_INITIATED)

#define SHUTDOWN_FLAGS (EWX_SHUTDOWN | EWX_REBOOT | EWX_POWEROFF |            \
                        EWX_WINLOGON_OLD_SHUTDOWN | EWX_WINLOGON_OLD_REBOOT | \
                        EWX_WINLOGON_OLD_POWEROFF)

/*
 * Shutdown logging stuff
 */
#define SR_EVENT_INITIATE_CLEAN       1
#define SR_EVENT_INITIATE_CLEAN_ABORT 2
#define SR_EVENT_EXITWINDOWS          3
#define SR_EVENT_DIRTY                4

typedef struct _SHUTDOWN_REASON
{
    UINT   cbSize;             /* Set to sizeof(SHUTDOWN_REASON) */
    UINT   uFlags;             /* Shutdown flags; e.g., EWX_SHUTDOWN */
    DWORD  dwReasonCode;       /* Optional field */
    DWORD  dwEventType;        /* See #defines above */
    BOOL   fShutdownCancelled; /* Optional field */
    LPWSTR lpszComment;        /* Optional field */
} SHUTDOWN_REASON, *PSHUTDOWN_REASON;

WINUSERAPI
BOOL
WINAPI
RecordShutdownReason(
    PSHUTDOWN_REASON psr);

WINUSERAPI
BOOL
WINAPI
DisplayExitWindowsWarnings(
    UINT uExitWindowsFlags);

#define BSM_COMPONENTS          0x0000000F
#define BSM_VALID               0x0000001F
#define BSF_QUEUENOTIFYMESSAGE  0x20000000
#define BSF_SYSTEMSHUTDOWN      0x40000000
#define BSF_MSGSRV32OK          0x80000000
#define BSF_VALID               0x000007FF
#define BSF_ASYNC               (BSF_POSTMESSAGE | BSF_SENDNOTIFYMESSAGE)
//
// NOTE: Completion port-based notification is not implemented in Win2K,
// nor is it planned for Whistler.
//
#define DEVICE_NOTIFY_COMPLETION_HANDLE 0x00000002

WINUSERAPI
ULONG
WINAPI
DeviceEventWorker(
    IN HWND    hWnd,
    IN WPARAM  wParam,
    IN LPARAM  lParam,
    IN DWORD   dwFlags,
    OUT PDWORD pdwResult
    );
typedef BOOL (CALLBACK* WAITMESSAGEEXPROC)(UINT fsWakeMask, DWORD dwTimeout);
#define PW_VALID               (PW_CLIENTONLY)
#define LWA_VALID              (LWA_COLORKEY            | \
                                LWA_ALPHA)
#define ULW_VALID              (ULW_COLORKEY            | \
                                ULW_ALPHA               | \
                                ULW_OPAQUE)
#define FLASHW_FLASHNOFG    0x00000008
#define FLASHW_TIMERCALL    0x00000400
#define FLASHW_DONE         0x00000800
#define FLASHW_STARTON      0x00001000
#define FLASHW_COUNTING     0x00002000
#define FLASHW_KILLTIMER    0x00004000
#define FLASHW_ON           0x00008000
#define FLASHW_VALID        (FLASHW_ALL | FLASHW_TIMERNOFG)
#define FLASHW_COUNTMASK    0xFFFF0000
#define FLASHW_CALLERBITS   (FLASHW_VALID | FLASHW_COUNTMASK)
#define SWP_STATECHANGE     0x8000  /* force size, move messages */
#define SWP_NOCLIENTSIZE    0x0800  /* Client didn't resize */
#define SWP_NOCLIENTMOVE    0x1000  /* Client didn't move   */

#define SWP_DEFERDRAWING    0x2000
#define SWP_CREATESPB       0x4000

#define SWP_CHANGEMASK      (SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED | SWP_SHOWWINDOW | SWP_HIDEWINDOW | SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)

#define SWP_NOCHANGE        (SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)

#define SWP_VALID1          (SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOREDRAW | SWP_NOACTIVATE | SWP_FRAMECHANGED)
#define SWP_VALID2          (SWP_SHOWWINDOW | SWP_HIDEWINDOW | SWP_NOCOPYBITS | SWP_NOOWNERZORDER | SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE | SWP_NOSENDCHANGING | SWP_ASYNCWINDOWPOS | SWP_DEFERDRAWING | SWP_CREATESPB)
#define SWP_VALID           (SWP_VALID1 | SWP_VALID2)
#define SWP_NOTIFYCREATE    0x10000000
#define SWP_NOTIFYDESTROY   0x20000000
#define SWP_NOTIFYACTIVATE  0x40000000
#define SWP_NOTIFYFS        0x80000000
#define SWP_NOTIFYALL       (SWP_NOTIFYCREATE | SWP_NOTIFYDESTROY | SWP_NOTIFYACTIVATE | SWP_NOTIFYFS)

#undef SWP_VALID
#define SWP_VALID           (SWP_DEFERERASE      | \
                             SWP_ASYNCWINDOWPOS  | \
                             SWP_NOCOPYBITS      | \
                             SWP_NOOWNERZORDER   | \
                             SWP_NOSENDCHANGING  | \
                             SWP_NOSIZE          | \
                             SWP_NOMOVE          | \
                             SWP_NOZORDER        | \
                             SWP_NOREDRAW        | \
                             SWP_NOACTIVATE      | \
                             SWP_FRAMECHANGED    | \
                             SWP_SHOWWINDOW      | \
                             SWP_HIDEWINDOW)
#define HWND_GROUPTOTOP HWND_TOPMOST
/*
 * WARNING:
 * The following structures must NOT be DWORD padded because they are
 * followed by strings, etc that do not have to be DWORD aligned.
 */
#include <pshpack2.h>

/*
 * Chicago dialog template
 */
typedef struct {
    WORD wDlgVer;
    WORD wSignature;
    DWORD dwHelpID;
    DWORD dwExStyle;
    DWORD style;
    WORD cDlgItems;
    short x;
    short y;
    short cx;
    short cy;
} DLGTEMPLATE2;
typedef DLGTEMPLATE2 *LPDLGTEMPLATE2A;
typedef DLGTEMPLATE2 *LPDLGTEMPLATE2W;
#ifdef UNICODE
typedef LPDLGTEMPLATE2W LPDLGTEMPLATE2;
#else
typedef LPDLGTEMPLATE2A LPDLGTEMPLATE2;
#endif // UNICODE
typedef CONST DLGTEMPLATE2 *LPCDLGTEMPLATE2A;
typedef CONST DLGTEMPLATE2 *LPCDLGTEMPLATE2W;
#ifdef UNICODE
typedef LPCDLGTEMPLATE2W LPCDLGTEMPLATE2;
#else
typedef LPCDLGTEMPLATE2A LPCDLGTEMPLATE2;
#endif // UNICODE
/*
 * Dialog item template for NT 1.0a/Chicago (dit2)
 */
typedef struct {
    DWORD dwHelpID;
    DWORD dwExStyle;
    DWORD style;
    short x;
    short y;
    short cx;
    short cy;
    DWORD dwID;
} DLGITEMTEMPLATE2;
typedef DLGITEMTEMPLATE2 *PDLGITEMTEMPLATE2A;
typedef DLGITEMTEMPLATE2 *PDLGITEMTEMPLATE2W;
#ifdef UNICODE
typedef PDLGITEMTEMPLATE2W PDLGITEMTEMPLATE2;
#else
typedef PDLGITEMTEMPLATE2A PDLGITEMTEMPLATE2;
#endif // UNICODE
typedef DLGITEMTEMPLATE2 *LPDLGITEMTEMPLATE2A;
typedef DLGITEMTEMPLATE2 *LPDLGITEMTEMPLATE2W;
#ifdef UNICODE
typedef LPDLGITEMTEMPLATE2W LPDLGITEMTEMPLATE2;
#else
typedef LPDLGITEMTEMPLATE2A LPDLGITEMTEMPLATE2;
#endif // UNICODE

#include <poppack.h> /* Resume normal packing */

/*
 * The driver flags corresponding to these mouse events are
 * shifted to the right by one, e.g.
 *     MOUSEEVENTF_LEFTDOWN >> 1 == MOUSE_LEFT_BUTTON_DOWN
 *
 * The mouse driver sends the fourth and fifth buttons corresponding
 * as button flags, so we define MOUSEEVENTF_ flags INTERNALLY for
 * mimicking the input sent by the driver.
 */

#define MOUSEEVENTF_DRIVER_X1DOWN   0x0080 /* x1 button down */
#define MOUSEEVENTF_DRIVER_X1UP     0x0100 /* x1 button up */
#define MOUSEEVENTF_DRIVER_X2DOWN   0x0200 /* x2 button down */
#define MOUSEEVENTF_DRIVER_X2UP     0x0400 /* x2 button up */
/* Legal MOUSEEVENTF_ flags that indicate a button has been pressed or the wheel moved */
#define MOUSEEVENTF_BUTTONMASK           \
            (MOUSEEVENTF_LEFTDOWN |      \
            MOUSEEVENTF_LEFTUP |         \
            MOUSEEVENTF_RIGHTDOWN |      \
            MOUSEEVENTF_RIGHTUP |        \
            MOUSEEVENTF_MIDDLEDOWN |     \
            MOUSEEVENTF_MIDDLEUP |       \
            MOUSEEVENTF_XDOWN |          \
            MOUSEEVENTF_XUP |            \
            MOUSEEVENTF_WHEEL)

/* MOUSEEVENTF_ flags that indicate useful data in the mouseData field */
#define MOUSEEVENTF_MOUSEDATAMASK         \
            (MOUSEEVENTF_XDOWN |          \
            MOUSEEVENTF_XUP |             \
            MOUSEEVENTF_WHEEL)

typedef DWORD (CALLBACK* GETQUEUESTATUSPROC)(IN UINT flags);
typedef DWORD (CALLBACK* MSGWAITFORMULTIPLEOBJECTSEXPROC)(IN DWORD nCount, IN CONST HANDLE *pHandles, IN DWORD dwMilliseconds, IN DWORD dwWakeMask, IN DWORD dwFlags);
#define MWMO_VALID          0x0007
#define QS_SMSREPLY         0x0200
#define QS_THREADATTACHED   0x0800
#define QS_EXCLUSIVE        0x1000      // wait for these events only!!
#define QS_EVENT            0x2000      // signifies event message
#define QS_TRANSFER         0x4000      // Input was transfered from another thread
//                          0x8000      // unused, but should not be used for external API.
                                        // Win9x has used this for SMSREPLY
#define QS_VALID           (QS_KEY           | \
                            QS_MOUSEMOVE     | \
                            QS_MOUSEBUTTON   | \
                            QS_POSTMESSAGE   | \
                            QS_TIMER         | \
                            QS_PAINT         | \
                            QS_SENDMESSAGE   | \
                            QS_TRANSFER      | \
                            QS_HOTKEY        | \
                            QS_ALLPOSTMESSAGE| \
                            QS_RAWINPUT)

/*
 * QS_EVENT is used to clear the QS_EVENT bit, QS_EVENTSET is used to
 * set the bit.
 *
 * Include QS_SENDMESSAGE because the queue events
 * match what a win3.1 app would see as the QS_SENDMESSAGE bit. Plus 16 bit
 * apps don't even know about QS_EVENT.
 */
#define QS_EVENTSET        (QS_EVENT | QS_SENDMESSAGE)
/*
 * When you add a system metric, be sure to
 * add it to userexts.c in the function Idsi.
 */
#define SM_UNUSED_64            64
#define SM_UNUSED_65            65
#define SM_UNUSED_66            66
#define SM_BOOLEANS             85
/*
 * Add system metrics that don't take space in gpsi->aiSysMet here.
 */
/*
 * To add a BOOLEAN system metric increment SM_ENDBOOLRANGE by 1 and make your
 * SM_XXXX constant that new value.
 */

#define SM_STARTBOOLRANGE       0x2000
#define SM_ENDBOOLRANGE         0x2001
/*
 * When you add a system metric, be sure to
 * add it to userexts.c in the function Idsi.
 */
#if(_WIN32_WINNT >= 0x0501)
typedef int (CALLBACK* GETSYSTEMMETRICSPROC)(IN int nIndex);
#endif /* _WIN32_WINNT >= 0x0501 */
#define PMB_VALID       PMB_ACTIVE

WINUSERAPI
UINT
WINAPI
PaintMenuBar(
    IN HWND hwnd,
    IN HDC hdc,
    IN int iLeftOffset,
    IN int iRightOffset,
    IN int iTopOffset,
    IN DWORD dwFlags);

WINUSERAPI
UINT
WINAPI
CalcMenuBar(
    IN HWND hwnd,
    IN int iLeftOffset,
    IN int iRightOffset,
    IN int iTopOffset,
    IN LPCRECT prcWnd);
WINUSERAPI
int
WINAPI
DrawMenuBarTemp(
    IN HWND,
    IN HDC,
    IN LPCRECT,
    IN HMENU,
    IN HFONT);
WINUSERAPI BOOL WINAPI SetSystemMenu( IN HWND, IN HMENU);
/*
 * MNS_ values are stored in pMenu->fFlags.
 * Low order bits are used for internal MF* flags defined in user.h
 */
#define MNS_LAST            0x04000000
#define MNS_VALID           0xFC000000
#define MIM_MASK                    0x8000001F
#define MNGOF_GAP            0x00000003
#define MNGOF_CROSSBOUNDARY  0x00000004
#define MIIM_MASK        0x000001FF
#define HBMMENU_MIN                 ((HBITMAP)  0)
#define HBMMENU_MBARFIRST           ((HBITMAP)  2)
#define HBMMENU_UNUSED              ((HBITMAP)  4)
#define HBMMENU_MBARLAST            ((HBITMAP)  7)
#define HBMMENU_POPUPFIRST          ((HBITMAP)  8)
#define HBMMENU_POPUPLAST           ((HBITMAP) 11)
#define HBMMENU_MAX                 ((HBITMAP) 12)
/*
 * Make sure to keep this in synch with the MENUITEMINFO structure. It should
 * be equal to the size of the structure pre NT5.
 */
#define SIZEOFMENUITEMINFO95 FIELD_OFFSET(MENUITEMINFO, hbmpItem)
#define TPM_SYSMENU         0x0200L
#define TPM_FIRSTANIBITPOS  10
#define TPM_ANIMATIONBITS   0x3C00L
#if (WINVER >= 0x0500)
#define TPM_VALID      (TPM_LEFTBUTTON   | \
                        TPM_RIGHTBUTTON  | \
                        TPM_LEFTALIGN    | \
                        TPM_CENTERALIGN  | \
                        TPM_RIGHTALIGN   | \
                        TPM_TOPALIGN     | \
                        TPM_VCENTERALIGN | \
                        TPM_BOTTOMALIGN  | \
                        TPM_HORIZONTAL   | \
                        TPM_VERTICAL     | \
                        TPM_NONOTIFY     | \
                        TPM_RECURSE      | \
                        TPM_RETURNCMD    | \
                        TPM_HORPOSANIMATION | \
                        TPM_HORNEGANIMATION | \
                        TPM_VERPOSANIMATION | \
                        TPM_VERNEGANIMATION | \
                        TPM_NOANIMATION     |\
                        TPM_LAYOUTRTL)
#else /* (WINVER >= 0x0500) */
#define TPM_VALID      (TPM_LEFTBUTTON   | \
                        TPM_RIGHTBUTTON  | \
                        TPM_LEFTALIGN    | \
                        TPM_CENTERALIGN  | \
                        TPM_RIGHTALIGN   | \
                        TPM_TOPALIGN     | \
                        TPM_VCENTERALIGN | \
                        TPM_BOTTOMALIGN  | \
                        TPM_HORIZONTAL   | \
                        TPM_VERTICAL     | \
                        TPM_NONOTIFY     | \
                        TPM_RETURNCMD)

#endif /* (WINVER >= 0x0500) */
typedef struct _dropfilestruct {
   DWORD pFiles;                       // offset of file list
   POINT pt;                           // drop point
   BOOL fNC;                           // is it on NonClient area
   BOOL fWide;                         // WIDE character switch
} DROPFILESTRUCT, FAR * LPDROPFILESTRUCT;
#define DT_VALID                    0x0007ffff  /* union of all others */
#undef DT_VALID
#define DT_VALID           (DT_CENTER          | \
                            DT_RIGHT           | \
                            DT_VCENTER         | \
                            DT_BOTTOM          | \
                            DT_WORDBREAK       | \
                            DT_SINGLELINE      | \
                            DT_EXPANDTABS      | \
                            DT_TABSTOP         | \
                            DT_NOCLIP          | \
                            DT_EXTERNALLEADING | \
                            DT_CALCRECT        | \
                            DT_NOPREFIX        | \
                            DT_INTERNAL        | \
                            DT_EDITCONTROL     | \
                            DT_PATH_ELLIPSIS   | \
                            DT_END_ELLIPSIS    | \
                            DT_MODIFYSTRING    | \
                            DT_RTLREADING      | \
                            DT_WORD_ELLIPSIS   | \
                            DT_NOFULLWIDTHCHARBREAK |\
                            DT_HIDEPREFIX      | \
                            DT_PREFIXONLY      )

#define DST_TEXTMAX     0x0002
#define DST_GLYPH       0x0005
#define DST_TYPEMASK    0x0007
#define DST_GRAYSTRING  0x0008
#define DSS_DEFAULT     0x0040
#define DSS_INACTIVE    0x0100
#define DCX_INVALID          0x00000800L
#define DCX_INUSE            0x00001000L
#define DCX_SAVEDRGNINVALID  0x00002000L
#define DCX_REDIRECTED       0x00004000L
#define DCX_OWNDC            0x00008000L

#define DCX_USESTYLE         0x00010000L
#define DCX_NEEDFONT         0x00020000L
#define DCX_NODELETERGN      0x00040000L
#define DCX_NOCLIPCHILDREN   0x00080000L

#define DCX_NORECOMPUTE      0x00100000L
#define DCX_DESTROYTHIS      0x00400000L
#define DCX_CREATEDC         0x00800000L

#define DCX_REDIRECTEDBITMAP 0x08000000L
#define DCX_PWNDORGINVISIBLE 0x10000000L
#define DCX_NOMIRROR         0x40000000L // Don't RTL Mirror DC (RTL_MIRRORING)


#define DCX_MATCHMASK       (DCX_WINDOW           | \
                             DCX_CACHE            | \
                             DCX_REDIRECTED       | \
                             DCX_CLIPCHILDREN     | \
                             DCX_CLIPSIBLINGS     | \
                             DCX_NORESETATTRS     | \
                             DCX_LOCKWINDOWUPDATE | \
                             DCX_CREATEDC)

#define DCX_VALID           (DCX_WINDOW           | \
                             DCX_CACHE            | \
                             DCX_NORESETATTRS     | \
                             DCX_CLIPCHILDREN     | \
                             DCX_CLIPSIBLINGS     | \
                             DCX_PARENTCLIP       | \
                             DCX_EXCLUDERGN       | \
                             DCX_INTERSECTRGN     | \
                             DCX_EXCLUDEUPDATE    | \
                             DCX_INTERSECTUPDATE  | \
                             DCX_LOCKWINDOWUPDATE | \
                             DCX_INVALID          | \
                             DCX_INUSE            | \
                             DCX_SAVEDRGNINVALID  | \
                             DCX_OWNDC            | \
                             DCX_USESTYLE         | \
                             DCX_NEEDFONT         | \
                             DCX_NODELETERGN      | \
                             DCX_NOCLIPCHILDREN   | \
                             DCX_NORECOMPUTE      | \
                             DCX_VALIDATE         | \
                             DCX_DESTROYTHIS      | \
                             DCX_CREATEDC)
/*
 * DCX_MASK define valid DCX flags callable from applications.
 * Note that DCX_USESTYLE and DCX_NODELETERGN should not be here.
 * Themes uses them extensively so they are just an exception.
 */
#define DCX_MASK            (DCX_WINDOW           | \
                             DCX_CACHE            | \
                             DCX_NORESETATTRS     | \
                             DCX_CLIPCHILDREN     | \
                             DCX_CLIPSIBLINGS     | \
                             DCX_PARENTCLIP       | \
                             DCX_EXCLUDERGN       | \
                             DCX_INTERSECTRGN     | \
                             DCX_EXCLUDEUPDATE    | \
                             DCX_INTERSECTUPDATE  | \
                             DCX_LOCKWINDOWUPDATE | \
                             DCX_USESTYLE         | \
                             DCX_NODELETERGN      | \
                             DCX_VALIDATE)

WINUSERAPI
BOOL
WINAPI
AlignRects(
    IN OUT LPRECT arc,
    IN DWORD cCount,
    IN DWORD iPrimary,
    IN DWORD dwFlags);

//
// AlignRects flags
//

#define CUDR_NORMAL             0x0000
#define CUDR_NOSNAPTOGRID       0x0001
#define CUDR_NORESOLVEPOSITIONS 0x0002
#define CUDR_NOCLOSEGAPS        0x0004
#define CUDR_NOPRIMARY          0x0010
#if(_WIN32_WINNT >= 0x0501)
typedef int (CALLBACK* SETWINDOWRGNPROC)(IN HWND hWnd, IN HRGN hRgn, IN BOOL bRedraw);
#endif /* _WIN32_WINNT >= 0x0501 */
#define RDW_REDRAWWINDOW        0x1000  /* Called from RedrawWindow()*/
#define RDW_SUBTRACTSELF        0x2000  /* Subtract self from hrgn   */

#define RDW_COPYRGN             0x4000  /* Copy the passed-in region */
#define RDW_IGNOREUPDATEDIRTY   0x8000  /* Ignore WFUPDATEDIRTY      */
#define RDW_INVALIDATELAYERS    0x00010000 /* Allow layered windows invalidation */

#define RDW_VALIDMASK          (RDW_INVALIDATE      | \
                                RDW_INTERNALPAINT   | \
                                RDW_ERASE           | \
                                RDW_VALIDATE        | \
                                RDW_NOINTERNALPAINT | \
                                RDW_NOERASE         | \
                                RDW_NOCHILDREN      | \
                                RDW_ALLCHILDREN     | \
                                RDW_UPDATENOW       | \
                                RDW_ERASENOW        | \
                                RDW_FRAME           | \
                                RDW_NOFRAME)
#define SW_EXACTTIME        0x0020
#define SW_SCROLLWINDOW     0x8000  /* Called from ScrollWindow() */

#define SW_VALIDFLAGS      (SW_SCROLLWINDOW     | \
                            SW_SCROLLCHILDREN   | \
                            SW_INVALIDATE       | \
                            SW_SMOOTHSCROLL     | \
                            SW_EXACTTIME        | \
                            SW_ERASE)
#if(_WIN32_WINNT >= 0x0501)
typedef BOOL (CALLBACK* ENABLESCROLLBARPROC)(IN HWND hWnd, IN UINT wSBflags, IN UINT wArrows);
#endif /* _WIN32_WINNT >= 0x0501 */
#define ESB_MAX             0x0003
#define SB_DISABLE_MASK     ESB_DISABLE_BOTH
#if(_WIN32_WINNT >= 0x0501)
typedef BOOL (CALLBACK* ADJUSTWINDOWRECTEXPROC)(IN OUT LPRECT lpRect, IN DWORD dwStyle,
        IN BOOL bMenu, IN DWORD dwExStyle);
#endif /* _WIN32_WINNT >= 0x0501 */

/*
 * Help Engine stuff
 *
 * Note: for Chicago this is in winhelp.h and called WINHLP
 */
typedef struct {
    WORD cbData;              /* Size of data                     */
    WORD usCommand;           /* Command to execute               */
    ULONG_PTR ulTopic;        /* Topic/context number (if needed) */
    DWORD ulReserved;         /* Reserved (internal use)          */
    WORD offszHelpFile;       /* Offset to help file in block     */
    WORD offabData;           /* Offset to other data in block    */
} HLP, *LPHLP;

#if(WINVER >= 0x0500)
#define MB_LASTVALIDTYPE MB_CANCELTRYCONTINUE
#else
#define MB_LASTVALIDTYPE MB_RETRYCANCEL
#endif
#define MBEX_VALIDL                 0xf3f7
#define MBEX_VALIDH                 1
WINUSERAPI
int
WINAPI
MessageBoxTimeoutA(
    IN HWND hWnd,
    IN LPCSTR lpText,
    IN LPCSTR lpCaption,
    IN UINT uType,
    IN WORD wLanguageId,
    IN DWORD dwTimeout);
WINUSERAPI
int
WINAPI
MessageBoxTimeoutW(
    IN HWND hWnd,
    IN LPCWSTR lpText,
    IN LPCWSTR lpCaption,
    IN UINT uType,
    IN WORD wLanguageId,
    IN DWORD dwTimeout);
#ifdef UNICODE
#define MessageBoxTimeout  MessageBoxTimeoutW
#else
#define MessageBoxTimeout  MessageBoxTimeoutA
#endif // !UNICODE


#define MB_VALID                   (MB_OK                   | \
                                    MB_OKCANCEL             | \
                                    MB_ABORTRETRYIGNORE     | \
                                    MB_YESNOCANCEL          | \
                                    MB_YESNO                | \
                                    MB_RETRYCANCEL          | \
                                    MB_ICONHAND             | \
                                    MB_ICONQUESTION         | \
                                    MB_ICONEXCLAMATION      | \
                                    MB_ICONASTERISK         | \
                                    MB_DEFBUTTON1           | \
                                    MB_DEFBUTTON2           | \
                                    MB_DEFBUTTON3           | \
                                    MB_DEFBUTTON4           | \
                                    MB_APPLMODAL            | \
                                    MB_SYSTEMMODAL          | \
                                    MB_TASKMODAL            | \
                                    MB_HELP                 | \
                                    MB_TOPMOST              | \
                                    MB_RIGHT                | \
                                    MB_RTLREADING           | \
                                    MB_NOFOCUS              | \
                                    MB_SETFOREGROUND        | \
                                    MB_DEFAULT_DESKTOP_ONLY | \
                                    MB_SERVICE_NOTIFICATION | \
                                    MB_TYPEMASK             | \
                                    MB_USERICON             | \
                                    MB_ICONMASK             | \
                                    MB_DEFMASK              | \
                                    MB_MODEMASK             | \
                                    MB_MISCMASK)
#define CWP_VALID           (CWP_SKIPINVISIBLE | CWP_SKIPDISABLED | CWP_SKIPTRANSPARENT)
#define COLOR_3DALTFACE         25
#if(WINVER >= 0x0501)
#define COLOR_ENDCOLORS         COLOR_MENUBAR
#else
#define COLOR_ENDCOLORS         COLOR_INFOBK
#endif /* WINVER >= 0x0501 */
#define COLOR_MAX               (COLOR_ENDCOLORS+1)
WINUSERAPI
HANDLE
WINAPI
SetSysColorsTemp(
    IN CONST COLORREF *,
    IN CONST HBRUSH *,
    IN UINT_PTR wCnt);
/*
 * RTL Mirroring APIs (RTL_MIRRORING)
 */

WINUSERAPI
BOOL
WINAPI
SetDeskWallpaper(
    IN LPCSTR lpString);

WINUSERAPI
HWND
WINAPI
CreateDialogIndirectParamAorW(
    IN HANDLE hmod,
    IN LPCDLGTEMPLATE lpDlgTemplate,
    IN HWND hwndOwner,
    IN DLGPROC lpDialogFunc,
    IN LPARAM dwInitParam,
    IN UINT fAnsi);

WINUSERAPI
INT_PTR
WINAPI
DialogBoxIndirectParamAorW(
    IN HINSTANCE hmod,
    IN LPCDLGTEMPLATEW lpDlgTemplate,
    IN HWND hwndOwner,
    IN DLGPROC lpDialogFunc,
    IN LPARAM dwInitParam,
    IN UINT fAnsiFlags);

WINUSERAPI
void
WINAPI
LoadLocalFonts(void);

WINUSERAPI
UINT
WINAPI
UserRealizePalette(IN HDC hdc);

WINUSERAPI BOOL    WINAPI  SetShellWindow( IN HWND);
WINUSERAPI BOOL    WINAPI  SetShellWindowEx( IN HWND, IN HWND);
WINUSERAPI HWND    WINAPI  GetProgmanWindow(void);
WINUSERAPI BOOL    WINAPI  SetProgmanWindow( IN HWND);
WINUSERAPI HWND    WINAPI  GetTaskmanWindow(void);
WINUSERAPI BOOL    WINAPI  SetTaskmanWindow( IN HWND);
WINUSERAPI
BOOL
WINAPI
IsWindowInDestroy(IN HWND hwnd);

WINUSERAPI
BOOL
WINAPI
IsServerSideWindow(IN HWND hwnd);
WINUSERAPI HWND WINAPI GetNextQueueWindow ( IN HWND hWnd, IN INT nCmd);
#define MF_CHANGE_VALID   (MF_INSERT          | \
                           MF_CHANGE          | \
                           MF_APPEND          | \
                           MF_DELETE          | \
                           MF_REMOVE          | \
                           MF_BYCOMMAND       | \
                           MF_BYPOSITION      | \
                           MF_SEPARATOR       | \
                           MF_ENABLED         | \
                           MF_GRAYED          | \
                           MF_DISABLED        | \
                           MF_UNCHECKED       | \
                           MF_CHECKED         | \
                           MF_USECHECKBITMAPS | \
                           MF_STRING          | \
                           MF_BITMAP          | \
                           MF_OWNERDRAW       | \
                           MF_POPUP           | \
                           MF_MENUBARBREAK    | \
                           MF_MENUBREAK       | \
                           MF_UNHILITE        | \
                           MF_HILITE          | \
                           MF_SYSMENU)

#define MF_VALID          (MF_CHANGE_VALID    | \
                           MF_HELP            | \
                           MF_MOUSESELECT)

#define MFT_MASK            0x00036B64L
#define MFS_HOTTRACK        MF_APPEND
#define MFS_MASK            0x0000108BL
#define MFS_HOTTRACKDRAWN   0x10000000L
#define MFS_CACHEDBMP       0x20000000L
#define MFS_BOTTOMGAPDROP   0x40000000L
#define MFS_TOPGAPDROP      0x80000000L
#define MFS_GAPDROP         0xC0000000L

#define MFR_POPUP           0x01
#define MFR_END             0x80

#define MFT_OLDAPI_MASK     0x00006B64L
#define MFS_OLDAPI_MASK     0x0000008BL
#define MFT_NONSTRING       0x00000904L
#define MFT_BREAK           0x00000060L
typedef struct {        // version 1
    DWORD dwHelpID;
    DWORD fType;
    DWORD fState;
    DWORD menuId;
    WORD  wResInfo;
    WCHAR mtString[1];
} MENUITEMTEMPLATE2, *PMENUITEMTEMPLATE2;
#define SC_LAMEBUTTON   0xF190
#define IDC_NWPEN           MAKEINTRESOURCE(32531)
#define IDC_HUNG            MAKEINTRESOURCE(32632)
WINUSERAPI UINT PrivateExtractIconExA(
    IN LPCSTR szFileName,
    IN int      nIconIndex,
    OUT HICON   *phiconLarge,
    OUT HICON   *phiconSmall,
    IN UINT     nIcons);
WINUSERAPI UINT PrivateExtractIconExW(
    IN LPCWSTR szFileName,
    IN int      nIconIndex,
    OUT HICON   *phiconLarge,
    OUT HICON   *phiconSmall,
    IN UINT     nIcons);
#ifdef UNICODE
#define PrivateExtractIconEx  PrivateExtractIconExW
#else
#define PrivateExtractIconEx  PrivateExtractIconExA
#endif // !UNICODE
#define LR_GLOBAL           0x0100
#define LR_ENVSUBST         0x0200
#define LR_ACONFRAME        0x0400
#define LR_CREATEREALDIB    0x0800
#define LR_VALID            0xF8FF
#define DI_VALID       (DI_MASK | DI_IMAGE | DI_COMPAT | DI_DEFAULTSIZE | DI_NOMIRROR)
#define OBM_STARTUP         32733
#define OBM_TRUETYPE        32732
#define OBM_HELP            32731
#define OBM_HELPD           32730
#define OBM_RDRVERT         32559
#define OBM_RDRHORZ         32660
#define OBM_RDR2DIM         32661
#define OCR_NWPEN           32631
#define OCR_HELP            32651


#define OCR_RDRVERT         32652
#define OCR_RDRHORZ         32653
#define OCR_RDR2DIM         32654
#define OCR_RDRNORTH        32655
#define OCR_RDRSOUTH        32656
#define OCR_RDRWEST         32657
#define OCR_RDREAST         32658
#define OCR_RDRNORTHWEST    32659
#define OCR_RDRNORTHEAST    32660
#define OCR_RDRSOUTHWEST    32661
#define OCR_RDRSOUTHEAST    32662

#define OCR_AUTORUN         32663

/*
 * Default Cursor IDs to get original image from User
 */
#define OCR_FIRST_DEFAULT           100
#define OCR_ARROW_DEFAULT           100
#define OCR_IBEAM_DEFAULT           101
#define OCR_WAIT_DEFAULT            102
#define OCR_CROSS_DEFAULT           103
#define OCR_UPARROW_DEFAULT         104
#define OCR_SIZENWSE_DEFAULT        105
#define OCR_SIZENESW_DEFAULT        106
#define OCR_SIZEWE_DEFAULT          107
#define OCR_SIZENS_DEFAULT          108
#define OCR_SIZEALL_DEFAULT         109
#define OCR_NO_DEFAULT              110
#define OCR_APPSTARTING_DEFAULT     111
#define OCR_HELP_DEFAULT            112
#define OCR_NWPEN_DEFAULT           113
#define OCR_HAND_DEFAULT            114
#define OCR_ICON_DEFAULT            115
#define OCR_AUTORUN_DEFAULT         116
#define COCR_CONFIGURABLE           (OCR_AUTORUN_DEFAULT - OCR_FIRST_DEFAULT + 1)
/* Default IDs for original User images */
#define OIC_FIRST_DEFAULT           100
#define OIC_APPLICATION_DEFAULT     100
#define OIC_HAND_DEFAULT            101
#define OIC_WARNING_DEFAULT         101
#define OIC_QUESTION_DEFAULT        102
#define OIC_EXCLAMATION_DEFAULT     103
#define OIC_ERROR_DEFAULT           103
#define OIC_ASTERISK_DEFAULT        104
#define OIC_INFORMATION_DEFAULT     104
#define OIC_WINLOGO_DEFAULT         105
#define COIC_CONFIGURABLE           (OIC_WINLOGO_DEFAULT - OIC_FIRST_DEFAULT + 1)
#define IDUSERICON      20
#define ES_FMTMASK          0x0003L
#define ES_COMBOBOX         0x0200L
#define EM_SETFONT              0x00C3 /* no longer suported */
#define EM_SETWORDBREAK         0x00CA /* no longer suported */
#define EM_MSGMAX               0x00DA
#define BS_IMAGEMASK        0x000000C0L
#define BS_HORZMASK         0x00000300L
#define BS_VERTMASK         0x00000C00L
#define BS_ALIGNMASK        0x00000F00L
#define SS_TEXTMAX0         0x00000002L
#define SS_TEXTMIN1         0x0000000BL
#define SS_TEXTMAX1         0x0000000DL
#define ISSSTEXTOROD(bType) (((bType) <= SS_TEXTMAX0) \
                                || (((bType) >= SS_TEXTMIN1) && ((bType) <= SS_TEXTMAX1)))
#define DDL_NOFILES         0x1000
#define DDL_VALID          (DDL_READWRITE  | \
                            DDL_READONLY   | \
                            DDL_HIDDEN     | \
                            DDL_SYSTEM     | \
                            DDL_DIRECTORY  | \
                            DDL_ARCHIVE    | \
                            DDL_POSTMSGS   | \
                            DDL_DRIVES     | \
                            DDL_EXCLUSIVE)
/*
 * Valid dialog style bits for Chicago compatibility.
 */
//#define DS_VALID_FLAGS (DS_ABSALIGN|DS_SYSMODAL|DS_LOCALEDIT|DS_SETFONT|DS_MODALFRAME|DS_NOIDLEMSG | DS_SETFOREGROUND)
#define DS_VALID_FLAGS   0x1FFF

#define SCDLG_CLIENT            0x0001
#define SCDLG_ANSI              0x0002
#define SCDLG_NOREVALIDATE      0x0004
#define SCDLG_16BIT             0x0008      // Created for a 16 bit thread; common dialogs

#define DS_VALID31          0x01e3L
#define DS_VALID40          0x7FFFL
#define DS_RECURSE      DS_CONTROL  /* BOGUS GOING AWAY */
#define DS_COMMONDIALOG     0x4000L

#define DS_NONBOLD  DS_3DLOOK   /* BOGUS GOING AWAY */
#define LBCB_CARETON            0x01A3
#define LBCB_CARETOFF           0x01A4
#define LB_INSERTSTRINGUPPER    0x01AA
#define LB_INSERTSTRINGLOWER    0x01AB
#define LB_ADDSTRINGUPPER       0x01AC
#define LB_ADDSTRINGLOWER       0x01AD
#define LBCB_STARTTRACK         0x01AE
#define LBCB_ENDTRACK           0x01AF
#define CBEC_SETCOMBOFOCUS          (CB_MSGMAX+1)
#define CBEC_KILLCOMBOFOCUS         (CB_MSGMAX+2)
#define SIF_RETURNOLDPOS    0x1000
#define SIF_NOSCROLL        0x2000
#define SIF_MASK            0x701F
#if(_WIN32_WINNT >= 0x0501)
typedef BOOL (CALLBACK* GETSCROLLINFOPROC)(IN HWND, IN int, IN OUT LPSCROLLINFO);
typedef int  (CALLBACK* SETSCROLLINFOPROC)(IN HWND, IN int, IN LPCSCROLLINFO, IN BOOL);
#endif /* _WIN32_WINNT >= 0x0501 */
#define HELP_HB_NORMAL    0x0000L
#define HELP_HB_STRING    0x0100L
#define HELP_HB_STRUCT    0x0200L
#define GR_MAXOBJECT      1
#if(_WIN32_WINNT >= 0x0500)
/*
 * Query win32k statistics -internal
 * QUERYUSER_CS         Query critical section usage
 * QUERYUSER_HANDLES    Query user per-process user handle count
 */

#define QUC_PID_TOTAL           0xffffffff
#define QUERYUSER_HANDLES       0x1
#if defined (USER_PERFORMANCE)
#define QUERYUSER_CS            0x2

/*
 *  The counters in CSSTATISTICS refer to the USER critical section:
 *      cExclusive counts how many times the CS was aquired exclusive
 *      cShared counts how many times the CS was aquired shared
 *      i64TimeExclusive counts the time (NtQueryPerformanceCounter() units)
 *      spent in the resource since the last query.
 */
typedef struct _tagCSStatistics {
        DWORD   cExclusive;
        DWORD   cShared;
        __int64 i64TimeExclusive;
} CSSTATISTICS;
#endif // USER_PERFORMANCE

BOOL
WINAPI
QueryUserCounters(
    IN  DWORD   dwQueryType,
    IN  LPVOID  pvIn,
    IN  DWORD   dwInSize,
    OUT LPVOID  pvResult,
    IN  DWORD   dwOutSize
);
#endif /* _WIN32_WINNT >= 0x0500 */
#define SPI_TIMEOUTS                0x0007
#define SPI_KANJIMENU               0x0008
#define SPI_UNUSED39                0x0027
#define SPI_UNUSED40                0x0028
#define SPI_UNUSED108              0x006C
#define SPI_UNUSED109              0x006D
#define SPI_MAX                   0x0074

/*
 * ADDING NEW SPI_* VALUES
 * If the value is a BOOL, it should be added after SPI_STARTBOOLRANGE
 * If the value is a DWORD, it should be added after SPI_STARTDWORDRANGE
 * If the value is a structure or a string, go ahead and setup SPI_START*RANGE....
 */

/*
 * If adding a new SPI value in the following ranges:
 * -You must define both SPI_GET* and SPI_SET* using consecutive numbers
 * -The low order bit of SPI_GET* must be 0
 * -The low order bit of SPI_SET* must be 1
 * -Properly update SPI_MAX*RANGE
 * -Add the default value to kernel\globals.c in the proper *CPUserPreferences* variable
 * -Add the default value to the proper registry hives.
 * -If your value requires some special validation, do so in kernel\ntstubs.c
 * -If you find something wrong in this documentation, FIX IT!.
 */
#define SPIF_SET                  0x0001
#define SPIF_BOOL                 0x1000
#define SPIF_DWORD                0x2000
#define SPIF_RANGETYPEMASK        0x3000
/*
 * BOOLeans range.
 * For GET, pvParam is a pointer to a BOOL
 * For SET, pvParam is the value
 */
#define SPI_STARTBOOLRANGE                  0x1000
#define SPI_UNUSED1010                      0x1010
#define SPI_UNUSED1011                      0x1011
/*
 * All SPI_s for UI effects must be < SPI_GETUIEFFECTS
 */
#define SPI_MAXBOOLRANGE                    0x1040
#define SPI_BOOLRANGECOUNT ((SPI_MAXBOOLRANGE - SPI_STARTBOOLRANGE) / 2)
#define SPI_BOOLMASKDWORDSIZE (((SPI_BOOLRANGECOUNT - 1) / 32) + 1)

/*
 * DWORDs range.
 * For GET, pvParam is a pointer to a DWORD
 * For SET, pvParam is the value
 */
#define SPI_STARTDWORDRANGE                 0x2000
#define FE_FONTSMOOTHINGTYPE_VALID          (FE_FONTSMOOTHINGSTANDARD | FE_FONTSMOOTHINGCLEARTYPE | FE_FONTSMOOTHINGDOCKING)
#define FE_FONTSMOOTHINGORIENTATION_VALID          (FE_FONTSMOOTHINGORIENTATIONRGB)
#define SPI_MAXDWORDRANGE                   0x2014
#define SPI_DWORDRANGECOUNT ((SPI_MAXDWORDRANGE - SPI_STARTDWORDRANGE) / 2)
#define SPIF_VALID            (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE)
#define ARW_VALID                   0x000FL
#define MAX_SCHEME_NAME_SIZE 128
#define CDS_RAWMODE         0x00000040
#define CDS_TRYCLOSEST      0x00000080
#define CDS_EXCLUSIVE       0x80000000
#define CDS_VALID           0xD00000FF
#define EDS_SHOW_DUPLICATES           0x00000001
#define EDS_SHOW_MONITOR_NOT_CAPABLE  0x00000002
VOID LoadRemoteFonts(VOID);
#if(_WIN32_WINNT >= 0x0501)
typedef BOOL (CALLBACK* SYSTEMPARAMETERSINFO) (
    IN UINT,
    IN UINT,
    IN OUT PVOID,
    IN UINT);
#endif /* _WIN32_WINNT >= 0x0501 */
#define FKF_VALID           0x0000007F
#define SKF_VALID           0x000001FF
#define SKF_STATEINFO         0xffff0000
#define MKF_VALID           0x000000FF
#define MKF_STATEINFO       0xB3000000
#define ATF_VALID           0x00000003
#define SSF_VALID           0x00000007
#define TKF_VALID           0x0000003F

WINUSERAPI VOID WINAPI RegisterNetworkCapabilities( IN DWORD dwBitsToSet, IN DWORD dwValues);
#define RNC_NETWORKS              0x00000001
#define RNC_LOGON                 0x00000002

#if !defined(WINNT)     // Win95 version of EndTask
WINUSERAPI DWORD WINAPI EndTask( IN HWND hwnd, IN DWORD idProcess, IN LPSTR lpszCaption, IN DWORD dwFlags);
#define ET_ALLOWFORWAIT     0x00000001
#define ET_TRYTOKILLNICELY  0x00000002
#define ET_NOUI             0x00000004
#define ET_NOWAIT           0x00000008
#define ET_VALID           (ET_ALLOWFORWAIT | ET_TRYTOKILLNICELY | ET_NOUI | ET_NOWAIT)
#endif

#define LOGON_LOGOFF          0
#define LOGON_INPUT_TIMEOUT   1
#define LOGON_RESTARTSHELL    2


#if (_WIN32_WINNT >= 0x0500)
#define LOGON_ACCESSNOTIFY    3
#define LOGON_POWERSTATE      4
#define LOGON_LOCKWORKSTATION 5

#define SESSION_RECONNECTED   6
#define SESSION_DISCONNECTED  7
#define SESSION_LOGOFF        8
#define LOGON_PLAYEVENTSOUND  9
#if(_WIN32_WINNT >= 0x0501)
#define LOGON_POWEREVENT      10
#endif /* _WIN32_WINNT >= 0x0501 */
#define LOGON_LOGOFFCANCELED  11
#if(_WIN32_WINNT >= 0x0501)
#define LOGON_SHOW_POWER_MESSAGE 12
#define LOGON_REMOVE_POWER_MESSAGE 13
#define SESSION_PRERECONNECT  14
#define SESSION_DISABLESCRNSAVER   15
#define SESSION_ENABLESCRNSAVER     16
#define SESSION_PRERECONNECTDESKTOPSWITCH  17
#define SESSION_HELPASSISTANTSHADOWSTART   18
#define SESSION_HELPASSISTANTSHADOWFINISH  19
#define SESSION_DISCONNECTPIPE     20

#define LOCK_NORMAL           0
#define LOCK_RESUMEHIBERNATE  1
#endif /* _WIN32_WINNT >= 0x0501 */

/*
 * Notification codes for WM_DESKTOPNOTIFY
 */
#define DESKTOP_RELOADWALLPAPER 0

#define    ACCESS_STICKYKEYS            0x0001
#define    ACCESS_FILTERKEYS            0x0002
#define    ACCESS_MOUSEKEYS             0x0003
#define    ACCESS_TOGGLEKEYS            0x0004
#define    ACCESS_HIGHCONTRAST          0x0005  // notification dlg
#define    ACCESS_UTILITYMANAGER        0x0006
#define    ACCESS_HIGHCONTRASTON        0x0008
#define    ACCESS_HIGHCONTRASTOFF       0x0009
#define    ACCESS_HIGHCONTRASTCHANGE    0x000A
#define    ACCESS_HIGHCONTRASTONNOREG   0x000C
#define    ACCESS_HIGHCONTRASTOFFNOREG  0x000D
#define    ACCESS_HIGHCONTRASTCHANGENOREG 0x000E
#define    ACCESS_HIGHCONTRASTNOREG  0x0004


#define USER_SOUND_DEFAULT                0      // default MB sound
#define USER_SOUND_SYSTEMHAND             1      // MB_ICONHAND shifted
#define USER_SOUND_SYSTEMQUESTION         2      // MB_ICONQUESTION shifted
#define USER_SOUND_SYSTEMEXCLAMATION      3      // MB_ICONEXCLAMATION shifted
#define USER_SOUND_SYSTEMASTERISK         4      // MB_ICONASTERISK shifted
#define USER_SOUND_MENUPOPUP              5
#define USER_SOUND_MENUCOMMAND            6
#define USER_SOUND_OPEN                   7
#define USER_SOUND_CLOSE                  8
#define USER_SOUND_RESTOREUP              9
#define USER_SOUND_RESTOREDOWN            10
#define USER_SOUND_MINIMIZE               11
#define USER_SOUND_MAXIMIZE               12
#define USER_SOUND_SNAPSHOT               13
#define USER_SOUND_MAX                    14


#ifdef _NTPOAPI_
typedef struct tagPOWERSTATEPARAMS {
    POWER_ACTION        SystemAction;
    SYSTEM_POWER_STATE  MinSystemState;
    ULONG               Flags;
    BOOL                FullScreenMode;
} POWERSTATEPARAMS, *PPOWERSTATEPARAMS;
#endif

#endif

#define LOGON_FLG_MASK      0xF0000000
#define LOGON_FLG_SHIFT     28

#define STARTF_DESKTOPINHERIT   0x40000000
#define STARTF_SCREENSAVER      0x80000000

#define WSS_ERROR       0
#define WSS_BUSY        1
#define WSS_IDLE        2

#define DTF_CENTER    0x00   /* Center the bitmap (default)                  */
#define DTF_TILE      0x01   /* Tile the bitmap                              */
#define DTF_STRETCH   0x02   /* Stretch bitmap to cover screen.              */
#if 0 /* the following have not been used anywhere in NT since at least 1992 */
#define DTF_NOPALETTE 0x04   /* Realize palette, otherwise match to default. */
#define DTF_RETAIN    0x08   /* Retain bitmap, ignore win.ini changes        */
#define DTF_FIT       0x10   /* Fit the bitmap to the screen (scaled).       */
#endif

#ifdef _INC_DDEMLH
BOOL DdeIsDataHandleReadOnly(
    IN HDDEDATA hData);

int DdeGetDataHandleFormat(
    IN HDDEDATA hData);

DWORD DdeGetCallbackInstance(VOID);
#endif /* defined _INC_DDEMLH */

#define LPK_TABBED_TEXT_OUT 0
#define LPK_PSM_TEXT_OUT    1
#define LPK_DRAW_TEXT_EX    2
#define LPK_EDIT_CONTROL    3

VOID
WINAPI
InitializeLpkHooks(
    IN CONST FARPROC *lpfpLpkHooks
);

WINUSERAPI
HWND
WINAPI
WOWFindWindow(
    IN LPCSTR lpClassName,
    IN LPCSTR lpWindowName);

int
WINAPI
InternalDoEndTaskDlg(
    IN TCHAR* pszTitle);

DWORD
WINAPI
InternalWaitCancel(
    IN HANDLE handle,
    IN DWORD dwMilliseconds);

HANDLE
WINAPI
InternalCreateCallbackThread(
    IN HANDLE hProcess,
    IN ULONG_PTR lpfn,
    IN ULONG_PTR dwData);

WINUSERAPI
UINT
WINAPI
GetInternalWindowPos(
    IN HWND hWnd,
    OUT LPRECT lpRect,
    IN LPPOINT lpPoint);

WINUSERAPI
BOOL
WINAPI
SetInternalWindowPos(
    IN HWND hWnd,
    IN UINT cmdShow,
    IN LPRECT lpRect,
    IN LPPOINT lpPoint);

WINUSERAPI
BOOL
WINAPI
CalcChildScroll(
    IN HWND hWnd,
    IN UINT sb);

WINUSERAPI
BOOL
WINAPI
RegisterTasklist(
    IN HWND hWndTasklist);

WINUSERAPI
BOOL
WINAPI
CascadeChildWindows(
    IN HWND hWndParent,
    IN UINT flags);

WINUSERAPI
BOOL
WINAPI
TileChildWindows(
    IN HWND hWndParent,
    IN UINT flags);

/*
 * Services support routines
 */
WINUSERAPI
BOOL
WINAPI
RegisterServicesProcess(
    IN DWORD dwProcessId);

/*
 * Logon support routines
 */
WINUSERAPI
BOOL
WINAPI
RegisterLogonProcess(
    IN DWORD dwProcessId,
    IN BOOL fSecure);

WINUSERAPI
UINT
WINAPI
LockWindowStation(
    IN HWINSTA hWindowStation);

WINUSERAPI
BOOL
WINAPI
UnlockWindowStation(
    IN HWINSTA hWindowStation);

WINUSERAPI
BOOL
WINAPI
SetWindowStationUser(
    IN HWINSTA hWindowStation,
    IN PLUID pLuidUser,
    IN PSID pSidUser,
    IN DWORD cbSidUser);

WINUSERAPI
BOOL
WINAPI
SetDesktopBitmap(
    IN HDESK hdesk,
    IN HBITMAP hbmWallpaper,
    IN DWORD dwStyle);

WINUSERAPI
BOOL
WINAPI
SetLogonNotifyWindow(
    IN HWND    hWndNotify);

WINUSERAPI
UINT
WINAPI
GetIconId(
    IN HANDLE hRes,
    IN LPSTR lpszType);

WINUSERAPI
int
WINAPI
CriticalNullCall(
    VOID);

WINUSERAPI
int
WINAPI
NullCall(
    VOID);

WINUSERAPI
VOID
WINAPI
UserNotifyConsoleApplication(
    IN DWORD dwProcessId);

WINUSERAPI
BOOL
WINAPI
EnterReaderModeHelper(
    HWND hwnd);

/*
 * Reserved console space.
 *
 * This was moved from the console code so that we can localize it
 * in one place.  This was necessary for dealing with the background
 * color, which we need to have for the hungapp drawing.  These are
 * stored in the extra-window-bytes of each console.
 */
#define GWL_CONSOLE_WNDALLOC  (3 * sizeof(DWORD))
#define GWL_CONSOLE_PID       0
#define GWL_CONSOLE_TID       4
#define GWL_CONSOLE_BKCOLOR   8


VOID vFontSweep();
VOID vLoadLocalT1Fonts();
VOID vLoadRemoteT1Fonts();


#ifndef NOMSG

#define TM_INMENUMODE     0x0001
#define TM_POSTCHARBREAKS 0x0002

WINUSERAPI
BOOL
WINAPI
TranslateMessageEx(
    IN CONST MSG *lpMsg,
    IN UINT flags);

#endif /* !NOMSG */

/*
 * Those values can be specified as nAnsiChar for MBToWCSEx
 * USER_AWCONV_COUNTSTRING:      Count the length of the string including trailing \0
 * USER_AWCONV_COUNTSTRINGSZ:    Count the length of the string excluding trailing \0
 *
 * Note: The result includes trailing \0 if USER_AWCONV_COUNTSTRING is specified.
 *  USER_AWCONV_COUNTSTRINGSZ will not null-terminate the restult string. It may return
 * 0 if the source strlen() == 0.
 */
#define USER_AWCONV_COUNTSTRING          (-1)
#define USER_AWCONV_COUNTSTRINGSZ        (-2)


WINUSERAPI
int
WINAPI
WCSToMBEx(
    IN WORD wCodePage,
    IN LPCWSTR pUnicodeString,
    IN int cbUnicodeChar,
    OUT LPSTR *ppAnsiString,
    IN int nAnsiChar,
    IN BOOL bAllocateMem);

WINUSERAPI
int
WINAPI
MBToWCSEx(
    IN WORD wCodePage,
    IN LPCSTR pAnsiString,
    IN int nAnsiChar,
    OUT LPWSTR *ppUnicodeString,
    IN int cbUnicodeChar,
    IN BOOL bAllocateMem);

#define UPUSP_USERLOGGEDON        0x00000001
#define UPUSP_POLICYCHANGE        0x00000002
#define UPUSP_REMOTESETTINGS      0x00000004


#define UPUSP_USERLOGGEDON        0x00000001
#define UPUSP_POLICYCHANGE        0x00000002
#define UPUSP_REMOTESETTINGS      0x00000004

WINUSERAPI
BOOL
WINAPI
UpdatePerUserSystemParameters(
    IN HANDLE hToken,
    IN DWORD  dwFlags);

typedef VOID  (APIENTRY *PFNW32ET)(VOID);

WINUSERAPI
BOOL
WINAPI
RegisterUserHungAppHandlers(
    IN PFNW32ET pfnW32EndTask,
    IN HANDLE   hEventWowExec);

WINUSERAPI
ATOM
WINAPI
RegisterClassWOWA(
    IN PVOID   lpWndClass,
    IN LPDWORD pdwWOWstuff);

WINUSERAPI
LONG
WINAPI
GetClassWOWWords(
    IN HINSTANCE hInstance,
    OUT LPCTSTR pString);

WINUSERAPI
DWORD
WINAPI
CurrentTaskLock(
    IN DWORD hlck);

WINUSERAPI
HDESK
WINAPI
GetInputDesktop(
    VOID);

#define WINDOWED       0
#define FULLSCREEN     1
#define GDIFULLSCREEN  2
#define FULLSCREENMIN  4


#define WCSToMB(pUnicodeString, cbUnicodeChar, ppAnsiString, nAnsiChar,\
bAllocateMem)\
WCSToMBEx(0, pUnicodeString, cbUnicodeChar, ppAnsiString, nAnsiChar, bAllocateMem)

#define MBToWCS(pAnsiString, nAnsiChar, ppUnicodeString, cbUnicodeChar,\
bAllocateMem)\
MBToWCSEx(0, pAnsiString, nAnsiChar, ppUnicodeString, cbUnicodeChar, bAllocateMem)

#define ID(string) (((ULONG_PTR)string & ~0x0000ffff) == 0)

/*
 * For setting RIT timers and such.  GDI uses this for the cursor-restore
 * timer.
 */
#define TMRF_READY      0x0001
#define TMRF_SYSTEM     0x0002
#define TMRF_RIT        0x0004
#define TMRF_INIT       0x0008
#define TMRF_ONESHOT    0x0010
#define TMRF_WAITING    0x0020
#define TMRF_PTIWINDOW  0x0040


/*
 * For GDI SetAbortProc support.
 */

WINUSERAPI
int
WINAPI
CsDrawTextA(
    IN HDC hDC,
    IN LPCSTR lpString,
    IN int nCount,
    IN LPRECT lpRect,
    IN UINT uFormat);
WINUSERAPI
int
WINAPI
CsDrawTextW(
    IN HDC hDC,
    IN LPCWSTR lpString,
    IN int nCount,
    IN LPRECT lpRect,
    IN UINT uFormat);
#ifdef UNICODE
#define CsDrawText  CsDrawTextW
#else
#define CsDrawText  CsDrawTextA
#endif // !UNICODE

WINUSERAPI
LONG
WINAPI
CsTabbedTextOutA(
    IN HDC hDC,
    IN int X,
    IN int Y,
    IN LPCSTR lpString,
    IN int nCount,
    IN int nTabPositions,
    IN LPINT lpnTabStopPositions,
    IN int nTabOrigin);
WINUSERAPI
LONG
WINAPI
CsTabbedTextOutW(
    IN HDC hDC,
    IN int X,
    IN int Y,
    IN LPCWSTR lpString,
    IN int nCount,
    IN int nTabPositions,
    IN LPINT lpnTabStopPositions,
    IN int nTabOrigin);
#ifdef UNICODE
#define CsTabbedTextOut  CsTabbedTextOutW
#else
#define CsTabbedTextOut  CsTabbedTextOutA
#endif // !UNICODE

WINUSERAPI
int
WINAPI
CsFrameRect(
    IN HDC hDC,
    IN CONST RECT *lprc,
    IN HBRUSH hbr);

#ifdef UNICODE
#define CsDrawText      CsDrawTextW
#define CsTabbedTextOut CsTabbedTextOutW
#else /* !UNICODE */
#define CsDrawText      CsDrawTextA
#define CsTabbedTextOut CsTabbedTextOutA
#endif /* !UNICODE */

/*
 * Custom Cursor action.
 */
WINUSERAPI
HCURSOR
WINAPI
GetCursorFrameInfo( // Obsolete? - IanJa
    IN HCURSOR hcur,
    OUT LPWSTR id,
    IN int iFrame,
    OUT LPDWORD pjifRate,
    OUT LPINT pccur);


/*
 * WOW: replace cursor/icon handle
 */

WINUSERAPI
BOOL
WINAPI
SetCursorContents( IN HCURSOR hCursor, IN HCURSOR hCursorNew);


#ifdef WX86

/*
 *  Wx86
 *  export from wx86.dll to convert an x86 hook proc to risc address.
 */
typedef
PVOID
(*PFNWX86HOOKCALLBACK)(
    SHORT HookType,
    PVOID HookProc
    );

typedef
HMODULE
(*PFNWX86LOADX86DLL)(
    LPCWSTR lpLibFileName,
    DWORD   dwFlags
    );


typedef
BOOL
(*PFNWX86FREEX86DLL)(
    HMODULE hMod
    );

#endif







typedef struct _TAG {
    DWORD type;
    DWORD style;
    DWORD len;
} TAG, *PTAG;

#define MAKETAG(a, b, c, d) (DWORD)(a | (b<<8) | ((DWORD)c<<16) | ((DWORD)d<<24))


/* Valid TAG types. */

/* 'ASDF' (CONT) - Advanced Systems Data Format */

#define TAGT_ASDF MAKETAG('A', 'S', 'D', 'F')


/* 'RAD ' (CONT) - ?R Animation ?Definition (an aggregate type) */

#define TAGT_RAD  MAKETAG('R', 'A', 'D', ' ')


/* 'ANIH' (DATA) - ANImation Header */
/* Contains an ANIHEADER structure. */

#define TAGT_ANIH MAKETAG('A', 'N', 'I', 'H')


/*
 * 'RATE' (DATA) - RATE table (array of jiffies)
 * Contains an array of JIFs.  Each JIF specifies how long the corresponding
 * animation frame is to be displayed before advancing to the next frame.
 * If the AF_SEQUENCE flag is set then the count of JIFs == anih.cSteps,
 * otherwise the count == anih.cFrames.
 */
#define TAGT_RATE MAKETAG('R', 'A', 'T', 'E')

/*
 * 'SEQ ' (DATA) - SEQuence table (array of frame index values)
 * Countains an array of DWORD frame indices.  anih.cSteps specifies how
 * many.
 */
#define TAGT_SEQ  MAKETAG('S', 'E', 'Q', ' ')


/* 'ICON' (DATA) - Windows ICON format image (replaces MPTR) */

#define TAGT_ICON MAKETAG('I', 'C', 'O', 'N')


/* 'TITL' (DATA) - TITLe string (can be inside or outside aggregates) */
/* Contains a single ASCIIZ string that titles the file. */

#define TAGT_TITL MAKETAG('T', 'I', 'T', 'L')


/* 'AUTH' (DATA) - AUTHor string (can be inside or outside aggregates) */
/* Contains a single ASCIIZ string that indicates the author of the file. */

#define TAGT_AUTH MAKETAG('A', 'U', 'T', 'H')



#define TAGT_AXOR MAKETAG('A', 'X', 'O', 'R')


/* Valid TAG styles. */

/* 'CONT' - CONTainer chunk (contains other DATA and CONT chunks) */

#define TAGS_CONT MAKETAG('C', 'O', 'N', 'T')


/* 'DATA' - DATA chunk */

#define TAGS_DATA MAKETAG('D', 'A', 'T', 'A')

typedef DWORD JIF, *PJIF;

typedef struct _ANIHEADER {     /* anih */
    DWORD cbSizeof;
    DWORD cFrames;
    DWORD cSteps;
    DWORD cx, cy;
    DWORD cBitCount, cPlanes;
    JIF   jifRate;
    DWORD fl;
} ANIHEADER, *PANIHEADER;

/* If the AF_ICON flag is specified the fields cx, cy, cBitCount, and */
/* cPlanes are all unused.  Each frame will be of type ICON and will */
/* contain its own dimensional information. */

#define AF_ICON     0x0001L     /* Windows format icon/cursor animation */
#define AF_SEQUENCE 0x0002L     /* Animation is sequenced */
#define WINEVENT_32BITCALLER    0x8000  //  - unused in NT
#define WINEVENT_VALID          0x0007  //
#ifdef REDIRECTION
#define EVENT_SYSTEM_REDIRECTEDPAINT    0x0018
#endif // REDIRECTION

WINUSERAPI
BOOL
WINAPI
IsProcess16Bit(
    VOID);

// Output from DISPID_ACC_STATE (IanJa: taken from oleacc.h)
/*
 * CONSTANTS
 */

/*
 * Object constants (these are NOT public).  OBJID are public IDs for
 * standard frame elements.  But the indeces for their elements are not.
 */

// TITLEBAR
#define INDEX_TITLEBAR_SELF             0
#define INDEX_TITLEBAR_IMEBUTTON        1
#define INDEX_TITLEBAR_MINBUTTON        2
#define INDEX_TITLEBAR_MAXBUTTON        3
#define INDEX_TITLEBAR_HELPBUTTON       4
#define INDEX_TITLEBAR_CLOSEBUTTON      5

#define INDEX_TITLEBAR_MIC              1
#define INDEX_TITLEBAR_MAC              5

#define INDEX_TITLEBAR_RESTOREBUTTON    6 // The min/max buttons turn into this


// SCROLLBAR
#define INDEX_SCROLLBAR_SELF            0
#define INDEX_SCROLLBAR_UP              1
#define INDEX_SCROLLBAR_UPPAGE          2
#define INDEX_SCROLLBAR_THUMB           3
#define INDEX_SCROLLBAR_DOWNPAGE        4
#define INDEX_SCROLLBAR_DOWN            5

#define INDEX_SCROLLBAR_MIC             1
#define INDEX_SCROLLBAR_MAC             5

#define INDEX_SCROLLBAR_LEFT            7
#define INDEX_SCROLLBAR_LEFTPAGE        8
#define INDEX_SCROLLBAR_HORZTHUMB       9
#define INDEX_SCROLLBAR_RIGHTPAGE       10
#define INDEX_SCROLLBAR_RIGHT           11

#define INDEX_SCROLLBAR_HORIZONTAL      6
#define INDEX_SCROLLBAR_GRIP            12


// COMBOBOXES
#define INDEX_COMBOBOX                  0
#define INDEX_COMBOBOX_ITEM             1
#define INDEX_COMBOBOX_BUTTON           2
#define INDEX_COMBOBOX_LIST             3

#define CCHILDREN_COMBOBOX              3


#define CBLISTBOXID 1000
#define CBEDITID    1001
#define CBBUTTONID  1002


// CURSORS
#define CURSOR_SYSTEM_NOTHING           -1
#define CURSOR_SYSTEM_UNKNOWN           0
#define CURSOR_SYSTEM_ARROW             1
#define CURSOR_SYSTEM_IBEAM             2
#define CURSOR_SYSTEM_WAIT              3
#define CURSOR_SYSTEM_CROSS             4
#define CURSOR_SYSTEM_UPARROW           5
#define CURSOR_SYSTEM_SIZENWSE          6
#define CURSOR_SYSTEM_SIZENESW          7
#define CURSOR_SYSTEM_SIZEWE            8
#define CURSOR_SYSTEM_SIZENS            9
#define CURSOR_SYSTEM_SIZEALL           10
#define CURSOR_SYSTEM_NO                11
#define CURSOR_SYSTEM_APPSTARTING       12
#define CURSOR_SYSTEM_HELP              13
#define CURSOR_SYSTEM_NWPEN             14
#define CURSOR_SYSTEM_HAND              15
#define CCURSOR_SYSTEM                  15

#define     GA_MIN          1
#define     GA_MAX          3
#if(_WIN32_WINNT >= 0x0500)

/*
 * The max number of tags to fail that can be
 * specified to Win32PoolAllocationStats. If tagsCount is more than
 * this value then all the pool allocations will fail.
 */
#define MAX_TAGS_TO_FAIL        256

BOOL
WINAPI
Win32PoolAllocationStats(
    IN  LPDWORD parrTags,
    IN  SIZE_T  tagCount,
    OUT SIZE_T* lpdwMaxMem,
    OUT SIZE_T* lpdwCrtMem,
    OUT LPDWORD lpdwMaxAlloc,
    OUT LPDWORD lpdwCrtAlloc);

#define WHF_DESKTOP             0x00000001
#define WHF_SHAREDHEAP          0x00000002
#define WHF_CSRSS               0x00000004
#define WHF_ALL                 (WHF_DESKTOP | WHF_SHAREDHEAP | WHF_CSRSS)

#define WHF_VALID               WHF_ALL

VOID
WINAPI
DbgWin32HeapFail(
    DWORD    dwFlags,
    BOOL     bFail
);

typedef struct tagDBGHEAPSTAT {
    DWORD   dwTag;
    DWORD   dwSize;
    DWORD   dwCount;
} DBGHEAPSTAT, *PDBGHEAPSTAT;

DWORD
WINAPI
DbgWin32HeapStat(
    PDBGHEAPSTAT    phs,
    DWORD    dwLen,
    DWORD    dwFlags
);

#define WPROTOCOLNAME_LENGTH    10
#define WAUDIONAME_LENGTH       10

typedef struct tagWSINFO {
    WCHAR ProtocolName[WPROTOCOLNAME_LENGTH];
    WCHAR AudioDriverName[WAUDIONAME_LENGTH];
} WSINFO, *PWSINFO;

BOOL
GetWinStationInfo(
    WSINFO* pWsInfo);

#endif /* _WIN32_WINNT >= 0x0500 */
/*
 * The handle to this structure is passed in the lParam
 * of WM_INPUT message.
 * The application can call GetRawInputData API to
 * get the detailed information, including the header
 * and all the content of the Raw Input.
 *
 * For the bulk read the RawInput in the message loop,
 * the application may call GetRawInputBuffer API.
 *
 * For the device specific information,
 * the application may call GetRawInputDeviceInfo API.
 *
 * Raw Input is available only when the application
 * calls SetRawInputDevices with valid device
 * specifications.
 */
#define RID_GETTYPE_INPUT           0x10000000
#define RID_GETTYPE_DEVICE          0x20000000
#define RID_GETTYPE_MASK            0xf0000000
#define RIDEV_ADD_OR_MODIFY     0x00000000
#define RIDEV_MODEMASK          0x00000001
#define RIDEV_INCLUDE           0x00000000
#define RIDEV_VALID             0x00000731

/*
 * vkey table counts, macros, etc. input synchonized key state tables have
 * 2 bits per vkey: fDown, fToggled. Async key state tables have 3 bits:
 * fDown, fToggled, fDownSinceLastRead.
 *
 * Important! The array gafAsyncKeyState matches the bit positions of the
 * afKeyState array in each thread info block. The fDownSinceLastRead bit
 * for the async state is stored in a separate bit array, called
 * gafAsyncKeyStateRecentDown.
 *
 * It is important that the bit positions of gafAsyncKeyState and
 * pti->afKeyState match because we copy from one to the other to maintain
 * key state synchronization between threads.
 *
 * These macros below MUST be used when setting / querying key state.
 */
#define CVKKEYSTATE                 256
#define CBKEYSTATE                  (CVKKEYSTATE >> 2)
#define CBKEYSTATERECENTDOWN        (CVKKEYSTATE >> 3)
#define KEYSTATE_TOGGLE_BYTEMASK    0xAA    // 10101010
#define KEYSTATE_DOWN_BYTEMASK      0x55    // 01010101

/*
 * Two bits per VK (down & toggle) so we can pack 4 VK keystates into 1 byte:
 *
 *              Byte 0                           Byte 1
 * .---.---.---.---.---.---.---.---. .---.---.---.---.---.---.---.---. .-- -
 * | T | D | T | D | T | D | T | D | | T | D | T | D | T | D | T | D | |
 * `---'---'---'---'---'---'---'---' `---'---'---'---'---'---'---'---' `-- -
 * : VK 3  : VK 2  : VK 1  : VK 0  : : VK 7  : VK 6  : VK 5  : VK 4  : :
 *
 * KEY_BYTE(pb, vk)   identifies the byte containing the VK's state
 * KEY_DOWN_BIT(vk)   identifies the VK's down bit within a byte
 * KEY_TOGGLE_BIT(vk) identifies the VK's toggle bit within a byte
 */
#define KEY_BYTE(pb, vk)   pb[((BYTE)(vk)) >> 2]
#define KEY_DOWN_BIT(vk)   (1 << ((((BYTE)(vk)) & 3) << 1))
#define KEY_TOGGLE_BIT(vk) (1 << (((((BYTE)(vk)) & 3) << 1) + 1))

#define TestKeyDownBit(pb, vk)     (KEY_BYTE(pb,vk) &   KEY_DOWN_BIT(vk))
#define SetKeyDownBit(pb, vk)      (KEY_BYTE(pb,vk) |=  KEY_DOWN_BIT(vk))
#define ClearKeyDownBit(pb, vk)    (KEY_BYTE(pb,vk) &= ~KEY_DOWN_BIT(vk))
#define TestKeyToggleBit(pb, vk)   (KEY_BYTE(pb,vk) &   KEY_TOGGLE_BIT(vk))
#define SetKeyToggleBit(pb, vk)    (KEY_BYTE(pb,vk) |=  KEY_TOGGLE_BIT(vk))
#define ClearKeyToggleBit(pb, vk)  (KEY_BYTE(pb,vk) &= ~KEY_TOGGLE_BIT(vk))
#define ToggleKeyToggleBit(pb, vk) (KEY_BYTE(pb,vk) ^=  KEY_TOGGLE_BIT(vk))

/*
 * Similar to the above, but here we need only one bit per VK (down)
 * so we can pack 8 VK down states into 1 byte.
 */
#define RKEY_BYTE(pb, vk) pb[((BYTE)(vk)) >> 3]
#define RKEY_BIT(vk)      (1 << ((BYTE)(vk) & 7))

#define TestKeyRecentDownBit(pb, vk)  (RKEY_BYTE(pb,vk) &   RKEY_BIT(vk))
#define SetKeyRecentDownBit(pb, vk)   (RKEY_BYTE(pb,vk) |=  RKEY_BIT(vk))
#define ClearKeyRecentDownBit(pb, vk) (RKEY_BYTE(pb,vk) &= ~RKEY_BIT(vk))

#define TestKeyStateDown(pq, vk)\
        TestKeyDownBit(pq->afKeyState, vk)
#define SetKeyStateDown(pq, vk)\
        SetKeyDownBit(pq->afKeyState, vk)
#define ClearKeyStateDown(pq, vk)\
        ClearKeyDownBit(pq->afKeyState, vk)
#define TestKeyStateToggle(pq, vk)\
        TestKeyToggleBit(pq->afKeyState, vk)
#define SetKeyStateToggle(pq, vk)\
        SetKeyToggleBit(pq->afKeyState, vk)
#define ClearKeyStateToggle(pq, vk)\
        ClearKeyToggleBit(pq->afKeyState, vk)

#define TestAsyncKeyStateDown(vk)\
        TestKeyDownBit(gafAsyncKeyState, vk)
#define SetAsyncKeyStateDown(vk)\
        SetKeyDownBit(gafAsyncKeyState, vk)
#define ClearAsyncKeyStateDown(vk)\
        ClearKeyDownBit(gafAsyncKeyState, vk)
#define TestAsyncKeyStateToggle(vk)\
        TestKeyToggleBit(gafAsyncKeyState, vk)
#define SetAsyncKeyStateToggle(vk)\
        SetKeyToggleBit(gafAsyncKeyState, vk)
#define ClearAsyncKeyStateToggle(vk)\
        ClearKeyToggleBit(gafAsyncKeyState, vk)
#define TestAsyncKeyStateRecentDown(vk)\
        TestKeyRecentDownBit(gafAsyncKeyStateRecentDown, vk)
#define SetAsyncKeyStateRecentDown(vk)\
        SetKeyRecentDownBit(gafAsyncKeyStateRecentDown, vk)
#define ClearAsyncKeyStateRecentDown(vk)\
        ClearKeyRecentDownBit(gafAsyncKeyStateRecentDown, vk)


#if(_WIN32_WINNT >= 0x0501)

#ifndef NOUSER
#ifndef NOSCROLL
#ifndef NOSYSMETRICS
#ifndef NOSYSPARAMSINFO

typedef BOOL (CALLBACK* OVERRIDEWNDPROC)(HWND, UINT, WPARAM, LPARAM, LRESULT*, void**);
typedef BOOL (CALLBACK* FORCERESETUSERAPIHOOK)(HMODULE hmod);
typedef VOID (CALLBACK* MDIREDRAWFRAMEPROC)(HWND hwndChild, BOOL fAdd);

/*
 * Flags passed to UAH DLL's indicating current status of UAH.
 *
 * UIAH_INITIALIZE   : UAH are being initialized for current process and DLL has just been loaded.
 * UIAH_UNINITIALIZE : UAH are being uninitialized for current process and DLL is about to be unloaded.
 * UIAH_UNHOOK       : UAH have been unregistered system-wide but DLL can't be unloaded due to outstanding
 *                     API calls into it.  Table of function pointers (guah) has been reset to native
 *                     user32 functions to prevent further calls.
 */
#define UIAH_INITIALIZE     0
#define UIAH_UNINITIALIZE   1
#define UIAH_UNHOOK         2

typedef struct tagMSGMASK {
    BYTE *              rgb;
    DWORD               cb;
} MSGMASK, *PMSGMASK;

typedef struct tagUSEROWPINFO {
    OVERRIDEWNDPROC     pfnBeforeOWP;
    OVERRIDEWNDPROC     pfnAfterOWP;
    MSGMASK             mm;
} USEROWPINFO, *PUSEROWPINFO;

typedef struct tagUSERAPIHOOK {
    DWORD                  cbSize;
    WNDPROC                pfnDefWindowProcA;
    WNDPROC                pfnDefWindowProcW;
    MSGMASK                mmDWP;
    GETSCROLLINFOPROC      pfnGetScrollInfo;
    SETSCROLLINFOPROC      pfnSetScrollInfo;
    ENABLESCROLLBARPROC    pfnEnableScrollBar;
    ADJUSTWINDOWRECTEXPROC pfnAdjustWindowRectEx;
    SETWINDOWRGNPROC       pfnSetWindowRgn;
    USEROWPINFO            uoiWnd;
    USEROWPINFO            uoiDlg;
    GETSYSTEMMETRICSPROC   pfnGetSystemMetrics;
    SYSTEMPARAMETERSINFO   pfnSystemParametersInfoA;
    SYSTEMPARAMETERSINFO   pfnSystemParametersInfoW;
    FORCERESETUSERAPIHOOK  pfnForceResetUserApiHook;
    DRAWFRAMECONTROLPROC   pfnDrawFrameControl;
    DRAWCAPTIONPROC        pfnDrawCaption;
    MDIREDRAWFRAMEPROC     pfnMDIRedrawFrame;
} USERAPIHOOK, *PUSERAPIHOOK;

typedef BOOL (CALLBACK* INITUSERAPIHOOK)(DWORD dwCmd, void* pvParam);


WINUSERAPI
BOOL
WINAPI
RegisterUserApiHook(
    IN HINSTANCE hmod,
    IN INITUSERAPIHOOK pfnUserApiHook);

WINUSERAPI
BOOL
WINAPI
UnregisterUserApiHook(VOID);

#endif  /*!NOSYSPARAMSINFO*/
#endif  /*!NOSYSMETRICS*/
#endif  /* NOSCROLL */


/*
 * Message Hook
 */

#ifndef NOMSG

typedef struct tagMESSAGEPUMPHOOK {
    DWORD               cbSize;
    INTERNALGETMESSAGEPROC
                        pfnInternalGetMessage;
    WAITMESSAGEEXPROC   pfnWaitMessageEx;
    GETQUEUESTATUSPROC  pfnGetQueueStatus;
    MSGWAITFORMULTIPLEOBJECTSEXPROC
                        pfnMsgWaitForMultipleObjectsEx;
} MESSAGEPUMPHOOK;

typedef BOOL (CALLBACK* INITMESSAGEPUMPHOOK)(DWORD dwCmd, void* pvParam);

WINUSERAPI
BOOL
WINAPI
RegisterMessagePumpHook(
    IN INITMESSAGEPUMPHOOK pfnInitMPH);

WINUSERAPI
BOOL
WINAPI
UnregisterMessagePumpHook();

#endif /* NOMSG */

#endif  /* NOUSER */
#endif /* _WIN32_WINNT >= 0x0501 */

#ifdef REDIRECTION
WINUSERAPI
BOOL
WINAPI
SetProcessRedirectionMode(
    IN HANDLE hProcess,
    IN BOOL bRedirectionMode);

WINUSERAPI
BOOL
WINAPI
GetProcessRedirectionMode(
    IN HANDLE hProcess,
    OUT PBOOL pbRedirectionMode);

WINUSERAPI
BOOL
WINAPI
SetDesktopRedirectionMode(
IN HANDLE hProcess,
IN BOOL bRedirectionMode);

WINUSERAPI
BOOL
WINAPI
GetDesktopRedirectionMode(
IN HANDLE hProcess,
OUT PBOOL pbRedirectionMode);
#endif // REDIRECTION

/*
 * We set this bit in GetDeviceChangeInfo to signify that the drive letter
 * represents a new drive.
 */
#define HMCE_ARRIVAL 0x80000000

/*
 * Shutdown reason code
 */
#include <reason.h>

typedef struct _REASON_INITIALISER {
    DWORD dwCode;
    DWORD dwNameId;
    DWORD dwDescId;
} REASON_INITIALISER;

typedef struct _REASON
{
    DWORD dwCode;
    WCHAR szName[MAX_REASON_NAME_LEN];
    WCHAR szDesc[MAX_REASON_DESC_LEN];
} REASON, *PREASON;

typedef struct _REASONDATA
{
    REASON** rgReasons;
    int cReasons;
    int cReasonCapacity;
    DWORD dwReasonSelect;
    WCHAR szComment[MAX_REASON_COMMENT_LEN];
    WCHAR szBugID[MAX_REASON_BUGID_LEN];
    int cCommentLen;
    int cBugIDLen;
} REASONDATA, *PREASONDATA;


BOOL ReasonCodeNeedsComment(DWORD dwCode);
BOOL ReasonCodeNeedsBugID(DWORD dwCode);
BOOL BuildReasonArray(REASONDATA *pdata, BOOL forCleanUI, BOOL forDirtyUI);
VOID DestroyReasons(REASONDATA *pdata);
BOOL GetReasonTitleFromReasonCode(DWORD code, WCHAR *title, DWORD dwTitleLen);
BOOL IsSETEnabled();

// Reason Titles
#define IDS_REASON_UNPLANNED_HARDWARE_MAINTENANCE_TITLE         8250
#define IDS_REASON_PLANNED_HARDWARE_MAINTENANCE_TITLE           8251
#define IDS_REASON_UNPLANNED_HARDWARE_INSTALLATION_TITLE        8252
#define IDS_REASON_PLANNED_HARDWARE_INSTALLATION_TITLE          8253

//#define IDS_REASON_UNPLANNED_OPERATINGSYSTEM_UPGRADE_TITLE      8254
#define IDS_REASON_PLANNED_OPERATINGSYSTEM_UPGRADE_TITLE        8255
#define IDS_REASON_UNPLANNED_OPERATINGSYSTEM_RECONFIG_TITLE     8256
#define IDS_REASON_PLANNED_OPERATINGSYSTEM_RECONFIG_TITLE       8257

#define IDS_REASON_APPLICATION_HUNG_TITLE                       8258
#define IDS_REASON_APPLICATION_UNSTABLE_TITLE                   8259
#define IDS_REASON_APPLICATION_MAINTENANCE_TITLE                8260

#define IDS_REASON_UNPLANNED_OTHER_TITLE                        8261
#define IDS_REASON_PLANNED_OTHER_TITLE                          8262

#define IDS_REASON_SYSTEMFAILURE_BLUESCREEN_TITLE               8263
#define IDS_REASON_POWERFAILURE_CORDUNPLUGGED_TITLE             8264
#define IDS_REASON_POWERFAILURE_ENVIRONMENT_TITLE               8265
#define IDS_REASON_OTHERFAILURE_HUNG_TITLE                      8266
#define IDS_REASON_OTHERFAILURE_TITLE                           8267
#define IDS_REASON_APPLICATION_PM_TITLE                         8268

// Default reason title returned by GetReasonTitleFromReasonCode
#define IDS_REASON_DEFAULT_TITLE                                8269

#define IDS_REASON_LEGACY_API_TITLE                             8270

// Reason Descriptions
#define IDS_REASON_HARDWARE_MAINTENANCE_DESCRIPTION             8275
#define IDS_REASON_HARDWARE_INSTALLATION_DESCRIPTION            8276

#define IDS_REASON_OPERATINGSYSTEM_UPGRADE_DESCRIPTION          8277
#define IDS_REASON_OPERATINGSYSTEM_RECONFIG_DESCRIPTION         8278

#define IDS_REASON_APPLICATION_HUNG_DESCRIPTION                 8279
#define IDS_REASON_APPLICATION_UNSTABLE_DESCRIPTION             8280
#define IDS_REASON_APPLICATION_MAINTENANCE_DESCRIPTION          8281

#define IDS_REASON_OTHER_DESCRIPTION                            8282

#define IDS_REASON_SYSTEMFAILURE_BLUESCREEN_DESCRIPTION         8283
#define IDS_REASON_POWERFAILURE_CORDUNPLUGGED_DESCRIPTION       8284
#define IDS_REASON_POWERFAILURE_ENVIRONMENT_DESCRIPTION         8285
#define IDS_REASON_OTHERFAILURE_HUNG_DESCRIPTION                8286
#define IDS_REASON_APPLICATION_PM_DESCRIPTION                   8287
#define IDS_REASON_PLANNED_OPERATINGSYSTEM_SERVICEPACK_TITLE    8288
#define IDS_REASON_PLANNED_OPERATINGSYSTEM_HOTFIX_TITLE         8289
#define IDS_REASON_UNPLANNED_OPERATINGSYSTEM_HOTFIX_TITLE       8290
#define IDS_REASON_PLANNED_OPERATINGSYSTEM_SECURITYFIX_TITLE    8291
#define IDS_REASON_UNPLANNED_OPERATINGSYSTEM_SECURITYFIX_TITLE  8292
#define IDS_REASON_PLANNED_APPLICATION_INSTALLATION_TITLE       8293
#define IDS_REASON_SECURITY_ISSUE_TITLE                         8300
#define IDS_REASON_LOSS_OF_NETWORK_TITLE                        8301

#define IDS_REASON_OPERATINGSYSTEM_SERVICEPACK_DESCRIPTION      8294
#define IDS_REASON_OPERATINGSYSTEM_HOTFIX_DESCRIPTION           8295
#define IDS_REASON_OPERATINGSYSTEM_SECURITYFIX_DESCRIPTION      8296
#define IDS_REASON_APPLICATION_INSTALLATION_DESCRIPTION         8297
#define IDS_REASON_LEGACY_API_DESCRIPTION                       8298
#define IDS_REASON_SECURITY_ISSUE_DESCRIPTION                   8310
#define IDS_REASON_LOSS_OF_NETWORK_DESCRIPTION                  8311




#define WC_HARDERRORHANDLER "HardErrorHandler"
#define COPYDATA_HARDERROR  "HardError"

typedef struct _tagHardErrorData
{
    DWORD   dwSize;             // Size of this structure
    DWORD   dwError;            // Hard Error
    DWORD   dwFlags;            // Hard Error flags
    UINT    uOffsetTitleW;      // Offset to UNICODE Title
    UINT    uOffsetTextW;       // Offset to UNICODE Text
} HARDERRORDATA, *PHARDERRORDATA;
#ifdef __cplusplus
}
#endif  /* __cplusplus */
#endif  /* !_WINUSERP_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\winfont.h ===
/******************************Module*Header*******************************\
* Module Name: winfont.h
*
* font file headers for 2.0 and 3.0 windows *.fnt files
*
* Created: 25-Oct-1990 11:08:08
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) Microsoft Corporation. All rights reserved.
*
* (General description of its use)
*
*
\**************************************************************************/


/******************************Public*Macro********************************\
* WRITE_WORD
*
* Writes a word to the misaligned address, pv.
*
* !!! Note: this only works for little-endian.
*
* History:
*  11-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

#define WRITE_WORD(pv, word)                                        \
{                                                                   \
    *(PBYTE) (pv)       = (BYTE) ((word) & 0x00ff);                 \
    *((PBYTE) (pv) + 1) = (BYTE) (((word) & 0xff00) >> 8);          \
}


/******************************Public*Macro********************************\
* READ_WORD
*
* Reads a word from the misaligned address, pv.
*
* !!! Note: this only works for little-endian.
*
* History:
*  11-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

#define READ_WORD(pv)                                               \
( (WORD)                                                            \
    ( ((WORD)*(PBYTE) (pv)) & (WORD)0x00ff ) |                      \
    ( ((WORD)*((PBYTE) (pv) + (WORD)1) & (WORD)0x00ff) << 8 )       \
)



/******************************Public*Macro********************************\
* WRITE_DWORD
*
* Writes a dword to the misaligned address, pv.
*
* !!! Note: this only works for little-endian.
*
* History:
*  11-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/


#define WRITE_DWORD(pv, dword)                                      \
{                                                                   \
    *(PBYTE) (pv)       = (BYTE) ((dword) & 0x000000ff);            \
    *((PBYTE) (pv) + 1) = (BYTE) (((dword) & 0x0000ff00) >> 8 );    \
    *((PBYTE) (pv) + 2) = (BYTE) (((dword) & 0x00ff0000) >> 16);    \
    *((PBYTE) (pv) + 3) = (BYTE) (((dword) & 0xff000000) >> 24);    \
}


/******************************Public*Macro********************************\
* READ_DWORD
*
* Reads a DWORD from the misaligned address, pv.
*
* !!! Note: this only works for little-endian.
*
* History:
*  11-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

#define READ_DWORD(pv)                                              \
( (DWORD)                                                           \
    ( (*(PBYTE) (pv)) & 0x000000ff ) |                              \
    ( (*((PBYTE) (pv) + 1) & 0x000000ff) << 8 ) |                   \
    ( (*((PBYTE) (pv) + 2) & 0x000000ff) << 16) |                   \
    ( (*((PBYTE) (pv) + 3) & 0x000000ff) << 24)                     \
)


// font file header (2.0 ddk adaptation guide, 7.7.3.
// and 3.0 ddk,  Adaptation Guide section 13.3)

// CAUTION: These structures, as they are defined in the Adaptation Guide are
//          out of allignment.(Not even WORD alligned,let alone DWORD alligned.)
//          Here we make our own structures, so that when
//          disk files are read in the data is copied in correctly, and so that
//          the data can be accessed in memory regardless of the architecture.

/**************************************************************************\

// the original structure was

typedef struct {
    WORD    Version;          // Always 17985 for the Nonce
    DWORD   Size;             // Size of whole file
    char    Copyright[60];
    WORD    Type;             // Raster Font if Type & 1 == 0
    WORD    Points;           // Nominal Point size
    WORD    VertRes;          // Nominal Vertical resolution
    WORD    HorizRes;         // Nominal Horizontal resolution
    WORD    Ascent;           // Height of Ascent
    WORD    IntLeading;       // Internal (Microsoft) Leading
    WORD    ExtLeading;       // External (Microsoft) Leading
    BYTE    Italic;           // Italic font if set
    BYTE    Underline;        // Etc.
    BYTE    StrikeOut;        // Etc.
    WORD    Weight;           // Weight: 200 = regular
    BYTE    CharSet;          // ANSI=0. other=255
    WORD    PixWidth;         // Fixed width. 0 ==> Variable
    WORD    PixHeight;        // Fixed Height
    BYTE    Family;           // Pitch and Family
    WORD    AvgWidth;         // Width of character 'X'
    WORD    MaxWidth;         // Maximum width
    BYTE    FirstChar;        // First character defined in font
    BYTE    LastChar;         // Last character defined in font
    BYTE    DefaultChar;          // Sub. for out of range chars.
    BYTE    BreakChar;        // Word Break Character
    WORD    WidthBytes;       // No.Bytes/row of Bitmap
    DWORD   Device;           // Pointer to Device Name string
    DWORD   Face;           // Pointer to Face Name String
    DWORD   BitsPointer;        // Pointer to Bit Map
    DWORD   BitsOffset;     // Offset to Bit Map
    } FontHeaderType;       // Above pointers all rel. to start of file

// the original 3.0 header:

typedef struct {
    WORD    fsVersion;
    DWORD   fsSize;
    char    fsCopyright[60];
    WORD    fsType;           // Type field for the font
    WORD    fsPoints;         // Point size of font
    WORD    fsVertRes;        // Vertical digitization
    WORD    fsHorizRes;       // Horizontal digitization
    WORD    fsAscent;         // Baseline offset from char cell top
    WORD    fsInternalLeading;    // Internal leading included in font
    WORD    fsExternalLeading;    // Prefered extra space between lines
    BYTE    fsItalic;         // Flag specifying if italic
    BYTE    fsUnderline;          // Flag specifying if underlined
    BYTE    fsStrikeOut;          // Flag specifying if struck out
    WORD    fsWeight;         // Weight of font
    BYTE    fsCharSet;        // Character set of font
    WORD    fsPixWidth;       // Width field for the font
    WORD    fsPixHeight;          // Height field for the font
    BYTE    fsPitchAndFamily;     // Flag specifying pitch and family
    WORD    fsAvgWidth;       // Average character width
    WORD    fsMaxWidth;       // Maximum character width
    BYTE    fsFirstChar;          // First character in the font
    BYTE    fsLastChar;       // Last character in the font
    BYTE    fsDefaultChar;        // Default character for out of range
    BYTE    fsBreakChar;          // Character to define wordbreaks
    WORD    fsWidthBytes;         // Number of bytes in each row
    DWORD   fsDevice;         // Offset to device name
    DWORD   fsFace;           // Offset to face name
    DWORD   fsBitsPointer;        // Bits pointer
    DWORD   fsBitsOffset;         // Offset to the begining of the bitmap
    BYTE    fsDBfiller;       // Word alignment for the offset table

    DWORD   fsFlags;          // Bit flags
    WORD    fsAspace;         // Global A space, if any
    WORD    fsBspace;         // Global B space, if any
    WORD    fsCspace;         // Global C space, if any
    DWORD   fsColorPointer;       // offset to color table, if any
    DWORD   fsReserved[4];        //
    BYTE    fsCharOffset;         // Area for storing the char. offsets

    } FontHeader30;

typedef struct tagFFH {
    WORD        fhVersion        ;
    DWORD       fhSize           ;
    char        fhCopyright[60]  ;
    WORD        fhType           ;
    WORD        fhPoints         ;
    WORD        fhVertRes        ;
    WORD        fhHorizRes       ;
    WORD        fhAscent         ;
    WORD        fhInternalLeading;
    WORD        fhExternalLeading;
    BYTE        fhItalic         ;
    BYTE        fhUnderline      ;
    BYTE        fhStrikeOut      ;
    WORD        fhWeight         ;
    BYTE        fhCharSet        ;
    WORD        fhPixWidth       ;
    WORD        fhPixHeight      ;
    BYTE        fhPitchAndFamily ;
    WORD        fhAvgWidth       ;
    WORD        fhMaxWidth       ;
    BYTE        fhFirstChar      ;
    BYTE        fhLastChar       ;
    BYTE        fhDefaultChar    ;
    BYTE        fhBreakChar      ;
    WORD        fhWidthBytes     ;
    DWORD       fhDevice         ;
    DWORD       fhFace           ;
    DWORD       fhBitsPointer    ;
    } FFH;

\**************************************************************************/


// type of the font file

#define TYPE_RASTER                     0x0000
#define TYPE_VECTOR                     0x0001
#define TYPE_BITS_IN_ROM                0x0004
#define TYPE_REALIZED_BY_DEVICE         0x0080

// reserved fields in the fsType field, used are 0-th,2-nd, and 7-th bit

#define BITS_RESERVED (~(TYPE_VECTOR|TYPE_BITS_IN_ROM|TYPE_REALIZED_BY_DEVICE))

// supported in win 3.0

#define DFF_FIXED                0x01    // fixed font
#define DFF_PROPORTIONAL         0x02    // proportional font

// not supported in win 3.0, except maybe if someone has
// custom created such a font, using font editor or a similar tool

#define DFF_ABCFIXED             0x04    // ABC fixed font
#define DFF_ABCPROPORTIONAL      0x08    // ABC proportional font
#define DFF_1COLOR               0x10
#define DFF_16COLOR              0x20
#define DFF_256COLOR             0x40
#define DFF_RGBCOLOR             0x80


// here we list offsets of all fields of the original  structures
// as they are computed under the assumption that the C compiler does not
// insert any paddings between fields

#define  OFF_Version          0L   //   WORD     Always 17985 for the Nonce
#define  OFF_Size             2L   //   DWORD    Size of whole file
#define  OFF_Copyright        6L   //   char[60]

// Note: Win 3.1 hack.  The LSB of Type is used by Win 3.1 as an engine type
//       and font embedding flag.  Font embedding is a form of a "hidden
//       font file".  The MSB of Type is the same as the fsSelection from
//       IFIMETRICS.  (Strictly speaking, the MSB of Type is equal to the
//       LSB of IFIMETRICS.fsSelection).

#define  OFF_Type            66L   //   WORD     Raster Font if Type & 1 == 0
#define  OFF_Points          68L   //   WORD     Nominal Point size
#define  OFF_VertRes         70L   //   WORD     Nominal Vertical resolution
#define  OFF_HorizRes        72L   //   WORD     Nominal Horizontal resolution
#define  OFF_Ascent          74L   //   WORD     Height of Ascent
#define  OFF_IntLeading      76L   //   WORD     Internal (Microsoft) Leading
#define  OFF_ExtLeading      78L   //   WORD     External (Microsoft) Leading
#define  OFF_Italic          80L   //   BYTE     Italic font if set
#define  OFF_Underline       81L   //   BYTE     Etc.
#define  OFF_StrikeOut       82L   //   BYTE     Etc.
#define  OFF_Weight          83L   //   WORD     Weight: 200 = regular
#define  OFF_CharSet         85L   //   BYTE     ANSI=0. other=255
#define  OFF_PixWidth        86L   //   WORD     Fixed width. 0 ==> Variable
#define  OFF_PixHeight       88L   //   WORD     Fixed Height
#define  OFF_Family          90L   //   BYTE     Pitch and Family
#define  OFF_AvgWidth        91L   //   WORD     Width of character 'X'
#define  OFF_MaxWidth        93L   //   WORD     Maximum width
#define  OFF_FirstChar       95L   //   BYTE     First character defined in font
#define  OFF_LastChar        96L   //   BYTE     Last character defined in font
#define  OFF_DefaultChar     97L   //   BYTE     Sub. for out of range chars.
#define  OFF_BreakChar       98L   //   BYTE     Word Break Character
#define  OFF_WidthBytes      99L   //   WORD     No.Bytes/row of Bitmap
#define  OFF_Device         101L   //   DWORD    Pointer to Device Name string
#define  OFF_Face           105L   //   DWORD    Pointer to Face Name String
#define  OFF_BitsPointer    109L   //   DWORD    Pointer to Bit Map
#define  OFF_BitsOffset     113L   //   DWORD    Offset to Bit Map
#define  OFF_jUnused20      117L   //   BYTE     byte filler
#define  OFF_OffTable20     118L   //   WORD     here begins char table for 2.0

// 3.0 addition

#define  OFF_jUnused30      117L       //  BYTE      enforces word allignment
#define  OFF_Flags      118L       //  DWORD     Bit flags
#define  OFF_Aspace     122L       //  WORD      Global A space, if any
#define  OFF_Bspace     124L       //  WORD      Global B space, if any
#define  OFF_Cspace     126L       //  WORD      Global C space, if any
#define  OFF_ColorPointer   128L       //  DWORD     offset to color table, if any
#define  OFF_Reserved       132L       //  DWORD[4]
#define  OFF_OffTable30     148L       //  WORD      Area for storing the char. offsets in 3.0

// latest offset for pscript device font pfm files [bodind]

#if 0

// This is from win31 sources \drivers\printers\pstt\utils\pfm.c [bodind]
........

WORD dfWidthBytes;
DWORD dfDevice;
DWORD dfFace;
DWORD dfBitsPointer;
DWORD dfBitsOffset;  // up to here the offsets are the same as in *.fon files

WORD  dfSizeFields;
DWORD dfExtMetricsOffset;
DWORD dfExtentTable;
DWORD dfOriginTable;
DWORD dfPairKernTable;
DWORD dfTrackKernTable;
DWORD dfDriverInfo;
DWORD dfReserved;

#endif

#define  OFF_SizeFields         117L
#define  OFF_ExtMetricsOffset   119L
#define  OFF_ExtentTable        123L
#define  OFF_OriginTable        127L
#define  OFF_PairKernTable      131L
#define  OFF_TrackKernTable     135L
#define  OFF_DriverInfo         139L
#define  OFF_ReservedPscript    143L


// FFH offsets

#define  OFF_FFH_Version          0L   //   WORD     Always 17985 for the Nonce
#define  OFF_FFH_Size             2L   //   DWORD    Size of whole file
#define  OFF_FFH_Copyright        6L   //   char[60]
#define  OFF_FFH_Type            66L   //   WORD     Raster Font if Type & 1 == 0
#define  OFF_FFH_Points          68L   //   WORD     Nominal Point size
#define  OFF_FFH_VertRes         70L   //   WORD     Nominal Vertical resolution
#define  OFF_FFH_HorizRes        72L   //   WORD     Nominal Horizontal resolution
#define  OFF_FFH_Ascent          74L   //   WORD     Height of Ascent
#define  OFF_FFH_IntLeading      76L   //   WORD     Internal (Microsoft) Leading
#define  OFF_FFH_ExtLeading      78L   //   WORD     External (Microsoft) Leading
#define  OFF_FFH_Italic          80L   //   BYTE     Italic font if set
#define  OFF_FFH_Underline       81L   //   BYTE     Etc.
#define  OFF_FFH_StrikeOut       82L   //   BYTE     Etc.
#define  OFF_FFH_Weight          83L   //   WORD     Weight: 200 = regular
#define  OFF_FFH_CharSet         85L   //   BYTE     ANSI=0. other=255
#define  OFF_FFH_PixWidth        86L   //   WORD     Fixed width. 0 ==> Variable
#define  OFF_FFH_PixHeight       88L   //   WORD     Fixed Height
#define  OFF_FFH_Family          90L   //   BYTE     Pitch and Family
#define  OFF_FFH_AvgWidth        91L   //   WORD     Width of character 'X'
#define  OFF_FFH_MaxWidth        93L   //   WORD     Maximum width
#define  OFF_FFH_FirstChar       95L   //   BYTE     First character defined in font
#define  OFF_FFH_LastChar        96L   //   BYTE     Last character defined in font
#define  OFF_FFH_DefaultChar     97L   //   BYTE     Sub. for out of range chars.
#define  OFF_FFH_BreakChar       98L   //   BYTE     Word Break Character
#define  OFF_FFH_WidthBytes      99L   //   WORD     No.Bytes/row of Bitmap
#define  OFF_FFH_Device         101L   //   DWORD    Pointer to Device Name string
#define  OFF_FFH_Face           105L   //   DWORD    Pointer to Face Name String
#define  OFF_FFH_BitsPointer    109L   //   DWORD    Pointer to Bit Map

#define SIZEFFH (OFF_FFH_BitsPointer + 4)


// This is used in NtGdiMakeFontDir

#define CJ_FONTDIR (SIZEFFH + LF_FACESIZE + LF_FULLFACESIZE + LF_FACESIZE + 10)




// header sizes in bytes of the original headers

#define  HDRSIZE20         117L   //   or 113L ?
#define  HDRSIZE30         148L   //   CharOffset is not counted as header

#define  HDRSIZEDIFF       (HDRSIZE30 - HDRSIZE20)   // 31 byte



// ranges for some quantities

#define MAX_PT_SIZE         999     // max size in points

// weight range

#define MIN_WEIGHT             1    // adaptation guide
#define MAX_WEIGHT          1000    // adaptation guide

// maximal size of bitmap font in pixels, (bound on cx and cy)

#define  MAX_PEL_SIZE  64

// 2.0 fonts have offsets that fit into 64k

#define SEGMENT_SIZE 65536L     // IN bytes

// offset limit for 2.0 font files

#define MAX_20_OFFSET      65534   // 64K - 2

// sizes of the offset table entries for the 2.0 and 3.0 fonts respectively

#define CJ_ENTRY_20  4   // two bytes for cx + two bytes for the offset
#define CJ_ENTRY_30  6   // two bytes for cx + four bytes for the offset


#define WINWT_TO_PANWT(x) ((x)/100 + 1)

// From [Windows 3.1] gdifeng.inc

#define WIN_VERSION 0x0310
#define GDI_VERSION 0x0101


// From [Windows 3.1] gdipfont.inc

#define PF_ENGINE_TYPE  0x03
#define PF_ENCAPSULATED 0x80        // used in FFH.fhType to identify hidden (embedded) font
#define PANDFTYPESHIFT  1

// for embeded fonts

#define PF_TID          0x40    // if set use TID ( WOW apps )
                                // otherwise use PID ( NT apps )


// From [Windows 3.1] fonteng2.asm
#define DEF_BRK_CHARACTER   0x0201  // default char for all TT fonts


// BITMAP size related macros

// number of bytes in a scan of a monobitmap that actually contain some info
// Note that this is the same as ((((cx) + 7) & ~7) >> 3), the last two bits
// are lost anyway because of >> 3

#define CJ_SCAN(cx) (((cx) + 7) >> 3)

// move this to a common place so we don't have it in multiple places
// given a byte count, compute the minimum 4 byte (DWORD) aligned size (in bytes)

#define ALIGN4(X) (((X) + 3) & ~3)

// size of the whole  bimtap, only dword pad the last scan

#define CJ_BMP(cx,cy) ALIGN4(CJ_SCAN(cx) * (cy))

// get the size of GLYPHDATA  structure that at the bottom has appended
// a dib format bitmap for the glyph
// Add  offsetof(GLYPHDATA,aulBMData[2]) to cjDIB to account for cx and cy
// are stored in aulBMData[0] and aulBMData[1] respectively

#define CJ_GLYPHDATA(cx,cy) (offsetof(GLYPHBITS,aj) + CJ_BMP(cx,cy))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\wowgdip.h ===
/******************************Module*Header*******************************\
* Module Name: wowgdip.h                                                   *
*                                                                          *
* Declarations of GDI services provided to WOW.                            *
*                                                                          *
* Created: 30-Jan-1993 13:14:57                                            *
* Author: Charles Whitmer [chuckwh]                                        *
*                                                                          *
* Copyright (c) Microsoft Corporation. All rights reserved.                *
\**************************************************************************/

extern BOOL GdiCleanCacheDC(HDC hdcLocal);
extern int APIENTRY SetBkModeWOW(HDC hdc,int iMode);
extern int APIENTRY SetPolyFillModeWOW(HDC hdc,int iMode);
extern int APIENTRY SetROP2WOW(HDC hdc,int iMode);
extern int APIENTRY SetStretchBltModeWOW(HDC hdc,int iMode);
extern UINT APIENTRY SetTextAlignWOW(HDC hdc,UINT iMode);
extern DWORD APIENTRY GetGlyphOutlineWow( HDC, UINT, UINT, LPGLYPHMETRICS, DWORD, LPVOID, CONST MAT2* );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\directui.h ===
/*
 * DirectUI main header
 */

#ifndef DUI_INC_DIRECTUI_H_INCLUDED
#define DUI_INC_DIRECTUI_H_INCLUDED

#pragma once

// External dependencies

// The following is required to build using DirectUI

/******************************************************
#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN     // Exclude rarely-used stuff from Windows headers
#endif

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500     // TODO: Remove this when updated headers are available
#endif

// Windows Header Files
#ifndef WINVER
#define WINVER 0x0500
#endif 

#include <windows.h>            // Windows
#include <windowsx.h>           // User macros

// COM Header Files
#include <objbase.h>            // CoCreateInstance, IUnknown

// C RunTime Header Files
#include <stdlib.h>             // Standard library
#include <malloc.h>             // Memory allocation
#include <wchar.h>              // Character routines
#include <process.h>            // Multi-threaded routines

// DirectUser
#define GADGET_ENABLE_TRANSITIONS
#include <duser.h>
*******************************************************/

// Base Published

#include "duierror.h"
#include "duialloc.h"
#include "duisballoc.h"
#include "duisurface.h"
#include "duiuidgen.h"
#include "duifontcache.h"
#include "duibtreelookup.h"
#include "duivaluemap.h"
#include "duidynamicarray.h"

// Util Published

#include "duiconvert.h"
#include "duiemfload.h"
#include "duigadget.h"

// Core Published

#include "duielement.h"
#include "duievent.h"
#include "duiexpression.h"
#include "duihost.h"
#include "duilayout.h"
#include "duiproxy.h"
#include "duisheet.h"
#include "duithread.h"
#include "duivalue.h"
#include "duiaccessibility.h"

// Control Published

#include "duibutton.h"
#include "duiedit.h"
#include "duicombobox.h"
#include "duinative.h"
#include "duiprogress.h"
#include "duirefpointelement.h"
#include "duirepeatbutton.h"
#include "duiscrollbar.h"
#include "duiscrollviewer.h"
#include "duiselector.h"
#include "duithumb.h"
#include "duiviewer.h"

// Layout Published

#include "duiborderlayout.h"
#include "duifilllayout.h"
#include "duiflowlayout.h"
#include "duigridlayout.h"
#include "duininegridlayout.h"
#include "duirowlayout.h"
#include "duiverticalflowlayout.h"

// Parser Published

#include "duiparserobj.h"

#endif // DUI_INC_DIRECTUI_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duialloc.h ===
/*
 * Global memory allocation
 */

#ifndef DUI_BASE_ALLOC_H_INCLUDED
#define DUI_BASE_ALLOC_H_INCLUDED

#pragma once

#include <new.h>

namespace DirectUI
{

extern HANDLE g_hHeap;

inline void* HAlloc(SIZE_T s)
{
    return HeapAlloc(g_hHeap, 0, s);
}

inline void* HAllocAndZero(SIZE_T s)
{ 
    return HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, s);
}

inline void* HReAlloc(void* p, SIZE_T s)
{ 
    return HeapReAlloc(g_hHeap, 0, p, s);
}

inline void* HReAllocAndZero(void* p, SIZE_T s)
{ 
    return HeapReAlloc(g_hHeap, HEAP_ZERO_MEMORY, p, s);
}

inline void HFree(void* p)
{
    HeapFree(g_hHeap, 0, p);
}

template <typename T> inline T* HNew()
{
    T* p = (T*)HAlloc(sizeof(T));
    if (p)
        new(p) T;

    return p;
}

template <typename T> inline T* HNewAndZero()
{
    T* p = (T*)HAllocAndZero(sizeof(T));
    if (p)
        new(p) T;

    return p;
}

template <typename T> inline void HDelete(T* p)
{
    p->~T();
    HFree(p);
}

} // namespace DirectUI

#endif // DUI_BASE_ALLOC_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\wowuserp.h ===
/******************************Module*Header*******************************\
* Module Name: wowuserp.h                                                  *
*                                                                          *
* Declarations of USER services provided to WOW.                           *
*                                                                          *
* Created: 03-Mar-1993                                                     *
* Author: John Colleran [johnc]                                            *
*                                                                          *
* Copyright (c) Microsoft Corporation. All rights reserved.                *
\**************************************************************************/

#include "w32w64.h"

#pragma pack(1)
typedef struct _NE_MODULE_SEG {
    USHORT ns_sector;
    USHORT ns_cbseg;
    USHORT ns_flags;
    USHORT ns_minalloc;
    USHORT ns_handle;
} NEMODULESEG;
typedef struct _NE_MODULE_SEG UNALIGNED *PNEMODULESEG;
#pragma pack()


// Shared WOW32 prototypes called by USER32.
typedef HLOCAL  (WINAPI *PFNLALLOC)(UINT dwFlags, UINT dwBytes, HANDLE hInstance);
typedef HLOCAL  (WINAPI *PFNLREALLOC)(HLOCAL hMem, UINT dwBytes, UINT dwFlags, HANDLE hInstance, PVOID* ppv);
typedef LPVOID  (WINAPI *PFNLLOCK)(HLOCAL hMem, HANDLE hInstance);
typedef BOOL    (WINAPI *PFNLUNLOCK)(HLOCAL hMem, HANDLE hInstance);
typedef UINT    (WINAPI *PFNLSIZE)(HLOCAL hMem, HANDLE hInstance);
typedef HLOCAL  (WINAPI *PFNLFREE)(HLOCAL hMem, HANDLE hInstance);
typedef WORD    (WINAPI *PFN16GALLOC)(UINT flags, DWORD cb);
typedef VOID    (WINAPI *PFN16GFREE)(WORD h16Mem);
typedef DWORD   (WINAPI *PFNGETMODFNAME)(HANDLE hModule, LPTSTR lpszPath, DWORD cchPath);
typedef VOID    (WINAPI *PFNEMPTYCB)(VOID);
typedef DWORD   (WINAPI *PFNGETEXPWINVER)(HANDLE hModule);
typedef HANDLE  (WINAPI *PFNFINDA)(HANDLE hModule, LPCSTR lpName,  LPCSTR lpType,  WORD wLang);
typedef HANDLE  (WINAPI *PFNFINDW)(HANDLE hModule, LPCWSTR lpName, LPCWSTR lpType, WORD wLang);
typedef HANDLE  (WINAPI *PFNLOAD)(HANDLE hModule, HANDLE hResInfo);
typedef BOOL    (WINAPI *PFNFREE)(HANDLE hResData, HANDLE hModule);
typedef LPSTR   (WINAPI *PFNLOCK)(HANDLE hResData, HANDLE hModule);
typedef BOOL    (WINAPI *PFNUNLOCK)(HANDLE hResData, HANDLE hModule);
typedef DWORD   (WINAPI *PFNSIZEOF)(HANDLE hModule, HANDLE hResInfo);
typedef DWORD   (WINAPI *PFNWOWWNDPROCEX)(HWND hwnd, UINT uMsg, WPARAM uParam, LPARAM lParam, DWORD dw, PVOID adwWOW);
typedef BOOL    (WINAPI *PFNWOWDLGPROCEX)(HWND hwnd, UINT uMsg, WPARAM uParam, LPARAM lParam, DWORD dw, PVOID adwWOW);
typedef int     (WINAPI *PFNWOWEDITNEXTWORD)(LPSTR lpch, int ichCurrent, int cch, int code, DWORD dwProc16);
typedef VOID    (WINAPI *PFNWOWCBSTOREHANDLE)(WORD wFmt, WORD h16);
typedef WORD    (FASTCALL *PFNGETPROCMODULE16)(DWORD vpfn);
typedef VOID    (FASTCALL *PFNWOWMSGBOXINDIRECTCALLBACK)(DWORD vpfnCallback, LPHELPINFO lpHelpInfo);
typedef int     (WINAPI *PFNWOWILSTRCMP)(LPCWSTR lpString1, LPCWSTR lpString2);
typedef VOID    (FASTCALL *PFNWOWTELLWOWTHEHDLG)(HWND hDlg);
typedef DWORD	(FASTCALL *PFNWOWTASK16SCHEDNOTIFY)(DWORD NotifyParm ,DWORD dwParam);

// Shared USER32 prototypes called by WOW32
typedef HWND    (WINAPI *PFNCSCREATEWINDOWEX)(DWORD dwExStyle, LPCTSTR lpClassName,
        LPCTSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HANDLE hInstance, LPVOID lpParam, DWORD Flags);
typedef VOID    (WINAPI *PFNDIRECTEDYIELD)(DWORD ThreadId);
typedef VOID    (WINAPI *PFNFREEDDEDATA)(HANDLE hDDE, BOOL fIgnorefRelease, BOOL fFreeTruelyGlobalObjects);
typedef LONG    (WINAPI *PFNGETCLASSWOWWORDS)(HINSTANCE hInstance, LPCTSTR pString);
typedef BOOL    (WINAPI *PFNINITTASK)(UINT dwExpWinVer, DWORD dwAppCompatFlags,DWORD dwUserWOWCompatFlags, LPCSTR lpszModName, LPCSTR lpszBaseFileName, DWORD hTaskWow, DWORD dwHotkey, DWORD idTask, DWORD dwX, DWORD dwY, DWORD dwXSize, DWORD dwYSize);
typedef ATOM    (WINAPI *PFNREGISTERCLASSWOWA)(PVOID lpWndClass, LPDWORD pdwWOWstuff);
typedef BOOL    (WINAPI *PFNREGISTERUSERHUNGAPPHANDLERS)(PFNW32ET pfnW32EndTask, HANDLE hEventWowExec);
typedef HWND    (WINAPI *PFNSERVERCREATEDIALOG)(HANDLE hmod, LPDLGTEMPLATE lpDlgTemplate, DWORD cb, HWND hwndOwner , DLGPROC pfnWndProc, LPARAM dwInitParam, UINT fFlags);
typedef HCURSOR (WINAPI *PFNSERVERLOADCREATECURSORICON)(HANDLE hmod, LPTSTR lpModName, DWORD dwExpWinVer, LPCTSTR lpName, DWORD cb, PVOID pcur, LPTSTR lpType, BOOL fClient);
typedef HMENU   (WINAPI *PFNSERVERLOADCREATEMENU)(HANDLE hMod, LPTSTR lpName, CONST LPMENUTEMPLATE pmt, DWORD cb, BOOL fCallClient);
typedef BOOL    (WINAPI *PFNWOWCLEANUP)(HANDLE hInstance, DWORD hTaskWow);
typedef BOOL    (WINAPI *PFNWOWMODULEUNLOAD)(HANDLE hModule);
typedef HWND    (WINAPI *PFNWOWFINDWINDOW)(LPCSTR lpClassName, LPCSTR lpWindowName);
typedef HBITMAP (WINAPI *PFNWOWLOADBITMAPA)(HINSTANCE hmod, LPCSTR lpName, LPBYTE pResData, DWORD cbResData);
typedef BOOL    (WINAPI *PFNWOWWAITFORMSGANDEVENT)(HANDLE hevent);
typedef BOOL    (WINAPI *PFNYIELDTASK)(VOID);
typedef DWORD   (WINAPI *PFNGETFULLUSERHANDLE)(WORD wHandle);
typedef DWORD   (WINAPI *PFNGETMENUINDEX)(HMENU hMenu, HMENU hSubMenu);
typedef WORD    (WINAPI *PFNWOWGETDEFWINDOWPROCBITS)(PBYTE pDefWindowProcBits, WORD cbDefWindowProcBits);
typedef VOID    (WINAPI *PFNFILLWINDOW)(HWND hwndParent, HWND hwnd, HDC hdc, HANDLE hBrush);

// other prototypes
typedef BOOL    (WINAPI *PFNWOWGLOBALFREEHOOK)(HGLOBAL hMem);


/*
 * MEASUREITEMSTRUCT itemWidth tag telling wow the itemData is a flat pointer
 */
#define MIFLAG_FLAT      0x464C4154

/*
 * WOWTask16SchedNotify NotifyParm values
 */
#define WOWSCHNOTIFY_WAIT  0x00000000
#define WOWSCHNOTIFY_RUN   0x00000001

/*
 * CallWindowProc Bits
 */
#define WOWCLASS_RPL_MASK  0x00060000  // the LDT bits that store the 2 high bits
#define WNDPROC_WOWPROC     0xC0000000  // These bits for WOW Window Procs
#define WNDPROC_WOWMASK     0x3fffffff  // To mask off wow bits
#define WNDPROC_HANDLE      0xFFFF      // HIWORD(x) == 0xFFFF for handle

// USER needs a way to distinguish between a WOW and a Win32 window proc. We
// used to achieve this by always setting the MSB of a 16:16 address as 1 (and
// storing the MSB in the Table indicator bit of the LDT which is always 1). The
// MSB of a user mode flat address was guranteed to be never 1 as the user mode
// address space was limited to 2GB. Starting with NT 5.0, user mode address
// space is being increased to 3GB. This change breaks the above assumption
// that a 32bit user mode flat address will never have the MSB as 1.
// To work around this problem, WOW is going to use the  two bits of a
// 16:16 address instead of just one. We will set both these bits as 1 because
// with 3GB address space, the user mode flat addresses cannot have 11 as the
// first two bits. To achieve this, we will save the 2 most significant bits of
// the selector in the bit 1 and bit 2. We are able to do this because for WOW
// because both these bits have fixed values.
//
// SudeepB 21-Nov-1996

#ifndef _WIN64

// MarkWOWProc
// zero out the RPL bits
// get the high two bit in position where they have to be saved
// save the high bits and mark it a wow proc

#define MarkWOWProc(vpfnProc,result)                                  \
{                                                                     \
    ULONG temp1,temp2;                                                \
    temp1 = (ULONG)vpfnProc & ~WOWCLASS_RPL_MASK;                     \
    temp2 = ((ULONG)vpfnProc & WNDPROC_WOWPROC) >> 13;                \
    (ULONG)result = temp1 | temp2 | WNDPROC_WOWPROC;                  \
}

// UnMarkWOWProc
// mask off the marker bits
// get the saved bits to right places
// restore the saved bits and set the RPL field correctly

#define UnMarkWOWProc(vpfnProc,result)                     \
{                                                          \
    ULONG temp1,temp2;                                     \
    temp1 = (ULONG)vpfnProc & WNDPROC_WOWMASK;             \
    temp2 = ((ULONG)vpfnProc & WOWCLASS_RPL_MASK) << 13;   \
    result = temp1 | temp2 | WOWCLASS_RPL_MASK;            \
}

#define IsWOWProc(vpfnProc) (((ULONG)vpfnProc & WNDPROC_WOWPROC) == WNDPROC_WOWPROC)

#else

#define MarkWOWProc(vpfnProc,result)    DBG_UNREFERENCED_PARAMETER(vpfnProc)
#define UnMarkWOWProc(vpfnProc,result)  DBG_UNREFERENCED_PARAMETER(vpfnProc)
#define IsWOWProc(vpfnProc)             (FALSE)

#endif

/*
 * CreateWindow flags
 */
#define CW_FLAGS_ANSI       0x00000001

typedef struct tagAPFNWOWHANDLERSIN
{
    // In'ees - passed from WOW32 to USER32 and called by USER32
    PFNLALLOC                           pfnLocalAlloc;
    PFNLREALLOC                         pfnLocalReAlloc;
    PFNLLOCK                            pfnLocalLock;
    PFNLUNLOCK                          pfnLocalUnlock;
    PFNLSIZE                            pfnLocalSize;
    PFNLFREE                            pfnLocalFree;
    PFNGETEXPWINVER                     pfnGetExpWinVer;
    PFN16GALLOC                         pfn16GlobalAlloc;
    PFN16GFREE                          pfn16GlobalFree;
    PFNEMPTYCB                          pfnEmptyCB;
    PFNFINDA                            pfnFindResourceEx;
    PFNLOAD                             pfnLoadResource;
    PFNFREE                             pfnFreeResource;
    PFNLOCK                             pfnLockResource;
    PFNUNLOCK                           pfnUnlockResource;
    PFNSIZEOF                           pfnSizeofResource;
    PFNWOWWNDPROCEX                     pfnWowWndProcEx;
    PFNWOWDLGPROCEX                     pfnWowDlgProcEx;
    PFNWOWEDITNEXTWORD                  pfnWowEditNextWord;
    PFNWOWCBSTOREHANDLE                 pfnWowCBStoreHandle;
    PFNGETPROCMODULE16                  pfnGetProcModule16;
    PFNWOWMSGBOXINDIRECTCALLBACK        pfnWowMsgBoxIndirectCallback;
    PFNWOWILSTRCMP                      pfnWowIlstrsmp;
    PFNWOWTELLWOWTHEHDLG                pfnWOWTellWOWThehDlg;
    PFNWOWTASK16SCHEDNOTIFY		pfnWowTask16SchedNotify;
} PFNWOWHANDLERSIN, * APFNWOWHANDLERSIN;


typedef struct tagAPFNWOWHANDLERSOUT
{
    // Out'ees - passed from USER32 to WOW32 and called/used by WOW32
    DWORD                               dwBldInfo;
    PFNCSCREATEWINDOWEX                 pfnCsCreateWindowEx;
    PFNDIRECTEDYIELD                    pfnDirectedYield;
    PFNFREEDDEDATA                      pfnFreeDDEData;
    PFNGETCLASSWOWWORDS                 pfnGetClassWOWWords;
    PFNINITTASK                         pfnInitTask;
    PFNREGISTERCLASSWOWA                pfnRegisterClassWOWA;
    PFNREGISTERUSERHUNGAPPHANDLERS      pfnRegisterUserHungAppHandlers;
    PFNSERVERCREATEDIALOG               pfnServerCreateDialog;
    PFNSERVERLOADCREATECURSORICON       pfnServerLoadCreateCursorIcon;
    PFNSERVERLOADCREATEMENU             pfnServerLoadCreateMenu;
    PFNWOWCLEANUP                       pfnWOWCleanup;
    PFNWOWMODULEUNLOAD                  pfnWOWModuleUnload;
    PFNWOWFINDWINDOW                    pfnWOWFindWindow;
    PFNWOWLOADBITMAPA                   pfnWOWLoadBitmapA;
    PFNWOWWAITFORMSGANDEVENT            pfnWowWaitForMsgAndEvent;
    PFNYIELDTASK                        pfnYieldTask;
    PFNGETFULLUSERHANDLE                pfnGetFullUserHandle;
    PFNGETMENUINDEX                     pfnGetMenuIndex;
    PFNWOWGETDEFWINDOWPROCBITS          pfnWowGetDefWindowProcBits;
    PFNFILLWINDOW                       pfnFillWindow;
    INT *                               aiWowClass;
} PFNWOWHANDLERSOUT, * APFNWOWHANDLERSOUT;


//
// The WW structure is embedded at the end of USER's WND structure.
// However, WOW and USER use different names to access the WW
// fields. So this structure is defined as a union of two structures,
// WHICH MUST HAVE THE SAME SIZE, just different field names.
//
// Make sure that WND_CNT_WOWDWORDS matches the number of DWORDs
//  used by the WOW only fields.
//
// FindPWW(hwnd) returns a read-only pointer to this structure for
// a given window.  To change elements of this structure, use
// SETWW (== SetWindowLong) with the appropriate GWL_WOW* offset
// defined below.
//

/* WOW class/handle type identifiers (see WARNING below)
 */

#define FNID_START                  0x0000029A
#define FNID_END                    0x000002B8

#define WOWCLASS_UNKNOWN    0   // here begin our "window handle" classes
#define WOWCLASS_WIN16      1
#define WOWCLASS_BUTTON     2
#define WOWCLASS_COMBOBOX   3
#define WOWCLASS_EDIT       4
#define WOWCLASS_LISTBOX    5
#define WOWCLASS_MDICLIENT  6
#define WOWCLASS_SCROLLBAR  7
#define WOWCLASS_STATIC     8
#define WOWCLASS_DESKTOP    9
#define WOWCLASS_DIALOG     10
#define WOWCLASS_ICONTITLE  11
#define WOWCLASS_MENU       12
#define WOWCLASS_SWITCHWND  13
#define WOWCLASS_COMBOLBOX  14
#define WOWCLASS_MAX        14  // Always equal to the last value used.

#define WOWCLASS_NOTHUNK    0xFF // not an actual class index
//
// WARNING! The above sequence and values must be maintained otherwise the
// table in WMSG16.C for message thunking must be changed.  Same goes for
// table in WALIAS.C.
//


//
// When including this from USER, VPWNDPROC is undefined
//
#ifndef _WALIAS_
typedef DWORD VPWNDPROC;
typedef DWORD VPSZ;
#endif

typedef struct tagWOWCLS {
    VPSZ       vpszMenu;
    WORD       iClsExtra;   // app's value for class extra
    WORD       hMod16;
    } WC;

typedef WC UNALIGNED *PWC;

typedef struct _WW { /* ww */
    /*
     *
     * WOW/USER fields
     * NOTE: The order and size of the following 4 fields is assumed
     *       by the SetWF, ClrWF, TestWF, MaskWF macros.
     *       Specifically, state must remain the first field in this structure.
     *
     */
    DWORD         state;        // State flags
    DWORD         state2;       //
    DWORD         ExStyle;      // Extended Style
    DWORD         style;        // Style flags

    KHANDLE       hModule;      // Handle to module instance data (32-bit).
    WORD          hMod16;       // WOW only -- hMod of wndproc
    WORD          fnid;         // record window proc used by this hwnd
                        // access through GETFNID

} WW, *PWW, **PPWW;

// this is tied to WFISINITIALIZED in ntuser\inc\user.h
#define WINDOW_IS_INITIALIZED   0x80000000

ULONG_PTR UserRegisterWowHandlers(APFNWOWHANDLERSIN apfnWowIn, APFNWOWHANDLERSOUT apfnWowOut);

VOID WINAPI RegisterWowBaseHandlers(PFNWOWGLOBALFREEHOOK pfn);

BOOL
InitTask(
    UINT dwExpWinVer,
    DWORD dwAppCompatFlags,
    DWORD dwAppCompatFlagsEx,
    LPCSTR lpszModName,
    LPCSTR lpszBaseFileName,
    DWORD hTaskWow,
    DWORD dwHotkey,
    DWORD idTask,
    DWORD dwX,
    DWORD dwY,
    DWORD dwXSize,
    DWORD dwYSize);

// Following bits occupy the hiword of hTaskWow which is actually only a WORD
#define HTW_IS16BIT	0x80000000
#define HTW_ISMEOW	0x40000000

BOOL YieldTask(VOID);

#define DY_OLDYIELD     ((DWORD)-1)
VOID DirectedYield(DWORD ThreadId);
DWORD UserGetInt16State(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duiborderlayout.h ===
/*
 * BorderLayout
 */

#ifndef DUI_BORDERLAYOUT_H_INCLUDED
#define DUI_BORDERLAYOUT_H_INCLUDED

#pragma once

namespace DirectUI
{

// BorderLayout positions
#define BLP_Left        0
#define BLP_Top         1
#define BLP_Right       2
#define BLP_Bottom      3
#define BLP_Client      4

////////////////////////////////////////////////////////
// BorderLayout

class BorderLayout : public Layout
{
public:
    static HRESULT Create(int dNumParams, int* pParams, OUT Value** ppValue);  // For parser
    static HRESULT Create(OUT Layout** ppLayout);

    // Layout callbacks
    virtual void DoLayout(Element* pec, int dWidth, int dHeight);
    virtual SIZE UpdateDesiredSize(Element* pec, int dConstW, int dConstH, Surface* psrf);
    virtual void OnAdd(Element* pec, Element** ppeAdd, UINT cCount);
    virtual void OnRemove(Element* pec, Element** ppeRemove, UINT cCount);
    virtual void OnLayoutPosChanged(Element* pec, Element* peChanged, int dOldLP, int dNewLP);
    virtual Element* GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyableOnly);

    BorderLayout() { }
    void Initialize();
    virtual ~BorderLayout() { }

    Element* _peClientPos;
    SIZE _sizeDesired;

    SIZE GetMaxCenter(Element* pec, int x, int y, int cw, int ch, int mTop, int mLeft, int mRight, int mBottom, bool setValues, HDC hDC);
    SIZE GetMaxLeftRight(Element* pec, int current, int x, int y, int cw, int ch, int mTop, int mLeft, int mRight, int mBottom, bool setValues, HDC hDC);
    SIZE GetMaxTopBottom(Element* pec, int current, int x, int y, int cw, int ch, int mTop, int mLeft, int mRight, int mBottom, bool setValues, HDC hDC = NULL);
    int NextChild(int i, Element* pec, Element** ppeCurrent, int* playoutPos);

private:
    void SetClient(Element* pe);
};

} // namespace DirectUI

#endif // DUI_BORDERLAYOUT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duiaccessibility.h ===
/*
 * Accessibility support
 */

#ifndef DUI_CORE_ACCESSIBILITY_H_INCLUDED
#define DUI_CORE_ACCESSIBILITY_H_INCLUDED

#pragma once

#include <oleauto.h>
#include <oleacc.h>

#if !defined(SUPPRESS)

#define SUPPRESS(ClassName) \
private: \
ClassName(const ClassName & copy); \
ClassName & operator=(const ClassName & rhs); \
public:

#endif

namespace DirectUI
{
class Element;
class HWNDElement;
class HWNDHost;

void NotifyAccessibilityEvent(IN DWORD dwEvent, Element * pe);

class DuiAccessible : public IAccessible, public IEnumVARIANT, public IOleWindow
{
public:
    static HRESULT Create(Element * pe, DuiAccessible ** ppDA);
    
    SUPPRESS(DuiAccessible);

    //
    // Our IAccessible implementations can be disconnected from the actual
    // element at any time.
    //
    virtual HRESULT Disconnect();

    DuiAccessible() { }
    void Initialize(Element * pe) { _pe = pe; _cRefs = 1; }
    virtual ~DuiAccessible();

public:
    //
    // IUnknown methods
    //
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvObj);

    //
    // IDispatch methods
    //
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid);
    STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr);

    //
    // IAccessible methods
    //
    STDMETHOD(accSelect)(long flagsSelect, VARIANT varChild);
    STDMETHOD(accLocation)(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild);
    STDMETHOD(accNavigate)(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt);
    STDMETHOD(accHitTest)(long xLeft, long yTop, VARIANT *pvarChildAtPoint);
    STDMETHOD(accDoDefaultAction)(VARIANT varChild);
    STDMETHOD(get_accChild)(VARIANT varChildIndex, IDispatch **ppdispChild);
    STDMETHOD(get_accParent)(IDispatch **ppdispParent);
    STDMETHOD(get_accChildCount)(long *pChildCount);
    STDMETHOD(get_accName)(VARIANT varChild, BSTR *pszName);
    STDMETHOD(put_accName)(VARIANT varChild, BSTR szName);
    STDMETHOD(get_accValue)(VARIANT varChild, BSTR *pszValue);
    STDMETHOD(put_accValue)(VARIANT varChild, BSTR pszValue);
    STDMETHOD(get_accDescription)(VARIANT varChild, BSTR *pszDescription);
    STDMETHOD(get_accKeyboardShortcut)(VARIANT varChild, BSTR *pszKeyboardShortcut);
    STDMETHOD(get_accRole)(VARIANT varChild, VARIANT *pvarRole);
    STDMETHOD(get_accState)(VARIANT varChild, VARIANT *pvarState);
    STDMETHOD(get_accHelp)(VARIANT varChild, BSTR *pszHelp);
    STDMETHOD(get_accHelpTopic)(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic);
    STDMETHOD(get_accFocus)(VARIANT *pvarFocusChild);
    STDMETHOD(get_accSelection)(VARIANT *pvarSelectedChildren);
    STDMETHOD(get_accDefaultAction)(VARIANT varChild, BSTR *pszDefaultAction);

    //
    // IEnumVARIANT methods
    //
    STDMETHOD(Next)(unsigned long celt, VARIANT * rgvar, unsigned long * pceltFetched);
    STDMETHOD(Skip)(unsigned long celt);
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(IEnumVARIANT ** ppenum);

    //
    // IOleWindow methods
    //
    STDMETHOD(GetWindow)(HWND * phwnd);
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);

protected:
    Element * GetAccessibleParent(Element * pe);
    HRESULT GetDispatchFromElement(Element * pe, IDispatch ** ppDispatch);

protected:
    Element * _pe;
    
private:
    LONG _cRefs;
};

class HWNDElementAccessible : public DuiAccessible
{
public:
    static HRESULT Create(HWNDElement * pe, DuiAccessible ** ppDA);
    SUPPRESS(HWNDElementAccessible);

    //
    // Our IAccessible implementations can be disconnected from the actual
    // element at any time.
    //
    virtual HRESULT Disconnect();

    HWNDElementAccessible() { }
    HRESULT Initialize(HWNDElement * pe);
    virtual ~HWNDElementAccessible();
    
public:
    //
    // IAccessible methods
    //
    STDMETHOD(get_accParent)(IDispatch **ppdispParent);
    
private:
    IAccessible * _pParent;
};

class HWNDHostAccessible : public DuiAccessible
{
public:
    static HRESULT Create(HWNDHost * pe, DuiAccessible ** ppDA);
    SUPPRESS(HWNDHostAccessible);

    //
    // Our IAccessible implementations can be disconnected from the actual
    // element at any time.
    //
    virtual HRESULT Disconnect();

    HWNDHostAccessible() { }
    HRESULT Initialize(HWNDHost * pe);
    virtual ~HWNDHostAccessible();
    
public:
    //
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvObj);
    
    //
    // IAccessible methods
    //
    STDMETHOD(accSelect)(long flagsSelect, VARIANT varChild);
    STDMETHOD(accLocation)(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild);
    STDMETHOD(accNavigate)(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt);
    STDMETHOD(accHitTest)(long xLeft, long yTop, VARIANT *pvarChildAtPoint);
    STDMETHOD(accDoDefaultAction)(VARIANT varChild);
    STDMETHOD(get_accChild)(VARIANT varChildIndex, IDispatch **ppdispChild);
    STDMETHOD(get_accParent)(IDispatch **ppdispParent);
    STDMETHOD(get_accChildCount)(long *pChildCount);
    STDMETHOD(get_accName)(VARIANT varChild, BSTR *pszName);
    STDMETHOD(put_accName)(VARIANT varChild, BSTR szName);
    STDMETHOD(get_accValue)(VARIANT varChild, BSTR *pszValue);
    STDMETHOD(put_accValue)(VARIANT varChild, BSTR pszValue);
    STDMETHOD(get_accDescription)(VARIANT varChild, BSTR *pszDescription);
    STDMETHOD(get_accKeyboardShortcut)(VARIANT varChild, BSTR *pszKeyboardShortcut);
    STDMETHOD(get_accRole)(VARIANT varChild, VARIANT *pvarRole);
    STDMETHOD(get_accState)(VARIANT varChild, VARIANT *pvarState);
    STDMETHOD(get_accHelp)(VARIANT varChild, BSTR *pszHelp);
    STDMETHOD(get_accHelpTopic)(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic);
    STDMETHOD(get_accFocus)(VARIANT *pvarFocusChild);
    STDMETHOD(get_accSelection)(VARIANT *pvarSelectedChildren);
    STDMETHOD(get_accDefaultAction)(VARIANT varChild, BSTR *pszDefaultAction);

    //
    // IEnumVARIANT methods
    //
    STDMETHOD(Next)(unsigned long celt, VARIANT * rgvar, unsigned long * pceltFetched);
    STDMETHOD(Skip)(unsigned long celt);
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(IEnumVARIANT ** ppenum);
    
    //
    // IOleWindow methods
    //
    STDMETHOD(GetWindow)(HWND * phwnd);
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);

private:
    IAccessible * _pCtrl;
    IEnumVARIANT * _pEnum;
    IOleWindow * _pOleWindow;
};

} // namespace DirectUI

#endif // DUI_CORE_ACCESSIBILITY_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duibutton.h ===
/*
 * Button
 */

#ifndef DUI_CONTROL_BUTTON_H_INCLUDED
#define DUI_CONTROL_BUTTON_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// Button

// ButtonClick event
struct ButtonClickEvent : Event
{
    UINT  nCount;
    UINT  uModifiers;
    POINT pt;
};

struct ButtonContextEvent : Event
{
    UINT uModifiers;
    POINT pt;
};

// Class definition
class Button : public Element
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(AE_MouseAndKeyboard, ppElement); }
    static HRESULT Create(UINT nActive, OUT Element** ppElement);

    // System events
    virtual void OnInput(InputEvent* pie);

    // Event types
    static UID Click;
    static UID Context;

    // Property definitions
    static PropertyInfo* PressedProp;
    static PropertyInfo* CapturedProp;

    // Quick property accessors
    bool GetPressed()           DUIQuickGetter(bool, GetBool(), Pressed, Specified)
    bool GetCaptured()          DUIQuickGetter(bool, GetBool(), Captured, Specified)

    HRESULT SetPressed(bool v)  DUIQuickSetter(CreateBool(v), Pressed)
    HRESULT SetCaptured(bool v) DUIQuickSetter(CreateBool(v), Captured)
     
    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // override the DefaultAction() of Element.
    virtual HRESULT DefaultAction();

    Button() { }
    HRESULT Initialize(UINT nActive);
    virtual ~Button() { }

private:
    BOOL  _bRightPressed;
};

} // namespace DirectUI

#endif // DUI_CONTROL_BUTTON_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\directuipp.h ===
/*
 * DirectUI UI file pre-process header
 */

#ifndef DUI_INC_DIRECTUIPP_H_INCLUDED
#define DUI_INC_DIRECTUIPP_H_INCLUDED

/*
 * NOTE: Various system #defines are replicated here for 2 reasons:
 *    1) Preprocessing a file like winuser.h results in a huge UIPP file
 *    2) The resultant UIPP file cannot be parsed by DUI due to function prototypes
 */


/*
 * SYSMETRIC: Retrieves system dependent information (integer values)
 *
 * Can use GetSystemMetrics() SM_* values plus DirectUI-specific values
 * as argument
 */

#ifndef DIRECTUIPP_IGNORESYSDEF

// GetSystemMetrics()

#define SM_CXSCREEN             0
#define SM_CYSCREEN             1
#define SM_CXVSCROLL            2
#define SM_CYHSCROLL            3
#define SM_CYCAPTION            4
#define SM_CXBORDER             5
#define SM_CYBORDER             6
#define SM_CXDLGFRAME           7
#define SM_CYDLGFRAME           8
#define SM_CYVTHUMB             9
#define SM_CXHTHUMB             10
#define SM_CXICON               11
#define SM_CYICON               12
#define SM_CXCURSOR             13
#define SM_CYCURSOR             14
#define SM_CYMENU               15
#define SM_CXFULLSCREEN         16
#define SM_CYFULLSCREEN         17
#define SM_CYKANJIWINDOW        18
#define SM_MOUSEPRESENT         19
#define SM_CYVSCROLL            20
#define SM_CXHSCROLL            21
#define SM_DEBUG                22
#define SM_SWAPBUTTON           23
#define SM_RESERVED1            24
#define SM_RESERVED2            25
#define SM_RESERVED3            26
#define SM_RESERVED4            27
#define SM_CXMIN                28
#define SM_CYMIN                29
#define SM_CXSIZE               30
#define SM_CYSIZE               31
#define SM_CXFRAME              32
#define SM_CYFRAME              33
#define SM_CXMINTRACK           34
#define SM_CYMINTRACK           35
#define SM_CXDOUBLECLK          36
#define SM_CYDOUBLECLK          37
#define SM_CXICONSPACING        38
#define SM_CYICONSPACING        39
#define SM_MENUDROPALIGNMENT    40
#define SM_PENWINDOWS           41
#define SM_DBCSENABLED          42
#define SM_CMOUSEBUTTONS        43
#define SM_CXFIXEDFRAME         SM_CXDLGFRAME
#define SM_CYFIXEDFRAME         SM_CYDLGFRAME
#define SM_CXSIZEFRAME          SM_CXFRAME
#define SM_CYSIZEFRAME          SM_CYFRAME
#define SM_SECURE               44
#define SM_CXEDGE               45
#define SM_CYEDGE               46
#define SM_CXMINSPACING         47
#define SM_CYMINSPACING         48
#define SM_CXSMICON             49
#define SM_CYSMICON             50
#define SM_CYSMCAPTION          51
#define SM_CXSMSIZE             52
#define SM_CYSMSIZE             53
#define SM_CXMENUSIZE           54
#define SM_CYMENUSIZE           55
#define SM_ARRANGE              56
#define SM_CXMINIMIZED          57
#define SM_CYMINIMIZED          58
#define SM_CXMAXTRACK           59
#define SM_CYMAXTRACK           60
#define SM_CXMAXIMIZED          61
#define SM_CYMAXIMIZED          62
#define SM_NETWORK              63
#define SM_CLEANBOOT            67
#define SM_CXDRAG               68
#define SM_CYDRAG               69
#define SM_SHOWSOUNDS           70
#define SM_CXMENUCHECK          71
#define SM_CYMENUCHECK          72
#define SM_SLOWMACHINE          73
#define SM_MIDEASTENABLED       74
#define SM_MOUSEWHEELPRESENT    75
#define SM_XVIRTUALSCREEN       76
#define SM_YVIRTUALSCREEN       77
#define SM_CXVIRTUALSCREEN      78
#define SM_CYVIRTUALSCREEN      79
#define SM_CMONITORS            80
#define SM_SAMEDISPLAYFORMAT    81
#define SM_CMETRICS             83

#endif // DIRECTUIPP_IGNORESYSDEF

#define DSM_NCMAX               -1
#define DSM_CAPTIONFONTSIZE     -1
#define DSM_CAPTIONFONTWEIGHT   -2
#define DSM_CAPTIONFONTSTYLE    -3
#define DSM_MENUFONTSIZE        -4
#define DSM_MENUFONTWEIGHT      -5
#define DSM_MENUFONTSTYLE       -6
#define DSM_MESSAGEFONTSIZE     -7
#define DSM_MESSAGEFONTWEIGHT   -8
#define DSM_MESSAGEFONTSTYLE    -9
#define DSM_SMCAPTIONFONTSIZE   -10
#define DSM_SMCAPTIONFONTWEIGHT -11
#define DSM_SMCAPTIONFONTSTYLE  -12
#define DSM_STATUSFONTSIZE      -13
#define DSM_STATUSFONTWEIGHT    -14
#define DSM_STATUSFONTSTYLE     -15
#define DSM_NCMIN               -15

#define DSM_ICMAX               -16
#define DSM_ICONFONTSIZE        -16
#define DSM_ICONFONTWEIGHT      -17
#define DSM_ICONFONTSTYLE       -18
#define DSM_ICMIN               -18


/*
 * SYSMETRICSTR: Retrieves system dependent information (string values)
 *
 * Can use DirectUI-specific values as argument
 */

#define DSMS_NCMIN              1
#define DSMS_CAPTIONFONTFACE    1
#define DSMS_MENUFONTFACE       2
#define DSMS_MESSAGEFONTFACE    3
#define DSMS_SMCAPTIONFONTFACE  4
#define DSMS_STATUSFONTFACE     5
#define DSMS_NCMAX              5

#define DSMS_ICMIN              6
#define DSMS_ICONFONTFACE       6
#define DSMS_ICMAX              6


#ifndef DIRECTUIPP_IGNORESYSDEF

/*
 * DrawFrameControl
 */

#define DFC_CAPTION             1
#define DFC_MENU                2
#define DFC_SCROLL              3
#define DFC_BUTTON              4
#define DFC_POPUPMENU           5

#define DFCS_CAPTIONCLOSE       0x0000
#define DFCS_CAPTIONMIN         0x0001
#define DFCS_CAPTIONMAX         0x0002
#define DFCS_CAPTIONRESTORE     0x0003
#define DFCS_CAPTIONHELP        0x0004

#define DFCS_MENUARROW          0x0000
#define DFCS_MENUCHECK          0x0001
#define DFCS_MENUBULLET         0x0002
#define DFCS_MENUARROWRIGHT     0x0004
#define DFCS_SCROLLUP           0x0000
#define DFCS_SCROLLDOWN         0x0001
#define DFCS_SCROLLLEFT         0x0002
#define DFCS_SCROLLRIGHT        0x0003
#define DFCS_SCROLLCOMBOBOX     0x0005
#define DFCS_SCROLLSIZEGRIP     0x0008
#define DFCS_SCROLLSIZEGRIPRIGHT 0x0010

#define DFCS_BUTTONCHECK        0x0000
#define DFCS_BUTTONRADIOIMAGE   0x0001
#define DFCS_BUTTONRADIOMASK    0x0002
#define DFCS_BUTTONRADIO        0x0004
#define DFCS_BUTTON3STATE       0x0008
#define DFCS_BUTTONPUSH         0x0010

#define DFCS_INACTIVE           0x0100
#define DFCS_PUSHED             0x0200
#define DFCS_CHECKED            0x0400

#define DFCS_TRANSPARENT        0x0800
#define DFCS_HOT                0x1000

#define DFCS_ADJUSTRECT         0x2000
#define DFCS_FLAT               0x4000
#define DFCS_MONO               0x8000

#endif // DIRECTUIPP_IGNORESYSDEF

/*
 * Themes Support (from TmSchema.h)
 *
 * Can't include UxTheme headers directly since they use 'enum' 
 * instead of #define. So, the preprocessor won't resolve to numbers.
 */

#ifndef DIRECTUIPP_IGNORESYSDEF

// Button parts
#define BP_PUSHBUTTON           1
#define BP_RADIOBUTTON          2
#define BP_CHECKBOX             3
#define BP_GROUPBOX             4
#define BP_USERBUTTON           5

// PushButton states
#define PBS_NORMAL              1
#define PBS_HOT                 2
#define PBS_PRESSED             3
#define PBS_DISABLED            4
#define PBS_DEFAULTED           5

// RadioButton states
#define RBS_UNCHECKEDNORMAL     1
#define RBS_UNCHECKEDHOT        2
#define RBS_UNCHECKEDPRESSED    3
#define RBS_UNCHECKEDDISABLED   4
#define RBS_CHECKEDNORMAL       5
#define RBS_CHECKEDHOT          6
#define RBS_CHECKEDPRESSED      7
#define RBS_CHECKEDDISABLED     8

// CheckBox states
#define CBS_UNCHECKEDNORMAL     1
#define CBS_UNCHECKEDHOT        2
#define CBS_UNCHECKEDPRESSED    3
#define CBS_UNCHECKEDDISABLED   4
#define CBS_CHECKEDNORMAL       5
#define CBS_CHECKEDHOT          6
#define CBS_CHECKEDPRESSED      7
#define CBS_CHECKEDDISABLED     8
#define CBS_MIXEDNORMAL         9
#define CBS_MIXEDHOT            10
#define CBS_MIXEDPRESSED        11
#define CBS_MIXEDDISABLED       12

// ScrollBar parts
#define SBP_ARROWBTN            1
#define SBP_THUMBBTNHORZ        2
#define SBP_THUMBBTNVERT        3
#define SBP_LOWERTRACKHORZ      4
#define SBP_UPPERTRACKHORZ      5
#define SBP_LOWERTRACKVERT      6
#define SBP_UPPERTRACKVERT      7
#define SBP_GRIPPERHORZ         8
#define SBP_GRIPPERVERT         9
#define SBP_SIZEBOX             10

// ArrowBtn states
#define ABS_UPNORMAL            1
#define ABS_UPHOT               2
#define ABS_UPPRESSED           3
#define ABS_UPDISABLED          4
#define ABS_DOWNNORMAL          5
#define ABS_DOWNHOT             6
#define ABS_DOWNPRESSED         7
#define ABS_DOWNDISABLED        8    
#define ABS_LEFTNORMAL          9
#define ABS_LEFTHOT             10
#define ABS_LEFTPRESSED         11
#define ABS_LEFTDISABLED        12
#define ABS_RIGHTNORMAL         13
#define ABS_RIGHTHOT            14
#define ABS_RIGHTPRESSED        15
#define ABS_RIGHTDISABLED       16

// ScrollBar states
#define SCRBS_NORMAL            1
#define SCRBS_HOT               2
#define SCRBS_PRESSED           3
#define SCRBS_DISABLED          4

// SizeBox states
#define SZB_RIGHTALIGN          1
#define SZB_LEFTALIGN           2

// Toolbar parts
#define TP_BUTTON               1
#define TP_DROPDOWNBUTTON       2
#define TP_SPLITBUTTON          3
#define TP_SPLITBUTTONDROPDOWN  4
#define TP_SEPARATOR            5
#define TP_SEPARATORVERT        6

// Toolbar states
#define TS_NORMAL               1
#define TS_HOT                  2
#define TS_PRESSED              3
#define TS_DISABLED             4
#define TS_CHECKED              5
#define TS_HOTCHECKED           6

#endif // DIRECTUIPP_IGNORESYSDEF

#endif // DUI_INC_DIRECTUIPP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duibtreelookup.h ===
/*
 * BTreeLookup
 */

/*
 * Stores data and associated key and uses a binary search for quick lookup
 * Used if gets are much more frequent than gets
 *
 * Keys are compared as pointers. If fKeyIsWStr is true, Keys are dereferenced
 * as WCHAR* and compared
 */

#ifndef DUI_BASE_BTREELOOKUP_H_INCLUDED
#define DUI_BASE_BTREELOOKUP_H_INCLUDED

#pragma once

namespace DirectUI
{

template <typename D> class BTreeLookup
{
    typedef struct
    {
        void* pKey;
        D tData;
    } ENTRY, *PENTRY;

    typedef void (*PBTENUMCALLBACK)(void* pKey, D tData);

public:
    static HRESULT Create(bool fKeyIsWStr, OUT BTreeLookup<D>** ppBTree);
    virtual ~BTreeLookup();

    void Destroy() { HDelete< BTreeLookup<D> >(this); }

    D* GetItem(void* pKey);                  // Pointer to Value (NULL if doesn't exist, internal copy returned)
    HRESULT SetItem(void* pKey, D* ptData);  // Setup Key/Value map, creates new is doesn't exist (via indirection)
    HRESULT SetItem(void* pKey, D tData);    // Setup Key/Value map, creates new is doesn't exist
    void Remove(void* pKey);                 // Removes Key/Value map, ok if Key doesn't exist
    void Enum(PBTENUMCALLBACK pfnCallback);  // Callback with every item in map

    static int __cdecl ENTRYCompare(const void* pA, const void* pB);
    static int __cdecl WStrENTRYCompare(const void* pA, const void* pB);

    BTreeLookup() { }
    void Initialize(bool fKeyIsWStr);

private:
    UINT _uListSize;
    PENTRY _pList;
    bool _fKeyIsWStr;
};

template <typename D> HRESULT BTreeLookup<D>::Create(bool fKeyIsWStr, OUT BTreeLookup<D>** ppBTree)
{
    *ppBTree = NULL;

    // Instantiate
    BTreeLookup<D>* pbt = HNew< BTreeLookup<D> >();
    if (!pbt)
        return E_OUTOFMEMORY;

    pbt->Initialize(fKeyIsWStr);

    *ppBTree = pbt;

    return S_OK;
}

template <typename D> void BTreeLookup<D>::Initialize(bool fKeyIsWStr)
{
    _uListSize = 0;
    _pList = NULL;
    _fKeyIsWStr = fKeyIsWStr;
}

template <typename D> BTreeLookup<D>::~BTreeLookup()
{
    if (_pList)
        HFree(_pList);
}

template <typename D> D* BTreeLookup<D>::GetItem(void* pKey)
{
    DUIAssert(_fKeyIsWStr ? pKey != NULL : true, "pKey may not be NULL");

    //PENTRY pEntry = NULL;

    if (_pList)
    {
        //ENTRY eKey = { pKey }; // Create ENTRY key, populate key field
        //pEntry = (PENTRY)bsearch(&eKey, _pList, _uListSize, sizeof(ENTRY), ENTRYCompare);

        PENTRY pEntry;
        int uPv;
        int uLo = 0;
        int uHi = _uListSize - 1;
        while (uLo <= uHi)
        {
            uPv = (uHi + uLo) / 2;

            pEntry = _pList + uPv;

            // Locate
            if (!_fKeyIsWStr)
            {
                // Key is numeric
                if ((UINT_PTR)pKey == (UINT_PTR)pEntry->pKey)
                    return &(pEntry->tData);

                if ((UINT_PTR)pKey < (UINT_PTR)pEntry->pKey)
                    uHi = uPv - 1;
                else
                    uLo = uPv + 1;
            }
            else
            {
                // Key is pointer to a wide string
                int cmp = _wcsicmp((LPCWSTR)pKey, (LPCWSTR)pEntry->pKey);

                if (!cmp)
                    return &(pEntry->tData);

                if (cmp < 0)
                    uHi = uPv - 1;
                else
                    uLo = uPv + 1;
            }
        }
    }

    //return pEntry ? &(pEntry->tData) : NULL;
    return NULL;
}

template <typename D> HRESULT BTreeLookup<D>::SetItem(void* pKey, D tData)
{
    D* pData = GetItem(pKey);  // Find current entry (if exits)

    if (pData)
    {
        // Entry found and have pointer to data of entry
        *pData = tData;
    }
    else
    {
        // Entry not found, allocate room for new entry, store, and sort

        // New size
        UINT uNewSize = _uListSize + 1;

        if (_pList)
        {
            DUIAssert(uNewSize > 1, "Tracked list size and actual size differ");

            PENTRY pNewList = (PENTRY)HReAlloc(_pList, sizeof(ENTRY) * uNewSize);
            if (!pNewList)
                return E_OUTOFMEMORY;

            _pList = pNewList;
        }
        else
        {
            DUIAssert(uNewSize == 1, "Tracked list size and actual list size differ");

            _pList = (PENTRY)HAlloc(sizeof(ENTRY));
            if (!_pList)
                return E_OUTOFMEMORY;
        }

        // Update size
        _uListSize = uNewSize;

        // Store
        _pList[_uListSize - 1].pKey = pKey;
        _pList[_uListSize - 1].tData = tData;

        // Sort
        qsort(_pList, _uListSize, sizeof(ENTRY), !_fKeyIsWStr ? ENTRYCompare : WStrENTRYCompare);
    }

    return S_OK;
}

template <typename D> HRESULT BTreeLookup<D>::SetItem(void* pKey, D* ptData)
{
    D* pData = GetItem(pKey);  // Find current entry (if exits)

    if (pData)
    {
        // Entry found and have pointer to data of entry
        *pData = *ptData;
    }
    else
    {
        // Entry not found, allocate room for new entry, store, and sort

        // New size
        UINT uNewSize = _uListSize + 1;

        if (_pList)
        {
            DUIAssert(uNewSize > 1, "Tracked list size and actual list size differ");

            PENTRY pNewList = (PENTRY)HReAlloc(_pList, sizeof(ENTRY) * uNewSize);
            if (!pNewList)
                return E_OUTOFMEMORY;

            _pList = pNewList;
        }
        else
        {
            DUIAssert(uNewSize == 1, "Tracked list size and actual list size differ");

            _pList = (PENTRY)HAlloc(sizeof(ENTRY));
            if (!_pList)
                return E_OUTOFMEMORY;
        }

        // Update size
        _uListSize = uNewSize;

        // Store
        _pList[_uListSize - 1].pKey = pKey;
        _pList[_uListSize - 1].tData = *ptData;

        // Sort
        qsort(_pList, _uListSize, sizeof(ENTRY), !_fKeyIsWStr ? ENTRYCompare : WStrENTRYCompare);
    }

    return S_OK;
}

// Returns success even if key isn't found
template <typename D> void BTreeLookup<D>::Remove(void* pKey)
{
    // Validate parameters
    DUIAssert(_fKeyIsWStr ? pKey != NULL : true, "Invalid parameter: pKey == NULL");

    if (_pList)
    {
        // Search for ENTRY with key
        //ENTRY eKey = { pKey };
        //PENTRY pEntry = (PENTRY)bsearch(&eKey, _pList, _uListSize, sizeof(ENTRY), ENTRYCompare);

        PENTRY pEntry = NULL;
        int uPv;
        int uLo = 0;
        int uHi = _uListSize - 1;
        while (uLo <= uHi)
        {
            uPv = (uHi + uLo) / 2;

            pEntry = _pList + uPv;

            // Locate
            if (!_fKeyIsWStr)
            {
                // Key is numeric
                if ((UINT_PTR)pKey == (UINT_PTR)pEntry->pKey)
                    break;

                if ((UINT_PTR)pKey < (UINT_PTR)pEntry->pKey)
                    uHi = uPv - 1;
                else
                    uLo = uPv + 1;
            }
            else
            {
                // Key is pointer to a wide string
                int cmp = _wcsicmp((LPCWSTR)pKey, (LPCWSTR)pEntry->pKey);

                if (!cmp)
                    break;

                if (cmp < 0)
                    uHi = uPv - 1;
                else
                    uLo = uPv + 1;
            }

            pEntry = NULL;
        }

        if (pEntry)
        {
            UINT uIndex = (UINT)(((UINT_PTR)pEntry - (UINT_PTR)_pList) / sizeof(ENTRY));

            DUIAssert(uIndex < _uListSize, "Index out of bounds");

            // ENTRY found, move all entries after this entry down
            MoveMemory(pEntry, pEntry + 1, (_uListSize - uIndex - 1) * sizeof(ENTRY));

            // One less entry
            UINT uNewSize = _uListSize - 1;

            // Trim allocation
            if (uNewSize == 0)
            {
                HFree(_pList);
                _pList = NULL;
            }
            else
            {
                PENTRY pNewList = (PENTRY)HReAlloc(_pList, uNewSize * sizeof(ENTRY));

                // List is becoming smaller, if re-allocation failed, keep previous and continue
                if (pNewList)
                    _pList = pNewList;
            }

            // Update size
            _uListSize = uNewSize;
        }
    }
}

template <typename D> void BTreeLookup<D>::Enum(PBTENUMCALLBACK pfnCallback)
{
    if (_pList)
    {
        for (UINT i = 0; i < _uListSize; i++)
            pfnCallback(_pList[i].pKey, _pList[i].tData);
    }
}

template <typename D> int __cdecl BTreeLookup<D>::ENTRYCompare(const void* pA, const void* pB)
{
    PENTRY pEA = (PENTRY)pA;
    PENTRY pEB = (PENTRY)pB;

    if ((UINT_PTR)pEA->pKey == (UINT_PTR)pEB->pKey)
        return 0;
    else if ((UINT_PTR)pEA->pKey < (UINT_PTR)pEB->pKey)
        return -1;
    else
        return 1;
}

template <typename D> int __cdecl BTreeLookup<D>::WStrENTRYCompare(const void* pA, const void* pB)
{
    PENTRY pEA = (PENTRY)pA;
    PENTRY pEB = (PENTRY)pB;

    // Ignore case
    return _wcsicmp((LPCWSTR)pEA->pKey, (LPCWSTR)pEB->pKey);
}

} // namespace DirectUI

#endif // DUI_BASE_BTREELOOKUP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duiconvert.h ===
/*
 * Conversion
 */

#ifndef DUI_UTIL_CONVERT_H_INCLUDED
#define DUI_UTIL_CONVERT_H_INCLUDED

#pragma once

namespace DirectUI
{

#define DUIARRAYSIZE(a)    (sizeof(a) / sizeof(a[0]))

/////////////////////////////////////////////////////////////////////////////
// String conversion

#define DUI_CODEPAGE    CP_ACP  // String conversion codepage

LPSTR UnicodeToMultiByte(LPCWSTR pszUnicode, int cChars = -1, int* pMultiBytes = NULL);
LPWSTR MultiByteToUnicode(LPCSTR pszMulti, int dBytes = -1, int* pUniChars = NULL);

/////////////////////////////////////////////////////////////////////////////
// Atom conversion

ATOM StrToID(LPCWSTR psz);

/////////////////////////////////////////////////////////////////////////////
// Bitmap conversion

HBITMAP LoadDDBitmap(LPCWSTR pszBitmap, HINSTANCE hResLoad, int cx, int cy);
#ifdef GADGET_ENABLE_GDIPLUS
HRESULT LoadDDBitmap(LPCWSTR pszBitmap, HINSTANCE hResLoad, int cx, int cy, UINT nFormat, OUT Gdiplus::Bitmap** ppgpbmp);
#endif
HBITMAP ProcessAlphaBitmapI(HBITMAP hbmSource);
#ifdef GADGET_ENABLE_GDIPLUS
Gdiplus::Bitmap * ProcessAlphaBitmapF(HBITMAP hbmSource, UINT nFormat);
#endif

/////////////////////////////////////////////////////////////////////////////
// Color conversion

inline COLORREF RemoveAlpha(COLORREF cr) { return ~(255 << 24) & cr; }
inline COLORREF NearestPalColor(COLORREF cr) { return (0x02000000) | cr; }

const int SysColorEnumOffset = 10000; // Used to identify a system color enum
inline bool IsSysColorEnum(int c) { return c >= SysColorEnumOffset; }
inline int MakeSysColorEnum(int c) { return c + SysColorEnumOffset; }
inline int ConvertSysColorEnum(int c) { return c - SysColorEnumOffset; }

HBRUSH BrushFromEnumI(int c);
COLORREF ColorFromEnumI(int c);
#ifdef GADGET_ENABLE_GDIPLUS
Gdiplus::Color ColorFromEnumF(int c);
#endif

#ifdef GADGET_ENABLE_GDIPLUS

inline Gdiplus::Color RemoveAlpha(Gdiplus::Color cr)
{ 
    return Gdiplus::Color(cr.GetR(), cr.GetG(), cr.GetB());
}

inline Gdiplus::Color Convert(COLORREF cr)
{
    return Gdiplus::Color(GetAValue(cr), GetRValue(cr), GetGValue(cr), GetBValue(cr));
}

#endif

inline IsOpaque(BYTE bAlphaLevel)
{
    return bAlphaLevel >= 250;
}

inline IsTransparent(BYTE bAlphaLevel)
{
    return bAlphaLevel <= 5;
}

int PointToPixel(int nPoint);
int RelPixToPixel(int nRelPix);

inline int PointToPixel(int nPoint, int nDPI)
{
    return -MulDiv(nPoint, nDPI, 72);
}

inline int RelPixToPixel(int nRelPix, int nDPI)
{
    return MulDiv(nRelPix, nDPI, 96);
}

/////////////////////////////////////////////////////////////////////////////
// Bitmap conversion

bool IsPalette(HWND hWnd = NULL);
//HPALETTE PALToHPALETTE(LPWSTR pPALFile, bool bMemFile = false, DWORD dMemFileSize = 0, LPRGBQUAD pRGBQuad = NULL, LPWSTR pError = NULL);

} // namespace DirectUI

#endif // DUI_UTIL_CONVERT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duiedit.h ===
// edit.h
//

#ifndef DUI_CONTROL_EDIT_H_INCLUDED
#define DUI_CONTROL_EDIT_H_INCLUDED

#include "duihwndhost.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Edit

// EditEnter event
struct EditEnterEvent : Event
{
};

// Class definition
class Edit : public HWNDHost
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(AE_MouseAndKeyboard, ppElement); }
    static HRESULT Create(UINT nActive, OUT Element** ppElement);

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);
    virtual void OnInput(InputEvent* pie);

    // Control notifications
    virtual bool OnNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet);

    virtual UINT MessageCallback(GMSG* pGMsg);

    // Rendering
    SIZE GetContentSize(int dConstW, int dConstH, Surface* psrf);

    // Event types
    static UID Enter;

    // Property definitions
    static PropertyInfo* MultilineProp;
    static PropertyInfo* PasswordCharacterProp;
    static PropertyInfo* DirtyProp;

    // Quick property accessors
    int GetPasswordCharacter()              DUIQuickGetter(int, GetInt(), PasswordCharacter, Specified)
    bool GetMultiline()                     DUIQuickGetter(bool, GetBool(), Multiline, Specified)
    bool GetDirty()                         DUIQuickGetter(bool, GetBool(), Dirty, Specified)
    

    HRESULT SetPasswordCharacter(int v)     DUIQuickSetter(CreateInt(v), PasswordCharacter)
    HRESULT SetMultiline(bool v)            DUIQuickSetter(CreateBool(v), Multiline)
    HRESULT SetDirty(bool v);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    Edit() { }
    virtual ~Edit() { }
    HRESULT Initialize(UINT nActive) { return HWNDHost::Initialize(HHC_CacheFont | HHC_SyncText | HHC_SyncPaint, nActive); }

protected:

    virtual HWND CreateHWND(HWND hwndParent);
};

} // namespace DirectUI

#endif // DUI_CONTROL_EDIT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duicombobox.h ===
// Combobox.h
//

#ifndef DUI_CONTROL_COMBOBOX_H_INCLUDED
#define DUI_CONTROL_COMBOBOX_H_INCLUDED

#include "duihwndhost.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Combobox

// SelectionChange event
struct SelectionIndexChangeEvent : Event
{
    int iOld;
    int iNew;
};

// Class definition
class Combobox : public HWNDHost
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(AE_MouseAndKeyboard, ppElement); }
    static HRESULT Create(UINT nActive, OUT Element** ppElement);

    // System events
    virtual void OnInput(InputEvent* pie);
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // Control notifications
    virtual bool OnNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet);

    // Sizing callback
    virtual BOOL OnAdjustWindowSize(int x, int y, UINT uFlags);

    // Rendering
    SIZE GetContentSize(int dConstW, int dConstH, Surface* psrf);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    int AddString(LPCWSTR lpszString);

    // Event types
    static UID SelectionChange;

    // Property definitions
    static PropertyInfo* SelectionProp;

    // Quick property accessors
    int     GetSelection()             DUIQuickGetter(int, GetInt(), Selection, Specified)

    HRESULT SetSelection(int v)        DUIQuickSetter(CreateInt(v), Selection)

    Combobox() { }
    virtual ~Combobox() { }
    HRESULT Initialize(UINT nActive) { return HWNDHost::Initialize(HHC_CacheFont | HHC_SyncText | HHC_SyncPaint, nActive); }

    virtual HWND CreateHWND(HWND hwndParent);
};

} // namespace DirectUI

#endif // DUI_CONTROL_COMBOBOX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duidynamicarray.h ===
/*
 * Dynamic array
 */

#ifndef DUI_BASE_DYNAMICARRAY_H_INCLUDED
#define DUI_BASE_DYNAMICARRAY_H_INCLUDED

#pragma once

namespace DirectUI
{

//-------------------------------------------------------------------------
//
// DyanamicArray
//
// Stores values in an array the double size when it reaches capacity
//
// Compile DEBUG for bounds checking and other DUIAsserts, see public class
// declarations for API
//
// Values are stored natively. Type is chosen at compile time. For example
// (Value is type BYTE, initial capacity is 10):
//
// DynamicArray<BYTE>* pda;
// DynamicArray<BYTE>::Create(10, &pda);
//
// pda->Add(4);
// pda->Insert(0, 7);
//
// DUITrace("0: %d\n", pda->GetItem(0));  // a[0] = 7
// DUITrace("1: %d\n", pda->GetItem(1));  // a[1] = 4
//
// pda->Remove(0);
//
// DUITrace("0: %d\n", pda->GetItem(0));  // a[0] = 4
//
// The Value type must support the following operation:
//    Assignment (=)
//
//-------------------------------------------------------------------------

template <typename T> class DynamicArray
{
public:                                                // API
    static HRESULT Create(UINT uCapacity, bool fZeroData, OUT DynamicArray<T>** ppArray);
    virtual ~DynamicArray();
    void Destroy() { HDelete< DynamicArray<T> >(this); }

    // 'Ptr' methods return addesses, note that Add and Insert may cause the array
    // to be reallocated and moved in memory. Be sure not to use pointers after
    // an Add or Insert operation

    typedef int (__cdecl *QSORTCMP )(const void*, const void*);

    HRESULT Add(T tItem);                              // Insert Item at end of list (double capacity if needed)
    HRESULT AddPtr(OUT T** ppNewItem);                 // Allocate room for Item at end of list and return pointer (double capacity if needed)
    HRESULT Insert(UINT uIndex, T tItem);              // Insert Item at location (double capacity if needed)
    HRESULT InsertPtr(UINT uIndex, OUT T** pNewItem);  // Allocate room at insertion point and return pointer (double capacity if needed)
    void SetItem(UINT uIndex, T tItem);                // Overwrite Item at location
    T GetItem(UINT uIndex);                            // Get Item at location
    T* GetItemPtr(UINT uIndex);                        // Get pointer to Item at location
    UINT GetSize();                                    // Return size of array (not current capacity)
    UINT GetIndexPtr(T* pItem);                        // Return index of Item based on its pointer
    int GetIndexOf(T tItem);                           // Return index of Item
    void Remove(UINT uIndex);                          // Remove Item at location
    void Reset();                                      // Reset array to be reused (make zero size)
    bool WasMoved();                                   // May be called right after Add or Insert to determine if da was moved in memory
    HRESULT Clone(OUT DynamicArray<T>** ppClone);      // Make exact copy of array
    bool IsEqual(DynamicArray<T>* pda);                // Return true if contents are equal to da
    void Sort(QSORTCMP fpCmp);                         // Sort the array
    void MakeImmutable();                              // Write-once, make so can only do read-only operations
    void MakeWritable();                               // Make read/write

    bool fLock       : 1;

    DynamicArray() { }
    HRESULT Initialize(UINT uCapacity, bool fZeroData);

private:
    UINT _uSize;
    UINT _uCapacity;
    T* _pData;

	bool _fZeroData  : 1;                   // Zero memory for data if InsertPtr is used
    bool _fWasMoved  : 1;                   // On a reallocation (via Add or Insert), true if fLock was moved
    bool _fImmutable : 1;                   // If true, can only do read-only operations
};

template <typename T> HRESULT DynamicArray<T>::Create(UINT uCapacity, bool fZeroData, OUT DynamicArray<T>** ppArray)
{
    *ppArray = NULL;

    // Instantiate
    DynamicArray<T>* pda = HNew< DynamicArray<T> >();
    if (!pda)
        return E_OUTOFMEMORY;

    HRESULT hr = pda->Initialize(uCapacity, fZeroData);
    if (FAILED(hr))
    {
        pda->Destroy();
        return hr;
    }

    *ppArray = pda;

    return S_OK;
}

template <typename T> HRESULT DynamicArray<T>::Initialize(UINT uCapacity, bool fZeroData)
{
    _uCapacity = uCapacity;
    _uSize = 0;

    if (_uCapacity)  // Allocate only if have an initial capacity
    {
        _pData = (T*)HAlloc(sizeof(T) * _uCapacity);
        if (!_pData)
            return E_OUTOFMEMORY;
    }
    else
        _pData = NULL;

    _fZeroData = fZeroData;
    _fWasMoved = false;
    _fImmutable = false;
    fLock = false;

    return S_OK;
}

template <typename T> DynamicArray<T>::~DynamicArray()
{
    if (_pData)
        HFree(_pData);
}

// Copy data into array
template <typename T> HRESULT DynamicArray<T>::Add(T tItem)
{
    return Insert(_uSize, tItem);
}

template <typename T> HRESULT DynamicArray<T>::AddPtr(OUT T** ppNewItem)
{
    return InsertPtr(_uSize, ppNewItem);
}

template <typename T> HRESULT DynamicArray<T>::Insert(UINT uIndex, T tItem)
{
    DUIAssert(!_fImmutable, "Only read operations allowed on immutable DynamicArray");

    _fWasMoved = false;

    DUIAssert(uIndex <= _uSize, "DynamicArray index out of bounds");

    // Resize if needed
    if (_uSize == _uCapacity)
    {
        // Double capacity of list
        UINT uNewCapacity = _uCapacity;

        if (uNewCapacity == 0)
        {
            uNewCapacity = 1;
        }
        else
        {
            uNewCapacity *= 2;
        }

        // Reallocate current fLock
        UINT_PTR pOld = (UINT_PTR)_pData;

        if (_pData)
        {
            T* pNewData = (T*)HReAlloc(_pData, sizeof(T) * uNewCapacity);
            if (!pNewData)
                return E_OUTOFMEMORY;

            _pData = pNewData;
        }
        else
        {
            _pData = (T*)HAlloc(sizeof(T) * uNewCapacity);
            if (!_pData)
                return E_OUTOFMEMORY;
        }

        // Update capacity field
        _uCapacity = uNewCapacity;

        if (pOld != (UINT_PTR)_pData)
            _fWasMoved = true;
    }

    // Shift data at index down one slot
    MoveMemory(_pData + (uIndex + 1), _pData + uIndex, (_uSize - uIndex) * sizeof(T));

    // Copy new data at insertion point
    _pData[uIndex] = tItem;

    _uSize++;

    return S_OK;
}

template <typename T> HRESULT DynamicArray<T>::InsertPtr(UINT uIndex, T** pNewItem)
{
    DUIAssert(!_fImmutable, "Only read operations allowed on immutable DynamicArray");

    _fWasMoved = false;

    DUIAssert(uIndex <= _uSize, "DynamicArray index out of bounds");

    // Resize if needed
    if (_uSize == _uCapacity)
    {
        // Double capacity of list
        UINT uNewCapacity = _uCapacity;

        if (uNewCapacity == 0)
        {
            uNewCapacity = 1;
        }
        else
        {
            uNewCapacity *= 2;
        }

        // Reallocate current fLock
        UINT_PTR pOld = (UINT_PTR)_pData;

        if (_pData)
        {
            T* pNewData = (T*)HReAlloc(_pData, sizeof(T) * uNewCapacity);
            if (!pNewData)
                return E_OUTOFMEMORY;

            _pData = pNewData;
        }
        else
        {
            _pData = (T*)HAlloc(sizeof(T) * uNewCapacity);
            if (!_pData)
                return E_OUTOFMEMORY;
        }

        // Update capacity field
        _uCapacity = uNewCapacity;

        if (pOld != (UINT_PTR)_pData)
            _fWasMoved = true;
    }

    // Shift data at index down one slot
    MoveMemory(_pData + (uIndex + 1), _pData + uIndex, (_uSize - uIndex) * sizeof(T));

    _uSize++;

    if (_fZeroData)
        ZeroMemory(_pData + uIndex, sizeof(T));

    *pNewItem = _pData + uIndex;

    return S_OK;
}

template <typename T> void DynamicArray<T>::SetItem(UINT uIndex, T tItem)
{
    DUIAssert(!_fImmutable, "Only read operations allowed on immutable DynamicArray");

    DUIAssert(uIndex < _uSize, "DynamicArray index out of bounds");

    // Copy new data at insertion point
    _pData[uIndex] = tItem;
}

template <typename T> T DynamicArray<T>::GetItem(UINT uIndex)
{
    DUIAssert(uIndex < _uSize, "DynamicArray index out of bounds");

    return _pData[uIndex];
}

template <typename T> T* DynamicArray<T>::GetItemPtr(UINT uIndex)
{
    DUIAssert(!_fImmutable, "Only read operations allowed on immutable DynamicArray");

    DUIAssert(uIndex < _uSize, "DynamicArray index out of bounds");

    return _pData + uIndex;
}

template <typename T> UINT DynamicArray<T>::GetIndexPtr(T* pItem)
{
    DUIAssert((((UINT_PTR)pItem - (UINT_PTR)_pData) / sizeof(T)) >= 0 && (((UINT_PTR)pItem - (UINT_PTR)_pData) / sizeof(T)) < _uSize, "GetIndexPtr out of bounds");
    return (UINT)(((UINT_PTR)pItem - (UINT_PTR)_pData) / sizeof(T));
}

template <typename T> int DynamicArray<T>::GetIndexOf(T tItem)
{
    for (UINT i = 0; i < _uSize; i++)
    {
        if (_pData[i] == tItem)
            return i;
    }

    return -1;
}

template <typename T> UINT DynamicArray<T>::GetSize()
{
    return _uSize;
}

template <typename T> void DynamicArray<T>::Remove(UINT uIndex)
{
    DUIAssert(!_fImmutable, "Only read operations allowed on immutable DynamicArray");

    DUIAssert(uIndex < _uSize, "DynamicArray index out of bounds");

    // Shift memory
    MoveMemory(_pData + uIndex, _pData + (uIndex + 1), (_uSize - uIndex - 1) * sizeof(T));

    _uSize--;
}

template <typename T> void DynamicArray<T>::Reset()
{
    DUIAssert(!_fImmutable, "Only read operations allowed on immutable DynamicArray");

    _uSize = 0;
    _fWasMoved = false;
    fLock = false;
}

template <typename T> bool DynamicArray<T>::WasMoved()
{
    return _fWasMoved;
}

template <typename T> HRESULT DynamicArray<T>::Clone(OUT DynamicArray<T>** ppClone)  // New instance returned
{
    // Validate parameters
    DUIAssert(ppClone, "Invalid parameter: ppClone == NULL");

    *ppClone = NULL;

    DynamicArray<T>* pda = HNew< DynamicArray<T> >();
    if (!pda)
        return E_OUTOFMEMORY;

    pda->_uSize = _uSize;
    pda->_uCapacity = _uCapacity;
    pda->_fZeroData = _fZeroData;
    pda->_fWasMoved = _fWasMoved;
    pda->_fImmutable = false;
    pda->_pData = NULL;

    if (_pData)
    {
        pda->_pData = (T*)HAlloc(sizeof(T) * _uCapacity);
        if (!pda->_pData)
        {
            pda->Destroy();
            return E_OUTOFMEMORY;
        }

        CopyMemory(pda->_pData, _pData, sizeof(T) * _uSize);
    }

    *ppClone = pda;

    return S_OK;
}

template <typename T> bool DynamicArray<T>::IsEqual(DynamicArray<T>* pda)
{
    if (!pda)
        return false;

    if (_uSize != pda->_uSize)
        return false;

    DUIAssert(!((_pData && !pda->_pData) || (!_pData && pda->_pData)), "Invalid comparison");

    if (_pData && memcmp(_pData, pda->_pData, sizeof(T) * _uSize) != 0)
        return false;

    return true;
}

template <typename T> void DynamicArray<T>::Sort(QSORTCMP fpCmp)
{
    if (_uSize)
    {
        qsort(_pData, _uSize, sizeof(T), fpCmp);
    }
}

template <typename T> void DynamicArray<T>::MakeImmutable()
{
#if DBG
    _fImmutable = true;
#endif
}

template <typename T> void DynamicArray<T>::MakeWritable()
{
#if DBG
    _fImmutable = false;
#endif
}

} // namespace DirectUI

#endif // DUI_BASE_DYNAMICARRAY_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duiemfload.h ===
/*
 * Metafile converter/loader
 */

#ifndef DUI_UTIL_EMFLOAD_H_INCLUDED
#define DUI_UTIL_EMFLOAD_H_INCLUDED

#pragma once

namespace DirectUI
{

#define HIMETRICINCH    2540
#define APM_SIGNATURE   0x9AC6CDD7

// Metafile Pagemaker structures
#ifndef RC_INVOKED
#pragma pack(2)
typedef struct tagRECTS
{
    short left;
    short top;
    short right;
    short bottom;
} RECTS, *PRECTS;

typedef struct tagAPMFILEHEADER
{
    DWORD key;
    WORD  hmf;
    RECTS bbox;
    WORD  inch;
    DWORD reserved;
    WORD  checksum;
} APMFILEHEADER, *PAPMFILEHEADER;
#pragma pack()
#endif

HENHMETAFILE LoadMetaFile(LPCWSTR pszMetaFile);
HENHMETAFILE LoadMetaFile(UINT uRCID, HINSTANCE hInst);
HENHMETAFILE LoadMetaFile(void* pData, UINT cbSize);

} // namespace DirectUI

#endif // DUI_UTIL_EMFLOAD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duierror.h ===
/*
 * Error checking support methods
 */

#ifndef DUI_BASE_ERROR_H_INCLUDED
#define DUI_BASE_ERROR_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// DirectUser debugging services

#define QUOTE(s) #s
#define STRINGIZE(s) QUOTE(s)
#define _countof(x) (sizeof(x) / sizeof(x[0]))

DECLARE_INTERFACE(IDebug)
{
    STDMETHOD_(BOOL, AssertFailedLine)(THIS_ LPCSTR pszExpression, LPCSTR pszFileName, UINT idxLineNum) PURE;
    STDMETHOD_(BOOL, IsValidAddress)(THIS_ const void * lp, UINT nBytes, BOOL bReadWrite) PURE;
    STDMETHOD_(void, BuildStack)(THIS_ HGLOBAL * phStackData, UINT * pcCSEntries) PURE;
    STDMETHOD_(BOOL, Prompt)(THIS_ LPCSTR pszExpression, LPCSTR pszFileName, UINT idxLineNum, LPCSTR pszTitle) PURE;
};

EXTERN_C DUSER_API IDebug* WINAPI GetDebug();
EXTERN_C DUSER_API void _cdecl AutoTrace(const char* pszFormat, ...);

#define IDebug_AssertFailedLine(p, a, b, c)         (p ? (p)->AssertFailedLine(a, b, c) : false)
#define IDebug_IsValidAddress(p, a, b, c)           (p ? (p)->IsValidAddress(a, b, c) : false)
#define IDebug_BuildStack(p, a, b)                  (p ? (p)->BuildStack(a, b) : false)
#define IDebug_Prompt(p, a, b, c, d)                (p ? (p)->Prompt(a, b, c, d) : false)

// Define AutoDebugBreak

#ifndef AutoDebugBreak
#define AutoDebugBreak() ForceDebugBreak()
#endif

////////////////////////////////////////////////////////
// DirectUI debugging macros

#if DBG

#define DUIAssert(f, comment) \
    { \
        if (!((f)) && IDebug_AssertFailedLine(GetDebug(), STRINGIZE((f)) "\r\n" comment, __FILE__, __LINE__)) \
            AutoDebugBreak(); \
    }

#define DUIAssertNoMsg(f) \
    { \
        if (!((f)) && IDebug_AssertFailedLine(GetDebug(), STRINGIZE((f)), __FILE__, __LINE__)) \
            AutoDebugBreak(); \
    } 

#define DUIAssertForce(comment) \
    { \
        if (IDebug_AssertFailedLine(GetDebug(), STRINGIZE((f)) "\r\n" comment, __FILE__, __LINE__)) \
            AutoDebugBreak(); \
    }

#define DUIPrompt(comment, prompt) \
    { \
        if (IDebug_Prompt(GetDebug(), comment, __FILE__, __LINE__, prompt)) \
            AutoDebugBreak(); \
    } 

#define DUIVerifyNoMsg(f)               DUIAssertNoMsg((f))

#define DUIVerify(f, comment)           DUIAssert((f), comment)

#define DUITrace                        AutoTrace

#else

#define DUIAssertNoMsg(f)               ((void)0)
#define DUIAssert(f, comment)           ((void)0)
#define DUIAssertForce(comment)         ((void)0)

#define DUIPrompt(comment, prompt)      ((void)0)

#define DUIVerifyNoMsg(f)               ((void)(f))
#define DUIVerify(f, comment)           ((void)(f, comment))

#define DUITrace                        1 ? (void) 0 : AutoTrace

#endif

////////////////////////////////////////////////////////
// Error codes

// If any DUI API can fail to an abnormal program event, the API's return value
// is always HRESULT. Any API that isn't part of this category either returns
// void or any other data type
//
// All erroneous program events (internal invalid state or invalid parameters)
// are handled by asserts

#define DUI_E_USERFAILURE               MAKE_DUERROR(1001)
#define DUI_E_NODEFERTABLE              MAKE_DUERROR(1002)
#define DUI_E_PARTIAL                   MAKE_DUERROR(1003)

////////////////////////////////////////////////////////
// Profiling support

#ifdef PROFILING

void ICProfileOn();
void ICProfileOff();

#define ProfileOn()    ICProfileOn()
#define ProfileOff()   ICProfileOff()
#else
#define ProfileOn()
#define ProfileOff()

#endif

////////////////////////////////////////////////////////
// Quick profiling

#define StartBlockTimer()  __int64 _dFreq, _dStart, _dStop; \
                           QueryPerformanceFrequency((LARGE_INTEGER*)&_dFreq); \
                           QueryPerformanceCounter((LARGE_INTEGER*)&_dStart)

#define StopBlockTimer()   QueryPerformanceCounter((LARGE_INTEGER*)&_dStop)

#define BlockTime()        (((_dStop - _dStart) * 1000) / _dFreq)


void ForceDebugBreak();

} // namespace DirectUI

#endif // DUI_BASE_ERROR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duielement.h ===
/*
 * Element
 */

#ifndef DUI_CORE_ELEMENT_H_INCLUDED
#define DUI_CORE_ELEMENT_H_INCLUDED

#pragma once

#include "duivalue.h"
#include "duievent.h"
#include "duisheet.h"
#include "duilayout.h"

struct IAccessible;

namespace DirectUI
{

#if DBG
extern UINT g_cGetDep;
extern UINT g_cGetVal;
extern UINT g_cOnPropChg;
#endif

class DuiAccessible;

// TODO: Switch DUI listeners to use DirectUser MessageHandlers

/*
 * Element Properties
 *
 * Element provides default behavior for Get/SetValue based on the flags used in PropertyInfo.
 * The Flags also define what indicies are available during property operations.
 *
 * Get/SetValue cannot be overridden. Rather, a default implemention is supplied for GetValue's
 * on all properties. By default, Get's on the Specified and Computed index are handled by a
 * built-in Value Expression (VE) while Get's on Local query a local store (see below for exact
 * default behavior). However, various system properties override this default behavior with
 * different unchangable Value Expressions (implicit VEs) in the Local and Computed indicies.
 *
 * End users will use Normal properties and may occasionally use LocalOnly properties. Although
 * available to derived classes, TriLevel property functionaly is only useful by the system.
 *
 * All property value must be available generically through GetValue.
 *
 * Flags supported (default behavior):
 * 
 * "LocalOnly"
 *   Indicies: Local
 *        Get: Retrieve local value from Element. If none is set, 'Unset' returned.
 *        Set: Stores value locally on the Element. 
 * Dependents: None
 *  Modifiers: Readonly: Disallow Set
 *
 * "Normal"
 *   Indicies: Local, Specified (implicit VE)
 *        Get:     Local: Retrieve local value from Element. If none is set, 'Unset' returned.
 *             Specified: Does a Get on the Local value. If 'Unset', return Property Sheet value
 *                        if Cascade modifier is set. If 'Unset', return parent's value if Inherit
 *                        modifier is set. If 'Unset' return property's Default value. 
 *                        Automatically evaulate value expressions before return.
 *        Set:     Local: Stores value locally on the Element.
 *             Specified: Unsupported.
 * Dependents: Specified is dependent on Local.
 *  Modifiers: Readonly: Disallow Set for Local.
 *              Cascade: Used with Specified Get (see Get description).
 *              Inherit: Used with Specified Get (see Get description).
 *
 * "TriLevel"
 *   Indicies: Local, Specified (implicit VE), Computed (implicit VE)
 *        Get:     Local: Retrieve local value from Element. If none is set, 'Unset' returned.
 *             Specified: Does a Get on the Local value. If 'Unset', return Property Sheet value
 *                        if Cascade modifier is set. If 'Unset', return parent's value if Inherit
 *                        modifier is set. If 'Unset' return property's Default value. 
 *                        Automatically evaulate value expressions before return.
 *              Computed: Does a get of the Specified value.
 *        Set:     Local: Stores value locally on the Element.
 *             Specified: Unsupported.
 *              Computed: Unsupported.
 * Dependents: Computed is dependent on Specified. Specified is dependent on Local.
 *  Modifiers: Readonly: Disallow Set for Local.
 *              Cascade: Used with Specified Get (see Get description).
 *              Inherit: Used with Specified Get (see Get description).
 *
 * SetValue must always be used by derived classes. However, SetValue is sometimes bypassed and
 * Pre/PostSourceChange is called directly in the case of LocalOnly properties that are ReadOnly
 * and are cached directly on the Element (optimization). All other ReadOnly sets use
 * _SetValue since generic storage (of Values) is used. SetValue is used in all other cases.
 *
 * For ReadOnly values, if storing the value is cheap (i.e. bools) and interit and style sheet
 * functionality is not required, it is best to not use generic storage (_SetValue). Rather,
 * write the value directly and call Pre/PostSourceChange directly ("LocalOnly property). 
 * Otherwise, if a ReadOnly value requires inheritance and/or sheet lookups, or the value is
 * seldom different than a default value, use _SetValue (generic storage, "Normal" property).
 *
 * For Normal/ReadOnly, use SetValue, For LocalOnly/ReadOnly, use _SetValue,
 * For internal LocalOnly/ReadOnly, set and store manually (no generic storage)
 *
 * All property values must be settable generically via SetValue except ReadOnly properties.
 * Any "LocalOnly" property that doesn't use generic storage must initialize their members
 * at construction to the property's default value. "Normal" properties will choose the
 * default value automatically when queried. All derived classes (external) will use "Normal"
 * properties.
 *
 * SetValue only accepts the PI_Local index. ReadOnly sets do not fire OnPropertyChanging.
 * All value sets must result in a PreSourceChange, followed by the store update (in which GetValue
 * will retrieve values from), followed by a PostSourceChange. OnPropertyChange and old value
 * compare are optional.
 *
 * Set values are updated immediately (i.e. an immediate GetValue after will produce the updated
 * result). Location and Extent are updated after the defer cycle ends (EndDefer, SetValues are internal).
 */

/*
 * Element Multithreading
 *
 * Elements have context affinity. A single thread is allowed per context. This thread
 * is owned by the context. Only that thread may be allowed to access objects in its
 * context. This requirement is not enforced in this library. The caller application
 * must ensure access to objects in a context happens via the owned thread.
 *
 * A Proxy class is provided to invoke methods on objects from an out-of-context thread.
 *
 * The library supports multiple instances in the same process. This would happen by
 * linking the library to multiple process modules. The only restriction is a thread
 * must access a set of objects consistantly with the same instance of the library code.
 *
 */

/*
 * Error Reporting
 *
 * Conditions that would affect the stability of DirectUI are reported. Some conditions are
 * only reported in Debug builds, and other in both Release and Debug
 *
 *  Debug time reporting:
 *   Erroneous states are reported in Debug (checked) builds. An erroneous state arises
 *   when a programming error is found or when invalid arguments are passed to a method.
 *   Erroneous states cause raising of asserts
 *
 *  Release time reporting:
 *   Abnormal states (such as out of memory or resources) that result in a serious condition
 *   (crash or very irregular state) are reported via HRESULTs. Any DUI API that can fail due to
 *   these types of abnormal states returns an HRESULT. If a method fails, it will recover.
 *   Some methods (such as object creation methods) will recover by freeing any memory or
 *   resources allocated within that method (resulting of a complete undo of all the work it
 *   accomplished up to the point of the failure). Other methods (such as rendering and the defer 
 *   cycle) will do as much work as possible. Upon a failure, they will return an 'incomplete'
 *   error, however, they would have not completed. Failures do not result in crashes or irregular
 *   state. Failures are ignored in callbacks
 */

typedef int (__cdecl *CompareCallback)(const void*, const void*);

// Property indicies
#define PI_Local        1
#define PI_Specified    2
#define PI_Computed     3

// Property flags
#define PF_LocalOnly    0x01
#define PF_Normal       0x02
#define PF_TriLevel     0x03
#define PF_Cascade      0x04
#define PF_Inherit      0x08
#define PF_ReadOnly     0x10

#define PF_TypeBits     0x03  // Map out for LocalOnly, Normal, or Trilevel

// For use in OnPropertyChanged, mask out non-retrieval index property changes
#define IsProp(p)       ((p##Prop == ppi) && ((ppi->fFlags&PF_TypeBits) == iIndex))
#define RetIdx(p)       (p->fFlags&PF_TypeBits)
    
// Property groups
#define PG_AffectsDesiredSize         0x00000001    // Normal priority
#define PG_AffectsParentDesiredSize   0x00000002
#define PG_AffectsLayout              0x00000004
#define PG_AffectsParentLayout        0x00000008
#define PG_AffectsBounds              0x00010000    // Low priority
#define PG_AffectsDisplay             0x00020000

#define PG_NormalPriMask              0x0000FFFF
#define PG_LowPriMask                 0xFFFF0000

// Layout cycle queue modes
#define LC_Pass         0
#define LC_Normal       1
#define LC_Optimize     2

// todo: get these from accessibility
#define GA_NOTHANDLED     ((Element*) -1)

// to be internal
#define NAV_LOGICAL    0x00000001 // unset == directional
#define NAV_FORWARD    0x00000002 // unset == backward
#define NAV_VERTICAL   0x00000004 // unset == horizontal
#define NAV_RELATIVE   0x00000008 // unset == absolute

// to be exposed
#define NAV_FIRST      (NAV_FORWARD | NAV_LOGICAL)
#define NAV_LAST       (NAV_LOGICAL)
#define NAV_UP         (NAV_RELATIVE | NAV_VERTICAL)
#define NAV_DOWN       (NAV_RELATIVE | NAV_VERTICAL | NAV_FORWARD)
#define NAV_LEFT       (NAV_RELATIVE)
#define NAV_RIGHT      (NAV_RELATIVE | NAV_FORWARD)
#define NAV_NEXT       (NAV_RELATIVE | NAV_FORWARD | NAV_LOGICAL)
#define NAV_PREV       (NAV_RELATIVE | NAV_LOGICAL)

// to be exposed
#define DIRECTION_LTR     0
#define DIRECTION_RTL     1

// Asynchronous destroy message (must be async to ensure outstanding
// defer pointers are cleared)
#define GM_DUIASYNCDESTROY            GM_USER - 1


////////////////////////////////////////////////////////
// PropertyInfo

struct IClassInfo;

struct EnumMap
{
    LPCWSTR pszEnum;
    int nEnum;
};

struct PropertyInfo
{
    WCHAR szName[81];
    int fFlags;
    int fGroups;
    int* pValidValues;
    EnumMap* pEnumMaps;
    Value* pvDefault;
    int _iIndex;           // Class-wide unique id (zero-based consecutive, set by ClassInfo)
    int _iGlobalIndex;     // Process-wide unique id (zero-based consecutive, set by ClassInfo (manually set for Element))
    IClassInfo* _pciOwner; // Class that this property is defined on (direct owner, not inherited-by)
};

class Element;

////////////////////////////////////////////////////////
// UpdateCache

struct UpdateCache
{
    Element* peSrc;
    PropertyInfo* ppiSrc;
    int iIndexSrc;
    Value* pvOldSrc;
    Value* pvNewSrc;
};

////////////////////////////////////////////////////////
// Dependencies

struct Dependency
{
    Element* pe;
    PropertyInfo* ppi;
    int iIndex;
};

// Track dependency records in PC list
struct DepRecs
{
    int iDepPos;
    int cDepCnt;
};

struct NavReference
{
    void Init(Element* pe, RECT* prc);

    UINT     cbSize;
    Element* pe;
    RECT*    prc;
};

////////////////////////////////////////////////////////
// Class information interface

// Used so that a class will not be linked out if a class is not referred to
// (and is only referred by the parser)
#define UsingDUIClass(classn) static IClassInfo* _DUI__pCI##classn = ##classn::Class

struct IClassInfo
{
    virtual HRESULT CreateInstance(OUT Element** ppElement) = 0;
    virtual PropertyInfo* EnumPropertyInfo(UINT nEnum) = 0;  // Includes base classes
    virtual UINT GetPICount() = 0;                           // Includes base classes
    virtual UINT GetGlobalIndex() = 0;
    virtual IClassInfo* GetBaseClass() = 0;
    virtual LPCWSTR GetName() = 0;
    virtual bool IsValidProperty(PropertyInfo* ppi) = 0;
    virtual bool IsSubclassOf(IClassInfo* pci) = 0;
    virtual void Destroy() = 0;
};

////////////////////////////////////////////////////////
// Element Listener interface
struct IElementListener
{
    virtual void OnListenerAttach(Element* peFrom) = 0;
    virtual void OnListenerDetach(Element* peFrom) = 0;
    virtual bool OnListenedPropertyChanging(Element* peFrom, PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew) = 0;
    virtual void OnListenedPropertyChanged(Element* peFrom, PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew) = 0;
    virtual void OnListenedInput(Element* peFrom, InputEvent* pInput) = 0;
    virtual void OnListenedEvent(Element* peFrom, Event* pEvent) = 0;
};

#if DBG
////////////////////////////////////////////////////////
// Track "owner" context of this instance to validation that threads that don't
// belong to the context don't access the object.
//
// For side-by-side library support, also store the TLS slot of the instance
// of the library in the process that created this object. This will ensure the 
// thread is using the correct library instance to access the object. 

struct Owner
{
    HDCONTEXT hCtx;
    DWORD dwTLSSlot;
};
#endif

////////////////////////////////////////////////////////
// Element

typedef DynamicArray<Element*> ElementList;
class DeferCycle;
struct PCRecord;

#define EC_NoGadgetCreate       0x1  // Do not create DisplayNode, must be created within constructor override
#define EC_SelfLayout           0x2  // Element will lay out children (via self layout callbacks)

class Element
{
public:

    ////////////////////////////////////////////////////////
    // Construction / destruction

    static HRESULT Create(UINT nCreate, OUT Element** ppe);
    HRESULT Destroy(bool fDelayed = true);  // Destroy self
    HRESULT DestroyAll();                   // Destroy all children

    Element() { }
    virtual ~Element();
    HRESULT Initialize(UINT nCreate);

    ////////////////////////////////////////////////////////
    // Properties (impl in property.cpp)

    // Accessors
    Value* GetValue(PropertyInfo* ppi, int iIndex, UpdateCache* puc = NULL);
    HRESULT SetValue(PropertyInfo* ppi, int iIndex, Value* pv);

    // Additional property methods
    HRESULT RemoveLocalValue(PropertyInfo* ppi);

    // Deferring
    static void StartDefer();
    static void EndDefer();

    // Checks
    inline bool IsValidAccessor(PropertyInfo* ppi, int iIndex, bool bSetting);
    static bool IsValidValue(PropertyInfo* ppi, Value* pv);
    bool IsRTL() { return (GetDirection() == DIRECTION_RTL);}

    // System event callbacks
    virtual bool OnPropertyChanging(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);  // Direct
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);   // Direct
    virtual void OnGroupChanged(int fGroups, bool bLowPri);                                      // Direct
    virtual void OnInput(InputEvent* pInput);                                                    // Direct and bubbled
    virtual void OnKeyFocusMoved(Element* peFrom, Element* peTo);                                // Direct and bubbled
    virtual void OnMouseFocusMoved(Element* peFrom, Element* peTo);                              // Direct and bubbled
    virtual void OnDestroy();                                                                    // Direct
    // ContainerCleanup: OnLoadedFromResource(dictionary)
 
    // Generic eventing and callback (pointer is only guaranteed good for the lifetime of the call)
    void FireEvent(Event* pEvent, bool fFull = true);
    virtual void OnEvent(Event* pEvent);

    // Rendering callbacks
    virtual void Paint(HDC hDC, const RECT* prcBounds, const RECT* prcInvalid, RECT* prcSkipBorder, RECT* prcSkipContent);
#ifdef GADGET_ENABLE_GDIPLUS
    virtual void Paint(Gdiplus::Graphics* pgpgr, const Gdiplus::RectF* prcBounds, const Gdiplus::RectF* prcInvalid, Gdiplus::RectF* prSkipBorder, Gdiplus::RectF* prSkipContent);
#endif
    virtual SIZE GetContentSize(int dConstW, int dConstH, Surface* psrf);
    float GetTreeAlphaLevel();

    // Hierarchy
    HRESULT Add(Element* pe);
    virtual HRESULT Add(Element** ppe, UINT cCount);
    HRESULT Insert(Element* pe, UINT iInsertIdx);
    virtual HRESULT Insert(Element** ppe, UINT cCount, UINT iInsertIdx);

    HRESULT Add(Element* pe, CompareCallback lpfnCompare);
    HRESULT SortChildren(CompareCallback lpfnCompare);

    HRESULT Remove(Element* peFrom);
    HRESULT RemoveAll();
    virtual HRESULT Remove(Element** ppe, UINT cCount);

    // Mapping and navigation
    Element* FindDescendent(ATOM atomID);
    void MapElementPoint(Element* peFrom, const POINT* pptFrom, POINT* pptTo);
    Element* GetImmediateChild(Element* peFrom);
    bool IsDescendent(Element* pe);
    virtual Element* GetAdjacent(Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyable);
    Element* GetKeyWithinChild();
    Element* GetMouseWithinChild();
    bool EnsureVisible();
    bool EnsureVisible(UINT uChild);
    virtual bool EnsureVisible(int x, int y, int cx, int cy);
    virtual void SetKeyFocus();

    // Element Listeners
    HRESULT AddListener(IElementListener* pel);
    void RemoveListener(IElementListener* pel);

    // Effects, animate display node to match current Element state
    void InvokeAnimation(int dAni, UINT nTypeMask);
    void InvokeAnimation(UINT nTypes, UINT nInterpol, float flDuration, float flDelay, bool fPushToChildren = false);
    void StopAnimation(UINT nTypes);

    // Display node callback extension
    virtual UINT MessageCallback(GMSG* pGMsg);

    // Internal defer cycle and Layout-only callbacks 
    SIZE _UpdateDesiredSize(int dConstW, int dConstH, Surface* psrf);
    void _UpdateLayoutPosition(int dX, int dY);
    void _UpdateLayoutSize(int dWidth, int dHeight);

    // Use in DoLayout on children where one or more properties will be changed which will
    // cause a Layout GPC to be queued. This will cancel the layout GPCs and force the child
    // to be included in the current layout cycle
    void _StartOptimizedLayoutQ() { DUIAssertNoMsg(_fBit.fNeedsLayout != LC_Optimize); _fBit.fNeedsLayout = LC_Optimize; }
    void _EndOptimizedLayoutQ() { _fBit.fNeedsLayout = LC_Normal; }

    // Internal defer cycle and PropertySheet-only callbacks
    static void _AddDependency(Element* pe, PropertyInfo* ppi, int iIndex, DepRecs* pdr, DeferCycle* pdc, HRESULT* phr);

    // Internal DirectUser interop
    static HRESULT CALLBACK _DisplayNodeCallback(HGADGET hgadCur, void * pvCur, EventMsg * pGMsg);

    // Internal IUnknown interface impl
    long __stdcall QueryInterface(REFIID iid, void** pvObj) { UNREFERENCED_PARAMETER(iid); UNREFERENCED_PARAMETER(pvObj); return E_NOTIMPL; }
    ULONG __stdcall AddRef() { return 1; }
    ULONG __stdcall Release() { return 1; }
    
private:

    // Value update
    HRESULT _GetDependencies(PropertyInfo* ppi, int iIndex, DepRecs* pdr, int iPCSrcRoot, DeferCycle* pdc);
    static void _VoidPCNotifyTree(int iPCPos, DeferCycle* pdc);

    // Defer cycle
    static void _FlushDS(Element* pe, DeferCycle* pdc);
    static void _FlushLayout(Element* pe, DeferCycle* pdc);

    // Value Update
    HRESULT _PreSourceChange(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);
    HRESULT _PostSourceChange();

protected:

    // EC_SelfLayout flag at creation activates these methods. No external layouts are used for layout,
    // rather, Element is responsible for layout (use when layout is specific and hierarchy is known)
    virtual void _SelfLayoutDoLayout(int dWidth, int dHeight);
    virtual SIZE _SelfLayoutUpdateDesiredSize(int dConstW, int dConstH, Surface* psrf);

    // Internal Set and Remove
    HRESULT _SetValue(PropertyInfo* ppi, int iIndex, Value* pv, bool fInternalCall = true);
    HRESULT _RemoveLocalValue(PropertyInfo* ppi, bool fInternalCall = true);

    // Natvie hosting system event callbacks and retrieval
    virtual void OnHosted(Element* peNewHost);    // Direct
    virtual void OnUnHosted(Element* peOldHost);  // Direct
    void MarkHosted() { _fBit.bHosted = true; }

public:

    inline void DoubleBuffered(bool fEnabled = true)
    {
        if (_hgDisplayNode)
            SetGadgetStyle(_hgDisplayNode, (fEnabled) ? GS_BUFFERED : 0, GS_BUFFERED);
    }

    inline BOOL IsRoot()
    {
        return IsHosted() && (GetParent() == NULL);
    }

    // Return if being hosted by a native root
    inline Element* GetRoot()
    {
        if (!IsHosted())
            return NULL;

        Element * peCur = this;
        while (peCur->GetParent() != NULL) 
        {
            peCur = peCur->GetParent();
        }
            
        return peCur;
    }

    static BTreeLookup<IClassInfo*>* pciMap;

    // Event types
    static UID KeyboardNavigate;

    // Property definitions
    static PropertyInfo* ParentProp;            // 00
    static PropertyInfo* ChildrenProp;          // 01
    static PropertyInfo* VisibleProp;           // 02 
    static PropertyInfo* WidthProp;             // 03
    static PropertyInfo* HeightProp;            // 04
    static PropertyInfo* LocationProp;          // 05
    static PropertyInfo* ExtentProp;            // 06
    static PropertyInfo* XProp;                 // 07
    static PropertyInfo* YProp;                 // 08
    static PropertyInfo* PosInLayoutProp;       // 09
    static PropertyInfo* SizeInLayoutProp;      // 10
    static PropertyInfo* DesiredSizeProp;       // 11
    static PropertyInfo* LastDSConstProp;       // 12
    static PropertyInfo* LayoutProp;            // 13
    static PropertyInfo* LayoutPosProp;         // 14
    static PropertyInfo* BorderThicknessProp;   // 15
    static PropertyInfo* BorderStyleProp;       // 16
    static PropertyInfo* BorderColorProp;       // 17
    static PropertyInfo* PaddingProp;           // 18
    static PropertyInfo* MarginProp;            // 19
    static PropertyInfo* ForegroundProp;        // 20
    static PropertyInfo* BackgroundProp;        // 21
    static PropertyInfo* ContentProp;           // 22
    static PropertyInfo* FontFaceProp;          // 23
    static PropertyInfo* FontSizeProp;          // 24
    static PropertyInfo* FontWeightProp;        // 25
    static PropertyInfo* FontStyleProp;         // 26
    static PropertyInfo* ActiveProp;            // 27
    static PropertyInfo* ContentAlignProp;      // 28
    static PropertyInfo* KeyFocusedProp;        // 29
    static PropertyInfo* KeyWithinProp;         // 30
    static PropertyInfo* MouseFocusedProp;      // 31
    static PropertyInfo* MouseWithinProp;       // 32
    static PropertyInfo* ClassProp;             // 33
    static PropertyInfo* IDProp;                // 34
    static PropertyInfo* SheetProp;             // 35
    static PropertyInfo* SelectedProp;          // 36
    static PropertyInfo* AlphaProp;             // 37
    static PropertyInfo* AnimationProp;         // 38
    static PropertyInfo* CursorProp;            // 39
    static PropertyInfo* DirectionProp;         // 40
    static PropertyInfo* AccessibleProp;        // 41
    static PropertyInfo* AccRoleProp;           // 42
    static PropertyInfo* AccStateProp;          // 43
    static PropertyInfo* AccNameProp;           // 44
    static PropertyInfo* AccDescProp;           // 45
    static PropertyInfo* AccValueProp;          // 46
    static PropertyInfo* AccDefActionProp;      // 47
    static PropertyInfo* ShortcutProp;          // 48
    static PropertyInfo* EnabledProp;           // 49

#if DBG
    Owner owner;
#endif

protected:

    HGADGET _hgDisplayNode;

private:

    int _iIndex;

    BTreeLookup<Value*>* _pvmLocal;

    int _iGCSlot;
    int _iGCLPSlot;
    int _iPCTail;

    IElementListener** _ppel;

    // All "cached" values are caching resulting values from the Specified and Computed IVEs.
    // All local (loc) values are for ReadOnly properties. These values are updated directly
    // since it is not required to go generically through SetValue because they are ReadOnly.
    // They are used often or are cheap to store (bools), so they do not use generic
    // storage (via _SetValue).

    // Cached and local values
    Element* _peLocParent;        // Parent local
    POINT _ptLocPosInLayt;        // Position in layout local
    SIZE _sizeLocSizeInLayt;      // Size in layout local
    SIZE _sizeLocLastDSConst;     // Last desired size constraint local
    SIZE _sizeLocDesiredSize;     // Desired size local

    int _dSpecLayoutPos;          // Cached layout position
    Value* _pvSpecSheet;          // Cached property sheet specified (Value cached due to destruction)
    ATOM _atomSpecID;             // Cached id specified
    int _dSpecAlpha;              // Cached alpha value

    struct _BitMap
    {
        // Local values
        bool bLocKeyWithin       : 1;  // 0  Keyboard within local
        bool bLocMouseWithin     : 1;  // 1  Mouse within local

        // Direct VE cache
        bool bCmpVisible         : 1;  // 2  Cached visible computed
        bool bSpecVisible        : 1;  // 3  Cached visible specified
        UINT fSpecActive         : 2;  // 4  Cached active state specified
        bool bSpecSelected       : 1;  // 5  Cached selected state specified
        bool bSpecKeyFocused     : 1;  // 6  Cached keyboard focused state specified
        bool bSpecMouseFocused   : 1;  // 7  Cached mouse focused state specified
        UINT nSpecDirection      : 1;  // 8  Cached direction specified
        bool bSpecAccessible     : 1;  // 9  Cached accessible specified
        bool bSpecEnabled        : 1;  // 10 Cached enabled specified

        // Indirect VE cache (cache if default value)
        bool bHasChildren        : 1;  // 11 Cached children state (likely to be default value, no full cache)
        bool bHasLayout          : 1;  // 12 Cached layout state (likely to be default value, no full cache)
        bool bHasBorder          : 1;  // 13 Cached border state (likely to be default value, no full cache)
        bool bHasPadding         : 1;  // 14 Cached padding state (likely to be default value, no full cache)
        bool bHasMargin          : 1;  // 15 Cached margin state (likely to be default value, no full cache)
        bool bHasContent         : 1;  // 16 Cached content state (likely to be default value, no full cache)
        bool bDefaultCAlign      : 1;  // 17 Cached content align state (likely to be default value, no full cache)
        bool bWordWrap           : 1;  // 18 Cached content align state (likely to be default value, no full cache)
        bool bHasAnimation       : 1;  // 19 Cached animation state (likely to be default value, no full cache)
        bool bDefaultCursor      : 1;  // 20 Cached cursor state (likely to be default value, no full cache)
        bool bDefaultBorderColor : 1;  // 21 Cached border color state (likely to be default value, no full cache)
        bool bDefaultForeground  : 1;  // 22 Cached foreground state (likely to be default value, no full cache)
        bool bDefaultFontWeight  : 1;  // 23 Cached font weight state (likely to be default value, no full cache)
        bool bDefaultFontStyle   : 1;  // 24 Cached font style state (likely to be default value, no full cache)

        // Layout and UDS flags
        bool bSelfLayout         : 1;  // 25 Element is laying out itself (callbacks active, external layout set is undefined)
        bool bNeedsDSUpdate      : 1;  // 26
        UINT fNeedsLayout        : 2;  // 27

        // Lifetime flags
        bool bDestroyed          : 1;  // 28

        // Hosting flags
        bool bHosted             : 1;  // 29 Initially set by host Element directly

    } _fBit;

public:

    // Element DisplayNode and Index access
    HGADGET GetDisplayNode()     { return _hgDisplayNode; }
    int GetIndex()               { return _iIndex; }
    bool IsDestroyed()           { return _fBit.bDestroyed; }
    bool IsHosted()              { return _fBit.bHosted; }

    // Cache state for faster property value lookup
    bool IsSelfLayout()          { return _fBit.bSelfLayout; }
    bool HasChildren()           { return _fBit.bHasChildren; }   // Quick check before doing lookup
    bool HasLayout()             { return _fBit.bHasLayout; }     // Quick check before doing lookup
    bool HasBorder()             { return _fBit.bHasBorder; }     // Quick check before doing lookup
    bool HasPadding()            { return _fBit.bHasPadding; }    // Quick check before doing lookup
    bool HasMargin()             { return _fBit.bHasMargin; }     // Quick check before doing lookup
    bool HasContent()            { return _fBit.bHasContent; }    // Quick check before doing lookup
    bool IsDefaultCAlign()       { return _fBit.bDefaultCAlign; } // Quick check before doing lookup
    bool IsWordWrap()            { return _fBit.bWordWrap; }      // Quick check before doing lookup
    bool HasAnimation()          { return _fBit.bHasAnimation; }  // Quick check before doing lookup
    bool IsDefaultCursor()       { return _fBit.bDefaultCursor; } // Quick check before doing lookup

    // Quick property accessors (since system has knowledge of its unchangable value expressions, use cached values 
    // directly were possible to bypass GetValue value lookup). Quick accessors are only used during non-cache
    // gets. (PostSourceChange requires GetValue directly (with update-cache flag) for cache updates.)
    // All derived classes do accessors normally (no direct cache lookups)

    #define DUIQuickGetter(t, gv, p, i)                     { Value* pv; t v = (pv = GetValue(p##Prop, PI_##i))->gv; pv->Release(); return v; }
    #define DUIQuickGetterInd(gv, p, i)                     { return (*ppv = GetValue(p##Prop, PI_##i))->gv; }
    #define DUIQuickSetter(cv, p)                           { Value* pv = Value::cv; if (!pv) return E_OUTOFMEMORY; HRESULT hr = SetValue(p##Prop, PI_Local, pv); pv->Release(); return hr; }

    Element* GetParent()                                    { return _peLocParent; }
    bool GetVisible()                                       { return _fBit.bCmpVisible; }
    int GetWidth()                                          DUIQuickGetter(int, GetInt(), Width, Specified)
    int GetHeight()                                         DUIQuickGetter(int, GetInt(), Height, Specified)
    ElementList* GetChildren(Value** ppv)                   { return (*ppv = (HasChildren() ? GetValue(ChildrenProp, PI_Specified) : ChildrenProp->pvDefault))->GetElementList(); }
    int GetX()                                              DUIQuickGetter(int, GetInt(), X, Specified)
    int GetY()                                              DUIQuickGetter(int, GetInt(), Y, Specified)
    Layout* GetLayout(Value** ppv)                          { return (*ppv = (HasLayout() ? GetValue(LayoutProp, PI_Specified) : LayoutProp->pvDefault))->GetLayout(); }
    int GetLayoutPos()                                      { return _dSpecLayoutPos; }
    const RECT* GetBorderThickness(Value** ppv)             { return (*ppv = (HasBorder() ? GetValue(BorderThicknessProp, PI_Specified) : BorderThicknessProp->pvDefault))->GetRect(); }
    int GetBorderStyle()                                    DUIQuickGetter(int, GetInt(), BorderStyle, Specified)
    int GetBorderStdColor()                                 DUIQuickGetter(int, GetInt(), BorderColor, Specified)
    const Fill* GetBorderColor(Value** ppv)                 DUIQuickGetterInd(GetFill(), BorderColor, Specified)
    const RECT* GetPadding(Value** ppv)                     { return (*ppv = (HasPadding() ? GetValue(PaddingProp, PI_Specified) : PaddingProp->pvDefault))->GetRect(); }
    const RECT* GetMargin(Value** ppv)                      { return (*ppv = (HasMargin() ? GetValue(MarginProp, PI_Specified) : MarginProp->pvDefault))->GetRect(); }
    const POINT* GetLocation(Value** ppv)                   DUIQuickGetterInd(GetPoint(), Location, Local)
    const SIZE* GetExtent(Value** ppv)                      DUIQuickGetterInd(GetSize(), Extent, Local)
    const SIZE* GetDesiredSize()                            { return &_sizeLocDesiredSize; }
    int GetForegroundStdColor()                             DUIQuickGetter(int, GetInt(), Foreground, Specified)
    const Fill* GetForegroundColor(Value** ppv)             DUIQuickGetterInd(GetFill(), Foreground, Specified)
    int GetBackgroundStdColor()                             DUIQuickGetter(int, GetInt(), Background, Specified)
    const LPWSTR GetContentString(Value** ppv)              { return (*ppv = (HasContent() ? GetValue(ContentProp, PI_Specified) : Value::pvStringNull))->GetString(); }
    const LPWSTR GetFontFace(Value** ppv)                   DUIQuickGetterInd(GetString(), FontFace, Specified)
    int GetFontSize()                                       DUIQuickGetter(int, GetInt(), FontSize, Specified)
    int GetFontWeight()                                     DUIQuickGetter(int, GetInt(), FontWeight, Specified)
    int GetFontStyle()                                      DUIQuickGetter(int, GetInt(), FontStyle, Specified)
    int GetActive()                                         { return _fBit.fSpecActive; }
    int GetContentAlign()                                   { Value* pv; int v = (pv = (!IsDefaultCAlign() ? GetValue(ContentAlignProp, PI_Specified) : Value::pvIntZero))->GetInt(); pv->Release(); return v; }
    bool GetKeyFocused()                                    { return _fBit.bSpecKeyFocused; }
    bool GetKeyWithin()                                     { return _fBit.bLocKeyWithin; }
    bool GetMouseFocused()                                  { return _fBit.bSpecMouseFocused; }
    bool GetMouseWithin()                                   { return _fBit.bLocMouseWithin; }
    const LPWSTR GetClass(Value** ppv)                      DUIQuickGetterInd(GetString(), Class, Specified)
    ATOM GetID()                                            { return _atomSpecID; }
    PropertySheet* GetSheet()                               { return _pvSpecSheet->GetPropertySheet(); }
    bool GetSelected()                                      { return _fBit.bSpecSelected; }
    int GetAlpha()                                          { return _dSpecAlpha; }
    int GetAnimation()                                      DUIQuickGetter(int, GetInt(), Animation, Specified)
    int GetDirection()                                      DUIQuickGetter(int, GetInt(), Direction, Specified)
    bool GetAccessible()                                    { return _fBit.bSpecAccessible; }
    int GetAccRole()                                        DUIQuickGetter(int, GetInt(), AccRole, Specified)
    int GetAccState()                                       DUIQuickGetter(int, GetInt(), AccState, Specified)
    const LPWSTR GetAccName(Value** ppv)                    DUIQuickGetterInd(GetString(), AccName, Specified)
    const LPWSTR GetAccDesc(Value** ppv)                    DUIQuickGetterInd(GetString(), AccDesc, Specified)
    const LPWSTR GetAccValue(Value** ppv)                   DUIQuickGetterInd(GetString(), AccValue, Specified)
    const LPWSTR GetAccDefAction(Value** ppv)               DUIQuickGetterInd(GetString(), AccDefAction, Specified)
    int GetShortcut()                                       DUIQuickGetter(int, GetInt(), Shortcut, Specified)
    bool GetEnabled()                                       { return _fBit.bSpecEnabled; }

    HRESULT SetVisible(bool v)                              DUIQuickSetter(CreateBool(v), Visible)
    HRESULT SetWidth(int v)                                 DUIQuickSetter(CreateInt(v), Width)
    HRESULT SetHeight(int v)                                DUIQuickSetter(CreateInt(v), Height)
    HRESULT SetX(int v)                                     DUIQuickSetter(CreateInt(v), X)
    HRESULT SetY(int v)                                     DUIQuickSetter(CreateInt(v), Y)
    HRESULT SetLayout(Layout* v)                            DUIQuickSetter(CreateLayout(v), Layout)
    HRESULT SetLayoutPos(int v)                             DUIQuickSetter(CreateInt(v), LayoutPos)
    HRESULT SetBorderThickness(int l, int t, int r, int b)  DUIQuickSetter(CreateRect(l, t, r, b), BorderThickness)
    HRESULT SetBorderStyle(int v)                           DUIQuickSetter(CreateInt(v), BorderStyle)
    HRESULT SetBorderStdColor(int v)                        DUIQuickSetter(CreateInt(v), BorderColor)
    HRESULT SetBorderColor(COLORREF cr)                     DUIQuickSetter(CreateColor(cr), BorderColor)
    HRESULT SetBorderGradientColor(COLORREF cr0, 
            COLORREF cr1, BYTE dType = FILLTYPE_HGradient)  DUIQuickSetter(CreateColor(cr0, cr1, dType), BorderColor)
    HRESULT SetPadding(int l, int t, int r, int b)          DUIQuickSetter(CreateRect(l, t, r, b), Padding)
    HRESULT SetMargin(int l, int t, int r, int b)           DUIQuickSetter(CreateRect(l, t, r, b), Margin)
    HRESULT SetForegroundStdColor(int v)                    DUIQuickSetter(CreateInt(v), Foreground)
    HRESULT SetForegroundColor(COLORREF cr)                 DUIQuickSetter(CreateColor(cr), Foreground)
    HRESULT SetForegroundColor(COLORREF cr0, COLORREF cr1, 
            BYTE dType = FILLTYPE_HGradient)                DUIQuickSetter(CreateColor(cr0, cr1, dType), Foreground)
    HRESULT SetForegroundColor(COLORREF cr0, COLORREF cr1, COLORREF cr2,
            BYTE dType = FILLTYPE_TriHGradient)             DUIQuickSetter(CreateColor(cr0, cr1, cr2, dType), Foreground)
    HRESULT SetBackgroundStdColor(int v)                    DUIQuickSetter(CreateInt(v), Background)
    HRESULT SetBackgroundColor(COLORREF cr)                 DUIQuickSetter(CreateColor(cr), Background)
    HRESULT SetBackgroundColor(COLORREF cr0, COLORREF cr1,
            BYTE dType = FILLTYPE_HGradient)                DUIQuickSetter(CreateColor(cr0, cr1, dType), Background)
    HRESULT SetBackgroundColor(COLORREF cr0, COLORREF cr1, COLORREF cr2,
            BYTE dType = FILLTYPE_TriHGradient)             DUIQuickSetter(CreateColor(cr0, cr1, cr2, dType), Background)
    HRESULT SetContentString(LPCWSTR v)                     DUIQuickSetter(CreateString(v), Content)
    HRESULT SetContentGraphic(LPCWSTR v, 
            BYTE dBlendMode = GRAPHIC_NoBlend,
            UINT dBlendValue = 0)                           DUIQuickSetter(CreateGraphic(v, dBlendMode, dBlendValue), Content)
    HRESULT SetContentGraphic(LPCWSTR v, USHORT cxDesired, 
            USHORT cyDesired)                               DUIQuickSetter(CreateGraphic(v, cxDesired, cyDesired), Content)
    HRESULT SetFontFace(LPCWSTR v)                          DUIQuickSetter(CreateString(v), FontFace)
    HRESULT SetFontSize(int v)                              DUIQuickSetter(CreateInt(v), FontSize)
    HRESULT SetFontWeight(int v)                            DUIQuickSetter(CreateInt(v), FontWeight)
    HRESULT SetFontStyle(int v)                             DUIQuickSetter(CreateInt(v), FontStyle)
    HRESULT SetActive(int v)                                DUIQuickSetter(CreateInt(v), Active)
    HRESULT SetContentAlign(int v)                          DUIQuickSetter(CreateInt(v), ContentAlign)
    HRESULT SetClass(LPCWSTR v)                             DUIQuickSetter(CreateString(v), Class)
    HRESULT SetID(LPCWSTR v)                                DUIQuickSetter(CreateAtom(v), ID)
    HRESULT SetSheet(PropertySheet* v)                      DUIQuickSetter(CreatePropertySheet(v), Sheet)
    HRESULT SetSelected(bool v)                             DUIQuickSetter(CreateBool(v), Selected)
    HRESULT SetAlpha(int v)                                 DUIQuickSetter(CreateInt(v), Alpha)
    HRESULT SetAnimation(int v)                             DUIQuickSetter(CreateInt(v), Animation)
    HRESULT SetStdCursor(int v)                             DUIQuickSetter(CreateInt(v), Cursor)
    HRESULT SetCursor(LPCWSTR v)                            DUIQuickSetter(CreateCursor(v), Cursor)
    HRESULT SetDirection(int v)                             DUIQuickSetter(CreateInt(v), Direction)
    HRESULT SetAccessible(bool v)                           DUIQuickSetter(CreateBool(v), Accessible)
    HRESULT SetAccRole(int v)                               DUIQuickSetter(CreateInt(v), AccRole)
    HRESULT SetAccState(int v)                              DUIQuickSetter(CreateInt(v), AccState)
    HRESULT SetAccName(LPCWSTR v)                           DUIQuickSetter(CreateString(v), AccName)
    HRESULT SetAccDesc(LPCWSTR v)                           DUIQuickSetter(CreateString(v), AccDesc)
    HRESULT SetAccValue(LPCWSTR v)                          DUIQuickSetter(CreateString(v), AccValue)
    HRESULT SetAccDefAction(LPCWSTR v)                      DUIQuickSetter(CreateString(v), AccDefAction)
    HRESULT SetShortcut(int v)                              DUIQuickSetter(CreateInt(v), Shortcut)
    HRESULT SetEnabled(bool v)                              DUIQuickSetter(CreateBool(v), Enabled)

    ////////////////////////////////////////////////////////
    // ClassInfo accessors (static and virtual instance-based)

    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    ///////////////////////////////////////////////////////
    // Accessibility support

    DuiAccessible * _pDuiAccessible;
    virtual HRESULT GetAccessibleImpl(IAccessible ** ppAccessible);
    HRESULT QueueDefaultAction();
    virtual HRESULT DefaultAction();
};

////////////////////////////////////////////////////////
// Element helpers

Element* ElementFromGadget(HGADGET hGadget);
void QueryDetails(Element* pe, HWND hParent);

////////////////////////////////////////////////////////
// DeferCycle: Per-thread deferring information

// Group notifications: deferred until EndDefer and coalesced
struct GCRecord
{
    Element* pe;
    int fGroups;
};

// Property notifications: deferred until source's dependency
// graph is searched (within SetValue call), not coalesced
struct PCRecord
{
    bool fVoid;
    Element* pe;
    PropertyInfo* ppi;
    int iIndex;
    Value* pvOld;
    Value* pvNew;
    DepRecs dr;
    int iPrevElRec;
};

class DeferCycle
{
public:
    static HRESULT Create(DeferCycle** ppDC);
    void Destroy() { HDelete<DeferCycle>(this); }
    
    void Reset();

    DynamicArray<GCRecord>* pdaGC;            // Group changed database
    DynamicArray<GCRecord>* pdaGCLP;          // Low priority group changed database
    DynamicArray<PCRecord>* pdaPC;            // Property changed database
    ValueMap<Element*,BYTE>* pvmLayoutRoot;   // Layout trees pending
    ValueMap<Element*,BYTE>* pvmUpdateDSRoot; // Update desired size trees pending

    int cEnter;
    bool fFiring;
    int iGCPtr;
    int iGCLPPtr;
    int iPCPtr;
    int iPCSSUpdate;
    int cPCEnter;

    DeferCycle() { }
    HRESULT Initialize();
    virtual ~DeferCycle();
};

#if DBG
// Process-wide element count
extern LONG g_cElement;
#endif

// Per-thread Element slot
extern DWORD g_dwElSlot;

struct ElTls
{
    HDCONTEXT hCtx;         // DirectUser thread context
    int cRef;
    SBAlloc* psba;
    DeferCycle* pdc;
    FontCache* pfc;
    bool fCoInitialized;
    int dEnableAnimations;
#if DBG
    int cDNCBEnter;         // Track when _DisplayNodeCallback is entered
#endif
};

/////////////////////////////////////////////////////////////////////////////
// Per-Context object access

inline bool IsAnimationsEnabled() 
{ 
    ElTls* petls = (ElTls*)TlsGetValue(g_dwElSlot);
    if (!petls) 
        return false; 
    return (petls->dEnableAnimations == 0); 
}

inline void EnableAnimations()
{
    ElTls* petls = (ElTls*)TlsGetValue(g_dwElSlot);
    if (!petls)
        return;
    petls->dEnableAnimations++;
}

inline void DisableAnimations()
{
    ElTls* petls = (ElTls*)TlsGetValue(g_dwElSlot);
    if (!petls)
        return;
    petls->dEnableAnimations--;
}

inline HDCONTEXT GetContext()
{
    ElTls* petls = (ElTls*)TlsGetValue(g_dwElSlot);
    if (!petls)
        return NULL;
    return petls->hCtx;
}

inline DeferCycle* GetDeferObject()
{
    ElTls* petls = (ElTls*)TlsGetValue(g_dwElSlot);
    if (!petls)
        return NULL;
    return petls->pdc;
}

inline FontCache* GetFontCache()
{
    ElTls* petls = (ElTls*)TlsGetValue(g_dwElSlot);
    if (!petls)
        return NULL;
    return petls->pfc;
}

inline SBAlloc* GetSBAllocator()
{
#if 0
    ElTls* petls = (ElTls*)TlsGetValue(g_dwElSlot);
    if (!petls)
        return NULL;
    return petls->psba;
#else
    ElTls* petls = (ElTls*)TlsGetValue(g_dwElSlot);
    DUIAssert(petls != NULL, "Must have valid SBAllocator");
    return petls->psba;
#endif
}

// Use to check if Element may be accessed via the current thread
#if DBG
inline void ContextCheck(Element* pe)
{
    DUIAssert(pe->owner.dwTLSSlot == g_dwElSlot, "Element being accessed out of side-by-side instance");
    DUIAssert(pe->owner.hCtx == GetContext(), "Element being accessed out of context");
}
#define DUIContextAssert(pe) ContextCheck(pe)
#else
#define DUIContextAssert(pe)
#endif

////////////////////////////////////////////////////////
// Property enumerations

// ActiveProp
#define AE_Inactive             0x00000000
#define AE_Mouse                0x00000001
#define AE_Keyboard             0x00000002
#define AE_MouseAndKeyboard     (AE_Mouse | AE_Keyboard)

// BorderStyleProp
#define BDS_Solid               0
#define BDS_Raised              1
#define BDS_Sunken              2
#define BDS_Rounded             3

// FontStyleProp
#define FS_None                 0x00000000
#define FS_Italic               0x00000001
#define FS_Underline            0x00000002
#define FS_StrikeOut            0x00000004
#define FS_Shadow               0x00000008

// FontWeightProp
#define FW_DontCare             0
#define FW_Thin                 100
#define FW_ExtraLight           200
#define FW_Light                300
#define FW_Normal               400
#define FW_Medium               500
#define FW_SemiBold             600
#define FW_Bold                 700
#define FW_ExtraBold            800
#define FW_Heavy                900
    
// ContentAlignProp (CAE_XY, Y=bits 0-1, X=bits 2-3)
#define CA_TopLeft              0x00000000  // (0,0)
#define CA_TopCenter            0x00000001  // (0,1)
#define CA_TopRight             0x00000002  // (0,2)
#define CA_MiddleLeft           0x00000004  // (1,0)
#define CA_MiddleCenter         0x00000005  // (1,1)
#define CA_MiddleRight          0x00000006  // (1,2)
#define CA_BottomLeft           0x00000008  // (2,0)
#define CA_BottomCenter         0x00000009  // (2,1)
#define CA_BottomRight          0x0000000A  // (2,2)
#define CA_WrapLeft             0x0000000C  // (3,0)
#define CA_WrapCenter           0x0000000D  // (3,1)
#define CA_WrapRight            0x0000000E  // (3,2)

#define CA_EndEllipsis          0x00000010
#define CA_FocusRect            0x00000020

// AnimationProp (Interpolation | CatType [ | CatType | ... ] | Speed)
#define ANI_InterpolMask        0x0000000F
#define ANI_DelayMask           0x000000F0
#define ANI_TypeMask            0x0FFFFF00
#define ANI_SpeedMask           0xF0000000

#define ANI_DefaultInterpol     0x00000000
#define ANI_Linear              0x00000001  // INTERPOLATION_LINEAR
#define ANI_Log                 0x00000002  // INTERPOLATION_LOG
#define ANI_Exp                 0x00000003  // INTERPOLATION_EXP
#define ANI_S                   0x00000004  // INTERPOLATION_S

#define ANI_DelayNone           0x00000000
#define ANI_DelayShort          0x00000010
#define ANI_DelayMedium         0x00000020
#define ANI_DelayLong           0x00000030

#define ANI_AlphaType           0x00000F00
#define ANI_BoundsType          0x0000F000
#define ANI_XFormType           0x000F0000

#define ANI_None                0x00000000
#define ANI_Alpha               0x00000100
#define ANI_Position            0x00001000
#define ANI_Size                0x00002000
#define ANI_SizeH               0x00003000
#define ANI_SizeV               0x00004000
#define ANI_Rect                0x00005000
#define ANI_RectH               0x00006000
#define ANI_RectV               0x00007000
#define ANI_Scale               0x00010000

#define ANI_DefaultSpeed        0x00000000
#define ANI_VeryFast            0x10000000
#define ANI_Fast                0x20000000
#define ANI_MediumFast          0x30000000
#define ANI_Medium              0x40000000
#define ANI_MediumSlow          0x50000000
#define ANI_Slow                0x60000000
#define ANI_VerySlow            0x70000000

// CursorProp
#define CUR_Arrow               0
#define CUR_Hand                1
#define CUR_Help                2
#define CUR_No                  3
#define CUR_Wait                4
#define CUR_SizeAll             5
#define CUR_SizeNESW            6
#define CUR_SizeNS              7
#define CUR_SizeNWSE            8
#define CUR_SizeWE              9
#define CUR_Total              10

// Internal property indicies for property compares. Must match up one to one
// with Element property definitions
#define _PIDX_Parent            0
#define _PIDX_PosInLayout       1
#define _PIDX_SizeInLayout      2
#define _PIDX_DesiredSize       3
#define _PIDX_LastDSConst       4
#define _PIDX_Location          5
#define _PIDX_Extent            6
#define _PIDX_LayoutPos         7
#define _PIDX_Active            8
#define _PIDX_Children          9
#define _PIDX_Layout            10
#define _PIDX_BorderThickness   11
#define _PIDX_Padding           12
#define _PIDX_Margin            13
#define _PIDX_Visible           14
#define _PIDX_X                 15
#define _PIDX_Y                 16
#define _PIDX_ContentAlign      17
#define _PIDX_KeyFocused        18
#define _PIDX_KeyWithin         19
#define _PIDX_MouseFocused      20
#define _PIDX_MouseWithin       21
#define _PIDX_Content           22
#define _PIDX_Sheet             23
#define _PIDX_Width             24
#define _PIDX_Height            25
#define _PIDX_BorderStyle       26
#define _PIDX_BorderColor       27
#define _PIDX_Foreground        28
#define _PIDX_Background        29
#define _PIDX_FontFace          30
#define _PIDX_FontSize          31
#define _PIDX_FontWeight        32
#define _PIDX_FontStyle         33
#define _PIDX_Class             34
#define _PIDX_ID                35
#define _PIDX_Selected          36
#define _PIDX_Alpha             37
#define _PIDX_Animation         38
#define _PIDX_Cursor            39
#define _PIDX_Direction         40
#define _PIDX_Accessible        41
#define _PIDX_AccRole           42
#define _PIDX_AccState          43
#define _PIDX_AccName           44
#define _PIDX_AccDesc           45
#define _PIDX_AccValue          46
#define _PIDX_AccDefAction      47
#define _PIDX_Shortcut          48
#define _PIDX_Enabled           49

#define _PIDX_TOTAL             50

////////////////////////////////////////////////////////
// Class information template

// All classes that derive from Element must create a global instance of this class.
// It maintains a list of the class properties (provides enumeration) and creation method
// C = Class, B = Base class

// Defined in Element.cpp
extern UINT g_iGlobalCI;
extern UINT g_iGlobalPI;

template <typename C, typename B> class ClassInfo : public IClassInfo
{
public:
    // Registration (cannot unregister -- will be registered until UnInitProcess is called)
    static HRESULT Register(LPCWSTR pszName, PropertyInfo** ppPI, UINT cPI)
    {
        HRESULT hr;
    
        // If class mapping doesn't exist, registration fails 
        if (!Element::pciMap)
            return E_FAIL;

        // Check for entry in mapping, if exists, ignore registration
        if (!Element::pciMap->GetItem((void*)pszName))
        {
            // Never been registered, create class info entry
            hr = Create(pszName, ppPI, cPI, &C::Class);
            if (FAILED(hr))
                return hr;
        
            hr = Element::pciMap->SetItem((void*)pszName, C::Class);
            if (FAILED(hr))
                return hr;
        }

        return S_OK;
    }

    // Construction
    static HRESULT Create(LPCWSTR pszName, PropertyInfo** ppPI, UINT cPI, IClassInfo** ppCI)
    {
        *ppCI = NULL;

        // Element map must already exist
        if (!Element::pciMap)
            return E_FAIL;
    
        ClassInfo* pci = HNew<ClassInfo>();
        if (!pci)
            return E_OUTOFMEMORY;

        // Setup state
        pci->_ppPI = ppPI;
        pci->_cPI = cPI;
        pci->_pszName = pszName;

        // Set global index
        pci->_iGlobalIndex = g_iGlobalCI++;

        // Setup property ownership
        for (UINT i = 0; i < cPI; i++)
        {
            ppPI[i]->_iIndex = i;
            ppPI[i]->_iGlobalIndex = g_iGlobalPI++;
            ppPI[i]->_pciOwner = pci;
        }

#if DBG
        // Call string conversion method directly since can't assume Util library is available for header
        CHAR szNameA[101];
        ZeroMemory(szNameA, sizeof(szNameA));
        WideCharToMultiByte(CP_ACP, 0, pszName, -1, szNameA, (sizeof(szNameA) / sizeof(CHAR)) - 1, NULL, NULL);
        //DUITrace("RegDUIClass[%d]: '%s', %d ClassProps\n", pci->_iGlobalIndex, szNameA, cPI);
#endif

        *ppCI = pci;

        return S_OK;
    }

    void Destroy() { HDelete<ClassInfo>(this); }

public:
    HRESULT CreateInstance(OUT Element** ppElement) { return C::Create(ppElement); }
    PropertyInfo* EnumPropertyInfo(UINT nEnum) { return (nEnum < _cPI) ? _ppPI[nEnum] : B::Class->EnumPropertyInfo(nEnum - _cPI); }
    UINT GetPICount() { return _cPI + B::Class->GetPICount(); }
    UINT GetGlobalIndex() { return _iGlobalIndex; }
    IClassInfo* GetBaseClass() { return B::Class; }
    LPCWSTR GetName() { return _pszName; }
    bool IsValidProperty(PropertyInfo* ppi) { return (ppi->_pciOwner == this) ? true : B::Class->IsValidProperty(ppi); }
    bool IsSubclassOf(IClassInfo* pci) { return (pci == this) ? true : B::Class->IsSubclassOf(pci); }

    ClassInfo() { }
    virtual ~ClassInfo() { }

private:
    PropertyInfo** _ppPI;  // Array of properties for this class (C)
    UINT _cPI;             // Count of properties for this class (C)
    UINT _iGlobalIndex;    // Zero-based unique contiguous class id
    LPCWSTR _pszName;      // Class name
};

} // namespace DirectUI

#endif // DUI_CORE_ELEMENT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duiexpression.h ===
/*
 * Value expressions
 */

#ifndef DUI_CORE_EXPRESSION_H_INCLUDED
#define DUI_CORE_EXPRESSION_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// Expression

class Expression
{
public:
    void Destroy() { HDelete<Expression>(this); }
};

} // namespace DirectUI

#endif // DUI_CORE_EXPRESSION_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duievent.h ===
/*
 * Event
 */

#ifndef DUI_CORE_EVENT_H_INCLUDED
#define DUI_CORE_EVENT_H_INCLUDED

#pragma once

namespace DirectUI
{

class Element;

////////////////////////////////////////////////////////
// Generic event structures

// Eventing system is based on DU's messaging system
// All DUI events are packaged into a DU message

#define GM_DUIEVENT     GM_USER - 2

struct Event
{
    // TODO: cbSize
    Element* peTarget;
    UID uidType;
    bool fHandled;
    UINT nStage;
};

BEGIN_STRUCT(GMSG_DUIEVENT, EventMsg)
    Event* pEvent;
END_STRUCT(GMSG_DUIEVENT)

////////////////////////////////////////////////////////
// System event structures

////////////////////////////////////////////////////////
// Input event type

struct InputEvent
{
    Element* peTarget;
    bool fHandled;
    UINT nStage;
    UINT nDevice;
    UINT nCode;
    UINT uModifiers;
};

// Input event GINPUT_MOUSE nCode extra fields
struct MouseEvent : InputEvent
{
    POINT ptClientPxl;
    BYTE bButton;
    UINT nFlags;
};

struct MouseDragEvent: MouseEvent
{
    SIZE  sizeDelta;
    BOOL  fWithin;
};

struct MouseClickEvent: MouseEvent
{
    UINT cClicks;
};

struct MouseWheelEvent: MouseEvent
{
    short sWheel;
};

// Input event GINPUT_KEYBOARD nCode extra fields
struct KeyboardEvent : InputEvent
{
    WCHAR ch;
    WORD cRep;
    WORD wFlags;
};

////////////////////////////////////////////////////////
// Action event type

// TODO


struct KeyboardNavigateEvent : Event
{
    int iNavDir;
};


////////////////////////////////////////////////////////
// DUI Element query message

// Eventing system is based on DU's messaging system
// All DUI events are packaged into a DU message

#define GM_DUIGETELEMENT   GM_USER - 3

BEGIN_STRUCT(GMSG_DUIGETELEMENT, EventMsg)
    Element* pe;
END_STRUCT(GMSG_DUIGETELEMENT)


////////////////////////////////////////////////////////
// DUI Accessibility default action

// Accessibility default actions are always async

#define GM_DUIACCDEFACTION  GM_USER - 4

} // namespace DirectUI

#endif // DUI_CORE_EVENT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duigadget.h ===
/*
 * Manual Gadget utility methods
 */

#ifndef DUI_UTIL_GADGET_H_INCLUDED
#define DUI_UTIL_GADGET_H_INCLUDED

#pragma once

namespace DirectUI
{

void SetGadgetOpacity(HGADGET hgad, BYTE dAlpha);
void OffsetGadgetPosition(HGADGET hgad, int x, int y);

} // namespace DirectUI

#endif // DUI_UTIL_GADGET_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duifilllayout.h ===
/*
 * FillLayout
 */

#ifndef DUI_FILLLAYOUT_H_INCLUDED
#define DUI_FILLLAYOUT_H_INCLUDED

#pragma once

namespace DirectUI
{

// FillLayout positions
// "Auto (-1)" means stretch to size of parent
// All other layout positions describe a limited type of stretch
// (i.e. "left" means stretch all edges to parent except right edge)
#define FLP_Left        0
#define FLP_Top         1
#define FLP_Right       2
#define FLP_Bottom      3

////////////////////////////////////////////////////////
// FillLayout

class FillLayout : public Layout
{
public:
    static HRESULT Create(int dNumParams, int* pParams, OUT Value** ppValue);  // For parser
    static HRESULT Create(OUT Layout** ppLayout);

    // Layout callbacks
    virtual void DoLayout(Element* pec, int dWidth, int dHeight);
    virtual SIZE UpdateDesiredSize(Element* pec, int dConstW, int dConstH, Surface* psrf);
    virtual Element* GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyableOnly);

    FillLayout() { };
    void Initialize();   
    virtual ~FillLayout() { };

private:
    RECT rcMargin;  
};

} // namespace DirectUI

#endif // DUI_FILLLAYOUT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duigridlayout.h ===
/*
 * Gridlayout
 */

#ifndef DUI_LAYOUT_GRIDLAYOUT_H_INCLUDED
#define DUI_LAYOUT_GRIDLAYOUT_H_INCLUDED

#pragma once

namespace DirectUI
{

// No layout positions

////////////////////////////////////////////////////////
// GridLayout

class GridLayout : public Layout
{
public:
    static HRESULT Create(int dNumParams, int* pParams, OUT Value** ppValue);  // For parser
    static HRESULT Create(int iRows, int iCols, OUT Layout** ppLayout);

    // Layout callbacks
    virtual void DoLayout(Element* pec, int cx, int cy);
    virtual SIZE UpdateDesiredSize(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf);
    virtual Element* GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyableOnly);

    GridLayout() { }
    void Initialize(int iRows, int iCols);
    virtual ~GridLayout();

protected:
    UINT _uRows;
    UINT _uCols;
    UINT _fBits;
    int* _arColMargins;
    int* _arRowMargins;

    inline UINT GetCurrentRows(Element* pec);
    inline UINT GetCurrentRows(int c);
    inline UINT GetCurrentCols(Element* pec);
    inline UINT GetCurrentCols(int c);
};

} // namespace DirectUI

#endif // DUI_LAYOUT_GRIDLAYOUT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duifontcache.h ===
/*
 * Font Cache
 */

#ifndef DUI_BASE_FONTCACHE_H_INCLUDED
#define DUI_BASE_FONTCACHE_H_INCLUDED

#pragma once

namespace DirectUI
{

// Supported styles
#define FS_None                 0x00000000
#define FS_Italic               0x00000001
#define FS_Underline            0x00000002
#define FS_StrikeOut            0x00000004

class FontCache
{
public:

    static HRESULT Create(UINT uCacheSize, OUT FontCache** ppCache);
    void Destroy();

    HFONT CheckOutFont(LPWSTR szFamily, int dSize, int dWeight, int dStyle, int dAngle);
    void CheckInFont() { _fLock = false; }

    struct FontRecord
    {
        HFONT hFont;

        WCHAR szFamily[LF_FACESIZE];
        int dSize;
        int dWeight;
        int dStyle;
        int dAngle;

        UINT uHits;
    };

    struct RecordIdx  // Array sorted by frequency of use
    {
        FontCache* pfcContext;  // Context used for global sort routine
        UINT idx;     // Refers to a FontRecord location
    };
    
    UINT _GetRecordHits(UINT uRec) { return (_pDB + uRec)->uHits; }

    FontCache() {}
    HRESULT Initialize(UINT uCacheSize);
    virtual ~FontCache();

private:
    bool _fLock;
    UINT _uCacheSize;
    FontRecord* _pDB;   // Array of cached records
    RecordIdx* _pFreq;  // Array of sorted record indicies by frequency of use
};

} // namespace DirectUI

#endif // DUI_BASE_FONTCACHE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duiflowlayout.h ===
/*
 * FlowLayout
 */

#ifndef DUI_LAYPUT_FLOWLAYOUT_H_INCLUDED
#define DUI_LAYPUT_FLOWLAYOUT_H_INCLUDED

#pragma once

namespace DirectUI
{

// No layout positions

struct LINE
{
    UINT cx;             // length of line
    UINT cy;             // thickness of line
    UINT y;              // pixel start of line (always 0 for first line)
    UINT cElements;      // number of elements in line
    UINT* arxElement;    // pixel start of elements in line (one less than cElements -- because first start is always 0)
    UINT iStart;         // index of first element in line
};

////////////////////////////////////////////////////////
// flow layout

class FlowLayout : public Layout
{
public:
    static HRESULT Create(int dNumParams, int* pParams, OUT Value** ppValue);  // For parser
    static HRESULT Create(bool fWrap, UINT uYAlign, UINT uXLineAlign, UINT uYLineAlign, OUT Layout** ppLayout);
    
    // Layout callbacks
    virtual void DoLayout(Element* pec, int dWidth, int dHeight);
    virtual SIZE UpdateDesiredSize(Element* pec, int dConstW, int dConstH, Surface* psrf);
    virtual Element* GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool fKeyableOnly);

    int GetLine(Element* pec, Element* pe);

    FlowLayout() { }
    void Initialize(bool fWrap, UINT uYAlign, UINT uXLineAlign, UINT uYLineAlign);
    virtual ~FlowLayout();

protected:
    SIZE BuildCacheInfo(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf, bool fRealSize);

    bool _fWrap;
    UINT _uXLineAlign;
    UINT _uYLineAlign;
    UINT _uYAlign;
    SIZE _sizeDesired;
    SIZE _sizeLastConstraint;
    UINT _cLines;
    LINE* _arLines;

    static SIZE g_sizeZero;

    // not sure we need to have these -- check i18n dir & dir override flags to see if they're enough
    // bool _bBtoT;
    // bool _bRtoL;
};

} // namespace DirectUI

#endif // DUI_LAYPUT_FLOWLAYOUT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duihost.h ===
/*
 * Host
 */

#ifndef DUI_CORE_HOST_H_INCLUDED
#define DUI_CORE_HOST_H_INCLUDED

#pragma once

#include "duielement.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// HWNDElement

#define HWEM_FLUSHWORKINGSET      WM_USER

class HWNDElement : public Element
{
public:
    static HRESULT Create(OUT Element** ppElement);  // Required for ClassInfo (always fails)
    static HRESULT Create(HWND hParent, bool fDblBuffer, UINT nCreate, OUT Element** ppElement);

    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);
    virtual void OnGroupChanged(int fGroups, bool bLowPri);
    virtual void OnDestroy();
    virtual void OnEvent(Event* pEvent);
    virtual void OnInput(InputEvent* pInput);
    virtual bool CanSetFocus() {return true;}

    Element* ElementFromPoint(POINT* ppt);

    static LRESULT CALLBACK StaticWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);    
    virtual LRESULT WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    void FlushWorkingSet();  // Async

    HWND GetHWND() { return _hWnd; }
    Element* GetKeyFocusedElement();

    void ShowUIState(bool fUpdateAccel, bool fUpdateFocus);
    WORD GetUIState() { return _wUIState; }
    bool ShowAccel() { return !(GetUIState() & UISF_HIDEACCEL); }
    bool ShowFocus() { return !(GetUIState() & UISF_HIDEFOCUS); }

    void SetParentSizeControl(bool bParentSizeControl) {_bParentSizeControl = bParentSizeControl;}
    void SetScreenCenter(bool bScreenCenter) {_bScreenCenter = bScreenCenter;}
    
    // Property definitions
    static PropertyInfo* WrapKeyboardNavigateProp;

    // Quick property accessors
    bool GetWrapKeyboardNavigate()           DUIQuickGetter(bool, GetBool(), WrapKeyboardNavigate, Specified)

    HRESULT SetWrapKeyboardNavigate(bool v)  DUIQuickSetter(CreateBool(v), WrapKeyboardNavigate)

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    ///////////////////////////////////////////////////////
    // Accessibility support
    virtual HRESULT GetAccessibleImpl(IAccessible ** ppAccessible);
    
    HWNDElement() {_bParentSizeControl = false;  _bScreenCenter = false;}
    virtual ~HWNDElement() { }
    HRESULT Initialize(HWND hParent, bool fDblBuffer, UINT nCreate);

protected:

    HWND _hWnd;
    HPALETTE _hPal;
    bool _bParentSizeControl;
    bool _bScreenCenter;
    WORD _wUIState;
};

} // namespace DirectUI

#endif // DUI_CORE_HOST_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duinavigation.h ===
/*
 * Spatial navigation support
 */

#ifndef DUI_CORE_NAVIGATION_H_INCLUDED
#define DUI_CORE_NAVIGATION_H_INCLUDED

#pragma once

namespace DirectUI
{

//
// This class encapsulates the "standard" approach to spatial
// navigation.  Will need much work in the future.
//
class DuiNavigate
{
public:
    static Element * Navigate(Element * peFrom, ElementList * pelConsider, int nNavDir);
};

}

#endif // DUI_CORE_NAVIGATION_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duinative.h ===
/*
 * Native
 */

#ifndef DUI_CONTROL_NATIVE_H_INCLUDED
#define DUI_CONTROL_NATIVE_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// Top-level native HWND host of HWNDElement

#define NHHO_IgnoreClose          1  // Ignore WM_CLOSE (i.e. Alt-F4, 'X' button), must be closed via DestroyWindow
#define NHHO_NoSendQuitMessage    2
#define NHHO_HostControlsSize     4
#define NHHO_ScreenCenter         8
#define NHHO_DeleteOnHWNDDestroy  16 // If the HWND is destroyed, destroy NativeHWNDHost instance


#define NHHM_ASYNCDESTROY   WM_USER

class NativeHWNDHost
{
public:
    static HRESULT Create(LPCWSTR pszTitle, HWND hWndParent, HICON hIcon, int dX, int dY, int dWidth, int dHeight, int iExStyle, int iStyle, UINT nOptions, OUT NativeHWNDHost** ppHost);
    void Destroy() { HDelete<NativeHWNDHost>(this); }

    HWND GetHWND() { return _hWnd; }
    Element* GetElement() { return _pe; }
    void Host(Element* pe);
    void ShowWindow(int iShow = SW_SHOWNORMAL) { DUIAssertNoMsg(_hWnd); ::ShowWindow(_hWnd, iShow); }
    void HideWindow() { DUIAssertNoMsg(_hWnd); ::ShowWindow(_hWnd, SW_HIDE); }
    void DestroyWindow() { DUIAssertNoMsg(_hWnd); PostMessage(_hWnd, NHHM_ASYNCDESTROY, 0, 0); }

    static LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    NativeHWNDHost() { }
    HRESULT Initialize(LPCWSTR pszTitle, HWND hWndParent, HICON hIcon, int dX, int dY, int dWidth, int dHeight, int iExStyle, int iStyle, UINT nOptions);
    virtual ~NativeHWNDHost() { }

private:
    HWND _hWnd;
    Element* _pe;
    UINT _nOptions;
};

} // namespace DirectUI

#endif // DUI_CONTROL_NATIVE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duilayout.h ===
/*
 * Layout
 */

#ifndef DUI_CORE_LAYOUT_H_INCLUDED
#define DUI_CORE_LAYOUT_H_INCLUDED

#pragma once

namespace DirectUI
{

// Global layout positions
#define LP_None         -3
#define LP_Absolute     -2
#define LP_Auto         -1

////////////////////////////////////////////////////////
// Alignment enumerations

#define ALIGN_LEFT      0
#define ALIGN_TOP       0
#define ALIGN_RIGHT     1
#define ALIGN_BOTTOM    1
#define ALIGN_CENTER    2
#define ALIGN_JUSTIFY   3

// Forward declarations
class Element;
typedef DynamicArray<Element*> ElementList;
struct NavReference;

struct NavScoring
{
    BOOL TrackScore(Element* peTest, Element* peChild);
    void Init(Element* peRelative, int iNavDir, NavReference const* pnr);
    BOOL Try(Element* peChild, int iNavDir, NavReference const* pnr, bool fKeyableOnly);

    int iHighScore;
    Element* peWinner;

private:
    int iBaseIndex;
    int iLow;
    int iHigh;
    int iMajorityScore;
};

/**
 * NOTE: Layouts are currently single context only (non-shareable). All contexts passed in to
 * callbacks (Element* pec) will be the same.
 */

////////////////////////////////////////////////////////
// Base layout

class Layout
{
public:
    static HRESULT Create(Layout** ppLayout);
    void Destroy() { HDelete<Layout>(this); }

    // Layout callbacks
    virtual void DoLayout(Element* pec, int dWidth, int dHeight);
    virtual SIZE UpdateDesiredSize(Element* pec, int dConstW, int dConstH, Surface* psrf);
    virtual void OnAdd(Element* pec, Element** ppeAdd, UINT cCount);
    virtual void OnRemove(Element* pec, Element** ppeRemove, UINT cCount);
    virtual void OnLayoutPosChanged(Element* pec, Element* peChanged, int dOldLP, int dNewLP);
    virtual void Attach(Element* pec);
    virtual void Detach(Element* pec);

    // Layout client query methods (omits absolute children)
    UINT GetLayoutChildCount(Element* pec);
    int GetLayoutIndexFromChild(Element* pec, Element* peChild);
    Element* GetChildFromLayoutIndex(Element* pec, int iLayoutIdx, ElementList* peList = NULL);
    virtual Element* GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyableOnly);

    Layout() { }
    void Initialize();
    virtual ~Layout();
    
protected:
    static void UpdateLayoutRect(Element* pec, int cxContainer, int cyContainer, Element* peChild, int xElement, int yElement, int cxElement, int cyElement);

    // Dirty bit
    // This exists in base Layout merely as a convenience for derived Layout Managers.
    // Some LMs cache data during an UpdateDesiredSize call. This cached data is used
    // during DoLayout and is usually dependent on number of children and/or layout
    // position of children. This means that if UpdateDesiredSize doesn't get called
    // on these LMs, the cache will be invalid for the DoLayout. Since UpdateDesiredSize is
    // always called by LMs, you cannot assume that you will always get an UpdateDesiredSize
    // before a DoLayout. LMs may terminate UpdateDesiredSize passes because they
    // ran out of room, or couldn't make an allocation. This bit is used to mark
    // if a cache is valid. It is automatically invalidated in the base in the following
    // methods: OnAdd, OnRemove, OnLayoutPosChanged, Attach, and Detach.
    bool IsCacheDirty() { return _fCacheDirty; }
    void SetCacheDirty() { _fCacheDirty = true; }
    void ClearCacheDirty() { _fCacheDirty = false; }

    // TODO: Make shareable (supports only 1 context currently)
    Element* _peClient;

    // TODO: Multiple contexts
    DynamicArray<Element*>* _pdaIgnore;

private:
    bool _fCacheDirty;
    
};

} // namespace DirectUI

#endif // DUI_CORE_LAYOUT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duininegrid.h ===
/*
 * NineGrid bitmap rendering (ported from UxTheme)
 */

#ifndef DUI_UTIL_NINEGRID_H_INCLUDED
#define DUI_UTIL_NINEGRID_H_INCLUDED

#pragma once

namespace DirectUI
{

//---------------------------------------------------------------------------
//#include "uxtheme.h"        // need MARGINS struct from here
typedef struct _MARGINS
{
    int cxLeftWidth;      // width of left border that retains its size
    int cxRightWidth;     // width of right border that retains its size
    int cyTopHeight;      // height of top border that retains its size
    int cyBottomHeight;   // height of bottom border that retains its size
} MARGINS, *PMARGINS;

//#include "tmschema.h"       // need SIZINGTYPE, VALIGN, HALIGN enums from here
enum SIZINGTYPE
{
    ST_TRUESIZE,
    ST_STRETCH,
    ST_TILE,

    ST_TILEHORZ,
    ST_TILEVERT,
    ST_TILECENTER
};

enum HALIGN
{
    HA_LEFT,
    HA_CENTER,
    HA_RIGHT
};

enum VALIGN
{
    VA_TOP,
    VA_CENTER,
    VA_BOTTOM
};

//---------------------------------------------------------------------------
#ifndef HEIGHT
#define HEIGHT(rc) ((rc).bottom - (rc).top)
#endif
//---------------------------------------------------------------------------
#ifndef WIDTH
#define WIDTH(rc) ((rc).right - (rc).left)
#endif
//---------------------------------------------------------------------------
enum MBSIZING
{
    MB_COPY,
    MB_STRETCH,
    MB_TILE
};
//------------------------------------------------------------------------------------
struct BRUSHBUFF
{
    int iBuffLen;
    BYTE *pBuff;
};
//---------------------------------------------------------------------------
struct MBINFO
{
    DWORD dwSize;       // size of this struct (versioning support)

    HDC hdcDest;
    HDC hdcSrc;
    RECT rcClip;                    // don't draw outside this rect
    HBITMAP hBitmap;

    //---- for quick tiling ----
    BRUSHBUFF *pBrushBuff;

    //---- options ----
    DWORD dwOptions;                // subset DrawNineGrid() option flags

    POINT ptTileOrigin;             // for MBO_TILEORIGIN
    
    BITMAPINFOHEADER *pbmHdr;       // for MBO_DIRECTBITS
    BYTE *pBits;                    // for MBO_DIRECTBITS
    
    COLORREF crTransparent;         // for MBO_TRANSPARENT
    _BLENDFUNCTION AlphaBlendInfo;  // for MBO_ALPHABLEND

    HBRUSH *pCachedBrushes;         // for DNG_CACHEBRUSHES
    int iCacheIndex;                // which brush to use
};
//---------------------------------------------------------------------------
//---- DrawNineGrid() "dwOptions" bits ----

//---- shared with MultiBlt()  ----
#define DNG_ALPHABLEND     (1 << 0)     // use AlphaBlendInfo
#define DNG_TRANSPARENT    (1 << 1)     // transparancy defined by crTransparent
#define DNG_TILEORIGIN     (1 << 2)     // use ptTileOrigin
#define DNG_DIRECTBITS     (1 << 3)     // use pbmHdr & pBits
#define DNG_CACHEBRUSHES   (1 << 4)     // use/set pCachedBrushes
#define DNG_MANUALTILING   (1 << 5)     // loop thru BitBlt's
#define DNG_DIRECTBRUSH    (1 << 6)     // create brushes from temp. extracted DIB's
#define DNG_FLIPGRIDS      (1 << 7)    // all grid images should be flipped

//---- used only by DrawNineGrid()  ----
#define DNG_OMITBORDER     (1 << 16)    // don't draw border
#define DNG_OMITCONTENT    (1 << 17)    // don't draw middle 
#define DNG_SOLIDBORDER    (1 << 18)    // sample borders and draw as solid colors
#define DNG_SOLIDCONTENT   (1 << 19)    // sample content as draw as solid color
#define DNG_BGFILL         (1 << 20)    // use crFill for ST_TRUESIZE
//------------------------------------------------------------------------------------
struct NGINFO
{
    DWORD dwSize;       // size of this struct (versioning support)

    HDC hdcDest;
    RECT rcClip;                    // don't draw outside this rect
    SIZINGTYPE eImageSizing;
    HBITMAP hBitmap;
    RECT rcSrc;             // where to get bits from
    RECT rcDest;            // where to draw bits to
    int iDestMargins[4];   
    int iSrcMargins[4];  

    //---- for quick tiling ----
    BRUSHBUFF *pBrushBuff;

    //---- options ----
    DWORD dwOptions;

    POINT ptTileOrigin;             // for DNG_TILEORIGIN
    
    BITMAPINFOHEADER *pbmHdr;       // for DNG_DIRECTBITS
    BYTE *pBits;                    // for DNG_DIRECTBITS
    
    COLORREF crTransparent;         // for DNG_TRANSPARENT
    _BLENDFUNCTION AlphaBlendInfo;  // for DNG_ALPHABLEND

    HBRUSH *pCachedBrushes;         // for DNG_CACHEBRUSHES

    COLORREF *pcrBorders;           // for DNG_SOLIDBORDERS, DNG_SOLIDCONTENT

    //---- for ST_TRUESIZE images smaller than rcDest ----
    COLORREF crFill;      
    VALIGN eVAlign;
    HALIGN eHAlign;
};
//---------------------------------------------------------------------------
HRESULT MultiBlt(MBINFO *pmb, MBSIZING eSizing, int iDestX, int iDestY, int iDestW, int iDestH,
     int iSrcX, int iSrcY, int iSrcW, int iSrcH);

HRESULT DrawNineGrid(NGINFO *png);
//---------------------------------------------------------------------------

} // namespace DirectUI

#endif // DUI_UTIL_NINEGRID_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duihwndhost.h ===
// HWNDHost.h
//

#ifndef DUI_CONTROL_HWNDHOST_H_INCLUDED
#define DUI_CONTROL_HWNDHOST_H_INCLUDED

namespace DirectUI
{

////////////////////////////////////////////////////////
// HWNDHost

// Element to HWND bridge

#define HHC_CacheFont           0x00000001

// HWNDHost subclasses the HWND child and intercepts all input. This input is forward to DUser
// as a normal message (as if the message never originated via the HWND child). After the input
// message routes, it will be sent to the peer gadget and then on to Element (via OnInput).
// A HWND message will be constructed and sent to the HWND child.
//
// The following flags disables the forwarding of the original HWND message into the DUser world.
// Thus, while the underlying gadget may get mouse/key focus, the HWND will appear as a
// "dead area" within the Element.
//
// These options are used if the HWND is used in an environment where it is not guaranteed that
// all messages sent to it will be dispatched. If they aren't, DUser's state cannot by synchronized.

#define HHC_NoMouseForward      0x00000002
#define HHC_NoKeyboardForward   0x00000004
#define HHC_SyncText            0x00000008
#define HHC_SyncPaint           0x00000010

// Class definition
class HWNDHost : public Element
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(HHC_CacheFont, AE_MouseAndKeyboard, ppElement); }
    static HRESULT Create(UINT nCreate, UINT nActive, OUT Element** ppElement);

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);
    virtual void OnInput(InputEvent* pInput);
    virtual void OnDestroy();

    // HWNDHost system events, control notification
    virtual bool OnNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet);

    // Sizing callback
    virtual BOOL OnAdjustWindowSize(int x, int y, UINT uFlags);
    
    // Message callback
    virtual UINT MessageCallback(GMSG* pGMsg);

    // Rendering
    virtual void Paint(HDC hDC, const RECT* prcBounds, const RECT* prcInvalid, RECT* prcSkipBorder, RECT* prcSkipContent);
#ifdef GADGET_ENABLE_GDIPLUS
    virtual void Paint(Gdiplus::Graphics* pgpgr, const Gdiplus::RectF* prcBounds, const Gdiplus::RectF* prcInvalid, Gdiplus::RectF* prSkipBorder, Gdiplus::RectF* prSkipContent);
#endif

    HWND GetHWND() { return _hwndCtrl; }
    
    HWND GetHWNDParent() { return _hwndSink; }

    void Detach();

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    ///////////////////////////////////////////////////////
    // Accessibility support
    virtual HRESULT GetAccessibleImpl(IAccessible ** ppAccessible);

    HWNDHost() { }
    HRESULT Initialize(UINT nCreate, UINT nActive);
    virtual ~HWNDHost() { }

protected:

    virtual void OnHosted(Element* peNewHost);
    virtual void OnUnHosted(Element* peOldHost);
    virtual HWND CreateHWND(HWND hwndParent);

    // Synchronize control and sink to changes
    void SyncRect(UINT nChangeFlags, bool bForceSync = false);
    void SyncParent();
    void SyncStyle();
    void SyncVisible();
    void SyncFont();
    void SyncText();

private:
    // Control and sink subclass procs
    static BOOL CALLBACK _SinkWndProc(void* pThis, HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet);
    static BOOL CALLBACK _CtrlWndProc(void* pThis, HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet);

    static const UINT g_rgMouseMap[7][3];   // Gadget input message to HWND input message mapping

    bool _fHwndCreate;                      // On first call, create HWNDs (sink and control)

    HWND _hwndCtrl;                         // Hosted control
    HWND _hwndSink;                         // HWND used to receive control notifications
    WNDPROC _pfnCtrlOrgProc;                // The Controls original WNDPROC

    RECT _rcBounds;                         // Bounds of sink and control (in client coordinates)
    HFONT _hFont;                           // Cached font (optional)

    UINT _nCreate;                          // Creation flags
};

} // namespace DirectUI

#endif // DUI_CONTROL_HWNDHOST_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duininegridlayout.h ===
/*
 * NineGridLayout
 */

#ifndef DUI_NINEGRIDLAYOUT_H_INCLUDED
#define DUI_NINEGRIDLAYOUT_H_INCLUDED

#pragma once

namespace DirectUI
{

// BorderLayout positions
#define NGLP_TopLeft     0
#define NGLP_Top         1
#define NGLP_TopRight    2
#define NGLP_Left        3
#define NGLP_Client      4
#define NGLP_Right       5
#define NGLP_BottomLeft  6
#define NGLP_Bottom      7
#define NGLP_BottomRight 8

////////////////////////////////////////////////////////
// NineGridLayout

class NineGridLayout : public Layout
{
public:
    static HRESULT Create(int dNumParams, int* pParams, OUT Value** ppValue);  // For parser
    static HRESULT Create(OUT Layout** ppLayout);

    // Layout callbacks
    virtual void DoLayout(Element* pec, int dWidth, int dHeight);
    virtual SIZE UpdateDesiredSize(Element* pec, int dConstW, int dConstH, Surface* psrf);
    virtual void OnAdd(Element* pec, Element** ppeAdd, UINT cCount);
    virtual void OnRemove(Element* pec, Element** ppeRemove, UINT cCount);
    virtual void OnLayoutPosChanged(Element* pec, Element* peChanged, int dOldLP, int dNewLP);
    virtual Element* GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyableOnly);

    NineGridLayout() { };
    void Initialize();   
    virtual ~NineGridLayout() { };

private:
    enum
    {
    };

    enum ESlot
    {
        Margin1  = 0,
        Left     = 1,
        Top      = 1,
        Margin2  = 2,
        Center   = 3,
        Margin3  = 4,
        Right    = 5,
        Bottom   = 5,
        Margin4  = 6,
        NumSlots = 7
    };

    enum EDim
    {
        X       = 0,
        Y       = 1,
        NumDims = 2
    };

    enum EConst
    {
        NumCells    = 9,
        CellsPerRow = 3
    };


    Element* _peTiles[NumCells];
    SIZE _sizeDesired;
    int _length[NumDims][NumSlots];

    void _UpdateTileList(int iTile, Element* pe);
};

} // namespace DirectUI

#endif // DUI_NINEGRIDLAYOUT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duiparserobj.h ===
/*
 * Parser
 */

#ifndef DUI_PARSER_PARSEROBJ_H_INCLUDED
#define DUI_PARSER_PARSEROBJ_H_INCLUDED

#pragma once

namespace DirectUI
{

#define MAXIDENT            31

////////////////////////////////////////////////////////
// Parser table definitions

struct EnumTable
{
    LPWSTR pszEnum;
    int nEnum;
};

typedef HRESULT (*PLAYTCREATE)(int, int*, Value**);
struct LayoutTable
{
    LPWSTR pszLaytType;
    PLAYTCREATE pfnLaytCreate;
};

typedef struct
{
    LPWSTR pszElType;
    IClassInfo* pci;
} ElementTable;

struct SysColorTable
{
    LPWSTR pszSysColor;
    int nSysColor;
};

////////////////////////////////////////////////////////
// Parser tree data structures
// Parse tree nodes are any data structure dynamically allocated to store tree information

// Parse tree node types
#define NT_ValueNode            0
#define NT_PropValPairNode      1
#define NT_ElementNode          2
#define NT_AttribNode           3
#define NT_RuleNode             4
#define NT_SheetNode            5
                            
// Tree node base class
struct Node
{
    BYTE nType;
};

// Value node
#define VNT_Normal              0
#define VNT_LayoutCreate        1
#define VNT_SheetRef            2
#define VNT_EnumFixup           3  // Map name to int Value once PropertyInfo is known

struct LayoutCreate
{
    union
    {
        PLAYTCREATE pfnLaytCreate;
        LPWSTR pszLayout;  // Fixup happens immediately during Value creation
    };
    int dNumParams;
    int* pParams;
};

struct EnumsList
{
    int dNumParams;
    LPWSTR* pEnums;  // Enums to be OR'd
};

struct ValueNode : Node
{
    BYTE nValueType;
    union
    {
        Value* pv;        // VNT_Normal
        LayoutCreate lc;  // VNT_LayoutCreate, created during Element creates
        LPWSTR psres;     // VNT_SheetRef
        EnumsList el;     // VNT_EnumFixup
    };
};

// Property/Value Pair
#define PVPNT_Normal            0
#define PVPNT_Fixup             1  // Map name to ppi once Element type is known

struct PropValPairNode : Node
{
    BYTE nPropValPairType;
    union
    {
        PropertyInfo* ppi;  // PVPNT_Normal
        LPWSTR pszProperty; // PVPNT_Fixup
    };
    ValueNode* pvn;

    PropValPairNode* pNext;
};

// Element node
struct ElementNode : Node
{
    IClassInfo* pci;
    PropValPairNode* pPVNodes;
    LPWSTR pszResID;
    Value* pvContent;

    ElementNode* pChild;
    ElementNode* pNext;
};

// Sheet attribute node
#define PALOGOP_Equal           0
#define PALOGOP_NotEqual        1

struct AttribNode : PropValPairNode
{
    UINT nLogOp;
};

// Sheet rule node
struct RuleNode : Node
{
    IClassInfo* pci;
    AttribNode* pCondNodes;
    PropValPairNode* pDeclNodes;

    RuleNode* pNext;
};

// Sheet node
struct SheetNode : Node
{
    Value* pvSheet;  // Create once all Rules are known
    RuleNode* pRules;
    LPWSTR pszResID;
};

// Intermediate parser data structures
struct ParamsList
{
    int dNumParams;
    int* pParams;
};

struct StartTag
{
    WCHAR szTag[MAXIDENT];
    WCHAR szResID[MAXIDENT];
    PropValPairNode* pPVNodes;
};

// Parser

typedef void (CALLBACK *PPARSEERRORCB)(LPCWSTR pszError, LPCWSTR pszToken, int dLine);

class Parser
{
public:
    static HRESULT Create(const CHAR* pBuffer, int cCharCount, HANDLE* pHList, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser);
    static HRESULT Create(UINT uRCID, HANDLE* pHList, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser);
    static HRESULT Create(LPCWSTR pFile, HANDLE* pHList, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser);

    static HRESULT Create(const CHAR* pBuffer, int cCharCount, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser);
    static HRESULT Create(UINT uRCID, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser);
    static HRESULT Create(LPCWSTR pFile, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser);

    void Destroy() { HDelete<Parser>(this); }

    HRESULT CreateElement(LPCWSTR pszResID, Element* peSubstitute, OUT Element** ppElement);
    virtual Value* GetSheet(LPCWSTR pszResID);
    LPCWSTR ResIDFromSheet(Value* pvSheet);

    void GetPath(LPCWSTR pIn, LPWSTR pOut, size_t cbOut);

    // Parser/scanner only use
    int _Input(CHAR* pBuffer, int cMaxChars);
    void* _TrackNodeAlloc(SIZE_T s);                // Parse-tree node memory
    void _UnTrackNodeAlloc(Node* pn);               // Parse-tree node memory
    void* _TrackAlloc(SIZE_T s);                    // Node-specific state
    void* _TrackTempAlloc(SIZE_T s);                // Parse-time temporary memory
    void _TrackTempAlloc(void* pm);                 // Parse-time temporary memory
    void* _TrackTempReAlloc(void* pm, SIZE_T s);    // Parse-time temporary memory
    void _UnTrackTempAlloc(void* pm);               // Parse-time temporary memory
    void _ParseError(LPCWSTR pszError, LPCWSTR pszToken, int dLine);

    ValueNode* _CreateValueNode(BYTE nValueType, void* pData);
    PropValPairNode* _CreatePropValPairNode(LPCWSTR pszProperty, ValueNode* pvn, UINT* pnLogOp = NULL);
    RuleNode* _CreateRuleNode(LPCWSTR pszClass, AttribNode* pCondNodes, PropValPairNode* pDeclNodes);
    ElementNode* _CreateElementNode(StartTag* pst, Value* pvContent);
    SheetNode* _CreateSheetNode(LPCWSTR pszResID, RuleNode* pRuleNodes);
    static int _QuerySysMetric(int idx);
    static LPCWSTR _QuerySysMetricStr(int idx, LPWSTR psz, UINT c);

    bool WasParseError() { return _fParseError; }
    HANDLE GetHandle(int iHandle) { return _pHList[iHandle]; }
    HINSTANCE GetHInstance() { return static_cast<HINSTANCE>(GetHandle(0)); }  // Always assume 0th item is the default HINSTANCE used

    static HRESULT ReplaceSheets(Element* pe, Parser* pFrom, Parser* pTo);

    DynamicArray<ElementNode*>* _pdaElementList;     // Root Element list
    DynamicArray<SheetNode*>* _pdaSheetList;         // Sheet list

    // Global parser context
    static Parser* g_pParserCtx;
    static bool g_fParseAbort;
    static HDC g_hDC;
    static int g_nDPI;
    static HRESULT g_hrParse;                        // Abnormal errors during parse

    Parser() { }
    HRESULT Initialize(const CHAR* pBuffer, int cCharCount, HANDLE* pHList, PPARSEERRORCB pfnErrorCB);
    HRESULT Initialize(UINT uRCID, HANDLE* pHList, PPARSEERRORCB pfnErrorCB);
    HRESULT Initialize(LPCWSTR pFile, HANDLE* pHList, PPARSEERRORCB pfnErrorCB);

    // Single HINSTANCE, setup internal default list
    // 0th entry is always default HINSTANCE when no handle is specified
    HRESULT Initialize(const CHAR* pBuffer, int cCharCount, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB) { _hDefault = hInst; return Initialize(pBuffer, cCharCount, &_hDefault, pfnErrorCB); }
    HRESULT Initialize(UINT uRCID, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB) { _hDefault = hInst; return Initialize(uRCID, &_hDefault, pfnErrorCB); }
    HRESULT Initialize(LPCWSTR pFile, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB) { _hDefault = hInst; return Initialize(pFile, &_hDefault, pfnErrorCB); }

    virtual ~Parser();

    virtual bool ConvertEnum(LPCWSTR pszEnum, int* pEnum, PropertyInfo* ppi);
    virtual PLAYTCREATE ConvertLayout(LPCWSTR pszLayout);
    virtual IClassInfo* ConvertElement(LPCWSTR pszElement);

private:
    HRESULT _ParseBuffer(const CHAR* pBuffer, int cCharCount);
    void _DestroyTables();

    // Error handling
    bool _fParseError;
    PPARSEERRORCB _pfnErrorCB;

    // Input callback buffer and tracking
    const CHAR* _pInputBuf;
    int _dInputChars;
    int _dInputPtr;

    // Parse tree allocations and temporary parse-time only allocations
    DynamicArray<Node*>* _pdaNodeMemTrack;  // Parser nodes
    DynamicArray<void*>* _pdaMemTrack;      // Parser node extra memory
    DynamicArray<void*>* _pdaTempMemTrack;  // Temp parse-time only memory

    bool _FixupPropValPairNode(PropValPairNode* ppvpn, IClassInfo* pci, bool bRestrictVal);

    WCHAR _szDrive[MAX_PATH];   // Drive letter to the file being parsed
    WCHAR _szPath[MAX_PATH];    // Path to the file being parsed

    HANDLE* _pHList;            // Pointer to handle list used for exposing runtime handles during parse
    HANDLE _hDefault;           // Default handle list (1 item - default HINSTANCE) if no list is provided

    HRESULT _InstantiateElementNode(ElementNode* pn, Element* peSubstitute, Element* peParent, OUT Element** ppElement);
};

} // namespace DirectUI

#endif // DUI_PARSER_PARSEROBJ_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duiproxy.h ===
/*
 * Proxy
 */

#ifndef DUI_CORE_PROXY_H_INCLUDED
#define DUI_CORE_PROXY_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// Proxy message

#define GM_PROXYINVOKE     GM_USER

BEGIN_STRUCT(GMSG_PROXYINVOKE, EventMsg)
    UINT nType;
    void* pData;
END_STRUCT(GMSG_PROXYINVOKE)


////////////////////////////////////////////////////////
// Proxy

class Proxy
{
public:
    Proxy();
    ~Proxy();

    static HRESULT CALLBACK SyncCallback(HGADGET hgadCur, void * pvCur, EventMsg * pGMsg);

protected:

    // Caller invoke
    void Invoke(UINT nType, void* pData);

    // Callee thread-safe invoke sink
    virtual void OnInvoke(UINT nType, void* pData);

    HGADGET _hgSync;
};

} // namespace DirectUI

#endif // DUI_CORE_PROXY_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duisballoc.h ===
/*
 * Fixed-Size Small Block Allocator
 */

#ifndef DUI_BASE_SBALLOC_H_INCLUDED
#define DUI_BASE_SBALLOC_H_INCLUDED

#pragma once

#include "duialloc.h"

namespace DirectUI
{

#define SBALLOC_FILLCHAR    0xFE

struct ISBLeak  // Leak detector, not ref counted
{
    virtual void AllocLeak(void* pBlock) = 0;
};

struct SBSection
{
    SBSection* pNext;
    BYTE* pData;
};

class SBAlloc
{
public:
    static HRESULT Create(UINT uBlockSize, UINT uBlocksPerSection, ISBLeak* pisbLeak, SBAlloc** ppSBA);
    void Destroy();

    void* Alloc();
    void Free(void* pBlock);

    SBAlloc() { }
    virtual ~SBAlloc();

private:
    bool _FillStack();

    UINT _uBlockSize;
    UINT _uBlocksPerSection;
    SBSection* _pSections;
    BYTE** _ppStack;  // Free block cache
    int _dStackPtr;
    ISBLeak* _pisbLeak;
};

} // namespace DirectUI

#endif // DUI_BASE_SBALLOC_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duiprogress.h ===
/*
 * Progress
 */

#ifndef DUI_CONTROL_PROGRESS_H_INCLUDED
#define DUI_CONTROL_PROGRESS_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// Progress

// Class definition
class Progress : public Element
{
public:
    static HRESULT Create(OUT Element** ppElement);

    // Rendering overrides
    virtual void Paint(HDC hDC, const RECT* prcBounds, const RECT* prcInvalid, RECT* prcSkipBorder, RECT* prcSkipContent);
    virtual SIZE GetContentSize(int dConstW, int dConstH, Surface* psrf);

    // Property definitions
    static PropertyInfo* PositionProp;
    static PropertyInfo* MinimumProp;
    static PropertyInfo* MaximumProp;

    // Quick property accessors
    int GetPosition()           DUIQuickGetter(int, GetInt(), Position, Specified)
    int GetMaximum()            DUIQuickGetter(int, GetInt(), Maximum, Specified)
    int GetMinimum()            DUIQuickGetter(int, GetInt(), Minimum, Specified)

    HRESULT SetPosition(int v)  DUIQuickSetter(CreateInt(v), Position)
    HRESULT SetMaximum(int v)   DUIQuickSetter(CreateInt(v), Maximum)
    HRESULT SetMinimum(int v)   DUIQuickSetter(CreateInt(v), Minimum)

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    Progress() { }
    HRESULT Initialize() { return Element::Initialize(0); }
    virtual ~Progress() { }
};

} // namespace DirectUI

#endif // DUI_CONTROL_PROGRESS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duiscrollbar.h ===
/*
 * ScrollBar
 */

#ifndef DUI_CONTROL_SCROLLBAR_H_INCLUDED
#define DUI_CONTROL_SCROLLBAR_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// ScrollBar

// Scroll bar layout order
#define SBO_Normal          0x00043210
#define SBO_ArrowsAtTop     0x00032140
#define SBO_ArrowsAtBottom  0x00040321

// Scroll event
struct ScrollEvent : Event
{
    int dPos;
};

// Class definition
class ScrollBar : public Element
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(true, ppElement); }
    static HRESULT Create(bool fBuildSubTree, OUT Element** ppElement);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // System events
    virtual bool OnPropertyChanging(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // Self-layout methods
    void _SelfLayoutDoLayout(int dWidth, int dHeight);
    SIZE _SelfLayoutUpdateDesiredSize(int dConstW, int dConstH, Surface* psrf);

    // Event types
    static UID Scroll;

    // Property definitions
    static PropertyInfo* PositionProp;
    static PropertyInfo* MinimumProp;
    static PropertyInfo* MaximumProp;
    static PropertyInfo* PageProp;
    static PropertyInfo* LineProp;
    static PropertyInfo* VerticalProp;
    static PropertyInfo* ProportionalProp;
    static PropertyInfo* OrderProp;

    // Quick property accessors
    int GetPosition()                   DUIQuickGetter(int, GetInt(), Position, Specified)
    int GetMaximum()                    DUIQuickGetter(int, GetInt(), Maximum, Specified)
    int GetMinimum()                    DUIQuickGetter(int, GetInt(), Minimum, Specified)
    int GetPage()                       DUIQuickGetter(int, GetInt(), Page, Specified)
    int GetLine()                       DUIQuickGetter(int, GetInt(), Line, Specified)
    int GetOrder()                      DUIQuickGetter(int, GetInt(), Order, Specified) 
    bool GetProportional()              DUIQuickGetter(bool, GetBool(), Proportional, Specified)
    bool GetVertical()                  DUIQuickGetter(bool, GetBool(), Vertical, Specified)

    HRESULT SetPosition(int v)          DUIQuickSetter(CreateInt(v), Position) 
    HRESULT SetMaximum(int v)           DUIQuickSetter(CreateInt(v), Maximum) 
    HRESULT SetMinimum(int v)           DUIQuickSetter(CreateInt(v), Minimum) 
    HRESULT SetPage(int v)              DUIQuickSetter(CreateInt(v), Page) 
    HRESULT SetLine(int v)              DUIQuickSetter(CreateInt(v), Line) 
    HRESULT SetOrder(int v)             DUIQuickSetter(CreateInt(v), Order) 
    HRESULT SetProportional(bool v)     DUIQuickSetter(CreateBool(v), Proportional)
    HRESULT SetVertical(bool v)         DUIQuickSetter(CreateBool(v), Vertical) 

    int LineUp(UINT nCount = 1)     { SetPosition(GetPosition() - (nCount * GetLine()));    return GetPosition(); }
    int LineDown(UINT nCount = 1)   { SetPosition(GetPosition() + (nCount * GetLine()));    return GetPosition(); }
    int PageUp(UINT nCount = 1)     { SetPosition(GetPosition() - (nCount * GetPageInc())); return GetPosition(); }
    int PageDown(UINT nCount = 1)   { SetPosition(GetPosition() + (nCount * GetPageInc())); return GetPosition(); }
    int Home()                      { SetPosition(GetMinimum());                            return GetPosition(); }
    int End()                       { SetPosition(GetMaximum());                            return GetPosition(); }

    bool IsScrollable();
    bool IsPinned() { return _fPinned; }

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    ScrollBar() { }
    HRESULT Initialize(bool fBuildSubTree);
    virtual ~ScrollBar() { }

protected:

#define SP_LineUp   0
#define SP_PageUp   1
#define SP_Thumb    2
#define SP_PageDown 3
#define SP_LineDown 4
#define SP_Count    5

    Element* _peParts[SP_Count];

#define _peLineUp   _peParts[SP_LineUp]
#define _peLineDown _peParts[SP_LineDown]
#define _pePageUp   _peParts[SP_PageUp]
#define _pePageDown _peParts[SP_PageDown]
#define _peThumb    _peParts[SP_Thumb]

private:

    int GetPageInc();

    int _posTop;
    int _cTrack;

    bool _fPinned;
};

} // namespace DirectUI

#endif // DUI_CONTROL_SCROLLBAR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duiscrollviewer.h ===
/*
 * ScrollViewer
 */

#ifndef DUI_CONTROL_SCROLLVIEWER_H_INCLUDED
#define DUI_CONTROL_SCROLLVIEWER_H_INCLUDED

#pragma once

#include "duiscrollbar.h"
#include "duiviewer.h"

namespace DirectUI
{

#define BV_AsNeeded 0
#define BV_Never    1
#define BV_Always   2

// Auto-pinning support
#define P_None      0
#define P_Horz      1
#define P_Vert      2

////////////////////////////////////////////////////////
// ScrollViewer

// Class definition
class ScrollViewer : public Element, public IElementListener
{
public:
    static HRESULT Create(OUT Element** ppElement);

    // Generic events
    virtual void OnEvent(Event* pEvent);
    virtual void OnInput(InputEvent* pie);

    // System events
    virtual bool OnPropertyChanging(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // Hierarchy
    virtual HRESULT Add(Element** ppe, UINT cCount);

    // Listener impl
    virtual void OnListenerAttach(Element* peFrom) { peFrom; }
    virtual void OnListenerDetach(Element* peFrom) { peFrom; }
    virtual bool OnListenedPropertyChanging(Element* peFrom, PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew) { peFrom; ppi; iIndex; pvOld; pvNew; return true; }
    virtual void OnListenedPropertyChanged(Element* peFrom, PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);
    virtual void OnListenedInput(Element* peFrom, InputEvent* pInput) { peFrom; pInput; }
    virtual void OnListenedEvent(Element* peFrom, Event* pEvent) { peFrom; pEvent; }

    // Property definitions
    static PropertyInfo* XOffsetProp;
    static PropertyInfo* YOffsetProp;
    static PropertyInfo* XScrollableProp;
    static PropertyInfo* YScrollableProp;
    static PropertyInfo* XBarVisibilityProp;
    static PropertyInfo* YBarVisibilityProp;
    static PropertyInfo* PinningProp;

    // Quick property accessors
    ScrollBar* GetXScrollBar()          { return _peHScroll; }
    ScrollBar* GetYScrollBar()          { return _peVScroll; }
    
    int GetXOffset()                    DUIQuickGetter(int, GetInt(), XOffset, Specified)
    int GetYOffset()                    DUIQuickGetter(int, GetInt(), YOffset, Specified)
    bool GetXScrollable()               DUIQuickGetter(bool, GetBool(), XScrollable, Specified)
    bool GetYScrollable()               DUIQuickGetter(bool, GetBool(), YScrollable, Specified)
    int GetXBarVisibility()             DUIQuickGetter(int, GetInt(), XBarVisibility, Specified)
    int GetYBarVisibility()             DUIQuickGetter(int, GetInt(), YBarVisibility, Specified)
    int GetPinning()                    DUIQuickGetter(int, GetInt(), Pinning, Specified)

    HRESULT SetXOffset(int v)           DUIQuickSetter(CreateInt(v), XOffset)
    HRESULT SetYOffset(int v)           DUIQuickSetter(CreateInt(v), YOffset)
    HRESULT SetXScrollable(bool v)      DUIQuickSetter(CreateBool(v), XScrollable)
    HRESULT SetYScrollable(bool v)      DUIQuickSetter(CreateBool(v), YScrollable)
    HRESULT SetXBarVisibility(int v)    DUIQuickSetter(CreateInt(v), XBarVisibility)
    HRESULT SetYBarVisibility(int v)    DUIQuickSetter(CreateInt(v), YBarVisibility)
    HRESULT SetPinning(int v)           DUIQuickSetter(CreateInt(v), Pinning)

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    ScrollViewer() { }
    HRESULT Initialize();
    virtual ~ScrollViewer() { }

protected:

    ScrollBar* _peHScroll;
    ScrollBar* _peVScroll;
    Viewer*    _peViewer;
    Element*   _peContent;

private:
    void CheckScroll(ScrollBar* psb, BOOL fScrollable, int iVisibility);

};

} // namespace DirectUI

#endif // DUI_CONTROL_SCROLLVIEWER_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duirepeatbutton.h ===
/*
 * RepeatButton
 */

#ifndef DUI_CONTROL_REPEATBUTTON_H_INCLUDED
#define DUI_CONTROL_REPEATBUTTON_H_INCLUDED

#pragma once

#include "duibutton.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// RepeatButton

// Class definition
class RepeatButton : public Button
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(AE_MouseAndKeyboard, ppElement); }
    static HRESULT Create(UINT nActive, OUT Element** ppElement);

    // System events
    virtual void OnInput(InputEvent* pie);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
    
    RepeatButton() { }
    HRESULT Initialize(UINT nActive);
    virtual ~RepeatButton() { }

private:
    static void CALLBACK _RepeatButtonActionCallback(GMA_ACTIONINFO* pmai);
    
    HACTION _hAction;
    BOOL _fActionDelay;
};

} // namespace DirectUI

#endif // DUI_CONTROL_REPEATBUTTON_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duirefpointelement.h ===
/*
 * RefPointElement
 */

#ifndef DUI_CONTROL_REFPOINTELEMENT_H_INCLUDED
#define DUI_CONTROL_REFPOINTELEMENT_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// RefPointElement

// Class definition
class RefPointElement : public Element
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(AE_Inactive, ppElement); }
    static HRESULT Create(UINT nActive, OUT Element** ppElement);

    // System Events
    //virtual void OnGroupChanged(int fGroups, bool bLowPri);
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // Global helpers
    static Element* FindRefPoint(Element* pe, POINT* ppt);
    static RefPointElement* Locate(Element* pe);

    // Property definitions
    static PropertyInfo* ReferencePointProp;
    static PropertyInfo* ActualReferencePointProp;

    // Quick property accessors
    const POINT* GetReferencePoint(Value** ppv)         { *ppv = GetValue(ReferencePointProp, PI_Local); return (*ppv != Value::pvUnset) ? (*ppv)->GetPoint() : NULL; }
    const POINT* GetActualReferencePoint(Value** ppv)   DUIQuickGetterInd(GetPoint(), ActualReferencePoint, Specified)
    
    HRESULT SetReferencePoint(int x, int y)             DUIQuickSetter(CreatePoint(x, y), ReferencePoint)

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    RefPointElement() { }
    HRESULT Initialize(UINT nActive);
    virtual ~RefPointElement() { }
};

} // namespace DirectUI

#endif // DUI_CONTROL_REFPOINTELEMENT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duirowlayout.h ===
/*
 * RowLayout
 */

#ifndef DUI_LAYOUT_ROWLAYOUT_H_INCLUDED
#define DUI_LAYOUT_ROWLAYOUT_H_INCLUDED

#pragma once

namespace DirectUI
{

// No layout positions

////////////////////////////////////////////////////////
// RowLayout

class RowLayout : public Layout
{
public:
    static HRESULT Create(int dNumParams, int* pParams, OUT Value** ppValue);  // For parser
    static HRESULT Create(int idShare, UINT uXAlign, UINT uYAlign, OUT Layout** ppLayout);

    virtual void Attach(Element* pec);
    virtual void Detach(Element* pec);

    // Layout callbacks
    virtual void DoLayout(Element* pec, int cx, int cy);
    virtual SIZE UpdateDesiredSize(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf);
    virtual Element* GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyableOnly);

    RowLayout() { }
    static HRESULT InternalCreate(UINT uXAlign, UINT uYAlign, OUT Layout** ppLayout);
    void Initialize(UINT uXAlign, UINT uYAlign);
    virtual ~RowLayout();

protected:
    SIZE _sizeDesired;
    BOOL _fRecalc;
    DynamicArray<Element*>* _arpeClients;
    UINT* _arxCols;
    UINT _cCols;
    UINT _uXAlign;
    UINT _uYAlign;
};

} // namespace DirectUI

#endif // DUI_LAYOUT_ROWLAYOUT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duiselector.h ===
/*
 * Selector
 */

#ifndef DUI_CONTROL_SELECTOR_H_INCLUDED
#define DUI_CONTROL_SELECTOR_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// Selector

// SelectionChange event
struct SelectionChangeEvent : Event
{
    Element* peOld;
    Element* peNew;
};

// Class definition
class Selector : public Element
{
public:
    static HRESULT Create(OUT Element** ppElement);
 
    // Generic events
    virtual void OnEvent(Event* pEvent);

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);
    virtual void OnInput(InputEvent* pInput);                                                    // Routed and bubbled
    virtual void OnKeyFocusMoved(Element *peFrom, Element *peTo);

    // Hierarchy
    virtual Element* GetAdjacent(Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyable);

    // Event types
    static UID SelectionChange;

    // Property definitions
    static PropertyInfo* SelectionProp;

    // Quick property accessors
    Element* GetSelection()             DUIQuickGetter(Element*, GetElement(), Selection, Specified)

    HRESULT SetSelection(Element* v)    DUIQuickSetter(CreateElementRef(v), Selection)

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    Selector() { }
    HRESULT Initialize() { return Element::Initialize(0); }
    virtual ~Selector() { }
};

} // namespace DirectUI

#endif // DUI_CONTROL_SELECTOR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duithread.h ===
/*
 * Thread methods, local storage
 */

#ifndef DUI_CORE_THREAD_H_INCLUDED
#define DUI_CORE_THREAD_H_INCLUDED

#pragma once

namespace DirectUI
{

/////////////////////////////////////////////////////////////////////////////
// Synchronization lock

class Lock
{
public:
    Lock() { InitializeCriticalSection(&_cs); }
    ~Lock() { DeleteCriticalSection(&_cs); }
    void Enter() { EnterCriticalSection(&_cs); }
    void Leave() { LeaveCriticalSection(&_cs); }

private:
    CRITICAL_SECTION _cs;
};

extern Lock* g_plkParser;

/////////////////////////////////////////////////////////////////////////////
// Initialization

HRESULT InitProcess();
HRESULT UnInitProcess();

HRESULT InitThread();
HRESULT UnInitThread();

// Control library class registration
HRESULT RegisterAllControls();

/////////////////////////////////////////////////////////////////////////////
// Message pump

void StartMessagePump();
void StopMessagePump();

} // namespace DirectUI

#endif // DUI_CORE_THREAD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duisheet.h ===
/*
 * PropertySheet
 */

#ifndef DUI_CORE_SHEET_H_INCLUDED
#define DUI_CORE_SHEET_H_INCLUDED

#pragma once

namespace DirectUI
{

/*
 * PropertySheets are used as extensions to the unchangeable value expression used
 * for Specified value retrieval on Elements. They provide three main services:
 *
 * * The ability to describe conditional relationships (dependencies) on a per-class level
 * * Values can be overridden by setting a local value on the Element
 * * They can be described declaratively using a CSS-like grammar
 *
 * PropertySheets are a type of value expression (but limited). Thus, they provide
 * a way to change values of properties based on other property changes without hard coding
 * the logic within a derived class of Element (using OnPropertyChanged).
 *
 * Only properties with the "Cascade" flag may be placed in the body of a Rule. Properties
 * that should be marked as cascadable are those that need to be updated based on changes
 * of other properties, but shouldn't be assumed at compile-time what these relationships
 * are. Such properties include any property that drives painting code directly (color,
 * fonts, padding, etc.).
 */

// Foreward declarations
class Value;
struct PropertyInfo;
class Element;
struct IClassInfo;
struct DepRecs;
class DeferCycle;

////////////////////////////////////////////////////////
// Rule addition structures

// Declaration PropertyInfo/Value tuple
struct Decl
{
    PropertyInfo* ppi;    // Implicit index of Specified
    Value* pv;
};

// Single rule conditional (l-operand op r-operand): <PropertyInfo[RetrievalIndex]> <LogOp> <Value>
struct Cond
{
    PropertyInfo* ppi;    // Implicit index of Retrieval index
    UINT nLogOp;
    Value* pv;
};

// PropertySheet Logical operations (nLogOp)
#define PSLO_Equal      0
#define PSLO_NotEqual   1

////////////////////////////////////////////////////////
// Internal database structures

// Conditional to value map
struct CondMap
{
    Cond* pConds;         // NULL terminated
    Value* pv;
    UINT uSpecif;
};

// Dependent list, used for sheet scope and propertyinfo data (conditionals/dependencies)
struct DepList
{
    PropertyInfo** pDeps; // Implicit index of Specified
    UINT cDeps;
};

// Storage for property-specific information
struct PIData : DepList
{
    // Used for PropertyInfo[Specified] lookups. The PropertyInfo will have
    // a list of conditionals (sorted by specificity)
    CondMap* pCMaps;
    UINT cCMaps;
};

// Stored by _pDB, one record per class type
struct Record
{
    DepList ss;    // Sheet scope
    PIData* ppid;  // 0th property data
};

////////////////////////////////////////////////////////
// PropertySheet

class PropertySheet
{
public:
    static HRESULT Create(OUT PropertySheet** ppSheet);
    void Destroy() { HDelete<PropertySheet>(this); }

    HRESULT AddRule(IClassInfo* pci, Cond* pConds, Decl* pDecls);  // Conds and Decls must be NULL or NULL-terminating
    void MakeImmutable();

    Value* GetSheetValue(Element* pe, PropertyInfo* ppi);
    void GetSheetDependencies(Element* pe, PropertyInfo* ppi, DepRecs* pdr, DeferCycle* pdc, HRESULT* phr);
    void GetSheetScope(Element* pe, DepRecs* pdr, DeferCycle* pdc, HRESULT* phr);

    PropertySheet() { }
    HRESULT Initialize();    
    virtual ~PropertySheet();
    
private:
    Record* _pDB;  // Array of per-class data
    IClassInfo** _pCIIdxMap;  // Map _pDB indicies to actual IClassInfo
    UINT _uRuleId;
    DynamicArray<Cond*>* _pdaSharedCond;
    bool _fImmutable;
};

} // namespace DirectUI

#endif // DUI_CORE_SHEET_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duiuidgen.h ===
/*
 * Unique ID generator (application-wide uniqueness)
 */

#ifndef DUI_BASE_UIDGEN_H_INCLUDED
#define DUI_BASE_UIDGEN_H_INCLUDED

namespace DirectUI
{

#define UID BYTE*
#define DefineUniqueID(name) BYTE _uid##name; UID name = &_uid##name;
#define DefineClassUniqueID(classn, name) BYTE _uid##classn##name; UID classn::name = &_uid##classn##name;

} // namespace DirectUI

#endif // DUI_BASE_UIDGEN_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duisurface.h ===
/*
 * Surface
 */

#ifndef DUI_BASE_SURFACE_H_INCLUDED
#define DUI_BASE_SURFACE_H_INCLUDED

#pragma once

#pragma warning(disable: 4127)  // conditional expression is constant

namespace DirectUI
{

////////////////////////////////////////////////////////
// Surface

class Surface
{
public:
    enum EType
    {
        stDC      = GSURFACE_HDC,
#ifdef GADGET_ENABLE_GDIPLUS
        stGdiPlus = GSURFACE_GPGRAPHICS
#endif
    };

    virtual EType GetType() const PURE;
    inline static Surface::EType GetSurfaceType(UINT nSurfaceType);
    inline static UINT GetSurfaceType(Surface::EType type);
};

class DCSurface : public Surface
{
public:
    inline DCSurface(HDC hdc) { _hdc = hdc; }
    inline HDC GetHDC() { return _hdc; }

    virtual EType GetType() const { return Surface::stDC; }
    
protected:
    HDC _hdc;
};

#ifdef GADGET_ENABLE_GDIPLUS

class GpSurface : public Surface
{
public:
    inline GpSurface(Gdiplus::Graphics* pgpgr) { _pgpgr = pgpgr; }
    inline Gdiplus::Graphics* GetGraphics() { return _pgpgr; }

    virtual EType GetType() const { return Surface::stGdiPlus; }
    
protected:
    Gdiplus::Graphics* _pgpgr;
};

#endif // GADGET_ENABLE_GDIPLUS

inline Surface::EType Surface::GetSurfaceType(UINT nSurfaceType)
{
    DUIAssert(stDC == GSURFACE_HDC, "ID's must match");
    return (EType)nSurfaceType;
}

inline UINT Surface::GetSurfaceType(Surface::EType type)
{
    DUIAssert(stDC == GSURFACE_HDC, "ID's must match");
    return (UINT) type;
}

inline HDC CastHDC(Surface* psrf)
{
    DUIAssert(psrf->GetType() == Surface::stDC, "Must be an HDC surface");
    return ((DCSurface*)psrf)->GetHDC();
}

#ifdef GADGET_ENABLE_GDIPLUS

inline Gdiplus::Graphics* CastGraphics(Surface* psrf)
{
    DUIAssert(psrf->GetType() == Surface::stGdiPlus, "Must be a GDI+ surface");
    return ((GpSurface*)psrf)->GetGraphics();
}

#endif // GADGET_ENABLE_GDIPLUS


//
// Some handy alpha-value operations that are used throughout DirectUI
//

#define ARGB(a, r, g, b)    ((a << 24) | RGB(r, g, b))          // Current A values may be 255 (opaque) or 0 (transparent)
#define ORGB(r, g, b)       ARGB(255, r, g, b)                  // Opaque color
#define GetAValue(v)        ((BYTE)((v & 0xFF000000) >> 24))

}; // namespace DirectUI

#endif // DUI_BASE_SURFACE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duithumb.h ===
/*
 * Thumb
 */

#ifndef DUI_CONTORL_THUMB_H_INCLUDED
#define DUI_CONTORL_THUMB_H_INCLUDED

#pragma once

#include "duibutton.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Thumb

// ThumbDrag event
struct ThumbDragEvent : Event
{
    SIZE sizeDelta;
};

// Class definition
class Thumb : public Button
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(AE_Mouse, ppElement); }
    static HRESULT Create(UINT nActive, OUT Element** ppElement);

    // System events
    virtual void OnInput(InputEvent* pie);

    // Event types
    static UID Drag;

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    Thumb() { }
    HRESULT Initialize(UINT nActive) { return Button::Initialize(nActive); }
    virtual ~Thumb() { }
};

} // namespace DirectUI

#endif // DUI_CONTORL_THUMB_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duivaluemap.h ===
/*
 * Value map
 */

#ifndef DUI_BASE_VALUEMAP_H_INCLUDED
#define DUI_BASE_VALUEMAP_H_INCLUDED

#pragma once

namespace DirectUI
{

//-------------------------------------------------------------------------
//
// ValueMap
//
// Stores Key/Value pairs
//
// Compile DEBUG for DUIAsserts, see public class declarations for API
//
// Keys and Values are stored natively and the type of each can be chosen
// at compile time. For example (Key is an int, Value is a string pointer,
// and the map will have 5 buckets):
//
// ValueMap<int,LPWSTR>* pvm;
// ValueMap<int,LPWSTR>::Create(5, &pvm);
// pvm->SetItem(1150, L"One thousand one hundred and fifty");
// LPWSTR psz;
// pvm->GetItem(1150, &psz);
// DUITrace("%s\n", psz);
//
// The Key type must support the following operations:
//    Assignment (=)
//    Int cast for finding bucket (int)
//    Equality (==)
//
// The Value type must support the following operation:
//    Assignment (=)
//
// Given the above, a key can be created based on a string where the
// correct mapping occurs even though the instance of the string is different.
//
//    class StringKey
//    {
//    public:
//        StringKey(LPWSTR);
//        operator =(LPWSTR);
//        BOOL operator ==(StringKey);
//        operator INT_PTR();
//
//    private:
//        LPWSTR pszStr;
//    };
//
//    StringKey::StringKey(LPWSTR pstr)
//    {
//        pszStr = pstr;
//    }
//
//    StringKey::operator =(LPWSTR pstr)
//    {
//        pszStr = pstr;
//    }
//
//    BOOL StringKey::operator ==(StringKey st)
//    {
//        return wcscmp(pszStr, st.pszStr) == 0;
//    }
//
//    StringKey::operator INT_PTR()  // Create hash code from string
//    {
//        int dHash = 0;
//        LPWSTR pstr = pszStr;
//        WCHAR c;
//
//        while (*pstr)
//        {
//            c = *pstr++;
//            dHash += (c << 1) + (c >> 1) + c;
//        }
//
//        return dHash;
//    }
//
// It's usage would be:
//
// ValueMap<StringKey, int> v(11);
//
// v.SetItem(L"My favorite number", 4);
// v.SetItem(L"Your favorite number", 8);
//
// Trace1(L"Mine : %d\n", *v.GetItem(L"My favorite number");      // 4
// Trace1(L"Yours: %d\n", *v.GetItem(L"Your favorite number");    // 8
//
// v.SetItem(L"My favorite number", 5150);
//
// Trace1(L"Mine : %d\n", *v.GetItem(L"My favorite number");      // 5150
//
// v.Remove(L"Your favorite number";
//
// DUIAssert(!v.ContainsKey(L"Your favorite number"), "Error!");    // Mapping is removed
//
//-------------------------------------------------------------------------

template <typename K, typename D> class ValueMap
{
    typedef struct _ENTRY
    {
        bool fInUse;
        K tKey;
        D tData;
        struct _ENTRY* peNext;

    } ENTRY, *PENTRY;

    typedef void (*VMENUMCALLBACK)(K tKey, D tData);

public:                                     // API
    static HRESULT Create(UINT uBuckets, OUT ValueMap<K,D>** ppMap);
    virtual ~ValueMap();
    void Destroy() { HDelete< ValueMap<K,D> >(this); }

    D* GetItem(K, bool);                    // Pointer to Value (NULL if doesn't exist, internal copy returned)
    HRESULT SetItem(K, D*, bool);           // Setup Key/Value map, creates new is doesn't exist (via indirection)
    HRESULT SetItem(K, D, bool);            // Setup Key/Value map, creates new is doesn't exist
    void Remove(K, bool, bool);             // Removes Key/Value map, ok if Key doesn't exist
    void Enum(VMENUMCALLBACK pfnCallback);  // Callback with every item in map
    bool IsEmpty();                         // True if no entries
    K* GetFirstKey();                       // Returns pointer to first key found in table
    HRESULT GetDistribution(WCHAR**);       // Returns a null terminated string describing table distribution (must HFree)

    ValueMap() { }
    HRESULT Initialize(UINT uBuckets);

private:
    UINT _uBuckets;
    PENTRY* _ppBuckets;
};

template <typename K, typename D> HRESULT ValueMap<K,D>::Create(UINT uBuckets, OUT ValueMap<K,D>** ppMap)
{
    DUIAssert(uBuckets > 0, "Must create at least one bucket in ValueMap");

    *ppMap = NULL;

    // Instantiate
    ValueMap<K,D>* pvm = HNew< ValueMap<K,D> >();
    if (!pvm)
        return E_OUTOFMEMORY;

    HRESULT hr = pvm->Initialize(uBuckets);
    if (FAILED(hr))
    {
        pvm->Destroy();
        return hr;
    }

    *ppMap = pvm;

    return S_OK;
}

template <typename K, typename D> HRESULT ValueMap<K,D>::Initialize(UINT uBuckets)
{
    _uBuckets = uBuckets;
    _ppBuckets = (PENTRY*)HAllocAndZero(sizeof(PENTRY) * _uBuckets);

    if (!_ppBuckets)
    {
        // Object isn't created if buckets cannot be allocated
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

template <typename K, typename D> ValueMap<K,D>::~ValueMap()
{
    PENTRY pe;
    PENTRY peNext;

    for (UINT i = 0; i < _uBuckets; i++)
    {
        pe = _ppBuckets[i];
        while (pe != NULL)
        {
            peNext = pe->peNext;
            HFree(pe);

            pe = peNext;
        }
    }

    HFree(_ppBuckets);
}

template <typename K, typename D> void ValueMap<K,D>::Enum(VMENUMCALLBACK pfnCallback)
{
    PENTRY pe;
    for (UINT i = 0; i < _uBuckets; i++)
    {
        pe = _ppBuckets[i];
        while (pe)
        {
            if (pe->fInUse)
                pfnCallback(pe->tKey, pe->tData);

            pe = pe->peNext;
        }
    }
}

template <typename K, typename D> K* ValueMap<K,D>::GetFirstKey()
{
    PENTRY pe;
    for (UINT i = 0; i < _uBuckets; i++)
    {
        pe = _ppBuckets[i];
        while (pe)
        {
            if (pe->fInUse)
                return &pe->tKey;

            pe = pe->peNext;
        }
    }

    return NULL;
}

template <typename K, typename D> D* ValueMap<K,D>::GetItem(K tKey, bool fKeyIsPtr)
{
    // Pointer based keys are shifted for better distribution

    // Search for items in buckets

    PENTRY pe = _ppBuckets[(UINT)(((fKeyIsPtr) ? (int)tKey >> 2 : (int)tKey) % _uBuckets)];

    while (pe && !(pe->fInUse && (pe->tKey == tKey)))
    {
        pe = pe->peNext;
    }

    return (pe) ? &pe->tData : NULL;
}

// Stores the value of tData (via indirection)
template <typename K, typename D> HRESULT ValueMap<K,D>::SetItem(K tKey, D* pData, bool fKeyIsPtr)
{
    // Pointer based keys are shifted for better distribution

    PENTRY pe;
    PENTRY pUnused = NULL;
    UINT uBucket = (UINT)(((fKeyIsPtr) ? (int)tKey >> 2 : (int)tKey) % _uBuckets);

    // Search for items in buckets
    pe = _ppBuckets[uBucket];

    while (pe && !(pe->fInUse && (pe->tKey == tKey)))
    {
        if (!pe->fInUse)
        {
            pUnused = pe;
        }

        pe = pe->peNext;
    }

    if (pe)
    {
        // Item found
        pe->tData = *pData;
    }
    else
    {
        // Reuse or create new item
        if (pUnused)
        {
            pUnused->fInUse = true;
            pUnused->tKey = tKey;
            pUnused->tData = *pData;
        }
        else
        {
            pe = (PENTRY)HAlloc(sizeof(ENTRY));
            if (!pe)
                return E_OUTOFMEMORY;

            pe->fInUse = true;
            pe->tKey = tKey;
            pe->tData = *pData;
            pe->peNext = _ppBuckets[uBucket];

            _ppBuckets[uBucket] = pe;
        }
    }

    return S_OK;
}

// Stores the value of tData
template <typename K, typename D> HRESULT ValueMap<K,D>::SetItem(K tKey, D tData, bool fKeyIsPtr)
{
    // Pointer based keys are shifted for better distribution

    PENTRY pe;
    PENTRY pUnused = NULL;
    UINT uBucket = (UINT)(((fKeyIsPtr) ? (UINT_PTR)tKey >> 2 : (INT_PTR)tKey) % _uBuckets);

    // Search for items in buckets
    pe = _ppBuckets[uBucket];

    while (pe && !(pe->fInUse && (pe->tKey == tKey)))
    {
        if (!pe->fInUse)
        {
            pUnused = pe;
        }

        pe = pe->peNext;
    }

    if (pe)
    {
        // Item found
        pe->tData = tData;
    }
    else
    {
        // Reuse or create new item
        if (pUnused)
        {
            pUnused->fInUse = true;
            pUnused->tKey = tKey;
            pUnused->tData = tData;
        }
        else
        {
            pe = (PENTRY)HAlloc(sizeof(ENTRY));
            if (!pe)
                return E_OUTOFMEMORY;

            pe->fInUse = true;
            pe->tKey = tKey;
            pe->tData = tData;
            pe->peNext = _ppBuckets[uBucket];

            _ppBuckets[uBucket] = pe;
        }
    }

    return S_OK;
}

template <typename K, typename D> void ValueMap<K,D>::Remove(K tKey, bool fFree, bool fKeyIsPtr)
{
    // Pointer based keys are shifted for better distribution

    PENTRY pe;
    PENTRY pePrev = NULL;
    UINT uBucket = (UINT)(((fKeyIsPtr) ? (UINT_PTR)tKey >> 2 : (INT_PTR)tKey) % _uBuckets);

    // Search for items in buckets
    pe = _ppBuckets[uBucket];

    while (pe && !(pe->fInUse && (pe->tKey == tKey)))
    {
        pePrev = pe;      // Keep the previous item
        pe = pe->peNext;
    }

    if (pe)
    {
        if (fFree)
        {
            if (pePrev != NULL)
            {
                pePrev->peNext = pe->peNext;
            }
            else
            {
                _ppBuckets[uBucket] = pe->peNext;
            }

            HFree(pe);
        }
        else
        {
            pe->fInUse = false;
        }
    }
}

template <typename K, typename D> bool ValueMap<K,D>::IsEmpty()
{
    PENTRY pe;
    for (UINT i = 0; i < _uBuckets; i++)
    {
        pe = _ppBuckets[i];
        while (pe != NULL)
        {
            if (pe->fInUse)
                return false;

            pe = pe->peNext;
        }
    }

    return true;
}

template <typename K, typename D> HRESULT ValueMap<K,D>::GetDistribution(OUT WCHAR** ppszDist)
{
    *ppszDist = NULL;

    LPWSTR pszOut = (LPWSTR)HAlloc((256 + _uBuckets * 24) * sizeof(WCHAR));
    if (!pszOut)
        return E_OUTOFMEMORY
        
    WCHAR pszBuf[151];

    swprintf(pszOut, L"Buckets for %x (Slots InUse/Total): %d - ", this, _uBuckets);

    PENTRY pe;
    UINT cInUse;
    UINT cCount;
    for (UINT i = 0; i < _uBuckets; i++)
    {
        pe = _ppBuckets[i];

        cInUse = 0;
        cCount = 0;

        while (pe)
        {
            cCount++;
            if (pe->fInUse)
                cInUse++;

            pe = pe->peNext;
        }

        swprintf(pszBuf, L"(B%d): %d/%d ", i, cInUse, cCount);
        wcscat(pszOut, pszBuf);
    }

    return pszOut;
}

} // namespace DirectUI

#endif // DUI_BASE_VALUEMAP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duivalue.h ===
/*
 * Value
 */

#ifndef DUI_CORE_VALUE_H_INCLUDED
#define DUI_CORE_VALUE_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// Value

/*
 * Value Multithreading
 * 
 * Values are immutable and are a process-wide resource. A value created in one thread can be
 * used in any thread. Access to them are synchronized (thread-safe) and they do not have
 * thread-affinity.
 *
 * TODO: Impl thread-safety for Values
 */

// Forward declarations
class Element;
class Layout;
class PropertySheet;
class Expression;
typedef DynamicArray<Element*> ElementList;

// Value will maintain the lifetime of ElementLists, Layouts, PropertySheets, and Expressions after
// a new Value is created with a pointer to the object (these objects are created externally). When
// the reference count goes to zero, these objects will be deleted. 

#define DUIV_UNAVAILABLE   -2
#define DUIV_UNSET         -1
#define DUIV_NULL          0
#define DUIV_INT           1
#define DUIV_BOOL          2
#define DUIV_ELEMENTREF    3
#define DUIV_ELLIST        4  // List deleted on Value destruction and made immutable on create (Value only object holding external created ElementList)
#define DUIV_STRING        5  // String duplicated on creation and freed on destruction (Value creates new internal instance)
#define DUIV_POINT         6
#define DUIV_SIZE          7
#define DUIV_RECT          8
#define DUIV_FILL          9
#define DUIV_LAYOUT        10 // Layout object destroyed on Value destruction (Value only object holding external created Layout)
#define DUIV_GRAPHIC       11 // Bitmap handle freed on Value destruction (Value creates new internal instance)
#define DUIV_SHEET         12 // PropertySheet object destroyed on Value destruction and made immutable on create (Value only object holding external created PropertySheet)
#define DUIV_EXPR          13 // Expression object destroyed on Value destruction (Value only object holding external created Expression)
#define DUIV_ATOM          14
#define DUIV_CURSOR        15 // Will not destroy cursor handle upon value destruction

// Value structures and macros

#define FILLTYPE_HGradient            ((BYTE)0)
#define FILLTYPE_VGradient            ((BYTE)1)
#define FILLTYPE_Solid                ((BYTE)2)
#define FILLTYPE_TriHGradient         ((BYTE)3)
#define FILLTYPE_TriVGradient         ((BYTE)4)
#define FILLTYPE_DrawFrameControl     ((BYTE)5)  // DrawFrameControl fill
#define FILLTYPE_DrawThemeBackground  ((BYTE)6)  // DrawThemeBackground fill

struct Fill  // Solid colors and fills
{
    BYTE dType;
    union
    {
        struct
        {
            COLORREF cr;
            COLORREF cr2;
            COLORREF cr3;
        } ref;

        struct
        {
            UINT uType;
            UINT uState;
        } fillDFC;

        struct
        {
            HTHEME hTheme;
            int iPartId;
            int iStateId;
        } fillDTB;
    };
};

// Graphic
// Graphic objects may either have an Alpha channel applied to the entire bitmap, 
// may have full alpha transparency of a particular color in the bitmap (with the
// option of an auto-color pick (upper left corner)), or neither

#define GRAPHICTYPE_Bitmap                  ((BYTE)0)
#define GRAPHICTYPE_Icon                    ((BYTE)1)
#define GRAPHICTYPE_EnhMetaFile             ((BYTE)2)

#ifdef GADGET_ENABLE_GDIPLUS
#define GRAPHICTYPE_GpBitmap                ((BYTE)3)
#endif

// Valid modes for Bitmaps (Alpha or RGB used depending on mode), meaning based on context of use
#define GRAPHIC_NoBlend                     ((BYTE)0)
#define GRAPHIC_AlphaConst                  ((BYTE)1)
#define GRAPHIC_AlphaConstPerPix            ((BYTE)2)
#define GRAPHIC_TransColor                  ((BYTE)3)
#define GRAPHIC_Stretch                     ((BYTE)4)
#define GRAPHIC_NineGrid                    ((BYTE)5)
#define GRAPHIC_NineGridTransColor          ((BYTE)6)
#define GRAPHIC_NineGridAlphaConstPerPix    ((BYTE)7)

struct Graphic
{
    HANDLE hImage;          // Will hold hBitmap, hIcon, hEnhMetaFile or Gdiplus::Bitmap
    HANDLE hAltImage;
    USHORT cx;
    USHORT cy;
    struct
    {
        BYTE dImgType   : 2;
        BYTE dMode      : 3;
        bool bFlip      : 1;
        bool bRTLGraphic: 1;
        bool bFreehImage: 1;
        
        union
        {
            BYTE dAlpha;
            struct
            {
                BYTE r: 8;
                BYTE g: 8;
                BYTE b: 8;
            } rgbTrans;
        };
    } BlendMode;
};

struct Cursor
{
    HCURSOR hCursor;
};

// Compile-time static version of the Value class
struct _StaticValue
{
    BYTE _fReserved0;
    BYTE _fReserved1;
    short _dType;
    int _cRef;
    int _val0;
    int _val1;
    int _val2;
    int _val3;
};

struct _StaticValueColor
{
    BYTE _fReserved0;
    BYTE _fReserved1;
    short _dType;
    int _cRef;
    BYTE dType;
    COLORREF cr;
    COLORREF crSec;
    USHORT x;
    USHORT y;
};

struct _StaticValuePtr
{
    BYTE _fReserved0;
    BYTE _fReserved1;
    short _dType;
    int _cRef;
    void* _ptr;
};

// Value class (24-bytes)
class Value
{
private:
    BYTE _fReserved0;  // Reserved for small block allocator
    BYTE _fReserved1;  // Data alignment padding
    short _dType;
    int _cRef;
    union
    {
        int _intVal;
        bool _boolVal;
        Element* _peVal;
        ElementList* _peListVal;
        LPWSTR _pszVal;
        POINT _ptVal;
        SIZE _sizeVal;
        RECT _rectVal;
        Fill _fillVal;
        Layout* _plVal;
        Graphic _graphicVal;
        PropertySheet* _ppsVal;
        Expression* _pexVal;
        ATOM _atomVal;
        Cursor _cursorVal;
    };

    void _ZeroRelease();

public:

#if DBG
    bool IsZeroRef() { return !_cRef; }
#endif

    // Value creation methods
    static Value* CreateInt(int dValue);
    static Value* CreateBool(bool bValue);
    static Value* CreateElementRef(Element* peValue);
    static Value* CreateElementList(ElementList* peListValue);
    static Value* CreateString(LPCWSTR pszValue, HINSTANCE hResLoad = NULL);
    static Value* CreatePoint(int x, int y);
    static Value* CreateSize(int cx, int cy);
    static Value* CreateRect(int left, int top, int right, int bottom);
    static Value* CreateColor(COLORREF cr);
    static Value* CreateColor(COLORREF cr0, COLORREF cr1, BYTE dType = FILLTYPE_HGradient);
    static Value* CreateColor(COLORREF cr0, COLORREF cr1, COLORREF cr2, BYTE dType = FILLTYPE_TriHGradient);
    static Value* CreateFill(const Fill & clrSrc);
    static Value* CreateDFCFill(UINT uType, UINT uState);
    static Value* CreateDTBFill(HTHEME hTheme, int iPartId, int iStateId);
    static Value* CreateLayout(Layout* plValue);
    static Value* CreateGraphic(HBITMAP hBitmap, BYTE dBlendMode = GRAPHIC_TransColor, UINT dBlendValue = (UINT)-1, bool bFlip = false, bool bRTL = false);
#ifdef GADGET_ENABLE_GDIPLUS
    static Value* CreateGraphic(Gdiplus::Bitmap * pgpbmp, BYTE dBlendMode = GRAPHIC_TransColor, UINT dBlendValue = (UINT)-1, bool bFlip = false, bool bRTL = false);
#endif
    static Value* CreateGraphic(HICON hIcon, bool bFlip = false, bool bRTL = false);
    static Value* CreateGraphic(LPCWSTR pszBMP, BYTE dBlendMode = GRAPHIC_TransColor, UINT dBlendValue = (UINT)-1, USHORT cx = 0, USHORT cy = 0, HINSTANCE hResLoad = NULL,
                                bool bFlip = false, bool bRTL = false);
    static Value* CreateGraphic(LPCWSTR pszICO, USHORT cxDesired, USHORT cyDesired, HINSTANCE hResLoad = NULL, bool bFlip = false, bool bRTL = false);
    static Value* CreateGraphic(HENHMETAFILE hEnhMetaFile, HENHMETAFILE hAltEnhMetaFile = NULL);
    static Value* CreatePropertySheet(PropertySheet* ppsValue);
    static Value* CreateExpression(Expression* pexValue);
    static Value* CreateAtom(LPCWSTR pszValue);
    static Value* CreateCursor(LPCWSTR pszValue);
    static Value* CreateCursor(HCURSOR hValue);

    // Reference count methods
    void AddRef() { if (_cRef != -1) _cRef++; }  // -1 is static value
    void Release() { if (_cRef != -1 && !--_cRef) _ZeroRelease(); }  // -1 is static value
    int GetRefCount() { return _cRef; }

    // Accessors
    int GetType();
    LPVOID GetImage(bool bGetRTL);
    int GetInt();
    bool GetBool();
    Element* GetElement();
    ElementList* GetElementList();     // Invalid if released (object referred to destroyed)
    const LPWSTR GetString();          // Invalid if released (object referred to destroyed)
    const POINT* GetPoint();           // Invalid if released
    const SIZE* GetSize();             // Invalid if released
    const RECT* GetRect();             // Invalid if released
    const Fill* GetFill();             // Invalid if released
    Layout* GetLayout();               // Invalid if released (object referred to destroyed)
    Graphic* GetGraphic();             // Invalid if released (object indirectly referred to destroyed)
    PropertySheet* GetPropertySheet(); // Invalid if released (object referred to destroyed)
    Expression* GetExpression();       // Invalid if released (object referred to destroyed)
    ATOM GetAtom();                    // Invalid if released
    Cursor* GetCursor();               // Invalid if released
    
    // Equality
    bool IsEqual(Value* pv);

    // Conversion
    LPWSTR ToString(LPWSTR psz, UINT c);

    // Common values
    static Value* pvUnavailable;
    static Value* pvNull;
    static Value* pvUnset;
    static Value* pvElementNull;
    static Value* pvElListNull;
    static Value* pvBoolTrue;
    static Value* pvBoolFalse;
    static Value* pvStringNull;
    static Value* pvPointZero;
    static Value* pvSizeZero;
    static Value* pvRectZero;
    static Value* pvIntZero;
    static Value* pvLayoutNull;
    static Value* pvGraphicNull;
    static Value* pvSheetNull;
    static Value* pvExprNull;
    static Value* pvAtomZero;
    static Value* pvCursorNull;
    static Value* pvColorTrans;
};

//LPVOID  GetImage(Graphic *pg, bool bGetRTL);

#define GethBitmap(pv, bGetRTL)            ((HBITMAP)pv->GetImage(bGetRTL))
#define GethIcon(pv, bGetRTL)              ((HICON)pv->GetImage(bGetRTL))
#define GethEnhMetaFile(pv, bGetRTL)       ((HENHMETAFILE)pv->GetImage(bGetRTL))
#define GetGpBitmap(pv, bGetRTL)          ((Gdiplus::Bitmap *)pv->GetImage(bGetRTL))

#define StaticValue(name, type, val0) static _StaticValue name = { 0, 0, type, -1, val0, 0, 0, 0 }
#define StaticValue2(name, type, val0, val1) static _StaticValue name = { 0, 0, type, -1, val0, val1, 0, 0 }
#define StaticValue4(name, type, val0, val1, val2, val3) static _StaticValue name = { 0, 0, type, -1, val0, val1, val2, val3 }
#define StaticValueColorSolid(name, cr) static _StaticValueColor name = { 0, 0, DUIV_FILL, -1, FILLTYPE_Solid, cr, 0, 0, 0 }
#define StaticValuePtr(name, type, ptr) static _StaticValuePtr name = { 0, 0, type, -1, ptr }


// Accessors
inline int 
Value::GetType()
{
    return _dType;
}

inline int 
Value::GetInt()  // Copy passed out
{
    DUIAssert(_dType == DUIV_INT, "Invalid value type");

    return _intVal;
}

inline bool 
Value::GetBool()  // Copy passed out
{
    DUIAssert(_dType == DUIV_BOOL, "Invalid value type");

    return _boolVal;
}

inline Element * 
Value::GetElement()  // Copy passed out
{
    DUIAssert(_dType == DUIV_ELEMENTREF, "Invalid value type");

    return _peVal;
}

inline ElementList * 
Value::GetElementList()  // Copy passed out, invalid (destroyed) if value released
{
    DUIAssert(_dType == DUIV_ELLIST, "Invalid value type");

    return _peListVal;
}

inline const LPWSTR 
Value::GetString()  // Copy passed out, invalid (destroyed) if value released
{
    DUIAssert(_dType == DUIV_STRING, "Invalid value type");

    return _pszVal;
}

inline const POINT *
Value::GetPoint()  // Pointer to internal structure, invalid if value released
{
    DUIAssert(_dType == DUIV_POINT, "Invalid value type");

    return &_ptVal;
}

inline const SIZE *
Value::GetSize()  // Pointer to internal structure, invalid if value released
{
    DUIAssert(_dType == DUIV_SIZE, "Invalid value type");

    return &_sizeVal;
}

inline const RECT *
Value::GetRect()  // Pointer to internal structure, invalid if value released
{
    DUIAssert(_dType == DUIV_RECT, "Invalid value type");

    return &_rectVal;
}

inline const Fill *
Value::GetFill()  // Pointer to internal structure, invalid if value released
{
    DUIAssert(_dType == DUIV_FILL, "Invalid value type");

    return &_fillVal;
}

inline Layout *
Value::GetLayout()  // Copy passed out, invalid (destroyed) if value released
{
    DUIAssert(_dType == DUIV_LAYOUT, "Invalid value type");
    
    return _plVal;
}

inline Graphic *
Value::GetGraphic()  // Pointer to internal structure, invalid if value released
{
    DUIAssert(_dType == DUIV_GRAPHIC, "Invalid value type");
    
    return &_graphicVal;
}

inline PropertySheet * Value::GetPropertySheet()  // Copy passed out, invalid (destroyed) if value released
{
    DUIAssert(_dType == DUIV_SHEET, "Invalid value type");

    return _ppsVal;
}

inline Expression *
Value::GetExpression()  // Copy passed out, invalid (destroyed) if value released
{
    DUIAssert(_dType == DUIV_EXPR, "Invalid value type");
    
    return _pexVal;
}

inline ATOM 
Value::GetAtom()  // Copy passed out
{
    DUIAssert(_dType == DUIV_ATOM, "Invalid value type");
    
    return _atomVal;
}

inline Cursor *
Value::GetCursor()  // Pointer to internal structure, invalid if value released
{
    DUIAssert(_dType == DUIV_CURSOR, "Invalid value type");
    
    return &_cursorVal;
}

} // namespace DirectUI

#endif // DUI_CORE_VALUE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duiverticalflowlayout.h ===
/*
 * Verticalflowlayout
 */

#ifndef DUI_LAYOUT_VERTICALFLOWLAYOUT_H_INCLUDED
#define DUI_LAYOUT_VERTICALFLOWLAYOUT_H_INCLUDED

#pragma once

namespace DirectUI
{

// No layout positions

struct VLINE
{
    UINT cy;             // length of line
    UINT cx;             // thickness of line
    UINT x;              // pixel start of line (always 0 for first line)
    UINT cElements;      // number of elements in line
    UINT* aryElement;    // pixel start of elements in line (one less than cElements -- because first start is always 0)
    UINT iStart;         // index of first element in line
};
    
////////////////////////////////////////////////////////
// vertical flow layout

class VerticalFlowLayout : public Layout
{
public:
    static HRESULT Create(int dNumParams, int* pParams, Value** ppValue);  // For parser
    static HRESULT Create(bool fWrap, UINT uXAlign, UINT uXLineAlign, UINT uYLineAlign, Layout** ppLayout);

    // Layout callbacks
    virtual void DoLayout(Element* pec, int cx, int cy);
    virtual SIZE UpdateDesiredSize(Element* pec, int dConstW, int dConstH, Surface* psrf);
    virtual Element* GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool fKeyableOnly);

    int GetLine(Element* pec, Element* pe);

    VerticalFlowLayout() { }
    void Initialize(bool fWrap, UINT uXAlign, UINT uXLineAlign, UINT uYLineAlign);
    virtual ~VerticalFlowLayout();

protected:
    SIZE BuildCacheInfo(Element *pec, int cxConstraint, int cyConstraint, Surface* psrf, bool fRealSize);

    bool _fWrap;
    UINT _uXLineAlign;
    UINT _uYLineAlign;
    UINT _uXAlign;
    SIZE _sizeDesired;
    SIZE _sizeLastConstraint;
    UINT _cLines;
    VLINE* _arLines;

    static SIZE g_sizeZero;
};

} // namespace DirectUI

#endif // DUI_LAYOUT_VERTICALFLOWLAYOUT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duser.h ===
#if !defined(INC__DUser_h__INCLUDED)
#define INC__DUser_h__INCLUDED


#ifdef __cplusplus
#define DEFARG(x)   = x
#else
#define DEFARG(x)
#endif


// 
// Setup implied switches
//

#ifdef GADGET_ENABLE_TRANSITIONS
#define GADGET_ENABLE_COM
#endif // GADGET_ENABLE_TRANSITIONS

#ifdef _GDIPLUS_H
#if !defined(GADGET_ENABLE_GDIPLUS)
#define GADGET_ENABLE_GDIPLUS
#endif
#endif


#ifdef GADGET_ENABLE_ALL

#define GADGET_ENABLE_COM
#define GADGET_ENABLE_OLE
#define GADGET_ENABLE_DX
#define GADGET_ENABLE_TRANSITIONS

#endif // GADGET_ENABLE_ALL


//
// Include external DirectUser definitions.
//

#ifdef GADGET_ENABLE_COM
#include <ObjBase.h>            // CoCreateInstance
#include <unknwn.h>             // IUnknown
#endif

#include "DUserError.h"
#include "DUserCore.h"
#include "DUserUtil.h"

#ifdef GADGET_ENABLE_TRANSITIONS
#include "DUserMotion.h"
#endif

#endif // INC__DUser_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\dusercore.h ===
/***************************************************************************\
*
* File: DUserCore.h
*
* Description:
* DUserCore.h defines the DirectUser/Core, the low-level composition engine.
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/

#if !defined(INC__DUserCore_h__INCLUDED)
#define INC__DUserCore_h__INCLUDED

/*
 * Include dependencies
 */

#include <limits.h>             // Standard constants

#ifdef __cplusplus
extern "C" {
#endif

#ifdef DUSER_EXPORTS
#define DUSER_API
#else
#define DUSER_API __declspec(dllimport)
#endif

/***************************************************************************\
*
* Basics
*
\***************************************************************************/

DECLARE_HANDLE(HGADGET);
DECLARE_HANDLE(HDCONTEXT);
DECLARE_HANDLE(HCLASS);

DUSER_API   BOOL        WINAPI  DeleteHandle(HANDLE h);
DUSER_API   BOOL        WINAPI  IsStartDelete(HANDLE h, BOOL * pfStarted);

#define IGTM_MIN                (0)     // +
#define IGTM_NONE               (0)     // | No special threading model
#define IGTM_SINGLE             (1)     // | Single threaded application
#define IGTM_SEPARATE           (2)     // | MT with single thread per context 
#define IGTM_MULTIPLE           (3)     // | MT with multiple threads per context
#define IGTM_MAX                (3)     // +

#define IGMM_MIN                (1)     // +
#define IGMM_COMPATIBLE         (1)     // | Core running in Compatible mode
#define IGMM_ADVANCED           (2)     // | Core running in Advanced mode
#define IGMM_STANDARD           (3)     // | Standard mode on Whistler
#define IGMM_MAX                (3)     // +

#define IGPM_MIN                (0)     // +
#define IGPM_BLEND              (0)     // | Optimize for blend between speed / size
#define IGPM_SPEED              (1)     // | Optimize for pure speed
#define IGPM_SIZE               (2)     // | Optimize for minimum working set
#define IGPM_MAX                (2)     // +

typedef struct tagINITGADGET
{
    DWORD       cbSize;         // Size of structure
    UINT        nThreadMode;    // Threading model
    UINT        nMsgMode;       // DirectUser/Core messaging subsystem mode
    UINT        nPerfMode;      // Performance tuning mode
    HDCONTEXT   hctxShare;      // Existing context to share with
} INITGADGET;

DUSER_API   HDCONTEXT   WINAPI  InitGadgets(INITGADGET * pInit);


#define IGC_MIN             (1)
#define IGC_DXTRANSFORM     (1) // DirectX Transforms
#define IGC_GDIPLUS         (2) // GDI+
#define IGC_MAX             (2)

DUSER_API   BOOL        WINAPI  InitGadgetComponent(UINT nOptionalComponent);
DUSER_API   BOOL        WINAPI  UninitGadgetComponent(UINT nOptionalComponent);

DUSER_API   HDCONTEXT   WINAPI  GetContext(HANDLE h);
DUSER_API   BOOL        WINAPI  IsInsideContext(HANDLE h);

#ifdef __cplusplus

#define BEGIN_STRUCT(name, baseclass) \
    struct name : baseclass {

#define END_STRUCT(name)   \
    };

#define FORWARD_STRUCT(name) \
    struct name;

#else

#define BEGIN_STRUCT(name, baseclass) \
    typedef struct tag##name {  \
        baseclass;

#define END_STRUCT(name) \
    } name;

#define FORWARD_STRUCT(name) \
    typedef struct name;

#endif


/***************************************************************************\
*
* Messaging and Events
*
\***************************************************************************/

#define GMF_DIRECT              0x00000000  // + When message reaches hgadMsg
#define GMF_ROUTED              0x00000001  // | Before message reaches hgadMsg
#define GMF_BUBBLED             0x00000002  // | After message reaches hgadMsg
#define GMF_EVENT               0x00000003  // | After message becomes an event
#define GMF_DESTINATION         0x00000003  // + Destination of message

typedef int MSGID;
typedef int PRID;

// New Messages
typedef struct tagGMSG
{
    DWORD       cbSize;         // (REQUIRED) Size of message in bytes
    MSGID       nMsg;           // (REQUIRED) Gadget message
    HGADGET     hgadMsg;        // (REQUIRED) Gadget that message is "about"
} GMSG;

BEGIN_STRUCT(MethodMsg, GMSG)
END_STRUCT(MethodMsg)

BEGIN_STRUCT(EventMsg, MethodMsg)
    UINT        nMsgFlags;      // Flags about message
END_STRUCT(EventMsg)


#define GET_EVENT_DEST(pmsg) \
    (pmsg->nMsgFlags & GMF_DESTINATION)

#define SET_EVENT_DEST(pmsg, dest) \
    (pmsg->nMsgFlags = ((pmsg->nMsgFlags & ~GMF_DESTINATION) | (dest & GMF_DESTINATION)))

#define DEFINE_EVENT(event, guid)       \
    struct __declspec(uuid(guid)) event


/***************************************************************************\
*
* Gadget Classes
*
\***************************************************************************/

#ifndef __cplusplus
#error Requires C++ to compile
#endif

}; // extern "C" 

namespace DUser
{

// Forward declarations
class Gadget;
class SGadget;
struct MessageInfoStub;

};

DUSER_API   HRESULT     WINAPI  DUserDeleteGadget(DUser::Gadget * pg);
DUSER_API   HGADGET     WINAPI  DUserCastHandle(DUser::Gadget * pg);

namespace DUser
{

#define dapi
#define devent

//
// Core Classes
//

class Gadget
{
public:
            void *      m_pDummy;

    inline  HGADGET     GetHandle() const
    {
        return DUserCastHandle(const_cast<Gadget *> (this));
    }

    inline  void        Delete()
    {
        DUserDeleteGadget(this);
    }

            HRESULT     CallStubMethod(MethodMsg * pmsg);
            HRESULT     CallSuperMethod(MethodMsg * pmsg, void * pMT);
            
            UINT        CallStubEvent(EventMsg * pmsg, int nEventMsg);
            UINT        CallSuperEvent(EventMsg * pmsg, void * pMT, int nEventMsg);

    enum ConstructCommand
    {
        ccSuper         = 0,        // Construct the super-class
        ccSetThis       = 1,        // Set this pointer
    };

    struct ConstructInfo
    {
    };
};


class SGadget
{
public:
            Gadget *    m_pgad;
    static  HCLASS      s_hclSuper;

    inline  HGADGET     GetHandle() const
    {
        return DUserCastHandle(const_cast<Gadget *> (m_pgad));
    }

    inline  void        Delete()
    {
        DUserDeleteGadget(m_pgad);
    }
};

typedef HRESULT (SGadget::*MethodProc)(MethodMsg * pmsg);
typedef HRESULT (SGadget::*EventProc)(EventMsg * pmsg);

//
// Delegate support
//

class EventDelegate
{
public:
    typedef HRESULT (CALLBACK Gadget::*Proc)(EventMsg * p1);

    static inline EventDelegate
    Build(Gadget * pvThis, Proc pfn) 
    {
        EventDelegate ed;
        ed.m_pvThis = pvThis;
        ed.m_pfn    = pfn;
        return ed;
    }

    inline HRESULT Invoke(EventMsg * p1)
    {
        return (m_pvThis->*m_pfn)(p1);
    }

    Gadget *    m_pvThis;
    Proc        m_pfn;
};

#define EVENT_DELEGATE(instance, function) \
    DUser::EventDelegate::Build(reinterpret_cast<DUser::Gadget *>(reinterpret_cast<void *>(instance)), \
            reinterpret_cast<DUser::EventDelegate::Proc>(function))


//
// Typedef's
//

typedef HRESULT (CALLBACK * ConstructProc)(DUser::Gadget::ConstructCommand cmd, HCLASS hclCur, DUser::Gadget * pg, void * pvData);
typedef HRESULT (CALLBACK * PromoteProc)(ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pg, DUser::Gadget::ConstructInfo * pmicData);
typedef HCLASS  (CALLBACK * DemoteProc)(HCLASS hclCur, DUser::Gadget * pg, void * pvData);


//
// Message information and class structures
//

template<class t, class m>
inline void *
Method(HRESULT (t::*pfn)(m * pmsg))
{
    union
    {
       HRESULT (t::*in)(m * pmsg);
       void * out;
    };

    in = pfn;
    return out;
}

template<class t, class m>
inline void *
Event(HRESULT (t::*pfn)(m * pmsg))
{
    union
    {
       HRESULT (t::*in)(m * pmsg);
       void * out;
    };

    in = pfn;
    return out;
}


struct MessageInfoGuts
{
    void *      pfn;            // IN:  Implementation function
    LPCWSTR     pszMsgName;     // IN:  Name
};

struct MessageClassGuts
{
    DWORD       cbSize;         // IN:  Structure size
    DWORD       nClassVersion;  // IN:  This class's version
    LPCWSTR     pszClassName;   // IN:  Name of new class
    LPCWSTR     pszSuperName;   // IN:  Name of super-class
    MessageInfoGuts *           // IN:  Message information
                rgMsgInfo;
    int         cMsgs;          // IN:  Number of messages being registered
    PromoteProc pfnPromote;     // IN:  Promotion function
    DemoteProc  pfnDemote;      // IN:  Demotion function
    HCLASS      hclNew;         // OUT: Newly created class
    HCLASS      hclSuper;       // OUT: Newly created class's super
};

struct MessageInfoStub
{
    int         cbSlotOffset;   // OUT: Message slot offset
    LPCWSTR     pszMsgName;     // IN:  Name
};

struct MessageClassStub
{
    DWORD       cbSize;
    DWORD       nClassVersion;
    LPCWSTR     pszClassName;
    DUser::MessageInfoStub *
                rgMsgInfo;
    int         cMsgs;
};

struct MessageClassSuper
{
    DWORD       cbSize;
    DWORD       nClassVersion;
    LPCWSTR     pszClassName;
    void *      pmt;
};

}; // namespace DUser

extern "C" {

DUSER_API   HCLASS      WINAPI  DUserRegisterGuts(DUser::MessageClassGuts * pmc);
DUSER_API   HCLASS      WINAPI  DUserRegisterStub(DUser::MessageClassStub * pmc);
DUSER_API   HCLASS      WINAPI  DUserRegisterSuper(DUser::MessageClassSuper * pmc);
DUSER_API   HCLASS      WINAPI  DUserFindClass(LPCWSTR pszName, DWORD nVersion);
DUSER_API   DUser::Gadget *    
                        WINAPI  DUserBuildGadget(HCLASS hcl, DUser::Gadget::ConstructInfo * pmicData);

DUSER_API   BOOL        WINAPI  DUserInstanceOf(DUser::Gadget * pg, HCLASS hclTest);
DUSER_API   DUser::Gadget *    
                        WINAPI  DUserCastClass(DUser::Gadget * pg, HCLASS hclTest);
DUSER_API   DUser::Gadget *    
                        WINAPI  DUserCastDirect(HGADGET hgad);
DUSER_API   void *      WINAPI  DUserGetGutsData(DUser::Gadget * pg, HCLASS hclData);


/***************************************************************************\
*
* Messages
*
\***************************************************************************/

// Core messages
#define GM_EVENT            32768

#define GM_DESTROY          (1 + GM_EVENT)
#define GM_PAINT            (2 + GM_EVENT)
#define GM_INPUT            (3 + GM_EVENT)
#define GM_CHANGESTATE      (4 + GM_EVENT)
#define GM_CHANGERECT       (5 + GM_EVENT)
#define GM_CHANGESTYLE      (6 + GM_EVENT)
#define GM_QUERY            (7 + GM_EVENT)
#define GM_SYNCADAPTOR      (8 + GM_EVENT)
#define GM_PAINTCACHE       (9 + GM_EVENT)    // TODO: Move into GM_PAINT message

#define GM_USER             (1024 + GM_EVENT) // Starting point for user messages
#define GM_REGISTER         (1000000 + GM_EVENT) // Starting point for registered messages

// Win32 Messages
// TODO: Move these to winuser.h
#define WM_GETROOTGADGET   (WM_USER - 1)

// Message filtering
#define GMFI_PAINT          0x00000001
#define GMFI_INPUTKEYBOARD  0x00000002
#define GMFI_INPUTMOUSE     0x00000004
#define GMFI_INPUTMOUSEMOVE 0x00000008
#define GMFI_CHANGESTATE    0x00000010
#define GMFI_CHANGERECT     0x00000020
#define GMFI_CHANGESTYLE    0x00000040
#define GMFI_ALL            0xFFFFFFFF
#define GMFI_VALID         (GMFI_PAINT |                                                 \
                            GMFI_INPUTKEYBOARD | GMFI_INPUTMOUSE | GMFI_INPUTMOUSEMOVE | \
                            GMFI_CHANGESTATE | GMFI_CHANGERECT | GMFI_CHANGESTYLE)

#define GDESTROY_START      1   // Gadget has started the destruction process
#define GDESTROY_FINAL      2   // Gadget has been fully destroyed

BEGIN_STRUCT(GMSG_DESTROY, EventMsg)
    UINT        nCode;          // Destruction code
END_STRUCT(GMSG_DESTROY)

#define GINPUT_MOUSE        0
#define GINPUT_KEYBOARD     1
#define GINPUT_JOYSTICK     2

BEGIN_STRUCT(GMSG_INPUT, EventMsg)
    UINT        nDevice;        // Input device
    UINT        nCode;          // Specific action
    UINT        nModifiers;     // ctrl, alt, shift, leftbutton, middlebutton, rightbutton
    LONG        lTime;          // Time when message was sent
END_STRUCT(GMSG_INPUT)


#define GMOUSE_MOVE         0
#define GMOUSE_DOWN         1
#define GMOUSE_UP           2
#define GMOUSE_DRAG         3
#define GMOUSE_HOVER        4
#define GMOUSE_WHEEL        5
#define GMOUSE_MAX          5

#define GBUTTON_NONE        0
#define GBUTTON_LEFT        1
#define GBUTTON_RIGHT       2
#define GBUTTON_MIDDLE      3
#define GBUTTON_MAX         3

#define GMODIFIER_LCONTROL  0x00000001
#define GMODIFIER_RCONTROL  0x00000002
#define GMODIFIER_LSHIFT    0x00000004
#define GMODIFIER_RSHIFT    0x00000008
#define GMODIFIER_LALT      0x00000010
#define GMODIFIER_RALT      0x00000020
#define GMODIFIER_LBUTTON   0x00000040
#define GMODIFIER_RBUTTON   0x00000080
#define GMODIFIER_MBUTTON   0x00000100

#define GMODIFIER_CONTROL   (GMODIFIER_LCONTROL | GMODIFIER_RCONTROL)
#define GMODIFIER_SHIFT     (GMODIFIER_LSHIFT   | GMODIFIER_RSHIFT)
#define GMODIFIER_ALT       (GMODIFIER_LALT     | GMODIFIER_RALT)

BEGIN_STRUCT(GMSG_MOUSE, GMSG_INPUT)
    POINT       ptClientPxl;    // Mouse location in client coordinates
    BYTE        bButton;        // Mouse button
    UINT        nFlags;         // Misc. flags
END_STRUCT(GMSG_MOUSE)

BEGIN_STRUCT(GMSG_MOUSEDRAG, GMSG_MOUSE)
    SIZE        sizeDelta;      // Mouse drag distance
    BOOL        fWithin;        // Mouse within gadget's bounds
END_STRUCT(GMSG_MOUSEDRAG)

BEGIN_STRUCT(GMSG_MOUSECLICK, GMSG_MOUSE)
    UINT        cClicks;        // number of clicks in "quick" succession
END_STRUCT(GMSG_MOUSECLICK)

BEGIN_STRUCT(GMSG_MOUSEWHEEL, GMSG_MOUSE)
    short       sWheel;         // Wheel position
END_STRUCT(GMSG_MOUSEWHEEL)

#define GKEY_DOWN           0
#define GKEY_UP             1
#define GKEY_CHAR           2
#define GKEY_SYSDOWN        3
#define GKEY_SYSUP          4
#define GKEY_SYSCHAR        5

BEGIN_STRUCT(GMSG_KEYBOARD, GMSG_INPUT)
    WCHAR       ch;             // Character
    WORD        cRep;           // Repeat count
    WORD        wFlags;         // Misc. flags
END_STRUCT(GMSG_KEYBOARD)


#define GPAINT_RENDER       0   // Render this Gadget into the buffer
#define GPAINT_CACHE        1   // Post-render step for Cached drawing

BEGIN_STRUCT(GMSG_PAINT, EventMsg)
    UINT        nCmd;           // Painting command
    UINT        nSurfaceType;   // Surface type
END_STRUCT(GMSG_PAINT)


BEGIN_STRUCT(GMSG_PAINTRENDERI, GMSG_PAINT)
    LPCRECT     prcGadgetPxl;   // Logical position of gadget
    LPCRECT     prcInvalidPxl;  // Invalid rectangle in container coordinates
    HDC         hdc;            // DC to draw into
END_STRUCT(GMSG_PAINT)


#ifdef GADGET_ENABLE_GDIPLUS
BEGIN_STRUCT(GMSG_PAINTRENDERF, GMSG_PAINT)
    const Gdiplus::RectF *
                prcGadgetPxl;   // Logical position of gadget
    const Gdiplus::RectF *
                prcInvalidPxl;  // Invalid rectangle in container coordinates
    Gdiplus::Graphics *
                pgpgr;          // Graphics to draw into
END_STRUCT(GMSG_PAINT)
#endif // GADGET_ENABLE_GDIPLUS


BEGIN_STRUCT(GMSG_PAINTCACHE, EventMsg)
    LPCRECT     prcGadgetPxl;   // Logical position of gadget
    HDC         hdc;            // DC to draw into
    BYTE        bAlphaLevel;    // General alpha level when copying to destination
    BYTE        bAlphaFormat;   // Alpha format
END_STRUCT(GMSG_PAINTCACHE)


#define GSTATE_KEYBOARDFOCUS    0
#define GSTATE_MOUSEFOCUS       1
#define GSTATE_ACTIVE           2
#define GSTATE_CAPTURE          3

#define GSC_SET             0
#define GSC_LOST            1

BEGIN_STRUCT(GMSG_CHANGESTATE, EventMsg)
    UINT        nCode;          // Change command
    HGADGET     hgadSet;        // Gadget that is receiving the "state"
    HGADGET     hgadLost;       // Gadget that is loosing the "state"
    UINT        nCmd;           // Action that occurred
END_STRUCT(GMSG_CHANGESTATE)


BEGIN_STRUCT(GMSG_CHANGESTYLE, EventMsg)
    UINT        nNewStyle;      // New style
    UINT        nOldStyle;      // Old style
END_STRUCT(GMSG_CHANGESTYLE)


BEGIN_STRUCT(GMSG_CHANGERECT, EventMsg)
    RECT        rcNewRect;
    UINT        nFlags;
END_STRUCT(GMSG_CHANGERECT)


#ifdef GADGET_ENABLE_COM
#define GQUERY_INTERFACE    0
#define GQUERY_OBJECT       1
#endif

#define GQUERY_RECT         2
#define GQUERY_DESCRIPTION  3
#define GQUERY_DETAILS      4
#define GQUERY_HITTEST      5
#define GQUERY_PADDING      6

#ifdef GADGET_ENABLE_OLE
#define GQUERY_DROPTARGET   7
#endif // GADGET_ENABLE_OLE

BEGIN_STRUCT(GMSG_QUERY, EventMsg)
    UINT        nCode;          // Query command
END_STRUCT(GMSG_QUERY)

#ifdef GADGET_ENABLE_COM
BEGIN_STRUCT(GMSG_QUERYINTERFACE, EventMsg)
    IUnknown *  punk;
END_STRUCT(GMSG_QUERYINTERFACE)
#endif

#define GQR_FIXED           0   // Should fix inside bounging box
#define GQR_PRIVERT         1   // Vertical size is priority
#define GQR_PRIHORZ         2   // Horizontal size is priority

BEGIN_STRUCT(GMSG_QUERYRECT, GMSG_QUERY)
    SIZE        sizeBound;      // Rectangle to fit inside
    SIZE        sizeResult;     // Computed rectange
    UINT        nFlags;         // Flags to use in computation
END_STRUCT(GMSG_QUERYRECT)

BEGIN_STRUCT(GMSG_QUERYDESC, GMSG_QUERY)
    WCHAR       szName[128];
    WCHAR       szType[128];
END_STRUCT(GMSG_QUERYDESC)

#define GQDT_HWND           0   // Provided handle refers to parent HWND

BEGIN_STRUCT(GMSG_QUERYDETAILS, GMSG_QUERY)
    UINT        nType;
    HANDLE      hOwner;
END_STRUCT(GMSG_QUERYDETAILS)

#define GQHT_NOWHERE        0   // Location is not "inside"
#define GQHT_INSIDE         1   // Location is generically "inside"
#define GQHT_CHILD          2   // Location is inside child specified by pvResultData
                                // (NOT YET IMPLEMENTED)

BEGIN_STRUCT(GMSG_QUERYHITTEST, GMSG_QUERY)
    POINT       ptClientPxl;    // Location in client pixels
    UINT        nResultCode;    // Result code
    void *      pvResultData;   // Extra result information
END_STRUCT(GMSG_QUERYHITTEST)


BEGIN_STRUCT(GMSG_QUERYPADDING, GMSG_QUERY)
    RECT        rcPadding;      // Extra padding around content
END_STRUCT(GMSG_QUERYPADDING)


#ifdef GADGET_ENABLE_OLE
BEGIN_STRUCT(GMSG_QUERYDROPTARGET, GMSG_QUERY)
    HGADGET     hgadDrop;       // Gadget actually specifying the DropTarget
    IDropTarget *
                pdt;            // DropTarget of Gadget
END_STRUCT(GMSG_QUERYDROPTARGET)
#endif // GADGET_ENABLE_OLE


#define GSYNC_RECT          (1)
#define GSYNC_XFORM         (2)
#define GSYNC_STYLE         (3)
#define GSYNC_PARENT        (4)

BEGIN_STRUCT(GMSG_SYNCADAPTOR, EventMsg)
    UINT        nCode;          // Change code
END_STRUCT(GMSG_SYNCADAPTOR)


typedef HRESULT     (CALLBACK * GADGETPROC)(HGADGET hgadCur, void * pvCur, EventMsg * pMsg);

#define SGM_FULL            0x00000001      // Route and bubble the message
#define SGM_RECEIVECONTEXT  0x00000002      // Use the receiving Gadget's Context
#define SGM_VALID          (SGM_FULL | SGM_RECEIVECONTEXT)

typedef struct tagFGM_INFO
{
    EventMsg* pmsg;             // Message to fire
    UINT        nFlags;         // Flags modifying message being fired
    HRESULT     hr;             // Result of message (if send)
    void *      pvReserved;     // Reserved
} FGM_INFO;

#define FGMQ_SEND           1   // Standard "Send" message queue
#define FGMQ_POST           2   // Standard "Post" message queue

DUSER_API   HRESULT     WINAPI  DUserSendMethod(MethodMsg * pmsg);
DUSER_API   HRESULT     WINAPI  DUserPostMethod(MethodMsg * pmsg);
DUSER_API   HRESULT     WINAPI  DUserSendEvent(EventMsg * pmsg, UINT nFlags);
DUSER_API   HRESULT     WINAPI  DUserPostEvent(EventMsg * pmsg, UINT nFlags);

DUSER_API   BOOL        WINAPI  FireGadgetMessages(FGM_INFO * rgFGM, int cMsgs, UINT idQueue);
DUSER_API   UINT        WINAPI  GetGadgetMessageFilter(HGADGET hgad, void * pvCookie);
DUSER_API   BOOL        WINAPI  SetGadgetMessageFilter(HGADGET hgad, void * pvCookie, UINT nNewFilter, UINT nMask);

DUSER_API   MSGID       WINAPI  RegisterGadgetMessage(const GUID * pguid);
DUSER_API   MSGID       WINAPI  RegisterGadgetMessageString(LPCWSTR pszName);
DUSER_API   BOOL        WINAPI  UnregisterGadgetMessage(const GUID * pguid);
DUSER_API   BOOL        WINAPI  UnregisterGadgetMessageString(LPCWSTR pszName);
DUSER_API   BOOL        WINAPI  FindGadgetMessages(const GUID ** rgpguid, MSGID * rgnMsg, int cMsgs);

DUSER_API   BOOL        WINAPI  AddGadgetMessageHandler(HGADGET hgadMsg, MSGID nMsg, HGADGET hgadHandler);
DUSER_API   BOOL        WINAPI  RemoveGadgetMessageHandler(HGADGET hgadMsg, MSGID nMsg, HGADGET hgadHandler);

DUSER_API   BOOL        WINAPI  GetMessageExA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
DUSER_API   BOOL        WINAPI  GetMessageExW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
DUSER_API   BOOL        WINAPI  PeekMessageExA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
DUSER_API   BOOL        WINAPI  PeekMessageExW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
DUSER_API   BOOL        WINAPI  WaitMessageEx();

#ifdef UNICODE
#define GetMessageEx        GetMessageExW
#define PeekMessageEx       PeekMessageExW
#else
#define GetMessageEx        GetMessageExA
#define PeekMessageEx       PeekMessageExA
#endif


/***************************************************************************\
*
* Construction, Tree management
*
\***************************************************************************/

#define GC_HWNDHOST         0x00000001      // + Host inside an HWND
#define GC_NCHOST           0x00000002      // | Host inside Non-client of HWND
#define GC_DXHOST           0x00000003      // | Host inside DirectX Surface
#define GC_COMPLEX          0x00000004      // | Complex TreeGadget
#define GC_SIMPLE           0x00000005      // | Simple TreeGadget
#define GC_DETACHED         0x00000006      // | Detached TreeGadget
#define GC_MESSAGE          0x00000007      // | Message-only Gadget
#define GC_TYPE             0x0000000F      // + Type of Gadget to create
#define GC_VALID           (GC_TYPE)

DUSER_API   HGADGET     WINAPI  CreateGadget(HANDLE hParent, UINT nFlags, GADGETPROC pfnProc, void * pvGadgetData);


#define GENUM_CURRENT       0x00000001      // Starting node in enumeration
#define GENUM_SIBLINGS      0x00000002      // Siblings of starting node in enumeration

                                            // + Type of enumeration (exclusive)
#define GENUM_PARENTSUP     0x00000004      // | Parents of this node going up
#define GENUM_PARENTSDOWN   0x00000008      // | Parents of this node going down
#define GENUM_SHALLOWCHILD  0x0000000C      // | Shallow children
#define GENUM_DEEPCHILD     0x00000010      // + Deep children
#define GENUM_TYPE         (GENUM_PARENTSUP | GENUM_PARENTSDOWN | \
                            GENUM_SHALLOWCHILD | GENUM_DEEPCHILD)

#define GENUM_MODIFYTREE    0x00000020      // Allow modifying the Tree during enumeration

#define GENUM_VALID         (GENUM_CURRENT | GENUM_SIBLINGS | GENUM_TYPE | GENUM_MODIFYTREE)

typedef BOOL    (CALLBACK * GADGETENUMPROC)(HGADGET hgad, void * pvData);

DUSER_API   BOOL        WINAPI  EnumGadgets(HGADGET hgadEnum, GADGETENUMPROC pfnProc, void * pvData, UINT nFlags);

#define GORDER_MIN          0
#define GORDER_ANY          0               // Order does not matter
#define GORDER_BEFORE       1               // Move this gadget in-front of sibling
#define GORDER_BEHIND       2               // Move this gadget behind sibling
#define GORDER_TOP          3               // Move to front of sibling z-order
#define GORDER_BOTTOM       4               // Move to bottom of sibling z-order
#define GORDER_FORWARD      5               // Move forward in z-order
#define GORDER_BACKWARD     6               // Move backward in z-order
#define GORDER_MAX          6

DUSER_API   BOOL        WINAPI  SetGadgetOrder(HGADGET hgadMove, HGADGET hgadOther, UINT nCmd);
DUSER_API   BOOL        WINAPI  SetGadgetParent(HGADGET hgadMove, HGADGET hgadParent, HGADGET hgadOther, UINT nCmd);


#define GG_MIN              0
#define GG_PARENT           0
#define GG_NEXT             1
#define GG_PREV             2
#define GG_TOPCHILD         3
#define GG_BOTTOMCHILD      4
#define GG_ROOT             5
#define GG_MAX              5

DUSER_API   HGADGET     WINAPI  GetGadget(HGADGET hgad, UINT nCmd);

/***************************************************************************\
*
* Styles and properties
*
\***************************************************************************/

#define GS_RELATIVE         0x00000001      // Positioning is relative to parent
#define GS_VISIBLE          0x00000002      // Drawing is visible
#define GS_ENABLED          0x00000004      // Input in "enabled"
#define GS_BUFFERED         0x00000008      // Drawing is double-buffered
#define GS_ALLOWSUBCLASS    0x00000010      // Gadget can be subclassed
#define GS_KEYBOARDFOCUS    0x00000020      // Gadget can receive keyboard focus
#define GS_MOUSEFOCUS       0x00000040      // Gadget can receive mouse focus
#define GS_CLIPINSIDE       0x00000080      // Clip drawing inside this Gadget
#define GS_CLIPSIBLINGS     0x00000100      // Clip siblings of this Gadget
#define GS_HREDRAW          0x00000200      // Redraw entire Gadget if resized horizontally
#define GS_VREDRAW          0x00000400      // Redraw entire Gadget if resized vertically
#define GS_OPAQUE           0x00000800      // HINT: Drawing is composited
#define GS_ZEROORIGIN       0x00001000      // Set origin to (0,0)
#define GS_CUSTOMHITTEST    0x00002000      // Requires custom hit-testing
#define GS_ADAPTOR          0x00004000      // Requires extra notifications to host
#define GS_CACHED           0x00008000      // Drawing is cached
#define GS_DEEPPAINTSTATE   0x00010000      // Sub-tree inherits paint state

#define GS_VALID           (GS_RELATIVE | GS_VISIBLE | GS_ENABLED | GS_BUFFERED |       \
                            GS_ALLOWSUBCLASS | GS_KEYBOARDFOCUS | GS_MOUSEFOCUS |       \
                            GS_CLIPINSIDE | GS_CLIPSIBLINGS | GS_HREDRAW | GS_VREDRAW | \
                            GS_OPAQUE | GS_ZEROORIGIN | GS_CUSTOMHITTEST |              \
                            GS_ADAPTOR | GS_CACHED | GS_DEEPPAINTSTATE)

DUSER_API   UINT        WINAPI  GetGadgetStyle(HGADGET hgad);
DUSER_API   BOOL        WINAPI  SetGadgetStyle(HGADGET hgadChange, UINT nNewStyle, UINT nMask);

DUSER_API   HGADGET     WINAPI  GetGadgetFocus();
DUSER_API   BOOL        WINAPI  SetGadgetFocus(HGADGET hgadFocus);
DUSER_API   BOOL        WINAPI  IsGadgetParentChainStyle(HGADGET hgad, UINT nStyle, BOOL * pfVisible, UINT nFlags);
inline BOOL IsGadgetVisible(HGADGET hgad, BOOL * pfVisible, UINT nFlags) {
    return IsGadgetParentChainStyle(hgad, GS_VISIBLE, pfVisible, nFlags); }
inline BOOL IsGadgetEnabled(HGADGET hgad, BOOL * pfEnabled, UINT nFlags) {
    return IsGadgetParentChainStyle(hgad, GS_ENABLED, pfEnabled, nFlags); }

DUSER_API   PRID        WINAPI  RegisterGadgetProperty(const GUID * pguid);
DUSER_API   BOOL        WINAPI  UnregisterGadgetProperty(const GUID * pguid);

DUSER_API   BOOL        WINAPI  GetGadgetProperty(HGADGET hgad, PRID id, void ** ppvValue);
DUSER_API   BOOL        WINAPI  SetGadgetProperty(HGADGET hgad, PRID id, void * pvValue);
DUSER_API   BOOL        WINAPI  RemoveGadgetProperty(HGADGET hgad, PRID id);


/***************************************************************************\
*
* Painting, Transforms
*
\***************************************************************************/

#define BLEND_OPAQUE        255
#define BLEND_TRANSPARENT   0

#define PI                  3.14159265359

DUSER_API   BOOL        WINAPI  InvalidateGadget(HGADGET hgad);
DUSER_API   BOOL        WINAPI  SetGadgetFillI(HGADGET hgadChange, HBRUSH hbrFill, BYTE bAlpha, int w, int h);
#ifdef GADGET_ENABLE_GDIPLUS
DUSER_API   BOOL        WINAPI  SetGadgetFillF(HGADGET hgadChange, Gdiplus::Brush * pgpbr);
#endif // GADGET_ENABLE_GDIPLUS
DUSER_API   BOOL        WINAPI  GetGadgetScale(HGADGET hgad, float * pflX, float * pflY);
DUSER_API   BOOL        WINAPI  SetGadgetScale(HGADGET hgadChange, float flX, float flY);
DUSER_API   BOOL        WINAPI  GetGadgetRotation(HGADGET hgad, float * pflRotationRad);
DUSER_API   BOOL        WINAPI  SetGadgetRotation(HGADGET hgadChange, float flRotationRad);
DUSER_API   BOOL        WINAPI  GetGadgetCenterPoint(HGADGET hgad, float * pflX, float * pflY);
DUSER_API   BOOL        WINAPI  SetGadgetCenterPoint(HGADGET hgadChange, float flX, float flY);


#define GBIM_STYLE          0x00000001
#define GBIM_ALPHA          0x00000002
#define GBIM_FILL           0x00000004
#define GBIM_VALID         (GBIM_STYLE | GBIM_ALPHA | GBIM_FILL)

#define GBIS_FILL           0x00000001
#define GBIS_VALID         (GBIS_FILL)

typedef struct tagBUFFER_INFO
{
    DWORD       cbSize;
    UINT        nMask;
    UINT        nStyle;
    BYTE        bAlpha;
    COLORREF    crFill;
} BUFFER_INFO;

DUSER_API   BOOL        WINAPI  GetGadgetBufferInfo(HGADGET hgad, BUFFER_INFO * pbi);
DUSER_API   BOOL        WINAPI  SetGadgetBufferInfo(HGADGET hgadChange, const BUFFER_INFO * pbi);


#define GRT_VISRGN          0               // VisRgn in container coordinates
#define GRT_MIN             0
#define GRT_MAX             0

DUSER_API   BOOL        WINAPI  GetGadgetRgn(HGADGET hgad, UINT nRgnType, HRGN hrgn, UINT nFlags);

#define GRIM_OPTIONS        0x00000001      // nOptions is valid
#define GRIM_SURFACE        0x00000002      // nSurface is valid
#define GRIM_PALETTE        0x00000004      // Palette is valid
#define GRIM_DROPTARGET     0x00000008      // nDropTarget is valid
#define GRIM_VALID         (GRIM_OPTIONS | GRIM_SURFACE | GRIM_PALETTE | GRIM_DROPTARGET)

#define GSURFACE_MIN        0
#define GSURFACE_HDC        0               // HDC
#define GSURFACE_GPGRAPHICS 1               // Gdiplus::Graphics
#define GSURFACE_MAX        1

#define GRIO_MANUALDRAW     0x00000001      // Call DrawGadgetTree() to draw.
#define GRIO_VALID         (GRIO_MANUALDRAW)

#define GRIDT_MIN           0
#define GRIDT_NONE          0               // Not a drop target
#define GRIDT_FAST          1               // Using OLE2 polling DnD
#define GRIDT_PRECISE       2               // Rescan for positional changes
#define GRIDT_MAX           2

typedef struct tagROOT_INFO
{
    DWORD       cbSize;
    UINT        nMask;
    UINT        nOptions;
    UINT        nSurface;
    UINT        nDropTarget;

    union {
        void *      pvData;
        HPALETTE    hpal;
#ifdef GADGET_ENABLE_GDIPLUS
        Gdiplus::ColorPalette * 
                    pgppal;
#endif // GADGET_ENABLE_GDIPLUS
    };
} ROOT_INFO;

DUSER_API   BOOL        WINAPI  GetGadgetRootInfo(HGADGET hgadRoot, ROOT_INFO * pri);
DUSER_API   BOOL        WINAPI  SetGadgetRootInfo(HGADGET hgadRoot, const ROOT_INFO * pri);


#define GAIO_MOUSESTATE     0x00000001      // Synchronize mouse state
#define GAIO_KEYBOARDSTATE  0x00000002      // Synchronize keyboard state
#define GAIO_ENABLECAPTURE  0x00000004      // Synchronize mouse capture state

#define GAIM_OPTIONS        0x00000001      // nOptions is valid

typedef struct tagADAPTOR_INFO
{
    DWORD       cbSize;
    UINT        nMask;
    UINT        nOptions;
} ADAPTOR_INFO;

DUSER_API   BOOL        WINAPI  GetGadgetAdaptorInfo(HGADGET hgadAdaptor, ADAPTOR_INFO * pai);
DUSER_API   BOOL        WINAPI  SetGadgetAdaptorInfo(HGADGET hgadAdaptor, const ADAPTOR_INFO * pai);


/***************************************************************************\
*
* Position
*
\***************************************************************************/

#define SGR_MOVE            0x00000001      // Gadget is being moved
#define SGR_SIZE            0x00000002      // Gadget is being resized
#define SGR_CHANGEMASK     (SGR_MOVE | SGR_SIZE)

#define SGR_CLIENT          0x00000004      // Relative to itself
#define SGR_PARENT          0x00000008      // Relative to parent
#define SGR_CONTAINER       0x0000000c      // Relative to root container
#define SGR_DESKTOP         0x00000010      // Relative to virtual desktop
#define SGR_OFFSET          0x00000014      // Relative to current position
#define SGR_RECTMASK       (SGR_CLIENT | SGR_PARENT | SGR_CONTAINER | \
                            SGR_DESKTOP | SGR_OFFSET)

#define SGR_ACTUAL          0x00000100      // Actual (non-XForm) rectangle
#define SGR_NOINVALIDATE    0x00000200      // Don't automatically invalidate

#define SGR_VALID_GET      (SGR_RECTMASK | SGR_ACTUAL)
#define SGR_VALID_SET      (SGR_CHANGEMASK | SGR_RECTMASK | SGR_ACTUAL | SGR_NOINVALIDATE)

DUSER_API   BOOL        WINAPI  GetGadgetSize(HGADGET hgad, SIZE * psizeLogicalPxl);
DUSER_API   BOOL        WINAPI  GetGadgetRect(HGADGET hgad, RECT * prcPxl, UINT nFlags);
DUSER_API   BOOL        WINAPI  SetGadgetRect(HGADGET hgadChange, int x, int y, int w, int h, UINT nFlags);


DUSER_API   HGADGET     WINAPI  FindGadgetFromPoint(HGADGET hgadRoot, POINT ptContainerPxl, UINT nStyle, POINT * pptClientPxl);
DUSER_API   BOOL        WINAPI  MapGadgetPoints(HGADGET hgadFrom, HGADGET hgadTo, POINT * rgptClientPxl, int cPts);


/***************************************************************************\
*
* Tickets
*
\***************************************************************************/

DUSER_API   DWORD        WINAPI  GetGadgetTicket(HGADGET hgad);
DUSER_API   HGADGET      WINAPI  LookupGadgetTicket(DWORD dwTicket);

/***************************************************************************\
*
* Special hooks for different containers
*
\***************************************************************************/

DUSER_API   BOOL        WINAPI  ForwardGadgetMessage(HGADGET hgadRoot, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr);

#define GDRAW_SHOW          0x00000001
#define GDRAW_VALID         (GDRAW_SHOW)

DUSER_API   BOOL        WINAPI  DrawGadgetTree(HGADGET hgadDraw, HDC hdcDraw, const RECT * prcDraw, UINT nFlags);

typedef BOOL (CALLBACK* ATTACHWNDPROC)(void * pvThis, HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * plRet);
DUSER_API   BOOL        WINAPI  AttachWndProcA(HWND hwnd, ATTACHWNDPROC pfn, void * pvThis);
DUSER_API   BOOL        WINAPI  AttachWndProcW(HWND hwnd, ATTACHWNDPROC pfn, void * pvThis);
DUSER_API   BOOL        WINAPI  DetachWndProc(HWND hwnd, ATTACHWNDPROC pfn, void * pvThis);

#ifdef UNICODE
#define AttachWndProc       AttachWndProcW
#else
#define AttachWndProc       AttachWndProcA
#endif

#ifdef __cplusplus
};  // extern "C"
#endif

#endif // INC__DUserCore_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duiviewer.h ===
/*
 * Viewer
 */

#ifndef DUI_CONTROL_VIEWER_H_INCLUDED
#define DUI_CONTROL_VIEWER_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// Viewer

class Viewer : public Element
{
public:
    static HRESULT Create(OUT Element** ppElement);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // System events
    virtual void OnInput(InputEvent* pie);
    virtual bool OnPropertyChanging(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // Self-layout methods
    void _SelfLayoutDoLayout(int dWidth, int dHeight);
    SIZE _SelfLayoutUpdateDesiredSize(int dConstW, int dConstH, Surface* psrf);

    // Property definitions
    static PropertyInfo* XOffsetProp;
    static PropertyInfo* YOffsetProp;
    static PropertyInfo* XScrollableProp;
    static PropertyInfo* YScrollableProp;

    // Quick property accessors
    int GetXOffset()                    DUIQuickGetter(int, GetInt(), XOffset, Specified)
    int GetYOffset()                    DUIQuickGetter(int, GetInt(), YOffset, Specified)
    bool GetXScrollable()               DUIQuickGetter(bool, GetBool(), XScrollable, Specified)
    bool GetYScrollable()               DUIQuickGetter(bool, GetBool(), YScrollable, Specified)

    HRESULT SetXOffset(int v)           DUIQuickSetter(CreateInt(v), XOffset)
    HRESULT SetYOffset(int v)           DUIQuickSetter(CreateInt(v), YOffset)
    HRESULT SetXScrollable(bool v)      DUIQuickSetter(CreateBool(v), XScrollable)
    HRESULT SetYScrollable(bool v)      DUIQuickSetter(CreateBool(v), YScrollable)

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    bool EnsureVisible(int x, int y, int cx, int cy);

    Viewer() { }
    HRESULT Initialize();
    virtual ~Viewer() { }

private:
    Element* GetContent();
    bool InternalEnsureVisible(int x, int y, int cx, int cy);

};

} // namespace DirectUI

#endif // DUI_CONTROL_VIEWER_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duserctrl.h ===
#if !defined(INC__DUserCtrl_h__INCLUDED)
#define INC__DUserCtrl_h__INCLUDED


#ifdef __cplusplus
extern "C" {
#endif

#ifdef __cplusplus

#define BEGIN_INTERPOLATION_INTERFACE(i, guid) \
    struct __declspec(uuid(guid)) i;    \
    struct i : public IInterpolation    \
    {

#define END_INTERPOLATION_INTERFACE() \
    };


#define BEGIN_ANIMATION_INTERFACE(i, guid) \
    struct __declspec(uuid(guid)) i;    \
    struct i : public IAnimation        \
    {

#define END_ANIMATION_INTERFACE() \
    };


#else
// TODO: Create C definition
#endif

/***************************************************************************\
*
* ButtonGadget
*
\***************************************************************************/

DEFINE_EVENT(evButtonClicked, "DCADCE53-062B-4d1f-B36F-3F2EB27B88CF");



#ifdef GADGET_ENABLE_COM

/***************************************************************************\
*
* Interpolation
*
\***************************************************************************/

struct __declspec(uuid("E188CC9E-4805-487d-9313-3B22AC8FE336")) IInterpolation;
interface IInterpolation : public IUnknown
{
public:
    STDMETHOD_(float,       Compute)(float flProgress, float flStart, float flEnd) PURE;
};


BEGIN_INTERPOLATION_INTERFACE(ILinearInterpolation, "3FD65045-7BF5-4a65-B137-F441529BD8F4")
END_INTERPOLATION_INTERFACE()


BEGIN_INTERPOLATION_INTERFACE(ILogInterpolation, "98C0FB9A-534D-4b9f-A439-A8E13F0C2D9E")
    STDMETHOD_(void,        SetScale)(float flScale) PURE;
END_INTERPOLATION_INTERFACE()


BEGIN_INTERPOLATION_INTERFACE(IExpInterpolation, "280DC2CC-7703-4147-8356-3FAACE662CD1")
    STDMETHOD_(void,        SetScale)(float flScale) PURE;
END_INTERPOLATION_INTERFACE()


BEGIN_INTERPOLATION_INTERFACE(ISInterpolation, "D07C8B2F-1896-438f-9EC2-6938ABD0D20C")
    STDMETHOD_(void,        SetScale)(float flScale)  PURE;
END_INTERPOLATION_INTERFACE()


#define INTERPOLATION_LINEAR       (1)
#define INTERPOLATION_LOG          (2)
#define INTERPOLATION_EXP          (3)
#define INTERPOLATION_S            (4)

DUSER_API   BOOL        WINAPI  BuildInterpolation(UINT nIPolID, int nVersion, REFIID riid, void ** ppvUnk);


/***************************************************************************\
*
* Animations
*
\***************************************************************************/

#ifdef GADGET_ENABLE_TRANSITIONS

interface IAnimationCallback;

struct __declspec(uuid("7AACE668-81EB-48d7-8734-267C83FF6DFF")) IAnimation;
interface IAnimation : public IUnknown
{
public:
    STDMETHOD_(void,        SetFunction)(IInterpolation * pipol) PURE;

    enum ETime {
        tComplete,          // Completed normally
        tEnd,               // Jumped to end
        tAbort,             // Aborted in place
        tReset,             // Reset to beginning
        tDestroy            // The Gadget being animationed has been destroyed
    };
    STDMETHOD_(void,        SetTime)(ETime time) PURE;
    STDMETHOD_(UINT,        GetID)() const PURE;
    STDMETHOD_(void,        SetCallback)(IAnimationCallback * pcb) PURE;
};


interface IAnimationCallback : public IUnknown
{
public:
    STDMETHOD_(void,        OnComplete)(IAnimation * pAni, IAnimation::ETime time) PURE;
    STDMETHOD_(void,        OnSetTime)(IAnimation * pAni, IAnimation::ETime time) PURE;
};


#define ANIF_USESTART               0x00000001  // Use the specified start values 
                                                // instead of querying the current

struct GANI_DESC
{
    DWORD       cbSize;
    HGADGET     hgadChange;
    GMA_ACTION  act;
    UINT        nAniFlags;
    IInterpolation *    
                pipol;
    IAnimationCallback *
                pcb;
}; 


#define GANI_ALPHACOMPLETE_OPTIMIZE 0x00000001  // Turn off alpha-blending if not needed

struct GANI_ALPHADESC : public GANI_DESC
{
    float       flStart;
    float       flEnd;
    BOOL        fPushToChildren;
    UINT        nOnComplete;
};


struct GANI_SCALEDESC : public GANI_DESC
{
    enum EAlignment {
        aTopLeft,
        aTopCenter,
        aTopRight,
        aMiddleLeft,
        aMiddleCenter,
        aMiddleRight,
        aBottomLeft,
        aBottomCenter,
        aBottomRight
    };

    EAlignment  al;
    float       flStart;
    float       flEnd;
};


struct GANI_RECTDESC : public GANI_DESC
{
    POINT       ptStart;
    POINT       ptEnd;
    SIZE        sizeStart;
    SIZE        sizeEnd;
    UINT        nChangeFlags;
};


#define GANI_ROTATEDIRECTION_SHORT  0   // Shortest arc
#define GANI_ROTATEDIRECTION_LONG   1   // Longer arc
#define GANI_ROTATEDIRECTION_CW     2   // Clock-wise
#define GANI_ROTATEDIRECTION_CCW    3   // Counter clock-wise

struct GANI_ROTATEDESC : public GANI_DESC
{
    float       flStart;
    float       flEnd;
    UINT        nDir;
};


#define ANIMATION_ALPHA            (1)
#define ANIMATION_SCALE            (2)
#define ANIMATION_RECT             (3)
#define ANIMATION_ROTATE           (4)


DUSER_API   BOOL        WINAPI  BuildAnimation(UINT nAniID, int nVersion, GANI_DESC * pDesc, REFIID riid, void ** ppvUnk);
DUSER_API   BOOL        WINAPI  GetGadgetAnimation(HGADGET hgad, UINT nAniID, REFIID riid, void ** ppvUnk);


#endif // GADGET_ENABLE_TRANSITIONS
#endif // GADGET_ENABLE_COM

DUSER_API   BOOL        WINAPI  BuildDropTarget(HGADGET hgadRoot, HWND hwnd);

#ifdef __cplusplus
};
#endif

#endif // INC__DUserCtrl_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\dusererror.h ===
/***************************************************************************\
*
* File: DUserError.h
*
* Description:
* DUserError.h defines the DirectUser error values common across all of
* DirectUser.
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/

#if !defined(INC__DUserError_h__INCLUDED)
#define INC__DUserError_h__INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

#ifdef DUSER_EXPORTS
#define DUSER_API
#else
#define DUSER_API __declspec(dllimport)
#endif

#define FACILITY_DUSER  FACILITY_ITF
#define MAKE_DUSUCCESS(code)    MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_DUSER, code)
#define MAKE_DUERROR(code)      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DUSER, code)

/***************************************************************************\
*
* Error codes
*
\***************************************************************************/

// Callback function definitions

/*
 * Message was not handled at all.
 */
#define DU_S_NOTHANDLED             MAKE_DUSUCCESS(0)

/*
 * Message was completely handled (stop bubbling).
 */
#define DU_S_COMPLETE               MAKE_DUSUCCESS(1)

/*
 * Message was partially handled (continue bubbling).
 */
#define DU_S_PARTIAL                MAKE_DUSUCCESS(2)

/*
 * Enumeration was successful but prematurely stopped by the enumeration 
 * function
 */
#define DU_S_STOPPEDENUMERATION     MAKE_DUSUCCESS(10)


/*
 * The operation was successful, but the object was already created.
 */
#define DU_S_ALREADYEXISTS          MAKE_DUSUCCESS(20)

/*
 * There are not enough Kernel resources to perform the operation
 */
#define DU_E_OUTOFKERNELRESOURCES   MAKE_DUERROR(1)

/*
 * There are not enough GDI resources to perform the operation
 */
#define DU_E_OUTOFGDIRESOURCES      MAKE_DUERROR(2)

/*
 * Generic failure.
 */
#define DU_E_GENERIC                MAKE_DUERROR(10)

/*
 * Generic failure.
 */
#define DU_E_BUSY                   MAKE_DUERROR(11)

/*
 * The Context has not been initialized with InitGadgets().
 */
#define DU_E_NOCONTEXT              MAKE_DUERROR(20)

 /*
 * The object was used in the incorrect context.
 */
#define DU_E_INVALIDCONTEXT         MAKE_DUERROR(30)

/*
 * The Context has been marked to only allow read-only operations.  For example,
 * this may be in the middle of a read-only callback.
 */
#define DU_E_READONLYCONTEXT        MAKE_DUERROR(31)

/*
 * The threading model has already be determined by a previous call to 
 * InitGadgets() and can no longer be changed.
 */
#define DU_E_THREADINGALREADYSET    MAKE_DUERROR(32)

/*
 * Unable to use the IGMM_STANDARD messaging model because it is either 
 * unsupported or cannot be installed.
 */
#define DU_E_CANNOTUSESTANDARDMESSAGING MAKE_DUERROR(33)

/*
 * Can not mix an invalid coordinate mapping, for example having a non-relative
 * child of a relative parent.
 */
#define DU_E_BADCOORDINATEMAP       MAKE_DUERROR(40)

/*
 * Could not find a MSGID for one of the requested messages.  This will be 
 * represented by a '0' in the MSGID field for that message.
 */
#define DU_E_CANNOTFINDMSGID        MAKE_DUERROR(50)

/*
 * The operation is not legal because the specified Gadget does not have a 
 * GS_BUFFERED style.
 */
#define DU_E_NOTBUFFERED            MAKE_DUERROR(60)

/*
 * The specific Gadget has started the destruction and can not be be modified
 * in this manner.
 */
#define DU_E_STARTDESTROY           MAKE_DUERROR(70)

/*
 * The specified DirectUser optional component has not yet been initialized with
 * InitGadgetComponent().
 */
#define DU_E_NOTINITIALIZED         MAKE_DUERROR(80)

/*
 * The specified DirectUser object was not found.
 */
#define DU_E_NOTFOUND               MAKE_DUERROR(90)

/*
 * The specified parmeters are mismatched for the current object state.  For
 * example, the object is specified to use GDI HANDLE's, but the parameter was
 * a GDI+ Object.
 */
#define DU_E_MISMATCHEDTYPES        MAKE_DUERROR(100)

/*
 * GDI+ was unable to be loaded.  It may not be installed on the system or may
 * not be properly initialized.
 */
#define DU_E_CANNOTLOADGDIPLUS      MAKE_DUERROR(110)

/*
 * The specified class was already registered.
 */
#define DU_E_CLASSALREADYREGISTERED MAKE_DUERROR(120)

/*
 * The specified message was not found during class registration.
 */
#define DU_E_MESSAGENOTFOUND        MAKE_DUERROR(121)

/*
 * The specified message was not implemented during class registration.
 */
#define DU_E_MESSAGENOTIMPLEMENTED  MAKE_DUERROR(122)

/*
 * The implementation of the specific class has not yet been registered.
 */
#define DU_E_CLASSNOTIMPLEMENTED    MAKE_DUERROR(123)

/*
 * Sending the message failed.
 */
#define DU_E_MESSAGEFAILED          MAKE_DUERROR(124)


#ifdef __cplusplus
};  // extern "C"
#endif

#endif // INC__DUserCore_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duserservices.h ===
#if !defined(INC__DUserServices_h__INCLUDED)
#define INC__DUserServices_h__INCLUDED

/*
 * Include dependencies
 */

#include <limits.h>             // Standard constants

#ifdef __cplusplus
extern "C" {
#endif

#ifdef DUSER_EXPORTS
#define DUSER_API
#else
#define DUSER_API __declspec(dllimport)
#endif




#ifdef __cplusplus
};  // extern "C"
#endif

#endif // INC__DUserServices_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\dusermotion.h ===
#if !defined(INC__DUserMotion_h__INCLUDED)
#define INC__DUserMotion_h__INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

#ifdef DUSER_EXPORTS
#define DUSER_API
#else
#define DUSER_API __declspec(dllimport)
#endif

/***************************************************************************\
*
* Transitions
*
\***************************************************************************/

#define GTX_TYPE_DXFORM2D       1
#define GTX_TYPE_DXFORM3DRM     2

#define GTX_ITEMTYPE_NONE       0
#define GTX_ITEMTYPE_BITMAP     1
#define GTX_ITEMTYPE_HDC        2
#define GTX_ITEMTYPE_HWND       3
#define GTX_ITEMTYPE_GADGET     4
#define GTX_ITEMTYPE_DXSURFACE  5

#define GTX_EXEC_FORWARD        0x000000000
#define GTX_EXEC_BACKWARD       0x000000001
#define GTX_EXEC_DIR            0x000000001
#define GTX_EXEC_CACHE          0x000000002
#define GTX_EXEC_VALID          (GTX_EXEC_DIR | GTX_EXEC_CACHE)

#define GTX_IF_CROP             0x000000001
#define GTX_IF_VALID            (GTX_IF_CROP)

//
// Standard Transition header
//
struct GTX_TRXDESC
{
    UINT        tt;
};


//
// DirectX Transforms 2D
//

//
// TODO: Change implementation of DXTX2D to have better support for using Trx
// with only one input.  Should automatically create a secondary surface of a
// specified color-key that can be use to transition to.
//

struct GTX_DXTX2D_TRXDESC : public GTX_TRXDESC
{
    CLSID       clsidTransform;
    float       flDuration;
    LPCWSTR     pszCopyright;
};


//
// DirectX Transforms 3D Retained Mode
//
struct GTX_DXTX3DRM_TRXDESC : public GTX_TRXDESC
{
    CLSID       clsidTransform;
    float       flDuration;
    LPCWSTR     pszCopyright;
    IUnknown *  pRM;
};

struct GTX_ITEM
{
    UINT        nFlags;
    UINT        it;
    void *      pvData;
    RECT        rcCrop;
};

struct GTX_PLAY
{
    GTX_ITEM    rgIn[2];
    GTX_ITEM    gxiOut;
    UINT        nFlags;
};

DECLARE_HANDLE(HTRANSITION);

DUSER_API   HTRANSITION WINAPI  CreateTransition(const GTX_TRXDESC * ptx);
DUSER_API   BOOL        WINAPI  PlayTransition(HTRANSITION htrx, const GTX_PLAY * pgx);
DUSER_API   BOOL        WINAPI  GetTransitionInterface(HTRANSITION htrx, IUnknown ** ppUnk);

DUSER_API   BOOL        WINAPI  BeginTransition(HTRANSITION htrx, const GTX_PLAY * pgx);
DUSER_API   BOOL        WINAPI  PrintTransition(HTRANSITION htrx, float fProgress);
DUSER_API   BOOL        WINAPI  EndTransition(HTRANSITION htrx, const GTX_PLAY * pgx);


/***************************************************************************\
*
* Actions
*
\***************************************************************************/

struct GMA_ACTION;

DECLARE_HANDLE(HACTION);

struct GMA_ACTIONINFO
{
    HACTION     hact;           // Handle
    void *      pvData;         // Caller data
    float       flDuration;     // Duration in seconds
    float       flProgress;     // Progress (0 - 1)
    int         cEvent;         // Number of callbacks in this period
    int         cPeriods;       // Number of periods
    BOOL        fFinished;      // TODO: Change to a command
};

typedef void    (CALLBACK * ACTIONPROC)(GMA_ACTIONINFO * pmai);

struct GMA_ACTION
{
    DWORD       cbSize;         // Size of structure
    float       flDelay;        // Delay in seconds before starting
    float       flDuration;     // Duration in seconds of each period (0 = single shot)
    float       flPeriod;       // Time between beginnings of repeats (0 = no gap)
    UINT        cRepeat;        // Number of times to repeat (0 = single, -1 = infinite)
    DWORD       dwPause;        // Pause between callbacks (0 = default, -1 = none)
    ACTIONPROC  pfnProc;        // Function to call
    void *      pvData;         // Caller data
};


DUSER_API   HACTION     WINAPI  CreateAction(const GMA_ACTION * pma);
DUSER_API   BOOL        WINAPI  GetActionTimeslice(DWORD * pdwTimeslice);
DUSER_API   BOOL        WINAPI  SetActionTimeslice(DWORD dwTimeslice);

/***************************************************************************\
*
* Animations
*
\***************************************************************************/

class Visual;

namespace DUser
{

struct KeyFrame
{
    DWORD       cbSize;
};

};  // namespace DUser

DUSER_API   void        WINAPI  DUserStopAnimation(Visual * pgvSubject, PRID pridAni);

DUSER_API   PRID        WINAPI  DUserGetAlphaPRID();
DUSER_API   PRID        WINAPI  DUserGetRectPRID();
DUSER_API   PRID        WINAPI  DUserGetRotatePRID();
DUSER_API   PRID        WINAPI  DUserGetScalePRID();

#ifdef __cplusplus
};  // extern "C"
#endif

#endif // INC__DUserMotion_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\gadget.h ===
#if !defined(INC__Gadget_h__INCLUDED)
#define INC__Gadget_h__INCLUDED
#pragma once

// Forward declarations used in .gidl files

class Visual;

namespace Gdiplus
{
    class Brush;
    class Font;
    class Pen;
};


// Global helper functions

template <class T>
inline T * 
BuildVisual(Visual * pgvParent)
{
    Visual::VisualCI ci;
    ZeroMemory(&ci, sizeof(ci));
    ci.pgvParent = pgvParent;
    return T::Build(&ci);
}


inline bool IsHandled(HRESULT hr)
{
    return (hr == DU_S_COMPLETE) || (hr == DU_S_PARTIAL);
}


#endif // INC__Gadget_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\oak\inc\d3dnthal.h ===
/*==========================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dnthal.h
 *  Content:    Direct3D HAL include file for NT
 *
 ***************************************************************************/

#ifndef _D3DNTHAL_H_
#define _D3DNTHAL_H_

#include <ddrawint.h>
#ifndef _WINDOWS_
#define _WINDOWS_
#include <d3dtypes.h>
#include <d3dcaps.h>
#undef _WINDOWS_
#else
#include <d3dtypes.h>
#include <d3dcaps.h>
#endif

/*
 * If the HAL driver does not implement clipping, it must reserve at least
 * this much space at the end of the LocalVertexBuffer for use by the HEL
 * clipping.  I.e. the vertex buffer contain dwNumVertices+dwNumClipVertices
 * vertices.  No extra space is needed by the HEL clipping in the
 * LocalHVertexBuffer.
 */
#define D3DNTHAL_NUMCLIPVERTICES    20

/*
 * If no dwNumVertices is given, this is what will be used.
 */
#define D3DNTHAL_DEFAULT_TL_NUM ((32 * 1024) / sizeof (D3DTLVERTEX))
#define D3DNTHAL_DEFAULT_H_NUM  ((32 * 1024) / sizeof (D3DHVERTEX))

/*
 * Description for a device.
 * This is used to describe a device that is to be created or to query
 * the current device.
 *
 * For DX5 and subsequent runtimes, D3DNTDEVICEDESC is a user-visible
 * structure that is not seen by the device drivers. The runtime
 * stitches a D3DNTDEVICEDESC together using the D3DNTDEVICEDESC_V1
 * embedded in the GLOBALDRIVERDATA and the extended caps queried
 * from the driver using GetDriverInfo.
 */

typedef struct _D3DNTHALDeviceDesc_V1 {
    DWORD               dwSize;                     // Size of D3DNTHALDEVICEDESC_V1 structure
    DWORD               dwFlags;                    // Indicates which fields have valid data
    D3DCOLORMODEL       dcmColorModel;              // Color model of device
    DWORD               dwDevCaps;                  // Capabilities of device
    D3DTRANSFORMCAPS    dtcTransformCaps;           // Capabilities of transform
    BOOL                bClipping;                  // Device can do 3D clipping
    D3DLIGHTINGCAPS     dlcLightingCaps;            // Capabilities of lighting
    D3DPRIMCAPS         dpcLineCaps;
    D3DPRIMCAPS         dpcTriCaps;
    DWORD               dwDeviceRenderBitDepth;     // One of DDBB_8, 16, etc..
    DWORD               dwDeviceZBufferBitDepth;    // One of DDBD_16, 32, etc..
    DWORD               dwMaxBufferSize;            // Maximum execute buffer size
    DWORD               dwMaxVertexCount;           // Maximum vertex count
} D3DNTHALDEVICEDESC_V1, *LPD3DNTHALDEVICEDESC_V1;

#define D3DNTHALDEVICEDESCSIZE_V1 (sizeof(D3DNTHALDEVICEDESC_V1))

/*
 * This is equivalent to the D3DNTDEVICEDESC understood by DX5, available only
 * from DX6. It is the same as D3DNTDEVICEDESC structure in DX5.
 * D3DNTDEVICEDESC is still the user-visible structure that is not seen by the
 * device drivers. The runtime stitches a D3DNTDEVICEDESC together using the
 * D3DNTDEVICEDESC_V1 embedded in the GLOBALDRIVERDATA and the extended caps
 * queried from the driver using GetDriverInfo.
 */

typedef struct _D3DNTHALDeviceDesc_V2 {
    DWORD               dwSize;                     // Size of D3DNTDEVICEDESC structure
    DWORD               dwFlags;                    // Indicates which fields have valid data
    D3DCOLORMODEL       dcmColorModel;              // Color model of device
    DWORD               dwDevCaps;                  // Capabilities of device
    D3DTRANSFORMCAPS    dtcTransformCaps;           // Capabilities of transform
    BOOL                bClipping;                  // Device can do 3D clipping
    D3DLIGHTINGCAPS     dlcLightingCaps;            // Capabilities of lighting
    D3DPRIMCAPS         dpcLineCaps;
    D3DPRIMCAPS         dpcTriCaps;
    DWORD               dwDeviceRenderBitDepth;     // One of DDBD_16, etc..
    DWORD               dwDeviceZBufferBitDepth;    // One of DDBD_16, 32, etc..
    DWORD               dwMaxBufferSize;            // Maximum execute buffer size
    DWORD               dwMaxVertexCount;           // Maximum vertex count

    DWORD               dwMinTextureWidth, dwMinTextureHeight;
    DWORD               dwMaxTextureWidth, dwMaxTextureHeight;
    DWORD               dwMinStippleWidth, dwMaxStippleWidth;
    DWORD               dwMinStippleHeight, dwMaxStippleHeight;

} D3DNTHALDEVICEDESC_V2, *LPD3DNTHALDEVICEDESC_V2;

#define D3DNTHALDEVICEDESCSIZE_V2 (sizeof(D3DNTHALDEVICEDESC_V2))

#if(DIRECT3D_VERSION >= 0x0700)
/*
 * This is equivalent to the D3DNTDEVICEDESC understood by DX6, available only
 * from DX6. It is the same as D3DNTDEVICEDESC structure in DX6.
 * D3DNTDEVICEDESC is still the user-visible structure that is not seen by the
 * device drivers. The runtime stitches a D3DNTDEVICEDESC together using the
 * D3DNTDEVICEDESC_V1 embedded in the GLOBALDRIVERDATA and the extended caps
 * queried from the driver using GetDriverInfo.
 */

typedef struct _D3DNTDeviceDesc_V3 {
    DWORD               dwSize;                     // Size of D3DNTDEVICEDESC structure
    DWORD               dwFlags;                    // Indicates which fields have valid data
    D3DCOLORMODEL       dcmColorModel;              // Color model of device
    DWORD               dwDevCaps;                  // Capabilities of device
    D3DTRANSFORMCAPS    dtcTransformCaps;           // Capabilities of transform
    BOOL                bClipping;                  // Device can do 3D clipping
    D3DLIGHTINGCAPS     dlcLightingCaps;            // Capabilities of lighting
    D3DPRIMCAPS         dpcLineCaps;
    D3DPRIMCAPS         dpcTriCaps;
    DWORD               dwDeviceRenderBitDepth;     // One of DDBD_16, etc..
    DWORD               dwDeviceZBufferBitDepth;    // One of DDBD_16, 32, etc..
    DWORD               dwMaxBufferSize;            // Maximum execute buffer size
    DWORD               dwMaxVertexCount;           // Maximum vertex count

    DWORD               dwMinTextureWidth, dwMinTextureHeight;
    DWORD               dwMaxTextureWidth, dwMaxTextureHeight;
    DWORD               dwMinStippleWidth, dwMaxStippleWidth;
    DWORD               dwMinStippleHeight, dwMaxStippleHeight;

    DWORD               dwMaxTextureRepeat;
    DWORD               dwMaxTextureAspectRatio;
    DWORD               dwMaxAnisotropy;
    D3DVALUE            dvGuardBandLeft;
    D3DVALUE            dvGuardBandTop;
    D3DVALUE            dvGuardBandRight;
    D3DVALUE            dvGuardBandBottom;
    D3DVALUE            dvExtentsAdjust;
    DWORD               dwStencilCaps;
    DWORD               dwFVFCaps;                  // low 4 bits: 0 implies TLVERTEX only, 1..8 imply FVF aware
    DWORD               dwTextureOpCaps;
    WORD                wMaxTextureBlendStages;
    WORD                wMaxSimultaneousTextures;
} D3DNTDEVICEDESC_V3, *LPD3DNTDEVICEDESC_V3;

#define D3DNTDEVICEDESCSIZE_V3 (sizeof(D3DNTDEVICEDESC_V3))
#endif /* DIRECT3D_VERSION >= 0x0700 */
/* --------------------------------------------------------------
 * Instantiated by the HAL driver on driver connection.
 *
 * Regarding dwNumVertices, specify 0 if you are relying on the HEL to do
 * everything and you do not need the resultant TLVertex buffer to reside
 * in device memory.
 * The HAL driver will be asked to allocate dwNumVertices + dwNumClipVertices
 * in the case described above.
 */
typedef struct _D3DNTHAL_GLOBALDRIVERDATA {
    DWORD                   dwSize;                 // Size of this structure
    D3DNTHALDEVICEDESC_V1   hwCaps;                 // Capabilities of the hardware
    DWORD                   dwNumVertices;          // see following comment
    DWORD                   dwNumClipVertices;      // see following comment
    DWORD                   dwNumTextureFormats;    // Number of texture formats
    LPDDSURFACEDESC lpTextureFormats;               // Pointer to texture formats
} D3DNTHAL_GLOBALDRIVERDATA;
typedef D3DNTHAL_GLOBALDRIVERDATA *LPD3DNTHAL_GLOBALDRIVERDATA;

#define D3DNTHAL_GLOBALDRIVERDATASIZE (sizeof(D3DNTHAL_GLOBALDRIVERDATA))

#if(DIRECT3D_VERSION >= 0x0700)
/* --------------------------------------------------------------
 * Extended caps introduced with DX5 and queried with
 * GetDriverInfo (GUID_D3DExtendedCaps).
 */
typedef struct _D3DNTHAL_D3DDX6EXTENDEDCAPS {
    DWORD       dwSize;                             // Size of this structure

    DWORD       dwMinTextureWidth, dwMaxTextureWidth;
    DWORD       dwMinTextureHeight, dwMaxTextureHeight;
    DWORD       dwMinStippleWidth, dwMaxStippleWidth;
    DWORD       dwMinStippleHeight, dwMaxStippleHeight;

    // Fields added for DX6
    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;
    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;
    DWORD       dwFVFCaps;                          // low 4 bits: 0 implies TLVERTEX only, 1..8 imply FVF aware
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;

} D3DNTHAL_D3DDX6EXTENDEDCAPS;
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* --------------------------------------------------------------
 * Extended caps introduced with DX5 and queried with
 * GetDriverInfo (GUID_D3DExtendedCaps).
 */
typedef struct _D3DNTHAL_D3DEXTENDEDCAPS {
    DWORD       dwSize;                             // Size of this structure
    DWORD       dwMinTextureWidth, dwMaxTextureWidth;
    DWORD       dwMinTextureHeight, dwMaxTextureHeight;
    DWORD       dwMinStippleWidth, dwMaxStippleWidth;
    DWORD       dwMinStippleHeight, dwMaxStippleHeight;

    // Fields added for DX6
    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;
    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;
    DWORD       dwFVFCaps;                          // 0 implies TLVERTEX only, 1..8 imply full FVF aware
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;
#if(DIRECT3D_VERSION >= 0x0700)
    // Fields added for DX7
    DWORD       dwMaxActiveLights;
    D3DVALUE    dvMaxVertexW;

    WORD        wMaxUserClipPlanes;
    WORD        wMaxVertexBlendMatrices;

    DWORD       dwVertexProcessingCaps;

    DWORD       dwReserved1;
    DWORD       dwReserved2;
    DWORD       dwReserved3;
    DWORD       dwReserved4;
#endif /* DIRECT3D_VERSION >= 0x0700 */
} D3DNTHAL_D3DEXTENDEDCAPS;

typedef D3DNTHAL_D3DEXTENDEDCAPS *LPD3DNTHAL_D3DEXTENDEDCAPS;

#define D3DNTHAL_D3DEXTENDEDCAPSSIZE (sizeof(D3DNTHAL_D3DEXTENDEDCAPS))

// This is a temporary fix to make older NT drivers to compile
#define dvVertexProcessingCaps dwVertexProcessingCaps

#if(DIRECT3D_VERSION >= 0x0700)
typedef D3DNTHAL_D3DDX6EXTENDEDCAPS *LPD3DNTHAL_D3DDX6EXTENDEDCAPS;
#define D3DNTHAL_D3DDX6EXTENDEDCAPSSIZE (sizeof(D3DNTHAL_D3DDX6EXTENDEDCAPS))
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* --------------------------------------------------------------
 * Argument to the HAL functions.
 */

typedef ULONG_PTR D3DINTHAL_BUFFERHANDLE, *LPD3DINTHAL_BUFFERHANDLE;

typedef struct _D3DNTHAL_CONTEXTCREATEDATA {
    union
    {
        PDD_DIRECTDRAW_GLOBAL   lpDDGbl;    // in:  obsolete
        PDD_DIRECTDRAW_LOCAL    lpDDLcl;    // in:  Driver struct
    };
    union
    {
        PDD_SURFACE_LOCAL       lpDDS;      // in:  obsolete
        PDD_SURFACE_LOCAL       lpDDSLcl;   // in:  Surface to be used as target
    };
    union
    {
        PDD_SURFACE_LOCAL       lpDDSZ;     // in:  obsolete
        PDD_SURFACE_LOCAL       lpDDSZLcl;  // in:  Surface to be used as Z
    };
    DWORD                       dwPID;      // in:  Current process id
    ULONG_PTR                   dwhContext; // in/out: Context handle
    HRESULT                     ddrval;     // out: Return value
} D3DNTHAL_CONTEXTCREATEDATA;
typedef D3DNTHAL_CONTEXTCREATEDATA *LPD3DNTHAL_CONTEXTCREATEDATA;

typedef struct _D3DNTHAL_CONTEXTDESTROYDATA {
    ULONG_PTR   dwhContext; // in:  Context handle
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_CONTEXTDESTROYDATA;
typedef D3DNTHAL_CONTEXTDESTROYDATA *LPD3DNTHAL_CONTEXTDESTROYDATA;

typedef struct _D3DNTHAL_CONTEXTDESTROYALLDATA {
    DWORD       dwPID;      // in:  Process id to destroy contexts for
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_CONTEXTDESTROYALLDATA;
typedef D3DNTHAL_CONTEXTDESTROYALLDATA *LPD3DNTHAL_CONTEXTDESTROYALLDATA;

typedef struct _D3DNTHAL_SCENECAPTUREDATA {
    ULONG_PTR   dwhContext; // in:  Context handle
    DWORD       dwFlag;     // in:  Indicates beginning or end
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_SCENECAPTUREDATA;
typedef D3DNTHAL_SCENECAPTUREDATA *LPD3DNTHAL_SCENECAPTUREDATA;

typedef struct _D3DNTHAL_TEXTURECREATEDATA {
    ULONG_PTR   dwhContext; // in:  Context handle
    HANDLE      hDDS;       // in:  Handle to surface object
    ULONG_PTR   dwHandle;   // out: Handle to texture
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_TEXTURECREATEDATA;
typedef D3DNTHAL_TEXTURECREATEDATA *LPD3DNTHAL_TEXTURECREATEDATA;

typedef struct _D3DNTHAL_TEXTUREDESTROYDATA {
    ULONG_PTR   dwhContext; // in:  Context handle
    ULONG_PTR   dwHandle;   // in:  Handle to texture
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_TEXTUREDESTROYDATA;
typedef D3DNTHAL_TEXTUREDESTROYDATA *LPD3DNTHAL_TEXTUREDESTROYDATA;

typedef struct _D3DNTHAL_TEXTURESWAPDATA {
    ULONG_PTR   dwhContext; // in:  Context handle
    ULONG_PTR   dwHandle1;  // in:  Handle to texture 1
    ULONG_PTR   dwHandle2;  // in:  Handle to texture 2
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_TEXTURESWAPDATA;
typedef D3DNTHAL_TEXTURESWAPDATA *LPD3DNTHAL_TEXTURESWAPDATA;

typedef struct _D3DNTHAL_TEXTUREGETSURFDATA {
    ULONG_PTR   dwhContext; // in:  Context handle
    HANDLE      hDDS;       // out: Handle to surface object
    ULONG_PTR   dwHandle;   // in:  Handle to texture
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_TEXTUREGETSURFDATA;
typedef D3DNTHAL_TEXTUREGETSURFDATA *LPD3DNTHAL_TEXTUREGETSURFDATA;

/* --------------------------------------------------------------
 * Flags for the data parameters.
 */

/*
 * SceneCapture()
 * This is used as an indication to the driver that a scene is about to
 * start or end, and that it should capture data if required.
 */
#define D3DNTHAL_SCENE_CAPTURE_START    0x00000000L
#define D3DNTHAL_SCENE_CAPTURE_END  0x00000001L

/* --------------------------------------------------------------
 * Return values from HAL functions.
 */

/*
 * The context passed in was bad.
 */
#define D3DNTHAL_CONTEXT_BAD        0x000000200L

/*
 * No more contexts left.
 */
#define D3DNTHAL_OUTOFCONTEXTS      0x000000201L

/* --------------------------------------------------------------
 * Direct3D HAL Table.
 * Instantiated by the HAL driver on connection.
 *
 * Calls take the form of:
 *  retcode = HalCall(HalCallData* lpData);
 */

typedef DWORD   (APIENTRY *LPD3DNTHAL_CONTEXTCREATECB)  (LPD3DNTHAL_CONTEXTCREATEDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_CONTEXTDESTROYCB) (LPD3DNTHAL_CONTEXTDESTROYDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_CONTEXTDESTROYALLCB) (LPD3DNTHAL_CONTEXTDESTROYALLDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_SCENECAPTURECB)   (LPD3DNTHAL_SCENECAPTUREDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_TEXTURECREATECB)  (LPD3DNTHAL_TEXTURECREATEDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_TEXTUREDESTROYCB) (LPD3DNTHAL_TEXTUREDESTROYDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_TEXTURESWAPCB)    (LPD3DNTHAL_TEXTURESWAPDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_TEXTUREGETSURFCB) (LPD3DNTHAL_TEXTUREGETSURFDATA);

typedef struct _D3DNTHAL_CALLBACKS {
    DWORD                           dwSize;

    // Device context
    LPD3DNTHAL_CONTEXTCREATECB      ContextCreate;
    LPD3DNTHAL_CONTEXTDESTROYCB     ContextDestroy;
    LPD3DNTHAL_CONTEXTDESTROYALLCB  ContextDestroyAll;

    // Scene Capture
    LPD3DNTHAL_SCENECAPTURECB       SceneCapture;

    // Execution
    LPVOID                          dwReserved10;       // Must be zero (was Execute)
    LPVOID                          dwReserved11;       // Must be zero (was ExecuteClipped)
    LPVOID                          dwReserved22;       // Must be zero (was RenderState)
    LPVOID                          dwReserved23;       // Must be zero (was RenderPrimitive)

    ULONG_PTR                       dwReserved;         // Must be zero

    // Textures
    LPD3DNTHAL_TEXTURECREATECB      TextureCreate;
    LPD3DNTHAL_TEXTUREDESTROYCB     TextureDestroy;
    LPD3DNTHAL_TEXTURESWAPCB        TextureSwap;
    LPD3DNTHAL_TEXTUREGETSURFCB     TextureGetSurf;

    LPVOID                          dwReserved12;       // Must be zero
    LPVOID                          dwReserved13;       // Must be zero
    LPVOID                          dwReserved14;       // Must be zero
    LPVOID                          dwReserved15;       // Must be zero
    LPVOID                          dwReserved16;       // Must be zero
    LPVOID                          dwReserved17;       // Must be zero
    LPVOID                          dwReserved18;       // Must be zero
    LPVOID                          dwReserved19;       // Must be zero
    LPVOID                          dwReserved20;       // Must be zero
    LPVOID                          dwReserved21;       // Must be zero

    // Pipeline state
    LPVOID                          dwReserved24;       // Was GetState;

    ULONG_PTR                       dwReserved0;        // Must be zero
    ULONG_PTR                       dwReserved1;        // Must be zero
    ULONG_PTR                       dwReserved2;        // Must be zero
    ULONG_PTR                       dwReserved3;        // Must be zero
    ULONG_PTR                       dwReserved4;        // Must be zero
    ULONG_PTR                       dwReserved5;        // Must be zero
    ULONG_PTR                       dwReserved6;        // Must be zero
    ULONG_PTR                       dwReserved7;        // Must be zero
    ULONG_PTR                       dwReserved8;        // Must be zero
    ULONG_PTR                       dwReserved9;        // Must be zero

} D3DNTHAL_CALLBACKS;
typedef D3DNTHAL_CALLBACKS *LPD3DNTHAL_CALLBACKS;

#define D3DNTHAL_SIZE_V1 sizeof( D3DNTHAL_CALLBACKS )

typedef struct _D3DNTHAL_SETRENDERTARGETDATA {
    ULONG_PTR           dwhContext;     // in:  Context handle
    PDD_SURFACE_LOCAL   lpDDS;          // in:  new render target
    PDD_SURFACE_LOCAL   lpDDSZ;         // in:  new Z buffer
    HRESULT             ddrval;         // out: Return value
} D3DNTHAL_SETRENDERTARGETDATA;
typedef D3DNTHAL_SETRENDERTARGETDATA *LPD3DNTHAL_SETRENDERTARGETDATA;


typedef DWORD (APIENTRY *LPD3DNTHAL_SETRENDERTARGETCB) (LPD3DNTHAL_SETRENDERTARGETDATA);

typedef struct _D3DNTHAL_CALLBACKS2
{
    DWORD                           dwSize;                 // size of struct
    DWORD                           dwFlags;                // flags for callbacks

    LPD3DNTHAL_SETRENDERTARGETCB    SetRenderTarget;
    LPVOID                          dwReserved1;            // was Clear
    LPVOID                          dwReserved2;            // was DrawOnePrimitive
    LPVOID                          dwReserved3;            // was DrawOneIndexedPrimitive
    LPVOID                          dwReserved4;            // was DrawPrimitives
} D3DNTHAL_CALLBACKS2;
typedef D3DNTHAL_CALLBACKS2 *LPD3DNTHAL_CALLBACKS2;

#define D3DNTHAL2_CB32_SETRENDERTARGET    0x00000001L


typedef struct _D3DNTHAL_CLEAR2DATA
{
    ULONG_PTR           dwhContext;     // in:  Context handle

    // dwFlags can contain D3DCLEAR_TARGET or D3DCLEAR_ZBUFFER
    DWORD               dwFlags;        // in:  surfaces to clear

    DWORD               dwFillColor;    // in:  Color value for rtarget
    D3DVALUE            dvFillDepth;    // in:  Depth value for
                                        //      Z-buffer (0.0-1.0)
    DWORD               dwFillStencil;  // in:  value used to clear stencil buffer

    LPD3DRECT           lpRects;        // in:  Rectangles to clear
    DWORD               dwNumRects;     // in:  Number of rectangles

    HRESULT             ddrval;         // out: Return value
} D3DNTHAL_CLEAR2DATA;
typedef D3DNTHAL_CLEAR2DATA FAR *LPD3DNTHAL_CLEAR2DATA;

typedef struct _D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    DWORD           dwFlags;    // in:  Flags, currently set to 0
    ULONG_PTR       dwReserved; //
    DWORD           dwNumPasses;// out: Number of passes the hardware
                                //      can perform the operation in
    HRESULT         ddrval;     // out: return value
} D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA;
typedef D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA FAR *LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA;

//-----------------------------------------------------------------------------
// DrawPrimitives2 DDI
//-----------------------------------------------------------------------------

//
// Command structure for vertex buffer rendering
//

typedef struct _D3DNTHAL_DP2COMMAND
{
    BYTE        bCommand;           // vertex command
    BYTE        bReserved;
    union
    {
        WORD    wPrimitiveCount;    // primitive count for unconnected primitives
        WORD    wStateCount;        // count of render states to follow
    };
} D3DNTHAL_DP2COMMAND, *LPDNT3DHAL_DP2COMMAND;

//
// DrawPrimitives2 commands:
//

typedef enum _D3DNTHAL_DP2OPERATION
{
    D3DNTDP2OP_POINTS               = 1,
    D3DNTDP2OP_INDEXEDLINELIST      = 2,
    D3DNTDP2OP_INDEXEDTRIANGLELIST  = 3,
    D3DNTDP2OP_RESERVED0            = 4,
    D3DNTDP2OP_RENDERSTATE          = 8,
    D3DNTDP2OP_LINELIST             = 15,
    D3DNTDP2OP_LINESTRIP            = 16,
    D3DNTDP2OP_INDEXEDLINESTRIP     = 17,
    D3DNTDP2OP_TRIANGLELIST         = 18,
    D3DNTDP2OP_TRIANGLESTRIP        = 19,
    D3DNTDP2OP_INDEXEDTRIANGLESTRIP = 20,
    D3DNTDP2OP_TRIANGLEFAN          = 21,
    D3DNTDP2OP_INDEXEDTRIANGLEFAN   = 22,
    D3DNTDP2OP_TRIANGLEFAN_IMM      = 23,
    D3DNTDP2OP_LINELIST_IMM         = 24,
    D3DNTDP2OP_TEXTURESTAGESTATE    = 25,
    D3DNTDP2OP_INDEXEDTRIANGLELIST2 = 26,
    D3DNTDP2OP_INDEXEDLINELIST2     = 27,
    D3DNTDP2OP_VIEWPORTINFO         = 28,
    D3DNTDP2OP_WINFO                = 29,
    D3DNTDP2OP_SETPALETTE           = 30,
    D3DNTDP2OP_UPDATEPALETTE        = 31,
#if(DIRECT3D_VERSION >= 0x0700)
    //new for DX7
    D3DNTDP2OP_ZRANGE               = 32,
    D3DNTDP2OP_SETMATERIAL          = 33,
    D3DNTDP2OP_SETLIGHT             = 34,
    D3DNTDP2OP_CREATELIGHT          = 35,
    D3DNTDP2OP_SETTRANSFORM         = 36,
    D3DNTDP2OP_EXT                  = 37,
    D3DNTDP2OP_TEXBLT               = 38,
    D3DNTDP2OP_STATESET             = 39,
    D3DNTDP2OP_SETPRIORITY          = 40,
#endif /* DIRECT3D_VERSION >= 0x0700 */
    D3DNTDP2OP_SETRENDERTARGET      = 41,
    D3DNTDP2OP_CLEAR                = 42,
#if(DIRECT3D_VERSION >= 0x0700)
    D3DNTDP2OP_SETTEXLOD            = 43,
    D3DNTDP2OP_SETCLIPPLANE         = 44,
#endif /* DIRECT3D_VERSION >= 0x0700 */
#if(DIRECT3D_VERSION >= 0x0800)
    D3DNTDP2OP_CREATEVERTEXSHADER   = 45,
    D3DNTDP2OP_DELETEVERTEXSHADER   = 46,
    D3DNTDP2OP_SETVERTEXSHADER      = 47,
    D3DNTDP2OP_SETVERTEXSHADERCONST = 48,
    D3DNTDP2OP_SETSTREAMSOURCE      = 49,
    D3DNTDP2OP_SETSTREAMSOURCEUM    = 50,
    D3DNTDP2OP_SETINDICES           = 51,
    D3DNTDP2OP_DRAWPRIMITIVE        = 52,
    D3DNTDP2OP_DRAWINDEXEDPRIMITIVE = 53,
    D3DNTDP2OP_CREATEPIXELSHADER    = 54,
    D3DNTDP2OP_DELETEPIXELSHADER    = 55,
    D3DNTDP2OP_SETPIXELSHADER       = 56,
    D3DNTDP2OP_SETPIXELSHADERCONST  = 57,
    D3DNTDP2OP_CLIPPEDTRIANGLEFAN   = 58,
    D3DNTDP2OP_DRAWPRIMITIVE2       = 59,
    D3DNTDP2OP_DRAWINDEXEDPRIMITIVE2= 60,
    D3DNTDP2OP_DRAWRECTPATCH        = 61,
    D3DNTDP2OP_DRAWTRIPATCH         = 62,
    D3DNTDP2OP_VOLUMEBLT            = 63,
    D3DNTDP2OP_BUFFERBLT            = 64,
    D3DNTDP2OP_MULTIPLYTRANSFORM    = 65,
    D3DNTDP2OP_ADDDIRTYRECT         = 66,
    D3DNTDP2OP_ADDDIRTYBOX          = 67,
#endif /* DIRECT3D_VERSION >= 0x0800 */
} D3DNTHAL_DP2OPERATION;

//
// DrawPrimitives2 point primitives
//

typedef struct _D3DNTHAL_DP2POINTS
{
    WORD wCount;
    WORD wVStart;
} D3DNTHAL_DP2POINTS;

//
// DrawPrimitives2 line primitives
//

typedef struct _D3DNTHAL_DP2STARTVERTEX {
    WORD wVStart;
} D3DNTHAL_DP2STARTVERTEX, *LPD3DNTHAL_DP2STARTVERTEX;

typedef struct _D3DNTHAL_DP2LINELIST
{
    WORD wVStart;
} D3DNTHAL_DP2LINELIST;

typedef struct _D3DNTHAL_DP2INDEXEDLINELIST
{
    WORD wV1;
    WORD wV2;
} D3DNTHAL_DP2INDEXEDLINELIST;

typedef struct _D3DNTHAL_DP2LINESTRIP
{
    WORD wVStart;
} D3DNTHAL_DP2LINESTRIP;

typedef struct _D3DNTHAL_DP2INDEXEDLINESTRIP
{
    WORD wV[2];
} D3DNTHAL_DP2INDEXEDLINESTRIP;

//
// DrawPrimitives2 triangle primitives
//

typedef struct _D3DNTHAL_DP2TRIANGLELIST
{
    WORD wVStart;
} D3DNTHAL_DP2TRIANGLELIST;

typedef struct _D3DNTHAL_DP2INDEXEDTRIANGLELIST
{
    WORD wV1;
    WORD wV2;
    WORD wV3;
    WORD wFlags;
} D3DNTHAL_DP2INDEXEDTRIANGLELIST;

typedef struct _D3DNTHAL_DP2INDEXEDTRIANGLELIST2 {
    WORD wV1;
    WORD wV2;
    WORD wV3;
} D3DNTHAL_DP2INDEXEDTRIANGLELIST2, *LPD3DNTHAL_DP2INDEXEDTRIANGLELIST2;

typedef struct _D3DNTHAL_DP2TRIANGLESTRIP
{
    WORD wVStart;
} D3DNTHAL_DP2TRIANGLESTRIP;

typedef struct _D3DNTHAL_DP2INDEXEDTRIANGLESTRIP
{
    WORD wV[3];
} D3DNTHAL_DP2INDEXEDTRIANGLESTRIP;

typedef struct _D3DNTHAL_DP2TRIANGLEFAN
{
    WORD wVStart;
} D3DNTHAL_DP2TRIANGLEFAN;

typedef struct _D3DNTHAL_DP2INDEXEDTRIANGLEFAN
{
    WORD wV[3];
} D3DNTHAL_DP2INDEXEDTRIANGLEFAN;

typedef struct _D3DNTHAL_DP2TRIANGLEFAN_IMM {
    DWORD dwEdgeFlags;
} D3DNTHAL_DP2TRIANGLEFAN_IMM, *LPD3DNTHAL_DP2TRIANGLEFAN_IMM;

//
// DrawPrimitives2 Renderstate changes
//

typedef struct _D3DNTHAL_DP2RENDERSTATE
{
    D3DRENDERSTATETYPE RenderState;
    union
    {
        D3DVALUE fState;
        DWORD    dwState;
    };
} D3DNTHAL_DP2RENDERSTATE;
typedef D3DNTHAL_DP2RENDERSTATE  * LPD3DNTHAL_DP2RENDERSTATE;

typedef struct _D3DNTHAL_DP2TEXTURESTAGESTATE
{
    WORD  wStage;
    WORD  TSState;
    DWORD dwValue;
} D3DNTHAL_DP2TEXTURESTAGESTATE;
typedef D3DNTHAL_DP2TEXTURESTAGESTATE  *LPD3DNTHAL_DP2TEXTURESTAGESTATE;

typedef struct _D3DNTHAL_DP2VIEWPORTINFO {
    DWORD dwX;
    DWORD dwY;
    DWORD dwWidth;
    DWORD dwHeight;
} D3DNTHAL_DP2VIEWPORTINFO;
typedef D3DNTHAL_DP2VIEWPORTINFO  *LPD3DNTHAL_DP2VIEWPORTINFO;

typedef struct _D3DNTHAL_DP2WINFO {
    D3DVALUE dvWNear;
    D3DVALUE dvWFar;
} D3DNTHAL_DP2WINFO;
typedef D3DNTHAL_DP2WINFO  *LPD3DNTHAL_DP2WINFO;

typedef struct _D3DNTHAL_DP2SETPALETTE
{
    DWORD dwPaletteHandle;
    DWORD dwPaletteFlags;
    DWORD dwSurfaceHandle;
} D3DNTHAL_DP2SETPALETTE;
typedef D3DNTHAL_DP2SETPALETTE  *LPD3DNTHAL_DP2SETPALETTE;

typedef struct _D3DNTHAL_DP2UPDATEPALETTE
{
    DWORD dwPaletteHandle;
    WORD  wStartIndex;
    WORD  wNumEntries;
} D3DNTHAL_DP2UPDATEPALETTE;
typedef D3DNTHAL_DP2UPDATEPALETTE  *LPD3DNTHAL_DP2UPDATEPALETTE;

typedef struct _D3DNTHAL_DP2SETRENDERTARGET
{
    DWORD hRenderTarget;
    DWORD hZBuffer;
} D3DNTHAL_DP2SETRENDERTARGET;
typedef D3DNTHAL_DP2SETRENDERTARGET  *LPD3DNTHAL_DP2SETRENDERTARGET;

#if(DIRECT3D_VERSION >= 0x0700)
// Values for dwOperations in the D3DHAL_DP2STATESET
#define D3DHAL_STATESETBEGIN     0
#define D3DHAL_STATESETEND       1
#define D3DHAL_STATESETDELETE    2
#define D3DHAL_STATESETEXECUTE   3
#define D3DHAL_STATESETCAPTURE   4

typedef struct _D3DNTHAL_DP2STATESET
{
    DWORD               dwOperation;
    DWORD               dwParam;    // State set handle passed with D3DHAL_STATESETBEGIN,
                                    // D3DHAL_STATESETEXECUTE, D3DHAL_STATESETDELETE
                                    // D3DHAL_STATESETCAPTURE
    D3DSTATEBLOCKTYPE   sbType;     // Type use with D3DHAL_STATESETBEGIN/END
} D3DNTHAL_DP2STATESET;
typedef D3DNTHAL_DP2STATESET  *LPD3DNTHAL_DP2STATESET;
//
// T&L Hal specific stuff
//
typedef struct _D3DNTHAL_DP2ZRANGE
{
    D3DVALUE    dvMinZ;
    D3DVALUE    dvMaxZ;
} D3DNTHAL_DP2ZRANGE;
typedef D3DNTHAL_DP2ZRANGE  *LPD3DNTHAL_DP2ZRANGE;

typedef D3DMATERIAL7 D3DNTHAL_DP2SETMATERIAL, *LPD3DNTHAL_DP2SETMATERIAL;

typedef struct _D3DNTHAL_DP2SETLIGHT
{
    DWORD       dwIndex;
    union {
        DWORD   lightData;
        DWORD   dwDataType;
    };
} D3DNTHAL_DP2SETLIGHT;
typedef D3DNTHAL_DP2SETLIGHT  *LPD3DNTHAL_DP2SETLIGHT;

typedef struct _D3DNTHAL_DP2SETCLIPPLANE
{
    DWORD     dwIndex;
    D3DVALUE  plane[4];
} D3DNTHAL_DP2SETCLIPPLANE;
typedef D3DNTHAL_DP2SETCLIPPLANE  *LPD3DNTHAL_DP2SETCLIPPLANE;

typedef struct _D3DNTHAL_DP2CREATELIGHT
{
    DWORD dwIndex;
} D3DNTHAL_DP2CREATELIGHT;
typedef D3DNTHAL_DP2CREATELIGHT  *LPD3DNTHAL_DP2CREATELIGHT;

typedef struct _D3DNTHAL_DP2SETTRANSFORM
{
    D3DTRANSFORMSTATETYPE xfrmType;
    D3DMATRIX             matrix;
} D3DNTHAL_DP2SETTRANSFORM;
typedef D3DNTHAL_DP2SETTRANSFORM  *LPD3DNTHAL_DP2SETTRANSFORM;

typedef struct _D3DNTHAL_DP2EXT
{
    DWORD dwExtToken;
    DWORD dwSize;
} D3DNTHAL_DP2EXT;
typedef D3DNTHAL_DP2EXT  *LPD3DNTHAL_DP2EXT;

typedef struct _D3DNTHAL_DP2TEXBLT
{
    DWORD   dwDDDestSurface;    // dest surface
    DWORD   dwDDSrcSurface;     // src surface
    POINT   pDest;
    RECTL   rSrc;               // src rect
    DWORD   dwFlags;            // blt flags
} D3DNTHAL_DP2TEXBLT;
typedef D3DNTHAL_DP2TEXBLT  *LPD3DNTHAL_DP2TEXBLT;

typedef struct _D3DNTHAL_DP2SETPRIORITY
{
    DWORD dwDDDestSurface;  // dest surface
    DWORD dwPriority;
} D3DNTHAL_DP2SETPRIORITY;
typedef D3DNTHAL_DP2SETPRIORITY  *LPD3DNTHAL_DP2SETPRIORITY;

typedef struct _D3DNTHAL_DP2CLEAR
{
    // dwFlags can contain D3DCLEAR_TARGET, D3DCLEAR_ZBUFFER, and/or D3DCLEAR_STENCIL
    DWORD               dwFlags;        // in:  surfaces to clear
    DWORD               dwFillColor;    // in:  Color value for rtarget
    D3DVALUE            dvFillDepth;    // in:  Depth value for Z buffer (0.0-1.0)
    DWORD               dwFillStencil;  // in:  value used to clear stencil buffer
    RECT                Rects[1];       // in:  Rectangles to clear
} D3DNTHAL_DP2CLEAR;
typedef D3DNTHAL_DP2CLEAR  *LPD3DNTHAL_DP2CLEAR;

typedef struct _D3DNTHAL_DP2SETTEXLOD
{
    DWORD dwDDSurface;
    DWORD dwLOD;
} D3DNTHAL_DP2SETTEXLOD;
typedef D3DNTHAL_DP2SETTEXLOD  *LPD3DNTHAL_DP2SETTEXLOD;

#endif /* DIRECT3D_VERSION >= 0x0700 */


typedef struct _D3DNTHAL_DRAWPRIMITIVES2DATA
{
    ULONG_PTR               dwhContext;             // in: Context handle
    DWORD                   dwFlags;                // in: flags (look below)
    DWORD                   dwVertexType;           // in: vertex type
    PDD_SURFACE_LOCAL       lpDDCommands;           // in: vertex buffer command data
    DWORD                   dwCommandOffset;        // in: offset to start of vb commands
    DWORD                   dwCommandLength;        // in: number of bytes of command data
    union
    {
        PDD_SURFACE_LOCAL   lpDDVertex;             // in: surface containing vertex data
        LPVOID              lpVertices;             // in: User mode pointer to vertices
    };
    DWORD                   dwVertexOffset;         // in: offset to start of vertex data
    DWORD                   dwVertexLength;         // in: number of vertices of vertex data
    DWORD                   dwReqVertexBufSize;     // in: number of bytes required for
                                                    //     the next vertex buffer
    DWORD                   dwReqCommandBufSize;    // in: number if bytes required for
                                                    //     the next commnand buffer
    LPDWORD                 lpdwRStates;            // in: Pointer to the array where render states are updated
    union
    {
        DWORD               dwVertexSize;           // in: Size of each vertex in bytes
        HRESULT             ddrval;                 // out: return value
    };
    DWORD                   dwErrorOffset;          // out: offset in LPDDVBCOMMAND to
                                                    //      first failed D3DNTHAL_VBCOMMAND
} D3DNTHAL_DRAWPRIMITIVES2DATA;
typedef D3DNTHAL_DRAWPRIMITIVES2DATA  FAR *LPD3DNTHAL_DRAWPRIMITIVES2DATA;

// Indicates that the lpVertices field in the DrawPrimitives2 data is
// valid, i.e. user allocated memory.
#define D3DNTHALDP2_USERMEMVERTICES   0x00000001L
// Indicates that the command buffer and vertex buffer are a system memory execute buffer
// resulting from the use of the Execute buffer API.
#define D3DNTHALDP2_EXECUTEBUFFER     0x00000002L

// The swap flags indicate if it is OK for the driver to swap the submitted buffers with new
// buffers and asyncronously work on the submitted buffers.
#define D3DNTHALDP2_SWAPVERTEXBUFFER  0x00000004L
#define D3DNTHALDP2_SWAPCOMMANDBUFFER 0x00000008L
// The requested flags are present if the new buffers which the driver can allocate need to be
// of atleast a given size. If any of these flags are set, the corresponding dwReq* field in
// D3DNTHAL_DRAWPRIMITIVES2DATA will also be set with the requested size in bytes.
#define D3DNTHALDP2_REQVERTEXBUFSIZE  0x00000010L
#define D3DNTHALDP2_REQCOMMANDBUFSIZE 0x00000020L
// These flags are set by the driver upon return from DrawPrimitives2 indicating if the new
// buffers are not in system memory.
#define D3DNTHALDP2_VIDMEMVERTEXBUF   0x00000040L
#define D3DNTHALDP2_VIDMEMCOMMANDBUF  0x00000080L


// Return values for the driver callback used in DP2 implementations
// Used by the driver to ask runtime to parse the execute buffer
#define D3DNTERR_COMMAND_UNPARSED         MAKE_DDHRESULT(3000)


typedef DWORD (APIENTRY *LPD3DNTHAL_CLEAR2CB) (LPD3DNTHAL_CLEAR2DATA);
typedef DWORD (APIENTRY *LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB) (LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA);
typedef DWORD (APIENTRY *LPD3DNTHAL_DRAWPRIMITIVES2CB) (LPD3DNTHAL_DRAWPRIMITIVES2DATA);

typedef struct _D3DNTHAL_CALLBACKS3
{
    DWORD                                   dwSize;     // size of struct
    DWORD                                   dwFlags;    // flags for callbacks

    LPD3DNTHAL_CLEAR2CB                     Clear2;
    LPVOID                                  lpvReserved;
    LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB  ValidateTextureStageState;
    LPD3DNTHAL_DRAWPRIMITIVES2CB            DrawPrimitives2;
} D3DNTHAL_CALLBACKS3;
typedef D3DNTHAL_CALLBACKS3 *LPD3DNTHAL_CALLBACKS3;

#define D3DNTHAL3_CB32_CLEAR2                       0x00000001L
#define D3DNTHAL3_CB32_RESERVED                     0x00000002L
#define D3DNTHAL3_CB32_VALIDATETEXTURESTAGESTATE    0x00000004L
#define D3DNTHAL3_CB32_DRAWPRIMITIVES2              0x00000008L

// typedef for the Callback that the drivers can use to parse unknown commands
// passed to them via the DrawPrimitives2 callback. The driver obtains this
// callback thru a GetDriverInfo call with GUID_D3DParseUnknownCommandCallback
// made by ddraw somewhere around the initialization time.
typedef HRESULT (CALLBACK *PFND3DNTPARSEUNKNOWNCOMMAND) (LPVOID lpvCommands,
                                                         LPVOID *lplpvReturnedCommand);

/* --------------------------------------------------------------
 * Texture stage renderstate mapping definitions.
 *
 * 256 renderstate slots [256, 511] are reserved for texture processing
 * stage controls, which provides for 8 texture processing stages each
 * with 32 DWORD controls.
 *
 * The renderstates within each stage are indexed by the
 * D3DTEXTURESTAGESTATETYPE enumerants by adding the appropriate
 * enumerant to the base for a given texture stage.
 *
 * Note, "state overrides" bias the renderstate by 256, so the two
 * ranges overlap.  Overrides are enabled for exebufs only, so all
 * this means is that Texture3 cannot be used with exebufs.
 */

/*
 * Base of all texture stage state values in renderstate array.
 */
#define D3DNTHAL_TSS_RENDERSTATEBASE 256UL

/*
 * Maximum number of stages allowed.
 */
#define D3DNTHAL_TSS_MAXSTAGES 8

/*
 * Number of state DWORDS per stage.
 */
#define D3DNTHAL_TSS_STATESPERSTAGE 64

/*
 * Texture handle's offset into the 32-DWORD cascade state vector
 */
#ifndef D3DTSS_TEXTUREMAP
#define D3DTSS_TEXTUREMAP 0
#endif

#define D3DRENDERSTATE_EVICTMANAGEDTEXTURES 61  // DDI render state only to Evict textures
#define D3DRENDERSTATE_SCENECAPTURE         62  // DDI only to replace SceneCapture


#if(DIRECT3D_VERSION >= 0x0800 )

// New values for dwOperations in the D3DHAL_DP2STATESET
#define D3DNTHAL_STATESETCREATE    5

// This bit is the same as D3DCLEAR_RESERVED0 in d3d8types.h
// When set it means that driver has to cull rects against current viewport.
// The bit is set only for pure devices
//
#define D3DNTCLEAR_COMPUTERECTS   0x00000008l  


typedef struct _D3DNTHAL_DP2MULTIPLYTRANSFORM
{
    D3DTRANSFORMSTATETYPE xfrmType;
    D3DMATRIX             matrix;
} D3DNTHAL_DP2MULTIPLYTRANSFORM;
typedef D3DNTHAL_DP2MULTIPLYTRANSFORM  *LPD3DNTHAL_DP2MULTIPLYTRANSFORM;


// Used by SetVertexShader and DeleteVertexShader
typedef struct _D3DNTHAL_DP2VERTEXSHADER
{
    // Vertex shader handle.
    // The handle could be 0, meaning that the current vertex shader is invalid
    // (not set). When driver recieves handle 0, it should invalidate all
    // streams pointer
    DWORD dwHandle;
} D3DNTHAL_DP2VERTEXSHADER;
typedef D3DNTHAL_DP2VERTEXSHADER  *LPD3DNTHAL_DP2VERTEXSHADER;

typedef struct _D3DNTHAL_DP2CREATEVERTEXSHADER
{
    DWORD dwHandle;     // Shader handle
    DWORD dwDeclSize;   // Shader declaration size in bytes
    DWORD dwCodeSize;   // Shader code size in bytes
    // Declaration follows
    // Shader code follows
} D3DNTHAL_DP2CREATEVERTEXSHADER;
typedef D3DNTHAL_DP2CREATEVERTEXSHADER  *LPD3DNTHAL_DP2CREATEVERTEXSHADER;

typedef struct _D3DNTHAL_DP2SETVERTEXSHADERCONST
{
    DWORD dwRegister;   // Const register to start copying
    DWORD dwCount;      // Number of 4-float vectors to copy
    // Data follows
} D3DNTHAL_DP2SETVERTEXSHADERCONST;
typedef D3DNTHAL_DP2SETVERTEXSHADERCONST  *LPD3DNTHAL_DP2SETVERTEXSHADERCONST;

typedef struct _D3DNTHAL_DP2SETSTREAMSOURCE
{
    DWORD dwStream;     // Stream index, starting from zero
    DWORD dwVBHandle;   // Vertex buffer handle
    DWORD dwStride;     // Vertex size in bytes
} D3DNTHAL_DP2SETSTREAMSOURCE;
typedef D3DNTHAL_DP2SETSTREAMSOURCE  *LPD3DNTHAL_DP2SETSTREAMSOURCE;

typedef struct _D3DNTHAL_DP2SETSTREAMSOURCEUM
{
    DWORD dwStream;     // Stream index, starting from zero
    DWORD dwStride;     // Vertex size in bytes
} D3DNTHAL_DP2SETSTREAMSOURCEUM;
typedef D3DNTHAL_DP2SETSTREAMSOURCEUM  *LPD3DNTHAL_DP2SETSTREAMSOURCEUM;

typedef struct _D3DNTHAL_DP2SETINDICES
{
    DWORD dwVBHandle;           // Index buffer handle
    DWORD dwStride;             // Index size in bytes (2 or 4)
} D3DNTHAL_DP2SETINDICES;
typedef D3DNTHAL_DP2SETINDICES  *LPD3DNTHAL_DP2SETINDICES;

typedef struct _D3DNTHAL_DP2DRAWPRIMITIVE
{
    D3DPRIMITIVETYPE primType;
    DWORD            VStart;
    DWORD            PrimitiveCount;
} D3DNTHAL_DP2DRAWPRIMITIVE;
typedef D3DNTHAL_DP2DRAWPRIMITIVE  *LPD3DNTHAL_DP2DRAWPRIMITIVE;

typedef struct _D3DNTHAL_DP2DRAWINDEXEDPRIMITIVE
{
    D3DPRIMITIVETYPE primType;
    INT              BaseVertexIndex;          // Vertex which corresponds to index 0
    DWORD            MinIndex;                 // Min vertex index in the vertex buffer
    DWORD            NumVertices;              // Number of vertices starting from MinIndex
    DWORD            StartIndex;               // Start index in the index buffer
    DWORD            PrimitiveCount;
} D3DNTHAL_DP2DRAWINDEXEDPRIMITIVE;
typedef D3DNTHAL_DP2DRAWINDEXEDPRIMITIVE  *LPD3DNTHAL_DP2DRAWINDEXEDPRIMITIVE;

typedef struct _D3DNTHAL_CLIPPEDTRIANGLEFAN
{
    DWORD FirstVertexOffset;    // Offset in bytes in the current stream 0
    DWORD dwEdgeFlags;
    DWORD PrimitiveCount;
} D3DNTHAL_CLIPPEDTRIANGLEFAN;
typedef D3DNTHAL_CLIPPEDTRIANGLEFAN  *LPD3DNTHAL_CLIPPEDTRIANGLEFAN;

typedef struct _D3DNTHAL_DP2DRAWPRIMITIVE2
{
    D3DPRIMITIVETYPE primType;
    DWORD            FirstVertexOffset;         // Offset in bytes in the stream 0
    DWORD            PrimitiveCount;
} D3DNTHAL_DP2DRAWPRIMITIVE2;
typedef D3DNTHAL_DP2DRAWPRIMITIVE2  *LPD3DNTHAL_DP2DRAWPRIMITIVE2;

typedef struct _D3DNTHAL_DP2DRAWINDEXEDPRIMITIVE2
{
    D3DPRIMITIVETYPE primType;
    INT              BaseVertexOffset;     // Stream 0 offset of the vertex which
                                           // corresponds to index 0. This offset could be
                                           // negative, but when an index is added to the
                                           // offset the result is positive
    DWORD            MinIndex;             // Min vertex index in the vertex buffer
    DWORD            NumVertices;          // Number of vertices starting from MinIndex
    DWORD            StartIndexOffset;     // Offset of the start index in the index buffer
    DWORD            PrimitiveCount;       // Number of triangles (points, lines)
} D3DNTHAL_DP2DRAWINDEXEDPRIMITIVE2;
typedef D3DNTHAL_DP2DRAWINDEXEDPRIMITIVE2  *LPD3DNTHAL_DP2DRAWINDEXEDPRIMITIVE2;

// Used by SetPixelShader and DeletePixelShader
typedef struct _D3DNTHAL_DP2PIXELSHADER
{
    // Pixel shader handle.
    // The handle could be 0, meaning that the current pixel shader is invalid
    // (not set).
    DWORD dwHandle;
} D3DNTHAL_DP2PIXELSHADER;
typedef D3DNTHAL_DP2PIXELSHADER  *LPD3DNTHAL_DP2PIXELSHADER;

typedef struct _D3DNTHAL_DP2CREATEPIXELSHADER
{
    DWORD dwHandle;     // Shader handle
    DWORD dwCodeSize;   // Shader code size in bytes
    // Shader code follows
} D3DNTHAL_DP2CREATEPIXELSHADER;
typedef D3DNTHAL_DP2CREATEPIXELSHADER  *LPD3DNTHAL_DP2CREATEPIXELSHADER;

typedef struct _D3DNTHAL_DP2SETPIXELSHADERCONST
{
    DWORD dwRegister;   // Const register to start copying
    DWORD dwCount;      // Number of 4-float vectors to copy
    // Data follows
} D3DNTHAL_DP2SETPIXELSHADERCONST;
typedef D3DNTHAL_DP2SETPIXELSHADERCONST  *LPD3DNTHAL_DP2SETPIXELSHADERCONST;

// Flags that can be supplied to DRAWRECTPATCH and DRAWTRIPATCH
#define _NT_RTPATCHFLAG_HASSEGS  0x00000001L
#define _NT_RTPATCHFLAG_HASINFO  0x00000002L

typedef struct _D3DNTHAL_DP2DRAWRECTPATCH
{
    DWORD Handle;
    DWORD Flags;
    // Optionally followed by D3DFLOAT[4] NumSegments and/or D3DRECTPATCH_INFO
} D3DNTHAL_DP2DRAWRECTPATCH;
typedef D3DNTHAL_DP2DRAWRECTPATCH  *LPD3DNTHAL_DP2DRAWRECTPATCH;

typedef struct _D3DNTHAL_DP2DRAWTRIPATCH
{
    DWORD Handle;
    DWORD Flags;
    // Optionally followed by D3DFLOAT[3] NumSegments and/or D3DTRIPATCH_INFO
} D3DNTHAL_DP2DRAWTRIPATCH;
typedef D3DNTHAL_DP2DRAWTRIPATCH  *LPD3DNTHAL_DP2DRAWTRIPATCH;

typedef struct _D3DNTHAL_DP2VOLUMEBLT
{
    DWORD   dwDDDestSurface;// dest surface
    DWORD   dwDDSrcSurface; // src surface
    DWORD   dwDestX;        // dest X (width)
    DWORD   dwDestY;        // dest Y (height)
    DWORD   dwDestZ;        // dest Z (depth)
    D3DBOX  srcBox;         // src box
    DWORD   dwFlags;        // blt flags
} D3DNTHAL_DP2VOLUMEBLT;
typedef D3DNTHAL_DP2VOLUMEBLT  *LPD3DNTHAL_DP2VOLUMEBLT;

typedef struct _D3DNTHAL_DP2BUFFERBLT
{
    DWORD     dwDDDestSurface; // dest surface
    DWORD     dwDDSrcSurface;  // src surface
    DWORD     dwOffset;        // Offset in the dest surface (in BYTES)
    D3DRANGE  rSrc;            // src range
    DWORD     dwFlags;         // blt flags
} D3DNTHAL_DP2BUFFERBLT;
typedef D3DNTHAL_DP2BUFFERBLT  *LPD3DNTHAL_DP2BUFFERBLT;

typedef struct _D3DNTHAL_DP2ADDDIRTYRECT
{
    DWORD     dwSurface;      // Driver managed surface
    RECTL     rDirtyArea;     // Area marked dirty
} D3DNTHAL_DP2ADDDIRTYRECT;
typedef D3DNTHAL_DP2ADDDIRTYRECT  *LPD3DNTHAL_DP2ADDDIRTYRECT;

typedef struct _D3DNTHAL_DP2ADDDIRTYBOX
{
    DWORD     dwSurface;      // Driver managed volume
    D3DBOX    DirtyBox;       // Box marked dirty
} D3DNTHAL_DP2ADDDIRTYBOX;
typedef D3DNTHAL_DP2ADDDIRTYBOX  *LPD3DNTHAL_DP2ADDDIRTYBOX;


// Macros to access vertex shader binary code

#define _NT_D3DSI_GETREGTYPE(token) (token & D3DSP_REGTYPE_MASK)
#define _NT_D3DSI_GETREGNUM(token)  (token & D3DSP_REGNUM_MASK)
#define _NT_D3DSI_GETOPCODE(command) (command & D3DSI_OPCODE_MASK)
#define _NT_D3DSI_GETWRITEMASK(token) (token & D3DSP_WRITEMASK_ALL)
#define _NT_D3DVS_GETSWIZZLECOMP(source, component)  (source >> ((component << 1) + 16) & 0x3)
#define _NT_D3DVS_GETSWIZZLE(token)  (token & D3DVS_SWIZZLE_MASK)
#define _NT_D3DVS_GETSRCMODIFIER(token) (token & D3DSP_SRCMOD_MASK)
#define _NT_D3DVS_GETADDRESSMODE(token) (token & D3DVS_ADDRESSMODE_MASK)

#define _NT_D3DRS_DELETERTPATCH       169     // DDI only to delete high order patch

//-----------------------------------------------------------------------------
//
// DirectX 8.0's new driver info querying mechanism.
//
// How to handle the new driver info query mechanism.
//
// DirectX 8.0 utilizes an extension to GetDriverInfo() to query for
// additional information from the driver. Currently this mechanism is only
// used for querying for DX8 style D3D caps but it may be used for other
// information over time.
//
// This extension to GetDriverInfo takes the form of a GetDriverInfo call
// with the GUID GUID_GetDriverInfo2. When a GetDriverInfo call with this
// GUID is received by the driver the driver must check the data passed
// in the lpvData field of the DD_GETDRIVERINFODATA data structure to see
// what information is being requested.
//
// It is important to note that the GUID GUID_GetDriverInfo2 is, in fact,
// the same as the GUID_DDStereoMode. If you driver doesn't handle
// GUID_DDStereoMode this is not an issue. However, if you wish your driver
// to handle GUID_DDStereoMode as well as GUID_GetDriverInfo2 special action
// must be taken. When a call tp GetDriverInfo with the GUID
// GUID_GetDriverInfo2/GUID_DDStereoMode is made the runtime sets the
// dwHeight field of the DD_STEREOMODE structure to the special value
// D3DGDI2_MAGIC. In this way you can determine when the request is a
// stereo mode call or a GetDriverInfo2 call. The dwHeight field of
// DD_STEREOMODE corresponds to the dwMagic field of the
// DD_GETDRIVERINFO2DATA structure.
//
// The dwExpectedSize field of the DD_GETDRIVERINFODATA structure is not
// used by when a GetDriverInfo2 request is being made and should be
// ignored. The actual expected size of the data is found in the
// dwExpectedSize of the DD_GETDRIVERINFO2DATA structure.
//
// Once the driver has determined that this is a call to
// GetDriverInfo2 it must then determine the type of information being
// requested by the runtime. This type is contained in the dwType field
// of the DD_GETDRIVERINFO2DATA data structure.
//
// Finally, once the driver knows this is a GetDriverInfo2 request of a
// particular type it can copy the requested data into the data buffer.
// It is important to note that the lpvData field of the DD_GETDRIVERINFODATA
// data structure points to data buffer in which to copy your data. lpvData
// also points to the DD_GETDRIVERINFO2DATA structure. This means that the
// data returned by the driver will overwrite the DD_GETDRIVERINFO2DATA
// structure and, hence, the DD_GETDRIVERINFO2DATA structure occupies the
// first few DWORDs of the buffer.
//
// The following code fragment demonstrates how to handle GetDriverInfo2.
//
// D3DCAPS8 myD3DCaps8;
//
// DWORD CALLBACK
// DdGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData)
// {
//     if (MATCH_GUID((lpData->guidInfo), GUID_GetDriverInfo2) )
//     {
//         ASSERT(NULL != lpData);
//         ASSERT(NULL != lpData->lpvData);
//
//         // Is this a call to GetDriverInfo2 or DDStereoMode?
//         if (((DD_GETDRIVERINFO2DATA*)(lpData->lpvData))->dwMagic == D3DGDI2_MAGIC)
//         {
//             // Yes, its a call to GetDriverInfo2, fetch the
//             // DD_GETDRIVERINFO2DATA data structure.
//             DD_GETDRIVERINFO2DATA* pgdi2 = lpData->lpvData;
//             ASSERT(NULL != pgdi2);
//
//             // What type of request is this?
//             switch (pgdi2->dwType)
//             {
//             case D3DGDI2_TYPE_GETD3DCAPS8:
//                 {
//                     // The runtime is requesting the DX8 D3D caps so
//                     // copy them over now.
//
//                     // It should be noted that the dwExpectedSize field
//                     // of DD_GETDRIVERINFODATA is not used for
//                     // GetDriverInfo2 calls and should be ignored.
//                     size_t copySize = min(sizeof(myD3DCaps8), pgdi2->dwExpectedSize);
//                     memcpy(lpData->lpvData, &myD3DCaps8, copySize);
//                     lpData->dwActualSize = copySize;
//                     lpData->ddRVal       = DD_OK;
//                     return DDHAL_DRIVER_HANDLED;
//                 }
//             default:
//                 // For any other GetDriverInfo2 types not handled
//                 // or understood by the driver set an ddRVal of
//                 // DDERR_CURRENTLYNOTAVAIL and return
//                 // DDHAL_DRIVER_HANDLED.
//                 return DDHAL_DRIVER_HANDLED;
//             }
//         }
//         else
//         {
//             // It must be a call a request for stereo mode support.
//             // Fetch the stereo mode data
//             DD_STEREOMODE* pStereoMode = lpData->lpvData;
//             ASSERT(NULL != pStereoMode);
//
//             // Process the stereo mode request...
//             lpData->dwActualSize = sizeof(DD_STEREOMODE);
//             lpData->ddRVal       = DD_OK;
//             return DDHAL_DRIVER_HANDLED;
//         }
//     }
//
//     // Handle any other device GUIDs...
//
// } // DdGetDriverInfo
//
//-----------------------------------------------------------------------------

//
// The data structure which is passed to the driver when GetDriverInfo is
// called with a GUID of GUID_GetDriverInfo2.
//
// NOTE: Although the fields listed below are all read only this data
// structure is actually the first four DWORDs of the data buffer into
// which the driver writes the requested infomation. As such, these fields
// (and the entire data structure) are overwritten by the data returned by
// the driver.
//
typedef struct _DDNT_GETDRIVERINFO2DATA
{
    DWORD       dwReserved;     // Reserved Field.
                                // Driver should not read or write this field.

    DWORD       dwMagic;        // Magic Number. Has the value D3DGDI2_MAGIC if
                                // this is a GetDriverInfo2 call. Otherwise
                                // this structure is, in fact, a DD_STEREOMODE
                                // call.
                                // Driver should only read this field.

    DWORD       dwType;         // Type of information requested. This field
                                // contains one of the DDGDI2_TYPE_ #defines
                                // listed below.
                                // Driver should only read (not write) this
                                // field.

    DWORD       dwExpectedSize; // Expected size of the information requested.
                                // Driver should only read (not write) this
                                // field.

    // The remainder of the data buffer (beyond the first four DWORDs)
    // follows here.
} DDNT_GETDRIVERINFO2DATA;

//
// IMPORTANT NOTE: This GUID has exactly the same value as GUID_DDStereoMode
// and as such you must be very careful when using it. If your driver needs
// to handle both GetDriverInfo2 and DDStereoMode it must have a single
// check for the shared GUID and then distinguish between which use of that
// GUID is being requested.
//
#define _NT_GUID_GetDriverInfo2 (GUID_DDStereoMode)

//
// Magic value used to determine whether a GetDriverInfo call with the
// GUID GUID_GetDriverInfo2/GUID_DDStereoMode is a GetDriverInfo2 request
// or a query about stereo capabilities. This magic number is stored in
// the dwHeight field of the DD_STEREOMODE data structure.
//
#define _NT_D3DGDI2_MAGIC       (0xFFFFFFFFul)

//
// The types of information which can be requested from the driver via
// GetDriverInfo2.
//

#define _NT_D3DGDI2_TYPE_GETD3DCAPS8          (0x00000001ul)  // Return the D3DCAPS8 data
#define _NT_D3DGDI2_TYPE_GETFORMATCOUNT       (0x00000002ul)  // Return the number of supported formats
#define _NT_D3DGDI2_TYPE_GETFORMAT            (0x00000003ul)  // Return a particular format
#define _NT_D3DGDI2_TYPE_DXVERSION            (0x00000004ul)  // Notify driver of current DX Version
#define _NT_D3DGDI2_TYPE_DEFERRED_AGP_AWARE   (0x00000018ul) // Runtime is aware of deferred AGP frees, and will send following
#define _NT_D3DGDI2_TYPE_FREE_DEFERRED_AGP    (0x00000019ul) // Free any deferred-freed AGP allocations for this process
#define _NT_D3DGDI2_TYPE_DEFER_AGP_FREES      (0x00000020ul) // Start Deferring AGP frees for this process

//
// This data structure is returned by the driver in response to a
// GetDriverInfo2 query with the type D3DGDI2_TYPE_GETFORMATCOUNT. It simply
// gives the number of surface formats supported by the driver. Currently this
// structure consists of a single member giving the number of supported
// surface formats.
//
typedef struct _DDNT_GETFORMATCOUNTDATA
{
    DDNT_GETDRIVERINFO2DATA gdi2;          // [in/out] GetDriverInfo2 data
    DWORD                   dwFormatCount; // [out]    Number of supported surface formats
    DWORD                   dwReserved;    // Reserved
} DDNT_GETFORMATCOUNTDATA;

//
// This data structure is used to request a specific surface format from the
// driver. It is guaranteed that the requested format will be greater than or
// equal to zero and less that the format count reported by the driver from
// the preceeding D3DGDI2_TYPE_GETFORMATCOUNT request.
//
typedef struct _DDNT_GETFORMATDATA
{
    DDNT_GETDRIVERINFO2DATA gdi2;          // [in/out] GetDriverInfo2 data
    DWORD                   dwFormatIndex; // [in]     The format to return
    DDPIXELFORMAT           format;        // [out]    The actual format
} DDNT_GETFORMATDATA;

//
// This data structure is used to notify drivers about the DirectX version
// number. This is the value that is denoted as DD_RUNTIME_VERSION in the
// DDK headers.
//
typedef struct _DDNT_DXVERSION
{
    DDNT_GETDRIVERINFO2DATA gdi2;          // [in/out] GetDriverInfo2 data
    DWORD                   dwDXVersion;   // [in]     The Version of DX
    DWORD                   dwReserved;    // Reserved
} DDNT_DXVERSION;

// Informs driver that runtime will send a notification after last outstanding AGP
// lock has been released. 
typedef struct _DDNT_DEFERRED_AGP_AWARE_DATA
{
    DDNT_GETDRIVERINFO2DATA gdi2;          // [in/out] GetDriverInfo2 data
} DDNT_DEFERRED_AGP_AWARE_DATA;

// Notification that the last AGP lock has been released. Driver can free all deferred AGP 
// allocations for this process.
typedef struct _DDNT_FREE_DEFERRED_AGP_DATA
{
    DDNT_GETDRIVERINFO2DATA gdi2;          // [in/out] GetDriverInfo2 data
    DWORD                   dwProcessId;   // [in] Process ID for whom to free deferred AGP
} DDNT_FREE_DEFERRED_AGP_DATA;


// New Caps that are not API visible that the driver exposes.
#define _NT_D3DDEVCAPS_HWVERTEXBUFFER       0x02000000L /* Device supports Driver Allocated Vertex Buffers*/
#define _NT_D3DDEVCAPS_HWINDEXBUFFER        0x04000000L /* Device supports Driver Allocated Index Buffers*/
#define _NT_D3DDEVCAPS_SUBVOLUMELOCK        0x08000000L /* Device supports locking a part of volume texture */ 
#define _NT_D3DPMISCCAPS_FOGINFVF           0x00002000L // Device supports separate fog value in the FVF

// New FVF flags that are not API visible but accessed by the driver
// Note, that D3DFVF_RESERVED2 includes this flag and should not be used for validation

#define _NT_D3DFVF_FOG                      0x00002000L // There is a separate fog value in the FVF vertex 

//
// This stuff is not API visible but should be DDI visible.
// Should be in Sync with d3d8types.h
//
#define _NT_D3DFMT_D32     (D3DFORMAT)71
#define _NT_D3DFMT_S1D15   (D3DFORMAT)72
#define _NT_D3DFMT_D15S1   (D3DFORMAT)73
#define _NT_D3DFMT_S8D24   (D3DFORMAT)74
#define _NT_D3DFMT_D24S8   (D3DFORMAT)75
#define _NT_D3DFMT_X8D24   (D3DFORMAT)76
#define _NT_D3DFMT_D24X8   (D3DFORMAT)77
#define _NT_D3DFMT_X4S4D24 (D3DFORMAT)78
#define _NT_D3DFMT_D24X4S4 (D3DFORMAT)79

// Vertex Shader 1.1 register limits. D3D device must provide at least
// specified number of registers
//
#define _NT_D3DVS_INPUTREG_MAX_V1_1         16
#define _NT_D3DVS_TEMPREG_MAX_V1_1          12
// This max required number. Device could have more registers. Check caps.
#define _NT_D3DVS_CONSTREG_MAX_V1_1         96
#define _NT_D3DVS_TCRDOUTREG_MAX_V1_1       8
#define _NT_D3DVS_ADDRREG_MAX_V1_1          1
#define _NT_D3DVS_ATTROUTREG_MAX_V1_1       2
#define _NT_D3DVS_MAXINSTRUCTIONCOUNT_V1_1  128

// Pixel Shader DX8 register limits. D3D device will have at most these
// specified number of registers
//
#define _NT_D3DPS_INPUTREG_MAX_DX8         8
#define _NT_D3DPS_TEMPREG_MAX_DX8          8
#define _NT_D3DPS_CONSTREG_MAX_DX8         8
#define _NT_D3DPS_TEXTUREREG_MAX_DX8       8

#endif // (DIRECT3D_VERSION >= 0x0800 )

#endif /* _D3DNTHAL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\oak\inc\ddkmapi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddkmapi.h
 *  Content:	Kernel mode APIs for accessing DirectDraw support.
 *
 ***************************************************************************/

#ifndef __DDKMAPI_INCLUDED__
#define __DDKMAPI_INCLUDED__


/*
 * API entry point
 */
DWORD
FAR PASCAL
DxApi(
    DWORD  dwFunctionNum,
    LPVOID lpvInBuffer,
    DWORD  cbInBuffer,
    LPVOID lpvOutBuffer,
    DWORD  cbOutBuffer
);

typedef
DWORD
(FAR PASCAL *LPDXAPI)(
    DWORD   dwFunctionNum,
    LPVOID  lpvInBuffer,
    DWORD   cbInBuffer,
    LPVOID  lpvOutBuffer,
    DWORD   cbOutBuffer
);

#define DXAPI_MAJORVERSION		1
#define DXAPI_MINORVERSION              0

#define DD_FIRST_DXAPI					0x500

typedef ULONG (FAR PASCAL *LPDD_NOTIFYCALLBACK)(DWORD dwFlags, PVOID pContext, DWORD dwParam1, DWORD dwParam2);

/*
 * Queries the DXAPI version number.
 *
 * Input:  Null
 * Output: LPDDGETVERSIONNUMBER
 */
#define DD_DXAPI_GETVERSIONNUMBER                       (DD_FIRST_DXAPI)

    typedef struct _DDGETVERSIONNUMBER
    {
        DWORD   ddRVal;
        DWORD   dwMajorVersion;
        DWORD   dwMinorVersion;
    } DDGETVERSIONNUMBER, FAR *LPDDGETVERSIONNUMBER;

/*
 * Closes the kernel mode handle.
 *
 * Input:  LPDDCLOSEHANDLE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_CLOSEHANDLE                            (DD_FIRST_DXAPI+1)

    typedef struct _DDCLOSEHANDLE
    {
        HANDLE  hHandle;
    } DDCLOSEHANDLE, FAR *LPDDCLOSEHANDLE;

/*
 * Opens the DirectDraw object and returns a kernel mode handle.
 *
 * Input:  LPDDOPENDIRECTDRAWIN
 * Output: LPDDOPENDIRECTDRAWOUT
 */
#define DD_DXAPI_OPENDIRECTDRAW                         (DD_FIRST_DXAPI+2)

    typedef struct _DDOPENDIRECTDRAWIN
    {
        ULONG_PTR            dwDirectDrawHandle;
        LPDD_NOTIFYCALLBACK pfnDirectDrawClose;
        PVOID               pContext;
    } DDOPENDIRECTDRAWIN, FAR *LPDDOPENDIRECTDRAWIN;

    typedef struct _DDOPENDIRECTDRAWOUT
    {
        DWORD   ddRVal;
        HANDLE  hDirectDraw;
    } DDOPENDIRECTDRAWOUT, FAR *LPDDOPENDIRECTDRAWOUT;

/*
 * Opens the surface and returns a kernel mode handle.
 *
 * Input:  LPDDOPENSURFACEIN
 * Output: LPDDOPENSURFACEOUT
 */
#define DD_DXAPI_OPENSURFACE                            (DD_FIRST_DXAPI+3)

    typedef struct _DDOPENSURFACEIN
    {
	HANDLE	            hDirectDraw;
        ULONG_PTR            dwSurfaceHandle;
        LPDD_NOTIFYCALLBACK pfnSurfaceClose;
        PVOID               pContext;
    } DDOPENSURFACEIN, FAR *LPDDOPENSURFACEIN;

    typedef struct _DDOPENSURFACEOUT
    {
        DWORD   ddRVal;
        HANDLE  hSurface;
    } DDOPENSURFACEOUT, FAR *LPDDOPENSURFACEOUT;

/*
 * Opens the VideoPort and returns a kernel mode handle.
 *
 * Input:  LPDDOPENVIDEOPORTIN
 * Output: LPDDOPENVIDEOPORTOUT
 */
#define DD_DXAPI_OPENVIDEOPORT                          (DD_FIRST_DXAPI+4)

    typedef struct _DDOPENVIDEOPORTIN
    {
	HANDLE		    hDirectDraw;
        ULONG               dwVideoPortHandle;
        LPDD_NOTIFYCALLBACK pfnVideoPortClose;
        PVOID               pContext;
    } DDOPENVIDEOPORTIN, FAR *LPDDOPENVIDEOPORTIN;

    typedef struct _DDOPENVIDEOPORTOUT
    {
        DWORD   ddRVal;
        HANDLE  hVideoPort;
    } DDOPENVIDEOPORTOUT, FAR *LPDDOPENVIDEOPORTOUT;

/*
 * Returns the kernel mode capabilities supported by the device
 *
 * Input:  HANDLE hDirectDraw
 * Output: LPDDGETKERNELCAPSOUT
 */
#define DD_DXAPI_GETKERNELCAPS                          (DD_FIRST_DXAPI+5)

    typedef struct _DDGETKERNELCAPSOUT
    {
	DWORD	ddRVal;
        DWORD	dwCaps;
	DWORD	dwIRQCaps;
    } DDGETKERNELCAPSOUT, FAR *LPDDGETKERNELCAPSOUT;

/*
 * Gets the current field number
 *
 * Input:  LPDDGETFIELDNUMIN
 * Output: LPDDGETFIELDNUMOUT
 */
#define DD_DXAPI_GET_VP_FIELD_NUMBER			(DD_FIRST_DXAPI+6)

    typedef struct _DDGETFIELDNUMIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
    } DDGETFIELDNUMIN, FAR *LPDDGETFIELDNUMIN;

    typedef struct _DDGETFIELDNUMOUT
    {
	DWORD	ddRVal;
	DWORD	dwFieldNum;
    } DDGETFIELDNUMOUT, FAR *LPDDGETFIELDNUMOUT;

/*
 * Sets the current field number
 *
 * Input:  LPDDSETFIELDNUM
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_FIELD_NUMBER			(DD_FIRST_DXAPI+7)

    typedef struct _DDSETFIELDNUM
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
	DWORD	dwFieldNum;
    } DDSETFIELDNUM, FAR *LPDDSETFIELDNUM;

/*
 * Indicates which fields should be skipped to undo the 3:2 pulldown.
 *
 * Input:  LPDDSETSKIPFIELD
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_SKIP_FIELD			(DD_FIRST_DXAPI+8)

    typedef struct _DDSETSKIPFIELD
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
	DWORD	dwStartField;
    } DDSETSKIPFIELD, FAR *LPDDSETSKIPFIELD;

/*
 * Notifies whether the surface is in bob or weave mode.
 *
 * Input:  LPDDGETSURFACESTATEIN
 * Output: LPDDGETSURFACESTATEOUT
 */
#define DD_DXAPI_GET_SURFACE_STATE			(DD_FIRST_DXAPI+9)

    typedef struct _DDGETSURFACESTATEIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hSurface;
    } DDGETSURFACESTATEIN, FAR *LPDDGETSURFACESTATEIN;

    typedef struct _DDGETSURFACESTATEOUT
    {
	DWORD	ddRVal;
	DWORD	dwStateCaps;
	DWORD	dwStateStatus;
    } DDGETSURFACESTATEOUT, FAR *LPDDGETSURFACESTATEOUT;

/*
 * Changes the surface between bob and weave mode.
 *
 * Input:  LPDDSETSURFACESTATE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_SURFACE_STATE			(DD_FIRST_DXAPI+10)

    typedef struct _DDSETSURFACETATE
    {
	HANDLE	hDirectDraw;
	HANDLE	hSurface;
	DWORD	dwState;
	DWORD	dwStartField;
    } DDSETSURFACESTATE, FAR *LPDDSETSURFACESTATE;

/*
 * Allows direct access to the surface memory
 *
 * Input:  LPDDLOCKIN
 * Output: LPDDLOCKOUT
 */
#define DD_DXAPI_LOCK					(DD_FIRST_DXAPI+11)

    typedef struct _DDLOCKIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hSurface;
    } DDLOCKIN, FAR *LPDDLOCKIN;

    typedef struct _DDLOCKOUT
    {
	DWORD	ddRVal;
	DWORD	dwSurfHeight;
	DWORD	dwSurfWidth;
	LONG	lSurfPitch;
	PVOID	lpSurface;
	DWORD	SurfaceCaps;
	DWORD	dwFormatFlags;
	DWORD	dwFormatFourCC;
	DWORD	dwFormatBitCount;
	union
	{
	    DWORD	dwRBitMask;
	    DWORD	dwYBitMask;
    	};
    	union
    	{
	    DWORD	dwGBitMask;
	    DWORD	dwUBitMask;
	};
	union
	{
	    DWORD	dwBBitMask;
	    DWORD	dwVBitMask;
	};
    } DDLOCKOUT, FAR *LPDDLOCKOUT;

/*
 * Flips the overlay surface
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_OVERLAY				(DD_FIRST_DXAPI+12)

    typedef struct _DDFLIPOVERLAY
    {
	HANDLE	hDirectDraw;
	HANDLE	hCurrentSurface;
	HANDLE	hTargetSurface;
	DWORD	dwFlags;
    } DDFLIPOVERLAY, FAR *LPDDFLIPOVERLAY;

/*
 * Flips the video port
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_VP				(DD_FIRST_DXAPI+13)

    typedef struct _DDFLIPVIDEOPORT
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
	HANDLE	hCurrentSurface;
	HANDLE	hTargetSurface;
	DWORD	dwFlags;
    } DDFLIPVIDEOPORT, FAR *LPDDFLIPVIDEOPORT;

/*
 * Returns the current surface receiving the data while autoflipping
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_CURRENT_VP_AUTOFLIP_SURFACE	(DD_FIRST_DXAPI+14)

    typedef struct _DDGETAUTOFLIPIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
    } DDGETAUTOFLIPIN, FAR *LPDDGETAUTOFLIPIN;

    typedef struct _DDGETAUTOFLIPOUT
    {
	DWORD	ddRVal;
	HANDLE	hVideoSurface;
	HANDLE	hVBISurface;
	BOOL	bPolarity;
    } DDGETAUTOFLIPOUT, FAR *LPDDGETAUTOFLIPOUT;

/*
 * Returns the surface that received the previous field of data (could
 * be the same as current if video is interleaved)
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_LAST_VP_AUTOFLIP_SURFACE		(DD_FIRST_DXAPI+15)

/*
 * Registers a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_REGISTER_CALLBACK			(DD_FIRST_DXAPI+16)

    typedef struct _DDREGISTERCALLBACK
    {
	HANDLE 	            hDirectDraw;
	ULONG	            dwEvents;
	LPDD_NOTIFYCALLBACK pfnCallback;
	ULONG_PTR            dwParam1;
	ULONG_PTR            dwParam2;
	PVOID	            pContext;
    } DDREGISTERCALLBACK, FAR *LPDDREGISTERCALLBACK;

/*
 * Unregisters a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_UNREGISTER_CALLBACK			(DD_FIRST_DXAPI+17)

/*
 * Returns the polarity (odd/even) of the current field
 *
 * Input:  LPDDGETPOLARITYIN
 * Output: LPDDGETPOLARITYOUT
 */
#define DD_DXAPI_GET_POLARITY				(DD_FIRST_DXAPI+18)

    typedef struct _DDGETPOLARITYIN
    {
	HANDLE 	hDirectDraw;
	HANDLE	hVideoPort;
    } DDGETPOLARITYIN, FAR *LPDDGETPOLARITYIN;

    typedef struct _DDGETPOLARITYOUT
    {
	DWORD 	ddRVal;
	BOOL	bPolarity;
    } DDGETPOLARITYOUT, FAR *LPDDGETPOLARITYOUT;

/*
 * Opens the device for capture
 *
 * Input:  LPDDOPENCAPTUREDEVICEIN
 * Output: LPDDOPENCAPTUREDEVICEOUT
 */
#define DD_DXAPI_OPENVPCAPTUREDEVICE			(DD_FIRST_DXAPI+19)

    typedef struct _DDOPENVPCAPTUREDEVICEIN
    {
	HANDLE  hDirectDraw;
	HANDLE  hVideoPort;
	DWORD   dwStartLine;
	DWORD   dwEndLine;
	DWORD   dwCaptureEveryNFields;
	LPDD_NOTIFYCALLBACK pfnCaptureClose;
	PVOID   pContext;
	DWORD	dwFlags;
    } DDOPENVPCAPTUREDEVICEIN, FAR * LPDDOPENVPCAPTUREDEVICEIN;

    typedef struct _DDOPENVPCAPTUREDEVICEOUT
    {
	DWORD	ddRVal;
	HANDLE	hCapture;
    } DDOPENVPCAPTUREDEVICEOUT, FAR * LPDDOPENVPCAPTUREDEVICEOUT;

    #define DDOPENCAPTURE_VIDEO	0x0001	// Capture from the video stream
    #define DDOPENCAPTURE_VBI	0x0002	// Capture from the VBI stream

/*
 * Adds a capture buffer to the internal video port capture queue
 *
 * Input:  LPDDADDVPCAPTUREBUFF
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_ADDVPCAPTUREBUFFER			(DD_FIRST_DXAPI+20)

    typedef struct _DDCAPBUFFINFO
    {
	DWORD   	dwFieldNumber;
	DWORD   	bPolarity;
	LARGE_INTEGER	liTimeStamp;
	DWORD   	ddRVal;
    } DDCAPBUFFINFO, FAR * LPDDCAPBUFFINFO;

    typedef struct _DDADDVPCAPTUREBUFF
    {
	HANDLE  hCapture;
	DWORD   dwFlags;
	PMDL    pMDL;
	PKEVENT pKEvent;
	LPDDCAPBUFFINFO lpBuffInfo;
    } DDADDVPCAPTUREBUFF, FAR * LPDDADDVPCAPTUREBUFF;

    #define DDADDBUFF_SYSTEMMEMORY	0x0001	// lpBuffer points to sys mem
    #define DDADDBUFF_NONLOCALVIDMEM	0x0002	// lpBuffer points to AGP mem
    #define DDADDBUFF_INVERT		0x0004	// invert the buffer during capture

/*
 * Flushes the internal video port capture queue
 *
 * Input:  HANDLE to capture device
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLUSHVPCAPTUREBUFFERS			(DD_FIRST_DXAPI+21)


/*
 * State flags returned by DSVXD_DXAPI_DD_GET_SURFACE_STATE
 */
#define DDSTATE_BOB				0x0001
#define DDSTATE_WEAVE				0x0002
#define DDSTATE_EXPLICITLY_SET			0x0004
#define DDSTATE_SOFTWARE_AUTOFLIP		0x0008
#define DDSTATE_SKIPEVENFIELDS			0x0010

/*
 * Event flags - passed into RegisterCallback
 */
#define DDEVENT_DISPLAY_VSYNC			0x0001
#define DDEVENT_VP_VSYNC			0x0002
#define DDEVENT_VP_LINE				0x0004
#define DDEVENT_PRERESCHANGE			0x0008
#define DDEVENT_POSTRESCHANGE			0x0010
#define DDEVENT_PREDOSBOX			0x0020
#define DDEVENT_POSTDOSBOX			0x0040

/*
 * Notification flags - passed to the notification proc
 */
#define DDNOTIFY_DISPLAY_VSYNC			0x0001	// dwParam1 = hDirectDraw
#define DDNOTIFY_VP_VSYNC			0x0002	// dwParam1 = hVideoPort
#define DDNOTIFY_VP_LINE	  		0x0004	// dwParam1 = hVideoPort
#define DDNOTIFY_PRERESCHANGE			0x0008	// dwParam1 = hDirectDraw
#define DDNOTIFY_POSTRESCHANGE			0x0010	// dwParam1 = hDirectDraw
#define DDNOTIFY_PREDOSBOX			0x0020  // dwParam1 = hDirectDraw
#define DDNOTIFY_POSTDOSBOX			0x0040  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSEDIRECTDRAW		0x0080  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSESURFACE			0x0100  // dwParam1 = hSurface
#define DDNOTIFY_CLOSEVIDEOPORT			0x0200  // dwParam1 = hVideoPort
#define DDNOTIFY_CLOSECAPTURE			0x0400  // dwParam1 = hCapture

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\windows\inc\duser\duserutil.h ===
#if !defined(INC__DUserUtil_h__INCLUDED)
#define INC__DUserUtil_h__INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

#ifdef DUSER_EXPORTS
#define DUSER_API
#else
#define DUSER_API __declspec(dllimport)
#endif

DUSER_API   BOOL        WINAPI  UtilSetBackground(HGADGET hgadChange, HBRUSH hbrBack);


/*
 * Utility Functions
 */

#define FS_NORMAL           0x00000000
#define FS_BOLD             0x00000001
#define FS_ITALIC           0x00000002
#define FS_UNDERLINE        0x00000004
#define FS_STRIKEOUT        0x00000008
#define FS_COMPATIBLE       0x00000010  // Use non-Gadget mechanism for computing size

DUSER_API   HFONT       WINAPI  UtilBuildFont(LPCWSTR pszName, int idxDeciSize, DWORD nFlags, HDC hdcDevice DEFARG(NULL));
DUSER_API   BOOL        WINAPI  UtilDrawBlendRect(HDC hdcDest, const RECT * prcDest, HBRUSH hbrFill, BYTE bAlpha, int wBrush, int hBrush);
DUSER_API   BOOL        WINAPI  UtilDrawOutlineRect(HDC hdc, const RECT * prcPxl, HPEN hpenDraw, int nThickness DEFARG(1));
DUSER_API   COLORREF    WINAPI  UtilGetColor(HBITMAP hbmp, POINT * pptPxl DEFARG(NULL));

/***************************************************************************\
*
* Color management
*
\***************************************************************************/

#define SC_AliceBlue            (0)
#define SC_AntiqueWhite         (1)
#define SC_Aqua                 (2)
#define SC_Aquamarine           (3)
#define SC_Azure                (4)
#define SC_Beige                (5)
#define SC_Bisque               (6)
#define SC_Black                (7)
#define SC_BlanchedAlmond       (8)
#define SC_Blue                 (9)
#define SC_BlueViolet           (10)
#define SC_Brown                (11)
#define SC_BurlyWood            (12)
#define SC_CadetBlue            (13)
#define SC_Chartreuse           (14)
#define SC_Chocolate            (15)
#define SC_Coral                (16)
#define SC_CornflowerBlue       (17)
#define SC_Cornsilk             (18)
#define SC_Crimson              (19)
#define SC_Cyan                 (20)
#define SC_DarkBlue             (21)
#define SC_DarkCyan             (22)
#define SC_DarkGoldenrod        (23)
#define SC_DarkGray             (24)
#define SC_DarkGreen            (25)
#define SC_DarkKhaki            (26)
#define SC_DarkMagenta          (27)
#define SC_DarkOliveGreen       (28)
#define SC_DarkOrange           (29)
#define SC_DarkOrchid           (30)
#define SC_DarkRed              (31)
#define SC_DarkSalmon           (32)
#define SC_DarkSeaGreen         (33)
#define SC_DarkSlateBlue        (34)
#define SC_DarkSlateGray        (35)
#define SC_DarkTurquoise        (36)
#define SC_DarkViolet           (37)
#define SC_DeepPink             (38)
#define SC_DeepSkyBlue          (39)
#define SC_DimGray              (40)
#define SC_DodgerBlue           (41)
#define SC_FireBrick            (42)
#define SC_FloralWhite          (43)
#define SC_ForestGreen          (44)
#define SC_Fuchsia              (45)
#define SC_Gainsboro            (46)
#define SC_GhostWhite           (47)
#define SC_Gold                 (48)
#define SC_Goldenrod            (49)
#define SC_Gray                 (50)
#define SC_Green                (51)
#define SC_GreenYellow          (52)
#define SC_Honeydew             (53)
#define SC_HotPink              (54)
#define SC_IndianRed            (55)
#define SC_Indigo               (56)
#define SC_Ivory                (57)
#define SC_Khaki                (58)
#define SC_Lavender             (59)
#define SC_LavenderBlush        (60)
#define SC_LawnGreen            (61)
#define SC_LemonChiffon         (62)
#define SC_LightBlue            (63)
#define SC_LightCoral           (64)
#define SC_LightCyan            (65)
#define SC_LightGoldenrodYellow (66)
#define SC_LightGreen           (67)
#define SC_LightGrey            (68)
#define SC_LightPink            (69)
#define SC_LightSalmon          (70)
#define SC_LightSeaGreen        (71)
#define SC_LightSkyBlue         (72)
#define SC_LightSlateGray       (73)
#define SC_LightSteelBlue       (74)
#define SC_LightYellow          (75)
#define SC_Lime                 (76)
#define SC_LimeGreen            (77)
#define SC_Linen                (78)
#define SC_Magenta              (79)
#define SC_Maroon               (80)
#define SC_MediumAquamarine     (81)
#define SC_MediumBlue           (82)
#define SC_MediumOrchid         (83)
#define SC_MediumPurple         (84)
#define SC_MediumSeaGreen       (85)
#define SC_MediumSlateBlue      (86)
#define SC_MediumSpringGreen    (87)
#define SC_MediumTurquoise      (88)
#define SC_MediumVioletRed      (89)
#define SC_MidnightBlue         (90)
#define SC_MintCream            (91)
#define SC_MistyRose            (92)
#define SC_Moccasin             (93)
#define SC_NavajoWhite          (94)
#define SC_Navy                 (95)
#define SC_OldLace              (96)
#define SC_Olive                (97)
#define SC_OliveDrab            (98)
#define SC_Orange               (99)
#define SC_OrangeRed            (100)
#define SC_Orchid               (101)
#define SC_PaleGoldenrod        (102)
#define SC_PaleGreen            (103)
#define SC_PaleTurquoise        (104)
#define SC_PaleVioletRed        (105)
#define SC_PapayaWhip           (106)
#define SC_PeachPuff            (107)
#define SC_Peru                 (108)
#define SC_Pink                 (109)
#define SC_Plum                 (110)
#define SC_PowderBlue           (111)
#define SC_Purple               (112)
#define SC_Red                  (113)
#define SC_RosyBrown            (114)
#define SC_RoyalBlue            (115)
#define SC_SaddleBrown          (116)
#define SC_Salmon               (117)
#define SC_SandyBrown           (118)
#define SC_SeaGreen             (119)
#define SC_Seashell             (120)
#define SC_Sienna               (121)
#define SC_Silver               (122)
#define SC_SkyBlue              (123)
#define SC_SlateBlue            (124)
#define SC_SlateGray            (125)
#define SC_Snow                 (126)
#define SC_SpringGreen          (127)
#define SC_SteelBlue            (128)
#define SC_Tan                  (129)
#define SC_Teal                 (130)
#define SC_Thistle              (131)
#define SC_Tomato               (132)
#define SC_Turquoise            (133)
#define SC_Violet               (134)
#define SC_Wheat                (135)
#define SC_White                (136)
#define SC_WhiteSmoke           (137)
#define SC_Yellow               (138)
#define SC_YellowGreen          (139)
#define SC_MAXCOLORS            (139)

DUSER_API   COLORREF    WINAPI  GetStdColorI(UINT c);
DUSER_API   HBRUSH      WINAPI  GetStdColorBrushI(UINT c);
DUSER_API   HPEN        WINAPI  GetStdColorPenI(UINT c);
#ifdef GADGET_ENABLE_GDIPLUS

#ifdef __cplusplus
};  // extern "C"

DUSER_API   Gdiplus::Color
                        WINAPI  GetStdColorF(UINT c);
DUSER_API   Gdiplus::Brush *
                        WINAPI  GetStdColorBrushF(UINT c);
DUSER_API   Gdiplus::Pen *
                        WINAPI  GetStdColorPenF(UINT c);

extern "C" {
#endif

#endif // GADGET_ENABLE_GDIPLUS
DUSER_API   LPCWSTR     WINAPI  GetStdColorName(UINT c);
DUSER_API   UINT        WINAPI  FindStdColor(LPCWSTR pszName);
DUSER_API   HPALETTE    WINAPI  GetStdPalette();

#ifdef __cplusplus
};  // extern "C"
#endif

#endif // INC__DUserUtil_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\oak\inc\compstui.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    compstui.h


Abstract:

    This module contains global header definition for the COMMON DRIVER UI


Author:

    19-Jun-1995 Mon 11:52:01 created  -by-  Daniel Chou (danielc)

    17-Aug-1995 Thu 14:59:28 updated  -by-  Daniel Chou (danielc)
        Updated for the first draft.

    23-Aug-1995 Wed 15:13:27 updated  -by-  Daniel Chou (danielc)
        Updated for second draft

    29-Aug-1995 Tue 11:33:24 updated  -by-  Daniel Chou (danielc)
        Adding ExtChkBox for some TVOT_xxx type

    31-Aug-1995 Thu 04:04:23 updated  -by-  Daniel Chou (danielc)
        Making UNICODE type

    01-Sep-1995 Fri 17:29:18 updated  -by-  Daniel Chou (danielc)
        Change the API interface type, so that it can be dynamically called
        and generate the property pages to be merge with the shell

    05-Sep-1995 Tue 11:52:43 updated  -by-  Daniel Chou (danielc)
        Rename to compspui.h and update the API entry structure

    07-Sep-1995 Thu 14:46:55 updated  -by-  Daniel Chou (danielc)
        rename to compstui.h and update comments

    07-Sep-1995 Thu 16:07:31 updated  -by-  Daniel Chou (danielc)
        Adding UNION type for pSel/Sel, pOldSel/OldSel

    08-Sep-1995 Fri 09:23:38 updated  -by-  Daniel Chou (danielc)
        Remove TypeIdx from OPTITEM and use pOptType, and remove all
        pOptType passed in the CPSUICBPARAM and COMPROPSHEETUI structures

    25-Sep-1995 Mon 19:39:45 updated  -by-  Daniel Chou (danielc)
        add other related stuff.

    26-Sep-1995 Tue 11:02:26 updated  -by-  Daniel Chou (danielc)
        Add error codes for GETLASTERROR

    27-Sep-1995 Wed 16:32:37 updated  -by-  Daniel Chou (danielc)
        Move hWndParent, pTitle, hInst and TitleIconID out from
        COMPROPSHEETUI to COMPROPSHEETUIHEADER.

    28-Sep-1995 Thu 17:06:46 updated  -by-  Daniel Chou (danielc)
        Add hInstCaller to COMPROPSHEETUI and add _COMPSTUI_ and cplusplus
        stuff

    28-Sep-1995 Thu 23:16:34 updated  -by-  Daniel Chou (danielc)
        change tick count for trackbar/scrollbar to multiply factor. and
        add the push button flag which can overwrite the update permission so
        it can let user view the current setting from push button's dialog
        display

    07-Feb-1996 Wed 17:45:31 updated  -by-  Daniel Chou (danielc)
        Change the API CommonPropSheetUI to CommonPropertySheetUI so that it
        not using stack but message base, this way any caller can add/delete
        pages as they want without worry about how many pages been added from
        its children.

    7:15 AM 2/14/2001 updated -by- Lazar Ivanov (LazarI)
        Making compstui fusion aware. Attaching a fusion activation context
        to the compstui handles and adding a new message for setting it called 
        CPSFUNC_SET_FUSION_CONTEXT. when a page is about to be created/inserted and 
        it doesn't specify an activation context in its PROPSHEETPAGE structure it 
        will be created into the parent's page activation context. if the parent's 
        activation context is not set then we look up the next parent and so on until 
        the top level parent is reached or until we find a parent with an activation 
        context properly set. if none of the parents have an activation context set, 
        then we force the default (NULL) activation context prior creating the page.

[Environment:]

    NT Windows - Common Property Sheet UI DLL.


[Notes:]


Revision History:


--*/

#ifndef _COMPSTUI_
#define _COMPSTUI_

#ifdef __cplusplus
extern "C" {
#endif


#if (!defined(RC_INVOKED))


//
// For compilers that don't support nameless unions
//

#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME      u
#define DUMMYUNIONNAME2     u2
#define DUMMYUNIONNAME3     u3
#define DUMMYUNIONNAME4     u4
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#define DUMMYUNIONNAME4
#endif
#endif

//
// Predefined ID for the TreeView Option Type
//
//


#define TVOT_2STATES        0
#define TVOT_3STATES        1
#define TVOT_UDARROW        2
#define TVOT_TRACKBAR       3
#define TVOT_SCROLLBAR      4
#define TVOT_LISTBOX        5
#define TVOT_COMBOBOX       6
#define TVOT_EDITBOX        7
#define TVOT_PUSHBUTTON     8
#define TVOT_CHKBOX         9
#define TVOT_LAST           TVOT_CHKBOX
#define TVOT_NONE           (TVOT_LAST + 1)

//
// Predefined ID for the TreeView Option Type
//
//
// TVOT_2STATES:
//      Count       = 2
//      pOptParam[0]=pointer to the State 1 OPTPARAM
//      pOptParam[1]=pointer to the State 2 OPTPARAM
//
//      BegCtrlID  = 2 States Group Box ID
//      BegCtrlID+1= 2 States static Text
//      BegCtrlID+2= state 1 Radio button ID
//      BegCtrlID+3= state 1 icon control ID
//      BegCtrlID+4= state 2 Radio button ID
//      BegCtrlID+5= state 2 icon control ID
//      BegCtrlID+6= Extended Check Box/Push Button control ID
//      BegCtrlID+7= Extended Check Box/Push Button Icon control ID
//
//  * For TVOT_3STATES, TVOT_3STATES, each of OPTPARAM consisted
//
//      Style =Ignored
//      pData =Pointer to the string to describe the state
//      IconID=Icons resource ID, or common UI standard icon ID
//      lParam=Ignored
//
//  * OPTITEM's 'Sel' is the selection index range from 0 to 1
//  * On the non-treeview page, this must be a auto radio button
//
//
// TVOT_3STATES:
//      Count       = 3
//      pOptParam[0]=pointer to the State 1 OPTPARAM
//      pOptParam[1]=pointer to the State 2 OPTPARAM
//      pOptParam[2]=pointer to the State 3 OPTPARAM
//
//      BegCtrlID  = 3 States Group Box ID
//      BegCtrlID+1= 3 States static Text
//      BegCtrlID+2= state 1 Radio button ID
//      BegCtrlID+3= state 1 icon control ID
//      BegCtrlID+4= state 2 Radio button ID
//      BegCtrlID+5= state 2 icon control ID
//      BegCtrlID+6= state 3 Radio button ID
//      BegCtrlID+7= state 3 icon control ID
//      BegCtrlID+8= Extended Check Box/Push Button control ID
//      BegCtrlID+9= Extended Check Box/Push Button Icon control ID
//
//  * For TVOT_2STATES, TVOT_3STATES, each of OPTPARAM consisted
//
//      Style =Ignored
//      pData =Pointer to the string to describe the state
//      IconID=Icons resource ID, or common UI standard icon ID
//      lParam=Ignored
//
//  * OPTITEM's 'Sel' is the selection index range from 0 to 1
//  * On the non-treeview page, this must be a auto radio button
//
//  ** For TVOT_2STATES, TVOT_3STSATES the 'Sel' field in the OPTITEM has
//     following definitions
//
//      State 1, Sel = 0
//      State 2, Sel = 1
//      State 3, Sel = 2
//
//      for any selection which based on false/true, no/yes, off/ontrue/false,
//      none/select then state 1 (sel=0) must always be the NO, FALSE, OFF or
//      NONE type.
//
//
// TVOT_UDARROW:
//      Count       = 2
//      pOptParam[0]=Pointer to the text of postfix and ICONS
//      pOptParam[1]=Pointer to the help line text above the control and
//                      IconID = (SHORT)Low range of the up-down control
//                      lParam = (SHORT)High range of the up-down control
//
//                          * Low/High must in range of a 16-bit sign integer
//
//          if pData pointed to no help text then common UI automatically
//          set the (# - #) as help line
//
//      BegCtrlID  = udarrow Group Box ID
//      BegCtrlID+1= udarrow title static title ID
//      BegCtrlID+2= udarrow's editbox ID
//      BegCtrlID+3= udarrow icon control ID
//      BegCtrlID+4= udarrow postfix static text ID
//      BegCtrlID+5= udarrow help static text ID
//      BegCtrlID+6= udarrow arrow ID
//      BegCtrlID+7= Extended Check Box/Push Button control ID
//      BegCtrlID+8= Extended Check Box/Push Button Icon control ID
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//      * Style field in the OPTPARAM is ignored
//
//
// TVOT_TRACKBAR:
//      Count       = 3
//      pOptParam[0]=Pointer to the text for the selection postfix and ICONS
//      pOptParam[1]=Pointer to the <Low Range Text> and
//                      IconID = (SHORT)Low range of the trackbar control
//                      lParam = (SHORT)High range of the trackbar control
//
//                          * Low/High must in range of a 16-bit sign integer
//
//      pOptParam[2]=Pointer to the <High Range Text> and
//                      IconID = 'Sel' multiply factor for display
//                      lParam = Page Size (increment)
//
//          if pData pointed to NULLt then common UI automatically
//          set the Low/High range.
//
//      BegCtrlID  = trackbar Group Box ID
//      BegCtrlID+1= trackbar static title ID
//      BegCtrlID+2= trackbar(horizontal) ID (static FRAME to define size)
//      BegCtrlID+3= trackbar icon control ID
//      BegCtrlID+4= trackbar low range text control ID
//      BegCtrlID+5= trackbar high range text control ID
//      BegCtrlID+6= trackbar postfix ID
//      BegCtrlID+7= Extended Check Box/Push Button control ID
//      BegCtrlID+8= Extended Check Box/Push Button Icon control ID
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//      * The multiply factor is used to multiply the current select with
//        this factor and display it. typically this is one
//      * the tick frequency is automatically to set to PageSize increment
//      * Style field in the OPTPARAM is ignored
//
//
// TVOT_SCROLLBAR:
//      Count       = 3
//      pOptParam[0]=Pointer to the text for the selection postfix and ICONS
//      pOptParam[1]=Pointer to the <Low Range Text> and
//                      IconID = (SHORT)Low range of the scrollbar control
//                      lParam = (SHORT)High range of the scroll control
//
//                          * Low/High must in range of a 16-bit sign integer
//
//      pOptParam[2]=Pointer to the <High Range Text> and
//                      IconID = 'Sel' multiply factor for display
//                      lParam = Page Size (increment)
//
//          if pData pointed to NULLt then common UI automatically
//          set the Low/High range.
//
//
//      BegCtrlID  = scrollbar(horizontal) group box ID
//      BegCtrlID+1= scrollbar(horizontal) static text ID
//      BegCtrlID+2= scrollbar(horizontal) ID
//      BegCtrlID+3= scrollbar icon control ID
//      BegCtrlID+4= scrollbar low range text control ID
//      BegCtrlID+5= scrollbar high range text control ID
//      BegCtrlID+6= scrollbar postfix control ID
//      BegCtrlID+7= Extended Check Box/Push Button control ID
//      BegCtrlID+8= Extended Check Box/Push Button Icon control ID
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//      * The multiply factor is used to multiply the current select with
//        this factor and display it. typically this is one
//      * Style field in the OPTPARAM is ignored
//
//
//
// TVOT_LISTBOX:
// TVOT_COMBOBOX:
//      Count       = N
//      pOptParam[0]=pointer to the first OPTPARAM (pData=string pointer)
//      pOptParam[1]=pointer to the second OPTPARAM (pData=string pointer)
//          .
//          .
//      pOptParam[N-1]=pointer to the N item string
//
//      BegCtrlID  = Listbox/ComboBox group box ID
//      BegCtrlID+1= Listbox/ComboBox static title ID
//      BegCtrlID+2= Listbox/Combobox ID
//      BegCtrlID+3= Listbox/Combobox icon control ID
//      BegCtrlID+4= Extended Check Box/Push Button control ID
//      BegCtrlID+5= Extended Check Box/Push Button Icon control ID
//
//      * for TVOT_LISTBOX, TVOT_COMBOBOX, the field used as
//
//          Style =Ignored by the common UI
//          pData =Pointer to the name of item
//          IconID=Icon resource ID for the item
//          lParam=ignored by the common UI
//
//      * Only SINGLE selection is supported, to do a multiple selction use
//        multiple OPTITEM and create a header for it
//
//      * an OTLBCBS_SORT style can be specified in the OPTTYPE's LBCBStyle
//        field, and the listbox or combobox will be sorted according to the
//        item's string.
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//
//      * for TVOT_LISTBOX, TVOT_COMBOBOX, when it get received the keyboard
//        focus then common UI will call callback function (only if
//        OPTIF_CALLBACK bit set) with reason of CPSUICB_REASON_LBCB_ACTIVE,
//        this give caller a chance to modify following structure flags/pdata
//        which associate with the current OPTITEM.   The caller's callback
//        function can ONLY modify the flags/data specified here.
//
//          OPTTYPE pointed by the pOptType from OPTITEM
//
//              Style: OTS_LBCB_SORT
//                     OTS_LBCB_INCL_ITEM_NONE
//
//          OPTPARAMs pointed by the pOptParam from the OPTTYPE
//
//              Flags: OPTPF_HIDE
//                     OPTPF_DISABLED
//
//              pData: change string name
//
//
//      * The TVOT_COMBOBOX typically only used in the tree-view if there is
//        only one selection available for that item, when there is only one
//        item then dropdown list will not enabled by the common UI
//
//
//
// TVOT_EDITBOX:
//      Count       = 2
//      pOptParam[0]=Pointer to the text of postfix and ICONS
//      pOptParam[1]=Pointer to the help line text above the control and
//                      IconID = Edit buffer sie in character pointed by pSel
//                                 this is including the NULL terminator.
//                      lParam = ignored.
//
//      BegCtrlID  = editBox group Box ID
//      BegCtrlID+1= editBox static title ID
//      BegCtrlID+2= editbox ID
//      BegCtrlID+3= editbox icon control ID
//      BegCtrlID+4= editbox postfix ID
//      BegCtrlID+5= editbox help ID
//      BegCtrlID+6= Extended Check Box/Push Button control ID
//      BegCtrlID+7= Extended Check Box/Push Button Icon control ID
//
//      * Style field is ignored
//
//      * pSel in the OPTITEM is the pointer to the editing string, the pSel
//        must pointed to a buffer eqaul or larger than the count of the buffer
//        (pOptParam[1]->IconID) size
//
//
// TVOT_PUSHBUTTON:
//      Count       = 1
//
//      BegCtrlID  = push button group box ID
//      BegCtrlID+1= push button static text ID (Not used by common UI)
//      BegCtrlID+2= push button ID
//      BegCtrlID+3= push button icon control ID
//      BegCtrlID+4= Extended Check Box/Push Button control ID
//      BegCtrlID+5= Extended Check Box/Push Button Icon control ID
//
//
//      PUSHBUTTON_TYPE_xxx specified the action and content of pData in the
//      pOptParam[0] as describe in the following
//
//          PUSHBUTTON_TYPE_DLGPROC
//
//              This push button is designed to bring up caller's dialog box
//
//                  pOptParam[0].pData  = Caller's DLGPROC
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_DLGPROC
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam = Caller's DIALOG resource template ID
//                                        or handle to the DLGTEMPLATE depends
//                                        on the OPTPF_USE_HDLGTEMPLATE flag
//
//
//              The 'lParam' passed to the DLGPROC's WM_INITDIALOG is the
//              CPSUICBPARAM structure pointer, and the reason field is set
//              to CPSUICB_REASON_DLGPROC.
//
//
//          PUSHBUTTON_TYPE_CALLBACK
//
//              This push button is designed to have caller process the item
//              which cannot accomplished with the dialog box along.
//
//                  pOptParam[0].pData  = CPSUICALLBACK function pointer
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_CALLBACK
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam = Not Used;
//
//              Durning the callback the Reason field in CPSUICBPARAM will
//              set to CPSUICB_REASON_PUSHBUTTON.
//
//              ** If pOptParam[0].pData callback function is NULL then common
//                 UI will call the pfnCallBack pointer set in the
//                 COMPROPSHEETUI structure if it is not NULL
//
//              ** The callback function should put the result of the callback
//                 in the pSel/Sel of OPTITEM associate with the push button
//
//          PUSHBUTTON_TYPE_HTCLRADJ
//
//              This push button is designed to bring up halftone color
//              adjustment dialog box.
//
//                  pOptParam[0].pData  = pointer to COLORADJUSTMENT structure
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_HTCLRADJ
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam =  Not Used;
//
//
//          PUSHBUTTON_TYPE_HTSETUP
//
//              This push button is designed to bring up device halftone
//              setup dialog box.
//
//                  pOptParam[0].pData  = pointer to DEVHTADJDATA structure
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_HTSETUP
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam = Not Used;
//
//
//      * 'Sel' field in the OPTITEM for the PUSHBUTTON is the last returned
//        LONG result from the called dialog box or funcitons.  The result
//        only valid if OPTIF_CHANGEONCE flag is set.  The common UI will set
//        OPTIF_CHANGEONCE if push button ever pushed.
//
//      * Since common UI donot know the meaning of the return value and
//        content of the called parameter, it is up to the caller to use
//        callback function to determine the returned result.
//
//      * When returned from the push button except push botton type
//        PUSHBUTTON_TYPE_CALLBACK common ui will call the callback function
//        if the OPTIF_CALLBACK flat is set.  The callback reason is set to
//        CPSUICB_REASON_SEL_CHANGED.
//
//      * If the passed in CPSUIF_UPDATE_PERMISSION Flags in the COMPROPSHEETUI
//        is clear then the callback function must ONLY display the dialog box
//        and not changed any OPTITEM data if OTS_PUSH_ENABLE_ALWAYS
//        flag is set in the OPTTYPE
//
//
// TVOT_CHKBOX:
//      Count               = 1
//
//      pOptparam[0].Style  = CHKBOXS_FALSE_TRUE    False/True
//                            CHKBOXS_NO_YES,       No/YES
//                            CHKBOXS_OFF_ON,       Off/ON
//                            CHKBOXS_FALSEPDATA    False/pData
//                            CHKBOXS_NO_PDATA      No/pData
//                            CHKBOXS_OFF_PDATA     Off/pData
//                            CHKBOXS_NONE_PDATA    None/pData
//      pOptParam[0].pData  = Only used if Style is CHKBOXS_NONE_PDATA
//      pOptParam[0].IconID = Icon resource ID
//      pOptParam[0].lParam = Ignored
//
//
//      BegCtrlID  = check box group ID
//      BegCtrlID+1= Check Box static text (not used by common UI)
//      BegCtrlID+2= check box button ID
//      BegCtrlID+3= check box icon control ID
//      BegCtrlID+4= Extended Check Box/Push Button control ID
//      BegCtrlID+5= Extended Check Box/Push Button Icon control ID
//
//
//  * BegCtrlID only used if the OPTITEM/OPTTYPE is belong to the the DLGPAGE
//    which has non-common UI dialog box template (DlgTemplateID in the DLGPAGE
//    is not standard DP_STD_xxx common ui dialog box template).    The common
//    UI used this ID to managed caller's dialog boxes item's selections and
//    initialization.
//
//  * for each item, it has group box ID (BegCtrlID) and static text ctronl ID
//    (BegCtrlID + 1).  The common UI will set the text in one of these two
//    control ID in followng seauence.
//
//      1) If group box control ID's window (BegCtrlID) is exist and the
//         OPTITEM's flag OPTIF_NO_GROUPBOX_NAME is not set then common UI will
//         set the pName from OPTITEM to the group box.
//
//      2) If the group box name is not set and static control ID's window
//         (BegCtrlID + 1) is exist then common UI will set the pName from
//         OPTITEM to the static text control.
//
//  * for TVOT_TRACKBAR and TVOT_SCROLLBAR, if pName in the OPTITEM is set to
//    either group box or static text control then common UI will also append
//    the current selection position of trackbar or scroll bar to the pName.
//
//  * If multiple OPTITEMs using the same POPTPARAM and need different
//    BegCtrlID for each control then then a separate OPTTYPE structure should
//    be generated but POPTPARAM pointed to the same OPTPARAM[]
//
//  * If a BegCtrlID+N is not used then skip that ID in your dialog box
//    template
//
//

#define CHKBOXS_FALSE_TRUE          0
#define CHKBOXS_NO_YES              1
#define CHKBOXS_OFF_ON              2
#define CHKBOXS_FALSE_PDATA         3
#define CHKBOXS_NO_PDATA            4
#define CHKBOXS_OFF_PDATA           5
#define CHKBOXS_NONE_PDATA          6


#define PUSHBUTTON_TYPE_DLGPROC     0
#define PUSHBUTTON_TYPE_CALLBACK    1
#define PUSHBUTTON_TYPE_HTCLRADJ    2
#define PUSHBUTTON_TYPE_HTSETUP     3


#define MAX_RES_STR_CHARS           160

//
// Common Printer UI's LPTSTR
//
// All string pointer in common printer UI structures can be either a real
// memory pointer or a string resource ID.  These are applied to LPTSTR type.
//
// The LPTSTR is defined to identify that the pointer can be a real string
// pointer or a resource ID (either common printer UI provided ID or caller's
// own resource ID).  common UI using following logic to get the final string.
//
//  LPTSTR  pData;
//
//      if ((pData & ~(ULONG_PTR)0xFFFF) != 0) then pData is a NULL terminated
//      string pointer
//
//          ELSE
//
//          (pData & (ULONG_PTR)0xFFFF) = Resource ID
//
//          if (Resource ID is within the common UI string resource ID range)
//          then it load the string from common UI DLL
//
//          ELSE
//
//              it load string from caller's resource
//
//
//  *  You can use MAKEINTRESOURCE(StrResID) to set this field
//
//  * The MAX characters loaded by the common UI from the resource is defined
//    as MAX_RES_STR_CHARS
//
//  * You cannot use LPTSTR as resource ID for the TVOT_EDITBOX style's
//    pSel in the OPTITEM, this pointer must be a real buffer pointer
//
//
//
// ICONs
//
//  Common UI using two types of Icons, One is 32x32 and the other is 16x16
//  plus if any monochrome icon with 32x32 and 16x16 sizes.
//
//  The 16x16 icon when displayed on the screen is using 16x17 pixel space,
//  this is ensure that downware adjacent icon is not crowded together.
//
//  In common UI, if you need to passed a ICON ID, it can either passed a
//  common UI's predefined ID or caller's own ICON resource ID.
//
//
//  * You can use to imagedit or any other Window icon editor to create the
//    icon, each icon file should have one unique icon resource ID which is
//    not overlay with the standard common UI IDI_CPSUI_xxx identifier.  For
//    each icon file, its should have both 32x32 and 16x16 size icon on
//    different display. (ie. monochrome).
//
//    Common UI will try to load the correct size of icon from the icon
//    resource, but it will stretch them if the size is not found.
//
//

//
// Flags for the OPTTYPE
//
//

#define OPTPF_HIDE                  0x01
#define OPTPF_DISABLED              0x02
#define OPTPF_ICONID_AS_HICON       0x04
#define OPTPF_OVERLAY_WARNING_ICON  0x08
#define OPTPF_OVERLAY_STOP_ICON     0x10
#define OPTPF_OVERLAY_NO_ICON       0x20
#define OPTPF_USE_HDLGTEMPLATE      0x40

typedef struct _OPTPARAM {
    WORD        cbSize;         // size of this structure
    BYTE        Flags;          // OPTPF_xxxx flags
    BYTE        Style;          // style use in this structure
    LPTSTR      pData;          // pointer to the data
    ULONG_PTR   IconID;         // iconID;
    LPARAM      lParam;         // parameter used
    ULONG_PTR   dwReserved[2];  // reserved dword, must be 0
    } OPTPARAM, *POPTPARAM;


//
// OPTPARAM
//
//  The OPTPARAM structure is used to describe each slectable item in the
//  common UI such as 'letter', 'legal' in the form slection list box
//
//  cbSize      - size of this structure
//
//  Flags       - defined as OPTPF_xxxx
//
//                  OPTPF_HIDE
//
//                      Specified hide this listed selection item and not
//                      availabe for user to select. This only available to
//                      following TVOT_xxx types
//
//                          TVOT_3STATES
//                          TVOT_LISTBOX
//                          TVOT_COMBOBOX
//
//                      If all the seclection items are OPTPF_HIDE then the
//                      OPTITEM is automatically hided by the common UI, if
//                      TVOT_3STATES has 2 states hide then an error is
//                      returned
//
//
//                  OPTPF_DISABLED
//
//                      Specified this listed selection item is disabled and
//                      not availabe for user to select.   This only available
//                      to following TVOT_xxx types
//
//                          TVOT_2STATES
//                          TVOT_3STATES
//                          TVOT_LISTBOX
//                          TVOT_COMBOBOX
//
//
//                  OPTPF_ICONID_AS_HICON
//
//                      If this flag is set then IconID DWORD field is treated
//                      as a handle to the icon rather then the resource ID
//
//
//                  OPTPF_OVERLAY_WARNING_ICON
//
//                      If this bit is set then this OPTPARAM item's icon will
//                      be overlaied by a common UI's IDI_CPSUI_WARNING icon.
//
//
//                  OPTPF_OVERLAY_STOP_ICON
//
//                      If this bit is set then this OPTPARAM item's icon will
//                      be overlaied by a common UI's IDI_CPSUI_STOP icon.
//
//
//                  OPTPF_OVERLAY_NO_ICON
//
//                      If this bit is set then this OPTPARAM item's icon will
//                      be overlaied by a common UI's IDI_CPSUI_NO icon.
//
//
//  Style       - Style for the OPTPARAM, it depends on the TVOT_xxx type as
//                describe below
//
//                  TVOT_PUSBUTTON
//
//                      it can be one of PUSHBUTTON_TYPE_xxxx.
//
//                  other TVOT_xxxx
//
//                      this fields is not used.
//
//
//  pData       - Is either a pointer to the item name (string) or it is
//                used to describe other data.
//
//                   * If the pData in the OPTPARAM is supposed to be a static
//                     pointer to a string and the string is a common UI
//                     standard resource ID then common UI will check if pData
//                     is equal to IDS_CPSUI_NOTINSTALLED, if true then
//                     common UI will overaly a not installed icon on top of
//                     the OPTPARAM's Icon.   This will not applied to the
//                     TVOT_EDITBOX type since the pData is not a static text
//                     pointer or a string resource ID.
//
//                  ** See LPTSTR description above
//
//  IconID      - This is the icon identifier, which can be a common strandard
//                IDI_CPSUI_xxx icon ID, caller's own icon resource ID, or a
//                handle to the caller defined icon if OPTPF_ICONID_AS_HICON
//                flag is set, in any case if the IconID is zero then it
//                indicated no icon.
//
//  lParam      - Extra data used by the OPTPARAM, it depends on the TVOT_xxx
//                type.
//
//  dwReserved[]- Reserved DWORDs, must be 0
//
//


#define OPTTF_TYPE_DISABLED             0x01
#define OPTTF_NOSPACE_BEFORE_POSTFIX    0x02


#define OTS_LBCB_SORT                   0x0001
#define OTS_LBCB_PROPPAGE_LBUSECB       0x0002
#define OTS_LBCB_PROPPAGE_CBUSELB       0x0004
#define OTS_LBCB_INCL_ITEM_NONE         0x0008
#define OTS_LBCB_NO_ICON16_IN_ITEM      0x0010
#define OTS_PUSH_INCL_SETUP_TITLE       0x0020
#define OTS_PUSH_NO_DOT_DOT_DOT         0x0040
#define OTS_PUSH_ENABLE_ALWAYS          0x0080


typedef struct _OPTTYPE {
    WORD        cbSize;
    BYTE        Type;           // TVOT_xxxx type of OPTIONS
    BYTE        Flags;          // OPTTF_xxx flags
    WORD        Count;          // Count of pOptParam passed
    WORD        BegCtrlID;      // start of item's group window ID
    POPTPARAM   pOptParam;      // pointer to the OPTPARAM
    WORD        Style;          // option type style as OTS_xxxx
    WORD        wReserved[3];   // wReserved, must be 0
    ULONG_PTR   dwReserved[3];  // DWORD reserved field (must be 0)
} OPTTYPE, *POPTTYPE;


//
// OPTTYPE
//
//  The OPTTYPE structure is used to describe a set of selection and its
//  select method,  such as Form/Tray assignment.  It has a pointer to a set
//  of selection item (OPTPARAM)
//
//
//  cbSize      - size of this structure
//
//  Type        - Specified the option type using predefined ID as TVOT_xxxx
//
//  Flags       - currently only one flag is defined
//
//
//                  OPTTF_TYPE_DISABLED
//
//                      The whole OPTTYPE's OPTPARAMs are disabled, and non of
//                      the selection in the OPTTYPE can be selected
//
//
//                  OPTTF_NOSPACE_BEFORE_POSTFIX
//
//                      This bit only valid if the OPTTYPE's pOptParam item
//                      specified a postfix string as describe in the above
//                      section.  If this flag is set then it asked common UI
//                      do not add a space character before the postfix string
//                      when it combine the pName in the OPTITEM and postfix
//                      string.   Typeically this bit is not set for the
//                      postfix string, but sometime it may be required not to
//                      add a space character in front of it, such as '%'
//                      postfix string.
//
//
//  Count       - Count of item pointed by pOptParam.  Some predefined number
//                must be set according to the TVOT_XXX description.
//
//  BegCtrlID   - Only used if the OPTITEM/OPTTYPE is belong to the the DLGPAGE
//                which has non-common UI dialog box template (DlgTemplateID
//                in the DLGPAGE is not standard DP_STD_xxx common ui dialog
//                box template).    The common UI used this ID to managed
//                caller's dialog boxes item's selections and initialization.
//
//                Each OPTITEM has predefined number of window ID which
//                associated with that item, the BegCtrlID specified the start
//                control window ID.  Each control window ID in the OPTITEM
//                must have the control ID sequence as describe in the TVOT_xxx
//                above.
//
//  pOptParam   - Pointer to array of OPTPARAM to describe each selectable item
//
//  Style       - Specified the style of type of control box, certain style
//                only apply to centain type of TVOT_xxxx.
//
//                OTS_LBCB_xxx only applied to TVOT_LISTBOX, TVOT_COMBOBOX
//                OTS_PUSH_xxx only applied to TVOT_PUSHBUTTON
//
//
//                  OTS_LBCB_SORT
//
//                      Specified that the listbox or combobox item is sorted
//                      in ascending order based on the pData string
//
//
//                  OTS_LBCB_PROPAGE_LBUSECB
//
//                      Used when Type is TVOT_LISTBOX, if it specified and
//                      this OPTTYPE also on the non-treeview user defined
//                      property sheet page dialog then common UI assume
//                      control is comobobox instead of listbox on the non-
//                      treeview page
//
//
//                  OTS_LBCB_PROPAGE_CBUSELB
//
//                      Used when Type is TVOT_COMBOBOX, if it specified and
//                      this OPTTYPE also on the non-treeview user defined
//                      property sheet page dialog then common UI assume
//                      control is listbox instead of combobox on the non-
//                      treeview page
//
//
//                  OTS_LBCB_INCL_ITEM_NONE
//
//                      when this flag is specified, the common ui will
//                      automatically add a 'None' selection to the listbox or
//                      combobox.   The 'Sel' will set to -1 if 'none' is
//                      selection is selected by the user.  It will also
//                      validate the 'Sel' durning the initialization,  any
//                      out of range value will be set to -1 (None).
//
//
//                  OTS_LBCB_NO_ICON16_IN_ITEM
//
//                      By default, each listbox, combox will have a small
//                      icon (16x16) in front of item text. by specified this
//                      bit, the listbox/combobox will not includes icons
//                      in the listbox/combobox.
//
//                      If clear then it specified that in the listbox/combobox
//                      to have 16x16 Icon added to the front of each item
//
//
//                  OTS_PUSH_INCL_SETUP_TITLE
//
//                      If specified for the push button then it automatically
//                      add the 'Setup' to the end of push botton text.
//
//
//                  OTS_PUSH_NO_DOT_DOT_DOT
//
//                      If specified then common UI will not add '...' to the
//                      end of the pName in the OPTITEM and push button name
//
//
//                  OTS_PUSH_ENABLE_ALWAYS
//
//                      This flag specified that even update permissio is not
//                      allowed, it still let user push the push button, if
//                      this flag is set then callback function or dialog box
//                      proc must disable all the control which let user
//                      modified the content, but just let user view the
//                      current setting.
//
//
//  wReserved[] - Reserved fields, must be 0
//
//  dwReserved[]- Reserved fields, must be 0
//
//


//
// Following are flags for the EXTPUSH
//


#define EPF_PUSH_TYPE_DLGPROC       0x0001
#define EPF_INCL_SETUP_TITLE        0x0002
#define EPF_NO_DOT_DOT_DOT          0x0004
#define EPF_ICONID_AS_HICON         0x0008
#define EPF_OVERLAY_WARNING_ICON    0x0010
#define EPF_OVERLAY_STOP_ICON       0x0020
#define EPF_OVERLAY_NO_ICON         0x0040
#define EPF_USE_HDLGTEMPLATE        0x0080


typedef struct _EXTPUSH {
    WORD                cbSize;         // size of the structure
    WORD                Flags;          // EPCBF_xxx flags
    LPTSTR              pTitle;         // extended push botton title
    union {
        DLGPROC         DlgProc;        // pointer to the dialog box proc
        FARPROC         pfnCallBack;    // callback function pointer
        } DUMMYUNIONNAME;
    ULONG_PTR           IconID;         // icon to be used
    union {
        WORD    DlgTemplateID;          // dialog box template ID
        HANDLE  hDlgTemplate;           // handle to the dialog template
        } DUMMYUNIONNAME;
    ULONG_PTR   dwReserved[3];          // reserved field, must be 0
    } EXTPUSH, *PEXTPUSH;

//
// EXTPUSH structure is used to describe the extened push button available
// on OPTITEM/OPTITEM, each OPTTYPE can optional have either one extended check
// box or one extended push button callback.
//
//
//  cbSize          - size of this structure
//
//  Flags           - flags for the EXTPUSH as EPF_xxxx
//
//                      EPF_PUSH_TYPE_DLGPROC
//
//                          If this bit is set then it specified the extended
//                          push button is type of DLGPROC and DlgProc and
//                          DlgTemplateID is valid for common UI to call.
//
//                          If this bit is clear then it specfied the extended
//                          push button is the callback style and pfnCallBack
//                          should be called by the common UI
//
//
//                      EPF_INCL_SETUP_TITLE
//
//                          If specified for the extended push button then it
//                          automatically add the 'Setup' to the end of
//                          extended push button's title
//
//
//                      EPF_NO_DOT_DOT_DOT
//
//                          If specified then common UI will not add '...' to
//                          the end of the pTitle in the EXTPUSH.
//
//
//                      EPF_ICONID_AS_HICON
//
//                          If this flag is set then IconID DWORD field is
//                          treated as a handle to the icon rather then the
//                          resource ID.
//
//
//                      EPF_OVERLAY_WARNING_ICON
//
//                          If this bit is set then this EXTPUSH's icon will be
//                          overlaied by a common UI's IDI_CPSUI_WARNING icon.
//
//
//                      EPF_OVERLAY_STOP_ICON
//
//                          If this bit is set then this EXTPUSH's icon will be
//                          overlaied by a common UI's IDI_CPSUI_STOP icon.
//
//
//                      EPF_OVERLAY_NO_ICON
//
//                          If this bit is set then this EXTPUSH's icon will be
//                          overlaied by a common UI's IDI_CPSUI_NO icon.
//
//
//  pTitle          - Pointed to extended push botton title
//
//                      ** See LPTSTR description above
//
//  DlgProc         - Pointer to the DLGPROC function supplied by the caller.
//                    When user push the button the common UI will call
//                    DialogBoxParam() with this fucction pointer and passed
//                    CPSUICBPARAM structure pointer to the WM_INITDIALOG with
//                    the Reason set to CPSUICB_REASON_EXTPUSH.  If this
//                    filed is NULL then common UI assumed that EXTPUSH is
//                    disabled (OPTIF_EXT_DISABLED | OPTIF_EXT_HIDE), this
//                    fields only used if EPF_PUSH_TYPE_DLGPROC flag is set
//
//  pfnCallBack     - Pointer to CPSUICALLBACK function, this only used if
//                    EPF_PUSH_TYPE_DLGPROC bit is clear, duringing callback
//                    it passed the CPSUICBPARAM pointer as parameter
//
//  IconID          - This is the icon identifier, which can be a common
//                    strandard IDI_CPSUI_xxx icon ID, caller's own icon
//                    resource ID, or a handle to the caller defined icon if
//                    EPF_ICONID_AS_HICON flag is set, in any case if the
//                    IconID is zero then it indicated no icon.
//
//  DlgTemplateID   - Specified the ressource ID for the dilaog box. If the
//                    DlgTemplateID = 0 then common UI will call the DlgProc
//                    with following parameter.
//
//                      DlgProc(hDlg, WM_USER, NULL, (LPARAM)pCPSUICBPaam);
//
//  hDlgTemplate    - Handle to the DLGTEMPLATE which will be use for pop up
//                    dialog box
//
//  wReserved[]     - WORD reserved field, must be 0
//
//  dwReserved[]    - DWORD reserved field, must be 0
//
//
//


//
// Following are flags for the EXTCHKBOX
//

#define ECBF_CHECKNAME_AT_FRONT         0x0001
#define ECBF_CHECKNAME_ONLY_ENABLED     0x0002
#define ECBF_ICONID_AS_HICON            0x0004
#define ECBF_OVERLAY_WARNING_ICON       0x0008
#define ECBF_OVERLAY_ECBICON_IF_CHECKED 0x0010
#define ECBF_OVERLAY_STOP_ICON          0x0020
#define ECBF_OVERLAY_NO_ICON            0x0040
#define ECBF_CHECKNAME_ONLY             0x0080


typedef struct _EXTCHKBOX {
    WORD        cbSize;         // size of the structure
    WORD        Flags;          // ECBF_xxx flags
    LPTSTR      pTitle;         // extended checkbox title
    LPTSTR      pSeparator;     // pointer to separator string for treeview
    LPTSTR      pCheckedName;   // string to be displayed when checked
    ULONG_PTR   IconID;         // icon to be used
    WORD        wReserved[4];   // reserved word, must be 0
    ULONG_PTR   dwReserved[2];  // reserved field, must be 0
    } EXTCHKBOX, *PEXTCHKBOX;


//
// EXTCHKBOX structure is used to describe the extened check box available on
// OPTITEM/OPTITEM, each OPTTYPE can optional have one extended check box.
// When using EXTCHKBOX the selection item can be checked or not checked
// based on user input.
//
//
//  cbSize      - size of this structure
//
//  Flags       - flags for the EXTCHKBOX as ECBF_xxxx
//
//                  ECBF_CHECKNAME_AT_FRONT
//
//                      This flag specified how to display item's name and its
//                      checked name in the treeview display.   If this flag is
//                      set then the checked name is display in front of
//                      separator name, otherwise the checked name is displayed
//                      after the separator.  For Example.
//
//                      Flag Set:   pCheckedName pSeparator SelectName
//                      Flag Clear: SelectName pSeparator pCheckedName
//
//
//                  ECBF_CHECKNAME_ONLY_ENABLED
//
//                      If set then it specified that in the treeview display,
//                      it will only show the pCheckedName if this extended
//                      check box is visible and enabled.  Some items may not
//                      desired to display the pCheckedName if the extended
//                      check box is disabled, such as Copy/Collate checkbox.
//
//
//                  ECBF_ICONID_AS_HICON
//
//                      If this flag is set then IconID DWORD field is treated
//                      as a handle to the icon rather then the resource ID
//
//
//                  ECBF_OVERLAY_WARNING_ICON
//
//                      If this bit is set then this EXTCHKBOX's icon will
//                      be overlaied by a common UI's IDI_CPSUI_WARNING icon.
//
//
//                  ECBF_OVERLAY_ECBICON_IF_CHECKED
//
//                      This bit specified to overlay the ExtChkBox's Icon to
//                      the OPTITEM's icon (or OPTPARAM) if the the extended
//                      checked box is checked
//
//
//                  ECBF_OVERLAY_STOP_ICON
//
//                      If this bit is set then this EXTCHKBOX's icon will
//                      be overlaied by a common UI's IDI_CPSUI_STOP icon.
//
//
//                  ECBF_OVERLAY_NO_ICON
//
//                      If this bit is set then this EXTCHKBOX's icon will
//                      be overlaied by a common UI's IDI_CPSUI_NO icon.
//
//
//  pTitle      - Pointed to extended check box title
//
//                  ** See LPTSTR description above
//
//  pSeparator  - Pointer to the separator to be used in the treeview
//                display or the static title control in the non-treeview
//                page,
//
//  pCheckedName- Pointed to the name to be displayed in the treeview if item
//                is checked.  pCheckedName is added according to the
//                pSeparator and the ECBF_CHECKNAME_AT_FRONT flags.
//
//                  * If the pCheckedName is equal to IDS_CPSUI_NOTINSTALLED
//                    then common UI will automatically overaly a not installed
//                    icon on top of the extended check box Icon.
//
//                      ** See LPTSTR description above
//
//  IconID      - This is the icon identifier, which can be a common strandard
//                IDI_CPSUI_xxx icon ID, caller's own icon resource ID, or a
//                handle to the caller defined icon if ECBF_ICONID_AS_HICON
//                flag is set, in any case if the IconID is zero then it
//                indicated no icon.
//
//  wReserved[] - WORD reserved field, must be 0
//
//  dwReserved[]- DWORD reserved field, must be 0
//


//
// Following the the Flags for the OPTITEM
//

#define OPTIF_COLLAPSE              0x00000001L
#define OPTIF_HIDE                  0x00000002L
#define OPTIF_CALLBACK              0x00000004L
#define OPTIF_CHANGED               0x00000008L
#define OPTIF_CHANGEONCE            0x00000010L
#define OPTIF_DISABLED              0x00000020L
#define OPTIF_ECB_CHECKED           0x00000040L
#define OPTIF_EXT_HIDE              0x00000080L
#define OPTIF_EXT_DISABLED          0x00000100L
#define OPTIF_SEL_AS_HICON          0x00000200L
#define OPTIF_EXT_IS_EXTPUSH        0x00000400L
#define OPTIF_NO_GROUPBOX_NAME      0x00000800L
#define OPTIF_OVERLAY_WARNING_ICON  0x00001000L
#define OPTIF_OVERLAY_STOP_ICON     0x00002000L
#define OPTIF_OVERLAY_NO_ICON       0x00004000L
#define OPTIF_INITIAL_TVITEM        0x00008000L
#define OPTIF_HAS_POIEXT            0x00010000L

#define OPTIF_MASK                  0x0001ffffL


#define DMPUB_NONE                  0
#define DMPUB_FIRST                 1

#define DMPUB_ORIENTATION           1
#define DMPUB_SCALE                 2
#define DMPUB_COPIES_COLLATE        3
#define DMPUB_DEFSOURCE             4
#define DMPUB_PRINTQUALITY          5
#define DMPUB_COLOR                 6
#define DMPUB_DUPLEX                7
#define DMPUB_TTOPTION              8
#define DMPUB_FORMNAME              9
#define DMPUB_ICMMETHOD             10
#define DMPUB_ICMINTENT             11
#define DMPUB_MEDIATYPE             12
#define DMPUB_DITHERTYPE            13
#define DMPUB_OUTPUTBIN             14
#define DMPUB_QUALITY               15
#define DMPUB_NUP                   16
#define DMPUB_PAGEORDER             17

#define DMPUB_LAST                  17

#define DMPUB_OEM_PAPER_ITEM        97
#define DMPUB_OEM_GRAPHIC_ITEM      98
#define DMPUB_OEM_ROOT_ITEM         99
#define DMPUB_USER                  100

#define MAKE_DMPUB_HIDEBIT(DMPub)   (DWORD)(((DWORD)0x01 << ((DMPub) - 1)))
#define IS_DMPUB_HIDDEN(dw, DMPub)  (BOOL)((DWORD)(dw) &                    \
                                           MAKE_DMPUB_HIDEBIT(DMPub))

//
// DMPUB_xxxx is used in OPTITEM to identify if the item is a DEVMODE public
// field. Following it identify which field correspond to the DMPUB_xxxx
//
//
//  DMPUB_ORIENTATION   - dmOrientation
//
//  DMPUB_SCALE         - dmScale
//
//  DMPUB_COPIES_COLLATE- dmCopies/dmCollate
//
//  DMPUB_DEFSOURCE     - dmDefSource    (Should only used form by caller)
//
//  DMPUB_PRINTQUALITY  - dmPrintQuality
//
//  DMPUB_COLOR         - dmColor
//
//  DMPUB_DUPLEX        - dmDuplex
//
//  DMPUB_TTOPTION      - dmTTOption
//
//  DMPUB_FORMNAME      - dmFormName
//
//  DMPUB_ICMMETHOD     - dmICMMethod
//
//  DMPUB_ICMINTENT     - dmICMIntent
//
//  DMPUB_MEDIATYPE     - dmMediaType
//
//  DMPUB_DITHERTYPE    - dmDitherType
//
//  DMPUB_USER          - Anything greater than or equal to DMPUB_USER can be
//                        used by the caller.
//
//  DMPUB_OUTPUTBIN     - Private
//
//  DMPUB_QUALITY       - Private
//
//  DMPUB_NUP           - Private
//
//  DMPUB_PAGEORDER     - Private
//
// When common UI is called for the 'Document Properties' (DEVMODE), it will
// group some of public items together simillar to the following in the
// treeview. How it group is common UI version dependent and caller should not
// concern its placement
//
//      Paper/Output                (Add in by the common UI)
//        Document Form             (DMPUB_FORMNAME)
//        Output Bin                (DMPUB_OUTPUTBIN)
//        Orientation               (DMPUB_ORIENTATION)
//        Source                    (DMPUB_DEFSOURCE)
//        Media                     (DMPUB_MEDIATYPE)
//        Number of Copies          (DMPUB_COPIES_COLLATE)
//        Page Order                (DMPUB_PAGEORDER)
//        Page Per Sheet            (DMPUB_NUP)
//        Duplex                    (DMPUB_DUPLEX)
//
//      Graphic                     (Add in by the common UI)
//        Print Quality             (DMPUB_PRINTQUALITY)
//        Quality Settings          (DMPUB_QUALITY)
//        Color                     (DMPUB_COLOR)
//          Image Color Matching    (Add in by the common UI)
//              ICM Method          (DMPUB_ICMMETHOD)
//              ICM Intent          (DMPUB_ICMINTENT)
//        Scaling                   (DMPUB_SCALE)
//        Dithering                 (DMPUB_DITHERTYPE)
//        TrueType Option           (DMPUB_TTOPTION)
//
//      Options
//        Halftone Color Adjustment...
//        ALL Other Caller's Document sticky options
//
//
//  For 'Document Properties' the standard page 1 (user friendly page) will
//  consist following items if it appear in the OPTITEM array passed by the
//  caller.   These items must have following predefined TVOT_xxx type
//  defined here and specified in the OPTTYPE's Type field.
//
//  All DMPUB_xxx (except >= DMPUB_USER) public ID must have following
//  TVOT_xxxx type specified, else a CPDU_INVALID_DMPUB_TVOT error is returned
//
//      DMPUB_ORIENTATION       - TVOT_2STATES/TVOT_3STATES
//      DMPUB_SCALE             - TVOT_UDARROW
//      DMPUB_COPIES_COLLATE    - TVOT_UDARROW + EXTCHKBOX (Collate)
//      DMPUB_DEFSOURCE         - TVOT_LISTBOX
//      DMPUB_PRINTQUALITY      - TVOT_LISTBOX
//      DMPUB_COLOR             - TVOT_2STATES
//      DMPUB_DUPLEX            - TVOT_2STATES/TVOT_3STATES
//      DMPUB_TTOPTION          - TVOT_LISTBOX
//      DMPUB_FORMNAME          - TVOT_LISTBOX
//      DMPUB_ICMMETHOD         - TVOT_2STATES/TVOT_3STATES
//      DMPUB_ICMINTENT         - TVOT_2STATES/TVOT_3STATES
//      DMPUB_MEDIATYPE         - TVOT_LISTBOX
//      DMPUB_DITHERTYPE        - TVOT_LISTBOX
//
//


#define OIEXTF_ANSI_STRING      0x0001

typedef struct _OIEXT {
    WORD        cbSize;
    WORD        Flags;
    HINSTANCE   hInstCaller;
    LPTSTR      pHelpFile;
    ULONG_PTR   dwReserved[4];
    } OIEXT, *POIEXT;

//
// OIEXT is a data structure used as extension to the OPTITEM data structure
//
//
//  cbSize      - sizeof this structure
//
//  Flags       - One or more of OIEXTF_xxxx may be specified.
//
//                  OIEXTF_ANSI_STRING
//
//                      Specified that LPTSTR in this data structure is a ansi
//                      string (not UNICODE).  This bit only checked if the
//                      LPTSTR is not the resource string ID
//
//  hInstCaller - DLL instance handle, when this hInst is not NULL then all
//                resource string and icon loading for this OPTITEM and its
//                OPTTYPE, OPTPARAM are loaded from this hInstCaller Handle.
//                If this filed is NULL then it will use the hInstCaller handle
//                specified in the COMPROPSHEETUI data structure
//
//  pHelpFile   - Resource string ID or pointer to the help file for this
//                OPTITEM.  If this pointer is NULL then help file for the
//                help index is assume specified in the pHelpFile field in the
//                COMPROPSHEETUI data structure.
//
//  dwReserved  - These fields are not used now, and must 0
//


typedef struct _OPTITEM {
    WORD        cbSize;                 // size of this structure
    BYTE        Level;                  // level in the tree view
    BYTE        DlgPageIdx;             // Index to the pDlgPage
    DWORD       Flags;                  // OPTIF_xxxx flags
    ULONG_PTR   UserData;               // caller's own data
    LPTSTR      pName;                  // name of the item
    union {
        LONG    Sel;                    // current selection (index)
        LPTSTR  pSel;                   // current selection (pStr)
        } DUMMYUNIONNAME;
    union {
        PEXTCHKBOX  pExtChkBox;         // Pointer to EXTCHKBOX structure
        PEXTPUSH    pExtPush;           // Pointer to EXTPUSH
        } DUMMYUNIONNAME2;
    POPTTYPE    pOptType;               // pointer to OPTTYPE structure
    DWORD       HelpIndex;              // Help file index
    BYTE        DMPubID;                // Devmode public filed ID
    BYTE        UserItemID;             // caller's own item ID
    WORD        wReserved;              // reserved WORD field, must be 0
    POIEXT      pOIExt;                 // Optitem extension pointer
    ULONG_PTR   dwReserved[3];          // reserved DWORD fields (must be 0)
    } OPTITEM, *POPTITEM;

//
// OPTITEM is to describe each treeview item's name, selection type and
// possible selection
//
//  cbSize          - sizeof this structure
//
//  Level           - The level in the treeview, the root should have lowest
//                    number and number should start with level 0.  the maximum
//                    number of levels are 256.
//
//  DlgPageIdx      - Zero-based index to the DLGPAGE araay pointee by
//                    pDlgPage. The Maximum index is MAX_DLGPPAGE_COUNT, if
//                    pDlgPage is a standard CPSUI_PDLGPAGE_xxxx then this
//                    field is automatically set the common UI
//
//  Flags           - OPTIF_xxxx flags as describe above
//
//                      OPTIF_COLLAPSE
//
//                          Collaspe treeview item and its children so it is
//                          not expanded initially.
//
//
//                      OPTIF_HIDE
//
//                          Hide this item from the treeview
//
//
//                      OPTIF_CALLBACK
//
//                          Callback to the caller when user making some
//                          changes a pointer (pfnCallBack) must provided and
//                          process as defined by the common UI.
//
//
//                      OPTIF_CHANGED
//
//                          This item was changed and need to re-display. this
//                          flag only used when caller returned from callback
//                          funciton.
//
//
//                      OPTIF_CHANGEONCE
//
//                          This item has been changed at least once.
//
//
//                      OPTIF_DISABLED
//
//                          Disable this item so it become not selectable.
//
//
//                      OPTIF_ECB_CHECKED
//
//                          Specified the associated extended check box is
//                          in checked state.
//
//
//                      OPTIF_EXT_HIDE
//
//                          Hide the extended check box/extended push botton.
//
//
//                      OPTIF_EXT_DISABLED
//
//                          The Extended check box/push botton is disabled and
//                          not selectable
//
//
//                      OPTIF_SEL_AS_HICON
//
//                          This flag only used if this item has no type,
//                          pOptType=NULL that is, when pOptType is NULL then
//                          'Sel' field is the IconID. if flag is set then it
//                          indicate 'pSel' is the Icon handle rather
//                          than the icon resource ID specified in Sel.
//
//
//                      OPTIF_EXT_IS_EXTPUSH
//
//                          Specified that pExtPush should be used when this
//                          pointer is not NULL, if this pointer is not NULL
//                          and this flag is clear then pExtChkBox is assumed.
//
//
//                      OPTIF_NO_GROUPBOX_NAME
//
//                          Specified that do not overwrite the group box title
//                          text, if group box ID is defined. See the TVOT_xx
//                          description above.
//
//
//                      OPTIF_OVERLAY_WARNING_ICON
//
//                          If this bit is set then this header OPTITEM's icon
//                          will be overlaied by a common UI's
//                          IDI_CPSUI_WARNING icon.  This bit only used if this
//                          item has no type, pOptType is NULL that is.
//
//
//                      OPTIF_OVERLAY_STOP_ICON
//
//                          If this bit is set then this header OPTITEM's icon
//                          will be overlaied by a common UI's IDI_CPSUI_STOP
//                          icon.  This bit only used if this item has no type,
//                          pOptType is NULL that is.
//
//
//                      OPTIF_OVERLAY_NO_ICON
//
//                          If this bit is set then this header OPTITEM's icon
//                          will be overlaied by a common UI's IDI_CPSUI_NO
//                          icon.  This bit only used if this item has no type,
//                          pOptType is NULL that is.
//
//
//                      OPTIF_INITIAL_TVITEM
//
//                          Specified that this item will be the initial item
//                          to be selected and display on the treeview page.
//                          If the selected item is currently a child or
//                          collapse then common UI will expand the selection
//                          then scroll it into view.
//
//                          If this flag is clear or the set item is in hide
//                          status common UI will pick the initial item to
//                          display.
//
//                      OPTIF_HAS_POIEXT
//
//                          Specified that pOIExt field is a valid pointer that
//                          points to OIEXT data structure.  The pOIExt only
//                          used by the common UI if this bit is set.
//
//
//  UserData        - a 32-bit number used by the caller and common UI will not
//                    modify it.
//
//  pName           - Pointer to the item's name, such as 'Upper Tray',
//                    'Memory' or it is used as data as describe in
//                    OPTPARAM/OPTTYPE structure
//
//                      ** See LPTSTR description above
//
//  pSel
//  Sel             - Current selection for this item. This is a union field
//                    which can be a pointer to a string or a LONG index
//                    selection.
//
//                      ** If pOptType field is NULL then 'Sel' is the icon ID
//                         to be used for the header.
//
//  pExtPush
//  pExtChkBox      - Pointer to either EXTPUSH or EXTCHKBOX data structure,
//                    if this pointer is NULL then this item does not have
//                    ectended check box/push botton associate with it.
//
//                    When an extended check box is associate with the
//                    OPTTYPE, the OPTIF_EXT_IS_EXTPUSH must not set, the
//                    OPTIF_ECB_CHECKED flag specified if the extended check
//                    box is checked or not checked.
//
//                    When an Extended push botton is associated with the
//                    OPTTYPE, the OPTIF_EXT_IS_EXTPUSH flag must set.
//
//                    The following flags are used in both EXTCHKBOX or
//                    EXTPUSH
//
//                      OPTIF_EXT_HIDE,
//                      OPTIF_EXT_DISABLED
//                      OPTIF_EXT_CHANGEONCE
//
//
//  pOptType        - Pointer to the OPTTYPE structure to describe the display
//                    and selections of the item.   If this pointer is NULL
//                    then this this item does not have any selection. and it
//                    is used as sub-items' header.
//
//                      * When pOptType is NULL then the 'Sel' is the Icon ID.
//
//
//  HelpIndex       - a index to the help file for context sensitive help
//                    if HelpInex=0 then there is no help for this item
//
//  DMPubID         - specified if this item is one of the public fields in the
//                    DEVMODE structure and supported by the common UI.
//
//                      DMPUB_NONE              - Not DEVMODE public fields
//                      DMPUB_ORIENTATION       - dmOrientation
//                      DMPUB_SCALE             - dmScale
//                      DMPUB_COPIES_COLLATE    - dmCopies/dmCollate
//                      DMPUB_DEFSOURCE         - dmDefSource
//                      DMPUB_PRINTQUALITY      - dmPrintQuality
//                      DMPUB_COLOR             - dmColor
//                      DMPUB_DUPLEX            - dmDuplex
//                      DMPUB_TTOPTION          - dmTTOption
//                      DMPUB_FORMNAME          - dmFormName
//                      DMPUB_ICMMETHOD         - dmICMMethod
//                      DMPUB_ICMINTENT         - dmICMIntent
//                      DMPUB_MEDIATYPE         - dmMediaType
//                      DMPUB_DITHERTYPE        - dmDitherType
//
//                      ** for most of DMPUB_FIRST to DMPUB_LAST each OPTITEM's
//                         pName is automatically set to the standard
//                         IDS_CPSUI_xxx for the consistancy reason, the
//                         standard pName is set according to following table.
//
//                          DMPUB_ORIENTATION    - IDS_CPSUI_ORIENTATION
//                          DMPUB_SCALE          - IDS_CPSUI_SCALING
//                          DMPUB_COPIES_COLLATE - IDS_CPSUI_COPIES
//                          DMPUB_DEFSOURCE      - IDS_CPSUI_SOURCE
//                          DMPUB_PRINTQUALITY   - IDS_CPSUI_PRINTQUALITY
//                                                 IDS_CPSUI_RESOLUTION
//                          DMPUB_COLOR          - IDS_CPSUI_COLOR_APPERANCE
//                          DMPUB_DUPLEX         - IDS_CPSUI_DUPLEX
//                          DMPUB_TTOPTION       - IDS_CPSUI_TTOPTION
//                          DMPUB_FORMNAME       - IDS_CPSUI_FORMNAME
//                          DMPUB_ICMMETHOD      - IDS_CPSUI_ICMMETHOD
//                          DMPUB_ICMINTENT      - IDS_CPSUI_ICMINTENT
//                          DMPUB_MEDIATYPE      - IDS_CPSUI_MEDIA
//                          DMPUB_DITHERTYPE     - IDS_CPSUI_DITHERING
//
//                          for DMPUB_PRINTQUALITY, if the pName is not one of
//                          IDS_CPSUI_PRINTQUALITY or IDS_CPSUI_RESOLUTION then
//                          common UI will automatically default the pName to
//                          IDS_CPSUI_RESOLUTION.
//
//                          Each pData (OPTPARAM) selection in OPTPARAM which
//                          OPTITEM's pOptType pointed to should use as much
//                          as IDS_CPSUI_xxx standard name as possible.
//
//
//                      ** for DMPUB_COPIES_COLLATE the common UI automatically
//                         doing the following before the callback
//
//                          1) Enable/Disable the collate extended check box if
//                             OPTIF_EXT_HIDE is not specified and pExtChkBox
//                             is not NULL in the OPTITEM.
//
//                          2) Automatically change the postfix for this item
//                             to be 'Copy' if selection is one, and 'Copies'
//                             if selection is greater than one in the treeview
//                             page, and it will also set the postfix in
//                             standard document property page if the postfix
//                             ID is provided (BegCtrlID + 4)
//
//
//                      ** for DMPUB_COLOR the common UI automatically doing
//                         the following before the callback, the gray
//                         selection must be Sel=0 and Color slection must be
//                         Sel=1
//
//                          1) Calling halftone color adjustment with current
//                             color/mono selection
//
//                          2) Disable ICM when color is not selected
//
//
//                      ** Please see above DMPUB_xx description for details.
//
//  UserItemID      - This is a byte ID intented to be used by the caller to
//                    identify the item
//
//  wReserved       - WORD reserved. Must be zero
//
//  pOIExt          - Pointer to the OIEXT data structure to specified that
//                    it has a OPTITEM extenstion structure.
//
//  dwReserved[]    - DWORD reserved and must be 0
//
//

//
// predefined ID for call back reason
//

#define CPSUICB_REASON_SEL_CHANGED      0
#define CPSUICB_REASON_PUSHBUTTON       1
#define CPSUICB_REASON_ECB_CHANGED      2
#define CPSUICB_REASON_DLGPROC          3
#define CPSUICB_REASON_UNDO_CHANGES     4
#define CPSUICB_REASON_EXTPUSH          5
#define CPSUICB_REASON_APPLYNOW         6
#define CPSUICB_REASON_OPTITEM_SETFOCUS 7
#define CPSUICB_REASON_ITEMS_REVERTED   8
#define CPSUICB_REASON_ABOUT            9
#define CPSUICB_REASON_SETACTIVE        10
#define CPSUICB_REASON_KILLACTIVE       11


//
// predefined ID for call back action
//

#define CPSUICB_ACTION_NONE             0
#define CPSUICB_ACTION_OPTIF_CHANGED    1
#define CPSUICB_ACTION_REINIT_ITEMS     2
#define CPSUICB_ACTION_NO_APPLY_EXIT    3
#define CPSUICB_ACTION_ITEMS_APPLIED    4


typedef struct _CPSUICBPARAM {
    WORD        cbSize;             // size of this structure
    WORD        Reason;             // CPSUICB_REASON_XXXXX callback reason
    HWND        hDlg;               // handle of the dialog box
    POPTITEM    pOptItem;           // pOptItem field from COMPROPSHEETUI
    WORD        cOptItem;           // cOptItem field from COMPROPSHEETUI
    WORD        Flags;              // flags field from COMPROPSHEETUI
    POPTITEM    pCurItem;           // current selected item of callback
    union {
        LONG    OldSel;             // Last selection (index)
        LPTSTR  pOldSel;            // Last selection (pStr)
        } DUMMYUNIONNAME;
    ULONG_PTR   UserData;           // UserData in the COMPROPSHEETUI struct.
    ULONG_PTR   Result;             // OUT parameter for the APPLYNOW
    } CPSUICBPARAM, *PCPSUICBPARAM;


typedef LONG (APIENTRY *_CPSUICALLBACK)(PCPSUICBPARAM pCPSUICBParam);
#define CPSUICALLBACK   LONG APIENTRY


//
// CPSUICBPARAM is used when commom UI callback to the caller, this structure
// describe the nature of callback and passed all necessary parameter for the
// caller to make changes in the pOptItem and passed an action back to the
// commom UI to redisplay the tree or page 1 data
//
//
//  cbSize      - must be CPSUICBPARAM
//
//  Reason      - defined the nature of the callback
//
//                  CPSUICB_REASON_SEL_CHANGED
//
//                      User make change to the pCurItem.  if the item is
//                      DMPUB_COPIES_COLLATE then common UI automatically
//                      change the collate extended check box without callback
//                      to the caller of the extended check box changes
//
//
//                  CPSUICB_REASON_PUSHBUTTON
//
//                      User push the push button and push button item is set
//                      to PUSHBUTTON_TYPE_CALLBACK.
//
//
//                  CPSUICB_REASON_ECB_CHANGED
//
//                      User make change to the extended checked box (i.e. it
//                      eiterh checked or not checked) EXTCHKBOX in the
//                      pCurItem passed in the call back parameter.
//
//
//                  CPSUICB_REASON_DLGPROC
//
//                      The callback reason is PUSHBUTTON_TYPE_DLGPROC
//
//
//                  CPSUICB_REASON_UNDO_CHANGES
//
//                      This callback currently is not implmented.
//
//
//                  CPSUICB_REASON_EXTPUSH
//
//                      The callback is result of user push the extend push
//                      button.
//
//
//                  CPSUICB_REASON_APPLYNOW
//
//                      The user press the apply now button. Durning callback
//                      the pCurItem is set to equal to pOptItem in this
//                      structure and 'OldSel' is set to the active DlgPageIdx
//                      (compare to the OPTITEM's DlgPageIdx) which the page
//                      user hitting the apply now button if the page is
//                      non-treeview page, otherwise the 'OldSel' is set to -1
//                      (for treeview page) to indicate all valid item should
//                      be apply now, if the callback return
//                      CPSUICB_ACTION_NONE then the common UI will exit the
//                      property sheet and returned CPSUI_OK back to the
//                      caller, and if the callback function returned
//                      CPSUICB_ACTION_NO_APPLY_EXIT then common UI will not
//                      exit the property sheet and callback function must
//                      pop-up messages dialog box to tell user why it cannot
//                      exist the property sheet until certain action is take
//                      by the user.
//
//
//                  CPSUICB_REASON_OPTITEM_SETFOCUS
//
//                      This callback reason is used when an OPTITEM is getting
//                      the keyboard focus. and give the callback function a
//                      chance to examine the item.
//
//
//                  CPSUICB_REASON_ITEMS_REVERTED
//
//                      This callback reason is used when user changed items
//                      and decided to revert changes from the parent item in
//                      the treeview.  The callback funciton is called after
//                      all revertable items are reverted to its original.
//
//                      The CPSUICBPARAM's pCurItem is same as pOptItem and
//                      'OldSel' field is same as cOptItem field.  for each of
//                      reverted item, the OPTIF_CHANGED bit will be set in the
//                      OPTITEM by the common UI to indicate the item is revert
//                      by the common UI.   The callback function MUST NOT
//                      reset this bit if it is set.
//
//
//                  CPSUICB_REASON_ABOUT
//
//                      This callback reason is used when user hit 'About...'
//                      push button in the treeview page, and the flag
//                      CPSUIF_ABOUT_CALLBACK is set.  The pCurItem is set to
//                      same as pOptItem and 'pOldSel' is a pointer pointed to
//                      original copy of COMPROPSHEETUI data structure which
//                      passed to the common UI.
//
//
//                  CPSUICB_REASON_SETACTIVE
//                  CPSUICB_REASON_KILLACTIVE
//
//                      The current property sheet is gaining or loosing focus,
//                      the pCurItem is set to equal to pOptItem in this
//                      structure and 'OldSel' is set to the current active
//                      DlgPageIdx (compare to the OPTITEM's DlgPageIdx).
//                      if the page is non-treeview page, otherwise the
//                      'OldSel' is set to -1 (for treeview page).
//
//  hDlg        - The handle to the dialog box (Properties page TAB) current
//                active for the callback.
//
//                Durning the callback the caller must not change the
//                DWLP_USERDATA on hDlg, otherwise the common UI will be crash.
//                If callback function need to get/set DWLP_USERDATA it should
//                call common UI's SetCPSUIUserData() and GetCPSUIUserData()
//                functions instead.
//
//  pCurItem    - Pointed to POPTITEM which the callback is generated for.
//
//  pOldSel
//  OldSel      - The last OPTITEM's pSel/Sel field before the change was made
//                by the user.  The pOldSel/OldSel only valid if the callback
//                reason is CPSUICB_REASON_SEL_CHANGED, this give the callback
//                function a chance to check against the previous item
//                selection.  This is a union field which can be a pointer to
//                a string or a LONG index selection.
//
//  UserData    - a 32-bit user defined data in the COMPROPSHEETUI structure,
//                commom UI will not changed it.
//
//  Result      - When the reason is CPSUICB_REASON_APPLYNOW, the callback
//                function MUST set the requested result for the caller into
//                'Result' field when it returned a value other than the
//                CPSUICB_ACTION_NO_APPLY_EXIT and common UI will send the
//                'Result' field value to this page's parent.
//
//                The called function should save the current result of
//                pOptItem.  The default 'Result' is set to CPSUI_OK (1) from
//                common UI.  This function can alter this result before it
//                return back to to the common UI.
//
//
//  Return Values:
//
//      CPSUICB_ACTION_NONE             - No action need to be take by the
//                                        common UI.
//
//      CPSUICB_ACTION_OPTIF_CHANGED    - Ask the common UI to examine the
//                                        OPTIF_CHANGED flag in the OPTITEM
//                                        data structure.  if the flag is set
//                                        then that item is assume need to be
//                                        re-display because of OPTITEM's Flags
//                                        field changed or item's selection
//                                        changed.   This is different from
//                                        CPSUICB_ACTION_REINIT_ITEMS which
//                                        it assume OPTTYPE or OPTPARAM data
//                                        also changed.
//
//
//      CPSUICB_ACTION_REINIT_ITEMS     - Ask the common UI to examine the
//                                        OPTIF_CHANGED flag in the OPTITEM
//                                        data structure.  if the flag is set
//                                        then that item is assume need to be
//                                        re-initialized in the dilaog box
//                                        control.  This happened if item's
//                                        OPTTYPE or OPTPARAMs flag/pdata
//                                        changed.
//
//
//      CPSUICB_ACTION_NO_APPLY_EXIT    - This return value only valid durning
//                                        CPSUICB_REASON_APPLYNOW callback
//                                        reason, it tell common UI it has
//                                        some constraints in its OPTITEM which
//                                        must correct or confirm by the user
//                                        before exit.  The callback function
//                                        must display and/or have user taking
//                                        some actions before return this
//                                        action to the common UI
//
//      CPSUICB_ACTION_ITEMS_APPLIED    - When responsed to the
//                                        CPSUICB_REASON_APPLYNOW, if the
//                                        returned action is
//                                        CPSUICB_ACTION_ITEMS_APPLIED then
//                                        common UI will reset OPTIF_CHANGEONCE
//                                        bit and save the new default for the
//                                        future undo operations.
//
//

#define DP_STD_TREEVIEWPAGE             0xFFFF
#define DP_STD_DOCPROPPAGE2             0xFFFE
#define DP_STD_DOCPROPPAGE1             0XFFFD
#define DP_STD_RESERVED_START           0xFFF0

#define MAX_DLGPAGE_COUNT               64

#define DPF_ICONID_AS_HICON             0x0001
#define DPF_USE_HDLGTEMPLATE            0x0002

typedef struct _DLGPAGE {
    WORD        cbSize;         // size of this structure
    WORD        Flags;          // DPF_xxxx flags
    DLGPROC     DlgProc;        // caller's dialog box subclass procedue
    LPTSTR      pTabName;       // pointer to the tab name
    ULONG_PTR   IconID;         // icon to be used
    union {
        WORD    DlgTemplateID;  // dialog box template ID
        HANDLE  hDlgTemplate;   // handle to the dialog template
        } DUMMYUNIONNAME;
    } DLGPAGE, *PDLGPAGE;


//
// DLGPAGE structure describe non-treeview page characteristics
//
//
//  cbSize          - size of this structure
//
//  Flags           - DPF_xxxx flags
//
//                      DPF_ICONID_AS_HICON
//
//                          If this flag is set then IconID DWORD field is
//                          treated as a handle to the icon rather then the
//                          resource ID
//
//
//  DlgProc         - caller's supplied DLGPROC for sub-class the page
//                    dialog box processing,
//
//                    if DlgProc is not NULL then common UI do the following
//                    according the the message received except for the
//                    DP_STD_xxx pages
//
//
//                      WM_INITDIALOG
//
//                          Common UI initialize the dialog box and then call
//                          DlgProc(WM_INITDIALOG) the DlgProc should return
//                          exactly the behavior for the WM_INITDIALOG
//
//                          The lParam in the WM_INITDIALOG data structure is
//                          a pointer to the PROPSHEETPAGE data structure.
//
//                          the lParam field in the PROPSHEETPAGE (lParam
//                          passed to the WM_INITDIALOG) is the UserData
//                          defined in COMPROPSHEETUI data structure
//
//                          To access to the PSPINFO data structure which
//                          associate with this page, use the common UI macro
//                          PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam) where
//                          lParam is the parameter passed to the
//                          WM_INITDIALOG message.
//
//                          The subclass function should save these pointers
//                          for its later use, but it MUST NOT modified the
//                          content of the PSPINFO data structure or system
//                          may crashed.
//
//
//                      OTHER DIALOG MESSAGES
//
//                          Iit call DlgProc() and if it returned the value is
//                          non-zero then common UI assume DlgProc() processed
//                          the message and will not process this message.
//
//                          If the returned vlaue from DlgProc() is zero then
//                          common UI will process this message.
//
//
//                      * Durning the DlgProc the caller must not change the
//                        DWLP_USERDATA on hDlg, otherwise the common UI will
//                        be crash.  If caller need to get/set DWLP_USERDATA it
//                        should call common UI's SetCPSUIUserData() and
//                        GetCPSUIUserData() instead.
//
//  pTabName        - Pointer to a string to describe the TAB title
//
//  IconID          - This is the icon identifier, which can be a common
//                    strandard IDI_CPSUI_xxx icon ID, caller's own icon
//                    resource ID, or a handle to the caller defined icon if
//                    DPF_ICONID_AS_HICON flag is set, in any case if the
//                    IconID is zero then it indicated no icon.
//
//  DlgTemplateID   - The template id to be use for the ProPage, it can be
//                    one of DP_STD_xxxx, the DP_STD_xxx has 240 x 240 dialog
//                    box units.
//
//
//                      DP_STD_TREEVIEWPAGE
//
//                          Specified that this page is a standard treeview
//                          page provided by the common ui.  The treeview page
//                          is a page using treeview display all valid OPTITEM
//                          passed to the common UI.  User can modify every
//                          valid selectable OPTITEM from the treeview page.
//
//                      DP_STD_DOCPROPPAGE
//
//                          Specified that this page is a standard document
//                          property page provided by the common UI
//
//  hDlgTemplate    - Handle to the DLGTEMPLATE which will be use for pop up
//                    dialog box
//
//
//  wReserved[]
//  dwReserved[]    - Reserved fields, must be 0
//
//
//  ** Tips of designing the dialog box controls
//
//      When designing the dialog box controls, each OPTITEM is correspoonds
//      to one input control plus one extended check box or extended push
//      button.  Since common UI will automatically disable and remove
//      OPTIF_HIDE items item from the property sheet and dynamically move
//      other controls, the following tips of designing the dialog box controls
//      should follow.
//
//      * Each item should have one input control plus optional of extended
//        check box/push botton, one icon control and other static controls
//
//      * Each item should occupied whole horizontal spaces of the property
//        sheet, items must not overlay in vertical direction.
//
//      * for TVOT_2STATES, TVOT_3STATES, if it araange radio buttons from
//        left to right in state order (ie. from first state's OPTPARAM to
//        last state's OPTPARAM) then the radio buttons and icons should
//        aligned in the Y coordinate.    If it arrange radio buttons from top
//        to bottom (ie. from first state's OPTPARAM to last state's OPTPARAM)
//        then the radio buttons and icons should aligned in the X coordinate.
//
//        common UI will automatically hide/move the radio buttons to compact
//        the dialog box controls.  If radio buttons/icons are arranged in
//        top/down order and there is other controls obscure in Y direction
//        then radio buttons will only be re-arranged but not remove any white
//        spaces in Y direction.
//
//      * If multiple items shared one group box, then the group box must
//        belongs to the first item (topmost in the dialog box group) in the
//        group, the group box must large enough to cover all the items in
//        side the group box.
//
//


#define CPSUIF_UPDATE_PERMISSION        0x0001
#define CPSUIF_ICONID_AS_HICON          0x0002
#define CPSUIF_ABOUT_CALLBACK           0x0004

#define CPSUI_PDLGPAGE_DOCPROP          (PDLGPAGE)1
#define CPSUI_PDLGPAGE_ADVDOCPROP       (PDLGPAGE)2
#define CPSUI_PDLGPAGE_PRINTERPROP      (PDLGPAGE)3
#define CPSUI_PDLGPAGE_TREEVIEWONLY     (PDLGPAGE)4

//
// For compatible misspelling #define
//

#define CPSUI_PDLGPAGE_TREEVIWONLY      CPSUI_PDLGPAGE_TREEVIEWONLY

typedef struct _COMPROPSHEETUI {
    WORD            cbSize;             // size of this structure
    WORD            Flags;              // CPSUIF_xxxx flags
    HINSTANCE       hInstCaller;        // caller's hInstance
    LPTSTR          pCallerName;        // pointer to the caller's name
    ULONG_PTR       UserData;           // caller's own data
    LPTSTR          pHelpFile;          // pointer to the help file
    _CPSUICALLBACK  pfnCallBack;        // callback function pointer
    POPTITEM        pOptItem;           // pointer to POPTITEM array
    PDLGPAGE        pDlgPage;           // pointer to the DLGPAGE array
    WORD            cOptItem;           // count of pOptItem array
    WORD            cDlgPage;           // count of pDlgPage array
    ULONG_PTR       IconID;             // icon to be used
    LPTSTR          pOptItemName;       // pointer to the optitem's data name
    WORD            CallerVersion;      // version for the caller apps
    WORD            OptItemVersion;     // version for the optitem name
    ULONG_PTR       dwReserved[4];      // reserved, must be 0
    } COMPROPSHEETUI, *PCOMPROPSHEETUI;


//
// COMPROPSHEETUI data structure is used when calling common UI to display dialog
// box of properties pages.
//
//
//  Size                - Must be sizeof (COMPROPSHEETUI)
//
//  Flags               - can be one or more of following
//
//                          CPSUIF_UPDATE_PERMISSION
//
//                              Specified the any valid pOptItem items are
//                              changeable by the user.
//
//
//                          CPSUIF_ICONID_AS_HICON
//
//                              If this flag is set then IconID DWORD field is
//                              treated as a handle to the icon rather then the
//                              resource ID
//
//
//                          CPSUIF_ABOUT_CALLBACK
//
//                              If this flag bit is set, then when user hit
//                              'About...' button in the treeview tab, it will
//                              call the callback function with a reason of
//                              CPSUICB_REASON_ABOUT, and callback MUST handle
//                              the about which pop-up dialog box to show user
//                              the information about the caller and OPTITEMs.
//
//                              If this bit is not set then common UI will call
//                              the ShellAbout() with formatted caller Name and
//                              pOptItemName with version numbers.
//
//
//  hInstCaller         - the caller's handle to its instance.  Commom UI use
//                        this handle to load caller's icon and other resources.
//
//  pCallerName         - Pointer to the caller's NULL terminated caller's
//                        name, most time this is driver's name,
//                        such as 'Postscript Driver'
//
//  UserData            - a 32-bit number used by the caller and common UI will
//                        not modify it.  this 32-bit number is passed back to
//                        the caller durning the callback function
//
//  pHelpFile           - specified a standard microsoft help file (path/file)
//                        for using in the common UI.  in OPTITEM specified
//                        HelpIndex for help in each item.
//
//  pfnCallBack         - Pointer to _CPSUICALLBACK callback function.  Common
//                        UI only callback to the caller if an OPTIF_CALLBACK
//                        is set OPTITEM data structure's flag fields and the
//                        item selection is changed by the user.
//
//  pOptItem            - Pointer to array of OPTITEM structure to be displayed
//                        by the common UI
//
//  pDlgPage            - Pointer to array of DLGPAGE structure to describe
//                        each property sheet page infomation, the following
//                        are the standard common ui DLGPAGEs.  When specified
//                        CPSUI_PDLGPAGE_xxxx, the common UI will automatically
//                        modify DlgPageIdx field in the OPTITEM, caller must
//                        set the iStartPage correctly.
//
//                          CPSUI_PDLGPAGE_DOCPROP
//
//                              specified this a common ui standard document
//                              property sheets. This includes two property
//                              sheets, 1) Page Setup 2) Advance (TreeView)
//
//
//                          CPSUI_PDLGPAGE_ADVDOCPROP
//
//                              Specified this is a treeview page only UI
//                              provided by the common UI, this only has one
//                              treeview page with tab of 'Advance'
//
//
//                          CPSUI_PDLGPAGE_PRINTERPROP
//
//                              Specified this is a common UI standard printer
//                              property sheet.  This only has one treeview
//                              page with tab of 'Device Options'
//
//
//                          CPSUI_PDLGPAGE_TREEVIEWONLY
//
//                              Specified this is a treeview page only UI
//                              provided by the common UI, this only has one
//                              treeview page
//
//
//
//  cOptItem            - Count of OPTITEM pointed by the pOptItem above
//
//  cDlgPage            - Count of DLGPAGE pointed by the pDlgPage.  If
//                        pDlgPage is one of the CPSUI_PDLGPAGE_xxxx then this
//                        field is ignored by the common UI.
//
//  IconID              - This is the icon identifier, which can be a common
//                        strandard IDI_CPSUI_xxx icon ID, caller's own icon
//                        resource ID, or a handle to the caller defined icon
//                        if CPSUIF_ICONID_AS_HICON flag is set, in any case
//                        if the IconID is zero then it indicated no icon.
//
//  pOptItemName        - Pointer to the pOptItem data NULL terminated name,
//                        most time this is device name, such as 'HP 4si'
//
//  CallerVersion       - Version for the caller, the HIBYTE(CallerVersion) is
//                        the major version, and LOBYTE(CallerVersion) is the
//                        minor version, such as 0x310 display as 3.16, 0x3ff
//                        display as 3.255 and 0x30a display as 3.10
//
//  OptItemVersion      - Version for the OPTITEM's data, the
//                        HIBYTE(OptItemVersion) is the major version, and
//                        LOBYTE(OptItemVersion) is the minor version, such as
//                        0x310 display as 3.16, 0x3ff display as 3.255 and
//                        0x30a display as 3.10.
//
//  dwReserved[4]       - reserved fields, must be 0
//
//
//  ** pTitlee and TitleBarIcon only used if CommonPrinterPropSheetUI()
//     is the last one the Property sheet UI chain and call the PropertySheet()
//
//


#define CPSFUNC_ADD_HPROPSHEETPAGE          0
#define CPSFUNC_ADD_PROPSHEETPAGEW          1
#define CPSFUNC_ADD_PCOMPROPSHEETUIA        2
#define CPSFUNC_ADD_PCOMPROPSHEETUIW        3
#define CPSFUNC_ADD_PFNPROPSHEETUIA         4
#define CPSFUNC_ADD_PFNPROPSHEETUIW         5
#define CPSFUNC_DELETE_HCOMPROPSHEET        6
#define CPSFUNC_SET_HSTARTPAGE              7
#define CPSFUNC_GET_PAGECOUNT               8
#define CPSFUNC_SET_RESULT                  9
#define CPSFUNC_GET_HPSUIPAGES              10
#define CPSFUNC_LOAD_CPSUI_STRINGA          11
#define CPSFUNC_LOAD_CPSUI_STRINGW          12
#define CPSFUNC_LOAD_CPSUI_ICON             13
#define CPSFUNC_GET_PFNPROPSHEETUI_ICON     14
#define CPSFUNC_ADD_PROPSHEETPAGEA          15
#define CPSFUNC_INSERT_PSUIPAGEA            16
#define CPSFUNC_INSERT_PSUIPAGEW            17
#define CPSFUNC_SET_PSUIPAGE_TITLEA         18
#define CPSFUNC_SET_PSUIPAGE_TITLEW         19
#define CPSFUNC_SET_PSUIPAGE_ICON           20
#define CPSFUNC_SET_DATABLOCK               21
#define CPSFUNC_QUERY_DATABLOCK             22
#define CPSFUNC_SET_DMPUB_HIDEBITS          23
#define CPSFUNC_IGNORE_CPSUI_PSN_APPLY      24
#define CPSFUNC_DO_APPLY_CPSUI              25
#define CPSFUNC_SET_FUSION_CONTEXT          26
#define MAX_CPSFUNC_INDEX                   26

#ifdef UNICODE
#define CPSFUNC_ADD_PCOMPROPSHEETUI         CPSFUNC_ADD_PCOMPROPSHEETUIW
#define CPSFUNC_ADD_PFNPROPSHEETUI          CPSFUNC_ADD_PFNPROPSHEETUIW
#define CPSFUNC_LOAD_CPSUI_STRING           CPSFUNC_LOAD_CPSUI_STRINGW
#define CPSFUNC_ADD_PROPSHEETPAGE           CPSFUNC_ADD_PROPSHEETPAGEW
#define CPSFUNC_INSERT_PSUIPAGE             CPSFUNC_INSERT_PSUIPAGEW
#define CPSFUNC_SET_PSUIPAGE_TITLE          CPSFUNC_SET_PSUIPAGE_TITLEW

#else
#define CPSFUNC_ADD_PCOMPROPSHEETUI         CPSFUNC_ADD_PCOMPROPSHEETUIA
#define CPSFUNC_ADD_PFNPROPSHEETUI          CPSFUNC_ADD_PFNPROPSHEETUIA
#define CPSFUNC_LOAD_CPSUI_STRING           CPSFUNC_LOAD_CPSUI_STRINGA
#define CPSFUNC_ADD_PROPSHEETPAGE           CPSFUNC_ADD_PROPSHEETPAGEA
#define CPSFUNC_INSERT_PSUIPAGE             CPSFUNC_INSERT_PSUIPAGEA
#define CPSFUNC_SET_PSUIPAGE_TITLE          CPSFUNC_SET_PSUIPAGE_TITLEA

#endif

//
// for the CPSFUNC_SET_RESULT
//

#define SR_OWNER            0
#define SR_OWNER_PARENT     1

typedef struct _SETRESULT_INFO {
    WORD        cbSize;
    WORD        wReserved;
    HANDLE      hSetResult;
    LRESULT     Result;
    } SETRESULT_INFO, *PSETRESULT_INFO;

//
// This is for CPSFUNC_INSERT_PSUIPAGE
//

#define HINSPSUIPAGE_FIRST              (HANDLE)0xFFFFFFFE
#define HINSPSUIPAGE_LAST               (HANDLE)0xFFFFFFFF
#define HINSPSUIPAGE_INDEX(i)           (HANDLE)MAKELONG(i, 0);

#define PSUIPAGEINSERT_GROUP_PARENT     0
#define PSUIPAGEINSERT_PCOMPROPSHEETUI  1
#define PSUIPAGEINSERT_PFNPROPSHEETUI   2
#define PSUIPAGEINSERT_PROPSHEETPAGE    3
#define PSUIPAGEINSERT_HPROPSHEETPAGE   4
#define PSUIPAGEINSERT_DLL              5
#define MAX_PSUIPAGEINSERT_INDEX        5


#define INSPSUIPAGE_MODE_BEFORE         0
#define INSPSUIPAGE_MODE_AFTER          1
#define INSPSUIPAGE_MODE_FIRST_CHILD    2
#define INSPSUIPAGE_MODE_LAST_CHILD     3
#define INSPSUIPAGE_MODE_INDEX          4


typedef struct _INSERTPSUIPAGE_INFO {
    WORD        cbSize;
    BYTE        Type;
    BYTE        Mode;
    ULONG_PTR   dwData1;
    ULONG_PTR   dwData2;
    ULONG_PTR   dwData3;
    } INSERTPSUIPAGE_INFO, *PINSERTPSUIPAGE_INFO;


//
// for the CPSFUNC_SET_HSTARTPAGE
//

#define SSP_TVPAGE          10000
#define SSP_STDPAGE1        10001
#define SSP_STDPAGE2        10002

typedef LONG_PTR (CALLBACK *PFNCOMPROPSHEET)(HANDLE hComPropSheet,
                                             UINT   Function,
                                             LPARAM lParam1,
                                             LPARAM lParam2);


typedef struct _PSPINFO {
    WORD            cbSize;
    WORD            wReserved;
    HANDLE          hComPropSheet;
    HANDLE          hCPSUIPage;
    PFNCOMPROPSHEET pfnComPropSheet;
    } PSPINFO, *PPSPINFO;

//
// PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam) macro retrieve a pointer to the
// PSPINFO data structure. the lParam must be the lParam passed to the
// WM_INITDIALOG, otherwise the system can failed
//

#define PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam)  \
                (PPSPINFO)((LPBYTE)lParam + ((LPPROPSHEETPAGE)lParam)->dwSize)

//
// PSPINFO
//
//  This structure is used durning property sheet page's WM_INITDIALOG message.
//  At WM_INITDIALOG, the lParam is a pointer to the PROPSHEETPAGE, and
//  lParam field in the PROPSHEETPAGE is a pointer to the PSPINFO.  the
//  original lParam in the PROPSHEETPAGE is saved in the lParam field in the
//  PSPINFO data structure.
//
//  When process WM_INITDIALOG message, it should save the lParam (PSPINFO
//  structure pointer) for later to call common UI callback functions.
//
//
//  cbSize          - Size of this structure in bytes
//
//  wReserved       - Reserved, must be set to zero
//
//  hComPropSheet   - Handle to the parent page which is the hComPropSheet
//                    passed to the CPSFUNC_ADD_PROPSHEETPAGE
//
//  hCPSUIPage      - Handle to the this added common UI property sheet page.
//
//  pfnComPropSheet - Pointer to the common UI callback function, using this
//                    function pointer to do CPSFUNC_xxxx
//
//

typedef struct _CPSUIDATABLOCK {
    DWORD   cbData;
    LPBYTE  pbData;
    } CPSUIDATABLOCK, *PCPSUIDATABLOCK;


#define APPLYCPSUI_NO_NEWDEF        0x00000001
#define APPLYCPSUI_OK_CANCEL_BUTTON 0x00000002

//
// PFNCOMPROPSHEET function descriptions
//
// For each function index, it passed a handle, a Function Index and two (2)
// long parameters, the 'hComPropSheet' handle passed must be the handle passed
// from common UI when common UI called the caller supplied function
//
// pfnPropSheetUI(pPropSheetUIData);
//
// Following are the description of each function index
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_HPROPSHEETPAGE
//
//      This function add a page to the hComPropSheet using handle to the
//      PROPSHEETPAGE
//
//
//  Parameters:
//
//      lParam1 - is a handle to the PROPSHEETPAGE that created by the caller
//                using CreatePropertySheetPage()
//
//      lParam2 - Not used, must be 0
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page, if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_PROPSHEETPAGE
//
//      This function add a page to the hComPropSheet using PROPSHEETPAGE
//      data structure.
//
//
//  Parameters:
//
//      lParam1 - is a pointer to PROPSHEETPAGE data structure
//
//      lParam2 - Not used.
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page, if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_PCOMPROPSHEETUI
//
//      This function add propety page(s) to the hComPropSheet handle using
//      COMPROPSHEETUI data structure.
//
//
//  Parameters:
//
//      lParam1 - is a pointer to COMPROPSHEETUI data structure
//
//      lParam2 - pointer to a 32-bit location that received the total pages
//                added by the COMPROPSHEETUI data structure if sucessful else
//                it contains the ERR_CPSUI_xxx error codes.
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page(s), if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_ADD_PFNPROPSHEETUI
//
//      This function add property page(s) to the hChild handle using
//      lParam1 as PFNPROPSHEETUI function pointer and lParam2 as the function
//      parameter.   The common UI call supplied function as following
//
//          PROPSHEETUI_INFO    PSUIInfo;
//
//          PSUIInfo.cbSize          = sizeof(PROPSHEETUI_INFO);
//          PSUIInfo.Version         = PROPSHEETUI_INFO_VERSION;
//          PSUIInfo.Flags           = (Ansi) ? 0: PSUIINFO_UNICODE;
//          PSUIInfo.Reason          = PROPSHEETUI_REASON_INIT;
//          PSUIInfo.hComPropSheet   = hComPropSheet;
//          PSUIInfo.pfnComPropSheet = ComPropSheetUICallBack;
//          PSUIInfo.lParamInit      = lParam2;
//          PSUIInfo.UserData        = 0;
//          PSUIInfo.Result          = 0;
//
//          ((PFNPROPSHEETUI)lParam1)(&PSUIInfo, lParam2);
//
//
//          If the pfnPropSheetUI() need to add/delete any common UI pages then
//          it must use hComPropSheet as its handle when calling the
//          ComPropSheetUICallBack().
//
//
//  Parameters:
//
//      lParam1 - a PFNPROPSHEETUI function pointer.
//
//      lParam2 - a 32-bit data that will be used as lParam when calling
//                PFNPROPSHEETUI function pointer.
//
//
//  Return Value:
//
//      The return value is the newly added property pages function handle, if
//      return value is NULL then function failed or no page is added.
//
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_DELETE_HCOMPROPSHEET
//
//      This function delete child property page(s) from hComPropSheet parent
//      using the child handle passed.
//
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that to be deleted.
//                This handle must be the handle returned from CPSFUNC_ADD_xxx
//                functions.
//
//      lParam2 - not used, must be 0
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_GET_PAGECOUNT
//
//      This function return total property sheet pages belongs to a common
//      UI property sheet page handle hComPropSheet
//
//
//  Parameters:
//
//      lParam1 - not used, must be 0
//
//      lParam2 - not used, must be 0.
//
//
//  Return Value:
//
//      The return value is total page count if function sucessful or zero if
//      function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_RESULT
//
//      This function set the result of property sheet page to its owner that
//      added this page by CPSFUNC_ADD_xxx function indices
//
//  Parameters:
//
//      lParam1 - Handle to the common UI property sheet page that setting the
//                result.  If this handle is NULL then it is treated as
//                equal to the hComPropSheet.
//
//      lParam2 - a 32-bit DWORD result to be set.
//
//
//  Return Value:
//
//      > 0: Successful, return value is total count of parents set the result
//      = 0: There is no owner or parent for the lParam1 handle.
//      < 0: function failed because of invalid lParam1 handle.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_HSTARTPAGE
//
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that to be set
//                as initial page that appear when the property sheet dialog
//                boxes is created.  This handle must be the handle returned
//                from CPSFUNC_ADD_xxx functions.
//
//                If lParam1 is NULL then lParam2 is a string pointer to the
//                page name (tab) that to be set for the start page
//
//      lParam2 - a LONG number to specified the children index. if lParam1
//                handle is a parent then lParam2 specified zero base children
//                index for using as start page.
//
//                It also can be one of following special index
//
//                  SSP_TVPAGE
//
//                      set to the treeview page, this only valid if lParam1
//                      handle was added by the CPSFUNC_ADD_PCOMPROPSHEETUI.
//
//                  SSP_STDPAGE
//
//                      Set to the standard document property sheet page
//                      (Page 1 user friendly page).  this only valid if
//                      lParam1 handle was added by the
//                      CPSFUNC_ADD_PCOMPROPSHEETUI.
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.  This function can only be
//      called when the property sheet is not display yet so the place to
//      call is during the PROPSHEETUI_REASON_GET_INFO_HEADER callback.
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_GET_HPSUIPAGES
//
//      This function return array of children HPROPSHEETPAGE belongs to
//      the parent hComPropSheet UI property sheet page handle hComPropSheet
//
//
//  Parameters:
//
//      lParam1 - Pointer to an array of HPROPSHEETPAGE that to be stored
//                the handle upon return.
//
//      lParam2 - Count of HPROPSHEETPAGE array pointed by the lParam1
//
//
//  Return Value:
//
//      The return value is total HPROPSHEETPAGE stored in the array pointed
//      by the lParam1.   To get all hPropSheetPage for any common property
//      sheet handle's (hCPSUIPage) children, it can use following sequence.
//
//          if ((cPage = pfnComPropSheet(hComPropSheet,
//                                       CPSFUNC_GET_PAGECOUNT,
//                                       (LPARAM)hCPSUIPage,
//                                       0L))   &&
//              (phPage = ALLOCMEM(cPage * sizeof(HANDLE)))) {
//
//              pfnComPropSheet(hCPSUIPage,
//                              CPSFUNC_GET_HPSUIPAGES,
//                              (LPARAM)phPage,
//                              (LPARAM)cPage);
//          }
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_LOAD_CPSUI_STRING
//
//      This function load the common property sheet UI resource string
//
//  Parameters:
//
//      lParam1 - Pointer to LPTSTR string which will stored the loaded
//                resource string from the common property sheet UI DLL.
//
//      lParam2 - LOWORD(lParam2) = Count of characters (includes null
//                                  terminator) which pointed by the lParam1
//
//                HIWORD(lParam2) = Common property sheet UI predefined string
//                                  resource ID as IDS_CPSUI_xxxx
//
//
//  Return Value:
//
//      > 0: Total characters stored in the string pointed by the lParam1, this
//           is not includes the null terminator
//      = 0: Invalid IDS_CPSUI_xxx passed from HIWORD(lParam)
//      < 0: Either lParam1 is NULL or count of character is 0 from
//           LOWORD(lParam2)
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_LOAD_CPSUI_ICON
//
//      This function load the common property sheet UI resource icon.
//
//  Parameters:
//
//      lParam1 - Common property sheet UI predefined icon resource ID as
//                IDI_CPSUI_xxxx.
//
//      lParam2 - LOWORD(lParam2) = cx icon size in pixel.  If zero then
//                                  SM_CXICON is used
//                HIWORD(lParam2) = cy icon size in pixel.  If zero then
//                                  SM_CYICON is used
//
//
//  Return Value:
//
//      Return value is the handle to the hIcon if function succeed, a NULL
//      if function failed. The caller must call DestroyIcon() when it no
//      longer need to use the hIcon returned
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_GET_PFNPROPSHEETUI_ICON
//
//      This function let the caller return hIcon of its children pages that
//      was added by CPSFUNC_ADD_PFNPROPSHEETUI
//
//  Parameters:
//
//      lParam1 - Handle of common property sheet pages that the hIcon will be
//                queried.  This handle must be the handle returned from
//                CPSFUNC_ADD_PFNPROPSHEETUI function.
//
//      lParam2 - LOWORD(lParam2) = cx icon size in pixel.  If zero then
//                                  SM_CXICON is used
//                HIWORD(lParam2) = cy icon size in pixel.  If zero then
//                                  SM_CYICON is used
//
//
//  Return Value:
//
//      Return value is the handle to the hIcon if function succeed, a NULL
//      if function failed. The caller must call DestroyIcon() when it no
//      longer need to use the hIcon returned
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_INSERT_PSUIPAGE
//
//      This function let the caller insert common property sheet pages at
//      set position.  The hComPropSheet must be the parent handle.
//
//  Parameters:
//
//      lParam1 - Handle of common property sheet pages that the page position
//                will be inserted.  This handle must be the handle returned
//                from previous CPSFUNC_ADD_xxx or CPSFUNC_INSERT_PSUIPAGE that
//                added or inserted using the hComPropSheet if the Mode field
//                in INSPSUIPAGE_INFO data structure is one of the follwing
//
//                  INSPSUIPAGE_MODE_BEFORE
//                  INSPSUIPAGE_MODE_AFTER      - Common UI page handle
//
//                  INSPSUIPAGE_MODE_INDEX      - the lParam1 is an zero based
//                                                child index.
//
//                  INSPSUIPAGE_MODE_FIRST_CHILD
//                  INSPSUIPAGE_MODE_LAST_CHILD - The lParam1 is ignonred.
//
//
//                If lParam1 is a valid common property sheet page handle then
//                it is  the child page handle of hComPropSheet that added by
//                CPSFUNC_ADD_xxx or inserted by CPSFUNC_INSERT_PSUIPAGE.
//
//      lParam2 - A pointer that points to INSERTPSUIPAGE_INFO data structure.
//                Fields must set according to the following.
//
//                  cbSize  - size of this structure
//
//                  Type    - Type of page(s) to be inserted.  It can be one
//                            of the following
//
//                      PSUIPAGEINSERT_GROUP_PARENT
//
//                          Insert a group parent that can be used to insert
//                          new pages under it.  This is typically used when
//                          a set of common UI pages must be group together and
//                          can be deleted later using a single group parent
//                          handle without individual deleting each page.
//
//                          This handle can be nested.  After this function
//                          returned the group parent handle, it can be used
//                          as hComPropSheet handle (first parameter in the
//                          common UI callback) as parent handle so insertion
//                          will be inserted at level below returned group
//                          parent handle.
//
//
//                      PSUIPAGEINSERT_PCOMPROPSHEETUI
//
//                          Insert pages using COMPROPSHEETUI data structure,
//                          dwData1 is a pointer to the COMPROPSHEETUI data
//                          structure.
//
//
//                      PSUIPAGEINSERT_PFNPROPSHEETUI
//
//                          Insert pages using PFNPROPSHEETUI function pointer.
//                          The dwData1 is a PFNPROPSHEETUI function pointer.
//                          The common UI will call this pfnPropSheetUI()
//                          function pointer with PROPSHEETUI_REASON_INIT to
//                          have it add pages.
//
//                          When common UI call pfnPropSheetUI() (dwData1) it
//                          also passed a 32-bit parameter from the dwData2
//                          field in INSERTPSUIPAGE_INFO data structure.
//
//
//                      PSUIPAGEINSERT_PROPSHEETPAGE
//
//                          Insert pages using PROPSHEETPAGE data structure.
//                          The dwData1 is a pointer to the PROPSHEETPAGE
//                          data structure.
//
//
//                      PSUIPAGEINSERT_HPROPSHEETPAGE
//
//                          Insert pages using HPROPSHEETPAGE handle.  The
//                          dwData1 is a PROPSHEETPAGE handle which was
//                          created by CreatePropertySheetPage().
//
//
//                      PSUIPAGEINSERT_DLL
//
//                          Insert pages from a dynnmaic link library.  The
//                          dwData1 is a pointer to a null terminated string
//                          that specified the dynamic link library file name.
//
//                          The dwData2 is a pointer to a null terminated ASCII
//                          string that specified the pfnPropSheetUI function
//                          name. (MUST BE ASCII STRING)
//
//                          Common UI will do a LoadLibrary((LPTSTR)dwData1),
//                          pfnPropSheetUI = GetProcAddress((LPTSTR)dwData2)
//                          then call the pfnPropSheetUI with a lParam from
//                          dwData3.  The called reason from common UI is
//                          set to PROPSHEETUI_REASON_INIT.
//
//                          Using this method insert pages will guaranteed that
//                          library will be unload correctly.
//
//
//                  Mode    - Insert Mode, it can be one of the following
//
//
//                      INSPSUIPAGE_MODE_BEFORE
//
//                          Insert pages before the common property sheet page
//                          handle specified by lParam1
//
//
//                      INSPSUIPAGE_MODE_AFTER
//
//                          Insert pages after the common property sheet page
//                          handle specified by lParam1
//
//
//                      INSPSUIPAGE_MODE_FIRST_CHILD
//
//                          Insert pages as the first child of hComPropSheet
//                          parent handle, the lParam1 is ignored
//
//
//                      INSPSUIPAGE_MODE_LAST_CHILD
//
//                          Insert pages as the last child of hComPropSheet
//                          parent handle, the lParam1 is ignored
//
//
//                      INSPSUIPAGE_MODE_INDEX
//
//                          Insert pages as a zero base child index of its
//                          parent handle specified by hComPropSheet.
//
//                          The lParam1 is the zero based index special handle
//                          that must generated by HINSPSUIPAGE_INDEX(Index)
//                          macro.   If the index is greater than or equal to
//                          the total count of children then it will treat the
//                          mode same as INSPSUIPAGE_MODE_LAST_CHILD
//
//
//                  dwData1
//                  dwData2
//                  dwData3 - 32-bit data associate with the 'Type' field
//                            as following
//
//
//                      PSUIPAGEINSERT_GROUP_PARENT
//
//                          dwData1 = Not used, must be 0
//                          dwData2 = Not used, must be 0
//                          dwData3 = Not used, must be 0
//
//
//                      PSUIPAGEINSERT_PCOMPROPSHEETUI
//
//                          dwData1 = pointer to COMPORPSHEETUI data structure.
//                          dwData2 = at return if sucessful, it contains total
//                                    page added.  If failed, it contains the
//                                    ERR_CPSUI_xxx codes
//                          dwData3 = Not used, must be 0
//
//
//                      PSUIPAGEINSERT_PFNPROPSHEETUI
//
//                          dwData1 = PFNPROPSHEETUI function pointer
//                          dwData2 = 32-bit parameter passed to pfnPropSheetUI
//                          dwData3 = Not used, must be 0
//
//
//                      PSUIPAGEINSERT_PROPSHEETPAGE
//
//                          dwData1 = Pointer to PROPSHEETPAGE data structure.
//                          dwData2 = not used, must be 0
//                          dwData3 = not used, must be 0
//
//
//                      PSUIPAGEINSERT_HPROPSHEETPAGE
//
//                          dwData1 = Is the HPROPSHEETPAGE handle that created
//                                    by a call to CreatePropertySheetPage().
//                          dwData2 = not used, must be 0
//                          dwData3 = not used, must be 0
//
//
//                      PSUIPAGEINSERT_DLL
//
//                          dwData1 = Pointer to a null terminated dynamic link
//                                    library filename.
//                          dwData2 = Pointer to a null terminated function
//                                    name (PFNPROPSHEETUI) in the dynamin link
//                                    library.
//                          dwData3 = 32-bit parameter passed to pfnPropSheetUI
//                                    (PFNPROPSHEETUI) function from dwData2
//
//
//  Return Value:
//
//      The return value is the handle of newly added common property sheet
//      page(s), if return value is NULL then function failed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_PSUIPAGE_TITLE
//
//      This function let the caller set a new title for a particular common
//      UI page title (on the property sheet page tab)
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that title to be
//                set.  This handle must be the handle returned from following
//
//                  CPSFUNC_ADD_PROPSHEETPAGE
//                  CPSFUNC_ADD_HPROPSHEETPAGE
//                  CPSFUNC_INSERT_PSUIPAGE with type of
//                              PSUIPAGEINSERT_PROPSHEETPAGE or
//                              PSUIPAGEINSERT_HPROPSHEETPAGE
//
//      lParam2 - Pointer to a null terminated string for the new title
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.
//
//      This function will returned 0 if the property sheet pages is not
//      currently displayed.
//
//
// -------------------------------------------------------------------------
// Function = CPSFUNC_SET_PSUIPAGE_ICON
//
//      This function let the caller set a new icon for a particular common
//      UI page icon (on the property sheet page tab)
//
//  Parameters:
//
//      lParam1 - the handle of common property sheet pages that icon to be
//                set.  This handle must be the handle returned from following
//
//                  CPSFUNC_ADD_PROPSHEETPAGE
//                  CPSFUNC_ADD_HPROPSHEETPAGE
//                  CPSFUNC_INSERT_PSUIPAGE with type of
//                              PSUIPAGEINSERT_PROPSHEETPAGE or
//                              PSUIPAGEINSERT_HPROPSHEETPAGE
//
//      lParam2 - Handle to Icon, this icon is best as 16x16 icon otherwise it
//                will be stretch to 16x16 (pixel).
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful, and less
//      or equal to zero if the function failed.
//
//      This function will returned 0 if the property sheet pages is not
//      currently displayed.
//
//      After this function is successful set the icon, the caller can destroy
//      the hIcon using DestroyIcon() if the hIcon is created by CreateIcon().
//      If the hIcon (lParam2) passed is using LoadIcon() then it does not need
//      to destroy the icon.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_SET_DATABLOCK
//
//      This function let the caller register a new data block so it can be
//      later query by other pages in the property sheet, this function should
//      call durning PSN_KILLACTIVE message
//
//  Parameters:
//
//      lParam1 - pointer CPSUIDATABLOCK structure which speicifed the buffer
//                and size for queried datablock identify by lParam2 to be set.
//
//      lParam2 - DWORD Identifier of data block to be set
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful which
//      indicate total bytes of data block registered.  If return value is less
//      or equal to zero then function failed and data block is not registered.
//
//      If lParam1 is NULL, (lParam1)->cbData or (lParam1)->pbbData is NULL
//      it return a -1 to indicate an error parameter passed.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_QUERY_DATABLOCK
//
//      This function let the caller query a registered data block so it can
//      used this data block to communicate between property sheet pages.
//      This function should call durning PSN_SETACTIVE message
//
//  Parameters:
//
//      lParam1 - pointer CPSUIDATABLOCK structure which speicifed the buffer
//                and size for queried datablock identify by lParam2
//
//      lParam2 - DWORD Identifier of data block to be queried
//
//
//  Return Value:
//
//      The return value is greater than zero if function sucessful which
//      indicate total bytes of data block copied into the pointer pointed by
//      the lParam1.  If return value is less or equal to zero then function
//      failed and data block is not copied to diciate the spcified datablock
//      Identifier (lParam2) is not found.
//
//      If CPSUIDATABLOCK pointer (lParam1) is NULL, (lParam1)->cbData or
//      (lParam1)->pbData is NULL then return value is the total bytes required
//      to copy the specified datablock identifier, if return value is less or
//      equal to zero then it indicate the spcified datablock identifier is
//      not found.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_SET_DMPUB_HIDEBITS
//
//      This function let the caller hide a set of predefined OPTITEMS in the
//      pages that was created using PSUIPAGEINSERT_PCOMPROPSHEETUI or
//      CPSFUNC_ADD_PCOMPROPSHEETUI with pDlgPage equal to
//      CPSUI_PDLGPAGE_DOCPROP or CPSUI_PDLGPAGE_ADVDOCPROP.
//
//      This function MUST called BEFORE the DOCPROP or ADVDOCPROP property
//      sheet pages are added using  PSUIPAGEINSERT_PCOMPROPSHEETUI or
//      CPSFUNC_ADD_PCOMPROPSHEETUI.
//
//  Parameters:
//
//      lParam1 - prdefined bit array masks to specified which DOCPROP item to
//                be hidden.  Each DMPUB item bit can be generate using macro
//                MAKE_DMPUB_HIDEBIT() and all items can be OR together.
//
//      lParam2 - Not used, MUST be 0
//
//
//  Return Value:
//
//      The return value is equal to lParam1 if this function is called before
//      DOCPROP or ADVDOCPROP pages are added. Return value is zero if these
//      pages already added which means failure.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_IGNORE_CPSUI_PSN_APPLY
//
//      This function let caller control how CPSUI process PSN_APPLY messages
//      for pages added through CPSFUNC_ADD_PCOMPROPSHEETUI or
//      CPSFUNC_INSERT_PSUIPAGE with type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//      If this function never called, the Default CPSUI behavior is to process
//      PSN_APPLY messages.
//
//  Parameters:
//
//      lParam1 - Handle to the page returned from pages added by using
//                CPSFUNC_ADD_PCOMPROPSHEETUI or CPSFUNC_INSERT_PSUIPAGE with
//                type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//      lParam2 - A non-zero value indicate to IGNORE the PSN_APPLY messages
//                for pages handle of lParam1.
//
//                A zero value to have CPSUI nomally process (not ignored) the
//                PSN_APPLY messages for pages handle of lParam1.
//
//                WARNING: if a PSN_APPLY messages are ignored, the caller must
//                         simulate a PSN_APPLY using CPSFUNC_DO_APPLY_CPSUI
//                         function or all changes WILL NOT applied, this is
//                         true even user hit 'OK' button.
//
//  Return Value:
//
//      the return value is zero if function failed, or non-zero to indicate
//      the function is successful.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_DO_APPLY_CPSUI
//
//      This function let caller simulate an apply (PSN_APPLY) to the pages
//      which added through CPSFUNC_ADD_PCOMPROPSHEETUI or
//      CPSFUNC_INSERT_PSUIPAGE with type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//  Parameters:
//
//      lParam1 - Handle to the page returned from pages added by using
//                CPSFUNC_ADD_PCOMPROPSHEETUI or CPSFUNC_INSERT_PSUIPAGE with
//                type of PSUIPAGEINSERT_PROPSHEETPAGE.
//
//      lParam2 - 32-bit flag to indicate how to do apply, currently only
//
//                  APPLYCPSUI_NO_NEWDEF
//
//                      The APPLYCPSUI_NO_NEWDEF bit specified that after the
//                      apply is done the undo buffer for all OPTITEMs still
//                      remain unchanged, this make next undo still possible.
//
//                      If APPLYCPSUI_NO_NEWDEF bit is clear then undo buffers
//                      are re-initialized after apply is done, the current
//                      changes for all OPTITEMs become the new undo default.
//
//
//                  APPLYCPSUI_OK_CANCEL_BUTTON
//
//                      If bit is set then it specified the apply is simulate
//                      a user hit 'Ok' or 'Cancel' button, if this bit is
//                      clear then it simulate a user hit 'Close' or 'Apply'
//                      button.  If caller getting a PSN_APPLY message, it can
//                      simulated using passed PSHNOTIFY (passed as lParam in
//                      WM_NOTIFY message) structure to determine how to set
//                      this bit as follow.
//
//                          if PSHNOTIFY.lParam == 0, then clear this bit
//                          otherwise set this bit.
//
//
//  Return Value:
//
//      the return value is less or equal to zero if it encounter an error and
//      apply failed (the active page will be switch to these pages).
//
//      If return value is greater than zero then changes were applied and
//      function sucessful.
//
// -------------------------------------------------------------------------
//
// Function = CPSFUNC_SET_FUSION_CONTEXT
//
//      This function is used to set a fusion activation context for
//      the specified page.
//
//  Parameters:
//
//      lParam1 - handle to fusion context. compstui duplicates the handle 
//                prior attaching it to its internal structures, so the caller
//                is not bound to keep the handle around. we release the 
//                passed in context handle when the compstui handle is deleted.
//
//      lParam2 - not used
//
//  Return Value:
//
//      the return value is less or equal to zero if it encounter an error and/or
//      something failed (look up the last error for details).
//
//      If return value is greater than zero then the call was sucessful.
//
// -------------------------------------------------------------------------
//


#define PROPSHEETUI_REASON_INIT             0
#define PROPSHEETUI_REASON_GET_INFO_HEADER  1
#define PROPSHEETUI_REASON_DESTROY          2
#define PROPSHEETUI_REASON_SET_RESULT       3
#define PROPSHEETUI_REASON_GET_ICON         4
#define MAX_PROPSHEETUI_REASON_INDEX        4

#define PROPSHEETUI_INFO_VERSION            0x0100

#define PSUIINFO_UNICODE                    0x0001

typedef struct _PROPSHEETUI_INFO {
    WORD            cbSize;
    WORD            Version;
    WORD            Flags;
    WORD            Reason;
    HANDLE          hComPropSheet;
    PFNCOMPROPSHEET pfnComPropSheet;
    LPARAM          lParamInit;
    ULONG_PTR       UserData;
    ULONG_PTR       Result;
    } PROPSHEETUI_INFO, *PPROPSHEETUI_INFO;


//
// For the PROPSHEETUI_REASON_GET_ICON call which lParam is a pointer to
// PROPSHEETUI_GETICON_INFO
//

typedef struct _PROPSHEETUI_GETICON_INFO {
    WORD    cbSize;
    WORD    Flags;
    WORD    cxIcon;
    WORD    cyIcon;
    HICON   hIcon;
    } PROPSHEETUI_GETICON_INFO, *PPROPSHEETUI_GETICON_INFO;


typedef LONG (FAR *PFNPROPSHEETUI)(PPROPSHEETUI_INFO   pPSUIInfo,
                                   LPARAM              lParam);


//
// PFNPROPSHEETUI
//
//  This function is user defined function which will be called by the common
//  UI when a caller wish to include the executable property sheets.
//
//  pPSUIInfo   - Pointer to PROPSHEETUI_INFO below for description of
//                PROPSHEETUI_INFO.
//
//                If this pointer is NULL then this function is not called from
//                common UI, and lParam should be used to determined the
//                action and outcome of this funciton.
//
//  lParam      - A LPARAM intented for this funciton depends on the reason.
//                If pPSUIInfo is NULL then this function is not called from
//                common UI, the lParam is the parameter which agreed with
//                the caller.
//
//                if pPSUIInfo is not NULL then this function assume the call
//                is from the common UI.  lParam has following meanion depends
//                on the reason field.
//
//                PROPSHEETUI_REASON_INIT
//
//                  The lParam is either passed from CPSFUNC_ADD_PFNPROPSHEETUI
//                  callback function's second parameter (lParam2) or it is
//                  from CommonPropertySheetUI()'s lParam (seccond parameter)
//                  without any modification.
//
//                  The lParam MUST NOT be a variable or a pointer to memory
//                  block which resides on the caller function's stack, since
//                  after this function exit, the lParam will become invalid
//                  and can cause fatal system error.
//
//                  The lParam parameter is copied to the lParamInit field in
//                  PROPSHEETUI_INFO data structure.  The lParamInit field
//                  will be passed to all subsequent pfnPropSheetUI() calls
//                  without any modification.
//
//
//                PROPSHEETUI_REASON_GET_INFO_HEADER:
//
//                  lParam is a pointer to the PROPSHEETUI_INFO_HEADER data
//                  structure. this function must correctly fill this structure
//                  fields before it returned.
//
//
//                PROPSHEETUI_REASON_DESTROY
//
//                  lParam is zero to indicate the destroy is cause either by a
//                  caller calling CPSFUNC_DELETE_HCOMPROPSHEET or failed
//                  in caller's CPSFUNC_ADD_xxxx.
//
//                  lParam is non zero to indicate the destroy is cause by
//                  exiting from the property sheet user interface.
//
//
//                PROPSHEETUI_REASON_SET_RESULT
//
//                  lParam is a pointer to SETRESULT_INFO data structure.
//                  Fields in SETRESULT_INFO data structure is set to following
//
//                      hSetResult: Handle to the common UI property sheet
//                                  pages which added by the CPSFUNC_ADD_xxx
//                                  callback function indices.
//
//                          Result: The result from the hSetResult to be set.
//                                  When return greater than zero then Result
//                                  in this field is set to its parent.
//
//
//                PROPSHEETUI_REASON_GET_ICON
//
//                  lParam is a pointer to PROPSHEETUI_GETICON_INFO data
//                  structure.  Fields in PROPSHEETUI_GETICON_INFO data
//                  structure are set to following
//
//                      cxIcon = cx Icon size in pixel
//                      cyIcon = cy Icon size in pixel
//                      hIcon  = Initial to NULL, and this function must put
//                               the created icon handle in this field before
//                               returned.
//


//
// PROPSHEETUI_INFO
//
//  This structure is used when common UI calling the caller passed function
//  entry point PFNPROPSHEETUI, the pfnPropSheetUI() return a LONG to
//  indicate result of this function.
//
//  When the pfnPropSheetUI() returned, it must also put the required result
//  in the Result field, each PROPSHEETUI_REASON_xxx has different required
//  result as describe below.
//
//
//
//  cbSize          - sizeof this structure (PROPSHEETUI_INFO)
//
//  Version         - the PROPSHEETUI_INFO data structure version. Current
//                    version is set to PROPSHEETUI_INFO_VERSION
//
//  Flags           - One or more following is may be defined
//
//                      PSUIINFO_UNICODE
//
//                          The caller's executable was original compiled was
//                          intented using unicode.
//
//
//  Reason          - Following reasons are defined.
//
//                      PROPSHEETUI_REASON_INIT
//
//                          When first time the pfnPropSheetUI() called, this
//                          reason is used to have the function initialize
//                          itself and use the pfnComPropSheet() function
//                          pointer provided to add new pages to the
//                          hComPropSheet handle passed.   The UserData in this
//                          data structure is initially set equal to zero (0).
//
//                          * Return > 0 to indicate sucesful and <= 0 to
//                            indicate error.
//
//                      *NOTE*
//
//                          The lParam MUST NOT be a variable or a pointer to
//                          memory block which resides on the caller function's
//                          stack, since after this function exit, the lParam
//                          will become invalid and can cause fatal system
//                          error.
//
//                          If this function reason returned failed ( <= 0),
//                          this function (pfnPropSheetUI) will received a
//                          PROPSHEETUI_REASON_DESTROY function reason right
//                          after this function reason returned.
//
//
//                      PROPSHEETUI_REASON_GET_INFO_HEADER
//
//                          It is called after the PROPSHEETUI_REASON_INIT is
//                          successful returned.  This reason is used to asked
//                          the function fill in the PROPSHEETUI_INFO_HEADER
//                          for pop-up the property sheet dialog boxes.
//
//                          lParam in this reason is a pointer to the
//                          PROPSHEETUI_INFO_HEADER data structure, following
//                          fields are requrested to be filled in.
//
//                              Flags       - PSUIHDRF_xxx flags
//                              pTitle      - The property sheet title
//                              hWndParent  - handle to the parent of property
//                                            sheet pages.
//                              hInst       - Instance data handle for this
//                                            function.
//                              hIcon
//                              IconID      - Icon used on the title bar.
//
//                          * Return > 0 to indicate sucesful and pop-up the
//                            property sheet dialog boxes or returned <= 0 to
//                            indicate error (not property sheet UI appeared)
//
//
//                      PROPSHEETUI_REASON_DESTROY
//
//                          When the property sheet ready to dismissed or the
//                          caller is delete the common UI pages added by the
//                          pfnPropSheetUI(), the common UI will call this
//                          entry point to have it de-initialized itself and
//                          free up all the memory used for this function
//                          instance.  The UserData field passed is the
//                          'UserData' field which returned from previous
//                          PROPSHEETUI_REASON_xxxx.
//
//                          When this function called, all hComPropSheet's
//                          children are desotroyed and children's common UI
//                          handles are not longer valid.
//
//                          * Return > 0 to indicate sucesful and <= 0 to
//                            indicate error.
//
//
//                      PROPSHEETUI_REASON_SET_RESULT
//
//                          The reason is used when an added handle from
//                          CPSFUNC_ADD_xxxx whant to return the result to
//                          this pfnPropSheetUI() caller.
//
//                          The lParam in second parameter is a pointer to a
//                          SETRESULT_INFO data structure.
//
//                              hSetResult: specified the common UI property
//                                          sheet page handle which added by
//                                          this function using
//                                          CPSFUNC_ADD_xxx indicies.
//
//                                  Result: Specified the Result to be set to
//                                          this pfnPropSheetUI() form the
//                                          hSetResult property sheet page
//                                          handle. If return value is greater
//                                          than zero then the value in this
//                                          Result field will be set to its
//                                          parent if one exist, at this case
//                                          this function can alter the Result
//                                          field value for its parent.
//
//                          * Returned greater than zero to continue send to
//                            its parent, else it stop sending the Result filed
//                            value to its parent.
//
//
//                      PROPSHEETUI_REASON_GET_ICON
//
//                          The reason is used to retrived the Icon which
//                          represent this pfnPropSheetUI().
//
//                          lParam is a pointer to PROPSHEETUI_GETICON_INFO '
//                          data structure.  Fields in PROPSHEETUI_GETICON_INFO
//                          data structure are set to following
//
//                              cxIcon = cx Icon size in pixel
//                              cyIcon = cy Icon size in pixel
//                              hIcon  = Initial to NULL, and this function
//                                       must put the created icon handle in
//                                       this field before return.
//
//
//                          * Return > 0 to indicate sucesful (hIcon is the
//                            requested icon handle).   Return = 0 to indicate
//                            no icon available, or return < 0 to indicate an
//                            error.
//
//              *NOTE*
//
//                  * For all PROPSHEETUI_REASON_xxx, the function can set new
//                    user defined DWORD data in the PROPSHEETUI_INFO data
//                    structure's UserData field.
//
//                  * For all PROPSHEETUI_REASON_xxx, the function can set new
//                    pfnPropSheetUI() DWORD result in PROPSHEETUI_INFO data
//                    structure's Result field.
//
//
//  hComPropSheet   - Handle to the COMPROPSHEETPAGE which this function should
//                    used as hComPropSheet parameter when calling
//                    pfnComPropSheet() to add or delete common UI property
//                    sheet pages.  The hComPropSheet is the instance handle to
//                    pfnPropSheetUI() function.
//
//  pfnComPropSheet - Pointer to the common UI callback function which for the
//                    pfnPropSheetUI() to add, delete, set user data, for a
//                    completed set of callback, see CPSFUNC_xxx descriptions
//                    above.
//
//  lParamInit      - The lParam originally passed duning the the first call
//                    reason PROPSHEETUI_REASON_INIT.  The lParamInit will be
//                    passed to each PROPSHEETUI_REASON_xxx calls.
//
//  UserData        - the UserData field is an IN and OUT parameter for each
//                    of the Reason,
//
//                      PROPSHEETUI_REASON_INIT
//
//                           IN: Initial set to zero (0).
//
//                          OUT: Specified new callee's own user data which
//                               will be passed back to other reason calls.
//
//
//                      PROPSHEETUI_REASON_DESTROY
//                      PROPSHEETUI_REASON_SET_RESULT
//                      PROPSHEETUI_REASON_GET_INFO_HEADER
//
//                           IN: The UserData specified at time when returned
//                               from the previous PROPSHEETUI_REASON_xxx
//
//                          OUT: Specified new callee's own user data which
//                               will be passed back to other reason calls.
//
//
// Result           - The Result field is an IN and OUT parameter for each of
//                    the reason.
//
//                      PROPSHEETUI_REASON_INIT
//
//                           IN: Set to zero (0).
//
//                          OUT: Set to default result of this PropSheetUI()
//                               function.
//
//
//                      PROPSHEETUI_REASON_DESTROY
//                      PROPSHEETUI_REASON_GET_INFO_HEADER
//                      PROPSHEETUI_REASON_SET_RESULT
//
//                           IN: The current 'Result' returned from previous
//                               PROPSHEETUI_REASON_xxx function.
//
//                          OUT: Set the new result of this PropSheetUI()
//                               function.
//
//


#define PSUIHDRF_OBSOLETE       0x0001
#define PSUIHDRF_NOAPPLYNOW     0x0002
#define PSUIHDRF_PROPTITLE      0x0004
#define PSUIHDRF_USEHICON       0x0008
#define PSUIHDRF_DEFTITLE       0x0010
#define PSUIHDRF_EXACT_PTITLE   0x0020

typedef struct _PROPSHEETUI_INFO_HEADER {
    WORD                    cbSize;
    WORD                    Flags;
    LPTSTR                  pTitle;
    HWND                    hWndParent;
    HINSTANCE               hInst;
    union {
        HICON               hIcon;
        ULONG_PTR           IconID;
        } DUMMYUNIONNAME;
    } PROPSHEETUI_INFO_HEADER, *PPROPSHEETUI_INFO_HEADER;

//
// PROPSHEETUI_INFO_HEADER
//
//  This data structure is used when common UI ready to pop-up the property
//  sheet page dialog boxes and it asked caller to provide more information.
//
//  Common property sheet UI passed this data structure as lParam when it call
//  provided pfnPropSheetUI() with PROPSHEETUI_REASON_GET_INFO_HEADER reason.
//
//
//  cbSize      - size of this structure
//
//  Flags       - PSUIHDRF_xxxx flags
//
//                  PSUIHDRF_OBSOLETE
//
//                      Not used, must not set this bit
//
//
//                  PSUIHDRF_NOAPPLYNOW
//
//                      Remove 'Apply Now' button.
//
//
//                  PSUIHDRF_PROPTITLE
//
//                      Automatically include 'Properties' in the title bar
//
//
//                  PSUIHDRF_USEHICON
//
//                      If this bit is specified then hIcon union field is
//                      a valid handle to the icon otherwise the IconID is
//                      the either caller's resource ID or common UI standard
//                      icon ID.
//
//                  PSUIHDRF_DEFTITLE
//
//                      Automatically include 'Default' in the title bar, the
//                      'Default' always added right after pTitle and before
//                      'Properties' if PSUIHDRF_PROPTITLE flag is set.
//
//                  PSUIHDRF_EXACT_PTITLE
//
//                      This flag indicate the pTitle set in this structure
//                      will be use without any modification by the compstui
//                      ie. compstui will not modified pTitle in any way and
//                      it will ignored PSUIHDRF_PROPTITLE, PSUIHDRF_DEFTITLE
//
//
//  pTitle      - Pointer to the NULL terminated caption name for the
//                property sheets.
//
//                  ** See LPTSTR typedef description above
//
//  hWndParent  - The handle of the window which will be parent of the common
//                UI property sheets, if NULL then current active window for
//                the calling thread is used.
//
//  hInst       - the caller's handle to its instance.  Commom UI use this
//                handle to load caller's icon and other resources.
//
//  hIcon
//  IconID      - Specified the icon which put on the title bar, it either a
//                handle to the icon or a icon resource ID depends on the
//                PSUIHDRF_USEHICON flag.
//



//
// LONG
// CommonPropertySheetUI(
//     HWND            hWndOwner,
//     PFNPROPSHEETUI  pfnPropSheetUI,
//     LPARAM          lParam,
//     LPDWORD         pResult
//     );
//
//
// The CommonPropSheetUI is the main entry point for the common property sheet
// user interface.   The original caller that wish to using common UI to pop-up
// property sheet will call this function and passed its own PFNPROPSHEETUI
// function address and a long parameter.
//
// If pfnPropSheetUI function return a LONG number greater than zero (0) then
// common UI will pop-up the property sheet page dialog boxes, when Property
// sheet pages is finished. (either hit Ok or Cancel) it will return the
// result of CPSUI_xxxx back to the caller.
//
// If pfnPropSheetUI function return a LONG number equal or less than zero (0)
// then it will return the CPSUI_CANCEL back to caller without pop-up the
// property sheet page dialog boxes.
//
//
//  Parameters:
//
//      hWndOwner       - Window handle for the owner of this proerty sheet
//                        pages dialog boxes.
//
//      pfnPropSheetUI  - a PFNPROPSHEETUI function pointer which is used by
//                        the caller to add its property sheet pages.
//
//      lParam          - a long parameter will be passed to the pfnPropSheetUI
//                        funciton.  The common UI called the pfnPropSheetUI as
//
//                          PROPSHEETUI_INFO    PSUIInfo;
//
//                          pfnPropSheetUI(&PSUIInfo, lParam);
//
//                        The caller must use pfnComPropSheet() to add/delete
//                        pages.  When it is done adding pages, it retuned
//                        greater than zero to indicate successful, and return
//                        less or equal to zero to indicate failure.
//
//      pResult         - a pointer to DWORD which received the final result
//                        of pfnPropSheetUI() funciton, this result is a copy
//                        from Result field of PROPSHEETUI_INFO data structure
//                        which passed to the pfnPropSheetUI() as the first
//                        parameter.  The pResult only will be set if the
//                        returned value from CommonPropertySheetUI() is not
//                        ERR_CPSUI_xxx.
//
//                        if pResult is NULL then common UI will not return
//                        pfnPropSheetUI()'s result back.
//
//
//  Return Value:
//
//      LONG    - < 0                   - property page does not displayed and
//                                        ERR_CPSUI_xxx is the error code
//                CPSUI_OK              - property page displayed.
//                CPSUI_RESTARTWINDOWS  - property page displayed and need to
//                                        restart window to take effect
//                CPSUI_REBOOTSYSTEM    - property page dispalyed and need
//                                        to reboot system to take effect
//
//


LONG
APIENTRY
CommonPropertySheetUIA(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    );

LONG
APIENTRY
CommonPropertySheetUIW(
    HWND            hWndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    LPDWORD         pResult
    );


#ifdef UNICODE
#define CommonPropertySheetUI   CommonPropertySheetUIW
#else
#define CommonPropertySheetUI   CommonPropertySheetUIA
#endif



//
// GetCPSUIUserData() and SetCPSUIUserData() is used for the pages added
// by the CPSFUNC_ADD_PCOMPROPSHEETUI.  The caller add this function and has
// sub class dialog procedure should not set DWLP_USERDATA but calling these
// function instead, otherwise the system can failed.
//

ULONG_PTR
APIENTRY
GetCPSUIUserData(
    HWND    hDlg
    );

BOOL
APIENTRY
SetCPSUIUserData(
    HWND        hDlg,
    ULONG_PTR   CPSUIUserData
    );


#define CPSUI_CANCEL                        0
#define CPSUI_OK                            1
#define CPSUI_RESTARTWINDOWS                2
#define CPSUI_REBOOTSYSTEM                  3

#define ERR_CPSUI_GETLASTERROR              -1
#define ERR_CPSUI_ALLOCMEM_FAILED           -2
#define ERR_CPSUI_INVALID_PDATA             -3
#define ERR_CPSUI_INVALID_LPARAM            -4
#define ERR_CPSUI_NULL_HINST                -5
#define ERR_CPSUI_NULL_CALLERNAME           -6
#define ERR_CPSUI_NULL_OPTITEMNAME          -7
#define ERR_CPSUI_NO_PROPSHEETPAGE          -8
#define ERR_CPSUI_TOO_MANY_PROPSHEETPAGES   -9
#define ERR_CPSUI_CREATEPROPPAGE_FAILED     -10
#define ERR_CPSUI_MORE_THAN_ONE_TVPAGE      -11
#define ERR_CPSUI_MORE_THAN_ONE_STDPAGE     -12
#define ERR_CPSUI_INVALID_PDLGPAGE          -13
#define ERR_CPSUI_INVALID_DLGPAGE_CBSIZE    -14
#define ERR_CPSUI_TOO_MANY_DLGPAGES         -15
#define ERR_CPSUI_INVALID_DLGPAGEIDX        -16
#define ERR_CPSUI_SUBITEM_DIFF_DLGPAGEIDX   -17
#define ERR_CPSUI_NULL_POPTITEM             -18
#define ERR_CPSUI_INVALID_OPTITEM_CBSIZE    -19
#define ERR_CPSUI_INVALID_OPTTYPE_CBSIZE    -20
#define ERR_CPSUI_INVALID_OPTTYPE_COUNT     -21
#define ERR_CPSUI_NULL_POPTPARAM            -22
#define ERR_CPSUI_INVALID_OPTPARAM_CBSIZE   -23
#define ERR_CPSUI_INVALID_EDITBOX_PSEL      -24
#define ERR_CPSUI_INVALID_EDITBOX_BUF_SIZE  -25
#define ERR_CPSUI_INVALID_ECB_CBSIZE        -26
#define ERR_CPSUI_NULL_ECB_PTITLE           -27
#define ERR_CPSUI_NULL_ECB_PCHECKEDNAME     -28
#define ERR_CPSUI_INVALID_DMPUBID           -29
#define ERR_CPSUI_INVALID_DMPUB_TVOT        -30
#define ERR_CPSUI_CREATE_TRACKBAR_FAILED    -31
#define ERR_CPSUI_CREATE_UDARROW_FAILED     -32
#define ERR_CPSUI_CREATE_IMAGELIST_FAILED   -33
#define ERR_CPSUI_INVALID_TVOT_TYPE         -34
#define ERR_CPSUI_INVALID_LBCB_TYPE         -35
#define ERR_CPSUI_SUBITEM_DIFF_OPTIF_HIDE   -36
#define ERR_CPSUI_INVALID_PUSHBUTTON_TYPE   -38
#define ERR_CPSUI_INVALID_EXTPUSH_CBSIZE    -39
#define ERR_CPSUI_NULL_EXTPUSH_DLGPROC      -40
#define ERR_CPSUI_NO_EXTPUSH_DLGTEMPLATEID  -41
#define ERR_CPSUI_NULL_EXTPUSH_CALLBACK     -42
#define ERR_CPSUI_DMCOPIES_USE_EXTPUSH      -43
#define ERR_CPSUI_ZERO_OPTITEM              -44


#define ERR_CPSUI_FUNCTION_NOT_IMPLEMENTED  -9999
#define ERR_CPSUI_INTERNAL_ERROR            -10000

#endif  // (!defined(RC_INVOKED))



//
//****************************************************************************
//*                                                                          *
//*      Common Property Sheet UI resource ID for the ICONs and STRINGs      *
//*                                                                          *
//* The Resource ID from 64000 to 65535 are reserved for common UI and must  *
//* not used as caller resource ID else the string, icon loading will not be *
//* correct.                                                                 *
//*                                                                          *
//****************************************************************************
//


//
// Common UI standard 32x32, 16x16 color and monochrome Icon IDs
//

#define IDI_CPSUI_ICONID_FIRST          64000

#define IDI_CPSUI_EMPTY                 64000
#define IDI_CPSUI_SEL_NONE              64001
#define IDI_CPSUI_WARNING               64002
#define IDI_CPSUI_NO                    64003
#define IDI_CPSUI_YES                   64004
#define IDI_CPSUI_FALSE                 64005
#define IDI_CPSUI_TRUE                  64006
#define IDI_CPSUI_OFF                   64007
#define IDI_CPSUI_ON                    64008
#define IDI_CPSUI_PAPER_OUTPUT          64009
#define IDI_CPSUI_ENVELOPE              64010
#define IDI_CPSUI_MEM                   64011
#define IDI_CPSUI_FONTCARTHDR           64012
#define IDI_CPSUI_FONTCART              64013
#define IDI_CPSUI_STAPLER_ON            64014
#define IDI_CPSUI_STAPLER_OFF           64015
#define IDI_CPSUI_HT_HOST               64016
#define IDI_CPSUI_HT_DEVICE             64017
#define IDI_CPSUI_TT_PRINTASGRAPHIC     64018
#define IDI_CPSUI_TT_DOWNLOADSOFT       64019
#define IDI_CPSUI_TT_DOWNLOADVECT       64020
#define IDI_CPSUI_TT_SUBDEV             64021
#define IDI_CPSUI_PORTRAIT              64022
#define IDI_CPSUI_LANDSCAPE             64023
#define IDI_CPSUI_ROT_LAND              64024
#define IDI_CPSUI_AUTOSEL               64025
#define IDI_CPSUI_PAPER_TRAY            64026
#define IDI_CPSUI_PAPER_TRAY2           64027
#define IDI_CPSUI_PAPER_TRAY3           64028
#define IDI_CPSUI_TRANSPARENT           64029
#define IDI_CPSUI_COLLATE               64030
#define IDI_CPSUI_DUPLEX_NONE           64031
#define IDI_CPSUI_DUPLEX_HORZ           64032
#define IDI_CPSUI_DUPLEX_VERT           64033
#define IDI_CPSUI_RES_DRAFT             64034
#define IDI_CPSUI_RES_LOW               64035
#define IDI_CPSUI_RES_MEDIUM            64036
#define IDI_CPSUI_RES_HIGH              64037
#define IDI_CPSUI_RES_PRESENTATION      64038
#define IDI_CPSUI_MONO                  64039
#define IDI_CPSUI_COLOR                 64040
#define IDI_CPSUI_DITHER_NONE           64041
#define IDI_CPSUI_DITHER_COARSE         64042
#define IDI_CPSUI_DITHER_FINE           64043
#define IDI_CPSUI_DITHER_LINEART        64044
#define IDI_CPSUI_SCALING               64045
#define IDI_CPSUI_COPY                  64046
#define IDI_CPSUI_HTCLRADJ              64047
#define IDI_CPSUI_HALFTONE_SETUP        64048
#define IDI_CPSUI_WATERMARK             64049
#define IDI_CPSUI_ERROR                 64050
#define IDI_CPSUI_ICM_OPTION            64051
#define IDI_CPSUI_ICM_METHOD            64052
#define IDI_CPSUI_ICM_INTENT            64053
#define IDI_CPSUI_STD_FORM              64054
#define IDI_CPSUI_OUTBIN                64055
#define IDI_CPSUI_OUTPUT                64056
#define IDI_CPSUI_GRAPHIC               64057
#define IDI_CPSUI_ADVANCE               64058
#define IDI_CPSUI_DOCUMENT              64059
#define IDI_CPSUI_DEVICE                64060
#define IDI_CPSUI_DEVICE2               64061
#define IDI_CPSUI_PRINTER               64062
#define IDI_CPSUI_PRINTER2              64063
#define IDI_CPSUI_PRINTER3              64064
#define IDI_CPSUI_PRINTER4              64065
#define IDI_CPSUI_OPTION                64066
#define IDI_CPSUI_OPTION2               64067
#define IDI_CPSUI_STOP                  64068
#define IDI_CPSUI_NOTINSTALLED          64069
#define IDI_CPSUI_WARNING_OVERLAY       64070
#define IDI_CPSUI_STOP_WARNING_OVERLAY  64071
#define IDI_CPSUI_GENERIC_OPTION        64072
#define IDI_CPSUI_GENERIC_ITEM          64073
#define IDI_CPSUI_RUN_DIALOG            64074
#define IDI_CPSUI_QUESTION              64075
#define IDI_CPSUI_FORMTRAYASSIGN        64076
#define IDI_CPSUI_PRINTER_FOLDER        64077
#define IDI_CPSUI_INSTALLABLE_OPTION    64078
#define IDI_CPSUI_PRINTER_FEATURE       64079
#define IDI_CPSUI_DEVICE_FEATURE        64080
#define IDI_CPSUI_FONTSUB               64081
#define IDI_CPSUI_POSTSCRIPT            64082
#define IDI_CPSUI_TELEPHONE             64083
#define IDI_CPSUI_DUPLEX_NONE_L         64084
#define IDI_CPSUI_DUPLEX_HORZ_L         64085
#define IDI_CPSUI_DUPLEX_VERT_L         64086
#define IDI_CPSUI_LF_PEN_PLOTTER        64087
#define IDI_CPSUI_SF_PEN_PLOTTER        64088
#define IDI_CPSUI_LF_RASTER_PLOTTER     64089
#define IDI_CPSUI_SF_RASTER_PLOTTER     64090
#define IDI_CPSUI_ROLL_PAPER            64091
#define IDI_CPSUI_PEN_CARROUSEL         64092
#define IDI_CPSUI_PLOTTER_PEN           64093
#define IDI_CPSUI_MANUAL_FEED           64094
#define IDI_CPSUI_FAX                   64095
#define IDI_CPSUI_PAGE_PROTECT          64096
#define IDI_CPSUI_ENVELOPE_FEED         64097
#define IDI_CPSUI_FONTCART_SLOT         64098
#define IDI_CPSUI_LAYOUT_BMP_PORTRAIT   64099
#define IDI_CPSUI_LAYOUT_BMP_ARROWL     64100
#define IDI_CPSUI_LAYOUT_BMP_ARROWS     64101
#define IDI_CPSUI_LAYOUT_BMP_BOOKLETL   64102
#define IDI_CPSUI_LAYOUT_BMP_BOOKLETP   64103
#define IDI_CPSUI_ICONID_LAST           64103

//
// Common UI standard String IDs
//


#define IDS_CPSUI_STRID_FIRST           64700

#define IDS_CPSUI_SETUP                 64700
#define IDS_CPSUI_MORE                  64701
#define IDS_CPSUI_CHANGE                64702
#define IDS_CPSUI_OPTION                64703
#define IDS_CPSUI_OF                    64704
#define IDS_CPSUI_RANGE_FROM            64705
#define IDS_CPSUI_TO                    64706
#define IDS_CPSUI_COLON_SEP             64707
#define IDS_CPSUI_LEFT_ANGLE            64708
#define IDS_CPSUI_RIGHT_ANGLE           64709
#define IDS_CPSUI_SLASH_SEP             64710
#define IDS_CPSUI_PERCENT               64711
#define IDS_CPSUI_LBCB_NOSEL            64712
#define IDS_CPSUI_PROPERTIES            64713
#define IDS_CPSUI_DEFAULTDOCUMENT       64714
#define IDS_CPSUI_DOCUMENT              64715
#define IDS_CPSUI_ADVANCEDOCUMENT       64716
#define IDS_CPSUI_PRINTER               64717
#define IDS_CPSUI_AUTOSELECT            64718
#define IDS_CPSUI_PAPER_OUTPUT          64719
#define IDS_CPSUI_GRAPHIC               64720
#define IDS_CPSUI_OPTIONS               64721
#define IDS_CPSUI_ADVANCED              64722
#define IDS_CPSUI_STDDOCPROPTAB         64723
#define IDS_CPSUI_STDDOCPROPTVTAB       64724
#define IDS_CPSUI_DEVICEOPTIONS         64725
#define IDS_CPSUI_FALSE                 64726
#define IDS_CPSUI_TRUE                  64727
#define IDS_CPSUI_NO                    64728
#define IDS_CPSUI_YES                   64729
#define IDS_CPSUI_OFF                   64730
#define IDS_CPSUI_ON                    64731
#define IDS_CPSUI_DEFAULT               64732
#define IDS_CPSUI_ERROR                 64733
#define IDS_CPSUI_NONE                  64734
#define IDS_CPSUI_NOT                   64735
#define IDS_CPSUI_EXIST                 64736
#define IDS_CPSUI_NOTINSTALLED          64737
#define IDS_CPSUI_ORIENTATION           64738
#define IDS_CPSUI_SCALING               64739
#define IDS_CPSUI_NUM_OF_COPIES         64740
#define IDS_CPSUI_SOURCE                64741
#define IDS_CPSUI_PRINTQUALITY          64742
#define IDS_CPSUI_RESOLUTION            64743
#define IDS_CPSUI_COLOR_APPERANCE       64744
#define IDS_CPSUI_DUPLEX                64745
#define IDS_CPSUI_TTOPTION              64746
#define IDS_CPSUI_FORMNAME              64747
#define IDS_CPSUI_ICM                   64748
#define IDS_CPSUI_ICMMETHOD             64749
#define IDS_CPSUI_ICMINTENT             64750
#define IDS_CPSUI_MEDIA                 64751
#define IDS_CPSUI_DITHERING             64752
#define IDS_CPSUI_PORTRAIT              64753
#define IDS_CPSUI_LANDSCAPE             64754
#define IDS_CPSUI_ROT_LAND              64755
#define IDS_CPSUI_COLLATE               64756
#define IDS_CPSUI_COLLATED              64757
#define IDS_CPSUI_PRINTFLDSETTING       64758
#define IDS_CPSUI_DRAFT                 64759
#define IDS_CPSUI_LOW                   64760
#define IDS_CPSUI_MEDIUM                64761
#define IDS_CPSUI_HIGH                  64762
#define IDS_CPSUI_PRESENTATION          64763
#define IDS_CPSUI_COLOR                 64764
#define IDS_CPSUI_GRAYSCALE             64765
#define IDS_CPSUI_MONOCHROME            64766
#define IDS_CPSUI_SIMPLEX               64767
#define IDS_CPSUI_HORIZONTAL            64768
#define IDS_CPSUI_VERTICAL              64769
#define IDS_CPSUI_LONG_SIDE             64770
#define IDS_CPSUI_SHORT_SIDE            64771
#define IDS_CPSUI_TT_PRINTASGRAPHIC     64772
#define IDS_CPSUI_TT_DOWNLOADSOFT       64773
#define IDS_CPSUI_TT_DOWNLOADVECT       64774
#define IDS_CPSUI_TT_SUBDEV             64775
#define IDS_CPSUI_ICM_BLACKWHITE        64776
#define IDS_CPSUI_ICM_NO                64777
#define IDS_CPSUI_ICM_YES               64778
#define IDS_CPSUI_ICM_SATURATION        64779
#define IDS_CPSUI_ICM_CONTRAST          64780
#define IDS_CPSUI_ICM_COLORMETRIC       64781
#define IDS_CPSUI_STANDARD              64782
#define IDS_CPSUI_GLOSSY                64783
#define IDS_CPSUI_TRANSPARENCY          64784
#define IDS_CPSUI_REGULAR               64785
#define IDS_CPSUI_BOND                  64786
#define IDS_CPSUI_COARSE                64787
#define IDS_CPSUI_FINE                  64788
#define IDS_CPSUI_LINEART               64789
#define IDS_CPSUI_ERRDIFFUSE            64790
#define IDS_CPSUI_HALFTONE              64791
#define IDS_CPSUI_HTCLRADJ              64792
#define IDS_CPSUI_USE_HOST_HT           64793
#define IDS_CPSUI_USE_DEVICE_HT         64794
#define IDS_CPSUI_USE_PRINTER_HT        64795
#define IDS_CPSUI_OUTBINASSIGN          64796
#define IDS_CPSUI_WATERMARK             64797
#define IDS_CPSUI_FORMTRAYASSIGN        64798
#define IDS_CPSUI_UPPER_TRAY            64799
#define IDS_CPSUI_ONLYONE               64800
#define IDS_CPSUI_LOWER_TRAY            64801
#define IDS_CPSUI_MIDDLE_TRAY           64802
#define IDS_CPSUI_MANUAL_TRAY           64803
#define IDS_CPSUI_ENVELOPE_TRAY         64804
#define IDS_CPSUI_ENVMANUAL_TRAY        64805
#define IDS_CPSUI_TRACTOR_TRAY          64806
#define IDS_CPSUI_SMALLFMT_TRAY         64807
#define IDS_CPSUI_LARGEFMT_TRAY         64808
#define IDS_CPSUI_LARGECAP_TRAY         64809
#define IDS_CPSUI_CASSETTE_TRAY         64810
#define IDS_CPSUI_DEFAULT_TRAY          64811
#define IDS_CPSUI_FORMSOURCE            64812
#define IDS_CPSUI_MANUALFEED            64813
#define IDS_CPSUI_PRINTERMEM_KB         64814
#define IDS_CPSUI_PRINTERMEM_MB         64815
#define IDS_CPSUI_PAGEPROTECT           64816
#define IDS_CPSUI_HALFTONE_SETUP        64817
#define IDS_CPSUI_INSTFONTCART          64818
#define IDS_CPSUI_SLOT1                 64819
#define IDS_CPSUI_SLOT2                 64820
#define IDS_CPSUI_SLOT3                 64821
#define IDS_CPSUI_SLOT4                 64822
#define IDS_CPSUI_LEFT_SLOT             64823
#define IDS_CPSUI_RIGHT_SLOT            64824
#define IDS_CPSUI_STAPLER               64825
#define IDS_CPSUI_STAPLER_ON            64826
#define IDS_CPSUI_STAPLER_OFF           64827
#define IDS_CPSUI_STACKER               64828
#define IDS_CPSUI_MAILBOX               64829
#define IDS_CPSUI_COPY                  64830
#define IDS_CPSUI_COPIES                64831
#define IDS_CPSUI_TOTAL                 64832
#define IDS_CPSUI_MAKE                  64833
#define IDS_CPSUI_PRINT                 64834
#define IDS_CPSUI_FAX                   64835
#define IDS_CPSUI_PLOT                  64836
#define IDS_CPSUI_SLOW                  64837
#define IDS_CPSUI_FAST                  64838
#define IDS_CPSUI_ROTATED               64839
#define IDS_CPSUI_RESET                 64840
#define IDS_CPSUI_ALL                   64841
#define IDS_CPSUI_DEVICE                64842
#define IDS_CPSUI_SETTINGS              64843
#define IDS_CPSUI_REVERT                64844
#define IDS_CPSUI_CHANGES               64845
#define IDS_CPSUI_CHANGED               64846
#define IDS_CPSUI_WARNING               64847
#define IDS_CPSUI_ABOUT                 64848
#define IDS_CPSUI_VERSION               64849
#define IDS_CPSUI_NO_NAME               64850
#define IDS_CPSUI_SETTING               64851
#define IDS_CPSUI_DEVICE_SETTINGS       64852
#define IDS_CPSUI_STDDOCPROPTAB1        64853
#define IDS_CPSUI_STDDOCPROPTAB2        64854
#define IDS_CPSUI_PAGEORDER             64855
#define IDS_CPSUI_FRONTTOBACK           64856
#define IDS_CPSUI_BACKTOFRONT           64857
#define IDS_CPSUI_QUALITY_SETTINGS      64858
#define IDS_CPSUI_QUALITY_DRAFT         64859
#define IDS_CPSUI_QUALITY_BETTER        64860
#define IDS_CPSUI_QUALITY_BEST          64861
#define IDS_CPSUI_QUALITY_CUSTOM        64862
#define IDS_CPSUI_OUTPUTBIN             64863
#define IDS_CPSUI_NUP                   64864
#define IDS_CPSUI_NUP_NORMAL            64865
#define IDS_CPSUI_NUP_TWOUP             64866
#define IDS_CPSUI_NUP_FOURUP            64867
#define IDS_CPSUI_NUP_SIXUP             64868
#define IDS_CPSUI_NUP_NINEUP            64869
#define IDS_CPSUI_NUP_SIXTEENUP         64870
#define IDS_CPSUI_SIDE1                 64871
#define IDS_CPSUI_SIDE2                 64872
#define IDS_CPSUI_BOOKLET               64873

#define IDS_CPSUI_STRID_LAST            64873


#ifdef __cplusplus
}
#endif

#endif      // _COMPSTUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\oak\inc\dmemmgr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	dmemmgr.h
 *  Content:	Direct Memory Manager include file
 *
 ***************************************************************************/

#ifndef __DMEMMGR_INCLUDED__
#define __DMEMMGR_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __NTDDKCOMP__

/*
 * pointer to video memory
 */
typedef ULONG_PTR FLATPTR;

typedef struct _VIDMEM *LPVIDMEM;

#else

/*
 * pointer to video memory, potentially 64-bit
 */
typedef ULONG_PTR FLATPTR;

typedef struct _VIDEOMEMORY *LPVIDMEM;

#endif

/*
 * Structure for querying extended heap alignment requirements
 */

typedef struct _SURFACEALIGNMENT
{
    union
    {
        struct
        {
            DWORD       dwStartAlignment;
            DWORD       dwPitchAlignment;
            DWORD       dwFlags;
            DWORD       dwReserved2;
        } Linear;
        struct
        {
            DWORD       dwXAlignment;
            DWORD       dwYAlignment;
            DWORD       dwFlags;
            DWORD       dwReserved2;
        } Rectangular;
    };
} SURFACEALIGNMENT;
typedef struct _SURFACEALIGNMENT FAR *LPSURFACEALIGNMENT;

#define SURFACEALIGN_DISCARDABLE	0x00000001l /* Surface can be discarded to   */
                                                    /* make room for another surface */


typedef struct _HEAPALIGNMENT
{
    DWORD                dwSize;
    DDSCAPS              ddsCaps;       /* Indicates which alignment fields are valid.*/
    DWORD                dwReserved;
    SURFACEALIGNMENT     ExecuteBuffer; /* Surfaces tagged with DDSCAPS_EXECUTEBUFFER */
    SURFACEALIGNMENT     Overlay;       /* Surfaces tagged with DDSCAPS_OVERLAY       */
    SURFACEALIGNMENT     Texture;       /* Surfaces tagged with DDSCAPS_TEXTURE       */
    SURFACEALIGNMENT     ZBuffer;       /* Surfaces tagged with DDSCAPS_ZBUFFER       */
    SURFACEALIGNMENT     AlphaBuffer;   /* Surfaces tagged with DDSCAPS_ALPHA         */
    SURFACEALIGNMENT     Offscreen;     /* Surfaces tagged with DDSCAPS_OFFSCREENPLAIN*/
    SURFACEALIGNMENT     FlipTarget;    /* Surfaces whose bits are potential primaries i.e. back buffers*/
} HEAPALIGNMENT;
typedef struct _HEAPALIGNMENT FAR *LPHEAPALIGNMENT;

typedef struct _DD_GETHEAPALIGNMENTDATA
{
    ULONG_PTR                  dwInstance;         // driver context
    DWORD                      dwHeap;             // heap index passed by DirectDraw
    HRESULT                    ddRVal;             // return value
    VOID*                      GetHeapAlignment;   // Unused: Win95 compatibility
    HEAPALIGNMENT              Alignment;          // Filled in by driver.
} DD_GETHEAPALIGNMENTDATA;
typedef struct _DD_GETHEAPALIGNMENTDATA *PDD_GETHEAPALIGNMENTDATA;

/*
 * video memory manager structures
 */
typedef struct _VMEML
{
    struct _VMEML 	FAR *next;
    FLATPTR		ptr;
    DWORD		size;
    BOOL                bDiscardable;
} VMEML, FAR *LPVMEML, FAR * FAR *LPLPVMEML;

typedef struct _VMEMR
{
    struct _VMEMR 	FAR *next;
    struct _VMEMR       FAR *prev;
    /*
     * The pUp, pDown, pLeft and pRight members were removed in DX5
     */
    struct _VMEMR 	FAR *pUp;
    struct _VMEMR 	FAR *pDown;
    struct _VMEMR 	FAR *pLeft;
    struct _VMEMR 	FAR *pRight;
    FLATPTR		ptr;
    DWORD		size;
    DWORD               x;
    DWORD               y;
    DWORD               cx;
    DWORD               cy;
    DWORD		flags;
    FLATPTR             pBits;
    BOOL                bDiscardable;
} VMEMR, FAR *LPVMEMR, FAR * FAR *LPLPVMEMR;

typedef struct _VMEMHEAP
{
    DWORD		        dwFlags;
    DWORD                       stride;
    LPVOID		        freeList;
    LPVOID		        allocList;
    DWORD                       dwTotalSize;
    FLATPTR                     fpGARTLin;      /* AGP: GART linear base of heap (app. visible)   */
    FLATPTR                     fpGARTDev;      /* AGP: GART device base of heap (driver visible) */
    DWORD                       dwCommitedSize; /* AGP: Number of bytes commited to heap          */
    /*
     * Extended alignment data:
     * Filled in by DirectDraw in response to a GetHeapAlignment HAL call.
     */
    DWORD                       dwCoalesceCount;
    HEAPALIGNMENT               Alignment;
    /*
     * These are analogous to VIDMEM.ddsCaps and VIDMEM.ddsCapsAlt. These values are queried from the
     * driver by a GetDriverInfo call. See the documentation for GUID_DDMoreSurfaceCaps
     */
    DDSCAPSEX                   ddsCapsEx;
    DDSCAPSEX                   ddsCapsExAlt;
#ifndef IS_16
    // Full physical address of heap base for NT AGP heaps.
    LARGE_INTEGER               liPhysAGPBase;
#endif
    // hdev for use with VidMemAllocAligned on NT.  Set by the system at
    // initialization time.
    HANDLE                      hdevAGP;
    // Physical reservation handle for NT heaps.
    LPVOID                      pvPhysRsrv;
    BYTE*                       pAgpCommitMask;
    DWORD                       dwAgpCommitMaskSize;
} VMEMHEAP;

typedef VMEMHEAP FAR *LPVMEMHEAP;

#define VMEMHEAP_LINEAR			0x00000001l /* Heap is linear                    */
#define VMEMHEAP_RECTANGULAR		0x00000002l /* Heap is rectangular               */
#define VMEMHEAP_ALIGNMENT  		0x00000004l /* Heap has extended alignment info  */

/*
 * This legacy export doesn't handle nonlocal heaps
 * This function is not available on Windows NT
 */
#ifndef __NTDDKCOMP__
extern FLATPTR WINAPI VidMemAlloc( LPVMEMHEAP pvmh, DWORD width, DWORD height );
#endif

/*
 * This export can be used by drivers to allocate aligned surfaces from heaps which
 * they have previously exposed to DirectDraw. This function can allocate from nonlocal heaps.
 */
extern FLATPTR WINAPI HeapVidMemAllocAligned(
                LPVIDMEM lpVidMem,
                DWORD dwWidth,
                DWORD dwHeight,
                LPSURFACEALIGNMENT lpAlignment ,
                LPLONG lpNewPitch );

/*
 * This export can free memory allocated via either allocation function
 */
extern void WINAPI VidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\oak\inc\ddrawint.h ===
/*++

Copyright (c) Microsoft Corporation. All Rights Reserved.

Module Name:

    ddrawint.h

Abstract:

    Private entry points, defines and types for Windows NT DirectDraw
    driver interface.  Corresponds to Windows' 'ddrawi.h' file.

    The structure names for NT are different from that of Win95.  Use
    dx95type.h to aid in porting DirectX code from Win95 to NT.

--*/

#ifndef __DD_INCLUDED__
#define __DD_INCLUDED__

/*
 * These GUIDs are used to identify driver info structures, not interfaces,
 * so the prefix GUID_ is used instead of IID_.
 */

DEFINE_GUID( GUID_MiscellaneousCallbacks,       0xefd60cc0, 0x49e7, 0x11d0, 0x88, 0x9d, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_Miscellaneous2Callbacks,      0x406B2F00, 0x3E5A, 0x11D1, 0xB6, 0x40, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x6A);
DEFINE_GUID( GUID_VideoPortCallbacks,           0xefd60cc1, 0x49e7, 0x11d0, 0x88, 0x9d, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_ColorControlCallbacks,        0xefd60cc2, 0x49e7, 0x11d0, 0x88, 0x9d, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_MotionCompCallbacks,          0xb1122b40, 0x5dA5, 0x11d1, 0x8f, 0xcF, 0x00, 0xc0, 0x4f, 0xc2, 0x9b, 0x4e);
DEFINE_GUID( GUID_VideoPortCaps,                0xefd60cc3, 0x49e7, 0x11d0, 0x88, 0x9d, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_D3DCaps,                      0x7bf06991, 0x8794, 0x11d0, 0x91, 0x39, 0x08, 0x00, 0x36, 0xd2, 0xef, 0x02);
DEFINE_GUID( GUID_D3DExtendedCaps, 		0x7de41f80, 0x9d93, 0x11d0, 0x89, 0xab, 0x00, 0xa0, 0xc9, 0x05, 0x41, 0x29);
DEFINE_GUID( GUID_D3DCallbacks,                 0x7bf06990, 0x8794, 0x11d0, 0x91, 0x39, 0x08, 0x00, 0x36, 0xd2, 0xef, 0x02);
DEFINE_GUID( GUID_D3DCallbacks2,                0xba584e1, 0x70b6, 0x11d0, 0x88, 0x9d, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_D3DCallbacks3,                0xddf41230, 0xec0a, 0x11d0, 0xa9, 0xb6, 0x00, 0xaa, 0x00, 0xc0, 0x99, 0x3e);
DEFINE_GUID( GUID_NonLocalVidMemCaps,           0x86c4fa80, 0x8d84, 0x11d0, 0x94, 0xe8, 0x00, 0xc0, 0x4f, 0xc3, 0x41, 0x37);
DEFINE_GUID( GUID_KernelCallbacks,              0x80863800, 0x6B06, 0x11D0, 0x9B, 0x06, 0x0, 0xA0, 0xC9, 0x03, 0xA3, 0xB8);
DEFINE_GUID( GUID_KernelCaps,                   0xFFAA7540, 0x7AA8, 0x11D0, 0x9B, 0x06, 0x00, 0xA0, 0xC9, 0x03, 0xA3, 0xB8);
DEFINE_GUID( GUID_ZPixelFormats,                0x93869880, 0x36cf, 0x11d1, 0x9b, 0x1b, 0x0, 0xaa, 0x0, 0xbb, 0xb8, 0xae);
DEFINE_GUID( GUID_DDMoreCaps,                   0x880baf30, 0xb030, 0x11d0, 0x8e, 0xa7, 0x00, 0x60, 0x97, 0x97, 0xea, 0x5b);
DEFINE_GUID( GUID_D3DParseUnknownCommandCallback, 0x2e04ffa0, 0x98e4, 0x11d1, 0x8c, 0xe1, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( GUID_NTCallbacks,                  0x6fe9ecde, 0xdf89, 0x11d1, 0x9d, 0xb0, 0x00, 0x60, 0x08, 0x27, 0x71, 0xba);
DEFINE_GUID( GUID_DDMoreSurfaceCaps,            0x3b8a0466, 0xf269, 0x11d1, 0x88, 0x0b, 0x0, 0xc0, 0x4f, 0xd9, 0x30, 0xc5);
DEFINE_GUID( GUID_GetHeapAlignment,             0x42e02f16, 0x7b41, 0x11d2, 0x8b, 0xff, 0x0, 0xa0, 0xc9, 0x83, 0xea, 0xf6);
DEFINE_GUID( GUID_UpdateNonLocalHeap,           0x42e02f17, 0x7b41, 0x11d2, 0x8b, 0xff, 0x0, 0xa0, 0xc9, 0x83, 0xea, 0xf6);
DEFINE_GUID( GUID_NTPrivateDriverCaps,          0xfad16a23, 0x7b66, 0x11d2, 0x83, 0xd7, 0x0, 0xc0, 0x4f, 0x7c, 0xe5, 0x8c);
DEFINE_GUID( GUID_DDStereoMode,                 0xf828169c, 0xa8e8, 0x11d2, 0xa1, 0xf2, 0x0, 0xa0, 0xc9, 0x83, 0xea, 0xf6);
DEFINE_GUID( GUID_VPE2Callbacks,                0x52882147, 0x2d47, 0x469a, 0xa0, 0xd1, 0x3, 0x45, 0x58, 0x90, 0xf6, 0xc8);

#ifndef GUID_DEFS_ONLY

#ifndef _NO_DDRAWINT_NO_COM
#ifndef _NO_COM
#define _NO_COM
#include "ddraw.h"
#include "dvp.h"
#undef _NO_COM
#else
#include "ddraw.h"
#include "dvp.h"
#endif
#else
#include "ddraw.h"
#include "dvp.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

/*
 * offset into video meory
 */
typedef ULONG_PTR FLATPTR;

/*
 * maximum number of surfaces that can be autoflipped between
 */
#define MAX_AUTOFLIP_BUFFERS    10

/*
 * Indicates the surface is D3D buffer, i.e., a linear chunk of
 * memory that holds a Direct3D structure. A driver reports this
 * cap to indicate that it can create buffers in video memory and
 * Direct3D uses this bit to request buffers. However, it is not
 * visible to the API.
 */
#define DDSCAPS_EXECUTEBUFFER DDSCAPS_RESERVED2
#define DDSCAPS_COMMANDBUFFER DDSCAPS_RESERVED3
#define DDSCAPS_VERTEXBUFFER DDSCAPS_RESERVED4


/*
 * This DDPF flag is used to indicate a DX8+ format capability entry in
 * the texture format list. It is not visible to applications.
 */
#define DDPF_D3DFORMAT                                          0x00200000l

/*
 * List of operations supported on formats in DX8+ texture list.
 * See the DX8 DDK for a complete description of these flags.
 */
#define D3DFORMAT_OP_TEXTURE                    0x00000001L
#define D3DFORMAT_OP_VOLUMETEXTURE              0x00000002L
#define D3DFORMAT_OP_CUBETEXTURE                0x00000004L
#define D3DFORMAT_OP_OFFSCREEN_RENDERTARGET     0x00000008L
#define D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET   0x00000010L
#define D3DFORMAT_OP_ZSTENCIL                   0x00000040L
#define D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH 0x00000080L

// This format can be used as a render target if the current display mode
// is the same depth if the alpha channel is ignored. e.g. if the device 
// can render to A8R8G8B8 when the display mode is X8R8G8B8, then the
// format op list entry for A8R8G8B8 should have this cap. 
#define D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET 0x00000100L

// This format contains DirectDraw support (including Flip).  This flag
// should not to be set on alpha formats.
#define D3DFORMAT_OP_DISPLAYMODE                0x00000400L

// The rasterizer can support some level of Direct3D support in this format
// and implies that the driver can create a Context in this mode (for some 
// render target format).  When this flag is set, the D3DFORMAT_OP_DISPLAYMODE
// flag must also be set.
#define D3DFORMAT_OP_3DACCELERATION             0x00000800L


/*
 * pre-declare pointers to structs containing data for DDHAL driver fns
 */
typedef struct _DD_CREATEPALETTEDATA *PDD_CREATEPALETTEDATA;
typedef struct _DD_CREATESURFACEDATA *PDD_CREATESURFACEDATA;
typedef struct _DD_CANCREATESURFACEDATA *PDD_CANCREATESURFACEDATA;
typedef struct _DD_WAITFORVERTICALBLANKDATA *PDD_WAITFORVERTICALBLANKDATA;
typedef struct _DD_DESTROYDRIVERDATA *PDD_DESTROYDRIVERDATA;
typedef struct _DD_SETMODEDATA *PDD_SETMODEDATA;
typedef struct _DD_DRVSETCOLORKEYDATA *PDD_DRVSETCOLORKEYDATA;
typedef struct _DD_GETSCANLINEDATA *PDD_GETSCANLINEDATA;
typedef struct _DD_MAPMEMORYDATA *PDD_MAPMEMORYDATA;

typedef struct _DD_DESTROYPALETTEDATA *PDD_DESTROYPALETTEDATA;
typedef struct _DD_SETENTRIESDATA *PDD_SETENTRIESDATA;

typedef struct _DD_BLTDATA *PDD_BLTDATA;
typedef struct _DD_LOCKDATA *PDD_LOCKDATA;
typedef struct _DD_UNLOCKDATA *PDD_UNLOCKDATA;
typedef struct _DD_UPDATEOVERLAYDATA *PDD_UPDATEOVERLAYDATA;
typedef struct _DD_SETOVERLAYPOSITIONDATA *PDD_SETOVERLAYPOSITIONDATA;
typedef struct _DD_SETPALETTEDATA *PDD_SETPALETTEDATA;
typedef struct _DD_FLIPDATA *PDD_FLIPDATA;
typedef struct _DD_DESTROYSURFACEDATA *PDD_DESTROYSURFACEDATA;
typedef struct _DD_SETCLIPLISTDATA *PDD_SETCLIPLISTDATA;
typedef struct _DD_ADDATTACHEDSURFACEDATA *PDD_ADDATTACHEDSURFACEDATA;
typedef struct _DD_SETCOLORKEYDATA *PDD_SETCOLORKEYDATA;
typedef struct _DD_GETBLTSTATUSDATA *PDD_GETBLTSTATUSDATA;
typedef struct _DD_GETFLIPSTATUSDATA *PDD_GETFLIPSTATUSDATA;

typedef struct _DD_CANCREATEVPORTDATA *PDD_CANCREATEVPORTDATA;
typedef struct _DD_CREATEVPORTDATA *PDD_CREATEVPORTDATA;
typedef struct _DD_FLIPVPORTDATA *PDD_FLIPVPORTDATA;
typedef struct _DD_GETVPORTCONNECTDATA *PDD_GETVPORTCONNECTDATA;
typedef struct _DD_GETVPORTBANDWIDTHDATA *PDD_GETVPORTBANDWIDTHDATA;
typedef struct _DD_GETVPORTINPUTFORMATDATA *PDD_GETVPORTINPUTFORMATDATA;
typedef struct _DD_GETVPORTOUTPUTFORMATDATA *PDD_GETVPORTOUTPUTFORMATDATA;
typedef struct _DD_GETVPORTAUTOFLIPSURFACEDATA *PDD_GETVPORTAUTOFLIPSURFACEDATA;
typedef struct _DD_GETVPORTFIELDDATA *PDD_GETVPORTFIELDDATA;
typedef struct _DD_GETVPORTLINEDATA *PDD_GETVPORTLINEDATA;
typedef struct _DD_DESTROYVPORTDATA *PDD_DESTROYVPORTDATA;
typedef struct _DD_GETVPORTFLIPSTATUSDATA *PDD_GETVPORTFLIPSTATUSDATA;
typedef struct _DD_UPDATEVPORTDATA *PDD_UPDATEVPORTDATA;
typedef struct _DD_WAITFORVPORTSYNCDATA *PDD_WAITFORVPORTSYNCDATA;
typedef struct _DD_GETVPORTSIGNALDATA *PDD_GETVPORTSIGNALDATA;
typedef struct _DD_VPORTCOLORDATA *PDD_VPORTCOLORDATA;

typedef struct _DD_COLORCONTROLDATA *PDD_COLORCONTROLDATA;

typedef struct _DD_GETAVAILDRIVERMEMORYDATA *PDD_GETAVAILDRIVERMEMORYDATA;

typedef struct _DD_FREEDRIVERMEMORYDATA *PDD_FREEDRIVERMEMORYDATA;
typedef struct _DD_SETEXCLUSIVEMODEDATA *PDD_SETEXCLUSIVEMODEDATA;
typedef struct _DD_FLIPTOGDISURFACEDATA *PDD_FLIPTOGDISURFACEDATA;

typedef struct _DD_GETDRIVERINFODATA *PDD_GETDRIVERINFODATA;

typedef struct _DD_SYNCSURFACEDATA *PDD_SYNCSURFACEDATA;
typedef struct _DD_SYNCVIDEOPORTDATA *PDD_SYNCVIDEOPORTDATA;

typedef struct _DD_GETMOCOMPGUIDSDATA *PDD_GETMOCOMPGUIDSDATA;
typedef struct _DD_GETMOCOMPFORMATSDATA *PDD_GETMOCOMPFORMATSDATA;
typedef struct _DD_CREATEMOCOMPDATA *PDD_CREATEMOCOMPDATA;
typedef struct _DD_GETMOCOMPCOMPBUFFDATA *PDD_GETMOCOMPCOMPBUFFDATA;
typedef struct _DD_GETINTERNALMOCOMPDATA *PDD_GETINTERNALMOCOMPDATA;
typedef struct _DD_BEGINMOCOMPFRAMEDATA *PDD_BEGINMOCOMPFRAMEDATA;
typedef struct _DD_ENDMOCOMPFRAMEDATA *PDD_ENDMOCOMPFRAMEDATA;
typedef struct _DD_RENDERMOCOMPDATA *PDD_RENDERMOCOMPDATA;
typedef struct _DD_QUERYMOCOMPSTATUSDATA *PDD_QUERYMOCOMPSTATUSDATA;
typedef struct _DD_DESTROYMOCOMPDATA *PDD_DESTROYMOCOMPDATA;

// Miscelleneous2 callbacks
typedef struct _DD_CREATESURFACEEXDATA *PDD_CREATESURFACEEXDATA;
typedef struct _DD_GETDRIVERSTATEDATA *PDD_GETDRIVERSTATEDATA;
typedef struct _DD_DESTROYDDLOCALDATA *PDD_DESTROYDDLOCALDATA;
typedef struct _DD_MORESURFACECAPS *PDD_MORESURFACECAPS;
typedef struct _DD_STEREOMODE *PDD_STEREOMODE;
typedef struct _DD_UPDATENONLOCALHEAPDATA *PDD_UPDATENONLOCALHEAPDATA;



/*
 * The following structure is defined in dmemmgr.h
 */
struct _DD_GETHEAPALIGNMENTDATA;
typedef struct _DD_GETHEAPALIGNMENTDATA *PDD_GETHEAPALIGNMENTDATA;

/*
 * value in the fpVidMem; indicates dwBlockSize is valid (surface object)
 */
#define DDHAL_PLEASEALLOC_BLOCKSIZE     0x00000002l
#define DDHAL_PLEASEALLOC_USERMEM       0x00000004l

/*
 * video memory data structures (passed in DD_HALINFO)
 */
typedef struct _VIDEOMEMORY
{
    DWORD               dwFlags;        // flags
    FLATPTR             fpStart;        // start of memory chunk
    union
    {
        FLATPTR         fpEnd;          // end of memory chunk
        DWORD           dwWidth;        // width of chunk (rectanglar memory)
    };
    DDSCAPS             ddsCaps;        // what this memory CANNOT be used for
    DDSCAPS             ddsCapsAlt;     // what this memory CANNOT be used for if it must
    union
    {
        struct _VMEMHEAP *lpHeap;       // heap pointer, used by DDRAW
        DWORD           dwHeight;       // height of chunk (rectanguler memory)
    };
} VIDEOMEMORY;
typedef VIDEOMEMORY *LPVIDEOMEMORY;

/*
 * flags for vidmem struct
 */
#define VIDMEM_ISLINEAR         0x00000001l     // heap is linear
#define VIDMEM_ISRECTANGULAR    0x00000002l     // heap is rectangular
#define VIDMEM_ISHEAP           0x00000004l     // heap is preallocated by driver
#define VIDMEM_ISNONLOCAL       0x00000008l     // heap populated with non-local video memory
#define VIDMEM_ISWC             0x00000010l     // heap populated with write combining memory
#define VIDMEM_HEAPDISABLED     0x00000020l     // heap disabled

typedef struct _VIDEOMEMORYINFO
{
    FLATPTR             fpPrimary;              // offset to primary surface
    DWORD               dwFlags;                // flags
    DWORD               dwDisplayWidth;         // current display width
    DWORD               dwDisplayHeight;        // current display height
    LONG                lDisplayPitch;          // current display pitch
    DDPIXELFORMAT       ddpfDisplay;            // pixel format of display
    DWORD               dwOffscreenAlign;       // byte alignment for offscreen surfaces
    DWORD               dwOverlayAlign;         // byte alignment for overlays
    DWORD               dwTextureAlign;         // byte alignment for textures
    DWORD               dwZBufferAlign;         // byte alignment for z buffers
    DWORD               dwAlphaAlign;           // byte alignment for alpha
    PVOID               pvPrimary;              // kernel-mode pointer to primary surface
} VIDEOMEMORYINFO;
typedef VIDEOMEMORYINFO *LPVIDEOMEMORYINFO;

/*
 * These structures contain the entry points in the display driver that
 * DDRAW will call.   Entries that the display driver does not care about
 * should be NULL.   Passed to DDRAW in DD_HALINFO.
 */
typedef struct _DD_DIRECTDRAW_GLOBAL *PDD_DIRECTDRAW_GLOBAL;
typedef struct _DD_SURFACE_GLOBAL *PDD_SURFACE_GLOBAL;
typedef struct _DD_PALETTE_GLOBAL *PDD_PALETTE_GLOBAL;
typedef struct _DD_CLIPPER_GLOBAL *PDD_CLIPPER_GLOBAL;
typedef struct _DD_DIRECTDRAW_LOCAL *PDD_DIRECTDRAW_LOCAL;
typedef struct _DD_SURFACE_LOCAL *PDD_SURFACE_LOCAL;
typedef struct _DD_SURFACE_MORE *PDD_SURFACE_MORE;
typedef struct _DD_SURFACE_INT *PDD_SURFACE_INT;
typedef struct _DD_VIDEOPORT_LOCAL *PDD_VIDEOPORT_LOCAL;
typedef struct _DD_PALETTE_LOCAL *PDD_PALETTE_LOCAL;
typedef struct _DD_CLIPPER_LOCAL *PDD_CLIPPER_LOCAL;
typedef struct _DD_MOTIONCOMP_LOCAL *PDD_MOTIONCOMP_LOCAL;

/*
 * DIRECTDRAW object callbacks
 */
typedef DWORD   (APIENTRY *PDD_SETCOLORKEY)(PDD_DRVSETCOLORKEYDATA );
typedef DWORD   (APIENTRY *PDD_CANCREATESURFACE)(PDD_CANCREATESURFACEDATA );
typedef DWORD   (APIENTRY *PDD_WAITFORVERTICALBLANK)(PDD_WAITFORVERTICALBLANKDATA );
typedef DWORD   (APIENTRY *PDD_CREATESURFACE)(PDD_CREATESURFACEDATA);
typedef DWORD   (APIENTRY *PDD_DESTROYDRIVER)(PDD_DESTROYDRIVERDATA);
typedef DWORD   (APIENTRY *PDD_SETMODE)(PDD_SETMODEDATA);
typedef DWORD   (APIENTRY *PDD_CREATEPALETTE)(PDD_CREATEPALETTEDATA);
typedef DWORD   (APIENTRY *PDD_GETSCANLINE)(PDD_GETSCANLINEDATA);
typedef DWORD   (APIENTRY *PDD_MAPMEMORY)(PDD_MAPMEMORYDATA);

typedef DWORD   (APIENTRY *PDD_GETDRIVERINFO)(PDD_GETDRIVERINFODATA);

typedef struct DD_CALLBACKS
{
    DWORD                       dwSize;
    DWORD                       dwFlags;
    PDD_DESTROYDRIVER           DestroyDriver;
    PDD_CREATESURFACE           CreateSurface;
    PDD_SETCOLORKEY             SetColorKey;
    PDD_SETMODE                 SetMode;
    PDD_WAITFORVERTICALBLANK    WaitForVerticalBlank;
    PDD_CANCREATESURFACE        CanCreateSurface;
    PDD_CREATEPALETTE           CreatePalette;
    PDD_GETSCANLINE             GetScanLine;
    PDD_MAPMEMORY               MapMemory;
} DD_CALLBACKS;

typedef DD_CALLBACKS *PDD_CALLBACKS;

#define DDHAL_CB32_DESTROYDRIVER        0x00000001l
#define DDHAL_CB32_CREATESURFACE        0x00000002l
#define DDHAL_CB32_SETCOLORKEY          0x00000004l
#define DDHAL_CB32_SETMODE              0x00000008l
#define DDHAL_CB32_WAITFORVERTICALBLANK 0x00000010l
#define DDHAL_CB32_CANCREATESURFACE     0x00000020l
#define DDHAL_CB32_CREATEPALETTE        0x00000040l
#define DDHAL_CB32_GETSCANLINE          0x00000080l
#define DDHAL_CB32_MAPMEMORY            0x80000000l

// This structure can be queried from the driver from NT5 onward
// using GetDriverInfo with GUID_MiscellaneousCallbacks

typedef DWORD   (APIENTRY *PDD_GETAVAILDRIVERMEMORY)(PDD_GETAVAILDRIVERMEMORYDATA);

typedef struct _DD_MISCELLANEOUSCALLBACKS {
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_GETAVAILDRIVERMEMORY            GetAvailDriverMemory;
} DD_MISCELLANEOUSCALLBACKS, *PDD_MISCELLANEOUSCALLBACKS;

#define DDHAL_MISCCB32_GETAVAILDRIVERMEMORY    0x00000001l

// DDHAL_DDMISCELLANEOUS2CALLBACKS:
//   This structure can be queried from the driver from DX7 onward
//   using GetDriverInfo with GUID_Miscellaneous2Callbacks

typedef DWORD   (APIENTRY *PDD_ALPHABLT)(PDD_BLTDATA);
typedef DWORD   (APIENTRY *PDD_CREATESURFACEEX)(PDD_CREATESURFACEEXDATA);
typedef DWORD   (APIENTRY *PDD_GETDRIVERSTATE)(PDD_GETDRIVERSTATEDATA);
typedef DWORD   (APIENTRY *PDD_DESTROYDDLOCAL)(PDD_DESTROYDDLOCALDATA);

typedef struct _DD_MISCELLANEOUS2CALLBACKS {
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_ALPHABLT                        AlphaBlt;
    PDD_CREATESURFACEEX                 CreateSurfaceEx;
    PDD_GETDRIVERSTATE                  GetDriverState;
    PDD_DESTROYDDLOCAL                  DestroyDDLocal;
} DD_MISCELLANEOUS2CALLBACKS, *PDD_MISCELLANEOUS2CALLBACKS;

#define DDHAL_MISC2CB32_ALPHABLT                 0x00000001l
#define DDHAL_MISC2CB32_CREATESURFACEEX          0x00000002l
#define DDHAL_MISC2CB32_GETDRIVERSTATE           0x00000004l
#define DDHAL_MISC2CB32_DESTROYDDLOCAL           0x00000008l

// This is used in the CreateSurfaceEx callback to indicate that the
// SwapHandle emulation is being done
#define DDHAL_CREATESURFACEEX_SWAPHANDLES      0x00000001l

// This structure can be queried from the driver from NT5 onward
// using GetDriverInfo with GUID_NTCallbacks

typedef DWORD   (APIENTRY *PDD_FREEDRIVERMEMORY)(PDD_FREEDRIVERMEMORYDATA);
typedef DWORD   (APIENTRY *PDD_SETEXCLUSIVEMODE)(PDD_SETEXCLUSIVEMODEDATA);
typedef DWORD   (APIENTRY *PDD_FLIPTOGDISURFACE)(PDD_FLIPTOGDISURFACEDATA);

typedef struct _DD_NTCALLBACKS {
    DWORD                   dwSize;
    DWORD                   dwFlags;
    PDD_FREEDRIVERMEMORY    FreeDriverMemory;
    PDD_SETEXCLUSIVEMODE    SetExclusiveMode;
    PDD_FLIPTOGDISURFACE    FlipToGDISurface;
} DD_NTCALLBACKS, *PDD_NTCALLBACKS;

#define DDHAL_NTCB32_FREEDRIVERMEMORY   0x00000001l
#define DDHAL_NTCB32_SETEXCLUSIVEMODE   0x00000002l
#define DDHAL_NTCB32_FLIPTOGDISURFACE   0x00000004l

/*
 * DIRECTDRAWPALETTE object callbacks
 */
typedef DWORD   (APIENTRY *PDD_PALCB_DESTROYPALETTE)(PDD_DESTROYPALETTEDATA );
typedef DWORD   (APIENTRY *PDD_PALCB_SETENTRIES)(PDD_SETENTRIESDATA );

typedef struct DD_PALETTECALLBACKS
{
    DWORD                       dwSize;
    DWORD                       dwFlags;
    PDD_PALCB_DESTROYPALETTE    DestroyPalette;
    PDD_PALCB_SETENTRIES        SetEntries;
} DD_PALETTECALLBACKS;

typedef DD_PALETTECALLBACKS *PDD_PALETTECALLBACKS;

#define DDHAL_PALCB32_DESTROYPALETTE    0x00000001l
#define DDHAL_PALCB32_SETENTRIES        0x00000002l

/*
 * DIRECTDRAWSURFACE object callbacks
 */
typedef DWORD   (APIENTRY *PDD_SURFCB_LOCK)(PDD_LOCKDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_UNLOCK)(PDD_UNLOCKDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_BLT)(PDD_BLTDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_UPDATEOVERLAY)(PDD_UPDATEOVERLAYDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_SETOVERLAYPOSITION)(PDD_SETOVERLAYPOSITIONDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_SETPALETTE)(PDD_SETPALETTEDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_FLIP)(PDD_FLIPDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_DESTROYSURFACE)(PDD_DESTROYSURFACEDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_SETCLIPLIST)(PDD_SETCLIPLISTDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_ADDATTACHEDSURFACE)(PDD_ADDATTACHEDSURFACEDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_SETCOLORKEY)(PDD_SETCOLORKEYDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_GETBLTSTATUS)(PDD_GETBLTSTATUSDATA);
typedef DWORD   (APIENTRY *PDD_SURFCB_GETFLIPSTATUS)(PDD_GETFLIPSTATUSDATA);


typedef struct DD_SURFACECALLBACKS
{
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_SURFCB_DESTROYSURFACE           DestroySurface;
    PDD_SURFCB_FLIP                     Flip;
    PDD_SURFCB_SETCLIPLIST              SetClipList;
    PDD_SURFCB_LOCK                     Lock;
    PDD_SURFCB_UNLOCK                   Unlock;
    PDD_SURFCB_BLT                      Blt;
    PDD_SURFCB_SETCOLORKEY              SetColorKey;
    PDD_SURFCB_ADDATTACHEDSURFACE       AddAttachedSurface;
    PDD_SURFCB_GETBLTSTATUS             GetBltStatus;
    PDD_SURFCB_GETFLIPSTATUS            GetFlipStatus;
    PDD_SURFCB_UPDATEOVERLAY            UpdateOverlay;
    PDD_SURFCB_SETOVERLAYPOSITION       SetOverlayPosition;
    LPVOID                              reserved4;
    PDD_SURFCB_SETPALETTE               SetPalette;
} DD_SURFACECALLBACKS;
typedef DD_SURFACECALLBACKS *PDD_SURFACECALLBACKS;

#define DDHAL_SURFCB32_DESTROYSURFACE           0x00000001l
#define DDHAL_SURFCB32_FLIP                     0x00000002l
#define DDHAL_SURFCB32_SETCLIPLIST              0x00000004l
#define DDHAL_SURFCB32_LOCK                     0x00000008l
#define DDHAL_SURFCB32_UNLOCK                   0x00000010l
#define DDHAL_SURFCB32_BLT                      0x00000020l
#define DDHAL_SURFCB32_SETCOLORKEY              0x00000040l
#define DDHAL_SURFCB32_ADDATTACHEDSURFACE       0x00000080l
#define DDHAL_SURFCB32_GETBLTSTATUS             0x00000100l
#define DDHAL_SURFCB32_GETFLIPSTATUS            0x00000200l
#define DDHAL_SURFCB32_UPDATEOVERLAY            0x00000400l
#define DDHAL_SURFCB32_SETOVERLAYPOSITION       0x00000800l
#define DDHAL_SURFCB32_RESERVED4                0x00001000l
#define DDHAL_SURFCB32_SETPALETTE               0x00002000l

/*
 * DIRECTVIDEOPORT object callbacks
 */
typedef DWORD (APIENTRY *PDD_VPORTCB_CANCREATEVIDEOPORT)(PDD_CANCREATEVPORTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_CREATEVIDEOPORT)(PDD_CREATEVPORTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_FLIP)(PDD_FLIPVPORTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETBANDWIDTH)(PDD_GETVPORTBANDWIDTHDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETINPUTFORMATS)(PDD_GETVPORTINPUTFORMATDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETOUTPUTFORMATS)(PDD_GETVPORTOUTPUTFORMATDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETAUTOFLIPSURF)(PDD_GETVPORTAUTOFLIPSURFACEDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETFIELD)(PDD_GETVPORTFIELDDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETLINE)(PDD_GETVPORTLINEDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETVPORTCONNECT)(PDD_GETVPORTCONNECTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_DESTROYVPORT)(PDD_DESTROYVPORTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETFLIPSTATUS)(PDD_GETVPORTFLIPSTATUSDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_UPDATE)(PDD_UPDATEVPORTDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_WAITFORSYNC)(PDD_WAITFORVPORTSYNCDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_GETSIGNALSTATUS)(PDD_GETVPORTSIGNALDATA);
typedef DWORD (APIENTRY *PDD_VPORTCB_COLORCONTROL)(PDD_VPORTCOLORDATA);

typedef struct DD_VIDEOPORTCALLBACKS
{
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_VPORTCB_CANCREATEVIDEOPORT      CanCreateVideoPort;
    PDD_VPORTCB_CREATEVIDEOPORT         CreateVideoPort;
    PDD_VPORTCB_FLIP                    FlipVideoPort;
    PDD_VPORTCB_GETBANDWIDTH            GetVideoPortBandwidth;
    PDD_VPORTCB_GETINPUTFORMATS         GetVideoPortInputFormats;
    PDD_VPORTCB_GETOUTPUTFORMATS        GetVideoPortOutputFormats;
    LPVOID                              lpReserved1;
    PDD_VPORTCB_GETFIELD                GetVideoPortField;
    PDD_VPORTCB_GETLINE                 GetVideoPortLine;
    PDD_VPORTCB_GETVPORTCONNECT         GetVideoPortConnectInfo;
    PDD_VPORTCB_DESTROYVPORT            DestroyVideoPort;
    PDD_VPORTCB_GETFLIPSTATUS           GetVideoPortFlipStatus;
    PDD_VPORTCB_UPDATE                  UpdateVideoPort;
    PDD_VPORTCB_WAITFORSYNC             WaitForVideoPortSync;
    PDD_VPORTCB_GETSIGNALSTATUS         GetVideoSignalStatus;
    PDD_VPORTCB_COLORCONTROL            ColorControl;
} DD_VIDEOPORTCALLBACKS;

typedef DD_VIDEOPORTCALLBACKS *PDD_VIDEOPORTCALLBACKS;

#define DDHAL_VPORT32_CANCREATEVIDEOPORT        0x00000001l
#define DDHAL_VPORT32_CREATEVIDEOPORT           0x00000002l
#define DDHAL_VPORT32_FLIP                      0x00000004l
#define DDHAL_VPORT32_GETBANDWIDTH              0x00000008l
#define DDHAL_VPORT32_GETINPUTFORMATS           0x00000010l
#define DDHAL_VPORT32_GETOUTPUTFORMATS          0x00000020l
#define DDHAL_VPORT32_GETAUTOFLIPSURF           0x00000040l
#define DDHAL_VPORT32_GETFIELD                  0x00000080l
#define DDHAL_VPORT32_GETLINE                   0x00000100l
#define DDHAL_VPORT32_GETCONNECT                0x00000200l
#define DDHAL_VPORT32_DESTROY                   0x00000400l
#define DDHAL_VPORT32_GETFLIPSTATUS             0x00000800l
#define DDHAL_VPORT32_UPDATE                    0x00001000l
#define DDHAL_VPORT32_WAITFORSYNC               0x00002000l
#define DDHAL_VPORT32_GETSIGNALSTATUS           0x00004000l
#define DDHAL_VPORT32_COLORCONTROL              0x00008000l

/*
 * DIRECTDRAWCOLORCONTROL object callbacks
 */
typedef DWORD (APIENTRY *PDD_COLORCB_COLORCONTROL)(PDD_COLORCONTROLDATA);

typedef struct _DD_COLORCONTROLCALLBACKS
{
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_COLORCB_COLORCONTROL            ColorControl;
} DD_COLORCONTROLCALLBACKS;

typedef DD_COLORCONTROLCALLBACKS *PDD_COLORCONTROLCALLBACKS;

#define DDHAL_COLOR_COLORCONTROL                0x00000001l

/*
 * DIRECTDRAWSURFACEKERNEL object callbacks
 * This structure can be queried from the driver from DX5 onward
 * using GetDriverInfo with GUID_KernelCallbacks
 */
typedef DWORD (APIENTRY *PDD_KERNELCB_SYNCSURFACE)(PDD_SYNCSURFACEDATA);
typedef DWORD (APIENTRY *PDD_KERNELCB_SYNCVIDEOPORT)(PDD_SYNCVIDEOPORTDATA);

typedef struct DD_KERNELCALLBACKS
{
    DWORD                               dwSize;
    DWORD                               dwFlags;
    PDD_KERNELCB_SYNCSURFACE            SyncSurfaceData;
    PDD_KERNELCB_SYNCVIDEOPORT          SyncVideoPortData;
} DD_KERNELCALLBACKS, *PDD_KERNELCALLBACKS;

#define DDHAL_KERNEL_SYNCSURFACEDATA            0x00000001l
#define DDHAL_KERNEL_SYNCVIDEOPORTDATA          0x00000002l

/*
 * DIRECTDRAWVIDEO object callbacks
 */
typedef DWORD (APIENTRY *PDD_MOCOMPCB_GETGUIDS)( PDD_GETMOCOMPGUIDSDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_GETFORMATS)( PDD_GETMOCOMPFORMATSDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_CREATE)( PDD_CREATEMOCOMPDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_GETCOMPBUFFINFO)( PDD_GETMOCOMPCOMPBUFFDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_GETINTERNALINFO)( PDD_GETINTERNALMOCOMPDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_BEGINFRAME)( PDD_BEGINMOCOMPFRAMEDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_ENDFRAME)( PDD_ENDMOCOMPFRAMEDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_RENDER)( PDD_RENDERMOCOMPDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_QUERYSTATUS)( PDD_QUERYMOCOMPSTATUSDATA);
typedef DWORD (APIENTRY *PDD_MOCOMPCB_DESTROY)( PDD_DESTROYMOCOMPDATA);

typedef struct DD_MOTIONCOMPCALLBACKS
{
    DWORD                           dwSize;
    DWORD                           dwFlags;
    PDD_MOCOMPCB_GETGUIDS           GetMoCompGuids;
    PDD_MOCOMPCB_GETFORMATS         GetMoCompFormats;
    PDD_MOCOMPCB_CREATE             CreateMoComp;
    PDD_MOCOMPCB_GETCOMPBUFFINFO    GetMoCompBuffInfo;
    PDD_MOCOMPCB_GETINTERNALINFO    GetInternalMoCompInfo;
    PDD_MOCOMPCB_BEGINFRAME         BeginMoCompFrame;
    PDD_MOCOMPCB_ENDFRAME           EndMoCompFrame;
    PDD_MOCOMPCB_RENDER             RenderMoComp;
    PDD_MOCOMPCB_QUERYSTATUS        QueryMoCompStatus;
    PDD_MOCOMPCB_DESTROY            DestroyMoComp;
} DD_MOTIONCOMPCALLBACKS;
typedef DD_MOTIONCOMPCALLBACKS *PDD_MOTIONCOMPCALLBACKS;

#define DDHAL_MOCOMP32_GETGUIDS                 0x00000001
#define DDHAL_MOCOMP32_GETFORMATS               0x00000002
#define DDHAL_MOCOMP32_CREATE                   0x00000004
#define DDHAL_MOCOMP32_GETCOMPBUFFINFO          0x00000008
#define DDHAL_MOCOMP32_GETINTERNALINFO          0x00000010
#define DDHAL_MOCOMP32_BEGINFRAME               0x00000020
#define DDHAL_MOCOMP32_ENDFRAME                 0x00000040
#define DDHAL_MOCOMP32_RENDER                   0x00000080
#define DDHAL_MOCOMP32_QUERYSTATUS              0x00000100
#define DDHAL_MOCOMP32_DESTROY                  0x00000200

/*
 * CALLBACK RETURN VALUES
 *
 * these are values returned by the driver from the above callback routines
 */
/*
 * indicates that the display driver didn't do anything with the call
 */
#define DDHAL_DRIVER_NOTHANDLED         0x00000000l

/*
 * indicates that the display driver handled the call; HRESULT value is valid
 */
#define DDHAL_DRIVER_HANDLED            0x00000001l

/*
 * indicates that the display driver couldn't handle the call because it
 * ran out of color key hardware resources
 */
#define DDHAL_DRIVER_NOCKEYHW           0x00000002l

/*
 * Capabilities structure for non-local video memory
 */
typedef struct _DD_NONLOCALVIDMEMCAPS
{
    DWORD   dwSize;
    DWORD   dwNLVBCaps;           // driver specific capabilities for non-local->local vidmem blts
    DWORD   dwNLVBCaps2;          // more driver specific capabilities non-local->local vidmem blts
    DWORD   dwNLVBCKeyCaps;       // driver color key capabilities for non-local->local vidmem blts
    DWORD   dwNLVBFXCaps;         // driver FX capabilities for non-local->local blts
    DWORD   dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
} DD_NONLOCALVIDMEMCAPS;
typedef struct _DD_NONLOCALVIDMEMCAPS *PDD_NONLOCALVIDMEMCAPS;

/*
 * DDRAW internal version of DIRECTDRAWPALETTE object; it has data after the vtable
 */
typedef struct _DD_PALETTE_GLOBAL
{
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
} DD_PALETTE_GLOBAL;

typedef struct _DD_PALETTE_LOCAL
{
    ULONG                       dwReserved0;    // reserved for future expansion
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
} DD_PALETTE_LOCAL;

/*
 * DDRAW internal version of DIRECTDRAWCLIPPER object; it has data after the vtable
 */
typedef struct _DD_CLIPPER_GLOBAL
{
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
} DD_CLIPPER_GLOBAL;

typedef struct _DD_CLIPPER_LOCAL
{
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
} DD_CLIPPER_LOCAL;

typedef struct _DD_ATTACHLIST *PDD_ATTACHLIST;
typedef struct _DD_ATTACHLIST
{
    PDD_ATTACHLIST              lpLink;         // link to next attached surface
    PDD_SURFACE_LOCAL           lpAttached;     // attached surface local object
} DD_ATTACHLIST;

/*
 * DDRAW surface interface struct
 */
typedef struct _DD_SURFACE_INT
{
    PDD_SURFACE_LOCAL           lpLcl;          // pointer to interface data
} DD_SURFACE_INT;

/*
 * DDRAW internal version of DIRECTDRAWSURFACE struct
 *
 * the GBL structure is global data for all duplicate objects
 */
typedef struct _DD_SURFACE_GLOBAL
{
    union 
    {
        DWORD                   dwBlockSizeY;   // block size that display driver requested (return)
        LONG                    lSlicePitch;    // slice pitch for volume textures
    };

    union 
    {
        LPVIDEOMEMORY           lpVidMemHeap;   // heap vidmem was alloc'ed from
        DWORD                   dwBlockSizeX;   // block size that display driver requested (return)
        DWORD                   dwUserMemSize;  // user-mode memory size that display driver requested (return)
    };

    FLATPTR                     fpVidMem;       // pointer to video memory
    union
    {
        LONG                    lPitch;         // pitch of surface
        DWORD                   dwLinearSize;   // linear size of non-rectangular surface
    };
    LONG                        yHint;          // y-coordinate of surface
    LONG                        xHint;          // x-coordinate of surface
    DWORD                       wHeight;        // height of surface
    DWORD                       wWidth;         // width of surface
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
    DDPIXELFORMAT               ddpfSurface;    // pixel format of surface
    FLATPTR                     fpHeapOffset;   // raw offset in source heap
    HANDLE                      hCreatorProcess;// opaque identifier for creating process
} DD_SURFACE_GLOBAL;

/*
 * a structure holding additional LCL surface information (to maintain some
 * compatibility with Win95).
 */
typedef struct _DD_SURFACE_MORE
{
    DWORD                       dwMipMapCount;      // number of mip-map levels
    PDD_VIDEOPORT_LOCAL         lpVideoPort;        // video port currently writing data to this surface
    DWORD                       dwOverlayFlags;     // current overlay flags
    DDSCAPSEX                   ddsCapsEx;          // more surface capabilities
    DWORD                       dwSurfaceHandle;    // cookie for use with CreateSurfaceEx DDI
} DD_SURFACE_MORE, *PDD_SURFACE_MORE;

/*
 * the LCL structure is local data for each individual surface object
 */
typedef struct _DD_SURFACE_LOCAL
{
    PDD_SURFACE_GLOBAL          lpGbl;            // pointer to surface shared data
    DWORD                       dwFlags;          // flags
    DDSCAPS                     ddsCaps;          // capabilities of surface
    ULONG_PTR                   dwReserved1;      // reserved for use by display driver
    union
    {
        DDCOLORKEY              ddckCKSrcOverlay; // color key for source overlay use
        DDCOLORKEY              ddckCKSrcBlt;     // color key for source blt and texture use
    };
    union
    {
        DDCOLORKEY              ddckCKDestOverlay;// color key for destination overlay use
        DDCOLORKEY              ddckCKDestBlt;    // color key for destination blt
    };
    PDD_SURFACE_MORE            lpSurfMore;       // pointer to additional local data
    PDD_ATTACHLIST              lpAttachList;     // link to surfaces we attached to
    PDD_ATTACHLIST              lpAttachListFrom; // link to surfaces that attached to us
    RECT                        rcOverlaySrc;     // Overlay source rectangle relative to surface
} DD_SURFACE_LOCAL;

#define DDRAWISURF_HASCKEYSRCBLT        0x00000800L     // surface has CKSrcBlt
#define DDRAWISURF_HASPIXELFORMAT       0x00002000L     // surface structure has pixel format data
#define DDRAWISURF_HASOVERLAYDATA       0x00004000L     // surface structure has overlay data
#define DDRAWISURF_FRONTBUFFER          0x04000000L     // surface was originally a front buffer
#define DDRAWISURF_BACKBUFFER           0x08000000L     // surface was originally backbuffer
#define DDRAWISURF_INVALID              0x10000000L     // surface has been invalidated by mode set
#define DDRAWISURF_DRIVERMANAGED        0x40000000L     // surface is a driver managed texture (D3D)

/*
 * More driver capabilities (in addition to those described in DDCORECAPS).
 * This struct contains the caps bits added to the DDCAPS structure in DX6.
 */
typedef struct _DD_MORECAPS
{
    DWORD   dwSize; 		    // size of DDMORECAPS structure
    DWORD   dwAlphaCaps;	    // driver-specific alpha caps for overlays & Vmem->Vmem blts
    DWORD   dwSVBAlphaCaps;	    // driver-specific alpha capabilities for System->Vmem blts
    DWORD   dwVSBAlphaCaps;	    // driver-specific alpha capabilities for Vmem->System blts
    DWORD   dwSSBAlphaCaps;	    // driver-specific alpha capabilities for System->System blts
    DWORD   dwFilterCaps;           // driver-specific filter caps for overlays & Vmem->Vmem blts
    DWORD   dwSVBFilterCaps;        // driver-specific filter capabilities for System->Vmem blts
    DWORD   dwVSBFilterCaps;        // driver-specific filter capabilities for Vmem->System blts
    DWORD   dwSSBFilterCaps;        // driver-specific filter capabilities for System->System blts
} DD_MORECAPS;

typedef DD_MORECAPS *PDD_MORECAPS;

/*
 * rop stuff
 */
#define ROP_HAS_SOURCE          0x00000001l
#define ROP_HAS_PATTERN         0x00000002l
#define ROP_HAS_SOURCEPATTERN   ROP_HAS_SOURCE | ROP_HAS_PATTERN

/*
 * This structure mirrors the first entries of the DDCAPS but is of a fixed
 * size and will not grow as DDCAPS grows. This is the structure your driver
 * returns in DDCOREINFO. Additional caps will be requested via a GetDriverInfo
 * call.
 */
typedef struct _DDNTCORECAPS
{
    DWORD       dwSize;                 // size of the DDDRIVERCAPS structure
    DWORD       dwCaps;                 // driver specific capabilities
    DWORD       dwCaps2;                // more driver specific capabilites
    DWORD       dwCKeyCaps;             // color key capabilities of the surface
    DWORD       dwFXCaps;               // driver specific stretching and effects capabilites
    DWORD       dwFXAlphaCaps;          // alpha driver specific capabilities
    DWORD       dwPalCaps;              // palette capabilities
    DWORD       dwSVCaps;               // stereo vision capabilities
    DWORD       dwAlphaBltConstBitDepths;       // DDBD_2,4,8
    DWORD       dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
    DWORD       dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
    DWORD       dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
    DWORD       dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
    DWORD       dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD       dwZBufferBitDepths;             // DDBD_8,16,24,32
    DWORD       dwVidMemTotal;          // total amount of video memory
    DWORD       dwVidMemFree;           // amount of free video memory
    DWORD       dwMaxVisibleOverlays;   // maximum number of visible overlays
    DWORD       dwCurrVisibleOverlays;  // current number of visible overlays
    DWORD       dwNumFourCCCodes;       // number of four cc codes
    DWORD       dwAlignBoundarySrc;     // source rectangle alignment
    DWORD       dwAlignSizeSrc;         // source rectangle byte size
    DWORD       dwAlignBoundaryDest;    // dest rectangle alignment
    DWORD       dwAlignSizeDest;        // dest rectangle byte size
    DWORD       dwAlignStrideAlign;     // stride alignment
    DWORD       dwRops[DD_ROP_SPACE];   // ROPS supported
    DDSCAPS     ddsCaps;                // DDSCAPS structure has all the general capabilities
    DWORD       dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwReserved1;            // reserved
    DWORD       dwReserved2;            // reserved
    DWORD       dwReserved3;            // reserved
    DWORD       dwSVBCaps;              // driver specific capabilities for System->Vmem blts
    DWORD       dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
    DWORD       dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
    DWORD       dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
    DWORD       dwVSBCaps;              // driver specific capabilities for Vmem->System blts
    DWORD       dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
    DWORD       dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
    DWORD       dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
    DWORD       dwSSBCaps;              // driver specific capabilities for System->System blts
    DWORD       dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
    DWORD       dwSSBFXCaps;            // driver FX capabilities for System->System blts
    DWORD       dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
    DWORD       dwMaxVideoPorts;        // maximum number of usable video ports
    DWORD       dwCurrVideoPorts;       // current number of video ports used
    DWORD       dwSVBCaps2;             // more driver specific capabilities for System->Vmem blts
} DDNTCORECAPS, *PDDNTCORECAPS;

/*
 * structure for D3D buffer callbacks
 */
typedef struct _DD_D3DBUFCALLBACKS
{
    DWORD dwSize;
    DWORD dwFlags;
    PDD_CANCREATESURFACE        CanCreateD3DBuffer;
    PDD_CREATESURFACE           CreateD3DBuffer;
    PDD_SURFCB_DESTROYSURFACE   DestroyD3DBuffer;
    PDD_SURFCB_LOCK             LockD3DBuffer;
    PDD_SURFCB_UNLOCK           UnlockD3DBuffer;
} DD_D3DBUFCALLBACKS, *PDD_D3DBUFCALLBACKS;

#define DDHAL_EXEBUFCB32_CANCREATEEXEBUF    0x00000001l
#define DDHAL_EXEBUFCB32_CREATEEXEBUF       0x00000002l
#define DDHAL_EXEBUFCB32_DESTROYEXEBUF      0x00000004l
#define DDHAL_EXEBUFCB32_LOCKEXEBUF         0x00000008l
#define DDHAL_EXEBUFCB32_UNLOCKEXEBUF       0x00000010l

/*
 * NT friendly names
 */
#define DDHAL_D3DBUFCB32_CANCREATED3DBUF    DDHAL_EXEBUFCB32_CANCREATEEXEBUF    
#define DDHAL_D3DBUFCB32_CREATED3DBUF       DDHAL_EXEBUFCB32_CREATEEXEBUF       
#define DDHAL_D3DBUFCB32_DESTROYD3DBUF      DDHAL_EXEBUFCB32_DESTROYEXEBUF      
#define DDHAL_D3DBUFCB32_LOCKD3DBUF         DDHAL_EXEBUFCB32_LOCKEXEBUF         
#define DDHAL_D3DBUFCB32_UNLOCKD3DBUF       DDHAL_EXEBUFCB32_UNLOCKEXEBUF       


/*
 * structure for display driver to call DDHAL_Create with
 * the _V4 version was used by NT4 drivers
 */
typedef struct _DD_HALINFO_V4
{
    DWORD                       dwSize;
    VIDEOMEMORYINFO             vmiData;                // video memory info
    DDNTCORECAPS                ddCaps;                 // hw specific caps
    PDD_GETDRIVERINFO           GetDriverInfo;          // callback for querying driver data
    DWORD                       dwFlags;                // create flags
} DD_HALINFO_V4, *PDD_HALINFO_V4;

typedef struct _DD_HALINFO
{
    DWORD                       dwSize;
    VIDEOMEMORYINFO             vmiData;                // video memory info
    DDNTCORECAPS                ddCaps;                 // hw specific caps
    PDD_GETDRIVERINFO           GetDriverInfo;          // callback for querying driver data
    DWORD                       dwFlags;                // create flags
    LPVOID                      lpD3DGlobalDriverData;  // D3D global Data
    LPVOID                      lpD3DHALCallbacks;      // D3D callbacks
    PDD_D3DBUFCALLBACKS         lpD3DBufCallbacks;      // Buffer callbacks
} DD_HALINFO, *PDD_HALINFO;

#define DDHALINFO_GETDRIVERINFOSET      0x00000004l     // indicates that GetDriverInfo is set
#define DDHALINFO_GETDRIVERINFO2        0x00000008l     // indicates driver support GetDriverInfo2 variant
                                                        // of GetDriverInfo. New for DX 8.0


/*
 * DDRAW version of DirectDraw object;
 *
 */
typedef struct _DD_DIRECTDRAW_GLOBAL
{
    VOID*                       dhpdev;         // driver's private PDEV pointer
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
    ULONG_PTR                   dwReserved2;    // reserved for use by display driver
    LPDDVIDEOPORTCAPS           lpDDVideoPortCaps;// Info returned by the HAL (an array if more than one video port)
} DD_DIRECTDRAW_GLOBAL;

typedef struct _DD_DIRECTDRAW_LOCAL
{
    PDD_DIRECTDRAW_GLOBAL       lpGbl;            // pointer to data
} DD_DIRECTDRAW_LOCAL;

typedef struct _DD_VIDEOPORT_LOCAL
{
    PDD_DIRECTDRAW_LOCAL        lpDD;             // pointer to DIRECTDRAW_LCL
    DDVIDEOPORTDESC             ddvpDesc;         // description used at create time
    DDVIDEOPORTINFO             ddvpInfo;         // most recent video port info
    PDD_SURFACE_INT             lpSurface;        // surface receiving the data
    PDD_SURFACE_INT             lpVBISurface;     // surface receiving the VBI data
    DWORD                       dwNumAutoflip;    // Number of current autoflip surfaces
    DWORD                       dwNumVBIAutoflip; // Number of VBI surfaces currently being autoflipped
    ULONG_PTR                   dwReserved1;      // Reserved for display driver
    ULONG_PTR                   dwReserved2;      // Reserved for display driver
    ULONG_PTR                   dwReserved3;      // Reserved for display driver
} DD_VIDEOPORT_LOCAL;

#define DDRAWIVPORT_ON                  0x00000001      // Video port is pumping data
#define DDRAWIVPORT_SOFTWARE_AUTOFLIP   0x00000002      // Video port cannot use hardware autoflip
#define DDRAWIVPORT_COLORKEYANDINTERP   0x00000004      // Overlay cannot bob and colorkey at same time

typedef struct _DD_MOTIONCOMP_LOCAL
{
    PDD_DIRECTDRAW_LOCAL        lpDD;             // pointer to DIRECTDRAW_LCL
    GUID                            guid;
    DWORD                           dwUncompWidth;
    DWORD                           dwUncompHeight;
    DDPIXELFORMAT                   ddUncompPixelFormat;
    DWORD                           dwDriverReserved1;
    DWORD                           dwDriverReserved2;
    DWORD                           dwDriverReserved3;
    LPVOID                          lpDriverReserved1;
    LPVOID                          lpDriverReserved2;
    LPVOID                          lpDriverReserved3;
} DD_MOTIONCOMP_LOCAL;


/*
 * More driver surface capabilities (in addition to those described in DDCORECAPS).
 * This struct contains the caps bits added to the DDCAPS.ddsCaps structure in DX6.
 */
typedef struct _DD_MORESURFACECAPS
{
    DWORD       dwSize;             // size of DDMORESURFACECAPS structure
    DDSCAPSEX   ddsCapsMore;
    /*
     * The DDMORESURFACECAPS struct is of variable size. The following list may be
     * filled in by DX6-aware drivers (see DDVERSIONINFO) to restrict their
     * video memory heaps (those which are exposed to DirectDraw) to
     * certain sets of DDSCAPS_ bits. Thse entries are exactly analogous to
     * the ddsCaps and ddsCapsAlt members of the VIDMEM structures listed in
     * the VIDMEMINFO.pvmList member of DDHALINFO.vmiData. There should be
     * exactly DDHALINFO.vmiData.dwNumHeaps copies of tagExtendedHeapRestrictions
     * in this struct. The size of this struct is thus:
     *  DDMORESURFACECAPS.dwSize = sizeof(DDMORESURFACECAPS) +
     *          (DDHALINFO.vmiData.dwNumHeaps-1) * sizeof(DDSCAPSEX)*2;
     * Note the -1 accounts for the fact that DDMORESURFACECAPS is declared to have 1
     * tagExtendedHeapRestrictions member.
     */
    struct tagNTExtendedHeapRestrictions
    {
        DDSCAPSEX   ddsCapsEx;
        DDSCAPSEX   ddsCapsExAlt;
    } ddsExtendedHeapRestrictions[1];
} DD_MORESURFACECAPS;

// for DX7, we check each mode in the driver if it supports 
// Stereo, driver returns DD_OK if mode is ok for stereo
typedef struct _DD_STEREOMODE
{
    DWORD       dwSize;             // size of DDSTEREOMODECAPS structure

    DWORD       dwHeight;
    DWORD       dwWidth;
    DWORD       dwBpp;
    DWORD       dwRefreshRate;

    BOOL        bSupported;

} DD_STEREOMODE;

typedef struct _DD_UPDATENONLOCALHEAPDATA
{
    PDD_DIRECTDRAW_GLOBAL      lpDD;                // driver struct
    DWORD                      dwHeap;              // heap index
    FLATPTR                    fpGARTLin;           // linear GART address of start of heap
    FLATPTR                    fpGARTDev;           // high physical GART address of start of heap
    ULONG_PTR                  ulPolicyMaxBytes;    // maximum amount of AGP memory to use
    HRESULT                    ddRVal;              // return value
    VOID*                      UpdateNonLocalHeap;  // Unused: Win95 compatibility
} DD_UPDATENONLOCALHEAPDATA;

/*
 * Private caps that the driver passes to change DirectDraw behavior.
 * These caps are not exposed to the application
 */

typedef struct DD_NTPRIVATEDRIVERCAPS
{
    DWORD                               dwSize;
    DWORD                               dwPrivateCaps;
} DD_NTPRIVATEDRIVERCAPS;

// Driver wants DD_CREATESURFACEDATA.lplpSList to contain a list of
// surfaces to create rather than always a single surface.
#define DDHAL_PRIVATECAP_ATOMICSURFACECREATION 0x00000001l

// Driver wants to be notified when creating a primary surface.
#define DDHAL_PRIVATECAP_NOTIFYPRIMARYCREATION  0x00000002l

#define DDHAL_PRIVATECAP_RESERVED1              0x00000004l

/////////////////////////////////////////////////////////////////////////////
// NT Note:
//
// The following structures must match, field for field, the corresponding
// structures as declared in 'ddrawi.h.'  We cannot simply use the same
// structures because the sub-structures such as DD_DIRECTDRAW_GLOBAL are
// different, and have to be properly typed for the drivers.
//
/////////////////////////////////////////////////////////////////////////////

/****************************************************************************
 *
 * DDHAL structures for Surface Object callbacks
 *
 ***************************************************************************/

/*
 * This special flag is seen only by drivers.  The DD runtime sets this
 * bit in DDHAL_BLTDATA.dwFlags if the dwAFlags and ddrgbaScaleFactors
 * members at the end of the DDHAL_BLTDATA structure are valid.
 * The flag is always set if the DDHAL_BLTDATA structure is passed to
 * the driver via the AlphaBlt HAL callback; otherwise, the flag is zero.
 */
#define DDBLT_AFLAGS 		0x80000000L

/*
 * This flag will be set in DDHAL_BLTDATA.dwAFlags if the call was originated
 * by the AlphaBlt API method. If the call was originated by the Blt API,
 * this flag will not be set.
 * Drivers which have a unified Blt/AlphaBlt DDI can use this flag to distinguish
 * between the two API calls.
 */
#define DDABLT_SRCOVERDEST      0x00000001L

/*
 * structure for passing information to DDHAL Blt fn
 */
typedef struct _DD_BLTDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDDestSurface;// dest surface
    RECTL                       rDest;          // dest rect
    PDD_SURFACE_LOCAL           lpDDSrcSurface; // src surface
    RECTL                       rSrc;           // src rect
    DWORD                       dwFlags;        // blt flags
    DWORD                       dwROPFlags;     // ROP flags (valid for ROPS only)
    DDBLTFX                     bltFX;          // blt FX
    HRESULT                     ddRVal;         // return value
    VOID*                       Blt;            // Unused: Win95 compatibility
    BOOL                        IsClipped;      // clipped blt?
    RECTL                       rOrigDest;      // unclipped dest rect
                                                // (only valid if IsClipped)
    RECTL                       rOrigSrc;       // unclipped src rect
                                                // (only valid if IsClipped)
    DWORD                       dwRectCnt;      // count of dest rects
                                                // (only valid if IsClipped)
    LPRECT                      prDestRects;    // array of dest rects
                                                // (only valid if IsClipped)
    DWORD                       dwAFlags;       // DDABLT_ flags (for AlphaBlt DDI)
    DDARGB                      ddargbScaleFactors;  // ARGB scaling factors (AlphaBlt)
} DD_BLTDATA;

/*
 * structure for passing information to DDHAL Lock fn
 */
typedef struct _DD_LOCKDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    DWORD                       bHasRect;       // rArea is valid
    RECTL                       rArea;          // area being locked
    LPVOID                      lpSurfData;     // pointer to screen memory (return value)
    HRESULT                     ddRVal;         // return value
    VOID*                       Lock;           // Unused: Win95 compatibility
    DWORD                       dwFlags;        // DDLOCK flags
    FLATPTR                     fpProcess;      // process start address
} DD_LOCKDATA;

/*
 * structure for passing information to DDHAL Unlock fn
 */
typedef struct _DD_UNLOCKDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    HRESULT                     ddRVal;         // return value
    VOID*                       Unlock;         // Unused: Win95 compatibility
} DD_UNLOCKDATA;

/*
 * structure for passing information to DDHAL UpdateOverlay fn
 */
typedef struct _DD_UPDATEOVERLAYDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDDestSurface;// dest surface
    RECTL                       rDest;          // dest rect
    PDD_SURFACE_LOCAL           lpDDSrcSurface; // src surface
    RECTL                       rSrc;           // src rect
    DWORD                       dwFlags;        // flags
    DDOVERLAYFX                 overlayFX;      // overlay FX
    HRESULT                     ddRVal;         // return value
    VOID*                       UpdateOverlay;  // Unused: Win95 compatibility
} DD_UPDATEOVERLAYDATA;

/*
 * structure for passing information to DDHAL UpdateOverlay fn
 */
typedef struct _DD_SETOVERLAYPOSITIONDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSrcSurface; // src surface
    PDD_SURFACE_LOCAL           lpDDDestSurface;// dest surface
    LONG                        lXPos;          // x position
    LONG                        lYPos;          // y position
    HRESULT                     ddRVal;         // return value
    VOID*                       SetOverlayPosition; // Unused: Win95 compatibility
} DD_SETOVERLAYPOSITIONDATA;
/*
 * structure for passing information to DDHAL SetPalette fn
 */
typedef struct _DD_SETPALETTEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    PDD_PALETTE_GLOBAL          lpDDPalette;    // palette to set to surface
    HRESULT                     ddRVal;         // return value
    VOID*                       SetPalette;     // Unused: Win95 compatibility
    BOOL                        Attach;         // attach this palette?
} DD_SETPALETTEDATA;

/*
 * structure for passing information to DDHAL Flip fn
 */
typedef struct _DD_FLIPDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpSurfCurr;     // current surface
    PDD_SURFACE_LOCAL           lpSurfTarg;     // target surface (to flip to)
    DWORD                       dwFlags;        // flags
    HRESULT                     ddRVal;         // return value
    VOID*                       Flip;           // Unused: Win95 compatibility
    PDD_SURFACE_LOCAL           lpSurfCurrLeft;     // left target surface (to flip to)
    PDD_SURFACE_LOCAL           lpSurfTargLeft;     // left target surface (to flip to)
} DD_FLIPDATA;

/*
 * structure for passing information to DDHAL DestroySurface fn
 */
typedef struct _DD_DESTROYSURFACEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    HRESULT                     ddRVal;         // return value
    VOID*                       DestroySurface;// Unused: Win95 compatibility
} DD_DESTROYSURFACEDATA;

/*
 * structure for passing information to DDHAL SetClipList fn
 */
typedef struct _DD_SETCLIPLISTDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    HRESULT                     ddRVal;         // return value
    VOID*                       SetClipList;    // Unused: Win95 compatibility
} DD_SETCLIPLISTDATA;

/*
 * structure for passing information to DDHAL AddAttachedSurface fn
 */
typedef struct _DD_ADDATTACHEDSURFACEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    PDD_SURFACE_LOCAL           lpSurfAttached; // surface to attach
    HRESULT                     ddRVal;         // return value
    VOID*                       AddAttachedSurface; // Unused: Win95 compatibility
} DD_ADDATTACHEDSURFACEDATA;

/*
 * structure for passing information to DDHAL SetColorKey fn
 */
typedef struct _DD_SETCOLORKEYDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    DWORD                       dwFlags;        // flags
    DDCOLORKEY                  ckNew;          // new color key
    HRESULT                     ddRVal;         // return value
    VOID*                       SetColorKey;    // Unused: Win95 compatibility
} DD_SETCOLORKEYDATA;

/*
 * structure for passing information to DDHAL GetBltStatus fn
 */
typedef struct _DD_GETBLTSTATUSDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    DWORD                       dwFlags;        // flags
    HRESULT                     ddRVal;         // return value
    VOID*                       GetBltStatus;   // Unused: Win95 compatibility
} DD_GETBLTSTATUSDATA;

/*
 * structure for passing information to DDHAL GetFlipStatus fn
 */
typedef struct _DD_GETFLIPSTATUSDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    DWORD                       dwFlags;        // flags
    HRESULT                     ddRVal;         // return value
    VOID*                       GetFlipStatus;  // Unused: Win95 compatibility
} DD_GETFLIPSTATUSDATA;

/****************************************************************************
 *
 * DDHAL structures for Palette Object callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL DestroyPalette fn
 */
typedef struct _DD_DESTROYPALETTEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_PALETTE_GLOBAL          lpDDPalette;    // palette struct
    HRESULT                     ddRVal;         // return value
    VOID*                       DestroyPalette; // Unused: Win95 compatibility
} DD_DESTROYPALETTEDATA;

/*
 * structure for passing information to DDHAL SetEntries fn
 */
typedef struct _DD_SETENTRIESDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_PALETTE_GLOBAL          lpDDPalette;    // palette struct
    DWORD                       dwBase;         // base palette index
    DWORD                       dwNumEntries;   // number of palette entries
    LPPALETTEENTRY              lpEntries;      // color table
    HRESULT                     ddRVal;         // return value
    VOID*                       SetEntries;     // Unused: Win95 compatibility
} DD_SETENTRIESDATA;

/****************************************************************************
 *
 * DDHAL structures for Driver Object callbacks
 *
 ***************************************************************************/

typedef DDSURFACEDESC* PDD_SURFACEDESC;

/*
 * structure for passing information to DDHAL CreateSurface fn
 */
typedef struct _DD_CREATESURFACEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACEDESC             lpDDSurfaceDesc;// description of surface being created
    PDD_SURFACE_LOCAL           *lplpSList;     // list of created surface objects
    DWORD                       dwSCnt;         // number of surfaces in SList
    HRESULT                     ddRVal;         // return value
    VOID*                       CreateSurface;  // Unused: Win95 compatibility
} DD_CREATESURFACEDATA;

/*
 * structure for passing information to DDHAL CanCreateSurface fn
 */
typedef struct _DD_CANCREATESURFACEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;                   // driver struct
    PDD_SURFACEDESC             lpDDSurfaceDesc;        // description of surface being created
    DWORD                       bIsDifferentPixelFormat;// pixel format differs from primary surface
    HRESULT                     ddRVal;                 // return value
    VOID*                       CanCreateSurface;       // Unused: Win95 compatibility
} DD_CANCREATESURFACEDATA;

/*
 * structure for passing information to DDHAL CreatePalette fn
 */
typedef struct _DD_CREATEPALETTEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_PALETTE_GLOBAL          lpDDPalette;    // ddraw palette struct
    LPPALETTEENTRY              lpColorTable;   // colors to go in palette
    HRESULT                     ddRVal;         // return value
    VOID*                       CreatePalette;  // Unused: Win95 compatibility
    BOOL                        is_excl;        // process has exclusive mode
} DD_CREATEPALETTEDATA;

/*
 * Return if the vertical blank is in progress
 */
#define DDWAITVB_I_TESTVB                       0x80000006l

/*
 * structure for passing information to DDHAL WaitForVerticalBlank fn
 */
typedef struct _DD_WAITFORVERTICALBLANKDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    DWORD                       dwFlags;        // flags
    DWORD                       bIsInVB;        // is in vertical blank
    DWORD                       hEvent;         // event
    HRESULT                     ddRVal;         // return value
    VOID*                       WaitForVerticalBlank; // Unused: Win95 compatibility
} DD_WAITFORVERTICALBLANKDATA;

/*
 * structure for passing information to DDHAL driver SetColorKey fn
 */
typedef struct _DD_DRVSETCOLORKEYDATA
{
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface struct
    DWORD                       dwFlags;        // flags
    DDCOLORKEY                  ckNew;          // new color key
    HRESULT                     ddRVal;         // return value
    VOID*                       SetColorKey;    // Unused: Win95 compatibility
} DD_DRVSETCOLORKEYDATA;

/*
 * structure for passing information to DDHAL GetScanLine fn
 */
typedef struct _DD_GETSCANLINEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    DWORD                       dwScanLine;     // returned scan line
    HRESULT                     ddRVal;         // return value
    VOID*                       GetScanLine;    // Unused: Win95 compatibility
} DD_GETSCANLINEDATA;

/*
 * structure for passing information to DDHAL MapMemory fn
 */
typedef struct _DD_MAPMEMORYDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    BOOL                        bMap;           // TRUE if map; FALSe if un-map
    HANDLE                      hProcess;       // process handle
    FLATPTR                     fpProcess;      // returned address in process' address space
    HRESULT                     ddRVal;         // return value
} DD_MAPMEMORYDATA;

/****************************************************************************
 *
 * DDHAL structures for VideoPort callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL CanCreateVideoPort fn
 */
typedef struct _DD_CANCREATEVPORTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;               // driver struct
    LPDDVIDEOPORTDESC           lpDDVideoPortDesc;
    HRESULT                     ddRVal;             // return value
    VOID*                       CanCreateVideoPort; // Unused: Win95 compatibility
} DD_CANCREATEVPORTDATA;

/*
 * structure for passing information to DDHAL CreateVideoPort fn
 */
typedef struct _DD_CREATEVPORTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;              // driver struct
    LPDDVIDEOPORTDESC           lpDDVideoPortDesc;
    PDD_VIDEOPORT_LOCAL         lpVideoPort;       // Video port created
    HRESULT                     ddRVal;            // return value
    VOID*                       CreateVideoPort;   // Unused: Win95 compatibility
} DD_CREATEVPORTDATA;

/*
 * structure for passing information to DDHAL FlipVideoPort fn
 */
typedef struct _DD_FLIPVPORTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;          // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;   // Video port object
    PDD_SURFACE_LOCAL           lpSurfCurr;    // current surface
    PDD_SURFACE_LOCAL           lpSurfTarg;    // target surface
    HRESULT                     ddRVal;        // return value
    VOID*                       FlipVideoPort; // Unused: Win95 compatibility
} DD_FLIPVPORTDATA;

/*
 * structure for passing information to DDHAL GetVideoPortBandwidth fn
 */
typedef struct _DD_GETVPORTBANDWIDTHDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                  // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;           // Video port object
    LPDDPIXELFORMAT             lpddpfFormat;          // Format for bandwidth
    DWORD                       dwWidth;
    DWORD                       dwHeight;
    DWORD                       dwFlags;               // Prescale factor for bandwidth
    LPDDVIDEOPORTBANDWIDTH      lpBandwidth;           // Returned bandwidth parameters
    HRESULT                     ddRVal;                // return value
    VOID*                       GetVideoPortBandwidth; // Unused: Win95 compatibility
} DD_GETVPORTBANDWIDTHDATA;

/*
 * structure for passing information to DDHAL GetVideoPortInputFormats fn
 */
typedef struct _DD_GETVPORTINPUTFORMATDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                     // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;              // Video port object
    DWORD                       dwFlags;                  // VBI, regular, or both
    LPDDPIXELFORMAT             lpddpfFormat;             // Array of formats
    DWORD                       dwNumFormats;             // # of formats in array
    HRESULT                     ddRVal;                   // return value
    VOID*                       GetVideoPortInputFormats; // Unused: Win95 compatibility
} DD_GETVPORTINPUTFORMATDATA;

/*
 * structure for passing information to DDHAL GetVideoPortOutputFormats fn
 */
typedef struct _DD_GETVPORTOUTPUTFORMATDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                     // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;              // Video port object
    DWORD                       dwFlags;                  // VBI, regular, or both
    LPDDPIXELFORMAT             lpddpfInputFormat;        // Input format
    LPDDPIXELFORMAT             lpddpfOutputFormats;      // Array of output formats
    DWORD                       dwNumFormats;             // # of formats in array
    HRESULT                     ddRVal;                   // return value
    VOID*                       GetVideoPortInputFormats; // Unused: Win95 compatibility
} DD_GETVPORTOUTPUTFORMATDATA;

/*
 * structure for passing information to DDHAL GetVideoPortField fn
 */
typedef struct _DD_GETVPORTFIELDDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;              // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;       // Video port object
    BOOL                        bField;            // TRUE if even
    HRESULT                     ddRVal;            // return value
    VOID*                       GetVideoPortField; // Unused: Win95 compatibility
} DD_GETVPORTFIELDDATA;

/*
 * structure for passing information to DDHAL GetVideoPortLine fn
 */
typedef struct _DD_GETVPORTLINEDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;             // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;      // Video port object
    DWORD                       dwLine;           // Current line counter
    HRESULT                     ddRVal;           // return value
    VOID*                       GetVideoPortLine; // Unused: Win95 compatibility
} DD_GETVPORTLINEDATA;

/*
 * structure for passing information to DDHAL GetVideoPortConnectInfo fn
 */
typedef struct _DD_GETVPORTCONNECTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                    // driver struct
    DWORD                       dwPortId;                // ID of desired video port
    LPDDVIDEOPORTCONNECT        lpConnect;               // Array of DDVIDEOPORTCONNECT structures
    DWORD                       dwNumEntries;            // # of structures in array
    HRESULT                     ddRVal;                  // return value
    VOID*                       GetVideoPortConnectInfo; // Unused: Win95 compatibility
} DD_GETVPORTCONNECTDATA;

/*
 * structure for passing information to DDHAL DestroyVideoPort fn
 */
typedef struct _DD_DESTROYVPORTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;             // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;      // Video port object
    HRESULT                     ddRVal;           // return value
    VOID*                       DestroyVideoPort; // Unused: Win95 compatibility
} DD_DESTROYVPORTDATA;

/*
 * structure for passing information to DDHAL GetVideoPortFlipStatus fn
 */
typedef struct _DD_GETVPORTFLIPSTATUSDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                   // driver struct
    FLATPTR                     fpSurface;              // surface struct
    HRESULT                     ddRVal;                 // return value
    VOID*                       GetVideoPortFlipStatus; // Unused: Win95 compatibility
} DD_GETVPORTFLIPSTATUSDATA;

typedef DDVIDEOPORTINFO*   PDD_VIDEOPORTINFO;
/*
 * structure for passing information to DDHAL UpdateVideoPort fn
 */
typedef struct _DD_UPDATEVPORTDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;             // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;      // Video port object
    PDD_SURFACE_INT            *lplpDDSurface;    // surface struct
    PDD_SURFACE_INT            *lplpDDVBISurface; // VBI surface structure
    PDD_VIDEOPORTINFO           lpVideoInfo;      // Video information
    DWORD                       dwFlags;          // DDRAWI_VPORTSTART, DDRAWI_VPORTSTOP, DDRAWI_VPORTUPDATE
    DWORD                       dwNumAutoflip;    // # of autoflip surfaces. If > 1, lpDDSurface is an array.
    DWORD                       dwNumVBIAutoflip; // # of autoflip surfaces. If > 1, lpDDVBISurface is an array.
    HRESULT                     ddRVal;           // return value
    VOID*                       UpdateVideoPort;  // Unused: Win95 compatibility
} DD_UPDATEVPORTDATA;

#define DDRAWI_VPORTSTART       0x0001
#define DDRAWI_VPORTSTOP        0x0002
#define DDRAWI_VPORTUPDATE      0x0003

/*
 * structure for passing information to DDHAL WaitForVideoPortSync fn
 */
typedef struct _DD_WAITFORVPORTSYNCDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;            // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;     // Video port object
    DWORD                       dwFlags;         // DDVPEVENT_XXXX
    DWORD                       dwLine;
    DWORD                       dwTimeOut;       // Max time to wait before returning
    HRESULT                     ddRVal;          // return value
    VOID*                       UpdateVideoPort; // Unused: Win95 compatibility
} DD_WAITFORVPORTSYNCDATA;

/*
 * structure for passing information to DDHAL GetVideoSignalStatus fn
 */
typedef struct _DD_GETVPORTSIGNALDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;                 // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;          // Video port object
    DWORD                       dwStatus;             // Video signal status
    HRESULT                     ddRVal;               // return value
    VOID*                       GetVideoSignalStatus; // Unused: Win95 compatibility
} DD_GETVPORTSIGNALDATA;

/*
 * structure for passing information to DDHAL GetVideoSignalStatus fn
 */
typedef struct _DD_VPORTCOLORDATA
{
    PDD_DIRECTDRAW_LOCAL        lpDD;         // driver struct
    PDD_VIDEOPORT_LOCAL         lpVideoPort;  // Video port object
    DWORD                       dwFlags;      // Video signal status
    LPDDCOLORCONTROL            lpColorData;
    HRESULT                     ddRVal;       // return value
    VOID*                       ColorControl; // Unused: Win95 compatibility
} DD_VPORTCOLORDATA;

#define DDRAWI_VPORTGETCOLOR    0x0001
#define DDRAWI_VPORTSETCOLOR    0x0002

/****************************************************************************
 *
 * DDHAL structures for Color Control callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL ColorControl fn
 */
typedef struct _DD_COLORCONTROLDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;    // surface
    LPDDCOLORCONTROL            lpColorData;    // color control information
    DWORD                       dwFlags;        // DDRAWI_GETCOLOR/DDRAWI_SETCOLOR
    HRESULT                     ddRVal;         // return value
    VOID*                       ColorControl;   // Unused: Win95 compatibility
} DD_COLORCONTROLDATA;

#define DDRAWI_GETCOLOR         0x0001
#define DDRAWI_SETCOLOR         0x0002

/****************************************************************************
 *
 * DDHAL structure for GetDriverData callback
 *
 ***************************************************************************/

typedef struct _DD_GETDRIVERINFODATA {

    // Input fields filled in by DirectDraw

    VOID*                       dhpdev;         // Driver context
    DWORD                       dwSize;         // Size of this structure
    DWORD                       dwFlags;        // Flags
    GUID                        guidInfo;       // GUID that DirectX is querying for
    DWORD                       dwExpectedSize; // Size of callbacks structure expected by DirectDraw.
    PVOID                       lpvData;        // Buffer that will receive the requested data

    // Output fields filled in by driver

    DWORD                       dwActualSize;   // Size of callbacks structure expected by driver
    HRESULT                     ddRVal;         // Return value from driver

} DD_GETDRIVERINFODATA;

/****************************************************************************
 *
 * DDHAL structure for misc. driver callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL GetAvailDriverMemory fn
 */
typedef struct _DD_GETAVAILDRIVERMEMORYDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;            // driver struct
    DDSCAPS                     DDSCaps;         // caps for type of surface memory
    DWORD                       dwTotal;         // total memory for this kind of surface
    DWORD                       dwFree;          // free memory for this kind of surface
    HRESULT                     ddRVal;          // return value
    VOID*                       GetAvailDriverMemory; // Unused: Win95 compatibility
} DD_GETAVAILDRIVERMEMORYDATA;


/****************************************************************************
 *
 * DDHAL structures for NT callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL FreeDriverMemory fn
 */
typedef struct _DD_FREEDRIVERMEMORYDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;            // driver struct
    PDD_SURFACE_LOCAL           lpDDSurface;     // surface object trying to be created
    HRESULT                     ddRVal;          // return value
    VOID*                       FreeDriverMemory;// Unused: Win95 compatibility
} DD_FREEDRIVERMEMORYDATA;

/*
 * structure for passing information to DDHAL SetExclusiveMode fn
 */
typedef struct _DD_SETEXCLUSIVEMODEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    DWORD                       dwEnterExcl;    // TRUE if entering exclusive mode, FALSE is leaving
    DWORD                       dwReserved;     // reserved for future use
    HRESULT                     ddRVal;         // return value
    VOID*                       SetExclusiveMode; // Unused: Win95 compatibility
} DD_SETEXCLUSIVEMODEDATA;

/*
 * structure for passing information to DDHAL FlipToGDISurface fn
 */
typedef struct _DD_FLIPTOGDISURFACEDATA
{
    PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
    DWORD                       dwToGDI;        // TRUE if flipping to the GDI surface, FALSE if flipping away
    DWORD                       dwReserved;     // reserved for future use
    HRESULT                     ddRVal;         // return value
    VOID*                       FlipToGDISurface; // Unused: Win95 compatibility
} DD_FLIPTOGDISURFACEDATA;

/****************************************************************************
 *
 * DDHAL structure for kernel callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL SyncSurfaceData fn
 */
typedef struct _DD_SYNCSURFACEDATA
{
    PDD_DIRECTDRAW_LOCAL   lpDD;        // driver struct
    PDD_SURFACE_LOCAL      lpDDSurface; // Surface to sync with
    DWORD       dwSurfaceOffset;        // Offset in frame buffer of surface
    ULONG_PTR    fpLockPtr;              // Surface lock ptr
    LONG        lPitch;                 // Surface pitch
    DWORD       dwOverlayOffset;        // Added to dwSurfaceOffset for origin, clipping, etc.
    ULONG       dwDriverReserved1;      // Reserved for the HAL
    ULONG       dwDriverReserved2;      // Reserved for the HAL
    ULONG       dwDriverReserved3;      // Reserved for the HAL
    ULONG       dwDriverReserved4;      // Reserved for the HAL
    HRESULT     ddRVal;
} DD_SYNCSURFACEDATA;

/*
 * structure for passing information to DDHAL SyncVideoPortData fn
 */
typedef struct _DD_SYNCVIDEOPORTDATA
{
    PDD_DIRECTDRAW_LOCAL    lpDD;       // driver struct
    PDD_VIDEOPORT_LOCAL     lpVideoPort;// Video port object
    DWORD       dwOriginOffset;         // Start address relative to surface
    DWORD       dwHeight;               // Height of total video region (per field)
    DWORD       dwVBIHeight;            // Height of VBI region (per field)
    ULONG       dwDriverReserved1;      // Reserved for the HAL
    ULONG       dwDriverReserved2;      // Reserved for the HAL
    ULONG       dwDriverReserved3;      // Reserved for the HAL
    HRESULT     ddRVal;
} DD_SYNCVIDEOPORTDATA;

/****************************************************************************
 *
 * DDHAL structure for motion comp callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL GetMoCompGuids
 */
typedef struct _DD_GETMOCOMPGUIDSDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    DWORD                     dwNumGuids;
    GUID*                     lpGuids;
    HRESULT                   ddRVal;
} DD_GETMOCOMPGUIDSDATA;

/*
 * structure for passing information to DDHAL GetMoCompFormats
 */
typedef struct _DD_GETMOCOMPFORMATSDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    GUID*                     lpGuid;
    DWORD                     dwNumFormats;
    LPDDPIXELFORMAT           lpFormats;
    HRESULT                   ddRVal;
} DD_GETMOCOMPFORMATSDATA;

/*
 * structure for passing information to DDHAL CreateMoComp
 */
typedef struct _DD_CREATEMOCOMPDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    GUID*                     lpGuid;
    DWORD                     dwUncompWidth;
    DWORD                     dwUncompHeight;
    DDPIXELFORMAT             ddUncompPixelFormat;
    LPVOID                    lpData;
    DWORD                     dwDataSize;
    HRESULT                   ddRVal;
} DD_CREATEMOCOMPDATA;

/*
 * structure for passing information to DDHAL GetMoCompBuffInfo
 */
typedef struct _DDCOMPBUFFERINFO
{
    DWORD                     dwSize;             // [in]   size of the struct
    DWORD                     dwNumCompBuffers;   // [out]  number of buffers required for compressed data
    DWORD                     dwWidthToCreate;    // [out]    Width of surface to create
    DWORD                     dwHeightToCreate;   // [out]    Height of surface to create
    DWORD                     dwBytesToAllocate;  // [out]    Total number of bytes used by each surface
    DDSCAPS2                  ddCompCaps;         // [out]    caps to create surfaces to store compressed data
    DDPIXELFORMAT             ddPixelFormat;      // [out]  format to create surfaces to store compressed data
} DDCOMPBUFFERINFO, *LPDDCOMPBUFFERINFO;

typedef struct _DD_GETMOCOMPCOMPBUFFDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    GUID*                     lpGuid;
    DWORD                     dwWidth;            // [in]   width of uncompressed data
    DWORD                     dwHeight;           // [in]   height of uncompressed data
    DDPIXELFORMAT             ddPixelFormat;      // [in]   pixel-format of uncompressed data
    DWORD                     dwNumTypesCompBuffs;// [in/out] number of memory types required for comp buffers
    LPDDCOMPBUFFERINFO        lpCompBuffInfo;     // [in]   driver supplied info regarding comp buffers (allocated by client)
    HRESULT                   ddRVal;             // [out]
} DD_GETMOCOMPCOMPBUFFDATA;

/*
 * structure for passing information to DDHAL GetMoCompBuffInfo
 */
typedef struct _DD_GETINTERNALMOCOMPDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    GUID*                     lpGuid;
    DWORD                     dwWidth;            // [in]   width of uncompressed data
    DWORD                     dwHeight;           // [in]   height of uncompressed data
    DDPIXELFORMAT             ddPixelFormat;      // [in]   pixel-format of uncompressed data
    DWORD                     dwScratchMemAlloc;  // [out]  amount of scratch memory will the hal allocate for its private use
    HRESULT                   ddRVal;             // [out]
} DD_GETINTERNALMOCOMPDATA;

/*
 * structure for passing information to DDHAL BeginMoCompFrame
 */
typedef struct _DD_BEGINMOCOMPFRAMEDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    PDD_SURFACE_LOCAL         lpDestSurface;        // [in]  destination buffer in which to decoding this frame
    DWORD                     dwInputDataSize;      // [in]  size of other misc input data to begin frame
    LPVOID                    lpInputData;          // [in]  pointer to misc input data
    DWORD                     dwOutputDataSize;     // [in]  size of other misc output data to begin frame
    LPVOID                    lpOutputData;         // [in]  pointer to output misc data (allocated by client)
    HRESULT                   ddRVal;               // [out]
} DD_BEGINMOCOMPFRAMEDATA;

/*
 * structure for passing information to DDHAL EndMoCompFrame
 */
typedef struct _DD_ENDMOCOMPFRAMEDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    LPVOID                    lpInputData;
    DWORD                     dwInputDataSize;
    HRESULT                   ddRVal;
} DD_ENDMOCOMPFRAMEDATA;

/*
 * structure for passing information to DDHAL RenderMoComp
 */
typedef struct _DDMOCOMPBUFFERINFO
{
    DWORD                     dwSize;         // [in]    size of the struct
    PDD_SURFACE_LOCAL         lpCompSurface;  // [in]    pointer to buffer containing compressed data
    DWORD                     dwDataOffset;   // [in]    offset of relevant data from the beginning of buffer
    DWORD                     dwDataSize;     // [in]    size of relevant data
    LPVOID                    lpPrivate;      // Reserved by DirectDraw
} DDMOCOMPBUFFERINFO, *LPDDMOCOMPBUFFERINFO;

typedef struct _DD_RENDERMOCOMPDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    DWORD                     dwNumBuffers;     // [in]  Number of entries in the lpMacroBlockInfo array
    LPDDMOCOMPBUFFERINFO      lpBufferInfo;     // [in]  Surfaces containing macro block info
    DWORD                     dwFunction;       // [in]  Function
    LPVOID                    lpInputData;
    DWORD                     dwInputDataSize;
    LPVOID                    lpOutputData;
    DWORD                     dwOutputDataSize;
    HRESULT                   ddRVal;           // [out]
} DD_RENDERMOCOMPDATA;

/*
 * structure for passing information to DDHAL QueryMoCompStatus
 */
typedef struct _DD_QUERYMOCOMPSTATUSDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    PDD_SURFACE_LOCAL         lpSurface;        // [in]  Surface being queried
    DWORD                     dwFlags;          // [in]  DDMCQUERY_XXX flags
    HRESULT                   ddRVal;            // [out]
} DD_QUERYMOCOMPSTATUSDATA;

#define DDMCQUERY_READ          0x00000001

/*
 * structure for passing information to DDHAL DestroyVideo
 */
typedef struct _DD_DESTROYMOCOMPDATA
{
    PDD_DIRECTDRAW_LOCAL      lpDD;
    PDD_MOTIONCOMP_LOCAL      lpMoComp;
    HRESULT                   ddRVal;
} DD_DESTROYMOCOMPDATA;


/****************************************************************************
 *
 * DDHAL structures for Miscellaneous2 callbacks
 *
 ***************************************************************************/
// This DDI is called by the kernel only.
typedef struct _DD_CREATESURFACEEXDATA
{
    DWORD                       dwFlags;
    PDD_DIRECTDRAW_LOCAL        lpDDLcl;        // driver struct
    PDD_SURFACE_LOCAL           lpDDSLcl;       // created surface
                                                // objects
    HRESULT                     ddRVal;         // return value
} DD_CREATESURFACEEXDATA;

// This DDI is used by both ddraw and d3d to obtain information from
// the driver.
typedef struct _DD_GETDRIVERSTATEDATA
{
    DWORD                       dwFlags;        // Flags to indicate the data
                                                // required
    union
    {
        PDD_DIRECTDRAW_GLOBAL       lpDD;           // driver struct
        DWORD_PTR                   dwhContext;     // d3d context
    };
    LPDWORD                     lpdwStates;     // ptr to the state data
                                                // to be filled in by the
                                                // driver
    DWORD                       dwLength;
    HRESULT                     ddRVal;         // return value
} DD_GETDRIVERSTATEDATA;

typedef struct _DD_DESTROYDDLOCALDATA
{
    DWORD dwFlags;
    PDD_DIRECTDRAW_LOCAL pDDLcl;
    HRESULT  ddRVal;
} DD_DESTROYDDLOCALDATA;


#ifdef __cplusplus
};
#endif

#endif  // GUID_DEFS_ONLY

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\oak\inc\dx95type.h ===
/******************************Module*Header*******************************\
*
* Module Name: dx95type.h
*
* Portability module for NT kernel-mode DirectX components created from
* Win95 sources
*
* Copyright (c) Microsoft Corp. All Rights Reserved.
*
\**************************************************************************/

#ifndef __DX95TYPE_H__
#define __DX95TYPE_H__

// Basic includes
#ifndef NODXINCLUDES
#ifdef WINNT
#include <stddef.h>
// Includes ddrawint.h and d3dnthal.h
#include <winddi.h>
#else // WINNT
#include <ddrawi.h>
#include <d3dhal.h>
#endif // WINNT
#endif // NODXINCLUDES

// Simple memory allocation of N bytes
#ifndef NODXMALLOC
#ifdef WINNT
#define DXMALLOC(n) EngAllocMem(0, n, 'amxD')
#define DXMALLOCZ(n) EngAllocMem(FL_ZERO_MEMORY, n, 'amxD')
#define DXFREE(p) EngFreeMem(p)
#else // WINNT
#define DXMALLOC(n) HeapAlloc(GetProcessHeap(), 0, n)
#define DXMALLOCZ(n) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, n)
#define DXFREE(n) HeapFree(GetProcessHeap(), 0, n)
#endif // WINNT
#endif // NODXMALLOC

// Surface and palette access macros
#ifndef NODXLCL
#ifdef WINNT
#define DDS_LCL(pdds) (pdds)
#define DDP_LCL(pddp) (pddp)
#else // WINNT
#define DDS_LCL(pdds) (((DDRAWI_DDRAWSURFACE_INT *)(pdds))->lpLcl)
#define DDP_LCL(pddp) (((DDRAWI_DDRAWPALETTE_INT *)(pddp))->lpLcl)
#endif // WINNT
#define DDS_LCL_OR_NULL(pdds) ((pdds) == NULL ? NULL : DDS_LCL(pdds))
#define DDP_LCL_OR_NULL(pddp) ((pddp) == NULL ? NULL : DDP_LCL(pddp))
#endif // NODXLCL

// Typedefs and defines to create a Win95-like compilation environment

#ifndef NODX95TYPES
#ifdef WINNT

typedef D3DNTHALDEVICEDESC_V1           D3DDEVICEDESC_V1;
typedef PDD_SURFACE_LOCAL               LPDDRAWI_DDRAWSURFACE_LCL;
typedef PDD_SURFACE_MORE                LPDDRAWI_DDRAWSURFACE_MORE;
typedef PDD_SURFACE_GLOBAL              LPDDRAWI_DDRAWSURFACE_GBL;
typedef PDD_DIRECTDRAW_GLOBAL           LPDDRAWI_DIRECTDRAW_GBL;
typedef PDD_ATTACHLIST                  LPATTACHLIST;

typedef DDNTCORECAPS                    DDCORECAPS;
typedef PDDNTCORECAPS                   LPDDCORECAPS;
typedef DD_HALINFO                      DDHALINFO;
typedef PDD_HALINFO                     LPDDHALINFO;
typedef DD_MORECAPS                     DDMORECAPS;
typedef PDD_MORECAPS                    LPDDMORECAPS;

// DirectDraw HAL function data structures

typedef PDD_CREATEPALETTEDATA           LPDDHAL_CREATEPALETTEDATA;
typedef PDD_CREATESURFACEDATA           LPDDHAL_CREATESURFACEDATA;
typedef PDD_CREATESURFACEEXDATA         LPDDHAL_CREATESURFACEEXDATA;
typedef PDD_CANCREATESURFACEDATA        LPDDHAL_CANCREATESURFACEDATA;
typedef PDD_WAITFORVERTICALBLANKDATA    LPDDHAL_WAITFORVERTICALBLANKDATA;
typedef PDD_DESTROYDRIVERDATA           LPDDHAL_DESTROYDRIVERDATA;
typedef PDD_SETMODEDATA                 LPDDHAL_SETMODEDATA;
typedef PDD_DRVSETCOLORKEYDATA          LPDDHAL_DRVSETCOLORKEYDATA;
typedef PDD_GETSCANLINEDATA             LPDDHAL_GETSCANLINEDATA;
typedef PDD_MAPMEMORYDATA               LPDDHAL_MAPMEMORYDATA;
typedef PDD_SETEXCLUSIVEMODEDATA        LPDDHAL_SETEXCLUSIVEMODEDATA;
typedef PDD_FLIPTOGDISURFACEDATA        LPDDHAL_FLIPTOGDISURFACEDATA;
typedef PDD_UPDATENONLOCALHEAPDATA      LPDDHAL_UPDATENONLOCALHEAPDATA;
typedef PDD_GETHEAPALIGNMENTDATA        LPDDHAL_GETHEAPALIGNMENTDATA;
typedef DD_CREATEPALETTEDATA            DDHAL_CREATEPALETTEDATA;
typedef DD_CREATESURFACEDATA            DDHAL_CREATESURFACEDATA;
typedef DD_CREATESURFACEEXDATA          DDHAL_CREATESURFACEEXDATA;
typedef DD_CANCREATESURFACEDATA         DDHAL_CANCREATESURFACEDATA;
typedef DD_WAITFORVERTICALBLANKDATA     DDHAL_WAITFORVERTICALBLANKDATA;
typedef DD_DRVSETCOLORKEYDATA           DDHAL_DRVSETCOLORKEYDATA;
typedef DD_GETSCANLINEDATA              DDHAL_GETSCANLINEDATA;
typedef DD_MAPMEMORYDATA                DDHAL_MAPMEMORYDATA;
typedef DD_SETEXCLUSIVEMODEDATA         DDHAL_SETEXCLUSIVEMODEDATA;
typedef DD_FLIPTOGDISURFACEDATA         DDHAL_FLIPTOGDISURFACEDATA;
typedef DD_UPDATENONLOCALHEAPDATA       DDHAL_UPDATENONLOCALHEAPDATA;

typedef PDD_DESTROYPALETTEDATA          LPDDHAL_DESTROYPALETTEDATA;
typedef PDD_SETENTRIESDATA              LPDDHAL_SETENTRIESDATA;
typedef DD_DESTROYPALETTEDATA           DDHAL_DESTROYPALETTEDATA;
typedef DD_SETENTRIESDATA               DDHAL_SETENTRIESDATA;

typedef PDD_BLTDATA                     LPDDHAL_BLTDATA;
typedef PDD_LOCKDATA                    LPDDHAL_LOCKDATA;
typedef PDD_UNLOCKDATA                  LPDDHAL_UNLOCKDATA;
typedef PDD_UPDATEOVERLAYDATA           LPDDHAL_UPDATEOVERLAYDATA;
typedef PDD_SETOVERLAYPOSITIONDATA      LPDDHAL_SETOVERLAYPOSITIONDATA;
typedef PDD_SETPALETTEDATA              LPDDHAL_SETPALETTEDATA;
typedef PDD_FLIPDATA                    LPDDHAL_FLIPDATA;
typedef PDD_DESTROYSURFACEDATA          LPDDHAL_DESTROYSURFACEDATA;
typedef PDD_SETCLIPLISTDATA             LPDDHAL_SETCLIPLISTDATA;
typedef PDD_ADDATTACHEDSURFACEDATA      LPDDHAL_ADDATTACHEDSURFACEDATA;
typedef PDD_SETCOLORKEYDATA             LPDDHAL_SETCOLORKEYDATA;
typedef PDD_GETBLTSTATUSDATA            LPDDHAL_GETBLTSTATUSDATA;
typedef PDD_GETFLIPSTATUSDATA           LPDDHAL_GETFLIPSTATUSDATA;
typedef PDD_GETAVAILDRIVERMEMORYDATA    LPDDHAL_GETAVAILDRIVERMEMORYDATA;
typedef PDD_GETDRIVERINFODATA           LPDDHAL_GETDRIVERINFODATA;
typedef PDD_GETDRIVERSTATEDATA          LPDDHAL_GETDRIVERSTATEDATA;
typedef PDD_DESTROYDDLOCALDATA          LPDDHAL_DESTROYDDLOCALDATA;
typedef DD_BLTDATA                      DDHAL_BLTDATA;
typedef DD_LOCKDATA                     DDHAL_LOCKDATA;
typedef DD_UNLOCKDATA                   DDHAL_UNLOCKDATA;
typedef DD_UPDATEOVERLAYDATA            DDHAL_UPDATEOVERLAYDATA;
typedef DD_SETOVERLAYPOSITIONDATA       DDHAL_SETOVERLAYPOSITIONDATA;
typedef DD_SETPALETTEDATA               DDHAL_SETPALETTEDATA;
typedef DD_FLIPDATA                     DDHAL_FLIPDATA;
typedef DD_DESTROYSURFACEDATA           DDHAL_DESTROYSURFACEDATA;
typedef DD_SETCLIPLISTDATA              DDHAL_SETCLIPLISTDATA;
typedef DD_ADDATTACHEDSURFACEDATA       DDHAL_ADDATTACHEDSURFACEDATA;
typedef DD_SETCOLORKEYDATA              DDHAL_SETCOLORKEYDATA;
typedef DD_GETBLTSTATUSDATA             DDHAL_GETBLTSTATUSDATA;
typedef DD_GETFLIPSTATUSDATA            DDHAL_GETFLIPSTATUSDATA;
typedef DD_GETAVAILDRIVERMEMORYDATA     DDHAL_GETAVAILDRIVERMEMORYDATA;
typedef DD_GETDRIVERINFODATA            DDHAL_GETDRIVERINFODATA;
typedef DD_GETDRIVERSTATEDATA           DDHAL_GETDRIVERSTATEDATA;
typedef DD_DESTROYDDLOCALDATA           DDHAL_DESTROYDDLOCALDATA;

typedef PDD_CANCREATEVPORTDATA          LPDDHAL_CANCREATEVPORTDATA;
typedef PDD_CREATEVPORTDATA             LPDDHAL_CREATEVPORTDATA;
typedef PDD_FLIPVPORTDATA               LPDDHAL_FLIPVPORTDATA;
typedef PDD_GETVPORTCONNECTDATA         LPDDHAL_GETVPORTCONNECTDATA;
typedef PDD_GETVPORTBANDWIDTHDATA       LPDDHAL_GETVPORTBANDWIDTHDATA;
typedef PDD_GETVPORTINPUTFORMATDATA     LPDDHAL_GETVPORTINPUTFORMATDATA;
typedef PDD_GETVPORTOUTPUTFORMATDATA    LPDDHAL_GETVPORTOUTPUTFORMATDATA;
typedef PDD_GETVPORTFIELDDATA           LPDDHAL_GETVPORTFIELDDATA;
typedef PDD_GETVPORTLINEDATA            LPDDHAL_GETVPORTLINEDATA;
typedef PDD_DESTROYVPORTDATA            LPDDHAL_DESTROYVPORTDATA;
typedef PDD_GETVPORTFLIPSTATUSDATA      LPDDHAL_GETVPORTFLIPSTATUSDATA;
typedef PDD_UPDATEVPORTDATA             LPDDHAL_UPDATEVPORTDATA;
typedef PDD_WAITFORVPORTSYNCDATA        LPDDHAL_WAITFORVPORTSYNCDATA;
typedef PDD_GETVPORTSIGNALDATA          LPDDHAL_GETVPORTSIGNALDATA;
typedef PDD_VPORTCOLORDATA              LPDDHAL_VPORTCOLORDATA;
typedef DD_CANCREATEVPORTDATA           DDHAL_CANCREATEVPORTDATA;
typedef DD_CREATEVPORTDATA              DDHAL_CREATEVPORTDATA;
typedef DD_FLIPVPORTDATA                DDHAL_FLIPVPORTDATA;
typedef DD_GETVPORTCONNECTDATA          DDHAL_GETVPORTCONNECTDATA;
typedef DD_GETVPORTBANDWIDTHDATA        DDHAL_GETVPORTBANDWIDTHDATA;
typedef DD_GETVPORTINPUTFORMATDATA      DDHAL_GETVPORTINPUTFORMATDATA;
typedef DD_GETVPORTOUTPUTFORMATDATA     DDHAL_GETVPORTOUTPUTFORMATDATA;
typedef DD_GETVPORTFIELDDATA            DDHAL_GETVPORTFIELDDATA;
typedef DD_GETVPORTLINEDATA             DDHAL_GETVPORTLINEDATA;
typedef DD_DESTROYVPORTDATA             DDHAL_DESTROYVPORTDATA;
typedef DD_GETVPORTFLIPSTATUSDATA       DDHAL_GETVPORTFLIPSTATUSDATA;
typedef DD_UPDATEVPORTDATA              DDHAL_UPDATEVPORTDATA;
typedef DD_WAITFORVPORTSYNCDATA         DDHAL_WAITFORVPORTSYNCDATA;
typedef DD_GETVPORTSIGNALDATA           DDHAL_GETVPORTSIGNALDATA;
typedef DD_VPORTCOLORDATA               DDHAL_VPORTCOLORDATA;

typedef PDD_COLORCONTROLDATA            LPDDHAL_COLORCONTROLDATA;
typedef DD_COLORCONTROLDATA             DDHAL_COLORCONTROLDATA;

typedef PDD_SYNCSURFACEDATA             LPDDHAL_SYNCSURFACEDATA;
typedef PDD_SYNCVIDEOPORTDATA           LPDDHAL_SYNCVIDEOPORTDATA;
typedef DD_SYNCSURFACEDATA              DDHAL_SYNCSURFACEDATA;
typedef DD_SYNCVIDEOPORTDATA            DDHAL_SYNCVIDEOPORTDATA;

typedef PDD_GETMOCOMPGUIDSDATA          LPDDHAL_GETMOCOMPGUIDSDATA;
typedef PDD_GETMOCOMPFORMATSDATA        LPDDHAL_GETMOCOMPFORMATSDATA;
typedef PDD_CREATEMOCOMPDATA            LPDDHAL_CREATEMOCOMPDATA;
typedef PDD_GETMOCOMPCOMPBUFFDATA       LPDDHAL_GETMOCOMPCOMPBUFFDATA;
typedef PDD_GETINTERNALMOCOMPDATA       LPDDHAL_GETINTERNALMOCOMPDATA;
typedef PDD_BEGINMOCOMPFRAMEDATA        LPDDHAL_BEGINMOCOMPFRAMEDATA;
typedef PDD_ENDMOCOMPFRAMEDATA          LPDDHAL_ENDMOCOMPFRAMEDATA;
typedef PDD_RENDERMOCOMPDATA            LPDDHAL_RENDERMOCOMPDATA;
typedef PDD_QUERYMOCOMPSTATUSDATA       LPDDHAL_QUERYMOCOMPSTATUSDATA;
typedef PDD_DESTROYMOCOMPDATA           LPDDHAL_DESTROYMOCOMPDATA;
typedef DD_GETMOCOMPGUIDSDATA           DDHAL_GETMOCOMPGUIDSDATA;
typedef DD_GETMOCOMPFORMATSDATA         DDHAL_GETMOCOMPFORMATSDATA;
typedef DD_CREATEMOCOMPDATA             DDHAL_CREATEMOCOMPDATA;
typedef DD_GETMOCOMPCOMPBUFFDATA        DDHAL_GETMOCOMPCOMPBUFFDATA;
typedef DD_GETINTERNALMOCOMPDATA        DDHAL_GETINTERNALMOCOMPDATA;
typedef DD_BEGINMOCOMPFRAMEDATA         DDHAL_BEGINMOCOMPFRAMEDATA;
typedef DD_ENDMOCOMPFRAMEDATA           DDHAL_ENDMOCOMPFRAMEDATA;
typedef DD_RENDERMOCOMPDATA             DDHAL_RENDERMOCOMPDATA;
typedef DD_QUERYMOCOMPSTATUSDATA        DDHAL_QUERYMOCOMPSTATUSDATA;
typedef DD_DESTROYMOCOMPDATA            DDHAL_DESTROYMOCOMPDATA;

// DirectDraw HAL call backs

typedef PDD_SETCOLORKEY                 LPDDHAL_SETCOLORKEY;
typedef PDD_CANCREATESURFACE            LPDDHAL_CANCREATESURFACE;
typedef PDD_WAITFORVERTICALBLANK        LPDDHAL_WAITFORVERTICALBLANK;
typedef PDD_CREATESURFACE               LPDDHAL_CREATESURFACE;
typedef PDD_DESTROYDRIVER               LPDDHAL_DESTROYDRIVER;
typedef PDD_SETMODE                     LPDDHAL_SETMODE;
typedef PDD_CREATEPALETTE               LPDDHAL_CREATEPALETTE;
typedef PDD_GETSCANLINE                 LPDDHAL_GETSCANLINE;
typedef PDD_MAPMEMORY                   LPDDHAL_MAPMEMORY;
typedef PDD_GETAVAILDRIVERMEMORY        LPDDHAL_GETAVAILDRIVERMEMORY;
typedef PDD_GETDRIVERINFODATA           LPDDHAL_GETDRIVERINFODATA;
typedef PDD_SYNCSURFACEDATA             LPDDHAL_SYNCSURFACEDATA;
typedef PDD_SYNCVIDEOPORTDATA           LPDDHAL_SYNCVIDEOPORTDATA;
typedef PDD_SETEXCLUSIVEMODE            LPDDHAL_SETEXCLUSIVEMODE;
typedef PDD_FLIPTOGDISURFACE            LPDDHAL_FLIPTOGDISURFACE;

typedef PDD_ALPHABLT                    LPDDHAL_ALPHABLT;
typedef PDD_CREATESURFACEEX             LPDDHAL_CREATESURFACEEX;
typedef PDD_GETDRIVERSTATE              LPDDHAL_GETDRIVERSTATE;

typedef PDD_PALCB_DESTROYPALETTE        LPDDHALPALCB_DESTROYPALETTE;
typedef PDD_PALCB_SETENTRIES            LPDDHALPALCB_SETENTRIES;

typedef PDD_SURFCB_LOCK                 LPDDHALSURFCB_LOCK;
typedef PDD_SURFCB_UNLOCK               LPDDHALSURFCB_UNLOCK;
typedef PDD_SURFCB_BLT                  LPDDHALSURFCB_BLT;
typedef PDD_SURFCB_UPDATEOVERLAY        LPDDHALSURFCB_UPDATEOVERLAY;
typedef PDD_SURFCB_SETOVERLAYPOSITION   LPDDHALSURFCB_SETOVERLAYPOSITION;
typedef PDD_SURFCB_SETPALETTE           LPDDHALSURFCB_SETPALETTE;
typedef PDD_SURFCB_FLIP                 LPDDHALSURFCB_FLIP;
typedef PDD_SURFCB_DESTROYSURFACE       LPDDHALSURFCB_DESTROYSURFACE;
typedef PDD_SURFCB_SETCLIPLIST          LPDDHALSURFCB_SETCLIPLIST;
typedef PDD_SURFCB_ADDATTACHEDSURFACE   LPDDHALSURFCB_ADDATTACHEDSURFACE;
typedef PDD_SURFCB_SETCOLORKEY          LPDDHALSURFCB_SETCOLORKEY;
typedef PDD_SURFCB_GETBLTSTATUS         LPDDHALSURFCB_GETBLTSTATUS;
typedef PDD_SURFCB_GETFLIPSTATUS        LPDDHALSURFCB_GETFLIPSTATUS;

typedef PDD_VPORTCB_CANCREATEVIDEOPORT  LPDDHALVPORTCB_CANCREATEVIDEOPORT;
typedef PDD_VPORTCB_CREATEVIDEOPORT     LPDDHALVPORTCB_CREATEVIDEOPORT;
typedef PDD_VPORTCB_FLIP                LPDDHALVPORTCB_FLIP;
typedef PDD_VPORTCB_GETBANDWIDTH        LPDDHALVPORTCB_GETBANDWIDTH;
typedef PDD_VPORTCB_GETINPUTFORMATS     LPDDHALVPORTCB_GETINPUTFORMATS;
typedef PDD_VPORTCB_GETOUTPUTFORMATS    LPDDHALVPORTCB_GETOUTPUTFORMATS;
typedef PDD_VPORTCB_GETFIELD            LPDDHALVPORTCB_GETFIELD;
typedef PDD_VPORTCB_GETLINE             LPDDHALVPORTCB_GETLINE;
typedef PDD_VPORTCB_GETVPORTCONNECT     LPDDHALVPORTCB_GETVPORTCONNECT;
typedef PDD_VPORTCB_DESTROYVPORT        LPDDHALVPORTCB_DESTROYVPORT;
typedef PDD_VPORTCB_GETFLIPSTATUS       LPDDHALVPORTCB_GETFLIPSTATUS;
typedef PDD_VPORTCB_UPDATE              LPDDHALVPORTCB_UPDATE;
typedef PDD_VPORTCB_WAITFORSYNC         LPDDHALVPORTCB_WAITFORSYNC;
typedef PDD_VPORTCB_GETSIGNALSTATUS     LPDDHALVPORTCB_GETSIGNALSTATUS;
typedef PDD_VPORTCB_COLORCONTROL        LPDDHALVPORTCB_COLORCONTROL;

typedef PDD_MOCOMPCB_GETGUIDS           LPDDHALMOCOMPCB_GETGUIDS;
typedef PDD_MOCOMPCB_GETFORMATS         LPDDHALMOCOMPCB_GETFORMATS;
typedef PDD_MOCOMPCB_CREATE             LPDDHALMOCOMPCB_CREATE;
typedef PDD_MOCOMPCB_GETCOMPBUFFINFO    LPDDHALMOCOMPCB_GETCOMPBUFFINFO;
typedef PDD_MOCOMPCB_GETINTERNALINFO    LPDDHALMOCOMPCB_GETINTERNALINFO;
typedef PDD_MOCOMPCB_BEGINFRAME         LPDDHALMOCOMPCB_BEGINFRAME;
typedef PDD_MOCOMPCB_ENDFRAME           LPDDHALMOCOMPCB_ENDFRAME;
typedef PDD_MOCOMPCB_RENDER             LPDDHALMOCOMPCB_RENDER;
typedef PDD_MOCOMPCB_QUERYSTATUS        LPDDHALMOCOMPCB_QUERYSTATUS;
typedef PDD_MOCOMPCB_DESTROY            LPDDHALMOCOMPCB_DESTROY;

typedef DD_CALLBACKS                    DDHAL_DDCALLBACKS;
typedef DD_PALETTECALLBACKS             DDHAL_DDPALETTECALLBACKS;
typedef DD_SURFACECALLBACKS             DDHAL_DDSURFACECALLBACKS;
typedef DD_VIDEOPORTCALLBACKS           DDHAL_DDVIDEOPORTCALLBACKS;
typedef DD_COLORCONTROLCALLBACKS        DDHAL_DDCOLORCONTROLCALLBACKS;
typedef DD_KERNELCALLBACKS              DDHAL_DDKERNELCALLBACKS;
typedef DD_MOTIONCOMPCALLBACKS          DDHAL_DDMOTIONCOMPCALLBACKS;
typedef DD_MISCELLANEOUS2CALLBACKS      DDHAL_DDMISCELLANEOUS2CALLBACKS;
typedef DD_D3DBUFCALLBACKS              DDHAL_D3DBUFCALLBACKS;
typedef DD_NTCALLBACKS                  DDHAL_DDNTCALLBACKS;

typedef PDD_CALLBACKS                   LPDDHAL_DDCALLBACKS;
typedef PDD_PALETTECALLBACKS            LPDDHAL_DDPALETTECALLBACKS;
typedef PDD_SURFACECALLBACKS            LPDDHAL_DDSURFACECALLBACKS;
typedef PDD_VIDEOPORTCALLBACKS          LPDDHAL_DDVIDEOPORTCALLBACKS;
typedef PDD_COLORCONTROLCALLBACKS       LPDDHAL_DDCOLORCONTROLCALLBACKS;
typedef PDD_KERNELCALLBACKS             LPDDHAL_DDKERNELCALLBACKS;
typedef PDD_MOTIONCOMPCALLBACKS         LPDDHAL_DDMOTIONCOMPCALLBACKS;
typedef PDD_MISCELLANEOUS2CALLBACKS     LPDDHAL_DDMISCELLANEOUS2CALLBACKS;
typedef PDD_D3DBUFCALLBACKS             LPDDHAL_D3DBUFCALLBACKS;
typedef PDD_NTCALLBACKS                 LPDDHAL_DDNTCALLBACKS;

// bit definition for dwFlags in dwPaletteFlags in D3DHAL_DP2SETPALETTE
#define DDRAWIPAL_256       0x00000001l // 256 entry palette
#define DDRAWIPAL_16        0x00000002l // 16 entry palette
#define DDRAWIPAL_GDI       0x00000004l // palette allocated through GDI
#define DDRAWIPAL_STORED_8  0x00000008l // palette stored as 8bpp/entry
#define DDRAWIPAL_STORED_16 0x00000010l // palette stored as 16bpp/entry
#define DDRAWIPAL_STORED_24 0x00000020l // palette stored as 24bpp/entry
#define DDRAWIPAL_EXCLUSIVE 0x00000040l // palette being used in exclusive mode
#define DDRAWIPAL_INHEL     0x00000080l // palette is done in the hel
#define DDRAWIPAL_DIRTY         0x00000100l     // gdi palette out 'o sync
#define DDRAWIPAL_ALLOW256  0x00000200l // can fully update palette
#define DDRAWIPAL_4             0x00000400l     // 4 entry palette
#define DDRAWIPAL_2             0x00000800l     // 2 entry palette
#define DDRAWIPAL_STORED_8INDEX 0x00001000l     // palette stored as 8-bit index into dst palette
#define DDRAWIPAL_ALPHA     0x00002000l // palette entries contain alpha

typedef D3DNTHAL_CALLBACKS              D3DHAL_CALLBACKS;
typedef D3DNTHAL_GLOBALDRIVERDATA       D3DHAL_GLOBALDRIVERDATA;
typedef D3DNTHAL_CONTEXTCREATEDATA      D3DHAL_CONTEXTCREATEDATA;
typedef D3DNTHAL_CONTEXTDESTROYDATA     D3DHAL_CONTEXTDESTROYDATA;
typedef D3DNTHAL_CONTEXTDESTROYALLDATA  D3DHAL_CONTEXTDESTROYALLDATA;
typedef D3DNTHAL_SCENECAPTUREDATA       D3DHAL_SCENECAPTUREDATA;
typedef D3DNTHAL_TEXTURECREATEDATA      D3DHAL_TEXTURECREATEDATA;
typedef D3DNTHAL_TEXTUREDESTROYDATA     D3DHAL_TEXTUREDESTROYDATA;
typedef D3DNTHAL_TEXTURESWAPDATA        D3DHAL_TEXTURESWAPDATA;
typedef D3DNTHAL_TEXTUREGETSURFDATA     D3DHAL_TEXTUREGETSURFDATA;

typedef D3DNTHAL_CALLBACKS2             D3DHAL_CALLBACKS2;
typedef D3DNTHAL_SETRENDERTARGETDATA    D3DHAL_SETRENDERTARGETDATA;

typedef D3DNTHAL_CALLBACKS3             D3DHAL_CALLBACKS3;
typedef D3DNTHAL_CLEAR2DATA             D3DHAL_CLEAR2DATA;
typedef D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA   D3DHAL_VALIDATETEXTURESTAGESTATEDATA;
typedef D3DNTHAL_DRAWPRIMITIVES2DATA    D3DHAL_DRAWPRIMITIVES2DATA;
typedef D3DNTHAL_D3DEXTENDEDCAPS        D3DHAL_D3DEXTENDEDCAPS;

typedef LPD3DNTHAL_CALLBACKS            LPD3DHAL_CALLBACKS;
typedef LPD3DNTHAL_GLOBALDRIVERDATA     LPD3DHAL_GLOBALDRIVERDATA;
typedef LPD3DNTHAL_CONTEXTCREATEDATA    LPD3DHAL_CONTEXTCREATEDATA;
typedef LPD3DNTHAL_CONTEXTDESTROYDATA   LPD3DHAL_CONTEXTDESTROYDATA;
typedef LPD3DNTHAL_CONTEXTDESTROYALLDATA LPD3DHAL_CONTEXTDESTROYALLDATA;
typedef LPD3DNTHAL_SCENECAPTUREDATA     LPD3DHAL_SCENECAPTUREDATA;
typedef LPD3DNTHAL_TEXTURECREATEDATA    LPD3DHAL_TEXTURECREATEDATA;
typedef LPD3DNTHAL_TEXTUREDESTROYDATA   LPD3DHAL_TEXTUREDESTROYDATA;
typedef LPD3DNTHAL_TEXTURESWAPDATA      LPD3DHAL_TEXTURESWAPDATA;
typedef LPD3DNTHAL_TEXTUREGETSURFDATA   LPD3DHAL_TEXTUREGETSURFDATA;

typedef LPD3DNTHAL_CALLBACKS2           LPD3DHAL_CALLBACKS2;
typedef LPD3DNTHAL_SETRENDERTARGETDATA  LPD3DHAL_SETRENDERTARGETDATA;

typedef LPD3DNTHAL_CALLBACKS3           LPD3DHAL_CALLBACKS3;
typedef LPD3DNTHAL_CLEAR2DATA           LPD3DHAL_CLEAR2DATA;
typedef LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA;
typedef LPD3DNTHAL_DRAWPRIMITIVES2DATA  LPD3DHAL_DRAWPRIMITIVES2DATA;
typedef LPD3DNTHAL_D3DEXTENDEDCAPS      LPD3DHAL_D3DEXTENDEDCAPS;

#define D3DHAL2_CB32_SETRENDERTARGET          D3DNTHAL2_CB32_SETRENDERTARGET

#define D3DHAL_CONTEXT_BAD              D3DNTHAL_CONTEXT_BAD
#define D3DHAL_OUTOFCONTEXTS            D3DNTHAL_OUTOFCONTEXTS
#define D3DHALSTATE_GET_RENDER          D3DNTHALSTATE_GET_RENDER
#define D3DHAL_SCENE_CAPTURE_START      D3DNTHAL_SCENE_CAPTURE_START
#define D3DHAL_SCENE_CAPTURE_END        D3DNTHAL_SCENE_CAPTURE_END

#define D3DHAL3_CB32_CLEAR2                   D3DNTHAL3_CB32_CLEAR2
#define D3DHAL3_CB32_RESERVED                 D3DNTHAL3_CB32_RESERVED
#define D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE  D3DNTHAL3_CB32_VALIDATETEXTURESTAGESTATE
#define D3DHAL3_CB32_DRAWPRIMITIVES2          D3DNTHAL3_CB32_DRAWPRIMITIVES2

//-----------------------------------------------------------------------------
// DrawPrimitives2 DDI
//-----------------------------------------------------------------------------
typedef D3DNTHAL_DP2COMMAND D3DHAL_DP2COMMAND;
typedef LPDNT3DHAL_DP2COMMAND LPD3DHAL_DP2COMMAND;
typedef D3DNTHAL_DP2OPERATION D3DHAL_DP2OPERATION;
typedef D3DNTHAL_DP2POINTS D3DHAL_DP2POINTS;
typedef D3DNTHAL_DP2LINELIST D3DHAL_DP2LINELIST;
typedef D3DNTHAL_DP2INDEXEDLINELIST D3DHAL_DP2INDEXEDLINELIST;
typedef D3DNTHAL_DP2LINESTRIP D3DHAL_DP2LINESTRIP;
typedef D3DNTHAL_DP2INDEXEDLINESTRIP D3DHAL_DP2INDEXEDLINESTRIP;
typedef D3DNTHAL_DP2TRIANGLELIST D3DHAL_DP2TRIANGLELIST;
typedef D3DNTHAL_DP2INDEXEDTRIANGLELIST D3DHAL_DP2INDEXEDTRIANGLELIST;
typedef D3DNTHAL_DP2INDEXEDTRIANGLELIST2 D3DHAL_DP2INDEXEDTRIANGLELIST2;
typedef D3DNTHAL_DP2TRIANGLESTRIP D3DHAL_DP2TRIANGLESTRIP;
typedef D3DNTHAL_DP2INDEXEDTRIANGLESTRIP D3DHAL_DP2INDEXEDTRIANGLESTRIP;
typedef D3DNTHAL_DP2TRIANGLEFAN D3DHAL_DP2TRIANGLEFAN;
typedef D3DNTHAL_DP2INDEXEDTRIANGLEFAN D3DHAL_DP2INDEXEDTRIANGLEFAN;
typedef D3DNTHAL_DP2RENDERSTATE D3DHAL_DP2RENDERSTATE;
typedef D3DNTHAL_DP2TEXTURESTAGESTATE D3DHAL_DP2TEXTURESTAGESTATE;
typedef D3DNTHAL_DP2TRIANGLEFAN_IMM D3DHAL_DP2TRIANGLEFAN_IMM;
typedef D3DNTHAL_DP2STARTVERTEX D3DHAL_DP2STARTVERTEX;
typedef D3DNTHAL_DP2VIEWPORTINFO D3DHAL_DP2VIEWPORTINFO;
typedef D3DNTHAL_DP2WINFO D3DHAL_DP2WINFO;
typedef D3DNTHAL_DP2SETPALETTE      D3DHAL_DP2SETPALETTE;
typedef D3DNTHAL_DP2UPDATEPALETTE   D3DHAL_DP2UPDATEPALETTE;
typedef D3DNTHAL_DP2ZRANGE          D3DHAL_DP2ZRANGE;
typedef D3DNTHAL_DP2SETMATERIAL     D3DHAL_DP2SETMATERIAL;
typedef D3DNTHAL_DP2SETLIGHT        D3DHAL_DP2SETLIGHT;
typedef D3DNTHAL_DP2SETCLIPPLANE    D3DHAL_DP2SETCLIPPLANE;
typedef D3DNTHAL_DP2CREATELIGHT     D3DHAL_DP2CREATELIGHT;
typedef D3DNTHAL_DP2SETTRANSFORM    D3DHAL_DP2SETTRANSFORM;
typedef D3DNTHAL_DP2EXT             D3DHAL_DP2EXT;
typedef D3DNTHAL_DP2TEXBLT          D3DHAL_DP2TEXBLT;
typedef D3DNTHAL_DP2STATESET        D3DHAL_DP2STATESET;
typedef D3DNTHAL_DP2SETPRIORITY     D3DHAL_DP2SETPRIORITY;
typedef D3DNTHAL_DP2SETRENDERTARGET D3DHAL_DP2SETRENDERTARGET;
typedef D3DNTHAL_DP2CLEAR           D3DHAL_DP2CLEAR;
typedef D3DNTHAL_DP2SETTEXLOD       D3DHAL_DP2SETTEXLOD;

#define D3DDP2OP_POINTS               D3DNTDP2OP_POINTS
#define D3DDP2OP_INDEXEDLINELIST      D3DNTDP2OP_INDEXEDLINELIST
#define D3DDP2OP_INDEXEDLINELIST2     D3DNTDP2OP_INDEXEDLINELIST2
#define D3DDP2OP_INDEXEDTRIANGLELIST  D3DNTDP2OP_INDEXEDTRIANGLELIST
#define D3DDP2OP_INDEXEDTRIANGLELIST2 D3DNTDP2OP_INDEXEDTRIANGLELIST2
#define D3DDP2OP_RENDERSTATE          D3DNTDP2OP_RENDERSTATE
#define D3DDP2OP_LINELIST             D3DNTDP2OP_LINELIST
#define D3DDP2OP_LINESTRIP            D3DNTDP2OP_LINESTRIP
#define D3DDP2OP_INDEXEDLINESTRIP     D3DNTDP2OP_INDEXEDLINESTRIP
#define D3DDP2OP_TRIANGLELIST         D3DNTDP2OP_TRIANGLELIST
#define D3DDP2OP_TRIANGLESTRIP        D3DNTDP2OP_TRIANGLESTRIP
#define D3DDP2OP_INDEXEDTRIANGLESTRIP D3DNTDP2OP_INDEXEDTRIANGLESTRIP
#define D3DDP2OP_TRIANGLEFAN          D3DNTDP2OP_TRIANGLEFAN
#define D3DDP2OP_INDEXEDTRIANGLEFAN   D3DNTDP2OP_INDEXEDTRIANGLEFAN
#define D3DDP2OP_TRIANGLEFAN_IMM      D3DNTDP2OP_TRIANGLEFAN_IMM
#define D3DDP2OP_LINELIST_IMM         D3DNTDP2OP_LINELIST_IMM
#define D3DDP2OP_TEXTURESTAGESTATE    D3DNTDP2OP_TEXTURESTAGESTATE
#define D3DDP2OP_VIEWPORTINFO         D3DNTDP2OP_VIEWPORTINFO
#define D3DDP2OP_WINFO                D3DNTDP2OP_WINFO
#define D3DDP2OP_SETPALETTE           D3DNTDP2OP_SETPALETTE
#define D3DDP2OP_UPDATEPALETTE        D3DNTDP2OP_UPDATEPALETTE

#define D3DDP2OP_ZRANGE               D3DNTDP2OP_ZRANGE
#define D3DDP2OP_SETMATERIAL          D3DNTDP2OP_SETMATERIAL
#define D3DDP2OP_SETLIGHT             D3DNTDP2OP_SETLIGHT
#define D3DDP2OP_CREATELIGHT          D3DNTDP2OP_CREATELIGHT
#define D3DDP2OP_SETTRANSFORM         D3DNTDP2OP_SETTRANSFORM
#define D3DDP2OP_EXT                  D3DNTDP2OP_EXT                  
#define D3DDP2OP_TEXBLT               D3DNTDP2OP_TEXBLT
#define D3DDP2OP_STATESET             D3DNTDP2OP_STATESET
#define D3DDP2OP_SETPRIORITY          D3DNTDP2OP_SETPRIORITY
#define D3DDP2OP_SETRENDERTARGET      D3DNTDP2OP_SETRENDERTARGET
#define D3DDP2OP_CLEAR                D3DNTDP2OP_CLEAR
#define D3DDP2OP_SETTEXLOD            D3DNTDP2OP_SETTEXLOD
#define D3DDP2OP_SETCLIPPLANE         D3DNTDP2OP_SETCLIPPLANE

#define D3DERR_COMMAND_UNPARSED       D3DNTERR_COMMAND_UNPARSED
#define D3DHALDP2_USERMEMVERTICES     D3DNTHALDP2_USERMEMVERTICES
#define D3DHALDP2_EXECUTEBUFFER       D3DNTHALDP2_EXECUTEBUFFER
#define D3DHALDP2_SWAPVERTEXBUFFER    D3DNTHALDP2_SWAPVERTEXBUFFER
#define D3DHALDP2_SWAPCOMMANDBUFFER   D3DNTHALDP2_SWAPCOMMANDBUFFER
#define D3DHALDP2_REQVERTEXBUFSIZE    D3DNTHALDP2_REQVERTEXBUFSIZE
#define D3DHALDP2_REQCOMMANDBUFSIZE   D3DNTHALDP2_REQCOMMANDBUFSIZE
#define D3DHALDP2_VIDMEMVERTEXBUF     D3DNTHALDP2_VIDMEMVERTEXBUF
#define D3DHALDP2_VIDMEMCOMMANDBUF    D3DNTHALDP2_VIDMEMCOMMANDBUF


#define PFND3DPARSEUNKNOWNCOMMAND     PFND3DNTPARSEUNKNOWNCOMMAND

#if(DIRECT3D_VERSION >= 0x0800 )
#define D3DDP2OP_CREATEVERTEXSHADER    D3DNTDP2OP_CREATEVERTEXSHADER
#define D3DDP2OP_DELETEVERTEXSHADER    D3DNTDP2OP_DELETEVERTEXSHADER
#define D3DDP2OP_SETVERTEXSHADER       D3DNTDP2OP_SETVERTEXSHADER
#define D3DDP2OP_SETVERTEXSHADERCONST  D3DNTDP2OP_SETVERTEXSHADERCONST
#define D3DDP2OP_SETSTREAMSOURCE       D3DNTDP2OP_SETSTREAMSOURCE
#define D3DDP2OP_SETSTREAMSOURCEUM     D3DNTDP2OP_SETSTREAMSOURCEUM
#define D3DDP2OP_SETINDICES            D3DNTDP2OP_SETINDICES
#define D3DDP2OP_DRAWPRIMITIVE         D3DNTDP2OP_DRAWPRIMITIVE
#define D3DDP2OP_DRAWINDEXEDPRIMITIVE  D3DNTDP2OP_DRAWINDEXEDPRIMITIVE
#define D3DDP2OP_CREATEPIXELSHADER     D3DNTDP2OP_CREATEPIXELSHADER
#define D3DDP2OP_DELETEPIXELSHADER     D3DNTDP2OP_DELETEPIXELSHADER
#define D3DDP2OP_SETPIXELSHADER        D3DNTDP2OP_SETPIXELSHADER
#define D3DDP2OP_SETPIXELSHADERCONST   D3DNTDP2OP_SETPIXELSHADERCONST
#define D3DDP2OP_CLIPPEDTRIANGLEFAN    D3DNTDP2OP_CLIPPEDTRIANGLEFAN
#define D3DDP2OP_DRAWPRIMITIVE2        D3DNTDP2OP_DRAWPRIMITIVE2
#define D3DDP2OP_DRAWINDEXEDPRIMITIVE2 D3DNTDP2OP_DRAWINDEXEDPRIMITIVE2
#define D3DDP2OP_DRAWRECTPATCH         D3DNTDP2OP_DRAWRECTPATCH
#define D3DDP2OP_DRAWTRIPATCH          D3DNTDP2OP_DRAWTRIPATCH
#define D3DDP2OP_VOLUMEBLT             D3DNTDP2OP_VOLUMEBLT
#define D3DDP2OP_BUFFERBLT             D3DNTDP2OP_BUFFERBLT
#define D3DDP2OP_MULTIPLYTRANSFORM     D3DNTDP2OP_MULTIPLYTRANSFORM
#define D3DDP2OP_ADDDIRTYRECT          D3DNTDP2OP_ADDDIRTYRECT         
#define D3DDP2OP_ADDDIRTYBOX           D3DNTDP2OP_ADDDIRTYBOX          


#define D3DHAL_STATESETCREATE    D3DNTHAL_STATESETCREATE    
#define D3DCLEAR_COMPUTERECTS    D3DNTCLEAR_COMPUTERECTS  
   
typedef D3DNTHAL_DP2MULTIPLYTRANSFORM   D3DHAL_DP2MULTIPLYTRANSFORM;
typedef LPD3DNTHAL_DP2MULTIPLYTRANSFORM LPD3DHAL_DP2MULTIPLYTRANSFORM;
typedef D3DNTHAL_DP2VERTEXSHADER        D3DHAL_DP2VERTEXSHADER ;
typedef LPD3DNTHAL_DP2VERTEXSHADER      LPD3DHAL_DP2VERTEXSHADER;

typedef  D3DNTHAL_DP2CREATEVERTEXSHADER      D3DHAL_DP2CREATEVERTEXSHADER;
typedef  LPD3DNTHAL_DP2CREATEVERTEXSHADER    LPD3DHAL_DP2CREATEVERTEXSHADER;
typedef  D3DNTHAL_DP2SETVERTEXSHADERCONST    D3DHAL_DP2SETVERTEXSHADERCONST;
typedef  LPD3DNTHAL_DP2SETVERTEXSHADERCONST  LPD3DHAL_DP2SETVERTEXSHADERCONST;
typedef  D3DNTHAL_DP2SETSTREAMSOURCE         D3DHAL_DP2SETSTREAMSOURCE;
typedef  LPD3DNTHAL_DP2SETSTREAMSOURCE       LPD3DHAL_DP2SETSTREAMSOURCE;
typedef  D3DNTHAL_DP2SETSTREAMSOURCEUM       D3DHAL_DP2SETSTREAMSOURCEUM;
typedef  LPD3DNTHAL_DP2SETSTREAMSOURCEUM     LPD3DHAL_DP2SETSTREAMSOURCEUM;
typedef  D3DNTHAL_DP2SETINDICES              D3DHAL_DP2SETINDICES;
typedef  LPD3DNTHAL_DP2SETINDICES            LPD3DHAL_DP2SETINDICES;
typedef  D3DNTHAL_DP2DRAWPRIMITIVE           D3DHAL_DP2DRAWPRIMITIVE;
typedef  LPD3DNTHAL_DP2DRAWPRIMITIVE         LPD3DHAL_DP2DRAWPRIMITIVE;
typedef  D3DNTHAL_DP2DRAWINDEXEDPRIMITIVE    D3DHAL_DP2DRAWINDEXEDPRIMITIVE;
typedef  LPD3DNTHAL_DP2DRAWINDEXEDPRIMITIVE  LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE;
typedef  D3DNTHAL_CLIPPEDTRIANGLEFAN         D3DHAL_CLIPPEDTRIANGLEFAN;
typedef  LPD3DNTHAL_CLIPPEDTRIANGLEFAN       LPD3DHAL_CLIPPEDTRIANGLEFAN;
typedef  D3DNTHAL_DP2DRAWPRIMITIVE2          D3DHAL_DP2DRAWPRIMITIVE2;
typedef  LPD3DNTHAL_DP2DRAWPRIMITIVE2        LPD3DHAL_DP2DRAWPRIMITIVE2;
typedef  D3DNTHAL_DP2DRAWINDEXEDPRIMITIVE2   D3DHAL_DP2DRAWINDEXEDPRIMITIVE2;
typedef  LPD3DNTHAL_DP2DRAWINDEXEDPRIMITIVE2 LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2;
typedef  D3DNTHAL_DP2PIXELSHADER             D3DHAL_DP2PIXELSHADER;
typedef  LPD3DNTHAL_DP2PIXELSHADER           LPD3DHAL_DP2PIXELSHADER;
typedef  D3DNTHAL_DP2CREATEPIXELSHADER       D3DHAL_DP2CREATEPIXELSHADER;
typedef  LPD3DNTHAL_DP2CREATEPIXELSHADER     LPD3DHAL_DP2CREATEPIXELSHADER;
typedef  D3DNTHAL_DP2SETPIXELSHADERCONST     D3DHAL_DP2SETPIXELSHADERCONST;
typedef  LPD3DNTHAL_DP2SETPIXELSHADERCONST   LPD3DHAL_DP2SETPIXELSHADERCONST;

#define RTPATCHFLAG_HASSEGS  _NT_RTPATCHFLAG_HASSEGS  
#define RTPATCHFLAG_HASINFO  _NT_RTPATCHFLAG_HASINFO  

typedef  D3DNTHAL_DP2DRAWRECTPATCH   D3DHAL_DP2DRAWRECTPATCH;
typedef  LPD3DNTHAL_DP2DRAWRECTPATCH LPD3DHAL_DP2DRAWRECTPATCH;
typedef  D3DNTHAL_DP2DRAWTRIPATCH    D3DHAL_DP2DRAWTRIPATCH;
typedef  LPD3DNTHAL_DP2DRAWTRIPATCH  LPD3DHAL_DP2DRAWTRIPATCH;
typedef  D3DNTHAL_DP2VOLUMEBLT       D3DHAL_DP2VOLUMEBLT;
typedef  LPD3DNTHAL_DP2VOLUMEBLT     LPD3DHAL_DP2VOLUMEBLT;
typedef  D3DNTHAL_DP2BUFFERBLT       D3DHAL_DP2BUFFERBLT;
typedef  LPD3DNTHAL_DP2BUFFERBLT     LPD3DHAL_DP2BUFFERBLT;
typedef  D3DNTHAL_DP2ADDDIRTYRECT    D3DHAL_DP2ADDDIRTYRECT;
typedef  LPD3DNTHAL_DP2ADDDIRTYRECT  LPD3DHAL_DP2ADDDIRTYRECT;
typedef  D3DNTHAL_DP2ADDDIRTYBOX     D3DHAL_DP2ADDDIRTYBOX;
typedef  LPD3DNTHAL_DP2ADDDIRTYBOX   LPD3DHAL_DP2ADDDIRTYBOX;

#define D3DSI_GETREGTYPE      _NT_D3DSI_GETREGTYPE
#define D3DSI_GETREGNUM       _NT_D3DSI_GETREGNUM
#define D3DSI_GETOPCODE       _NT_D3DSI_GETOPCODE
#define D3DSI_GETWRITEMASK    _NT_D3DSI_GETWRITEMASK
#define D3DVS_GETSWIZZLECOMP  _NT_D3DVS_GETSWIZZLECOMP
#define D3DVS_GETSWIZZLE      _NT_D3DVS_GETSWIZZLE
#define D3DVS_GETSRCMODIFIER  _NT_D3DVS_GETSRCMODIFIER
#define D3DVS_GETADDRESSMODE  _NT_D3DVS_GETADDRESSMODE

#define D3DRS_DELETERTPATCH       _NT_D3DRS_DELETERTPATCH       

typedef DDNT_GETDRIVERINFO2DATA   DD_GETDRIVERINFO2DATA;;

#define GUID_GetDriverInfo2 _NT_GUID_GetDriverInfo2 
#define D3DGDI2_MAGIC       _NT_D3DGDI2_MAGIC       

#define D3DGDI2_TYPE_GETD3DCAPS8    _NT_D3DGDI2_TYPE_GETD3DCAPS8    
#define D3DGDI2_TYPE_GETFORMATCOUNT _NT_D3DGDI2_TYPE_GETFORMATCOUNT 
#define D3DGDI2_TYPE_GETFORMAT      _NT_D3DGDI2_TYPE_GETFORMAT      
#define D3DGDI2_TYPE_DXVERSION      _NT_D3DGDI2_TYPE_DXVERSION      
#define D3DGDI2_TYPE_DEFERRED_AGP_AWARE   _NT_D3DGDI2_TYPE_DEFERRED_AGP_AWARE
#define D3DGDI2_TYPE_FREE_DEFERRED_AGP    _NT_D3DGDI2_TYPE_FREE_DEFERRED_AGP
#define D3DGDI2_TYPE_DEFER_AGP_FREES      _NT_D3DGDI2_TYPE_DEFER_AGP_FREES

typedef DDNT_GETFORMATCOUNTDATA DD_GETFORMATCOUNTDATA;
typedef DDNT_GETFORMATDATA      DD_GETFORMATDATA;
typedef DDNT_DXVERSION          DD_DXVERSION;
typedef DDNT_DEFERRED_AGP_AWARE_DATA  DD_DEFERRED_AGP_AWARE_DATA;
typedef DDNT_FREE_DEFERRED_AGP_DATA   DD_FREE_DEFERRED_AGP_DATA;

#define D3DDEVCAPS_HWVERTEXBUFFER       _NT_D3DDEVCAPS_HWVERTEXBUFFER       
#define D3DDEVCAPS_HWINDEXBUFFER        _NT_D3DDEVCAPS_HWINDEXBUFFER        
#define D3DDEVCAPS_SUBVOLUMELOCK        _NT_D3DDEVCAPS_SUBVOLUMELOCK

#define D3DPMISCCAPS_FOGINFVF           _NT_D3DPMISCCAPS_FOGINFVF
#define D3DFVF_FOG                      _NT_D3DFVF_FOG

#define D3DFMT_D32     _NT_D3DFMT_D32    
#define D3DFMT_S1D15   _NT_D3DFMT_S1D15  
#define D3DFMT_D15S1   _NT_D3DFMT_D15S1  
#define D3DFMT_S8D24   _NT_D3DFMT_S8D24  
#define D3DFMT_D24S8   _NT_D3DFMT_D24S8  
#define D3DFMT_X8D24   _NT_D3DFMT_X8D24  
#define D3DFMT_D24X8   _NT_D3DFMT_D24X8 
#define D3DFMT_X4S4D24 _NT_D3DFMT_X4S4D24 
#define D3DFMT_D24X4S4 _NT_D3DFMT_D24X4S4 

#define D3DVS_INPUTREG_MAX_V1_1         _NT_D3DVS_INPUTREG_MAX_V1_1         
#define D3DVS_TEMPREG_MAX_V1_1          _NT_D3DVS_TEMPREG_MAX_V1_1          
#define D3DVS_CONSTREG_MAX_V1_1         _NT_D3DVS_CONSTREG_MAX_V1_1         
#define D3DVS_TCRDOUTREG_MAX_V1_1       _NT_D3DVS_TCRDOUTREG_MAX_V1_1       
#define D3DVS_ADDRREG_MAX_V1_1          _NT_D3DVS_ADDRREG_MAX_V1_1          
#define D3DVS_ATTROUTREG_MAX_V1_1       _NT_D3DVS_ATTROUTREG_MAX_V1_1       
#define D3DVS_MAXINSTRUCTIONCOUNT_V1_1  _NT_D3DVS_MAXINSTRUCTIONCOUNT_V1_1  

#define D3DPS_INPUTREG_MAX_DX8         _NT_D3DPS_INPUTREG_MAX_DX8         
#define D3DPS_TEMPREG_MAX_DX8          _NT_D3DPS_TEMPREG_MAX_DX8          
#define D3DPS_CONSTREG_MAX_DX8         _NT_D3DPS_CONSTREG_MAX_DX8         
#define D3DPS_TEXTUREREG_MAX_DX8       _NT_D3DPS_TEXTUREREG_MAX_DX8       

#endif // (DIRECT3D_VERSION >= 0x0800 )

#ifdef DX8DDK_DX7HAL_DEFINES 

// Some legacy (<=DX7) definitions that are in d3dhal.h

#define D3DHAL_TSS_MAXSTAGES           D3DNTHAL_TSS_MAXSTAGES
typedef PDD_DIRECTDRAW_LOCAL           LPDDRAWI_DIRECTDRAW_LCL;

typedef D3DNTHAL_DP2OPERATION            *LPD3DHAL_DP2OPERATION;
typedef D3DNTHAL_DP2POINTS               *LPD3DHAL_DP2POINTS;
typedef D3DNTHAL_DP2LINELIST             *LPD3DHAL_DP2LINELIST;
typedef D3DNTHAL_DP2INDEXEDLINELIST      *LPD3DHAL_DP2INDEXEDLINELIST;
typedef D3DNTHAL_DP2LINESTRIP            *LPD3DHAL_DP2LINESTRIP;
typedef D3DNTHAL_DP2INDEXEDLINESTRIP     *LPD3DHAL_DP2INDEXEDLINESTRIP;
typedef D3DNTHAL_DP2TRIANGLELIST         *LPD3DHAL_DP2TRIANGLELIST;
typedef D3DNTHAL_DP2INDEXEDTRIANGLELIST  *LPD3DHAL_DP2INDEXEDTRIANGLELIST;
typedef D3DNTHAL_DP2INDEXEDTRIANGLELIST2 *LPD3DHAL_DP2INDEXEDTRIANGLELIST2;
typedef D3DNTHAL_DP2TRIANGLESTRIP        *LPD3DHAL_DP2TRIANGLESTRIP;
typedef D3DNTHAL_DP2INDEXEDTRIANGLESTRIP *LPD3DHAL_DP2INDEXEDTRIANGLESTRIP;
typedef D3DNTHAL_DP2TRIANGLEFAN          *LPD3DHAL_DP2TRIANGLEFAN;
typedef D3DNTHAL_DP2INDEXEDTRIANGLEFAN   *LPD3DHAL_DP2INDEXEDTRIANGLEFAN;
typedef D3DNTHAL_DP2RENDERSTATE          *LPD3DHAL_DP2RENDERSTATE;
typedef D3DNTHAL_DP2TEXTURESTAGESTATE    *LPD3DHAL_DP2TEXTURESTAGESTATE;
typedef D3DNTHAL_DP2TRIANGLEFAN_IMM      *LPD3DHAL_DP2TRIANGLEFAN_IMM;
typedef D3DNTHAL_DP2STARTVERTEX          *LPD3DHAL_DP2STARTVERTEX;
typedef D3DNTHAL_DP2VIEWPORTINFO         *LPD3DHAL_DP2VIEWPORTINFO;
typedef D3DNTHAL_DP2WINFO                *LPD3DHAL_DP2WINFO;
typedef D3DNTHAL_DP2SETPALETTE           *LPD3DHAL_DP2SETPALETTE;
typedef D3DNTHAL_DP2UPDATEPALETTE        *LPD3DHAL_DP2UPDATEPALETTE;
typedef D3DNTHAL_DP2ZRANGE               *LPD3DHAL_DP2ZRANGE;
typedef D3DNTHAL_DP2SETMATERIAL          *LPD3DHAL_DP2SETMATERIAL;
typedef D3DNTHAL_DP2SETLIGHT             *LPD3DHAL_DP2SETLIGHT;
typedef D3DNTHAL_DP2SETCLIPPLANE         *LPD3DHAL_DP2SETCLIPPLANE;
typedef D3DNTHAL_DP2CREATELIGHT          *LPD3DHAL_DP2CREATELIGHT;
typedef D3DNTHAL_DP2SETTRANSFORM         *LPD3DHAL_DP2SETTRANSFORM;
typedef D3DNTHAL_DP2EXT                  *LPD3DHAL_DP2EXT;
typedef D3DNTHAL_DP2TEXBLT               *LPD3DHAL_DP2TEXBLT;
typedef D3DNTHAL_DP2STATESET             *LPD3DHAL_DP2STATESET;
typedef D3DNTHAL_DP2SETPRIORITY          *LPD3DHAL_DP2SETPRIORITY;
typedef D3DNTHAL_DP2SETRENDERTARGET      *LPD3DHAL_DP2SETRENDERTARGET;
typedef D3DNTHAL_DP2CLEAR                *LPD3DHAL_DP2CLEAR;
typedef D3DNTHAL_DP2SETTEXLOD            *LPD3DHAL_DP2SETTEXLOD;

// Values for dwDataType in D3DHAL_DP2SETLIGHT
#define D3DHAL_SETLIGHT_ENABLE   0
#define D3DHAL_SETLIGHT_DISABLE  1
// If this is set, light data will be passed in after the
// D3DLIGHT7 structure
#define D3DHAL_SETLIGHT_DATA     2

#define D3DHAL_NUMCLIPVERTICES  20

#define D3DTSS_MAX ((D3DTEXTURESTAGESTATETYPE)29) 

/*
 * If DX8 driver wants to support pre-DX8 applications, it should use these
 * definitions for pre-DX8 world matrices
*/
#define D3DTRANSFORMSTATE_WORLD_DX7  1
#define D3DTRANSFORMSTATE_WORLD1_DX7 4
#define D3DTRANSFORMSTATE_WORLD2_DX7 5
#define D3DTRANSFORMSTATE_WORLD3_DX7 6

/*
 * Generally needed maximum state structure sizes.  Note that the copy of
 * these in refrasti.hpp must be kept in sync with these.
 */

#define D3DHAL_MAX_RSTATES (D3DRENDERSTATE_WRAPBIAS + 128)
/* Last state offset for combined render state and texture stage array + 1 */
#define D3DHAL_MAX_RSTATES_AND_STAGES \
    (D3DHAL_TSS_RENDERSTATEBASE + \
     D3DHAL_TSS_MAXSTAGES * D3DHAL_TSS_STATESPERSTAGE)
/* Last texture state ID */
#define D3DHAL_MAX_TEXTURESTATES (13)
/* Last texture state ID + 1 */
#define D3DHAL_TEXTURESTATEBUF_SIZE (D3DHAL_MAX_TEXTURESTATES+1)

/*
 * If no dwNumVertices is given, this is what will be used.
 */
#define D3DHAL_DEFAULT_TL_NUM   ((32 * 1024) / sizeof (D3DTLVERTEX))
#define D3DHAL_DEFAULT_H_NUM    ((32 * 1024) / sizeof (D3DHVERTEX))

typedef D3DDEVICEDESC_V1 *LPD3DDEVICEDESC_V1;
#define D3DDEVICEDESCSIZE_V1 (sizeof(D3DDEVICEDESC_V1))

#define D3DHAL_GLOBALDRIVERDATASIZE (sizeof(D3DHAL_GLOBALDRIVERDATA))

#define D3DHAL_D3DEXTENDEDCAPSSIZE (sizeof(D3DHAL_D3DEXTENDEDCAPS))

#endif // DX8DDK_DX7HAL_DEFINES 
 


#endif // WINNT
#endif // NODX95TYPES

#endif // __DX95TYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\oak\inc\lmon.h ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation
All rights reserved

Module Name:

    lmon.h

--*/


typedef struct _PORT_INFO_FFA {
    LPSTR   pName;
    DWORD   cbMonitorData;
    LPBYTE  pMonitorData;
} PORT_INFO_FFA, *PPORT_INFO_FFA, *LPPORT_INFO_FFA;

typedef struct _PORT_INFO_FFW {
    LPWSTR  pName;
    DWORD   cbMonitorData;
    LPBYTE  pMonitorData;
} PORT_INFO_FFW, *PPORT_INFO_FFW, *LPPORT_INFO_FFW;

#ifdef UNICODE
#define PORT_INFO_FF PORT_INFO_FFW
#define PPORT_INFO_FF PPORT_INFO_FFW
#define LPPORT_INFO_FF LPPORT_INFO_FFW
#else
#define PORT_INFO_FF PORT_INFO_FFA
#define PPORT_INFO_FF PPORT_INFO_FFA
#define LPPORT_INFO_FF LPPORT_INFO_FFA
#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\oak\inc\ddrawi.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddrawi.h
 *  Content:    DirectDraw internal header file
 *      Used by DirectDraw and by the display drivers.
 *@@BEGIN_DDKSPLIT
 *      See ddrawpr.h for all information private to DirectDraw.
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   25-dec-94  craige  initial implementation
 *   06-jan-95  craige  video memory manager integration
 *   13-jan-95  craige  re-worked to updated spec + ongoing work
 *   21-jan-95  craige  made 32-bit + ongoing work
 *   31-jan-95  craige  and even more ongoing work...
 *   04-feb-95  craige  performance tuning, ongoing work
 *   22-feb-95  craige  use critical sections on Win95
 *   02-mar-95  craige  work work work
 *   06-mar-95  craige  HEL integration
 *   11-mar-95  craige  palette stuff
 *   17-mar-95  craige  COM interface
 *   19-mar-95  craige  use HRESULTs, use same process list handling for
 *          driver objects as surface and palette
 *   20-mar-95  craige  new CSECT work
 *   23-mar-95  craige  attachment work
 *   27-mar-95  craige  linear or rectangular vidmem
 *   28-mar-95  craige  RGBQUAD -> PALETTEENTRY; other palette stuff
 *   29-mar-95  craige  removed Eitherxxx caps from DIRECTDRAW
 *   31-mar-95  craige  use critical sections with palettes
 *   04-apr-95  craige  palette tweaks
 *   06-apr-95  craige  split out process list stuff
 *   10-apr-95  craige  bug 3,16 - palette issues
 *   13-apr-95  craige  EricEng's little contribution to our being late
 *   06-may-95  craige  use driver-level csects only
 *   09-may-95  craige  escape call to get 32-bit DLL
 *   14-may-95  craige  cleaned out obsolete junk
 *   15-may-95  craige  made separate VMEM struct for rect & linear
 *   24-may-95  kylej   removed obsolete ZOrder variables
 *   24-may-95  craige  removed dwOrigNumHeaps
 *   28-may-95  craige  cleaned up HAL: added GetBltStatus;GetFlipStatus;
 *          GetScanLine
 *   02-jun-95  craige  added PROCESS_LIST2 to DIRECTDRAW object; removed
 *          hWndPal from DIRECTDRAW object; added lpDDSurface
 *          to DIRECTDRAWPALETTE object
 *   06-jun-95  craige  maintain entire primary surface in DIRECTDRAW object
 *   07-jun-95  craige  moved DCLIST to PROCESSLIST
 *   10-jun-95  craige  split out vmemmgr stuff
 *   12-jun-95  craige  new process list stuff
 *   16-jun-95  craige  removed fpVidMemOrig; new surface structure
 *   20-jun-95  kylej   added is_excl field to DDHAL_CREATEPALETTEDATA struct
 *   21-jun-95  craige  added DirectDrawClipper object; removed clipping
 *          info from surface object
 *   22-jun-95  craige  more clipping work
 *   25-jun-95  craige  one ddraw mutex
 *   26-jun-95  craige  reorganized surface structure
 *   27-jun-95  craige  added dwModeCreatedIn to surface
 *   30-jun-95  kylej   removed lpPrimarySurface, dwZDepth, dwAlphaDepth
 *          from direct draw object.  Modified some surface and
 *                      direct draw object flags.
 *   01-jul-95  craige  hide composition & streaming stuff
 *   02-jul-95  craige  added extra reserved field for HEL
 *   03-jul-95  craige  YEEHAW: new driver struct; added pUnkOuter to all objects
 *   09-jul-95  craige  track win16lock info in driver struct; added
 *          DDHAL_DRIVER_NOCKEYHW
 *   10-jul-95  craige  support SetOverlayPosition
 *   13-jul-95  craige  removed old junk from ddraw object; added new mode stuff;
 *          changed Get/SetOverlayPosition to use longs;
 *          fixed duplicate flag in DDRAWIPAL_xxx
 *   14-jul-95  craige  added VIDMEM_ISHEAP
 *   20-jul-95  craige  internal reorg to prevent thunking during modeset;
 *          palette bugs
 *   22-jul-95  craige  bug 230 - unsupported starting modes
 *   29-jul-95  toddla  remove unused palette stuff
 *   31-jul-95  toddla  added DD_HAL_VERSION
 *   01-aug-95  toddla  added dwPDevice to DDRAWI_DIRECTDRAW_GBL
 *   10-aug-95  craige  added VALID_ALIGNMENT
 *   13-aug-95  craige  internal/external version of DD_HAL_VERSION
 *   21-aug-95  craige  mode X support
 *   27-aug-95  craige  bug 742: added DDRAWIPAL_ALLOW256
 *   08-nov-95  colinmc added DDRAWIPAL flags to support 1, 2 and 4 bit
 *                      RGB and indexed palettes
 *   21-nov-95  colinmc made Direct3D a queryable interface off DirectDraw
 *   23-nov-95  colinmc made Direct3D textures and devices queryable off
 *                      DirectDraw surfaces
 *   09-dec-95  colinmc execute buffer support
 *   12-dec-95  colinmc shared back and z-buffer support (run away, run away...)
 *   22-dec-95  colinmc Direct3D support no longer conditional
 *   02-jan-96  kylej   New interface structures, no vtbl in local objects
 *   10-jan-96  colinmc Aggregate IUnknowns of surfaces now maintained as
 *                      list
 *   18-jan-96  jeffno  Changed free entries in DDRAW_GBL and SURFACE_LCL to NT
 *                      kernel-mode handles
 *   29-jan-96  colinmc Aggregated IUnknowns now stored in additional
 *                      surface structure
 *   09-feb-96  colinmc Addition of lost surface flag to local surface
 *                      objects
 *   17-feb-96  colinmc Fixed execute buffer size restriction problem
 *   01-mar-96  kylej   Change DDCAPS size
 *   03-mar-96  colinmc Hack to keep interim drivers working
 *   13-mar-96  craige  Bug 7528: hw that doesn't have modex
 *   14-mar-96  colinmc Class factory support for clippers
 *   24-mar-96  colinmc Bug 14321: not possible to specify back buffer and
 *                      mip-map count in a single call
 *   13-apr-96  colinmc Bug 17736: no notification to driver of when GDI
 *                      frame buffer is being displayed
 *   16-apr-96  kylej   Bug 17900: DBLNODE struct incompatible with ddraw 1
 *   05-sep-96  craige  added dwAppHackFlags to DDRAWI_DIRECTDRAW_LCL struct.
 *   01-oct-96  ketand  added GetAvailDriverMemory
 *   05-oct-96  colinmc Work Item: Removing the restriction on taking Win16
 *                      lock on VRAM surfaces (not including the primary)
 *   07-oct-96  colinmc Fixed build breaker with GetAvailDriverMem
 *   07-oct-96  ketand  Created DDRAWSURFACE_GBL_MORE
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   09-nov-96  colinmc Fixed problem with old and new drivers not working
 *                      with DirectDraw
 *   15-nov-96  colinmc Finally removed DDSCAPS_3D and moved the definition
 *                      of DDSCAPS_EXECUTEBUFFER to here so that it was
 *                      visible from the DDK.
 *   08-dec-96  colinmc Initial AGP support
 *   12-jan-97  colinmc More Win16 lock work
 *   13-jan-97 jvanaken Basic support for IDirectDrawSurface3 interface
 *   21-jan-97  ketand  Deleted Winwatch/Streaming/Composition. Add multi-mon support.
 *   27-jan-97  colinmc AGP support
 *   29-jan-97  colinmc Fixed build breaker
 *   29-jan-97  smac    Removed old ring 0 code
 *   29-jan-97  jeffno  Mode13 support. A new flag in DDMODEINFO.
 *   01-feb-97  colinmc Bug 5574: Need to remove USE_ALIAS from headers
 *                      Bug 4665: Extra bytes per surface for driver
 *   02-feb-97  colinmc Bug 5625: DirectX drivers not longer be recognized
 *                                due to bad size validation on DDCALLBACKS
 *   24-feb-97  ketand  Add dwContext to GETDRIVERINFODATA for NT and multimon
 *   03-mar-97  smac    Added kernel mode interface
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *   08-mar-97  colinmc New function to allow surface pointer to be
 *                      specified
 *   11-mar-97  jeffno  Asynchronous DMA support
 *   23-mar-97  colinmc Bug 6673: Change structure numbering scheme for
 *                      consistency's sake and pass version number to the
 *                      driver. Also update the runtime version number
 *                      passed in the DCI command
 *   24-mar-97  jeffno  Optimized Surfaces
 *   30-sep-97  jeffno  IDirectDraw4
 *   03-oct-97  jeffno  DDSCAPS2 and DDSURFACEDESC2
 *   31-oct-97 johnstep Persistent-content surfaces for Windows 9x
 *   05-nov-97 jvanaken Support for AlphaBlt and SetSpriteDisplayList
 *   26-nov-97 t-craigs IDirectDrawPalette2 and a few changes/additions to Surface4
 *@@END_DDKSPLIT
 *
 ***************************************************************************/
#ifndef __DDRAWI_INCLUDED__
#define __DDRAWI_INCLUDED__

//
// This is a helper for external driver builds.
//
#if (!defined(WIN95)) && (!defined(WINNT))
#define WIN95
#endif

/*
 * METAQUESTION: Why are Windows handles stored as DWORDs instead of
 *       their proper types?
 * METAANSWER:   To make the thunk to the 16-bit side completely painless.
 */

#define OBJECT_ISROOT           0x80000000l // object is root object

/*
 * stuff for drivers
 */
#ifndef _WIN32
typedef long    HRESULT;
typedef LPVOID  REFIID;
#ifndef GUID_DEFINED
    #define GUID_DEFINED
    typedef struct _GUID {
        ULONG   Data1;
        unsigned short Data2;
        unsigned short Data3;
        unsigned char Data4[8];
    } GUID;
#endif // !defined(GUID_DEFINED)

typedef GUID FAR *LPGUID;
#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )
#endif

/*
 * These definitions are required to allow polymorphic structure members (i.e. those
 * that are referred to both as DWORDs and as pointers) to resolve into a type
 * of correct size to hold the largest of those two types (i.e. pointer) on 64 bit
 * systems. For 32 bit environments, ULONG_PTR resolves to a DWORD.
 */
#ifndef MAXULONG_PTR
#define ULONG_PTR    DWORD
#define PULONG_PTR   LPDWORD
#endif //MAXULONG_PTR

//@@BEGIN_DDKSPLIT
// Include ddrawp.h for DirectDraw and D3D builds.  DDK includes ddraw.h
#ifdef MSBUILD
    #include "ddrawp.h"
    #include "dvpp.h"
    #include "ddkernel.h"
#else
//@@END_DDKSPLIT
    #include "ddraw.h"
    #include "dvp.h"
    #include "ddkernel.h"
//@@BEGIN_DDKSPLIT
#endif
#include "ddmcp.h"
//@@END_DDKSPLIT
#include "dmemmgr.h"

#ifdef IS_16
// ddraw16 16-bit compiler cannot handle 32-bit d3d headers included by d3dhal.h
// so for ddraw16 build, explicitly list d3dhal ptr types here
#define LPD3DHAL_GLOBALDRIVERDATA   ULONG_PTR
#define LPD3DHAL_CALLBACKS          ULONG_PTR
#define LPD3DHAL_CALLBACKS2         ULONG_PTR
#define LPD3DHAL_CALLBACKS3         ULONG_PTR
#define LPD3DHAL_D3DEXTENDEDCAPS    ULONG_PTR
#define LPD3DHAL_COMMANDBUFFERCALLBACKS ULONG_PTR
//@@BEGIN_DDKSPLIT
#else
// make sure to get d3d8 private version so the
// d3d8typesp gets included instead of d3d8types
#if DIRECT3D_VERSION >= 0x800
#include "d3dhalp.h"
#else
#include "d3dhal.h"
#endif
//@@END_DDKSPLIT
#endif

#ifndef _WIN32
/*
 * these error codes are DIFFERENT in Win32 and Win16!!!!
 */
#undef  E_NOTIMPL
#undef  E_OUTOFMEMORY
#undef  E_INVALIDARG
#undef  E_FAIL
#define E_NOTIMPL                        0x80004001L
#define E_OUTOFMEMORY                    0x8007000EL
#define E_INVALIDARG                     0x80070057L
#define E_FAIL                           0x80004005L
#endif


#define DDUNSUPPORTEDMODE       ((DWORD) -1)


#define VALID_ALIGNMENT( align ) (!((align == 0) || (align % 2) != 0 ))

#ifdef _WIN32
/*
 * These GUIDs are used to identify driver info structures, not interfaces,
 * so the prefix GUID_ is used instead of IID_.
 *
 */

DEFINE_GUID( GUID_MiscellaneousCallbacks,       0xefd60cc0, 0x49e7, 0x11d0, 0x88, 0x9d, 0x00, 0xaa, 0x00, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_VideoPortCallbacks,       0xefd60cc1, 0x49e7, 0x11d0, 0x88, 0x9d, 0x00, 0xaa, 0x00, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_ColorControlCallbacks,    0xefd60cc2, 0x49e7, 0x11d0, 0x88, 0x9d, 0x00, 0xaa, 0x00, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_VideoPortCaps,            0xefd60cc3, 0x49e7, 0x11d0, 0x88, 0x9d, 0x00, 0xaa, 0x00, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_D3DCallbacks2,        0x0ba584e1, 0x70b6, 0x11d0, 0x88, 0x9d, 0x00, 0xaa, 0x00, 0xbb, 0xb7, 0x6a);
DEFINE_GUID( GUID_D3DCallbacks3,                0xddf41230, 0xec0a, 0x11d0, 0xa9, 0xb6, 0x00, 0xaa, 0x00, 0xc0, 0x99, 0x3e);
DEFINE_GUID( GUID_NonLocalVidMemCaps,       0x86c4fa80, 0x8d84, 0x11d0, 0x94, 0xe8, 0x00, 0xc0, 0x4f, 0xc3, 0x41, 0x37);
DEFINE_GUID( GUID_KernelCallbacks,      0x80863800, 0x6B06, 0x11D0, 0x9B, 0x06, 0x0, 0xA0, 0xC9, 0x03, 0xA3, 0xB8);
DEFINE_GUID( GUID_KernelCaps,           0xFFAA7540, 0x7AA8, 0x11D0, 0x9B, 0x06, 0x00, 0xA0, 0xC9, 0x03, 0xA3, 0xB8);
DEFINE_GUID( GUID_D3DExtendedCaps,      0x7de41f80, 0x9d93, 0x11d0, 0x89, 0xab, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
DEFINE_GUID( GUID_ZPixelFormats,        0x93869880, 0x36cf, 0x11d1, 0x9b, 0x1b, 0x0, 0xaa, 0x0, 0xbb, 0xb8, 0xae);
DEFINE_GUID( GUID_DDMoreSurfaceCaps,        0x3b8a0466, 0xf269, 0x11d1, 0x88, 0x0b, 0x0, 0xc0, 0x4f, 0xd9, 0x30, 0xc5);
DEFINE_GUID( GUID_DDStereoMode,          0xf828169c, 0xa8e8, 0x11d2, 0xa1, 0xf2, 0x0, 0xa0, 0xc9, 0x83, 0xea, 0xf6);
DEFINE_GUID( GUID_OptSurfaceKmodeInfo,      0xe05c8472, 0x51d4, 0x11d1, 0x8c, 0xce, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( GUID_OptSurfaceUmodeInfo,      0x9d792804, 0x5fa8, 0x11d1, 0x8c, 0xd0, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( GUID_UserModeDriverInfo,       0xf0b0e8e2, 0x5f97, 0x11d1, 0x8c, 0xd0, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( GUID_UserModeDriverPassword,   0x97f861b6, 0x60a1, 0x11d1, 0x8c, 0xd0, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID(GUID_D3DParseUnknownCommandCallback, 0x2e04ffa0, 0x98e4, 0x11d1, 0x8c, 0xe1, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( GUID_MotionCompCallbacks,      0xb1122b40, 0x5dA5, 0x11d1, 0x8f, 0xcF, 0x00, 0xc0, 0x4f, 0xc2, 0x9b, 0x4e);
DEFINE_GUID( GUID_Miscellaneous2Callbacks,  0x406B2F00, 0x3E5A, 0x11D1, 0xB6, 0x40, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x6A);
//@@BEGIN_DDKSPLIT
DEFINE_GUID( GUID_NTCallbacks,                  0x6fe9ecde, 0xdf89, 0x11d1, 0x9d, 0xb0, 0x00, 0x60, 0x08, 0x27, 0x71, 0xba);
DEFINE_GUID( GUID_DDMoreCaps,               0x880baf30, 0xb030, 0x11d0, 0x8e, 0xa7, 0x00, 0x60, 0x97, 0x97, 0xea, 0x5b);
DEFINE_GUID( GUID_VPE2Callbacks,            0x52882147, 0x2d47, 0x469a, 0xa0, 0xd1, 0x3, 0x45, 0x58, 0x90, 0xf6, 0xc8);
//@@END_DDKSPLIT
#endif //_WIN32

// The Callback that the drivers can use to parse unknown commands
// passed to them via the DrawPrimitives2 callback. The driver obtains this
// callback thru a GetDriverInfo call with GUID_D3DParseUnknownCommandCallback
// made by ddraw somewhere around the initialization time.
#ifdef __cplusplus
extern "C"
#endif
HRESULT CALLBACK D3DParseUnknownCommand (LPVOID lpvCommands,
                                         LPVOID *lplpvReturnedCommand);
/*
 * This DDPF flag is used by drivers to signify that this format is new and may be
 * a candidate for hiding from certain applications
 * KEEP THIS DEFINITION IN SYNC WITH THAT OF DDPF_RESERVED1 IN DDRAW.H
 */
#define DDPF_NOVEL_TEXTURE_FORMAT                               0x00100000l


/*
 * This DDPF flag is used to indicate a DX8+ format capability entry in
 * the texture format list. It is not visible to applications.
 */
#define DDPF_D3DFORMAT                                          0x00200000l

/*
 * List of operations supported on formats in DX8+ texture list.
 * See the DX8 DDK for a complete description of these flags.
 */
#define D3DFORMAT_OP_TEXTURE                    0x00000001L
#define D3DFORMAT_OP_VOLUMETEXTURE              0x00000002L
#define D3DFORMAT_OP_CUBETEXTURE                0x00000004L
#define D3DFORMAT_OP_OFFSCREEN_RENDERTARGET     0x00000008L
#define D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET   0x00000010L
#define D3DFORMAT_OP_ZSTENCIL                   0x00000040L
#define D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH 0x00000080L

// This format can be used as a render target if the current display mode
// is the same depth if the alpha channel is ignored. e.g. if the device 
// can render to A8R8G8B8 when the display mode is X8R8G8B8, then the
// format op list entry for A8R8G8B8 should have this cap. 
#define D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET 0x00000100L

// This format contains DirectDraw support (including Flip).  This flag
// should not to be set on alpha formats.
#define D3DFORMAT_OP_DISPLAYMODE                0x00000400L

// The rasterizer can support some level of Direct3D support in this format
// and implies that the driver can create a Context in this mode (for some 
// render target format).  When this flag is set, the D3DFORMAT_OP_DISPLAYMODE
// flag must also be set.
#define D3DFORMAT_OP_3DACCELERATION             0x00000800L

// If the driver needs a private format to be D3D or driver manageable,
// then it needs to tell D3D the pixelsize in bits per pixel by setting
// dwPrivateFormatBitCount in DDPIXELFORMAT and by setting the below
// format op. If the below format op is not set, then D3D or the driver
// will NOT be allowed to manage the format.
#define D3DFORMAT_OP_PIXELSIZE                  0x00001000L

/*
 * List of processes attached to a DirectDraw object
 */
typedef struct _PROCESS_LIST
{
    struct _PROCESS_LIST    FAR *lpLink;
    DWORD           dwProcessId;
    DWORD           dwRefCnt;
    DWORD           dwAlphaDepth;
    DWORD           dwZDepth;
} PROCESS_LIST;
typedef PROCESS_LIST    FAR *LPPROCESS_LIST;

/*
 * Information about the refresh rates that monitor/display card can support
 */
typedef struct _DDMONITORINFO
{
    WORD    Manufacturer;       // Montor manufacturer
    WORD    Product;            // Monitor product ID
    DWORD   SerialNumber;       // Monitor serial number
    GUID    DeviceIdentifier;   // From DDDEVICEIDENTIFIER, describes card/driver
    int     Mode640x480;        // Highest refresh rate support, 0 if none, -1 if untested
    int     Mode800x600;
    int     Mode1024x768;
    int     Mode1280x1024;
    int     Mode1600x1200;
    int     ModeReserved1;
    int     ModeReserved2;
    int     ModeReserved3;
} DDMONITORINFO, FAR *LPDDMONITORINFO;

//@@BEGIN_DDKSPLIT
/*
 * Mode test context and mode list structures used by StartModeTest API
 */
typedef struct _MODETESTDATA
{
    DWORD   dwWidth;
    DWORD   dwHeight;
    DWORD   dwBPP;
    DWORD   dwRefreshRate;
} MODETESTDATA, * LPMODETESTDATA;

typedef struct _MODETESTCONTEXT
{
    DWORD           dwTimeStamp;
    DWORD           dwNumModes;
    DWORD           dwCurrentMode;
    DWORD           dwOrigModeIndex;
    LPMODETESTDATA  lpModeList;
} MODETESTCONTEXT, * LPMODETESTCONTEXT;
//@@END_DDKSPLIT

/*
 * DeleteFromActiveProcessList return codes
 */
#define DELETED_OK          0
#define DELETED_LASTONE         1
#define DELETED_NOTFOUND        2

#define DDBLT_ANYALPHA \
        (DDBLT_ALPHASRCSURFACEOVERRIDE | \
        DDBLT_ALPHASRCCONSTOVERRIDE | \
        DDBLT_ALPHASRC | \
        DDBLT_ALPHADESTSURFACEOVERRIDE | \
        DDBLT_ALPHADESTCONSTOVERRIDE | \
        DDBLT_ALPHADEST)

#define DDOVER_ANYALPHA \
        (DDOVER_ALPHASRCSURFACEOVERRIDE | \
        DDOVER_ALPHASRCCONSTOVERRIDE | \
        DDOVER_ALPHASRC | \
        DDOVER_ALPHADESTSURFACEOVERRIDE | \
        DDOVER_ALPHADESTCONSTOVERRIDE | \
        DDOVER_ALPHADEST)


typedef struct IDirectDrawClipperVtbl DIRECTDRAWCLIPPERCALLBACKS;
typedef struct IDirectDrawPaletteVtbl DIRECTDRAWPALETTECALLBACKS;
typedef struct IDirectDrawSurfaceVtbl DIRECTDRAWSURFACECALLBACKS;
typedef struct IDirectDrawSurface2Vtbl DIRECTDRAWSURFACE2CALLBACKS;
typedef struct IDirectDrawSurface3Vtbl DIRECTDRAWSURFACE3CALLBACKS;
typedef struct IDirectDrawSurface4Vtbl DIRECTDRAWSURFACE4CALLBACKS;
typedef struct IDirectDrawSurface7Vtbl DIRECTDRAWSURFACE7CALLBACKS;
typedef struct IDirectDrawColorControlVtbl DIRECTDRAWCOLORCONTROLCALLBACKS;
typedef struct IDirectDrawVtbl DIRECTDRAWCALLBACKS;
typedef struct IDirectDraw2Vtbl DIRECTDRAW2CALLBACKS;
typedef struct IDirectDraw4Vtbl DIRECTDRAW4CALLBACKS;
typedef struct IDirectDraw7Vtbl DIRECTDRAW7CALLBACKS;
typedef struct IDirectDrawKernelVtbl DIRECTDRAWKERNELCALLBACKS;
typedef struct IDirectDrawSurfaceKernelVtbl DIRECTDRAWSURFACEKERNELCALLBACKS;
typedef struct IDirectDrawGammaControlVtbl DIRECTDRAWGAMMACONTROLCALLBACKS;

//@@BEGIN_DDKSPLIT
#ifdef POSTPONED
typedef struct IDirectDrawFactory2Vtbl DDFACTORY2CALLBACKS;
typedef struct IDirectDrawPalette2Vtbl DIRECTDRAWPALETTE2CALLBACKS;
typedef struct IPersistVtbl DIRECTDRAWSURFACEPERSISTCALLBACKS;
typedef struct IPersistStreamVtbl DIRECTDRAWSURFACEPERSISTSTREAMCALLBACKS;
typedef struct IPersistVtbl DIRECTDRAWPALETTEPERSISTCALLBACKS;
typedef struct IPersistStreamVtbl DIRECTDRAWPALETTEPERSISTSTREAMCALLBACKS;
typedef struct IDirectDrawOptSurfaceVtbl DIRECTDRAWOPTSURFACECALLBACKS;
#endif //POSTPONED
//@@END_DDKSPLIT

typedef DIRECTDRAWCLIPPERCALLBACKS FAR *LPDIRECTDRAWCLIPPERCALLBACKS;
typedef DIRECTDRAWPALETTECALLBACKS FAR *LPDIRECTDRAWPALETTECALLBACKS;
typedef DIRECTDRAWSURFACECALLBACKS FAR *LPDIRECTDRAWSURFACECALLBACKS;
typedef DIRECTDRAWCALLBACKS FAR *LPDIRECTDRAWCALLBACKS;

#ifdef __cplusplus
extern "C" {
#endif

#if defined( IS_32 ) || defined( WIN32 ) || defined( _WIN32 )
    #undef IS_32
    #define IS_32
    #define DDAPI       WINAPI
    #define EXTERN_DDAPI    WINAPI
#else
    #define DDAPI       __loadds WINAPI
    #define EXTERN_DDAPI    __export WINAPI
#endif

//@@BEGIN_DDKSPLIT
#ifdef POSTPONED
typedef struct _NONDELEGATINGUNKNOWNCALLBACKS
{
    HRESULT (DDAPI *QueryInterface) (LPDIRECTDRAW, REFIID, LPVOID FAR * );
    DWORD   (DDAPI *AddRef) (LPDIRECTDRAW);
    DWORD   (DDAPI *Release) (LPDIRECTDRAW);
} NONDELEGATINGUNKNOWNCALLBACKS;
#endif
//@@END_DDKSPLIT


/*
 * DCI escape
 */
#ifndef DCICOMMAND
#define DCICOMMAND      3075        // escape value
#endif

/*
 * this is the DirectDraw version
 * passed to the driver in DCICMD.dwVersion
 *
 * Most older HALs will fail if DD_VERSION does not match what they
 * are expecting.  Therefore, DD_VERSION cannot change if we want DX5+ to
 * run on DX2/3 HALs.  For this reason, we added a new version call that
 * allows the HAL to know the real version of DirectDraw, which is equal
 * to DD_RUNTIME_VERSION.  This is for informational purposes only.  HALs
 * should not fail DirectDraw if they receive an unknown DirectDraw runtime
 * version.
 */
#define DD_VERSION              0x00000200l
#define DD_RUNTIME_VERSION      0x00000802l

/*
 * this is the HAL version.
 * the driver returns this number from QUERYESCSUPPORT/DCICOMMAND
 */
#define DD_HAL_VERSION          0x0100
//@@BEGIN_DDKSPLIT
#define DD_HAL_VERSION_EXTERNAL 0x0100
#undef DD_HAL_VERSION
#define DD_HAL_VERSION      0x00ff  // special internal version
//@@END_DDKSPLIT

#include "dciddi.h"

#define DDCREATEDRIVEROBJECT    10      // create an object
#define DDGET32BITDRIVERNAME    11      // get a 32-bit driver name
#define DDNEWCALLBACKFNS    12      // new callback fns coming
#define DDVERSIONINFO       13      // tells driver the ddraw version

typedef struct
{
    char    szName[260];            // 32-bit driver name
    char    szEntryPoint[64];       // entry point
    DWORD   dwContext;          // context to pass to entry point
} DD32BITDRIVERDATA, FAR *LPDD32BITDRIVERDATA;

typedef struct
{
    DWORD    dwHALVersion;           // Version of DirectDraw for which the HAL was created
    ULONG_PTR dwReserved1;            // Reserved for future use
    ULONG_PTR dwReserved2;            // Reserved for future use
} DDVERSIONDATA, FAR *LPDDVERSIONDATA;

typedef DWORD   (FAR PASCAL *LPDD32BITDRIVERINIT)(DWORD dwContext);

/*
 * pointer to video meory
 */
typedef ULONG_PTR FLATPTR;

/*
 * indicates that DDRAW.DLL has been unloaded...
 */
#define DDRAW_DLL_UNLOADED  (LPVOID) 1

/*
 * critical section types
 */
typedef LPVOID      CSECT_HANDLE;
#ifdef NOUSE_CRITSECTS
typedef xxx         CSECT;          // generate an error for now
#else
#if defined( IS_32 ) && !defined( _NOCSECT_TYPE )
typedef CRITICAL_SECTION    CSECT;
typedef CSECT           *LPCSECT;
#else
typedef struct
{
    DWORD   vals[6];
} CSECT;
typedef void            FAR *LPCSECT;
#endif
#endif

/*
 * DLL names
 */
#define DDHAL_DRIVER_DLLNAME    "DDRAW16.DLL"
#define DDHAL_APP_DLLNAME   "DDRAW.DLL"

/*
 * maximum size of a driver name
 */
#ifndef CCHDEVICENAME
#define CCHDEVICENAME 32
#endif
#define MAX_DRIVER_NAME     CCHDEVICENAME

/*
 * largest palette supported
 */
#define MAX_PALETTE_SIZE    256

/*
 * maximum number of surfaces that can be autoflipped between
 */
#define MAX_AUTOFLIP_BUFFERS    10

/*
 * Indicates the surface is an execute buffer, i.e., a linear chunk of system
 * or video memory that holds a Direct3D display list. A driver reports this
 * cap to indicate that it can create execute buffers in video memory and
 * Direct3D uses this bit to request execute buffers. However, it is not
 * visible to via the API.
 */
#define DDSCAPS_EXECUTEBUFFER                   DDSCAPS_RESERVED2
/*
 * Indicates to the driver that the "execute" buffer that is to be created is actually
 * a vertex buffer. Used by CreateVertexBuffer in D3D
 */
#define DDSCAPS2_VERTEXBUFFER                   DDSCAPS2_RESERVED1

/*
 * Indicates to the driver that the "execute" buffer that is to be created is actually
 * a command buffer. Used by internally in D3D
 */
#define DDSCAPS2_COMMANDBUFFER                  DDSCAPS2_RESERVED2

/*
 * Indicates to the driver that the "execute" buffer that is to be created is actually
 * an index buffer.
 */
#define DDSCAPS2_INDEXBUFFER                    DDSCAPS2_RESERVED3


/*
 * Internal formats are not exposed to applications.
//@@BEGIN_DDKSPLIT
 * NOTE: Must keep these in sync with enum in d3d8types.h
//@@END_DDKSPLIT
 */

#define D3DFMT_INTERNAL_D32                  71
#define D3DFMT_INTERNAL_S1D15                72
#define D3DFMT_INTERNAL_D15S1                73
#define D3DFMT_INTERNAL_S8D24                74
#define D3DFMT_INTERNAL_D24S8                75
#define D3DFMT_INTERNAL_X8D24                76
#define D3DFMT_INTERNAL_D24X8                77



/*
 * pre-declare pointers to structs containing data for DDHAL fns
 */
typedef struct _DDHAL_CREATEPALETTEDATA FAR *LPDDHAL_CREATEPALETTEDATA;
typedef struct _DDHAL_CREATESURFACEDATA FAR *LPDDHAL_CREATESURFACEDATA;
typedef struct _DDHAL_CANCREATESURFACEDATA FAR *LPDDHAL_CANCREATESURFACEDATA;
typedef struct _DDHAL_WAITFORVERTICALBLANKDATA FAR *LPDDHAL_WAITFORVERTICALBLANKDATA;
typedef struct _DDHAL_DESTROYDRIVERDATA FAR *LPDDHAL_DESTROYDRIVERDATA;
typedef struct _DDHAL_SETMODEDATA FAR *LPDDHAL_SETMODEDATA;
typedef struct _DDHAL_DRVSETCOLORKEYDATA FAR *LPDDHAL_DRVSETCOLORKEYDATA;
typedef struct _DDHAL_GETSCANLINEDATA FAR *LPDDHAL_GETSCANLINEDATA;

typedef struct _DDHAL_DESTROYPALETTEDATA FAR *LPDDHAL_DESTROYPALETTEDATA;
typedef struct _DDHAL_SETENTRIESDATA FAR *LPDDHAL_SETENTRIESDATA;

typedef struct _DDHAL_BLTDATA FAR *LPDDHAL_BLTDATA;
typedef struct _DDHAL_LOCKDATA FAR *LPDDHAL_LOCKDATA;
typedef struct _DDHAL_UNLOCKDATA FAR *LPDDHAL_UNLOCKDATA;
typedef struct _DDHAL_UPDATEOVERLAYDATA FAR *LPDDHAL_UPDATEOVERLAYDATA;
typedef struct _DDHAL_SETOVERLAYPOSITIONDATA FAR *LPDDHAL_SETOVERLAYPOSITIONDATA;
typedef struct _DDHAL_SETPALETTEDATA FAR *LPDDHAL_SETPALETTEDATA;
typedef struct _DDHAL_FLIPDATA FAR *LPDDHAL_FLIPDATA;
typedef struct _DDHAL_DESTROYSURFACEDATA FAR *LPDDHAL_DESTROYSURFACEDATA;
typedef struct _DDHAL_SETCLIPLISTDATA FAR *LPDDHAL_SETCLIPLISTDATA;
typedef struct _DDHAL_ADDATTACHEDSURFACEDATA FAR *LPDDHAL_ADDATTACHEDSURFACEDATA;
typedef struct _DDHAL_SETCOLORKEYDATA FAR *LPDDHAL_SETCOLORKEYDATA;
typedef struct _DDHAL_GETBLTSTATUSDATA FAR *LPDDHAL_GETBLTSTATUSDATA;
typedef struct _DDHAL_GETFLIPSTATUSDATA FAR *LPDDHAL_GETFLIPSTATUSDATA;
typedef struct _DDHAL_SETEXCLUSIVEMODEDATA FAR *LPDDHAL_SETEXCLUSIVEMODEDATA;
typedef struct _DDHAL_FLIPTOGDISURFACEDATA FAR *LPDDHAL_FLIPTOGDISURFACEDATA;

typedef struct _DDHAL_CANCREATEVPORTDATA FAR *LPDDHAL_CANCREATEVPORTDATA;
typedef struct _DDHAL_CREATEVPORTDATA FAR *LPDDHAL_CREATEVPORTDATA;
typedef struct _DDHAL_FLIPVPORTDATA FAR *LPDDHAL_FLIPVPORTDATA;
typedef struct _DDHAL_GETVPORTCONNECTDATA FAR *LPDDHAL_GETVPORTCONNECTDATA;
typedef struct _DDHAL_GETVPORTBANDWIDTHDATA FAR *LPDDHAL_GETVPORTBANDWIDTHDATA;
typedef struct _DDHAL_GETVPORTINPUTFORMATDATA FAR *LPDDHAL_GETVPORTINPUTFORMATDATA;
typedef struct _DDHAL_GETVPORTOUTPUTFORMATDATA FAR *LPDDHAL_GETVPORTOUTPUTFORMATDATA;
typedef struct _DDHAL_GETVPORTFIELDDATA FAR *LPDDHAL_GETVPORTFIELDDATA;
typedef struct _DDHAL_GETVPORTLINEDATA FAR *LPDDHAL_GETVPORTLINEDATA;
typedef struct _DDHAL_DESTROYVPORTDATA FAR *LPDDHAL_DESTROYVPORTDATA;
typedef struct _DDHAL_GETVPORTFLIPSTATUSDATA FAR *LPDDHAL_GETVPORTFLIPSTATUSDATA;
typedef struct _DDHAL_UPDATEVPORTDATA FAR *LPDDHAL_UPDATEVPORTDATA;
typedef struct _DDHAL_WAITFORVPORTSYNCDATA FAR *LPDDHAL_WAITFORVPORTSYNCDATA;
typedef struct _DDHAL_GETVPORTSIGNALDATA FAR *LPDDHAL_GETVPORTSIGNALDATA;
typedef struct _DDHAL_VPORTCOLORDATA FAR *LPDDHAL_VPORTCOLORDATA;

typedef struct _DDHAL_COLORCONTROLDATA FAR *LPDDHAL_COLORCONTROLDATA;

typedef struct _DDHAL_GETAVAILDRIVERMEMORYDATA FAR *LPDDHAL_GETAVAILDRIVERMEMORYDATA;
typedef struct _DDHAL_UPDATENONLOCALHEAPDATA FAR *LPDDHAL_UPDATENONLOCALHEAPDATA;
typedef struct _DDHAL_GETHEAPALIGNMENTDATA FAR *LPDDHAL_GETHEAPALIGNMENTDATA;

typedef struct _DDHAL_GETDRIVERINFODATA FAR *LPDDHAL_GETDRIVERINFODATA;

typedef struct _DDHAL_SYNCSURFACEDATA FAR *LPDDHAL_SYNCSURFACEDATA;
typedef struct _DDHAL_SYNCVIDEOPORTDATA FAR *LPDDHAL_SYNCVIDEOPORTDATA;

typedef struct _DDHAL_GETMOCOMPGUIDSDATA FAR *LPDDHAL_GETMOCOMPGUIDSDATA;
typedef struct _DDHAL_GETMOCOMPFORMATSDATA FAR *LPDDHAL_GETMOCOMPFORMATSDATA;
typedef struct _DDHAL_CREATEMOCOMPDATA FAR *LPDDHAL_CREATEMOCOMPDATA;
typedef struct _DDHAL_GETMOCOMPCOMPBUFFDATA FAR *LPDDHAL_GETMOCOMPCOMPBUFFDATA;
typedef struct _DDHAL_GETINTERNALMOCOMPDATA FAR *LPDDHAL_GETINTERNALMOCOMPDATA;
typedef struct _DDHAL_BEGINMOCOMPFRAMEDATA FAR *LPDDHAL_BEGINMOCOMPFRAMEDATA;
typedef struct _DDHAL_ENDMOCOMPFRAMEDATA FAR *LPDDHAL_ENDMOCOMPFRAMEDATA;
typedef struct _DDHAL_RENDERMOCOMPDATA FAR *LPDDHAL_RENDERMOCOMPDATA;
typedef struct _DDHAL_QUERYMOCOMPSTATUSDATA FAR *LPDDHAL_QUERYMOCOMPSTATUSDATA;
typedef struct _DDHAL_DESTROYMOCOMPDATA FAR *LPDDHAL_DESTROYMOCOMPDATA;

typedef struct _DDHAL_CREATESURFACEEXDATA FAR *LPDDHAL_CREATESURFACEEXDATA;
typedef struct _DDHAL_GETDRIVERSTATEDATA FAR *LPDDHAL_GETDRIVERSTATEDATA;
typedef struct _DDHAL_DESTROYDDLOCALDATA FAR *LPDDHAL_DESTROYDDLOCALDATA;
//@@BEGIN_DDKSPLIT
#ifdef POSTPONED2
typedef struct _DDHAL_SETSPRITEDISPLAYLISTDATA FAR *LPDDHAL_SETSPRITEDISPLAYLISTDATA;
typedef struct _DDHAL_RESIZEDATA FAR *LPDDHAL_RESIZEDATA;
typedef struct _DDHAL_CAPTURECOMPOSITIONBUFFERDATA FAR *LPDDHAL_CAPTURECOMPOSITIONBUFFERDATA;
#endif //POSTPONED2
//@@END_DDKSPLIT


/*
 * value in the fpVidMem; indicates dwBlockSize is valid (surface object)
 */
#define DDHAL_PLEASEALLOC_BLOCKSIZE 0x00000002l


/*
 * Values in fpVidMem: Indicates dwLinearSizde is valid.
 * THIS VALUE CAN ONLY BE USED BY A D3D Optimize DRIVER FUNCTION
 * IT IS INVALID FOR A DRIVER TO RETURN THIS VALUE FROM CreateSurface32.
 */
#define DDHAL_PLEASEALLOC_LINEARSIZE    0x00000003l

/*
 * DRIVER SERVICES
 *
 * These services exported from ddraw.dll can be called by the HAL.
 * They are intended for use by the d3d Optimize HAL call.
 */
extern HRESULT DDAPI LateAllocateSurfaceMem(
    LPDIRECTDRAWSURFACE lpSurface,
    DWORD dwPleaseAllocType,
    DWORD dwWidthInBytesOrSize,
    DWORD dwHeight);

LPDIRECTDRAWSURFACE GetNextMipMap(
    LPDIRECTDRAWSURFACE lpLevel);
/*
 * video memory data structures (passed in DDHALINFO)
 */
typedef struct _VIDMEM
{
    DWORD       dwFlags;    // flags
    FLATPTR     fpStart;    // start of memory chunk
    union
    {
    FLATPTR     fpEnd;      // end of memory chunk
    DWORD       dwWidth;    // width of chunk (rectanglar memory)
    };
    DDSCAPS     ddsCaps;        // what this memory CANNOT be used for
    DDSCAPS     ddsCapsAlt; // what this memory CANNOT be used for if it must
    union
    {
    LPVMEMHEAP  lpHeap;     // heap pointer, used by DDRAW
    DWORD       dwHeight;   // height of chunk (rectanguler memory)
    };
} VIDMEM;
typedef VIDMEM FAR *LPVIDMEM;

/*
 * flags for vidmem struct
 */
#define VIDMEM_ISLINEAR         0x00000001l     // heap is linear
#define VIDMEM_ISRECTANGULAR    0x00000002l     // heap is rectangular
#define VIDMEM_ISHEAP           0x00000004l     // heap is preallocated by driver
#define VIDMEM_ISNONLOCAL       0x00000008l     // heap populated with non-local video memory
#define VIDMEM_ISWC             0x00000010l     // heap populated with write combining memory
#define VIDMEM_HEAPDISABLED     0x00000020l     // heap disabled

typedef struct _VIDMEMINFO
{
/* 0*/ FLATPTR      fpPrimary;      // pointer to primary surface
/* 4*/ DWORD        dwFlags;        // flags
/* 8*/ DWORD        dwDisplayWidth;     // current display width
/* c*/ DWORD        dwDisplayHeight;    // current display height
/*10*/ LONG     lDisplayPitch;      // current display pitch
/*14*/ DDPIXELFORMAT    ddpfDisplay;        // pixel format of display
/*34*/ DWORD        dwOffscreenAlign;   // byte alignment for offscreen surfaces
/*38*/ DWORD        dwOverlayAlign;     // byte alignment for overlays
/*3c*/ DWORD        dwTextureAlign;     // byte alignment for textures
/*40*/ DWORD        dwZBufferAlign;     // byte alignment for z buffers
/*44*/ DWORD        dwAlphaAlign;       // byte alignment for alpha
/*48*/ DWORD        dwNumHeaps;     // number of memory heaps in vmList
/*4c*/ LPVIDMEM     pvmList;        // array of heaps
} VIDMEMINFO;
typedef VIDMEMINFO FAR *LPVIDMEMINFO;

typedef struct _HEAPALIAS                  // PRIVATE
{
    FLATPTR  fpVidMem;                     // start of aliased vid mem
    LPVOID   lpAlias;                      // start of heap alias
    DWORD    dwAliasSize;                  // size of alias allocated
} HEAPALIAS;
typedef HEAPALIAS FAR *LPHEAPALIAS;

typedef struct _HEAPALIASINFO              // PRIVATE
{
    DWORD       dwRefCnt;                  // reference count of these aliases
    DWORD       dwFlags;                   // flags
    DWORD       dwNumHeaps;                // number of aliased heaps
    LPHEAPALIAS lpAliases;                 // array of heaps
} HEAPALIASINFO;
typedef HEAPALIASINFO FAR *LPHEAPALIASINFO;

#define HEAPALIASINFO_MAPPEDREAL   0x00000001l // PRIVATE: heap aliases mapped to real video memory
#define HEAPALIASINFO_MAPPEDDUMMY  0x00000002l // PRIVATE: heap aliased mapped to dummy memory

typedef struct _DDRAWI_DIRECTDRAW_INT FAR    *LPDDRAWI_DIRECTDRAW_INT;
typedef struct _DDRAWI_DIRECTDRAW_LCL FAR    *LPDDRAWI_DIRECTDRAW_LCL;
typedef struct _DDRAWI_DIRECTDRAW_GBL FAR    *LPDDRAWI_DIRECTDRAW_GBL;
typedef struct _DDRAWI_DDRAWSURFACE_GBL FAR  *LPDDRAWI_DDRAWSURFACE_GBL;
typedef struct _DDRAWI_DDRAWSURFACE_GBL_MORE FAR *LPDDRAWI_DDRAWSURFACE_GBL_MORE;
typedef struct _DDRAWI_DDRAWPALETTE_GBL FAR  *LPDDRAWI_DDRAWPALETTE_GBL;
typedef struct _DDRAWI_DDRAWPALETTE_INT FAR  *LPDDRAWI_DDRAWPALETTE_INT;
typedef struct _DDRAWI_DDRAWCLIPPER_INT FAR  *LPDDRAWI_DDRAWCLIPPER_INT;
typedef struct _DDRAWI_DDRAWCLIPPER_GBL FAR  *LPDDRAWI_DDRAWCLIPPER_GBL;
typedef struct _DDRAWI_DDRAWSURFACE_MORE FAR *LPDDRAWI_DDRAWSURFACE_MORE;
typedef struct _DDRAWI_DDRAWSURFACE_LCL FAR  *LPDDRAWI_DDRAWSURFACE_LCL;
typedef struct _DDRAWI_DDRAWSURFACE_INT FAR  *LPDDRAWI_DDRAWSURFACE_INT;
typedef struct _DDRAWI_DDVIDEOPORT_INT FAR   *LPDDRAWI_DDVIDEOPORT_INT;
typedef struct _DDRAWI_DDVIDEOPORT_LCL FAR   *LPDDRAWI_DDVIDEOPORT_LCL;
typedef struct _DDRAWI_DDRAWPALETTE_LCL FAR  *LPDDRAWI_DDRAWPALETTE_LCL;
typedef struct _DDRAWI_DDRAWCLIPPER_LCL FAR  *LPDDRAWI_DDRAWCLIPPER_LCL;
typedef struct _DDRAWI_DDMOTIONCOMP_INT FAR  *LPDDRAWI_DDMOTIONCOMP_INT;
typedef struct _DDRAWI_DDMOTIONCOMP_LCL FAR  *LPDDRAWI_DDMOTIONCOMP_LCL;

/*
 * List of IUnknowns aggregated by a DirectDraw surface.
 */
typedef struct _IUNKNOWN_LIST
{
    struct _IUNKNOWN_LIST FAR *lpLink;
    GUID                  FAR *lpGuid;
    IUnknown              FAR *lpIUnknown;
} IUNKNOWN_LIST;
typedef IUNKNOWN_LIST FAR *LPIUNKNOWN_LIST;

/*
 * hardware emulation layer stuff
 */
typedef BOOL    (FAR PASCAL *LPDDHEL_INIT)(LPDDRAWI_DIRECTDRAW_GBL,BOOL);

/*
 * These structures contain the entry points in the display driver that
 * DDRAW will call.   Entries that the display driver does not care about
 * should be NULL.   Passed to DDRAW in DDHALINFO.
 */

/*
 * DIRECTDRAW object callbacks
 */
typedef DWORD   (FAR PASCAL *LPDDHAL_SETCOLORKEY)(LPDDHAL_DRVSETCOLORKEYDATA );
typedef DWORD   (FAR PASCAL *LPDDHAL_CANCREATESURFACE)(LPDDHAL_CANCREATESURFACEDATA );
typedef DWORD   (FAR PASCAL *LPDDHAL_WAITFORVERTICALBLANK)(LPDDHAL_WAITFORVERTICALBLANKDATA );
typedef DWORD   (FAR PASCAL *LPDDHAL_CREATESURFACE)(LPDDHAL_CREATESURFACEDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_DESTROYDRIVER)(LPDDHAL_DESTROYDRIVERDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_SETMODE)(LPDDHAL_SETMODEDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_CREATEPALETTE)(LPDDHAL_CREATEPALETTEDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_GETSCANLINE)(LPDDHAL_GETSCANLINEDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_SETEXCLUSIVEMODE)(LPDDHAL_SETEXCLUSIVEMODEDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_FLIPTOGDISURFACE)(LPDDHAL_FLIPTOGDISURFACEDATA);

typedef DWORD   (FAR PASCAL *LPDDHAL_GETDRIVERINFO)(LPDDHAL_GETDRIVERINFODATA);

typedef struct _DDHAL_DDCALLBACKS
{
    DWORD            dwSize;
    DWORD            dwFlags;
    LPDDHAL_DESTROYDRIVER    DestroyDriver;
    LPDDHAL_CREATESURFACE    CreateSurface;
    LPDDHAL_SETCOLORKEY      SetColorKey;
    LPDDHAL_SETMODE      SetMode;
    LPDDHAL_WAITFORVERTICALBLANK WaitForVerticalBlank;
    LPDDHAL_CANCREATESURFACE     CanCreateSurface;
    LPDDHAL_CREATEPALETTE    CreatePalette;
    LPDDHAL_GETSCANLINE      GetScanLine;
    // *** New fields for DX2 *** //
    LPDDHAL_SETEXCLUSIVEMODE     SetExclusiveMode;
    LPDDHAL_FLIPTOGDISURFACE     FlipToGDISurface;
//@@BEGIN_DDKSPLIT
    // For backward compatibility with pre-DX5 runtimes, must not
    // add fields to this structure. Use GetDriverInfo instead.
//@@END_DDKSPLIT
} DDHAL_DDCALLBACKS;
typedef DDHAL_DDCALLBACKS FAR *LPDDHAL_DDCALLBACKS;

#define DDCALLBACKSSIZE_V1 ( offsetof( DDHAL_DDCALLBACKS, SetExclusiveMode ) )
#define DDCALLBACKSSIZE    sizeof( DDHAL_DDCALLBACKS )

#define DDHAL_CB32_DESTROYDRIVER    0x00000001l
#define DDHAL_CB32_CREATESURFACE    0x00000002l
#define DDHAL_CB32_SETCOLORKEY      0x00000004l
#define DDHAL_CB32_SETMODE      0x00000008l
#define DDHAL_CB32_WAITFORVERTICALBLANK 0x00000010l
#define DDHAL_CB32_CANCREATESURFACE 0x00000020l
#define DDHAL_CB32_CREATEPALETTE    0x00000040l
#define DDHAL_CB32_GETSCANLINE      0x00000080l
#define DDHAL_CB32_SETEXCLUSIVEMODE     0x00000100l
#define DDHAL_CB32_FLIPTOGDISURFACE     0x00000200l

/*
 * DIRECTDRAWPALETTE object callbacks
 */
typedef DWORD   (FAR PASCAL *LPDDHALPALCB_DESTROYPALETTE)(LPDDHAL_DESTROYPALETTEDATA );
typedef DWORD   (FAR PASCAL *LPDDHALPALCB_SETENTRIES)(LPDDHAL_SETENTRIESDATA );

typedef struct _DDHAL_DDPALETTECALLBACKS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    LPDDHALPALCB_DESTROYPALETTE DestroyPalette;
    LPDDHALPALCB_SETENTRIES SetEntries;
} DDHAL_DDPALETTECALLBACKS;
typedef DDHAL_DDPALETTECALLBACKS FAR *LPDDHAL_DDPALETTECALLBACKS;

#define DDPALETTECALLBACKSSIZE  sizeof( DDHAL_DDPALETTECALLBACKS )

#define DDHAL_PALCB32_DESTROYPALETTE    0x00000001l
#define DDHAL_PALCB32_SETENTRIES    0x00000002l

/*
 * DIRECTDRAWSURFACE object callbacks
 */
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_LOCK)(LPDDHAL_LOCKDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_UNLOCK)(LPDDHAL_UNLOCKDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_BLT)(LPDDHAL_BLTDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_UPDATEOVERLAY)(LPDDHAL_UPDATEOVERLAYDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_SETOVERLAYPOSITION)(LPDDHAL_SETOVERLAYPOSITIONDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_SETPALETTE)(LPDDHAL_SETPALETTEDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_FLIP)(LPDDHAL_FLIPDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_DESTROYSURFACE)(LPDDHAL_DESTROYSURFACEDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_SETCLIPLIST)(LPDDHAL_SETCLIPLISTDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_ADDATTACHEDSURFACE)(LPDDHAL_ADDATTACHEDSURFACEDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_SETCOLORKEY)(LPDDHAL_SETCOLORKEYDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_GETBLTSTATUS)(LPDDHAL_GETBLTSTATUSDATA);
typedef DWORD   (FAR PASCAL *LPDDHALSURFCB_GETFLIPSTATUS)(LPDDHAL_GETFLIPSTATUSDATA);


typedef struct _DDHAL_DDSURFACECALLBACKS
{
    DWORD               dwSize;
    DWORD               dwFlags;
    LPDDHALSURFCB_DESTROYSURFACE    DestroySurface;
    LPDDHALSURFCB_FLIP          Flip;
    LPDDHALSURFCB_SETCLIPLIST       SetClipList;
    LPDDHALSURFCB_LOCK          Lock;
    LPDDHALSURFCB_UNLOCK        Unlock;
    LPDDHALSURFCB_BLT           Blt;
    LPDDHALSURFCB_SETCOLORKEY       SetColorKey;
    LPDDHALSURFCB_ADDATTACHEDSURFACE    AddAttachedSurface;
    LPDDHALSURFCB_GETBLTSTATUS      GetBltStatus;
    LPDDHALSURFCB_GETFLIPSTATUS     GetFlipStatus;
    LPDDHALSURFCB_UPDATEOVERLAY     UpdateOverlay;
    LPDDHALSURFCB_SETOVERLAYPOSITION    SetOverlayPosition;
    LPVOID              reserved4;
    LPDDHALSURFCB_SETPALETTE        SetPalette;
} DDHAL_DDSURFACECALLBACKS;
typedef DDHAL_DDSURFACECALLBACKS FAR *LPDDHAL_DDSURFACECALLBACKS;

#define DDSURFACECALLBACKSSIZE sizeof( DDHAL_DDSURFACECALLBACKS )

#define DDHAL_SURFCB32_DESTROYSURFACE       0x00000001l
#define DDHAL_SURFCB32_FLIP         0x00000002l
#define DDHAL_SURFCB32_SETCLIPLIST      0x00000004l
#define DDHAL_SURFCB32_LOCK         0x00000008l
#define DDHAL_SURFCB32_UNLOCK           0x00000010l
#define DDHAL_SURFCB32_BLT          0x00000020l
#define DDHAL_SURFCB32_SETCOLORKEY      0x00000040l
#define DDHAL_SURFCB32_ADDATTACHEDSURFACE   0x00000080l
#define DDHAL_SURFCB32_GETBLTSTATUS         0x00000100l
#define DDHAL_SURFCB32_GETFLIPSTATUS        0x00000200l
#define DDHAL_SURFCB32_UPDATEOVERLAY        0x00000400l
#define DDHAL_SURFCB32_SETOVERLAYPOSITION   0x00000800l
#define DDHAL_SURFCB32_RESERVED4        0x00001000l
#define DDHAL_SURFCB32_SETPALETTE       0x00002000l

// This structure can be queried from the driver from DX5 onward
// using GetDriverInfo with GUID_MiscellaneousCallbacks

typedef DWORD   (FAR PASCAL *LPDDHAL_GETAVAILDRIVERMEMORY)(LPDDHAL_GETAVAILDRIVERMEMORYDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_UPDATENONLOCALHEAP)(LPDDHAL_UPDATENONLOCALHEAPDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_GETHEAPALIGNMENT)(LPDDHAL_GETHEAPALIGNMENTDATA);
/*
 * This prototype is identical to that of GetBltStatus
 */

typedef struct _DDHAL_DDMISCELLANEOUSCALLBACKS {
    DWORD                               dwSize;
    DWORD                               dwFlags;
    LPDDHAL_GETAVAILDRIVERMEMORY        GetAvailDriverMemory;
    LPDDHAL_UPDATENONLOCALHEAP          UpdateNonLocalHeap;
    LPDDHAL_GETHEAPALIGNMENT            GetHeapAlignment;
    /*
     * The GetSysmemBltStatus callback uses the same prototype as GetBltStatus.
     * It is legal to point both pointers to the same driver routine.
     */
    LPDDHALSURFCB_GETBLTSTATUS          GetSysmemBltStatus;
} DDHAL_DDMISCELLANEOUSCALLBACKS, *LPDDHAL_DDMISCELLANEOUSCALLBACKS;

#define DDHAL_MISCCB32_GETAVAILDRIVERMEMORY    0x00000001l
#define DDHAL_MISCCB32_UPDATENONLOCALHEAP      0x00000002l
#define DDHAL_MISCCB32_GETHEAPALIGNMENT        0x00000004l
#define DDHAL_MISCCB32_GETSYSMEMBLTSTATUS      0x00000008l

#define DDMISCELLANEOUSCALLBACKSSIZE sizeof(DDHAL_DDMISCELLANEOUSCALLBACKS)

//@@BEGIN_DDKSPLIT
// This structure can be queried from the driver from NT5 onward
// using GetDriverInfo with GUID_NTCallbacks

typedef DWORD   (FAR PASCAL *LPDDHAL_SETEXCLUSIVEMODE)(LPDDHAL_SETEXCLUSIVEMODEDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_FLIPTOGDISURFACE)(LPDDHAL_FLIPTOGDISURFACEDATA);

typedef struct _DDHAL_DDNTCALLBACKS {
    DWORD                       dwSize;
    DWORD                       dwFlags;
    LPVOID                      FreeDriverMemory; // kernel-mode only
    LPDDHAL_SETEXCLUSIVEMODE    SetExclusiveMode;
    LPDDHAL_FLIPTOGDISURFACE    FlipToGDISurface;
} DDHAL_DDNTCALLBACKS, *LPDDHAL_DDNTCALLBACKS;

#define DDHAL_NTCB32_FREEDRIVERMEMORY   0x00000001l
#define DDHAL_NTCB32_SETEXCLUSIVEMODE   0x00000002l
#define DDHAL_NTCB32_FLIPTOGDISURFACE   0x00000004l

#define DDNTCALLBACKSSIZE sizeof(DDHAL_DDNTCALLBACKS)


// This structure can be queried from the driver from Whistler onward
// using GetDriverInfo with GUID_NTCallbacks

typedef DWORD   (FAR PASCAL *LPDDHAL_ACQUIREVPORTNOTIFICATION)(LPDDRAWI_DDVIDEOPORT_LCL,HANDLE*,LPDDVIDEOPORTNOTIFY);
typedef DWORD   (FAR PASCAL *LPDDHAL_RELEASEVPORTNOTIFICATION)(LPDDRAWI_DDVIDEOPORT_LCL,HANDLE);

typedef struct _DDHAL_DDVPE2CALLBACKS {
    DWORD                               dwSize;
    DWORD                               dwFlags;
    LPDDHAL_ACQUIREVPORTNOTIFICATION    AcquireNotification;
    LPDDHAL_RELEASEVPORTNOTIFICATION    ReleaseNotification;
} DDHAL_DDVPE2CALLBACKS, *LPDDHAL_DDVPE2CALLBACKS;

#define DDHAL_VPE2CB32_ACQUIRENOTIFICATION  0x00000001l
#define DDHAL_VPE2CB32_RELEASENOTIFICATION  0x00000002l

#define DDVPE2CALLBACKSSIZE sizeof(DDHAL_DDVPE2CALLBACKS)
//@@END_DDKSPLIT

// DDHAL_DDMISCELLANEOUS2CALLBACKS:
//   This structure can be queried from the driver from DX7 onward
//   using GetDriverInfo with GUID_Miscellaneous2Callbacks

typedef DWORD   (FAR PASCAL *LPDDHAL_CREATESURFACEEX)(LPDDHAL_CREATESURFACEEXDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_GETDRIVERSTATE)(LPDDHAL_GETDRIVERSTATEDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_DESTROYDDLOCAL)(LPDDHAL_DESTROYDDLOCALDATA);
//@@BEGIN_DDKSPLIT
typedef DWORD   (FAR PASCAL *LPDDHAL_ALPHABLT)(LPDDHAL_BLTDATA);
#ifdef POSTPONED2
typedef DWORD   (FAR PASCAL *LPDDHAL_SETSPRITEDISPLAYLIST)(LPDDHAL_SETSPRITEDISPLAYLISTDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_RESIZE)(LPDDHAL_RESIZEDATA);
typedef DWORD   (FAR PASCAL *LPDDHAL_CAPTURECOMPOSITIONBUFFER)(LPDDHAL_CAPTURECOMPOSITIONBUFFERDATA);
#endif //POSTPONED2
//@@END_DDKSPLIT

typedef struct _DDHAL_DDMISCELLANEOUS2CALLBACKS {
    DWORD                               dwSize;
    DWORD                               dwFlags;
//@@BEGIN_DDKSPLIT
#if 1
    LPDDHAL_ALPHABLT                    AlphaBlt;
#else
//@@END_DDKSPLIT
    LPVOID                              Reserved;
//@@BEGIN_DDKSPLIT
#endif
//@@END_DDKSPLIT
    LPDDHAL_CREATESURFACEEX             CreateSurfaceEx;
    LPDDHAL_GETDRIVERSTATE              GetDriverState;
    LPDDHAL_DESTROYDDLOCAL              DestroyDDLocal;
//@@BEGIN_DDKSPLIT
#ifdef POSTPONED2
    LPDDHAL_SETSPRITEDISPLAYLIST        SetSpriteDisplayList;
    LPDDHAL_RESIZE                      Resize;
    LPDDHAL_CAPTURECOMPOSITIONBUFFER    CaptureCompositionBuffer;
#endif //POSTPONED2
//@@END_DDKSPLIT
} DDHAL_DDMISCELLANEOUS2CALLBACKS, *LPDDHAL_DDMISCELLANEOUS2CALLBACKS;

#define DDHAL_MISC2CB32_CREATESURFACEEX        0x00000002l
#define DDHAL_MISC2CB32_GETDRIVERSTATE         0x00000004l
#define DDHAL_MISC2CB32_DESTROYDDLOCAL         0x00000008l

//@@BEGIN_DDKSPLIT
#define DDHAL_MISC2CB32_ALPHABLT               0x00000001l
// ***** POSTPONED2 fields must NOT be ahead of other field as dwFlags bits must be contiguous
// ValidateCallbacks() is enforing this ******
#ifdef POSTPONED2
#define DDHAL_MISC2CB32_SETSPRITEDISPLAYLIST   0x00000008l
#define DDHAL_MISC2CB32_RESIZE                 0x00000010l
#define DDHAL_MISC2CB32_CAPTURECOMPOSITIONBUFFER 0x00000020l
#endif //POSTPONED2
//@@END_DDKSPLIT

#define DDMISCELLANEOUS2CALLBACKSSIZE sizeof(DDHAL_DDMISCELLANEOUS2CALLBACKS)


/*
 * DIRECTDRAWEXEBUF pseudo object callbacks
 *
 * NOTE: Execute buffers are not a distinct object type, they piggy back off
 * the surface data structures and high level API. However, they have their
 * own HAL callbacks as they may have different driver semantics from "normal"
 * surfaces. They also piggy back off the HAL data structures.
 *
 * !!! NOTE: Need to resolve whether we export execute buffer copying as a
 * blit or some other from of copy instruction.
 */
typedef DWORD   (FAR PASCAL *LPDDHALEXEBUFCB_CANCREATEEXEBUF)(LPDDHAL_CANCREATESURFACEDATA );
typedef DWORD   (FAR PASCAL *LPDDHALEXEBUFCB_CREATEEXEBUF)(LPDDHAL_CREATESURFACEDATA);
typedef DWORD   (FAR PASCAL *LPDDHALEXEBUFCB_DESTROYEXEBUF)(LPDDHAL_DESTROYSURFACEDATA);
typedef DWORD   (FAR PASCAL *LPDDHALEXEBUFCB_LOCKEXEBUF)(LPDDHAL_LOCKDATA);
typedef DWORD   (FAR PASCAL *LPDDHALEXEBUFCB_UNLOCKEXEBUF)(LPDDHAL_UNLOCKDATA);

typedef struct _DDHAL_DDEXEBUFCALLBACKS
{
    DWORD               dwSize;
    DWORD               dwFlags;
    LPDDHALEXEBUFCB_CANCREATEEXEBUF CanCreateExecuteBuffer;
    LPDDHALEXEBUFCB_CREATEEXEBUF    CreateExecuteBuffer;
    LPDDHALEXEBUFCB_DESTROYEXEBUF   DestroyExecuteBuffer;
    LPDDHALEXEBUFCB_LOCKEXEBUF      LockExecuteBuffer;
    LPDDHALEXEBUFCB_UNLOCKEXEBUF    UnlockExecuteBuffer;
} DDHAL_DDEXEBUFCALLBACKS;
typedef DDHAL_DDEXEBUFCALLBACKS FAR *LPDDHAL_DDEXEBUFCALLBACKS;

#define DDEXEBUFCALLBACKSSIZE sizeof( DDHAL_DDEXEBUFCALLBACKS )

#define DDHAL_EXEBUFCB32_CANCREATEEXEBUF    0x00000001l
#define DDHAL_EXEBUFCB32_CREATEEXEBUF       0x00000002l
#define DDHAL_EXEBUFCB32_DESTROYEXEBUF      0x00000004l
#define DDHAL_EXEBUFCB32_LOCKEXEBUF     0x00000008l
#define DDHAL_EXEBUFCB32_UNLOCKEXEBUF       0x00000010l

/*
 * DIRECTVIDEOPORT object callbacks
 */
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_CANCREATEVIDEOPORT)(LPDDHAL_CANCREATEVPORTDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_CREATEVIDEOPORT)(LPDDHAL_CREATEVPORTDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_FLIP)(LPDDHAL_FLIPVPORTDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_GETBANDWIDTH)(LPDDHAL_GETVPORTBANDWIDTHDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_GETINPUTFORMATS)(LPDDHAL_GETVPORTINPUTFORMATDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_GETOUTPUTFORMATS)(LPDDHAL_GETVPORTOUTPUTFORMATDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_GETFIELD)(LPDDHAL_GETVPORTFIELDDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_GETLINE)(LPDDHAL_GETVPORTLINEDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_GETVPORTCONNECT)(LPDDHAL_GETVPORTCONNECTDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_DESTROYVPORT)(LPDDHAL_DESTROYVPORTDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_GETFLIPSTATUS)(LPDDHAL_GETVPORTFLIPSTATUSDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_UPDATE)(LPDDHAL_UPDATEVPORTDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_WAITFORSYNC)(LPDDHAL_WAITFORVPORTSYNCDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_GETSIGNALSTATUS)(LPDDHAL_GETVPORTSIGNALDATA);
typedef DWORD (FAR PASCAL *LPDDHALVPORTCB_COLORCONTROL)(LPDDHAL_VPORTCOLORDATA);

typedef struct _DDHAL_DDVIDEOPORTCALLBACKS
{
    DWORD               dwSize;
    DWORD               dwFlags;
    LPDDHALVPORTCB_CANCREATEVIDEOPORT   CanCreateVideoPort;
    LPDDHALVPORTCB_CREATEVIDEOPORT      CreateVideoPort;
    LPDDHALVPORTCB_FLIP                 FlipVideoPort;
    LPDDHALVPORTCB_GETBANDWIDTH         GetVideoPortBandwidth;
    LPDDHALVPORTCB_GETINPUTFORMATS      GetVideoPortInputFormats;
    LPDDHALVPORTCB_GETOUTPUTFORMATS     GetVideoPortOutputFormats;
    LPVOID              lpReserved1;
    LPDDHALVPORTCB_GETFIELD             GetVideoPortField;
    LPDDHALVPORTCB_GETLINE              GetVideoPortLine;
    LPDDHALVPORTCB_GETVPORTCONNECT      GetVideoPortConnectInfo;
    LPDDHALVPORTCB_DESTROYVPORT         DestroyVideoPort;
    LPDDHALVPORTCB_GETFLIPSTATUS        GetVideoPortFlipStatus;
    LPDDHALVPORTCB_UPDATE               UpdateVideoPort;
    LPDDHALVPORTCB_WAITFORSYNC          WaitForVideoPortSync;
    LPDDHALVPORTCB_GETSIGNALSTATUS      GetVideoSignalStatus;
    LPDDHALVPORTCB_COLORCONTROL         ColorControl;
} DDHAL_DDVIDEOPORTCALLBACKS;
typedef DDHAL_DDVIDEOPORTCALLBACKS FAR *LPDDHAL_DDVIDEOPORTCALLBACKS;

#define DDVIDEOPORTCALLBACKSSIZE sizeof( DDHAL_DDVIDEOPORTCALLBACKS )

#define DDHAL_VPORT32_CANCREATEVIDEOPORT    0x00000001l
#define DDHAL_VPORT32_CREATEVIDEOPORT           0x00000002l
#define DDHAL_VPORT32_FLIP                      0x00000004l
#define DDHAL_VPORT32_GETBANDWIDTH              0x00000008l
#define DDHAL_VPORT32_GETINPUTFORMATS           0x00000010l
#define DDHAL_VPORT32_GETOUTPUTFORMATS          0x00000020l
#define DDHAL_VPORT32_GETFIELD                  0x00000080l
#define DDHAL_VPORT32_GETLINE                   0x00000100l
#define DDHAL_VPORT32_GETCONNECT                0x00000200l
#define DDHAL_VPORT32_DESTROY                   0x00000400l
#define DDHAL_VPORT32_GETFLIPSTATUS             0x00000800l
#define DDHAL_VPORT32_UPDATE                    0x00001000l
#define DDHAL_VPORT32_WAITFORSYNC               0x00002000l
#define DDHAL_VPORT32_GETSIGNALSTATUS           0x00004000l
#define DDHAL_VPORT32_COLORCONTROL      0x00008000l

/*
 * DIRECTDRAWCOLORCONTROL object callbacks
 */
typedef DWORD (FAR PASCAL *LPDDHALCOLORCB_COLORCONTROL)(LPDDHAL_COLORCONTROLDATA);

typedef struct _DDHAL_DDCOLORCONTROLCALLBACKS
{
    DWORD               dwSize;
    DWORD               dwFlags;
    LPDDHALCOLORCB_COLORCONTROL         ColorControl;
} DDHAL_DDCOLORCONTROLCALLBACKS;
typedef DDHAL_DDCOLORCONTROLCALLBACKS FAR *LPDDHAL_DDCOLORCONTROLCALLBACKS;

#define DDCOLORCONTROLCALLBACKSSIZE sizeof( DDHAL_DDCOLORCONTROLCALLBACKS )

#define DDHAL_COLOR_COLORCONTROL        0x00000001l

/*
 * DIRECTDRAWSURFACEKERNEL object callbacks
 * This structure can be queried from the driver from DX5 onward
 * using GetDriverInfo with GUID_KernelCallbacks
 */
typedef DWORD (FAR PASCAL *LPDDHALKERNELCB_SYNCSURFACE)(LPDDHAL_SYNCSURFACEDATA);
typedef DWORD (FAR PASCAL *LPDDHALKERNELCB_SYNCVIDEOPORT)(LPDDHAL_SYNCVIDEOPORTDATA);

typedef struct _DDHAL_DDKERNELCALLBACKS
{
    DWORD                               dwSize;
    DWORD                               dwFlags;
    LPDDHALKERNELCB_SYNCSURFACE     SyncSurfaceData;
    LPDDHALKERNELCB_SYNCVIDEOPORT   SyncVideoPortData;
} DDHAL_DDKERNELCALLBACKS, *LPDDHAL_DDKERNELCALLBACKS;

#define DDHAL_KERNEL_SYNCSURFACEDATA        0x00000001l
#define DDHAL_KERNEL_SYNCVIDEOPORTDATA      0x00000002l

#define DDKERNELCALLBACKSSIZE sizeof(DDHAL_DDKERNELCALLBACKS)

typedef HRESULT (WINAPI *LPDDGAMMACALIBRATORPROC)( LPDDGAMMARAMP, LPBYTE);

/*
 * DIRECTDRAWMOTIONCOMP object callbacks
 */
typedef DWORD (FAR PASCAL *LPDDHALMOCOMPCB_GETGUIDS)( LPDDHAL_GETMOCOMPGUIDSDATA);
typedef DWORD (FAR PASCAL *LPDDHALMOCOMPCB_GETFORMATS)( LPDDHAL_GETMOCOMPFORMATSDATA);
typedef DWORD (FAR PASCAL *LPDDHALMOCOMPCB_CREATE)( LPDDHAL_CREATEMOCOMPDATA);
typedef DWORD (FAR PASCAL *LPDDHALMOCOMPCB_GETCOMPBUFFINFO)( LPDDHAL_GETMOCOMPCOMPBUFFDATA);
typedef DWORD (FAR PASCAL *LPDDHALMOCOMPCB_GETINTERNALINFO)( LPDDHAL_GETINTERNALMOCOMPDATA);
typedef DWORD (FAR PASCAL *LPDDHALMOCOMPCB_BEGINFRAME)( LPDDHAL_BEGINMOCOMPFRAMEDATA);
typedef DWORD (FAR PASCAL *LPDDHALMOCOMPCB_ENDFRAME)( LPDDHAL_ENDMOCOMPFRAMEDATA);
typedef DWORD (FAR PASCAL *LPDDHALMOCOMPCB_RENDER)( LPDDHAL_RENDERMOCOMPDATA);
typedef DWORD (FAR PASCAL *LPDDHALMOCOMPCB_QUERYSTATUS)( LPDDHAL_QUERYMOCOMPSTATUSDATA);
typedef DWORD (FAR PASCAL *LPDDHALMOCOMPCB_DESTROY)( LPDDHAL_DESTROYMOCOMPDATA);

typedef struct _DDHAL_DDMOTIONCOMPCALLBACKS
{
    DWORD                           dwSize;
    DWORD                           dwFlags;
    LPDDHALMOCOMPCB_GETGUIDS        GetMoCompGuids;
    LPDDHALMOCOMPCB_GETFORMATS      GetMoCompFormats;
    LPDDHALMOCOMPCB_CREATE          CreateMoComp;
    LPDDHALMOCOMPCB_GETCOMPBUFFINFO GetMoCompBuffInfo;
    LPDDHALMOCOMPCB_GETINTERNALINFO GetInternalMoCompInfo;
    LPDDHALMOCOMPCB_BEGINFRAME      BeginMoCompFrame;
    LPDDHALMOCOMPCB_ENDFRAME        EndMoCompFrame;
    LPDDHALMOCOMPCB_RENDER          RenderMoComp;
    LPDDHALMOCOMPCB_QUERYSTATUS     QueryMoCompStatus;
    LPDDHALMOCOMPCB_DESTROY         DestroyMoComp;
} DDHAL_DDMOTIONCOMPCALLBACKS;
typedef DDHAL_DDMOTIONCOMPCALLBACKS FAR *LPDDHAL_DDMOTIONCOMPCALLBACKS;

#define DDMOTIONCOMPCALLBACKSSIZE sizeof( DDHAL_DDMOTIONCOMPCALLBACKS )

#define DDHAL_MOCOMP32_GETGUIDS         0x00000001
#define DDHAL_MOCOMP32_GETFORMATS       0x00000002
#define DDHAL_MOCOMP32_CREATE           0x00000004
#define DDHAL_MOCOMP32_GETCOMPBUFFINFO  0x00000008
#define DDHAL_MOCOMP32_GETINTERNALINFO  0x00000010
#define DDHAL_MOCOMP32_BEGINFRAME       0x00000020
#define DDHAL_MOCOMP32_ENDFRAME         0x00000040
#define DDHAL_MOCOMP32_RENDER           0x00000080
#define DDHAL_MOCOMP32_QUERYSTATUS      0x00000100
#define DDHAL_MOCOMP32_DESTROY          0x00000200

//@@BEGIN_DDKSPLIT
#ifdef POSTPONED
/*
 * DDHAL_DDUMODEDRVINFO object callbacks
 * Contains the data required for supporting user mode drivers.
 * This structure can be queried from the driver from DX6 onwards using:
 * GetDriverInfo with GUID_UserModeDriverInfo
 */
typedef struct _DDHAL_DDUMODEDRVINFO
{
    DWORD               dwSize;
    DWORD               dwFlags;
    LPSTR               lpszDllName;
    GUID                uniqueGuid;
    ULONG_PTR            dwReserved1;
} DDHAL_DDUMODEDRVINFO, *LPDDHAL_DDUMODEDRVINFO;
#define DDHAL_DDUMODEDRVINFOSIZE    sizeof( DDHAL_DDUMODEDRVINFO )

#define DDHAL_UMODEDRV_DLLNAME              0x00000001
#define DDHAL_UMODEDRV_UNIQGUID             0x00000002
#define DDHAL_UMODEDRV_ALL                  0x00000003


/*
 * DDHAL_DDUMODEDRVPASSWD object callbacks
 * This structure is used to query the usermode driver for its password GUID
 * (GetDriverInfo with GUID_UserModeDriverPassword)
 */
typedef struct _DDHAL_DDUMODEDRVPASSWD
{
    DWORD               dwSize;
    DWORD               dwFlags;
    GUID                passwdGuid;
} DDHAL_DDUMODEDRVPASSWD, *LPDDHAL_DDUMODEDRVPASSWD;
#define DDHAL_DDUMODEDRVPASSWDSIZE    sizeof( DDHAL_DDUMODEDRVPASSWD )

#define DDHAL_UMODEDRV_GUID              0x00000001


/*
 * This structure is used to store relevant information about the
 * user-mode driver in DDRAW_GBL
 */
typedef struct _DDUMODEDRVINFO
{
    LPVOID                   lpszDllName; // need not be saved
    HMODULE                  hUmodeDll;
    GUID                     uniqueGuid;  // need not be saved
    LPDDHAL_GETDRIVERINFO    GetDriverInfo;
} DDUMODEDRVINFO, *LPDDUMODEDRVINFO;

//
// DDOPTSURFACE
// Contains the callbacks and data required for supporting Optimized surfaces.
// This structure can be queried from the driver from DX6 onwards using:
// GetDriverInfo with GUID_OptSurfaceKmodeInfo and
// GetUmodeDriverInfo with GUID_OptSurfaceUmodeInfo.
//
typedef DWORD (FAR PASCAL *LPDDHALOPTSURFCB_CANOPTIMIZESURFACE)( LPDDHAL_CANOPTIMIZESURFACEDATA);
typedef DWORD (FAR PASCAL *LPDDHALOPTSURFCB_OPTIMIZESURFACE)( LPDDHAL_OPTIMIZESURFACEDATA);
typedef DWORD (FAR PASCAL *LPDDHALOPTSURFCB_UNOPTIMIZESURFACE)( LPDDHAL_UNOPTIMIZESURFACEDATA);
typedef DWORD (FAR PASCAL *LPDDHALOPTSURFCB_COPYOPTSURFACE)( LPDDHAL_COPYOPTSURFACEDATA);

typedef DWORD (FAR PASCAL *LPDDHALOPTSURFCB_KMODESVC)( LPDDHAL_KMODESVCDATA);

//
// This structure is used to store the Opt Surface information
// in DDRAWI_GBL
//
typedef struct _DDOPTSURFACEINFO
{
    // Umode information
    DWORD               dwNumGuids;
    LPGUID              lpGuidArray;
    LPDDHALOPTSURFCB_CANOPTIMIZESURFACE    CanOptimizeSurface;
    LPDDHALOPTSURFCB_OPTIMIZESURFACE       OptimizeSurface;
    LPDDHALOPTSURFCB_UNOPTIMIZESURFACE     UnOptimizeSurface;
    LPDDHALOPTSURFCB_COPYOPTSURFACE        CopyOptSurface;

    // Kmode information
    LPDDHALOPTSURFCB_KMODESVC                KmodeService;
} DDOPTSURFACEINFO, *LPDDOPTSURFACEINFO;

//
// This structure is used for obtaining Opt Surface kernel mode data
//
typedef struct _DDHAL_DDOPTSURFACEKMODEINFO
{
    DWORD               dwSize;
    DWORD               dwFlags;
    LPDDHALOPTSURFCB_KMODESVC KmodeService;
    ULONG_PTR            dwReserved2;
} DDHAL_DDOPTSURFACEKMODEINFO, *LPDDHAL_DDOPTSURFACEKMODEINFO;
#define DDOPTSURFACEKMODEINFOSIZE   sizeof( DDHAL_DDOPTSURFACEKMODEINFO )

#define DDHAL_OPTSURFKMODE_KMODESVC                 0x00000001
#define DDHAL_OPTSURFKMODE_ALL                      0x00000001

//
// This structure is used for obtaining Opt Surface user mode data
//
typedef struct _DDHAL_DDOPTSURFACEUMODEINFO
{
    DWORD               dwSize;
    DWORD               dwFlags;
    DWORD               dwNumGuids;
    LPGUID              lpGuidArray;
    LPDDHALOPTSURFCB_CANOPTIMIZESURFACE    CanOptimizeSurface;
    LPDDHALOPTSURFCB_OPTIMIZESURFACE       OptimizeSurface;
    LPDDHALOPTSURFCB_UNOPTIMIZESURFACE     UnOptimizeSurface;
    LPDDHALOPTSURFCB_COPYOPTSURFACE        CopyOptSurface;
    ULONG_PTR            dwReserved1;
    ULONG_PTR            dwReserved2;
} DDHAL_DDOPTSURFACEUMODEINFO, *LPDDHAL_DDOPTSURFACEUMODEINFO;
#define DDOPTSURFACEUMODEINFOSIZE    sizeof( DDHAL_DDOPTSURFACEUMODEINFO )

#define DDHAL_OPTSURFUMODE_NUMGUIDS                 0x00000001
#define DDHAL_OPTSURFUMODE_GUIDARRAY                0x00000002
#define DDHAL_OPTSURFUMODE_CANOPTIMIZESURFACE       0x00000004
#define DDHAL_OPTSURFUMODE_OPTIMIZESURFACE          0x00000008
#define DDHAL_OPTSURFUMODE_UNOPTIMIZESURFACE        0x00000010
#define DDHAL_OPTSURFUMODE_COPYOPTSURFACE           0x00000020
#define DDHAL_OPTSURFUMODE_ALL                      0x0000003f

#endif //POSTPONED
//@@END_DDKSPLIT

/*
 * CALLBACK RETURN VALUES
 *                      * these are values returned by the driver from the above callback routines
 */
/*
 * indicates that the display driver didn't do anything with the call
 */
#define DDHAL_DRIVER_NOTHANDLED     0x00000000l

/*
 * indicates that the display driver handled the call; HRESULT value is valid
 */
#define DDHAL_DRIVER_HANDLED        0x00000001l

/*
 * indicates that the display driver couldn't handle the call because it
 * ran out of color key hardware resources
 */
#define DDHAL_DRIVER_NOCKEYHW       0x00000002l

/*
 * Capabilities structure for non-local video memory
 */
typedef struct _DDNONLOCALVIDMEMCAPS
{
    DWORD   dwSize;
    DWORD   dwNLVBCaps;       // driver specific capabilities for non-local->local vidmem blts
    DWORD   dwNLVBCaps2;          // more driver specific capabilities non-local->local vidmem blts
    DWORD   dwNLVBCKeyCaps;       // driver color key capabilities for non-local->local vidmem blts
    DWORD   dwNLVBFXCaps;         // driver FX capabilities for non-local->local blts
    DWORD   dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
} DDNONLOCALVIDMEMCAPS;
typedef struct _DDNONLOCALVIDMEMCAPS FAR *LPDDNONLOCALVIDMEMCAPS;


/*
 * More driver surface capabilities (in addition to those described in DDCORECAPS).
 * This struct contains the caps bits added to the DDCAPS.ddsCaps structure in DX6.
 */
typedef struct _DDMORESURFACECAPS
{
    DWORD       dwSize;             // size of DDMORESURFACECAPS structure
    DDSCAPSEX   ddsCapsMore;
    /*
     * The DDMORESURFACECAPS struct is of variable size. The following list may be
     * filled in by DX6-aware drivers (see DDVERSIONINFO) to restrict their
     * video memory heaps (those which are exposed to DirectDraw) to
     * certain sets of DDSCAPS_ bits. Thse entries are exactly analogous to
     * the ddsCaps and ddsCapsAlt members of the VIDMEM structures listed in
     * the VIDMEMINFO.pvmList member of DDHALINFO.vmiData. There should be
     * exactly DDHALINFO.vmiData.dwNumHeaps copies of tagExtendedHeapRestrictions
     * in this struct. The size of this struct is thus:
     *  DDMORESURFACECAPS.dwSize = sizeof(DDMORESURFACECAPS) +
     *          (DDHALINFO.vmiData.dwNumHeaps-1) * sizeof(DDSCAPSEX)*2;
     * Note the -1 accounts for the fact that DDMORESURFACECAPS is declared to have 1
     * tagExtendedHeapRestrictions member.
     */
    struct tagExtendedHeapRestrictions
    {
        DDSCAPSEX   ddsCapsEx;
        DDSCAPSEX   ddsCapsExAlt;
    } ddsExtendedHeapRestrictions[1];
} DDMORESURFACECAPS, FAR * LPDDMORESURFACECAPS;

// Stereo, driver returns DD_OK if mode is ok for stereo
typedef struct _DDSTEREOMODE
{
    DWORD       dwSize;             // size of DDSTEREOMODECAPS structure

    DWORD       dwHeight;
    DWORD       dwWidth;
    DWORD       dwBpp;
    DWORD       dwRefreshRate;

    BOOL        bSupported;         // driver supports this video mode...

} DDSTEREOMODE, FAR * LPDDSTEREOMODE;


//@@BEGIN_DDKSPLIT
// For DX7, we define more DDraw driver caps (in addition to those in DDCORECAPS).
typedef struct _DDMORECAPS
{
    DWORD   dwSize;             // size of DDMORECAPS structure
    DWORD   dwAlphaCaps;        // driver-specific alpha caps for overlays & Vmem->Vmem blts
    DWORD   dwSVBAlphaCaps;     // driver-specific alpha capabilities for System->Vmem blts
    DWORD   dwVSBAlphaCaps;     // driver-specific alpha capabilities for Vmem->System blts
    DWORD   dwSSBAlphaCaps;     // driver-specific alpha capabilities for System->System blts
    DWORD   dwFilterCaps;       // driver-specific filter caps for overlays & Vmem->Vmem blts
    DWORD   dwSVBFilterCaps;    // driver-specific filter capabilities for System->Vmem blts
    DWORD   dwVSBFilterCaps;    // driver-specific filter capabilities for Vmem->System blts
    DWORD   dwSSBFilterCaps;    // driver-specific filter capabilities for System->System blts
#ifdef POSTPONED2
    DWORD   dwTransformCaps;        // driver-specific transform caps for overlays & Vmem->Vmem blts
    DWORD   dwSVBTransformCaps;     // driver-specific transform capabilities for System->Vmem blts
    DWORD   dwVSBTransformCaps;     // driver-specific transform capabilities for Vmem->System blts
    DWORD   dwSSBTransformCaps;     // driver-specific transformn capabilities for System->System blts
    DWORD   dwBltAffineMinifyLimit;   // minification limit for affine-transformed blits
    DWORD   dwOverlayAffineMinifyLimit; // minification limit for affine-transformed overlays
#endif
} DDMORECAPS, FAR * LPDDMORECAPS;
//@@END_DDKSPLIT


//@@BEGIN_DDKSPLIT
/*
 * Private:
 * Client data list element and head pointer
 */
typedef struct _PRIVATEDATANODE
{
    GUID                    guid;
    LPBYTE                  pData;
    DWORD                   cbData;
    DWORD                   dwFlags;
    DWORD                   dwContentsStamp;
    struct _PRIVATEDATANODE *pNext;
} PRIVATEDATANODE, FAR* LPPRIVATEDATANODE;

//@@END_DDKSPLIT

/*
 * DDRAW palette interface struct
 */
typedef struct _DDRAWI_DDRAWPALETTE_INT
{
    LPVOID                      lpVtbl;     // pointer to array of interface methods
    LPDDRAWI_DDRAWPALETTE_LCL   lpLcl;      // pointer to interface data
    LPDDRAWI_DDRAWPALETTE_INT   lpLink;     // link to next interface
    DWORD                       dwIntRefCnt;    // interface reference count
//@@BEGIN_DDKSPLIT
    ULONG_PTR                    dwReserved1;    // for DDrawEx
    ULONG_PTR                    dwReserved2;    // for DDrawEx
//@@END_DDKSPLIT
} DDRAWI_DDRAWPALETTE_INT;

/*
 * DDRAW internal version of DIRECTDRAWPALETTE object; it has data after the vtable
 */
typedef struct _DDRAWI_DDRAWPALETTE_GBL
{
    DWORD                       dwRefCnt;   // reference count
    DWORD                       dwFlags;    // flags
    LPDDRAWI_DIRECTDRAW_LCL     lpDD_lcl;   // PRIVATE: DIRECTDRAW object
    DWORD                       dwProcessId;    // owning process
    LPPALETTEENTRY              lpColorTable;   // array of palette entries
    union
    {
        ULONG_PTR               dwReserved1;    // reserved for use by display driver which created this object
        HPALETTE                hHELGDIPalette;
    };
    /*
     * Fields added in version 5.0. Check if the ddraw version >= 5 (passed during
     * driver initialization) to see if these fields will be present.
     */
    DWORD                       dwDriverReserved; // For use by HAL, regardless of who created object
    DWORD                       dwContentsStamp;  // Incremented when palette changes.
    /*
     * Fields added in version 6
     */
    DWORD                       dwSaveStamp;  // Incremented when palette changes.
    /*
     * And in version 7
     */
    DWORD                       dwHandle;       //Handle used in drawprim2 palette notification

} DDRAWI_DDRAWPALETTE_GBL;

//@@BEGIN_DDKSPLIT
/* Macro to bump the contents stamp so drivers can cheaply check for changed palette data.
 * Zero means no information
 */
#define BUMP_PALETTE_STAMP(pal_gbl)                  \
if ( pal_gbl->dwContentsStamp )                      \
{                                                    \
    pal_gbl->dwContentsStamp++;                      \
    if ( 0 == pal_gbl->dwContentsStamp)              \
        pal_gbl->dwContentsStamp++;                  \
}
//@@END_DDKSPLIT

/*
 * (CMcC) The palette no longer maintains a back pointer to the owning surface
 * (there may now be many owning surfaces). So the lpDDSurface is now dwReserved0
 * (this mod. assumes that sizeof(DWORD) == sizeof(LPDDRAWI_DDRAWSURFACE_LCL). A
 * fairly safe assumption I think.
 */
typedef struct _DDRAWI_DDRAWPALETTE_LCL
{
    DWORD                       lpPalMore;  // pointer to additional local data
    LPDDRAWI_DDRAWPALETTE_GBL   lpGbl;      // pointer to data
    ULONG_PTR                   dwUnused0;  // not currently used.
    DWORD                       dwLocalRefCnt;  // local ref cnt
    IUnknown                    FAR *pUnkOuter; // outer IUnknown
    LPDDRAWI_DIRECTDRAW_LCL     lpDD_lcl;   // pointer to owning local driver object
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
    /*
     * Added for DX6
     */
//@@BEGIN_DDKSPLIT
#if 1
    LPPRIVATEDATANODE           pPrivateDataHead;
    IUnknown *                  pAddrefedThisOwner; //This is the ddraw object that created this
                                                    //palette, if nonzero. Must Release it when palette
                                                    //is released.
    LPDDRAWI_DIRECTDRAW_INT     lpDD_Int;   // pointer to owning int
#else   //1
//@@END_DDKSPLIT
    ULONG_PTR                   dwDDRAWReserved1;
    ULONG_PTR                   dwDDRAWReserved2;
    ULONG_PTR                   dwDDRAWReserved3;
//@@BEGIN_DDKSPLIT
#endif  //1
//@@END_DDKSPLIT

} DDRAWI_DDRAWPALETTE_LCL;

// bit definition for dwFlags in DDRAWI_DDRAWPALETTE_GBL and
// dwPaletteFlags in D3DHAL_DP2SETPALETTE
#define DDRAWIPAL_256       0x00000001l // 256 entry palette
#define DDRAWIPAL_16        0x00000002l // 16 entry palette
#define DDRAWIPAL_GDI       0x00000004l // palette allocated through GDI
#define DDRAWIPAL_STORED_8  0x00000008l // palette stored as 8bpp/entry
#define DDRAWIPAL_STORED_16 0x00000010l // palette stored as 16bpp/entry
#define DDRAWIPAL_STORED_24 0x00000020l // palette stored as 24bpp/entry
#define DDRAWIPAL_EXCLUSIVE 0x00000040l // palette being used in exclusive mode
#define DDRAWIPAL_INHEL     0x00000080l // palette is done in the hel
#define DDRAWIPAL_DIRTY         0x00000100l     // gdi palette out 'o sync
#define DDRAWIPAL_ALLOW256  0x00000200l // can fully update palette
#define DDRAWIPAL_4             0x00000400l     // 4 entry palette
#define DDRAWIPAL_2             0x00000800l     // 2 entry palette
#define DDRAWIPAL_STORED_8INDEX 0x00001000l     // palette stored as 8-bit index into dst palette
#define DDRAWIPAL_ALPHA     0x00002000l // palette entries contain alpha

/*
 * DDRAW clipper interface struct
 */
typedef struct _DDRAWI_DDRAWCLIPPER_INT
{
    LPVOID                          lpVtbl;     // pointer to array of interface methods
    LPDDRAWI_DDRAWCLIPPER_LCL       lpLcl;      // pointer to interface data
    LPDDRAWI_DDRAWCLIPPER_INT       lpLink;     // link to next interface
    DWORD                           dwIntRefCnt;    // interface reference count
//@@BEGIN_DDKSPLIT
    ULONG_PTR                        dwReserved1;    // for DDrawEx
    ULONG_PTR                        dwReserved2;    // for DDrawEx
//@@END_DDKSPLIT
} DDRAWI_DDRAWCLIPPER_INT;

/*
 * DDRAW internal version of DIRECTDRAWCLIPPER object; it has data after the vtable
 */
typedef struct _DDRAWI_DDRAWCLIPPER_GBL
{
    DWORD                   dwRefCnt;   // reference count
    DWORD                   dwFlags;    // flags
    LPDDRAWI_DIRECTDRAW_GBL lpDD;       // PRIVATE: DIRECTDRAW object
    DWORD                   dwProcessId;    // owning process
    ULONG_PTR               dwReserved1;    // reserved for use by display driver
    ULONG_PTR               hWnd;       // window
    LPRGNDATA               lpStaticClipList; // clip list set by app
} DDRAWI_DDRAWCLIPPER_GBL;

/*
 * (CMcC) As with palettes, the clipper no longer maintains a back pointer to the
 * owning surface (there may now be many owning surfaces). So the lpDDSurface
 * is now dwReserved0 (this mod. assumes that sizeof(DWORD) ==
 * sizeof(LPDDRAWI_DDRAWSURFACE_LCL). A fairly safe assumption I think.
 */
typedef struct _DDRAWI_DDRAWCLIPPER_LCL
{
    DWORD                       lpClipMore; // pointer to additional local data
    LPDDRAWI_DDRAWCLIPPER_GBL   lpGbl;      // pointer to data
    LPDDRAWI_DIRECTDRAW_LCL     lpDD_lcl;   // pointer to owning local DD object
    DWORD                       dwLocalRefCnt;  // local ref cnt
    IUnknown                    FAR *pUnkOuter; // outer IUnknown
    LPDDRAWI_DIRECTDRAW_INT     lpDD_int;   // pointer to owning DD object interface
    ULONG_PTR                   dwReserved1;    // reserved for use by display driver
    IUnknown *                  pAddrefedThisOwner; //This is the ddraw object that created this
                                                    //clipper, if nonzero. Must Release it when clipper
                                                    //is released.
} DDRAWI_DDRAWCLIPPER_LCL;

#define DDRAWICLIP_WATCHWINDOW          0x00000001l
#define DDRAWICLIP_ISINITIALIZED        0x00000002l
#define DDRAWICLIP_INMASTERSPRITELIST   0x00000004l   // clipper is referenced in master sprite list

/*
 * ATTACHLIST - internally used to maintain list of attached surfaces
 */
typedef struct _ATTACHLIST
{
    DWORD                               dwFlags;
    struct _ATTACHLIST                  FAR *lpLink;      // link to next attached surface
    struct _DDRAWI_DDRAWSURFACE_LCL FAR *lpAttached;  // attached surface local obj
    struct _DDRAWI_DDRAWSURFACE_INT FAR *lpIAttached; // attached surface interface
} ATTACHLIST;
typedef ATTACHLIST FAR *LPATTACHLIST;
#define DDAL_IMPLICIT       0x00000001l

/*
 * DBLNODE - a node in a doubly-linked list of surface interfaces
 */
typedef struct _DBLNODE
{
    struct  _DBLNODE                    FAR *next;  // link to next node
    struct  _DBLNODE                    FAR *prev;  // link to previous node
    LPDDRAWI_DDRAWSURFACE_LCL           object;     // link to object
    LPDDRAWI_DDRAWSURFACE_INT           object_int; // object interface
} DBLNODE;
typedef DBLNODE FAR *LPDBLNODE;

/*
 * ACCESSRECTLIST - internally used to all rectangles that are accessed on a surface
 */
typedef struct _ACCESSRECTLIST
{
    struct _ACCESSRECTLIST FAR  *lpLink;     // link to next attached surface
    RECT                        rDest;       // rectangle being used
    LPDDRAWI_DIRECTDRAW_LCL     lpOwner;     // owning local object
    LPVOID                      lpSurfaceData;   // associated screen ptr
    DWORD                       dwFlags;     // PRIVATE: flags
    LPHEAPALIASINFO             lpHeapAliasInfo; // PRIVATE: aliased heaps being used by this lock
} ACCESSRECTLIST;
typedef ACCESSRECTLIST FAR *LPACCESSRECTLIST;

#define ACCESSRECT_VRAMSTYLE           0x00000001L    // PRIVATE: this lock is vram style (vidmem or implict sysmem)
#define ACCESSRECT_NOTHOLDINGWIN16LOCK 0x00000002L    // PRIVATE: this lock is not holding the Win16 lock
#define ACCESSRECT_BROKEN              0x00000004L    // PRIVATE: this lock was broken by an invalidate - don't call HAL on unlock

#ifndef WIN95
/* 
 * Do not change the size of this struct. This will move various members of surface and ddraw
 * structs and will prevent binaries from running on old win2k systems (or mismatched later NT builds)
 */
typedef struct _DISPLAYMODEINFO
{
    WORD wWidth;
    WORD wHeight;
    BYTE wBPP;
    BYTE wMonitorsAttachedToDesktop;
    WORD wRefreshRate;
} DISPLAYMODEINFO;
typedef struct _DISPLAYMODEINFO *LPDISPLAYMODEINFO;

#define EQUAL_DISPLAYMODE(a, b) (0 == memcmp(&(a), &(b), sizeof (DISPLAYMODEINFO)))
#endif

//@@BEGIN_DDKSPLIT
/*
 * Interface addref/release tracking structs
 */
//#define REFTRACKING
#ifdef REFTRACKING
typedef struct _DDRAWI_REFTRACKNODE
{
    LPVOID                      pReturnAddress;
    DWORD                       dwAddrefCount;
    DWORD                       dwReleaseCount;
    struct _DDRAWI_REFTRACKNODE FAR *  pNext;
} DDRAWI_REFTRACKNODE,  FAR * LPDDRAWI_REFTRACKNODE;

typedef struct _DDRAWI_REFTRACK
{
    LPVOID                  pLastAddref;
    LPVOID                  pLastRelease;
    LPDDRAWI_REFTRACKNODE   pHead;
} DDRAW_REFTRACK;

//in ddisunk.c:
extern void AddRefTrack(LPVOID * p);
extern void ReleaseTrack(LPVOID * p);
extern void DumpRefTrack(LPVOID p);

#define REFTRACKVAR DDRAW_REFTRACK  RefTrack;
#define ADDREFTRACK(pInt)           AddRefTrack(&pInt)
#define RELEASETRACK(pInt)          ReleaseTrack(&pInt)
#define DUMPREFTRACK(pInt)          DumpRefTrack(pInt)

#else

#define REFTRACKVAR
#define ADDREFTRACK(a)
#define RELEASETRACK(a)
#define DUMPREFTRACK(pInt)

#endif //REFTRACKING
//@@END_DDKSPLIT

/*
 * DDRAW surface interface struct
 */
typedef struct _DDRAWI_DDRAWSURFACE_INT
{
    LPVOID                      lpVtbl;     // pointer to array of interface methods
    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl;      // pointer to interface data
    LPDDRAWI_DDRAWSURFACE_INT   lpLink;     // link to next interface
    DWORD                       dwIntRefCnt;    // interface reference count
//@@BEGIN_DDKSPLIT
    ULONG_PTR                    dwReserved1;    // for DDrawEx
    ULONG_PTR                    dwReserved2;    // for DDrawEx
    REFTRACKVAR
//@@END_DDKSPLIT
} DDRAWI_DDRAWSURFACE_INT;

/*
 * DDRAW internal version of DIRECTDRAWSURFACE struct
 *
 * the GBL structure is global data for all duplicate objects
 */
typedef struct _DDRAWI_DDRAWSURFACE_GBL
{
    DWORD               dwRefCnt;   // reference count
    DWORD               dwGlobalFlags;  // global flags
    union
    {
        LPACCESSRECTLIST lpRectList; // list of accesses
        DWORD           dwBlockSizeY;   // block size that display driver requested (return)
        LONG            lSlicePitch;    // slice pitch for volume textures
    };
    union
    {
        LPVMEMHEAP      lpVidMemHeap;   // heap vidmem was alloc'ed from
        DWORD           dwBlockSizeX;   // block size that display driver requested (return)
    };
    union
    {
        LPDDRAWI_DIRECTDRAW_GBL lpDD;       // internal DIRECTDRAW object
        LPVOID          lpDDHandle;     // handle to internal DIRECTDRAW object
                        // for use by display driver
                        // when calling fns in DDRAW16.DLL
    };
    FLATPTR             fpVidMem;   // pointer to video memory
    union
    {
        LONG            lPitch;     // pitch of surface
        DWORD           dwLinearSize;   // linear size of non-rectangular surface
    };
    WORD                wHeight;    // height of surface
    WORD                wWidth;     // width of surface
    DWORD               dwUsageCount;   // number of access to this surface
    ULONG_PTR           dwReserved1;    // reserved for use by display driver
    //
    // NOTE: this part of the structure is ONLY allocated if the pixel
    //       format differs from that of the primary display
    //
    DDPIXELFORMAT       ddpfSurface;    // pixel format of surface
} DDRAWI_DDRAWSURFACE_GBL;

/*
 * This is an extender structure that is allocated off the end of the SURFACE_GBL
 * structure. DO NOT place any structures whose size can change in here.
 */
#define GET_LPDDRAWSURFACE_GBL_MORE(psurf_gbl)      \
    (*(LPDDRAWI_DDRAWSURFACE_GBL_MORE *)        \
    ((BYTE *)psurf_gbl - sizeof(DWORD_PTR)))

/*
 * Return the physical memory pointer for a given surface global object.
 *
 * NOTE: The physical memory pointer is ONLY valid for surfaces allocated from
 * non-local video memory. This field will not be valid for system memory or
 * local video memory surfaces.
 */
#define SURFACE_PHYSICALVIDMEM( psurf_gbl ) \
    ( GET_LPDDRAWSURFACE_GBL_MORE( psurf_gbl )->fpPhysicalVidMem )

/*
 * NOTE: This structure contains a set of fields for describing linear to physical
 * page mappings in the case of page locked system memory. It can also contain the
 * physical surface pointer of a surface in non-local memory. As there is no point
 * in having both a linear to physical page translation table and a physical memory
 * pointer for the same surface they are placed in a union.
 */
typedef struct _DDRAWI_DDRAWSURFACE_GBL_MORE
{
    DWORD           dwSize;
    union
    {
        DWORD       dwPhysicalPageTable;        // Physical address of page table (array of physical addresses/one per 4K page)
        FLATPTR     fpPhysicalVidMem;               // Physical address of surface (non-local video memory only)
    };
    LPDWORD         pPageTable;         // Linear address of page table
    DWORD           cPages;             // Number of Pages
    ULONG_PTR       dwSavedDCContext;               // PRIVATE: For use by DDSurface::GetDC
    FLATPTR         fpAliasedVidMem;                // PRIVATE: Alias for original fpVidMem
    ULONG_PTR       dwDriverReserved;               // Reserved for driver use (both system and video memory surfaces)
    ULONG_PTR       dwHELReserved;          // PRIVATE: For HEL use only
    DWORD           cPageUnlocks;           // Incremented whenever a surface is PageUnlocked
    ULONG_PTR       hKernelSurface;         // Kernel handle for this surface
    DWORD           dwKernelRefCnt;         // Ref count for kernel handle
    LPDDCOLORCONTROL lpColorInfo;       // PRIVATE: Initial color control settings
    FLATPTR         fpNTAlias;                      // PRIVATE: Used internally by NT DirectDraw
    DWORD           dwContentsStamp;                // Changes when surface data may have changed. 0 means no information
    LPVOID          lpvUnswappedDriverReserved;     // Reserved for use by display driver. Is not swapped when Flip is called on this surface
//@@BEGIN_DDKSPLIT
#if 1
    LPVOID          pvContents;         // Persistent-content memory
    DWORD           dwBackupStamp;      // Value of dwContentsStamp when contents restored
    DWORD           dwSaveStamp;        // Value of dwContentsStamp when contents saved via IPersistX
#else   //1
//@@END_DDKSPLIT
    LPVOID          lpDDRAWReserved2;
    DWORD           dwDDRAWReserved1;
    DWORD           dwDDRAWReserved2;
//@@BEGIN_DDKSPLIT
#endif  //1
//@@END_DDKSPLIT
    FLATPTR         fpAliasOfVidMem;    // PRIVATE: The original VidMem pointer of which fpAliasedVidMem is an alias of
                                        // This is used to compare with a given fpVidMem to see if we can use the cached fpAliasedVidMem or
                                        // if we need to call GetAliasedVidMem.
} DDRAWI_DDRAWSURFACE_GBL_MORE;

//@@BEGIN_DDKSPLIT
/* Macro to bump the contents stamp so drivers can cheaply check for changed surface data.
 * Zero means no information
 */
#define BUMP_SURFACE_STAMP(surf_gbl)                                                \
if ( GET_LPDDRAWSURFACE_GBL_MORE(surf_gbl)->dwContentsStamp )                      \
{                                                                                   \
    GET_LPDDRAWSURFACE_GBL_MORE(surf_gbl)->dwContentsStamp++;                      \
    if ( 0 ==GET_LPDDRAWSURFACE_GBL_MORE(surf_gbl)->dwContentsStamp)               \
        GET_LPDDRAWSURFACE_GBL_MORE(surf_gbl)->dwContentsStamp++;                  \
}
//@@END_DDKSPLIT

//@@BEGIN_DDKSPLIT
#define NUM_RECTS_IN_REGIONLIST 6
/* This holds the list of dirty regions for D3D texture managed surfaces */
typedef struct _REGIONLIST
{
    RGNDATAHEADER rdh;
    RECTL rect[NUM_RECTS_IN_REGIONLIST];
} REGIONLIST;

typedef REGIONLIST *LPREGIONLIST;
//@@END_DDKSPLIT

/*
 * a structure holding additional LCL surface information (can't simply be appended
 * to the LCL structure as that structure is of variable size).
 */
typedef struct _DDRAWI_DDRAWSURFACE_MORE
{
    DWORD                       dwSize;
    IUNKNOWN_LIST               FAR *lpIUnknowns;   // IUnknowns aggregated by this surface
    LPDDRAWI_DIRECTDRAW_LCL     lpDD_lcl;       // Pointer to the DirectDraw local object
    DWORD                       dwPageLockCount;    // count of pagelocks
    DWORD                       dwBytesAllocated;   // size of sys mem allocated
    LPDDRAWI_DIRECTDRAW_INT     lpDD_int;       // Pointer to the DirectDraw interface
    DWORD                       dwMipMapCount;      // Number of mip-map levels in the chain
    LPDDRAWI_DDRAWCLIPPER_INT   lpDDIClipper;       // Interface to attached clipper object
    //------- Fields added in Version 5.0 -------
    LPHEAPALIASINFO             lpHeapAliasInfo;    // PRIVATE: Aliased heaps being referenced by this lock
    DWORD                       dwOverlayFlags;     // Current overlay flags
    VOID                        *rgjunc;        // Blitter function table for new blitter
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port currently writting data to this surface
    LPDDOVERLAYFX               lpddOverlayFX;      // current overlay fx
    DDSCAPSEX                   ddsCapsEx;
    DWORD                       dwTextureStage;     // stage in multitexture cascade
//@@BEGIN_DDKSPLIT
#if 1
    LPVOID                      lpD3DDevIList;
    LPPRIVATEDATANODE           pPrivateDataHead;
    IUnknown *                  pAddrefedThisOwner; //This is the ddraw object that created this
                                                    //surface, if nonzero. Must Release it when surface
                                                    //is released.
    DWORD                       dwPFIndex;          // pixel-format index (cached by AlphaBlt HEL)
    BOOL *                      lpbDirty;           //this bit is for D3D Texture Manage syncronization
                                                    //if it's set, D3D has to flush batched DPs
                                                    //and then refresh its video copy and clear it to
                                                    //FALSE. Blt,Lock,GetDC will set it.
#else   //1
//@@END_DDKSPLIT
    LPVOID                      lpDDRAWReserved;
    LPVOID                      lpDDRAWReserved2;
    LPVOID                      lpDDrawReserved3;
    DWORD                       dwDDrawReserved4;
    LPVOID                      lpDDrawReserved5;
//@@BEGIN_DDKSPLIT
#endif  //1
//@@END_DDKSPLIT
   LPDWORD                      lpGammaRamp;
   LPDWORD                      lpOriginalGammaRamp;
//@@BEGIN_DDKSPLIT
#if 1
   LPREGIONLIST                 lpRegionList;
#ifndef WIN95
   DISPLAYMODEINFO              dmiCreated; // NT: mode surface created in
#endif
   // This is the new Surface handle generated by the ddraw runtime
   // This is sent to the driver as a cookie to associate a particular
   // surface by the CreateSurfaceEx DDI.
   DWORD                        dwSurfaceHandle;
   ULARGE_INTEGER               qwBatch; // batch number that refers to this texture (D3D)
   LPVOID                       lpTex;
#else   //1
//@@END_DDKSPLIT
   LPVOID                       lpDDrawReserved6;
#ifndef WIN95
   DISPLAYMODEINFO              dmiDDrawReserved7;
#endif
   DWORD                        dwSurfaceHandle;    // cookie for use with CreateSurfaceEx DDI
   DWORD                        qwDDrawReserved8[2];
   LPVOID                       lpDDrawReserved9;
//@@BEGIN_DDKSPLIT
#endif  //1
//@@END_DDKSPLIT
    DWORD                       cSurfaces;                  //PRIVATE
    LPDDSURFACEDESC2            pCreatedDDSurfaceDesc2;     //PRIVATE
    LPDDRAWI_DDRAWSURFACE_LCL   *slist;                     //PRIVATE
    DWORD                       dwFVF;              // saved FVF flags for exe bufs
   LPVOID                       lpVB;                       //PRIVATE
} DDRAWI_DDRAWSURFACE_MORE;

/*
 * Special values assigned to dwPFIndex member of DDRAWI_DDRAWSURFACE_MORE.
 */
#define PFINDEX_UNINITIALIZED  (0UL)    // pixel-format index is in uninitialized state
#define PFINDEX_UNSUPPORTED    (~0UL)   // surface's pixel format is not supported by HEL

/*
 * the LCL structure is local data for each individual surface object
 */
struct _DDRAWI_DDRAWSURFACE_LCL
{
    LPDDRAWI_DDRAWSURFACE_MORE      lpSurfMore; // pointer to additional local data
    LPDDRAWI_DDRAWSURFACE_GBL       lpGbl;      // pointer to surface shared data
    ULONG_PTR                        hDDSurface;     // NT Kernel-mode handle was dwUnused0
    LPATTACHLIST                    lpAttachList;   // link to surfaces we attached to
    LPATTACHLIST                    lpAttachListFrom;// link to surfaces that attached to this one
    DWORD                           dwLocalRefCnt;  // object refcnt
    DWORD                           dwProcessId;    // owning process
    DWORD                           dwFlags;    // flags
    DDSCAPS                         ddsCaps;    // capabilities of surface
    union
    {
        LPDDRAWI_DDRAWPALETTE_INT   lpDDPalette;    // associated palette
        LPDDRAWI_DDRAWPALETTE_INT   lp16DDPalette;  // 16-bit ptr to associated palette
    };
    union
    {
        LPDDRAWI_DDRAWCLIPPER_LCL   lpDDClipper;    // associated clipper
        LPDDRAWI_DDRAWCLIPPER_INT   lp16DDClipper;  // 16-bit ptr to associated clipper
    };
    DWORD                           dwModeCreatedIn;
    DWORD                           dwBackBufferCount; // number of back buffers created
    DDCOLORKEY                      ddckCKDestBlt;  // color key for destination blt use
    DDCOLORKEY                      ddckCKSrcBlt;   // color key for source blt use
//    IUnknown              FAR *pUnkOuter; // outer IUnknown
    ULONG_PTR                       hDC;        // owned dc
    ULONG_PTR                       dwReserved1;    // reserved for use by display driver

    /*
     * NOTE: this part of the structure is ONLY allocated if the surface
     *       can be used for overlays.  ddckCKSrcOverlay MUST NOT BE MOVED
     *       from the start of this area.
     */
    DDCOLORKEY                      ddckCKSrcOverlay;// color key for source overlay use
    DDCOLORKEY                      ddckCKDestOverlay;// color key for destination overlay use
    LPDDRAWI_DDRAWSURFACE_INT       lpSurfaceOverlaying; // surface we are overlaying
    DBLNODE                         dbnOverlayNode;
    /*
     * overlay rectangle, used by DDHEL
     */
    RECT                            rcOverlaySrc;
    RECT                            rcOverlayDest;
    /*
     * the below values are kept here for ddhel. they're set by UpdateOverlay,
     * they're used whenever the overlays are redrawn.
     */
    DWORD                           dwClrXparent;   // the *actual* color key (override, colorkey, or CLR_INVALID)
    DWORD                           dwAlpha;    // the per surface alpha
    /*
     * overlay position
     */
    LONG                            lOverlayX;  // current x position
    LONG                            lOverlayY;  // current y position
};
typedef struct _DDRAWI_DDRAWSURFACE_LCL DDRAWI_DDRAWSURFACE_LCL;

#define DDRAWISURFGBL_MEMFREE                   0x00000001L // video memory has been freed
#define DDRAWISURFGBL_SYSMEMREQUESTED           0x00000002L // surface is in system memory at request of user
#define DDRAWISURFGBL_ISGDISURFACE              0x00000004L // This surface represents what GDI thinks is front buffer
#define DDRAWISURFGBL_SOFTWAREAUTOFLIP          0x00000008L // This surface is autoflipped using software
#define DDRAWISURFGBL_LOCKNOTHOLDINGWIN16LOCK   0x00000010L // PRIVATE: a vram lock of the entire surface is not holding the Win16 lock
#define DDRAWISURFGBL_LOCKVRAMSTYLE             0x00000020L // PRIVATE: entire surface was locked with VRAM style lock
#define DDRAWISURFGBL_LOCKBROKEN                0x00000040L // PRIVATE: a lock of the entire surface was broken by an invalidate
#define DDRAWISURFGBL_IMPLICITHANDLE            0x00000080L // This dwKernelHandle was created implicitly
#define DDRAWISURFGBL_ISCLIENTMEM               0x00000100L // PRIVATE: the memory pointer to by fpVidMem was allocated by the client
#define DDRAWISURFGBL_HARDWAREOPSOURCE          0x00000200L // This surface was the source for an asynchronous hardware operation
#define DDRAWISURFGBL_HARDWAREOPDEST            0x00000400L // This surface was dest for an asynchronous hardware operation
#define DDRAWISURFGBL_HARDWAREOPSTARTED (DDRAWISURFGBL_HARDWAREOPSOURCE|DDRAWISURFGBL_HARDWAREOPDEST)
#define DDRAWISURFGBL_VPORTINTERLEAVED          0x00000800L // This surface contains interleaved video port data
#define DDRAWISURFGBL_VPORTDATA                 0x00001000L // This surface received data from the video port
#define DDRAWISURFGBL_LATEALLOCATELINEAR        0x00002000L // Optimized surface was allocated as a formless chunk. lPitch invalid, dwLinearSize valid.
#define DDRAWISURFGBL_SYSMEMEXECUTEBUFFER       0x00004000L // Driver sets this flag to tell ddraw that the surface was allocated in system memory
#define DDRAWISURFGBL_FASTLOCKHELD              0x00008000L // PRIVATE: indicates that InternLock took the fast path
#define DDRAWISURFGBL_READONLYLOCKHELD          0x00010000L // PRIVATE: indicates that the application indicated read-only lock
#define DDRAWISURFGBL_DX8SURFACE                0x00080000L // PRIVATE: indicates that the surace was created using DX8
#define DDRAWISURFGBL_DDHELDONTFREE             0x00100000L // PRIVATE: indicates that the surace memory should not be freed by the HEL
#define DDRAWISURFGBL_NOTIFYWHENUNLOCKED        0x00200000L // PRIVATE: indicates that the this surface help a NOSYSLOCK lock when a mode change occured


/*
 * NOTE: This flag was previously DDRAWISURFGBL_INVALID. This flags has been retired
 * and replaced by DDRAWISURF_INVALID in the local object.
 */
#define DDRAWISURFGBL_RESERVED0         0x80000000L // Reserved flag

#define DDRAWISURF_ATTACHED             0x00000001L // surface is attached to another
#define DDRAWISURF_IMPLICITCREATE       0x00000002L // surface implicitly created
#define DDRAWISURF_ISFREE               0x00000004L // surface already freed (temp flag)
#define DDRAWISURF_ATTACHED_FROM        0x00000008L // surface has others attached to it
#define DDRAWISURF_IMPLICITROOT         0x00000010L // surface root of implicit creation
#define DDRAWISURF_PARTOFPRIMARYCHAIN   0x00000020L // surface is part of primary chain
#define DDRAWISURF_DATAISALIASED        0x00000040L // used for thunking
#define DDRAWISURF_HASDC                0x00000080L // has a DC
#define DDRAWISURF_HASCKEYDESTOVERLAY   0x00000100L // surface has CKDestOverlay
#define DDRAWISURF_HASCKEYDESTBLT       0x00000200L // surface has CKDestBlt
#define DDRAWISURF_HASCKEYSRCOVERLAY    0x00000400L // surface has CKSrcOverlay
#define DDRAWISURF_HASCKEYSRCBLT        0x00000800L // surface has CKSrcBlt
#define DDRAWISURF_LOCKEXCLUDEDCURSOR   0x00001000L // surface was locked and excluded cursor
#define DDRAWISURF_HASPIXELFORMAT       0x00002000L // surface structure has pixel format data
#define DDRAWISURF_HASOVERLAYDATA       0x00004000L // surface structure has overlay data
#define DDRAWISURF_SETGAMMA             0x00008000L // gamma ramp for this surface is active
#define DDRAWISURF_SW_CKEYDESTOVERLAY   0x00010000L // surface expects to process colorkey in software
#define DDRAWISURF_SW_CKEYDESTBLT       0x00020000L // surface expects to process colorkey in software
#define DDRAWISURF_SW_CKEYSRCOVERLAY    0x00040000L // surface expects to process colorkey in software
#define DDRAWISURF_SW_CKEYSRCBLT        0x00080000L // surface expects to process colorkey in software
#define DDRAWISURF_HW_CKEYDESTOVERLAY   0x00100000L // surface expects to process colorkey in hardware
#define DDRAWISURF_HW_CKEYDESTBLT       0x00200000L // surface expects to process colorkey in hardware
#define DDRAWISURF_HW_CKEYSRCOVERLAY    0x00400000L // surface expects to process colorkey in hardware
#define DDRAWISURF_HW_CKEYSRCBLT        0x00800000L // surface expects to process colorkey in hardware
#define DDRAWISURF_INMASTERSPRITELIST   0x01000000l // surface is referenced in master sprite list
#define DDRAWISURF_HELCB                0x02000000L // surface is the ddhel cb. must call hel for lock/blt.
#define DDRAWISURF_FRONTBUFFER          0x04000000L // surface was originally a front buffer
#define DDRAWISURF_BACKBUFFER           0x08000000L // surface was originally backbuffer
#define DDRAWISURF_INVALID              0x10000000L     // surface has been invalidated by mode set
#define DDRAWISURF_DCIBUSY              0x20000000L     // HEL has turned off BUSY so DCI would work
#define DDRAWISURF_GETDCNULL            0x40000000L     // getdc could not lock and so returned GetDC(NULL)

//#define DDRAWISURF_CANTLOCK             0x20000000L     // surface cannot be locked (primary created by HEL)
#define DDRAWISURF_STEREOSURFACELEFT    0x20000000L     // surface is left of stereo pair
#define DDRAWISURF_DRIVERMANAGED        0x40000000L // Surface is a driver managed texture (D3D)
#define DDRAWISURF_DCILOCK              0x80000000L // Surface was locked using DCIBeginAccess

/*
 * rop stuff
 */
#define ROP_HAS_SOURCE      0x00000001l
#define ROP_HAS_PATTERN     0x00000002l
#define ROP_HAS_SOURCEPATTERN   ROP_HAS_SOURCE | ROP_HAS_PATTERN

/*
 * mode information
 */
typedef struct _DDHALMODEINFO
{
    DWORD   dwWidth;        // width (in pixels) of mode
    DWORD   dwHeight;       // height (in pixels) of mode
    LONG    lPitch;         // pitch (in bytes) of mode
    DWORD   dwBPP;          // bits per pixel
    WORD    wFlags;         // flags
    WORD    wRefreshRate;       // refresh rate
    DWORD   dwRBitMask;     // red bit mask
    DWORD   dwGBitMask;     // green bit mask
    DWORD   dwBBitMask;     // blue bit mask
    DWORD   dwAlphaBitMask;     // alpha bit mask
} DDHALMODEINFO;
typedef DDHALMODEINFO FAR *LPDDHALMODEINFO;

#define DDMODEINFO_PALETTIZED   0x0001  // mode is palettized
#define DDMODEINFO_MODEX        0x0002  // mode is a modex mode
#define DDMODEINFO_UNSUPPORTED  0x0004  // mode is not supported by driver

/*
 * Note internally, standard VGA modes are tagged as MODEX and STANDARDVGA
 */
#define DDMODEINFO_STANDARDVGA  0x0008  // mode is standard vga, e.g. mode 0x13

#define DDMODEINFO_MAXREFRESH   0x0010  // refresh rate specified is the max supported
#define DDMODEINFO_STEREO       0x0020  // mode can be switched to stereo

//@@BEGIN_DDKSPLIT
/*
 * This means that the mode marked as 16bpp is really 555
 */
#define DDMODEINFO_555MODE      0x0100

/*
 * This mode should only be used with DX7 or higher interfaces.
 */
#define DDMODEINFO_DX7ONLY      0x0200

#define DDMODEINFO_VALID        0x003C // valid

#define LISTGROWSIZE    1024

typedef struct _DDSURFACELISTENTRY
{
    DWORD   dwFlags;
    DWORD   nextentry;
    LPDDRAWI_DDRAWSURFACE_LCL   lpSurface;
} DDSURFACELISTENTRY;
typedef DDSURFACELISTENTRY FAR* LPDDSURFACELISTENTRY;
typedef struct _DWLIST
{
    LPDDSURFACELISTENTRY    dwList;    // array to hold handles, dynamically allocated
                        // dwList[0] is the size of array dwList if allocated
    DWORD   dwFreeList; // point to the first unused slot in dwList
} DWLIST;
typedef DWLIST FAR* LPDWLIST;
#ifdef WIN95
#define SURFACEHANDLELIST(this_lcl)    (this_lcl->SurfaceHandleList)
#else   //WIN95
#define SURFACEHANDLELIST(this_lcl)    (this_lcl->lpGbl->SurfaceHandleList)
#endif  //WIN95
//@@END_DDKSPLIT

/*
 * DDRAW interface struct
 */
typedef struct _DDRAWI_DIRECTDRAW_INT
{
    LPVOID                      lpVtbl;     // pointer to array of interface methods
    LPDDRAWI_DIRECTDRAW_LCL     lpLcl;      // pointer to interface data
    LPDDRAWI_DIRECTDRAW_INT     lpLink;     // link to next interface
    DWORD                       dwIntRefCnt;    // interface reference count
//@@BEGIN_DDKSPLIT
    ULONG_PTR                    dwReserved1;    // for DDrawEx
    ULONG_PTR                    dwReserved2;    // for DDrawEx
//@@END_DDKSPLIT
} DDRAWI_DIRECTDRAW_INT;

/*
 * DDRAW version of DirectDraw object; it has data after the vtable
 *
 * all entries marked as PRIVATE are not for use by the display driver
 */
typedef struct _DDHAL_CALLBACKS
{
    DDHAL_DDCALLBACKS           cbDDCallbacks;  // addresses in display driver for DIRECTDRAW object HAL
    DDHAL_DDSURFACECALLBACKS    cbDDSurfaceCallbacks; // addresses in display driver for DIRECTDRAWSURFACE object HAL
    DDHAL_DDPALETTECALLBACKS    cbDDPaletteCallbacks; // addresses in display driver for DIRECTDRAWPALETTE object HAL
    DDHAL_DDCALLBACKS           HALDD;      // HAL for DIRECTDRAW object
    DDHAL_DDSURFACECALLBACKS    HALDDSurface;   // HAL for DIRECTDRAWSURFACE object
    DDHAL_DDPALETTECALLBACKS    HALDDPalette;   // HAL for DIRECTDRAWPALETTE object
    DDHAL_DDCALLBACKS           HELDD;      // HEL for DIRECTDRAW object
    DDHAL_DDSURFACECALLBACKS    HELDDSurface;   // HEL for DIRECTDRAWSURFACE object
    DDHAL_DDPALETTECALLBACKS    HELDDPalette;   // HEL for DIRECTDRAWPALETTE object
    DDHAL_DDEXEBUFCALLBACKS     cbDDExeBufCallbacks; // addresses in display driver for DIRECTDRAWEXEBUF pseudo object HAL
    DDHAL_DDEXEBUFCALLBACKS     HALDDExeBuf;    // HAL for DIRECTDRAWEXEBUF pseudo object
    DDHAL_DDEXEBUFCALLBACKS     HELDDExeBuf;    // HEL for DIRECTDRAWEXEBUF preudo object
    DDHAL_DDVIDEOPORTCALLBACKS  cbDDVideoPortCallbacks; // addresses in display driver for VideoPort object HAL
    DDHAL_DDVIDEOPORTCALLBACKS  HALDDVideoPort; // HAL for DIRECTDRAWVIDEOPORT psuedo object
    DDHAL_DDCOLORCONTROLCALLBACKS cbDDColorControlCallbacks; // addresses in display driver for color control object HAL
    DDHAL_DDCOLORCONTROLCALLBACKS HALDDColorControl; // HAL for DIRECTDRAWCOLORCONTROL psuedo object
    DDHAL_DDMISCELLANEOUSCALLBACKS cbDDMiscellaneousCallbacks;
    DDHAL_DDMISCELLANEOUSCALLBACKS HALDDMiscellaneous;
    DDHAL_DDKERNELCALLBACKS     cbDDKernelCallbacks;
    DDHAL_DDKERNELCALLBACKS HALDDKernel;
    DDHAL_DDMOTIONCOMPCALLBACKS cbDDMotionCompCallbacks;
    DDHAL_DDMOTIONCOMPCALLBACKS HALDDMotionComp;
//@@BEGIN_DDKSPLIT
#ifdef WINNT
    DDHAL_DDNTCALLBACKS         cbDDNTCallbacks;
    DDHAL_DDNTCALLBACKS         HALDDNT;
#endif
    DDHAL_DDMISCELLANEOUS2CALLBACKS HELDDMiscellaneous2;  // HEL
    DDHAL_DDMISCELLANEOUS2CALLBACKS HALDDMiscellaneous2;  // HAL (32-bit, no thunk)
#ifndef WINNT
    DDHAL_DDNTCALLBACKS         cbDDNTCallbacks;
    DDHAL_DDNTCALLBACKS         HALDDNT;
#endif
#ifdef WINNT
    DDHAL_DDVPE2CALLBACKS         cbDDVPE2Callbacks;
    DDHAL_DDVPE2CALLBACKS         HALDDVPE2;
#endif
//@@END_DDKSPLIT
 } DDHAL_CALLBACKS, far *LPDDHAL_CALLBACKS;

//@@BEGIN_DDKSPLIT
/*
 * READ THIS - READ THIS - READ THIS - READ THIS - READ THIS - READ THIS
 *
 * Why have this structure and the API visible DDCAPS? Well we want to grow
 * DDCAPS so the application can get at new caps. but we can't grow the
 * DDCAPS that the driver returns to us because it is embeded by value in
 * DDCOREINFO and chaging is size would break drivers - sigh.Therefore this
 * structure, DDCORECAPS, is the caps structure returned to us by the driver
 * in DDHALINFO.
 *
 * IT HAS A FIXED SIZE AND MUST NEVER GROW OR SHRINK. Whereas the public
 * DDCAPS will grow as new capabilities are added. If new caps are needed
 * they should be returned through a GetDriverInfo call rather than
 * through growing DDCORECAPS.
 *
 * The field names of this structure must be maintained in sync. with the
 * those in the public DDCAPS structure. So if you rename a field at the
 * API level rename it here also (but don't break drivers)
 */
//@@END_DDKSPLIT

/*
 * This structure mirrors the first entries of the DDCAPS but is of a fixed
 * size and will not grow as DDCAPS grows. This is the structure your driver
 * returns in DDCOREINFO. Additional caps will be requested via a GetDriverInfo
 * call.
 */
typedef struct _DDCORECAPS
{
    DWORD   dwSize;         // size of the DDDRIVERCAPS structure
    DWORD   dwCaps;         // driver specific capabilities
    DWORD   dwCaps2;        // more driver specific capabilites
    DWORD   dwCKeyCaps;     // color key capabilities of the surface
    DWORD   dwFXCaps;       // driver specific stretching and effects capabilites
    DWORD   dwFXAlphaCaps;      // alpha driver specific capabilities
    DWORD   dwPalCaps;      // palette capabilities
    DWORD   dwSVCaps;       // stereo vision capabilities
    DWORD   dwAlphaBltConstBitDepths;   // DDBD_2,4,8
    DWORD   dwAlphaBltPixelBitDepths;   // DDBD_1,2,4,8
    DWORD   dwAlphaBltSurfaceBitDepths; // DDBD_1,2,4,8
    DWORD   dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
    DWORD   dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
    DWORD   dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD   dwZBufferBitDepths;     // DDBD_8,16,24,32
    DWORD   dwVidMemTotal;      // total amount of video memory
    DWORD   dwVidMemFree;       // amount of free video memory
    DWORD   dwMaxVisibleOverlays;   // maximum number of visible overlays
    DWORD   dwCurrVisibleOverlays;  // current number of visible overlays
    DWORD   dwNumFourCCCodes;   // number of four cc codes
    DWORD   dwAlignBoundarySrc; // source rectangle alignment
    DWORD   dwAlignSizeSrc;     // source rectangle byte size
    DWORD   dwAlignBoundaryDest;    // dest rectangle alignment
    DWORD   dwAlignSizeDest;    // dest rectangle byte size
    DWORD   dwAlignStrideAlign; // stride alignment
    DWORD   dwRops[DD_ROP_SPACE];   // ROPS supported
    DDSCAPS ddsCaps;        // DDSCAPS structure has all the general capabilities
    DWORD   dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD   dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD   dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD   dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD   dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD   dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD   dwReserved1;        // reserved
    DWORD   dwReserved2;        // reserved
    DWORD   dwReserved3;        // reserved
    DWORD   dwSVBCaps;      // driver specific capabilities for System->Vmem blts
    DWORD   dwSVBCKeyCaps;      // driver color key capabilities for System->Vmem blts
    DWORD   dwSVBFXCaps;        // driver FX capabilities for System->Vmem blts
    DWORD   dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
    DWORD   dwVSBCaps;      // driver specific capabilities for Vmem->System blts
    DWORD   dwVSBCKeyCaps;      // driver color key capabilities for Vmem->System blts
    DWORD   dwVSBFXCaps;        // driver FX capabilities for Vmem->System blts
    DWORD   dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
    DWORD   dwSSBCaps;      // driver specific capabilities for System->System blts
    DWORD   dwSSBCKeyCaps;      // driver color key capabilities for System->System blts
    DWORD   dwSSBFXCaps;        // driver FX capabilities for System->System blts
    DWORD   dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
    DWORD   dwMaxVideoPorts;    // maximum number of usable video ports
    DWORD   dwCurrVideoPorts;   // current number of video ports used
    DWORD   dwSVBCaps2;     // more driver specific capabilities for System->Vmem blts
} DDCORECAPS;

typedef DDCORECAPS FAR* LPDDCORECAPS;

typedef struct _DDRAWI_DIRECTDRAW_GBL
{
/*  0*/ DWORD                   dwRefCnt;    // reference count
/*  4*/ DWORD                   dwFlags;     // flags
/*  8*/ FLATPTR                 fpPrimaryOrig;   // primary surf vid mem. ptr
/*  c*/ DDCORECAPS              ddCaps;      // driver caps
/*148*/ DWORD                   dwInternal1;     // Private to ddraw.dll
/*16c*/ DWORD                   dwUnused1[9];    // not currently used
/*170*/ LPDDHAL_CALLBACKS       lpDDCBtmp;   // HAL callbacks
/*174*/ LPDDRAWI_DDRAWSURFACE_INT   dsList;      // PRIVATE: list of all surfaces
/*178*/ LPDDRAWI_DDRAWPALETTE_INT   palList;     // PRIVATE: list of all palettes
/*17c*/ LPDDRAWI_DDRAWCLIPPER_INT   clipperList;     // PRIVATE: list of all clippers
/*180*/ LPDDRAWI_DIRECTDRAW_GBL     lp16DD;      // PRIVATE: 16-bit ptr to this struct
/*184*/ DWORD                   dwMaxOverlays;   // maximum number of overlays
/*188*/ DWORD                   dwCurrOverlays;  // current number of visible overlays
/*18c*/ DWORD                   dwMonitorFrequency; // monitor frequency in current mode
/*190*/ DDCORECAPS              ddHELCaps;   // HEL capabilities
/*2cc*/ DWORD                   dwUnused2[50];   // not currently used
/*394*/ DDCOLORKEY              ddckCKDestOverlay; // color key for destination overlay use
/*39c*/ DDCOLORKEY              ddckCKSrcOverlay; // color key for source overlay use
/*3a4*/ VIDMEMINFO              vmiData;     // info about vid memory
/*3f4*/ LPVOID                  lpDriverHandle;  // handle for use by display driver
/*   */                          // to call fns in DDRAW16.DLL
/*3f8*/ LPDDRAWI_DIRECTDRAW_LCL         lpExclusiveOwner;   // PRIVATE: exclusive local object
/*3fc*/ DWORD                   dwModeIndex;     // current mode index
/*400*/ DWORD                   dwModeIndexOrig; // original mode index
/*404*/ DWORD                   dwNumFourCC;     // number of fourcc codes supported
/*408*/ DWORD                   FAR *lpdwFourCC; // PRIVATE: fourcc codes supported
/*40c*/ DWORD                   dwNumModes;  // number of modes supported
/*410*/ LPDDHALMODEINFO         lpModeInfo;  // PRIVATE: mode information
/*424*/ PROCESS_LIST            plProcessList;   // PRIVATE: list of processes using driver
/*428*/ DWORD                   dwSurfaceLockCount; // total number of outstanding locks
/*42c*/ DWORD                   dwAliasedLockCnt; // PRIVATE: number of outstanding aliased locks
/*430*/ ULONG_PTR                dwReserved3;     // reserved for use by display driver
/*434*/ ULONG_PTR                hDD;             // PRIVATE: NT Kernel-mode handle (was dwFree3).
/*438*/ char                    cObsolete[12];   // Obsolete field, do not use
/*444*/ DWORD                   dwReserved1;     // reserved for use by display driver
/*448*/ DWORD                   dwReserved2;     // reserved for use by display driver
/*44c*/ DBLNODE                 dbnOverlayRoot;  // The root node of the doubly-
/*   */                                                  // linked list of overlay z orders.
/*45c*/ volatile LPWORD         lpwPDeviceFlags; // driver physical device flags
/*460*/ DWORD                   dwPDevice;       // driver physical device (16:16 pointer)
/*464*/ DWORD                   dwWin16LockCnt;  // count on win16 holds
/*468*/ DWORD                   dwUnused3;       // was lpWin16LockOwner
/*46c*/ DWORD                   hInstance;       // instance handle of driver
/*470*/ DWORD                   dwEvent16;       // 16-bit event
/*474*/ DWORD                   dwSaveNumModes;  // saved number of modes supported
/*   */ //------- Fields added in Version 2.0 -------
//@@BEGIN_DDKSPLIT
#if 1   //Masked for DDK
/*478*/ LPD3DHAL_GLOBALDRIVERDATA lpD3DGlobalDriverData;  // Global D3D Data
/*47c*/ LPD3DHAL_CALLBACKS      lpD3DHALCallbacks;  // D3D HAL Callbacks
#else
//@@END_DDKSPLIT
/*478*/ ULONG_PTR                lpD3DGlobalDriverData;  // Global D3D Data
/*47c*/ ULONG_PTR                lpD3DHALCallbacks;  // D3D HAL Callbacks
//@@BEGIN_DDKSPLIT
#endif
//@@END_DDKSPLIT
/*480*/ DDCORECAPS              ddBothCaps;      // logical AND of driver and HEL caps
/*   */ //------- Fields added in Version 5.0 -------
/*5bc*/ LPDDVIDEOPORTCAPS       lpDDVideoPortCaps;// Info returned by the HAL (an array if more than one video port)
/*5c0*/ LPDDRAWI_DDVIDEOPORT_INT    dvpList;     // PRIVATE: list of all video ports
//@@BEGIN_DDKSPLIT
#if 1   //Masked for DDK
/*5c4*/ LPD3DHAL_CALLBACKS2     lpD3DHALCallbacks2;     // Post-DX3 D3D HAL callbacks
#else
//@@END_DDKSPLIT
/*5c4*/ ULONG_PTR                lpD3DHALCallbacks2;     // Post-DX3 D3D HAL callbacks
//@@BEGIN_DDKSPLIT
#endif  //1
//@@END_DDKSPLIT
/*5c8*/ RECT                    rectDevice;  // rectangle (in desktop coord) for device
/*5d8*/ DWORD                   cMonitors;   // number of monitors in the system
/*5dc*/ LPVOID                  gpbmiSrc;    // PRIVATE: used by HEL
/*5e0*/ LPVOID                  gpbmiDest;   // PRIVATE: used by HEL
/*5e4*/ LPHEAPALIASINFO         phaiHeapAliases; // PRIVATE: video memory heap aliases
/*5e8*/ ULONG_PTR               hKernelHandle;
/*5ec*/ ULONG_PTR               pfnNotifyProc;   // Notification proc registered w/ VDD
/*5f0*/ LPDDKERNELCAPS          lpDDKernelCaps;  // Capabilies of kernel mode interface
/*5f4*/ LPDDNONLOCALVIDMEMCAPS  lpddNLVCaps;     // hardware non-local to local vidmem caps
/*5f8*/ LPDDNONLOCALVIDMEMCAPS  lpddNLVHELCaps;  // emulation layer non-local to local vidmem caps
/*5fc*/ LPDDNONLOCALVIDMEMCAPS  lpddNLVBothCaps; // logical AND of hardware and emulation non-local to local vidmem caps
//@@BEGIN_DDKSPLIT
#if 1   //Masked for DDK
/*600*/ LPD3DHAL_D3DEXTENDEDCAPS lpD3DExtendedCaps; // extended caps for D3D
#else
//@@END_DDKSPLIT
/*600*/ ULONG_PTR                lpD3DExtendedCaps; // extended caps for D3D
//@@BEGIN_DDKSPLIT
#endif  //1
//@@END_DDKSPLIT
/*   */ //--------Fields added in Version 5.0A
/*604*/ DWORD                   dwDOSBoxEvent;      // Event set when returning from a DOS box
/*608*/ RECT                    rectDesktop;        // Desktop coordinates
/*618*/ char                    cDriverName[MAX_DRIVER_NAME]; // Display name
/*   */ //------- Fields added in Version 6.0 -------
//@@BEGIN_DDKSPLIT
#if 1   //Masked for DDK
/*638*/ LPD3DHAL_CALLBACKS3     lpD3DHALCallbacks3;     // DX6 D3D callbacks
#else
//@@END_DDKSPLIT
/*638*/ ULONG_PTR                lpD3DHALCallbacks3;     // DX6 D3D callbacks
//@@BEGIN_DDKSPLIT
#endif  //1
//@@END_DDKSPLIT
/*63c*/ DWORD                   dwNumZPixelFormats;     // Number of z-buffer+stencil pixel formats
/*640*/ LPDDPIXELFORMAT         lpZPixelFormats;        // Pointer to array of z-buffer pixel formats
/*644*/ LPDDRAWI_DDMOTIONCOMP_INT mcList;               // PRIVATE: list of all motion comp objects
/*648*/ DWORD                   hDDVxd;                 // handle to ddraw.vxd
/*64c*/ DDSCAPSEX               ddsCapsMore;            // as queried via GUID_DDMoreSurfaceCaps
//@@BEGIN_DDKSPLIT
/*658*/ DWORD                   dwBusyDueToAliasedLock; // Almost identical semantics as dwAliasedLockCnt,
#ifndef WIN95
        DISPLAYMODEINFO         dmiCurrent; // NT: current display mode
#endif
/*65c*/ LPDDRAWI_DDRAWSURFACE_INT dsFreeList; // PRIVATE: freed interface list, moved from dsList and ready to be recycled
/*660*/ DD32BITDRIVERDATA       dd32BitDriverData;

/*780*/ LPDDMORECAPS            lpddMoreCaps;           // more hardware caps bits for DX7
/*784*/ LPDDMORECAPS            lpddHELMoreCaps;        // more HEL caps bits for DX7
/*788*/ LPDDMORECAPS            lpddBothMoreCaps;       // bitwise AND of more hardware and HEL caps bits for DX7

/*78c*/ DDSCAPSEX               ddsHELCapsMore;            // as queried via GUID_DDMoreSurfaceCaps
/*   */ LPDDMONITORINFO         lpMonitorInfo;          // What refresh rates the monitor/card support

/*   */ LPDDHAL_GETDRIVERINFO       pGetDriverInfo;
#ifdef WINNT
        DWLIST                  SurfaceHandleList; // array to hold handles, dynamically allocated
#endif  //WINNT
        GUID                    guidDevice;             // GUID specifying the hardware device
#ifdef WINNT
        DDHALMODEINFO           ModeInfo;
#endif  //WINNT
#ifdef POSTPONED
/**/ LPDDUMODEDRVINFO           lpDDUmodeDrvInfo;       // Usermode driver info
/**/ LPDDOPTSURFACEINFO         lpDDOptSurfaceInfo;     //Optimized Surface Information
#endif //POSTPONED
#ifdef POSTPONED2
/**/ LPVOID                     lpMasterSpriteList;     // master sprite list
#endif //POSTPONED2
//@@END_DDKSPLIT
} DDRAWI_DIRECTDRAW_GBL;

//@@BEGIN_DDKSPLIT
typedef void (FAR PASCAL * LPPALETTEUPDATENOTIFY)(IUnknown FAR * pD3DIUnknown, DWORD dwPaletteHandle, DWORD dwStartIndex, DWORD dwNumberOfIndices, LPPALETTEENTRY pFirstIndex);

// For D3DIM700, we send a pointer as the last parameter
typedef void (FAR PASCAL * LPPALETTEASSOCIATENOTIFY7)(IUnknown FAR * pD3DIUnknown, DWORD dwPaletteHandle, DWORD dwPaletteFlags, LPDDRAWI_DDRAWSURFACE_LCL surf_lcl );
// For D3DIM, we just send the handle. (MB-41840)
typedef void (FAR PASCAL * LPPALETTEASSOCIATENOTIFY)(IUnknown FAR * pD3DIUnknown, DWORD dwPaletteHandle, DWORD dwPaletteFlags, DWORD dwSurfaceHandle);

typedef void (FAR PASCAL * LPSURFACEFLIPNOTIFY)(IUnknown FAR * pD3DIUnknown);
typedef HRESULT (FAR PASCAL * FLUSHD3DDEVICES) (LPDDRAWI_DDRAWSURFACE_LCL surf_lcl);
typedef void (FAR PASCAL * D3DTEXTUREUPDATE) (IUnknown FAR * pD3DIUnknown);
typedef HRESULT (FAR PASCAL * D3DCREATETEXTURE)(LPDIRECTDRAWSURFACE7 pDDS);
typedef void (FAR PASCAL * D3DDESTROYTEXTURE)(LPVOID pTex);
typedef void (FAR PASCAL * LPBREAKVBLOCK)(LPVOID lpVB);
typedef HRESULT (FAR PASCAL * D3DSETPRIORITY)(LPVOID lpTexI, DWORD dwPriority);
typedef HRESULT (FAR PASCAL * D3DGETPRIORITY)(LPVOID lpTexI, LPDWORD lpdwPriority);
typedef HRESULT (FAR PASCAL * D3DSETLOD)(LPVOID lpTexI, DWORD dwLOD);
typedef HRESULT (FAR PASCAL * D3DGETLOD)(LPVOID lpTexI, LPDWORD lpdwLOD);

#define PALETTEUPDATENOTIFY_NAME        "PaletteUpdateNotify"
#define PALETTEASSOCIATENOTIFY_NAME     "PaletteAssociateNotify"
#define SURFACEFLIPNOTIFY_NAME          "SurfaceFlipNotify"
#define FLUSHD3DDEVICES_NAME            "FlushD3DDevices"
#define FLUSHD3DDEVICES2_NAME           "FlushD3DDevices2"
#define D3DTEXTUREUPDATE_NAME           "D3DTextureUpdate"
#define D3DCREATETEXTURE_NAME           "CreateTexture"
#define D3DDESTROYTEXTURE_NAME          "DestroyTexture"
#define D3DSETPRIORITY_NAME             "SetPriority"
#define D3DGETPRIORITY_NAME             "GetPriority"
#define D3DSETLOD_NAME                  "SetLOD"
#define D3DGETLOD_NAME                  "GetLOD"
#define BREAKVBLOCK_NAME                "D3DBreakVBLock"
//@@END_DDKSPLIT

typedef struct _DDRAWI_DIRECTDRAW_LCL
{
    DWORD                       lpDDMore;           // pointer to additional local data
    LPDDRAWI_DIRECTDRAW_GBL     lpGbl;              // pointer to data
    DWORD                       dwUnused0;          // not currently used
    DWORD                       dwLocalFlags;       // local flags (DDRAWILCL_)
    DWORD                       dwLocalRefCnt;      // local ref cnt
    DWORD                       dwProcessId;        // owning process id
    IUnknown                    FAR *pUnkOuter;     // outer IUnknown
    DWORD                       dwObsolete1;
    ULONG_PTR                   hWnd;
    ULONG_PTR                   hDC;
    DWORD                       dwErrorMode;
    LPDDRAWI_DDRAWSURFACE_INT   lpPrimary;
    LPDDRAWI_DDRAWSURFACE_INT   lpCB;
    DWORD                       dwPreferredMode;
    //------- Fields added in Version 2.0 -------
    HINSTANCE                   hD3DInstance;       // Handle of Direct3D's DLL.
    IUnknown                    FAR *pD3DIUnknown;  // Direct3D's aggregated IUnknown.
    LPDDHAL_CALLBACKS           lpDDCB;             // HAL callbacks
    ULONG_PTR                   hDDVxd;             // handle to ddraw.vxd
    //------- Fields added in Version 5.0 -------
    DWORD                       dwAppHackFlags;     // app compatibilty flags
    //------- Fields added in Version 5.A -------
    ULONG_PTR                   hFocusWnd;          // Focus window set via SetCoopLevel
    DWORD                       dwHotTracking;      // Reactive menu etc setting cached while fullscreen
    DWORD                       dwIMEState;         // IME toolbar setting cached while fullscreen
    //------- Fields added in Version 6.0 -------
    ULONG_PTR                   hWndPopup;
    ULONG_PTR                   hDD;                // PRIVATE: NT Kernel-mode handle
//@@BEGIN_DDKSPLIT
#ifdef SHAREDZ
    LPDDRAWI_DDRAWSURFACE_INT   lpSharedZ;          // Shared z-buffer (if any).
    LPDDRAWI_DDRAWSURFACE_INT   lpSharedBack;       // Shared back-buffer (if any).
#endif
#ifndef WIN95
    DISPLAYMODEINFO             dmiPreferred;       // NT: preferred display mode
#endif
//@@END_DDKSPLIT
    ULONG_PTR                   hGammaCalibrator;   // Private
    LPDDGAMMACALIBRATORPROC     lpGammaCalibrator;  // Private
//@@BEGIN_DDKSPLIT
#ifdef WIN95
    DWLIST                      SurfaceHandleList;  // array to hold handles, dynamically allocated
#endif  //WIN95
    LPDDRAWI_DIRECTDRAW_LCL     lpLink;             // link to next local
    LPPALETTEUPDATENOTIFY       pPaletteUpdateNotify;
    LPPALETTEASSOCIATENOTIFY    pPaletteAssociateNotify;
    LPSURFACEFLIPNOTIFY         pSurfaceFlipNotify;
    DWORD                       cbitsPaletteBitfieldBitCount;
    LPDWORD                     pPaletteHandleUsedBitfield;
    FLUSHD3DDEVICES             pFlushD3DDevices;
    FLUSHD3DDEVICES             pFlushD3DDevices2;
    D3DTEXTUREUPDATE            pD3DTextureUpdate;
    D3DCREATETEXTURE            pD3DCreateTexture;
    D3DDESTROYTEXTURE           pD3DDestroyTexture;
    D3DSETPRIORITY              pD3DSetPriority;
    D3DGETPRIORITY              pD3DGetPriority;
    D3DSETLOD                   pD3DSetLOD;
    D3DGETLOD                   pD3DGetLOD;
    LPDIRECTDRAWSURFACECALLBACKS pddSurfaceCallbacks;
    LPMODETESTCONTEXT           lpModeTestContext;  // Keeps track of current mode test
    DWORD                       dwNumTexLocks;      // D3D texturing stats counter
    DWORD                       dwNumTexGetDCs;     // D3D texturing stats counter
#ifndef WIN95
    DWORD                       dwCursorShadow;     // Cursor shadow turned off while fullscreen
#endif
    LPBREAKVBLOCK               pBreakVBLock;       // Private
//@@END_DDKSPLIT
} DDRAWI_DIRECTDRAW_LCL;

#define DDRAWILCL_HASEXCLUSIVEMODE          0x00000001l
#define DDRAWILCL_ISFULLSCREEN              0x00000002l
#define DDRAWILCL_SETCOOPCALLED             0x00000004l
#define DDRAWILCL_ACTIVEYES                 0x00000008l
#define DDRAWILCL_ACTIVENO                  0x00000010l
#define DDRAWILCL_HOOKEDHWND                0x00000020l
#define DDRAWILCL_ALLOWMODEX                0x00000040l
#define DDRAWILCL_V1SCLBEHAVIOUR            0x00000080l
#define DDRAWILCL_MODEHASBEENCHANGED        0x00000100l
#define DDRAWILCL_CREATEDWINDOW             0x00000200l
#define DDRAWILCL_DIRTYDC                   0x00000400l     // Set on ChangeDisplaySettings, cleared when device DC is reinited
#define DDRAWILCL_DISABLEINACTIVATE         0x00000800l
#define DDRAWILCL_CURSORCLIPPED             0x00001000l
#define DDRAWILCL_EXPLICITMONITOR           0x00002000l // device was chosen explicitly i.e. not DDrawCreate(NULL)
#define DDRAWILCL_MULTITHREADED             0x00004000l // App threaten to be multithreaded
#define DDRAWILCL_FPUSETUP                  0x00008000l // D3D does not need to switch to single prec/exceptions disabled each time
#define DDRAWILCL_POWEREDDOWN               0x00010000l // Private: indicates that screen saver is powered down
#define DDRAWILCL_DIRECTDRAW7               0x00020000l // PRIVATE: Marks if this is a IDirectDraw7 object
#define DDRAWILCL_ATTEMPTEDD3DCONTEXT       0x00040000l // PRIVATE: Marks if this ddraw local has attempted to create a d3d context
#define DDRAWILCL_FPUPRESERVE               0x00080000l // D3D needs to switch to single prec/exceptions disabled each time
#define DDRAWILCL_DX8DRIVER                 0x00100000l // PRIVATE: Set if this drvier can handle lightweight surfaces
#define DDRAWILCL_DIRECTDRAW8               0x00200000l // PRIVATE: Marks if this is a IDirectDraw8 object

#define DDRAWI_xxxxxxxxx1                   0x00000001l     // unused
#define DDRAWI_xxxxxxxxx2                   0x00000002l // unused
#define DDRAWI_VIRTUALDESKTOP               0x00000008l     // driver is really a multi-monitor virtual desktop
#define DDRAWI_MODEX                        0x00000010l // driver is using modex
#define DDRAWI_DISPLAYDRV                   0x00000020l // driver is display driver
#define DDRAWI_FULLSCREEN                   0x00000040l // driver in fullscreen mode
#define DDRAWI_MODECHANGED                  0x00000080l // display mode has been changed
#define DDRAWI_NOHARDWARE                   0x00000100l // no driver hardware at all
#define DDRAWI_PALETTEINIT                  0x00000200l // GDI palette stuff has been initalized
#define DDRAWI_NOEMULATION                  0x00000400l // no emulation at all
#define DDRAWI_HASCKEYDESTOVERLAY           0x00000800l // driver has CKDestOverlay
#define DDRAWI_HASCKEYSRCOVERLAY            0x00001000l // driver has CKSrcOverlay
#define DDRAWI_HASGDIPALETTE                0x00002000l // GDI palette exists on primary surface
#define DDRAWI_EMULATIONINITIALIZED         0x00004000l // emulation is initialized
#define DDRAWI_HASGDIPALETTE_EXCLUSIVE      0x00008000l     // exclusive mode palette
#define DDRAWI_MODEXILLEGAL                 0x00010000l // modex is not supported by this hardware
#define DDRAWI_FLIPPEDTOGDI                 0x00020000l     // driver has been flipped to show GDI surface
#define DDRAWI_NEEDSWIN16FORVRAMLOCK        0x00040000l     // PRIVATE: Win16 lock must be taken when locking a VRAM surface
#define DDRAWI_PDEVICEVRAMBITCLEARED        0x00080000l     // PRIVATE: the PDEVICE's VRAM bit was cleared by a lock
#define DDRAWI_STANDARDVGA                  0x00100000l     // Device is using standard VGA mode (DDRAWI_MODEX will be set)
#define DDRAWI_EXTENDEDALIGNMENT            0x00200000l     // At least one heap has extended alignment. Ignore alignment in VIDMEMINFO
#define DDRAWI_CHANGINGMODE                 0x00400000l     // Currently in the middle of a mode change
#define DDRAWI_GDIDRV                       0x00800000l     // Driver is a GDI driver
#define DDRAWI_ATTACHEDTODESKTOP            0x01000000l     // Device is attached to the desktop
#define DDRAWI_UMODELOADED                  0x02000000l     // User mode driver dll is loaded
#define DDRAWI_DDRAWDATANOTFETCHED          0x04000000l     // PRIVATE: Marks mode-change data fetched (NT)
#define DDRAWI_SECONDARYDRIVERLOADED        0x08000000l     // PRIVATE: Marks if a secndary PVR-style HAL was loaded
#define DDRAWI_TESTINGMODES                 0x10000000l     // PRIVATE: A mode test in is progress
#define DDRAWI_DRIVERINFO2                  0x20000000l     // PRIVATE: Driver supports GetDriverInfo2

//@@BEGIN_DDKSPLIT
#ifdef IS_16
__inline BOOL IsD3DManaged(psurf_lcl)
LPDDRAWI_DDRAWSURFACE_LCL psurf_lcl;
#else
__inline BOOL IsD3DManaged(LPDDRAWI_DDRAWSURFACE_LCL psurf_lcl)
#endif
{
    if(psurf_lcl->dwFlags & DDRAWISURF_DRIVERMANAGED)
    {
        return FALSE;
    }
    else
    {
        return ((psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & (DDSCAPS2_TEXTUREMANAGE | DDSCAPS2_D3DTEXTUREMANAGE)) ? TRUE : FALSE);
    }
}

#ifdef IS_16
__inline void MarkDirty(surf_lcl)
LPDDRAWI_DDRAWSURFACE_LCL surf_lcl;
#else
__inline void MarkDirty(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl)
#endif // IS_16
{
    if(surf_lcl->lpSurfMore->lpbDirty)
    {
        *(surf_lcl->lpSurfMore->lpbDirty) = TRUE;
        if(surf_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW7)
        {
#ifdef DDASSERT
            DDASSERT(surf_lcl->lpSurfMore->lpDD_lcl->pD3DTextureUpdate);
            DDASSERT(surf_lcl->lpSurfMore->lpDD_lcl->pD3DIUnknown);
#endif
            surf_lcl->lpSurfMore->lpDD_lcl->pD3DTextureUpdate(surf_lcl->lpSurfMore->lpDD_lcl->pD3DIUnknown);
        }
    }
}

/* Flush all batched D3D drawprimitives that's using this surface */
#ifdef IS_16
__inline void FlushD3DStates(surf_lcl)
LPDDRAWI_DDRAWSURFACE_LCL surf_lcl;
#else
__inline void FlushD3DStates(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl)
#endif // IS_16
{
    if(surf_lcl->lpSurfMore->lpDD_lcl->pD3DIUnknown)
        surf_lcl->lpSurfMore->lpDD_lcl->pFlushD3DDevices(surf_lcl);
}

#ifdef IS_16
__inline BOOL IsToplevel(surf_lcl)
LPDDRAWI_DDRAWSURFACE_LCL surf_lcl;
#else
__inline BOOL IsToplevel(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl)
#endif // IS_16
{
    return !((surf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_MIPMAPSUBLEVEL) ||
               ((surf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP) &&
                   (surf_lcl->lpAttachListFrom != NULL)));
}
//@@END_DDKSPLIT

/*
 * VideoPort object interface
 */
typedef struct _DDRAWI_DDVIDEOPORT_INT
{
    LPVOID                      lpVtbl;     // pointer to array of interface methods
    LPDDRAWI_DDVIDEOPORT_LCL    lpLcl;      // pointer to interface data
    LPDDRAWI_DDVIDEOPORT_INT    lpLink;     // link to next interface
    DWORD                       dwIntRefCnt;    // interface reference count
    DWORD                       dwFlags;    // Private
} DDRAWI_DDVIDEOPORT_INT;

typedef struct _DDRAWI_DDVIDEOPORT_LCL
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;       // pointer to DIRECTDRAW_LCL
    DDVIDEOPORTDESC             ddvpDesc;   // description used at create time
    DDVIDEOPORTINFO             ddvpInfo;   // most recent video port info
    LPDDRAWI_DDRAWSURFACE_INT   lpSurface;  // surface receiving the data
    LPDDRAWI_DDRAWSURFACE_INT   lpVBISurface;   // surface receiving the VBI data
    LPDDRAWI_DDRAWSURFACE_INT   *lpFlipInts;    // PRIVATE: surfaces currently being autoflipped
    DWORD                       dwNumAutoflip;  // Number of current autoflip surfaces
    DWORD                       dwProcessID;    // ID of process owning this video port
    DWORD                       dwStateFlags;
    DWORD                       dwFlags;
    DWORD                       dwRefCnt;
    FLATPTR                     fpLastFlip;     // Location from which we last flipped
    ULONG_PTR                   dwReserved1;    // Reserved for display driver
    ULONG_PTR                   dwReserved2;    // Reserved for display driver
    HANDLE                      hDDVideoPort;   // NT Kernel-mode handle
    DWORD                       dwNumVBIAutoflip;//Number of VBI surfaces currently being autoflipped
    LPDDVIDEOPORTDESC           lpVBIDesc;  // PRIVATE
    LPDDVIDEOPORTDESC           lpVideoDesc;    // PRIVATE
    LPDDVIDEOPORTINFO           lpVBIInfo;  // PRIVATE
    LPDDVIDEOPORTINFO           lpVideoInfo;    // PRIVATE
    DWORD                       dwVBIProcessID; // ID of process owning this video port
    LPDDRAWI_DDVIDEOPORT_INT    lpVPNotify;
} DDRAWI_DDVIDEOPORT_LCL;

#define DDRAWIVPORT_ON                  0x00000001  // Video port is pumping data
#define DDRAWIVPORT_SOFTWARE_AUTOFLIP   0x00000002  // Video port cannot use hardware autoflip
#define DDRAWIVPORT_COLORKEYANDINTERP   0x00000004      // Overlay cannot bob and colorkey at same time
#define DDRAWIVPORT_NOKERNELHANDLES     0x00000008      // Unable to allocate kernel resources
#define DDRAWIVPORT_SOFTWARE_BOB        0x00000010  // All bobbing must be performed in software
#define DDRAWIVPORT_VBION               0x00000020  // Video is on for the VBI region
#define DDRAWIVPORT_VIDEOON             0x00000040  // Video is on for the video region

/*
 * MotionComp object interface
 */
typedef struct _DDRAWI_DDMOTIONCOMP_INT
{
    LPVOID                      lpVtbl;
    LPDDRAWI_DDMOTIONCOMP_LCL   lpLcl;
    LPDDRAWI_DDMOTIONCOMP_INT   lpLink;
    DWORD                       dwIntRefCnt;
} DDRAWI_DDMOTIONCOMP_INT;

typedef struct _DDRAWI_DDMOTIONCOMP_LCL
{
    LPDDRAWI_DIRECTDRAW_LCL lpDD;
    GUID                    guid;
    DWORD                   dwUncompWidth;
    DWORD                   dwUncompHeight;
    DDPIXELFORMAT           ddUncompPixelFormat;
    DWORD                   dwInternalFlags;
    DWORD                   dwRefCnt;
    DWORD                   dwProcessId;
    HANDLE                  hMoComp;
    DWORD                   dwDriverReserved1;
    DWORD                   dwDriverReserved2;
    DWORD                   dwDriverReserved3;
    LPVOID                  lpDriverReserved1;
    LPVOID                  lpDriverReserved2;
    LPVOID                  lpDriverReserved3;
} DDRAWI_DDMOTIONCOMP_LCL;

//@@BEGIN_DDKSPLIT
/*
 * The following structure is equivalent to the DDHALINFO structure defined in DirectDraw 1.0.
 * It is used by DirectDraw internally to interpret the DDHALINFO information passed from drivers written
 * prior to DirectDraw 2.0.  New applications and drivers should use the DDHALINFO structure defined after
 * this one.  DirectDraw distinguishes between the structures via the dwSize field.
 */
typedef struct _DDHALINFO_V1
{
    DWORD                   dwSize;
    LPDDHAL_DDCALLBACKS     lpDDCallbacks;      // direct draw object callbacks
    LPDDHAL_DDSURFACECALLBACKS  lpDDSurfaceCallbacks;   // surface object callbacks
    LPDDHAL_DDPALETTECALLBACKS  lpDDPaletteCallbacks;   // palette object callbacks
    VIDMEMINFO              vmiData;        // video memory info
    DDCAPS_DX1              ddCaps;         // hw specific caps
    DWORD                   dwMonitorFrequency; // monitor frequency in current mode
    DWORD                   hWndListBox;        // list box for debug output
    DWORD                   dwModeIndex;        // current mode: index into array
    LPDWORD                 lpdwFourCC;     // fourcc codes supported
    DWORD                   dwNumModes;     // number of modes supported
    LPDDHALMODEINFO         lpModeInfo;     // mode information
    DWORD                   dwFlags;        // create flags
    LPVOID                  lpPDevice;      // physical device ptr
    DWORD                   hInstance;      // instance handle of driver
} DDHALINFO_V1;
typedef DDHALINFO_V1 FAR *LPDDHALINFO_V1;
#define DDHALINFOSIZE_V1 sizeof( DDHALINFO_V1)

//@@END_DDKSPLIT

/*
 * structure for display driver to call DDHAL_Create with
 */
typedef struct _DDHALINFO
{
    DWORD                       dwSize;
    LPDDHAL_DDCALLBACKS         lpDDCallbacks;      // direct draw object callbacks
    LPDDHAL_DDSURFACECALLBACKS  lpDDSurfaceCallbacks;   // surface object callbacks
    LPDDHAL_DDPALETTECALLBACKS  lpDDPaletteCallbacks;   // palette object callbacks
    VIDMEMINFO                  vmiData;        // video memory info
    DDCORECAPS                  ddCaps;         // core hw specific caps
    DWORD                       dwMonitorFrequency; // monitor frequency in current mode
    LPDDHAL_GETDRIVERINFO       GetDriverInfo;          // callback to get arbitrary vtable from driver
    DWORD                       dwModeIndex;        // current mode: index into array
    LPDWORD                     lpdwFourCC;     // fourcc codes supported
    DWORD                       dwNumModes;     // number of modes supported
    LPDDHALMODEINFO             lpModeInfo;     // mode information
    DWORD                       dwFlags;        // create flags
    LPVOID                      lpPDevice;      // physical device ptr
    DWORD                       hInstance;      // instance handle of driver
    //------- Fields added in Version 2.0 -------
//@@BEGIN_DDKSPLIT
#if 1   //Masked for DDK
    LPD3DHAL_GLOBALDRIVERDATA   lpD3DGlobalDriverData;  // D3D global Data
    LPD3DHAL_CALLBACKS          lpD3DHALCallbacks;  // D3D callbacks
#else   //1
//@@END_DDKSPLIT
    ULONG_PTR                    lpD3DGlobalDriverData;  // D3D global Data
    ULONG_PTR                   lpD3DHALCallbacks;  // D3D callbacks
//@@BEGIN_DDKSPLIT
#endif  //1
    // For backward compatibility with pre-DX5 runtimes, must not
    // add fields to this structure. Use GetDriverInfo instead.
//@@END_DDKSPLIT
    LPDDHAL_DDEXEBUFCALLBACKS   lpDDExeBufCallbacks;    // Execute buffer pseudo object callbacks
} DDHALINFO;
typedef DDHALINFO FAR *LPDDHALINFO;

#define DDHALINFOSIZE_V2 sizeof( DDHALINFO )

#define DDHALINFO_ISPRIMARYDISPLAY  0x00000001l // indicates driver is primary display driver
#define DDHALINFO_MODEXILLEGAL      0x00000002l // indicates this hardware does not support modex modes
#define DDHALINFO_GETDRIVERINFOSET  0x00000004l // indicates that GetDriverInfo is set
#define DDHALINFO_GETDRIVERINFO2    0x00000008l // indicates driver support GetDriverInfo2 variant
                                                // of GetDriverInfo. New for DX 8.0

/*
 * DDRAW16.DLL entry points
 */
typedef BOOL (DDAPI *LPDDHAL_SETINFO)( LPDDHALINFO lpDDHalInfo, BOOL reset );
typedef FLATPTR (DDAPI *LPDDHAL_VIDMEMALLOC)( LPDDRAWI_DIRECTDRAW_GBL lpDD, int heap, DWORD dwWidth, DWORD dwHeight );
typedef void (DDAPI *LPDDHAL_VIDMEMFREE)( LPDDRAWI_DIRECTDRAW_GBL lpDD, int heap, FLATPTR fpMem );

extern BOOL DDAPI DDHAL_SetInfo( LPDDHALINFO lpDDHALInfo, BOOL reset );
extern FLATPTR DDAPI DDHAL_VidMemAlloc( LPDDRAWI_DIRECTDRAW_GBL lpDD, int heap, DWORD dwWidth, DWORD dwHeight );
extern void DDAPI DDHAL_VidMemFree( LPDDRAWI_DIRECTDRAW_GBL lpDD, int heap, FLATPTR fpMem );


typedef struct
{
    DWORD               dwSize;
    LPDDHAL_SETINFO     lpSetInfo;
    LPDDHAL_VIDMEMALLOC lpVidMemAlloc;
    LPDDHAL_VIDMEMFREE  lpVidMemFree;
} DDHALDDRAWFNS;
typedef DDHALDDRAWFNS FAR *LPDDHALDDRAWFNS;

/****************************************************************************
 *
 * DDHAL structures for Surface Object callbacks
 *
 ***************************************************************************/

//@@BEGIN_DDKSPLIT
/*
 * This special flag is seen only by drivers.  The DD runtime sets this
 * bit in DDHAL_BLTDATA.dwFlags if the dwAFlags and ddargbScaleFactors
 * members at the end of the DDHAL_BLTDATA structure are valid.
 * The flag is always set if the DDHAL_BLTDATA structure is passed to
 * the driver via the AlphaBlt HAL callback; otherwise, the flag is zero.
 */
#define DDBLT_AFLAGS            0x80000000L

/*
 * This flag will be set in DDHAL_BLTDATA.dwAFlags if the call was originated
 * by the AlphaBlt API method. If the call was originated by the Blt API,
 * this flag will not be set.
 * Drivers which have a unified Blt/AlphaBlt DDI can use this flag to distinguish
 * between the two API calls.
 */
#define DDABLT_SRCOVERDEST      0x00000001L
//@@END_DDKSPLIT

/*
 * structure for passing information to DDHAL Blt and AlphaBlt fns
 */
typedef struct _DDHAL_BLTDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDDestSurface;// dest surface
    RECTL                       rDest;      // dest rect
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSrcSurface; // src surface
    RECTL                       rSrc;       // src rect
    DWORD                       dwFlags;    // blt flags
    DWORD                       dwROPFlags; // ROP flags (valid for ROPS only)
    DDBLTFX                     bltFX;      // blt FX
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_BLT           Blt;        // PRIVATE: ptr to callback
    BOOL                        IsClipped;      // clipped blt?
    RECTL                       rOrigDest;  // unclipped dest rect
                                            // (only valid if IsClipped)
    RECTL                       rOrigSrc;   // unclipped src rect
                                            // (only valid if IsClipped)
    DWORD                       dwRectCnt;  // count of dest rects
                                            // (only valid if IsClipped)
    LPRECT                      prDestRects;    // array of dest rects

//@@BEGIN_DDKSPLIT

    DWORD                       dwAFlags;   // DDABLT_ flags (for AlphaBlt DDI)
    DDARGB                      ddargbScaleFactors;  // RGBA scaling factors (AlphaBlt)
//@@END_DDKSPLIT
} DDHAL_BLTDATA;

/*
 * structure for passing information to DDHAL Lock fn
 */
typedef struct _DDHAL_LOCKDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // surface struct
    DWORD                       bHasRect;   // rArea is valid
    RECTL                       rArea;      // area being locked
    LPVOID                      lpSurfData; // pointer to screen memory (return value)
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_LOCK          Lock;           // PRIVATE: ptr to callback
    DWORD                       dwFlags;        // DDLOCK flags
} DDHAL_LOCKDATA;

/*
 * structure for passing information to DDHAL Unlock fn
 */
typedef struct _DDHAL_UNLOCKDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // surface struct
    HRESULT                     ddRVal;         // return value
    LPDDHALSURFCB_UNLOCK        Unlock;     // PRIVATE: ptr to callback
} DDHAL_UNLOCKDATA;

/*
 * structure for passing information to DDHAL UpdateOverlay fn
 */
typedef struct _DDHAL_UPDATEOVERLAYDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDDestSurface;// dest surface
    RECTL                       rDest;      // dest rect
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSrcSurface; // src surface
    RECTL                       rSrc;       // src rect
    DWORD                       dwFlags;    // flags
    DDOVERLAYFX                 overlayFX;  // overlay FX
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_UPDATEOVERLAY UpdateOverlay;  // PRIVATE: ptr to callback
} DDHAL_UPDATEOVERLAYDATA;

/*
 * structure for passing information to DDHAL UpdateOverlay fn
 */
typedef struct _DDHAL_SETOVERLAYPOSITIONDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSrcSurface; // src surface
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDDestSurface;// dest surface
    LONG                        lXPos;      // x position
    LONG                        lYPos;      // y position
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_SETOVERLAYPOSITION SetOverlayPosition; // PRIVATE: ptr to callback
} DDHAL_SETOVERLAYPOSITIONDATA;
/*
 * structure for passing information to DDHAL SetPalette fn
 */
typedef struct _DDHAL_SETPALETTEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // surface struct
    LPDDRAWI_DDRAWPALETTE_GBL   lpDDPalette;    // palette to set to surface
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_SETPALETTE    SetPalette; // PRIVATE: ptr to callback
    BOOL                        Attach;         // attach this palette?
} DDHAL_SETPALETTEDATA;

/*
 * structure for passing information to DDHAL Flip fn
 */
typedef struct _DDHAL_FLIPDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpSurfCurr; // current surface
    LPDDRAWI_DDRAWSURFACE_LCL   lpSurfTarg; // target surface (to flip to)
    DWORD                       dwFlags;    // flags
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_FLIP          Flip;       // PRIVATE: ptr to callback
    LPDDRAWI_DDRAWSURFACE_LCL   lpSurfCurrLeft; // current surface
    LPDDRAWI_DDRAWSURFACE_LCL   lpSurfTargLeft; // target surface (to flip to)
} DDHAL_FLIPDATA;

/*
 * structure for passing information to DDHAL DestroySurface fn
 */
typedef struct _DDHAL_DESTROYSURFACEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // surface struct
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_DESTROYSURFACE DestroySurface;// PRIVATE: ptr to callback
} DDHAL_DESTROYSURFACEDATA;

/*
 * structure for passing information to DDHAL SetClipList fn
 */
typedef struct _DDHAL_SETCLIPLISTDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // surface struct
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_SETCLIPLIST   SetClipList;    // PRIVATE: ptr to callback
} DDHAL_SETCLIPLISTDATA;

/*
 * structure for passing information to DDHAL AddAttachedSurface fn
 */
typedef struct _DDHAL_ADDATTACHEDSURFACEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL         lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL       lpDDSurface;    // surface struct
    LPDDRAWI_DDRAWSURFACE_LCL       lpSurfAttached; // surface to attach
    HRESULT                         ddRVal;     // return value
    LPDDHALSURFCB_ADDATTACHEDSURFACE    AddAttachedSurface; // PRIVATE: ptr to callback
} DDHAL_ADDATTACHEDSURFACEDATA;

/*
 * structure for passing information to DDHAL SetColorKey fn
 */
typedef struct _DDHAL_SETCOLORKEYDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // surface struct
    DWORD                       dwFlags;    // flags
    DDCOLORKEY                  ckNew;      // new color key
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_SETCOLORKEY   SetColorKey;    // PRIVATE: ptr to callback
} DDHAL_SETCOLORKEYDATA;

/*
 * structure for passing information to DDHAL GetBltStatus fn
 */
typedef struct _DDHAL_GETBLTSTATUSDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // surface struct
    DWORD                       dwFlags;    // flags
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_GETBLTSTATUS  GetBltStatus;   // PRIVATE: ptr to callback
} DDHAL_GETBLTSTATUSDATA;

/*
 * structure for passing information to DDHAL GetFlipStatus fn
 */
typedef struct _DDHAL_GETFLIPSTATUSDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // surface struct
    DWORD                       dwFlags;    // flags
    HRESULT                     ddRVal;     // return value
    LPDDHALSURFCB_GETFLIPSTATUS GetFlipStatus;  // PRIVATE: ptr to callback
} DDHAL_GETFLIPSTATUSDATA;

/****************************************************************************
 *
 * DDHAL structures for Palette Object callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL DestroyPalette fn
 */
typedef struct _DDHAL_DESTROYPALETTEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWPALETTE_GBL   lpDDPalette;    // palette struct
    HRESULT                     ddRVal;     // return value
    LPDDHALPALCB_DESTROYPALETTE DestroyPalette; // PRIVATE: ptr to callback
} DDHAL_DESTROYPALETTEDATA;

/*
 * structure for passing information to DDHAL SetEntries fn
 */
typedef struct _DDHAL_SETENTRIESDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWPALETTE_GBL   lpDDPalette;    // palette struct
    DWORD                       dwBase;     // base palette index
    DWORD                       dwNumEntries;   // number of palette entries
    LPPALETTEENTRY              lpEntries;  // color table
    HRESULT                     ddRVal;     // return value
    LPDDHALPALCB_SETENTRIES     SetEntries; // PRIVATE: ptr to callback
} DDHAL_SETENTRIESDATA;

/****************************************************************************
 *
 * DDHAL structures for Driver Object callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL CreateSurface fn
 */
typedef struct _DDHAL_CREATESURFACEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDSURFACEDESC             lpDDSurfaceDesc;// description of surface being created
    LPDDRAWI_DDRAWSURFACE_LCL   FAR *lplpSList; // list of created surface objects
    DWORD                       dwSCnt;     // number of surfaces in SList
    HRESULT                     ddRVal;     // return value
    LPDDHAL_CREATESURFACE       CreateSurface;  // PRIVATE: ptr to callback
} DDHAL_CREATESURFACEDATA;

/*
 * structure for passing information to DDHAL CanCreateSurface fn
 */
typedef struct _DDHAL_CANCREATESURFACEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;           // driver struct
    LPDDSURFACEDESC             lpDDSurfaceDesc;    // description of surface being created
    DWORD                       bIsDifferentPixelFormat;// pixel format differs from primary surface
    HRESULT                     ddRVal;         // return value
    LPDDHAL_CANCREATESURFACE    CanCreateSurface;   // PRIVATE: ptr to callback
} DDHAL_CANCREATESURFACEDATA;

/*
 * structure for passing information to DDHAL CreatePalette fn
 */
typedef struct _DDHAL_CREATEPALETTEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWPALETTE_GBL   lpDDPalette;    // ddraw palette struct
    LPPALETTEENTRY              lpColorTable;   // colors to go in palette
    HRESULT                     ddRVal;     // return value
    LPDDHAL_CREATEPALETTE       CreatePalette;  // PRIVATE: ptr to callback
    BOOL                        is_excl;        // process has exclusive mode
} DDHAL_CREATEPALETTEDATA;

/*
 * Return if the vertical blank is in progress
 */
#define DDWAITVB_I_TESTVB           0x80000006l

/*
 * structure for passing information to DDHAL WaitForVerticalBlank fn
 */
typedef struct _DDHAL_WAITFORVERTICALBLANKDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    DWORD                       dwFlags;    // flags
    DWORD                       bIsInVB;    // is in vertical blank
    ULONG_PTR                   hEvent;     // event
    HRESULT                     ddRVal;     // return value
    LPDDHAL_WAITFORVERTICALBLANK    WaitForVerticalBlank; // PRIVATE: ptr to callback
} DDHAL_WAITFORVERTICALBLANKDATA;

/*
 * structure for passing information to DDHAL DestroyDriver fn
 */
typedef struct _DDHAL_DESTROYDRIVERDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;   // driver struct
    HRESULT                     ddRVal; // return value
    LPDDHAL_DESTROYDRIVER       DestroyDriver;  // PRIVATE: ptr to callback
} DDHAL_DESTROYDRIVERDATA;

/*
 * structure for passing information to DDHAL SetMode fn
 */
typedef struct _DDHAL_SETMODEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    DWORD                       dwModeIndex;    // new mode
    HRESULT                     ddRVal;     // return value
    LPDDHAL_SETMODE             SetMode;    // PRIVATE: ptr to callback
    BOOL                        inexcl;         // in exclusive mode
    BOOL                        useRefreshRate; // use the refresh rate data in the mode info
} DDHAL_SETMODEDATA;

/*
 * structure for passing information to DDHAL driver SetColorKey fn
 */
typedef struct _DDHAL_DRVSETCOLORKEYDATA
{
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // surface struct
    DWORD                       dwFlags;    // flags
    DDCOLORKEY                  ckNew;      // new color key
    HRESULT                     ddRVal;     // return value
    LPDDHAL_SETCOLORKEY         SetColorKey;    // PRIVATE: ptr to callback
} DDHAL_DRVSETCOLORKEYDATA;

/*
 * structure for passing information to DDHAL GetScanLine fn
 */
typedef struct _DDHAL_GETSCANLINEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    DWORD                       dwScanLine; // returned scan line
    HRESULT                     ddRVal;     // return value
    LPDDHAL_GETSCANLINE         GetScanLine;    // PRIVATE: ptr to callback
} DDHAL_GETSCANLINEDATA;

/*
 * structure for passing information to DDHAL SetExclusiveMode fn
 */
typedef struct _DDHAL_SETEXCLUSIVEMODEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;             // driver struct
    DWORD                       dwEnterExcl;      // TRUE if entering exclusive mode, FALSE is leaving
    DWORD                       dwReserved;       // reserved for future use
    HRESULT                     ddRVal;           // return value
    LPDDHAL_SETEXCLUSIVEMODE    SetExclusiveMode; // PRIVATE: ptr to callback
} DDHAL_SETEXCLUSIVEMODEDATA;

/*
 * structure for passing information to DDHAL FlipToGDISurface fn
 */
typedef struct _DDHAL_FLIPTOGDISURFACEDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;         // driver struct
    DWORD                       dwToGDI;          // TRUE if flipping to the GDI surface, FALSE if flipping away
    DWORD                       dwReserved;       // reserved for future use
    HRESULT            ddRVal;       // return value
    LPDDHAL_FLIPTOGDISURFACE    FlipToGDISurface; // PRIVATE: ptr to callback
} DDHAL_FLIPTOGDISURFACEDATA;

/****************************************************************************
 *
 * DDHAL structures for VideoPort callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL CanCreateVideoPort fn
 */
typedef struct _DDHAL_CANCREATEVPORTDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDVIDEOPORTDESC           lpDDVideoPortDesc;
    HRESULT                     ddRVal;             // return value
    LPDDHALVPORTCB_CANCREATEVIDEOPORT CanCreateVideoPort; // PRIVATE: ptr to callback
} DDHAL_CANCREATEVPORTDATA;

/*
 * structure for passing information to DDHAL CreateVideoPort fn
 */
typedef struct _DDHAL_CREATEVPORTDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDVIDEOPORTDESC           lpDDVideoPortDesc;
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port created
    HRESULT                     ddRVal;             // return value
    LPDDHALVPORTCB_CREATEVIDEOPORT CreateVideoPort; // PRIVATE: ptr to callback
} DDHAL_CREATEVPORTDATA;

/*
 * structure for passing information to DDHAL FlipVideoPort fn
 */
typedef struct _DDHAL_FLIPVPORTDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    LPDDRAWI_DDRAWSURFACE_LCL   lpSurfCurr;     // current surface
    LPDDRAWI_DDRAWSURFACE_LCL   lpSurfTarg;     // target surface
    HRESULT                     ddRVal;         // return value
    LPDDHALVPORTCB_FLIP         FlipVideoPort;  // PRIVATE: ptr to callback
} DDHAL_FLIPVPORTDATA;

/*
 * structure for passing information to DDHAL GetVideoPortBandwidth fn
 */
typedef struct _DDHAL_GETVPORTBANDWIDTHDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    LPDDPIXELFORMAT             lpddpfFormat;       // Format for bandwidth
    DWORD                       dwWidth;
    DWORD                       dwHeight;
    DWORD                       dwFlags;        // Prescale factor for bandwidth
    LPDDVIDEOPORTBANDWIDTH      lpBandwidth;        // Returned bandwidth parameters
    HRESULT                     ddRVal;             // return value
    LPDDHALVPORTCB_GETBANDWIDTH GetVideoPortBandwidth;  // PRIVATE: ptr to callback
} DDHAL_GETVPORTBANDWIDTHDATA;

/*
 * structure for passing information to DDHAL GetVideoPortInputFormats fn
 */
typedef struct _DDHAL_GETVPORTINPUTFORMATDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    DWORD                       dwFlags;        // VBI, regular, or both
    LPDDPIXELFORMAT             lpddpfFormat;       // Array of formats
    DWORD                       dwNumFormats;       // # of formats in array
    HRESULT                     ddRVal;             // return value
    LPDDHALVPORTCB_GETINPUTFORMATS GetVideoPortInputFormats; // PRIVATE: ptr to callback
} DDHAL_GETVPORTINPUTFORMATDATA;

/*
 * structure for passing information to DDHAL GetVideoPortOutputFormats fn
 */
typedef struct _DDHAL_GETVPORTOUTPUTFORMATDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    DWORD                       dwFlags;        // VBI, regular, or both
    LPDDPIXELFORMAT             lpddpfInputFormat;  // Input format
    LPDDPIXELFORMAT             lpddpfOutputFormats;    // Array of output formats
    DWORD                       dwNumFormats;       // # of formats in array
    HRESULT                     ddRVal;         // return value
    LPDDHALVPORTCB_GETOUTPUTFORMATS GetVideoPortOutputFormats; // PRIVATE: ptr to callback
} DDHAL_GETVPORTOUTPUTFORMATDATA;

/*
 * structure for passing information to DDHAL GetVideoPortField fn
 */
typedef struct _DDHAL_GETVPORTFIELDDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    BOOL                        bField;         // TRUE if even
    HRESULT                     ddRVal;         // return value
    LPDDHALVPORTCB_GETFIELD     GetVideoPortField;  // PRIVATE: ptr to callback
} DDHAL_GETVPORTFIELDDATA;

/*
 * structure for passing information to DDHAL GetVideoPortLine fn
 */
typedef struct _DDHAL_GETVPORTLINEDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    DWORD                       dwLine;         // Current line counter
    HRESULT                     ddRVal;         // return value
    LPDDHALVPORTCB_GETLINE      GetVideoPortLine;   // PRIVATE: ptr to callback
} DDHAL_GETVPORTLINEDATA;

/*
 * structure for passing information to DDHAL GetVideoPortConnectInfo fn
 */
typedef struct _DDHAL_GETVPORTCONNECTDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    DWORD                       dwPortId;       // ID of desired video port
    LPDDVIDEOPORTCONNECT        lpConnect;      // Array of DDVIDEOPORTCONNECT structures
    DWORD                       dwNumEntries;       // # of structures in array
    HRESULT                     ddRVal;             // return value
    LPDDHALVPORTCB_GETVPORTCONNECT GetVideoPortConnectInfo; // PRIVATE: ptr to callback
} DDHAL_GETVPORTCONNECTDATA;

/*
 * structure for passing information to DDHAL DestroyVideoPort fn
 */
typedef struct _DDHAL_DESTROYVPORTDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    HRESULT                     ddRVal;         // return value
    LPDDHALVPORTCB_DESTROYVPORT DestroyVideoPort;   // PRIVATE: ptr to callback
} DDHAL_DESTROYVPORTDATA;

/*
 * structure for passing information to DDHAL GetVideoPortFlipStatus fn
 */
typedef struct _DDHAL_GETVPORTFLIPSTATUSDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    FLATPTR                     fpSurface;      // surface struct
    HRESULT                     ddRVal;             // return value
    LPDDHALVPORTCB_GETFLIPSTATUS GetVideoPortFlipStatus; // PRIVATE: ptr to callback
} DDHAL_GETVPORTFLIPSTATUSDATA;

/*
 * structure for passing information to DDHAL UpdateVideoPort fn
 */
typedef struct _DDHAL_UPDATEVPORTDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    LPDDRAWI_DDRAWSURFACE_INT   *lplpDDSurface;     // surface struct
    LPDDRAWI_DDRAWSURFACE_INT   *lplpDDVBISurface;  // VBI surface structure
    LPDDVIDEOPORTINFO           lpVideoInfo;        // Video information
    DWORD                       dwFlags;        // DDRAWI_VPORTSTART, DDRAWI_VPORTSTOP, DDRAWI_VPORTUPDATE
    DWORD                       dwNumAutoflip;      // # of autoflip surfaces. If > 1, lpDDSurface and lpDDVBISurface are arrays.
    DWORD                       dwNumVBIAutoflip;   // # of autoflip surfaces. If > 1, lpDDSurface and lpDDVBISurface are arrays.
    HRESULT                     ddRVal;             // return value
    LPDDHALVPORTCB_UPDATE       UpdateVideoPort;    // PRIVATE: ptr to callback
} DDHAL_UPDATEVPORTDATA;

#define DDRAWI_VPORTSTART   0x0001
#define DDRAWI_VPORTSTOP    0x0002
#define DDRAWI_VPORTUPDATE  0x0003

/*
 * structure for passing information to DDHAL WaitForVideoPortSync fn
 */
typedef struct _DDHAL_WAITFORVPORTSYNCDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    DWORD                       dwFlags;        // DDVPEVENT_XXXX
    DWORD                       dwLine;
    DWORD                       dwTimeOut;              // Max time to wait before returning
    HRESULT                     ddRVal;         // return value
    LPDDHALVPORTCB_WAITFORSYNC  WaitForVideoPortSync;   // PRIVATE: ptr to callback
} DDHAL_WAITFORVPORTSYNCDATA;

/*
 * structure for passing information to DDHAL GetVideoSignalStatus fn
 */
typedef struct _DDHAL_GETVPORTSIGNALDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    DWORD                       dwStatus;       // Video signal status
    HRESULT                     ddRVal;         // return value
    LPDDHALVPORTCB_GETSIGNALSTATUS GetVideoSignalStatus;// PRIVATE: ptr to callback
} DDHAL_GETVPORTSIGNALDATA;

/*
 * structure for passing information to DDHAL GetVideoSignalStatus fn
 */
typedef struct _DDHAL_VPORTCOLORDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;           // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;        // Video port object
    DWORD                       dwFlags;        // Video signal status
    LPDDCOLORCONTROL            lpColorData;
    HRESULT                     ddRVal;         // return value
    LPDDHALVPORTCB_COLORCONTROL ColorControl;       // PRIVATE: ptr to callback
} DDHAL_VPORTCOLORDATA;

#define DDRAWI_VPORTGETCOLOR    0x0001
#define DDRAWI_VPORTSETCOLOR    0x0002

/****************************************************************************
 *
 * DDHAL structures for Color Control callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL ColorControl fn
 */
typedef struct _DDHAL_COLORCONTROLDATA
{
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // surface
    LPDDCOLORCONTROL            lpColorData;    // color control information
    DWORD                       dwFlags;    // DDRAWI_GETCOLOR/DDRAWI_SETCOLOR
    HRESULT                     ddRVal;     // return value
    LPDDHALCOLORCB_COLORCONTROL ColorControl;   // PRIVATE: ptr to callback
} DDHAL_COLORCONTROLDATA;

#define DDRAWI_GETCOLOR     0x0001
#define DDRAWI_SETCOLOR     0x0002

/****************************************************************************
 *
 * DDHAL structure for GetDriverData callback
 *
 ***************************************************************************/

typedef struct _DDHAL_GETDRIVERINFODATA {

    // Input fields filled in by DirectDraw
    DWORD       dwSize;         // Size of this structure
    DWORD       dwFlags;        // Flags
    GUID        guidInfo;       // GUID that DirectX is querying for
    DWORD       dwExpectedSize; // Size of callbacks structure expected by DirectDraw.
    LPVOID      lpvData;        // Buffer that will receive the requested data

    // Output fields filled in by driver
    DWORD       dwActualSize;   // Size of callbacks structure expected by driver
    HRESULT     ddRVal;         // Return value from driver

    // Input field: Context information for driver
    // On Win95, this is the dwReserved3 field of the DIRECTDRAW_GBL
    // On NT, this is the hDD field of DIRECTDRAW_GBL
    ULONG_PTR   dwContext;  // Context Information

} DDHAL_GETDRIVERINFODATA;

/****************************************************************************
 *
 * DDHAL structure for misc. driver callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL GetAvailDriverMemory fn
 */
typedef struct _DDHAL_GETAVAILDRIVERMEMORYDATA
{
    LPDDRAWI_DIRECTDRAW_GBL lpDD;        // driver struct
    DDSCAPS                 DDSCaps;     // caps for type of surface memory
    DWORD                   dwTotal;     // total memory for this kind of surface
    DWORD                   dwFree;      // free memory for this kind of surface
    HRESULT                 ddRVal;      // return value
    LPDDHAL_GETAVAILDRIVERMEMORY   GetAvailDriverMemory; // PRIVATE: ptr to callback
    DDSCAPSEX               ddsCapsEx;       // Added in V6. Driver should check DDVERSION info
                                                 // to see if this field is present.
} DDHAL_GETAVAILDRIVERMEMORYDATA;

/*
 * structure for passing information to DDHEL UpdateNonLocalHeap
 */
typedef struct _DDHAL_UPDATENONLOCALHEAPDATA
{
    LPDDRAWI_DIRECTDRAW_GBL    lpDD;               // driver struct
    DWORD                      dwHeap;             // heap index
    FLATPTR                    fpGARTLin;          // linear GART address of start of heap
    FLATPTR                    fpGARTDev;          // high physical GART address of start of heap
    ULONG_PTR                  ulPolicyMaxBytes;   // maximum amount of AGP memory to use
    HRESULT                    ddRVal;             // return value
    LPDDHAL_UPDATENONLOCALHEAP UpdateNonLocalHeap; // PRIVATE: ptr to callback
} DDHAL_UPDATENONLOCALHEAPDATA;

/*
 * Heap Alignment Data Structures
 */
typedef struct _DDHAL_GETHEAPALIGNMENTDATA
{
    ULONG_PTR                  dwInstance;         // driver context as returned from 32-bit driver init routine
    DWORD                      dwHeap;             // heap index passed by DirectDraw
    HRESULT                    ddRVal;             // return value
    LPDDHAL_GETHEAPALIGNMENT   GetHeapAlignment;   // PRIVATE: ptr to callback.
    HEAPALIGNMENT              Alignment;          // Filled in by driver. Defined in dmemmgr.h
} DDHAL_GETHEAPALIGNMENTDATA;

/*
 * These are the only caps you can set in DDHAL_GETHEAPALIGNMENTDATA.Alignment.ddsCaps.
 * Any other caps will be rejected by DirectDraw.
 */

#define DDHAL_ALIGNVALIDCAPS   (DDSCAPS_OFFSCREENPLAIN | \
                                DDSCAPS_EXECUTEBUFFER | \
                                DDSCAPS_OVERLAY | \
                                DDSCAPS_TEXTURE | \
                                DDSCAPS_ZBUFFER | \
                                DDSCAPS_ALPHA | \
                                DDSCAPS_FLIP )

/*
 * Note that GetSysmemBltStatus uses the same parameter block as GetBltStatus,
 * namely DDHAL_GETBLTSTATUSDATA
 */

//@@BEGIN_DDKSPLIT
#ifdef POSTPONED2

/****************************************************************************
 *
 * DDHAL structures for Miscellaneous2 callbacks
 *
 ***************************************************************************/

/*
 * Structure that contains the information describing a sprite in the
 * display list that is passed to SetSpriteDisplayList().  This is
 * similar to the DDSPRITE structure used by applications, except
 * that the ddckDestKey, ddckSrcKey, dwRectCnt, and lpRect members
 * below are "reserved" in the DDSPRITE structure.
 */
typedef struct _DDSPRITEI {
    RECT                rcDest;     // destination rectangle
    LPDIRECTDRAWSURFACE lpDDSSrc;   // source surface
    RECT                rcSrc;      // source rectangle
    DWORD               dwFlags;    // DDSPRITE_ flags
    DWORD               dwRectCnt;  // no. of rects in clip region
    LPRECT              lpRect;     // array of clip rects
    DDSPRITEFX          ddSpriteFX;     // sprite special FX
} DDSPRITEI, *LPDDSPRITEI;

/*
 * Structure for passing information to DDHAL SetSpriteDisplayList function
 */
typedef struct _DDHAL_SETSPRITEDISPLAYLISTDATA {
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // dest surface struct
    LPDDSPRITEI                 *lplpDDSprite;  // sprite display list
    DWORD                       dwCount;    // number of sprites in list
    DWORD                       dwSize;     // size of each struct in list
    DWORD                       dwFlags;    // flags
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDTargetSurface; // target surface (to flip to)
    DWORD                       dwRectCnt;  // no. of rects in clip region
    LPRECT                      lpRect;     // array of clip rects
    HRESULT                     ddRVal;     // return value
    //LPDDHAL_SETSPRITEDISPLAYLIST SetSpriteDisplayList; // PRIVATE:  ptr to callback
} DDHAL_SETSPRITEDISPLAYLISTDATA;

/*
 * Structure for passing information to DDHAL Resize function
 */
typedef struct _DDHAL_RESIZEDATA {
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;       // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // target surface struct
    DWORD                       dwFlags;    // flags
    DWORD                       dwWidth;    // new width of surface
    DWORD                       dwHeight;   // new height of surface
    HRESULT                     ddRVal;     // return value
    //LPDDHAL_RESIZE            Resize;     // PRIVATE:  ptr to callback
} DDHAL_RESIZEDATA;

/*
 * Structure for passing information to DDHAL CaptureComposionBuffer function
 */
typedef struct _DDHAL_CAPTURECOMPOSITIONBUFFERDATA {
    LPDDRAWI_DIRECTDRAW_GBL     lpDD;           // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // dest surface struct
    DWORD                       dwFlags;        // flags
    HRESULT                     ddRVal;         // return value
    //LPDDHAL_CAPTURECOMPOSITIONBUFFER CaptureCompostionBuffer; // PRIVATE:  ptr to callback
} DDHAL_CAPTURECOMPOSITIONBUFFERDATA;

#endif //POSTPONED2
//@@END_DDKSPLIT

typedef struct _DDHAL_CREATESURFACEEXDATA {
    DWORD                       dwFlags;    // Currently always 0 and not used
    LPDDRAWI_DIRECTDRAW_LCL     lpDDLcl;    // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSLcl;   // list of created surface objects
    HRESULT                     ddRVal;     // return value
} DDHAL_CREATESURFACEEXDATA;

typedef struct _DDHAL_GETDRIVERSTATEDATA {
    DWORD                       dwFlags;        // Flags to indicate the data
                                                // required
    union
    {
        // LPDDRAWI_DIRECTDRAW_GBL     lpDD;           // driver struct
        ULONG_PTR               dwhContext;     // d3d context
    };
    LPDWORD                     lpdwStates;     // ptr to the state data
                                                // to be filled in by the
                                                // driver
    DWORD                       dwLength;
    HRESULT                     ddRVal;         // return value
} DDHAL_GETDRIVERSTATEDATA;

typedef struct _DDHAL_DESTROYDDLOCALDATA
{
    DWORD dwFlags;
    LPDDRAWI_DIRECTDRAW_LCL pDDLcl;
    HRESULT  ddRVal;
} DDHAL_DESTROYDDLOCALDATA;

/****************************************************************************
 *
 * DDHAL structure for kernel callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL SyncSurfaceData fn
 */
typedef struct _DDHAL_SYNCSURFACEDATA
{
    DWORD                       dwSize;         // Size of this structure
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;   // driver struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSurface;    // Surface to sync with
    DWORD                       dwSurfaceOffset;    // Offset in frame buffer of surface
    ULONG_PTR                   fpLockPtr;      // Surface lock ptr
    LONG                        lPitch;         // Surface pitch
    DWORD                       dwOverlayOffset;    // Added to dwSurfaceOffset for origin, clipping, etc.
    DWORD                       dwOverlaySrcWidth;  // Src width of overlay
    DWORD                       dwOverlaySrcHeight; // Src height of overlay
    DWORD                       dwOverlayDestWidth; // Dest width of overlay
    DWORD                       dwOverlayDestHeight;    // Dest height of overlay
    ULONG_PTR                           dwDriverReserved1;  // Reserved for the HAL
    ULONG_PTR                           dwDriverReserved2;  // Reserved for the HAL
    ULONG_PTR                           dwDriverReserved3;  // Reserved for the HAL
    HRESULT                     ddRVal;
} DDHAL_SYNCSURFACEDATA;

/*
 * structure for passing information to DDHAL SyncVideoPortData fn
 */
typedef struct _DDHAL_SYNCVIDEOPORTDATA
{
    DWORD                       dwSize;         // Size of this structure
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;       // driver struct
    LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;    // Video port object
    DWORD                       dwOriginOffset;     // Start address relative to surface
    DWORD                       dwHeight;       // Height of total video region (per field)
    DWORD                       dwVBIHeight;        // Height of VBI region (per field)
    ULONG_PTR                   dwDriverReserved1;  // Reserved for the HAL
    ULONG_PTR                   dwDriverReserved2;  // Reserved for the HAL
    ULONG_PTR                   dwDriverReserved3;  // Reserved for the HAL
    HRESULT                     ddRVal;
} DDHAL_SYNCVIDEOPORTDATA;

//@@BEGIN_DDKSPLIT
#ifdef POSTPONED

/****************************************************************************
 *
 * DDHAL structures for Optimized Surface callbacks
 *
 ***************************************************************************/
typedef struct _DDHAL_CANOPTIMIZESURFACEDATA
{
    DWORD               dwFlags;       //in:  Not used
    DWORD               dwSize;        //in:  For future expansion
    LPDDRAWI_DIRECTDRAW_LCL lpDD;      //in:  Driver Struct
    DDOPTSURFACEDESC    ddOptSurfDesc; //in:  OptSurf description
    DDSURFACEDESC2      ddSurfaceDesc; //in:  Surface Description
    DWORD               bCanOptimize;  //out: Can optimize or not
    ULONG_PTR            dwReserved1;   //in:  Not used
    HRESULT             ddRVal;        //out: Returned value
} DDHAL_CANOPTIMIZESURFACEDATA;

typedef struct _DDHAL_OPTIMIZESURFACEDATA
{
    DWORD               dwFlags;            //in:  Not used
    DWORD               dwSize;             //in:  For future expansion
    LPDDRAWI_DIRECTDRAW_LCL lpDD;           //in:  Driver Struct
    DDOPTSURFACEDESC    ddOptSurfDesc;      //in-out:  OptSurf description
    LPDDRAWI_DDRAWSURFACE_LCL    lpDDSSrc;  //in:  Source surface
    LPDDRAWI_DDRAWSURFACE_LCL    lpDDSDest; //in:  Destination surface
    ULONG_PTR            dwReserved1;        //in:  Not used
    HRESULT             ddRVal;             //out: Returned value
} DDHAL_OPTIMIZESURFACEDATA;

typedef struct _DDHAL_UNOPTIMIZESURFACEDATA
{
    DWORD               dwFlags;               //in:  Not used
    DWORD               dwSize;                //in:  For future expansion
    LPDDRAWI_DIRECTDRAW_LCL lpDD;              //in:  Driver Struct
    LPDDRAWI_DDRAWSURFACE_LCL     lpDDSSrc;    //in:  Source surface
    LPDDRAWI_DDRAWSURFACE_LCL     lpDDSDest;   //in:  Destination surface
    ULONG_PTR            dwReserved1;           //in:  Not used
    HRESULT             ddRVal;                //out: Returned value
} DDHAL_UNOPTIMIZESURFACEDATA;

typedef struct _DDHAL_COPYOPTSURFACEDATA
{
    DWORD               dwFlags;             //in:  Not used
    DWORD               dwSize;              //in:  For future expansion
    LPDDRAWI_DIRECTDRAW_LCL lpDD;            //in:  Driver Struct
    LPDDRAWI_DDRAWSURFACE_LCL     lpDDSSrc;  //in:  Source surface
    LPDDRAWI_DDRAWSURFACE_LCL     lpDDSDest; //in:  Destination surface
    ULONG_PTR            dwReserved1;         //in:  Not used
    HRESULT             ddRVal;              //out: Returned value
} DDHAL_COPYOPTSURFACEDATA;

typedef struct _DDHAL_KMODESVCDATA
{
    DWORD               dwFlags;             //in-out:
    DWORD               dwSize;              //in:  For future expansion
    LPDDRAWI_DIRECTDRAW_LCL lpDD;            //in:  Driver Struct
    DWORD               dwNumBytes;          //in-out: Number of bytes
                                             //        communicated
    LPVOID              lpData;              //in-out: The actual data
                                             //        communicated
    ULONG_PTR            dwReserved1;         //in:  Not used
    HRESULT             ddRVal;              //out: Returned value
} DDHAL_OPTSURFKMODESVCDATA;

#endif //POSTPONED
//@@END_DDKSPLIT

/****************************************************************************
 *
 * DDHAL structure for motion comp callbacks
 *
 ***************************************************************************/

/*
 * structure for passing information to DDHAL GetMoCompGuids
 */
typedef struct _DDHAL_GETMOCOMPGUIDSDATA
{
    LPDDRAWI_DIRECTDRAW_LCL lpDD;
    DWORD               dwNumGuids;
    LPGUID              lpGuids;
    HRESULT             ddRVal;
    LPDDHALMOCOMPCB_GETGUIDS GetMoCompGuids;
} DDHAL_GETMOCOMPGUIDSDATA;

/*
 * structure for passing information to DDHAL GetMoCompFormats
 */
typedef struct _DDHAL_GETMOCOMPFORMATSDATA
{
    LPDDRAWI_DIRECTDRAW_LCL lpDD;
    LPGUID              lpGuid;
    DWORD               dwNumFormats;
    LPDDPIXELFORMAT     lpFormats;
    HRESULT             ddRVal;
    LPDDHALMOCOMPCB_GETFORMATS   GetMoCompFormats;
} DDHAL_GETMOCOMPFORMATSDATA;

/*
 * structure for passing information to DDHAL CreateMoComp
 */
typedef struct _DDHAL_CREATEMOCOMPDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;
    LPDDRAWI_DDMOTIONCOMP_LCL   lpMoComp;
    LPGUID                      lpGuid;
    DWORD                       dwUncompWidth;
    DWORD                       dwUncompHeight;
    DDPIXELFORMAT               ddUncompPixelFormat;
    LPVOID                      lpData;
    DWORD                       dwDataSize;
    HRESULT                     ddRVal;
    LPDDHALMOCOMPCB_CREATE      CreateMoComp;
} DDHAL_CREATEMOCOMPDATA;

/*
 * structure for passing information to DDHAL GetMoCompBuffInfo
 */
typedef struct _DDMCCOMPBUFFERINFO
{
    DWORD                       dwSize;             // [in]   size of the struct
    DWORD                       dwNumCompBuffers;   // [out]  number of buffers required for compressed data
    DWORD                       dwWidthToCreate;    // [out]    Width of surface to create
    DWORD                       dwHeightToCreate;   // [out]    Height of surface to create
    DWORD                       dwBytesToAllocate;  // [out]    Total number of bytes used by each surface
    DDSCAPS2                    ddCompCaps;         // [out]    caps to create surfaces to store compressed data
    DDPIXELFORMAT               ddPixelFormat;      // [out]  format to create surfaces to store compressed data
} DDMCCOMPBUFFERINFO, *LPDDMCCOMPBUFFERINFO;

typedef struct _DDHAL_GETMOCOMPCOMPBUFFDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;
    LPGUID                      lpGuid;
    DWORD                       dwWidth;            // [in]   width of uncompressed data
    DWORD                       dwHeight;           // [in]   height of uncompressed data
    DDPIXELFORMAT               ddPixelFormat;      // [in]   pixel-format of uncompressed data
    DWORD                       dwNumTypesCompBuffs;// [in/out] number of memory types required for comp buffers
    LPDDMCCOMPBUFFERINFO        lpCompBuffInfo;     // [in]   driver supplied info regarding comp buffers (allocated by client)
    HRESULT                     ddRVal;             // [out]
    LPDDHALMOCOMPCB_GETCOMPBUFFINFO  GetMoCompBuffInfo;
} DDHAL_GETMOCOMPCOMPBUFFDATA;

/*
 * structure for passing information to DDHAL GetMoCompBuffInfo
 */
typedef struct _DDHAL_GETINTERNALMOCOMPDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;
    LPGUID                      lpGuid;
    DWORD                       dwWidth;            // [in]   width of uncompressed data
    DWORD                       dwHeight;           // [in]   height of uncompressed data
    DDPIXELFORMAT               ddPixelFormat;      // [in]   pixel-format of uncompressed data
    DWORD                       dwScratchMemAlloc;  // [out]  amount of scratch memory will the hal allocate for its private use
    HRESULT                     ddRVal;             // [out]
    LPDDHALMOCOMPCB_GETINTERNALINFO  GetInternalMoCompInfo;
} DDHAL_GETINTERNALMOCOMPDATA;

/*
 * structure for passing information to DDHAL BeginMoCompFrame
 */
typedef struct _DDHAL_BEGINMOCOMPFRAMEDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;
    LPDDRAWI_DDMOTIONCOMP_LCL   lpMoComp;
    LPDDRAWI_DDRAWSURFACE_LCL   lpDestSurface;        // [in]  destination buffer in which to decoding this frame
    DWORD                       dwInputDataSize;      // [in]  size of other misc input data to begin frame
    LPVOID                      lpInputData;          // [in]  pointer to misc input data
    DWORD                       dwOutputDataSize;     // [in]  size of other misc output data to begin frame
    LPVOID                      lpOutputData;         // [in]  pointer to output misc data (allocated by client)
    HRESULT                     ddRVal;               // [out]
    LPDDHALMOCOMPCB_BEGINFRAME  BeginMoCompFrame;
} DDHAL_BEGINMOCOMPFRAMEDATA;

/*
 * structure for passing information to DDHAL EndMoCompFrame
 */
typedef struct _DDHAL_ENDMOCOMPFRAMEDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;
    LPDDRAWI_DDMOTIONCOMP_LCL   lpMoComp;
    LPVOID                      lpInputData;
    DWORD                       dwInputDataSize;
    HRESULT                     ddRVal;
    LPDDHALMOCOMPCB_ENDFRAME    EndMoCompFrame;
} DDHAL_ENDMOCOMPFRAMEDATA;

/*
 * structure for passing information to DDHAL RenderMoComp
 */
typedef struct _DDMCBUFFERINFO
{
    DWORD                       dwSize;         // [in]    size of the struct
    LPDDRAWI_DDRAWSURFACE_LCL   lpCompSurface;  // [in]    pointer to buffer containing compressed data
    DWORD                       dwDataOffset;   // [in]    offset of relevant data from the beginning of buffer
    DWORD                       dwDataSize;     // [in]    size of relevant data
    LPVOID                      lpPrivate;      // Reserved for DirectDraw;
} DDMCBUFFERINFO, *LPDDMCBUFFERINFO;


typedef struct _DDHAL_RENDERMOCOMPDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;
    LPDDRAWI_DDMOTIONCOMP_LCL   lpMoComp;
    DWORD                       dwNumBuffers;   // [in]  Number of entries in the lpMacroBlockInfo array
    LPDDMCBUFFERINFO            lpBufferInfo;   // [in]  Surfaces containing macro block info
    DWORD                       dwFunction;     // [in]  Function
    LPVOID                      lpInputData;
    DWORD                       dwInputDataSize;
    LPVOID                      lpOutputData;
    DWORD                       dwOutputDataSize;
    HRESULT                     ddRVal;         // [out]
    LPDDHALMOCOMPCB_RENDER      RenderMoComp;
} DDHAL_RENDERMOCOMPDATA;

/*
 * structure for passing information to DDHAL QueryMoCompStatus
 */
typedef struct _DDHAL_QUERYMOCOMPSTATUSDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;
    LPDDRAWI_DDMOTIONCOMP_LCL   lpMoComp;
    LPDDRAWI_DDRAWSURFACE_LCL   lpSurface;      // [in]  Surface being queried
    DWORD                       dwFlags;        // [in]  DDMCQUERY_XXX falgs
    HRESULT                     ddRVal;         // [out]
    LPDDHALMOCOMPCB_QUERYSTATUS QueryMoCompStatus;
} DDHAL_QUERYMOCOMPSTATUSDATA;

#define DDMCQUERY_READ          0x00000001
//@@BEGIN_DDKSPLIT
#define DDMCQUERY_VALID         0x00000001
//@@END_DDKSPLIT

/*
 * structure for passing information to DDHAL DestroyVideo
 */
typedef struct _DDHAL_DESTROYMOCOMPDATA
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDD;
    LPDDRAWI_DDMOTIONCOMP_LCL   lpMoComp;
    HRESULT                     ddRVal;
    LPDDHALMOCOMPCB_DESTROY     DestroyMoComp;
} DDHAL_DESTROYMOCOMPDATA;


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\oak\inc\dxmini.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dxmini.h
 *  Content:    Miniport support for DirectDraw DXAPI.  This file is
 *              analagous to Win95's ddkmmini.h.
 *
 ***************************************************************************/

#ifndef __DXMINI_INCLUDED__
#define __DXMINI_INCLUDED__

DEFINE_GUID(GUID_DxApi, 0x8a79bef0, 0xb915, 0x11d0, 0x91, 0x44, 0x08, 0x00, 0x36, 0xd2, 0xef, 0x02);

#ifndef GUID_DEFS_ONLY
/*============================================================================
 *
 * MDL structure for handling pagelocked memory.  This is copied from WDM.H
 *
 *==========================================================================*/

#ifndef MDL_MAPPING_FLAGS

    typedef struct _MDL {
        struct _MDL *MdlNext;
        short MdlSize;
        short MdlFlags;
        struct _EPROCESS *Process;
        ULONG *lpMappedSystemVa;
        ULONG *lpStartVa;
        ULONG ByteCount;
        ULONG ByteOffset;
    } MDL;
    typedef MDL *PMDL;

    #define MDL_MAPPED_TO_SYSTEM_VA     0x0001
    #define MDL_PAGES_LOCKED            0x0002
    #define MDL_SOURCE_IS_NONPAGED_POOL 0x0004
    #define MDL_ALLOCATED_FIXED_SIZE    0x0008
    #define MDL_PARTIAL                 0x0010
    #define MDL_PARTIAL_HAS_BEEN_MAPPED 0x0020
    #define MDL_IO_PAGE_READ            0x0040
    #define MDL_WRITE_OPERATION         0x0080
    #define MDL_PARENT_MAPPED_SYSTEM_VA 0x0100
    #define MDL_LOCK_HELD               0x0200
    #define MDL_SCATTER_GATHER_VA       0x0400
    #define MDL_IO_SPACE                0x0800
    #define MDL_NETWORK_HEADER          0x1000
    #define MDL_MAPPING_CAN_FAIL        0x2000
    #define MDL_ALLOCATED_MUST_SUCCEED  0x4000
    #define MDL_64_BIT_VA               0x8000

    #define MDL_MAPPING_FLAGS (MDL_MAPPED_TO_SYSTEM_VA     | \
                           MDL_PAGES_LOCKED            | \
                           MDL_SOURCE_IS_NONPAGED_POOL | \
                           MDL_PARTIAL_HAS_BEEN_MAPPED | \
                           MDL_PARENT_MAPPED_SYSTEM_VA | \
                           MDL_LOCK_HELD               | \
                           MDL_SYSTEM_VA               | \
                           MDL_IO_SPACE )
#endif

/*============================================================================
 *
 * Error values that may be returned by the miniport
 *
 *==========================================================================*/

#define DX_OK                                   0x0
#define DXERR_UNSUPPORTED                       0x80004001
#define DXERR_GENERIC                           0x80004005
#define DXERR_OUTOFCAPS                         0x88760168

/*============================================================================
 *
 * Structures maintained by DirectDraw
 *
 *==========================================================================*/

#define DDOVER_AUTOFLIP                       	0x00100000l
#define DDOVER_BOB                       	0x00200000l
#define DDOVER_OVERRIDEBOBWEAVE			0x00400000l
#define DDOVER_INTERLEAVED			0x00800000l

//
// Data for every DXAPI surface
//

typedef struct _DDSURFACEDATA {
    DWORD       ddsCaps;                // Ring 3 creation caps
    DWORD       dwSurfaceOffset;        // Offset in frame buffer of surface
    ULONG_PTR    fpLockPtr;              // Surface lock ptr
    DWORD       dwWidth;                // Surface width
    DWORD       dwHeight;               // Surface height
    LONG        lPitch;                 // Surface pitch
    DWORD       dwOverlayFlags;         // DDOVER_XX flags
    DWORD       dwOverlayOffset;        // Offset in frame buffer of overlay
    DWORD       dwOverlaySrcWidth;	// Src width of overlay
    DWORD       dwOverlaySrcHeight;	// Src height of overlay
    DWORD       dwOverlayDestWidth;	// Dest width of overlay
    DWORD       dwOverlayDestHeight;	// Dest height of overlay
    DWORD	dwVideoPortId;		// ID of video port (-1 if not connected to a video port)
    DWORD       dwFormatFlags;
    DWORD       dwFormatFourCC;
    DWORD       dwFormatBitCount;
    DWORD       dwRBitMask;
    DWORD       dwGBitMask;
    DWORD       dwBBitMask;
    ULONG       dwDriverReserved1;      // Reserved for the HAL/Miniport
    ULONG       dwDriverReserved2;      // Reserved for the HAL/Miniport
    ULONG       dwDriverReserved3;      // Reserved for the HAL/Miniport
    ULONG       dwDriverReserved4;      // Reserved for the HAL/Miniport
} DDSURFACEDATA, *LPDDSURFACEDATA;

//
// Data for every DXAPI video port
//

typedef struct DDVIDEOPORTDATA {
    DWORD       dwVideoPortId;          // ID of video port (0 - MaxVideoPorts-1)
    DWORD       dwVPFlags;              // Video port DDVP_ option flags
    DWORD       dwOriginOffset;         // Start address relative to surface
    DWORD       dwHeight;               // Height of total video region (per field)
    DWORD       dwVBIHeight;            // Height of VBI region (per field)
    ULONG       dwDriverReserved1;      // Reserved for the HAL/Miniport
    ULONG       dwDriverReserved2;      // Reserved for the HAL/Miniport
    ULONG       dwDriverReserved3;      // Reserved for the HAL/Miniport
} DDVIDEOPORTDATA, *LPDDVIDEOPORTDATA;


/*============================================================================
 *
 * Structures used to communicate with the Miniport
 *
 *==========================================================================*/

typedef struct _DX_IRQDATA {
    DWORD       dwIrqFlags;             // DDIRQ_ flags ORed in by miniport
} DX_IRQDATA, *PDX_IRQDATA;

typedef VOID (*PDX_IRQCALLBACK)(PDX_IRQDATA pIrqData);

#define DDIRQ_DISPLAY_VSYNC			0x00000001l
#define DDIRQ_BUSMASTER                         0x00000002l
#define DDIRQ_VPORT0_VSYNC			0x00000004l
#define DDIRQ_VPORT0_LINE			0x00000008l
#define DDIRQ_VPORT1_VSYNC			0x00000010l
#define DDIRQ_VPORT1_LINE			0x00000020l
#define DDIRQ_VPORT2_VSYNC			0x00000040l
#define DDIRQ_VPORT2_LINE			0x00000080l
#define DDIRQ_VPORT3_VSYNC			0x00000100l
#define DDIRQ_VPORT3_LINE			0x00000200l
#define DDIRQ_VPORT4_VSYNC			0x00000400l
#define DDIRQ_VPORT4_LINE			0x00000800l
#define DDIRQ_VPORT5_VSYNC			0x00001000l
#define DDIRQ_VPORT5_LINE			0x00002000l
#define DDIRQ_VPORT6_VSYNC			0x00004000l
#define DDIRQ_VPORT6_LINE			0x00008000l
#define DDIRQ_VPORT7_VSYNC			0x00010000l
#define DDIRQ_VPORT7_LINE			0x00020000l
#define DDIRQ_VPORT8_VSYNC			0x00040000l
#define DDIRQ_VPORT8_LINE			0x00080000l
#define DDIRQ_VPORT9_VSYNC			0x00010000l
#define DDIRQ_VPORT9_LINE			0x00020000l

// output from DxGetIrqInfo
typedef struct _DDGETIRQINFO {
    DWORD	dwFlags;
} DDGETIRQINFO, *PDDGETIRQINFO;
#define IRQINFO_HANDLED		0x01	// Miniport is managing IRQ
#define IRQINFO_NOTHANDLED	0x02	// Not supported on NT

// input to DxEnableIrq
typedef struct _DDENABLEIRQINFO {
    DWORD           dwIRQSources;
    DWORD           dwLine;             // Line for DDIRQ_VPORTx_LINE interrupt
    PDX_IRQCALLBACK IRQCallback;	// Miniport calls this when IRQ happens
    PDX_IRQDATA     lpIRQData;          // Parameter to be passed to IRQCallback
} DDENABLEIRQINFO, *PDDENABLEIRQINFO;

// input to DxSkipNextField
typedef struct _DDSKIPNEXTFIELDINFO {
    LPDDVIDEOPORTDATA   lpVideoPortData;
    DWORD               dwSkipFlags;
} DDSKIPNEXTFIELDINFO, *PDDSKIPNEXTFIELDINFO;

#define DDSKIP_SKIPNEXT                 1
#define DDSKIP_ENABLENEXT               2

// intput to DxBobNextField
typedef struct _DDBOBNEXTFIELDINFO {
    LPDDSURFACEDATA     lpSurface;
} DDBOBNEXTFIELDINFO, *PDDBOBNEXTFIELDINFO;

// intput to DxSetState
typedef struct _DDSETSTATEININFO {
    LPDDSURFACEDATA     lpSurfaceData;
    LPDDVIDEOPORTDATA   lpVideoPortData;
} DDSETSTATEININFO, *PDDSETSTATEININFO;

// output from DxSetState
typedef struct _DDSETSTATEOUTINFO {
    BOOL                bSoftwareAutoflip;
    DWORD               dwSurfaceIndex;
    DWORD               dwVBISurfaceIndex;
} DDSETSTATEOUTINFO, *PDDSETSTATEOUTINFO;

// input to DxLock
typedef struct _DDLOCKININFO {
    LPDDSURFACEDATA     lpSurfaceData;
} DDLOCKININFO, *PDDLOCKININFO;

// output from DxLock
typedef struct _DDLOCKOUTINFO {
    ULONG_PTR            dwSurfacePtr;
} DDLOCKOUTINFO, *PDDLOCKOUTINFO;

// input to DxFlipOverlay
typedef struct _DDFLIPOVERLAYINFO {
    LPDDSURFACEDATA     lpCurrentSurface;
    LPDDSURFACEDATA     lpTargetSurface;
    DWORD               dwFlags;
} DDFLIPOVERLAYINFO, *PDDFLIPOVERLAYINFO;

// intput to DxFlipVideoPort
typedef struct _DDFLIPVIDEOPORTINFO {
    LPDDVIDEOPORTDATA   lpVideoPortData;
    LPDDSURFACEDATA     lpCurrentSurface;
    LPDDSURFACEDATA     lpTargetSurface;
    DWORD               dwFlipVPFlags;
} DDFLIPVIDEOPORTINFO, *PDDFLIPVIDEOPORTINFO;

#define DDVPFLIP_VIDEO                  0x00000001l
#define DDVPFLIP_VBI                    0x00000002l

// input to DxGetPolarity
typedef struct _DDGETPOLARITYININFO {
    LPDDVIDEOPORTDATA   lpVideoPortData;
} DDGETPOLARITYININFO, *PDDGETPOLARITYININFO;

// output from DxGetPolarity
typedef struct _DDGETPOLARITYOUTINFO {
    DWORD               bPolarity;
} DDGETPOLARITYOUTINFO, *PDDGETPOLARITYOUTINFO;

// input to DxGetCurrentAutoflipSurface
typedef struct _DDGETCURRENTAUTOFLIPININFO {
    LPDDVIDEOPORTDATA   lpVideoPortData;
} DDGETCURRENTAUTOFLIPININFO, *PDDGETCURRENTAUTOFLIPININFO;

// output from DxGetCurrentAutoflipSurface
typedef struct _DDGETCURRENTAUTOFLIPOUTINFO {
    DWORD               dwSurfaceIndex;
    DWORD               dwVBISurfaceIndex;
} DDGETCURRENTAUTOFLIPOUTINFO, *PDDGETCURRENTAUTOFLIPOUTINFO;

// input to DxGetPreviousAutoflipSurface
typedef struct _DDGETPREVIOUSAUTOFLIPININFO {
    LPDDVIDEOPORTDATA   lpVideoPortData;
} DDGETPREVIOUSAUTOFLIPININFO, *PDDGETPREVIOUSAUTOFLIPININFO;

// output from DxGetPreviousAutoflipSurface
typedef struct _DDGETPREVIOUSAUTOFLIPOUTINFO {
    DWORD               dwSurfaceIndex;
    DWORD               dwVBISurfaceIndex;
} DDGETPREVIOUSAUTOFLIPOUTINFO, *PDDGETPREVIOUSAUTOFLIPOUTINFO;

// intput to DxTransfer
typedef struct _DDTRANSFERININFO {
    LPDDSURFACEDATA	lpSurfaceData;
    DWORD		dwStartLine;
    DWORD 		dwEndLine;
    ULONG_PTR   dwTransferID;
    DWORD 		dwTransferFlags;
    PMDL  		lpDestMDL;
} DDTRANSFERININFO, *PDDTRANSFERININFO;

#define DDTRANSFER_SYSTEMMEMORY		0x00000001
#define DDTRANSFER_NONLOCALVIDMEM	0x00000002
#define DDTRANSFER_INVERT		0x00000004
#define DDTRANSFER_CANCEL		0x00000080
#define DDTRANSFER_HALFLINES		0x00000100

// output from DxTransfer
typedef struct _DDTRANSFEROUTINFO {
    DWORD dwBufferPolarity;
} DDTRANSFEROUTINFO, *PDDTRANSFEROUTINFO;

// output from DxGetTransferStatus
typedef struct _DDGETTRANSFERSTATUSOUTINFO {
    DWORD_PTR dwTransferID;
} DDGETTRANSFERSTATUSOUTINFO, *PDDGETTRANSFEROUTINFO;

/*============================================================================
 *
 * DXAPI function prototypes
 *
 *==========================================================================*/

typedef DWORD (*PDX_GETIRQINFO)(PVOID,PVOID,PDDGETIRQINFO);
typedef DWORD (*PDX_ENABLEIRQ)(PVOID,PDDENABLEIRQINFO,PVOID);
typedef DWORD (*PDX_SKIPNEXTFIELD)(PVOID,PDDSKIPNEXTFIELDINFO,PVOID);
typedef DWORD (*PDX_BOBNEXTFIELD)(PVOID,PDDBOBNEXTFIELDINFO,PVOID);
typedef DWORD (*PDX_SETSTATE)(PVOID,PDDSETSTATEININFO,PDDSETSTATEOUTINFO);
typedef DWORD (*PDX_LOCK)(PVOID,PDDLOCKININFO,PDDLOCKOUTINFO);
typedef DWORD (*PDX_FLIPOVERLAY)(PVOID,PDDFLIPOVERLAYINFO,PVOID);
typedef DWORD (*PDX_FLIPVIDEOPORT)(PVOID,PDDFLIPVIDEOPORTINFO,PVOID);
typedef DWORD (*PDX_GETPOLARITY)(PVOID,PDDGETPOLARITYININFO,PDDGETPOLARITYOUTINFO);
typedef DWORD (*PDX_GETCURRENTAUTOFLIP)(PVOID,PDDGETCURRENTAUTOFLIPININFO,PDDGETCURRENTAUTOFLIPOUTINFO);
typedef DWORD (*PDX_GETPREVIOUSAUTOFLIP)(PVOID,PDDGETPREVIOUSAUTOFLIPININFO,PDDGETPREVIOUSAUTOFLIPOUTINFO);
typedef DWORD (*PDX_TRANSFER)(PVOID,PDDTRANSFERININFO,PDDTRANSFEROUTINFO);
typedef DWORD (*PDX_GETTRANSFERSTATUS)(PVOID,PVOID,PDDGETTRANSFEROUTINFO);

/*============================================================================
 *
 * HAL table filled in by the miniport and called by DirectDraw
 *
 *==========================================================================*/

#define DXAPI_HALVERSION 0x0001

typedef struct _DXAPI_INTERFACE {

    USHORT                  Size;
    USHORT                  Version;
    PVOID                   Context;
    PVOID                   InterfaceReference;
    PVOID                   InterfaceDereference;
    PDX_GETIRQINFO          DxGetIrqInfo;
    PDX_ENABLEIRQ           DxEnableIrq;
    PDX_SKIPNEXTFIELD       DxSkipNextField;
    PDX_BOBNEXTFIELD        DxBobNextField;
    PDX_SETSTATE            DxSetState;
    PDX_LOCK                DxLock;
    PDX_FLIPOVERLAY         DxFlipOverlay;
    PDX_FLIPVIDEOPORT       DxFlipVideoPort;
    PDX_GETPOLARITY         DxGetPolarity;
    PDX_GETCURRENTAUTOFLIP  DxGetCurrentAutoflip;
    PDX_GETPREVIOUSAUTOFLIP DxGetPreviousAutoflip;
    PDX_TRANSFER	    DxTransfer;
    PDX_GETTRANSFERSTATUS   DxGetTransferStatus;

} DXAPI_INTERFACE, *PDXAPI_INTERFACE;

#endif  // GUID_DEFS_ONLY

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\oak\inc\immdev.h ===
/**********************************************************************/
/*      immdev.h - Input Method Manager definitions                   */
/*                 for IME developers                                 */
/*                                                                    */
/*      Copyright (c) Microsoft Corporation. All rights reserved.     */
/**********************************************************************/

#ifndef _IMMDEV_
#define _IMMDEV_


#ifdef __cplusplus
extern "C" {
#endif


#ifndef _IMM_SDK_DEFINED_
#define _IMM_SDK_DEFINED_

#if (WINVER >= 0x040A)
DECLARE_HANDLE(HIMC);
DECLARE_HANDLE(HIMCC);
#else
typedef DWORD   HIMC;
typedef DWORD   HIMCC;
#endif /* WINVER >= 0x040A */

typedef HKL FAR  *LPHKL;
typedef UINT FAR *LPUINT;

typedef struct tagCOMPOSITIONFORM {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} COMPOSITIONFORM, *PCOMPOSITIONFORM, NEAR *NPCOMPOSITIONFORM, FAR *LPCOMPOSITIONFORM;


typedef struct tagCANDIDATEFORM {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} CANDIDATEFORM, *PCANDIDATEFORM, NEAR *NPCANDIDATEFORM, FAR *LPCANDIDATEFORM;


typedef struct tagCANDIDATELIST {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[1];
} CANDIDATELIST, *PCANDIDATELIST, NEAR *NPCANDIDATELIST, FAR *LPCANDIDATELIST;

typedef struct tagREGISTERWORDA {
    LPSTR   lpReading;
    LPSTR   lpWord;
} REGISTERWORDA, *PREGISTERWORDA, NEAR *NPREGISTERWORDA, FAR *LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
    LPWSTR  lpReading;
    LPWSTR  lpWord;
} REGISTERWORDW, *PREGISTERWORDW, NEAR *NPREGISTERWORDW, FAR *LPREGISTERWORDW;
#ifdef UNICODE
typedef REGISTERWORDW REGISTERWORD;
typedef PREGISTERWORDW PREGISTERWORD;
typedef NPREGISTERWORDW NPREGISTERWORD;
typedef LPREGISTERWORDW LPREGISTERWORD;
#else
typedef REGISTERWORDA REGISTERWORD;
typedef PREGISTERWORDA PREGISTERWORD;
typedef NPREGISTERWORDA NPREGISTERWORD;
typedef LPREGISTERWORDA LPREGISTERWORD;
#endif // UNICODE

#if (WINVER >= 0x040A)

typedef struct tagRECONVERTSTRING {
    DWORD dwSize;
    DWORD dwVersion;
    DWORD dwStrLen;
    DWORD dwStrOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwTargetStrLen;
    DWORD dwTargetStrOffset;
} RECONVERTSTRING, *PRECONVERTSTRING, NEAR *NPRECONVERTSTRING, FAR *LPRECONVERTSTRING;

#endif /* WINVER >= 0x040A */

#define STYLE_DESCRIPTION_SIZE  32

typedef struct tagSTYLEBUFA {
    DWORD       dwStyle;
    CHAR        szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFA, *PSTYLEBUFA, NEAR *NPSTYLEBUFA, FAR *LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
    DWORD       dwStyle;
    WCHAR       szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFW, *PSTYLEBUFW, NEAR *NPSTYLEBUFW, FAR *LPSTYLEBUFW;
#ifdef UNICODE
typedef STYLEBUFW STYLEBUF;
typedef PSTYLEBUFW PSTYLEBUF;
typedef NPSTYLEBUFW NPSTYLEBUF;
typedef LPSTYLEBUFW LPSTYLEBUF;
#else
typedef STYLEBUFA STYLEBUF;
typedef PSTYLEBUFA PSTYLEBUF;
typedef NPSTYLEBUFA NPSTYLEBUF;
typedef LPSTYLEBUFA LPSTYLEBUF;
#endif // UNICODE


#if (WINVER >= 0x040A)

#define IMEMENUITEM_STRING_SIZE 80

typedef struct tagIMEMENUITEMINFOA {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    CHAR        szString[IMEMENUITEM_STRING_SIZE];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOA, *PIMEMENUITEMINFOA, NEAR *NPIMEMENUITEMINFOA, FAR *LPIMEMENUITEMINFOA;
typedef struct tagIMEMENUITEMINFOW {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    WCHAR       szString[IMEMENUITEM_STRING_SIZE];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOW, *PIMEMENUITEMINFOW, NEAR *NPIMEMENUITEMINFOW, FAR *LPIMEMENUITEMINFOW;
#ifdef UNICODE
typedef IMEMENUITEMINFOW IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOW PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOW NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOW LPIMEMENUITEMINFO;
#else
typedef IMEMENUITEMINFOA IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOA PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOA NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOA LPIMEMENUITEMINFO;
#endif // UNICODE

typedef struct tagIMECHARPOSITION {
    DWORD       dwSize;
    DWORD       dwCharPos;
    POINT       pt;
    UINT        cLineHeight;
    RECT        rcDocument;
} IMECHARPOSITION, *PIMECHARPOSITION, NEAR *NPIMECHARPOSITION, FAR *LPIMECHARPOSITION;

typedef BOOL    (CALLBACK* IMCENUMPROC)(HIMC, LPARAM);

#endif /* WINVER >= 0x040A */



// prototype of IMM API

HKL  WINAPI ImmInstallIMEA(IN LPCSTR lpszIMEFileName, IN LPCSTR lpszLayoutText);
HKL  WINAPI ImmInstallIMEW(IN LPCWSTR lpszIMEFileName, IN LPCWSTR lpszLayoutText);
#ifdef UNICODE
#define ImmInstallIME  ImmInstallIMEW
#else
#define ImmInstallIME  ImmInstallIMEA
#endif // !UNICODE

HWND WINAPI ImmGetDefaultIMEWnd(IN HWND);

UINT WINAPI ImmGetDescriptionA(IN HKL, OUT LPSTR, IN UINT uBufLen);
UINT WINAPI ImmGetDescriptionW(IN HKL, OUT LPWSTR, IN UINT uBufLen);
#ifdef UNICODE
#define ImmGetDescription  ImmGetDescriptionW
#else
#define ImmGetDescription  ImmGetDescriptionA
#endif // !UNICODE

UINT WINAPI ImmGetIMEFileNameA(IN HKL, OUT LPSTR, IN UINT uBufLen);
UINT WINAPI ImmGetIMEFileNameW(IN HKL, OUT LPWSTR, IN UINT uBufLen);
#ifdef UNICODE
#define ImmGetIMEFileName  ImmGetIMEFileNameW
#else
#define ImmGetIMEFileName  ImmGetIMEFileNameA
#endif // !UNICODE

DWORD WINAPI ImmGetProperty(IN HKL, IN DWORD);

BOOL WINAPI ImmIsIME(IN HKL);

BOOL WINAPI ImmSimulateHotKey(IN HWND, IN DWORD);

HIMC WINAPI ImmCreateContext(void);
BOOL WINAPI ImmDestroyContext(IN HIMC);
HIMC WINAPI ImmGetContext(IN HWND);
BOOL WINAPI ImmReleaseContext(IN HWND, IN HIMC);
HIMC WINAPI ImmAssociateContext(IN HWND, IN HIMC);
#if (WINVER >= 0x040A)
BOOL WINAPI ImmAssociateContextEx(IN HWND, IN HIMC, IN DWORD);
#endif /* WINVER >= 0x040A */

LONG  WINAPI ImmGetCompositionStringA(IN HIMC, IN DWORD, OUT LPVOID, IN DWORD);
LONG  WINAPI ImmGetCompositionStringW(IN HIMC, IN DWORD, OUT LPVOID, IN DWORD);
#ifdef UNICODE
#define ImmGetCompositionString  ImmGetCompositionStringW
#else
#define ImmGetCompositionString  ImmGetCompositionStringA
#endif // !UNICODE

BOOL  WINAPI ImmSetCompositionStringA(IN HIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD, IN LPVOID lpRead, IN DWORD);
BOOL  WINAPI ImmSetCompositionStringW(IN HIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD, IN LPVOID lpRead, IN DWORD);
#ifdef UNICODE
#define ImmSetCompositionString  ImmSetCompositionStringW
#else
#define ImmSetCompositionString  ImmSetCompositionStringA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListCountA(IN HIMC, OUT LPDWORD lpdwListCount);
DWORD WINAPI ImmGetCandidateListCountW(IN HIMC, OUT LPDWORD lpdwListCount);
#ifdef UNICODE
#define ImmGetCandidateListCount  ImmGetCandidateListCountW
#else
#define ImmGetCandidateListCount  ImmGetCandidateListCountA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListA(IN HIMC, IN DWORD deIndex, OUT LPCANDIDATELIST, IN DWORD dwBufLen);
DWORD WINAPI ImmGetCandidateListW(IN HIMC, IN DWORD deIndex, OUT LPCANDIDATELIST, IN DWORD dwBufLen);
#ifdef UNICODE
#define ImmGetCandidateList  ImmGetCandidateListW
#else
#define ImmGetCandidateList  ImmGetCandidateListA
#endif // !UNICODE

DWORD WINAPI ImmGetGuideLineA(IN HIMC, IN DWORD dwIndex, OUT LPSTR, IN DWORD dwBufLen);
DWORD WINAPI ImmGetGuideLineW(IN HIMC, IN DWORD dwIndex, OUT LPWSTR, IN DWORD dwBufLen);
#ifdef UNICODE
#define ImmGetGuideLine  ImmGetGuideLineW
#else
#define ImmGetGuideLine  ImmGetGuideLineA
#endif // !UNICODE

BOOL WINAPI ImmGetConversionStatus(IN HIMC, OUT LPDWORD, OUT LPDWORD);
BOOL WINAPI ImmSetConversionStatus(IN HIMC, IN DWORD, IN DWORD);
BOOL WINAPI ImmGetOpenStatus(IN HIMC);
BOOL WINAPI ImmSetOpenStatus(IN HIMC, IN BOOL);

#if defined(_WINGDI_) && !defined(NOGDI)
BOOL WINAPI ImmGetCompositionFontA(IN HIMC, OUT LPLOGFONTA);
BOOL WINAPI ImmGetCompositionFontW(IN HIMC, OUT LPLOGFONTW);
#ifdef UNICODE
#define ImmGetCompositionFont  ImmGetCompositionFontW
#else
#define ImmGetCompositionFont  ImmGetCompositionFontA
#endif // !UNICODE

BOOL WINAPI ImmSetCompositionFontA(IN HIMC, IN LPLOGFONTA);
BOOL WINAPI ImmSetCompositionFontW(IN HIMC, IN LPLOGFONTW);
#ifdef UNICODE
#define ImmSetCompositionFont  ImmSetCompositionFontW
#else
#define ImmSetCompositionFont  ImmSetCompositionFontA
#endif // !UNICODE
#endif  // defined(_WINGDI_) && !defined(NOGDI)

BOOL    WINAPI ImmConfigureIMEA(IN HKL, IN HWND, IN DWORD, IN LPVOID);
BOOL    WINAPI ImmConfigureIMEW(IN HKL, IN HWND, IN DWORD, IN LPVOID);
#ifdef UNICODE
#define ImmConfigureIME  ImmConfigureIMEW
#else
#define ImmConfigureIME  ImmConfigureIMEA
#endif // !UNICODE

LRESULT WINAPI ImmEscapeA(IN HKL, IN HIMC, IN UINT, IN LPVOID);
LRESULT WINAPI ImmEscapeW(IN HKL, IN HIMC, IN UINT, IN LPVOID);
#ifdef UNICODE
#define ImmEscape  ImmEscapeW
#else
#define ImmEscape  ImmEscapeA
#endif // !UNICODE

DWORD   WINAPI ImmGetConversionListA(IN HKL, IN HIMC, IN LPCSTR, OUT LPCANDIDATELIST, IN DWORD dwBufLen, IN UINT uFlag);
DWORD   WINAPI ImmGetConversionListW(IN HKL, IN HIMC, IN LPCWSTR, OUT LPCANDIDATELIST, IN DWORD dwBufLen, IN UINT uFlag);
#ifdef UNICODE
#define ImmGetConversionList  ImmGetConversionListW
#else
#define ImmGetConversionList  ImmGetConversionListA
#endif // !UNICODE

BOOL    WINAPI ImmNotifyIME(IN HIMC, IN DWORD dwAction, IN DWORD dwIndex, IN DWORD dwValue);

BOOL WINAPI ImmGetStatusWindowPos(IN HIMC, OUT LPPOINT);
BOOL WINAPI ImmSetStatusWindowPos(IN HIMC, IN LPPOINT);
BOOL WINAPI ImmGetCompositionWindow(IN HIMC, OUT LPCOMPOSITIONFORM);
BOOL WINAPI ImmSetCompositionWindow(IN HIMC, IN LPCOMPOSITIONFORM);
BOOL WINAPI ImmGetCandidateWindow(IN HIMC, IN DWORD, OUT LPCANDIDATEFORM);
BOOL WINAPI ImmSetCandidateWindow(IN HIMC, IN LPCANDIDATEFORM);

BOOL WINAPI ImmIsUIMessageA(IN HWND, IN UINT, IN WPARAM, IN LPARAM);
BOOL WINAPI ImmIsUIMessageW(IN HWND, IN UINT, IN WPARAM, IN LPARAM);
#ifdef UNICODE
#define ImmIsUIMessage  ImmIsUIMessageW
#else
#define ImmIsUIMessage  ImmIsUIMessageA
#endif // !UNICODE


UINT WINAPI ImmGetVirtualKey(IN HWND);

typedef int (CALLBACK *REGISTERWORDENUMPROCA)(LPCSTR, DWORD, LPCSTR, LPVOID);
typedef int (CALLBACK *REGISTERWORDENUMPROCW)(LPCWSTR, DWORD, LPCWSTR, LPVOID);
#ifdef UNICODE
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCW
#else
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCA
#endif // !UNICODE

BOOL WINAPI ImmRegisterWordA(IN HKL, IN LPCSTR lpszReading, IN DWORD, IN LPCSTR lpszRegister);
BOOL WINAPI ImmRegisterWordW(IN HKL, IN LPCWSTR lpszReading, IN DWORD, IN LPCWSTR lpszRegister);
#ifdef UNICODE
#define ImmRegisterWord  ImmRegisterWordW
#else
#define ImmRegisterWord  ImmRegisterWordA
#endif // !UNICODE

BOOL WINAPI ImmUnregisterWordA(IN HKL, IN LPCSTR lpszReading, IN DWORD, IN LPCSTR lpszUnregister);
BOOL WINAPI ImmUnregisterWordW(IN HKL, IN LPCWSTR lpszReading, IN DWORD, IN LPCWSTR lpszUnregister);
#ifdef UNICODE
#define ImmUnregisterWord  ImmUnregisterWordW
#else
#define ImmUnregisterWord  ImmUnregisterWordA
#endif // !UNICODE

UINT WINAPI ImmGetRegisterWordStyleA(IN HKL, IN UINT nItem, OUT LPSTYLEBUFA);
UINT WINAPI ImmGetRegisterWordStyleW(IN HKL, IN UINT nItem, OUT LPSTYLEBUFW);
#ifdef UNICODE
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleW
#else
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleA
#endif // !UNICODE

UINT WINAPI ImmEnumRegisterWordA(IN HKL, IN REGISTERWORDENUMPROCA, IN LPCSTR lpszReading, IN DWORD, IN LPCSTR lpszRegister, IN LPVOID);
UINT WINAPI ImmEnumRegisterWordW(IN HKL, IN REGISTERWORDENUMPROCW, IN LPCWSTR lpszReading, IN DWORD, IN LPCWSTR lpszRegister, IN LPVOID);
#ifdef UNICODE
#define ImmEnumRegisterWord  ImmEnumRegisterWordW
#else
#define ImmEnumRegisterWord  ImmEnumRegisterWordA
#endif // !UNICODE

#if (WINVER >= 0x040A)
BOOL WINAPI ImmDisableIME(IN DWORD);
BOOL WINAPI ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);
DWORD WINAPI ImmGetImeMenuItemsA(IN HIMC, IN DWORD, IN DWORD, OUT LPIMEMENUITEMINFOA, OUT LPIMEMENUITEMINFOA, IN DWORD);
DWORD WINAPI ImmGetImeMenuItemsW(IN HIMC, IN DWORD, IN DWORD, OUT LPIMEMENUITEMINFOW, OUT LPIMEMENUITEMINFOW, IN DWORD);
#ifdef UNICODE
#define ImmGetImeMenuItems  ImmGetImeMenuItemsW
#else
#define ImmGetImeMenuItems  ImmGetImeMenuItemsA
#endif // !UNICODE

BOOL WINAPI ImmDisableTextFrameService(DWORD idThread);
#endif /* WINVER >= 0x040A */

// wParam for WM_IME_CONTROL
#define IMC_GETCANDIDATEPOS             0x0007
#define IMC_SETCANDIDATEPOS             0x0008
#define IMC_GETCOMPOSITIONFONT          0x0009
#define IMC_SETCOMPOSITIONFONT          0x000A
#define IMC_GETCOMPOSITIONWINDOW        0x000B
#define IMC_SETCOMPOSITIONWINDOW        0x000C
#define IMC_GETSTATUSWINDOWPOS          0x000F
#define IMC_SETSTATUSWINDOWPOS          0x0010
#define IMC_CLOSESTATUSWINDOW           0x0021
#define IMC_OPENSTATUSWINDOW            0x0022


// dwAction for ImmNotifyIME
#define NI_OPENCANDIDATE                0x0010
#define NI_CLOSECANDIDATE               0x0011
#define NI_SELECTCANDIDATESTR           0x0012
#define NI_CHANGECANDIDATELIST          0x0013
#define NI_FINALIZECONVERSIONRESULT     0x0014
#define NI_COMPOSITIONSTR               0x0015
#define NI_SETCANDIDATE_PAGESTART       0x0016
#define NI_SETCANDIDATE_PAGESIZE        0x0017
#define NI_IMEMENUSELECTED              0x0018

// lParam for WM_IME_SETCONTEXT
#define ISC_SHOWUICANDIDATEWINDOW       0x00000001
#define ISC_SHOWUICOMPOSITIONWINDOW     0x80000000
#define ISC_SHOWUIGUIDELINE             0x40000000
#define ISC_SHOWUIALLCANDIDATEWINDOW    0x0000000F
#define ISC_SHOWUIALL                   0xC000000F


// dwIndex for ImmNotifyIME/NI_COMPOSITIONSTR
#define CPS_COMPLETE                    0x0001
#define CPS_CONVERT                     0x0002
#define CPS_REVERT                      0x0003
#define CPS_CANCEL                      0x0004

// the modifiers of hot key
#define MOD_ALT                         0x0001
#define MOD_CONTROL                     0x0002
#define MOD_SHIFT                       0x0004

#define MOD_LEFT                        0x8000
#define MOD_RIGHT                       0x4000

#define MOD_ON_KEYUP                    0x0800
#define MOD_IGNORE_ALL_MODIFIER         0x0400

// Windows for Simplified Chinese Edition hot key ID from 0x10 - 0x2F
#define IME_CHOTKEY_IME_NONIME_TOGGLE           0x10
#define IME_CHOTKEY_SHAPE_TOGGLE                0x11
#define IME_CHOTKEY_SYMBOL_TOGGLE               0x12

// Windows for Japanese Edition hot key ID from 0x30 - 0x4F
#define IME_JHOTKEY_CLOSE_OPEN                  0x30

// Windows for Korean Edition hot key ID from 0x50 - 0x6F
#define IME_KHOTKEY_SHAPE_TOGGLE                0x50
#define IME_KHOTKEY_HANJACONVERT                0x51
#define IME_KHOTKEY_ENGLISH                     0x52

// Windows for Traditional Chinese Edition hot key ID from 0x70 - 0x8F
#define IME_THOTKEY_IME_NONIME_TOGGLE           0x70
#define IME_THOTKEY_SHAPE_TOGGLE                0x71
#define IME_THOTKEY_SYMBOL_TOGGLE               0x72

// direct switch hot key ID from 0x100 - 0x11F
#define IME_HOTKEY_DSWITCH_FIRST                0x100
#define IME_HOTKEY_DSWITCH_LAST                 0x11F

// IME private hot key from 0x200 - 0x21F
#define IME_HOTKEY_PRIVATE_FIRST                0x200
#define IME_ITHOTKEY_RESEND_RESULTSTR           0x200
#define IME_ITHOTKEY_PREVIOUS_COMPOSITION       0x201
#define IME_ITHOTKEY_UISTYLE_TOGGLE             0x202
#define IME_ITHOTKEY_RECONVERTSTRING            0x203
#define IME_HOTKEY_PRIVATE_LAST                 0x21F


// parameter of ImmGetCompositionString
#define GCS_COMPREADSTR                 0x0001
#define GCS_COMPREADATTR                0x0002
#define GCS_COMPREADCLAUSE              0x0004
#define GCS_COMPSTR                     0x0008
#define GCS_COMPATTR                    0x0010
#define GCS_COMPCLAUSE                  0x0020
#define GCS_CURSORPOS                   0x0080
#define GCS_DELTASTART                  0x0100
#define GCS_RESULTREADSTR               0x0200
#define GCS_RESULTREADCLAUSE            0x0400
#define GCS_RESULTSTR                   0x0800
#define GCS_RESULTCLAUSE                0x1000

// style bit flags for WM_IME_COMPOSITION
#define CS_INSERTCHAR                   0x2000
#define CS_NOMOVECARET                  0x4000


// IME version constants
#define IMEVER_0310                     0x0003000A
#define IMEVER_0400                     0x00040000


// IME property bits
#define IME_PROP_AT_CARET               0x00010000
#define IME_PROP_SPECIAL_UI             0x00020000
#define IME_PROP_CANDLIST_START_FROM_1  0x00040000
#define IME_PROP_UNICODE                0x00080000
#define IME_PROP_COMPLETE_ON_UNSELECT   0x00100000


// IME UICapability bits
#define UI_CAP_2700                     0x00000001
#define UI_CAP_ROT90                    0x00000002
#define UI_CAP_ROTANY                   0x00000004

// ImmSetCompositionString Capability bits
#define SCS_CAP_COMPSTR                 0x00000001
#define SCS_CAP_MAKEREAD                0x00000002
#define SCS_CAP_SETRECONVERTSTRING      0x00000004


// IME WM_IME_SELECT inheritance Capability bits
#define SELECT_CAP_CONVERSION           0x00000001
#define SELECT_CAP_SENTENCE             0x00000002


// ID for deIndex of ImmGetGuideLine
#define GGL_LEVEL                       0x00000001
#define GGL_INDEX                       0x00000002
#define GGL_STRING                      0x00000003
#define GGL_PRIVATE                     0x00000004


// ID for dwLevel of GUIDELINE Structure
#define GL_LEVEL_NOGUIDELINE            0x00000000
#define GL_LEVEL_FATAL                  0x00000001
#define GL_LEVEL_ERROR                  0x00000002
#define GL_LEVEL_WARNING                0x00000003
#define GL_LEVEL_INFORMATION            0x00000004


// ID for dwIndex of GUIDELINE Structure
#define GL_ID_UNKNOWN                   0x00000000
#define GL_ID_NOMODULE                  0x00000001
#define GL_ID_NODICTIONARY              0x00000010
#define GL_ID_CANNOTSAVE                0x00000011
#define GL_ID_NOCONVERT                 0x00000020
#define GL_ID_TYPINGERROR               0x00000021
#define GL_ID_TOOMANYSTROKE             0x00000022
#define GL_ID_READINGCONFLICT           0x00000023
#define GL_ID_INPUTREADING              0x00000024
#define GL_ID_INPUTRADICAL              0x00000025
#define GL_ID_INPUTCODE                 0x00000026
#define GL_ID_INPUTSYMBOL               0x00000027
#define GL_ID_CHOOSECANDIDATE           0x00000028
#define GL_ID_REVERSECONVERSION         0x00000029
#define GL_ID_PRIVATE_FIRST             0x00008000
#define GL_ID_PRIVATE_LAST              0x0000FFFF


// ID for dwIndex of ImmGetProperty
#define IGP_GETIMEVERSION               (DWORD)(-4)
#define IGP_PROPERTY                    0x00000004
#define IGP_CONVERSION                  0x00000008
#define IGP_SENTENCE                    0x0000000c
#define IGP_UI                          0x00000010
#define IGP_SETCOMPSTR                  0x00000014
#define IGP_SELECT                      0x00000018

// dwIndex for ImmSetCompositionString API
#define SCS_SETSTR                      (GCS_COMPREADSTR|GCS_COMPSTR)
#define SCS_CHANGEATTR                  (GCS_COMPREADATTR|GCS_COMPATTR)
#define SCS_CHANGECLAUSE                (GCS_COMPREADCLAUSE|GCS_COMPCLAUSE)
#define SCS_SETRECONVERTSTRING          0x00010000
#define SCS_QUERYRECONVERTSTRING        0x00020000

// attribute for COMPOSITIONSTRING Structure
#define ATTR_INPUT                      0x00
#define ATTR_TARGET_CONVERTED           0x01
#define ATTR_CONVERTED                  0x02
#define ATTR_TARGET_NOTCONVERTED        0x03
#define ATTR_INPUT_ERROR                0x04
#define ATTR_FIXEDCONVERTED             0x05

// bit field for IMC_SETCOMPOSITIONWINDOW, IMC_SETCANDIDATEWINDOW
#define CFS_DEFAULT                     0x0000
#define CFS_RECT                        0x0001
#define CFS_POINT                       0x0002
#define CFS_FORCE_POSITION              0x0020
#define CFS_CANDIDATEPOS                0x0040
#define CFS_EXCLUDE                     0x0080

// conversion direction for ImmGetConversionList
#define GCL_CONVERSION                  0x0001
#define GCL_REVERSECONVERSION           0x0002
#define GCL_REVERSE_LENGTH              0x0003

// bit field for conversion mode
#define IME_CMODE_ALPHANUMERIC          0x0000
#define IME_CMODE_NATIVE                0x0001
#define IME_CMODE_CHINESE               IME_CMODE_NATIVE
// IME_CMODE_HANGEUL is old name of IME_CMODE_HANGUL. It will be gone eventually.
#define IME_CMODE_HANGEUL               IME_CMODE_NATIVE
#define IME_CMODE_HANGUL                IME_CMODE_NATIVE
#define IME_CMODE_JAPANESE              IME_CMODE_NATIVE
#define IME_CMODE_KATAKANA              0x0002  // only effect under IME_CMODE_NATIVE
#define IME_CMODE_LANGUAGE              0x0003
#define IME_CMODE_FULLSHAPE             0x0008
#define IME_CMODE_ROMAN                 0x0010
#define IME_CMODE_CHARCODE              0x0020
#define IME_CMODE_HANJACONVERT          0x0040
#define IME_CMODE_SOFTKBD               0x0080
#define IME_CMODE_NOCONVERSION          0x0100
#define IME_CMODE_EUDC                  0x0200
#define IME_CMODE_SYMBOL                0x0400
#define IME_CMODE_FIXED                 0x0800
#define IME_CMODE_RESERVED          0xF0000000

// bit field for sentence mode
#define IME_SMODE_NONE                  0x0000
#define IME_SMODE_PLAURALCLAUSE         0x0001
#define IME_SMODE_SINGLECONVERT         0x0002
#define IME_SMODE_AUTOMATIC             0x0004
#define IME_SMODE_PHRASEPREDICT         0x0008
#define IME_SMODE_CONVERSATION          0x0010
#define IME_SMODE_RESERVED          0x0000F000


// style of candidate
#define IME_CAND_UNKNOWN                0x0000
#define IME_CAND_READ                   0x0001
#define IME_CAND_CODE                   0x0002
#define IME_CAND_MEANING                0x0003
#define IME_CAND_RADICAL                0x0004
#define IME_CAND_STROKE                 0x0005

// wParam of report message WM_IME_NOTIFY
#define IMN_CLOSESTATUSWINDOW           0x0001
#define IMN_OPENSTATUSWINDOW            0x0002
#define IMN_CHANGECANDIDATE             0x0003
#define IMN_CLOSECANDIDATE              0x0004
#define IMN_OPENCANDIDATE               0x0005
#define IMN_SETCONVERSIONMODE           0x0006
#define IMN_SETSENTENCEMODE             0x0007
#define IMN_SETOPENSTATUS               0x0008
#define IMN_SETCANDIDATEPOS             0x0009
#define IMN_SETCOMPOSITIONFONT          0x000A
#define IMN_SETCOMPOSITIONWINDOW        0x000B
#define IMN_SETSTATUSWINDOWPOS          0x000C
#define IMN_GUIDELINE                   0x000D
#define IMN_PRIVATE                     0x000E

#if (WINVER >= 0x040A)
// wParam of report message WM_IME_REQUEST
#define IMR_COMPOSITIONWINDOW           0x0001
#define IMR_CANDIDATEWINDOW             0x0002
#define IMR_COMPOSITIONFONT             0x0003
#define IMR_RECONVERTSTRING             0x0004
#define IMR_CONFIRMRECONVERTSTRING      0x0005
#define IMR_QUERYCHARPOSITION           0x0006
#define IMR_DOCUMENTFEED                0x0007
#endif /* WINVER >= 0x040A */

// error code of ImmGetCompositionString
#define IMM_ERROR_NODATA                (-1)
#define IMM_ERROR_GENERAL               (-2)


// dialog mode of ImmConfigureIME
#define IME_CONFIG_GENERAL              1
#define IME_CONFIG_REGISTERWORD         2
#define IME_CONFIG_SELECTDICTIONARY     3


// flags for ImmEscape
#define IME_ESC_QUERY_SUPPORT           0x0003
#define IME_ESC_RESERVED_FIRST          0x0004
#define IME_ESC_RESERVED_LAST           0x07FF
#define IME_ESC_PRIVATE_FIRST           0x0800
#define IME_ESC_PRIVATE_LAST            0x0FFF

#define IME_ESC_SEQUENCE_TO_INTERNAL    0x1001
#define IME_ESC_GET_EUDC_DICTIONARY     0x1003
#define IME_ESC_SET_EUDC_DICTIONARY     0x1004
#define IME_ESC_MAX_KEY                 0x1005
#define IME_ESC_IME_NAME                0x1006
#define IME_ESC_SYNC_HOTKEY             0x1007
#define IME_ESC_HANJA_MODE              0x1008
#define IME_ESC_AUTOMATA                0x1009
#define IME_ESC_PRIVATE_HOTKEY          0x100a
#define IME_ESC_GETHELPFILENAME         0x100b

// style of word registration
#define IME_REGWORD_STYLE_EUDC          0x00000001
#define IME_REGWORD_STYLE_USER_FIRST    0x80000000
#define IME_REGWORD_STYLE_USER_LAST     0xFFFFFFFF


#if (WINVER >= 0x040A)

// dwFlags for ImmAssociateContextEx
#define IACE_CHILDREN                   0x0001
#define IACE_DEFAULT                    0x0010
#define IACE_IGNORENOCONTEXT            0x0020

// dwFlags for ImmGetImeMenuItems
#define IGIMIF_RIGHTMENU                0x0001

// dwType for ImmGetImeMenuItems
#define IGIMII_CMODE                    0x0001
#define IGIMII_SMODE                    0x0002
#define IGIMII_CONFIGURE                0x0004
#define IGIMII_TOOLS                    0x0008
#define IGIMII_HELP                     0x0010
#define IGIMII_OTHER                    0x0020
#define IGIMII_INPUTTOOLS               0x0040

// fType of IMEMENUITEMINFO structure
#define IMFT_RADIOCHECK 0x00001
#define IMFT_SEPARATOR  0x00002
#define IMFT_SUBMENU    0x00004

// fState of IMEMENUITEMINFO structure
#define IMFS_GRAYED          MFS_GRAYED
#define IMFS_DISABLED        MFS_DISABLED
#define IMFS_CHECKED         MFS_CHECKED
#define IMFS_HILITE          MFS_HILITE
#define IMFS_ENABLED         MFS_ENABLED
#define IMFS_UNCHECKED       MFS_UNCHECKED
#define IMFS_UNHILITE        MFS_UNHILITE
#define IMFS_DEFAULT         MFS_DEFAULT

#endif /* WINVER >= 0x040A */

// type of soft keyboard
// for Windows Tranditional Chinese Edition
#define SOFTKEYBOARD_TYPE_T1            0x0001
// for Windows Simplified Chinese Edition
#define SOFTKEYBOARD_TYPE_C1            0x0002


#endif  // _IMM_SDK_DEFINED_

#ifndef _IMM_DDK_DEFINED_
#define _IMM_DDK_DEFINED_

typedef struct tagCOMPOSITIONSTRING {
    DWORD dwSize;
    DWORD dwCompReadAttrLen;
    DWORD dwCompReadAttrOffset;
    DWORD dwCompReadClauseLen;
    DWORD dwCompReadClauseOffset;
    DWORD dwCompReadStrLen;
    DWORD dwCompReadStrOffset;
    DWORD dwCompAttrLen;
    DWORD dwCompAttrOffset;
    DWORD dwCompClauseLen;
    DWORD dwCompClauseOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwCursorPos;
    DWORD dwDeltaStart;
    DWORD dwResultReadClauseLen;
    DWORD dwResultReadClauseOffset;
    DWORD dwResultReadStrLen;
    DWORD dwResultReadStrOffset;
    DWORD dwResultClauseLen;
    DWORD dwResultClauseOffset;
    DWORD dwResultStrLen;
    DWORD dwResultStrOffset;
    DWORD dwPrivateSize;
    DWORD dwPrivateOffset;
} COMPOSITIONSTRING, *PCOMPOSITIONSTRING, NEAR *NPCOMPOSITIONSTRING, FAR  *LPCOMPOSITIONSTRING;

typedef struct tagGUIDELINE {
    DWORD dwSize;
    DWORD dwLevel;
    DWORD dwIndex;
    DWORD dwStrLen;
    DWORD dwStrOffset;
    DWORD dwPrivateSize;
    DWORD dwPrivateOffset;
} GUIDELINE, *PGUIDELINE, NEAR *NPGUIDELINE, FAR *LPGUIDELINE;

#if (WINVER >= 0x040A)

typedef struct tagTRANSMSG {
    UINT   message;
    WPARAM wParam;
    LPARAM lParam;
} TRANSMSG, *PTRANSMSG, NEAR *NPTRANSMSG, FAR *LPTRANSMSG;

typedef struct tagTRANSMSGLIST {
    UINT     uMsgCount;
    TRANSMSG TransMsg[1];
} TRANSMSGLIST, *PTRANSMSGLIST, NEAR *NPTRANSMSGLIST, FAR *LPTRANSMSGLIST;

#endif /* WINVER >= 0x040A */

typedef struct tagCANDIDATEINFO {
    DWORD               dwSize;
    DWORD               dwCount;
    DWORD               dwOffset[32];
    DWORD               dwPrivateSize;
    DWORD               dwPrivateOffset;
} CANDIDATEINFO, *PCANDIDATEINFO, NEAR *NPCANDIDATEINFO, FAR *LPCANDIDATEINFO;


typedef struct tagINPUTCONTEXT {
    HWND                hWnd;
    BOOL                fOpen;
    POINT               ptStatusWndPos;
    POINT               ptSoftKbdPos;
    DWORD               fdwConversion;
    DWORD               fdwSentence;
    union   {
        LOGFONTA        A;
        LOGFONTW        W;
    } lfFont;
    COMPOSITIONFORM     cfCompForm;
    CANDIDATEFORM       cfCandForm[4];
    HIMCC               hCompStr;
    HIMCC               hCandInfo;
    HIMCC               hGuideLine;
    HIMCC               hPrivate;
    DWORD               dwNumMsgBuf;
    HIMCC               hMsgBuf;
    DWORD               fdwInit;
    DWORD               dwReserve[3];
} INPUTCONTEXT, *PINPUTCONTEXT, NEAR *NPINPUTCONTEXT, FAR *LPINPUTCONTEXT;

typedef struct tagIMEINFO {
    DWORD       dwPrivateDataSize;
    DWORD       fdwProperty;
    DWORD       fdwConversionCaps;
    DWORD       fdwSentenceCaps;
    DWORD       fdwUICaps;
    DWORD       fdwSCSCaps;
    DWORD       fdwSelectCaps;
} IMEINFO, *PIMEINFO, NEAR *NPIMEINFO, FAR *LPIMEINFO;

typedef struct tagSOFTKBDDATA {
    UINT        uCount;
    WORD        wCode[1][256];
} SOFTKBDDATA, *PSOFTKBDDATA, NEAR *NPSOFTKBDDATA, FAR * LPSOFTKBDDATA;


BOOL WINAPI ImmGetHotKey(IN DWORD, OUT LPUINT lpuModifiers, OUT LPUINT lpuVKey, OUT LPHKL);
BOOL WINAPI ImmSetHotKey(IN DWORD, IN UINT, IN UINT, IN HKL);
BOOL WINAPI ImmGenerateMessage(IN HIMC);
#if (WINVER >= 0x040A)
LRESULT WINAPI ImmRequestMessageA(IN HIMC, IN WPARAM, IN LPARAM);
LRESULT WINAPI ImmRequestMessageW(IN HIMC, IN WPARAM, IN LPARAM);
#ifdef UNICODE
#define ImmRequestMessage  ImmRequestMessageW
#else
#define ImmRequestMessage  ImmRequestMessageA
#endif // !UNICODE
#endif /* WINVER >= 0x040A */

//
// Prototype of soft keyboard APIs
//

HWND WINAPI ImmCreateSoftKeyboard(IN UINT, IN HWND, IN int, IN int);
BOOL WINAPI ImmDestroySoftKeyboard(IN HWND);
BOOL WINAPI ImmShowSoftKeyboard(IN HWND, IN int);

LPINPUTCONTEXT WINAPI ImmLockIMC(IN HIMC);
BOOL  WINAPI ImmUnlockIMC(IN HIMC);
DWORD WINAPI ImmGetIMCLockCount(IN HIMC);

HIMCC  WINAPI ImmCreateIMCC(IN DWORD);
HIMCC  WINAPI ImmDestroyIMCC(IN HIMCC);
LPVOID WINAPI ImmLockIMCC(IN HIMCC);
BOOL   WINAPI ImmUnlockIMCC(IN HIMCC);
DWORD  WINAPI ImmGetIMCCLockCount(IN HIMCC);
HIMCC  WINAPI ImmReSizeIMCC(IN HIMCC, IN DWORD);
DWORD  WINAPI ImmGetIMCCSize(IN HIMCC);

// the window extra offset
#define IMMGWL_IMC                      0
#define IMMGWL_PRIVATE                  (sizeof(LONG))

#ifdef _WIN64
#undef IMMGWL_IMC
#undef IMMGWL_PRIVATE
#endif /* _WIN64 */

#define IMMGWLP_IMC                     0
#define IMMGWLP_PRIVATE                 (sizeof(LONG_PTR))


// for NI_CONTEXTUPDATED
#define IMC_SETCONVERSIONMODE           0x0002
#define IMC_SETSENTENCEMODE             0x0004
#define IMC_SETOPENSTATUS               0x0006

// wParam for WM_IME_CONTROL to the soft keyboard
#define IMC_GETSOFTKBDFONT              0x0011
#define IMC_SETSOFTKBDFONT              0x0012
#define IMC_GETSOFTKBDPOS               0x0013
#define IMC_SETSOFTKBDPOS               0x0014
#define IMC_GETSOFTKBDSUBTYPE           0x0015
#define IMC_SETSOFTKBDSUBTYPE           0x0016
#define IMC_SETSOFTKBDDATA              0x0018


// dwAction for ImmNotifyIME
#define NI_CONTEXTUPDATED               0x0003
// dwSystemInfoFlags bits
#define IME_SYSINFO_WINLOGON            0x0001
#define IME_SYSINFO_WOW16               0x0002

#define GCS_COMP                        (GCS_COMPSTR|GCS_COMPATTR|GCS_COMPCLAUSE)
#define GCS_COMPREAD                    (GCS_COMPREADSTR|GCS_COMPREADATTR |GCS_COMPREADCLAUSE)
#define GCS_RESULT                      (GCS_RESULTSTR|GCS_RESULTCLAUSE)
#define GCS_RESULTREAD                  (GCS_RESULTREADSTR|GCS_RESULTREADCLAUSE)


// bits of fdwInit of INPUTCONTEXT
#define INIT_STATUSWNDPOS               0x00000001
#define INIT_CONVERSION                 0x00000002
#define INIT_SENTENCE                   0x00000004
#define INIT_LOGFONT                    0x00000008
#define INIT_COMPFORM                   0x00000010
#define INIT_SOFTKBDPOS                 0x00000020


// IME property bits
#define IME_PROP_END_UNLOAD             0x00000001
#define IME_PROP_KBD_CHAR_FIRST         0x00000002
#define IME_PROP_IGNORE_UPKEYS          0x00000004
#define IME_PROP_NEED_ALTKEY            0x00000008
#define IME_PROP_NO_KEYS_ON_CLOSE       0x00000010
#define IME_PROP_ACCEPT_WIDE_VKEY       0x00000020

// IME UICapability bits
#define UI_CAP_SOFTKBD                  0x00010000

#define IMN_SOFTKBDDESTROYED            0x0011


// flags for ImmEscape
// prototype of IME APIs
BOOL    WINAPI ImeInquire(IN LPIMEINFO, OUT LPTSTR lpszUIClass, IN DWORD dwSystemInfoFlags);
BOOL    WINAPI ImeConfigure(IN HKL, IN HWND, IN DWORD, IN LPVOID);
DWORD   WINAPI ImeConversionList(HIMC, LPCTSTR, LPCANDIDATELIST, DWORD dwBufLen, UINT uFlag);
BOOL    WINAPI ImeDestroy(UINT);
LRESULT WINAPI ImeEscape(HIMC, UINT, LPVOID);
BOOL    WINAPI ImeProcessKey(IN HIMC, IN UINT, IN LPARAM, IN CONST LPBYTE);
BOOL    WINAPI ImeSelect(IN HIMC, IN BOOL);
BOOL    WINAPI ImeSetActiveContext(IN HIMC, IN BOOL);
#if (WINVER >= 0x040A)
UINT    WINAPI ImeToAsciiEx(IN UINT uVirtKey, IN UINT uScaCode, IN CONST LPBYTE lpbKeyState, OUT LPTRANSMSGLIST lpTransBuf, IN UINT fuState, IN HIMC);
#else
UINT    WINAPI ImeToAsciiEx(IN UINT uVirtKey, IN UINT uScaCode, IN CONST LPBYTE lpbKeyState, OUT LPDWORD lpdwTransBuf, IN UINT fuState, IN HIMC);
#endif /* WINVER >= 0x040A */
BOOL    WINAPI NotifyIME(IN HIMC, IN DWORD, IN DWORD, IN DWORD);
BOOL    WINAPI ImeRegisterWord(IN LPCTSTR, IN DWORD, IN LPCTSTR);
BOOL    WINAPI ImeUnregisterWord(IN LPCTSTR, IN DWORD, IN LPCTSTR);
UINT    WINAPI ImeGetRegisterWordStyle(IN UINT nItem, OUT LPSTYLEBUF);
UINT    WINAPI ImeEnumRegisterWord(IN REGISTERWORDENUMPROC, IN LPCTSTR, IN DWORD, IN LPCTSTR, IN LPVOID);
BOOL    WINAPI ImeSetCompositionString(IN HIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD, IN LPVOID lpRead, IN DWORD);

#endif  // _IMM_DDK_DEFINED_

#ifdef __cplusplus
}
#endif

#endif  // _IMMDEV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\oak\inc\gldrv.h ===
/*++ BUILD Version: 0001

Copyright (c) 1985-94, Microsoft Corporation

Module Name:

    gldrv.h

Abstract:

    Private entry points, defines and types for Installable OpenGL DDI.

--*/

#ifndef _GLDRV_
#define _GLDRV_

typedef struct _GLDISPATCHTABLE {
    void      (APIENTRY *glNewList                )( GLuint list, GLenum mode );
    void      (APIENTRY *glEndList                )( void );
    void      (APIENTRY *glCallList               )( GLuint list );
    void      (APIENTRY *glCallLists              )( GLsizei n, GLenum type, const GLvoid *lists );
    void      (APIENTRY *glDeleteLists            )( GLuint list, GLsizei range );
    GLuint    (APIENTRY *glGenLists               )( GLsizei range );
    void      (APIENTRY *glListBase               )( GLuint base );
    void      (APIENTRY *glBegin                  )( GLenum mode );
    void      (APIENTRY *glBitmap                 )( GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap );
    void      (APIENTRY *glColor3b                )( GLbyte red, GLbyte green, GLbyte blue );
    void      (APIENTRY *glColor3bv               )( const GLbyte *v );
    void      (APIENTRY *glColor3d                )( GLdouble red, GLdouble green, GLdouble blue );
    void      (APIENTRY *glColor3dv               )( const GLdouble *v );
    void      (APIENTRY *glColor3f                )( GLfloat red, GLfloat green, GLfloat blue );
    void      (APIENTRY *glColor3fv               )( const GLfloat *v );
    void      (APIENTRY *glColor3i                )( GLint red, GLint green, GLint blue );
    void      (APIENTRY *glColor3iv               )( const GLint *v );
    void      (APIENTRY *glColor3s                )( GLshort red, GLshort green, GLshort blue );
    void      (APIENTRY *glColor3sv               )( const GLshort *v );
    void      (APIENTRY *glColor3ub               )( GLubyte red, GLubyte green, GLubyte blue );
    void      (APIENTRY *glColor3ubv              )( const GLubyte *v );
    void      (APIENTRY *glColor3ui               )( GLuint red, GLuint green, GLuint blue );
    void      (APIENTRY *glColor3uiv              )( const GLuint *v );
    void      (APIENTRY *glColor3us               )( GLushort red, GLushort green, GLushort blue );
    void      (APIENTRY *glColor3usv              )( const GLushort *v );
    void      (APIENTRY *glColor4b                )( GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha );
    void      (APIENTRY *glColor4bv               )( const GLbyte *v );
    void      (APIENTRY *glColor4d                )( GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha );
    void      (APIENTRY *glColor4dv               )( const GLdouble *v );
    void      (APIENTRY *glColor4f                )( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha );
    void      (APIENTRY *glColor4fv               )( const GLfloat *v );
    void      (APIENTRY *glColor4i                )( GLint red, GLint green, GLint blue, GLint alpha );
    void      (APIENTRY *glColor4iv               )( const GLint *v );
    void      (APIENTRY *glColor4s                )( GLshort red, GLshort green, GLshort blue, GLshort alpha );
    void      (APIENTRY *glColor4sv               )( const GLshort *v );
    void      (APIENTRY *glColor4ub               )( GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha );
    void      (APIENTRY *glColor4ubv              )( const GLubyte *v );
    void      (APIENTRY *glColor4ui               )( GLuint red, GLuint green, GLuint blue, GLuint alpha );
    void      (APIENTRY *glColor4uiv              )( const GLuint *v );
    void      (APIENTRY *glColor4us               )( GLushort red, GLushort green, GLushort blue, GLushort alpha );
    void      (APIENTRY *glColor4usv              )( const GLushort *v );
    void      (APIENTRY *glEdgeFlag               )( GLboolean flag );
    void      (APIENTRY *glEdgeFlagv              )( const GLboolean *flag );
    void      (APIENTRY *glEnd                    )( void );
    void      (APIENTRY *glIndexd                 )( GLdouble c );
    void      (APIENTRY *glIndexdv                )( const GLdouble *c );
    void      (APIENTRY *glIndexf                 )( GLfloat c );
    void      (APIENTRY *glIndexfv                )( const GLfloat *c );
    void      (APIENTRY *glIndexi                 )( GLint c );
    void      (APIENTRY *glIndexiv                )( const GLint *c );
    void      (APIENTRY *glIndexs                 )( GLshort c );
    void      (APIENTRY *glIndexsv                )( const GLshort *c );
    void      (APIENTRY *glNormal3b               )( GLbyte nx, GLbyte ny, GLbyte nz );
    void      (APIENTRY *glNormal3bv              )( const GLbyte *v );
    void      (APIENTRY *glNormal3d               )( GLdouble nx, GLdouble ny, GLdouble nz );
    void      (APIENTRY *glNormal3dv              )( const GLdouble *v );
    void      (APIENTRY *glNormal3f               )( GLfloat nx, GLfloat ny, GLfloat nz );
    void      (APIENTRY *glNormal3fv              )( const GLfloat *v );
    void      (APIENTRY *glNormal3i               )( GLint nx, GLint ny, GLint nz );
    void      (APIENTRY *glNormal3iv              )( const GLint *v );
    void      (APIENTRY *glNormal3s               )( GLshort nx, GLshort ny, GLshort nz );
    void      (APIENTRY *glNormal3sv              )( const GLshort *v );
    void      (APIENTRY *glRasterPos2d            )( GLdouble x, GLdouble y );
    void      (APIENTRY *glRasterPos2dv           )( const GLdouble *v );
    void      (APIENTRY *glRasterPos2f            )( GLfloat x, GLfloat y );
    void      (APIENTRY *glRasterPos2fv           )( const GLfloat *v );
    void      (APIENTRY *glRasterPos2i            )( GLint x, GLint y );
    void      (APIENTRY *glRasterPos2iv           )( const GLint *v );
    void      (APIENTRY *glRasterPos2s            )( GLshort x, GLshort y );
    void      (APIENTRY *glRasterPos2sv           )( const GLshort *v );
    void      (APIENTRY *glRasterPos3d            )( GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glRasterPos3dv           )( const GLdouble *v );
    void      (APIENTRY *glRasterPos3f            )( GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glRasterPos3fv           )( const GLfloat *v );
    void      (APIENTRY *glRasterPos3i            )( GLint x, GLint y, GLint z );
    void      (APIENTRY *glRasterPos3iv           )( const GLint *v );
    void      (APIENTRY *glRasterPos3s            )( GLshort x, GLshort y, GLshort z );
    void      (APIENTRY *glRasterPos3sv           )( const GLshort *v );
    void      (APIENTRY *glRasterPos4d            )( GLdouble x, GLdouble y, GLdouble z, GLdouble w );
    void      (APIENTRY *glRasterPos4dv           )( const GLdouble *v );
    void      (APIENTRY *glRasterPos4f            )( GLfloat x, GLfloat y, GLfloat z, GLfloat w );
    void      (APIENTRY *glRasterPos4fv           )( const GLfloat *v );
    void      (APIENTRY *glRasterPos4i            )( GLint x, GLint y, GLint z, GLint w );
    void      (APIENTRY *glRasterPos4iv           )( const GLint *v );
    void      (APIENTRY *glRasterPos4s            )( GLshort x, GLshort y, GLshort z, GLshort w );
    void      (APIENTRY *glRasterPos4sv           )( const GLshort *v );
    void      (APIENTRY *glRectd                  )( GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2 );
    void      (APIENTRY *glRectdv                 )( const GLdouble *v1, const GLdouble *v2 );
    void      (APIENTRY *glRectf                  )( GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2 );
    void      (APIENTRY *glRectfv                 )( const GLfloat *v1, const GLfloat *v2 );
    void      (APIENTRY *glRecti                  )( GLint x1, GLint y1, GLint x2, GLint y2 );
    void      (APIENTRY *glRectiv                 )( const GLint *v1, const GLint *v2 );
    void      (APIENTRY *glRects                  )( GLshort x1, GLshort y1, GLshort x2, GLshort y2 );
    void      (APIENTRY *glRectsv                 )( const GLshort *v1, const GLshort *v2 );
    void      (APIENTRY *glTexCoord1d             )( GLdouble s );
    void      (APIENTRY *glTexCoord1dv            )( const GLdouble *v );
    void      (APIENTRY *glTexCoord1f             )( GLfloat s );
    void      (APIENTRY *glTexCoord1fv            )( const GLfloat *v );
    void      (APIENTRY *glTexCoord1i             )( GLint s );
    void      (APIENTRY *glTexCoord1iv            )( const GLint *v );
    void      (APIENTRY *glTexCoord1s             )( GLshort s );
    void      (APIENTRY *glTexCoord1sv            )( const GLshort *v );
    void      (APIENTRY *glTexCoord2d             )( GLdouble s, GLdouble t );
    void      (APIENTRY *glTexCoord2dv            )( const GLdouble *v );
    void      (APIENTRY *glTexCoord2f             )( GLfloat s, GLfloat t );
    void      (APIENTRY *glTexCoord2fv            )( const GLfloat *v );
    void      (APIENTRY *glTexCoord2i             )( GLint s, GLint t );
    void      (APIENTRY *glTexCoord2iv            )( const GLint *v );
    void      (APIENTRY *glTexCoord2s             )( GLshort s, GLshort t );
    void      (APIENTRY *glTexCoord2sv            )( const GLshort *v );
    void      (APIENTRY *glTexCoord3d             )( GLdouble s, GLdouble t, GLdouble r );
    void      (APIENTRY *glTexCoord3dv            )( const GLdouble *v );
    void      (APIENTRY *glTexCoord3f             )( GLfloat s, GLfloat t, GLfloat r );
    void      (APIENTRY *glTexCoord3fv            )( const GLfloat *v );
    void      (APIENTRY *glTexCoord3i             )( GLint s, GLint t, GLint r );
    void      (APIENTRY *glTexCoord3iv            )( const GLint *v );
    void      (APIENTRY *glTexCoord3s             )( GLshort s, GLshort t, GLshort r );
    void      (APIENTRY *glTexCoord3sv            )( const GLshort *v );
    void      (APIENTRY *glTexCoord4d             )( GLdouble s, GLdouble t, GLdouble r, GLdouble q );
    void      (APIENTRY *glTexCoord4dv            )( const GLdouble *v );
    void      (APIENTRY *glTexCoord4f             )( GLfloat s, GLfloat t, GLfloat r, GLfloat q );
    void      (APIENTRY *glTexCoord4fv            )( const GLfloat *v );
    void      (APIENTRY *glTexCoord4i             )( GLint s, GLint t, GLint r, GLint q );
    void      (APIENTRY *glTexCoord4iv            )( const GLint *v );
    void      (APIENTRY *glTexCoord4s             )( GLshort s, GLshort t, GLshort r, GLshort q );
    void      (APIENTRY *glTexCoord4sv            )( const GLshort *v );
    void      (APIENTRY *glVertex2d               )( GLdouble x, GLdouble y );
    void      (APIENTRY *glVertex2dv              )( const GLdouble *v );
    void      (APIENTRY *glVertex2f               )( GLfloat x, GLfloat y );
    void      (APIENTRY *glVertex2fv              )( const GLfloat *v );
    void      (APIENTRY *glVertex2i               )( GLint x, GLint y );
    void      (APIENTRY *glVertex2iv              )( const GLint *v );
    void      (APIENTRY *glVertex2s               )( GLshort x, GLshort y );
    void      (APIENTRY *glVertex2sv              )( const GLshort *v );
    void      (APIENTRY *glVertex3d               )( GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glVertex3dv              )( const GLdouble *v );
    void      (APIENTRY *glVertex3f               )( GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glVertex3fv              )( const GLfloat *v );
    void      (APIENTRY *glVertex3i               )( GLint x, GLint y, GLint z );
    void      (APIENTRY *glVertex3iv              )( const GLint *v );
    void      (APIENTRY *glVertex3s               )( GLshort x, GLshort y, GLshort z );
    void      (APIENTRY *glVertex3sv              )( const GLshort *v );
    void      (APIENTRY *glVertex4d               )( GLdouble x, GLdouble y, GLdouble z, GLdouble w );
    void      (APIENTRY *glVertex4dv              )( const GLdouble *v );
    void      (APIENTRY *glVertex4f               )( GLfloat x, GLfloat y, GLfloat z, GLfloat w );
    void      (APIENTRY *glVertex4fv              )( const GLfloat *v );
    void      (APIENTRY *glVertex4i               )( GLint x, GLint y, GLint z, GLint w );
    void      (APIENTRY *glVertex4iv              )( const GLint *v );
    void      (APIENTRY *glVertex4s               )( GLshort x, GLshort y, GLshort z, GLshort w );
    void      (APIENTRY *glVertex4sv              )( const GLshort *v );
    void      (APIENTRY *glClipPlane              )( GLenum plane, const GLdouble *equation );
    void      (APIENTRY *glColorMaterial          )( GLenum face, GLenum mode );
    void      (APIENTRY *glCullFace               )( GLenum mode );
    void      (APIENTRY *glFogf                   )( GLenum pname, GLfloat param );
    void      (APIENTRY *glFogfv                  )( GLenum pname, const GLfloat *params );
    void      (APIENTRY *glFogi                   )( GLenum pname, GLint param );
    void      (APIENTRY *glFogiv                  )( GLenum pname, const GLint *params );
    void      (APIENTRY *glFrontFace              )( GLenum mode );
    void      (APIENTRY *glHint                   )( GLenum target, GLenum mode );
    void      (APIENTRY *glLightf                 )( GLenum light, GLenum pname, GLfloat param );
    void      (APIENTRY *glLightfv                )( GLenum light, GLenum pname, const GLfloat *params );
    void      (APIENTRY *glLighti                 )( GLenum light, GLenum pname, GLint param );
    void      (APIENTRY *glLightiv                )( GLenum light, GLenum pname, const GLint *params );
    void      (APIENTRY *glLightModelf            )( GLenum pname, GLfloat param );
    void      (APIENTRY *glLightModelfv           )( GLenum pname, const GLfloat *params );
    void      (APIENTRY *glLightModeli            )( GLenum pname, GLint param );
    void      (APIENTRY *glLightModeliv           )( GLenum pname, const GLint *params );
    void      (APIENTRY *glLineStipple            )( GLint factor, GLushort pattern );
    void      (APIENTRY *glLineWidth              )( GLfloat width );
    void      (APIENTRY *glMaterialf              )( GLenum face, GLenum pname, GLfloat param );
    void      (APIENTRY *glMaterialfv             )( GLenum face, GLenum pname, const GLfloat *params );
    void      (APIENTRY *glMateriali              )( GLenum face, GLenum pname, GLint param );
    void      (APIENTRY *glMaterialiv             )( GLenum face, GLenum pname, const GLint *params );
    void      (APIENTRY *glPointSize              )( GLfloat size );
    void      (APIENTRY *glPolygonMode            )( GLenum face, GLenum mode );
    void      (APIENTRY *glPolygonStipple         )( const GLubyte *mask );
    void      (APIENTRY *glScissor                )( GLint x, GLint y, GLsizei width, GLsizei height );
    void      (APIENTRY *glShadeModel             )( GLenum mode );
    void      (APIENTRY *glTexParameterf          )( GLenum target, GLenum pname, GLfloat param );
    void      (APIENTRY *glTexParameterfv         )( GLenum target, GLenum pname, const GLfloat *params );
    void      (APIENTRY *glTexParameteri          )( GLenum target, GLenum pname, GLint param );
    void      (APIENTRY *glTexParameteriv         )( GLenum target, GLenum pname, const GLint *params );
    void      (APIENTRY *glTexImage1D             )( GLenum target, GLint level, GLint components, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels );
    void      (APIENTRY *glTexImage2D             )( GLenum target, GLint level, GLint components, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels );
    void      (APIENTRY *glTexEnvf                )( GLenum target, GLenum pname, GLfloat param );
    void      (APIENTRY *glTexEnvfv               )( GLenum target, GLenum pname, const GLfloat *params );
    void      (APIENTRY *glTexEnvi                )( GLenum target, GLenum pname, GLint param );
    void      (APIENTRY *glTexEnviv               )( GLenum target, GLenum pname, const GLint *params );
    void      (APIENTRY *glTexGend                )( GLenum coord, GLenum pname, GLdouble param );
    void      (APIENTRY *glTexGendv               )( GLenum coord, GLenum pname, const GLdouble *params );
    void      (APIENTRY *glTexGenf                )( GLenum coord, GLenum pname, GLfloat param );
    void      (APIENTRY *glTexGenfv               )( GLenum coord, GLenum pname, const GLfloat *params );
    void      (APIENTRY *glTexGeni                )( GLenum coord, GLenum pname, GLint param );
    void      (APIENTRY *glTexGeniv               )( GLenum coord, GLenum pname, const GLint *params );
    void      (APIENTRY *glFeedbackBuffer         )( GLsizei size, GLenum type, GLfloat *buffer );
    void      (APIENTRY *glSelectBuffer           )( GLsizei size, GLuint *buffer );
    GLint     (APIENTRY *glRenderMode             )( GLenum mode );
    void      (APIENTRY *glInitNames              )( void );
    void      (APIENTRY *glLoadName               )( GLuint name );
    void      (APIENTRY *glPassThrough            )( GLfloat token );
    void      (APIENTRY *glPopName                )( void );
    void      (APIENTRY *glPushName               )( GLuint name );
    void      (APIENTRY *glDrawBuffer             )( GLenum mode );
    void      (APIENTRY *glClear                  )( GLbitfield mask );
    void      (APIENTRY *glClearAccum             )( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha );
    void      (APIENTRY *glClearIndex             )( GLfloat c );
    void      (APIENTRY *glClearColor             )( GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha );
    void      (APIENTRY *glClearStencil           )( GLint s );
    void      (APIENTRY *glClearDepth             )( GLclampd depth );
    void      (APIENTRY *glStencilMask            )( GLuint mask );
    void      (APIENTRY *glColorMask              )( GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha );
    void      (APIENTRY *glDepthMask              )( GLboolean flag );
    void      (APIENTRY *glIndexMask              )( GLuint mask );
    void      (APIENTRY *glAccum                  )( GLenum op, GLfloat value );
    void      (APIENTRY *glDisable                )( GLenum cap );
    void      (APIENTRY *glEnable                 )( GLenum cap );
    void      (APIENTRY *glFinish                 )( void );
    void      (APIENTRY *glFlush                  )( void );
    void      (APIENTRY *glPopAttrib              )( void );
    void      (APIENTRY *glPushAttrib             )( GLbitfield mask );
    void      (APIENTRY *glMap1d                  )( GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points );
    void      (APIENTRY *glMap1f                  )( GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points );
    void      (APIENTRY *glMap2d                  )( GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points );
    void      (APIENTRY *glMap2f                  )( GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points );
    void      (APIENTRY *glMapGrid1d              )( GLint un, GLdouble u1, GLdouble u2 );
    void      (APIENTRY *glMapGrid1f              )( GLint un, GLfloat u1, GLfloat u2 );
    void      (APIENTRY *glMapGrid2d              )( GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2 );
    void      (APIENTRY *glMapGrid2f              )( GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2 );
    void      (APIENTRY *glEvalCoord1d            )( GLdouble u );
    void      (APIENTRY *glEvalCoord1dv           )( const GLdouble *u );
    void      (APIENTRY *glEvalCoord1f            )( GLfloat u );
    void      (APIENTRY *glEvalCoord1fv           )( const GLfloat *u );
    void      (APIENTRY *glEvalCoord2d            )( GLdouble u, GLdouble v );
    void      (APIENTRY *glEvalCoord2dv           )( const GLdouble *u );
    void      (APIENTRY *glEvalCoord2f            )( GLfloat u, GLfloat v );
    void      (APIENTRY *glEvalCoord2fv           )( const GLfloat *u );
    void      (APIENTRY *glEvalMesh1              )( GLenum mode, GLint i1, GLint i2 );
    void      (APIENTRY *glEvalPoint1             )( GLint i );
    void      (APIENTRY *glEvalMesh2              )( GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2 );
    void      (APIENTRY *glEvalPoint2             )( GLint i, GLint j );
    void      (APIENTRY *glAlphaFunc              )( GLenum func, GLclampf ref );
    void      (APIENTRY *glBlendFunc              )( GLenum sfactor, GLenum dfactor );
    void      (APIENTRY *glLogicOp                )( GLenum opcode );
    void      (APIENTRY *glStencilFunc            )( GLenum func, GLint ref, GLuint mask );
    void      (APIENTRY *glStencilOp              )( GLenum fail, GLenum zfail, GLenum zpass );
    void      (APIENTRY *glDepthFunc              )( GLenum func );
    void      (APIENTRY *glPixelZoom              )( GLfloat xfactor, GLfloat yfactor );
    void      (APIENTRY *glPixelTransferf         )( GLenum pname, GLfloat param );
    void      (APIENTRY *glPixelTransferi         )( GLenum pname, GLint param );
    void      (APIENTRY *glPixelStoref            )( GLenum pname, GLfloat param );
    void      (APIENTRY *glPixelStorei            )( GLenum pname, GLint param );
    void      (APIENTRY *glPixelMapfv             )( GLenum map, GLint mapsize, const GLfloat *values );
    void      (APIENTRY *glPixelMapuiv            )( GLenum map, GLint mapsize, const GLuint *values );
    void      (APIENTRY *glPixelMapusv            )( GLenum map, GLint mapsize, const GLushort *values );
    void      (APIENTRY *glReadBuffer             )( GLenum mode );
    void      (APIENTRY *glCopyPixels             )( GLint x, GLint y, GLsizei width, GLsizei height, GLenum type );
    void      (APIENTRY *glReadPixels             )( GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels );
    void      (APIENTRY *glDrawPixels             )( GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels );
    void      (APIENTRY *glGetBooleanv            )( GLenum pname, GLboolean *params );
    void      (APIENTRY *glGetClipPlane           )( GLenum plane, GLdouble *equation );
    void      (APIENTRY *glGetDoublev             )( GLenum pname, GLdouble *params );
    GLenum    (APIENTRY *glGetError               )( void );
    void      (APIENTRY *glGetFloatv              )( GLenum pname, GLfloat *params );
    void      (APIENTRY *glGetIntegerv            )( GLenum pname, GLint *params );
    void      (APIENTRY *glGetLightfv             )( GLenum light, GLenum pname, GLfloat *params );
    void      (APIENTRY *glGetLightiv             )( GLenum light, GLenum pname, GLint *params );
    void      (APIENTRY *glGetMapdv               )( GLenum target, GLenum query, GLdouble *v );
    void      (APIENTRY *glGetMapfv               )( GLenum target, GLenum query, GLfloat *v );
    void      (APIENTRY *glGetMapiv               )( GLenum target, GLenum query, GLint *v );
    void      (APIENTRY *glGetMaterialfv          )( GLenum face, GLenum pname, GLfloat *params );
    void      (APIENTRY *glGetMaterialiv          )( GLenum face, GLenum pname, GLint *params );
    void      (APIENTRY *glGetPixelMapfv          )( GLenum map, GLfloat *values );
    void      (APIENTRY *glGetPixelMapuiv         )( GLenum map, GLuint *values );
    void      (APIENTRY *glGetPixelMapusv         )( GLenum map, GLushort *values );
    void      (APIENTRY *glGetPolygonStipple      )( GLubyte *mask );
    const GLubyte * (APIENTRY *glGetString        )( GLenum name );
    void      (APIENTRY *glGetTexEnvfv            )( GLenum target, GLenum pname, GLfloat *params );
    void      (APIENTRY *glGetTexEnviv            )( GLenum target, GLenum pname, GLint *params );
    void      (APIENTRY *glGetTexGendv            )( GLenum coord, GLenum pname, GLdouble *params );
    void      (APIENTRY *glGetTexGenfv            )( GLenum coord, GLenum pname, GLfloat *params );
    void      (APIENTRY *glGetTexGeniv            )( GLenum coord, GLenum pname, GLint *params );
    void      (APIENTRY *glGetTexImage            )( GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels );
    void      (APIENTRY *glGetTexParameterfv      )( GLenum target, GLenum pname, GLfloat *params );
    void      (APIENTRY *glGetTexParameteriv      )( GLenum target, GLenum pname, GLint *params );
    void      (APIENTRY *glGetTexLevelParameterfv )( GLenum target, GLint level, GLenum pname, GLfloat *params );
    void      (APIENTRY *glGetTexLevelParameteriv )( GLenum target, GLint level, GLenum pname, GLint *params );
    GLboolean (APIENTRY *glIsEnabled              )( GLenum cap );
    GLboolean (APIENTRY *glIsList                 )( GLuint list );
    void      (APIENTRY *glDepthRange             )( GLclampd zNear, GLclampd zFar );
    void      (APIENTRY *glFrustum                )( GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar );
    void      (APIENTRY *glLoadIdentity           )( void );
    void      (APIENTRY *glLoadMatrixf            )( const GLfloat *m );
    void      (APIENTRY *glLoadMatrixd            )( const GLdouble *m );
    void      (APIENTRY *glMatrixMode             )( GLenum mode );
    void      (APIENTRY *glMultMatrixf            )( const GLfloat *m );
    void      (APIENTRY *glMultMatrixd            )( const GLdouble *m );
    void      (APIENTRY *glOrtho                  )( GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar );
    void      (APIENTRY *glPopMatrix              )( void );
    void      (APIENTRY *glPushMatrix             )( void );
    void      (APIENTRY *glRotated                )( GLdouble angle, GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glRotatef                )( GLfloat angle, GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glScaled                 )( GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glScalef                 )( GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glTranslated             )( GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glTranslatef             )( GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glViewport               )( GLint x, GLint y, GLsizei width, GLsizei height );
    // OpenGL version 1.0 entries end here

    // OpenGL version 1.1 entries begin here
    void      (APIENTRY *glArrayElement           )(GLint i);
    void      (APIENTRY *glBindTexture            )(GLenum target, GLuint texture);
    void      (APIENTRY *glColorPointer           )(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glDisableClientState     )(GLenum array);
    void      (APIENTRY *glDrawArrays             )(GLenum mode, GLint first, GLsizei count);
    void      (APIENTRY *glDrawElements           )(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
    void      (APIENTRY *glEdgeFlagPointer        )(GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glEnableClientState      )(GLenum array);
    void      (APIENTRY *glIndexPointer           )(GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glIndexub                )(GLubyte c);
    void      (APIENTRY *glIndexubv               )(const GLubyte *c);
    void      (APIENTRY *glInterleavedArrays      )(GLenum format, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glNormalPointer          )(GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glPolygonOffset          )(GLfloat factor, GLfloat units);
    void      (APIENTRY *glTexCoordPointer        )(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glVertexPointer          )(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
    GLboolean (APIENTRY *glAreTexturesResident    )(GLsizei n, const GLuint *textures, GLboolean *residences);
    void      (APIENTRY *glCopyTexImage1D         )(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
    void      (APIENTRY *glCopyTexImage2D         )(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
    void      (APIENTRY *glCopyTexSubImage1D      )(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
    void      (APIENTRY *glCopyTexSubImage2D      )(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
    void      (APIENTRY *glDeleteTextures         )(GLsizei n, const GLuint *textures);
    void      (APIENTRY *glGenTextures            )(GLsizei n, GLuint *textures);
    void      (APIENTRY *glGetPointerv            )(GLenum pname, GLvoid* *params);
    GLboolean (APIENTRY *glIsTexture              )(GLuint texture);
    void      (APIENTRY *glPrioritizeTextures     )(GLsizei n, const GLuint *textures, const GLclampf *priorities);
    void      (APIENTRY *glTexSubImage1D          )(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
    void      (APIENTRY *glTexSubImage2D          )(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
    void      (APIENTRY *glPopClientAttrib        )(void);
    void      (APIENTRY *glPushClientAttrib       )(GLbitfield mask);
} GLDISPATCHTABLE, *PGLDISPATCHTABLE;

// OpenGL Client/Driver Procedure Table.

typedef struct _GLCLTPROCTABLE {
    int             cEntries;           // Number of function entries in table
    GLDISPATCHTABLE glDispatchTable;    // OpenGL function dispatch table
} GLCLTPROCTABLE, *PGLCLTPROCTABLE;

// Number of entries expected for various versions of OpenGL
#define OPENGL_VERSION_100_ENTRIES      306
#define OPENGL_VERSION_110_ENTRIES      336

// Driver GLRC handle.

typedef ULONG DHGLRC;

// SetProcTable function prototype for DrvSetContext.

typedef VOID (APIENTRY *PFN_SETPROCTABLE)(PGLCLTPROCTABLE);

// DrvSetCallbackProcs prototypes
typedef VOID   (APIENTRY *PFN_SETCURRENTVALUE)(VOID *pv);
typedef VOID  *(APIENTRY *PFN_GETCURRENTVALUE)(VOID);
typedef DHGLRC (APIENTRY *PFN_GETDHGLRC)(HGLRC hrc);

// Driver context function prototypes.

BOOL            APIENTRY DrvCopyContext(DHGLRC, DHGLRC, UINT);
DHGLRC          APIENTRY DrvCreateContext(HDC);
DHGLRC          APIENTRY DrvCreateLayerContext(HDC, int);
BOOL            APIENTRY DrvDeleteContext(DHGLRC);
PGLCLTPROCTABLE APIENTRY DrvSetContext(HDC,DHGLRC,PFN_SETPROCTABLE);
BOOL            APIENTRY DrvReleaseContext(DHGLRC);
BOOL            APIENTRY DrvValidateVersion(ULONG);
BOOL		APIENTRY DrvShareLists(DHGLRC, DHGLRC);
PROC            APIENTRY DrvGetProcAddress(LPCSTR);
VOID            APIENTRY DrvSetCallbackProcs(INT, PROC *);
BOOL            APIENTRY DrvDescribeLayerPlane(HDC, INT, INT, UINT,
                                               LPLAYERPLANEDESCRIPTOR);
INT             APIENTRY DrvSetLayerPaletteEntries(HDC, INT, INT, INT,
                                                   CONST COLORREF *);
INT             APIENTRY DrvGetLayerPaletteEntries(HDC, INT, INT, INT,
                                                   COLORREF *);
BOOL            APIENTRY DrvRealizeLayerPalette(HDC, INT, BOOL);
BOOL            APIENTRY DrvSwapLayerBuffers(HDC, UINT);

#if WINVER >= 0x500

typedef struct IDirectDrawSurface *LPDIRECTDRAWSURFACE;
typedef struct _DDSURFACEDESC *LPDDSURFACEDESC;

DHGLRC          APIENTRY DrvCreateDirectDrawContext(HDC, LPDIRECTDRAWSURFACE,
                                                    int);
int             APIENTRY DrvEnumTextureFormats(int, LPDDSURFACEDESC);
BOOL            APIENTRY DrvBindDirectDrawTexture(LPDIRECTDRAWSURFACE);
DWORD           APIENTRY DrvSwapMultipleBuffers(UINT cBuffers,
                                                CONST WGLSWAP *pgswap);

#endif // WINVER >= 0x500

// Input structure for OPENGL_CMD ExtEscape.

typedef struct _WNDOBJ WNDOBJ;
typedef struct _XLATEOBJ XLATEOBJ;

typedef struct _OPENGLCMD
{
    ULONG    ulSubEsc;
    FLONG    fl;
    WNDOBJ   *pwo;
    XLATEOBJ *pxo;
} OPENGLCMD, *POPENGLCMD;

#if WINVER >= 0x500

#define OPENGLCMD_MAXMULTI WGL_SWAPMULTIPLE_MAX

typedef struct _OPENGLCMDMULTI
{
    ULONG ulSubEsc;
    FLONG fl;
    ULONG cMulti;
    XLATEOBJ *pxo;
} OPENGLCMDMULTI, *POPENGLCMDMULTI;

#endif // WINVER >= 0x500

// Flags for OPENGL_CMD ExtEscape.

#define OGLCMD_NEEDWNDOBJ       0x01
#define OGLCMD_NEEDXLATEOBJ     0x02

#if WINVER >= 0x500
#define OGLCMD_MULTIWNDOBJ      0x04
#endif // WINVER >= 0x500

// OPENGL_GETINFO ExtEscape sub-escape numbers.  They are defined by Microsoft.

#define OPENGL_GETINFO_DRVNAME  0

// Input structure for OPENGL_GETINFO ExtEscape.

typedef struct _OPENGLGETINFO
{
    ULONG   ulSubEsc;
} OPENGLGETINFO, *POPENGLGETINFO;

// Input structure for OPENGL_GETINFO_DRVNAME ExtEscape.

typedef struct _GLDRVNAME
{
    OPENGLGETINFO   oglget;
} GLDRVNAME, *PGLDRVNAME;

// Output structure for OPENGL_GETINFO_DRVNAME ExtEscape.

typedef struct _GLDRVNAMERET
{
    ULONG   ulVersion;              // must be 1 for this version
    ULONG   ulDriverVersion;        // driver specific version number
    WCHAR   awch[MAX_PATH+1];
} GLDRVNAMERET, *PGLDRVNAMERET;

#endif /* _GLDRV_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\oak\inc\prcomoem.h ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    prcomoem.h

Abstract:

    Interface declaration for Windows NT printer driver OEM plugins

--*/

#ifndef _PRCOMOEM_H_
#define _PRCOMOEM_H_

//
// This file has to be included after printoem.h. We also need to inlude
// objbase.h or comcat.h from sdk\inc.
//

//
// Each dll/exe must initialize the GUIDs once.If you are not using precompiled
// headers for the file(s) which initializes the GUIDs, define INITGUID before
// including objbase.h.
//

//
// Class ID for OEM rendering component. All OEM rendering plugin need to use this ID.
//
// {6d6abf26-9f38-11d1-882a-00c04fb961ec}
//

DEFINE_GUID(CLSID_OEMRENDER, 0x6d6abf26, 0x9f38, 0x11d1, 0x88, 0x2a, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Class ID for OEM UI component. All OEM UI plugin need to use this ID.
//
// {abce80d7-9f46-11d1-882a-00c04fb961ec}
//

DEFINE_GUID(CLSID_OEMUI, 0xabce80d7, 0x9f46, 0x11d1, 0x88, 0x2a, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemCommon Interface
//
// {7f42285e-91d5-11d1-8820-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemCommon, 0x7f42285e, 0x91d5, 0x11d1, 0x88, 0x20, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemEngine Interface
//
// {63d17590-91d8-11d1-8820-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemEngine, 0x63d17590, 0x91d8, 0x11d1, 0x88, 0x20, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemUI Interface
//
// {C6A7A9D0-774C-11d1-947F-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemUI, 0xc6a7a9d0, 0x774c, 0x11d1, 0x94, 0x7f, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

//
// Interface ID for IPrintOemUI2 Interface
//
// {292515F9-B54B-489B-9275-BAB56821395E}
//

DEFINE_GUID(IID_IPrintOemUI2, 0x292515f9, 0xb54b, 0x489b, 0x92, 0x75, 0xba, 0xb5, 0x68, 0x21, 0x39, 0x5e);

//
// Interface ID for IPrintOemDriverUI interface
//
// {92B05D50-78BC-11d1-9480-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemDriverUI, 0x92b05d50, 0x78bc, 0x11d1, 0x94, 0x80, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

//
// Interface ID for IPrintCoreUI2 interface
//
// {085CCFCA-3ADF-4c9e-B491-D851A6EDC997}
//

DEFINE_GUID(IID_IPrintCoreUI2, 0x85ccfca, 0x3adf, 0x4c9e, 0xb4, 0x91, 0xd8, 0x51, 0xa6, 0xed, 0xc9, 0x97);

//
// Interface ID for IPrintOemPS Interface
//
// {688342b5-8e1a-11d1-881f-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemPS, 0x688342b5, 0x8e1a, 0x11d1, 0x88, 0x1f, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintOemPS2 Interface
//
// {BECF7F34-51B3-46c9-8A1C-18679BD21F36}
//

DEFINE_GUID(IID_IPrintOemPS2, 0xbecf7f34, 0x51b3, 0x46c9, 0x8a, 0x1c, 0x18, 0x67, 0x9b, 0xd2, 0x1f, 0x36);

//
// Interface ID for IPrintOemDriverPS interface
//
// {d90060c7-8e1a-11d1-881f-00c04fb961ec}
//

DEFINE_GUID(IID_IPrintOemDriverPS, 0xd90060c7, 0x8e1a, 0x11d1, 0x88, 0x1f, 0x00, 0xc0, 0x4f, 0xb9, 0x61, 0xec);

//
// Interface ID for IPrintCorePS2 interface
//
// {CDBB0B0B-A917-40d7-9FBF-483B3BE7EF22}

DEFINE_GUID(IID_IPrintCorePS2, 0xcdbb0b0b, 0xa917, 0x40d7, 0x9f, 0xbf, 0x48, 0x3b, 0x3b, 0xe7, 0xef, 0x22);

//
// Interface ID for IPrintOemUni Interface
//
// {D67EBBF0-78BF-11d1-9480-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemUni, 0xd67ebbf0, 0x78bf, 0x11d1, 0x94, 0x80, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

//
// Interface ID for IPrintOemUni2 Interface
//
// {B91220AC-15CC-4e7a-A21E-9591F34D6F6C}
//

DEFINE_GUID(IID_IPrintOemUni2, 0xb91220ac, 0x15cc, 0x4e7a, 0xa2, 0x1e, 0x95, 0x91, 0xf3, 0x4d, 0x6f, 0x6c);

//
// Interface ID for IPrintOemDriverUni interface
//
// {D67EBBF1-78BF-11d1-9480-00A0C90640B8}
//

DEFINE_GUID(IID_IPrintOemDriverUni, 0xd67ebbf1, 0x78bf, 0x11d1, 0x94, 0x80, 0x0, 0xa0, 0xc9, 0x6, 0x40, 0xb8);

#undef IUnknown

#ifdef __cplusplus
extern "C" {
#endif

//
//****************************************************************************
//  IPrintOemCommon interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemCommon
DECLARE_INTERFACE_(IPrintOemCommon, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;
};

#ifndef KERNEL_MODE

//
// Definitions used by user interface module only.
// Make sure the macro KERNEL_MODE is not defined.
//

//
//****************************************************************************
//  IPrintOemUI interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemUI
DECLARE_INTERFACE_(IPrintOemUI, IPrintOemCommon)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj)PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)PURE;
    STDMETHOD_(ULONG, Release) (THIS)PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemUI methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface) (THIS_ IUnknown *pIUnknown) PURE;


    //
    // CommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_
            DWORD  dwMode,
            POEMCUIPPARAM   pOemCUIPParam
            )PURE;

    //
    // DocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            )PURE;

    //
    // DevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            )PURE;


    //
    // DevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            )PURE;

    //
    // DeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            )PURE;

    //
    // UpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            )PURE;

    //
    // PrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            )PURE;

    //
    // DriverEvent
    //

    STDMETHOD(DriverEvent) (THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            )PURE;

    //
    // QueryColorProfile
    //

    STDMETHOD(QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulQueryMode,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData
            )PURE;

    //
    // FontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            )PURE;

    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
           )PURE;
};


//
//****************************************************************************
//  IPrintOemUI2 interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemUI2
DECLARE_INTERFACE_(IPrintOemUI2, IPrintOemUI)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj)PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)PURE;
    STDMETHOD_(ULONG, Release) (THIS)PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemUI methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface) (THIS_ IUnknown *pIUnknown) PURE;


    //
    // CommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_
            DWORD  dwMode,
            POEMCUIPPARAM   pOemCUIPParam
            )PURE;

    //
    // DocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            )PURE;

    //
    // DevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            )PURE;


    //
    // DevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            )PURE;

    //
    // DeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            )PURE;

    //
    // UpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            )PURE;

    //
    // PrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            )PURE;

    //
    // DriverEvent
    //

    STDMETHOD(DriverEvent) (THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            )PURE;

    //
    // QueryColorProfile
    //

    STDMETHOD(QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulQueryMode,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData
            )PURE;

    //
    // FontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            )PURE;

    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
           )PURE;

    //
    // IPrintOemUI2 methods
    //

    //
    // QueryJobAttributes
    //

    STDMETHOD(QueryJobAttributes)  (THIS_
            HANDLE      hPrinter,
            PDEVMODE    pDevmode,
            DWORD       dwLevel,
            LPBYTE      lpAttributeInfo
           )PURE;

    //
    // Hide Standard UI
    //

    STDMETHOD(HideStandardUI)  (THIS_
            DWORD       dwMode
           )PURE;

    //
    // DocumentEvent
    //

    STDMETHOD(DocumentEvent) (THIS_
            HANDLE      hPrinter,
            HDC         hdc,
            INT         iEsc,
            ULONG       cbIn,
            PVOID       pvIn,
            ULONG       cbOut,
            PVOID       pvOut,
            PINT        piResult
           )PURE;
};


//
//****************************************************************************
//  IPrintOemDriverUI interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemDriverUI
DECLARE_INTERFACE_(IPrintOemDriverUI, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj)PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)PURE;
    STDMETHOD_(ULONG, Release) (THIS)PURE;

    //
    // IPrintOemDriverUI methods
    //

    //
    // Helper function to get driver settings
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_
                        PVOID   pci,
                        PCSTR   Feature,
                        PVOID   pOutput,
                        DWORD   cbSize,
                        PDWORD  pcbNeeded,
                        PDWORD  pdwOptionsReturned
                        )PURE;

    //
    // Helper function to allow OEM plugins upgrade private registry
    // settings. This function should be called only by OEM's UpgradePrinter()
    //

    STDMETHOD(DrvUpgradeRegistrySetting) (THIS_
                        HANDLE   hPrinter,
                        PCSTR    pFeature,
                        PCSTR    pOption
                        )PURE;

    //
    // Helper function to allow OEM plugins to update the driver UI
    // settings and show constraints. This function should be called only when
    // the UI is present.
    //

    STDMETHOD(DrvUpdateUISetting) (THIS_
                        PVOID    pci,
                        PVOID    pOptItem,
                        DWORD    dwPreviousSelection,
                        DWORD    dwMode
                        )PURE;
};

//
//****************************************************************************
//  IPrintCoreUI2 interface
//
//  This is the revised core driver helper interface OEM UI plugin can call.
//  It supercedes the old helper interface IPrintOemDriverUI.
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintCoreUI2
DECLARE_INTERFACE_(IPrintCoreUI2, IPrintOemDriverUI)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj)PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)PURE;
    STDMETHOD_(ULONG, Release) (THIS)PURE;

    //
    // IPrintOemDriverUI methods
    //

    //
    // Helper function to get driver settings. This function is only supported
    // for UI plugins that do not fully replace core driver's standard UI.
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_
                        PVOID   pci,
                        PCSTR   Feature,
                        PVOID   pOutput,
                        DWORD   cbSize,
                        PDWORD  pcbNeeded,
                        PDWORD  pdwOptionsReturned
                        )PURE;

    //
    // Helper function to allow OEM plugins upgrade private registry
    // settings. This function is supported for any UI plugins and should be
    // called only by OEM's UpgradePrinter.
    //

    STDMETHOD(DrvUpgradeRegistrySetting) (THIS_
                        HANDLE   hPrinter,
                        PCSTR    pFeature,
                        PCSTR    pOption
                        )PURE;

    //
    // Helper function to allow OEM plugins to update the driver UI settings.
    // This function is only supported for UI plugins that do not fully replace
    // core driver's standard UI. It should be called only when the UI is present.
    //

    STDMETHOD(DrvUpdateUISetting) (THIS_
                        PVOID    pci,
                        PVOID    pOptItem,
                        DWORD    dwPreviousSelection,
                        DWORD    dwMode
                        )PURE;

    //
    // IPrintCoreUI2 new methods
    //

    //
    // Following four helper functions are only supported for UI plugins that fully
    // replace core driver's standard UI. They should only be called by the UI plugin's
    // DocumentPropertySheets, DevicePropertySheets and their property sheet callback
    // functions.
    //
    // Helper function to retrieve driver's current setting as a list of
    // feature/option keyword pairs.
    //

    STDMETHOD(GetOptions) (THIS_
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pmszFeaturesRequested,
                           IN  DWORD      cbIn,
                           OUT PSTR       pmszFeatureOptionBuf,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded) PURE;

    //
    // Helper function to change driver's setting using a list of feature/option
    // keyword pairs.
    //

    STDMETHOD(SetOptions) (THIS_
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pmszFeatureOptionBuf,
                           IN  DWORD      cbIn,
                           OUT PDWORD     pdwResult) PURE;

    //
    // Helper function to retrieve the option(s) of a given feature that are
    // constrained in driver's current setting.
    //

    STDMETHOD(EnumConstrainedOptions) (THIS_
                                       IN  POEMUIOBJ  poemuiobj,
                                       IN  DWORD      dwFlags,
                                       IN  PCSTR      pszFeatureKeyword,
                                       OUT PSTR       pmszConstrainedOptionList,
                                       IN  DWORD      cbSize,
                                       OUT PDWORD     pcbNeeded) PURE;

    //
    // Helper function to retrieve a list of feature/option keyword pairs from
    // driver's current setting that conflict with the given feature/option pair.
    //

    STDMETHOD(WhyConstrained) (THIS_
                               IN  POEMUIOBJ  poemuiobj,
                               IN  DWORD      dwFlags,
                               IN  PCSTR      pszFeatureKeyword,
                               IN  PCSTR      pszOptionKeyword,
                               OUT PSTR       pmszReasonList,
                               IN  DWORD      cbSize,
                               OUT PDWORD     pcbNeeded) PURE;

    //
    // Following five helper functions are supported for any UI plugins.
    //
    // Helper function to retrieve global attribute.
    //

    STDMETHOD(GetGlobalAttribute) (THIS_
                                   IN  POEMUIOBJ  poemuiobj,
                                   IN  DWORD      dwFlags,
                                   IN  PCSTR      pszAttribute,
                                   OUT PDWORD     pdwDataType,
                                   OUT PBYTE      pbData,
                                   IN  DWORD      cbSize,
                                   OUT PDWORD     pcbNeeded) PURE;


    //
    // Helper function to retrieve attribute of a given feature.
    //

    STDMETHOD(GetFeatureAttribute) (THIS_
                                    IN  POEMUIOBJ  poemuiobj,
                                    IN  DWORD      dwFlags,
                                    IN  PCSTR      pszFeatureKeyword,
                                    IN  PCSTR      pszAttribute,
                                    OUT PDWORD     pdwDataType,
                                    OUT PBYTE      pbData,
                                    IN  DWORD      cbSize,
                                    OUT PDWORD     pcbNeeded) PURE;

    //
    // Helper function to retrieve attribute of a given feature/option selection.
    //

    STDMETHOD(GetOptionAttribute) (THIS_
                                   IN  POEMUIOBJ  poemuiobj,
                                   IN  DWORD      dwFlags,
                                   IN  PCSTR      pszFeatureKeyword,
                                   IN  PCSTR      pszOptionKeyword,
                                   IN  PCSTR      pszAttribute,
                                   OUT PDWORD     pdwDataType,
                                   OUT PBYTE      pbData,
                                   IN  DWORD      cbSize,
                                   OUT PDWORD     pcbNeeded) PURE;

    //
    // Helper function to retrieve the list of feature keyword.
    //

    STDMETHOD(EnumFeatures) (THIS_
                             IN  POEMUIOBJ  poemuiobj,
                             IN  DWORD      dwFlags,
                             OUT PSTR       pmszFeatureList,
                             IN  DWORD      cbSize,
                             OUT PDWORD     pcbNeeded) PURE;

    //
    // Helper function to retrieve the list of options keyword of a given feature.
    //

    STDMETHOD(EnumOptions) (THIS_
                            IN  POEMUIOBJ  poemuiobj,
                            IN  DWORD      dwFlags,
                            IN  PCSTR      pszFeatureKeyword,
                            OUT PSTR       pmszOptionList,
                            IN  DWORD      cbSize,
                            OUT PDWORD     pcbNeeded) PURE;

    //
    // Helper function to query system simulation support
    //

    STDMETHOD(QuerySimulationSupport) (THIS_
                                       IN  HANDLE  hPrinter,
                                       IN  DWORD   dwLevel,
                                       OUT PBYTE   pCaps,
                                       IN  DWORD   cbSize,
                                       OUT PDWORD  pcbNeeded) PURE;
};

#else   // KERNEL_MODE

//
// Definitions used by rendering module only.
// Make sure the macro KERNEL_MODE is defined.
//

//
//****************************************************************************
//  IPrintOemEngine interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemEngine
DECLARE_INTERFACE_(IPrintOemEngine, IPrintOemCommon)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;
};

//
//****************************************************************************
//  IPrintOemPS interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemPS
DECLARE_INTERFACE_(IPrintOemPS, IPrintOemEngine)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to construct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;

    //
    // IPrintOemPS methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface)(THIS_  IUnknown *pIUnknown) PURE;

    //
    // Method for OEM to generate output at specific injection point
    //

    STDMETHOD(Command) (THIS_   PDEVOBJ     pdevobj,
                                DWORD       dwIndex,
                                PVOID       pData,
                                DWORD       cbSize,
                                OUT DWORD   *pdwResult) PURE;
};

//
//****************************************************************************
//  IPrintOemPS2 interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemPS2
DECLARE_INTERFACE_(IPrintOemPS2, IPrintOemPS)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to construct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;

    //
    // IPrintOemPS methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface)(THIS_  IUnknown *pIUnknown) PURE;

    //
    // Method for OEM to generate output at specific injection point
    //

    STDMETHOD(Command) (THIS_   PDEVOBJ     pdevobj,
                                DWORD       dwIndex,
                                PVOID       pData,
                                DWORD       cbSize,
                                OUT DWORD   *pdwResult) PURE;

    //
    // IPrintOemPS2 methods
    //

    //
    // Method for plugin to hook out spooler's WritePrinter API so it
    // can get access to output data PostScript driver is generating
    //
    // At DrvEnablePDEV time, PostScript driver will call this function with
    // pdevobj = NULL, pBuf = NULL, cbBuffer = 0 to detect if the plugin
    // implements this function. Plugin should return S_OK to indicate it is
    // implementing this function, or return E_NOTIMPL otherwise.
    //
    // In pcbWritten, plugins should return the number of bytes written to the
    // spooler's WritePrinter function. Zero doesn't carry a special meaning,
    // errors must be reported through the returned HRESULT.
    //

    STDMETHOD(WritePrinter) (THIS_   PDEVOBJ    pdevobj,
                                     PVOID      pBuf,
                                     DWORD      cbBuffer,
                                     PDWORD     pcbWritten) PURE;

    //
    // Method for plugin to implement if it wants to be called to get the chance
    // to override some PDEV settings such as paper margins.
    // Plugins that recognize the adjustment type should return S_OK.
    // If the adjustment type is unrecognized, they should return S_FALSE
    // and not E_NOTIMPL, this code should be reserved for the COM meaning.
    // If the plugin fails the call, it should return E_FAIL.
    // The chain of plugins will be called until a plugin returns S_OK or
    // any failure code other than E_NOTIMPL, in other words, until the first
    // plugin that is designed to handle the adjustment is found.
    //

    STDMETHOD(GetPDEVAdjustment) (THIS_ PDEVOBJ    pdevobj,
                                        DWORD      dwAdjustType,
                                        PVOID      pBuf,
                                        DWORD      cbBuffer,
                                        OUT BOOL  *pbAdjustmentDone) PURE;
};

//
//****************************************************************************
//  IPrintOemDriverPS interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemDriverPS
DECLARE_INTERFACE_(IPrintOemDriverPS, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemDriverPS methods
    //

    //
    // Method for OEM to get driver settings
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_   PVOID   pdriverobj,
                                            PCSTR   Feature,
                                            PVOID   pOutput,
                                            DWORD   cbSize,
                                            PDWORD  pcbNeeded,
                                            PDWORD  pdwOptionsReturned) PURE;

    //
    // Method for OEM to write to spooler buffer
    //

    STDMETHOD(DrvWriteSpoolBuf)(THIS_       PDEVOBJ     pdevobj,
                                            PVOID       pBuffer,
                                            DWORD       cbSize,
                                            OUT DWORD   *pdwResult) PURE;
};

//
//****************************************************************************
//  IPrintCorePS2 interface
//
//  This is the revised core driver helper interface OEM PS render plugin can
//  call. It supercedes the old helper interface IPrintOemDriverPS.
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintCorePS2
DECLARE_INTERFACE_(IPrintCorePS2, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintCorePS2 methods
    //

    //
    // Method for OEM to write to spooler buffer.
    //

    STDMETHOD(DrvWriteSpoolBuf)(THIS_
                           IN  PDEVOBJ  pdevobj,
                           IN  PVOID    pBuffer,
                           IN  DWORD    cbSize,
                           OUT DWORD    *pdwResult) PURE;

    //
    // Helper function to retrieve driver's current setting as a list of
    // feature/option keyword pairs.
    //

    STDMETHOD(GetOptions) (THIS_
                           IN  PDEVOBJ  pdevobj,
                           IN  DWORD    dwFlags,
                           IN  PCSTR    pmszFeaturesRequested,
                           IN  DWORD    cbIn,
                           OUT PSTR     pmszFeatureOptionBuf,
                           IN  DWORD    cbSize,
                           OUT PDWORD   pcbNeeded) PURE;

    //
    // Helper function to retrieve global attribute.
    //

    STDMETHOD(GetGlobalAttribute) (THIS_
                                   IN  PDEVOBJ  pdevobj,
                                   IN  DWORD    dwFlags,
                                   IN  PCSTR    pszAttribute,
                                   OUT PDWORD   pdwDataType,
                                   OUT PBYTE    pbData,
                                   IN  DWORD    cbSize,
                                   OUT PDWORD   pcbNeeded) PURE;


    //
    // Helper function to retrieve attribute of a given feature.
    //

    STDMETHOD(GetFeatureAttribute) (THIS_
                                    IN  PDEVOBJ  pdevobj,
                                    IN  DWORD    dwFlags,
                                    IN  PCSTR    pszFeatureKeyword,
                                    IN  PCSTR    pszAttribute,
                                    OUT PDWORD   pdwDataType,
                                    OUT PBYTE    pbData,
                                    IN  DWORD    cbSize,
                                    OUT PDWORD   pcbNeeded) PURE;

    //
    // Helper function to retrieve attribute of a given feature/option selection.
    //

    STDMETHOD(GetOptionAttribute) (THIS_
                                   IN  PDEVOBJ  pdevobj,
                                   IN  DWORD    dwFlags,
                                   IN  PCSTR    pszFeatureKeyword,
                                   IN  PCSTR    pszOptionKeyword,
                                   IN  PCSTR    pszAttribute,
                                   OUT PDWORD   pdwDataType,
                                   OUT PBYTE    pbData,
                                   IN  DWORD    cbSize,
                                   OUT PDWORD   pcbNeeded) PURE;

    //
    // Helper function to retrieve the list of feature keyword.
    //

    STDMETHOD(EnumFeatures) (THIS_
                             IN  PDEVOBJ  pdevobj,
                             IN  DWORD    dwFlags,
                             OUT PSTR     pmszFeatureList,
                             IN  DWORD    cbSize,
                             OUT PDWORD   pcbNeeded) PURE;

    //
    // Helper function to retrieve the list of options keyword of a given feature.
    //

    STDMETHOD(EnumOptions) (THIS_
                            IN  PDEVOBJ  pdevobj,
                            IN  DWORD    dwFlags,
                            IN  PCSTR    pszFeatureKeyword,
                            OUT PSTR     pmszOptionList,
                            IN  DWORD    cbSize,
                            OUT PDWORD   pcbNeeded) PURE;
};

//
//****************************************************************************
//  IPrintOemUni interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemUni
DECLARE_INTERFACE_(IPrintOemUni, IPrintOemEngine)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to construct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;

    //
    // IPrintOemUni methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown) PURE;

    //
    // Method for getting OEM implemented methods.
    // Returns S_OK if the given method is implemented.
    // Returns S_FALSE if the given method is not implemented.
    //
    //

    STDMETHOD(GetImplementedMethod) (THIS_  PSTR    pMethodName) PURE;

    //
    // DriverDMS
    //

    STDMETHOD(DriverDMS)(THIS_  PVOID   pDevObj,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;

    //
    // CommandCallback
    //

    STDMETHOD(CommandCallback)(THIS_    PDEVOBJ     pdevobj,
                                        DWORD       dwCallbackID,
                                        DWORD       dwCount,
                                        PDWORD      pdwParams,
                                        OUT INT     *piResult) PURE;


    //
    // ImageProcessing
    //

    STDMETHOD(ImageProcessing)(THIS_    PDEVOBJ             pdevobj,
                                        PBYTE               pSrcBitmap,
                                        PBITMAPINFOHEADER   pBitmapInfoHeader,
                                        PBYTE               pColorTable,
                                        DWORD               dwCallbackID,
                                        PIPPARAMS           pIPParams,
                                        OUT PBYTE           *ppbResult) PURE;

    //
    // FilterGraphics
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen) PURE;

    //
    // Compression
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult) PURE;

    //
    // HalftonePattern
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize) PURE;

    //
    // MemoryUsage
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage) PURE;

    //
    // TTYGetInfo
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded
                                    ) PURE;
    //
    // DownloadFontheader
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // DownloadCharGlyph
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult) PURE;


    //
    // TTDownloadMethod
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // OutputCharStr
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph) PURE;

    //
    // SendFontCmd
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv) PURE;

    //
    // TextOutAsBitmap
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix) PURE;
};

//
//****************************************************************************
//  IPrintOemUni2 interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemUni2
DECLARE_INTERFACE_(IPrintOemUni2, IPrintOemUni)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemCommon methods
    //

    //
    // Method for getting OEM related information
    //

    STDMETHOD(GetInfo) (THIS_   DWORD   dwMode,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;
    //
    // Method for OEM private devmode handling
    //

    STDMETHOD(DevMode) (THIS_   DWORD       dwMode,
                                POEMDMPARAM pOemDMParam) PURE;

    //
    // IPrintOemEngine methods
    //

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_   DWORD           DriverVersion,
                                      DWORD           cbSize,
                                      PDRVENABLEDATA  pded) PURE;

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS) PURE;

    //
    // Method for OEM to construct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_   PDEVOBJ         pdevobj,
                                      PWSTR           pPrinterName,
                                      ULONG           cPatterns,
                                      HSURF          *phsurfPatterns,
                                      ULONG           cjGdiInfo,
                                      GDIINFO        *pGdiInfo,
                                      ULONG           cjDevInfo,
                                      DEVINFO        *pDevInfo,
                                      DRVENABLEDATA  *pded,
                                      OUT PDEVOEM    *pDevOem) PURE;

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_   PDEVOBJ         pdevobj) PURE;

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_   PDEVOBJ         pdevobjOld,
                                      PDEVOBJ         pdevobjNew) PURE;

    //
    // IPrintOemUni methods
    //

    //
    // Method for publishing Driver interface.
    //

    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown) PURE;

    //
    // Method for getting OEM implemented methods.
    // Returns S_OK if the given method is implemented.
    // Returns S_FALSE if the given method is not implemented.
    //
    //

    STDMETHOD(GetImplementedMethod) (THIS_  PSTR    pMethodName) PURE;

    //
    // DriverDMS
    //

    STDMETHOD(DriverDMS)(THIS_  PVOID   pDevObj,
                                PVOID   pBuffer,
                                DWORD   cbSize,
                                PDWORD  pcbNeeded) PURE;

    //
    // CommandCallback
    //

    STDMETHOD(CommandCallback)(THIS_    PDEVOBJ     pdevobj,
                                        DWORD       dwCallbackID,
                                        DWORD       dwCount,
                                        PDWORD      pdwParams,
                                        OUT INT     *piResult) PURE;


    //
    // ImageProcessing
    //

    STDMETHOD(ImageProcessing)(THIS_    PDEVOBJ             pdevobj,
                                        PBYTE               pSrcBitmap,
                                        PBITMAPINFOHEADER   pBitmapInfoHeader,
                                        PBYTE               pColorTable,
                                        DWORD               dwCallbackID,
                                        PIPPARAMS           pIPParams,
                                        OUT PBYTE           *ppbResult) PURE;

    //
    // FilterGraphics
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen) PURE;

    //
    // Compression
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult) PURE;

    //
    // HalftonePattern
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize) PURE;

    //
    // MemoryUsage
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage) PURE;

    //
    // TTYGetInfo
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded
                                    ) PURE;
    //
    // DownloadFontheader
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // DownloadCharGlyph
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult) PURE;


    //
    // TTDownloadMethod
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // OutputCharStr
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph) PURE;

    //
    // SendFontCmd
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv) PURE;

    //
    // TextOutAsBitmap
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix) PURE;

    //
    // IPrintOemUni2 methods
    //

    //
    // Method for plugin to hook out spooler's WritePrinter API so it
    // can get access to output data Universal driver is generating
    //
    // At DrvEnablePDEV time, Universal driver will call this function with
    // pdevobj = NULL, pBuf = NULL, cbBuffer = 0 to detect if the plugin
    // implements this function. Plugin should return S_OK to indicate it is
    // implementing this function, or return E_NOTIMPL otherwise.
    //
    // In pcbWritten, plugins should return the number of bytes written to the
    // spooler's WritePrinter function. Zero doesn't carry a special meaning,
    // errors must be reported through the returned HRESULT.
    //

    STDMETHOD(WritePrinter) (THIS_   PDEVOBJ    pdevobj,
                                     PVOID      pBuf,
                                     DWORD      cbBuffer,
                                     PDWORD     pcbWritten) PURE;
};


//
//****************************************************************************
//  IPrintOemDriverUni interface
//****************************************************************************
//

#undef INTERFACE
#define INTERFACE IPrintOemDriverUni
DECLARE_INTERFACE_(IPrintOemDriverUni, IUnknown)
{
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    //
    // IPrintOemDriverUni methods
    //

    //
    // Function to get driver settings
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_   PVOID   pdriverobj,
                                            PCSTR   Feature,
                                            PVOID   pOutput,
                                            DWORD   cbSize,
                                            PDWORD  pcbNeeded,
                                            PDWORD  pdwOptionsReturned) PURE;

    //
    // Common to both Unidrv & Pscript
    //

    STDMETHOD(DrvWriteSpoolBuf)(THIS_       PDEVOBJ     pdevobj,
                                            PVOID       pBuffer,
                                            DWORD       cbSize,
                                            OUT DWORD   *pdwResult) PURE;

    //
    // Unidrv specific XMoveTo and YMoveTo. Returns E_NOT_IMPL in Pscript
    //

    STDMETHOD(DrvXMoveTo)(THIS_     PDEVOBJ     pdevobj,
                                    INT         x,
                                    DWORD       dwFlags,
                                    OUT INT     *piResult) PURE;

    STDMETHOD(DrvYMoveTo)(THIS_     PDEVOBJ     pdevobj,
                                    INT         y,
                                    DWORD       dwFlags,
                                    OUT INT     *piResult) PURE;
    //
    // Unidrv specific. To get the standard variable value.
    //

    STDMETHOD(DrvGetStandardVariable)(THIS_     PDEVOBJ     pdevobj,
                                                DWORD       dwIndex,
                                                PVOID       pBuffer,
                                                DWORD       cbSize,
                                                PDWORD      pcbNeeded) PURE;

    //
    // Unidrv specific.  To Provide OEM plugins access to GPD data.
    //

    STDMETHOD (DrvGetGPDData)(THIS_  PDEVOBJ     pdevobj,
                                     DWORD       dwType,     // Type of the data
                                     PVOID         pInputData,   // reserved. Should be set to 0
                                     PVOID          pBuffer,     // Caller allocated Buffer to be copied
                                     DWORD       cbSize,     // Size of the buffer
                                     PDWORD      pcbNeeded   // New Size of the buffer if needed.
                             ) PURE;


    //
    // Unidrv specific. To do the TextOut.
    //

    STDMETHOD(DrvUniTextOut)(THIS_    SURFOBJ    *pso,
                                      STROBJ     *pstro,
                                      FONTOBJ    *pfo,
                                      CLIPOBJ    *pco,
                                      RECTL      *prclExtra,
                                      RECTL      *prclOpaque,
                                      BRUSHOBJ   *pboFore,
                                      BRUSHOBJ   *pboOpaque,
                                      POINTL     *pptlBrushOrg,
                                      MIX         mix) PURE;

    //
    //   Warning!!!  new method!!  must place at end of
    //   interface - else major incompatibility with previous oem plugins
    //

    STDMETHOD(DrvWriteAbortBuf)(THIS_       PDEVOBJ     pdevobj,
                                            PVOID       pBuffer,
                                            DWORD       cbSize,
                                            DWORD       dwWait  //  pause data transmission for this many millisecs.
                               ) PURE;
};

#endif  // !KERNEL_MODE

#ifdef __cplusplus
}
#endif

#endif  // !_PRCOMOEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\oak\inc\kbd.h ===
/****************************** Module Header ******************************\
* Module Name: kbd.h
*
* Copyright (c) Microsoft Corporation. All rights reserved.
*
* Keyboard table values that form the basis for languages and keyboard types.
* The basis is US, kbd type 4 - all others are a variation on this.
* This file is included by all kbd**.h files.
*
* History:
* 10-Jan-1991 GregoryW
* 23-Apr-1991 IanJa         VSC_TO_VK _* macros from oemtab.c
\***************************************************************************/

#ifndef _KBD_
#define _KBD_

#if defined(BUILD_WOW6432)
    #define KBD_LONG_POINTER __ptr64
#else
    #define KBD_LONG_POINTER
#endif


/****************************************************************************\
*
* Keyboard Layers.   Used in kdb??.dll and in usersrv.dll
*
\****************************************************************************/

/*
 * KE.usFlaggedVk values, also used in the keyboard layer tables.
 */
#define KBDEXT        (USHORT)0x0100
#define KBDMULTIVK    (USHORT)0x0200
#define KBDSPECIAL    (USHORT)0x0400
#define KBDNUMPAD     (USHORT)0x0800
#define KBDUNICODE    (USHORT)0x1000
#define KBDINJECTEDVK (USHORT)0x2000
#define KBDMAPPEDVK   (USHORT)0x4000
#define KBDBREAK      (USHORT)0x8000

/*
 * Key message lParam bits
 */
#define EXTENDED_BIT   0x01000000
#define DONTCARE_BIT   0x02000000
#define FAKE_KEYSTROKE 0x02000000
#define ALTNUMPAD_BIT  0x04000000 // copied from windows\inc\wincon.w

/*
 * Keyboard Shift State defines. These correspond to the bit mask defined
 * by the VkKeyScan() API.
 */
#define KBDBASE        0
#define KBDSHIFT       1
#define KBDCTRL        2
#define KBDALT         4
// three symbols KANA, ROYA, LOYA are for FE
#define KBDKANA        8
#define KBDROYA        0x10
#define KBDLOYA        0x20
#define KBDGRPSELTAP   0x80

/*
 * Handy diacritics
 */
#define GRAVE           0x0300
#define ACUTE           0x0301
#define CIRCUMFLEX      0x0302
#define TILDE           0x0303
#define MACRON          0x0304
#define OVERSCORE       0x0305
#define BREVE           0x0306
#define DOT_ABOVE       0x0307
#define UMLAUT          0x0308
#define DIARESIS        UMLAUT
#define HOOK_ABOVE      0x0309
#define RING            0x030A
#define DOUBLE_ACUTE    0x030B
#define HACEK           0x030C

#define CEDILLA         0x0327
#define OGONEK          0x0328
#define TONOS           0x0384
#define DIARESIS_TONOS  0x0385


#define wszGRAVE           L"\x0300"
#define wszACUTE           L"\x0301"
#define wszCIRCUMFLEX      L"\x0302"
#define wszTILDE           L"\x0303"
#define wszMACRON          L"\x0304"
#define wszOVERSCORE       L"\x0305"
#define wszBREVE           L"\x0306"
#define wszDOT_ABOVE       L"\x0307"
#define wszUMLAUT          L"\x0308"
#define wszHOOK_ABOVE      L"\x0309"
#define wszRING            L"\x030A"
#define wszDOUBLE_ACUTE    L"\x030B"
#define wszHACEK           L"\x030C"

#define wszCEDILLA         L"\x0327"
#define wszOGONEK          L"\x0328"
#define wszTONOS           L"\x0384"
#define wszDIARESIS_TONOS  L"\x0385"

#define IDS_FROM_SCANCODE(prefix, base) \
        (0xc000 + ((0x ## prefix) >= 0xE0 ? 0x100 : 0) + (0x ## base))

/***************************************************************************\
* MODIFIER KEYS
*
* All keyboards have "Modifier" keys which are used to alter the behaviour of
* some of the other keys.  These shifter keys are usually:
*   Shift  (left and/or right Shift key)
*   Ctrl   (left and/or right Ctrl key)
*   Alt    (left and/or right Alt key)
*   AltGr  (right Alt key only)
*
* NOTE:
*   All keyboards use the Shift key.
*   All keyboards use a Ctrl key to generate ASCII control characters.
*   All keyboards with a number pad use the Alt key and the NumPad to
*     generate characters by number.
*   Keyboards using AltGr as a Modifier Key usually translate the Virtual
*     ScanCode to Virtual Keys VK_CTRL + VK_ALT at input time: the Modifier
*     tables should be written to treat Ctrl + Alt as a valid shifter
*     key combination in these cases.
*
* By holding down 0 or more of these Modifier keys, a "shift state" is
* obtained : the shift state may affect the translation of Virtual Scancodes
* to Virtual Keys and/or the translation of Virtuals Key to Characters.
*
* EXAMPLES:
*
* Each key on a particular keyboard may be marked with up to five different
* characters in five different positions:
*
*              .-------.
*             /|       |\
*            : | 2   4 | :
*            | |       | |
*            | |       | |
*            | | 1   3 | |
*            | |_______| |
*            | /       \ |
*            |/    5    \|
*            `-----------'
*
* A key may also be able to generate a character that is not marked on it:
* these are ASCII Control chars, lower-case letters and/or "invisible keys".
*                                                  .-------.
*      An example of an "Invisible Key":          /|       |\
*                                                : | >     | :
*  The German M24 keyboard 2 should produce the  | |       | |
*  '|' character when ALT SHIFT is is held down  | |       | |
*  while the '<' key (shown here) is pressed:    | | <   \ | |
*  This keyboard has four other invisible        | |_______| |
*  characters.  France, Italy and Spain also     | /       \ |
*  support invisible characters on the M24       |/         \|
*  Keyboard 2 with ALT SHIFT depressed.          `-----------'
*
* The keyboard table must list the keys that contribute to it's shift state,
* and indicate which combinations are valid.  This is done with
*    aCharModifiers[]  - convert combinations of Modifier Keys to Bitmasks.
* and
*    aModification[];  - convert Modifier Bitmasks to enumerated Modifications
*
* AN EXAMPLE OF VALID AND INVALID MODIFIER KEY COMBINATIONS
*
*    The US English keyboard has 3 Modifier keys:
*      Shift (left or right); Ctrl (left or right); and Alt (left or right).
*
*    The only valid combinations of these Modifier Keys are:
*      none pressed      : Character at position (1) on the key.
*      Shift             : Character at position (2) on the key.
*      Ctrl              : Ascii Control characters
*      Shift + Ctrl      : Ascii Control characters
*      Alt               : Character-by-number on the numpad
*
*    The invalid combinations (that do not generate any characters) are:
*      Shift + Alt
*      Alt + Ctrl
*      Shift + Alt + Ctrl
*
* Something (???) :
* -----------------
*      Modifier keys              Character produced
*      -------------------------  ------------------
*   0  No shifter key depressed   position 1
*   1  Shift key is depressed     position 2
*   2  AltGr (r.h. Alt) depressed position 4 or 5 (whichever is marked)
*
* However, note that 3 shifter keys (SHIFT, can be combined in a
* characters, depending on the Keyboards
* Consider the following keyboards:
*
*     .-------.            STRANGE KBD         PECULIAR KBD
*    /|       |\           ==================  ==================
*   : | 2   4 | :    1   -
*   | |       | |    2   - SHIFT               SHIFT
*   | |       | |    3   - MENU                MENU
*   | | 1   3 | |    4   - SHIFT + MENU        SHIFT + MENU
*   | |_______| |    5   -    no such keys     CTRL  + MENU
*   | /       \ |
*   |/    5    \|
*   `-----------'
* Both STRANGE and PECULIAR keyboards could have aVkToBits[] =
*   { VK_SHIFT  , KBDSHIFT }, // 0x01
*   { VK_CONTROL, KBDCTRL  }, // 0x02
*   { VK_MENU   , KBDALT   }, // 0x04
*   { 0,          0        }
*
* The STRANGE keyboard has 4 distinct shift states, while the PECULIAR kbd
* has 5.  However, note that 3 shifter bits can be combined in a
* total of 2^3 == 8 ways.  Each such combination must be related to one (or
* none) of the enumerated shift states.
* Each shifter key combination can be represented by three binary bits:
*  Bit 0  is set if VK_SHIFT is down
*  Bit 1  is set if VK_CONTROL is down
*  Bit 2  is set if VK_MENU is down
*
* Example: If the STRANGE keyboard generates no characters in combination
* when just the ALT key is held down, nor when the SHIFT, CTRL and ALT keys
* are all held down, then the tables might look like this:
*
*                                VK_MENU,
*                        VK_CTRL,                    0
*    };
*    aModification[] = {
*        0,            //   0       0       0     = 000  <none>
*        1,            //   0       0       1     = 001  SHIFT
*        SHFT_INVALID, //   0       1       0     = 010  ALT
*        2,            //   0       1       1     = 011  SHIFT ALT
*        3,            //   1       0       0     = 100  CTRL
*        4,            //   1       0       1     = 101  SHIFT CTRL
*        5,            //   1       1       0     = 110  CTRL ALT
*        SHFT_INVALID  //   1       1       1     = 111  SHIFT CTRL ALT
*    };
*
*
\***************************************************************************/

/***************************************************************************\
* VK_TO_BIT - associate a Virtual Key with a Modifier bitmask.
*
* Vk        - the Virtual key (eg: VK_SHIFT, VK_RMENU, VK_CONTROL etc.)
*             Special Values:
*                0        null terminator
* ModBits   - a combination of KBDALT, KBDCTRL, KBDSHIFT and kbd-specific bits
*             Any kbd-specific shift bits must be the lowest-order bits other
*             than KBDSHIFT, KBDCTRL and KBDALT (0, 1 & 2)
*
* Those languages that use AltGr (VK_RMENU) to shift keys convert it to
* CTRL+ALT with the KBDSPECIAL bit in the ausVK[] entry for VK_RMENU
* and by having an entry in aVkToPfnOem[] to simulate the right Vk sequence.
*
\***************************************************************************/
typedef struct {
    BYTE Vk;
    BYTE ModBits;
} VK_TO_BIT, *KBD_LONG_POINTER PVK_TO_BIT;

/***************************************************************************\
* pModNumber  - a table to map shift bits to enumerated shift states
*
* Table attributes: Ordered table
*
* Maps all possible shifter key combinations to an enumerated shift state.
* The size of the table depends on the value of the highest order bit used
* in aCharModifiers[*].ModBits
*
* Special values for aModification[*]
*   SHFT_INVALID - no characters produced with this shift state.
LATER: (ianja) no SHFT_CTRL - control characters encoded in tables like others
*   SHFT_CTRL    - standard control character production (all keyboards must
*                  be able to produce CTRL-C == 0x0003 etc.)
*   Other        - enumerated shift state (not less than 0)
*
* This table is indexed by the Modifier Bits to obtain an Modification Number.
*
*                        CONTROL MENU SHIFT
*
*    aModification[] = {
*        0,            //   0     0     0     = 000  <none>
*        1,            //   0     0     1     = 001  SHIFT
*        SHFT_INVALID, //   0     1     0     = 010  ALT
*        2,            //   0     1     1     = 011  SHIFT ALT
*        3,            //   1     0     0     = 100  CTRL
*        4,            //   1     0     1     = 101  SHIFT CTRL
*        5,            //   1     1     0     = 110  CTRL ALT
*        SHFT_INVALID  //   1     1     1     = 111  SHIFT CTRL ALT
*    };
*
\***************************************************************************/
typedef struct {
    PVK_TO_BIT pVkToBit;     // Virtual Keys -> Mod bits
    WORD       wMaxModBits;  // max Modification bit combination value
    BYTE       ModNumber[];  // Mod bits -> Modification Number
} MODIFIERS, *KBD_LONG_POINTER PMODIFIERS;

WORD GetModifierBits(PMODIFIERS pModifiers, LPBYTE afKeyState);
WORD GetModificationNumber(PMODIFIERS pModifiers, WORD wModBits);

#define SHFT_INVALID 0x0F

/***************************************************************************\
* VSC_VK     - Associate a Virtual Scancode with a Virtual Key
*  Vsc - Virtual Scancode
*  Vk  - Virtual Key | flags
* Used by VKFromVSC() for scancodes prefixed 0xE0 or 0xE1
\***************************************************************************/
typedef struct _VSC_VK {
    BYTE Vsc;
    USHORT Vk;
} VSC_VK, *KBD_LONG_POINTER PVSC_VK;

/***************************************************************************\
* VK_VSC     - Associate a Virtual Key with a Virtual Scancode
*  Vk  - Virtual Key
*  Vsc - Virtual Scancode
* Used by MapVirtualKey for Virtual Keys not appearing in ausVK[]
\***************************************************************************/
typedef struct _VK_VSC {
    BYTE Vk;
    BYTE Vsc;
} VK_VSC, *KBD_LONG_POINTER PVK_VSC;

/***************************************************************************\
*
* VK_TO_WCHARS<n> - Associate a Virtual Key with <n> UNICODE characters
*
* VirtualKey  - The Virtual Key.
* wch[]       - An array of characters, one for each shift state that
*               applies to the specified Virtual Key.
*
* Special values for VirtualKey:
*    -1        - This entry contains dead chars for the previous entry
*    0         - Terminates a VK_TO_WCHARS[] table
*
* Special values for Attributes:
*    CAPLOK    - The CAPS-LOCK key affects this key like SHIFT
*    SGCAPS    - CapsLock uppercases the unshifted char (Swiss-German)
*
* Special values for wch[*]:
*    WCH_NONE  - No character is generated by pressing this key with the
*                current shift state.
*    WCH_DEAD  - The character is a dead-key: the next VK_TO_WCHARS[] entry
*                will contain the values of the dead characters (diaresis)
*                that can be produced by the Virtual Key.
*    WCH_LGTR  - The character is a ligature.  The characters generated by
*                this keystroke are found in the ligature table.
*
\***************************************************************************/
#define WCH_NONE 0xF000
#define WCH_DEAD 0xF001
#define WCH_LGTR 0xF002

#define CAPLOK      0x01
#define SGCAPS      0x02
#define CAPLOKALTGR 0x04
// KANALOK is for FE
#define KANALOK     0x08
#define GRPSELTAP   0x80

/*
 * Macro for VK to WCHAR with "n" shift states
 */
#define TYPEDEF_VK_TO_WCHARS(n) typedef struct _VK_TO_WCHARS##n {  \
                                    BYTE  VirtualKey;      \
                                    BYTE  Attributes;      \
                                    WCHAR wch[n];          \
                                } VK_TO_WCHARS##n, *KBD_LONG_POINTER PVK_TO_WCHARS##n;

/*
 * To facilitate coding the table scanning routine.
 */

/*
 * Table element types (for various numbers of shift states), used
 * to facilitate static initializations of tables.
 * VK_TO_WCHARS1 and PVK_TO_WCHARS1 may be used as the generic type
 */
TYPEDEF_VK_TO_WCHARS(1) // VK_TO_WCHARS1, *PVK_TO_WCHARS1;
TYPEDEF_VK_TO_WCHARS(2) // VK_TO_WCHARS2, *PVK_TO_WCHARS2;
TYPEDEF_VK_TO_WCHARS(3) // VK_TO_WCHARS3, *PVK_TO_WCHARS3;
TYPEDEF_VK_TO_WCHARS(4) // VK_TO_WCHARS4, *PVK_TO_WCHARS4;
TYPEDEF_VK_TO_WCHARS(5) // VK_TO_WCHARS5, *PVK_TO_WCHARS5;
TYPEDEF_VK_TO_WCHARS(6) // VK_TO_WCHARS6, *PVK_TO_WCHARS5;
TYPEDEF_VK_TO_WCHARS(7) // VK_TO_WCHARS7, *PVK_TO_WCHARS7;
// these three (8,9,10) are for FE
TYPEDEF_VK_TO_WCHARS(8) // VK_TO_WCHARS8, *PVK_TO_WCHARS8;
TYPEDEF_VK_TO_WCHARS(9) // VK_TO_WCHARS9, *PVK_TO_WCHARS9;
TYPEDEF_VK_TO_WCHARS(10) // VK_TO_WCHARS10, *PVK_TO_WCHARS10;

/***************************************************************************\
*
* VK_TO_WCHAR_TABLE - Describe a table of VK_TO_WCHARS1
*
* pVkToWchars     - points to the table.
* nModifications  - the number of shift-states supported by this table.
*                   (this is the number of elements in pVkToWchars[*].wch[])
*
* A keyboard may have several such tables: all keys with the same number of
*    shift-states are grouped together in one table.
*
* Special values for pVktoWchars:
*     NULL     - Terminates a VK_TO_WCHAR_TABLE[] list.
*
\***************************************************************************/

typedef struct _VK_TO_WCHAR_TABLE {
    PVK_TO_WCHARS1 pVkToWchars;
    BYTE           nModifications;
    BYTE           cbSize;
} VK_TO_WCHAR_TABLE, *KBD_LONG_POINTER PVK_TO_WCHAR_TABLE;

/***************************************************************************\
*
* Dead Key (diaresis) tables
*
* LATER IanJa: supplant by an NLS API that composes Diacritic+Base -> WCHAR
*
\***************************************************************************/
typedef struct {
    DWORD  dwBoth;  // diacritic & char
    WCHAR  wchComposed;
    USHORT uFlags;
} DEADKEY, *KBD_LONG_POINTER PDEADKEY;

#define DEADTRANS(ch, accent, comp, flags) { MAKELONG(ch, accent), comp, flags}

/*
 * Bit values for uFlags
 */
#define DKF_DEAD  0x0001

/***************************************************************************\
*
* Ligature table
*
\***************************************************************************/
/*
 * Macro for ligature with "n" characters
 */
#define TYPEDEF_LIGATURE(n) typedef struct _LIGATURE##n {     \
                                    BYTE  VirtualKey;         \
                                    WORD  ModificationNumber; \
                                    WCHAR wch[n];             \
                                } LIGATURE##n, *KBD_LONG_POINTER PLIGATURE##n;

/*
 * To facilitate coding the table scanning routine.
 */

/*
 * Table element types (for various numbers of ligatures), used
 * to facilitate static initializations of tables.
 *
 * LIGATURE1 and PLIGATURE1 are used as the generic type
 */
TYPEDEF_LIGATURE(1) // LIGATURE1, *PLIGATURE1;
TYPEDEF_LIGATURE(2) // LIGATURE2, *PLIGATURE2;
TYPEDEF_LIGATURE(3) // LIGATURE3, *PLIGATURE3;
TYPEDEF_LIGATURE(4) // LIGATURE4, *PLIGATURE4;
TYPEDEF_LIGATURE(5) // LIGATURE5, *PLIGATURE5;

/***************************************************************************\
* VSC_LPWSTR - associate a Virtual Scancode with a Text string
*
* Uses:
*   GetKeyNameText(), aKeyNames[]  Map virtual scancode to name of key
*
\***************************************************************************/
typedef struct {
    BYTE   vsc;
    WCHAR *KBD_LONG_POINTER pwsz;
} VSC_LPWSTR, *KBD_LONG_POINTER PVSC_LPWSTR;

typedef WCHAR *KBD_LONG_POINTER DEADKEY_LPWSTR;

/*
 * Along with ligature support we're adding a proper version number.
 * The previous version number (actually just unused bits...) was
 * always zero.  The version number will live in the high word of
 * fLocaleFlags.
 */
#define KBD_VERSION         1
#define GET_KBD_VERSION(p)  (HIWORD((p)->fLocaleFlags))

/*
 * Attributes such as AltGr, LRM_RLM, ShiftLock are stored in the the low word
 * of fLocaleFlags (layout specific) or in gdwKeyboardAttributes (all layouts)
 */
#define KLLF_ALTGR       0x0001
#define KLLF_SHIFTLOCK   0x0002
#define KLLF_LRM_RLM     0x0004

/*
 * Some attributes are per-layout (specific to an individual layout), some
 * attributes are per-user (apply globally to all layouts).  Some are both.
 */
#define KLLF_LAYOUT_ATTRS (KLLF_SHIFTLOCK | KLLF_ALTGR | KLLF_LRM_RLM)
#define KLLF_GLOBAL_ATTRS (KLLF_SHIFTLOCK)

/*
 * Flags passed in to the KeyboardLayout API (KLF_*) as can be converted to
 * internal (KLLF_*) attributes:
 */
#define KLL_ATTR_FROM_KLF(x)         ((x) >> 15)
#define KLL_LAYOUT_ATTR_FROM_KLF(x)  (KLL_ATTR_FROM_KLF(x) & KLLF_LAYOUT_ATTRS)
#define KLL_GLOBAL_ATTR_FROM_KLF(x)  (KLL_ATTR_FROM_KLF(x) & KLLF_GLOBAL_ATTRS)

/*
 * If KLF_SHIFTLOCK & KLF_LRM_RLM are defined, we can check the KLLF_* values
 */
#ifdef KLF_SHIFTLOCK
#if KLLF_SHIFTLOCK != KLL_ATTR_FROM_KLF(KLF_SHIFTLOCK)
    #error KLLF_SHIFTLOCK != KLL_ATTR_FROM_KLF(KLF_SHIFTLOCK)
#endif
#endif // KLF_SHIFTLOCK
#ifdef KLF_LRM_RLM
#if KLLF_LRM_RLM != KLL_ATTR_FROM_KLF(KLF_LRM_RLM)
    #error KLLF_LRM_RLM != KLL_ATTR_FROM_KLF(KLF_LRM_RLM)
#endif
#endif // KLF_LRM_RLM

/***************************************************************************\
* KBDTABLES
*
* This structure describes all the tables that implement the keyboard layer.
*
* When switching to a new layer, we get a new KBDTABLES structure: all key
* processing tables are accessed indirectly through this structure.
*
\***************************************************************************/

typedef struct tagKbdLayer {
    /*
     * Modifier keys
     */
    PMODIFIERS pCharModifiers;

    /*
     * Characters
     */
    PVK_TO_WCHAR_TABLE pVkToWcharTable;  // ptr to tbl of ptrs to tbl

    /*
     * Diacritics
     */
    PDEADKEY pDeadKey;

    /*
     * Names of Keys
     */
    PVSC_LPWSTR pKeyNames;
    PVSC_LPWSTR pKeyNamesExt;
    WCHAR *KBD_LONG_POINTER *KBD_LONG_POINTER pKeyNamesDead;

    /*
     * Scan codes to Virtual Keys
     */
    USHORT  *KBD_LONG_POINTER pusVSCtoVK;
    BYTE    bMaxVSCtoVK;
    PVSC_VK pVSCtoVK_E0;  // Scancode has E0 prefix
    PVSC_VK pVSCtoVK_E1;  // Scancode has E1 prefix

    /*
     * Locale-specific special processing
     */
    DWORD fLocaleFlags;

    /*
     * Ligatures
     */
    BYTE       nLgMax;
    BYTE       cbLgEntry;
    PLIGATURE1 pLigature;

    /*
     * Type and subtype. These are optional.
     */
    DWORD      dwType;     // Keyboard Type
    DWORD      dwSubType;  // Keyboard SubType: may contain OemId
} KBDTABLES, *KBD_LONG_POINTER PKBDTABLES;

/*
 * FarEast-specific special...
 */
typedef struct _VK_FUNCTION_PARAM {
    BYTE  NLSFEProcIndex;
    ULONG NLSFEProcParam;
} VK_FPARAM, *KBD_LONG_POINTER PVK_FPARAM;

typedef struct _VK_TO_FUNCTION_TABLE {
    BYTE Vk;
    BYTE NLSFEProcType;
    BYTE NLSFEProcCurrent;
    // Index[0] : Base
    // Index[1] : Shift
    // Index[2] : Control
    // Index[3] : Shift+Control
    // Index[4] : Alt
    // Index[5] : Shift+Alt
    // Index[6] : Control+Alt
    // Index[7] : Shift+Control+Alt
    BYTE NLSFEProcSwitch;   // 8 bits
    VK_FPARAM NLSFEProc[8];
    VK_FPARAM NLSFEProcAlt[8];
} VK_F, *KBD_LONG_POINTER PVK_F;

typedef struct tagKbdNlsLayer {
    USHORT OEMIdentifier;
    USHORT LayoutInformation;
    UINT  NumOfVkToF;
    PVK_F pVkToF;
    //
    // The pusMouseVKey array provides a translation from the virtual key
    // value to an index.  The index is used to select the appropriate
    // routine to process the virtual key, as well as to select extra
    // information that is used by this routine during its processing.
    // If this value is NULL, following default will be used.
    //
    // ausMouseVKey[] = {
    //     VK_CLEAR,           // Numpad 5: Click active button
    //     VK_PRIOR,           // Numpad 9: Up & Right
    //     VK_NEXT,            // Numpad 3: Down & Right
    //     VK_END,             // Numpad 1: Down & Left
    //     VK_HOME,            // Numpad 7: Up & Left
    //     VK_LEFT,            // Numpad 4: Left
    //     VK_UP,              // Numpad 8: Up
    //     VK_RIGHT,           // Numpad 6: Right
    //     VK_DOWN,            // Numpad 2: Down
    //     VK_INSERT,          // Numpad 0: Active button down
    //     VK_DELETE,          // Numpad .: Active button up
    //     VK_MULTIPLY,        // Numpad *: Select both buttons
    //     VK_ADD,             // Numpad +: Double click active button
    //     VK_SUBTRACT,        // Numpad -: Select right button
    //     VK_DEVIDE|KBDEXT,   // Numpad /: Select left button
    //     VK_NUMLOCK|KBDEXT}; // Num Lock
    //
    INT     NumOfMouseVKey;
    USHORT *KBD_LONG_POINTER pusMouseVKey;
} KBDNLSTABLES, *KBD_LONG_POINTER PKBDNLSTABLES;


/*
 * The maximum number of layout tables in a DLL
 */
#define KBDTABLE_MULTI_MAX  (8)

/*
 * Multiple keyboard layout table in a DLL
 */
typedef struct tagKBDTABLE_DESC {
    WCHAR wszDllName[32];
    DWORD dwType;     // Keyboard type ID
    DWORD dwSubType;  // Combined SubType ID (OEMID : SubType)
} KBDTABLE_DESC, *KBD_LONG_POINTER PKBDTABLE_DESC;

typedef struct tagKBDTABLE_MULTI {
    UINT nTables;
    KBDTABLE_DESC aKbdTables[KBDTABLE_MULTI_MAX];
} KBDTABLE_MULTI, *KBD_LONG_POINTER PKBDTABLE_MULTI;


/*
 * Format of the registry value for the Dynamic Layout Switching
 */
typedef struct tagKBD_TYPE_INFO {
    DWORD dwVersion;
    DWORD dwType;
    DWORD dwSubType;
} KBD_TYPE_INFO, *PKBD_TYPE_INFO;

//
// Keyboard type
//
#define KEYBOARD_TYPE_GENERIC_101   (4)
//
// Keyboard Type = 7 : Japanese Keyboard
// Keyboard Type = 8 : Korean Keyboard
//
#define KEYBOARD_TYPE_JAPAN (7)
#define KEYBOARD_TYPE_KOREA (8)

// Unknown keyboard type
#define KEYBOARD_TYPE_UNKNOWN   (0x51)


//
// OEM Ids - KBDNLSTABLES.OEMIdentifier
//
// PSS ID Number: Q130054
// Article last modified on 05-16-1995
//
// 3.10 1.20 | 3.50 1.20
// WINDOWS   | WINDOWS NT
//
// ---------------------------------------------------------------------
// The information in this article applies to:
// - Microsoft Windows Software Development Kit (SDK) for Windows
//   version 3.1
// - Microsoft Win32 Software Development Kit (SDK) version 3.5
// - Microsoft Win32s version 1.2
// ---------------------------------------------------------------------
// SUMMARY
// =======
// Because of the variety of computer manufacturers (NEC, Fujitsu, IBMJ, and
// so on) in Japan, sometimes Windows-based applications need to know which
// OEM (original equipment manufacturer) manufactured the computer that is
// running the application. This article explains how.
//
// MORE INFORMATION
// ================
// There is no documented way to detect the manufacturer of the computer that
// is currently running an application. However, a Windows-based application
// can detect the type of OEM Windows by using the return value of the
// GetKeyboardType() function.
//
// If an application uses the GetKeyboardType API, it can get OEM ID by
// specifying "1" (keyboard subtype) as argument of the function. Each OEM ID
// is listed here:
//
// OEM Windows       OEM ID
// ------------------------------
// Microsoft         00H (DOS/V)
// all AX            01H
// EPSON             04H
// Fujitsu           05H
// IBMJ              07H
// Matsushita        0AH
// NEC               0DH
// Toshiba           12H
//
// Application programs can use these OEM IDs to distinguish the type of OEM
// Windows. Note, however, that this method is not documented, so Microsoft
// may not support it in the future version of Windows.
//
// As a rule, application developers should write hardware-independent code,
// especially when making Windows-based applications. If they need to make a
// hardware-dependent application, they must prepare the separated program
// file for each different hardware architecture.
//
// Additional reference words: 3.10 1.20 3.50 1.20 kbinf
// KBCategory: kbhw
// KBSubcategory: wintldev
// =============================================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
//
#define NLSKBD_OEM_MICROSOFT          0x00
#define NLSKBD_OEM_AX                 0x01
#define NLSKBD_OEM_EPSON              0x04
#define NLSKBD_OEM_FUJITSU            0x05
#define NLSKBD_OEM_IBM                0x07
#define NLSKBD_OEM_MATSUSHITA         0x0A
#define NLSKBD_OEM_NEC                0x0D
#define NLSKBD_OEM_TOSHIBA            0x12
#define NLSKBD_OEM_DEC                0x18 // only NT
//
// Microsoft (default) - keyboards hardware/layout
//
#define MICROSOFT_KBD_101_TYPE           0
#define MICROSOFT_KBD_AX_TYPE            1
#define MICROSOFT_KBD_106_TYPE           2
#define MICROSOFT_KBD_002_TYPE           3
#define MICROSOFT_KBD_001_TYPE           4
#define MICROSOFT_KBD_FUNC              12
//
// AX consortium - keyboards hardware/layout
//
#define AX_KBD_DESKTOP_TYPE              1
//
// Fujitsu - keyboards hardware/layout
//
#define FMR_KBD_JIS_TYPE                 0
#define FMR_KBD_OASYS_TYPE               1
#define FMV_KBD_OASYS_TYPE               2
//
// NEC - keyboards hardware/layout
//
#define NEC_KBD_NORMAL_TYPE              1
#define NEC_KBD_N_MODE_TYPE              2
#define NEC_KBD_H_MODE_TYPE              3
#define NEC_KBD_LAPTOP_TYPE              4
#define NEC_KBD_106_TYPE                 5
//
// Toshiba - keyboards hardware/layout
//
#define TOSHIBA_KBD_DESKTOP_TYPE        13
#define TOSHIBA_KBD_LAPTOP_TYPE         15
//
// DEC - keyboards hardware/layout
//
#define DEC_KBD_ANSI_LAYOUT_TYPE         1 // only NT
#define DEC_KBD_JIS_LAYOUT_TYPE          2 // only NT


//
// Korean keyboard subtype
//
#define MICROSOFT_KBD_101A_TYPE         MICROSOFT_KBD_101_TYPE
#define MICROSOFT_KBD_101B_TYPE         4
#define MICROSOFT_KBD_101C_TYPE         5
#define MICROSOFT_KBD_103_TYPE          6

//
// Keyboard layout information - KBDNLSTABLE.LayoutInformation
//

//
// If this flag is on, System sends notification to keyboard
// drivers (leyout/kernel mode). when IME (Input-Mehod-Editor)
// status become changed.
//
#define NLSKBD_INFO_SEND_IME_NOTIFICATION  0x0001

//
// If this flag is on, System will use VK_HOME/VK_KANA instead of
// VK_NUMLOCK/VK_SCROLL for Accessibility toggle keys.
// + Typically, NEC PC-9800 Series will use this bit, because
//   they does not have 'NumLock' and 'ScrollLock' keys.
//
#define NLSKBD_INFO_ACCESSIBILITY_KEYMAP   0x0002

//
// If this flag is on, System will return 101 or 106 Japanese
// keyboard type/subtype id, when GetKeyboardType() is called.
//
#define NLSKBD_INFO_EMURATE_101_KEYBOARD   0x0010
#define NLSKBD_INFO_EMURATE_106_KEYBOARD   0x0020

//
// Keyboard layout function types
//
// - VK_F.NLSFEProcType
//
#define KBDNLS_TYPE_NULL      0
#define KBDNLS_TYPE_NORMAL    1
#define KBDNLS_TYPE_TOGGLE    2

//
// - VK_F.NLSFEProcCurrent
//
#define KBDNLS_INDEX_NORMAL   1
#define KBDNLS_INDEX_ALT      2

//
// - VK_F.NLSFEProc[]
//
#define KBDNLS_NULL             0 // Invalid function
#define KBDNLS_NOEVENT          1 // Drop keyevent
#define KBDNLS_SEND_BASE_VK     2 // Send Base VK_xxx
#define KBDNLS_SEND_PARAM_VK    3 // Send Parameter VK_xxx
#define KBDNLS_KANALOCK         4 // VK_KANA (with hardware lock)
#define KBDNLS_ALPHANUM         5 // VK_DBE_ALPHANUMERIC
#define KBDNLS_HIRAGANA         6 // VK_DBE_HIRAGANA
#define KBDNLS_KATAKANA         7 // VK_DBE_KATAKANA
#define KBDNLS_SBCSDBCS         8 // VK_DBE_SBCSCHAR/VK_DBE_DBCSCHAR
#define KBDNLS_ROMAN            9 // VK_DBE_ROMAN/VK_DBE_NOROMAN
#define KBDNLS_CODEINPUT       10 // VK_DBE_CODEINPUT/VK_DBE_NOCODEINPUT
#define KBDNLS_HELP_OR_END     11 // VK_HELP or VK_END [NEC PC-9800 Only]
#define KBDNLS_HOME_OR_CLEAR   12 // VK_HOME or VK_CLEAR [NEC PC-9800 Only]
#define KBDNLS_NUMPAD          13 // VK_NUMPAD? for Numpad key [NEC PC-9800 Only]
#define KBDNLS_KANAEVENT       14 // VK_KANA [Fujitsu FMV oyayubi Only]
#define KBDNLS_CONV_OR_NONCONV 15 // VK_CONVERT and VK_NONCONVERT [Fujitsu FMV oyayubi Only]


#define JAPANESE_KEYBOARD(Id)  ((Id).Type == KEYBOARD_TYPE_JAPAN)
#define KOREAN_KEYBOARD(Id)    ((Id).Type == KEYBOARD_TYPE_KOREA)

// Fujitsu Oyayubi-shift keyboard
#define FUJITSU_KBD_CONSOLE(Id)  (JAPANESE_KEYBOARD(Id) && \
                                  (Id).Subtype == ((NLSKBD_OEM_FUJITSU<<4)|FMV_KBD_OASYS_TYPE))
        // This number 0x00020002 is registered in registry key as
        // HKLM\System\CurrentControlSet\Control\Terminal Server\KeyboardType Mapping\JPN
#define FUJITSU_KBD_REMOTE(Id)   (JAPANESE_KEYBOARD(Id) && \
                                  (Id).SubType == 0x00020002)

#define KBD_LAYOUT_LANG(hkl)    (PRIMARYLANGID(HandleToUlong(hkl)))

#define JAPANESE_KBD_LAYOUT(hkl)    (KBD_LAYOUT_LANG(hkl) == LANG_JAPANESE)
#define KOREAN_KBD_LAYOUT(hkl)      (KBD_LAYOUT_LANG(hkl) == LANG_KOREAN)

// end of FE specific

/***************************************************************************\
* Macros for ausVK[] values (used below)
*
* These macros prefix each argument with VK_ to produce the name of a Virtual
* Key defined in "winuser.h" (eg: ESCAPE becomes VK_ESCAPE).
\***************************************************************************/
#ifndef KBD_TYPE
#define KBD_TYPE 4
#endif

/*
 * _NE() selects the Virtual Key according to keyboard type
 */
#if   (KBD_TYPE == 1)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v1)
#elif (KBD_TYPE == 2)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v2)
#elif (KBD_TYPE == 3)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v3)
#elif (KBD_TYPE == 4)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v4)
#elif (KBD_TYPE == 5)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v5)
#elif (KBD_TYPE == 6)
#define _NE(v1,v2,v3,v4,v5,v6) (VK_##v6)
#elif (KBD_TYPE == 7)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v7)
#elif (KBD_TYPE == 8)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v8)
#elif (KBD_TYPE == 10)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v10)
#elif (KBD_TYPE == 11)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v11)
#elif (KBD_TYPE == 12)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v12)
#elif (KBD_TYPE == 13)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v13)
#elif (KBD_TYPE == 16)
#define _NE(v7,v8,v16,v10,v11,v12,v13) (VK_##v16)
#elif (KBD_TYPE == 20)
#define _NE(v20,v21,v22)           (VK_##v20)
#elif (KBD_TYPE == 21)
#define _NE(v20,v21,v22)           (VK_##v21)
#elif (KBD_TYPE == 22)
#define _NE(v20,v21,v22)           (VK_##v22)
#elif (KBD_TYPE == 30)
#define _NE(v30,v33,v34)           (VK_##v30)
#elif (KBD_TYPE == 33)
#define _NE(v30,v33,v34)           (VK_##v33)
#elif (KBD_TYPE == 34)
#define _NE(v30,v33,v34)           (VK_##v34)
#elif (KBD_TYPE == 40)
#define _NE(v40,v41)               (VK_##v40)
#elif (KBD_TYPE == 41)
#define _NE(v40,v41)               (VK_##v41)
#endif

/*
 * _EQ() selects the same Virtual Key for all keyboard types
 */
#if   (KBD_TYPE <= 6)
#define _EQ(         v4      ) (VK_##v4)
#elif (KBD_TYPE >= 7) && (KBD_TYPE <= 16)
#define _EQ(   v8            ) (VK_##v8)
#elif (KBD_TYPE > 20) && (KBD_TYPE <= 22)
#define _EQ(v20              ) (VK_##v20)
#elif (KBD_TYPE >= 30) && (KBD_TYPE <= 34)
#define _EQ(         v30     ) (VK_##v30)
#elif (KBD_TYPE == 37)
#define _EQ(         v37     ) (VK_##v37)
#elif (KBD_TYPE >= 40) && (KBD_TYPE <= 41)
#define _EQ( v40             ) (VK_##v40)
#endif

/*
 * A bit of trickery for virtual key names 'A' to 'Z' and '0' to '9' so
 * that they are not converted to a VK_* name.
 * With this macro, VK_'A' equates to 'A' etc.
 */
#define VK_
#define VK__none_   0xFF
#define VK_ABNT_C1  0xC1
#define VK_ABNT_C2  0xC2

#if (KBD_TYPE <= 6)
/***************************************************************************\
* T** - Values for ausVK[] (Virtual Scan Code to Virtual Key conversion)
*
* These values are for Scancode Set 3 and the USA.
* Other languages substitute their own values where required (files kbd**.h)
*
* Six sets of keyboards are supported, according to KBD_TYPE:
*
* KBD_TYPE   Keyboard (examples)
* ========   =======================================================
*    1       AT&T '301' & '302'; Olivetti 83-key; PC-XT 84-key; etc.
*    2       Olivetti M24 102-key
*    3       HP Vectra (DIN); Olivetti 86-key; etc.
*    4 *     Enhanced 101/102-key; Olivetti A; etc.
*    5       Nokia (Ericsson) type 5 (1050, etc.)
*    6       Nokia (Ericsson) type 6 (9140)
*
* * If KBD_TYPE is not defined, the default is type 4.
*
* KB3270 comments refers to KB 3270 keyboards in native emulation mode (DIP
* switches all OFF), and the Scancode Map used to convert its scancodes to
* standard scancode set 1.
*    KB3270 <= 57      - this entry is reached by mapping from scancode 0x57
*                        to an arbitrary scancode: the VK is what counts
*    KB3270 => HOME    - this scancode is mapped to the scancode for VK_HOME
*    KB3270            - no mapping involved, a scancode for KB3270 only
*
* _EQ() : all keyboard types have the same virtual key for this scancode
* _NE() : different virtual keys for this scancode, depending on kbd type
*
*     +------+ +--------+--------+--------+--------+--------+--------+
*     | Scan | |  kbd   |  kbd   |  kbd   |  kbd   |  kbd   |  kbd   |
*     | code | | type 1 | type 2 | type 3 | type 4 | type 5 | type 6 |
\****+-------+-+--------+--------+--------+--------+--------+--------+******/
#define T00 _EQ(                           _none_                    )
#define T01 _EQ(                           ESCAPE                    )
#define T02 _EQ(                           '1'                       )
#define T03 _EQ(                           '2'                       )
#define T04 _EQ(                           '3'                       )
#define T05 _EQ(                           '4'                       )
#define T06 _EQ(                           '5'                       )
#define T07 _EQ(                           '6'                       )
#define T08 _EQ(                           '7'                       )
#define T09 _EQ(                           '8'                       )
#define T0A _EQ(                           '9'                       )
#define T0B _EQ(                           '0'                       )
#define T0C _EQ(                           OEM_MINUS                 )
#define T0D _NE(OEM_PLUS,OEM_4,   OEM_PLUS,OEM_PLUS,OEM_PLUS,OEM_PLUS)
#define T0E _EQ(                           BACK                      )
#define T0F _EQ(                           TAB                       )
#define T10 _EQ(                           'Q'                       )
#define T11 _EQ(                           'W'                       )
#define T12 _EQ(                           'E'                       )
#define T13 _EQ(                           'R'                       )
#define T14 _EQ(                           'T'                       )
#define T15 _EQ(                           'Y'                       )
#define T16 _EQ(                           'U'                       )
#define T17 _EQ(                           'I'                       )
#define T18 _EQ(                           'O'                       )
#define T19 _EQ(                           'P'                       )
#define T1A _NE(OEM_4,   OEM_6,   OEM_4,   OEM_4,   OEM_4,   OEM_4   )
#define T1B _NE(OEM_6,   OEM_1,   OEM_6,   OEM_6,   OEM_6,   OEM_6   )
#define T1C _EQ(                           RETURN                    )
#define T1D _EQ(                           LCONTROL                  )
#define T1E _EQ(                           'A'                       )
#define T1F _EQ(                           'S'                       )
#define T20 _EQ(                           'D'                       )
#define T21 _EQ(                           'F'                       )
#define T22 _EQ(                           'G'                       )
#define T23 _EQ(                           'H'                       )
#define T24 _EQ(                           'J'                       )
#define T25 _EQ(                           'K'                       )
#define T26 _EQ(                           'L'                       )
#define T27 _NE(OEM_1,   OEM_PLUS,OEM_1,   OEM_1,   OEM_1,   OEM_1   )
#define T28 _NE(OEM_7,   OEM_3,   OEM_7,   OEM_7,   OEM_3,   OEM_3   )
#define T29 _NE(OEM_3,   OEM_7,   OEM_3,   OEM_3,   OEM_7,   OEM_7   )
#define T2A _EQ(                           LSHIFT                    )
#define T2B _EQ(                           OEM_5                     )
#define T2C _EQ(                           'Z'                       )
#define T2D _EQ(                           'X'                       )
#define T2E _EQ(                           'C'                       )
#define T2F _EQ(                           'V'                       )
#define T30 _EQ(                           'B'                       )
#define T31 _EQ(                           'N'                       )
#define T32 _EQ(                           'M'                       )
#define T33 _EQ(                           OEM_COMMA                 )
#define T34 _EQ(                           OEM_PERIOD                )
#define T35 _EQ(                           OEM_2                     )
#define T36 _EQ(                           RSHIFT                    )
#define T37 _EQ(                           MULTIPLY                  )
#define T38 _EQ(                           LMENU                     )
#define T39 _EQ(                           ' '                       )
#define T3A _EQ(                           CAPITAL                   )
#define T3B _EQ(                           F1                        )
#define T3C _EQ(                           F2                        )
#define T3D _EQ(                           F3                        )
#define T3E _EQ(                           F4                        )
#define T3F _EQ(                           F5                        )
#define T40 _EQ(                           F6                        )
#define T41 _EQ(                           F7                        )
#define T42 _EQ(                           F8                        )
#define T43 _EQ(                           F9                        )
#define T44 _EQ(                           F10                       )
#define T45 _EQ(                           NUMLOCK                   )
#define T46 _EQ(                           SCROLL                    )
#define T47 _EQ(                           HOME                      )
#define T48 _EQ(                           UP                        )
#define T49 _EQ(                           PRIOR                     )
#define T4A _EQ(                           SUBTRACT                  )
#define T4B _EQ(                           LEFT                      )
#define T4C _EQ(                           CLEAR                     )
#define T4D _EQ(                           RIGHT                     )
#define T4E _EQ(                           ADD                       )
#define T4F _EQ(                           END                       )
#define T50 _EQ(                           DOWN                      )
#define T51 _EQ(                           NEXT                      )
#define T52 _EQ(                           INSERT                    )
#define T53 _EQ(                           DELETE                    )
#define T54 _EQ(                           SNAPSHOT                  )
#define T55 _EQ(                           _none_                    ) // KB3270 => DOWN
#define T56 _NE(OEM_102, HELP,    OEM_102, OEM_102, _none_,  OEM_PA2 ) // KB3270 => LEFT
#define T57 _NE(F11,     RETURN,  F11,     F11,     _none_,  HELP    ) // KB3270 => ZOOM
#define T58 _NE(F12,     LEFT,    F12,     F12,     _none_,  OEM_102 ) // KB3270 => HELP
#define T59 _EQ(                           CLEAR                     )
#define T5A _EQ(                           OEM_WSCTRL                )// WSCtrl
#define T5B _EQ(                           OEM_FINISH                )// Finish
#define T5C _EQ(                           OEM_JUMP                  )// Jump
#define T5D _EQ(                           EREOF                     )
#define T5E _EQ(                           OEM_BACKTAB               ) // KB3270 <= 7E
#define T5F _EQ(                           OEM_AUTO                  ) // KB3270
#define T60 _EQ(                           _none_                    )
#define T61 _EQ(                           _none_                    )
#define T62 _EQ(                           ZOOM                      ) // KB3270 <= 57
#define T63 _EQ(                           HELP                      ) // KB3270 <= 58
#define T64 _EQ(                           F13                       )
#define T65 _EQ(                           F14                       )
#define T66 _EQ(                           F15                       )
#define T67 _EQ(                           F16                       )
#define T68 _EQ(                           F17                       )
#define T69 _EQ(                           F18                       )
#define T6A _EQ(                           F19                       )
#define T6B _EQ(                           F20                       )
#define T6C _EQ(                           F21                       )
#define T6D _EQ(                           F22                       )
#define T6E _EQ(                           F23                       )
#define T6F _EQ(                           OEM_PA3                   ) // KB3270
#define T70 _EQ(                           _none_                    )
#define T71 _EQ(                           OEM_RESET                 ) // KB3270
#define T72 _EQ(                           _none_                    )
#define T73 _EQ(                           ABNT_C1                   )
#define T74 _EQ(                           _none_                    )
#define T75 _EQ(                           _none_                    ) // KB3270 => RETURN
#define T76 _EQ(                           F24                       )
#define T77 _EQ(                           _none_                    ) // KB3270 => HOME
#define T78 _EQ(                           _none_                    ) // KB3270 => UP
#define T79 _EQ(                           _none_                    ) // KB3270 => DELETE
#define T7A _EQ(                           _none_                    ) // KB3270 => INSERT
#define T7B _EQ(                           OEM_PA1                   ) // KB3270
#define T7C _EQ(                           TAB                       ) // KB3270 => TAB
#define T7D _EQ(                           _none_                    ) // KB3270 => RIGHT
#define T7E _EQ(                           ABNT_C2                   ) // KB3270 => BACKTAB
#define T7F _EQ(                           OEM_PA2                   ) // KB3270

#define X10 _EQ(                           MEDIA_PREV_TRACK          ) // SpeedRacer
#define X19 _EQ(                           MEDIA_NEXT_TRACK          ) // SpeedRacer
#define X1C _EQ(                           RETURN                    )
#define X1D _EQ(                           RCONTROL                  )
#define X20 _EQ(                           VOLUME_MUTE               ) // SpeedRacer
#define X21 _EQ(                           LAUNCH_APP2               ) // SpeedRacer (Calculator?)
#define X22 _EQ(                           MEDIA_PLAY_PAUSE          ) // SpeedRacer
#define X24 _EQ(                           MEDIA_STOP                ) // SpeedRacer
#define X2E _EQ(                           VOLUME_DOWN               ) // SpeedRacer
#define X30 _EQ(                           VOLUME_UP                 ) // SpeedRacer
#define X32 _EQ(                           BROWSER_HOME              ) // SpeedRacer
#define X35 _EQ(                           DIVIDE                    )
#define X37 _EQ(                           SNAPSHOT                  )
#define X38 _EQ(                           RMENU                     )
#define X46 _EQ(                           CANCEL                    )
#define X47 _EQ(                           HOME                      )
#define X48 _EQ(                           UP                        )
#define X49 _EQ(                           PRIOR                     )
#define X4B _EQ(                           LEFT                      )
#define X4D _EQ(                           RIGHT                     )
#define X4F _EQ(                           END                       )
#define X50 _EQ(                           DOWN                      )
#define X51 _NE(NEXT,    F1,      NEXT,    NEXT,    _none_, OEM_PA2  )
#define X52 _EQ(                           INSERT                    )
#define X53 _EQ(                           DELETE                    )
#define X5B _EQ(                           LWIN                      )
#define X5C _EQ(                           RWIN                      )
#define X5D _EQ(                           APPS                      )
#define X5E _EQ(                           POWER                     )
#define X5F _EQ(                           SLEEP                     ) // SpeedRacer
#define X65 _EQ(                           BROWSER_SEARCH            ) // SpeedRacer
#define X66 _EQ(                           BROWSER_FAVORITES         ) // SpeedRacer
#define X67 _EQ(                           BROWSER_REFRESH           ) // SpeedRacer
#define X68 _EQ(                           BROWSER_STOP              ) // SpeedRacer
#define X69 _EQ(                           BROWSER_FORWARD           ) // SpeedRacer
#define X6A _EQ(                           BROWSER_BACK              ) // SpeedRacer
#define X6B _EQ(                           LAUNCH_APP1               ) // SpeedRacer (my computer?)
#define X6C _EQ(                           LAUNCH_MAIL               ) // SpeedRacer
#define X6D _EQ(                           LAUNCH_MEDIA_SELECT       ) // SpeedRacer


        /*
         * The break key is sent to us as E1,LCtrl,NumLock
         * We must convert the E1+LCtrl to BREAK, then ignore the Numlock
         */
#define Y1D _EQ(                           PAUSE                     )

#elif (KBD_TYPE >= 7) && (KBD_TYPE <= 16)
/***********************************************************************************\
* T** - Values for ausVK[] (Virtual Scan Code to Virtual Key conversion)
*
* Three sets of keyboards are supported, according to KBD_TYPE:
*
* KBD_TYPE   Keyboard (examples)
* ========   =====================================
*    7       Japanese IBM type 002 keyboard.
*    8 *     Japanese OADG (106) keyboard.
*   10       Korean 101 (type A) keyboard.
*   11       Korean 101 (type B) keyboard.
*   12       Korean 101 (type C) keyboard.
*   13       Korean 103 keyboard.
*   16       Japanese AX keyboard.
*
*     +------+ +----------+----------+----------+----------+----------+----------+----------+
*     | Scan | |   kbd    |   kbd    |   kbd    |   kbd    |   kbd    |   kbd    |   kbd    |
*     | code | |  type 7  |  type 8  |  type 16 |  type 10 |  type 11 |  type 12 |  type 13 |
\****+-------+-+----------+----------+----------+----------+----------+----------+----------+*/
#define T00 _EQ(           _none_                                                           )
#define T01 _EQ(           ESCAPE                                                           )
#define T02 _EQ(           '1'                                                              )
#define T03 _EQ(           '2'                                                              )
#define T04 _EQ(           '3'                                                              )
#define T05 _EQ(           '4'                                                              )
#define T06 _EQ(           '5'                                                              )
#define T07 _EQ(           '6'                                                              )
#define T08 _EQ(           '7'                                                              )
#define T09 _EQ(           '8'                                                              )
#define T0A _EQ(           '9'                                                              )
#define T0B _EQ(           '0'                                                              )
#define T0C _EQ(           OEM_MINUS                                                        )
#define T0D _NE(OEM_7,     OEM_7,     OEM_PLUS,  OEM_PLUS,  OEM_PLUS,  OEM_PLUS,  OEM_PLUS  )
#define T0E _EQ(           BACK                                                             )
#define T0F _EQ(           TAB                                                              )
#define T10 _EQ(           'Q'                                                              )
#define T11 _EQ(           'W'                                                              )
#define T12 _EQ(           'E'                                                              )
#define T13 _EQ(           'R'                                                              )
#define T14 _EQ(           'T'                                                              )
#define T15 _EQ(           'Y'                                                              )
#define T16 _EQ(           'U'                                                              )
#define T17 _EQ(           'I'                                                              )
#define T18 _EQ(           'O'                                                              )
#define T19 _EQ(           'P'                                                              )
#define T1A _NE(OEM_4,     OEM_3,     OEM_4,     OEM_4,     OEM_4,     OEM_4,     OEM_4     )
#define T1B _NE(OEM_6,     OEM_4,     OEM_6,     OEM_6,     OEM_6,     OEM_6,     OEM_6     )
#define T1C _EQ(           RETURN                                                           )
#define T1D _EQ(           LCONTROL                                                         )
#define T1E _EQ(           'A'                                                              )
#define T1F _EQ(           'S'                                                              )
#define T20 _EQ(           'D'                                                              )
#define T21 _EQ(           'F'                                                              )
#define T22 _EQ(           'G'                                                              )
#define T23 _EQ(           'H'                                                              )
#define T24 _EQ(           'J'                                                              )
#define T25 _EQ(           'K'                                                              )
#define T26 _EQ(           'L'                                                              )
#define T27 _NE(OEM_PLUS,  OEM_PLUS,  OEM_1,     OEM_1,     OEM_1,     OEM_1,     OEM_1     )
#define T28 _NE(OEM_1,     OEM_1,     OEM_7,     OEM_7,     OEM_7,     OEM_7,     OEM_7     )
#define T29 _NE(OEM_3,     DBE_SBCSCHAR,OEM_3,   OEM_3,     OEM_3,     OEM_3,     OEM_3     )
#define T2A _EQ(           LSHIFT                                                           )
#define T2B _NE(OEM_5,     OEM_6,     OEM_5,     OEM_5,     OEM_5,     OEM_5,     OEM_5     )
#define T2C _EQ(           'Z'                                                              )
#define T2D _EQ(           'X'                                                              )
#define T2E _EQ(           'C'                                                              )
#define T2F _EQ(           'V'                                                              )
#define T30 _EQ(           'B'                                                              )
#define T31 _EQ(           'N'                        